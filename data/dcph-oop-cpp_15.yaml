- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Testing Classes and Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类和组件
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts through exploring means to test the classes and components
    that comprise our OO programs. We will explore various strategies to help ensure
    that the code we write will be well-tested and robust.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们的追求，通过探索测试构成我们面向对象程序类和组件的方法，来增加你的C++编程知识库，而不仅仅是面向对象的概念。我们将探讨各种策略，以确保我们编写的代码经过充分测试且稳健。
- en: This chapter shows how to test your OO programs through testing individual classes,
    as well as testing the various components that work together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何通过测试单个类以及测试协同工作的各种组件来测试你的面向对象程序。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the canonical class form and creating robust classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解典型类形式和创建稳健类
- en: Creating drivers to test classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建驱动程序以测试类
- en: Testing classes related by inheritance, association, or aggregation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试通过继承、关联或聚合相关的类
- en: Testing exception handling mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异常处理机制
- en: By the end of this chapter, you will have various techniques in your programming
    arsenal to ensure that your code is well-tested before it goes into production.
    Having the skills to consistently produce robust code will help you become a more
    beneficial programmer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有各种技术，以确保你的代码在生产前经过充分测试。具备持续生产稳健代码的技能将帮助你成为一个更有益的程序员。
- en: Let’s increase our C++ skills set by examining various techniques for OO testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究面向对象测试的各种技术，让我们增加我们的C++技能集。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter15` in a file named `Chp15-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15)。每个完整程序示例都可以在GitHub仓库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter15`子目录中找到，文件名为`Chp15-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3AxyLFH](https://bit.ly/3AxyLFH).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址查看：[https://bit.ly/3AxyLFH](https://bit.ly/3AxyLFH)。
- en: Contemplating OO testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考面向对象测试
- en: Software testing is immensely important prior to any code deployment. Testing
    object-oriented software will require different techniques than other types of
    software. Because OO software contains relationships between classes, we must
    understand how to test dependencies and relationships that may exist between classes.
    Additionally, each object may progress through different states based on the order
    that operations are applied to each instance, as well as through specific interactions
    with related objects (for example, via association). The overall flow of control
    through an OO application is much more complex than with procedural applications,
    as the combinations and order of operations applied to a given object and influences
    from associated objects are numerous.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何代码部署之前进行软件测试至关重要。测试面向对象软件需要不同于其他类型软件的技术。因为面向对象软件包含类之间的关系，我们必须了解如何测试可能存在于类之间的依赖关系和关系。此外，每个对象可能根据应用于每个实例的操作顺序以及与相关对象的特定交互（例如，通过关联）而处于不同的状态。与过程式应用程序相比，面向对象应用程序的整体控制流程要复杂得多，因为应用于特定对象的操作组合和顺序以及来自相关对象的影响众多。
- en: Nonetheless, there are metrics and processes we can apply to test OO software.
    These range from understanding idioms and patterns we can apply for class specification,
    to creating drivers to test classes both independently and as they relate to other
    classes. These processes can further include creating scenarios to provide likely
    sequences of events or states that objects may progress through. Relationships
    between objects, such as inheritance, association, and aggregation become very
    important in testing; related objects can influence the state of an existing object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然可以应用一些指标和流程来测试面向对象（OO）软件。这些指标和流程包括理解我们可以应用于类指定的惯用语句和模式，以及创建驱动程序来独立测试类以及它们与其他类之间的关系。这些流程还可以包括创建场景，以提供对象可能经历的事件或状态的预期序列。对象之间的关系，如继承、关联和聚合，在测试中变得非常重要；相关对象可以影响现有对象的状态。
- en: Let’s begin our quest in testing OO software by understanding a simple pattern
    that we can often apply to classes we develop. This idiom will ensure that a class
    is potentially complete, with no unexpected behavior. We will start with the canonical
    class form.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过理解一个简单的模式开始我们的面向对象软件测试之旅，这个模式我们经常可以应用于我们开发的类。这个惯用语句将确保一个类可能是完整的，没有意外的行为。我们将从规范类形式开始。
- en: Understanding the canonical class form
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解规范类形式
- en: For many classes in C++, it is reasonable to follow a pattern for class specification
    to ensure that a new class contains a full set of desired components. The **canonical
    class form** is a robust specification of a class that enables class instances
    to provide uniform behavior (analogous to standard data types) in areas such as
    initialization, assignment, argument passing, and usage in return values from
    functions. The canonical class form will apply to most classes that are intended
    for either instantiation or that will serve as public base classes for new derived
    classes. Classes that are intended to serve as private or protected base classes
    (even if they may be instantiated themselves) may not follow all parts of this
    idiom.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++中的许多类，遵循类指定的模式以确保新类包含所需的所有组件是合理的。**规范类形式**是对类的一个稳健的规范，它使类实例能够在初始化、赋值、参数传递以及函数返回值的使用等方面提供统一的行为（类似于标准数据类型）。规范类形式适用于大多数旨在实例化或将成为新派生类公共基类的类。旨在作为私有或保护基类的类（即使它们可能被实例化）可能不会遵循这个惯用语句的所有部分。
- en: 'A class following **orthodox** canonical form will include the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个遵循**正统**规范形式的类将包括以下内容：
- en: A default constructor (or an `=default` prototype to explicitly allow this interface)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数（或一个`=default`原型，以显式允许此接口）
- en: A copy constructor
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复制构造函数
- en: An overloaded assignment operator
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重载的赋值运算符
- en: A virtual destructor
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个虚析构函数
- en: Though any of the aforementioned components may be prototyped with `=default`
    to explicitly utilize the default, system-supplied implementations, modern preferences
    are moving away from such practices (as these prototypes are generally redundant).
    The exception is the default constructor whose interface you will not otherwise
    get without using `=default` when other constructors are present.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述任何组件都可以使用`=default`原型来显式利用默认的系统提供的实现，但现代的偏好正在远离这种做法（因为这些原型通常是多余的）。例外是默认构造函数，如果没有使用`=default`，在其他构造函数存在的情况下，你将无法获得其接口。
- en: 'A class following the **extended** canonical form will additionally include
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个遵循**扩展**规范形式的类将还包括以下内容：
- en: A *move* copy constructor
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*移动*复制构造函数
- en: A *move* assignment operator
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*移动*赋值运算符
- en: Let’s look at each component of the canonical class form in the next subsections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来在下一小节中查看规范类形式的每个组成部分。
- en: Default constructor
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: A `=default` to the default constructor prototype; this is especially useful
    when in-class initialization is utilized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对默认构造函数原型的`=default`；这在利用类内初始化时特别有用。
- en: Additionally, a default constructor for a given class’ base class will be called
    in the absence of an alternate base class constructor specification in the member
    initialization list. If a base class has no such default constructor (and one
    hasn’t been provided because a constructor with another signature exists), the
    implicit call to the base class constructor will be flagged as an error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果没有在成员初始化列表中指定其他基类构造函数，将调用给定类的基类的默认构造函数。如果一个基类没有这样的默认构造函数（并且没有提供，因为存在具有不同签名的构造函数），对基类构造函数的隐式调用将被标记为错误。
- en: Let’s also consider multiple inheritance situations in which a diamond-shaped
    hierarchy occurs, and virtual base classes are used to eliminate duplication of
    the most base class subobjects within instances of the most derived class. In
    this scenario, the default constructor for the now *shared* base class subobject
    is called unless otherwise specified in the member initialization list of the
    derived class responsible for creating the diamond shape. This occurs even if
    non-default constructors are specified in the member initialization list at the
    middle level; remember these specifications are ignored when the mid-levels specify
    a potentially shared virtual base class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑多继承的情况，其中出现菱形层次结构，并且使用虚拟基类来消除最派生类实例中最基本类子对象的重复。在这种情况下，除非在负责创建菱形结构的派生类的成员初始化列表中另有指定，否则将调用现在*共享*的基类子对象的默认构造函数。即使在中级别的成员初始化列表中指定了非默认构造函数，这种情况也会发生；记住，当中级别指定一个可能共享的虚拟基类时，这些指定将被忽略。
- en: Copy constructor
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拷贝构造函数
- en: A **copy constructor** is often crucial for all objects containing pointer data
    members. Unless a copy constructor is supplied by the programmer, a system-supplied
    copy constructor will be linked in when necessary in the application. The system-supplied
    copy constructor performs a member-wise (shallow) copy of all data members. This
    means that multiple instances of a class may contain pointers to *shared* pieces
    of memory representing the data that should have been individualized. Unless resource
    sharing is intended, raw pointer data members in the newly instantiated object
    will want to allocate their own memory and copy the data values from the source
    object into this memory. Also, remember to use the member initialization list
    in a derived class copy constructor to specify the base class’ copy constructor
    to copy the base class data members. Certainly, copying the base class subobject
    in a deep fashion is crucial; additionally, the base class data members are inevitably
    private, so selecting the base class copy constructor in the derived class’ member
    initialization list is very important.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含指针数据成员的所有对象，**拷贝构造函数**通常至关重要。除非程序员提供了拷贝构造函数，否则在应用程序需要时将链接系统提供的拷贝构造函数。系统提供的拷贝构造函数执行所有数据成员的成员级（浅）拷贝。这意味着类的多个实例可能包含指向*共享*内存块的指针，这些内存块代表应该个性化的数据。除非有意资源共享，否则新实例化的对象中的原始指针数据成员将想要分配自己的内存并将数据值从源对象复制到这个内存中。此外，请记住在派生类的拷贝构造函数中使用成员初始化列表来指定基类的拷贝构造函数以复制基类数据成员。当然，以深度方式复制基类子对象至关重要；此外，基类数据成员必然是私有的，因此在派生类的成员初始化列表中选择基类拷贝构造函数非常重要。
- en: By specifying a copy constructor, we also help provide an expected manner for
    the creation of objects passed (or returned) by value from a function. Ensuring
    deep copies in these scenarios is crucial. The user may think these copies are
    *by value*, yet if their pointer data members are actually shared with the source
    instance, it’s not truly passing (or returning) an object by value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定拷贝构造函数，我们也有助于提供从函数传递（或返回）值时创建对象的预期方式。在这些情况下确保深度拷贝至关重要。用户可能会认为这些拷贝是*按值*进行的，但如果它们的指针数据成员实际上与源实例共享，那么这并不是真正按值传递（或返回）对象。
- en: Overloaded assignment operator
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载赋值运算符
- en: An **overloaded assignment operator**, much like the copy constructor, is often
    also crucial for all objects containing pointer data members. The default behavior
    for the system-supplied assignment operator is a shallow assignment of data from
    source to destination object. Again, when data members are raw pointers, unless
    the two objects want to share the resources for heap data members, it is highly
    recommended that the assignment operator should be overloaded. Allocated space
    in the destination object should be equal to the source data member sizes for
    any such pointer data members. The contents (data) should then be copied from
    source to destination object for each pointer data member.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**重载的赋值运算符**，就像拷贝构造函数一样，对于所有包含指针数据成员的对象通常也是至关重要的。系统提供的赋值运算符的默认行为是从源对象到目标对象的浅拷贝。同样，当数据成员是原始指针时，除非两个对象想要共享堆数据成员的资源，否则强烈建议重载赋值运算符。目标对象中分配的空间应等于任何此类指针数据成员的数据成员大小。然后应该将每个指针数据成员的内容（数据）从源对象复制到目标对象。
- en: Also, remember that an overloaded assignment operator is not *inherited*; each
    class is responsible for writing its own version. This makes sense, as the derived
    class inevitably has more data members to copy than the assignment operator function
    in its base class. However, when overloading an assignment operator in a derived
    class, remember to call the base class’ assignment operator to perform a deep
    assignment of inherited base class members (which may be private and otherwise
    inaccessible).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，重载的赋值运算符不是*继承*的；每个类都负责编写自己的版本。这很有意义，因为派生类不可避免地有比其基类赋值运算符函数更多的数据成员要复制。然而，当在派生类中重载赋值运算符时，请记住调用基类的赋值运算符以执行继承基类成员的深度赋值（这些成员可能是私有的且无法访问）。
- en: Virtual destructor
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚析构函数
- en: A `=default`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: A `=default`).
- en: Move copy constructor
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动拷贝构造函数
- en: A `this`. We then must null the source object’s pointers to those data members
    so that both instances do not *share* the dynamically allocated data members.
    We have, in essence, moved (the memory for) the pointer data members.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`this`。然后我们必须将源对象对这些数据成员的指针设置为空，这样两个实例就不会*共享*动态分配的数据成员。本质上，我们已经移动了（这些指针的内存）。
- en: What about the non-pointer data members? The memory for these data members will
    be copied as usual. The memory for the non-pointer data members and the memory
    for the pointers themselves (not the memory pointed to by those pointers), still
    reside in the source instance. As such, the best we can do is designate a null
    value (`nullptr`) for the source object’s pointers and place a `0` (or similar)
    value in the non-pointer data members to indicate that these members are no longer
    relevant.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么非指针数据成员怎么办？这些数据成员的内存将按常规复制。非指针数据成员的内存以及指针本身的内存（不是那些指针指向的内存）仍然位于源实例中。因此，我们能做的最好的事情是为源对象的指针指定一个空值（`nullptr`），并在非指针数据成员中放置一个`0`（或类似值）以指示这些成员不再相关。
- en: 'We will use the `move()` function, found in the C++ Standard Library, to indicate
    a move copy constructor as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用C++标准库中找到的`move()`函数，如下指示移动拷贝构造函数：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Additionally, with classes related by inheritance, we will also use `move()`
    in the member initialization list of the derived class move copy constructor.
    This will specify the base class move copy constructor to help initialize the
    subobject.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于通过继承相关联的类，我们也会在派生类移动拷贝构造函数的成员初始化列表中使用`move()`。这将指定基类的移动拷贝构造函数以帮助初始化子对象。
- en: Move assignment operator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动赋值运算符
- en: A **move assignment operator** is much like an overloaded assignment operator
    and is often crucial for all objects containing pointer data members. However,
    the goal is to again conserve memory by *moving* the dynamically allocated data
    of the source object to the destination object (versus performing a deep assignment).
    As with the overloaded assignment operator, we will test for self-assignment and
    then delete any previously dynamically allocated data members from the (pre-existing)
    destination object. However, we will then simply copy the pointer data members
    from the source object to those in the destination object. We will also null out
    the pointers in the source object so that the two instances do not share these
    dynamically allocated data members.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动赋值运算符**与重载的赋值运算符非常相似，对于所有包含指针数据成员的对象来说通常至关重要。然而，目标是再次通过 *移动* 源对象的动态分配数据到目标对象（而不是执行深拷贝）来节省内存。与重载的赋值运算符一样，我们将测试自赋值，然后从（现有的）目标对象中删除任何先前动态分配的数据成员。然而，然后我们将简单地从源对象复制指针数据成员到目标对象。我们还将使源对象中的指针为空，这样两个实例就不会共享这些动态分配的数据成员。'
- en: Also, much like the move copy constructor, non-pointer data members will be
    simply copied from source to destination object and replaced with a `nullptr`
    value in the source object to indicate non-usage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于移动复制构造函数，非指针数据成员将简单地从源对象复制到目标对象，并在源对象中用 `nullptr` 值替换，以指示未使用。
- en: 'We will again use the `move()` function as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `move()` 函数，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionally, with classes related by inheritance, we can again specify that
    the move assignment operator of the derived class will call the base class move
    assignment operator to help complete the task.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于通过继承相关联的类，我们还可以指定派生类的移动赋值运算符将调用基类的移动赋值运算符以帮助完成任务。
- en: Bringing the components of canonical class form together
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将规范类形式的组件组合在一起
- en: 'Let’s see an example of a pair of classes that embrace the canonical class
    form. We will start with our `Person` class. This example can be found, as a complete
    program, in our GitHub repository:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一对采用规范类形式的类的示例。我们将从我们的 `Person` 类开始。这个例子可以作为完整的程序在我们的 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous class definition, we notice that `Person` contains a default
    constructor, copy constructor, overloaded assignment operator, and a virtual destructor.
    Here, we have embraced the orthodox canonical class form as a pattern applicable
    for a class that might one day serve as a public base class. Also notice that
    we have added the prototypes for the move copy constructor and move assignment
    operator to additionally embrace the extended canonical class form.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们注意到 `Person` 包含一个默认构造函数、复制构造函数、重载的赋值运算符和一个虚析构函数。在这里，我们采用了传统的规范类形式作为可能有一天会作为公共基类的类的模式。同时请注意，我们添加了移动复制构造函数和移动赋值运算符的原型，以进一步采用扩展规范类形式。
- en: The prototypes of the move copy constructor `Person(Person &&);` and the move
    assignment operator `Person &operator=(Person &&);` contain parameters of type
    `Person &&`. These are examples of `Person &`, will bind to the original copy
    constructor and overloaded assignment operator, whereas r-value reference parameters
    will bind to the applicable move methods instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 移动复制构造函数 `Person(Person &&);` 和移动赋值运算符 `Person &operator=(Person &&);` 的原型包含类型为
    `Person &&` 的参数。这些都是 `Person &` 的例子，将绑定到原始的复制构造函数和重载的赋值运算符，而右值引用参数将绑定到相应的移动方法。
- en: 'Let’s now look at the definitions for the methods contributing to the extended
    canonical class form – the move copy constructor and the move assignment operator
    for `Person`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下对扩展规范类形式有所贡献的方法的定义——`Person` 的移动构造函数和移动赋值运算符：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice, in the preceding move copy constructor for data members that are pointers,
    we overtake the source object’s dynamically allocated memory by using simple pointer
    assignments in the member initialization list (versus memory allocation such as
    we would employ in a deep copy constructor). We then place a `nullptr` value in
    the source object’s pointer data members in the body of the constructor. For non-pointer
    data members, we simply copy the values from the source to the destination object
    and place a zeroed or empty value (such as `'\0'` for `p.middleInitial` or using
    `clear()` for `p.firstName`) in the source object to indicate its further non-use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的移动构造函数中，对于指针类型的成员变量，我们通过在成员初始化列表中使用简单的指针赋值来接管源对象的动态分配的内存（而不是像在深度复制构造函数中那样使用内存分配）。然后我们在构造函数的主体中将源对象的指针数据成员设置为`nullptr`值。对于非指针数据成员，我们简单地从源对象复制值到目标对象，并在源对象中放置一个零值或空值（例如，对于`p.middleInitial`使用`'\0'`或使用`clear()`对于`p.firstName`），以指示其进一步的非使用。
- en: In the move assignment operator, we check for self-assignment and then employ
    the same scheme to merely move the dynamically allocated memory from the source
    object to the destination object with a simple pointer assignment. We copy simple
    data members as well, and of course, replace source object data values with either
    null pointers (`nullptr`) or zeroed values to indicate further non-use. The return
    value of `*this` allows for cascaded assignments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动赋值运算符中，我们检查自赋值，然后采用相同的方案，仅通过简单的指针赋值将动态分配的内存从源对象移动到目标对象。我们也复制简单的数据成员，当然，用空指针（`nullptr`）或零值替换源对象的数据值，以指示其进一步的非使用。`*this`的返回值允许级联赋值。
- en: 'Now, let’s see how a derived class, `Student`, employs both the orthodox and
    extended canonical class form while utilizing its base class components to aid
    in the implementation of selected idiom methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看派生类`Student`如何利用其基类组件，同时采用正统和扩展规范类形式来实现选定的惯用方法：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding class definition, we again see that `Student` contains a default
    constructor, a copy constructor, an overloaded assignment operator, and a virtual
    destructor to complete the orthodox canonical class form.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们再次看到`Student`包含一个默认构造函数、一个复制构造函数、一个重载的赋值运算符和一个虚析构函数，以完成正统的规范类形式。
- en: Notice, however, that in the `Student` copy constructor, we specify the use
    of the `Person` copy constructor through the member initialization list. Similarly,
    in the `Student` overloaded assignment operator, once we check for self-assignment,
    we call the overloaded assignment operator in `Person` to help us complete the
    task using `Person::operator=(s);`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在`Student`复制构造函数中，我们通过成员初始化列表指定了使用`Person`复制构造函数。同样，在`Student`重载的赋值运算符中，一旦我们检查到自赋值，我们就调用`Person`中的重载赋值运算符来帮助我们完成任务，使用`Person::operator=(s);`。
- en: 'Let’s now look at the method definitions contributing to the extended canonical
    class form of `Student` – the move copy constructor and the move assignment operator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看对`Student`扩展规范类形式做出贡献的方法定义——移动复制构造函数和移动赋值运算符：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice, in the previously listed `Student` move copy constructor, we specify
    the utilization of the base class move copy constructor in the member initialization
    list. The remainder of the `Student` move copy constructor is similar to that
    found in the `Person` base class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在之前列出的`Student`移动复制构造函数中，我们在成员初始化列表中指定了使用基类的移动复制构造函数。`Student`移动复制构造函数的其余部分与`Person`基类中的类似。
- en: Likewise, let’s notice in the `Student` move assignment operator, the call to
    the base class move `operator=` with `Person::operator=(move(s));`. The remainder
    of this method is similar to that found in the base class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们注意到在`Student`移动赋值运算符中，调用了基类的移动赋值运算符`Person::operator=(move(s));`。此方法的其他部分与基类中的类似。
- en: A good rule of thumb is that most non-trivial classes should minimally utilize
    the orthodox canonical class form. Of course, there are exceptions. For example,
    a class that will only serve as a protected or private base class need not have
    a virtual destructor because derived class instances cannot be upcast past a non-public
    inheritance boundary. Similarly, if we have a good reason to not want copies or
    to disallow an assignment, we can prohibit copies or assignments using the `=
    delete` specification in the extended signature of either of these methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是，大多数非平凡类应该至少利用正统的规范类形式。当然，也有一些例外。例如，一个仅作为受保护的或私有基类的类不需要有虚拟析构函数，因为派生类实例不能超出非公共继承边界向上转换。同样，如果我们有充分的理由不希望有副本或禁止赋值，我们可以在这些方法的扩展签名中使用`=
    delete`指定来禁止副本或赋值。
- en: Nonetheless, the canonical class form will add robustness to classes that embrace
    this idiom. The uniformity among classes utilizing this idiom with respect to
    their implementation of initialization, assignment, and argument passing will
    be valued by programmers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，规范类形式将为采用这种语法的类增加健壮性。程序员将重视使用这种语法在初始化、赋值和参数传递方面的类之间的统一性。
- en: Let’s move forward to take a look at a complementary idea to the canonical class
    form, that of robustness.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看与规范类形式互补的一个想法，那就是健壮性。
- en: Ensuring a class is robust
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保类是健壮的
- en: An important feature of C++ is the ability to build libraries of classes for
    widespread reuse. Whether we wish to achieve this goal, or simply wish to provide
    reliable code for our own organization’s use, our code must be robust. A **robust
    class** will be well-tested, should follow the canonical class form (except for
    requiring a virtual destructor in protected and private base classes), and be
    portable (or included in a platform-specific library). Any class that is a candidate
    for reuse, or which is to be used in any professional capacity, must absolutely
    be robust.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C++的一个重要特性是能够构建用于广泛重用的类库。无论我们是否希望实现这一目标，或者只是希望为我们自己的组织提供可靠的代码，我们的代码都必须是健壮的。一个**健壮的类**应该经过良好的测试，应遵循规范类形式（除了在受保护的和私有的基类中需要虚拟析构函数外），并且应该是可移植的（或包含在特定平台的库中）。任何可能被重用或将在任何专业场合使用的类，绝对必须是健壮的。
- en: A robust class must ensure that all instances of a given class are fully constructed.
    A **fully constructed object** is one in which all data members are appropriately
    initialized. All constructors for a given class (including copy constructors)
    must be verified to initialize all data members. The values with which data members
    are loaded should be checked for range suitability. Remember, an uninitialized
    data member is a potential disaster! Precautions should be made in the event that
    a given constructor does not complete properly or if the initial values of data
    members are inappropriate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个健壮的类必须确保给定类的所有实例都是完全构建的。一个**完全构建的对象**是指所有数据成员都适当地初始化了。给定类的所有构造函数（包括拷贝构造函数）都必须经过验证以确保初始化所有数据成员。数据成员加载的值应该检查范围适宜性。记住，未初始化的数据成员可能是一个潜在的灾难！如果给定的构造函数没有正确完成或者数据成员的初始值不合适，应该采取预防措施。
- en: Fully constructed objects may be validated using a variety of techniques. A
    rudimentary (and not advised) technique is to embed a status data member into
    each class (or derive or embed a status ancestor/member). Set the status member
    to `0` in the member initialization list and to `1` as the last line of the constructor.
    Probe this value after instantiation. The huge downfall of this approach is that
    users will certainly forget to probe the *fully constructed* success flag.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种技术来验证完全构建的对象。一种（不推荐）的基本技术是在每个类中嵌入一个状态数据成员（或从或嵌入一个状态祖先/成员）。在成员初始化列表中将状态成员设置为`0`，在构造函数的最后一条语句中将它设置为`1`。在实例化后检查这个值。这种方法的一个巨大缺陷是用户肯定会忘记检查**完全构建**的成功标志。
- en: An alternative to the simple, aforementioned scheme is to utilize in-class initialization
    for all simple data types, resetting these members in the member initialization
    list of each alternate constructor to the desired values. After instantiation,
    the values may again be probed to determine whether an alternate constructor completed
    successfully. This is still far from an ideal implementation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述简单方案不同的替代方案是，对于所有简单数据类型，利用课堂初始化，将这些成员在替代构造函数的成员初始化列表中重置为所需的值。实例化之后，可以再次探测这些值，以确定是否成功完成了替代构造函数。这仍然远非理想的实现。
- en: A much better technique is to utilize exception handling. Embedding exception
    handling inside each constructor is ideal. If data members are not initialized
    within a suitable range, first try to re-enter their values, or open an alternate
    database for input, for example. As a last resort, you can throw an exception
    to report the *not fully constructed object*. We will more closely examine exception
    handling with respect to testing later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的技术是利用异常处理。将异常处理嵌入到每个构造函数中是理想的。如果数据成员没有在合适的范围内初始化，首先尝试重新输入它们的值，或者打开一个备用的数据库进行输入，例如。作为最后的手段，你可以抛出一个异常来报告*未完全构建的对象*。我们将在本章稍后更详细地检查与测试相关的异常处理。
- en: Meanwhile, let us move forward with a technique to rigorously test our classes
    and components – creating drivers to test classes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们继续探讨一种严格测试我们的类和组件的技术——创建用于测试类的驱动程序。
- en: Creating drivers to test classes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建驱动程序以测试类
- en: In [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*,
    we briefly talked about breaking our code into source and header files. Let us
    briefly recap. Typically, the header file will be named after the class (such
    as `Student.h`) and will contain the class definition, plus any inline member
    function definitions. By placing inline functions in a header file, they will
    be properly re-expanded should their implementations change (as the header is
    subsequently included in each source file, creating a dependency with that header).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B19087_05.xhtml#_idTextAnchor222)《详细探索类》中，我们简要地讨论了将代码拆分为源文件和头文件。让我们简要回顾一下。通常，头文件将以类的名称命名（例如`Student.h`），并包含类的定义以及任何内联成员函数的定义。通过将内联函数放在头文件中，如果它们的实现发生变化（因为头文件随后包含在每个源文件中，从而与该头文件建立依赖关系），它们将被正确地重新展开。
- en: The implementation for the methods of each class will be placed in a corresponding
    source code file (such as `Student.cpp`), which will include the header on which
    it is based (that is, `#include "Student.h"`). Note that the double quotes imply
    that this header is in our current working directory; we could also specify a
    path as to where to find the header. By comparison, the angle brackets used with
    C++ libraries tell the preprocessor to look in predesignated directories by the
    compiler. Also, note that each derived class header file will include the header
    file for its base class (so that it may see member function prototypes).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类的方法实现将放置在相应的源代码文件中（例如`Student.cpp`），该文件将包含基于它的头文件（即`#include "Student.h"`）。注意，双引号表示该头文件位于我们的当前工作目录中；我们也可以指定一个路径来查找头文件。相比之下，与C++库一起使用的尖括号告诉预处理器在编译器预先指定的目录中查找。此外，请注意，每个派生类的头文件将包含其基类的头文件（这样它可以看到成员函数原型）。
- en: Note that any static data member or method definitions will appear in their
    corresponding source code files (so that only one definition per application will
    exist).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何静态数据成员或方法定义都将出现在它们相应的源代码文件中（这样每个应用程序将只有一个定义）。
- en: With this header and source code file structure in mind, we can now create a
    driver to test each individual class or each grouping of closely related classes
    (such as those related through association or aggregation). Classes related through
    inheritance can be tested in their own, individual driver files. Each driver file
    can be named to reflect the class that is being tested, such as `StudentDriver.cpp`.
    The driver file will include the relevant header files for the class(es) being
    tested. Of course, the source files from the classes in question would be compiled
    and linked to the driver file as part of the compilation process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑到这个头文件和源代码文件结构的情况下，我们现在可以创建一个驱动程序来测试每个单独的类或每个紧密相关的类的分组（例如，通过关联或聚合相关的类）。通过继承相关的类可以在它们自己的单独的驱动程序文件中进行测试。每个驱动程序文件可以命名为反映正在测试的类，例如`StudentDriver.cpp`。驱动程序文件将包含正在测试的类（的）相关头文件。当然，在编译过程中，相关类的源文件会被编译并链接到驱动程序文件中。
- en: The driver file can simply contain a `main()` function as a test bed to instantiate
    the class(es) in question and serve as a scope to test each member function. The
    driver will test default instantiation, typical instantiation, copy construction,
    assignment between objects, and each of the additional methods in the class(es).
    Should virtual destructors or other virtual functions exist, we should instantiate
    derived class instances (in the derived class’ driver), upcasting these instances
    to be stored using base class pointers, and then invoke the virtual functions
    to verify that the correct behaviors occur. In the case of a virtual destructor,
    we can trace which destructor is the entry point in the destruction sequence by
    deleting a dynamically allocated instance (or waiting for a stack instance to
    go out of scope) and single-stepping through our debugger to verify all is as
    expected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动文件可以简单地包含一个`main()`函数作为测试床，以实例化相关的类，并作为测试每个成员函数的范围。驱动程序将测试默认实例化、典型实例化、拷贝构造、对象之间的赋值以及类中每个额外的方法。如果存在虚拟析构函数或其他虚拟函数，我们应该实例化派生类实例（在派生类的驱动程序中），将这些实例向上转换为使用基类指针存储，然后调用虚拟函数以验证是否发生正确的行为。在虚拟析构函数的情况下，我们可以通过删除动态分配的实例（或等待栈实例超出作用域）并使用调试器单步执行来跟踪析构序列中的入口点，以验证一切是否如预期。
- en: We can also test that objects are fully constructed; we will see more on this
    topic shortly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试对象是否完全构造；我们将在稍后了解更多关于这个话题的内容。
- en: 'Assuming we have our usual `Person` and `Student` class hierarchy, here is
    a simple driver (the file containing `main()`) to test the `Student` class. This
    driver can be found in our GitHub repository. To make a complete program, you
    will also need to compile and link together the `Student.cpp` and `Person.cpp`
    files found in this same directory. Here is the GitHub repository URL for the
    driver:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个常见的`Person`和`Student`类层次结构，以下是一个简单的驱动程序（包含`main()`的文件）来测试`Student`类。这个驱动程序可以在我们的GitHub仓库中找到。要制作一个完整的程序，您还需要编译并链接同一目录中找到的`Student.cpp`和`Person.cpp`文件。以下是驱动程序的GitHub仓库URL：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp)'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Briefly reviewing the preceding program fragment, we can see that we have tested
    each means for instantiation, including the copy constructor. We’ve also tested
    the assignment operator, verified each member function works (an example method
    is shown), and verified that the virtual functions (including the virtual destructor),
    work as intended.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾前面的程序片段，我们可以看到我们已经测试了每种实例化方式，包括拷贝构造函数。我们还测试了赋值运算符，验证了每个成员函数的工作情况（示例方法如下），并验证了虚拟函数（包括虚拟析构函数）按预期工作。
- en: Now that we have seen a basic driver test our classes, let’s consider some additional
    metrics we can use when testing classes related via inheritance, association,
    or aggregation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到基本驱动程序测试了我们的类，让我们考虑一些在测试通过继承、关联或聚合相关的类时可以使用的额外指标。
- en: Testing related classes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试相关类
- en: With OO programs, it is not sufficient to simply test an individual class for
    completeness and robustness, though these are good starting points. Completeness
    entails not only following the canonical class form but also ensuring that data
    members have a safe means for access using appropriate access methods (labeled
    as `const` when not modifying the instance). Completeness also verifies that the
    required interface as specified by the OO design has been implemented.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象程序中，仅仅测试单个类以验证完整性和健壮性是不够的，尽管这些都是好的起点。完整性不仅意味着遵循规范类形式，而且还确保数据成员有使用适当访问方法（当不修改实例时标记为`const`）的安全访问方式。完整性还验证了面向对象设计指定的所需接口是否已实现。
- en: Robustness leads us to verify that all of the aforementioned methods had been
    tested within an appropriate driver, evaluated for platform independence, and
    verified that each means for instantiation leads to a fully constructed object.
    We can augment this type of testing with threshold testing of data members, for
    instance, noting when exceptions are thrown. Completeness and robustness, though
    seemingly comprehensive, are actually the most straightforward means for OO component
    testing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 健壮性使我们验证所有上述方法是否已在适当的驱动程序中测试过，评估了平台独立性，并验证了每种实例化的方式都导致一个完全构建的对象。我们可以通过数据成员的阈值测试来增强这种类型的测试，例如，注意何时抛出异常。虽然看似全面，但完整性和健壮性实际上是面向对象组件测试的最直接手段。
- en: The more challenging means for testing is to test the interaction between related
    classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更具挑战性的测试方法是测试相关类之间的交互。
- en: Testing classes related through inheritance, association, or aggregation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试通过继承、关联或聚合相关联的类
- en: Classes related through various object relationships require various additional
    means for component testing. Objects with various relationships with one another
    can impact the state progression a given instance may have during its life expectancy
    within the application. This type of testing will require the most detailed effort.
    We will find that scenarios will be useful to help us capture the usual interactions
    between related objects, leading to more comprehensive ways to test classes that
    interact with one another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过各种对象关系相关联的类需要各种额外的测试手段。具有彼此之间不同关系的对象可能会影响给定实例在其应用程序生命周期内可能具有的状态进展。这种测试将需要最详细的工作。我们将发现场景对于帮助我们捕捉相关对象之间的通常交互是有用的，从而导致测试相互交互的类的更全面的方法。
- en: Let’s begin by considering how we can test classes related to inheritance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑如何测试与继承相关的类。
- en: Adding strategies to test inheritance
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加测试继承的策略
- en: Classes related through public inheritance need to have virtual functions verified.
    For example, have all intended derived class methods been overridden? Remember,
    a derived class does not need to override all virtual functions specified in its
    base class if base class behaviors are still deemed appropriate at the derived
    class level. It will be necessary to compare the implementation to the design
    to ensure that we have overridden all required polymorphic operations with suitable
    methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过公共继承相关联的类需要验证虚函数。例如，所有预期的派生类方法是否都被覆盖了？记住，如果基类行为在派生类级别仍然被认为是合适的，派生类不需要覆盖其基类中指定的所有虚函数。将实现与设计进行比较是必要的，以确保我们已用适当的方法覆盖了所有必需的多态操作。
- en: Certainly, the binding of virtual functions is done at runtime (that is, dynamic
    binding). It will be important to create derived class instances and store them
    using base class pointers so that the polymorphic operations can be applied. We
    then need to verify that the derived class behavior shines through. If not, perhaps
    we may find ourselves in an unintended function hiding situation, or perhaps the
    base class operation wasn’t marked `virtual` as intended (keeping in mind that
    the keywords `virtual` and `override` at the derived class level, though nice
    and recommended, are optional and do not affect the dynamic behavior).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虚函数的绑定是在运行时完成的（即动态绑定）。创建派生类实例并使用基类指针存储它们，以便应用多态操作，这将是重要的。然后我们需要验证派生类行为是否显现出来。如果没有，我们可能发现自己处于一个意外的函数隐藏情况，或者可能是基类操作没有按照预期标记为`virtual`（记住，在派生类级别，关键字`virtual`和`override`虽然很好且推荐，但不是必需的，并且不影响动态行为）。
- en: Though classes related through inheritance have unique testing strategies, remember
    that instantiation will create a single object, that is, of a base class or of
    a derived class type. When we instantiate one such type, we have one such instance,
    not a pair of instances working together. A derived class merely has a base class
    subobject, which is part of itself. Let’s consider how this compares with associated
    objects or aggregates, which can be separate objects (association), potentially
    interacting with their companions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过继承相关联的类有独特的测试策略，但请记住，实例化将创建一个单一的对象，即基类或派生类类型。当我们实例化此类类型时，我们有一个这样的实例，而不是一对共同工作的实例。派生类仅仅有一个基类子对象，它是它自身的一部分。让我们考虑一下这与关联对象或聚合体相比如何，这些可以是独立的对象（关联），可能与其伴侣相互作用。
- en: Adding strategies to test aggregation and association
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加测试聚合和关联的策略
- en: Classes related through association or aggregation may be multiple instances
    communicating with one another and causing state changes with one another. This
    is certainly more complex than the object relationship of inheritance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联或聚合相关联的类可能存在多个实例相互通信并相互引起状态变化。这肯定比继承的对象关系更复杂。
- en: Classes related via aggregation are generally easier to test than those related
    via association. Thinking of the most common form of aggregation (composition),
    the embedded (inner) object is part of the outer (whole) object. When the outer
    object is instantiated, we get the memory for the inner object embedded within
    the *whole*. The memory layout is not tremendously different (other than the potential
    ordering) when compared to the memory layout of a derived class instance, which
    contains a base class subobject. In each case, we are still dealing with a single
    instance (even though it has embedded *parts*). The point of comparison with testing,
    however, is that operations applied to the *whole* are often delegated to the
    *parts* or components. We will rigorously need to test the operations, on the
    whole, to ensure that they delegate necessary information to each of the parts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚合相关联的类通常比通过关联相关联的类更容易测试。考虑到最常见的聚合形式（组合），嵌入式（内部）对象是外部（整体）对象的一部分。当外部对象被实例化时，我们得到嵌入在*整体*中的内部对象的内存。与包含基类子对象的派生类实例的内存布局相比，内存布局并没有太大不同（除了可能的顺序）。在每种情况下，我们仍然在处理一个单一实例（尽管它有嵌入式*部分*）。然而，在测试中的比较点是，应用于*整体*的操作通常被委托给*部分*或组件。我们将严格需要测试整体上的操作，以确保它们将必要的信息委托给每个部分。
- en: Classes related via the lesser-used form of a general aggregation (where the
    whole contains pointers to the parts versus the typical embedded object implementation
    of composition) have similar issues to an association, as the implementation is
    similar. With that in mind, let’s take a look at testing issues relating to associated
    objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过较少使用的通用聚合形式（其中整体包含对部分的指针，而不是典型的组合嵌入式对象实现）相关联的类，与关联有类似的问题，因为实现是相似的。考虑到这一点，让我们看看与关联对象相关的测试问题。
- en: Classes related via an association are often independently existing objects,
    which at some point in the application have created a link to one another. There
    may or may not be a predetermined point in the application when the two objects
    create a link to one another. Operations applied to one object may cause a change
    in the associated object. For example, let us consider a `Student` and a `Course`.
    Both may exist independently, then at some point in the application, a `Student`
    may add a `Course` with `Student::AddCourse()`. By doing so, not only does a particular
    `Student` instance now contain a link to a specific `Course` instance, but the
    `Student::AddCourse()` operation has caused a change in the `Course` class. That
    particular `Student` instance is now part of a particular `Course` instance’s
    roster. At any point, the `Course` may be canceled, rippling a change in all `Student`
    instances who are enrolled in that `Course`. These changes reflect states in which
    each associated object may exist. For example, a `Student` may be in a state of
    *currently enrolled*, or *dropping* a `Course`. There are many possibilities.
    How do we test all of them?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联相关联的类通常是独立存在的对象，它们在应用中的某个时刻创建了彼此之间的链接。在应用中，两个对象创建彼此之间的链接可能有一个预定的点，也可能没有。对一个对象应用的操作可能会引起相关对象的变化。例如，让我们考虑一个`Student`（学生）和一个`Course`（课程）。它们可能独立存在，然后在应用中的某个时刻，一个`Student`可能通过`Student::AddCourse()`添加一个`Course`。通过这样做，不仅特定的`Student`实例现在包含了对特定`Course`实例的链接，而且`Student::AddCourse()`操作已经引起了`Course`类的变化。那个特定的`Student`实例现在成为特定`Course`实例名单的一部分。在任何时候，`Course`都可能被取消，从而影响所有注册该`Course`的`Student`实例。这些变化反映了每个相关对象可能存在的状态。例如，一个`Student`可能处于**当前注册**或**退课**的状态。有许多可能性。我们如何测试所有这些情况？
- en: Adding scenarios to aid in testing object relationships
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加场景以帮助测试对象关系
- en: The notion of a scenario comes up in object-oriented analysis as a means to
    both create OO designs and test them. A **scenario** is a descriptive walkthrough
    of a likely series of events that will occur in an application. A scenario will
    feature classes and how they may interact with one another for a specific situation.
    Many related scenarios can be collected into the OO concept of a **use case**.
    In the OO analysis and design phases, scenarios help determine which classes may
    exist in the application as well as operations and relationships each may have.
    In testing, scenarios can be reused to form the basis for driver creation to test
    various object relationships. With this in mind, a series of drivers can be developed
    to test numerous scenarios (that is, use cases). This type of modeling will more
    thoroughly be able to provide a test bed for related objects than the initial,
    simple means of testing for completeness and robustness.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象分析中，场景的概念被提出作为一种既可创建面向对象设计又可对其进行测试的手段。**场景**是对应用中可能发生的一系列事件的描述性遍历。一个场景将展示类以及它们在特定情况下可能如何相互交互。许多相关的场景可以收集到面向对象的**用例**概念中。在面向对象分析和设计阶段，场景有助于确定应用中可能存在的类以及每个类可能具有的操作和关系。在测试中，场景可以被重用来形成驱动器创建的基础，以测试各种对象关系。考虑到这一点，可以开发一系列驱动器来测试许多场景（即用例）。这种类型的建模将能够比最初简单测试完整性和鲁棒性的方法更全面地为相关对象提供测试平台。
- en: Another area of concern between any type of related classes is that of version
    control. What happens, for example, if a base class definition or default behavior
    changes? How will that impact a derived class? How will that impact associated
    objects? With each change, we inevitably will need to revisit component testing
    for all related classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的相关类之间的另一个关注领域是版本控制。例如，如果基类定义或默认行为发生变化，会发生什么？这将对派生类有何影响？这将对相关对象有何影响？随着每次变化，我们不可避免地需要重新访问所有相关类的组件测试。
- en: Next, let’s consider how exception handling mechanisms factor into OO component
    testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑异常处理机制如何在面向对象组件测试中发挥作用。
- en: Testing exception handling mechanisms
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常处理机制
- en: Now that we can create drivers to test each class (or a grouping of related
    classes), we will want to understand which methods in our code may throw exceptions.
    For these scenarios, we will want to add try blocks within the driver to ensure
    we know how to handle each potential exception thrown. Before doing so, we should
    ask ourselves, did we include adequate exception handling in our code during the
    development process? For example, considering instantiation, do our constructors
    check whether an object is fully constructed? Do they throw exceptions if not?
    If the answer is no, our classes may not be as robust as we had anticipated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建用于测试每个类（或相关类的组合）的驱动程序，我们将希望了解我们代码中的哪些方法可能会抛出异常。对于这些场景，我们希望在驱动程序中添加 try
    块以确保我们知道如何处理每个潜在的异常。在这样做之前，我们应该问自己，在开发过程中，我们是否在我们的代码中包含了足够的异常处理？例如，考虑到实例化，我们的构造函数是否检查对象是否完全构建？如果没有，它们是否会抛出异常？如果答案是“否”，那么我们的类可能没有我们预期的那么健壮。
- en: Let’s consider embedding exception handling into a constructor, and how we may
    construct a driver to test all potential means for instantiation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将异常处理嵌入到构造函数中，以及我们如何构建一个驱动程序来测试所有可能的实例化方法。
- en: Embedding exception handling in constructors to create robust classes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在构造函数中嵌入异常处理以创建健壮的类
- en: We may recall from our recent [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions*, that we can create our own exception classes, derived from
    the C++ Standard Library `exception` class. Let’s assume that we have created
    such a class, namely `ConstructionException`. If at any point in a constructor
    we are not able to properly initialize a given instance to provide a fully constructed
    object, we can throw a `ConstructionException` from any constructor. The implication
    of potentially throwing a `ConstructionException` is that we now should enclose
    instantiation within try blocks and add matching catch blocks to anticipate a
    `ConstructionException` that may be thrown. Keep in mind, however, that instances
    declared within the scope of a try block have scope only within the `try`-`catch`
    pairing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还记得我们最近的[*第11章*](B19087_11.xhtml#_idTextAnchor488)，*处理异常*，我们可以创建自己的异常类，这些类是从
    C++ 标准库 `exception` 类派生出来的。让我们假设我们已经创建了一个这样的类，即 `ConstructionException`。如果在构造函数的任何点上我们无法正确初始化给定的实例以提供一个完全构建的对象，我们可以从任何构造函数中抛出
    `ConstructionException`。抛出 `ConstructionException` 的潜在含义是，我们现在应该将实例化包含在 try 块中，并添加匹配的
    catch 块来预测可能抛出的 `ConstructionException`。然而，请记住，在 try 块作用域内声明的实例的作用域仅限于 `try`-`catch`
    对。
- en: The good news is that if an object does not complete construction (that is,
    if an exception is thrown before the constructor completes), the object will technically
    not exist. If an object does not technically exist, there will be no necessary
    clean up of a partially instantiated object. We will, however, need to think about
    what this means to our application if an instance we anticipate does not fully
    construct. How will that alter the progression of our code? Part of testing is
    to ensure that we have considered all ways in which our code may be used and bulletproof
    our code accordingly!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果一个对象没有完成构建（即，如果在构造函数完成之前抛出了异常），那么从技术上讲，该对象将不存在。如果一个对象在技术上不存在，那么就没有必要清理部分实例化的对象。然而，我们需要考虑，如果我们预期的实例没有完全构建，这对我们的应用程序意味着什么？这将如何改变我们代码的执行流程？测试的一部分是确保我们已经考虑了我们的代码可能被使用的所有方式，并相应地使我们的代码更加健壮！
- en: It is important to note that the introduction of `try` and `catch` blocks may
    alter our program flow, and it is crucial to include this type of testing in our
    drivers. We may seek scenarios that account for the `try` and `catch` blocks as
    we conduct our testing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，引入 `try` 和 `catch` 块可能会改变我们的程序流程，并且在我们的驱动程序中包含这种类型的测试是至关重要的。在我们进行测试时，我们可能会寻找考虑
    `try` 和 `catch` 块的场景。
- en: We have now seen how we can augment our test drivers to accommodate classes
    that may throw exceptions. We have also discussed in this chapter adding scenarios
    in our drivers to help track the states between objects with relationships and,
    of course, simple class idioms we can follow to set us up for success. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何增强我们的测试驱动程序以适应可能会抛出异常的类。我们也在本章中讨论了在我们的驱动程序中添加场景以帮助跟踪具有关系的对象之间的状态，以及当然，我们可以遵循的简单类习惯用法，以帮助我们取得成功。现在，在我们继续到下一章之前，让我们简要回顾这些概念。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have increased our ability to become better C++ programmers
    by examining various OO class and component testing practices and strategies.
    Our primary goal is to ensure that our code is robust, well-tested, and can be
    deployed error-free to our various organizations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过检查各种面向对象类和组件测试实践和策略，我们提高了成为更好的 C++ 程序员的能力。我们的主要目标是确保我们的代码健壮、经过良好测试，并且可以无错误地部署到我们的各个组织中。
- en: We have considered programming idioms, such as following the canonical class
    form to ensure that our classes are complete and have expected behavior for construction/destruction,
    assignment, and usage in argument passing and as return values from functions.
    We have talked about what it means to create a robust class – one that follows
    the canonical class form that is also well-tested, platform-independent, and tested
    for fully constructed objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了编程惯用法，例如遵循经典类形式以确保我们的类完整，并且对于构造/析构、赋值以及在参数传递和函数返回值中的使用具有预期的行为。我们讨论了创建健壮类意味着什么——即遵循经典类形式且经过良好测试、平台无关且对完全构造的对象进行了测试的类。
- en: We have also explored how to create drivers to test individual classes or sets
    of related classes. We have established a checklist of items to test individual
    classes within a driver. We have looked more thoroughly at object relationships
    to understand that objects that interact with one another require more sophisticated
    testing. That is, as objects move from state to state, they may be impacted by
    associated objects, which can further alter their course of progression. We’ve
    added utilizing scenarios as test cases for our drivers to better capture the
    dynamic states in which instances may move within an application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何创建驱动程序来测试单个类或相关类的集合。我们为驱动程序中的单个类建立了一个测试清单。我们更深入地研究了对象关系，以了解相互交互的对象需要更复杂的测试。也就是说，当对象从一个状态移动到另一个状态时，它们可能会受到相关对象的影响，这可能会进一步改变它们的进程。我们为我们的驱动程序添加了利用场景作为测试用例，以更好地捕捉实例在应用程序中可能移动的动态状态。
- en: Finally, we have taken a look at how exception handling mechanisms can impact
    how we test our code. We have augmented our drivers to account for the flow of
    control that try and catch blocks may redirect our applications from their anticipated,
    typical progression.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经探讨了异常处理机制如何影响我们测试代码的方式。我们已经增强了我们的驱动程序，以考虑 try 和 catch 块可能会将我们的应用程序从预期的典型流程中重定向的流程控制。
- en: We are now ready to continue forward with the next part of our book, design
    patterns and idioms in C++. We will start with [*Chapter 16*](B19087_16.xhtml#_idTextAnchor711),
    *Using the Observer Pattern*. In the remaining chapters, we will understand how
    to apply popular design patterns and employ them in our coding. These skills will
    make us better programmers. Let’s move forward!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续前进，进入我们书籍的下一部分，即 C++ 中的设计模式和惯用法。我们将从[*第16章*](B19087_16.xhtml#_idTextAnchor711)开始，*使用观察者模式*。在接下来的章节中，我们将了解如何应用流行的设计模式并将它们应用于我们的编码。这些技能将使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Consider a pair of classes from one of your previous exercises containing an
    object relationship (hint – public inheritance will be easier to consider than
    association).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到你的前一个练习中的一个包含对象关系的类对（提示——与关联相比，公共继承更容易考虑）。
- en: Do your classes follow the canonical class form? Orthodox or extended? Why,
    or why not? If they do not and should, revise the classes to follow this idiom.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的类遵循经典类形式吗？是正则的还是扩展的？为什么，或者为什么不？如果它们不遵循并且应该遵循，请修改类以遵循这个惯用法。
- en: Would you consider your classes robust? Why, or why not?
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为你的类是健壮的吗？为什么，或者为什么不？
- en: 'Create a driver (or two) to test your pair of classes:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个（或两个）驱动程序来测试你的类对：
- en: Be sure to test for the usual checklist of items (construction, assignment,
    destruction, the public interface, upcasting (if applicable), and use of a virtual
    function).
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测试以下常规清单项目（构造、赋值、析构、公共接口、向上转型（如果适用）以及虚拟函数的使用）。
- en: (Optional) If you selected two classes related using association, create a separate
    driver to follow a typical scenario detailing the interaction of the two classes.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）如果你选择了通过关联使用的关系相关的两个类，创建一个单独的驱动程序来遵循典型场景，详细说明两个类的交互。
- en: Be sure to include testing of exception handling in one of your test drivers.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在你的测试驱动程序中包含异常处理的测试。
- en: Create a `ConstructionException` class (derived from the C++ Standard Library
    `exception`). Embed checks within your constructors in a sample class to throw
    a `ConstructionException` when necessary. Be sure to enclose all forms of instantiation
    of this class within the appropriate `try` and `catch` block pairings.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ConstructionException`类（从C++标准库的`exception`派生）。在示例类中嵌入检查，在必要时抛出`ConstructionException`。确保将此类的所有实例化形式都包含在适当的`try`和`catch`块对中。
- en: 'Part 4: Design Patterns and Idioms in C++'
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：C++中的设计模式和惯用法
- en: The goal of this part is to expand your C++ repertoire, beyond OOP and other
    necessary skills, to include knowledge of core design patterns. Design patterns
    provide well-proven techniques and strategies to solve recurring types of OO problems.
    This section introduces common design patterns and demonstrates in depth how to
    apply these patterns by building on previous examples within the book in creative
    ways. Each chapter contains detailed code examples to exemplify each pattern.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的目标是扩展你的C++技能库，不仅限于面向对象编程和其他必要技能，还包括核心设计模式的知识。设计模式提供了经过验证的技术和策略来解决重复出现的OO问题。本节介绍了常见的设计模式，并通过在书中构建创意示例深入展示了如何应用这些模式。每一章都包含详细的代码示例，以说明每个模式。
- en: The initial chapter in this section introduces the idea of design patterns and
    discusses the advantages of utilizing such patterns within coding solutions. The
    initial chapter also introduces the Observer pattern and provides an in-depth
    program to appreciate the various components of this pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一章介绍了设计模式的概念，并讨论了在编码解决方案中利用此类模式的优势。第一章还介绍了观察者模式，并提供了深入理解该模式各个组成部分的程序示例。
- en: The next chapter explains the Factory Method pattern and likewise provides detailed
    programs, showing how to implement the Factory Method pattern with and without
    an Object Factory. This chapter additionally compares an Object Factory to an
    Abstract Factory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章解释了工厂方法模式，并同样提供了详细的程序，展示了如何实现带和不带对象工厂的工厂方法模式。本章还比较了对象工厂与抽象工厂。
- en: The following chapter introduces the Adapter pattern and provides implementation
    strategies and program examples using inheritance versus association to implement
    the Adapter class. Additionally, an adapter as a simple wrapper class is illustrated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了适配器模式，并提供了使用继承与关联实现适配器类的实现策略和程序示例。此外，还展示了适配器作为一个简单的包装类。
- en: The Singleton pattern is examined in the following chapter. Following two simple
    examples, a paired-class implementation is demonstrated with a detailed example.
    Registries to accommodate Singletons are also introduced.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨单例模式。在两个简单的示例之后，展示了使用配对类实现的详细示例。还介绍了用于容纳单例的注册表。
- en: The final chapter in this section and book introduces the pImpl pattern to reduce
    compile-time dependencies within your code. A basic implementation is provided
    and then expanded upon using unique pointers. Performance issues are additionally
    explored relating to this pattern.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和本书的最后一章介绍了pImpl模式，以减少代码中的编译时依赖。提供了一个基本实现，然后使用唯一指针进行扩展。此外，还探讨了与该模式相关的性能问题。
- en: 'This part comprises the following chapters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 16*](B19087_16.xhtml#_idTextAnchor711), *Using the Observer Pattern*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19087_16.xhtml#_idTextAnchor711), *使用观察者模式*'
- en: '[*Chapter 17*](B19087_17.xhtml#_idTextAnchor743), *Applying the Factory Pattern*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19087_17.xhtml#_idTextAnchor743), *应用工厂模式*'
- en: '[*Chapter 18*](B19087_18.xhtml#_idTextAnchor783), *Applying the Adapter Pattern*'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B19087_18.xhtml#_idTextAnchor783), *应用适配器模式*'
- en: '[*Chapter 19*](B19087_19.xhtml#_idTextAnchor829), *Using the Singleton Pattern*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第19章*](B19087_19.xhtml#_idTextAnchor829), *使用单例模式*'
- en: '[*Chapter 20*](B19087_20.xhtml#_idTextAnchor876), *Removing Implementation
    Details Using the pImpl Pattern*'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第20章*](B19087_20.xhtml#_idTextAnchor876), *使用pImpl模式去除实现细节*'
- en: 'Part 4: Design Patterns and Idioms in C++'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分：C++中的设计模式和惯用法
