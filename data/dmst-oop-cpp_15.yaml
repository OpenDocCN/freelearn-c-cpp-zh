- en: '*Chapter 12*: Friends and Operator Overloading'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：友元和运算符重载'
- en: This chapter will continue our pursuit of expanding your C++ programming repertoire
    beyond OOP concepts, with the goal of writing more extensible code. We will next
    explore **friend functions**, **friend classes**, and **operator overloading**
    in C++. We will understand how operator overloading can extend operators beyond
    their usage with standard types to behave uniformly with user-defined types, and
    why this is a powerful OOP tool. We will learn how friend functions and classes
    can be safely used to achieve this goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展你的C++编程技能，超越OOP概念，目标是编写更具可扩展性的代码。接下来，我们将探索**友元函数**、**友元类**和**运算符重载**在C++中的应用。我们将了解运算符重载如何将运算符扩展到与用户定义类型一致的行为，以及为什么这是一个强大的OOP工具。我们将学习如何安全地使用友元函数和类来实现这一目标。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding friend functions and friend classes, appropriate reasons to utilize
    them, and measures to add safety to their usage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解友元函数和友元类，适当使用它们的原因，以及增加安全性的措施
- en: Learning operator overloading essentials – how and why to overload operators
    and ensuring operators are polymorphic between standard and user-defined types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习运算符重载的基本要点——如何以及为何重载运算符，并确保运算符在标准类型和用户定义类型之间是多态的
- en: Implementing operator functions; knowing when friends may be necessary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现运算符函数；了解何时需要友元
- en: By the end of this chapter, you will unlock the proper usage of friends and
    understand their utility in harnessing C++'s ability to overload operators. Though
    the usage of friend functions and classes can be exploited, you will instead learn
    about their contained usage only within two tightly coupled classes. You will
    understand how the proper usage of friends can enhance operator overloading, allowing
    operators to be extended to support user-defined types so they may work associatively
    with their operands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将掌握友元的正确使用，并了解它们在利用C++重载运算符的能力方面的实用性。尽管可以利用友元函数和类的使用，但您将只学习它们在两个紧密耦合的类中的受限使用。您将了解如何正确使用友元可以增强运算符重载，使运算符能够扩展以支持用户定义类型，以便它们可以与其操作数关联工作。
- en: Let's increase our understanding of C++ by expanding your programming repertoire
    through exploring friend functions, friend classes, and operator overloading.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索友元函数、友元类和运算符重载来扩展你的C++编程技能，增进对C++的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter12`
    subdirectory in a file named `Chp12-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub网址找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节编号相对应，后跟破折号，再跟所在章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp12-Ex1.cpp`的文件中的`Chapter12`子目录下找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f3tIm4](https://bit.ly/3f3tIm4).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址观看：[https://bit.ly/3f3tIm4](https://bit.ly/3f3tIm4)。
- en: Understanding friend classes and friend functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解友元类和友元函数
- en: Encapsulation is a valuable OOP feature that C++ offers through the proper usage
    of classes and access regions. Encapsulation offers uniformity in the manner in
    which data and behaviors are manipulated. In general, it is unwise to forfeit
    the encapsulated protection that a class offers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是C++通过类和访问区域的正确使用提供的宝贵的OOP特性。封装提供了数据和行为被操作的统一方式。总的来说，放弃类提供的封装保护是不明智的。
- en: There are, however, selected programming situations in which breaking encapsulation
    slightly is considered more acceptable than the alternative of providing an *overly
    public* interface to a class, that is, when a class needs to provide methods for
    two classes to cooperate, yet, in general, those methods are inappropriate to
    be publicly accessible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些编程情况下，略微破坏封装性被认为比提供一个*过度公开*的类接口更可接受，也就是说，当一个类需要为两个类提供合作的方法时，但总的来说，这些方法不适合公开访问时。
- en: 'Let''s consider a scenario that may lead us to consider slightly forfeiting
    (that is, breaking) the sacred OOP concept of encapsulation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个可能导致我们稍微放弃（即破坏）封装的情景：
- en: Two tightly coupled classes may exist that are not otherwise related to one
    another. One class may have one or more associations with the other class and
    needs to manipulate the other class's members. Yet, a public interface to allow
    access to such members would make these internals *overly public* and subject
    to manipulation well beyond the needs of the pair of tightly coupled classes.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在两个紧密耦合的类，它们在其他方面没有关联。一个类可能与另一个类有一个或多个关联，并且需要操作另一个类的成员。然而，为了允许访问这些成员的公共接口会使这些内部*过度公开*，并且容易受到远远超出这对紧密耦合类的需求的操纵。
- en: In this situation, it is a better choice to allow one class in the tightly coupled
    pair to have access to the other class's members versus providing a public interface
    in the other class, which allows more manipulation of these members than is generally
    safe. We will see, momentarily, how to minimize this prospective loss of encapsulation.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，允许紧密耦合的一对类中的一个类访问另一个类的成员比在另一个类中提供一个公共接口更好，这个公共接口允许对这些成员进行更多操作，而这通常是不安全的。我们将看到，如何最小化这种潜在的封装损失。
- en: Selected operator overloading situations, which we will soon see, may require
    an instance to have access to its members while in a function that is outside
    of its class scope. Again, a fully accessible public interface may be considered
    dangerous.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们很快将看到，选定的运算符重载情况可能需要一个实例在其类作用域之外的函数中访问其成员。再次强调，一个完全可访问的公共接口可能被认为是危险的。
- en: '**Friend functions** and **friend classes** allow this selective breaking of
    encapsulation to occur. Breaking encapsulation is serious and should not be done
    to simply override access regions. Instead, friends can be used – with added safety
    measures – when the choices are slightly breaking encapsulation between two tightly
    coupled classes or providing an overly public interface, which would yield greater
    and potentially unwanted access to another class''s members from various scopes
    in the application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元函数**和**友元类**允许这种有选择性地打破封装。打破封装是严肃的，不应该简单地用来覆盖访问区域。相反，当在两个紧密耦合的类之间轻微打破封装或提供一个过度公开的接口时，可以使用友元函数和友元类，同时加入安全措施，这样做可能会从应用程序的各个作用域中获得更大且可能不受欢迎的对另一个类成员的访问。'
- en: Let us take a look at how each may be used and then we will add the relevant
    safety measures we should insist on employing. Let's start with friend functions
    and friend classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下如何使用每个，然后我们将添加我们应该坚持使用的相关安全措施。让我们从友元函数和友元类开始。
- en: Using friend functions and friend classes
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用友元函数和友元类
- en: '**Friend functions** are functions that are individually granted *extended
    scope* to include the class with which they are associated. Let''s examine the
    implications and logistics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元函数**是被单独授予*扩展作用域*的函数，以包括它们所关联的类。让我们来看一下其含义和具体情况：'
- en: In the scope of friend functions, an instance of the associated type can access
    its own members as if it were in the scope of its own class.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在友元函数的作用域中，关联类型的实例可以访问自己的成员，就好像它在自己的类作用域中一样。
- en: A friend function needs to be prototyped as a friend in the class definition
    of the class relinquishing access (that is, extending its scope).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友元函数需要在放弃访问权限的类的类定义中作为友元进行原型声明（即扩展其作用域）。
- en: The keyword `friend` is used in front of the prototype that provides access.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`friend`用于提供访问权限的原型前面。
- en: Functions overloading friend functions are not considered friends.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载友元函数的函数不被视为友元。
- en: '**Friend classes** are classes in which every member function of the class
    is a friend function of the associated class. Let''s examine the logistics:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元类**是指该类的每个成员函数都是关联类的友元函数。让我们来看一下具体情况：'
- en: A friend class should have a forward declaration in the class definition of
    the class that is providing it with access to its members (that is, scope).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友元类应该在提供访问权限的类的类定义中进行前向声明（即作用域）。
- en: The keyword `friend` should precede the forward declaration of the class gaining
    access (that is, whose scope has been extended).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`friend`应该在获得访问权限的类的前向声明之前。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Friend classes and friend functions should be utilized sparingly, only when
    breaking encapsulation selectively and slightly is a better choice than offering
    an *overly public* interface (that is, a public interface that would universally
    offer undesired access to selected members within any scope of the application).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 友元类和友元函数应该谨慎使用，只有在有选择地和轻微地打破封装比提供一个*过度公开*的接口更好的选择时才使用（即一个普遍提供对应用程序中任何作用域中的选定成员的不受欢迎访问的公共接口）。
- en: 'Let''s begin by examining the syntax for friend classes and friend function
    declarations. The following classes do not represent complete class definitions;
    however, the complete program can be found in our online GitHub repository as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下友元类和友元函数声明的语法。以下类并不代表完整的类定义；然而，完整的程序可以在我们的在线GitHub存储库中找到，链接如下：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code fragment, we first notice a friend class definition within
    the `Id` class. The statement `friend class Student;` indicates that all member
    functions in `Student` are friend functions to `Id`. This all-inclusive statement
    is used in lieu of naming every function of the `Student` class as a friend function
    of `Id`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先注意到了`Id`类中的友元类定义。语句`friend class Student;`表明`Student`中的所有成员函数都是`Id`的友元函数。这个包容性的语句用来代替将`Student`类的每个函数都命名为`Id`的友元函数。
- en: Also, in the `Student` class, notice the declaration of `friend void Id::SetStudent(Student
    *);`. This friend function declaration indicates that only this specific member
    function of `Id` is a friend function of `Student`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`Student`类中，注意`friend void Id::SetStudent(Student *);`的声明。这个友元函数声明表明只有`Id`的这个特定成员函数是`Student`的友元函数。
- en: 'The implication of the friend function prototype, `friend void Id::SetStudent(Student
    *);`, is that if a `Student` finds itself in the scope of the `Id::SetStudent()`
    method, that `Student` may manipulate its own members as though it is in its own
    scope, namely, that of `Student`. You may ask: which `Student` may find itself
    in the scope of `Id::SetStudent(Student *)`? That''s easy. It is the one passed
    to the method as an input parameter. The result is that the input parameter of
    type `Student *` in the `Id::SetStudent()` method may access its own private and
    protected members as if the `Student` instance were in its own class scope – it
    is in the scope of a friend function.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 友元函数原型`friend void Id::SetStudent(Student *);`的含义是，如果一个`Student`发现自己在`Id::SetStudent()`方法的范围内，那么这个`Student`可以操纵自己的成员，就好像它在自己的范围内一样，也就是`Student`的范围。你可能会问：哪个`Student`可能会发现自己在`Id::SetStudent(Student
    *)`的范围内？很简单。就是作为输入参数传递给方法的那个。结果是，在`Id::SetStudent()`方法中的`Student *`类型的输入参数可以访问自己的私有和受保护成员，就好像`Student`实例在自己的类范围内一样——它在友元函数的范围内。
- en: Similarly, the implication of the friend class forward declaration `friend class
    Student;` found in the `Id` class is that if any `Id` instance finds itself in
    a `Student` method, that `Id` instance can access its own private or protected
    methods as if it were in its own class. The `Id` instance may be in any member
    function of its friend class, `Student`; it is as though those methods have been
    augmented to also have the scope of the `Id` class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Id`类中的友元类前向声明`friend class Student;`的含义是，如果任何`Id`实例发现自己在`Student`方法中，那么这个`Id`实例可以访问自己的私有或受保护方法，就好像它在自己的类中一样。`Id`实例可以在其友元类`Student`的任何成员函数中，就好像这些方法也扩展到了`Id`类的范围一样。
- en: 'Notice that the class giving up access – that is, widening its scope – is the
    one to announce friendship. That is, the `friend class Student;` statement in
    `Id` says: if any `Id` happens to be in any member function of `Student`, allow
    that `Id` to have full access to its members as if it is in its own scope. Likewise,
    the friend function statement in `Student` indicates: if a `Student` instance
    is found (via the input parameter) in this particular method of `Id`, it may have
    access to its elements fully, as though it were in a member function of its own
    class. Think in terms of friendship as a means of augmenting scope.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，放弃访问的类——也就是扩大其范围的类——是宣布友谊的类。也就是说，在`Id`中的`friend class Student;`语句表示：如果任何`Id`恰好在`Student`的任何成员函数中，允许该`Id`完全访问其成员，就好像它在自己的范围内一样。同样，在`Student`中的友元函数语句表示：如果`Student`实例（通过输入参数）在`Id`的特定方法中被找到，它可以完全访问其元素，就好像它在自己类的成员函数中一样。以友谊作为扩大范围的手段来思考。
- en: Now that we have seen the basic mechanics of friend functions and friend classes,
    let's employ a simple contract to make it a bit more appealing to selectively
    break encapsulation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了友元函数和友元类的基本机制，让我们使用一个简单的约定来使其更具吸引力，以有选择地打破封装。
- en: Making access safer when using friends
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在使用友元时使访问更安全
- en: 'We have seen that two tightly coupled classes, such as those related through
    an association, may need to extend their scope somewhat to selectively include
    one another through the use of **friend functions** or **friend classes**. The
    alternative is offering a public interface to select elements of each class. However,
    consider that you may not want the public interface to those elements to be uniformly
    accessible to be used in any scope of the application. You are truly facing a
    tough choice: utilize friends or provide an *overly public* interface.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过关联相关的两个紧密耦合的类可能需要通过使用**友元函数**或**友元类**来有选择地扩展它们的范围。另一种选择是为每个类提供公共接口。然而，请考虑您可能不希望这些元素的公共接口在应用程序的任何范围内都是统一可访问的。您确实面临着一个艰难的选择：使用友元或提供一个*过度公共*的接口。
- en: Though it may make you initially cringe to utilize friends, it may be safer
    than the alternative of providing an undesired public interface to class elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初使用友元可能会让您感到不安，但这可能比提供不需要的公共接口给类元素更安全。
- en: 'To lessen the panic that you feel toward the selective breaking of encapsulation
    that friends allow, consider adding the following contract to your usage of friends:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少对友元允许的选择性打破封装的恐慌，考虑在使用友元时添加以下约定：
- en: When utilizing friends, to lessen the loss of encapsulation, one class can provide
    private access methods to the other class's data members. Make these methods inline
    wherever possible, for efficiency.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用友元时，为了减少封装的损失，一个类可以为另一个类的数据成员提供私有访问方法。尽可能将这些方法设置为内联，以提高效率。
- en: The instance in question should agree to only utilize the private access methods
    created to appropriately access its desired members while in the scope of the
    friend function (even though it could actually unrestrictedly access any data
    or methods of its own type in the scope of the friend function).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题实例应同意只使用创建的私有访问方法来适当地访问其所需的成员，而在友元函数的范围内（即使它实际上可以在友元函数的范围内无限制地访问自己类型的任何数据或方法）。
- en: 'Here is a simple example to illustrate two tightly coupled classes appropriately
    using a `main()` function and several methods are not shown to save space, the
    complete example can be found in our GitHub repository as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子来说明两个紧密耦合的类如何适当地使用`main()`函数，为了节省空间，省略了几个方法，完整的例子可以在我们的GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp)'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's examine the preceding class definitions for `LinkListElement` and `LinkList`.
    Notice, in the `LinkListElement` class, we have three private member functions,
    that is, `void *GetData();`, `LinkListElement *GetNext();`, and `void SetNext(LinkListElement
    *);`. These three member functions should not be part of the public class interface.
    It is only appropriate for these methods to be used within the scope of `LinkList`,
    a class that is tightly coupled with `LinkListElement`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`LinkListElement`和`LinkList`的前面的类定义。请注意，在`LinkListElement`类中，我们有三个私有成员函数，即`void
    *GetData();`，`LinkListElement *GetNext();`和`void SetNext(LinkListElement *);`。这三个成员函数不应该是公共类接口的一部分。这些方法只适合在`LinkList`的范围内使用，这是与`LinkListElement`紧密耦合的类。
- en: Next, notice the `friend class LinkList;` forward declaration in the `LinkListElement`
    class. This declaration means that all member functions of `LinkList` are friend
    functions of `LinkListElement`. As a result, any `LinkListElement` instances that
    find themselves in `LinkList` methods may access their own aforementioned private
    `GetData()`, `GetNext()`, and `SetNext()` methods simply because they will be
    in the scope of a friend class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意`LinkListElement`类中的`friend class LinkList;`前向声明。这个声明意味着`LinkList`的所有成员函数都是`LinkListElement`的友元函数。因此，任何发现自己在`LinkList`方法中的`LinkListElement`实例都可以访问自己前面提到的私有`GetData()`，`GetNext()`和`SetNext()`方法，因为它们将在友元类的范围内。
- en: Next, let's take a look at the `LinkList` class in the preceding code. The class
    definition itself does not have any unique declarations with respect to friendship.
    After all, it is the `LinkListElement` class that has widened its scope to include
    methods of the `LinkedList` class, not the other way around.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看前面代码中的`LinkList`类。类定义本身没有与友好相关的唯一声明。毕竟，是`LinkListElement`类扩大了其范围以包括`LinkedList`类的方法，而不是相反。
- en: 'Now, let''s take a look at two selected member functions of the `LinkList`
    class. The full complement of these methods may be found online, at the previously
    mentioned URL:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`LinkList`类的两个选定的成员函数。这些方法的完整组合可以在网上找到，就像之前提到的URL中一样。
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we examine the preceding code, we can see that in a sampling of `LinkList`
    methods, a `LinkListElement` can call private methods on itself because it is
    in the scope of a friend function (which is essentially its own scope, widened).
    For example, in `LinkList::InsertAtFront()`, `LinkListElement *temp` sets its
    `next` member to `head` using `temp->SetNext(head)`. Certainly, we could have
    also directly accessed the private data member here using `temp->next = head;`.
    However, we maintained a modicum of encapsulation by `LinkListElement` providing
    private access functions, such as `SetNext()`, and asking `LinkList` methods (friend
    functions) to have `temp` utilize the private method `SetNext()`, rather than
    just directly manipulating the data member itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查前面的代码时，我们可以看到在`LinkList`方法的抽样中，`LinkListElement`可以调用自己的私有方法，因为它在友元函数的范围内（本质上是自己的范围，扩大了）。例如，在`LinkList::InsertAtFront()`中，`LinkListElement
    *temp`使用`temp->SetNext(head)`将其`next`成员设置为`head`。当然，我们也可以直接在这里访问私有数据成员，使用`temp->next
    = head;`。但是，通过`LinkListElement`提供私有访问函数，如`SetNext()`，并要求`LinkList`方法（友元函数）让`temp`利用私有方法`SetNext()`，而不是直接操作数据成员本身，我们保持了封装的程度。
- en: Because `GetData()`, `GetNext()`, and `SetNext()` in `LinkListElement` are inline
    functions, we do not forfeit performance by providing a sense of encapsulated
    access to the members `data` and `next`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`LinkListElement`中的`GetData()`，`GetNext()`和`SetNext()`是内联函数，所以我们不会因为提供对成员`data`和`next`的封装访问而损失性能。
- en: We can similarly see that other member functions of `LinkList`, such as `RemoveAtFront()`
    (and `Print()`, which appears in the online code), have `LinkListElement` instances
    utilizing its private access methods, rather than allowing the `LinkListElement`
    instances to grab their private `data` and `next` members directly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到`LinkList`的其他成员函数，比如`RemoveAtFront()`（以及在线代码中出现的`Print()`），都有`LinkListElement`实例利用其私有访问方法，而不是允许`LinkListElement`实例直接获取其私有的`data`和`next`成员。
- en: '`LinkListElement` and `LinkList` are iconic examples of two tightly coupled
    classes in which it may be better to extend one class to include the other''s
    scope for access, rather than providing an *overly public* interface. After all,
    we wouldn''t want users in `main()` to get their hands on a `LinkListElement`
    and apply `SetNext()`, for example, which could change an entire `LinkedList`
    without the `LinkList` class''s knowledge.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkListElement`和`LinkList`是两个紧密耦合的类的标志性示例，也许最好是扩展一个类以包含另一个类的范围，以便访问，而不是提供一个过度公开的接口。毕竟，我们不希望`main()`中的用户接触到`LinkListElement`并应用`SetNext()`，例如，这可能会在不知道`LinkList`类的情况下改变整个`LinkedList`。'
- en: Now that we have seen the mechanics as well as suggested usage for friend functions
    and classes, let's explore another language feature that may need to utilize friends
    – that of operator overloading.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了友元函数和类的机制以及建议的用法，让我们探索另一个可能需要利用友元的语言特性 - 运算符重载。
- en: Deciphering operator overloading essentials
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密运算符重载要点
- en: C++ has a variety of operators in the language. C++ allows most operators to
    be redefined to include usage with user-defined types; this is known as **operator
    overloading**. In this way, user-defined types may utilize the same notation as
    standard types to perform these well-understood operations. We can view an overloaded
    operator as polymorphic in that its same form can be used with a variety of types
    – standard and user-defined.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言中有各种运算符。C++允许大多数运算符重新定义以包括与用户定义类型的使用；这被称为**运算符重载**。通过这种方式，用户定义的类型可以利用与标准类型相同的符号来执行这些众所周知的操作。我们可以将重载的运算符视为多态的，因为它的相同形式可以与各种类型
    - 标准和用户定义的类型一起使用。
- en: 'Not all operators may be overloaded in C++. The following operators cannot
    be overloaded: member access (`.`), the ternary conditional operator (`?:`), the
    scope resolution operator (`::`), the pointer to member operator (`.*`), the `sizeof()`
    operator, and the `typeid()` operator. All the rest may be overloaded, provided
    at least one operand is a user defined type.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有运算符都可以在C++中重载。以下运算符无法重载：成员访问（`。`），三元条件运算符（`？：`），作用域解析运算符（`::`），成员指针运算符（`.*`），`sizeof（）`运算符和`typeid（）`运算符。其余的都可以重载，只要至少有一个操作数是用户定义的类型。
- en: When overloading an operator, it is important to promote the same meaning that
    the operator has for standard types. For example, the extraction operator (`<<)`
    is defined when used in conjunction with `cout` to print to standard output. This
    operator can be applied to various standard types, such as integers, floating-point
    numbers, and character strings. Should the extraction operator (`<<`) be overloaded
    for a user-defined type, such as `Student`, it should also mean to print to standard
    output. In this fashion, operator `<<` is polymorphic when used in the context
    of an output buffer, such as `cout`; that is, it has the same meaning, but different
    implementation, for all types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在重载运算符时，重要的是要促进与标准类型相同的含义。例如，当与`cout`一起使用时，提取运算符（`<<`）被定义为打印到标准输出。这个运算符可以应用于各种标准类型，如整数，浮点数和字符串。如果提取运算符（`<<`）被重载为用户定义的类型，如`Student`，它也应该意味着打印到标准输出。这样，运算符`<<`在输出缓冲区的上下文中是多态的；也就是说，对于所有类型，它具有相同的含义，但不同的实现。
- en: It is important to note that when overloading an operator in C++, we may not
    change the predefined precedence of the operators as they occur in the language.
    This makes sense – we are not rewriting the compiler to parse and interpret expressions
    differently. We are merely extending the meaning of an operator from its usage
    with standard types to include usage with user defined types. Operator precedence
    will remain unchanged.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重载C++中的运算符时，重要的是要注意，我们不能改变语言中运算符的预定义优先级。这是有道理的 - 我们不是在重写编译器以解析和解释表达式。我们只是将运算符的含义从其与标准类型的使用扩展到包括与用户定义类型的使用。运算符优先级将保持不变。
- en: An `operator`, followed by the symbol representing the operator that you wish
    to overload.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符，后跟表示您希望重载的运算符的符号。
- en: 'Let''s take a look at the simple syntax of an operator function prototype:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看运算符函数原型的简单语法：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we intend to provide a means to add a floating-point number and a `Student`
    instance using the C++ addition operator (`+`). The meaning of this addition might
    be to average the new floating-point number with the student's existing grade
    point average. Here, the name of the operator function is `operator+()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打算提供一种方法，使用C++加法运算符（`+`）来添加一个浮点数和一个`Student`实例。这种加法的含义可能是将新的浮点数与学生现有的平均成绩进行平均。在这里，运算符函数的名称是`operator+()`。
- en: In the aforementioned prototype, the operator function is not a member function
    of any class. The left expected operand will be a `float` and the right operand
    will be a `Student`. The return type of the function (`Student &`) allows us to
    cascade the use of `+` with multiple operands or be paired with multiple operators,
    such as `s1 = 3.45 + s2;`. The overall concept is that we can define how to use
    `+` with multiple types, provided at least one operand is a user defined type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，运算符函数不是任何类的成员函数。左操作数将是`float`，右操作数将是`Student`。函数的返回类型（`Student＆`）允许我们将`+`与多个操作数级联使用，或者与多个运算符配对使用，例如`s1
    = 3.45 + s2;`。总体概念是我们可以定义如何使用`+`与多种类型，只要至少有一个操作数是用户定义的类型。
- en: There's actually a lot more involved than the simple syntax shown above. Before
    we fully examine a detailed example, let's first take a look at more logistics
    relating to implementing operator functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，比上面显示的简单语法涉及的内容要多得多。在我们完全检查详细示例之前，让我们首先看一下与实现运算符函数相关的更多后勤事项。
- en: Implementing operator functions and knowing when friends might be necessary
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现运算符函数并知道何时可能需要友元
- en: 'An **operator function**, the mechanism to overload an operator, may be implemented
    as a member function or as a regular, external function. Let''s summarize the
    mechanics of implementing operator functions with the following key points:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符函数**，重载运算符的机制，可以作为成员函数或常规外部函数实现。让我们总结实现运算符函数的机制，以下是关键点：'
- en: Operator functions that are implemented as member functions will receive an
    implicit argument (the `this` pointer), plus at most one explicit argument. If
    the left operand in the overloaded operation is a user defined type in which modifications
    to the class can easily be made, implementing the operator function as a member
    function is reasonable and preferred.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为成员函数实现的运算符函数将接收一个隐式参数（`this`指针），最多一个显式参数。如果重载操作中的左操作数是可以轻松修改类的用户定义类型，则将运算符函数实现为成员函数是合理且首选的。
- en: Operator functions that are implemented as external functions will receive one
    or two explicit arguments. If the left operand in the overloaded operation is
    a standard type or a class type that is not modifiable, then an external (non-member)
    function must be used to overload this operator. This external function may need
    to be a `friend` of any object type that is used as the right-hand function argument.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为外部函数实现的运算符函数将接收一个或两个显式参数。如果重载操作中的左操作数是不可修改的标准类型或类类型，则必须使用外部（非成员）函数来重载此运算符。这个外部函数可能需要是用作右操作数的任何对象类型的“友元”。
- en: Operator functions should most often be implemented reciprocally. That is, when
    overloading a binary operator, ensure that it has been defined to work, no matter
    in which order the data types (should they differ) appear in the operator.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符函数通常应该被互相实现。也就是说，当重载二元运算符时，确保它已经被定义为可以工作，无论数据类型（如果它们不同）以何种顺序出现在运算符中。
- en: 'Let''s take a look at a full program example to illustrate the mechanics of
    operator overloading, including member and non-member functions, as well as scenarios
    requiring the usage of friends. Though some well-known portions of the program
    have been excluded to save space, the full program example can be found online
    in our GitHub repository:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个完整的程序示例，以说明运算符重载的机制，包括成员和非成员函数，以及需要使用友元的情况。尽管为了节省空间，程序的一些众所周知的部分已被排除在外，但完整的程序示例可以在我们的GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s begin with our code examination by first looking at the preceding class
    definition for `Person`. In addition to the class elements that we are accustomed
    to seeing, we have four operator functions prototyped: `operator=()`, `operator==()`,
    and `operator+()`, which is implemented twice – so that the operands to `+` can
    be reversed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代码审查开始，首先查看前面的`Person`类定义。除了我们习惯看到的类元素之外，我们还有四个运算符函数的原型：`operator=()`、`operator==()`和`operator+()`，它被实现了两次
    - 以便可以颠倒`+`的操作数。
- en: Functions for `operator=()`, `operator==()`, and one version of `operator+()`
    will be implemented as member functions of this class, whereas the other `operator+()`,
    with `const char *` and `Person` parameters, will be implemented as a non-member
    function and will additionally necessitate the use of a friend function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator=()`、`operator==()`和`operator+()`的一个版本将作为此类的成员函数实现，而另一个`operator+()`，带有`const
    char *`和`Person`参数，将作为非成员函数实现，并且还需要使用友元函数。'
- en: Overloading the assignment operator
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载赋值运算符
- en: 'Let''s move forward to examine the applicable operator function definitions
    for this class, starting by overloading the assignment operator:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查此类的适用运算符函数定义，首先是重载赋值运算符：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let us now review the overloaded assignment operator in the preceding code.
    It is designated by the member function `Person &Person::operator=(const Person
    &p);`. Here, we will be assigning memory from a source object, which will be an
    input parameter `p`, to a destination object, which will be pointed to by `this`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下前面代码中重载的赋值运算符。它由成员函数`Person &Person::operator=(const Person &p);`指定。在这里，我们将从源对象（输入参数`p`）分配内存到目标对象（由`this`指向）。
- en: Our first order of business will be to ensure that we are not assigning an object
    to itself. Should this be the case, there is no work to be done! We make this
    check by testing `if (this != &p)` to see whether both addresses point to the
    same object. If we're not assigning an object to itself, we continue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是确保我们没有将对象分配给自身。如果是这种情况，就没有工作要做！我们通过测试`if (this != &p)`来检查这一点，看看两个地址是否指向同一个对象。如果我们没有将对象分配给自身，我们继续。
- en: Next, within the conditional statement (`if`), we first deallocate the existing
    memory for the dynamically allocated data members pointed to by `this`. After
    all, the object on the left-hand side of the assignment pre-exists and undoubtedly
    has allocations for these data members.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在条件语句（`if`）中，我们首先释放由`this`指向的动态分配的数据成员的现有内存。毕竟，赋值语句左侧的对象已经存在，并且无疑为这些数据成员分配了内存。
- en: Now, we notice that the core piece of code within the conditional statement
    looks very similar to that of the copy constructor. That is, we carefully allocate
    space for pointer data members to match the sizes needed from their corresponding
    data members of the input parameter `p`. We then copy the applicable data members
    from input parameter `p` to the data members pointed to by `this`. For the `char`
    data member, `middleInitial`, memory allocation is not necessary; we merely use
    an assignment. In this segment of code, we ensure that we have performed a deep
    assignment. A shallow assignment, where the source and destination object would
    otherwise share memory for the data portions of data members that are pointers,
    would be a disaster waiting to happen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们注意到条件语句中的核心代码看起来与复制构造函数非常相似。也就是说，我们仔细为指针数据成员分配空间，以匹配输入参数`p`的相应数据成员所需的大小。然后，我们将适用的数据成员从输入参数`p`复制到由`this`指向的数据成员。对于`char`数据成员`middleInitial`，不需要内存分配；我们仅使用赋值。在这段代码中，我们确保已执行了深度赋值。浅赋值，其中源对象和目标对象否则会共享数据成员的内存部分的指针，将是一场等待发生的灾难。
- en: Lastly, at the end of our implementation of `operator=()`, we return `*this`.
    Notice that the return type from this function is a reference to a `Person`. Since
    `this` is a pointer, we merely dereference it so that we may return a referenceable
    object. This is done so that assignments between `Person` instances can be cascaded;
    that is, `p1 = p2 = p3;` where `p1`, `p2`, and `p3` are each an instance of `Person`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们对`operator=()`的实现结束时，我们返回`*this`。请注意，此函数的返回类型是`Person`的引用。由于`this`是一个指针，我们只需对其进行解引用，以便返回一个可引用的对象。这样做是为了使`Person`实例之间的赋值可以级联；也就是说，`p1
    = p2 = p3;`其中`p1`、`p2`和`p3`分别是`Person`的实例。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An overloaded assignment operator is not inherited by derived classes, therefore
    it must be defined by each class in the hierarchy. Neglecting to overload `operator=`
    for a class will force the compiler to provide you with a default, shallow assignment
    operator for that class; this is dangerous for any classes containing data members
    that are pointers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的赋值运算符不会被派生类继承，因此必须由层次结构中的每个类定义。如果忽略为类重载`operator=`，编译器将为该类提供默认的浅赋值运算符；这对于包含指针数据成员的任何类都是危险的。
- en: 'Should the programmer wish to disallow assignment between two objects, the
    keyword `delete` can be used in the prototype of the overloaded assignment operator
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员希望禁止两个对象之间的赋值，可以在重载的赋值操作符的原型中使用关键字`delete`。
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is useful to remember that the overloaded assignment operator shares many
    similarities with the copy constructor; the same care and cautions apply to both
    language features. Keep in mind, however, the assignment operator will be invoked
    when conducting an assignment between two pre-existing objects, whereas the copy
    constructor is implicitly invoked for initialization, following the creation of
    a new instance. With the copy constructor, the new instance uses the existing
    instance as its basis for initialization; similarly, the left-hand object of the
    assignment operator uses the right-hand object as its basis for the assignment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要记住，重载的赋值操作符与复制构造函数有许多相似之处；对这两种语言特性都需要同样的小心和谨慎。然而，赋值操作符将在两个已存在对象之间进行赋值时被调用，而复制构造函数在创建新实例后隐式被调用进行初始化。对于复制构造函数，新实例使用现有实例作为其初始化的基础；同样，赋值操作符的左操作数使用右操作数作为其赋值的基础。
- en: Overloading the comparison operator
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载比较操作符
- en: 'Next, let''s take a look at our implementation of the overloaded comparison
    operator:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们对重载比较操作符的实现：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Continuing with a segment from our previous program, we overload the comparison
    operator. It is designated by the member function `int Person::operator==(const
    Person &p);`. Here, we will be comparing a `Person` object on the right-hand side
    of the operator, which will be referenced by the input parameter `p`, to a `Person`
    object on the left-hand side of the operator, which will be pointed to by `this`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前程序的一部分，我们重载比较操作符。它由成员函数`int Person::operator==(const Person &p);`指定。在这里，我们将比较右操作数上的`Person`对象，它将由输入参数`p`引用，与左操作数上的`Person`对象进行比较，它将由`this`指向。
- en: Similarly, our first order of business will be to test whether the object on
    the `if (this != &p)` to see whether both addresses point to the same object.
    If both addresses point to the same object, we return the boolean (`bool`) value
    of `true`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的首要任务是测试`if (this != &p)`，看看两个地址是否指向同一个对象。如果两个地址指向同一个对象，我们返回`true`的布尔值。
- en: Next, we check whether the two `Person` objects contain identical values. They
    may be separate objects in memory, yet if they contain identical values, we can
    likewise choose to return a `bool` value of `true`. If there is no match, we then
    return a `bool` value of `false`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查两个`Person`对象是否包含相同的值。它们可能是内存中的不同对象，但如果它们包含相同的值，我们同样可以选择返回`true`的`bool`值。如果没有匹配，我们返回`false`的`bool`值。
- en: Overloading the addition operator as a member function
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为成员函数重载加法操作符
- en: 'Now, let''s take a look at how to overload `operator+` for `Person` and `const
    char *`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为`Person`和`const char *`重载`operator+`：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Moving forward with the preceding program, we overload the addition operator
    (`+`) to be used with a `Person` and a `const char *`. The operator function is
    designated by the member function prototype `Person& Person::operator+(const char
    *t);`. The parameter `t` will represent the right-hand operand of `operator+`,
    which is a character string. The left-hand operand will be pointed to by `this`.
    An example of its use would be `p1 + "Miss"`, where we wish to add a `title` to
    `Person` `p1` using `operator+`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的程序，我们重载加法操作符（`+`），用于`Person`和`const char *`。操作符函数由成员函数原型`Person& Person::operator+(const
    char *t);`指定。参数`t`代表`operator+`的右操作数，即一个字符串。左操作数将由`this`指向。一个例子是`p1 + "Miss"`，我们希望使用`operator+`给`Person
    p1`添加一个称号。
- en: In the body of this member function, we merely use the input parameter `t` as
    an argument to `ModifyTitle()`, that is, `ModifyTitle(t);`. We then return `*this`
    so that we may cascade the use of this operator (notice the return type is `Person
    &`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个成员函数的主体中，我们仅仅将输入参数`t`作为`ModifyTitle()`的参数使用，即`ModifyTitle(t);`。然后我们返回`*this`，以便我们可以级联使用这个操作符（注意返回类型是`Person
    &`）。
- en: Overloading the addition operator as a non-member function (using friends)
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为非成员函数重载加法操作符（使用友元）
- en: 'Now, let''s reverse the order of operands with `operator+` to allow for a `const
    char *` and a `Person`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们颠倒`operator+`的操作数顺序，允许`const char *`和`Person`：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Continuing forward with the preceding program, we would ideally like `operator+`
    to work not only with a `Person` and a `const char *`, but also with the operands
    reversed; that is, with a `const char *` and a `Person`. There is no reason this
    operator should work one way and not the other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的程序，我们理想地希望`operator+`不仅适用于`Person`和`const char *`，还适用于操作数的顺序颠倒；也就是说，`const
    char *`和`Person`。没有理由这个操作符只能单向工作。
- en: To implement `operator+` fully, we next overload `operator+()` to be used with
    `const char *` and `Person`. The operator function is designated by the non-member
    function `Person& operator+(const char *t, Person &p);`, which has two explicit
    input parameters. The first parameter, `t`, will represent the left operand of
    `operator+`, which is a character string. The second parameter, `p`, will be a
    reference to the right operand used in `operator+`. An example use might be `"Miss"
    + p1`, where we wish to add a title to `Person p1` using `operator+`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全实现`operator+`，接下来我们将重载`operator+()`，用于`const char *`和`Person`。操作符函数由非成员函数`Person&
    operator+(const char *t, Person &p);`指定，有两个显式输入参数。第一个参数`t`代表`operator+`的左操作数，即一个字符串。第二个参数`p`是用于`operator+`的右操作数的引用。一个例子是`"Miss"
    + p1`，我们希望使用`operator+`给`Person p1`添加一个称号。
- en: In the body of this non-member function, we merely take the input parameter
    `p` and apply the protected method `ModifyTitle()` using the string of characters
    specified by parameter `t`. That is, `p.ModifyTitle(t)`. However, because `Person::ModifyTitle()`
    is protected, `Person &p` may not invoke this method outside of member functions
    of `Person`. We are in an external function; we are not in the scope of `Person`.
    Therefore, unless this member function is a `friend` of `Person`, `p` may not
    invoke `ModifyTitle()`. Luckily, `Person &operator+(const char *, Person &);`
    has been prototyped as a friend function in the `Person` class, providing the
    necessary scope to `p` to allow it to invoke its protected method. It is as if
    `p` is in the scope of `Person`; it is in the scope of a friend function of `Person`!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非成员函数的主体中，我们只是取输入参数`p`，并使用参数`t`指定的字符串应用受保护的方法`ModifyTitle()`。也就是说，`p.ModifyTitle(t)`。然而，因为`Person::ModifyTitle()`是受保护的，`Person
    &p`不能在`Person`的成员函数之外调用这个方法。我们在一个外部函数中；我们不在`Person`的范围内。因此，除非这个成员函数是`Person`的`friend`，否则`p`不能调用`ModifyTitle()`。幸运的是，在`Person`类中已经将`Person
    &operator+(const char *, Person &);`原型化为`friend`函数，为`p`提供了必要的范围，使其能够调用它的受保护方法。就好像`p`在`Person`的范围内一样；它在`Person`的`friend`函数的范围内！
- en: 'Finally, let us move forward to our `main()` function, tying together our many
    aforementioned code segments, so we may see how to invoke our operator functions
    utilizing our overloaded operators:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们继续前进到我们的`main()`函数，将我们之前提到的许多代码段联系在一起，这样我们就可以看到如何调用我们的操作函数，利用我们重载的运算符：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, let us examine our `main()` function for the preceding program. We
    begin by instantiating three instances of `Person`, namely, `p1`, `p2`, and `p3`;
    we then print their values using the member function `Print()` for each instance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来检查一下前面程序的`main()`函数。我们首先实例化了三个`Person`的实例，即`p1`、`p2`和`p3`；然后我们使用成员函数`Print()`打印它们的值。
- en: 'Now, we invoke our overloaded assignment operator with the statement `p1 =
    p2;`. Under the hood, this translates to the following operator function invocation:
    `p1.operator=(p2);`. From this, we can clearly see that we are invoking the previously
    defined `operator=()` method of `Person`, which performs a deep copy from the
    source object `p2` to the destination object `p1`. We apply `p1.Print();` to see
    our resulting copy.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们用语句`p1 = p2;`调用了我们重载的赋值运算符。在底层，这转换成了以下的操作函数调用：`p1.operator=(p2);`。从这里，我们可以清楚地看到，我们正在调用之前定义的`Person`的`operator=()`方法，它从源对象`p2`深度复制到目标对象`p1`。我们应用`p1.Print();`来查看我们的复制结果。
- en: 'Next, we invoke our overloaded `operator+` with `"Ms." + p2`. This portion
    of this line of code translates to the following operator function call: `operator+("Ms.",
    p2);`. Here, we simply invoke our previously described `operator+()` function,
    which is a non-member function and `friend` of the `Person` class. Because this
    function returns a `Person &`, we can cascade this function call to look more
    like the usual context of addition and additionally write `p2 = "Ms." + p2;`.
    In this full line of code, first `operator+()` is invoked for `"Ms." + p2`. The
    return value of this invocation is `p2`, which is then used as the right-hand
    operand of the cascaded call to `operator=`. Notice that the left-hand operand
    to `operator=` also happens to be `p2`. Fortunately, the overloaded assignment
    operator checks for self-assignment.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用重载的`operator+`来处理`"Ms." + p2`。这行代码的一部分转换成以下的操作函数调用：`operator+("Ms.",
    p2);`。在这里，我们简单地调用了之前描述的`operator+()`函数，这是一个`Person`类的非成员函数和`friend`。因为这个函数返回一个`Person
    &`，我们可以将这个函数调用级联，看起来更像是通常的加法上下文，并且额外地写成`p2 = "Ms." + p2;`。在这行完整的代码中，首先对`"Ms."
    + p2`调用了`operator+()`。这个调用的返回值是`p2`，然后被用作级联调用`operator=`的右操作数。注意到`operator=`的左操作数也恰好是`p2`。幸运的是，重载的赋值运算符会检查自我赋值。
- en: Now, we see a cascaded assignment of `p1 = p2 = p3;`. Here, we are invoking
    the overloaded assignment operator twice. First, we invoke `operator=` with `p2`
    and `p3`. The translated call would be `p2.operator=(p3);`. Then, using the return
    value of the first function call, we would invoke `operator=` a second time. The
    nested, translated call for `p1 = p2 = p3;` would look like `p1.operator=(p2.operator=(p3));`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到了`p1 = p2 = p3;`的级联赋值。在这里，我们两次调用了重载的赋值运算符。首先，我们用`p2`和`p3`调用了`operator=`。翻译后的调用将是`p2.operator=(p3);`。然后，使用第一个函数调用的返回值，我们将第二次调用`operator=`。`p1
    = p2 = p3;`的嵌套、翻译后的调用看起来像`p1.operator=(p2.operator=(p3));`。
- en: Lastly, in this program, we invoke the overloaded comparison operator twice.
    For example, each comparison of `if (p2 == p2)` or `if (p1 == p3)` merely calls
    the `operator==` member function we have defined above. Recall, we've written
    this function to report `true` both if the objects are the same in memory or simply
    contain the same values, and return `false` otherwise.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个程序中，我们两次调用了重载的比较运算符。例如，每次比较`if (p2 == p2)`或`if (p1 == p3)`只是调用了我们上面定义的`operator==`成员函数。回想一下，我们已经编写了这个函数，如果对象在内存中相同或者只是包含相同的值，就报告`true`，否则返回`false`。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个程序的输出：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have now seen how to specify and utilize friend classes and friend functions,
    how to overload C++ operators, and cases when these two concepts can complement
    each other. Let us now briefly recap the features we have learned about in this
    chapter, before moving forward to our next chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何指定和使用友元类和友元函数，如何在C++中重载运算符，以及这两个概念如何互补。在继续前往下一章之前，让我们简要回顾一下我们在本章学到的特性。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have furthered our C++ programming endeavors beyond OOP
    language features to include features that will enable us to write more extensible
    programs. We have learned how to utilize friend functions and friend classes and
    we have learned how to overload operators in C++.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的C++编程努力进一步推进，超越了面向对象编程语言特性，包括了能够编写更具扩展性的程序的特性。我们已经学会了如何利用友元函数和友元类，以及如何在C++中重载运算符。
- en: We have seen that friend functions and classes should be used sparingly and
    with caution. They are not meant to provide a blatant means to go around access
    regions. Instead, they are meant to handle programming situations to allow access
    between two tightly coupled classes without providing the alternative of an *overly
    public* interface in either of those classes, which could be misused on a broader
    scale.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到友元函数和类应该谨慎使用。它们并不是为了提供一个明显的方法来绕过访问区域。相反，它们的目的是处理编程情况，允许两个紧密耦合的类之间进行访问，而不在这些类中的任何一个提供*过度公开*的接口，这可能会被广泛滥用。
- en: We have seen how to overload operators in C++ using operator functions, both
    as member and non-member functions. We have learned that overloading operators
    will allow us to extend the meaning of C++ operators to include user defined types
    in the same way they encompass standard types. We have also seen that in some
    cases, friend functions or classes may come in handy to help implement operator
    functions so they may behave associatively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在C++中使用运算符函数重载运算符，既作为成员函数又作为非成员函数。我们已经了解到，重载运算符将允许我们扩展C++运算符的含义，以包括用户定义类型，就像它们包含标准类型一样。我们还看到，在某些情况下，友元函数或类可能会派上用场，以帮助实现运算符函数，使其可以进行关联行为。
- en: We have added important features to our C++ repertoire through exploring friends
    and operator overloading, the latter of which will help us to ensure code we will
    soon write using templates can be used for nearly any data type, contributing
    to highly extensible and reusable code. We are now ready to move forward to [*Chapter
    13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486), *Working with Templates*,
    so that we can continue expanding our C++ programming skills with essential language
    features that will make us better programmers. Let's move ahead!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索友元和运算符重载，我们已经为我们的C++技能库添加了重要的功能，后者将帮助我们确保我们即将使用模板编写的代码可以用于几乎任何数据类型，从而为高度可扩展和可重用的代码做出贡献。我们现在准备继续前进到[*第13章*]，*使用模板*，以便我们可以继续扩展我们的C++编程技能，使用将使我们成为更好的程序员的基本语言特性。让我们继续前进！
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Overload `operator=` in your `Shape` exercise from [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*, or alternatively, overload `operator=` in your on-going
    `LifeForm`/`Person`/`Student` classes as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[*第8章*]（B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335）的`Shape`练习中重载`operator=`，*掌握抽象类*，或者在你正在进行的`LifeForm`/`Person`/`Student`类中重载`operator=`如下：
- en: 'a. Define `operator=` in `Shape` (or `LifeForm`) and override this method in
    all of its derived classes. Hint: the derived implementation of `operator=()`
    will do more work than its ancestor, yet could call its ancestor''s implementation
    to perform the base class part of the work.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在`Shape`（或`LifeForm`）中定义`operator=`，并在其所有派生类中重写这个方法。提示：`operator=()`的派生实现将比其祖先做更多的工作，但可以调用其祖先的实现来执行基类部分的工作。
- en: Overload `operator<<` in your `Shape` class (or `LifeForm` class) to print information
    about each `Shape` (or `LifeForm`). The arguments to this function should be `ostream
    &` and `Shape &` (or `LifeForm &`). Note that `ostream` is from the C++ standard
    library (`using namespace std;`).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Shape`类（或`LifeForm`类）中重载`operator<<`，以打印关于每个`Shape`（或`LifeForm`）的信息。这个函数的参数应该是`ostream
    &`和`Shape &`（或`LifeForm &`）。注意，`ostream`来自C++标准库（`using namespace std;`）。
- en: a. You may either provide one function, `ostream &operator<<(ostream &, Shape
    &);`, and from it call a polymorphic, `Print()`, which is defined in `Shape` and
    redefined in each derived class), or provide multiple `operator<<` methods to
    implement this functionality (one for each derived class). If using the `Lifeform`
    hierarchy, substitute `LifeForm` for `Shape`, above.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: a. 你可以提供一个函数`ostream &operator<<(ostream &, Shape &);`，并从中调用多态的`Print()`，它在`Shape`中定义，并在每个派生类中重新定义），或者提供多个`operator<<`方法来实现这个功能（每个派生类一个）。如果使用`Lifeform`层次结构，将`Shape`替换为`LifeForm`。
- en: 'Create an `ArrayInt` class to provide safe integer arrays with bounds checking.
    Overload `operator[]` to return an element if it exists in the array, or throw
    an exception if it is `OutOfBounds`. Add other methods to your `ArrayInt`, such
    as `Resize()`, and `RemoveElement()`. Model the data comprising the array using
    a dynamically allocated array (that is, using `int *contents`) so that you can
    easily handle resizing. The code would begin as:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ArrayInt`类，提供带边界检查的安全整数数组。重载`operator[]`，如果数组中存在元素，则返回该元素，否则抛出异常`OutOfBounds`。在你的`ArrayInt`中添加其他方法，比如`Resize()`和`RemoveElement()`。使用动态分配数组（即使用`int
    *contents`）来模拟数组的数据，这样你就可以轻松处理调整大小。代码将以以下方式开始：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
