- en: Packaging Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包项目
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Generating source and binary packages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成源代码和二进制包
- en: Distributing a C++/Python project built with CMake/pybind11 *via* PyPI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过PyPI分发使用CMake/pybind11构建的C++/Python项目
- en: Distributing a C/Fortran/Python project build with CMake/CFFI *via* PyPI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过PyPI分发使用CMake/CFFI构建的C/Fortran/Python项目
- en: Distributing a simple project as Conda package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单项目作为Conda包分发
- en: Distributing a project with dependencies as Conda package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将具有依赖项的项目作为Conda包分发
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Up to this point, we have compiled and installed (example) software packages
    "from sources" – this meant fetching the project *via* Git, and executing the
    configure, build, test, and install steps manually. However, in practice, software
    packages are often rather installed using package managers, such as Apt, DNF,
    Pacman, pip, and Conda. We need to be able to distribute our code projects in
    various formats: as source archives or as binary installer.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从源代码编译并安装（示例）软件包——这意味着通过Git获取项目，并手动执行配置、构建、测试和安装步骤。然而，在实践中，软件包通常使用包管理器（如Apt、DNF、Pacman、pip和Conda）进行安装。我们需要能够以各种格式分发我们的代码项目：作为源代码存档或作为二进制安装程序。
- en: 'This is what we refer to as packaging time in the now familiar scheme showing
    the various phases of a project using CMake:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在熟悉的CMake项目使用方案中提到的打包时间，显示了项目的各个阶段：
- en: '![](img/e63ce10f-4ef7-4d7d-a47d-56cffb9ee8b2.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e63ce10f-4ef7-4d7d-a47d-56cffb9ee8b2.jpg)'
- en: In this chapter, we will explore different packaging strategies. We will first
    discuss packaging using the tool CPack in the CMake family. We will also provide
    recipes for packaging and uploading CMake projects to the Python Package Index
    (PyPI, [https://pypi.org](https://pypi.org)) and the Anaconda Cloud ([https://anaconda.org](https://anaconda.org))
    – these are standard and popular platforms for distributing packages *via* the
    package managers pip and Conda ([https://conda.io/docs/](https://conda.io/docs/)),
    respectively. For PyPI, we will demonstrate how to package and distribute mixed
    C++/Python or C/Fortran/Python projects. For Conda, we will show how to package
    C++ projects with dependencies on other libraries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的打包策略。我们将首先讨论使用CMake家族中的工具CPack进行打包。我们还将提供将CMake项目打包并上传到Python Package
    Index（PyPI，[https://pypi.org](https://pypi.org））和Anaconda Cloud（[https://anaconda.org](https://anaconda.org)）的食谱——这些都是通过包管理器pip和Conda（[https://conda.io/docs/](https://conda.io/docs/））分发包的标准且流行的平台。对于PyPI，我们将演示如何打包和分发混合C++/Python或C/Fortran/Python项目。对于Conda，我们将展示如何打包依赖于其他库的C++项目。
- en: Generating source and binary packages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成源代码和二进制包
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01).
    The recipe is valid with CMake version 3.6 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01)找到。该食谱适用于CMake版本3.6（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'If your code is open source, users will expect to be able to download the sources
    for your project and build by themselves using your perfectly tailored CMake scripts.
    Of course, the packaging operation could be done with a script, but CPack offers
    a more compact and portable alternative. This recipe will guide you through the
    creation of a number of packaging alternatives:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码是开源的，用户将期望能够下载您项目的源代码，并使用您精心定制的CMake脚本自行构建。当然，打包操作可以用脚本完成，但CPack提供了更紧凑和便携的替代方案。本食谱将指导您创建多种打包替代方案：
- en: '**Source code archives:** You can use these formats to ship the source code
    directly as a compressed archive in your favorite format. Your users will not
    have to worry about your specific version control system.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码存档**：您可以使用这些格式直接将源代码作为您喜欢的格式的压缩存档发货。您的用户不必担心您的特定版本控制系统。'
- en: '**Binary archives:** Use these to package the freshly built targets into compressed
    archives in your favorite format. These can be extremely useful, but might not
    be robust enough to distribute libraries and executables.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制存档**：使用这些格式将新构建的目标打包成您喜欢的格式的压缩存档。这些可能非常有用，但可能不足以分发库和可执行文件。'
- en: '**Platform-native binary installers:** CPack is able to generate binary installers
    in many different formats, so you can target the distribution of your software
    to many different platforms. In particular, we will show how to generate installers:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台原生二进制安装程序**：CPack能够生成多种不同格式的二进制安装程序，因此您可以将软件分发目标定位到许多不同的平台。特别是，我们将展示如何生成安装程序：'
- en: In `.deb` format for Debian-based GNU/Linux distributions: [https://manpages.debian.org/unstable/dpkg-dev/deb.5.en.html](https://manpages.debian.org/unstable/dpkg-dev/deb.5.en.html)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`.deb`格式为Debian基础的GNU/Linux发行版：[https://manpages.debian.org/unstable/dpkg-dev/deb.5.en.html](https://manpages.debian.org/unstable/dpkg-dev/deb.5.en.html)
- en: In `.rpm` format for Red Hat-based GNU/Linux distributions: [http://rpm.org/](http://rpm.org/)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`.rpm`格式为Red Hat基础的GNU/Linux发行版：[http://rpm.org/](http://rpm.org/)
- en: In `.dmg` format for macOS Bundles: [https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`.dmg`格式为macOS捆绑包：[https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html)
- en: 'In NSIS format for Windows: [http://nsis.sourceforge.net/Main_Page](http://nsis.sourceforge.net/Main_Page)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以NSIS格式为Windows：[http://nsis.sourceforge.net/Main_Page](http://nsis.sourceforge.net/Main_Page)
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the source code for the `message` library presented in [Chapter
    10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml), *Writing an Installer*, Recipe
    3, *Exporting your targets*. The project tree consists of the following directories
    and files:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第10章[72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml]中介绍的`message`库的源代码，*编写安装程序*，第3个配方，*导出目标*。项目树由以下目录和文件组成：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since the emphasis in this recipe will be on effective usage of CPack, we will
    not comment on the source code itself. We will only add packaging directives in
    `CMakeCPack.cmake`, which we will discuss in a moment. In addition, we have added
    `INSTALL.md` and a  `LICENSE` file: they contain installation instructions and
    the license for the project and are required by the packaging directives.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本配方的重点将是有效使用CPack，我们将不对源代码本身进行评论。我们只会在`CMakeCPack.cmake`中添加打包指令，我们将在稍后讨论。此外，我们添加了`INSTALL.md`和一个`LICENSE`文件：它们包含项目安装说明和许可证，并且是打包指令所必需的。
- en: How to do it
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us look at the packaging directives that need to be added to this project.
    We will collect them in `CMakeCPack.cmake`, which is included at the end of `CMakeLists.txt`
    using `include(CMakeCPack.cmake)`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看需要添加到此项目的打包指令。我们将它们收集在`CMakeCPack.cmake`中，该文件在`CMakeLists.txt`的末尾使用`include(CMakeCPack.cmake)`包含：
- en: 'We declare the name of the package. This is the same as the name of the project
    and hence we use the `PROJECT_NAME` CMake variable:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明包的名称。这与项目名称相同，因此我们使用`PROJECT_NAME` CMake变量：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We declare the package vendor:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了包的供应商：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The packaged sources will include a description file. This is the plain-text
    file with the installation instructions:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包的源代码将包括一个描述文件。这是包含安装说明的纯文本文件：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also add a brief summary of the package:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了包的简要概述：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The license file will also be included in the package:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许可证文件也将包含在包中：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When installing from the distributed package, the files will be placed in the
    `/opt/recipe-01` directory:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分发的包中安装时，文件将被放置在`/opt/recipe-01`目录中：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The major, minor, and patch versions of the packages are set as variables for
    CPack:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包的主版本、次版本和补丁版本设置为CPack的变量：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We set a list of files and directories to be ignored during the packaging operations:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一组文件和目录，以在打包操作期间忽略：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We list the packaging generators for source code archives – in our case `ZIP`,
    to generate a `.zip` archive, and `TGZ`, for a `.tar.gz` archive.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们列出了源代码存档的打包生成器——在我们的例子中是`ZIP`，用于生成`.zip`存档，以及`TGZ`，用于`.tar.gz`存档。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also list the binary archive generators:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还列出了二进制存档生成器：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now declare also the platform-native binary installers, starting with the
    DEB and RPM package generators, only available for GNU/Linux:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在还声明了平台原生的二进制安装程序，从DEB和RPM包生成器开始，仅适用于GNU/Linux：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we are on Windows, we will want to generate an NSIS installer:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用的是Windows，我们将希望生成一个NSIS安装程序：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, on macOS, a bundle is our installer of choice:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，在macOS上，捆绑包是我们的首选安装程序：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We print an informative message to the user on the packaging generators available
    on the current system:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向用户打印有关当前系统上可用的包装生成器的信息性消息：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we include the `CPack.cmake` standard module. This will add a `package` and
    a `package_source` target to the build system:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们包含了`CPack.cmake`标准模块。这将向构建系统添加一个`package`和一个`package_source`目标：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now configure the project as usual:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样配置项目：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the following command, we can list the available targets (the example
    output is obtained on a GNU/Linux system with Unix Makefiles as generator):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，我们可以列出可用的目标（示例输出是在使用Unix Makefiles作为生成器的GNU/Linux系统上获得的）：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that the `package` and `package_source` targets are available. The
    source packages can be generated with the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`package`和`package_source`目标可用。源包可以通过以下命令生成：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we can build the binary packages:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以构建二进制包：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, in our case, we obtained the following list of binary packages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们获得了以下二进制包列表：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'CPack can be used to generate many different types of packages for distribution.
    When generating the build system, the CPack instructions we listed in `CMakeCPack.cmake`
    are used to generate a `CPackConfig.cmake` file in the build directory. When running
    the CMake command for the `package` or `package_source` targets, CPack is automatically
    invoked with the autogenerated configuration file as argument. Indeed, these two
    new targets are simple rules that wrap calls to CPack. Much as CMake, CPack also
    has a concept of generators. Whereas generators in the context of CMake are the
    tools that will be used to generate the native build scripts, for example, Unix
    Makefiles or Visual Studio project files, in the context of CPack these are the
    tools to be used for packaging. We listed these, exercising particular care for
    the different platforms, using the `CPACK_SOURCE_GENERATOR` and the `CPACK_GENERATOR`
    variables for the source and binary packages, respectively. Thus the Debian packaging
    utilities will be invoked for the `DEB` package generator, whereas the appropriate
    archiving tool on the given platform will be invoked for the `TGZ` generator.
    We can invoke CPack directly from the `build` directory and select which generator
    to use with the `-G` command-line option. The RPM package can be generated with
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CPack可以用来生成许多不同类型的包用于分发。在生成构建系统时，我们在`CMakeCPack.cmake`中列出的CPack指令用于在构建目录中生成一个`CPackConfig.cmake`文件。当运行CMake命令为`package`或`package_source`目标时，CPack会自动使用自动生成的配置文件作为参数调用。确实，这两个新目标只是简单地包装了对CPack的调用。就像CMake一样，CPack也有生成器的概念。在CMake的上下文中，生成器是用于生成原生构建脚本的工具，例如Unix
    Makefiles或Visual Studio项目文件，而在CPack的上下文中，这些是用于打包的工具。我们列出了这些，特别注意不同的平台，使用`CPACK_SOURCE_GENERATOR`和`CPACK_GENERATOR`变量为源和二进制包。因此，Debian打包工具将被调用用于`DEB`包生成器，而在给定平台上适当的存档工具将被调用用于`TGZ`生成器。我们可以直接从`build`目录调用CPack，并使用`-G`命令行选项选择要使用的生成器。RPM包可以通过以下方式生成：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For any distribution, be it source or binary, we need to package only those
    contents that will be strictly necessary for the end user, hence the entire build
    directory and any other file related to version control will have to be excluded
    from the list of files to be packaged. In our example, the exclusion list was
    declared with the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何分发，无论是源还是二进制，我们只需要打包最终用户严格需要的那些内容，因此整个构建目录和与版本控制相关的任何其他文件都必须从要打包的文件列表中排除。在我们的示例中，排除列表是通过以下命令声明的：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also need to specify basic information about our package, such as the name,
    a short description, and the version. This information is set by means of CMake
    variables, which are then passed on to CPack when including the corresponding
    module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定有关我们包的基本信息，例如名称、简短描述和版本。这些信息是通过CMake变量设置的，然后在包含相应的模块时传递给CPack。
- en: Since CMake 3.9 the `project()` command accepts a `DESCRIPTION` field, with
    a short string describing the project. CMake will set a `PROJECT_DESCRIPTION`
    which can be reused to set the `CPACK_PACKAGE_DESCRIPTION_SUMMARY`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自CMake 3.9起，`project()`命令接受一个`DESCRIPTION`字段，其中包含对项目的简短描述。CMake将设置一个`PROJECT_DESCRIPTION`，可以用来设置`CPACK_PACKAGE_DESCRIPTION_SUMMARY`。
- en: Let us look in detail at the instructions for the different kinds of packages
    we can generate for our example project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看我们为示例项目可以生成的不同类型的包的说明。
- en: Source archives
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码存档
- en: 'In our example, we decided to use the `TGZ` and `ZIP` generators for the source
    archive. These will result in `.tar.gz` and `.zip` archives, respectively. We
    can inspect the contents of the generated `.tar.gz` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们决定为源归档使用`TGZ`和`ZIP`生成器。这将分别产生`.tar.gz`和`.zip`归档文件。我们可以检查生成的`.tar.gz`文件的内容：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, only the contents of the source tree are included. Notice that
    the `INSTALL.md` and `LICENSE` files are also included, as specified by means
    of the `CPACK_PACKAGE_DESCRIPTION_FILE` and `CPACK_RESOURCE_FILE_LICENSE` variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，只有源树的内容被包括在内。注意，`INSTALL.md`和`LICENSE`文件也被包括在内，这是通过`CPACK_PACKAGE_DESCRIPTION_FILE`和`CPACK_RESOURCE_FILE_LICENSE`变量指定的。
- en: 'The `package_source` target is not understood by the Visual Studio family of
    generators: [https://gitlab.kitware.com/cmake/cmake/issues/13058](https://gitlab.kitware.com/cmake/cmake/issues/13058).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`package_source`目标不被Visual Studio系列的生成器理解：[https://gitlab.kitware.com/cmake/cmake/issues/13058](https://gitlab.kitware.com/cmake/cmake/issues/13058)。'
- en: Binary archives
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制归档文件
- en: 'When creating binary archives, CPack will package the contents of the targets
    described in our `CMakeCPack.cmake` file as described by the installation instructions.
    Thus in our example the hello-world executable, the message shared library, and
    the corresponding header files will all be packaged in the `.tar.gz` and `.zip`
    formats. In addition, also the CMake configuration files will be packaged. This
    is very useful for other projects that will need to link against our library.
    The installation prefix used in the package may differ from the one used when
    installing the project from the build tree. The `CPACK_PACKAGING_INSTALL_PREFIX`
    variable may be used to achieve this. In our example, we set it to a specific
    location on the system: `/opt/recipe-01`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建二进制归档文件时，CPack将根据我们的`CMakeCPack.cmake`文件中描述的安装说明，将目标的内容打包。因此，在我们的示例中，hello-world可执行文件、消息共享库以及相应的头文件都将被打包在`.tar.gz`和`.zip`格式中。此外，CMake配置文件也将被打包。这对于需要链接到我们库的其他项目非常有用。在包中使用的安装前缀可能与从构建树安装项目时使用的前缀不同。可以使用`CPACK_PACKAGING_INSTALL_PREFIX`变量来实现这一点。在我们的示例中，我们将其设置为系统上的特定位置：`/opt/recipe-01`。
- en: 'We can analyze the contents of the generated `.tar.gz` archive:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分析生成的`.tar.gz`归档文件的内容：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Platform-native binary installers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台原生二进制安装程序
- en: We expect the configuration for each platform-native binary installer to be
    slightly different. These differences can be managed with CPack within a single
    `CMakeCPack.cmake`, as we have done in our example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计每个平台原生二进制安装程序的配置会有所不同。这些差异可以在一个`CMakeCPack.cmake`中通过CPack进行管理，正如我们在示例中所做的那样。
- en: 'For GNU/Linux, the stanza configures both the `DEB` and `RPM` generators:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GNU/Linux，该节配置了`DEB`和`RPM`生成器：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our example depends on the UUID library, and the `CPACK_DEBIAN_PACKAGE_DEPENDS`
    and `CPACK_RPM_PACKAGE_REQUIRES` options let us specify dependencies between our
    package and others in the database. We can use the `dpkg` and `rpm` programs to
    analyze the contents of the generated `.deb` and `.rpm` packages, respectively.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例依赖于UUID库，`CPACK_DEBIAN_PACKAGE_DEPENDS`和`CPACK_RPM_PACKAGE_REQUIRES`选项允许我们在我们的包和其他数据库中的包之间指定依赖关系。我们可以使用`dpkg`和`rpm`程序分别分析生成的`.deb`和`.rpm`包的内容。
- en: 'Note that `CPACK_PACKAGING_INSTALL_PREFIX` also affects these package generators:
    our package will be installed to `/opt/recipe-01`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CPACK_PACKAGING_INSTALL_PREFIX`也会影响这些包生成器：我们的包将被安装到`/opt/recipe-01`。
- en: 'CMake truly provides support for cross-platform and portable build systems.
    The following stanza will create an installer using the Nullsoft Scriptable Install
    System (NSIS):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CMake确实提供了对跨平台和便携式构建系统的支持。以下节将使用Nullsoft Scriptable Install System（NSIS）创建一个安装程序：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the following stanza will enable the Bundle packager if we are building
    the project on macOS:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们正在macOS上构建项目，以下节将启用Bundle打包器：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the macOS example, we first need to configure a property list file for the
    package, something achieved by the `configure_file` command. The location of `Info.plist`
    and the icon for the package are then set as variables for CPack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS示例中，我们首先需要为包配置一个属性列表文件，这可以通过`configure_file`命令实现。然后，`Info.plist`的位置和包的图标被设置为CPack的变量。
- en: 'You can read more about the property list format here: [https://en.wikipedia.org/wiki/Property_list](https://en.wikipedia.org/wiki/Property_list).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于属性列表格式的信息：[https://en.wikipedia.org/wiki/Property_list](https://en.wikipedia.org/wiki/Property_list)。
- en: There is more
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Instead of listing the CPack configuration settings in `CMakeCPack.cmake` as
    we have done for simplicity, we could have placed the per-generator settings of
    `CPACK_*` variables in a separate file, such as `CMakeCPackOptions.cmake`, and
    included these settings into `CMakeCPack.cmake` using `set(CPACK_PROJECT_CONFIG_FILE
    "${PROJECT_SOURCE_DIR}/CMakeCPackOptions.cmake")`.  This file can also be configured
    at CMake time and then included at CPack time, providing a clean way to configure
    multi-format package generators (see also: [https://cmake.org/cmake/help/v3.6/module/CPack.html](https://cmake.org/cmake/help/v3.6/module/CPack.html)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有像之前为了简化而将CPack配置设置列在`CMakeCPack.cmake`中，而是可以将`CPACK_*`变量的每个生成器设置放在一个单独的文件中，例如`CMakeCPackOptions.cmake`，并使用`set(CPACK_PROJECT_CONFIG_FILE
    "${PROJECT_SOURCE_DIR}/CMakeCPackOptions.cmake")`将这些设置包含到`CMakeCPack.cmake`中。这个文件也可以在CMake时配置，然后在CPack时包含，提供了一种干净的方式来配置多格式包生成器（另请参见：[https://cmake.org/cmake/help/v3.6/module/CPack.html](https://cmake.org/cmake/help/v3.6/module/CPack.html)）。
- en: As with all tools in the CMake family, CPack is powerful and versatile and offers
    much more flexibility and options than what we have shown in this recipe. The
    interested reader should read the official documentation for the command-line
    interface to CPack ([https://cmake.org/cmake/help/v3.6/manual/cpack.1.html](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01))
    and the manual pages, which detail the additional generators that CPack knows
    how to use to package projects ([https://cmake.org/cmake/help/v3.6/module/CPack.html](https://cmake.org/cmake/help/v3.6/module/CPack.html)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与CMake家族中的所有工具一样，CPack功能强大且多才多艺，提供了比本食谱中展示的更多的灵活性和选项。感兴趣的读者应阅读CPack的官方文档，了解命令行界面的详细信息（[https://cmake.org/cmake/help/v3.6/manual/cpack.1.html](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-01)）以及详细介绍CPack如何使用额外生成器打包项目的man页面（[https://cmake.org/cmake/help/v3.6/module/CPack.html](https://cmake.org/cmake/help/v3.6/module/CPack.html)）。
- en: Distributing a C++/Python project built with CMake/pybind11 via PyPI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过PyPI分发使用CMake/pybind11构建的C++/Python项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-02).
    The recipe is valid with CMake version 3.11 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-02)找到。该食谱适用于CMake版本3.11（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will take the pybind11 example from [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 5, *Building C++ and Python projects using pybind11*, as a starting
    point, add relevant install targets and pip packaging information and upload the
    project to PyPI. Our goal will be to arrive at a project that can be installed
    using pip and runs CMake and fetches the pybind11 dependency under the hood.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将以[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，第5个食谱，*使用pybind11构建C++和Python项目*中的pybind11示例为起点，添加相关的安装目标和pip打包信息，并将项目上传到PyPI。我们的目标将是得到一个可以使用pip安装的项目，并在幕后运行CMake并获取pybind11依赖项。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To distribute a package *via *PyPI, you will need a user account at [https://pypi.org](https://pypi.org),[ ](https://pypi.org)but
    it is possible to first exercise with installations from a local path.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过PyPI分发包，您需要在[https://pypi.org](https://pypi.org)上注册一个用户账户，但也可以先从本地路径进行安装练习。
- en: We also generally recommend to install this and other Python packages with pip
    using either Pipenv ([https://docs.pipenv.org](https://docs.pipenv.org/)) or Virtual
    Environments ([https://virtualenv.pypa.io/en/stable/](https://virtualenv.pypa.io/en/stable/))
    instead of installing them into the system environment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还普遍建议使用pip安装此包和其他Python包，使用Pipenv（[https://docs.pipenv.org](https://docs.pipenv.org/)）或虚拟环境（[https://virtualenv.pypa.io/en/stable/](https://virtualenv.pypa.io/en/stable/)）而不是安装到系统环境中。
- en: 'Our starting point is the pybind11 example from [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 5, *Building C++ and Python projects using pybind11*, which
    contains a top-level `CMakeLists.txt` file and an `account/CMakeLists.txt` file
    that configures the account example targets and uses the following project tree:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点是来自[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，第5个食谱，*使用pybind11构建C++和Python项目*的pybind11示例，其中包含一个顶级`CMakeLists.txt`文件和一个`account/CMakeLists.txt`文件，该文件配置了账户示例目标并使用以下项目树：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this recipe, we will keep `account.cpp`, `account.hpp`, and the `test.py`
    script unchanged. We will modify `account/CMakeLists.txt` and add a couple of
    files for pip to be able to build and install the package. For this, we will require
    three additional files in the root directory: `README.rst`, `MANIFEST.in`, and `setup.py`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将保持`account.cpp`，`account.hpp`和`test.py`脚本不变。我们将修改`account/CMakeLists.txt`并添加一些文件，以便pip能够构建和安装包。为此，我们需要在根目录中添加三个额外的文件：`README.rst`，`MANIFEST.in`和`setup.py`。
- en: '`README.rst` contains documentation about the project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.rst`包含有关项目的文档：'
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`MANIFEST.in` lists files that should be installed along the Python modules
    and packages:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`列出了应与Python模块和包一起安装的文件：'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And, finally, `setup.py` contains instructions for building and installing
    the project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`setup.py`包含构建和安装项目的指令：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will place `__init__.py` into the `account` subdirectory:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`__init__.py`放入`account`子目录中：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will also place `version.py` into the `account` subdirectory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把`version.py`放入`account`子目录中：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This means that we will arrive at the following file structure for our project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的项目将具有以下文件结构：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'This recipe builds on top of [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 5, *Building C++ and Python projects using pybind11*. Let us
    see how in detail:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方建立在[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，配方5，*使用pybind11构建C++和Python项目*的基础上。让我们详细看看：
- en: 'First, we extend `account/CMakeLists.txt`. The only addition is the last directive,
    which specifies the install target:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们扩展`account/CMakeLists.txt`。唯一的添加是最后一个指令，它指定了安装目标：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And that''s it! With the install target and the `README.rst`, `MANIFEST.in`,
    `setup.py`, `__init__.py`, and `version.py` files in place, we are ready to test
    the installation of our example code which is interfaced using pybind11:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！有了安装目标和`README.rst`，`MANIFEST.in`，`setup.py`，`__init__.py`和`version.py`文件，我们就可以测试使用pybind11接口的示例代码的安装了：
- en: For this, create a new directory somewhere on your computer and we will test
    the installation there.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在你的计算机上创建一个新的目录，我们将在那里测试安装。
- en: 'Inside the newly created directory, we run `pipenv install` from a local path.
    Adjust the local path to point to the directory that holds the `setup.py` script:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的目录中，我们从本地路径运行`pipenv install`。调整本地路径以指向包含`setup.py`脚本的目录：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we spawn a Python shell inside the Pipenv environment:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在Pipenv环境中启动一个Python shell：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the Python shell, we can test our CMake package:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python shell中，我们可以测试我们的CMake包：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `${CMAKE_CURRENT_BINARY_DIR}` directory contains the compiled `account.cpython-36m-x86_64-linux-gnu.so` Python
    module built using pybind11, but note that its name depends on the operating system
    (in this case, 64-bit Linux) and the Python environment (in this case, Python
    3.6). The `setup.py` script will run CMake under the hood and install the Python
    module into the correct path, depending on the selected Python environment (system
    Python or Pipenv or Virtual Environment). But now we have two challenges when
    installing the module:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`${CMAKE_CURRENT_BINARY_DIR}`目录包含使用pybind11编译的`account.cpython-36m-x86_64-linux-gnu.so`Python模块，但请注意，其名称取决于操作系统（在这种情况下，64位Linux）和Python环境（在这种情况下，Python
    3.6）。`setup.py`脚本将在后台运行CMake，并将Python模块安装到正确的路径，具体取决于所选的Python环境（系统Python或Pipenv或虚拟环境）。但现在我们在安装模块时面临两个挑战：'
- en: The naming can change.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名可能会改变。
- en: The path is set outside of CMake.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径是在CMake之外设置的。
- en: 'We can solve this by using the following install target, where `setup.py` will
    define the install target location:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下安装目标来解决这个问题，其中`setup.py`将定义安装目标位置：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we instruct CMake to install the compiled Python module file into the `account` subdirectory
    relative to the install target location ([Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*, discusses in detail how the target location can be set). The
    latter will be set by `setup.py` by defining `CMAKE_INSTALL_PREFIX` to point to
    the right path depending on the Python environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指导CMake将编译后的Python模块文件安装到相对于安装目标位置的`account`子目录中（[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*，详细讨论了如何设置目标位置）。后者将由`setup.py`通过定义`CMAKE_INSTALL_PREFIX`指向正确的路径，这取决于Python环境。
- en: 'Let us now inspect how we achieve this in `setup.py`; we will start from the
    bottom of the script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下我们是如何在`setup.py`中实现这一点的；我们将从脚本的底部开始：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The script contains a number of placeholders and hopefully self-explaining
    directives, but here we will focus on the last directive, `cmdclass`, where we
    extend the default build step by a custom function, which we call `extend_build`.
    This function subclasses the default build step:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含多个占位符和希望自我解释的指令，但我们将重点关注最后一个指令`cmdclass`，在这里我们通过一个自定义函数扩展默认的构建步骤，我们称之为`extend_build`。这个函数是默认构建步骤的子类：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, the function checks whether CMake is available on the system. The core
    of the function executes two CMake commands:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该函数检查系统上是否安装了CMake。函数的核心执行两个CMake命令：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here we have the possibility to change the default generator used by setting
    the `CMAKE_GENERATOR` environment variable. The install prefix is defined as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过设置`CMAKE_GENERATOR`环境变量来更改默认的生成器。安装前缀定义如下：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `get_python_lib` function imported from `distutils.sysconfig` provides the
    root directory for the install prefix. The `cmake --build _build_dir --target
    install` command builds and installs our project in one step in a portable way.
    The reason why we use the name `_build_dir` instead of simply `build` is that
    your project might already contain a `build` directory when testing the local
    install, which would conflict with a fresh installation. For packages already
    uploaded to PyPI, the name of the build directory does not make a difference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`distutils.sysconfig`导入的`get_python_lib`函数提供了安装前缀的根目录。`cmake --build _build_dir
    --target install`命令以可移植的方式一步构建并安装我们的项目。我们使用名称`_build_dir`而不是简单的`build`的原因是，在测试本地安装时，您的项目可能已经包含一个`build`目录，这会与新安装发生冲突。对于已经上传到PyPI的包，构建目录的名称并不重要。'
- en: There is more
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容。
- en: Now that we have the local install tested, we are ready to upload the package
    to PyPI. But, before we do that, make sure that the metadata in `setup.py` (such
    as the name of the project, and the contact and license information) is reasonable,
    and that the project name is not already taken on PyPI. It is also good practice
    to first test upload to and download from the PyPI test instance ([https://test.pypi.org](https://test.pypi.org))
    before uploading to [https://pypi.org](https://pypi.org).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了本地安装，我们准备将包上传到PyPI。但是，在这样做之前，请确保`setup.py`中的元数据（如项目名称、联系信息和许可证信息）是合理的，并且项目名称在PyPI上尚未被占用。在将包上传到[https://pypi.org](https://pypi.org)之前，先测试上传到PyPI测试实例[https://test.pypi.org](https://test.pypi.org)并下载，这是一个良好的实践。
- en: 'Before the upload, we need to create a file called `.pypirc` in the home directory
    containing (replace `yourusername` and `yourpassword`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传之前，我们需要在主目录中创建一个名为`.pypirc`的文件，其中包含（替换`yourusername`和`yourpassword`）：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will proceed in two steps. First, we create the distribution locally:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步进行。首先，我们在本地创建分发：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the second step, we upload the generated distribution data using Twine (we
    install Twine into a local Pipenv):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用Twine（我们将其安装到本地Pipenv中）上传生成的分发数据：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As a next step, try to install from the test instance into an isolated environment:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试从测试实例安装到一个隔离的环境中：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once this is working, we are ready to upload to production PyPI:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个工作正常，我们就可以准备上传到生产PyPI了：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Distributing a C/Fortran/Python project build with CMake/CFFI via PyPI
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过PyPI分发使用CMake/CFFI构建的C/Fortran/Python项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-03) and
    has a C++ and Fortran example. The recipe is valid with CMake version 3.5 (and
    higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-03)找到，并包含C++和Fortran示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: This recipe is a mashup of the previous recipe and [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects, *Recipe 6, *Mixing C, C++, Fortran, and Python using Python CFFI*. We
    will reuse many building blocks from the previous recipe, but instead of using
    pybind11, we will use Python CFFI to provide the Python interface. In this recipe,
    our goal is to share a Fortran project *via* PyPI, but instead of Fortran, it
    could equally be a C or C++ project or any language exposing a C interface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是之前的配方和[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目，*配方6，*使用Python
    CFFI混合C、C++、Fortran和Python*的混合体。我们将重用之前配方的许多构建块，但不是使用pybind11，而是使用Python CFFI来提供Python接口。在这个配方中，我们的目标是通过PyPI共享一个Fortran项目，但它同样可以是C或C++项目，或者任何暴露C接口的语言项目。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start out with the following file tree:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下文件树开始：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The top-level `CMakeLists.txt` file and all sources below `account`, except `account/CMakeLists.txt`,
    are unchanged from how they appeared in [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 6, *Mixing C, C++, Fortran, and Python using Python CFFI*. We
    will shortly discuss the small changes we need to apply to `account/CMakeLists.txt`.
    The `README.rst` file is identical with the previous recipe. The `setup.py` script
    contains one extra line compared to the previous recipe (the line containing `install_requires=[''cffi''])`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级的`CMakeLists.txt`文件和`account`下的所有源文件，除了`account/CMakeLists.txt`，与[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，配方6，*使用Python
    CFFI混合C、C++、Fortran和Python*中出现的方式相同。我们很快会讨论需要应用到`account/CMakeLists.txt`的小改动。`README.rst`文件与之前的配方相同。`setup.py`脚本与之前的配方相比包含一条额外的行（包含`install_requires=['cffi']`的行）：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`MANIFEST.in` lists files that should be installed along with the Python modules
    and packages and contains the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`列出了应与Python模块和包一起安装的文件，并包含以下内容：'
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Under the `account` subdirectory, we see two new files. Again, there is a `version.py`
    file holding the project version for `setup.py`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`account`子目录下，我们看到了两个新文件。同样，有一个`version.py`文件，它保存了`setup.py`的项目版本：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The subdirectory also holds the `interface_file_names.cfg.in` file, which we
    will be discussing soon:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 子目录还包含`interface_file_names.cfg.in`文件，我们很快就会讨论它：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How to do it
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let usdiscuss the steps necessary to achieve the packaging:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论实现打包所需的步骤：
- en: 'We extend `account/CMakeLists.txt` from [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 6, *Mixing C, C++, Fortran, and Python using Python CFFI*. The
    only additions are the following directives:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们扩展了[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，配方6，*使用Python
    CFFI混合C、C++、Fortran和Python*中的`account/CMakeLists.txt`。唯一的添加指令如下：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And that's it! With the install target and the additional files in place, we
    are ready to test the installation. For this, create a new directory somewhere
    on your computer and we will test the installation there.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！安装目标和附加文件就位后，我们就可以开始测试安装了。为此，在你的电脑上创建一个新的目录，我们将在那里进行安装测试。
- en: 'Inside the newly created directory, we run `pipenv install` from a local path.
    Adjust the local path to point to the directory that holds the `setup.py` script:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的目录中，我们从本地路径运行`pipenv install`。调整本地路径以指向包含`setup.py`脚本的目录：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we spawn a Python shell inside the Pipenv environment:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在Pipenv环境中启动一个Python shell：
- en: '[PRE56]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Inside the Python shell, we can test our CMake package:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python shell中，我们可以测试我们的CMake包：
- en: '[PRE57]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The extension to install mixed-language projects using Python CFFI and CMake
    compared to [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, Recipe 6, *Mixing C, C++, Fortran, and Python using Python CFFI* consists
    of two additional steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，配方6，*使用Python CFFI混合C、C++、Fortran和Python*相比，使用Python
    CFFI和CMake安装混合语言项目的扩展包括两个额外步骤：
- en: We require the `setup.py` layer.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`setup.py`层。
- en: We install targets such that the header files and the shared library file(s)
    required by the CFFI layer are installed in the correct paths depending on the
    selected Python environment.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装目标，以便CFFI层所需的头文件和共享库文件根据所选Python环境安装在正确的路径中。
- en: 'The structure of `setup.py` is almost identical to the previous recipe, and
    we refer you to the previous recipe for a discussion of this file. The only addition
    was a line containing `install_requires=[''cffi'']` to make sure that installing
    our example package also fetches and installs the required Python CFFI. The `setup.py`
    script will automatically install `__init__.py` and `version.py`, since these
    are referenced from the `setup.py` script.  `MANIFEST.in` is slightly changed
    to package not only `README.rst` and CMake files, but also the header and Fortran
    source files:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`的结构与之前的食谱几乎相同，我们请您参考之前的食谱来讨论这个文件。唯一的增加是包含`install_requires=[''cffi'']`的行，以确保安装我们的示例包也会获取并安装所需的Python
    CFFI。`setup.py`脚本将自动安装`__init__.py`和`version.py`，因为这些是从`setup.py`脚本引用的。`MANIFEST.in`稍作修改，以打包不仅包括`README.rst`和CMake文件，还包括头文件和Fortran源文件：'
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We have three challenges in this recipe to package a CMake project that uses
    Python CFFI with `setup.py`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将面临三个挑战，即打包使用Python CFFI和`setup.py`的CMake项目：
- en: We need to copy the `account.h` and `account_export.h` header files as well
    as the shared library to the Python module location which depends on the Python
    environment.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将`account.h`和`account_export.h`头文件以及共享库复制到依赖于Python环境的Python模块位置。
- en: We need to tell `__init__.py` where to locate these header files and the library.
    In [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language Projects*,
    Recipe 6, *Mixing C, C++, Fortran, and Python using Python CFFI* we have solved
    these using environment variables, but it would be unpractical to set these every
    time we plan to use the Python module.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要告诉`__init__.py`在哪里找到这些头文件和库。在[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，第6个食谱，*使用Python
    CFFI混合C、C++、Fortran和Python*中，我们通过使用环境变量解决了这些问题，但每次我们计划使用Python模块时设置这些变量是不切实际的。
- en: On the Python side, we don't know the exact name (suffix) of the shared library
    file, since it depends on the operating system.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python方面，我们不知道共享库文件的确切名称（后缀），因为它取决于操作系统。
- en: 'Let us start with the last point: we don''t know the exact name, but upon build
    system generation CMake does and therefore we use the generator expression in
    `interface_file_names.cfg.in` to expand the placeholder:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最后一点开始：我们不知道确切的名称，但在生成构建系统时CMake知道，因此我们在`interface_file_names.cfg.in`中使用生成器表达式来扩展占位符：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This input file is used to generate `${CMAKE_CURRENT_BINARY_DIR}/interface_file_names.cfg`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此输入文件用于生成`${CMAKE_CURRENT_BINARY_DIR}/interface_file_names.cfg`：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then define the two header files as `PUBLIC_HEADER` (see also [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml), *Writing
    an Installer*) and the configuration file as `RESOURCE`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将两个头文件定义为`PUBLIC_HEADER`（另请参见[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*），并将配置文件定义为`RESOURCE`：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we install the library, header files, and the configuration file to
    a structure relative to a path defined by `setup.py`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将库、头文件和配置文件安装到一个相对于由`setup.py`定义的路径的结构中：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we set `DESTINATION` for both `LIBRARY` and `RUNTIME` to point to
    `account/lib`. This is important for Windows, where shared libraries have executable
    entry points and therefore we have to specify both.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`DESTINATION`设置为`LIBRARY`和`RUNTIME`，指向`account/lib`。这对于Windows来说很重要，因为共享库具有可执行入口点，因此我们必须同时指定两者。
- en: 'The Python package will be able to find these files thanks to this section
    in `account/__init__.py`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python包将能够通过`account/__init__.py`中的这一部分找到这些文件：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this case, `_cfg_file` will be found and parsed and `setup.py` will find
    the header file under `include` and the library under `lib` and pass these on
    to CFFI to construct the library object. This is also the reason why we have used
    `lib` as the install target `DESTINATION` and not `CMAKE_INSTALL_LIBDIR`, which
    otherwise might confuse `account/__init__.py`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`_cfg_file`将被找到并解析，`setup.py`将在`include`下找到头文件，在`lib`下找到库，并将这些传递给CFFI以构造库对象。这也是我们使用`lib`作为安装目标`DESTINATION`而不是`CMAKE_INSTALL_LIBDIR`的原因，否则可能会让`account/__init__.py`感到困惑。
- en: There is more
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: For follow-up steps for getting the package to the PyPI test and production
    instances, we refer the reader to the previous recipe since these steps are analogous.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将包上传到PyPI测试和生产实例的后续步骤，我们请读者参考之前的食谱，因为这些步骤是类似的。
- en: Distributing a simple project as Conda package
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个简单项目作为Conda包分发
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-04).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-04)找到。本节适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: While PyPI is a standard and popular platform to distribute Python packages,
    Anaconda ([https://anaconda.org](https://anaconda.org)) is more general in the
    sense that it allows to not only distribute Python or mixed-language projects
    with a Python interface but also allows packaging and dependency management for
    non-Python projects. In this recipe, we will prepare a Conda package for a very
    simple C++ example project configured and built using CMake without dependencies
    other than C++. In the next recipe, we will prepare and discuss a more complex
    Conda package.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PyPI是分发Python包的标准且流行的平台，但Anaconda（[https://anaconda.org](https://anaconda.org)）更为通用，因为它不仅允许分发带有Python接口的Python或混合语言项目，还允许为非Python项目进行打包和依赖管理。在本节中，我们将为使用CMake配置和构建的非常简单的C++示例项目准备一个Conda包，该项目没有除C++之外的其他依赖项。在下一节中，我们将准备并讨论一个更复杂的Conda包。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Our goal will be to package the following simple example code (`example.cpp`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标将是打包以下简单的示例代码（`example.cpp`）：
- en: '[PRE64]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How to do it
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'This is how to proceed, step by step:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是按步骤进行的方法：
- en: 'The `CMakeLists.txt` file starts with the minimum version requirement, project
    name, and supported language:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`文件以最小版本要求、项目名称和支持的语言开始：'
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We wish to build the `hello-conda` executable, which is built from `example.cpp`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望构建`hello-conda`可执行文件，该文件由`example.cpp`构建：
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We conclude `CMakeLists.txt` by defining the install target:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过定义安装目标来结束`CMakeLists.txt`：
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will describe the Conda package in a file called `meta.yaml`, which we will
    place under `conda-recipe` to arrive at the following file structure:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在名为`meta.yaml`的文件中描述Conda包，我们将把它放在`conda-recipe`下，以达到以下文件结构：
- en: '[PRE68]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `meta.yaml` file consists of the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`meta.yaml`文件由以下内容组成：'
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we can try to build the package:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试构建包：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will see lots of output on the screen, but once the build is complete, we
    can install the package. We will do this first locally:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在屏幕上看到大量输出，但一旦构建完成，我们就可以安装包。我们将首先进行本地安装：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we are ready to test it – open a new terminal (assuming Anaconda is activated)
    and type the following:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备测试它——打开一个新的终端（假设已激活Anaconda）并输入以下内容：
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After the successful test, we can remove the package again:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试成功后，我们可以再次删除该包：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The install target in `CMakeLists.txt` is an essential component to this recipe:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`中的安装目标是本节的关键组件：'
- en: '[PRE74]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This target makes sure that the binary is installed in `${CMAKE_INSTALL_PREFIX}/bin`.
    The prefix variable is defined by Conda in the build step of `meta.yaml`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此目标确保二进制文件安装在`${CMAKE_INSTALL_PREFIX}/bin`中。前缀变量在`meta.yaml`的构建步骤中由Conda定义：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The build step configures the project, sets the install prefix to `${PREFIX}` (intrinsic
    variable set by Conda), builds, and installs the project. The motivation to call
    the build directory `build_conda` is similar to the previous recipes: a specific
    build directory name makes it easier to experiment with local installs based on
    directories that might already contain a directory called `build`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤配置项目，将安装前缀设置为`${PREFIX}`（由Conda设置的内在变量），构建并安装项目。将构建目录命名为`build_conda`的动机与前面的节类似：特定的构建目录名称使得更容易基于可能已经包含名为`build`的目录的目录进行本地安装实验。
- en: By installing the package into the Anaconda environment, we made the executable
    available to the system.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将包安装到Anaconda环境中，我们使可执行文件对系统可用。
- en: There is more
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'The configuration file `meta.yaml` can be used to specify build, test, and
    install steps for projects of in principle any complexity. Please refer to the
    official documentation for an in-depth discussion: [https://conda.io/docs/user-guide/tasks/build-packages/define-metadata.html.](https://conda.io/docs/user-guide/tasks/build-packages/define-metadata.html)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件`meta.yaml`可用于指定项目的构建、测试和安装步骤，原则上任何复杂度的项目都可以使用。请参考官方文档进行深入讨论：[https://conda.io/docs/user-guide/tasks/build-packages/define-metadata.html](https://conda.io/docs/user-guide/tasks/build-packages/define-metadata.html)。
- en: For an upload of a Conda package to the Anaconda cloud, please follow the official
    Anaconda cloud documentation: [https://docs.anaconda.com/anaconda-cloud/user-guide/](https://docs.anaconda.com/anaconda-cloud/user-guide/).
    Also, consider Miniconda as a lightweight alternative to Anaconda: [https://conda.io/miniconda.html](https://conda.io/miniconda.html).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Conda包上传到Anaconda云，请遵循Anaconda云官方文档：[https://docs.anaconda.com/anaconda-cloud/user-guide/](https://docs.anaconda.com/anaconda-cloud/user-guide/)。同时，可以考虑使用Miniconda作为Anaconda的轻量级替代品：[https://conda.io/miniconda.html](https://conda.io/miniconda.html)。
- en: Distributing a project with dependencies as Conda package
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以Conda包形式分发具有依赖关系的项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-05).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-11/recipe-05)找到。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will build on the findings of the previous recipe and prepare
    a more realistic and sophisticated Conda package for an example CMake project
    that will depend on and utilize the implementation of the DGEMM function, for
    matrix-matrix multiplication, available in the Intel Math Kernel Library (MKL).
    Intel MKL is made available as a Conda package. This recipe will provide us with
    a toolset to prepare and share Conda packages with dependencies.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将基于前一个食谱的发现，为示例CMake项目准备一个更真实、更复杂的Conda包，该项目将依赖于并利用Intel数学内核库（MKL）中提供的DGEMM函数实现，用于矩阵乘法。Intel
    MKL作为Conda包提供。本食谱将为我们提供准备和共享具有依赖关系的Conda包的工具集。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we will use the same file naming and directory structure as
    in the previous simple Conda recipe:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们将使用与前一个简单Conda食谱相同的文件命名和目录结构：
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The example source file (`example.cpp`) performs a matrix-matrix multiplication
    and compares the result returned by the MKL library against a "noddy" implementation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源文件（`example.cpp`）执行矩阵乘法，并将MKL库返回的结果与“noddy”实现进行比较：
- en: '[PRE77]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also need a modified `meta.yaml`. However, the only change compared to the
    previous recipe is a line listing the `mkl-devel` dependency under requirements:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个修改过的`meta.yaml`。但是，与前一个食谱相比，唯一的更改是在需求下添加了`mkl-devel`依赖项的行：
- en: '[PRE78]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How to do it
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These are the steps to follow to prepare our package:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是准备我们包的步骤：
- en: 'The `CMakeLists.txt` file starts with the minimum version requirement, project
    name, and supported language:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`文件以最小版本要求、项目名称和支持的语言开始：'
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We wish to build the `dgemm-example` executable, which is built from `example.cpp`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望构建`dgemm-example`可执行文件，它由`example.cpp`构建：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We then need to locate MKL libraries installed *via *`mkl-devel`. We prepare
    an `INTERFACE` library called `IntelMKL`. This can be used as any other target
    and will set include directories, compiler options, and link libraries for any
    dependent target. The setup is made to mimic what is suggested by the Intel MKL
    link line advisor ([https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/](https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/)).
    First, we set the compiler options:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要定位通过`mkl-devel`安装的MKL库。我们准备了一个名为`IntelMKL`的`INTERFACE`库。这可以像任何其他目标一样使用，并将为任何依赖目标设置包含目录、编译器选项和链接库。设置旨在模仿Intel
    MKL链接行顾问建议的内容（[https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/](https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/)）。首先，我们设置编译器选项：
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we search for the `mkl.h` header file and set the `include` directories
    for the `IntelMKL` target:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们搜索`mkl.h`头文件，并为`IntelMKL`目标设置`include`目录：
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, we locate the libraries and set the link libraries for the `IntelMKL`
    target:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定位库并设置`IntelMKL`目标的链接库：
- en: '[PRE83]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We use the `cmake_print_properties` function to print out useful messages about
    the `IntelMKL` target:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`cmake_print_properties`函数打印有关`IntelMKL`目标的有用消息：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We link the `dgemm-example` target against these libraries:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`dgemm-example`目标与这些库链接：
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We conclude `CMakeLists.txt` by defining the install target:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过定义安装目标来结束`CMakeLists.txt`：
- en: '[PRE86]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we can try to build the package:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试构建包：
- en: '[PRE87]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We will see lots of output on the screen, but once the build is complete, we
    can install the package. We will do this first locally:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在屏幕上看到大量输出，但一旦构建完成，我们就可以安装该包。我们将首先在本地进行此操作：
- en: '[PRE88]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now we are ready to test it – open a new terminal (assuming Anaconda is activated)
    and type:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备测试它 – 打开一个新的终端（假设Anaconda已激活）并输入：
- en: '[PRE89]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'After the successful test, we can remove the package again:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试成功后，我们可以再次删除该包：
- en: '[PRE90]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The only change in `meta.yaml` compared to the previous recipe is the `mkl-devel` dependency.
    The challenge from the CMake perspective is to locate the MKL libraries that are
    installed by Anaconda. Fortunately, we know that they are located in `${CMAKE_INSTALL_PREFIX}`.
    The Intel MKL link line advisor available online ([https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/](https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/))
    can be used to look up how to link MKL into our project depending on the platform
    and compiler chosen. We have decided to wrap this information into an `INTERFACE`
    library. This solution is ideal for the case of MKL: the library is not a target
    created by our project, or any subproject, but it still needs to be dealt with
    in a possibly very convoluted manner; that is: setting compiler flags, include
    directories, and link libraries. CMake `INTERFACE` libraries are targets in the
    build system, but do not create any build output, at least directly. However,
    since they are targets, we may set their properties on them. Just as "real" targets,
    they can also be installed, exported, and imported.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方相比，`meta.yaml`中的唯一变化是`mkl-devel`依赖项。从CMake的角度来看，挑战在于定位Anaconda安装的MKL库。幸运的是，我们知道它们位于`${CMAKE_INSTALL_PREFIX}`。在线提供的Intel
    MKL链接行顾问（[https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/](https://software.intel.com/en-us.articles/intel-mkl-link-line-advisor/)）可以用来查找根据所选平台和编译器将MKL链接到我们项目的方法。我们决定将这些信息封装成一个`INTERFACE`库。对于MKL的情况，这种解决方案是理想的：该库不是我们项目或任何子项目创建的目标，但它仍然需要以可能非常复杂的方式处理；即：设置编译器标志、包含目录和链接库。CMake
    `INTERFACE`库是构建系统中的目标，但不直接创建任何构建输出。然而，由于它们是目标，我们可以在它们上面设置属性。就像“真实”目标一样，它们也可以被安装、导出和导入。
- en: 'First of all, we declare a new library called `IntelMKL` with the `INTERFACE`
    attribute. We then need to set properties as needed and we follow the pattern
    of calling the appropriate CMake command on the target with the `INTERFACE` attribute,
    using the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个名为`IntelMKL`的新库，并带有`INTERFACE`属性。然后我们需要根据需要设置属性，我们遵循在目标上使用`INTERFACE`属性调用适当的CMake命令的模式，使用以下命令：
- en: '`target_compile_options`, to set `INTERFACE_COMPILE_OPTIONS`. In our case,
    `-m64` has to be set, but only if using the GNU or AppleClang compilers. Note
    that we do this with a generator expression.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_options`，用于设置`INTERFACE_COMPILE_OPTIONS`。在我们的例子中，必须设置`-m64`，但仅在使用GNU或AppleClang编译器时。请注意，我们使用生成器表达式来执行此操作。'
- en: '`target_include_directories`, to set the `INTERFACE_INCLUDE_DIRECTORIES`. These
    can be set after finding the `mkl.h` header file on the system. This was done
    with the `find_path` CMake command.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories`，用于设置`INTERFACE_INCLUDE_DIRECTORIES`。这些可以在系统中找到`mkl.h`头文件后设置。这是通过`find_path`
    CMake命令完成的。'
- en: '`target_link_libraries`, to set the `INTERFACE_LINK_LIBRARIES`. We decided
    to link against the single dynamic library `libmkl_rt.so` and searched for it
    with the `find_library` CMake command. The GNU or AppleClang compilers will also
    need to link the executable to the native threading and mathematical libraries.
    Once again, these cases are elegantly handled with generator expressions.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_link_libraries`，用于设置`INTERFACE_LINK_LIBRARIES`。我们决定链接到单个动态库`libmkl_rt.so`，并使用`find_library`
    CMake命令搜索它。GNU或AppleClang编译器还需要将可执行文件链接到本机线程和数学库。再次，这些情况都优雅地使用生成器表达式处理。'
- en: 'The properties we have just set on the IntelMKL target can be printed out for
    the user by means of the `cmake_print_properties` command. Finally, we link against
    the `IntelMKL` target. As expected, this will set compiler flags, include directories,
    and link libraries as necessary to compile successfully:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在IntelMKL目标上设置的属性可以通过`cmake_print_properties`命令打印出来供用户查看。最后，我们链接到`IntelMKL`目标。正如预期的那样，这将设置编译器标志、包含目录和链接库，以确保成功编译：
- en: '[PRE91]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: There is more
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: The Anaconda cloud contains a wealth of packages. With the preceding recipes,
    it is possible and relatively simple to build Conda packages for CMake projects
    that may depend on other Conda packages. Explore the possibility and share your
    software packages for others to build on your developments!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda云包含大量包。有了前面的配方，就有可能并且相对简单地为可能依赖于其他Conda包的CMake项目构建Conda包。探索这种可能性，并分享您的软件包，以便其他人可以在您的开发基础上构建！
