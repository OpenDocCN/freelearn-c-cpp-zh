["```cpp\nint m_numberOfPlayers; \n\nvoid RunScripts(){} \n\nclass GameObject {}; \n```", "```cpp\nnamespace ConsoleHelper \n{ \n  class string \n  { \n    friend bool operator == (const string &string1,\n    const string &string2); \n    friend bool operator < (const string &string1,\n    const string &string2); \n    //other operators ... \n    public: \n    string (); \n    string(const char* input); \n    ~string() ; \n    //more functions ... \n  } \n} \n```", "```cpp\nConsoleHelper::string name = new ConsoleHelper::string(\"Player Name\");\n```", "```cpp\nusing namespace ConsoleHelper; \n```", "```cpp\nusing namespace ConsoleHelper::string; \n```", "```cpp\nclass Enemy \n{ \n  public: \n    void RunAIScripts(); \n    void Update(double deltaTime); \n  private: \n    int m_health; \n    int m_damage; \n};\n```", "```cpp\nclass Boss : public Enemy \n{ \n  public: \n    void Update(double deltaTime); \n    //more functions... \n}; \n```", "```cpp\n//Somewhere in game or level manager \nvoid UpdateObjects (double deltaTime) \n{ \n  enemy.Update(deltaTime); \n  boss.Update(deltaTime); \n} \n```", "```cpp\n//Somewhere in game or level manager \nvoid UpdateAI () \n{ \n  enemy.RunAIScripts(); \n  boss.RunAIScripts (); \n} \n```", "```cpp\nclass FlyingEnemy : public Enemy \n{ \n  public: \n    void Update(double deltaTime); \n    void FlightAI(); \n    //many more functions...  \n} \n```", "```cpp\nclass FlyingBoss : public Boss, public FlyingEnemy \n{ \n  public: \n    void Update(double deltaTime); \n    //other functions... \n} \n```", "```cpp\nFlyingEnemy::Update(deltaTime); \n```", "```cpp\nclass Boss : public virtual Enemy \n{ \n  public: \n    //functions... \n}; \n\nclass FlyingEnemy : public virtual Enemy \n{ \n  public: \n    //functions...  \n} \n\nclass FlyingBoss : public Boss, public FlyingEnemy \n{ \n  public: \n    //other functions... \n} \n```", "```cpp\nFlyingBoss* FlyBoss = new FlyingBoss();  \n```", "```cpp\nBoss* FlyBoss = new FlyingBoss(); \n```", "```cpp\nvirtual void Update(double deltaTime); \n```", "```cpp\nvoid MyFunction(GameObject myObj) \n{ \n  //do some object stuff \n} \n```", "```cpp\nvoid MyFunction (GameObject& myObj) \n{ \n  //do some object stuff \n} \n```", "```cpp\nvoid MyFunction (GameObject* myObj) \n{ \n  //do some object stuff \n} \n```", "```cpp\nconst char* pixelShader; \n```", "```cpp\n    std::unique_ptr<T> p = new std::make_unique<T>();\n```", "```cpp\nstd::shared_ptr<T> p = new std::make_shared<T>(); \n```", "```cpp\nconst int MAX_BULLETS = 100;\n```", "```cpp\nvoid ObjFunction(GameObject &myObject) \n{ \n  //do stuff \n  If(*myObject.value == 0) \n  { \n    //run some logic \n    Game.changeState(newState); \n    //possible unknown modifier function \n    *myObject.value = 1; \n  } \n} \n```", "```cpp\nvoid ObjFunction(const GameObject &myObject) \n{ \n  //do stuff \n  If(*myObject.value == 0) \n  { \n    //run some logic \n    Game.ChangeState(newState); \n    //possible unknown modifier function \n    *myObject.value = 1; //now will throw a compile error \n  } \n}\n```", "```cpp\nvoid ObjFunction(const GameObject &myObject) const \n{ \n  //do stuff \n  If(*myObject.value == 0) \n  { \n    //run some logic \n    Game.ChangeState(newState); \n    //possible unknown modifier function \n    *myObject.value = 1; //now will throw a compile error \n  } \n} \n```", "```cpp\nint number = 10; \nPlayer plr = Player(); \n```", "```cpp\nPlayer* plr = new Player(); \nchar* name = new char[10]; \ndelete plr; \ndelete[] name; \n```", "```cpp\n#include <assert.h> \n... \nvoid MyFunction(int number) \n{ \n  ... \n  assert(number != NULL); \n  ... \n} \n```", "```cpp\nVoid ErroringFunction() \n{ \n  ...// do something that causes error \n  throw; \n} \nVoid MyFunction() \n{ \n  ... \n  Try //the try block \n  { \n    ... \n    ErroringFunction(); \n    ... \n  } \n  Catch(...)//catch *all exceptions block \n  { \n    ... //handle the exception \n  } \n} \n```", "```cpp\n... \nThrow MyExeception(\"Error! Occurred in Myfunction()\"); \n... \nCatch(MyException e) \n{ \n  ...//handle exception \n}  \n```", "```cpp\nstd::vector<int> playerID ; \n```", "```cpp\nstd::list<int> objValues; \n```", "```cpp\nstd::map<int,string> gameObjects; \n```", "```cpp\nclass Rectangle \n{ \n  public: \n    Rectangle(int topLeft, int topRight, int bottomLeft,\n    int bottomRight) : \n    m_topLeft (topLeft), m_topRight(topRight), \n    m_bottomLeft(bottomLeft), m_bottomRight(bottomRight){} \n\n    int GetWidth() { return m_topRight - m_topLeft; } \n  private: \n    int m_topLeft; \n    int m_topRight; \n    int m_bottomLeft; \n    int m_bottomRight; \n}; \n```", "```cpp\ntemplate <class T> \nclass Rectangle \n{ \n  public: \n    Rectangle(T topLeft, T topRight, T bottomLeft,\n    T bottomRight) : \n    m_topLeft(topLeft), m_topRight (topRight), \n    m_bottomLeft(bottomLeft), m_bottomRight(bottomRight){} \n\n    T GetWidth() { return m_topRight - m_topLeft; } \n    T GetHeight() { return m_bottomLeft - m_topLeft;} \n  private: \n    T m_topLeft; \n    T m_topRight; \n    T m_bottomLeft; \n    T m_bottomRight; \n}; \n```", "```cpp\nRectangle(10,20,1,2); \n```", "```cpp\nRectangle (1,1,0.5,0.5); \n```", "```cpp\ntemplate<class T> \nvoid Swap (T &a, T &b) \n{ \n    T temp = a; \n    a = b; \n    b = temp; \n} \n```", "```cpp\nSwap(23,42); \nor float values; \nSwap(12.5, 5.2); \n```", "```cpp\nSwap(1.8, 22); // Results in a compile time error \n```", "```cpp\ntemplate<class T> \nconstexpr T pi = T(3.1415926535897932385); \n```", "```cpp\ntemplate<typename T> \nT area_of_circle_with_radius(T r)  \n{ \n  return pi<T> * r * r; \n} \n```", "```cpp\nint value = 10; \n```", "```cpp\nauto value = 10; \n```", "```cpp\ntemplate <typename ObjectType, typename ObjectFactory> \nvoid CreateObject (const ObjectFactory &objFactory) \n{ \n  ObjectType obj = objFactory.makeObject(); \n  // do stuff with obj \n} \n```", "```cpp\nMyObjFactory objFactory; \nCreateObject<PreDefinedObj>(objFactory); \n```", "```cpp\ntemplate <typename ObjectFactory > \nvoid CreateObject (const ObjectFactory &objFactory) \n{ \n  auto obj = objFactory.MakeObject(); \n  // do stuff with obj \n} \n```", "```cpp\nMyObjFactory objFactory; \nCreateObject (objFactory); \n```", "```cpp\nfor (auto it = v.begin(); it != v.end(); ++it)  \n{ \n  //do stuff \n}\n```", "```cpp\nTreeObject CreateObject (const ObjectFactory &objFactory) \n{ \n  auto obj = objFactory.MakeObject(); \n  return obj; \n} \n```", "```cpp\ntemplate <typename ObjectFactory > \nauto CreateObject(const ObjectFactory &objFactory) -> decltype (objFactory.makeObject()) \n{ \n  auto obj = objFactory.MakeObject(); \n  return obj; \n} \n```", "```cpp\ndouble lastTime = getSystemTime(); \nwhile (!gameOver) \n{ \n  double currentTime = getSystemTime (); \n  double deltaTime = currentTime - lastTime; \n  CheckInput(); \n  Update(deltaTime); \n  Draw(); \n  lastTime = currentTime; \n} \n```", "```cpp\n//simple enum to define our states \nEnum GameState \n{ \n  Waiting, \n  Playing, \n  GameOver \n} \n\nGameState currentGameState = GameState.Waiting; \n\n//Other game class functions... \n\nvoid Update(double deltaTime) \n{ \n  //switch case that acts as our machine \n  switch(currentGameState) \n  { \n    case Waiting: \n      //do things while in waiting state \n      //Transition to the next state \n      currentGameState = Playing; \n    break; \n    case Playing: \n      //do things while in playing state \n      CheckInput(); \n      UpdateObjects(deltaTime); \n      Draw(); \n      //Transition to the next state \n      currentGameState = Gameover; \n    break; \n    case Gameover: \n      //do things while in waiting state \n      UploadHighScore(); \n      ResetGame(); \n      //Transition to the next state \n      currentGameState = Waiting; \n    break; \n  } \n```", "```cpp\n//Event could be an enum or struct that houses the different event types \nvoid GameObject::HandleEvent(Event* event) \n{ \n  switch(event) \n  { \n    case Collision: \n      HandleCollision(); \n      //Do other things... \n    break; \n    Case Explosion: \n      HandleExplosion() \n      //More things... \n    break; \n  } \n} \n```", "```cpp\nclass Event \n{ \n  protected: \n    virtual ~event() {}; \n}; \n```", "```cpp\nvoid onEvent(Event* event) \n{ \n  if (Collision* collision = dynamic_cast<Collision*>(event)) \n  { \n    onCollision(collision); \n  } \n  else if (Explosion* explosion = dynamic_cast< Explosion *>(event)) \n  { \n    onExplosion(explosion); \n  } \n  //etc... \n}\n```", "```cpp\nTemplate <class T> \nbool TryHandleEvent(const Event* event) \n{ \n  If(cosnt T* event = dynamic_cast<const T*> (event)) \n  { \n    Return HandleEvent(event); \n  } \n  Return false; \n} \n\nvoid OnEvent( const Event* event) \n{ \n  If(TryHandleEvent<Collision>(event)) return; \n  Else if(TryHandleEvent<Explosion>(event)) return; \n} \n```"]