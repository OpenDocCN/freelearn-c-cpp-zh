- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Creating a World of Your Own in Godot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Godot中创建自己的世界
- en: In *Part 1* of this book, you learned the basics of programming! No small feat
    if you ask me. So, congrats on that milestone! Now, it’s time to tie it all together
    and start working on our game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*第一部分*中，你学习了编程的基础！如果问我，这可不是一件小事情。所以，恭喜你达到这个里程碑！现在，是时候将所有这些知识串联起来，开始制作我们的游戏了。
- en: In the early days of game development, everything happened through code. A computer
    wizard had to program everything, from systems and features to levels and asset
    placement. In recent times, the tooling for creating games has gotten way better,
    is free, and is very user-friendly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的早期，所有的事情都是通过代码完成的。计算机巫师必须编写所有代码，从系统、功能到关卡和资产放置。近年来，创建游戏的工具已经变得非常好用，而且是免费的，非常用户友好。
- en: Godot, like most modern game engines (Unity, Unreal Engine, Construct, and others),
    has a graphical interface that makes it easy to drag and drop elements of our
    game into levels or other scenes. In this chapter, we’ll learn how to use this
    graphical interface by creating a rudimentary player character and a little world
    for them to inhabit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Godot，像大多数现代游戏引擎（Unity、Unreal Engine、Construct等）一样，有一个图形界面，这使得我们可以轻松地将游戏元素拖放到关卡或其他场景中。在本章中，我们将通过创建一个基本的玩家角色和它们的小世界来学习如何使用这个图形界面。
- en: We’ll also learn some tricks to tie the code and graphical editor together with
    node references and variable exports.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习一些技巧，将代码和图形编辑器通过节点引用和变量导出结合起来。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: The node-based system of Godot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Godot的基于节点的系统
- en: Creating a player character
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建玩家角色
- en: Referencing nodes in scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本中引用节点
- en: Exporting variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出变量
- en: Making rudimentary shapes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作基本的形状
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Because we will create a game from scratch, I took the liberty of providing
    you with the base of a project. You can find this base project in the folder for
    this chapter under `/start`. This project supplies some assets, such as pictures
    and sounds. Creating these assets is outside the scope of this book. The resulting
    project files for this chapter can be found under `/result` of this chapter’s
    folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从头开始创建游戏，我自作主张地为你提供了一个项目的基础。你可以在本章的文件夹下的`/start`中找到这个基础项目。该项目提供了一些资产，如图片和声音。创建这些资产超出了本书的范围。本章的结果项目文件可以在本章文件夹的`/result`下找到。
- en: In the subsequent chapters, you’ll find the resulting project in the `root`
    folder of that chapter. It’s assumed that you use the results from the previous
    chapter as a starting point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，你将在该章节的`root`文件夹中找到最终的项目。假设你使用上一章的结果作为起点。
- en: 'So, get the starting project, and let’s dive in: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，获取起始项目，让我们深入探讨：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start)。
- en: Game design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计
- en: 'Before mindlessly creating a game, let’s plan out what kind of game we want
    to make. This will structure our thoughts and make sure we work toward the game
    we want to make without taking unnecessary detours. The best way to do this is
    through a **game design document** (**GDD**). Though there is no set format for
    this kind of document, it should eventually answer some basic questions about
    the game:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在盲目地创建游戏之前，让我们规划一下我们想要制作的游戏类型。这将结构化我们的思想，并确保我们朝着我们想要制作的游戏前进，而不会走不必要的弯路。最好的方式是通过**游戏设计文档**（**GDD**）。尽管这种文档没有固定的格式，但它最终应该回答一些关于游戏的基本问题：
- en: Which genre is the game?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏属于哪个类型？
- en: What mechanics will be in the game?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏将包含哪些机制？
- en: What is the story?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事是什么？
- en: Some game design documents are hundreds of pages long. But as this is not a
    game design book, let’s define our game regarding these three questions and then
    work out the details as we go.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏设计文档长达数百页。但鉴于这不是一本游戏设计书籍，让我们就以下三个问题来定义我们的游戏，然后在我们前进的过程中详细规划。
- en: Genre
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: Recently, we have witnessed the birth of a new genre known as **vampire survivor-likes**,
    also known as a **VS** game. In this type of game, you control a character in
    a 2D top-down world. The character has to defeat waves of monsters coming after
    them by shooting them. The player can control the character by moving them around,
    but shooting happens automatically. It does not require input.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我们见证了名为 **吸血鬼生存类** 的新类型的诞生，也称为 **VS** 游戏。在这种类型的游戏中，你控制一个角色在 2D 俯视世界中。这个角色必须通过射击来击败追击他们的怪物波次。玩家可以通过移动角色来控制角色，但射击是自动发生的。它不需要输入。
- en: This genre has a huge player base, and the base game is relatively simple to
    implement and yet satisfying to play. Therefore, it would be the ideal type of
    game to recreate throughout the following chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的游戏拥有庞大的玩家基础，基础游戏相对简单易实现，同时玩起来也令人满意。因此，它将是以下章节中重新创建的理想游戏类型。
- en: Mechanics
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: 'The survivor-like genre has some staple mechanics that are very important to
    get right:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生存类游戏有一些基本的机制，这些机制非常重要，需要正确实现：
- en: '**2D world**: The playing field is a 2D plane on which we have a top-down view.
    Some of them are indeed in 3D, but the mechanics still shine in 2D.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D 世界**：游戏场是一个 2D 平面，我们在其中有一个俯视视角。其中一些确实是 3D 的，但机制在 2D 中仍然很出色。'
- en: '**Movement of the character**: We need to be able to move the character around
    in the world.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色的移动**：我们需要能够在世界中移动角色。'
- en: '**Waves of enemies**: We need enemies that threaten to kill the player and
    we need to spawn them so that they pose a proper challenge .'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敌人波次**：我们需要威胁到玩家生命的敌人，并且我们需要生成它们，以便它们构成适当的挑战。'
- en: '**Automatic shooting**: The player character will automatically shoot projectiles
    aimed at the enemies.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动射击**：玩家角色将自动射击针对敌人的投射物。'
- en: Now that we have sorted out the genre and staple mechanics, let’s work out the
    story our game will be based on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理了游戏类型和基本机制，让我们来制定我们的游戏将基于的故事。
- en: Story
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故事
- en: Let’s not burden ourselves too much with writing the whole story. In games,
    the story can also be told through how the game looks and feels. So, we can specify
    a general setting that binds the whole experience together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要在编写整个故事上给自己太多压力。在游戏中，故事也可以通过游戏的外观和感觉来讲述。因此，我们可以指定一个将整个体验联系在一起的一般设置。
- en: 'How about this as our setting: You are a medieval knight fighting in the king’s
    tournament to find the strongest soldier in the whole land. You’ll have to battle
    multiple enemies, such as orcs and trolls, in multiple rounds, each harder than
    the last. The only weapon you are given is a bow, with which you can shoot arrows
    at your adversaries.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设定如何：你是一位中世纪骑士，在国王的锦标赛中战斗，以寻找整个土地上最强的士兵。你将不得不在多轮比赛中与多个敌人战斗，如兽人和巨魔，每一轮都比上一轮更难。你唯一得到的武器是一把弓，你可以用它向你的对手射箭。
- en: Now that we have an idea of the kind of game we are creating, let’s get into
    it!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们正在创建的游戏类型有了想法，让我们开始吧！
- en: Creating a player character
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家角色
- en: 'We’ll start by creating a rudimentary player character for our game:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的游戏创建一个基本的玩家角色：
- en: Open the `main.tscn` file I provided in the project base.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我在项目基础上提供的 `main.tscn` 文件。
- en: 'Select the `root` node, called `Main`, and press the **Add Child** **Node**
    button:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择名为 `Main` 的 `root` 节点，然后按 **添加子节点** **Node** 按钮：
- en: '![Figure 6.1 – The button to add a new child node to the selected node in the
    tree](img/B19358_06_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 在树中为所选节点添加新子节点的按钮](img/B19358_06_01.jpg)'
- en: Figure 6.1 – The button to add a new child node to the selected node in the
    tree
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 在树中为所选节点添加新子节点的按钮
- en: 'Then, find and add a **Node2D** node. You can use the search bar at the top
    to make searching for the node easier. This is a node that has a position in 2D
    space:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，查找并添加一个 **Node2D** 节点。您可以使用顶部的搜索栏来简化节点的搜索。这是一个在 2D 空间中具有位置的节点：
- en: '![Figure 6.2 – Finding and selecting the Node2D node](img/B19358_06_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 查找和选择 Node2D 节点](img/B19358_06_02.jpg)'
- en: Figure 6.2 – Finding and selecting the Node2D node
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 查找和选择 Node2D 节点
- en: Next, rename this Node2D as `Player` by right clicking the node and choosing
    **Rename**, just like we did in [*Chapter 2*](B19358_02.xhtml#_idTextAnchor044).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过右键单击节点并选择 **重命名**，将此 Node2D 重命名为 `Player`，就像我们在 [*第 2 章*](B19358_02.xhtml#_idTextAnchor044)
    中做的那样。
- en: '`Player` will be the base node for our player character. From here, we will
    add all the other nodes that comprise the `Player` node. The first of these nodes
    will be a sprite.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 将是我们玩家角色的基础节点。从这里，我们将添加构成 `Player` 节点的所有其他节点。这些节点中的第一个将是一个精灵。'
- en: Adding a sprite
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加精灵
- en: 'The first thing we can do to flesh out our player character is to give it a
    visual, something that the player can relate to as the main character. Follow
    *Steps 1* to *3* in the *Creating a player character* section again to add a node
    called `Sprite2D` to the `Player` node so that the scene tree looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是为我们的玩家角色添加一个视觉元素，一些玩家可以将其与主要角色联系起来的东西。再次按照 *步骤 1* 到 *3* 在 *创建玩家角色*
    部分中操作，将一个名为 `Sprite2D` 的节点添加到 `Player` 节点中，以便场景树看起来像这样：
- en: '![Figure 6.3 – The scene tree so far](img/B19358_06_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 到目前为止的场景树](img/B19358_06_03.jpg)'
- en: Figure 6.3 – The scene tree so far
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 到目前为止的场景树
- en: 'The `Sprite2D` node is a node that can display an image, also called a `Sprite2D`,
    you’ll see that the **Inspector** view on the right-hand side gets populated with
    information about that node:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprite2D` 节点是一个可以显示图像的节点，也称为 `Sprite2D`，你将看到右侧的 **检查器** 视图会填充有关该节点的信息：'
- en: '![Figure 6.4 – The Inspector view of a Sprite2D node](img/B19358_06_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – Sprite2D 节点的检查器视图](img/B19358_06_04.jpg)'
- en: Figure 6.4 – The Inspector view of a Sprite2D node
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Sprite2D 节点的检查器视图
- en: There are settings for **Texture**, **Offset**, **Animation**, **Region**, and
    more. You can look through them to get an idea of all the available settings.
    The different tabs are **Property Groups**, while the settings themselves are
    called **Properties**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有 **纹理**、**偏移**、**动画**、**区域** 等设置。你可以浏览它们，以了解所有可用的设置。不同的选项卡是 **属性组**，而设置本身被称为
    **属性**。
- en: We are only interested in the **Texture** property because this is where we
    can set the image this node displays. So, let’s add a sprite for our character!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对 **纹理** 属性感兴趣，因为这是我们可以设置该节点显示的图像的地方。所以，让我们为我们的角色添加一个精灵！
- en: In the `assets/sprites/character`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `assets/sprites/character`。
- en: Here, you’ll find a bunch of premade character sprites.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，你可以找到一些预制的角色精灵。
- en: Kenney assets
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kenney 资产
- en: The assets we are using in this book all come from Kenney and are free to use
    in any project you want. You can find more of his great assets at [https://kenney.nl/](https://kenney.nl/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的所有资产都来自 Kenney，并且可以在你想要的任何项目中免费使用。你可以在 [https://kenney.nl/](https://kenney.nl/)
    找到他更多优秀的资产。
- en: Drag and drop any of them onto the `Sprite2D` node. I’m using the `character01.png`
    texture.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们中的任何一个拖放到 `Sprite2D` 节点上。我正在使用 `character01.png` 纹理。
- en: 'The `Sprite2D` node should now look something like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sprite2D` 节点现在应该看起来像这样：'
- en: '![Figure 6.5 – Adding a texture to a sprite node](img/B19358_06_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 向精灵节点添加纹理](img/B19358_06_05.jpg)'
- en: Figure 6.5 – Adding a texture to a sprite node
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 向精灵节点添加纹理
- en: 'The sprite should also turn up in the 2D view of the editor. However, it seems
    to be very small. That’s because the image is only `16` × `16` pixels in size.
    Let’s scale it up a little. Under the `3`. You can set the scale for the X and
    Y axes separately, but we want them both to be equal so that the sprite scales
    without stretching:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵也应该出现在编辑器的 2D 视图中。然而，它看起来非常小。这是因为图像的大小只有 `16` × `16` 像素。让我们稍微放大一下。在 `3` 之下。你可以分别设置
    X 轴和 Y 轴的缩放比例，但我们希望它们都相等，这样精灵在缩放时不会拉伸：
- en: '![Figure 6.6 – The Transform properties of a sprite node](img/B19358_06_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 精灵节点的变换属性](img/B19358_06_06.jpg)'
- en: Figure 6.6 – The Transform properties of a sprite node
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 精灵节点的变换属性
- en: Oh no – what’s this?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不——这是怎么回事？
- en: '![Figure 6.7 – A blurry pixel art sprite](img/B19358_06_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 一个模糊的像素艺术精灵](img/B19358_06_07.jpg)'
- en: Figure 6.7 – A blurry pixel art sprite
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 一个模糊的像素艺术精灵
- en: 'The sprite looks blurry! This happened because we’re using **pixel art** assets,
    a style well known for its blocky pixels. When upscaling, Godot Engine uses an
    algorithm that blurs out these pixels. This is great for other art styles, such
    as hand-drawn or vector art, but not for pixel art. Luckily, there is a solution.
    Follow these steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个精灵看起来模糊！这是因为我们正在使用 **像素艺术** 资产，这种风格以其方块像素而闻名。当放大时，Godot 引擎使用一个算法来模糊这些像素。这对于其他艺术风格，如手绘或矢量艺术，非常棒，但对于像素艺术来说则不然。幸运的是，有一个解决方案。按照以下步骤操作：
- en: 'Navigate to **Project** | **Project Settings...**:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **项目** | **项目设置...**：
- en: '![Figure 6.8 – Going to Project Settings...](img/B19358_06_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 前往项目设置...](img/B19358_06_08.jpg)'
- en: Figure 6.8 – Going to Project Settings...
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 前往项目设置...
- en: 'Under **Rendering** | **Textures**, set **Default Texture Filter** to **Nearest**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **渲染** | **纹理** 下，将 **默认纹理过滤器** 设置为 **最近**：
- en: '![Figure 6.9 – Setting Default Texture Filter to Nearest](img/B19358_06_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 将默认纹理过滤器设置为最近](img/B19358_06_09.jpg)'
- en: Figure 6.9 – Setting Default Texture Filter to Nearest
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 设置默认纹理过滤器为最近邻
- en: These settings will scale the image in a way that is better suited for pixel
    art. Now, our sprite looks way better!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置将以更适合像素艺术的方式缩放图像。现在，我们的精灵看起来好多了！
- en: '![Figure 6.10 – A crisp pixel art sprite](img/B19358_06_10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 清晰的像素艺术精灵](img/B19358_06_10.jpg)'
- en: Figure 6.10 – A crisp pixel art sprite
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 清晰的像素艺术精灵
- en: Now that we can see our player, let’s look into displaying a health UI.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们的玩家，让我们看看如何显示健康 UI。
- en: Displaying health
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示健康信息
- en: 'Next, let’s add something to display the player’s health above the character.
    Sure, we haven’t created a script for the player yet that tracks health, but we
    can put the visuals in place. We will use a `Label` node, which can display text
    in the game:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一些东西来显示玩家健康信息在角色上方。当然，我们还没有为玩家创建跟踪健康的脚本，但我们可以放置视觉效果。我们将使用 `Label` 节点，它可以在游戏中显示文本：
- en: Find and add a `Label` node to the `Player` node.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Player` 节点中查找并添加一个 `Label` 节点。
- en: 'Name the node `HealthLabel`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点命名为 `HealthLabel`：
- en: '![Figure 6.11 - The scene tree with the HealthLabel node added](img/B19358_06_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 - 添加了 HealthLabel 节点的场景树](img/B19358_06_11.jpg)'
- en: Figure 6.11 - The scene tree with the HealthLabel node added
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 - 添加了 HealthLabel 节点的场景树
- en: 'When selecting the `Label` node, the `10/10` into it as if the player has 10
    out of their 10 lives:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择 `Label` 节点时，将其中的 `10/10` 放入其中，就像玩家有 10 条生命中的 10 条一样：
- en: '![Figure 6.12 – The Inspector view of a Label node with the text set to 10/10](img/B19358_06_12.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 文本设置为 10/10 的 Label 节点的检查器视图](img/B19358_06_12.jpg)'
- en: Figure 6.12 – The Inspector view of a Label node with the text set to 10/10
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 文本设置为 10/10 的 Label 节点的检查器视图
- en: 'Next, drag the label on top of the player so that it’s out of the way of the
    sprite:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将标签拖到玩家上方，使其远离精灵：
- en: '![Figure 6.13 – Repositioning the HealthLabel node above the player character](img/B19358_06_13.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 将 HealthLabel 节点重新定位在玩家角色上方](img/B19358_06_13.jpg)'
- en: Figure 6.13 – Repositioning the HealthLabel node above the player character
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 将 HealthLabel 节点重新定位在玩家角色上方
- en: Great! With the `HealthLabel` label in place, we can update it through a script
    later on (see the *Creating the player script* section). This is all we need to
    set up the nodes in the scene tree.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在 `HealthLabel` 标签就位后，我们可以在稍后通过脚本更新它（见 *创建玩家脚本* 部分）。这就是我们在场景树中设置节点所需的所有内容。
- en: Now, let’s see how we can manipulate the nodes we’ve added.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以操作我们添加的节点。
- en: Manipulating nodes in the editor
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在编辑器中操作节点
- en: 'Now that we have a small scene tree in place, let’s look at what tools we have
    available to manipulate the nodes. If you look at the top right of the 2D editor,
    you’ll see some of these tools:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个小场景树，让我们看看我们有哪些工具可以用来操作节点。如果你看看 2D 编辑器的右上角，你会看到一些这些工具：
- en: '![Figure 6.14 – The toolbar in the 2D editor view](img/B19358_06_14.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 2D 编辑器视图中的工具栏](img/B19358_06_14.jpg)'
- en: Figure 6.14 – The toolbar in the 2D editor view
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 2D 编辑器视图中的工具栏
- en: 'There are many interesting tools in this toolbar, but the first four are the
    most important ones for now:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏中有很多有趣的工具，但就目前而言，前四个是最重要的：
- en: '**Select mode**: This is the default mode and is a multitool. You can select
    nodes within the scene and drag them around.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择模式**：这是默认模式，是一个多工具。您可以在场景中选择节点并将它们拖动。'
- en: '**Move mode**: In this mode, you can move the selected node.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动模式**：在此模式下，您可以移动选定的节点。'
- en: '**Rotate mode**: In this mode, you can rotate the selected node.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转模式**：在此模式下，您可以旋转选定的节点。'
- en: '**Scale mode**: In this mode, you can scale the selected node.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放模式**：在此模式下，您可以缩放选定的节点。'
- en: 'Try these modes by selecting the `Player` node and messing around a bit. This
    could lead you to a result like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 `Player` 节点并进行一些操作来尝试这些模式。这可能会导致以下结果：
- en: '![Figure 6.15 – The Player node after multiple transform manipulations](img/B19358_06_15.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 多次变换操作后的 Player 节点](img/B19358_06_15.jpg)'
- en: Figure 6.15 – The Player node after multiple transform manipulations
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 多次变换操作后的 Player 节点
- en: You’ll also notice that when you move, rotate, or scale a node, its child nodes
    will be manipulated in the same way. This inheritance of transformation is the
    strength of the hierarchical node system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，当你移动、旋转或缩放一个节点时，其子节点将以相同的方式被操作。这种变换的继承是层次节点系统的优势。
- en: 'If you look at the `Player` node, you’ll see the exact modifications you made
    to it. If you change any of these values, you’ll see them reflected in the 2D
    editor too:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `Player` 节点，你会看到你对其所做的确切修改。如果你更改这些值中的任何一个，你也会在 2D 编辑器中看到它们的变化：
- en: '![Figure 6.16 – The Transform parameters after multiple transform manipulations](img/B19358_06_16.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 多次变换操作后的变换参数](img/B19358_06_16.jpg)'
- en: Figure 6.16 – The Transform parameters after multiple transform manipulations
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 多次变换操作后的变换参数
- en: As an experiment, try changing the value for `Skew` from the **Inspector** view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，尝试从 **检查器** 视图中更改 `Skew` 的值。
- en: 'Before you continue with the following sections, don’t forget to reset all
    these manipulations in the `Player` node. You can do this simply by pressing the
    ↺ symbol next to each property. This button will set the property back to its
    default value. Let’s also set the position of the `Player` node so that the player
    character is roughly centered on the screen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续以下部分之前，别忘了将 `Player` 节点中的所有这些操作重置。你可以通过简单地按每个属性旁边的 ↺ 符号来完成此操作。此按钮将属性重置为其默认值。让我们也将
    `Player` 节点的位置设置为玩家角色大致位于屏幕中心：
- en: '![Figure 6.17 – Positioning the player character in the middle of the screen](img/B19358_06_17.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 将玩家角色定位在屏幕中间](img/B19358_06_17.jpg)'
- en: Figure 6.17 – Positioning the player character in the middle of the screen
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 将玩家角色定位在屏幕中间
- en: With that, we’ve finished creating the base for our player character and learned
    how we can manipulate nodes within the editor. Next, we’ll focus on the player
    character’s script and learn how we can manipulate nodes through code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了玩家角色的基础创建，并学习了如何在编辑器中操作节点。接下来，我们将关注玩家角色的脚本，并学习如何通过代码操作节点。
- en: Creating the player script
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家脚本
- en: 'This is the moment we have been training for. We already know how to do this!
    So, start by creating a new script that is attached to the `Player` node:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直在训练的时刻。我们已经知道如何做到这一点！所以，首先创建一个新的脚本，并将其附加到 `Player` 节点：
- en: 'Right-click the `Player` node and select **Attach Script**:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Player` 节点并选择 **附加脚本**：
- en: '![Figure 6.18 – Attaching a script to the Player node](img/B19358_06_18.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 将脚本附加到 Player 节点](img/B19358_06_18.jpg)'
- en: Figure 6.18 – Attaching a script to the Player node
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 将脚本附加到 Player 节点
- en: 'In the dialogue that pops up, call the script `player.gd`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，将脚本命名为 `player.gd`：
- en: '![Figure 6.19 – Calling the script player.gd](img/B19358_06_19.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 调用脚本 player.gd](img/B19358_06_19.jpg)'
- en: Figure 6.19 – Calling the script player.gd
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 调用脚本 player.gd
- en: 'We’ll keep it simple for now and just add some code to manage the health of
    the player:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在保持简单，只添加一些代码来管理玩家的健康：
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `clamp()` function we use in the `add_health_points()` function takes a
    numeric value as the first argument and keeps it in between the second two numeric
    parameters.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `add_health_points()` 函数中使用的 `clamp()` 函数将一个数值作为第一个参数，并将其保持在第二个和第三个数值参数之间。
- en: This way, the health is always between `0` and `MAX_HEALTH`, which is `10` at
    the max.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，健康值始终在 `0` 和 `MAX_HEALTH` 之间，最大值为 `10`。
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that you can *Ctrl* and click on Windows and Linux or *Option* and
    click on Mac on any function to go to the documentation and have a look at what
    it does.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Windows 和 Linux 上，你可以 *Ctrl* 和点击任何函数以转到文档并查看其功能；在 Mac 上，你可以 *Option* 和点击。
- en: With this in place, we can change the player’s health. Now, let’s look at how
    we can update the `HealthLabel` node we created earlier to reflect this value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就可以更改玩家的健康值了。现在，让我们看看如何更新我们之前创建的 `HealthLabel` 节点以反映这个值。
- en: Referencing nodes in a script
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中引用节点
- en: We want to update the `HealthLabel` node of our player character according to
    the amount of health the player still has left. To change nodes in our scene from
    within the script, we need to be able to reference them. Luckily, this is pretty
    easy in Godot 4.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据玩家剩余的健康量更新玩家角色的 `HealthLabel` 节点。为了在脚本中更改场景中的节点，我们需要能够引用它们。幸运的是，在 Godot
    4 中这相当简单。
- en: 'There are multiple ways to get a node’s reference, but the easiest is the dollar
    notation. This notation looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 获取节点引用有多种方法，但最简单的是美元符号表示法。这种表示法看起来是这样的：
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The notation starts with a dollar sign (`$`), followed by the path through the
    scene tree to the node we want. Here, we reference the health label we created
    earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该表示法以美元符号 (`$`) 开头，后跟通过场景树到我们想要引用的节点的路径。在这里，我们引用了之前创建的健康标签。
- en: 'Note that this path is relative to the node with the script where this path
    is mentioned. So if the main node has a script and we want to reference the player’s
    health label, the notation would look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此路径相对于提及此路径的脚本所在的节点。因此，如果主节点有一个脚本，我们想要引用玩家的健康标签，表示法将如下所示：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, now that we know how to get the reference to a node, let’s create a small
    function that updates the player’s health label and call it in the `add_health_points()`
    function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经知道了如何获取节点的引用，让我们创建一个小的函数来更新玩家的健康标签，并在`add_health_points()`函数中调用它：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'func add_health_points(difference: int):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'func add_health_points(difference: int):'
- en: health += difference
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: health += difference
- en: health = clamp(health, 0, MAX_HEALTH)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: health = clamp(health, 0, MAX_HEALTH)
- en: 'HealthLabel node is displaying. But there is a better way of accessing or referencing
    nodes within the scene tree: by caching them. We’ll take a look at that next.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: HealthLabel节点正在显示。但有一种更好的方法来访问或引用场景树中的节点：通过缓存它们。我们将在下一节中查看这一点。
- en: Caching node references
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存节点引用
- en: Though the dollar notation is very convenient, sometimes, you will need to access
    a certain node often. In such cases, using the dollar notation will be slow because
    the engine will have to keep searching for the node within the tree and accessing
    it every time.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然美元符号非常方便，但有时你需要经常访问某个节点。在这种情况下，使用美元符号将会很慢，因为引擎将不得不在树中不断搜索节点，并在每次访问时都这样做。
- en: Caching
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存
- en: In computer lingo, caching means storing a certain piece of data for later so
    that you don’t have to load it every time it is needed.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在计算机术语中，缓存意味着为了以后使用而存储某些数据，这样你就不必每次需要时都加载它。
- en: 'To stop searching the node each time, we can save a reference to the node in
    a variable. For example, we can change the player script like so:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了每次停止搜索节点，我们可以在变量中保存节点的引用。例如，我们可以这样更改玩家脚本：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'func _ready():'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: add_health_points(-2)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: add_health_points(-2)
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '@export var health: int = 10'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var health: int = 10'
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'func _ready():'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: update_health_label()
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: update_health_label()
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'func _ready():'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: print(health)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: print(health)
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@export var health: int = 10:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var health: int = 10:'
- en: 'get:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'get:'
- en: return health
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: return health
- en: 'set(new_value):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '设置(new_value):'
- en: health = clamp(new_value, 0, MAX_HEALTH)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: health = clamp(new_value, 0, MAX_HEALTH)
- en: update_health_label()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: update_health_label()
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'print(health) # Execute the getter'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(health) # 执行获取器'
- en: 'health = 100 # Execute the setter'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'health = 100 # 执行设置器'
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'func add_health_points(difference: int):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'func add_health_points(difference: int):'
- en: health += difference
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: health += difference
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'func update_health_label():'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'func update_health_label():'
- en: 'if not is_instance_valid(_health_label):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not is_instance_valid(_health_label):'
- en: return
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: extends Node2D
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: extends Node2D
- en: 'const MAX_HEALTH: int = 10'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'const MAX_HEALTH: int = 10'
- en: '@onready var _health_label: Label = $HealthLabel'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '@onready var _health_label: Label = $HealthLabel'
- en: '@export var health: int = 10:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var health: int = 10:'
- en: 'get:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 获取：
- en: return health
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: return health
- en: 'set(new_value):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'set(new_value):'
- en: health = clamp(new_value, 0, MAX_HEALTH)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: health = clamp(new_value, 0, MAX_HEALTH)
- en: update_health_label()
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: update_health_label()
- en: 'func _ready():'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: update_health_label()
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: update_health_label()
- en: 'func update_health_label():'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'func update_health_label():'
- en: 'if not is_instance_valid(_health_label):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not is_instance_valid(_health_label):'
- en: return
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
- en: 'func add_health_points(difference: int):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'func add_health_points(difference: int):'
- en: health += difference
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: health += difference
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '@export var health: int = 10'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var health: int = 10'
- en: '@export var damage: float = 0.0'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var damage: float = 0.0'
- en: '@export var player_name: String = "Erika"'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var player_name: String = "Erika"'
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '@export_range(0, 10) health: int = 10'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '@export_range(0, 10) health: int = 10'
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '@export_range(0, MAX_HEALTH) health: int = 10'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '@export_range(0, MAX_HEALTH) health: int = 10'
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
