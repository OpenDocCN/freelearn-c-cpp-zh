- en: '*Chapter 6*: Signals and Slots'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：信号和槽'
- en: In the previous chapters, we learned how to create GUI applications with Qt
    Widgets and Qt Quick. But to make our applications usable, we need to add a communication
    mechanism. The **signals** and **slots** mechanism is one of the distinct features
    of Qt and makes it unique from other frameworks. Signals and slots are implemented
    through Qt's meta-object system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何使用Qt Widgets和Qt Quick创建GUI应用程序。但是为了使我们的应用程序可用，我们需要添加一个通信机制。**信号**和**槽**机制是Qt的一个独特特性，使其与其他框架不同。信号和槽是通过Qt的元对象系统实现的。
- en: In this chapter, you will learn about signals and slots in depth and how they
    work internally. You will be able to receive notifications from different classes
    and take the corresponding action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将深入了解信号和槽以及它们的内部工作原理。您将能够从不同的类中接收通知并采取相应的行动。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding Qt signals and slots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qt信号和槽
- en: The working mechanism of Qt signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt信号和槽的工作机制
- en: Getting to know Qt's property system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Qt的属性系统
- en: Understanding signals and the handler event system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信号和处理程序事件系统
- en: Understanding events and the event loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件和事件循环
- en: Managing events with an event filter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件过滤器管理事件
- en: Drag and drop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放
- en: By the end of this chapter, you will be able to communicate between C++ classes
    with QML and between QML components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够在C++类与QML之间以及QML组件之间进行通信。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include having the minimum versions
    of Qt (6.0.0) and Qt Creator (4.14.0) installed on the latest desktop platform
    available, such as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台上安装Qt（6.0.0）和Qt Creator（4.14.0）的最低版本，例如Windows 10、Ubuntu 20.04或macOS
    10.14。
- en: 'All the code in this chapter can be downloaded from the following GitHub link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以从以下GitHub链接下载：
- en: '[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter06)'
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots in this chapter were taken on a Windows machine. You will see
    similar screens based on the underlying platforms on your machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的屏幕截图是在Windows机器上拍摄的。您将在您的机器上看到基于底层平台的类似屏幕。
- en: Understanding Qt signals and slots
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Qt信号和槽
- en: In GUI programming, when a user performs any action with any UI element, another
    element should get updated, or a certain task should be done. To achieve this,
    we want communication between objects. For example, if a user clicks the **Close**
    button on the **Title** bar, it is expected that the window closes. Different
    frameworks use different approaches to achieve this kind of communication. A **callback**
    is one of the most commonly used approaches. A callback is a function that's passed
    as an argument to another function. Callbacks can have multiple drawbacks and
    may suffer from complications in ensuring the type-correctness of callback arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI编程中，当用户对任何UI元素执行任何操作时，另一个元素应该得到更新，或者应该执行某个特定的任务。为了实现这一点，我们需要对象之间的通信。例如，如果用户点击**标题**栏上的**关闭**按钮，预期窗口会关闭。不同的框架使用不同的方法来实现这种通信。**回调**是最常用的方法之一。回调是作为参数传递给另一个函数的函数。回调可能有多个缺点，并且可能在确保回调参数的类型正确性方面出现复杂性。
- en: In the Qt framework, we have a substitute for this callback technique known
    as signals and slots. A signal is a message that is passed to communicate that
    the state of an object has changed. This signal may carry information about the
    change that has occurred. A slot is a special function that is invoked in response
    to a specific signal. Since slots are functions, they contain logic to perform
    a certain action. Qt Widgets have many predefined signals, but you can always
    extend your classes and add your own signals to them. Similarly, you can also
    add your own slots to handle the intended signal. Signals and slots make it easy
    to implement the observer pattern while avoiding boilerplate code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt框架中，我们有一个称为信号和槽的回调技术的替代方法。信号是传递的消息，用于传达对象状态已更改。这个信号可能携带有关已发生更改的信息。槽是在特定信号的响应中调用的特殊函数。由于槽是函数，它们包含执行某个动作的逻辑。Qt
    Widgets有许多预定义的信号，但您始终可以扩展您的类并向其添加自己的信号。同样，您也可以添加自己的槽来处理预期的信号。信号和槽使得实现观察者模式变得容易，同时避免样板代码。
- en: To be able to communicate, you must connect the corresponding signals and slots.
    Let's understand the connection mechanism and syntaxes of a signal and slot connection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够通信，您必须连接相应的信号和槽。让我们了解信号和槽连接的连接机制和语法。
- en: Understanding syntax
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解语法
- en: 'To connect a signal to a slot, we can use `QObject::connect()`. This is a thread-safe
    function. The standard syntax is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将信号连接到槽，我们可以使用`QObject::connect()`。这是一个线程安全的函数。标准语法如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding connection, the first argument is the sender object, while
    the next argument is the signal from the sender. The third argument is the receiver
    object, while the fourth is the slot method. The last argument is optional and
    describes the type of connection to be established. It determines whether the
    notification will be delivered to the slot immediately or queued for later. There
    are six different types of connections that can be made in Qt 6\. Let''s have
    a look at the connection types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的连接中，第一个参数是发送方对象，而下一个参数是发送方的信号。第三个参数是接收方对象，而第四个是槽方法。最后一个参数是可选的，描述要建立的连接类型。它确定通知是立即传递给槽还是排队等待。在Qt
    6中可以建立六种不同类型的连接。让我们来看看连接类型：
- en: '`Qt::DirectConnection` is used; otherwise, `Qt::QueuedConnection` is used.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Qt::DirectConnection`；否则，使用`Qt::QueuedConnection`。
- en: '**Qt::DirectConnection**: In this case, both the signal and slot live in the
    same thread. The slot is called immediately after the signal is emitted.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt::DirectConnection**：在这种情况下，信号和槽都位于同一线程中。信号发射后立即调用槽。'
- en: '**Qt::QueuedConnection**: In this case, the slot lives in another thread. The
    slot is called once control returns to the event loop of the receiver''s thread.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt::QueuedConnection**：在这种情况下，槽位于另一个线程中。一旦控制返回到接收者线程的事件循环，就会调用槽。'
- en: '`Qt::QueuedConnection`, except that the signaling thread blocks until the slot
    returns. This connection must not be used if both the sender and receiver are
    in the same thread to avoid deadlock.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::QueuedConnection`，除了发出信号的线程会阻塞，直到槽返回。如果发送者和接收者在同一线程中，则不能使用此连接以避免死锁。'
- en: '`bitwise OR`. This is used to avoid duplicate connections. The connection will
    fail if the connection already exists.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按位或`。这用于避免重复连接。如果连接已经存在，则连接将失败。'
- en: '`Qt::BlockingQueuedConnection` to avoid deadlocks. You are sending an event
    to the same thread and then locking the thread, waiting for the event to be processed.
    Since the thread is blocked, the event will never be processed, and the thread
    will be blocked forever, causing a deadlock. Use this connection type if you know
    what you are doing. You must know the implementation details of both threads before
    using this connection type.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::BlockingQueuedConnection`以避免死锁。您正在向同一线程发送事件，然后锁定线程，等待事件被处理。由于线程被阻塞，事件将永远不会被处理，线程将永远被阻塞，导致死锁。如果知道自己在做什么，请使用此连接类型。在使用此连接类型之前，必须了解两个线程的实现细节。'
- en: 'There are several ways to connect signals and slots. You must use the `SIGNAL()`
    and `SLOT()` macros when specifying the signal and the slot function, respectively.
    The most commonly used syntax is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种连接信号和槽的方法。在指定信号和槽函数时，必须使用`SIGNAL()`和`SLOT()`宏。最常用的语法如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the original syntax that has been around since the beginning of Qt.
    However, its implementation has changed quite a few times. New features have been
    added without breaking the basic **Application Programming Interface** (**API**).
    It is recommended to use the new function pointer syntax, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自Qt诞生以来就存在的原始语法。但是，它的实现已经多次更改。新功能已添加，而不会破坏基本的**应用程序编程接口**（**API**）。建议使用新的函数指针语法，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are pros and cons to both syntaxes. You can learn more about the differences
    between **string-based** and **functor-based** connections at
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语法各有优缺点。您可以在以下链接中了解有关**基于字符串**和**基于函数对象**连接之间的区别的更多信息：
- en: '[https://doc.qt.io/qt-6/signalsandslots-syntaxes.html](https://doc.qt.io/qt-6/signalsandslots-syntaxes.html)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/signalsandslots-syntaxes.html](https://doc.qt.io/qt-6/signalsandslots-syntaxes.html)'
- en: 'If a connection fails, then the preceding statement returns `false`. You can
    also connect to functors or C++11 lambdas, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，则前面的语句返回`false`。您还可以按如下方式连接到函数对象或C++11 lambda：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can check the return value to verify whether the signal connected to the
    slot successfully. The connection can fail if the signatures aren't compatible,
    or the signal and slot are missing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查返回值以验证信号是否成功连接到槽。如果签名不兼容，或者信号和槽缺失，连接可能会失败。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`Qt::UniqueConnection` does not work for lambdas, non-member functions, and
    functors; it can only be used to connect to member functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt::UniqueConnection`不适用于lambda、非成员函数和函数对象；它只能用于连接到成员函数。'
- en: 'The signatures of signals and slots may contain arguments, and these arguments
    may have default values. You can connect a signal to a slot if the signal has
    at least as many arguments as the slot, as well as if there is a possible implicit
    conversion between the types of the corresponding arguments. Let''s look at feasible
    connections with varying numbers of arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽的签名可能包含参数，并且这些参数可能具有默认值。如果信号的参数至少与槽的参数一样多，并且相应参数的类型之间存在可能的隐式转换，则可以将信号连接到槽。让我们看一下具有不同参数数量的可行连接：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, the following one won''t work as the slot has more arguments than
    the signal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，以下情况将无法正常工作，因为槽的参数比信号的参数多：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Every connection you make emits a signal, so duplicate connections emit two
    signals. You can break a connection using `disconnect()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您建立的每个连接都会发射一个信号，因此重复的连接会发射两个信号。您可以使用`disconnect()`来断开连接。
- en: 'You can also use Qt with a third-party signal/slot mechanism. If you want to
    use both mechanisms for the same project, then add the following configuration
    to your Qt project (`.pro`) file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将Qt与第三方信号/槽机制一起使用。如果要在同一项目中使用两种机制，则将以下配置添加到Qt项目（`.pro`）文件中：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's create an example with a simple signal and slot connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的信号和槽连接的示例。
- en: Declaring signals and slots
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明信号和槽
- en: 'To create a signal and slot, you must declare the signal and slot inside your
    custom class. The header file of the class will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建信号和槽，必须在自定义类中声明信号和槽。类的头文件将如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have added `Q_OBJECT` to the class to facilitate the signals
    and slots mechanism. You can declare a signal with the `signals` keyword in your
    header file, as shown in the previous snippet. Similarly, slots can be declared
    with the `slots` keyword. Both signals and slots can have arguments. In this example,
    we used the same object for the sender and receiver to make this explanation simpler.
    In most cases, signals and slots will be located in different classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已向类添加了`Q_OBJECT`以便于信号和槽机制。您可以在头文件中使用`signals`关键字声明信号，如前面的代码片段所示。类似地，可以使用`slots`关键字声明槽。信号和槽都可以带有参数。在此示例中，我们使用相同的对象作为发送者和接收者，以使解释更简单。在大多数情况下，信号和槽将位于不同的类中。
- en: Next, we will discuss how to connect the signal to the slot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何将信号连接到槽。
- en: Connecting the signal to the slot
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将信号连接到槽
- en: 'Previously, we declared a custom signal and slot. Now, let''s look at how to
    connect them. You can define a signal and slot connection and emit the signal
    inside `MyClass`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们声明了一个自定义信号和槽。现在，让我们看看如何连接它们。您可以在`MyClass`内定义信号和槽的连接，并发出信号，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You need to emit the signal after the connection to invoke the slot. In the
    preceding example, we used the traditional way of signal and slot declaration.
    You can replace the connection with the latest syntax, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接后需要发出信号以调用槽。在前面的例子中，我们使用了信号和槽声明的传统方式。您可以将连接替换为最新的语法，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is not only possible to connect one signal to one slot, but also to connect
    many slots and signals. Similarly, many signals can be connected to one slot.
    We will learn how to do that in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以将一个信号连接到一个槽，还可以连接多个槽和信号。同样，许多信号可以连接到一个槽。我们将在下一节中学习如何做到这一点。
- en: Connecting a single signal to multiple slots
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单个信号连接到多个槽
- en: You can connect the same signal to multiple slots. These slots will be called
    in the same order as the connections are made. Let's consider that a signal named
    `signalX()` is connected to three slots called `slotA()`, `slotB()`, and `slotC()`.
    When `signalA()` is emitted, all three slots will be invoked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将相同的信号连接到多个槽。这些槽将按照连接的顺序依次调用。假设一个名为`signalX()`的信号连接到名为`slotA()`、`slotB()`和`slotC()`的三个槽。当发出`signalA()`时，所有三个槽都将被调用。
- en: 'Let''s look at the traditional way of making connections:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看传统的连接方式：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create connections as per the new syntax, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按照新的语法创建连接，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next section, we will learn how to connect multiple signals to a single
    slot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将多个信号连接到单个槽。
- en: Connecting multiple signals to a single slot
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个信号连接到单个槽
- en: 'In the previous section, you learned how to create a connection between a single
    signal and multiple slots. Now, let''s look at the following code to understand
    how to connect multiple signals to a single slot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您学习了如何在单个信号和多个槽之间创建连接。现在，让我们看一下以下代码，以了解如何将多个信号连接到单个槽：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have used three different signals called `signalX()`, `signalY()`,
    and `signalZ()`, but there is a single slot defined as `slotX()`. When any of
    these signals are emitted, that slot is called.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了三个不同的信号，分别是`signalX()`、`signalY()`和`signalZ()`，但是只定义了一个名为`slotX()`的槽。当任何一个这些信号被发出时，都会调用该槽。
- en: In the next section, we will learn how to connect one signal to another signal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将一个信号连接到另一个信号。
- en: Connecting a signal to another signal
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接一个信号到另一个信号
- en: 'Sometimes, you may have to forward a signal instead of directly connecting
    to a slot. You can connect one signal to another signal as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要转发一个信号，而不是直接连接到一个槽。您可以按照以下方式将一个信号连接到另一个信号：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also create connections as per the new syntax, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按照新的语法创建连接，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding line, we have connected `signalA()` to `signalB()`. Hence,
    when `signalA()` is emitted, `signalB()` will also be emitted and the corresponding
    slot connected to `signalB()` will be invoked. Let''s consider that we have a
    button in our GUI, and we want to forward the button click as a different signal.
    The following code snippet shows how to forward a signal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们已经将`signalA()`连接到`signalB()`。因此，当发出`signalA()`时，`signalB()`也将被发出，并且连接到`signalB()`的相应槽将被调用。假设我们的GUI中有一个按钮，并且我们希望将按钮点击转发为不同的信号。以下代码片段显示了如何转发信号：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we forwarded the button click signal to our custom
    signal. We can call the slot that is connected to the custom signal as discussed
    earlier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将按钮点击信号转发到我们的自定义信号。我们可以调用连接到自定义信号的槽，就像之前讨论的那样。
- en: In this section, we learned how connections are made and how to use signals
    and slots. Now, you can communicate between different classes and share information.
    In the next section, we will learn about the working mechanism behind signals
    and slots.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何进行连接以及如何使用信号和槽。现在，你可以在不同的类之间进行通信并共享信息。在下一节中，我们将学习信号和槽背后的工作机制。
- en: The working mechanism of Qt signals and slots
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt信号和槽的工作机制
- en: In the previous sections, we learned about signal and slot syntaxes and how
    to connect them. Now, we will understand how it works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们学习了信号和槽的语法以及如何连接它们。现在，我们将了解它是如何工作的。
- en: While creating a connection, Qt looks for the index of the signal and the slot.
    Qt uses a lookup string table to find the corresponding indexes. Then, a `QObjectPrivate::Connection`
    object is created and added to the internal linked lists. Since one signal can
    be connected to multiple slots, each signal can have a list of the connected slots.
    Each connection contains the receiver's name and the index of the slot. Each object
    has a connection vector that associates with each signal in a linked list of `QObjectPrivate::Connection`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建连接时，Qt会查找信号和槽的索引。Qt使用查找字符串表来找到相应的索引。然后，创建一个`QObjectPrivate::Connection`对象并将其添加到内部链接列表中。由于一个信号可以连接到多个槽，每个信号可以有一个连接的槽列表。每个连接包含接收者的名称和槽的索引。每个对象都有一个连接向量，与`QObjectPrivate::Connection`的链接列表中的每个信号相关联。
- en: 'The following diagram illustrates how `ConnectionList` creates connections
    between sender and receiver objects:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了`ConnectionList`如何在发件人和接收者对象之间创建连接：
- en: '![Figure 6.1 – Illustration of the connection mechanism between the sender
    and receiver'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 发件人和接收者之间连接机制的说明'
- en: '](img/Figure_6.1_B16231.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B16231.jpg)'
- en: Figure 6.1 – Illustration of the connection mechanism between the sender and
    receiver
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 发件人和接收者之间连接机制的说明
- en: '`ConnectionList` is a singly linked list that contains all the connections
    from and to an object. `signalVector` contains the lists of connections for a
    given signal. Each `Connection` is also part of a *senders* linked list. Linked
    lists are used because they permit faster addition and removal of objects. Each
    object also has a reversed list of connections the object is connected to for
    automatic deletion. For detailed internal implementation, look at the latest `qobject_p.h`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectionList`是一个包含与对象之间所有连接的单向链表。`signalVector`包含给定信号的连接列表。每个`Connection`也是*senders*链表的一部分。使用链表是因为它们允许更快地添加和删除对象。每个对象还有一个反向连接列表，用于自动删除对象。有关详细的内部实现，请查看最新的`qobject_p.h`。'
- en: 'There are quite a few articles on how signals and slots work on the *woboq*
    website. You can also explore the Qt source code on the woboq website. Go to the
    following link if you need further information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*woboq*网站上有很多关于信号和槽工作原理的文章。您还可以在woboq网站上探索Qt源代码。如果需要更多信息，请访问以下链接：
- en: '[https://woboq.com/blog/how-qt-signals-slots-work.html](https://woboq.com/blog/how-qt-signals-slots-work.html).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://woboq.com/blog/how-qt-signals-slots-work.html](https://woboq.com/blog/how-qt-signals-slots-work.html)。'
- en: Now, let's learn about Qt's meta-object system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下Qt的元对象系统。
- en: Qt's meta-object system
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt的元对象系统
- en: '**Qt''s meta-object system** is the core mechanism behind the signals and slots
    mechanism. It provides features such as inter-object communication, a dynamic
    property system, and runtime type information.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt的元对象系统**是信号和槽机制背后的核心机制。它提供了诸如对象间通信、动态属性系统和运行时类型信息等功能。'
- en: 'The meta-object system is implemented with a three-part mechanism. These mechanisms
    are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 元对象系统是通过三部分机制实现的。这些机制如下：
- en: QObject
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QObject
- en: Q_OBJECT macro
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q_OBJECT宏
- en: Meta-Object Compiler
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元对象编译器
- en: The `QObject` class is the base class of all Qt objects. It is a very powerful
    mechanism that facilitates the signals and slots mechanism. The `QObject` class
    provides a base class for objects that can take advantage of the meta-object system.
    `QObject` derived classes arrange themselves in an object tree. This creates the
    parent-children relationship between classes. When you create a `QObject` derived
    class with another `QObject` derived class as a parent, the object will be automatically
    added to the parent's `children()` list. The parent takes ownership of the object.
    GUI programming requires both runtime efficiency and a high level of flexibility.
    Qt achieved this by combining the speed of C++ with the flexibility of the Qt
    Object Model. Qt provides the required features by implementing standard C++ techniques
    based on the inheritance from QObject.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject`类是所有Qt对象的基类。它是一个非常强大的机制，可以促进信号和槽机制。`QObject`类为可以利用元对象系统的对象提供了一个基类。`QObject`派生类在对象树中排列，从而在类之间创建了父子关系。当您创建一个`QObject`派生类，并将另一个`QObject`派生类作为父类时，该对象将自动添加到父类的`children()`列表中。父类将拥有该对象。GUI编程需要运行时效率和高度的灵活性。Qt通过将C++的速度与Qt对象模型的灵活性相结合来实现这一点。Qt通过基于从QObject继承的标准C++技术来提供所需的功能。'
- en: 'You can learn more about the Qt Object Model at the following link:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关Qt对象模型的更多信息：
- en: '[https://doc.qt.io/qt-6/object.html](https://doc.qt.io/qt-6/object.html).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/object.html](https://doc.qt.io/qt-6/object.html)。'
- en: The `Q_OBJECT` macro appears inside the private section of the class declaration.
    It is used to enable signals, slots, and other services provided by Qt's meta-object
    system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_OBJECT`宏出现在类声明的私有部分。它用于启用Qt元对象系统提供的信号、槽和其他服务。'
- en: '`QObject` derived classes to implement meta-object features. It provides the
    capability to introspect the objects at runtime. By default, C++ does not have
    introspection support. Hence, Qt created `moc`. It is a code-generating program
    that handles Qt''s C++ extensions. The tool reads the C++ header files and if
    it locates the `Q_OBJECT` macro, then it creates another C++ source file with
    the meta-object code. That generated file contains the code required for the introspection.
    Both files are compiled and linked together. In addition to providing the signals
    and slots mechanism for communication between objects, the meta-object code offers
    several additional features to find the class name and inheritance details, and
    also helps with setting properties at runtime. Qt''s `moc` provides a clean way
    to go beyond the compiled language''s facilities.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject`派生类用于实现元对象特性。它提供了在运行时检查对象的能力。默认情况下，C++不支持内省。因此，Qt创建了`moc`。这是一个处理Qt的C++扩展的代码生成程序。该工具读取C++头文件，如果找到`Q_OBJECT`宏，那么它会创建另一个包含元对象代码的C++源文件。生成的文件包含了内省所需的代码。这两个文件被编译和链接在一起。除了为对象之间的通信提供信号和槽机制之外，元对象代码还提供了几个额外的功能，可以找到类名和继承详情，并且还可以帮助在运行时设置属性。Qt的`moc`提供了一种超越编译语言功能的清晰方式。'
- en: You can perform type casts by using `qobject_cast()` on `QObject` derived classes.
    The `qobject_cast()` function acts similar to the standard C++ `dynamic_cast()`.
    The advantage is that it doesn't require `QObject`, but if you don't add the `Q_OBJECT`
    macro, then the signals and slots and the other meta-object system features will
    not be available. A `QObject` derived class without meta code is equivalent to
    its closest ancestor containing meta-object code. There is also a lighter version
    of the `Q_OBJECT` macro, known as `Q_GADGET`, that can be used to utilize some
    of the capabilities provided by `QMetaObject`. A class that uses `Q_GADGET` doesn't
    have signals or slots.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`qobject_cast()`在`QObject`派生类上执行类型转换。`qobject_cast()`函数类似于标准的C++ `dynamic_cast()`。优点是它不需要`QObject`，但如果您不添加`Q_OBJECT`宏，那么信号和槽以及其他元对象系统功能将不可用。没有元代码的`QObject`派生类等同于包含元对象代码的最近祖先。还有一个更轻量级的`Q_OBJECT`宏的版本，称为`Q_GADGET`，可以用于利用`QMetaObject`提供的一些功能。使用`Q_GADGET`的类没有信号或槽。
- en: We have seen a few new keywords here, such as `Q_OBJECT`, `signals`, `slots`,
    `emit`, `SIGNAL`, and `SLOT`. These are known as the Qt extensions of C++. They
    are very simple macros meant to be seen by `moc`, defined in `qobjectdefs.h`.
    Out of these, `emit` is an empty macro that is not parsed by `moc`. It is kept
    just to give the developer hints.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一些新关键字，如`Q_OBJECT`、`signals`、`slots`、`emit`、`SIGNAL`和`SLOT`。这些被称为C++的Qt扩展。它们是非常简单的宏，旨在被`moc`看到，定义在`qobjectdefs.h`中。其中，`emit`是一个空的宏，不会被`moc`解析。它只是为了给开发人员提供提示。
- en: You can learn about why Qt uses `moc` for signals and slots at [https://doc.qt.io/qt-6/why-moc.html](https://doc.qt.io/qt-6/why-moc.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://doc.qt.io/qt-6/why-moc.html](https://doc.qt.io/qt-6/why-moc.html)了解为什么Qt使用`moc`来处理信号和槽。
- en: In this section, we learned about Qt's meta-object system. In the next section,
    we will discuss the `moc` generated code and discuss some of the underlying implementations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Qt的元对象系统。在下一节中，我们将讨论`moc`生成的代码并讨论一些底层实现。
- en: MOC generated code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MOC生成的代码
- en: 'In this section, we will have a look at the code generated by `moc` in Qt6\.
    When you build the earlier signal and slot example, you will see the generated
    files under the build directory: `moc_myclass.cpp` and `moc_predefs.h`. Let''s
    open the `moc_myclass.cpp` file with a text editor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下Qt6中由`moc`生成的代码。当您构建之前的信号和槽示例时，您会在构建目录下看到生成的文件：`moc_myclass.cpp`和`moc_predefs.h`。让我们用文本编辑器打开`moc_myclass.cpp`文件：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that the information about the Qt Meta-Object Compiler version at
    the top of the file. Please note that all the changes that are made in this file
    will be lost on recompiling the project. So, don't modify anything in this file.
    We are looking at the file to understand the working mechanism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件顶部找到有关Qt元对象编译器版本的信息。请注意，对此文件所做的所有更改将在重新编译项目时丢失。因此，请不要修改此文件中的任何内容。我们正在查看该文件以了解工作机制。
- en: 'Let''s look at the integer data of `QMetaObject`. As you can see, there are
    two columns; the first column is the count, while the second column is the index
    in this array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`QMetaObject`的整数数据。您可以看到有两列；第一列是计数，而第二列是数组中的索引：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we have one method, and the description of the method starts at
    index 14\. You can find the number of available signals in `signalCount`. For
    each function, `moc` also saves the return type of each parameter, their type,
    and their index to the name. In each meta-object, the methods are given an index,
    beginning with 0\. They are arranged as signals, then slots, and then as other
    functions. These indexes are relative indexes and exclude the indexes of parent
    objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个方法，方法的描述从索引14开始。您可以在`signalCount`中找到可用信号的数量。对于每个函数，`moc`还保存每个参数的返回类型、它们的类型和它们的索引到名称。在每个元对象中，方法被赋予一个索引，从0开始。它们按信号、然后是槽，然后是其他函数排列。这些索引是相对索引，不包括父对象的索引。
- en: 'When you look further into the code, you will find the `MyClass::metaObject()`
    function. This function returns `QObject::d_ptr->dynamicMetaObject()` for dynamic
    meta-objects. The `metaObject()` function normally returns the class'' s`taticMetaObject`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进一步查看代码时，您会发现`MyClass::metaObject()`函数。这个函数返回动态元对象的`QObject::d_ptr->dynamicMetaObject()`。`metaObject()`函数通常返回类的`staticMetaObject`：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the incoming string data matches the current class, you must convert this
    pointer into a void pointer and pass it to the outside world. If it is not the
    current class, then `qt_metacast()` of the parent class is called to continue
    the query:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入的字符串数据匹配当前类时，必须将此指针转换为void指针并传递给外部世界。如果不是当前类，则调用父类的`qt_metacast()`来继续查询：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Qt''s meta-object system uses the `qt_metacall()` function to access the meta-information
    for a particular `QObject` object. When we emit a signal, `qt_metacall()` is called
    and then calls the real signal function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的元对象系统使用`qt_metacall()`函数来访问特定`QObject`对象的元信息。当我们发出一个信号时，会调用`qt_metacall()`，然后调用真实的信号函数：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you call a signal, it calls the `moc` generated code, which internally
    calls `QMetaObject::activate()`, as shown in the following snippet. Then, `QMetaObject::activate()`
    looks into the internal data structures to find out about the slots that are connected
    to that signal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个信号时，它调用了`moc`生成的代码，内部调用了`QMetaObject::activate()`，如下面的代码片段所示。然后，`QMetaObject::activate()`查看内部数据结构，以了解连接到该信号的槽。
- en: 'You can find the detailed implementation of this function inside `qobject.cpp`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`qobject.cpp`中找到此函数的详细实现：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By doing this, you can explore the complete generated code and look at the
    symbols further. Now, let''s look at the `moc` generated code where the slot is
    called. The slot is called by its index in the `qt_static_metacall` function,
    as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以探索完整生成的代码并进一步查看符号。现在，让我们看一下`moc`生成的代码，其中调用了槽。槽是通过`qt_static_metacall`函数中的索引来调用的，如下所示：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The array pointers to the argument are in the same format as the signal. `_a[0]`
    is not touched because everything here returns void:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数组指针的格式与信号相同。`_a[0]`没有被触及，因为这里的一切都返回void：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This returns `true` if the signal is connected to at least one receiver; otherwise,
    it returns `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`true`，如果信号连接到至少一个接收器；否则，它将返回`false`。
- en: When an object is destroyed, an `QObjectPrivate::senders` list is iterated,
    and all `Connection::receiver` are set to `0`. Also, `Connection::receiver->connectionLists->dirty`
    is set to `true`. Each `QObjectPrivate::connectionLists` is also iterated to remove
    the **connection** in the senders lists.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被销毁时，`QObjectPrivate::senders`列表被迭代，并且所有`Connection::receiver`被设置为`0`。此外，`Connection::receiver->connectionLists->dirty`被设置为`true`。还要迭代每个`QObjectPrivate::connectionLists`以删除发送者列表中的**连接**。
- en: In this section, we went through some sections of the `moc` generated code and
    understood the working mechanism behind signals and slots. In the next section,
    we will learn about Qt's property system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们浏览了一些`moc`生成的代码部分，并了解了信号和槽背后的工作机制。在下一节中，我们将学习Qt的属性系统。
- en: Getting to know Qt's property system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Qt的属性系统
- en: 'Qt''s property system is similar to some other compiler vendors. However, it
    provides a cross-platform advantage and works with standard compilers supported
    by Qt on different platforms. To add a property, you must add the `Q_PROPERTY()`
    macro to the `QObject` derived class. This property acts like a class data member,
    but it provides extra features that are available through the Meta-Object System.
    A simple syntax looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的属性系统类似于其他一些编译器供应商。但是它提供了跨平台的优势，并且可以与Qt在不同平台上支持的标准编译器一起使用。要添加一个属性，您必须将`Q_PROPERTY()`宏添加到`QObject`派生类中。这个属性就像一个类数据成员，但它提供了通过元对象系统可用的额外功能。一个简单的语法如下所示：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding syntax, we used some of the most common parameters. But there
    are more parameters that are supported in the syntax. You can find out more by
    reading the Qt documentation. Let''s have a look at the following code snippet,
    which uses the `MEMBER` parameter:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的语法中，我们使用了一些最常见的参数。但是语法支持更多的参数。您可以通过阅读Qt文档了解更多信息。让我们看一下下面使用`MEMBER`参数的代码片段：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding snippet, we exported a member variable as a Qt property using
    the `MEMBER` keyword. The type here is `QString`, and the `NOTIFY` signal is used
    to implement QML property binding.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们使用`MEMBER`关键字将一个成员变量导出为Qt属性。这里的类型是`QString`，`NOTIFY`信号用于实现QML属性绑定。
- en: Now, let's explore how to read and write properties with the Meta-Object System.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何使用元对象系统读取和写入属性。
- en: Reading and writing properties with the Meta-Object System
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元对象系统读取和写入属性
- en: 'Let''s create a class named `MyClass`, which is a subclass of `QWidget`. Let''s
    add the `Q_OBJECT` macro to its private section to enable the property system.
    In this example, we want to create a property in `MyClass` to keep track of a
    version''s value. The name of the property will be `version`, and its type will
    be `QString`, which is defined in `MyClass`. Let''s look at the following code
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`MyClass`的类，它是`QWidget`的子类。让我们在其私有部分添加`Q_OBJECT`宏以启用属性系统。在这个例子中，我们想在`MyClass`中创建一个属性来跟踪版本的值。属性的名称将是`version`，其类型将是`QString`，它在`MyClass`中定义。让我们看一下下面的代码片段：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To get the property changed notification, you have to emit `versionChanged()`
    after the `version` value is changed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得属性更改通知，您必须在更改`version`值后发出`versionChanged()`。
- en: 'Let''s have a look at the `main.cpp` file for the preceding example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下上面示例的`main.cpp`文件：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code snippet, the property is set by invoking `setVersion()`.
    You can see that `versionChanged()` signal is emitted every time the version is
    changed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，通过调用`setVersion()`来设置属性。您可以看到每次更改版本时都会发出`versionChanged()`信号。
- en: You can also read a property using `QObject::property()` and write it using
    `QObject::setProperty()`. You can also query dynamic properties using `QObject::property()`,
    similar to compile time `Q_PROPERTY()` declarations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`QObject::property()`读取属性，并使用`QObject::setProperty()`写入属性。您还可以使用`QObject::property()`查询动态属性，类似于编译时的`Q_PROPERTY()`声明。
- en: 'You can also set the property like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以这样设置属性：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, we discussed the property system. In the next section, we will
    learn about signals and slots in Qt Designer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了属性系统。在下一节中，我们将学习Qt Designer中的信号和槽。
- en: Using signals and slots in Qt Designer
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中使用信号和槽
- en: If you are using the Qt Widgets module, then you can use Qt Designer to edit
    signal and slot connections in the form. Qt default widgets come with many signals
    and slots. Let's see how we can implement signals and slots in Qt Designer without
    writing any code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Qt Widgets模块，那么可以使用Qt Designer在表单中编辑信号和槽连接。Qt默认小部件带有许多信号和槽。让我们看看如何在Qt Designer中实现信号和槽而不编写任何代码。
- en: 'You can drag a **Dial** control and a **Slider** control onto the form. You
    can add connections via **Signals and Slots Editor** at the bottom tab, as shown
    in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将**Dial**控件和**Slider**控件拖放到表单上。您可以通过底部选项卡上的**信号和槽编辑器**添加连接，如下面的截图所示：
- en: '![Figure 6.2 – Creating signals and slots connections using Qt Designer'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 使用Qt Designer创建信号和槽连接'
- en: '](img/Figure_6.2_B16231.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B16231.jpg)'
- en: Figure 6.2 – Creating signals and slots connections using Qt Designer
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 使用Qt Designer创建信号和槽连接
- en: Alternatively, you can press *F4* or select the **Edit Signals/Slots** button
    from the top toolbar. Then, you can select the control and create a connection
    by dragging the connection to the receiver. If you have custom signals or slots
    defined for your custom class, they will be automatically displayed in **Signals
    and Slots Editor**. However, most developers prefer to define connections inside
    C++ source files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以按下*F4*或从顶部工具栏中选择**编辑信号/槽**按钮。然后，您可以选择控件并通过将连接拖动到接收器来创建连接。如果您为自定义类定义了自定义信号或槽，它们将自动显示在**信号和槽编辑器**中。但是，大多数开发人员更喜欢在C++源文件中定义连接。
- en: In this section, we discussed using Qt Designer to implement signals and slots
    in Qt Widgets. Now, let's look at how signals are handled in QML.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了使用Qt Designer在Qt Widgets中实现信号和槽。现在，让我们看一下在QML中如何处理信号。
- en: Understanding signals and the handler event system in QML
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解QML中的信号和处理程序事件系统
- en: Previously, we learned how to connect signals and slots inside C++ source files
    and use them with the Qt Widgets module. Now, let's look at how we can communicate
    in QML. QML has a signal and handler mechanism, similar to signals and slots.
    In a QML document, a signal is an event, and the signal is responded to through
    a signal handler. Like a slot in C++, a signal handler is invoked when a signal
    is emitted in QML. In Qt terminology, the method is a slot that is connected to
    the signal; all the methods defined in QML are created as Qt slots. Hence, there
    is no separate declaration for slots in QML. A signal is a notification from an
    object that some event has occurred. You can place logic inside JavaScript or
    a method to respond to the signal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何在C++源文件中连接信号和槽，并在Qt Widgets模块中使用它们。现在，让我们看看如何在QML中进行通信。QML具有类似信号和槽的信号和处理程序机制。在QML文档中，信号是一个事件，通过信号处理程序响应信号。与C++中的槽一样，当在QML中发射信号时，将调用信号处理程序。在Qt术语中，该方法是连接到信号的槽；在QML中定义的所有方法都被创建为Qt槽。因此，在QML中没有单独的槽声明。信号是来自对象的通知，表明发生了某个事件。您可以在JavaScript或方法内放置逻辑以响应信号。
- en: 'Let''s look at how to write a signal handler. You can declare a signal handler
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写信号处理程序。您可以按如下方式声明信号处理程序：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `signalName` is the name of the signal. The first letter of the signal's
    name is capitalized while writing a handler. So, the signal handler here is named
    `onSignalName`. The signal and signal handler should be defined inside the same
    object. The logic inside the signal handler is a block of JavaScript code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`signalName`是信号的名称。在编写处理程序时，信号的名称的第一个字母应大写。因此，这里的信号处理程序被命名为`onSignalName`。信号和信号处理程序应该在同一个对象内定义。信号处理程序内的逻辑是一段JavaScript代码块。
- en: For example, when the user clicks within the mouse area, the `clicked()` signal
    is emitted. To handle the `clicked()` signal, we must add the `onClicked:{…}`
    signal handler.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户在鼠标区域内点击时，将发射`clicked()`信号。要处理`clicked()`信号，我们必须添加`onClicked:{...}`信号处理程序。
- en: Signal handlers are simple functions that are invoked by the QML engine when
    an associated signal is emitted. When you add a signal to a QML object, Qt automatically
    adds a corresponding signal handler to the object definition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序是由QML引擎在关联信号被发射时调用的简单函数。当您向QML对象添加信号时，Qt会自动向对象定义中添加相应的信号处理程序。
- en: Let's start by adding a custom signal to a QML document.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在QML文档中添加一个自定义信号。
- en: Adding a signal in QML
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在QML中添加信号
- en: 'To add a signal inside your QML class, you must use the `signal` keyword. The
    syntax for defining a new signal is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要在QML类中添加信号，必须使用`signal`关键字。定义新信号的语法如下：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is an example of this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A signal can be declared with or without any parameters. If no parameter is
    declared for the signal, then you can leave `()` brackets. You can emit a signal
    by invoking it as a function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以带参数也可以不带参数。如果没有为信号声明参数，则可以省略`()`括号。您可以通过调用它作为函数来发射信号：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we added a custom signal `composeMessage()` to the
    QML file. We used the corresponding signal handler; that is, `onComposeMessage()`.
    Then, we added a button that emits the `composeMessage()` signal when it is clicked.
    When you run this example, you will see that the signal handler is called automatically
    when the button is clicked.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在QML文件中添加了一个自定义信号`composeMessage()`。我们使用了相应的信号处理程序`onComposeMessage()`。然后，我们添加了一个按钮，当点击按钮时会发射`composeMessage()`信号。当您运行此示例时，您将看到在点击按钮时信号处理程序会自动调用。
- en: In this section, you learned how to declare a signal and how to implement the
    corresponding signal handler. In the next section, we will connect the signal
    to a function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何声明信号以及如何实现相应的信号处理程序。在下一节中，我们将把信号连接到函数。
- en: Connecting a signal to a function
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将信号连接到函数
- en: You can connect a signal to any function defined inside your QML document. You
    can use `connect()` to connect a signal either to a function or another signal.
    When a signal is connected to a function, that function is automatically invoked
    whenever the signal is emitted. This mechanism enables a signal to be received
    by a function instead of a signal handler.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将信号连接到QML文档中定义的任何函数。您可以使用`connect()`将信号连接到函数或另一个信号。当信号连接到函数时，每当信号被发射时，该函数将自动调用。这种机制使得信号可以被函数而不是信号处理程序接收。
- en: 'In the following snippet, the `composeMessage()` signal is connected to the
    `transmitMessage()` function using the `connect()` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，使用`connect()`函数将`composeMessage()`信号连接到`transmitMessage()`函数：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In QML, signal handling is implemented using the following syntax:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中，信号处理是使用以下语法实现的：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also remove a connection using the `disconnect()` function. You can
    disconnect the connection like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`disconnect()`函数来删除连接。您可以这样断开连接：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let's explore how to forward a signal in QML.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何在QML中转发信号。
- en: Connecting a signal to a signal
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将信号连接到另一个信号
- en: You can connect a signal to another signal in QML. You can achieve this using
    the `connect()` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在QML中将信号连接到另一个信号。您可以使用`connect()`函数实现这一点。
- en: 'Let''s explore how we can do this by looking at the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来探讨如何做到这一点：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, we connected the `clicked()` signal to the `forwardButtonClick()`
    signal. You can implement the necessary logic at the root level inside the `onForwardButtonClick()`
    signal handler. You can also emit the signal from the button click handler, as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`clicked()`信号连接到`forwardButtonClick()`信号。您可以在`onForwardButtonClick()`信号处理程序内部的根级别实现必要的逻辑。您还可以从按钮点击处理程序中发射信号，如下所示：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this section, we discussed how to connect two signals and handle them. In
    the next section, we will discuss how to communicate between the C++ class and
    QML using signals and slots.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何连接两个信号并处理它们。在下一节中，我们将讨论如何使用信号和槽在C++类和QML之间进行通信。
- en: Defining property attributes and understanding property binding
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义属性属性并理解属性绑定
- en: 'Previously, we learned how to define a type in C++ by registering the `Q_PROPERTY`
    of a class, which is then registered with the QML type system. It is also possible
    to create custom properties in a QML document. Property binding is a core feature
    of QML that allows us to create relationships between various object properties.
    You can declare a property in a QML document with the following syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何通过注册类的`Q_PROPERTY`来定义C++中的类型，然后将其注册到QML类型系统中。在QML文档中也可以创建自定义属性。属性绑定是QML的核心特性，允许我们创建各种对象属性之间的关系。您可以使用以下语法在QML文档中声明属性：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this way, you can expose a particular parameter to outside objects or maintain
    internal states more efficiently. Let''s look at the following property declaration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以将特定参数暴露给外部对象，或更有效地维护内部状态。让我们看一下以下属性声明：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you declare a custom property, Qt implicitly creates a property-change
    signal for that property. The associated signal handler is `on<PropertyName>Changed`,
    where `<PropertyName>` is the name of the property, with the first letter capitalized.
    For the previously declared property, the associated signal handler is `onVersionChanged`,
    as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明自定义属性时，Qt会隐式创建该属性的属性更改信号。相关的信号处理程序是`on<PropertyName>Changed`，其中`<PropertyName>`是属性的名称，首字母大写。对于先前声明的属性，相关的信号处理程序是`onVersionChanged`，如下所示：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the property is assigned a static value, then it remains constant until
    it is explicitly assigned a new value. To update these values dynamically, you
    should use property binding inside your QML document. We used simple property
    binding earlier, as shown in the following snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性被分配了静态值，那么它将保持不变，直到显式分配新值。要动态更新这些值，您应该在QML文档中使用属性绑定。我们之前使用了简单的属性绑定，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we can combine this with the property that''s exposed by the backend
    C++ class, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以将其与后端C++类暴露的属性结合使用，如下所示：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous line, `myClass` is the backend C++ object that's registered
    with the QML engine. In this case, whenever the `versionChanged()` change signal
    is emitted from the C++ side, the QML `version` property gets updated automatically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，`myClass`是已在QML引擎中注册的后端C++对象。在这种情况下，每当从C++端发出`versionChanged()`变化信号时，QML的`version`属性会自动更新。
- en: Next, we'll discuss how to integrate signals and slots between C++ and QML.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在C++和QML之间集成信号和槽。
- en: Integrating signals and slots between C++ and QML
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++和QML之间集成信号和槽
- en: In C++, to interact with the QML layer, you can use signals, slots, and `Q_INVOKABLE`
    functions. You can also create properties using the `Q_PROPERTY` macro. To respond
    to signals from objects, you can use the `Connections` QML type. When a property
    changes inside a C++ file, `Q_PROPERTY` automatically updates the values. If the
    property has a binding with any QML property, it will automatically update the
    property values inside QML. In this case, the signal slot mechanism is established
    automatically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，要与QML层交互，可以使用信号、槽和`Q_INVOKABLE`函数。您还可以使用`Q_PROPERTY`宏创建属性。要响应来自对象的信号，可以使用`Connections`
    QML类型。当C++文件中的属性发生变化时，`Q_PROPERTY`会自动更新值。如果属性与任何QML属性绑定，它将自动更新QML中的属性值。在这种情况下，信号槽机制会自动建立。
- en: 'Let''s look at the following example, which uses the aforementioned mechanism:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例，它使用了上述的机制：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, we declared a Q_PROPERTY-based notification. We can
    get the new `counter` value when the `counterChanged()` signal is emitted. However,
    we used the `receiveFromQml()` function as a `Q_INVOKABLE` function so that we
    can call it directly inside the QML document. We are emitting `sendToQml()`, which
    is handled inside `main.qml`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明了基于Q_PROPERTY的通知。当发出`counterChanged()`信号时，我们可以获取新的`counter`值。然而，我们使用了`receiveFromQml()`函数作为`Q_INVOKABLE`函数，这样我们就可以直接在QML文档中调用它。我们正在发出`sendToQml()`，这在`main.qml`中进行处理：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s have a look at the QML implementation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下QML的实现：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding example, we used `Connections` to connect to the C++ signal.
    On button click, we are calling the `receiveFromQml()` C++ function, where we
    are emitting the signal. We have also declared the `count` property, which also
    listens to `counterChanged()`. We handled the data inside the associated signal
    handler; that is, `onCountChanged`. We can also update the `labelCount` data based
    on the notification:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`Connections`来连接到C++信号。在按钮点击时，我们调用`receiveFromQml()` C++函数，在那里我们发出信号。我们还声明了`count`属性，它也监听`counterChanged()`。我们在相关的信号处理程序`onCountChanged`中处理数据；也就是说，我们也可以根据通知更新`labelCount`数据：
- en: '![Figure 6.3 – The mechanism that was used in this example'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 在这个例子中使用的机制'
- en: '](img/Figure_6.3_B16231.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B16231.jpg)'
- en: Figure 6.3 – The mechanism that was used in this example
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - 在这个例子中使用的机制
- en: The preceding diagram illustrates the communication mechanism in this example.
    For explanation purposes, we have kept multiple approaches in the same example
    to explain the communication mechanism between C++ and QML.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上图说明了此示例中的通信机制。为了解释的目的，我们在同一个示例中保留了多种方法，以解释C++和QML之间的通信机制。
- en: In this section, you learned about the signals and slots mechanism through examples.
    In the next section, we will learn about events and the event loop in Qt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您通过示例学习了信号和槽机制。在下一节中，我们将学习Qt中的事件和事件循环。
- en: Understanding events and the event loop
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件和事件循环
- en: Qt is an event-based system, and all GUI applications are event-driven. In an
    event-driven application, there is usually a main loop that listens for events
    and then triggers a callback function when one of those events is detected. Events
    can be spontaneous or synthetic. Spontaneous events come from the outside environment.
    Synthetic events are custom events generated by the application. An event in Qt
    is a notification that represents something that has happened. Qt events are value
    types, derived from `QEvent`, which offers a type enumeration for each event.
    All events that arise inside a Qt application are encapsulated in objects that
    inherit from the `QEvent` class. All `QObject` derived classes can override the
    `QObject::event()` function in order to handle events targeted by their instances.
    Events can come from both inside and outside the application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个基于事件的系统，所有GUI应用程序都是事件驱动的。在事件驱动的应用程序中，通常有一个主循环，它监听事件，然后在检测到其中一个事件时触发回调函数。事件可以是自发的或合成的。自发事件来自外部环境。合成事件是应用程序生成的自定义事件。在Qt中，事件是表示已发生的事情的通知。Qt事件是值类型，派生自`QEvent`，为每个事件提供了类型枚举。在Qt应用程序内部产生的所有事件都封装在从`QEvent`类继承的对象中。所有`QObject`派生类都可以重写`QObject::event()`函数，以处理其实例所针对的事件。事件可以来自应用程序内部和外部。
- en: 'When an event occurs, Qt produces an event object by constructing an appropriate
    `QEvent` subclass instance, which it then delivers to the specific instance of
    `QObject` by calling its `event()` function. Unlike the signals and slots mechanism,
    where the slots connected to the signal are usually executed immediately, an event
    must wait for its turn, until the event loop dispatches all the events that arrived
    earlier. You must select the right mechanism as per your intended implementation.
    The following diagram illustrates how events are created and managed in event-driven
    applications:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，Qt通过构造适当的`QEvent`子类实例来产生一个事件对象，然后通过调用其`event()`函数将其传递给特定的`QObject`实例。与信号和槽机制不同，信号连接的槽通常会立即执行，事件必须等待其轮次，直到事件循环分发所有先前到达的事件。您必须根据您的预期实现选择正确的机制。以下图表说明了事件在事件驱动应用程序中是如何创建和管理的：
- en: '![Figure 6.4 – Illustration of an event-driven application using the event
    loop'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 - 使用事件循环的事件驱动应用程序的说明'
- en: '](img/Figure_6.4_B16231.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B16231.jpg)'
- en: Figure 6.4 – Illustration of an event-driven application using the event loop
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 - 使用事件循环的事件驱动应用程序的说明
- en: We can enter Qt's main event loop by calling `QCoreApplication::exec()`. The
    application keeps running until `QCoreApplication::exit()` or `QCoreApplication::quit()`
    are called, which terminates the loop. `QCoreApplication` can process each event
    in the GUI thread and forward events to QObjects. Please note that the events
    are not delivered immediately; instead, they're queued up in an event queue and
    processed later, one after another. The event dispatcher loops through this queue,
    converts them into `QEvent` objects, and then dispatches the events to the target
    `QObject`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`QCoreApplication::exec()`进入Qt的主事件循环。应用程序会一直运行，直到调用`QCoreApplication::exit()`或`QCoreApplication::quit()`，这将终止循环。`QCoreApplication`可以在GUI线程中处理每个事件并将事件转发给QObjects。请注意，事件不会立即传递；相反，它们会排队在事件队列中，并稍后依次处理。事件调度程序循环遍历此队列，将它们转换为`QEvent`对象，然后将事件分派到目标`QObject`。
- en: 'A simplified event loop dispatcher may look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的事件循环调度器可能如下所示：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Some of the important Qt classes related to the event loop are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件循环相关的一些重要Qt类如下：
- en: '`event` queue.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`队列。'
- en: '`event` loop.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`循环。'
- en: '`event` loop for non-GUI based applications.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非GUI应用程序的`event`循环。
- en: '`event` loop for GUI-based applications.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI应用程序的`event`循环。
- en: '**QThread** is used to create custom threads and manage threads.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QThread**用于创建自定义线程和管理线程。'
- en: '**QSocketNotifier** is used to monitor activity on a file descriptor.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QSocketNotifier**用于监视文件描述符上的活动。'
- en: '`event` loop.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`循环。'
- en: 'You can read about these classes in the Qt documentation. The following link
    provides further insight into the event system:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Qt文档中了解这些类。以下链接提供了有关事件系统的更深入了解：
- en: '[https://wiki.qt.io/Threads_Events_QObjects](https://wiki.qt.io/Threads_Events_QObjects).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.qt.io/Threads_Events_QObjects](https://wiki.qt.io/Threads_Events_QObjects)。'
- en: In this section, we discussed events and Qt's event loop. In the next section,
    we will learn how to filter events with an event filter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了事件和Qt的事件循环。在下一节中，我们将学习如何使用事件过滤器过滤事件。
- en: Managing events with an event filter
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件过滤器管理事件
- en: In this section, you will learn how to manage events and how to filter a specific
    event and perform a task. You can achieve event filtering by reimplementing event
    handlers and installing event filters. You can redefine what an event handler
    should do by subclassing the widget of interest and reimplementing that event
    handler.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何管理事件，如何过滤特定事件并执行任务。您可以通过重新实现事件处理程序和安装事件过滤器来实现事件过滤。您可以通过对感兴趣的小部件进行子类化并重新实现该事件处理程序来重新定义事件处理程序应该执行的操作。
- en: 'Qt provides five different approaches for event processing, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了五种不同的事件处理方法，如下所示：
- en: Reimplementing a specific event handler, such as `paintEvent()`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新实现特定事件处理程序，如`paintEvent()`
- en: Reimplementing the `QObject::event()` function
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新实现`QObject::event()`函数
- en: Installing an event filter on the `QObject` instance
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`QObject`实例上安装事件过滤器
- en: Installing an event filter on the `QApplication` instance
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`QApplication`实例上安装事件过滤器
- en: Subclassing `QApplication` and reimplementing `notify()`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化`QApplication`并重新实现`notify()`
- en: 'The following code handles the left mouse button click on a custom widget while
    passing all other button clicks to the base `QWidget` class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了自定义小部件上的鼠标左键单击，同时将所有其他按钮点击传递给基类`QWidget`：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the previous example, we filtered only the left button press event. You
    can add the required action inside the respective block. The following diagram
    illustrates the high-level event processing mechanism:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们仅过滤了左键按下事件。您可以在相应的块内添加所需的操作。以下图示了高级事件处理机制：
- en: '![Figure 6.5 – Illustration of the event filter mechanism'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 - 事件过滤器机制的说明'
- en: '](img/Figure_6.5_B16231.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.5_B16231.jpg)'
- en: Figure 6.5 – Illustration of the event filter mechanism
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 事件过滤器机制的说明
- en: 'An event filter can be installed either on an application instance or a local
    object. If the event filter is installed in an `QCoreApplication` object, then
    all the events will go through this event filter. If it is installed in a `QObject`
    derived class, then the events that have been sent to that object will go through
    the event filter. Sometimes, there may not be any suitable Qt event type available
    for a specific action. In that case, you can create a custom event by creating
    a subclass from `QEvent`. You can reimplement `QObject::event()` to filter the
    intended event, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 事件过滤器可以安装在应用程序实例或本地对象上。如果事件过滤器安装在`QCoreApplication`对象中，则所有事件将通过此事件过滤器。如果它安装在派生自`QObject`的类中，则发送到该对象的事件将通过事件过滤器。有时，可能没有适合特定操作的Qt事件类型。在这种情况下，可以通过从`QEvent`创建子类来创建自定义事件。您可以重新实现`QObject::event()`以过滤所需的事件，如下所示：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we have created a custom event class named `MyCustomEvent` and created
    a custom type.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`MyCustomEvent`的自定义事件类，并创建了一个自定义类型。
- en: 'Now, let''s filter these events by reimplementing `event()`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过重新实现`event()`来过滤这些事件：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, we have passed the other events to `QWidget::event()` for further
    processing. If you want to prevent the event from propagating further, then `return
    true`; otherwise, `return false`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将其他事件传递给`QWidget::event()`以进行进一步处理。如果要阻止事件进一步传播，则`return true`；否则，`return
    false`。
- en: An event filter is an object that receives all the events that are sent to an
    object. The filter can either stop the event or forward it to the object. It screens
    the events if an object has been installed as an event filter for the watched
    object. It is also possible to monitor another object for events by using an event
    filter and performing the necessary tasks. The following example shows how to
    reimplement one of the most commonly used events – a keypress event – using the
    *event filter* approach.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 事件过滤器是一个接收发送到对象的所有事件的对象。过滤器可以停止事件或将其转发给对象。如果对象已被安装为监视对象的事件过滤器，则它会筛选事件。还可以使用事件过滤器监视另一个对象的事件并执行必要的任务。以下示例显示了如何使用*事件过滤器*方法重新实现最常用的事件之一
    - 按键事件。
- en: 'Let''s have a look at the following code snippet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we created a class called `MainWindow` and overridden
    `eventFilter()`. Let''s install the filter on `textEdit` using `installEventFilter()`.
    You can install multiple event filters on an object. However, if multiple event
    filters are installed on a single object, the filter that was installed last will
    be activated first. You can also remove an event filter by calling `removeEventFilter()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`MainWindow`的类，并重写了`eventFilter()`。让我们使用`installEventFilter()`在`textEdit`上安装过滤器。您可以在一个对象上安装多个事件过滤器。但是，如果在单个对象上安装了多个事件过滤器，则最后安装的过滤器将首先被激活。您还可以通过调用`removeEventFilter()`来移除事件过滤器：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we installed an `eventFilter` on the `textEdit` object.
    Now, let''s have a look at the `eventFilter()` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`textEdit`对象上安装了一个`eventFilter`。现在，让我们看一下`eventFilter()`函数：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, `textEdit` is the monitored object. Every time you press a key and if
    the `textEdit` is in focus, the event is captured. Since there may more objects
    that are children and `QMainWindow` may require the events, don't forget to pass
    the unhandled events to the base class for further event processing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`textEdit`是被监视的对象。每次按键时，如果`textEdit`处于焦点状态，则会捕获事件。由于可能有更多的子对象和`QMainWindow`可能需要事件，不要忘记将未处理的事件传递给基类以进行进一步的事件处理。
- en: Important note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once you've consumed the event in the `eventFilter()` function, make sure to
    `return true`. If the receiver object is deleted and you `return false`, then
    it can result in an application crash.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eventFilter()`函数中消耗了事件后，确保`return true`。如果接收对象被删除并且`return false`，那么可能导致应用程序崩溃。
- en: You can also combine the signals and slots mechanism with the event. You can
    achieve this by filtering the event and emitting a signal that corresponds to
    that event. I hope that you have understood the event handling mechanism in Qt.
    Now, let's look at drag and drop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将信号和槽机制与事件结合使用。您可以通过过滤事件并发出与该事件对应的信号来实现这一点。希望您已经了解了Qt中的事件处理机制。现在，让我们来看看拖放。
- en: Drag and drop
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: In this section, we will learn about **drag and drop** (**DnD**). In a GUI application,
    DnD is a pointing device gesture in which the user selects a virtual object by
    *grabbing* it and then *releasing* it on another virtual object. The drag and
    drop operation starts when the user makes some gesture that is recognized as a
    signal to start a drag action.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习**拖放**（**DnD**）。在GUI应用程序中，DnD是一种指向设备手势，用户通过*抓取*虚拟对象然后*释放*到另一个虚拟对象来选择虚拟对象。拖放操作在用户进行被识别为开始拖动操作的手势时开始。
- en: Let's discuss how we can implement drag and drop using Qt Widgets.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何使用Qt小部件实现拖放。
- en: Drag and drop in Qt Widgets
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt小部件中的拖放
- en: 'In Qt Widgets-based GUI applications, where drag and drop is used, the user
    starts dragging from a particular widget and drops the dragged object onto another
    widget. This requires us to reimplement several functions and it handles the corresponding
    events. The most common functions that need to be reimplemented to achieve drag
    and drop are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Qt Widgets的GUI应用程序中，使用拖放时，用户从特定的小部件开始拖动，并将被拖动的对象放到另一个小部件上。这要求我们重新实现几个函数并处理相应的事件。需要重新实现的最常见函数如下：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you''ve reimplemented the preceding functions, enable dropping on the
    target widget with the following statement:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您重新实现了上述函数，可以使用以下语句在目标小部件上启用放置：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To begin a drag, create a `QDrag` object and pass a pointer to the widget that
    begins the drag. The drag and drop operation is handled by a `QDrag` object. This
    operation requires the attached data description to be of the **Multipurpose Internet
    Mail Extensions** (**MIME**) type:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始拖动，创建一个`QDrag`对象，并传递一个指向开始拖动的小部件的指针。拖放操作由`QDrag`对象处理。此操作要求附加数据描述为**多用途互联网邮件扩展**（**MIME**）类型。
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code shows how to create a drag object and set a custom MIME type.
    Here, we used `text/csv` as the MIME type. You can supply more than one type of
    MIME-encoded data with a drag and drop operation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码显示了如何创建一个拖动对象并设置自定义MIME类型。在这里，我们使用`text/csv`作为MIME类型。您可以使用拖放操作提供多种类型的MIME编码数据。
- en: To intercept drag and drop events, you can reimplement `dragEnterEvent()`. This
    event handler is called when a drag is in progress and the mouse enters the widget.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截拖放事件，可以重新实现`dragEnterEvent()`。当拖动正在进行并且鼠标进入小部件时，将调用此事件处理程序。
- en: You can find several relevant examples in the examples section in Qt Creator.
    Since Qt Widgets aren't very popular these days, we are skipping the drag and
    drop example using widgets. In the next section, we will discuss drag and drop
    in QML.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Qt Creator的示例部分中找到几个相关示例。由于Qt小部件在当今并不十分流行，我们将跳过使用小部件进行拖放的示例。在下一节中，我们将讨论QML中的拖放。
- en: Drag and drop in QML
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在QML中进行拖放
- en: In the previous section, we discussed drag and drop using widgets. Since QML
    is used to create modern and touch-friendly applications, drag and drop is a very
    important feature. Qt provides several convenient QML types for implementing drag
    and drop. Internally, the corresponding events are handled similarly. These functions
    are declared in the `QQuickItem` class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了使用小部件进行拖放。由于QML用于创建现代和触摸友好的应用程序，拖放是一个非常重要的功能。Qt提供了几种方便的QML类型来实现拖放。在内部，相应的事件处理方式是相似的。这些函数在`QQuickItem`类中声明。
- en: 'For example, `dragEnterEvent()` is also available in `QQuickItem`, and is used
    to intercept drag and drop events, as described here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`dragEnterEvent()`也在`QQuickItem`中可用，用于拦截拖放事件，如下所述：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let's discuss how to implement this using the available QML types. Using the
    `Drag` attached property, any `Item` can be made a source of drag and drop events
    within a QML scene. A `DropArea` is an invisible item that can receive events
    when an item is dragged over it. When a drag action is active on an item, any
    change that's made to its position will generate a drag event that will be sent
    to any intersecting `DropArea`. The `DragEvent` QML type provides information
    about a drag event.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何使用可用的QML类型来实现这一点。使用`Drag`附加属性，任何`Item`都可以在QML场景中成为拖放事件的源。`DropArea`是一个可以在其上拖动项目时接收事件的不可见项目。当项目上存在拖动操作时，对其位置进行的任何更改都将生成一个拖动事件，该事件将发送到任何相交的`DropArea`。`DragEvent`
    QML类型提供有关拖动事件的信息。
- en: 'The following code snippet shows a simple drag and drop operation in QML:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在QML中进行简单拖放操作：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, we created a draggable item with an ID of `dragItem`.
    It contains a `MouseArea` to capture the mouse press event. Dragging is not limited
    to mouse drags. A drag action can be triggered by anything that can generate a
    drag event. A drag can be canceled by calling `Drag.cancel()` or by setting the
    `Drag.active` state to `false`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个ID为`dragItem`的可拖动项。它包含一个`MouseArea`来捕获鼠标按下事件。拖动不仅限于鼠标拖动。任何可以生成拖动事件的东西都可以触发拖动操作。可以通过调用`Drag.cancel()`或将`Drag.active`状态设置为`false`来取消拖动。
- en: 'The drop action can be completed with a drop event by calling `Drag.drop()`.
    Let''s add a `DropArea`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Drag.drop()`可以完成放置操作。让我们添加一个`DropArea`：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding snippet, we used a light blue rectangle to distinguish it as
    a `DropArea` on the screen. We are catching `dragItem` when it enters the `DropArea`
    region. When `dragItem` is leaving the `DropArea` region, the drop action is disabled.
    Therefore, when the drop is unsuccessful, the item will go back to its original
    position.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们使用浅蓝色矩形将其区分为屏幕上的`DropArea`。当`dragItem`进入`DropArea`区域时，我们捕获它。当`dragItem`离开`DropArea`区域时，放置操作被禁用。因此，当放置不成功时，项目将返回到其原始位置。
- en: In this section, we learned about drag and drop actions and their corresponding
    events. We discussed how to implement them using the Qt Widgets module, as well
    as in QML. Now, let's summarize what we learned in this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了拖放操作及其相应的事件。我们讨论了如何在Qt Widgets模块以及在QML中实现它们。现在，让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the core concepts of signals and slots in Qt.
    We discussed different ways of connecting signals and slots. We also learned how
    to connect one signal to multiple slots and multiple signals to a single slot.
    Then, we looked at how to use them with Qt Widgets, as well as in QML, as well
    as the mechanism behind the signal and slot connection. After that, you learned
    how to communicate between C++ and QML using signals and slots.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Qt中信号和槽的核心概念。我们讨论了连接信号和槽的不同方式。我们还学习了如何将一个信号连接到多个槽，以及多个信号连接到单个槽。然后，我们看了如何在Qt小部件中使用它们，以及在QML中使用它们，以及信号和槽连接背后的机制。之后，您学会了如何使用信号和槽在C++和QML之间进行通信。
- en: This chapter also discussed events and event loops in Qt. We explored how to
    use events instead of the signal-slot mechanism. After doing this, we created
    a sample program with a custom event handler to capture events and filter them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了Qt中的事件和事件循环。我们探讨了如何使用事件而不是信号槽机制。在这之后，我们创建了一个带有自定义事件处理程序的示例程序，以捕获事件并对其进行过滤。
- en: After learning about events, we implemented a simple drag and drop example.
    Now, you can communicate between classes, between C++ and QML, and implement the
    necessary actions based on events.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了事件之后，我们实现了一个简单的拖放示例。现在，您可以在类之间、在C++和QML之间进行通信，并根据事件实现必要的操作。
- en: In the next chapter, we will learn about Model View programming and how to create
    custom models.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于模型视图编程以及如何创建自定义模型。
