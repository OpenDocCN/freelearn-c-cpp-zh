- en: Chapter 8. Integrating C++ and the Unreal Editor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。集成C++和虚幻编辑器
- en: 'In this chapter, we will cover following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Using a class or `struct` as a blueprint variable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类或结构作为蓝图变量
- en: Creating classes or structs that can be subclassed in Blueprint
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中作为子类化的类或结构
- en: Creating functions that can be called in Blueprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中调用的函数
- en: Creating events that can be implemented in Blueprint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中实现的事件
- en: Exposing multi-cast delegates to Blueprint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多播委托公开给蓝图
- en: Creating C++ enums that can be used in Blueprint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中使用的C++枚举
- en: Editing class properties in different places in the editor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑器中的不同位置编辑类属性
- en: Making properties accessible in the Blueprint editor graph
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使属性在蓝图编辑器图中可访问
- en: Responding to property – changed events from the editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应编辑器中的属性更改事件
- en: Implementing a native code Construction Script
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现本地代码构造脚本
- en: Creating a new editor module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器模块
- en: Creating new toolbar buttons
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的工具栏按钮
- en: Creating new menu entries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的菜单项
- en: Creating a new editor window
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器窗口
- en: Creating a new Asset type
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的资产类型
- en: Creating custom context menu entries for Assets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资产创建自定义上下文菜单项
- en: Creating new console commands
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的控制台命令
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为蓝图创建一个新的图钉可视化器
- en: Inspecting types with custom **Details** panels
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义详细信息面板检查类型
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of Unreal's primary strengths is that it provides programmers with the ability
    to create Actors and other objects that can be customized or used by designers
    in the editor. This chapter shows how. Following that, we will try to customize
    the editor by creating custom Blueprint and Animation nodes from scratch. We will
    also implement custom editor windows and custom **Details** panels for inspecting
    the types created by users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻的主要优势之一是它为程序员提供了创建可以由设计师在编辑器中自定义或使用的角色和其他对象的能力。本章展示了如何实现这一点。在此之后，我们将尝试通过从头开始创建自定义蓝图和动画节点来自定义编辑器。我们还将实现自定义编辑器窗口和用于检查用户创建的类型的自定义详细信息面板。
- en: Using a class or struct as a blueprint variable
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类或结构作为蓝图变量
- en: Types that you declare in C++ do not automatically get incorporated into Blueprint
    for use as variables. This recipe shows you how to make them accessible so that
    you can use custom native code types as Blueprint function parameters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中声明的类型不会自动并入蓝图以用作变量。此示例向您展示如何使它们可访问，以便您可以将自定义本地代码类型用作蓝图函数参数。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new class using the editor. Unlike previous chapters, we are going
    to create an Object-based class. Object isn't visible in the default list of common
    classes, so we need to tick the **Show all classes** button in the editor UI,
    then select **Object**. Call your new **Object** subclass `TileType`.![How to
    do it…](img/00136.jpeg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个新的类。与之前的章节不同，我们将创建一个基于对象的类。对象在常见类列表中不可见，因此我们需要在编辑器UI中选中“显示所有类”按钮，然后选择“对象”。将您的新“对象”子类命名为“TileType”。![如何操作...](img/00136.jpeg)
- en: 'Add the following properties to the `TileType` definition:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到“TileType”定义中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile your code.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码。
- en: Inside the editor, create a new Blueprint class based on `Actor`. Call it `Tile`.![How
    to do it…](img/00137.jpeg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，基于“Actor”创建一个新的蓝图类。将其命名为“Tile”。![如何操作...](img/00137.jpeg)
- en: Within the blueprint editor for `Tile`, add a new variable to the Blueprint.
    Check the list of types that you can create as variables, and verify that `TileType`
    is not there.![How to do it…](img/00138.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Tile”的蓝图编辑器中，向蓝图添加一个新变量。检查您可以创建为变量的类型列表，并验证“TileType”是否不在其中。![如何操作...](img/00138.jpeg)
- en: 'Add `BlueprintType` to the `UCLASS` macro as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“BlueprintType”添加到“UCLASS”宏中，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Recompile the project, then return to the `Tile` blueprint editor.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译项目，然后返回到“Tile”蓝图编辑器。
- en: Now when you add a new variable to your actor, you can select `TileType` as
    the type for your new variable.![How to do it…](img/00139.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您向角色添加新变量时，可以选择“TileType”作为新变量的类型。![如何操作...](img/00139.jpeg)
- en: We've now established a "has-a" relationship between `Tile` and `TileType`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经建立了“Tile”和“TileType”之间的“有一个”关系。
- en: Now `TileType` is a Blueprint type that can be used as a function parameter.
    Create a new function on your `Tile` blueprint called `SetTileType`.![How to do
    it…](img/00140.jpeg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，“TileType”是一个可以用作函数参数的蓝图类型。在您的“Tile”蓝图上创建一个名为“SetTileType”的新函数。![如何操作...](img/00140.jpeg)
- en: Add a new input:![How to do it…](img/00141.jpeg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的输入：![如何操作...](img/00141.jpeg)
- en: Set the input parameter's type to `TileType`.![How to do it…](img/00142.jpeg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入参数的类型设置为“TileType”。![如何操作...](img/00142.jpeg)
- en: You can drag our `Type` variable into the viewport, and select **Set**.![How
    to do it…](img/00143.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将我们的“Type”变量拖动到视口中，并选择“设置”。![如何操作...](img/00143.jpeg)
- en: Assign the **Exec** pin and input parameter from `SetTileType` to the **Set**
    node.![How to do it…](img/00144.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“SetTileType”的**Exec**引脚和输入参数连接到**Set**节点。![如何操作...](img/00144.jpeg)
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For performance reasons, Unreal assumes that classes do not require the extra
    reflection code that is needed to make the type available to Blueprint.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于性能原因，虚幻假设类不需要额外的反射代码，以使类型可用于蓝图。
- en: We can override this default by specifying `BlueprintType` in our `UCLASS` macro.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的“UCLASS”宏中指定“BlueprintType”来覆盖此默认值。
- en: With the specifier included, the type is now made available as a parameter or
    variable in Blueprint.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含说明符后，该类型现在可以作为蓝图中的参数或变量使用。
- en: There's more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe shows that you can use a type as a function parameter in Blueprint
    if its native code declaration includes `BlueprintType`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示，如果其本地代码声明包括“BlueprintType”，则可以在蓝图中使用类型作为函数参数。
- en: However, at the moment, none of the properties that we defined in C++ are accessible
    to Blueprint.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前我们在C++中定义的属性都无法在蓝图中访问。
- en: Other recipes in this chapter deal with making those properties accessible so
    that we can actually do something meaningful with our custom objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其他示例涉及使这些属性可访问，以便我们可以对自定义对象进行有意义的操作。
- en: Creating classes or structs that can be subclassed in Blueprint
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中进行子类化的类或结构体
- en: While this book focuses on C++, when developing with Unreal, a more standard
    workflow is to implement core gameplay functionality as well as performance-critical
    code in C++, and expose those features to Blueprint to allow designers to prototype
    gameplay, which can then be refactored by programmers with additional Blueprint
    features, or pushed back down to the C++ layer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书侧重于C++，但在使用虚幻引擎进行开发时，更标准的工作流程是将核心游戏功能以及性能关键代码实现为C++，并将这些功能暴露给蓝图，以便设计师可以原型化游戏玩法，然后由程序员使用额外的蓝图功能进行重构，或者将其推回到C++层。
- en: One of the most common tasks, then, is to **mark up** our classes and structs
    in such a way that they are visible to the Blueprint system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最常见的任务是以这样的方式标记我们的类和结构体，以便它们对蓝图系统可见。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new `Actor` class using the editor wizard; call it `BaseEnemy`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个新的`Actor`类；将其命名为`BaseEnemy`。
- en: 'Add the following `UPROPERTY` to the class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`UPROPERTY`添加到该类中：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following class specifier to the `UCLASS` macro:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类限定符添加到`UCLASS`宏中：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the editor and create a new blueprint class. Expand the list to show all
    classes and select our `BaseEnemyclass` as the parent.![How to do it…](img/00145.jpeg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的蓝图类。展开列表以显示所有类，并选择我们的`BaseEnemyclass`作为父类。![如何做...](img/00145.jpeg)
- en: Name the new Blueprint `EnemyGoblin` and open it in the Blueprint editor.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图命名为`EnemyGoblin`并在蓝图编辑器中打开它。
- en: Note that the `UPROPERTY` macro we created earlier still aren't there because
    we haven't yet included the appropriate markup for them to be visible to Blueprint.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们之前创建的`UPROPERTY`宏还不存在，因为我们尚未包含适当的标记以使它们对蓝图可见。
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous recipe demonstrated the use of `BlueprintType` as a class specifier.
    `BlueprintType` allows the type to be used as a type within the Blueprint editor
    (that is, it can be a variable or a function input/return value).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的示例演示了`BlueprintType`作为类限定符的用法。`BlueprintType`允许将该类型用作蓝图编辑器中的类型（即，它可以是变量或函数的输入/返回值）。
- en: However, we may want to create blueprints based on our type (using inheritance)
    rather than composition (placing an instance of our type inside an `Actor`, for
    example).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们可能希望基于我们的类型创建蓝图（使用继承），而不是组合（例如将我们的类型的实例放在`Actor`内部）。
- en: This is why Epic provided `Blueprintable` as a class specifier. `Blueprintable`
    means a developer can mark a class as inheritable by the Blueprint classes.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么Epic提供了`Blueprintable`作为类限定符的原因。`Blueprintable`意味着开发人员可以将类标记为蓝图类的可继承类。
- en: We have both `BlueprintType` and `Blueprintable` instead of a single combined
    specifier, because sometimes, you may only want partial functionality. For example,
    certain classes should be usable as variables, but performance reasons forbid
    creating them in Blueprint. In that instance, you would use `BlueprintType` rather
    than both specifiers.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了`BlueprintType`和`Blueprintable`而不是单个组合限定词，因为有时您可能只需要部分功能。例如，某些类应该可用作变量，但出于性能原因，不允许在蓝图中创建它们。在这种情况下，您将使用`BlueprintType`而不是两个限定词。
- en: On the other hand, perhaps we want to use the Blueprint editor to create new
    subclasses, but we don't want to pass object instances around inside the `Actor`
    blueprints. It is recommended to use `Blueprintable`, but omit `BlueprintType`
    in this case.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，也许我们想要使用蓝图编辑器创建新的子类，但我们不想在`Actor`蓝图中传递对象实例。在这种情况下，建议使用`Blueprintable`，但在这种情况下省略`BlueprintType`。
- en: As before, neither `Blueprintable` or `BlueprintType` specifies anything about
    the member functions or member variables contained inside our class. We'll make
    those available in later recipes.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，`Blueprintable`和`BlueprintType`都没有指定类中包含的成员函数或成员变量的任何信息。我们将在后面的示例中使它们可用。
- en: Creating functions that can be called in Blueprint
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中调用的函数
- en: While marking classes as `BlueprintType` or `Blueprintable` allows us to pass
    instances of the class around in Blueprint, or to subclass the type with a Blueprint
    class, those specifiers don't actually say anything about member functions or
    variables, and if they should be exposed to Blueprint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将类标记为`BlueprintType`或`Blueprintable`允许我们在蓝图中传递类的实例，或者用蓝图类对类型进行子类化，但这些限定词实际上并不涉及成员函数或变量，以及它们是否应该暴露给蓝图。
- en: This recipe shows you how to mark a function so that it can be called within
    Blueprint graphs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例向您展示了如何标记函数，以便可以在蓝图图表中调用它。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new `Actor` class using the editor. Call the actor `SlidingDoor`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个新的`Actor`类。将该actor命名为`SlidingDoor`。
- en: 'Add the following `UPROPERTY` to the new class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`UPROPERTY`添加到新类中：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the class implementation by adding the following to the `.cpp` file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下内容添加到`.cpp`文件中来创建类的实现：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compile your code and launch the editor.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Drag a copy of your door out into the level.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将门的副本拖动到关卡中。
- en: Make sure you have your `SlidingDoor` instance selected, then open the Level
    blueprint. Right-click on the empty canvas, and expand **Call function on Sliding
    Door 1**.![How to do it…](img/00146.jpeg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了`SlidingDoor`实例，然后打开关卡蓝图。右键单击空白画布，展开**在Sliding Door 1上调用函数**。![如何做...](img/00146.jpeg)
- en: Expand the **Door** section, then select the `Open` function.![How to do it…](img/00147.jpeg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**Door**部分，然后选择`Open`函数。![如何做...](img/00147.jpeg)
- en: Link the execution pin (white arrow) from `BeginPlay` to the white arrow on
    the `Open` node, as seen in the following screenshot:![How to do it…](img/00148.jpeg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行引脚（白色箭头）从`BeginPlay`连接到`Open`节点上的白色箭头，如下图所示：![如何做...](img/00148.jpeg)
- en: Play your level, and verify that the door moves up as expected when `Open` is
    invoked on your door instance.![How to do it…](img/00149.jpeg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的关卡，并验证当在门实例上调用`Open`时，门是否按预期移动。![如何操作...](img/00149.jpeg)
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: Within the declaration of the door, we create a new function for opening the
    door, a Boolean to track if the door has been told to open, and a vector allowing
    us to precompute the target location of the door.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在门的声明中，我们创建一个新的函数来打开门，一个布尔值来跟踪门是否已被告知打开，以及一个向量，允许我们预先计算门的目标位置。
- en: We also override the `Tick` actor function so that we can perform some behavior
    on every frame.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还重写了`Tick` actor函数，以便我们可以在每一帧上执行一些行为。
- en: Within the constructor, we load in the cube mesh and scale it to represent our
    door.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们加载立方体网格并缩放它以表示我们的门。
- en: We also set `IsOpen` to a known good value of `false` and enable actor ticking
    by using `bCanEverTick` and `bStartWithTickEnabled`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将`IsOpen`设置为已知的好值`false`，并通过使用`bCanEverTick`和`bStartWithTickEnabled`启用actor
    ticking。
- en: These two Booleans control if ticking can be enabled for this actor and if ticking
    starts in an enabled state respectively.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个布尔值分别控制是否可以为此actor启用ticking以及是否以启用状态开始ticking。
- en: Inside the `Open` function, we calculate the target location relative to the
    door's starting position.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Open`函数内部，我们计算相对于门的起始位置的目标位置。
- en: We also change the `IsOpen` Boolean from `false` to `true`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将`IsOpen`布尔值从`false`更改为`true`。
- en: Now that the `IsOpen` Boolean is `true`, inside the `Tick` function, the door
    tries to move itself towards the target location using `SetActorLocation` and
    `Lerp` to interpolate between the current location and the destination.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`IsOpen`布尔值为`true`，在`Tick`函数内部，门尝试使用`SetActorLocation`和`Lerp`将自身移动到目标位置，以在当前位置和目标位置之间进行插值。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    has a number of recipes relating to the spawning of actors'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托"),
    *处理事件和委托*，有一些与生成actor相关的示例'
- en: Creating events that can be implemented in Blueprint
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中实现的事件
- en: Another way that C++ can be more tightly integrated with Blueprint is the creation
    of functions that can have Blueprint implementations in native code. This allows
    for a programmer to specify an event, and invoke it, without needing to know anything
    about the implementation. The class can then be subclassed in Blueprint, and another
    member of the production team can implement a handler for the event without ever
    having to go near a line of C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++与Blueprint更紧密集成的另一种方式是创建可以在本地代码中具有Blueprint实现的函数。这允许程序员指定一个事件并调用它，而无需了解任何实现细节。然后可以在Blueprint中对该类进行子类化，并且制作团队的另一成员可以实现该事件的处理程序，而无需接触任何C++代码。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new `StaticMeshActor` class called `Spotter`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Spotter`的新`StaticMeshActor`类。
- en: 'Make sure the following functions are defined and overridden in the class header:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在类头文件中定义并重写以下函数：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add this code to the constructor:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到构造函数中：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add this to the `Tick` function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到`Tick`函数中：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile and start the editor. Find your `Spotter` class in **Content Browser**,
    then left-click and drag a copy out into the game world.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器。在**内容浏览器**中找到您的`Spotter`类，然后左键单击并将其拖到游戏世界中。
- en: When you play the level, you'll see the red line showing the trace that the
    `Actor` is performing. However, nothing will happen, because we haven't implemented
    our `OnPlayerSpotted` event.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放关卡时，您将看到红线显示`Actor`执行的追踪。但是，什么都不会发生，因为我们还没有实现我们的`OnPlayerSpotted`事件。
- en: In order to implement this event, we need to create a blueprint subclass of
    our `Spotter`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这个事件，我们需要创建一个`Spotter`的蓝图子类。
- en: Right-click on `Spotter` in **Content Browser**, and select **Create Blueprint
    class based on Spotter**. Name the class `BPSpotter`.![How to do it…](img/00150.jpeg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中右键单击`Spotter`，然后选择**基于Spotter创建蓝图类**。将类命名为`BPSpotter`。![如何操作...](img/00150.jpeg)
- en: Inside the Blueprint editor, click on the **Override** button in the **Functions**
    section of the **My Blueprint** panel:![How to do it…](img/00151.jpeg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图编辑器中，点击**My Blueprint**面板的**Functions**部分的**Override**按钮：![如何操作...](img/00151.jpeg)
- en: Select **On Player Spotted**:![How to do it…](img/00152.jpeg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**On Player Spotted**：![如何操作...](img/00152.jpeg)
- en: Left-click and drag from the white execution pin on our event. In the context
    menu that appears, select and add a `Print String` node so that it is linked to
    the event.![How to do it…](img/00153.jpeg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的事件的白色执行引脚上左键单击并拖动。在出现的上下文菜单中，选择并添加一个`Print String`节点，以便它与事件链接起来。![如何操作...](img/00153.jpeg)
- en: Play the level again, and verify that walking in front of the trace that the
    `Spotter` is using now prints a string to the screen.![How to do it…](img/00154.jpeg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放关卡，并验证走在`Spotter`正在使用的追踪前是否将字符串打印到屏幕上。![如何操作...](img/00154.jpeg)
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: In the constructor for our `Spotter` object, we load one of the basic primitives,
    a cone, into our Static Mesh Component as a visual representation.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Spotter`对象的构造函数中，我们将一个基本的原始体，一个锥体，加载到我们的静态网格组件中作为视觉表示。
- en: We then rotate the cone so that it resembles a spotlight pointing to the *X*
    axis of the actor.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们旋转锥体，使其类似于指向actor的*X*轴的聚光灯。
- en: During the `Tick` function, we get the actor's location, and then find a point
    200 units away from the actor along its local *X* axis. We call the parent class
    implementation of `Tick` using `Super::` to ensure that any other tick functionality
    is preserved despite our override.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`函数期间，我们获取actor的位置，然后找到沿其本地*X*轴200个单位的点。我们使用`Super::`调用父类的`Tick`实现，以确保尽管我们进行了重写，但任何其他tick功能都得以保留。
- en: We convert a local position into a world space position by first acquiring the
    Actor-to-World transform for the `Actor`, then using that to transform a vector
    specifying the position.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先获取`Actor`的Actor-to-World变换，然后使用该变换来转换指定位置的向量，将局部位置转换为世界空间位置。
- en: The transform is based on the orientation of the root component, which is the
    static mesh component that we rotated during the constructor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变换基于根组件的方向，根组件是我们在构造函数中旋转的静态网格组件。
- en: As a result of that existing rotation, we need to rotate the vector we want
    to transform. Given that we want the vector to point out of what was the bottom
    of the cone, we want a distance along the negative up axis, that is, we want a
    vector of the form (0,0,-d), where *d* is the actual distance away.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现有的旋转，我们需要旋转我们想要转换的向量。考虑到我们希望向量指向锥体底部的方向，我们希望沿着负上轴的距离，也就是说，我们希望一个形如(0,0,-d)的向量，其中*d*是实际的距离。
- en: Having calculated our end location for our trace, we actually perform the trace
    with the `SweepSingleByChannel` function.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算了我们追踪的最终位置后，我们实际上使用`SweepSingleByChannel`函数进行追踪。
- en: Once the sweep is performed, we try to cast the resulting hit `Actor` into a
    pawn.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行扫描后，我们尝试将结果命中的`Actor`转换为一个pawn。
- en: If the cast was successful, we invoke our Implementable Event of `OnPlayerSpotted`,
    and the user-defined Blueprint code executes.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果转换成功，我们调用`OnPlayerSpotted`的可实现事件，并执行用户定义的蓝图代码。
- en: Exposing multi-cast delegates to Blueprint
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多播委托公开给蓝图
- en: Multi-cast delegates are a great way to broadcast an event to multiple objects
    who **listen** or **subscribe** to the event in question. They are particularly
    invaluable if you have a C++ module that generates events that potentially arbitrary
    Actors might want to be notified about. This recipe shows you how to create a
    multi-cast delegate in C++ that can notify a group of other Actors during runtime.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多播委托是一种将事件广播给多个**监听**或**订阅**该事件的对象的好方法。如果你有一个生成事件的C++模块，可能会有任意的Actor想要被通知到这些事件，那么多播委托尤其有价值。本示例向你展示了如何在C++中创建一个多播委托，以便在运行时通知一组其他Actor。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `StaticMeshActor` class called `King`. Add the following to the
    class header:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`King`的新的`StaticMeshActor`类。在类头文件中添加以下内容：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a new `UFUNCTION` to the class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个新的`UFUNCTION`：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add an instance of our multicast delegate to the class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加我们的多播委托的实例：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add our mesh initialization to the constructor:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的网格初始化添加到构造函数中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `Die` function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Die`函数：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a new class called `Peasant`, also based on `StaticMeshActor`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Peasant`的新类，也是基于`StaticMeshActor`的。
- en: 'Declare a default constructor in the class:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中声明一个默认构造函数：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Declare the following function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下函数：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the constructor:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现构造函数：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the function in the `.cpp` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现该函数：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open Blueprint and create a Blueprint class based on `APeasant` called `BPPeasant`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图并创建一个基于`APeasant`的蓝图类，命名为`BPPeasant`。
- en: Within the blueprint, click and drag away from the white (execution) pin of
    your `BeginPlay` node. Type `get all`, and you should see **Get All Actors Of
    Class**. Select the node to place it in your graph.![How to do it…](img/00155.jpeg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图中，点击并拖动离你的`BeginPlay`节点的白色（执行）引脚。输入`get all`，你应该会看到**获取所有类的Actor**。选择该节点并放置在你的图表中。![如何操作...](img/00155.jpeg)
- en: Set the value of the purple (class) node to `King`. You can type `king` in the
    search bar to make locating the class in the list easier.![How to do it…](img/00156.jpeg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将紫色（类）节点的值设置为`King`。你可以在搜索栏中输入`king`以更容易地找到该类。![如何操作...](img/00156.jpeg)
- en: Drag from the blue grid (object array) node out into empty space and place a
    get node.![How to do it…](img/00157.jpeg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从蓝色网格（对象数组）节点拖动到空白处并放置一个获取节点。![如何操作...](img/00157.jpeg)
- en: Drag away from the blue output pin of the get node, and place a Not Equal (object)
    node.![How to do it…](img/00158.jpeg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从获取节点的蓝色输出引脚处拖动，并放置一个不等（对象）节点。![如何操作...](img/00158.jpeg)
- en: Connect the red (bool) pin of the Not Equal node to a `Branch` node, and wire
    the execution pin of `Branch` to our `Get All Actors Of Class` node.![How to do
    it…](img/00159.jpeg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不等（bool）节点的红色引脚连接到一个`Branch`节点，并将`Branch`节点的执行引脚连接到我们的`Get All Actors Of Class`节点。![如何操作...](img/00159.jpeg)
- en: Connect the **True** pin of the branch to the **Bind Event to OnKing Death**
    node.![How to do it…](img/00160.jpeg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支的**True**引脚连接到**Bind Event to OnKing Death**节点。![如何操作...](img/00160.jpeg)
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you will probably have to untick **Context Sensitive** in the context
    menu for the **Bind Event** node to be visible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可能需要在上下文菜单中取消选中**上下文敏感**以使**绑定事件**节点可见。
- en: Drag out the red pin on the **Bind Event** node, and select **Add Custom Event…**
    in the context menu which appears after you release your left mouse button.![How
    to do it…](img/00161.jpeg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Bind Event**节点的红色引脚拖动，并在释放鼠标左键后出现的上下文菜单中选择**Add Custom Event…**。![如何操作...](img/00161.jpeg)
- en: Give your event a name, then connect the white execution pin to a new node named
    `Flee`.![How to do it…](img/00162.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的事件命名，然后将白色执行引脚连接到一个名为`Flee`的新节点。![如何操作...](img/00162.jpeg)
- en: Verify that your Blueprint looks like the following figure:![How to do it…](img/00163.jpeg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你的蓝图是否如下图所示：![如何操作...](img/00163.jpeg)
- en: Drag a copy of your `King` class into the level, then add a few `BPPeasant`
    instances around it in a circle.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的`King`类的副本拖动到关卡中，然后在其周围以圆形添加几个`BPPeasant`实例。
- en: Open the level Blueprint. Inside it, drag away from `BeginPlay,` and add a `Delay`
    node. Set the delay to **5** seconds.![How to do it…](img/00164.jpeg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开关卡蓝图。在其中，从`BeginPlay`处拖动并添加一个`Delay`节点。将延迟设置为**5**秒。![如何操作...](img/00164.jpeg)
- en: With your `King` instance selected in the level, right-click in the graph editor
    for the Level Blueprint.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中选择你的`King`实例，在图形编辑器中右键单击。
- en: Select **Call function on King 1**, and look in the `King` category for a function
    called `Die`.![How to do it…](img/00165.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Call function on King 1**，并在`King`类别中查找一个名为`Die`的函数。![如何操作...](img/00165.jpeg)
- en: Select `Die`, then connect its execution pin to the output execution pin from
    the delay.![How to do it…](img/00166.jpeg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Die`，然后将其执行引脚连接到延迟的输出执行引脚。![如何做...](img/00166.jpeg)
- en: When you play your level, you should see that the king dies after 5 seconds,
    and the peasants all wail and flee directly away from the king.![How to do it…](img/00167.jpeg)![How
    to do it…](img/00168.jpeg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你播放关卡时，你应该会看到国王在5秒后死亡，农民们都哀号并直接远离国王。![如何做...](img/00167.jpeg)![如何做...](img/00168.jpeg)
- en: How it works…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a new actor (based on `StaticMeshActor` for convenience, as it saves
    us having to declare or create a Static Mesh component for the `Actor` visual
    representation).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的演员（基于`StaticMeshActor`方便起见，因为这样可以省去为`Actor`的可视化表示声明或创建静态网格组件的步骤）。
- en: We declare a dynamic multicast delegate using the `DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`
    macro. Dynamic multicast delegates allow an arbitrary number of objects to subscribe
    (listen) and unsubscribe (stop listening) so that they will be notified when the
    delegate is broadcast.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`宏声明了一个动态多播委托。动态多播委托允许任意数量的对象订阅（监听）和取消订阅（停止监听），以便在广播委托时通知它们。
- en: The macro takes a number of arguments—the type name of the new delegate signature
    being created, the type of the signature's parameter, then the name of the signature's
    parameter.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该宏接受多个参数-正在创建的新委托签名的类型名称，签名参数的类型，然后是签名参数的名称。
- en: We also add a function to `King` that will allow us to tell it to die. Because
    we want to expose the function to Blueprints for prototyping, we mark it as `BlueprintCallable`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在`King`中添加了一个函数，允许我们告诉它死亡。因为我们希望将该函数暴露给蓝图进行原型设计，所以将其标记为`BlueprintCallable`。
- en: The `DECLARE_DYNAMIC_MULTICAST_DELEGATE` macro that we used earlier only declared
    a type; it didn't declare an instance of the delegate, so we do that now, referencing
    the type name that we provided earlier when invoking the macro.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前使用的`DECLARE_DYNAMIC_MULTICAST_DELEGATE`宏只声明了一个类型，没有声明委托的实例，所以现在我们要做的是声明一个委托的实例，引用之前在调用宏时提供的类型名称。
- en: Dynamic multicast delegates can be marked `BlueprintAssignable` in their `UPROPERTY`
    declaration. This indicates to Unreal that the Blueprint system can dynamically
    assign events to the delegate that will be called when the delegate's `Broadcast`
    function is called.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态多播委托可以在其`UPROPERTY`声明中标记为`BlueprintAssignable`。这告诉虚幻引擎蓝图系统可以动态地将事件分配给委托，当调用委托的`Broadcast`函数时将调用这些事件。
- en: As always, we assign a simple mesh to our `King` so that it has a visual representation
    in the game scene.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们为我们的`King`分配一个简单的网格，以便在游戏场景中有一个可视化表示。
- en: Within the `Die` function, we call `Broadcast` on our own delegate. We specified
    that the delegate would have a parameter that is a pointer to the king which died,
    so we pass this pointer as a parameter to the broadcast function.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Die`函数内部，我们调用自己的委托上的`Broadcast`函数。我们指定委托将有一个指向死去的国王的指针作为参数，所以我们将这个指针作为参数传递给广播函数。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want the king to be destroyed, rather than play an animation or other
    effect when it dies, you would need to change the delegate's declaration and pass
    in a different type. For example, you could use `FVector`, and simply pass in
    the location of the dead king directly so that the peasants could still flee appropriately.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望国王被销毁，而不是在死亡时播放动画或其他效果，你需要改变委托的声明并传入不同的类型。例如，你可以使用`FVector`，并直接传入死去的国王的位置，这样农民仍然可以适当地逃离。
- en: Without this, you potentially could have a situation where the `King` pointer
    is valid when `Broadcast` is called, but the call to `Actor::Destroy()` invalidates
    it before your bound functions are executed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个，当调用`Broadcast`时，`King`指针可能是有效的，但在执行绑定函数之前，调用`Actor::Destroy()`会使其无效。
- en: Within our next `StaticMeshActor` subclass, called `Peasant`, we initialize
    the static mesh component as usual using, a different shape to the one that we
    used for the `King`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的下一个`StaticMeshActor`子类`Peasant`中，我们像往常一样初始化静态网格组件，使用了与`King`不同的形状。
- en: Inside the implementation of the peasant's `Flee` function, we simulate the
    peasants playing sound by printing a message on the screen.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在农民的`Flee`函数的实现中，我们通过在屏幕上打印一条消息来模拟农民发出声音。
- en: We then calculate a vector to make the peasants flee by first finding a vector
    from the dead king to this peasant's location.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算一个向量，首先找到从死去的国王到这个农民位置的向量。
- en: We normalize the vector to retrieve a unit vector (with a length of 1) pointing
    in the same direction.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向量归一化以获得指向相同方向的单位向量（长度为1）。
- en: Scaling the normalized vector and adding it to our current location calculates
    a position at a fixed distance, in the exact direction for the peasant to be fleeing
    directly away from the dead king.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过缩放归一化向量并将其添加到当前位置，可以计算出一个固定距离的位置，正好是农民直接远离死去的国王的方向。
- en: '`SetActorLocation` is then used to actually teleport the peasants to that location.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`SetActorLocation`来实际将农民传送到该位置。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you used a Character with an AI controller, you could have the `Peasant`
    pathfind to the target location rather than teleporting. Alternatively, you could
    use a `Lerp` function invoked during the peasant's `Tick` to make them slide smoothly
    rather than jump directly to the location.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用带有AI控制器的角色，你可以让`Peasant`寻路到目标位置，而不是瞬间传送。或者，你可以在农民的`Tick`中使用`Lerp`函数来使它们平滑滑动，而不是直接跳到位置。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Look at [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components*, for more extended
    discussions about Actors and Components. [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    discusses events such as `NotifyActorOverlap`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121 "Chapter 4. Actors
    and Components")中查看有关演员和组件的更详细讨论，[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates")中讨论了诸如“NotifyActorOverlap”之类的事件。
- en: Creating C++ enums that can be used in Blueprint
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中使用的C++枚举
- en: Enums are commonly used in C++ as flags or inputs to switch statements. However,
    what if you want to pass an `enum` value to or from C++ from a Blueprint? Alternatively,
    if you want to use a `switch` statement in Blueprint that uses an `enum` from
    C++, how do you let the Blueprint editor know that your `enum` should be accessible
    within the editor? This recipe shows you how to make enums visible in Blueprint.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举通常在C++中用作标志或输入到switch语句中。然而，如果你想要从蓝图向C++传递一个“枚举”值，或者从C++向蓝图传递一个“枚举”值，该怎么办？或者，如果你想在蓝图中使用一个使用C++中的“枚举”的“switch”语句，你如何让蓝图编辑器知道你的“枚举”应该在编辑器中可访问？本教程向你展示了如何使枚举在蓝图中可见。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new `StaticMeshActor` class called `Tree` using the editor.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个名为“Tree”的新的“StaticMeshActor”类。
- en: 'Insert the following code above the class declaration:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明之前插入以下代码：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following `UPROPERTY` in the `Tree` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Tree”类中添加以下“UPROPERTY”：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following to the `Tree` constructor:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Tree”构造函数中添加以下内容：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create a new Blueprint class, called `MyTree`, based on `Tree`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“MyTree”的新蓝图类，基于“Tree”。
- en: Inside the blueprint editor for `MyTree`, click on the **Construction Script**
    tab.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“MyTree”的蓝图编辑器中，点击“构造脚本”选项卡。
- en: Right-click in the empty window, and type `treetype`. There is a **Get number
    of entries in TreeType** node.![How to do it…](img/00169.jpeg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空白窗口中右键点击，输入“treetype”。有一个“获取TreeType中的条目数”节点。![如何操作...](img/00169.jpeg)
- en: Place it, and then connect its output pin to a **Random Integer** node.![How
    to do it…](img/00170.jpeg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置它，然后将其输出引脚连接到一个“随机整数”节点。![如何操作...](img/00170.jpeg)
- en: Connect the output of the random integer to a `ToByte` node.![How to do it…](img/00171.jpeg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将随机整数的输出连接到“ToByte”节点的输入。![如何操作...](img/00171.jpeg)
- en: In the **Variables** section of the Blueprint panel, expand **Tree** and select
    **Type**.![How to do it…](img/00172.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图面板的“变量”部分，展开“Tree”并选择“Type”。![如何操作...](img/00172.jpeg)
- en: Drag this into the graph, and select **Set** when you see a small context menu
    appear.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖入图中，并在出现小的上下文菜单时选择“Set”。
- en: Connect the output of the `ToByte` node to the input of the **SET Type** node.
    You'll see an extra conversion node automatically appear.![How to do it…](img/00173.jpeg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“ToByte”节点的输出连接到“SET类型”节点的输入。你会看到一个额外的转换节点自动出现。![如何操作...](img/00173.jpeg)
- en: Lastly, connect the execution pin of **Construction Script** to the **SET Type**
    node's execution pin.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“构造脚本”的执行引脚连接到“SET类型”节点的执行引脚。
- en: Your Blueprint should look like the following:![How to do it…](img/00174.jpeg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的蓝图应该如下所示：![如何操作...](img/00174.jpeg)
- en: To verify that the blueprint is correctly functioning and randomly assigning
    a type to our tree, we are going to add some nodes to the Event Graph.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证蓝图是否正确运行并随机分配类型给我们的树，我们将在事件图中添加一些节点。
- en: Place a `Print String` node after the **Event BeginPlay** event node.![How to
    do it…](img/00175.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Event BeginPlay”事件节点之后放置一个“打印字符串”节点。![如何操作...](img/00175.jpeg)
- en: Place a `Format Text` node, and connect its output to the input of the `Print
    String` node. A conversion node will be added for you.![How to do it…](img/00176.jpeg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一个“格式文本”节点，并将其输出连接到“打印字符串”节点的输入。一个转换节点将会被添加给你。![如何操作...](img/00176.jpeg)
- en: Inside the `Format Text` node, add My Type is {`0`}! to the textbox.![How to
    do it…](img/00177.jpeg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“格式文本”节点中，将“My Type is {`0`}!”添加到文本框中。![如何操作...](img/00177.jpeg)
- en: Drag `Type` from the variables section of the Blueprint into the graph selecting
    **Get** from the menu.![How to do it…](img/00178.jpeg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从蓝图的变量部分拖动“Type”到图中，从菜单中选择“Get”。![如何操作...](img/00178.jpeg)
- en: Add an **Enum to Name** node to `Type` output pin.![How to do it…](img/00179.jpeg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个“Enum to Name”节点添加到“Type”的输出引脚。![如何操作...](img/00179.jpeg)
- en: Connect the Name output to the input pin on `Format Text` labelled `0`.![How
    to do it…](img/00180.jpeg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称输出连接到标记为“0”的“格式文本”的输入引脚。![如何操作...](img/00180.jpeg)
- en: Your Event Graph should now look like the following:![How to do it…](img/00181.jpeg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的事件图现在应该如下所示：![如何操作...](img/00181.jpeg)
- en: Drag a few copies of your Blueprint into the level and hit **Play**. You should
    see a number of trees printing information regarding their type, verifying that
    types are being randomly assigned by the Blueprint code that we created.![How
    to do it…](img/00182.jpeg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将几个副本的蓝图拖入关卡并点击“播放”。你应该看到一些树打印有关它们类型的信息，验证了我们创建的蓝图代码随机分配类型的功能。![如何操作...](img/00182.jpeg)
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As usual, we use `StaticMeshActor` as the base class for our `Actor` so that
    we can easily give it a visual representation in the level.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们使用“StaticMeshActor”作为我们的“Actor”的基类，以便我们可以在关卡中轻松地给它一个可视化表示。
- en: Enumerated types are exposed to the reflection system using the `UENUM` macro.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“UENUM”宏将枚举类型暴露给反射系统。
- en: We mark the `enum` as Blueprint-available using the `BlueprintType` specifier.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用“BlueprintType”修饰符将“枚举”标记为蓝图可用。
- en: The `enum` declaration is just the same as we would use in any other context.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “枚举”声明与我们在任何其他上下文中使用的方式完全相同。
- en: Our `Tree` requires a `TreeType`. Because *tree has tree-type* is the relationship
    we want to embody, we include an instance of `TreeType` in our `Tree` class.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的“Tree”需要一个“TreeType”。因为我们想要体现的关系是*树具有树类型*，所以我们在“Tree”类中包含了一个“TreeType”的实例。
- en: As usual, we need to use `UPROPERTY()` to make the member variable accessible
    to the reflection system.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要使用“UPROPERTY()”使成员变量对反射系统可访问。
- en: We use the `BlueprintReadWrite` specifier to mark the property as having both
    get and set support within Blueprint.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`BlueprintReadWrite`修饰符来标记该属性在蓝图中具有获取和设置的支持。
- en: Enumerated types require being wrapped in the `TEnumAsByte` template when used
    in `UPROPERTY`, so we declare an instance of `TEnumAsByte<TreeType>` as the Tree's
    `Type` variable.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在`UPROPERTY`中使用时，枚举类型需要被包装在`TEnumAsByte`模板中，因此我们声明一个`TEnumAsByte<TreeType>`的实例作为树的`Type`变量。
- en: The constructor changes for `Tree` are simply the standard load and initialize
    our static mesh component preamble used in other recipes.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Tree`的构造函数只是标准的加载和初始化我们在其他示例中使用的静态网格组件前导。'
- en: We create a Blueprint that inherits from our `Tree` class so that we can demonstrate
    the Blueprint-accessibility of the `TreeType enum`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个继承自我们的`Tree`类的蓝图，以便我们可以演示`TreeType enum`的蓝图可访问性。
- en: In order to have the Blueprint assign a type to the tree at random when we create
    an instance, we need to use the Blueprint **Construction Script**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使蓝图在创建实例时随机分配树的类型，我们需要使用蓝图的**Construction Script**。
- en: Within the **Construction Script**, we calculate the number of entries in the
    `TreeType enum`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Construction Script**中，我们计算`TreeType enum`中的条目数。
- en: We generate a random number, and use that as an index in the `TreeType enum`
    type to retrieve a value to store as our `Type`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成一个随机数，并将其作为`TreeType enum`类型中的索引来检索一个值，将其存储为我们的`Type`。
- en: The Random number node, however, returns integers. Enumerated types are treated
    as bytes in Blueprint, so we need to use a `ToByte` node, which can then be implicitly
    converted by Blueprint into an `enum` value.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，随机数节点返回整数。在蓝图中，枚举类型被视为字节，因此我们需要使用`ToByte`节点，然后蓝图可以将其隐式转换为`enum`值。
- en: Now that we have **Construction Script** assigning a type to our tree instances
    as they are created, we need to display the tree's type at runtime.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经在**Construction Script**中为创建的树实例分配了一个类型，我们需要在运行时显示树的类型。
- en: We do so with the graph attached to the `BeginPlay` event within the Event Graph
    tab.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过连接到事件图表选项卡中的`BeginPlay`事件附加的图表来实现。
- en: To display text on screen, we use a `Print String` node.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在屏幕上显示文本，我们使用`Print String`节点。
- en: To perform string substitution and print our type out as a human-readable string,
    we use the `Format Text` node.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行字符串替换并将我们的类型打印为可读字符串，我们使用`Format Text`节点。
- en: The `Format Text` node takes terms enclosed in curly braces, and allows you
    to substitute other values for those terms returning the final string.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Format Text`节点接受用花括号括起来的术语，并允许您替换这些术语的其他值，返回最终的字符串。'
- en: To substitute our `Type` into the `Format Text` node, we need to convert our
    variable stores from the `enum` value into the actual name of the value.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`Type`替换到`Format Text`节点中，我们需要将变量存储从`enum`值转换为实际值的名称。
- en: We can do so by accessing our `Type` variable, then using the `Enum to Name`
    node.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过访问我们的`Type`变量，然后使用`Enum to Name`节点来实现。
- en: '`Name`, or `FNames` in native code, are a type of variable that can be converted
    to strings by Blueprint, so we can connect our `Name` to the input on the `Format
    Text` node.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Name`或本机代码中的`FNames`是一种可以由蓝图转换为字符串的变量类型，因此我们可以将我们的`Name`连接到`Format Text`节点的输入上。'
- en: When we hit play, the graph executes retrieving the type of tree instances placed
    in the level, and printing the names to the screen.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们点击播放时，图表执行，检索放置在关卡中的树实例的类型，并将名称打印到屏幕上。
- en: Editing class properties in different places in the editor
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑器中的不同位置编辑类属性
- en: When developing with Unreal, it is common for programmers to implement properties
    on Actors or other objects in C++, and make them visible to the editor for designer
    use. However, sometimes it makes sense to view a property, or to make it editable,
    but only on the object's default state. Sometimes the property should only be
    modifiable at runtime with the default specified in C++. Fortunately, there are
    some specifiers that can help us restrict when a property is available.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚幻引擎进行开发时，程序员通常会在C++中为Actor或其他对象实现属性，并使其对设计师可见。然而，有时候查看属性或使其可编辑是有意义的，但仅在对象的默认状态下。有时，属性只能在运行时进行修改，其默认值在C++中指定。幸运的是，有一些修饰符可以帮助我们限制属性的可用性。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new `Actor` class in the editor called `PropertySpecifierActor`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个名为`PropertySpecifierActor`的新`Actor`类。
- en: 'Add the following property definitions to the class:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性定义添加到类中：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your code and launch the editor.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Create a new blueprint based on the class.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中基于该类创建一个新的蓝图。
- en: Open the blueprint, and look at the **Class Defaults** section.![How to do it…](img/00183.jpeg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图，查看**Class Defaults**部分。![如何操作...](img/00183.jpeg)
- en: Note which properties are editable and visible.![How to do it…](img/00184.jpeg)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意哪些属性是可编辑和可见的。![如何操作...](img/00184.jpeg)
- en: Place instances in the level, and view their **Details** panels.![How to do
    it…](img/00185.jpeg)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中放置实例，并查看它们的**Details**面板。![如何操作...](img/00185.jpeg)
- en: Note that a different set of properties are editable.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，可编辑的属性集不同。
- en: How it works…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When specifying `UPROPERTY`, we can indicate where we want that value to be
    available inside the Unreal editor.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定`UPROPERTY`时，我们可以指示我们希望该值在虚幻编辑器中的哪个位置可用。
- en: '`Visible*` prefixes indicate that the value is viewable in the **Details**
    panel for the indicated object. The value won''t be editable, however.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Visible*`前缀表示该值可以在指定对象的**Details**面板中查看。但是，该值不可编辑。'
- en: This doesn't mean that the variable is a `const` qualifier; however, native
    code can change the value, for instance.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并不意味着变量是`const`限定符；然而，本机代码可以更改值，例如。
- en: '`Edit*` prefixes indicate that the property can be altered within the **Details**
    panels inside the editor.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Edit*`前缀表示该属性可以在编辑器中的**Details**面板中进行更改。'
- en: '`InstanceOnly` as a suffix indicates that the property will only be displayed
    in the **Details** panels for instances of your class that have been placed into
    the game. They won''t be visible in the **Class Defaults** section of the Blueprint
    editor, for example.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为后缀的“InstanceOnly”表示该属性仅在已放置到游戏中的类的实例的“详细信息”面板中显示。例如，在蓝图编辑器的“类默认”部分中将不可见。
- en: '`DefaultsOnly` is the inverse of `InstanceOnly`— `UPROPERTY` will only display
    in the **Class Defaults section**, and can''t be viewed on individual instances
    within the level.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “DefaultsOnly”是“InstanceOnly”的反义词 - “UPROPERTY”仅显示在“类默认部分”中，并且无法在蓝图编辑器中的单个实例上查看。
- en: The suffix `Anywhere` is the combination of the two previous suffixes—the `UPROPERTY`
    will be visible in all **Details** panels that inspect either the object's defaults
    or a particular instance in the level.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后缀“Anywhere”是前两个后缀的组合 - “UPROPERTY”将在检查对象的默认值或级别中的特定实例的所有“详细信息”面板中可见。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe makes the property in question visible in the inspector, but doesn't
    allow the property to be referenced in the actual Blueprint Event Graph. See the
    next recipe for a description of how to make that possible.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方使得所讨论的属性在检视器中可见，但不允许在实际的蓝图事件图中引用该属性。请参阅下一个配方，了解如何实现这一点的描述。
- en: Making properties accessible in the Blueprint editor graph
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使属性在蓝图编辑器图中可访问
- en: The specifiers mentioned in the previous recipe are all well and good, but they
    only control the visibility of `UPROPERTY` in the **Details** panel. By default,
    even with those specifiers used appropriately, `UPROPERTY` won't be viewable or
    accessible in the actual editor graph for use at runtime.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个配方中提到的限定词都很好，但它们只控制了“UPROPERTY”在“详细信息”面板中的可见性。默认情况下，即使适当使用这些限定词，也无法在实际的编辑器图中查看或访问“UPROPERTY”以供运行时使用。
- en: Other specifiers, which can optionally be used in conjunction with the ones
    in the previous recipe, can be used to allow interacting with properties in the
    Event Graph.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 其他限定词可以选择与前一个配方中的限定词一起使用，以允许在事件图中与属性交互。
- en: How to do it…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: Create a new `Actor` class called `BlueprintPropertyActor` using the editor
    wizard.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个名为“BlueprintPropertyActor”的新“Actor”类。
- en: 'Add the following `UPROPERTY` to the actor using Visual Studio:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio将以下“UPROPERTY”添加到Actor中：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile your project, and start the editor.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目并启动编辑器。
- en: Create a Blueprint class based on your `BlueprintPropertyActor,` and open its
    graph.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于你的“BlueprintPropertyActor”的蓝图类，并打开其图表。
- en: Verify that the properties are visible under the category **Cookbook** in the
    **Variables** sectionof the **My Blueprint** panel.![How to do it…](img/00186.jpeg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证属性在“我的蓝图”面板的“变量”部分下的“Cookbook”类别下可见。![操作方法…](img/00186.jpeg)
- en: Left-click and drag the ReadWrite property into the event graph, and select
    `Get`.![How to do it…](img/00187.jpeg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击并将ReadWrite属性拖入事件图中，然后选择“Get”。![操作方法…](img/00187.jpeg)
- en: Repeat the previous step selecting `Set`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一步并选择“Set”。
- en: Drag the `ReadOnly` property into the graph, and note that the `Set` node is
    disabled.![How to do it…](img/00188.jpeg)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“ReadOnly”属性拖入图表中，并注意“Set”节点被禁用。![操作方法…](img/00188.jpeg)
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: '`BlueprintReadWrite` as a `UPROPERTY` specifier indicates to the Unreal Header
    Tool that the property should have both `Get` and `Set` operations exposed for
    use in Blueprints.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为“UPROPERTY”限定词的“BlueprintReadWrite”指示虚幻头文件工具应为蓝图公开该属性的“Get”和“Set”操作。
- en: '`BlueprintReadOnly` is, as the name implies, a specifier that only allows Blueprint
    to retrieve the value of the property; never set it.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “BlueprintReadOnly”是一个只允许蓝图检索属性值而不允许设置的限定词。
- en: '`BlueprintReadOnly` can be useful when a property is set by native code, but
    should be accessible within Blueprint.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当属性由本地代码设置但应在蓝图中访问时，“BlueprintReadOnly”非常有用。
- en: It should be noted that `BlueprintReadWrite` and `BlueprintReadOnly` don't specify
    anything about the property being accessible in the **Details** panels or the
    **My Blueprint** section of the editor—these specifiers only control the generation
    of the getter/setter nodes for use in Blueprint graphs.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该注意的是，“BlueprintReadWrite”和“BlueprintReadOnly”并没有指定属性在“详细信息”面板或编辑器的“我的蓝图”部分中是否可访问
    - 这些限定词只控制用于蓝图图表中的getter/setter节点的生成。
- en: Responding to property – changed events from the editor
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应编辑器中属性更改事件
- en: When a designer changes the properties of an `Actor` placed in the level, it
    is often important to show any visual results of that change immediately rather
    than just when the level is simulated or played.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计师更改放置在级别中的“Actor”的属性时，通常重要的是立即显示该更改的任何视觉结果，而不仅仅在模拟或播放级别时显示。
- en: When changes are made using the **Details** panels, there's a special event
    that the editor emits called `PostEditChangeProperty`, which gives the class instance
    a chance to respond to the property being edited.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“详细信息”面板进行更改时，编辑器会发出一个特殊事件，称为“PostEditChangeProperty”，该事件使类实例有机会响应属性的编辑。
- en: This recipe shows you how to handle `PostEditChangeProperty` for immediate in-editor
    feedback.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方向您展示如何处理“PostEditChangeProperty”以实现即时的编辑器反馈。
- en: How to do it…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: Create a new `Actor` called `APostEditChangePropertyActor` based on `StaticMeshActor`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于“StaticMeshActor”创建一个名为“APostEditChangePropertyActor”的新“Actor”。
- en: 'Add the following `UPROPERTY` to the class:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下“UPROPERTY”添加到类中：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following function definition:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数定义：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following to the class constructor:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到类构造函数中：
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement `PostEditChangeProperty`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“PostEditChangeProperty”：
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile your code, and launch the editor.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Drag an instance of your class into the game world, and verify that toggling
    the boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport.![How to do it…](img/00189.jpeg)![How to do it…](img/00190.jpeg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类的实例拖入游戏世界，并验证切换“ShowStaticMesh”的布尔值是否切换编辑器视口中网格的可见性。![操作方法…](img/00189.jpeg)![操作方法…](img/00190.jpeg)
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: We create a new `Actor` based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建一个新的`Actor`，以便通过静态网格轻松访问可视化表示。
- en: '`UPROPERTY` is added to give us a property to change, to cause `PostEditChangeProperty`
    events to be triggered.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`UPROPERTY`以提供我们要更改的属性，以触发`PostEditChangeProperty`事件。
- en: '`PostEditChangeProperty` is a virtual function defined in `Actor`.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostEditChangeProperty`是在`Actor`中定义的虚函数。'
- en: As a result, we override the function in our class.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在我们的类中重写该函数。
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component it controls.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类构造函数中，我们像往常一样初始化我们的网格，并将我们的`bool`属性的默认状态设置为与其控制的组件的可见性相匹配。
- en: Inside `PostEditChangeProperty`, we first check that the property is valid.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostEditChangeProperty`中，我们首先检查属性是否有效。
- en: Assuming it is, we retrieve the name of the property using `GetFName()`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设它是有效的，我们使用`GetFName()`检索属性的名称。
- en: '`FNames` are stored internally by the engine as a table of unique values.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FNames`在引擎内部以唯一值的表格形式存储。'
- en: Next we need to use the `GET_MEMBER_NAME_CHECKED` macro. The macro takes a number
    of parameters.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`GET_MEMBER_NAME_CHECKED`宏。该宏接受多个参数。
- en: The first one is the name of the class to check.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个是要检查的类的名称。
- en: The second parameter is the property to check the class for.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是要检查类的属性。
- en: The macro will, at compile-time, verify that the class contains the member specified
    by name.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏将在编译时验证类是否包含指定名称的成员。
- en: We compare the class member name that the macro returns against the name that
    our property contains.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将宏返回的类成员名称与我们的属性包含的名称进行比较。
- en: If they are the same, then we verify that our `StaticMeshComponent` is initialized
    correctly.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们相同，那么我们验证我们的`StaticMeshComponent`是否正确初始化。
- en: If it is, we set its visibility to match the value of our `ShowStaticMesh` Boolean.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，我们将其可见性设置为与我们的`ShowStaticMesh`布尔值的值相匹配。
- en: Implementing a native code Construction Script
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现本地代码构造脚本
- en: Within Blueprint, **Construction Script** is an event graph that runs any time
    a property is changed on the object it is attached to—whether from being dragged
    in the editor viewport or changed via direct entry in a **Details** panel.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中，**构造脚本**是一个事件图，它在附加到对象上的任何属性发生更改时运行-无论是通过在编辑器视口中拖动还是通过在**详细信息**面板中直接输入。
- en: Construction scripts allow the object in question to 'rebuild' itself based
    on its new location, for instance, or to change the components it contains based
    on user-selected options.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 构造脚本允许对象根据其新位置“重建”自身，例如，或者根据用户选择的选项更改其包含的组件。
- en: When coding in C++ with Unreal Engine, the equivalent concept is the `OnConstruction`
    function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚幻引擎进行C++编码时，等效的概念是`OnConstruction`函数。
- en: How to do it…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create a new `Actor` called `AOnConstructionActor` based on `StaticMeshActor`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AOnConstructionActor`的新`Actor`，基于`StaticMeshActor`。
- en: 'Add the following `UPROPERTY` to the class:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`UPROPERTY`添加到类中：
- en: '[PRE27]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following function definition:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数定义：
- en: '[PRE28]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following to the class constructor:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到类构造函数中：
- en: '[PRE29]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement `OnConstruction`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnConstruction`：
- en: '[PRE30]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile your code, and launch the editor.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Drag an instance of your class into the game world, and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类的实例拖动到游戏世界中，并验证切换`ShowStaticMesh`布尔值是否切换编辑器视口中网格的可见性。
- en: '`OnConstruction` does not currently run for C++ actors placed in a level if
    they are moved.'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果C++的Actor被移动，目前`OnConstruction`不会运行。
- en: To test this, place a breakpoint in your `OnConstruction` function, then move
    your actor around the level.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个，将断点放在你的`OnConstruction`函数中，然后将你的Actor移动到关卡中。
- en: Tip
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To place a breakpoint, place your cursor on the desired line, and hit *F9* in
    Visual Studio.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点，请将光标放在所需行上，然后在Visual Studio中按下*F9*。
- en: You'll notice that the function doesn't get called, but if you toggle the `ShowStaticMesh`
    Boolean, it does, causing your breakpoint to trigger.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到该函数不会被调用，但是如果切换`ShowStaticMesh`布尔值，它会被调用，从而触发断点。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to see why, take a look at `AActor::PostEditMove`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解原因，请查看`AActor::PostEditMove`：
- en: '[PRE31]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The top line here casts `UClass` for the current object to `UBlueprint`, and
    will only run the construction scripts and `OnConstruction` again if the class
    is a Blueprint.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的顶行将当前对象的`UClass`转换为`UBlueprint`，并且只有在类是蓝图时才会运行构造脚本和`OnConstruction`。
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: We create a new Actor based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建一个新的Actor，以便通过静态网格轻松访问可视化表示。
- en: '`UPROPERTY` is added to give us a property to change—to cause `PostEditChangeProperty`
    events to be triggered.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`UPROPERTY`以提供我们要更改的属性-以触发`PostEditChangeProperty`事件。
- en: '`OnConstruction` is a virtual function defined in Actor.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnConstruction`是在Actor中定义的虚函数。'
- en: As a result, we override the function in our class.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在我们的类中重写该函数。
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component that it
    controls.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类构造函数中，我们像往常一样初始化我们的网格，并将我们的`bool`属性的默认状态设置为与其控制的组件的可见性相匹配。
- en: Inside `OnConstruction`, the actor rebuilds itself using any properties that
    are required for doing so.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnConstruction`中，Actor使用任何需要进行重建的属性来重建自身。
- en: For this simple example, we set the visibility of the mesh to match the value
    of our `ShowStaticMesh` property.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个简单的示例，我们将网格的可见性设置为与我们的`ShowStaticMesh`属性的值相匹配。
- en: This could also be extended to changing other values based on the value of the
    `ShowStaticMesh` variable.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也可以扩展到根据`ShowStaticMesh`变量的值更改其他值。
- en: You'll note that we don't explicitly filter on a particular property being changed
    like the previous recipe does with `PostEditChangeProperty`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，与前一个示例中使用`PostEditChangeProperty`显式过滤特定属性更改不同。
- en: The `OnConstruction` script runs in its entirety for every property that gets
    changed on the object.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnConstruction`脚本会在对象上的每个属性发生更改时完整运行。'
- en: It has no way of testing which property was just edited, so you need to be judicious
    about placing computationally intensive code within it.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它无法测试刚刚编辑的属性，因此您需要谨慎地将计算密集型代码放在其中。
- en: Creating a new editor module
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器模块
- en: The following recipes all interact with editor mode-specific code and engine
    modules. As a result, it is considered good practice to create a new module that
    will only be loaded when the engine is running in editor mode so that we can place
    all our editor-only code inside it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例都与编辑器模式特定代码和引擎模块进行交互。因此，根据惯例，创建一个仅在引擎以编辑器模式运行时加载的新模块，以便我们可以将所有仅限于编辑器的代码放在其中。
- en: How to do it…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Open your project's `.uproject` file in a text editor such as Notepad or Notepad++.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器（如记事本或Notepad++）中打开项目的`.uproject`文件。
- en: 'Add the bolded section of the following to the file:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下粗体部分添加到文件中：
- en: '[PRE32]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the comma after the first module before the second set of curly braces.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意第一个模块之后第二组花括号前的逗号。
- en: In your source folder, create a new folder using the same name as you specified
    in your `uproject` file (in this instance, `"UE4CookbookEditor"`).
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件夹中，使用与您在`uproject`文件中指定的名称相同的名称创建一个新文件夹（在本例中为`"UE4CookbookEditor"`）。
- en: Inside this new folder, create a file called `UE4CookbookEditor.Build.cs`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，创建一个名为`UE4CookbookEditor.Build.cs`的文件。
- en: 'Insert the following into the file:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容插入文件中：
- en: '[PRE33]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new file called `UE4CookbookEditor.h` and add the following:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UE4CookbookEditor.h`的新文件，并添加以下内容：
- en: '[PRE34]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Lastly, create a new source file called `UE4CookbookEditor.cpp`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`UE4CookbookEditor.cpp`的新源文件。
- en: 'Add the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE35]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, close Visual Studio if you have it open, then right-click on the `.uproject`
    file, and select **Generate Visual Studio Project files**.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果您已经打开了Visual Studio，请关闭它，然后右键单击`.uproject`文件，选择**生成Visual Studio项目文件**。
- en: You should see a small window launch, display a progress bar, and then close.![How
    to do it…](img/00191.jpeg)
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个小窗口启动，显示进度条，然后关闭。![操作步骤如下](img/00191.jpeg)
- en: You can now launch Visual Studio, verify that your new module is visible in
    the IDE, and compile your project successfully.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以启动Visual Studio，验证IDE中是否可见新模块，并成功编译项目。
- en: The module is now ready for the next set of recipes.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该模块现在已准备好进行下一组操作。
- en: Note
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Code changes made in this editor module won't support hot-reloading in the same
    way that code in runtime modules does. If you get a compilation error that mentions
    changes to generated header files, simply close the editor, and rebuild from within
    your IDE instead.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在此编辑器模块中进行的代码更改不支持与运行时模块中的代码相同的热重载。如果出现提到更改生成的头文件的编译错误，请关闭编辑器，然后从IDE内部重新构建。
- en: How it works…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: Unreal projects use the `.uproject` file format to specify a number of different
    pieces of information about the project.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unreal项目使用`.uproject`文件格式来指定有关项目的许多不同信息。
- en: This information is used to inform the Header and Build tools about the modules
    that comprise this project, and is used for code generation and `makefile` creation.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此信息用于通知头文件和构建工具关于组成此项目的模块，并用于代码生成和`makefile`创建。
- en: The file uses JSON-style formatting.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该文件使用JSON样式的格式。
- en: 'These include the following:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些包括以下内容：
- en: The engine version that the project should be opened in
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目应该在其中打开的引擎版本
- en: A list of modules that are used in the project
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目中使用的模块列表
- en: A list of module declarations
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块声明列表
- en: 'Each of these module declarations contain the following:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个模块声明都包含以下内容：
- en: The name of the module.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称。
- en: The type of the module—is it an editor module (only runs in editor builds, has
    access to editor-only classes) or a Runtime module (runs in both editor and Shipping
    builds).
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的类型-它是一个编辑器模块（仅在编辑器构建中运行，可以访问仅限于编辑器的类）还是运行时模块（在编辑器和发布构建中运行）。
- en: The loading phase of the module—modules can be loaded at different points during
    program startup. This value specifies the point at which the module should be
    loaded, for example, if there are dependencies in other modules that should be
    loaded first.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的加载阶段-模块可以在程序启动的不同阶段加载。这个值指定了模块应该在哪个点加载，例如，如果有其他模块的依赖应该先加载。
- en: A list of dependencies for the module. These are essential modules that contain
    exported functions or classes that the module relies on.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的依赖列表。这些是包含模块所依赖的导出函数或类的基本模块。
- en: We ad a new module to the `uproject file`. The module's name is `UE4CookbookEditor`
    (conventionally, `Editor` should be appended to the main game module for an editor
    module).
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向`uproject`文件添加了一个新模块。该模块的名称是`UE4CookbookEditor`（按照惯例，对于编辑器模块，应该在主游戏模块后附加`Editor`）。
- en: This module is marked as an editor module, and is set to load after the baseline
    engine so that it can use the classes declared in Engine code.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该模块被标记为编辑器模块，并设置为在基线引擎之后加载，以便可以使用在引擎代码中声明的类。
- en: Our module's dependencies are left at the default values for now.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模块的依赖关系暂时保持默认值。
- en: With the `uproject` file altered to contain our new module, we need a build
    script for it.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uproject`文件修改为包含我们的新模块后，我们需要一个构建脚本。
- en: Build scripts are written in C#, and take the name `<ModuleName>.Build.cs`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建脚本是用C#编写的，名称为`<ModuleName>.Build.cs`。
- en: C#, unlike C++, doesn't use a separate header file and implementation—it's all
    there in the one `.cs` file.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与C++不同，C#不使用单独的头文件和实现文件-所有内容都在一个`.cs`文件中。
- en: We want to access the classes declared in the `UnrealBuildTool` module, so we
    include a `using` statement to indicate that we want to access that namespace.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要访问在`UnrealBuildTool`模块中声明的类，因此我们包含一个`using`语句来指示我们要访问该命名空间。
- en: We create a `public` class with the same name as our module, and which inherits
    from `ModuleRules`.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个与我们的模块同名的`public`类，并继承自`ModuleRules`。
- en: Inside our constructor, we add a number of modules to the dependencies of this
    module.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们将多个模块添加到此模块的依赖项中。
- en: There are both private dependencies and public dependencies. According to the
    code of the `ModuleRules` class, Public dependencies are modules that your module's
    public header files depend on. Private dependencies are modules that the private
    code depends on. Anything used in both public headers and private code should
    go into the `PublicDependencyModuleNames` array.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有私有依赖和公共依赖。根据`ModuleRules`类的代码，公共依赖是您模块的公共头文件依赖的模块。私有依赖是私有代码依赖的模块。在公共头文件和私有代码中都使用的内容应放入`PublicDependencyModuleNames`数组中。
- en: You'll note that our `PublicDependencyModuleNames` array contains our main game
    module. This is because some recipes in this chapter will extend the editor to
    better support the classes defined within our main game module.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们的`PublicDependencyModuleNames`数组包含我们的主游戏模块。这是因为本章中的一些示例将扩展编辑器以更好地支持我们主游戏模块中定义的类。
- en: Now that we've told the build system that we have a new module to build through
    the project file, and we've specified how to build the module with the build script,
    we need to create the C++ class that is our actual module.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经告诉构建系统通过项目文件构建新模块，并且已经指定了如何使用构建脚本构建模块，我们需要创建实际模块的C++类。
- en: We create a header file that includes the Engine header, the `ModuleManager`
    header, and the `UnrealEd` header.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个包含引擎头文件、`ModuleManager`头文件和`UnrealEd`头文件的头文件。
- en: We include `ModuleManager` because it defines `IModuleInterface`, the class
    that our module will inherit from.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包括`ModuleManager`，因为它定义了`IModuleInterface`，我们的模块将继承自该类。
- en: We also include `UnrealEd` because we're writing an editor module that will
    need to access the editor functionality.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还包括`UnrealEd`，因为我们正在编写一个需要访问编辑器功能的编辑器模块。
- en: The class we declare inherits from `IModuleInterface`, and takes its name from
    the usual prefix, `F`, followed by the module name.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明的类继承自`IModuleInterface`，并从通常的前缀`F`开始命名。
- en: Inside the `.cpp` file, we include our module's header, and then use the `IMPLEMENT_GAME_MODULE`
    macro.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，我们包含了模块的头文件，然后使用`IMPLEMENT_GAME_MODULE`宏。
- en: '`IMPLEMENT_GAME_MODULE` declares an exported C function, `InitializeModule()`,
    which returns an instance of our new module class.'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IMPLEMENT_GAME_MODULE`声明了一个导出的C函数`InitializeModule()`，它返回我们新模块类的实例。'
- en: This means that Unreal can simply call `InitializeModule()` on any library that
    exports it to retrieve a reference to the actual module implementation without
    needing to know what class it is.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着Unreal可以简单地调用任何导出它的库上的`InitializeModule()`来检索对实际模块实现的引用，而不需要知道它是什么类。
- en: Having added our new module, we now need to rebuild our Visual Studio solution,
    so we close Visual Studio and then regenerate the project files using the context
    menu.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了新模块后，我们现在需要重新构建Visual Studio解决方案，因此关闭Visual Studio，然后使用上下文菜单重新生成项目文件。
- en: With the project rebuilt, the new module will be visible in Visual Studio, and
    we can add code to it as usual.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建项目后，新模块将在Visual Studio中可见，我们可以像往常一样向其添加代码。
- en: Creating new toolbar buttons
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的工具栏按钮
- en: If you have created a custom tool or window for display within the editor, you
    probably need some way to let the user make it appear. The easiest way to do this
    is to create a toolbar customization that adds a new toolbar button, and have
    it display your window when clicked.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经为编辑器创建了自定义工具或窗口，那么您可能需要一种让用户显示它的方法。最简单的方法是创建一个工具栏自定义，添加一个新的工具栏按钮，并在点击时显示您的窗口。
- en: Create a new engine module by following the previous recipe, as we'll need it
    to initialize our toolbar customization.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例创建一个新的引擎模块，因为我们需要它来初始化我们的工具栏自定义。
- en: How to do it…
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new header file, and insert the following class declaration:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的头文件，并插入以下类声明：
- en: '[PRE36]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the new class by placing the following in the `.cpp` file:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`.cpp`文件中放置以下内容来实现新类：
- en: '[PRE37]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following within your module class:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的模块类中添加以下内容：
- en: '[PRE38]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Be sure to `#include` the header file for your command class as well.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保还`#include`您的命令类的头文件。
- en: 'We now need to implement `StartupModule` and `ShutdownModule`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要实现`StartupModule`和`ShutdownModule`：
- en: '[PRE39]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following includes:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下包含：
- en: '[PRE40]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Compile your project, and start the editor.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目，并启动编辑器。
- en: Verify that there's a new button on the toolbar in the main level editor, which
    can be clicked on to open a new window:![How to do it…](img/00192.jpeg)
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证在主级别编辑器的工具栏上有一个新按钮，可以单击它打开一个新窗口：![如何操作…](img/00192.jpeg)
- en: How it works…
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Unreal's editor UI is based on the concept of commands. Commands are a design
    pattern that allows looser coupling between the UI and the actions that it needs
    to perform.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unreal的编辑器UI基于命令的概念。命令是一种设计模式，允许UI和它需要执行的操作之间的耦合度较低。
- en: In order to create a class that contains a set of commands, it is necessary
    to inherit from `TCommands`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个包含一组命令的类，需要继承自`TCommands`。
- en: '`TCommands` is a template class that leverages the **Curiously Recurring Template
    Pattern** (**CRTP**). The CRTP is used commonly throughout **Slate** UI code as
    a means of creating compile-time polymorphism.'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TCommands`是一个模板类，利用了**奇异递归模板模式**（**CRTP**）。CRTP在**Slate** UI代码中常用作创建编译时多态的一种方式。'
- en: In the initializer list for `FCookbookCommands` constructor, we invoke the parent
    class constructor, passing in a number of parameters.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FCookbookCommands`构造函数的初始化列表中，我们调用父类构造函数，传入多个参数。
- en: The first parameter is the name of the command set, and is a simple `FName`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是命令集的名称，是一个简单的`FName`。
- en: The second parameter is a tooltip/human readable string, and as such, uses `FText`
    so it can support localization if necessary.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是一个工具提示/可读字符串，因此使用`FText`，以便在需要时支持本地化。
- en: If there's a parent group of commands, the third parameter contains the name
    of the group. Otherwise, it contains `NAME_None`.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有一个命令的父组，第三个参数包含组的名称。否则，它包含`NAME_None`。
- en: The final parameter for the constructor is the Slate Style set that contains
    any command icons that the command set will be using.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的最后一个参数是包含命令集将使用的任何命令图标的Slate样式集。
- en: The `RegisterCommands()` function allows `TCommands`-derived classes to create
    any command objects that they require. The resulting `FUICommandInfo` instances
    returned from that function are stored inside the `Commands` class as members
    so that UI elements or functions can be bound to the commands.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegisterCommands()`函数允许`TCommands`派生类创建它们所需的任何命令对象。从该函数返回的`FUICommandInfo`实例存储在`Commands`类中作为成员，以便可以将UI元素或函数绑定到命令上。'
- en: This is why we have the member variable `TSharedPtr<FUICommandInfo> MyButton`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么我们有一个成员变量`TSharedPtr<FUICommandInfo> MyButton`。
- en: In the implementation for the class, we simply need to create our commands in
    `RegisterCommands`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的实现中，我们只需要在`RegisterCommands`中创建我们的命令。
- en: The `UI_COMMAND` macro used to create an instance of `FUICommandInfo` expects
    a localization namespace to be defined even if it is just an empty default namespace.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UI_COMMAND`宏用于创建`FUICommandInfo`的实例，即使只是一个空的默认命名空间，也需要定义一个本地化命名空间。'
- en: As a result, we need to enclose our `UI_COMMAND` calls with `#defines` to set
    a valid value for `LOCTEXT_NAMESPACE` even if we don't intend to use localization.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，即使我们不打算使用本地化，我们仍需要用`#defines`来封装我们的`UI_COMMAND`调用，以设置`LOCTEXT_NAMESPACE`的有效值。
- en: The actual `UI_COMMAND` macro takes a number of parameters.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的`UI_COMMAND`宏接受多个参数。
- en: The first parameter is the variable to store the `FUICommandInfo` in.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是用来存储`FUICommandInfo`的变量。
- en: The second parameter is a human-readable name for the command.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是一个可读的命令名称。
- en: The third parameter is a description for the command.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个参数是命令的描述。
- en: The fourth parameter is `EUserInterfaceActionType`. This enumeration essentially
    specifies what sort of button is being created. It supports `Button`, `ToggleButton`,
    `RadioButton`, and `Check` as valid types.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个参数是`EUserInterfaceActionType`。这个枚举实际上指定了正在创建的按钮的类型。它支持`Button`、`ToggleButton`、`RadioButton`和`Check`作为有效类型。
- en: Buttons are simple generic buttons. A toggle button stores on and off states.
    The radio button is similar to a toggle, but is grouped with other radio buttons,
    and only one can be enabled at a time. Lastly, the checkbox displays a read-only
    checkbox adjacent to the button.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮是简单的通用按钮。切换按钮存储开和关的状态。单选按钮类似于切换按钮，但与其他单选按钮分组，并且一次只能启用一个。最后，复选框在按钮旁边显示一个只读复选框。
- en: The last parameter for `UI_COMMAND` is the input chord, or the combination of
    keys required to activate the command.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UI_COMMAND`的最后一个参数是输入键组合，或者激活命令所需的键的组合。'
- en: This parameter is primarily useful for defining key combinations for hotkeys
    linked to the command in question rather than buttons. As a result, we use an
    empty `InputGesture`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数主要用于为与该命令相关联的热键定义键组合，而不是按钮。因此，我们使用一个空的`InputGesture`。
- en: So we now have a set of commands, but we haven't told the engine we want to
    add the set to the commands that show on the toolbar. We also haven't set up what
    actually happens when the button is clicked. In order to do this, we need to perform
    some initialization when our module begins, so we place some code into the `StartupModule`/`ShutdownModule`
    functions.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以现在我们有了一组命令，但是我们还没有告诉引擎我们想要将这组命令添加到工具栏上显示的命令中。我们也还没有设置当按钮被点击时实际发生的事情。为了做到这一点，我们需要在模块开始时执行一些初始化操作，所以我们将一些代码放入`StartupModule`/`ShutdownModule`函数中。
- en: Inside `StartupModule`, we call the static `Register` function on the commands
    class that we defined earlier.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`中，我们调用之前定义的命令类上的静态`Register`函数。
- en: We then create a shared pointer to a list of commands using the `MakeShareable`
    function.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`MakeShareable`函数创建一个命令列表的共享指针。
- en: In the command list, we use `MapAction` to create a mapping, or association,
    between the `UICommandInfo` object, which we set as a member of the `FCookbookCommands`,
    and the actual function we want to execute when the command is invoked.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令列表中，我们使用`MapAction`来创建一个映射或关联，将我们设置为`FCookbookCommands`的成员的`UICommandInfo`对象与我们希望在调用命令时执行的实际函数关联起来。
- en: You'll note that we don't explicitly set anything regarding what could be used
    to invoke the command here.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，我们在这里没有明确设置任何关于如何调用命令的内容。
- en: To perform this mapping, we call the `MapAction` function. The first parameter
    to `MapAction` is a `FUICommandInfo` object, which we can retrieve from `FCookbookCommands`
    by using its static `Get()` method to retrieve the instance.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行这个映射，我们调用`MapAction`函数。`MapAction`的第一个参数是一个`FUICommandInfo`对象，我们可以通过使用它的静态`Get()`方法从`FCookbookCommands`中检索实例来获取它。
- en: '`FCookbookCommands` is implemented as a singleton—a class with a single instance
    that exists throughout the application. You''ll see the pattern in most places—there''s
    a static `Get()` method available in the engine.'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FCookbookCommands`被实现为一个单例类，即一个在整个应用程序中存在的单个实例。你会在大多数地方看到这种模式——引擎中有一个可用的静态`Get()`方法。'
- en: The second parameter of the `MapAction` function is a delegate bound to the
    function to be invoked when the command is executed.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MapAction`函数的第二个参数是一个绑定到在执行命令时要调用的函数的委托。'
- en: Because `UE4CookbookEditorModule` is a raw C++ class rather than a `UObject`,
    and we want to invoke a member function rather than a `static` function, we use
    `CreateRaw` to create a new delegate bound to a raw C++ member function.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`UE4CookbookEditorModule`是一个原始的C++类，而不是一个`UObject`，我们想要调用一个成员函数而不是一个`static`函数，所以我们使用`CreateRaw`来创建一个绑定到原始C++成员函数的新委托。
- en: '`CreateRaw` expects a pointer to the object instance, and a function reference
    to the function to invoke on that pointer.'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateRaw`期望一个指向对象实例的指针，并且一个对该指针上要调用的函数的函数引用。'
- en: The third parameter for `MapAction` is a delegate to call to test if the action
    can be executed. Because we want the command to be executable all the time, we
    can use a simple pre-defined delegate that always returns `true`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MapAction`的第三个参数是一个委托，用于调用以测试是否可以执行该操作。因为我们希望该命令始终可执行，所以我们可以使用一个简单的预定义委托，它始终返回`true`。'
- en: With an association created between our command and the action it should call,
    we now need to actually tell the extension system that we want to add new commands
    to the toolbar.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将我们的命令与它应该调用的操作关联起来，我们现在需要告诉扩展系统我们想要向工具栏添加新的命令。
- en: We can do this via the `FExtender` class, which can be used to extend menus,
    context menus, or toolbars.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过`FExtender`类来实现这一点，该类可用于扩展菜单、上下文菜单或工具栏。
- en: We initially create an instance of `FExtender` as a shared pointer so that our
    extensions are uninitialized when the module is shut down.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最初创建了一个`FExtender`的实例作为共享指针，以便在模块关闭时我们的扩展未初始化。
- en: We then call `AddToolBarExtension` on our new extender, storing the results
    in a shared pointer so that we can remove it on module uninitialization.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在我们的新扩展器上调用`AddToolBarExtension`，将结果存储在共享指针中，以便在模块未初始化时将其移除。
- en: '`AddToolBarExtension''s` first argument is the name of the extension point
    where we want to add our extension.'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddToolBarExtension`的第一个参数是我们要添加扩展的扩展点的名称。'
- en: To find where we want to place our extension, we first need to turn on the display
    of extension points within the editor UI.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到我们要放置扩展的位置，我们首先需要在编辑器UI中打开扩展点的显示。
- en: To do so, open **Editor Preferences** in the **Edit** menu within the editor:![How
    it works…](img/00193.jpeg)
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，请在编辑器的**Edit**菜单中打开**Editor Preferences**：![它是如何工作的...](img/00193.jpeg)
- en: Open **General** | **Miscellaneous**, and select **Display UIExtension Points**:![How
    it works…](img/00194.jpeg)
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**General** | **Miscellaneous**，然后选择**Display UIExtension Points**：![它是如何工作的...](img/00194.jpeg)
- en: Restart the editor, and you should see green text overlaid on the editor UI,
    as in the following screenshot:![How it works…](img/00195.jpeg)
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动编辑器，您应该会看到覆盖在编辑器UI上的绿色文本，如下面的屏幕截图所示：![它是如何工作的...](img/00195.jpeg)
- en: The green text indicates `UIExtensionPoint`, and the text's value is the string
    we should provide to the `AddToolBarExtension` function.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绿色文本表示`UIExtensionPoint`，文本的值是我们应该提供给`AddToolBarExtension`函数的字符串。
- en: We're going to add our extension to the **Compile** extension point in this
    recipe, but of course, you could use any other extension point you wish.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本示例中，我们将在**Compile**扩展点中添加我们的扩展，但是当然，您可以使用任何其他您希望的扩展点。
- en: It's important to note that adding a toolbar extension to a menu extension point
    will fail silently, and vice versa.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的是要注意，将工具栏扩展添加到菜单扩展点将会静默失败，反之亦然。
- en: The second parameter to `AddToolBarExtension` is a location anchor relative
    to the extension point specified. We've selected `FExtensionHook::Before`, so
    our icon will be displayed before the compile point.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddToolBarExtension`的第二个参数是相对于指定的扩展点的位置锚点。我们选择了`FExtensionHook::Before`，所以我们的图标将显示在编译点之前。'
- en: The next parameter is our command list containing mapped actions.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个参数是包含映射操作的命令列表。
- en: Finally, the last parameter is a delegate that is responsible for actually adding
    UI controls to the toolbar at the extension point and the anchor that we specified
    earlier.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最后一个参数是一个委托，负责将UI控件实际添加到我们之前指定的扩展点和锚点的工具栏上。
- en: The delegate is bound to a function that has the form void (`*func`)(`FToolBarBuilder`
    and `builder`). In this instance, it is a function called `AddToolbarExtension`
    defined in our module class.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托绑定到一个具有形式void(`*func`)(`FToolBarBuilder`和`builder`)的函数。在这个实例中，它是我们模块类中定义的一个名为`AddToolbarExtension`的函数。
- en: When the function is invoked, calling commands on the `builder` that add UI
    elements will apply those elements to the location in the UI we specified.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用该函数时，调用在作为函数参数传入的`FToolBarBuilder`实例上的命令，添加UI元素将将这些元素应用到我们指定的UI位置。
- en: Lastly, we need to load the level editor module within this function so that
    we can add our extender to the main toolbar within the level editor.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在此函数中加载级别编辑器模块，以便我们可以将我们的扩展器添加到级别编辑器中的主工具栏中。
- en: As usual, we can use `ModuleManager` to load a module and return a reference
    to it.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以使用`ModuleManager`加载一个模块并返回对它的引用。
- en: With that reference in hand, we can get the Toolbar Extensibility Manager for
    the module, and tell it to add our Extender.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个引用，我们可以获取模块的工具栏扩展性管理器，并告诉它添加我们的扩展器。
- en: While this may seem cumbersome at first, the intention is to allow you to apply
    the same toolbar extension to multiple toolbars in different modules if you would
    like to create a consistent UI layout between different editor windows.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然一开始可能会感到繁琐，但这样做的目的是允许您将相同的工具栏扩展应用于不同模块中的多个工具栏，以便在不同的编辑器窗口之间创建一致的UI布局。
- en: The counterpart to initializing our extension, of course, is removing it when
    our module is unloaded. To do that, we remove our extension from the extender,
    then null the shared pointers for both Extender and extension reclaiming their
    memory allocation.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，初始化我们的扩展的对应操作是在模块卸载时将其移除。为此，我们从扩展器中移除我们的扩展，然后将Extender和扩展的共享指针置空，以回收它们的内存分配。
- en: The `AddToolBarExtension` function within the editor module is the one which
    is responsible for actually adding UI elements to the toolbar that can invoke
    our commands.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddToolBarExtension`函数在编辑器模块中负责实际将UI元素添加到工具栏中，这些UI元素可以调用我们的命令。'
- en: It does this by calling functions on the `FToolBarBuilder` instance passed in
    as a function parameter.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过在传入的`FToolBarBuilder`实例上调用函数来实现这一点。
- en: Firstly, we retrieve an appropriate icon for our new toolbar button using the
    `FSlateIcon` constructor.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`FSlateIcon`构造函数为我们的新工具栏按钮获取适当的图标。
- en: With the icon loaded, we invoke `AddToolBarButton` on the `builder` instance.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了加载的图标，我们在`builder`实例上调用`AddToolBarButton`。
- en: '`AddToolbarButton` has a number of parameters.'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddToolbarButton`有许多参数。'
- en: The first parameter is the command to bind to—you'll notice it's the same `MyButton`
    member that we accessed earlier when binding the action to the command.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是要绑定的命令 - 您会注意到它与我们之前绑定操作到命令时访问的`MyButton`成员相同。
- en: The second parameter is an override for the extension hook we specified earlier,
    but we don't want to override that so we can use `NAME_None`.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是我们之前指定的扩展挂钩的覆盖，但我们不想覆盖它，所以我们可以使用`NAME_None`。
- en: The third parameter is a label override for the new button that we create.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个参数是我们创建的新按钮的标签覆盖。
- en: Parameter four is a tooltip for the new button.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个参数是新按钮的工具提示。
- en: The second-last parameter is the button's icon, and the last parameter is a
    name used to refer to this button element for highlighting support if you wish
    to use the in-editor tutorial framework.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 倒数第二个参数是按钮的图标，最后一个参数是用于引用此按钮元素以支持突出显示的名称，如果您希望使用编辑器内教程框架。
- en: Creating new menu entries
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新菜单项
- en: The workflow for creating new menu entries is almost identical to that for creating
    new toolbar buttons, so this recipe will build on the previous one, and show you
    how to add the command created therein to a menu rather than a toolbar.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新菜单项的工作流程与创建新工具栏按钮的工作流程几乎相同，因此本教程将在前一个教程的基础上进行构建，并向您展示如何将其中创建的命令添加到菜单而不是工具栏。
- en: How to do it…
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new function in your `module` class:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`module`类中创建一个新函数：
- en: '[PRE41]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find the following code within the `StartupModule` function:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`函数中找到以下代码：
- en: '[PRE42]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace the preceding code with the following:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换前面的代码：
- en: '[PRE43]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compile your code, and launch the editor.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Verify that you now have a menu entry under the **Window** menu that displays
    the **Cookbook** window when clicked. If you followed the preceding recipe, you'll
    also see the green text listing the UI extension points, including the one we
    used in this recipe (**LevelEditor**).![How to do it…](img/00196.jpeg)
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证现在在**Window**菜单下是否有一个菜单项，当单击时显示**Cookbook**窗口。如果您按照前面的教程操作，您还将看到列出UI扩展点的绿色文本，包括我们在此教程中使用的扩展点（**LevelEditor**）。![操作步骤...](img/00196.jpeg)
- en: How it works…
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: You'll note that `ToolbarExtender` is of type `FExtender` rather than `FToolbarExtender`
    or `FMenuExtender`.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到`ToolbarExtender`的类型是`FExtender`而不是`FToolbarExtender`或`FMenuExtender`。
- en: By using a generic `FExtender` class rather than a specific subclass, the framework
    allows you to create a series of command-function mappings that can be used on
    either menus or toolbars. The delegate that actually adds the UI controls (in
    this instance, `AddMenuExtension`) can link those controls to a subset of commands
    from your `FExtender`.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用通用的`FExtender`类而不是特定的子类，框架允许您创建一系列可以用于菜单或工具栏的命令-函数映射。实际添加UI控件的委托（在本例中为`AddMenuExtension`）可以将这些控件链接到您的`FExtender`中的一部分命令。
- en: This way, you don't need to have different `TCommands` classes for different
    types of extensions, and you can place the commands into a single central class
    regardless of where those commands are invoked from the UI.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，您就不需要为不同类型的扩展创建不同的`TCommands`类，并且可以将命令放入单个中央类中，而不管这些命令从UI的哪个位置调用。
- en: 'As a result, the only changes that are required are as follows:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，唯一需要的更改如下：
- en: Swapping calls to `AddToolBarExtension` with `AddMenuExtension`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AddToolBarExtension`的调用与`AddMenuExtension`交换。
- en: Creating a function that can be bound to `FMenuExtensionDelegate` rather than
    `FToolbarExtensionDelegate`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以绑定到`FMenuExtensionDelegate`而不是`FToolbarExtensionDelegate`的函数。
- en: Adding the extender to a Menu Extensibility Manager rather than a Toolbar Extensibility
    Manager.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将扩展器添加到菜单扩展性管理器而不是工具栏扩展性管理器。
- en: Creating a new editor window
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器窗口
- en: Custom editor windows are useful when you have a new tool with user-configurable
    settings, or want to display some information to people using your customized
    editor.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义编辑器窗口在您具有具有用户可配置设置的新工具或希望向使用您的自定义编辑器的人显示一些信息时非常有用。
- en: Be sure to have an editor module by following the recipe earlier in this chapter
    before you start.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保按照本章前面的教程创建了一个编辑器模块。
- en: Read through either the *Creating new menu entries* or *Creating new toolbar
    buttons* recipes so that you can create a button within the editor that will launch
    our new window.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*创建新菜单项*或*创建新工具栏按钮*的任一教程，以便您可以在编辑器中创建一个按钮，该按钮将启动我们的新窗口。
- en: How to do it…
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Inside your command''s bound function, add the following code:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令的绑定函数中，添加以下代码：
- en: '[PRE44]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compile your code, and launch the editor.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: When you activate the command you created, either by selecting the custom menu
    option or the toolbar option that you added, you should see that the window has
    been displayed with some centered text in the middle:![How to do it…](img/00197.jpeg)
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您激活您创建的命令时，无论是选择自定义菜单选项还是您添加的工具栏选项，您都应该看到窗口已显示在中间的一些居中文本中：![操作步骤...](img/00197.jpeg)
- en: How it works…
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: As should be self-explanatory, your new editor window won't display itself,
    and so, at the start of this recipe, it is mentioned that you should have implemented
    a custom menu or toolbar button or a console command that we can use to trigger
    the display of our new window.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如自解释，您的新编辑器窗口不会自行显示，因此，在本教程开始时提到，您应该实现一个自定义菜单或工具栏按钮或控制台命令，我们可以使用它来触发显示我们的新窗口。
- en: All of Slate's widgets are usually interacted with in the form of `TSharedRef<
    >` or `TSharedPtr< >`.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有Slate的小部件通常以`TSharedRef<>`或`TSharedPtr<>`的形式进行交互。
- en: The `SNew()` function returns a `TSharedRef` templated on the requested widget
    class.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SNew()`函数返回一个以请求的小部件类为模板的`TSharedRef`。'
- en: As has been mentioned elsewhere in this chapter, Slate widgets have a number
    of functions that they implement, which all return the object that the function
    was invoked on. This allows for method chaining to be used to configure the object
    at creation time.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如本章其他地方提到的，Slate小部件有许多它们实现的函数，这些函数都返回调用该函数的对象。这允许在创建时使用方法链来配置对象。
- en: This is what allows for the Slate syntax of `<Widget>.Property(Value).Property(Value)`.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是允许使用Slate语法`<Widget>.Property(Value).Property(Value)`的原因。
- en: The properties that are set on the widget in this recipe are the window title,
    the window size, and whether the window can be maximized and minimized.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们设置的小部件属性包括窗口标题、窗口大小以及窗口是否可以最大化和最小化。
- en: Once all the requisite properties on a widget have been set, the bracket operators
    (`[]`) can be used to specify the content to be placed inside the widget, for
    example, a picture or label inside a button.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦小部件上的所有必需属性都被设置好，括号运算符（`[]`）可以用来指定要放置在小部件内部的内容，例如，在按钮内部放置图片或标签。
- en: '`SWindow` is a top-level widget with only one slot for child widgets, so we
    don''t need to add a slot for it ourselves. We place content into that slot by
    creating it inside the pair of brackets.'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SWindow`是一个顶级小部件，只有一个用于子小部件的slot，所以我们不需要为它自己添加一个slot。我们通过在括号内创建内容来将内容放入该slot中。'
- en: The content we create is `SVerticalBox`, which is a widget that can have an
    arbitrary number of slots for child widgets that are displayed in a vertical list.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的内容是`SVerticalBox`，它是一个可以有任意数量的子小部件的小部件，这些子小部件以垂直列表的形式显示。
- en: For each widget we want to place into the vertical list, we need to create a
    **slot**.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们想要放置在垂直列表中的每个小部件，我们需要创建一个**slot**。
- en: The easiest way to do this is to use the overloaded `+` operator and the `SVerticalBox::Slot()`
    function.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做到这一点最简单的方法是使用重载的`+`运算符和`SVerticalBox::Slot()`函数。
- en: '`Slot()` returns a widget like any other, so we can set properties on it like
    we did on our `SWindow`.'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Slot()`返回一个像其他小部件一样的小部件，所以我们可以像在`SWindow`上设置属性一样在其上设置属性。'
- en: This recipe centers the Slot's content on both horizontal and vertical axes
    using `HAlign` and `VAlign`.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例使用`HAlign`和`VAlign`来使Slot的内容在水平和垂直轴上居中。
- en: A `Slot` has a single child widget, and it's created inside the `[]` operators
    just as for `SWindow`.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Slot`有一个单独的子小部件，并且它是在`[]`运算符中创建的，就像对于`SWindow`一样。'
- en: Inside the `Slot` content, we create a text block with some custom text.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Slot`内容中，我们创建了一个带有一些自定义文本的文本块。
- en: Our new `SWindow` now has its child widgets added, but it isn't being displayed
    yet, because it isn't added to the window hierarchy.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新`SWindow`现在已经添加了其子小部件，但还没有显示出来，因为它还没有添加到窗口层级中。
- en: The main frame module is used to check if we have a top-level editor window,
    and if it exists, our new window is added as a child.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主框架模块用于检查是否有顶级编辑器窗口，如果存在，则将我们的新窗口添加为子窗口。
- en: If there's no top-level window to be added as a child to, then we use the Slate
    Application singleton to add our window without a parent.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有顶级窗口要作为子窗口添加，那么我们可以使用Slate应用程序单例将我们的窗口添加到没有父窗口的情况下。
- en: If you would like to see the hierarchy of the window we've created, you can
    use the Slate Widget Reflector, which can be accessed via **Window** | **Developer
    Tools** | **Widget Reflector**.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要查看我们创建的窗口的层次结构，你可以使用Slate小部件反射器，它可以通过**窗口** | **开发者工具** | **小部件反射器**访问。
- en: If you select **Pick Live Widget**, and hover your cursor over the text in the
    center of our custom window, you will be able to see the **SWindow** with our
    custom widgets added to its hierarchy.![How it works…](img/00198.jpeg)
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择**选择实时小部件**，并将光标悬停在我们自定义窗口中央的文本上，你将能够看到包含我们自定义小部件的**SWindow**的层次结构。![它的工作原理…](img/00198.jpeg)
- en: See also
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 9](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121
    "Chapter 9. User Interfaces – UI and UMG"), *User Interfaces – UI and UMG*, is
    all about UI, and will show you how to add additional elements to your new custom
    window'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121 "第9章.
    用户界面 - UI和UMG")，“用户界面 - UI和UMG”，讲解了UI，并且会向你展示如何向你的新自定义窗口添加额外的元素。'
- en: Creating a new Asset type
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的资产类型
- en: At some point in your project, you might need to create a new custom Asset class,
    for example, an Asset to store conversation data in an RPG.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的某个时候，你可能需要创建一个新的自定义资产类，例如，用于在RPG中存储对话数据的资产。
- en: In order to properly integrate these with **Content Browser**, you'll need to
    create a new Asset type.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地将它们与**内容浏览器**集成，你需要创建一个新的资产类型。
- en: How to do it…
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a custom Asset based on `UObject`:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`UObject`的自定义资产：
- en: '[PRE45]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a class called `UCustomAssetFactory` based on `UFactory`, overriding
    `FactoryCreateNew`:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UCustomAssetFactory`的类，基于`UFactory`，并重写`FactoryCreateNew`方法：
- en: '[PRE46]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the class:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个类：
- en: '[PRE47]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Compile your code, and open the editor.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码，并打开编辑器。
- en: Right-click in **Content Browser**, and under the **Miscellaneous** tab of the
    **Create Advanced Asset** section, you should see your new class, and be able
    to create instances of your new custom type.![How to do it…](img/00199.jpeg)
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中右键单击，在**创建高级资产**部分的**杂项**选项卡下，你应该能够看到你的新类，并能够创建你的新自定义类型的实例。![如何操作…](img/00199.jpeg)
- en: How it works…
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: The first class is the actual object that can exist in the game at runtime.
    It's your texture, data file, or curve data, whatever you require.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个类是实际在游戏运行时存在的对象。它可以是纹理、数据文件或曲线数据，根据你的需求而定。
- en: For the purpose of this recipe, the simplest example is an asset that has an
    `FString` property to contain a name.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，最简单的例子是一个具有`FString`属性来存储名称的资产。
- en: The property is marked as `UPROPERTY` so that it remains in memory, and additionally
    marked as `EditAnywhere` so that it is editable on both, the default object and
    on instances of it.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该属性被标记为`UPROPERTY`，以便它保留在内存中，并且额外标记为`EditAnywhere`，以便在默认对象和其实例上都可以编辑它。
- en: The second class is `Factory`. Unreal uses the `Factory` design pattern to create
    instances of assets.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个类是`Factory`。虚幻使用`Factory`设计模式来创建资产的实例。
- en: This means that there is a generic base `Factory` that uses virtual methods
    to declare the interface of object creation, and then `Factory` subclasses are
    responsible for creating the actual object in question.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着有一个通用的基础`Factory`，它使用虚拟方法来声明对象创建的接口，然后`Factory`的子类负责创建实际的对象。
- en: The advantage of this approach is that the user-created subclass can potentially
    instantiate one of its own subclasses if required; it hides the implementation
    details regarding deciding which object to create away from the object requesting
    the creation.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法的优点是，用户创建的子类可以在需要时实例化其自己的子类；它将决定创建哪个对象的实现细节隐藏在请求创建的对象之外。
- en: With `UFactory` as our base class, we include the appropriate header.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`UFactory`作为基类，我们包含适当的头文件。
- en: The constructor is overridden, because there are a number of properties that
    we want to set for our new factory after the default constructor has run.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数被重写，因为在默认构造函数运行后，我们希望为新工厂设置一些属性。
- en: '`bCreateNew` signifies that the factory is currently able to create a new instance
    of the object in question from scratch.'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bCreateNew`表示工厂当前能够从头开始创建对象的新实例。'
- en: '`bEditAfterNew` indicates that we would like to edit the newly created object
    immediately after creation.'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “bEditAfterNew”表示我们希望在创建后立即编辑新创建的对象。
- en: The `SupportedClass` variable is an instance of `UClass` containing reflection
    information about the type of object the factory will create.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “SupportedClass”变量是一个包含有关工厂将创建的对象类型的反射信息的“UClass”的实例。
- en: The most significant function of our `UFactory` subclass is the actual factory
    method—`FactoryCreateNew`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`UFactory`子类最重要的功能是实际的工厂方法——`FactoryCreateNew`。
- en: '`FactoryCreateNew` is responsible for determining the type of object that should
    be created, and using `NewObject` to construct an instance of that type. It passes
    the following parameters through to the `NewObject` call.'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FactoryCreateNew`负责确定应该创建的对象类型，并使用`NewObject`构造该类型的实例。它将以下参数传递给`NewObject`调用。'
- en: '`InClass` is the class of object that will be constructed.'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InClass`是将要构造的对象的类。'
- en: '`InParent` is the object that should be containing the new object that will
    be created. If this isn''t specified, the object is assumed to go into the transient
    package, which means that it won''t be automatically saved.'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InParent`是应该包含将要创建的新对象的对象。如果未指定此参数，则假定对象将进入临时包，这意味着它不会自动保存。'
- en: '`Name` is the name of the object to be created.'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Name`是要创建的对象的名称。'
- en: '`Flags` is a bitmask of creation flags that control things such as making the
    object visible outside of the package it is contained in.'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Flags`是一个位掩码，用于控制创建标志，例如使对象在其所包含的包之外可见。'
- en: Within `FactoryCreateNew`, decisions can be made regarding which subclass should
    be instantiated. Other initialization can also be performed; for example, if there
    are sub-objects that require manual instantiation or initialization, they can
    be added here.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FactoryCreateNew`中，可以根据需要决定实例化哪个子类。还可以执行其他初始化操作；例如，如果有需要手动实例化或初始化的子对象，可以在此处添加。
- en: 'An example from the engine code for this function is as follows:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数的引擎代码示例如下：
- en: '[PRE48]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As can be seen here, there's a second call to `NewObject` to populate the `CameraInterpGroup`
    member of the `NewCamAnim` instance.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此所示，这里有第二次调用`NewObject`来填充`NewCamAnim`实例的`CameraInterpGroup`成员。
- en: See also
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Editing class properties in different places in the editor* recipe earlier
    in this chapter gives more context to the `EditAnywhere` property specifier
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的“编辑类属性在编辑器中的不同位置”配方为“EditAnywhere”属性指定器提供了更多上下文。
- en: Creating custom context menu entries for Assets
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为资产创建自定义上下文菜单项
- en: Custom Asset types commonly have special functions you wish to be able to perform
    on them. For example, converting images to sprites is an option you wouldn't want
    to add to any other Asset type. You can create custom context menu entries for
    specific Asset types in order to make those functions accessible to users.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资产类型通常具有您希望能够对其执行的特殊功能。例如，将图像转换为精灵是您不希望添加到任何其他资产类型的选项。您可以为特定的资产类型创建自定义上下文菜单项，以使这些功能对用户可用。
- en: How to do it…
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Create a new class based on `FAssetTypeActions_Base`. You'll need to include
    `AssetTypeActions_Base.h` in the header file.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`FAssetTypeActions_Base`的新类。您需要在头文件中包含`AssetTypeActions_Base.h`。
- en: 'Override the following virtual functions in the class:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中重写以下虚拟函数：
- en: '[PRE49]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Declare the following function:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下函数：
- en: '[PRE50]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the declared functions in the `.cpp` file:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现声明的函数：
- en: '[PRE51]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Within your editor module, add the following code to the `StartupModule()`
    function:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器模块中，将以下代码添加到`StartupModule()`函数中：
- en: '[PRE52]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following inside the module''s `ShutdownModule()` function:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的“ShutdownModule()”函数中添加以下内容：
- en: '[PRE53]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Compile your project, and launch the editor.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目并启动编辑器。
- en: Create an instance of your custom Asset inside **Content Browser**.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中创建自定义资产的实例。
- en: Right-click on your new Asset to see our custom command in the context menu.![How
    to do it…](img/00200.jpeg)
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的新资产，查看上下文菜单中的自定义命令。![操作步骤](img/00200.jpeg)
- en: Select the **CustomAssetAction** command to display a new blank editor window.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CustomAssetAction**命令以显示一个新的空白编辑器窗口。
- en: How it works…
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The base class for all asset type-specific context menu commands is `FAssetTypeActions_Base`,
    so we need to inherit from that class.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有特定于资产类型的上下文菜单命令的基类是“FAssetTypeActions_Base”，因此我们需要从该类继承。
- en: '`FAssetTypeActions_Base` is an abstract class that defines a number of virtual
    functions that allow for extending the context menu. The interface which contains
    the original information for these virtual functions can be found in `IAssetTypeActions.h`.'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FAssetTypeActions_Base`是一个抽象类，定义了一些虚拟函数，允许扩展上下文菜单。包含这些虚拟函数的原始信息的接口可以在`IAssetTypeActions.h`中找到。'
- en: We also declare a function which we bind to our custom context menu entry.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还声明了一个函数，将其绑定到我们自定义的上下文菜单项。
- en: '`IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )` is the
    function called by the engine code to see if our `AssetTypeActions` class contains
    any actions that can be applied to the selected objects.'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::HasActions(const TArray<UObject*>& InObjects)`是引擎代码调用的函数，用于查看我们的`AssetTypeActions`类是否包含可以应用于所选对象的任何操作。'
- en: '`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder&
    MenuBuilder)` is called if the `HasActions` function returns `true`. It calls
    functions on `MenuBuilder` to create the menu options for the actions that we
    provide.'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`HasActions`函数返回`true`，则调用`IAssetTypeActions::GetActions(const TArray<UObject*>&
    InObjects, class FMenuBuilder& MenuBuilder)`。它调用`MenuBuilder`上的函数来为我们提供的操作创建菜单选项。
- en: '`IAssetTypeActions::GetName()` returns the name of this class.'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetName()`返回此类的名称。'
- en: '`IAssetTypeActions::GetSupportedClass()` returns an instance of `UClass` which
    our actions class supports.'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetSupportedClass()`返回我们的操作类支持的`UClass`的实例。'
- en: '`IAssetTypeActions::GetTypeColor()` returns the color associated with this
    class and actions.'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetTypeColor()`返回与此类和操作相关联的颜色。'
- en: '`IAssetTypeActions::GetCategories()` returns a category appropriate for the
    asset. This is used to change the category under which the actions show in the
    context menu.'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetCategories()`返回适用于资产的类别。这用于更改在上下文菜单中显示的操作所属的类别。'
- en: Our overridden implementation of `HasActions` simply returns `true` under all
    circumstances relying on filtering based on the results of `GetSupportedClass`.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写的`HasActions`的实现只是在所有情况下返回`true`，依赖于基于`GetSupportedClass`结果的过滤。
- en: Inside the implementation of `GetActions`, we can call some functions on the
    `MenuBuilder` object that we are given as a function parameter. The `MenuBuilder`
    is passed as a reference, so any changes that are made by our function will persist
    after it returns.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetActions`的实现中，我们可以在作为函数参数给出的`MenuBuilder`对象上调用一些函数。`MenuBuilder`是作为引用传递的，所以我们函数所做的任何更改在函数返回后仍然存在。
- en: '`AddMenuEntry` has a number of parameters. The first parameter is the name
    of the action itself. This is the name that will be visible within the context
    menu. The name is an `FText` so that it can be localized should you wish. For
    the sake of simplicity, we construct `FText` from a string literal and don''t
    concern ourselves with multiple language support.'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddMenuEntry`有一些参数。第一个参数是操作本身的名称。这个名称将在上下文菜单中可见。名称是一个`FText`，所以如果需要，它可以进行本地化。为了简单起见，我们从字符串字面量构造`FText`，不关心多语言支持。'
- en: The second parameter is also `FText`, which we construct by calling `FText::FromString`.
    This parameter is the text displayed on a tooltip if the user hovers over our
    command for more than a small amount of time.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数也是`FText`，我们通过调用`FText::FromString`来构造它。如果用户在我们的命令上悬停的时间超过一小段时间，此参数是显示在工具提示中的文本。
- en: The next parameter is `FSlateIcon` for the command, which is constructed from
    the `LevelEditor.ViewOptions` icon within the editor style set.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个参数是命令的`FSlateIcon`，它是从编辑器样式集中的`LevelEditor.ViewOptions`图标构造的。
- en: The last parameter to this function is an `FUIAction` instance. The `FUIAction`
    is a wrapper around a delegate binding, so we use `FExecuteAction::CreateRaw`
    to bind the command to the `MyCustomAsset_Clicked` function on this very instance
    of `FMyCustomAssetActions`.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的最后一个参数是一个`FUIAction`实例。`FUIAction`是一个委托绑定的包装器，所以我们使用`FExecuteAction::CreateRaw`将命令绑定到`FMyCustomAssetActions`的这个实例上的`MyCustomAsset_Clicked`函数。
- en: This means that when the menu entry is clicked, our `MyCustomAssetContext_Clicked`
    function will be run.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着当菜单项被点击时，我们的`MyCustomAssetContext_Clicked`函数将被执行。
- en: Our implementation of `GetName` returns the name of our Asset type. This string
    will be used on the thumbnail for our Asset if we don't set one ourselves, apart
    from being used in the title of the menu section that our custom Assets will be
    placed in.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`GetName`的实现返回我们资产类型的名称。如果我们没有自己设置缩略图，这个字符串将用于我们的资产的缩略图上，除了在我们的自定义资产所在的菜单部分的标题中使用。
- en: As you'd expect, the implementation of `GetSupportedClass` returns `UMyCustomAsset::StaticClass()`,
    as this is the Asset type we want our actions to operate on.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所期望的，`GetSupportedClass`的实现返回`UMyCustomAsset::StaticClass()`，因为这是我们希望我们的操作作用的资产类型。
- en: '`GetTypeColor()` returns the color that will be used for color coding in **Content
    Browser**—the color is used in the bar at the bottom of the asset thumbnail. I''ve
    used Emerald here, but any arbitrary color will work.'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetTypeColor()`返回在**内容浏览器**中用于颜色编码的颜色，该颜色用于资产缩略图底部的条中。我在这里使用了Emerald，但任何任意的颜色都可以工作。'
- en: The real workhorse of this recipe is the `MyCustomAssetContext_Clicked()` function.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个配方的真正工作马是`MyCustomAssetContext_Clicked()`函数。
- en: The first thing that this function does is create a new instance of `SWindow`.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的第一件事是创建一个新的`SWindow`实例。
- en: '`SWindow` is the Slate Window—a class from the Slate UI framework.'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SWindow`是Slate窗口，是Slate UI框架中的一个类。'
- en: Slate Widgets are created using the `SNew` function, which returns an instance
    of the widget requested.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Slate小部件使用`SNew`函数创建，该函数返回所请求的小部件的实例。
- en: Slate uses the `builder` design pattern, which means that all the functions
    that are **chained** after `SNew` returns a reference to the object that was being
    operated on.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Slate使用`builder`设计模式，这意味着在`SNew`返回正在操作的对象的引用之后，所有**链接**在其后的函数都返回对该对象的引用。
- en: In this function, we create our new `SWindow`, then set the window title, its
    client size or area, and whether it can be maximized or minimized.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们创建了我们的新`SWindow`，然后设置窗口标题、其客户区大小或区域以及是否可以最大化或最小化。
- en: With our new Window ready, we need to get a reference to the root window for
    the editor so we can add our window to the hierarchy and get it displayed.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好我们的新窗口后，我们需要获取对编辑器的根窗口的引用，以便将我们的窗口添加到层次结构中并显示出来。
- en: We do this using the `IMainFrameModule` class. It's a module, so we use the
    **Module Manager** to load it.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`IMainFrameModule`类来实现这一点。它是一个模块，所以我们使用**模块管理器**来加载它。
- en: '`LoadModuleChecked` will assert if we can''t load the module, so we don''t
    need to check it.'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法加载模块，`LoadModuleChecked`将断言，因此我们不需要检查它。
- en: If the module was loaded, we check that we have a valid parent window. If that
    window is valid, then we use `FSlateApplication::AddWindowAsNativeChild` to add
    our window as a child of the top-level parent window.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块已加载，我们检查是否有一个有效的父窗口。如果该窗口有效，则使用`FSlateApplication::AddWindowAsNativeChild`将我们的窗口作为顶级父窗口的子窗口添加。
- en: If we don't have a top-level parent, the function uses `AddWindow` to add the
    new window without parenting it to another window within the hierarchy.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有顶级父窗口，该函数将使用`AddWindow`将新窗口添加到层次结构中的另一个窗口而不将其作为其子窗口。
- en: So now we have a class which will display custom actions on our custom Asset
    type, but we need to actually tell the engine that it should ask our class to
    handle custom actions for the type. In order to do that, we need to register our
    class with the Asset Tools module.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个类，它将在我们的自定义Asset类型上显示自定义操作，但我们实际上需要告诉引擎它应该要求我们的类处理该类型的自定义操作。为了做到这一点，我们需要使用Asset
    Tools模块注册我们的类。
- en: The best way to do this is to register our class when our editor module is loaded,
    and unregister it when it is shut down.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好的方法是在加载编辑器模块时注册我们的类，并在关闭时取消注册。
- en: As a result, we place our code into the `StartupModule` and `ShutdownModule`
    functions.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将代码放入`StartupModule`和`ShutdownModule`函数中。
- en: Inside `StartupModule`, we load the Asset Tools module using **Module Manager**.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`中，我们使用**Module Manager**加载Asset Tools模块。
- en: With the module loaded, we create a new shared pointer that references an instance
    of our custom Asset actions class.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载模块后，我们创建一个新的共享指针，引用我们自定义的Asset actions类的实例。
- en: All we then need to do is call `AssetModule.RegisterAssetTypeActions,` and pass
    in an instance of our actions class.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要调用`AssetModule.RegisterAssetTypeActions`，并传入我们的actions类的实例。
- en: We then need to store a reference to that `Actions` instance so that we can
    unregister it later.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要存储对该`Actions`实例的引用，以便以后可以取消注册它。
- en: The sample code for this recipe uses an array of all the created asset actions
    in case we want to add custom actions for other classes as well.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此示例代码使用一个数组来存储所有创建的asset actions，以便我们还可以为其他类添加自定义操作。
- en: Within `ShutdownModule`, we again retrieve an instance of the Asset Tools module.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`中，我们再次获取Asset Tools模块的实例。
- en: Using a range-based for loop, we iterate over the array of `Actions` instances
    that we populated earlier, and call `UnregisterAssetTypeActions`, passing in our
    `Actions` class so it can be unregistered.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环，我们遍历之前填充的`Actions`实例数组，并调用`UnregisterAssetTypeActions`，传入我们的`Actions`类以进行取消注册。
- en: With our class registered, the editor has been instructed to ask our registered
    class if it can handle assets which are right-clicked on.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册了我们的类后，编辑器已被指示询问我们注册的类是否可以处理右键单击的资产。
- en: If the asset is of the Custom Asset class, then its `StaticClass` will match
    the one returned by `GetSupportedClass`. The editor will then call `GetActions`,
    and display the menu with the alterations made by our implementation of that function.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资产是Custom Asset类的实例，则其`StaticClass`将与`GetSupportedClass`返回的类匹配。然后编辑器将调用`GetActions`并显示由我们对该函数的实现所做的更改的菜单。
- en: When the `CustomAssetAction` button is clicked, our custom `MyCustomAssetContext_Clicked`
    function will be called via the delegate that we created.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击`CustomAssetAction`按钮时，我们通过创建的委托调用我们的自定义`MyCustomAssetContext_Clicked`函数。
- en: Creating new console commands
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的控制台命令
- en: During development, console commands can be very helpful by allowing a developer
    or tester to easily bypass content, or disable the mechanics not relevant to the
    current test being run. The most common way to implement this is via console commands,
    which can invoke functions during runtime. The console can be accessed using the
    tilde key (`~`) or the equivalent in the upper-left area of the alphanumeric zone
    of your keyboard.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，控制台命令可以非常有用，允许开发人员或测试人员轻松绕过内容或禁用与当前运行的测试不相关的机制。最常见的实现方式是通过控制台命令，在运行时调用函数。可以使用波浪线键（`~`）或键盘字母数字区域左上角的等效键来访问控制台。
- en: '![Creating new console commands](img/00201.jpeg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![创建新的控制台命令](img/00201.jpeg)'
- en: Getting ready
  id: totrans-637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already followed the *Creating a new editor module* recipe, do
    so, as this recipe will need a place to initialize and register the console command.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有按照*创建新的编辑器模块*的步骤进行操作，请按照该步骤进行操作，因为此步骤需要一个地方来初始化和注册控制台命令。
- en: How to do it...
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'Open your editor module''s header file, and add the following code:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器模块的头文件，并添加以下代码：
- en: '[PRE54]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following within the implementation of `StartupModule`:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`的实现中添加以下内容：
- en: '[PRE55]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside `ShutdownModule`, add this:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`中，添加以下内容：
- en: '[PRE56]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the following function in the editor module:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器模块中实现以下函数：
- en: '[PRE57]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Compile your code, and launch the editor.
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Play the level, then hit the tilde key to bring up the console.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡，然后按下波浪线键打开控制台。
- en: Type `DisplayTestCommandWindow,` and hit *Enter*.![How to do it...](img/00202.jpeg)
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`DisplayTestCommandWindow`，然后按下*Enter*键。![操作步骤如下...](img/00202.jpeg)
- en: You should see our tutorial window open up:![How to do it...](img/00203.jpeg)
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到我们的教程窗口打开：![操作步骤如下...](img/00203.jpeg)
- en: How it works...
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Console commands are usually provided by a module. The best way to get the module
    to create the command when it is loaded is to place the code in the `StartupModule`
    method.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台命令通常由一个模块提供。在加载模块时，让模块创建命令的最佳方法是将代码放在`StartupModule`方法中。
- en: '`IConsoleManager` is the module that contains the console functionality for
    the engine.'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IConsoleManager`是包含引擎控制台功能的模块。'
- en: As it is a sub-module of the core module, we don't need to add any additional
    information to the build scripts to link in additional modules.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是核心模块的子模块，我们不需要在构建脚本中添加任何额外的信息来链接其他模块。
- en: In order to call functions within the console manager, we need to get a reference
    to the current instance of `IConsoleManager` that is being used by the engine.
    To do so, we invoke the static `Get` function, which returns a reference to the
    module in a similar way to a singleton.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调用控制台管理器内的函数，我们需要获取对引擎正在使用的当前`IConsoleManager`实例的引用。为此，我们调用静态的`Get`函数，它返回一个对模块的引用，类似于单例模式。
- en: '`RegisterConsoleCommand` is the function that we can use to add a new console
    command, and make it available in the console:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegisterConsoleCommand`是我们可以用来添加新的控制台命令并在控制台中使其可用的函数：'
- en: '[PRE58]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The parameters for the function are the following:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的参数如下：
- en: '`Name`: The actual console command that will be typed by users. It should not
    include spaces.'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Name:` 用户将要键入的实际控制台命令。它不应包含空格。'
- en: '`Help:` The tooltip that appears when users are looking at the command in the
    console. If your console command takes arguments, this is a good place to display
    usage information to users.'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Help:` 当用户在控制台中查看命令时显示的工具提示。如果控制台命令带有参数，这是一个向用户显示用法信息的好地方。'
- en: '`Command:` This is the actual function delegate that will be executed when
    the user types the command.'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Command:` 这是当用户输入命令时将执行的实际函数委托。'
- en: '`Flags:` These flags control visibility of the command in a shipping build,
    and are also used for console variables. `ECVF_Default` specifies the default
    behavior wherein the command is visible, and has no restrictions on availability
    in a release build.'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Flags:` 这些标志控制命令在发布版本中的可见性，并且也用于控制台变量。`ECVF_Default`指定默认行为，其中命令可见，并且在发布版本中没有可用性限制。'
- en: To create an instance of the appropriate delegate, we use the `CreateRaw` static
    function on the `FConsoleCommand` delegate type. This lets us bind a raw C++ function
    to the delegate. The extra argument that is supplied after the function reference,
    the `FString` `"Test Command Window"`, is a compile-time defined parameter that
    is passed to the delegate so that the end user doesn't have to specify the window
    name.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建适当委托的实例，我们使用`FConsoleCommand`委托类型上的`CreateRaw`静态函数。这使我们可以将原始的C++函数绑定到委托上。在函数引用之后提供的额外参数`FString`
    `"Test Command Window"`是一个在编译时定义的参数，传递给委托，以便最终用户不必指定窗口名称。
- en: The second console command, `DisplayUserSpecifiedWindow`, is one that demonstrates
    the use of arguments with console commands.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个控制台命令`DisplayUserSpecifiedWindow`演示了使用控制台命令参数的用法。
- en: The primary difference with this console command, aside from the different name
    for users to invoke it, is the use of `FConsoleCommandWithArgsDelegate` and the
    `CreateLambda` function on it in particular.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此控制台命令的主要区别是，除了用户调用它的不同名称之外，还使用了`FConsoleCommandWithArgsDelegate`和其中的`CreateLambda`函数。
- en: This function allows us to bind an anonymous function to a delegate. It's particularly
    handy when you want to wrap or adapt a function so its signature matches that
    of a particular delegate.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数允许我们将一个匿名函数绑定到一个委托上。当你想要包装或适应一个函数，使其签名与特定委托的签名匹配时，它特别方便。
- en: In our particular use case, the type of `FConsoleCommandWithArgsDelegate` specifies
    that the function should take a `const TArray` of FStrings. Our `DisplayWindow`
    function takes a single `FString` to specify the window title, so we need to somehow
    concatenate all the arguments of the console command into a single `FString` to
    use as our window title.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们特定的用例中，`FConsoleCommandWithArgsDelegate`的类型指定函数应该接受一个`const TArray`的FStrings。我们的`DisplayWindow`函数接受一个单独的`FString`来指定窗口标题，所以我们需要以某种方式将控制台命令的所有参数连接成一个单独的`FString`来用作我们的窗口标题。
- en: The lambda function allows us to do that before passing the `FString` onto the
    actual `DisplayWindow` function.
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda函数允许我们在将`FString`传递给实际的`DisplayWindow`函数之前执行此操作。
- en: The first line of the function, `[&](const TArray<FString>& Args)`, specifies
    that this lambda or anonymous function wants to capture the context of the declaring
    function by reference by including the ampersand in the capture options `[&]`.
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的第一行`[&](const TArray<FString>& Args)`指定了这个lambda或匿名函数希望通过引用捕获声明函数的上下文，通过在捕获选项`[&]`中包含和号。
- en: The second part is the same as a normal function declaration specifying that
    our lambda takes in `const Tarray` containing FStrings as a parameter called `Args`.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二部分与普通函数声明相同，指定了我们的lambda以`const TArray`作为参数，其中包含名为`Args`的FStrings。
- en: Within the lambda body, we create a new `FString,` and concatenate the strings
    that make up our arguments together, adding a space between them to separate them
    so that we don't get a title without spaces.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在lambda主体中，我们创建了一个新的`FString`，并将组成我们参数的字符串连接在一起，它们之间添加一个空格来分隔它们，以便我们不会得到没有空格的标题。
- en: It uses a range-based `for` loop for brevity to loop over them all and perform
    the concatenation.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简洁起见，它使用了基于范围的`for`循环来遍历它们并执行连接操作。
- en: Once they're all concatenated, we use the `this` pointer (captured by the `&`
    operator mentioned earlier) to invoke `DisplayWindow` with our new title.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它们都被连接起来，我们使用之前提到的`&`运算符捕获的`this`指针来调用`DisplayWindow`并传入我们的新标题。
- en: In order for our module to remove the console command when it is unloaded, we
    need to maintain a reference to the console command object.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在模块卸载时删除控制台命令，我们需要保持对控制台命令对象的引用。
- en: To achieve this, we create a member variable in the module of type `IConsoleCommand*`,
    called `DisplayTestCommand`. When we execute the `RegisterConsoleCommand` function,
    it returns a pointer to the console command object that we can use as a handle
    later.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们在模块中创建了一个名为`DisplayTestCommand`的类型为`IConsoleCommand*`的成员变量。当我们执行`RegisterConsoleCommand`函数时，它返回一个指向控制台命令对象的指针，我们可以稍后用作句柄。
- en: This allows us to enable or disable console commands at runtime based on gameplay
    or other factors.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够根据游戏玩法或其他因素在运行时启用或禁用控制台命令。
- en: Within `ShutdownModule`, we check to see if `DisplayTestCommand` refers to a
    valid console command object. If it does, we get a reference to the `IConsoleManager`
    object, and call `UnregisterConsoleCommand` passing in the pointer that we stored
    earlier in our call to `RegisterConsoleCommand`.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`中，我们检查`DisplayTestCommand`是否引用有效的控制台命令对象。如果是，我们获取对`IConsoleManager`对象的引用，并调用`UnregisterConsoleCommand`，传入我们在调用`RegisterConsoleCommand`时存储的指针。
- en: The call to `UnregisterConsoleCommand` deletes the `IConsoleCommand` instance
    via the passed-in pointer, so we don't need to `deallocate` the memory ourselves,
    just reset `DisplayTestCommand` to `nullptr` so we can be sure the old pointer
    doesn't dangle.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`UnregisterConsoleCommand`通过传入的指针删除`IConsoleCommand`实例，因此我们不需要自己`deallocate`内存，只需将`DisplayTestCommand`重置为`nullptr`，以确保旧指针不会悬空。
- en: The `DisplayWindow` function takes in the window title as an `FString` parameter.
    This allows us to either use a console command that takes arguments to specify
    the title, or a console command that uses payload parameters to hard-code the
    title for other commands.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DisplayWindow`函数以`FString`参数形式接受窗口标题。这使我们可以使用带有参数的控制台命令来指定标题，或者使用有效负载参数来为其他命令硬编码标题。'
- en: The function itself uses a function called `SNew()` to allocate and create an
    `SWindow` object.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数本身使用一个名为`SNew()`的函数来分配和创建一个`SWindow`对象。
- en: '`SWindow` is a Slate Window, a top-level window using the Slate UI framework.'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SWindow`是一个Slate窗口，它是使用Slate UI框架的顶级窗口。'
- en: Slate uses the `Builder` design pattern to allow for easy configuration of the
    new window.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Slate使用`Builder`设计模式来方便配置新窗口。
- en: The `Title`, `ClientSize`, `SupportsMaximize`, and `SupportsMinimize` functions
    used here, are all member functions of `SWindow`, and they return a reference
    to an `SWindow` (usually, the same object that the method was invoked on, but
    sometimes, a new object constructed with the new configuration).
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里使用的`Title`、`ClientSize`、`SupportsMaximize`和`SupportsMinimize`函数都是`SWindow`的成员函数，并且它们返回一个`SWindow`的引用（通常是调用该方法的对象，但有时是使用新配置构造的新对象）。
- en: The fact that all these member methods return a reference to the configured
    object allows us to chain these method invocations together to create the desired
    object in the right configuration.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些成员方法返回配置对象的引用，使我们能够将这些方法调用链接在一起，以创建所需的配置对象。
- en: The functions used in `DisplayWindow` create a new top-level Window that has
    a title based on the function parameter. It is 800x400 pixels wide, and cannot
    be maximized or minimized.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DisplayWindow`中使用的函数创建了一个基于函数参数的新顶级窗口。它的宽度为800x400像素，不能最大化或最小化。'
- en: With our new Window created, we retrieve a reference to the main application
    frame module. If the top-level window for the editor exists and is valid, we add
    our new window instance as a child of that top-level window.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了我们的新窗口后，我们获取对主应用程序框架模块的引用。如果编辑器的顶级窗口存在且有效，我们将我们的新窗口实例作为该顶级窗口的子窗口添加。
- en: To do this, we retrieve a reference to the Slate interface, and call `AddWindowAsNativeChild`
    to insert our window in the hierarchy.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们获取对Slate接口的引用，并调用`AddWindowAsNativeChild`将我们的窗口插入层次结构中。
- en: If there isn't a valid top-level window, we don't need to add our new window
    as a child of anything, so we can simply call `AddWindow,` and pass in our new
    window instance.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有有效的顶级窗口，我们不需要将我们的新窗口添加为任何窗口的子窗口，所以我们可以简单地调用`AddWindow`并传入我们的新窗口实例。
- en: See also
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    to learn more about delegates. It explains payload variables in greater detail.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关委托的更多信息，请参阅[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "第5章. 处理事件和委托")，*处理事件和委托*。它更详细地解释了有效负载变量。
- en: For more information on Slate, refer to [Chapter 9](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121
    "Chapter 9. User Interfaces – UI and UMG"), *User Interface*.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Slate的更多信息，请参阅[第9章](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121
    "第9章. 用户界面 - UI和UMG")，*用户界面*。
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为蓝图创建新的图形引脚可视化器
- en: Within the Blueprint system, we can use instances of our `MyCustomAsset` class
    as variables, provided we mark that class as a `BlueprintType` in its `UCLASS`
    macro.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图系统中，我们可以使用我们的`MyCustomAsset`类的实例作为变量，只要我们在其`UCLASS`宏中将该类标记为`BlueprintType`。
- en: 'However, by default, our new asset is simply treated as `UObject`, and we can''t
    access any of its members:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认情况下，我们的新资产只是被视为`UObject`，我们无法访问其任何成员：
- en: '![Creating a new graph pin visualizer for Blueprint](img/00204.jpeg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![为蓝图创建新的图形引脚可视化器](img/00204.jpeg)'
- en: 'For some types of assets, we might wish to enable in-line editing of literal
    values in the same way that classes such as `FVector` support the following:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的资产，我们可能希望以与`FVector`等类似的方式启用对字面值的内联编辑：
- en: '![Creating a new graph pin visualizer for Blueprint](img/00205.jpeg)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![为蓝图创建新的图形引脚可视化器](img/00205.jpeg)'
- en: In order to enable this, we need to use a **Graph Pin** visualizer. This recipe
    will show you how to enable in-line editing of an arbitrary type using a custom
    widget defined by you.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要使用一个**Graph Pin**可视化器。本教程将向您展示如何使用您定义的自定义小部件来启用任意类型的内联编辑。
- en: How to do it...
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new header file called `MyCustomAssetPinFactory.h`.
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyCustomAssetPinFactory.h`的新头文件。
- en: 'Inside the header, add the following code:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中，添加以下代码：
- en: '[PRE59]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create another header file called `SGraphPinCustomAsset`:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`SGraphPinCustomAsset`的头文件：
- en: '[PRE60]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implement `SGraphPinCustomAsset` in the `.cpp` file:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现`SGraphPinCustomAsset`：
- en: '[PRE61]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Add `#include "Chapter8/MyCustomAssetDetailsCustomization.h"` to the `UE4Cookbook`
    editor module implementation file.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`#include "Chapter8/MyCustomAssetDetailsCustomization.h"`添加到`UE4Cookbook`编辑器模块实现文件中。
- en: 'Add the following member to the editor module class:'
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员添加到编辑器模块类中：
- en: '[PRE62]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following to `StartupModule()`:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`StartupModule()`中：
- en: '[PRE63]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Also add the following code to `ShutdownModule()`:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将以下代码添加到`ShutdownModule()`中：
- en: '[PRE64]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Compile your code, and launch the editor.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。
- en: Create a new **Function** inside the Level Blueprint by clicking on the plus
    symbol beside **Functions** within the **My Blueprint** panel:![How to do it...](img/00206.jpeg)
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**我的蓝图**面板中的**函数**旁边的加号符号上点击，创建一个新的**函数**：![操作步骤...](img/00206.jpeg)
- en: Add an input parameter.![How to do it...](img/00207.jpeg)
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个输入参数。![操作步骤...](img/00207.jpeg)
- en: Set its type to `MyCustomAsset` (**Reference**):![How to do it...](img/00208.jpeg)
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类型设置为`MyCustomAsset`（**引用**）：![操作步骤...](img/00208.jpeg)
- en: In the Level Blueprint's Event graph, place an instance of your new function,
    and verify that the input pin now has a custom visualizer in the form of a color
    picker:![How to do it...](img/00209.jpeg)
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡蓝图的事件图中，放置一个新函数的实例，并验证输入引脚现在具有自定义的可视化器，形式为颜色选择器：![操作步骤...](img/00209.jpeg)
- en: How it works...
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: Customizing how objects appear as literal values on Blueprint pins is done using
    the `FGraphPanelPinFactory` class.
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FGraphPanelPinFactory`类来自定义蓝图引脚上对象的外观。
- en: 'This class defines a single virtual function:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类定义了一个虚拟函数：
- en: '[PRE65]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The function of `CreatePin`, as the name implies, is to create a new visual
    representation of the graph pin.
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreatePin`函数的作用是创建图针的新的可视化表示。'
- en: It receives a `UEdGraphPin` instance. `UEdGraphPin` contains information about
    the object that the pin represents so that our factory class can make an informed
    decision regarding which visual representation we should be displaying.
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收一个`UEdGraphPin`实例。`UEdGraphPin`包含有关图针所代表的对象的信息，以便我们的工厂类可以根据这些信息做出有根据的决策，确定应该显示哪种可视化表示。
- en: Within our implementation of the function, we check that the pin's type is our
    custom class.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的实现中，我们检查引脚的类型是否是我们自定义的类。
- en: We do this by looking at the `PinSubCategoryObject` property, which contains
    a `UClass`, and comparing it to the `UClass` associated with our custom asset
    class.
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过查看`PinSubCategoryObject`属性来实现这一点，该属性包含一个`UClass`，并将其与我们自定义资产类关联的`UClass`进行比较。
- en: If the pin's type meets our conditions, we return a new shared pointer to a
    Slate Widget, which is the visual representation of our object.
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果引脚的类型符合我们的条件，我们将返回一个指向Slate小部件的新共享指针，这是我们对象的可视化表示。
- en: If the pin is of the wrong type, we return a null pointer to indicate a failed
    state.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果引脚的类型错误，我们返回一个空指针来表示失败状态。
- en: The next class, `SGraphPinCustomAsset`, is the Slate Widget class, which is
    a visual representation of our object as a literal.
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的类`SGraphPinCustomAsset`是Slate小部件类，它是我们对象的一个字面上的可视化表示。
- en: It inherits from `SGraphPin`, the base class for all graph pins.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它继承自`SGraphPin`，是所有图针的基类。
- en: The `SGraphPinCustomAsset` class has a `Construct` function, which is called
    when the widget is created.
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SGraphPinCustomAsset`类有一个`Construct`函数，在创建小部件时调用。'
- en: 'It also implements some functions from the parent class: `GetPinColor()` and
    `GetDefaultValueWidget()`.'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还实现了父类的一些函数：`GetPinColor()`和`GetDefaultValueWidget()`。
- en: The last function defined is `ColorPicked`, a handler for when a user selects
    a color in our custom pin.
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后定义的函数是`ColorPicked`，用于处理用户在自定义引脚中选择颜色的情况。
- en: In the implementation of our custom class, we initialize our custom pin by calling
    the default implementation of `Construct`.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们自定义类的实现中，我们通过调用`Construct`的默认实现来初始化我们的自定义引脚。
- en: The role of `GetDefaultValueWidget` is to actually create the widget that is
    the custom representation of our class, and return it to the engine code.
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetDefaultValueWidget`的作用是实际上创建我们类的自定义表示的小部件，并将其返回给引擎代码。'
- en: In our implementation, it creates a new `SColorPicker` instance—we want the
    user to be able to select a color, and store the hex-based representation of that
    color inside the `FString` property in our custom class.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的实现中，它创建了一个新的`SColorPicker`实例，我们希望用户能够选择一种颜色，并将该颜色的十六进制表示存储在我们自定义类的`FString`属性中。
- en: This `SColorPicker` instance has a property called `OnColorCommitted`— this
    is a slate event that can be assigned to a function on an object instance.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`SColorPicker`实例有一个名为`OnColorCommitted`的属性，这是一个可以分配给对象实例上的函数的slate事件。
- en: Before returning our new `SColorPicker`, we link `OnColorCommitted` to the `ColorPicked`
    function on this current object, so it will be called if the user selects a new
    color.
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回我们的新`SColorPicker`之前，我们将`OnColorCommitted`链接到当前对象上的`ColorPicked`函数，以便在用户选择新颜色时调用它。
- en: The `ColorPicked` function receives the selected color as an input parameter.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColorPicked`函数接收所选颜色作为输入参数。'
- en: Because this widget is used when there's no object connected to the pin we are
    associated with, we can't simply set the property on the associated object to
    the desired color string.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为当我们关联的引脚没有连接到对象时，该小部件将被使用，所以我们不能简单地将属性设置为所需的颜色字符串。
- en: We need to create a new instance of our custom asset class, and we do that by
    using the `NewObject` template function.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建我们自定义资产类的一个新实例，我们使用`NewObject`模板函数来实现这一点。
- en: This function behaves similarly to the `SpawnActor` function discussed in other
    chapters, and initializes a new instance of the specified class before returning
    a pointer to it.
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的行为类似于其他章节中讨论的`SpawnActor`函数，并在返回指针之前初始化指定类的新实例。
- en: With a new instance in hand, we can set its `ColorName` property. `FLinearColors`
    can be converted to `FColor` objects, which define a `ToHex()` function that returns
    an `FString` with the hexadecimal representation of the color that was selected
    on the new widget.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了一个新的实例，我们可以设置它的`ColorName`属性。`FLinearColors`可以转换为`FColor`对象，它定义了一个`ToHex()`函数，返回一个十六进制表示所选颜色的`FString`。
- en: Finally, we need to actually place our new object instance into the graph so
    that it will be referenced when the graph is executed.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的新对象实例放置到图中，以便在执行图时引用它。
- en: To do this, we need to access the graph pin object that we represent, and use
    the `GetSchema` function. This function returns the Schema for the graph that
    owns the node that contains our pin.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要访问表示我们的图针对象，并使用`GetSchema`函数。该函数返回包含我们的针的节点所拥有的图的模式。
- en: The Schema contains the actual values that correspond to graph pins, and is
    a key element during graph evaluation.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式包含与图针对应的实际值，并且在图评估过程中是一个关键元素。
- en: Now that we have access to the Schema, we can set the default value for the
    pin that our widget represents. This value will be used during graph evaluation
    if the pin isn't connected to another pin, and acts like a default value provided
    during a function definition in C++.
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以访问模式，我们可以为我们的小部件表示的针设置默认值。如果该针未连接到另一个针，该值将在图评估过程中使用，并且类似于C++中函数定义期间提供的默认值。
- en: As with all the extensions we've made in this chapter, there has to be some
    sort of initialization or registration to tell the engine to defer to our custom
    implementation before using its default inbuilt representation.
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章中我们所做的所有扩展一样，必须进行某种初始化或注册，以告诉引擎在使用其默认内置表示之前，将其委托给我们的自定义实现。
- en: In order to do this, we need to add a new member to our editor module to store
    our `PinFactory` class instance.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在编辑器模块中添加一个新的成员来存储我们的`PinFactory`类实例。
- en: During `StartupModule`, we create a new shared pointer that references an instance
    of our `PinFactory` class.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`期间，我们创建一个引用我们的`PinFactory`类实例的新共享指针。
- en: We store it inside the editor module's member so it can be unregistered later.
    Then we call `FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)` to tell
    the engine to use our `PinFactory` to create the visual representation.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其存储在编辑器模块的成员中，以便以后可以取消注册。然后我们调用`FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)`来告诉引擎使用我们的`PinFactory`来创建可视化表示。
- en: During `ShutdownModule`, we unregister the pin factory using `UnregisterVisualPinFactory`.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`期间，我们使用`UnregisterVisualPinFactory`取消注册针工厂。
- en: Finally, we delete our old `PinFactory` instance by calling `Reset()` on the
    shared pointer that contains it.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在包含它的共享指针上调用`Reset()`来删除我们的旧`PinFactory`实例。
- en: Inspecting types with custom Details panels
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义详细面板检查类型
- en: 'By default, `UObject-`derived UAssets open in the generic property editor.
    It looks like the following screenshot:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，派生自`UObject`的UAssets在通用属性编辑器中打开。它的外观如下截图所示：
- en: '![Inspecting types with custom Details panels](img/00210.jpeg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义详细面板检查类型](img/00210.jpeg)'
- en: However, at times you may wish for custom widgets to allow editing of properties
    on your class. To facilitate this, Unreal supports **Details Customization**,
    which is the focus of this recipe.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能希望自定义小部件允许编辑类上的属性。为了方便这一点，虚幻支持**详细自定义**，这是本教程的重点。
- en: How to do it...
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new header file called `MyCustomAssetDetailsCustomization.h`.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyCustomAssetDetailsCustomization.h`的新头文件。
- en: 'Add the following includes to the header:'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加以下内容：
- en: '[PRE66]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define our customization class as follows:'
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的自定义类定义如下：
- en: '[PRE67]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the implementation file, create an implementation for `CustomizeDetails`:'
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中，为`CustomizeDetails`创建一个实现：
- en: '[PRE68]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Also create a definition for `ColorPicked`:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建`ColorPicked`的定义：
- en: '[PRE69]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Lastly, add the following includes in the `.cpp` file:'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`.cpp`文件中添加以下内容：
- en: '[PRE70]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In our editor module header, add the following to the implementation of `StartupModule`:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的编辑器模块头文件中，在`StartupModule`的实现中添加以下内容：
- en: '[PRE71]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add the following to `ShutdownModule`:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`ShutdownModule`中：
- en: '[PRE72]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Compile your code, and launch the editor. Create a new copy of `MyCustomAsset`
    via the content browser.
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并启动编辑器。通过内容浏览器创建`MyCustomAsset`的新副本。
- en: Double-click on it to verify that the default editor now shows your custom layout:![How
    to do it...](img/00211.jpeg)
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击它以验证默认编辑器现在显示您的自定义布局：![如何操作...](img/00211.jpeg)
- en: How it works...
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Details Customization is performed through the `IDetailCustomization` interface,
    which developers can inherit from when defining a class which customizes the way
    assets of a certain class are displayed.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`IDetailCustomization`接口执行详细自定义，开发人员可以从中继承，定义一个自定义显示某个类的资产的方式的类。
- en: 'The main function that `IDetailCustomization` uses to allow for this process
    to occur is the following:'
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IDetailCustomization`用于允许此过程发生的主要函数是以下函数：'
- en: '[PRE73]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Within our implementation of this function, we use methods on `DetailBuilder`
    passed in as a parameter to get an array of all selected objects. The loop then
    scans those to ensure that at least one selected object is of the correct type.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数的实现中，我们使用作为参数传递的`DetailBuilder`上的方法来获取所有选定对象的数组。然后循环扫描这些对象，以确保至少有一个选定对象是正确类型的。
- en: Customizing the representation of a class is done by calling methods on the
    `DetailBuilder` object. We create a new category for our details view by using
    the `EditCategory` function.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`DetailBuilder`对象上调用方法来自定义类的表示。我们使用`EditCategory`函数为我们的详细视图创建一个新的类别。
- en: The first parameter of the `EditCategory` function is the name of the category
    we are going to manipulate.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EditCategory`函数的第一个参数是我们要操作的类别的名称。'
- en: The second parameter is optional, and contains a potentially localized display
    name for the category.
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，并包含类别的可能本地化的显示名称。
- en: The third parameter is the priority of the category. Higher priority means it
    is displayed further up the list.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个参数是类别的优先级。优先级越高，它在列表中显示得越靠前。
- en: '`EditCategory` returns a reference to the category itself as `CategoryBuilder`,
    allowing us to chain additional method calls onto an invocation of `EditCategory`.'
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EditCategory`作为`CategoryBuilder`返回对类别本身的引用，允许我们在调用`EditCategory`时链接其他方法调用。'
- en: As a result, we call `AddCustomRow()` on `CategoryBuilder`, which adds a new
    key-value pair to be displayed in the category.
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在`CategoryBuilder`上调用`AddCustomRow()`，它会添加一个新的键值对以在类别中显示。
- en: Using the Slate syntax, we then specify that the row will contain a Vertical
    Box with a single center-aligned slot.
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Slate语法，我们指定该行将包含一个垂直盒子，其中有一个居中对齐的插槽。
- en: Inside the slot, we create a color picker control, and bind its `OnColorCommitted`
    delegate to our local `ColorPicked` event handler.
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插槽内，我们创建一个颜色选择器控件，并将其`OnColorCommitted`委托绑定到我们的本地`ColorPicked`事件处理程序上。
- en: 'Of course, this requires us to define and implement `ColourPicked`. It has
    the following signature:'
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，这要求我们定义和实现`ColourPicked`。它具有以下签名：
- en: '[PRE74]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Inside the implementation of `ColorPicked`, we check to see if one of our selected
    assets was of the correct type, because if at least one selected asset was correct,
    then `MyAsset` will be populated with a valid value.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ColorPicked`的实现中，我们检查是否有一个选定的资源是正确的类型，因为如果至少有一个选定的资源是正确的，那么`MyAsset`将被填充为有效值。
- en: Assuming we have a valid asset, we set the `ColorName` property to the hex string
    value corresponding to the color selected by the user.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个有效的资源，我们将`ColorName`属性设置为用户选择的颜色对应的十六进制字符串值。
