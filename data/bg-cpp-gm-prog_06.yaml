- en: Chapter 6.  Object-Oriented Programming, Classes, and SFML Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。面向对象编程，类和SFML视图
- en: This is the longest chapter of the book. There is a fair amount of theory, but
    the theory will give us the knowledge to start using **Object-Oriented Programming**
    (**OOP**) to powerful effect. Furthermore, we will not waste any time in putting
    that theory to good use. Before we explore C++ OOP, we will find out about and
    plan our next game project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书最长的章节。有相当多的理论，但这些理论将使我们有能力开始有效地使用面向对象编程（OOP）。此外，我们不会浪费时间来将理论付诸实践。在探索C++
    OOP之前，我们将了解并计划我们的下一个游戏项目。
- en: 'This is what we will do in the following chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在接下来的章节中要做的事情：
- en: Plan the **Zombie Arena** game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划“僵尸竞技场”游戏
- en: Learn about OOP and classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习面向对象编程和类
- en: Code the `Player` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写“Player”类
- en: Learn about the SFML `View` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解SFML的“View”类
- en: Build the Zombie Arena game engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建僵尸竞技场游戏引擎
- en: Put the `Player` class to work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让“Player”类开始工作
- en: Planning and starting the Zombie Arena game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划和开始僵尸竞技场游戏
- en: At this point, if you haven't already, I suggest you go and watch a video of
    Over 9,000 Zombies ([http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/))
    and Crimson Land ([http://store.steampowered.com/app/262830/](http://store.steampowered.com/app/262830/)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果你还没有的话，我建议你去观看《超过9000只僵尸》（[http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/)）和《血色之地》（[http://store.steampowered.com/app/262830/](http://store.steampowered.com/app/262830/)）的视频。
- en: 'Our game will obviously not be as in-depth or advanced as either of the examples
    but we will have the same basic set of features and game mechanics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏显然不会像这两个示例那样深入或先进，但我们将拥有相同的基本功能和游戏机制：
- en: A **Heads-up Display** (**HUD**) that shows details such as score, high score,
    bullets in clip,total bullets left, player health, and zombies left to kill
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一些细节的“HUD”，比如得分、最高分、弹夹中的子弹、剩余子弹、玩家生命和剩余待杀僵尸数
- en: The player will shoot zombies while frantically running away from them
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将在疯狂逃离僵尸的同时射击它们
- en: Move around a scrolling world using the  ***W*, *A*, *S*, and *D*** keys while
    aiming the gun using the mouse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用鼠标瞄准枪支的同时，使用W、A、S和D键在滚动世界中移动
- en: In between each level, choose a **level up** that will affect the way the game
    needs to be played to succeed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个级别之间，选择一个会影响游戏成功方式的“升级”。
- en: Collect **pick-ups** to restore health and ammunition
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集“拾取物”以恢复生命和弹药
- en: Each wave brings more zombies and a bigger arena
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一波都会带来更多的僵尸和更大的竞技场
- en: 'There will be three types of zombie to splatter. They will have different attributes
    such as appearance, health, and speed. We will call them chasers, bloaters, and
    crawlers. Take a look at this annotated screenshot of the game to see some of
    the features in action and the components and assets that make up the game:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将有三种类型的僵尸需要消灭。它们将具有不同的属性，如外观、生命和速度。我们将称它们为追逐者、膨胀者和爬行者。看一下游戏的注释截图，看看一些功能的运作以及组成游戏的组件和资源：
- en: '![Planning and starting the Zombie Arena game](img/image_06_001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![规划和开始僵尸竞技场游戏](img/image_06_001.jpg)'
- en: 'Here is a little bit more information about each of the numbered points:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于每个编号点的更多信息：
- en: The **SCORE** and **HI SCORE**. These, along with the other parts of the HUD,
    will be drawn in a separate layer, known as a **View**. The hi-score will be saved
    and loaded to a file.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 得分和最高分。这些与HUD的其他部分一起将在一个称为“视图”的单独图层中绘制。最高分将被保存并加载到文件中。
- en: This is a texture that will build a wall around the arena. This texture is contained
    in a single graphic called a **sprite-sheet**, along with the other background
    textures (3, 5, and 6).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个将在竞技场周围建造墙壁的纹理。这个纹理包含在一个称为“精灵表”的单个图形中，还有其他背景纹理（3、5和6）。
- en: The first of two mud textures from the sprite-sheet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵表中的两个泥浆纹理之一。
- en: This is an **ammo pick-up**. When the player gets this they will be given more
    ammunition. There is a **health pick-up** as well. The players can choose to upgrade these
    pick-ups in between waves of zombies.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个“弹药拾取物”。玩家获得这个拾取物后将获得更多弹药。还有一个“生命拾取物”。玩家可以选择在僵尸波之间升级这些拾取物。
- en: A grass texture, also from the sprite-sheet.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵表中的草纹理。
- en: The second mud texture from the sprite-sheet.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵表中的第二个泥浆纹理。
- en: A blood splat where there used to be a zombie.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 曾经有僵尸的地方现在是一滩血迹。
- en: The bottom part of the HUD. From left to right there is an icon to represent
    ammo, the number of bullets in the clip, the number of spare bullets, a health
    bar, the current wave of zombies, and the number of zombies remaining in this
    wave.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HUD的底部部分。从左到右依次是代表弹药的图标、弹夹中的子弹数量、备用子弹数量、生命条、当前僵尸波数以及本波剩余僵尸数量。
- en: The player character.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家角色。
- en: A crosshair which the player aims with the mouse.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家用鼠标瞄准的准星。
- en: A slow-moving but strong bloater zombie
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个移动缓慢但力量强大的膨胀僵尸
- en: A slightly faster-moving but weaker crawler zombie. There is also a chaser zombie
    who is very fast and weak. Unfortunately, I couldn't manage to get one in the
    screenshot before they were all killed.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个移动速度稍快但较弱的爬行僵尸。还有一个追逐者僵尸，速度非常快但很弱。不幸的是，在它们被全部杀死之前，我没能在截图中找到一个。
- en: We have a lot to do and new C++ skills to learn. Let's start by creating a new
    project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多事情要做，还有新的C++技能要学习。让我们从创建一个新项目开始。
- en: Creating a project from the template
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板创建项目
- en: 'Creating a new project is now extremely easy. Just follow these straightforward
    steps in Visual Studio:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新项目非常容易。只需在Visual Studio中按照这些简单的步骤进行：
- en: Select **File** | **New Project** from the main menu.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择“文件”|“新建项目”。
- en: Make sure that **Visual C++** is selected in the left-hand menu and then select
    **HelloSFML** from the list of presented options. This next image should make
    this clear:![Creating a project from the template](img/image_06_002.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在左侧菜单中选择了“Visual C++”，然后从所呈现的选项列表中选择“HelloSFML”。下一张图片应该能清楚地说明这一点：![从模板创建项目](img/image_06_002.jpg)
- en: In the **Name:** field, type `ZombieArena` and also make sure that the **Create
    directory for solution** option is checked. Now click **OK**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称：**字段中，键入`ZombieArena`，并确保**为解决方案创建目录**选项已被选中。现在点击**确定**。
- en: Now we need to copy the SFML `.dll` files into the main project directory. My
    main project directory is `D:\Visual Studio Stuff\Projects\ ZombieArena\ZombieArena`.
    This folder was created by Visual Studio in the previous step. If you put your
    `Projects` folder somewhere else then perform this step there instead. The files
    we need to copy in to the `Projects` folder are located in your `SFML\bin` folder.
    Open a window for each of the two locations and highlight the required `.dll`
    files.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将SFML的`.dll`文件复制到主项目目录中。我的主项目目录是`D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena`。这个文件夹是由Visual
    Studio在上一步中创建的。如果您将`Projects`文件夹放在其他地方，请在那里执行此步骤。我们需要复制到`Projects`文件夹中的文件位于您的`SFML\bin`文件夹中。为每个位置打开一个窗口，并突出显示所需的`.dll`文件。
- en: Now copy and paste the highlighted files into the project. The project is now
    set up and ready to go.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将突出显示的文件复制并粘贴到项目中。项目现在已经设置好，准备好了。
- en: The project assets
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目资产
- en: 'The assets in this project are more numerous and diverse than the previous
    game. The assets include:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目中的资产比以前的游戏更多样化和丰富。资产包括：
- en: A font for the writing on the screen
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上的字体
- en: Sound effects for different actions such as shooting, reloading, or getting
    hit by a zombie
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同动作的音效，如射击、装弹或被僵尸击中。
- en: All the graphics for the character, zombies, background, and sound required
    for the game are included in the download bundle. They can be found in the `Chapter
    6/graphics`, and `Chapter 6/sound` folders, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的角色、僵尸、背景和声音的所有图形都包含在下载包中。它们分别可以在`第6章/图形`和`第6章/声音`文件夹中找到。
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding the license. This will not cause a problem
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的字体尚未提供。这是因为我想避免任何关于许可证的可能歧义。不过这不会造成问题，因为我将向您展示确切的位置和方式来选择和下载字体。
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create and acquire them for yourself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我将提供资产本身或获取它们的信息，但您可能希望自己创建和获取它们。
- en: Exploring the assets
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索资产
- en: 'The graphical assets make up the parts of the scene that is our Zombie Arena
    game. Take a look at the graphical assets and it should be clear where in our
    game they will be used:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资产构成了我们的僵尸竞技场游戏场景的一部分。看一下图形资产，应该清楚我们的游戏中它们将被用在哪里：
- en: '![Exploring the assets](img/image_06_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![探索资产](img/image_06_003.jpg)'
- en: What might be less obvious, however, is the `background_sheet.png` which contains
    four different images. This is the sprite-sheet I mentioned previously, and we
    will see how we can use one to save memory and increase the speed of our game
    in [Chapter 7](ch07.html "Chapter 7. C++ References, Sprite Sheets, and Vertex
    Arrays"), *C++ References, Sprite Sheets, and Vertex Arrays*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能不太明显的是`background_sheet.png`，其中包含四个不同的图像。这是我之前提到的精灵表，我们将看到如何使用它来节省内存并提高游戏速度，详见[第7章](ch07.html
    "第7章。C++参考、精灵表和顶点数组")，*C++参考、精灵表和顶点数组*。
- en: 'The sound files are all `.wav` format. These are files which contain the sound
    effects that we will play at certain events throughout the game. They are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 声音文件都是`.wav`格式。这些文件包含了我们在游戏中的某些事件中播放的音效。它们是：
- en: '`hit.wav`: A sound that plays when a zombie comes into contact with the player'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hit.wav`：僵尸与玩家接触时播放的声音'
- en: '`pickup.wav`: A sound that plays when the player touches (collects) a health
    boost (pick-up)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pickup.wav`：玩家触摸（收集）健康提升（拾取）时播放的声音'
- en: '`powerup.wav`: A sound  that plays when the player chooses an attribute to
    increase (power-up) in between each wave of zombies'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powerup.wav`：玩家在每波僵尸之间选择增加属性（power-up）时播放的声音'
- en: '`reload.wav`: A satisfying click to let the player know they have loaded a
    fresh clip of ammunition'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload.wav`：令玩家知道他们已装入新弹药的满意点击声'
- en: '`reload_failed.wav`: A less satisfying sound that indicates failure to load
    new bullets'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload_failed.wav`：指示未能装入新子弹的不太令人满意的声音'
- en: '`shoot.wav`: A shooting sound'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shoot.wav`：射击声音'
- en: '`splat.wav`: A sound like a zombie being hit by a bullet'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splat.wav`：像僵尸被子弹击中的声音'
- en: Adding the assets to the project
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资产添加到项目中
- en: 'Once you have decided which assets you will use, it is time to add them to
    the project. These next instructions will assume you are using all the assets
    supplied in the book''s download bundle. Where you are using your own, simply
    replace the appropriate sound or graphic file with your own, using exactly the
    same file name that is used in this book:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定使用哪些资产，就该是将它们添加到项目中的时候了。下面的说明将假定您正在使用本书下载包中提供的所有资产。如果您使用自己的资产，只需用您自己的适当的声音或图形文件替换本书中使用的完全相同的文件名即可：
- en: Browse to `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena`。
- en: Create three new folders within this folder and name them `graphics`, `sound`,
    and `fonts`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建三个新文件夹，分别命名为`图形`、`声音`和`字体`。
- en: From the download bundle, copy the entire contents of `Chapter 6/graphics` into
    the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\graphics` folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第6章/图形`文件夹的全部内容复制到`D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\图形`文件夹中。
- en: From the download bundle, copy the entire contents of `Chapter 6/sound` into
    the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\sound` folder.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第6章/声音`文件夹的全部内容复制到`D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\声音`文件夹中。
- en: Now visit [http://www.1001freefonts.com/zombie_control.font](http://www.1001freefonts.com/zombie_control.font)
    in your web browser and download the **Zombie Control** font.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在您的网络浏览器中访问[http://www.1001freefonts.com/zombie_control.font](http://www.1001freefonts.com/zombie_control.font)，并下载**Zombie
    Control**字体。
- en: Extract the contents of the zipped download and add the `zombiecontrol.ttf`
    file to the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\fonts` folder.
    Now it's time to learn some more C++, so we can start writing the code for Zombie
    Arena.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提取压缩下载的内容，并将`zombiecontrol.ttf`文件添加到`D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\fonts`文件夹。现在是时候学习更多的C++了，这样我们就可以开始为Zombie
    Arena编写代码了。
- en: OOP
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP
- en: OOP is a programming paradigm that we could consider almost the standard way
    to code. It is true there are non-OOP ways to code and there are even some non-OOP
    game coding languages and libraries. However, starting from scratch, as this book
    does, there is no reason to do things any other way. When the benefits of OOP
    become apparent you will never look back.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一种编程范式，我们可以认为它几乎是编码的标准方式。的确，有非OOP的编码方式，甚至有一些非OOP的游戏编码语言和库。然而，从零开始，就像这本书所做的那样，没有理由以其他方式做事。当OOP的好处变得明显时，你将永远不会回头看。
- en: 'OOP will:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: OOP将会：
- en: Make our code easier to manage, change, or update
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的代码更易管理，更改或更新
- en: Make our code quicker and more reliable to write
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的代码更快，更可靠地编写
- en: Make it possible to easily use other people's code (such as SFML)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其可以轻松使用其他人的代码（如SFML）
- en: 'We have already seen the third benefit in action. Let''s look at the first
    two benefits by introducing a problem that needs solving. The problem we are faced
    with is the complexity of the current project. Let''s consider just a single zombie
    and what we need to make it function in the game:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了第三个好处的实际效果。让我们通过引入一个需要解决的问题来看一下前两个好处。我们面临的问题是当前项目的复杂性。让我们考虑一个单一的僵尸以及我们需要让它在游戏中运行的内容：
- en: Horizontal and vertical position
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平和垂直位置
- en: Size
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小
- en: Direction it is facing
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所面对的方向
- en: Different textures for each zombie type
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型的不同纹理
- en: Sprites
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵
- en: Different speeds for each zombie type
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型的不同速度
- en: Different health for each zombie type
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型的不同生命值
- en: Keeping track of the type of each zombie
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪每个僵尸的类型
- en: Collision-detection data
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测数据
- en: Intelligence (to chase the player)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能（追逐玩家）
- en: Is the zombie alive or dead?
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 僵尸是活着的还是死了？
- en: This list suggests perhaps a dozen variables for just one zombie! We would need,
    perhaps, whole arrays of each of these variables for managing a zombie horde.
    And what about all the bullets from the machine gun, the pick-ups, and the different
    level ups? The simple Timber!!! game was starting to get a bit unmanageable by
    the end, and it is easy to speculate that this more complicated shooter could
    be many times worse!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能为一个僵尸提供了大约十几个变量！我们可能需要整个数组来管理僵尸群。那么机枪的所有子弹、拾取物品和不同的升级呢？简单的Timber!!!游戏到最后开始变得有点难以管理，可以推测这个更复杂的射击游戏可能会更糟！
- en: Fortunately, handling complexity is not a new problem, and C++ was designed
    from the start to be the solution for this complexity.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，处理复杂性并不是一个新问题，C++从一开始就被设计为解决这种复杂性。
- en: What is OOP?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是OOP？
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一种编程方式，它涉及将我们的需求分解成比整体更易管理的块。
- en: Each chunk is self-contained, yet potentially reusable by other programs, while
    working together with the other chunks as a whole.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块是自包含的，但可能被其他程序重复使用，同时作为一个整体一起工作。
- en: These chunks are what we have been referring to as objects. When we plan and
    code an object, we do so with a **class**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块就是我们所说的对象。当我们计划和编写一个对象时，我们使用一个**类**。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A class can be thought of as the blueprint for an object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以被认为是对象的蓝图。
- en: We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can't live in it, but you can build a house
    from it. You build an instance of it. Often when we design classes for our games,
    we write them to represent real world things. In this project, we will write classes
    for the player, a zombie, a bullet, and more as well. However, OOP is more than
    this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现一个类的对象。这被称为类的**实例**。想象一下一个房子的蓝图。你不能住在里面，但你可以建造一座房子。你建造了它的一个实例。通常，当我们为我们的游戏设计类时，我们会写一些代表现实世界事物的类。在这个项目中，我们将为玩家、僵尸、子弹等编写类。然而，OOP不仅仅是这样。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: OOP is a way of doing things, a methodology that defines best practices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一种做事的方式，一种定义最佳实践的方法。
- en: The three core principles of OOP are **encapsulation**, **polymorphism,** and
    **inheritance**. This might sound complex, but actually, taken a step at a time,
    it is reasonably straightforward.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OOP的三个核心原则是**封装**，**多态**和**继承**。这可能听起来很复杂，但实际上，一步一步地进行，它是相当简单的。
- en: Encapsulation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation means keeping the internal workings of your code safe from interference
    from the code that uses it. You can achieve this by allowing only the variables
    and functions, which you choose, to be accessed. This means your code can always
    be updated, extended, or improved without affecting the programs that use it,
    as long as the exposed parts are still accessed in the same way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 封装意味着保护代码的内部工作，使其不受使用它的代码的干扰。你可以通过只允许你选择的变量和函数来访问来实现这一点。这意味着只要暴露的部分仍然以相同的方式被访问，你的代码就可以随时更新、扩展或改进，而不会影响使用它的程序。
- en: As an example, with proper encapsulation, it wouldn't matter if the SFML team
    needed to update the way their `Sprite` class works. As long as the function signatures
    remain the same, we don't have to worry about what goes on inside. Our code written
    before the update will still work after the update.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，通过适当的封装，如果SFML团队需要更新他们的`Sprite`类的工作方式，这并不重要。只要函数签名保持不变，我们就不必担心内部发生了什么。更新之前编写的代码仍然可以在更新后继续工作。
- en: Polymorphism
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism allows us to write code that is less dependent on the types we
    are trying to manipulate. This will make our code clearer and more efficient.
    Polymorphism means different forms. If the objects that we code can be more than
    one type of thing, then we can take advantage of this. Polymorphism might sound
    a little bit like black magic at this point. We will use polymorphism in the final
    project starting in [Chapter 12](ch12.html "Chapter 12. Abstraction and Code Management
    – Making Better Use of OOP"), *Abstraction and Code Management -* *Making Better
    Use of OOP*. Everything will then become clearer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性使我们能够编写不太依赖于我们试图操作的类型的代码。这将使我们的代码更清晰、更高效。多态性意味着不同的形式。如果我们编码的对象可以是多种类型的东西，那么我们就可以利用这一点。多态性在[第12章](ch12.html
    "第12章。抽象和代码管理-更好地利用OOP")中的最终项目中将会得到应用，*抽象和代码管理-更好地利用OOP*。一切都会变得更清晰。
- en: Inheritance
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Just like it sounds, inheritance means we can harness all the features and benefits
    of other people's classes, including the encapsulation and polymorphism, while
    further refining their code specifically to our situation. We will use inheritance
    in the final project starting in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management* - *Making
    Better Use of OOP*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像听起来的那样，继承意味着我们可以利用其他人类的所有功能和好处，包括封装和多态性，同时进一步调整他们的代码以适应我们的情况。我们将在[第12章](ch12.html
    "第12章。抽象和代码管理-更好地利用OOP")中的最终项目中使用继承，*抽象和代码管理* - *更好地利用OOP*。
- en: Why do it like this?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要这样做？
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained (encapsulated) nature means fewer or perhaps even
    zero consequences for other parts of the program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确编写时，所有这些OOP都允许您添加新功能，而无需过多担心它们与现有功能的交互。当您必须更改类时，其自包含（封装）的特性意味着对程序的其他部分的影响较少，甚至可能为零。
- en: You can use other people's code (such as the SFML classes) without knowing or
    perhaps even caring how it works inside.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他人的代码（例如SFML类），而无需知道甚至关心其内部工作原理。
- en: OOP, and by extension SFML, allows you to write games that use complicated concepts,
    such as multiple cameras, multiplayer, OpenGL, directional sound, and more besides.
    All this without breaking a sweat.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: OOP，以及扩展的SFML，使您能够编写使用复杂概念的游戏，例如多个摄像机、多人游戏、OpenGL、定向声音等等。所有这些都可以轻松实现。
- en: Using inheritance you can create multiple similar, yet different, versions of
    a class without starting the class from scratch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，您可以创建多个相似但不同版本的类，而无需从头开始编写类。
- en: You can still use the functions intended for the original type of object with
    your new object because of polymorphism.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态性，您仍然可以使用原始对象类型的函数来处理新对象。
- en: All this makes sense, really. And, as we know, C++ was designed from the start
    with all of this OOP in mind.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是有道理的。而且，正如我们所知，C++从一开始就考虑了所有这些OOP。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The ultimate key to success with OOP and making games (or any other type of
    app), other than the determination to succeed, is planning and design. It is not
    so much just knowing all the C++, SFML, and OOP topics that will help you write
    great code, but rather applying all that knowledge to write code that is well
    structured and designed. The code in this book is presented in an order and manner
    appropriate to learning the various C++ topics in a gaming context. The art and
    science of structuring your code is called **design patterns**. As your code gets
    longer and more complex, effective use of design patterns will become more important.
    The good news is that we don't need to invent these design patterns ourselves.
    We will need to learn about them as our projects get more complex. More on design
    patterns in the final chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OOP和制作游戏（或任何其他类型的应用程序）的最终成功关键，除了决心成功外，还包括规划和设计。重要的不仅仅是了解所有C++、SFML和OOP主题，而是将所有这些知识应用到编写结构良好、设计良好的代码中。本书中的代码按照适合在游戏环境中学习各种C++主题的顺序和方式呈现。结构化代码的艺术和科学称为**设计模式**。随着代码变得越来越长和复杂，有效使用设计模式将变得更加重要。好消息是，我们不需要自己发明这些设计模式。随着我们的项目变得更加复杂，我们需要了解它们。最终章节将更多地介绍设计模式。
- en: In this project we will learn about and use basic classes and encapsulation,
    and in the final project we will get a bit more daring and use inheritance, polymorphism,
    and other OOP-related C++ features too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将学习和使用基本类和封装，而在最终项目中，我们将更加大胆地使用继承、多态性和其他与C++相关的OOP特性。
- en: What is a class?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是类？
- en: A class is a bunch of code that can contain functions, variables, loops, and
    all the other C++ syntax we have already learned about. Each new class will be
    declared in its own `.h` code file with the same name as the class and its functions
    will be defined in their own `.cpp` file. This will become clearer when we actually
    look at writing some classes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一堆代码，可以包含函数、变量、循环和我们已经学过的所有其他C++语法。每个新类将在其自己的`.h`代码文件中声明，文件名与类名相同，其函数将在其自己的`.cpp`文件中定义。当我们实际编写一些类时，这将变得更清晰。
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class.
    It is an object made from the class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了一个类，我们可以使用它来创建任意数量的对象。记住，类是蓝图，我们根据蓝图制作对象。房子不是蓝图，就像对象不是类。它是从类制作的对象。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can think of an object as a variable and the class as a type.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将对象视为变量，将类视为类型。
- en: Of course, with all this talk of OOP and classes we haven't actually seen any
    code. So let's fix that now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，谈论OOP和类时，我们实际上还没有看到任何代码。所以现在让我们来解决这个问题。
- en: The class variable and function declarations
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类变量和函数声明
- en: Let's use a different game example to Zombie Arena. Consider the most basic
    game of all, Pong. A paddle/bat that bounces a ball. The paddle would be an excellent
    candidate for a class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个不同的游戏例子来看看，比如僵尸竞技场。考虑一下最基本的游戏，乒乓球。一个弹球的球拍。球拍将是一个很好的类候选。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you don''t know what Pong is, then take a look at this link: [https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道乒乓球是什么，那就看看这个链接：[https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong)
- en: 'Take a look at a hypothetical `Paddle.h` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下一个假设的`Paddle.h`文件：
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At first glance the code might appear a little complex, but when it is explained
    we will see there are very few new concepts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，代码可能看起来有点复杂，但当解释时，我们会发现其中几乎没有新概念。
- en: 'The first thing to notice is that a new class is declared using the `class`
    keyword followed by the name of the class, and that the entire declaration is
    enclosed in curly braces followed by a closing semicolon:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是使用`class`关键字声明了一个新类，后面跟着类的名称，整个声明被大括号括起来，后面跟着一个分号：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now look at the variable declarations and their names:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看变量的声明和它们的名称：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the names are prefixed with `m_`. This is not necessary, but it is a good
    convention. Variables declared as part of the class are called **member variables**.
    Prefixing with an `m_` makes it absolutely plain when we are dealing with a member
    variable. When we write functions for our classes, we will start to see local
    variables and parameters as well. The `m_` convention will then prove itself useful.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的名称都以`m_`为前缀。这不是必需的，但这是一个很好的约定。作为类的一部分声明的变量称为**成员变量**。以`m_`为前缀使得当我们处理成员变量时变得非常明显。当我们为我们的类编写函数时，我们将开始看到局部变量和参数。`m_`约定将证明自己是有用的。
- en: 'Notice also that all the variables are in a section of the code headed with
    the `private:` keyword. Scan your eyes over the previous sample code and notice
    that the body of the class code is separated into two sections:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，所有的变量都在以`private:`关键字开头的代码部分中。扫一眼之前的示例代码，注意类代码的主体分为两个部分：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `public` and `private` keywords control the encapsulation of our class.
    Anything that is private cannot be accessed directly by the user of an instance
    or object of the class. If you are designing a class for others to use, you don't
    want them being able to alter anything at will.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`和`private`关键字控制了我们的类的封装。任何私有的东西都不能被类的实例或对象的用户直接访问。如果你正在为其他人设计一个类来使用，你不希望他们能够随意改变任何东西。'
- en: This means that our four member variables cannot be accessed directly by our
    game engine in `main`. They can be accessed indirectly by the code of the class.
    For the `m_Length` and `m_Height` variables this is fairly easy to accept, as
    long as we don't need to change the size of the paddle. The `m_XPosition` and
    `m_YPosition` member variables, however, do need to be accessed, or how on earth
    will we move the paddle?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的四个成员变量不能被`main`中的游戏引擎直接访问。它们可以通过类的代码间接访问。对于`m_Length`和`m_Height`变量，这是相当容易接受的，只要我们不需要改变球拍的大小。然而，`m_XPosition`和`m_YPosition`成员变量需要被访问，否则我们怎么移动球拍呢？
- en: 'This problem is solved in the `public:` section of the code as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在代码的`public:`部分得到了解决：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The class provides two functions which are public and will be usable with an
    object of type `Paddle`. When we have seen the definition of these functions,
    we will see exactly how these functions manipulate the private variables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了两个公共函数，可以与`Paddle`类型的对象一起使用。当我们看到这些函数的定义时，我们将看到这些函数如何操纵私有变量。
- en: In summary, we have a bunch of inaccessible (private) variables that cannot
    be used from the `main` function. This is good because encapsulation makes our
    code less error prone and more maintainable. We then solve the problem of moving
    the paddle by providing indirect access to the `m_XPosition` and `m_YPosition`
    variables by providing two public functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们有一堆无法访问的（私有）变量，不能从`main`函数中使用。这是很好的，因为封装使我们的代码更少出错，更易维护。然后，我们通过提供两个公共函数来解决移动球拍的问题，间接访问`m_XPosition`和`m_YPosition`变量。
- en: The code in `main` can call these functions, but the code inside the functions
    controls exactly how the variables are altered.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`中的代码可以调用这些函数，但函数内部的代码控制着变量的具体修改方式。'
- en: Let's take a look at the function definitions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看函数的定义。
- en: The class function definitions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类函数定义
- en: 'The function definitions we will write in this book will all go in a separate
    file to the class and function declarations. We will use files with the same name
    as the class and the `.cpp` file extension. So, in our hypothetical example, this
    next code would go in a file called `Paddle.cpp`. Take a look at this really simple
    code that has just one new concept:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中编写的函数定义都将放在一个单独的文件中，与类和函数声明分开。我们将使用与类相同名称的文件和`.cpp`文件扩展名。因此，在我们的假设示例中，下一个代码将放在一个名为`Paddle.cpp`的文件中。看一下这个非常简单的代码，其中只有一个新概念：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing to note is that we must use an include directive to include
    the class and function declarations from the `Paddle.h` class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们必须使用包含指令来包含`Paddle.h`类中的类和函数声明。
- en: The new concept we see here is the use of the **scope resolution** operator,
    `::`. As the functions belong to a class, we must write the signature part by
    prefixing the function name with the class name and `::`. `void Paddle::moveLeft()`
    and `void Paddle::moveRight`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的新概念是**作用域解析**运算符`::`的使用。由于函数属于一个类，我们必须通过在函数名前加上类名和`::`来编写签名部分。`void
    Paddle::moveLeft()`和`void Paddle::moveRight`。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, we have briefly seen the scope resolution operator before. Whenever
    we declare an object of a class and we have not previously used `using namespace..`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们之前已经简要看到了作用域解析运算符。每当我们声明一个类的对象并且之前没有使用`using namespace..`。
- en: 'Note also that we could have put the function definitions and declarations
    in one file like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以把函数的定义和声明放在一个文件中，就像这样：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, when our classes get longer (as they will with our first Zombie Arena
    class) it is more organized to separate the function definitions into their own
    file. Furthermore, header files are considered public, and are often used for
    documentation purposes if other people will be using the code that we write.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们的类变得更长（就像我们的第一个Zombie Arena类一样），将函数定义分离到它们自己的文件中会更有组织性。此外，头文件被认为是公共的，并且通常用于文档目的，如果其他人将使用我们编写的代码。
- en: Using an instance of a class
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类的实例
- en: Despite all the code we have seen related to classes, we haven't actually used
    the class. We already know how to do this as we have used the SFML classes many
    times already.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到了与类相关的所有代码，但我们实际上还没有使用这个类。我们已经知道如何做到这一点，因为我们已经多次使用了SFML类。
- en: 'First, we would create an instance of `Paddle` like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会像这样创建一个`Paddle`的实例：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `paddle` object has all the variables we declared in `Paddle.h`. We just
    can''t access them directly. We can, however, move our paddle using its public
    functions, like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`paddle`对象拥有我们在`Paddle.h`中声明的所有变量。我们只是不能直接访问它们。然而，我们可以使用它的公共函数来移动我们的挡板，就像这样：'
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that `paddle` is a `Paddle`, and as such it has all the member variables
    and all the functions available to it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`paddle`是一个`Paddle`，因此它拥有所有的成员变量和所有的可用函数。
- en: 'We could decide at a later date to make our **Pong** game multiplayer. In the
    `main` function, we could change the code to have two paddles. Perhaps like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定在以后的某个日期将我们的**Pong**游戏改为多人游戏。在`main`函数中，我们可以改变代码以拥有两个挡板。可能像这样：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is vitally important to realize that each of these instances of `Paddle`
    are separate objects with their very own set of variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要意识到，每个`Paddle`实例都是具有自己独特变量集的单独对象。
- en: Constructors and getter functions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和getter函数
- en: The simple Pong paddle example was a good way of introducing the basics of classes.
    Classes can be simple and short like `Paddle`, but they can also be longer, more
    complicated, and themselves contain other objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的Pong挡板示例是介绍类基础知识的好方法。类可以像`Paddle`一样简单和简短，但它们也可以更长，更复杂，并且本身包含其他对象。
- en: When it comes to making games, there is a vital thing missing from the hypothetical
    `Paddle` class. It might be fine for all these private member variables and public
    functions, but how will we draw anything? Our Pong paddles need a sprite and a
    texture too.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作游戏时，假设的`Paddle`类中缺少一个重要的东西。对于所有这些私有成员变量和公共函数来说可能还好，但我们如何绘制任何东西呢？我们的Pong挡板也需要一个精灵和一个纹理。
- en: We can include other objects in our class in exactly the same way that we include
    them in `main`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与在`main`中包含它们相同的方式在我们的类中包含其他对象。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here is an updated version of the `private:` section of `Paddle.h` code which
    includes a member `Sprite` and a member `Texture` too. Note that the file would
    also need the relevant SFML include directive for this code to compile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Paddle.h`代码中`private:`部分的更新版本，其中包括一个成员`Sprite`和一个成员`Texture`。请注意，该文件还需要相关的SFML包含指令，以便该代码能够编译。
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The new problem is immediately upon us. If `m_Sprite` and `m_Texture` are private,
    then how on earth will we draw them in the `main` function?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新问题立即出现。如果`m_Sprite`和`m_Texture`是私有的，那么我们怎么在`main`函数中绘制它们呢？
- en: We will need to provide a function that allows access to `m_Sprite` so it can
    be drawn. Look carefully at the new function declaration in the public section
    of `Paddle.h`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个函数，允许访问`m_Sprite`以便绘制。仔细看看`Paddle.h`公共部分的新函数声明。
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code declares a function called `getSprite`. The significant thing
    to notice is that `getSprite` returns a `Sprite` object. We will see the definition
    of `getSprite` very soon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码声明了一个名为`getSprite`的函数。要注意的重要事情是`getSprite`返回一个`Sprite`对象。我们很快就会看到`getSprite`的定义。
- en: If you are sharp minded, you will also have noticed that at no point have we
    loaded the texture or called `m_Sprite.setTexture(m_Texture)` to associate the
    texture with the sprite.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很敏锐，你也会注意到在任何时候我们都没有加载纹理或调用`m_Sprite.setTexture(m_Texture)`来将纹理与精灵关联起来。
- en: When a class is coded, a special function is created by the compiler. We don't
    see this function in our code but it is there. It is called a constructor. When
    we need to write some code to prepare an object for use, often a good place to
    do this is the constructor. When we want the constructor to do anything other
    than simply create an instance, we must replace the default (unseen) constructor
    provided by the compiler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被编码时，编译器会创建一个特殊的函数。我们在代码中看不到这个函数，但它确实存在。它被称为构造函数。当我们需要编写一些代码来准备一个对象供使用时，通常一个很好的地方就是构造函数。当我们希望构造函数做的事情不仅仅是创建一个实例时，我们必须替换编译器提供的默认（看不见的）构造函数。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: First, we provide a constructor function declaration. Note that constructors
    have no return type, not even `void`. Also note that we can immediately see that
    it is the constructor function because the function name is the same as the class,
    `Paddle`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们提供一个构造函数声明。请注意，构造函数没有返回类型，甚至没有`void`。还要注意，我们可以立即看到它是构造函数，因为函数名与类名`Paddle`相同。
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next code shows the new function definitions in `Paddle.cpp` (`getSprite`
    and the constructor, `Paddle`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了`Paddle.cpp`中的新函数定义（`getSprite`和构造函数`Paddle`）：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, we use the constructor function, `Paddle`, to load the
    texture and associate it with the sprite. Remember that this function is called
    at the time that an object of type `Paddle` is declared. More specifically, when
    the code `Paddle paddle` is executed, the constructor is called.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们使用构造函数`Paddle`来加载纹理并将其与精灵关联起来。请记住，这个函数是在声明`Paddle`类型的对象时调用的。更具体地说，当执行代码`Paddle
    paddle`时，构造函数被调用。
- en: In the `getSprite` function there is just one line of code that returns a copy
    of `m_Sprite` to the calling code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getSprite`函数中，只有一行代码将`m_Sprite`的副本返回给调用代码。
- en: We could do other setup work for our objects in the constructor as well and
    will do so when we build our first real class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在构造函数中为我们的对象进行其他设置工作，并且在构建我们的第一个真正的类时会这样做。
- en: 'If you want to see exactly how the `getSprite` function could be used, the
    code in `main` would look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看`getSprite`函数如何被使用，`main`中的代码将如下所示：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous line of code assumes we have an SFML `RenderWindow` object called
    `window`. As `getSprite` returns an object of type `Sprite`, the previous line
    of code works exactly as if the sprite had been declared in `main`. Now we have
    a neatly encapsulated class that provides controlled access via its public functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码假设我们有一个名为`window`的SFML `RenderWindow`对象。由于`getSprite`返回一个`Sprite`类型的对象，上一行代码的工作方式与在`main`中声明sprite的方式完全相同。现在我们有了一个通过其公共函数提供受控访问的封装良好的类。
- en: Jumping around in the code
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中跳来跳去
- en: 'I find that when I read books that jump around in the code files, I often find
    it hard to follow exactly what is going on. What follows are the complete listings
    for the hypothetical `Paddle.h` and `Paddle.cpp`, to get everything in context.
    Be sure to study them before moving on:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现当我阅读跳来跳去的代码文件的书时，我经常发现很难准确地理解发生了什么。接下来是假设的`Paddle.h`和`Paddle.cpp`的完整清单，以便在继续之前仔细研究它们：
- en: '`Paddle.h`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paddle.h`'
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Paddle.cpp`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paddle.cpp`'
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will constantly be revisiting classes and OOP throughout the rest of the
    book. For now, however, we know enough to get started on our first real class
    for the Zombie Arena game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将不断回顾类和面向对象编程。然而，现在我们已经知道足够的知识来开始我们的第一个真正的Zombie Arena游戏类。
- en: Building the Player-the first class
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Player-第一个类
- en: Let's think about what our `Player` class will need to do. The class will need
    to know how fast it can move, where in the game world it currently is, and how
    much health it has. As the `Player` class, in the player's eyes, is represented
    as a 2D graphical character, the class will need both a `Sprite` and a `Texture`
    object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们的`Player`类需要做什么。该类需要知道自己可以移动多快，当前在游戏世界中的位置以及拥有多少生命值。由于`Player`类在玩家眼中被表示为一个2D图形角色，该类将需要一个`Sprite`和一个`Texture`对象。
- en: Furthermore, although the reasons might not be obvious at this point, our `Player`
    class will also benefit from knowing a few details about the overall environment
    the game is running in. These details are screen resolution, the size of the tiles
    that make up an arena, and the overall size of the current arena.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管此时可能不明显，我们的`Player`类还将受益于了解游戏运行的整体环境的一些细节。这些细节包括屏幕分辨率、构成竞技场的瓦片大小以及当前竞技场的整体大小。
- en: As the `Player` class will be taking full responsibility for updating itself
    each frame, it will need to know the player's intentions at any given moment.
    For example, is the player currently holding down a particular keyboard direction
    key? Or is the player currently holding down multiple keyboard direction keys?
    Boolean variables to determine the status of the ***W*, *A*, *S*, and *D*** keys
    will be essential.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Player`类将全权负责每帧更新自身，它需要知道玩家在任何给定时刻的意图。例如，玩家当前是否按住特定的键盘方向键？或者玩家当前是否按住多个键盘方向键？布尔变量来确定***W*、*A*、*S*和*D***键的状态将是必不可少的。
- en: It is plain we are going to need quite a selection of variables in our new class.
    Having learned all we have about OOP, we will, of course, be making all these
    variables private. This means that we must provide access, where appropriate,
    from the `main` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们将需要在我们的新类中使用相当多的变量。通过学习了关于面向对象编程的所有知识，我们当然会将所有这些变量设置为私有的。这意味着我们必须在适当的时候从`main`函数中提供访问。
- en: We will use a whole bunch of `getter` functions, as well as some other functions,
    to set up our object. These functions are quite numerous; there are actually 21
    functions in this class. At first this might seem a little daunting, but we will
    go through them all and see that the majority of them simply set or get one of
    the private variables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一大堆`getter`函数，以及一些其他函数来设置我们的对象。这些函数相当多；实际上，在这个类中有21个函数。起初这可能看起来有点令人生畏，但我们将逐个查看它们，并看到其中大多数只是设置或获取其中一个私有变量。
- en: There are just a few fairly in-depth functions, such as `update`, which will
    be called once each frame from the `main` function, and `spawn`, which will handle
    the initializing of some of the private variables. As we will see, however, there
    is nothing complicated about them, and they will all be described in detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些相当深入的函数，比如`update`，它将从`main`函数中每帧调用一次，以及`spawn`，它将处理一些私有变量的初始化。然而，正如我们将看到的，它们都不复杂，并且将被详细描述。
- en: The best way to proceed is to code the header file. This will give us the opportunity
    to see all the private variables and examine all the function signatures. Pay
    close attention to the return values and argument types, as this will make understanding
    the code in the function definitions much easier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行的最佳方式是编写头文件。这将使我们有机会查看所有私有变量并检查所有函数签名。请特别注意返回值和参数类型，因为这将使理解函数定义中的代码变得更容易。
- en: Coding the Player class header file
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Player类头文件
- en: '**Right click** on **Header Files** in the **Solution Explorer** and select
    **Add** | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (`.h`),** and then, in the **Name** field, type `Player.h`. Finally,
    click the **Add** button. We are now ready to code the header file for our first
    class.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中**右键单击**“头文件”，然后选择**添加** | **新建项目...**。在“添加新项目”窗口中，通过左键单击**头文件（`.h`）**，然后在“名称”字段中输入`Player.h`。最后，单击**添加**按钮。现在我们准备为我们的第一个类编写头文件。
- en: 'Get started coding the `Player` class by adding the declaration, including
    the opening and closing curly braces followed by a semicolon:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加声明来开始编写`Player`类，包括开放和关闭的大括号，然后是一个分号：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s add all our private member variables. Based on what we have already
    discussed, see if you can work out what each of them will do. We will go through
    them individually in a minute:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加所有私有成员变量。根据我们已经讨论的内容，看看你能否弄清楚它们每一个将要做什么。我们将逐个讨论它们：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code declares all our member variables. Some are regular variables
    and some are themselves objects. Notice that they are all under the `private:`
    section of the class and are therefore not directly accessible from outside the
    class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了我们所有的成员变量。有些是常规变量，有些是对象本身。请注意，它们都在类的`private:`部分下，并且因此不能直接从类外部访问。
- en: Also notice, we are using the naming convention of prefixing `m_` to all the
    names of the non-constant variables. The `m_` prefix will remind us, while coding
    the function definitions, that they are member variables and are distinct from
    some local variables we will create in some of the functions, as well as being
    distinct from the function parameters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们使用了将`m_`前缀添加到所有非常量变量的命名约定。`m_`前缀将在编写函数定义时提醒我们，它们是成员变量，并且与我们将在一些函数中创建的一些局部变量以及与函数参数不同。
- en: All of the variable's uses will be obvious, such as `m_Position`, `m_Texture,`
    and `m_Sprite`, which are for the current location, the texture, and sprite of
    the player. In addition, each variable (or group of variables) is commented to
    make their usage plain.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量的用途都是明显的，比如`m_Position`、`m_Texture`和`m_Sprite`，它们分别用于玩家的当前位置、纹理和精灵。此外，每个变量（或变量组）都有注释，以便明确它们的用途。
- en: However, why exactly they are needed and the context they will be used in might
    not be so obvious. For example, `m_LastHit`, which is an object of type `Time`,
    is for recording the time that the player last received a hit from a zombie. The
    use we are putting `m_LastHit` to is plain, but at the same time, it is not obvious
    why we might need this information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们为什么需要以及它们将在什么上下文中使用可能并不那么明显。例如，`m_LastHit`是一个`Time`类型的对象，用于记录玩家上次受到僵尸攻击的时间。我们将`m_LastHit`用于的用途很明显，但同时，为什么我们可能需要这些信息并不明显。
- en: As we piece the rest of the game together, the context for each of the variables
    will become clearer. The important thing for now is to familiarize yourself with
    the names and types to make following along with the rest of the project trouble
    free.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们将游戏的其余部分拼凑在一起，每个变量的上下文将变得更加清晰。现在重要的是要熟悉变量的名称和类型，以便在项目的其余部分中跟随进行时无忧。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You don't need to memorize the variable names and types as we will discuss all
    the code when they are used. You do need to take your time to look over them and
    get a little bit familiar with them. Furthermore, as we proceed it might be worth
    referring back to this header file if anything seems unclear.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要记住变量名称和类型，因为我们在使用它们时会讨论所有代码。您需要花时间仔细查看它们，并对它们有一点熟悉。此外，随着我们的进行，如果有任何地方看起来不清楚，回头参考这个头文件可能是值得的。
- en: 'Now we can add a whole long list of functions. Add all of the following highlighted
    code and see if you can work out what it all does. Pay close attention to the
    return types, parameters and name of each function. This is key to understanding
    the code we will write throughout the rest of the project. What do they tell us
    about each function? Add the following highlighted code and then we will examine
    it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一整长串的函数。添加以下所有突出显示的代码，看看你能否弄清楚它们的作用。密切关注每个函数的返回类型、参数和名称。这对于理解我们将在项目的其余部分中编写的代码至关重要。它们告诉我们关于每个函数的什么信息？添加以下突出显示的代码，然后我们将对其进行检查：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First note, that all the functions are public. This means we can call all of
    these functions, using an instance of the class, from main, with code like this:
    `player.getSprite();`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意，所有函数都是公共的。这意味着我们可以使用类的实例从`main`函数中调用所有这些函数，代码如下：`player.getSprite();`。
- en: 'Assuming `player` is a fully set up instance of the `Player` class, the previous
    code will return a copy of `m_Sprite`. Putting this code into a real context,
    we could, in the main function, write code like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`player`是`Player`类的一个完全设置好的实例，之前的代码将返回`m_Sprite`的副本。将这段代码放入真实的上下文中，我们可以在`main`函数中编写如下代码：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous code would draw the player graphic in its correct location, just
    as if the sprite were declared in the `main` function itself. This is just like
    what we did with the hypothetical `Paddle` class previously.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在正确的位置绘制玩家图形，就好像精灵是在`main`函数中声明的一样。这就像我们之前对假设的`Paddle`类所做的一样。
- en: 'Before we move on to implement (write the definitions of) these functions in
    a corresponding `.cpp` file, let''s take a closer look at each of them in turn:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续在相应的`.cpp`文件中实现（编写定义）这些函数之前，让我们依次仔细看看每一个：
- en: '`void spawn(IntRect arena, Vector2f resolution, int tileSize):` This function
    does as the name suggests. It will prepare the object ready for use, including
    putting it in its starting location (spawning it). Notice that it doesn''t return
    any data, but it does have three arguments. It receives an `IntRect` called `arena`,
    which will be the size and location of the current level, a `Vector2f` that will
    contain the screen resolution, and an `int` which will hold the size of a background
    tile.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void spawn(IntRect arena, Vector2f resolution, int tileSize):` 此函数如其名称所示。它将准备好对象供使用，包括将其放在起始位置（生成）。请注意，它不返回任何数据，但它有三个参数。它接收一个名为`arena`的`IntRect`，它将是当前级别的大小和位置，一个将包含屏幕分辨率的`Vector2f`，以及一个将保存背景瓦片大小的`int`。'
- en: '`void resetPlayerStats`: Once we give the player the ability to level up between
    waves, we will need to be able to take away and reset those abilities when they
    die.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void resetPlayerStats`: 一旦我们让玩家能够在波之间升级，当他们死亡时，我们需要能够夺走并重置这些能力。'
- en: '`Time getLastHitTime()`: This function does just one thing, it returns the
    time when the player was last hit by a zombie. We will use this function when
    detecting collisions and it will enable us to make sure the player isn''t punished
    too frequently for contact with a zombie.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time getLastHitTime()`: 此函数只做一件事，即返回玩家上次被僵尸击中的时间。在检测碰撞时，我们将使用此函数，它将确保玩家不会因与僵尸接触而受到过多惩罚。'
- en: '`FloatRect getPosition()`: This function returns a `FloatRect` that describes
    the horizontal and vertical floating point coordinates of the rectangle which
    contains the player graphic. This again is useful for collision detection.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FloatRect getPosition()`: 此函数返回描述包含玩家图形的矩形的水平和垂直浮点坐标的`FloatRect`。这对于碰撞检测再次非常有用。'
- en: '`Vector2f getCenter()`: This is slightly different to `getPosition` because
    it is a `Vector2f` and contains just the X and Y locations of the very center
    of the player graphic.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector2f getCenter()`: 这与`getPosition`略有不同，因为它是一个`Vector2f`，只包含玩家图形中心的X和Y位置。'
- en: '`float getRotation()`: The code in main will sometimes need to know, in degrees,
    which way the player is currently facing. Three o''clock is zero degrees and increases
    clockwise.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float getRotation()`: `main`中的代码有时需要知道玩家当前面向的方向（以度为单位）。三点钟为零度，顺时针增加。'
- en: '`Sprite getSprite()`: As previously discussed, this function returns a copy
    of the sprite which represents the player.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite getSprite()`: 如前所述，此函数返回代表玩家的精灵的副本。'
- en: '`void moveLeft()`, `...Right()`, `...Up()`, `...Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function
    and the `Player` class will then be able to take action when one or more of the
    ***W*, *A*, *S*, and *D*** keys have been pressed.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void moveLeft()`, `...Right()`, `...Up()`, `...Down()`: 这四个函数没有返回类型或参数。它们将从`main`函数中调用，然后`Player`类将能够在按下***W*、*A*、*S*和*D***键时采取行动。'
- en: '`void stopLeft()`, `...Right()`, `...Up()`, `...Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function,
    and the `Player` class will then be able to take action when one or more of the 
    ***W*, *A*, *S*, and *D*** keys have been released.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void stopLeft()`, `...Right()`, `...Up()`, `...Down()`: 这四个函数没有返回类型或参数。它们将从`main`函数中调用，然后`Player`类将能够在释放***W*、*A*、*S*和*D***键时采取行动。'
- en: '`void update(float elapsedTime, Vector2i mousePosition)`: This will be the
    only relatively long function of the entire class. It will be called once per
    frame from `main`. It will do everything necessary to make sure the player object''s
    data is updated ready for collision detection and drawing. Notice it returns no
    data, but receives the amount of elapsed time since the last frame, along with
    a `Vector2i`, which will hold the horizontal and vertical screen location of the
    mouse pointer or crosshair.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void update(float elapsedTime, Vector2i mousePosition)`: 这将是整个类中唯一相对较长的函数。它将从`main`每帧调用一次。它将做一切必要的工作，以确保玩家对象的数据已更新，以便进行碰撞检测和绘制。请注意它不返回数据，但接收自上一帧以来经过的时间量，以及一个`Vector2i`，其中包含鼠标指针或准星的水平和垂直屏幕位置。'
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that these are integer screen coordinates, distinct from floating point
    world coordinates.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些是整数屏幕坐标，与浮点世界坐标不同。
- en: '`void upgradeSpeed()`: A function that can be called from the leveling-up screen
    when the player chooses to make the player faster.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void upgradeSpeed()`: 当玩家选择使玩家更快时，可以从升级屏幕调用的函数。'
- en: '`void upgradeHealth()`: Another function that can be called from the leveling-up
    screen when the player chooses to make the player stronger (have more health).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void upgradeHealth()`: 当玩家选择使玩家更强壮（拥有更多健康）时，可以从升级屏幕调用的另一个函数。'
- en: '`void increaseHealthLevel(int amount)`: A subtle but important difference to
    the previous function in that this one will increase the amount of health the
    player has, up to a maximum currently set. This function will be used when the
    player picks up a health pick-up.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void increaseHealthLevel(int amount)`: 与前一个函数相比，这个函数的一个微妙但重要的区别在于它将增加玩家的健康值，直到当前设置的最大值。当玩家拾取健康道具时，将使用此函数。'
- en: '`int getHealth()`: With the level of health being as dynamic as it is, we need
    to be able to determine how much health the player has at any given moment. This
    function returns an `int` which holds that value. As with the variables, it should
    now be plain what each of the functions is for. Also, as with the variables, the
    why and precise context of using some of these functions will only reveal itself
    as we progress with the project.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getHealth()`: 由于健康水平如此动态，我们需要能够确定玩家在任何给定时刻有多少健康。此函数返回一个包含该值的`int`。与变量一样，现在应该清楚每个函数的用途。此外，与变量一样，随着项目的进展，使用其中一些函数的原因和确切上下文只有在我们进行项目时才会显现。'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You don't need to memorize the function names, return types, or parameters as
    we will discuss all the code when they are used. You do need to take your time
    to look over them, along with the previous explanations, and get a little bit
    more familiar with them. Furthermore, as we proceed, it might be worth referring
    back to this header file if anything seems unclear.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要记住函数名称、返回类型或参数，因为我们将在使用它们时讨论所有代码。您需要花时间仔细查看它们，以及之前的解释，并对它们更加熟悉一些。此外，随着我们的进行，如果有任何地方看起来不清楚，回头参考这个头文件可能是值得的。
- en: Now we can move on to the meat of our functions, the definitions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行我们函数的核心部分，即定义。
- en: Coding the Player class function definitions
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Player`类函数定义
- en: At last we can begin to write the code which actually does the work of our class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始编写实际执行我们类工作的代码。
- en: '**Right click** on **Source Files** in the **Solution Explorer** and select
    **Add | New Item...**. In the **Add New Item** window, highlight (by **left-clicking**)
    **C++ File** ( **`.cpp`** )**,** and then in the **Name** field type `Player.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    our first class.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**右键单击**在**解决方案资源管理器**中的**源文件**，然后选择**添加 | 新建项...**。在**添加新项**窗口中，通过**左键单击**选择**C++文件（**`.cpp`**）**，然后在**名称**字段中键入`Player.cpp`。最后，单击**添加**按钮。现在我们准备好为我们的第一个类编写`.cpp`文件了。'
- en: 'Here are the necessary include directives followed by the definition of the
    constructor. Remember, the constructor will be called when we first instantiate
    an object of type `Player`. Add this code into the `Player.cpp` file and then
    we can take a closer look:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是必要的包含指令，后面是构造函数的定义。记住，当我们首次实例化`Player`类型的对象时，构造函数将被调用。将此代码添加到`Player.cpp`文件中，然后我们可以更仔细地查看：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the constructor function which, of course, has the same name as the class
    and no return type, we write code which begins to set up the `Player` object ready
    for use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，当然，它与类名相同且没有返回类型，我们编写了一些代码，开始设置`Player`对象以便随时使用。
- en: 'To be absolutely clear: This code will run when we write this code from the
    `main` function'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要非常清楚：当我们从`main`函数中编写这段代码时，这段代码将运行。
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Don't add this previous line of code just yet.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要添加上述代码。
- en: All we do is initialize `m_Speed`, `m_Health,` and `m_MaxHealth` from their
    related constants. Then we load the player graphic in to `m_Texture`, associate
    `m_Texture` with `m_Sprite,` and set the origin of `m_Sprite` to the center `(25,
    25)`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需从相关的常量中初始化`m_Speed`、`m_Health`和`m_MaxHealth`。然后将玩家图形加载到`m_Texture`中，将`m_Texture`与`m_Sprite`关联，并将`m_Sprite`的原点设置为中心`(25,
    25)`。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the cryptic comment `// !!Watch this space!!`, indicating that we will
    return to the loading of our texture and some important issues regarding it. We
    will eventually change how we deal with this texture once we have discovered a
    problem and learned a bit more C++. We will do so in [Chapter 8](ch08.html "Chapter 8. Pointers,
    the Standard Template Library, and Texture Management"), *Pointers, Standard Template
    Library, and Texture Management*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意神秘的注释`// !!Watch this space!!`，表明我们将返回到纹理的加载以及一些重要的相关问题。一旦我们发现了问题并学到了更多的C++知识，我们将改变处理这个纹理的方式。我们将在[第8章](ch08.html
    "第8章。指针、标准模板库和纹理管理")中进行这样的操作，*指针、标准模板库和纹理管理*。
- en: 'Next, we will code the `spawn` function. We will only ever create one instance
    of the `Player` class. We will, however, need to spawn it into the current level,
    each and every wave. This is what the spawn function will handle for us. Add the
    following code into the `Player.cpp` file. Be sure to examine the detail and read
    the comments:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`spawn`函数。我们只会创建`Player`类的一个实例。然而，我们需要在当前关卡中生成它，每一波都需要。这就是`spawn`函数将为我们处理的内容。将以下代码添加到`Player.cpp`文件中。确保仔细检查细节并阅读注释：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code starts off by initializing the `m_Position.x` and `m_Position.y`
    values to half the height and width of the passed in `arena`. This has the effect
    of moving the player to the center of the level, regardless of its size.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先将`m_Position.x`和`m_Position.y`的值初始化为传入`arena`的高度和宽度的一半。这样做的效果是将玩家移动到关卡的中心，而不管其大小如何。
- en: Next, we copy all of the coordinates and dimensions of the passed in `arena`
    to the member object of the same type, `m_Arena`. The details of the size and
    coordinates of the current arena are used so frequently that it makes sense to
    do so. We can now use `m_Arena` for tasks such as making sure the player can't
    walk through walls. In addition, we copy the passed in `tileSize` to the member
    variable `m_TileSize`, for the same purpose. We will see `m_Arena` and `m_TileSize`
    in action in the `update` function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将传入`arena`的所有坐标和尺寸复制到相同类型的成员对象`m_Arena`中。当前竞技场的大小和坐标的细节使用如此频繁，这样做是有道理的。现在我们可以使用`m_Arena`来执行任务，比如确保玩家不能穿过墙壁。此外，我们将传入的`tileSize`复制到成员变量`m_TileSize`中，以达到相同的目的。我们将在`update`函数中看到`m_Arena`和`m_TileSize`的作用。
- en: The final two lines of code copy the screen resolution from the `Vector2f`,
    `resolution,` which is a parameter of `spawn`, into `m_Resolution`, which is a
    member variable of `Player`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行代码将`spawn`的参数`Vector2f`中的屏幕分辨率复制到`Player`的成员变量`m_Resolution`中。
- en: 'Now add the very straightforward code of the `resetPlayerStats` function. When
    the player dies, we will use it to reset any upgrades they might have used:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加`resetPlayerStats`函数的非常简单的代码。当玩家死亡时，我们将使用它来重置他们可能使用的任何升级：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will not write the code that actually calls the `resetPlayerStats` function
    until we have nearly completed the project, but it is there ready for when we
    need it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我们几乎完成项目时，我们才会编写实际调用`resetPlayerStats`函数的代码，但是当我们需要时，它已经准备好了。
- en: In the next code, we will add two more functions. They will handle what happens
    when the player is hit by a zombie. We will be able to call `player.hit()` and
    pass in the current game time. We will also be able to query the last time that
    the player was hit by calling `player.getLastHitTime()`. Exactly how these functions
    will be useful will become apparent when we have some zombies!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段代码中，我们将添加另外两个函数。它们将处理玩家被僵尸击中时发生的情况。我们将能够调用`player.hit()`并传入当前游戏时间。我们还将能够查询玩家上次被击中的时间，通过调用`player.getLastHitTime()`。当我们有了一些僵尸时，这些函数将如何有用将变得明显！
- en: 'Add the two new functions into the `Player.cpp` file and then we will examine
    the C++ a little more closely:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个新函数添加到`Player.cpp`文件中，然后我们将更仔细地检查C++：
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code for `getLastHitTime` is very straightforward. Return whatever value
    is stored in `m_LastHit`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLastHitTime`函数的代码非常简单。返回`m_LastHit`中存储的任何值。'
- en: The `hit` function is a bit more in-depth and nuanced. First, the `if` statement
    checks to see whether the time passed in is 200 milliseconds further ahead than
    the time stored in `m_LastHit`. If it is, `m_LastHit` is updated with the time
    passed in and `m_Health` has `10` deducted from its current value. The last line
    of code in this `if` statement is `return true`. Note that the `else` clause simply
    returns `false` to the calling code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: “hit”函数有点更深入和微妙。首先，“if”语句检查传入的时间是否比“m_LastHit”中存储的时间晚200毫秒。如果是，就用传入的时间更新“m_LastHit”，并且从当前值中减去“10”。这个“if”语句中的最后一行代码是“return
    true”。请注意，“else”子句只是向调用代码返回“false”。
- en: The overall effect of this function is that health will only be deducted from
    the player up to five times per second. Remember that our game loop might be running
    at thousands of iterations per second. In this scenario, without the restriction,
    a zombie would only need to be in contact with the player for one second and tens
    of thousands of health points would be deducted. The `hit` function controls and
    restricts this occurrence. It also lets the calling code know if a new hit has
    been registered (or not) by returning `true` or `false`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的整体效果是，每秒只能从玩家身上扣除最多五次健康点。请记住，我们的游戏循环可能每秒运行数千次。在这种情况下，如果没有限制，僵尸只需要与玩家接触一秒钟，就会扣除成千上万的健康点。
    “hit”函数控制和限制了这种情况。它还通过返回“true”或“false”让调用代码知道是否已经注册了新的命中。
- en: This code implies that we will detect collisions between a zombie and the player
    in the `main` function. We will then call `player.hit()` to determine whether
    to deduct any health points.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着我们将在“main”函数中检测僵尸和玩家之间的碰撞。然后我们将调用“player.hit（）”来确定是否扣除任何健康点。
- en: Next, for the `Player` class we will implement a bunch of getter functions.
    They enable us to keep the data neatly encapsulated in the `Player` class, at
    the same time as making their values available to the `main` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于“Player”类，我们将实现一堆getter函数。它们使我们能够将数据整洁地封装在“Player”类中，同时使它们的值可用于“main”函数。
- en: 'Add the following code right after the previous block and then we will discuss
    exactly what each function does:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块之后添加以下代码，然后我们将讨论每个函数的确切作用：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous code is very straightforward. Each and every one of the previous
    five functions returns the value of one of our member variables. Look carefully
    at each and familiarize yourself with which function returns which value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常直接。前面的五个函数中的每一个都返回我们的成员变量的值。仔细看看每个，并熟悉哪个函数返回哪个值。
- en: 'The next eight short functions enable the keyboard controls (we will use from
    `main`) to change data contained in our object of type `Player`. Add the code
    in the `Player.cpp` file and then I will summarize how it all works:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的八个简短的函数使键盘控件（我们将从“main”中使用）能够改变我们的“Player”对象中包含的数据。将代码添加到“Player.cpp”文件中，然后我将总结它的工作原理：
- en: '[PRE28]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous code has four functions (`moveLeft`, `moveRight`, `moveUp`, `moveDown`)
    which set the related Boolean variables (`m_LeftPressed`, `m_RightPressed`, `m_UpPressed`,
    `m_DownPressed`) to `true`. The other four functions (`stopLeft`, `stopRight`,
    `stopUp`, `stopDown`) do the opposite and set the same `Boolean` variables to
    `false`. The instance of the `Player` class can now be kept informed of which
    of the  ***W*, *A*, *S*, and *D*** keys have been pressed and which are not.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有四个函数（“moveLeft”，“moveRight”，“moveUp”，“moveDown”），它们将相关的布尔变量（“m_LeftPressed”，“m_RightPressed”，“m_UpPressed”，“m_DownPressed”）设置为“true”。另外四个函数（“stopLeft”，“stopRight”，“stopUp”，“stopDown”）则相反，将相同的“布尔”变量设置为“false”。现在，“Player”类的实例可以清楚地知道哪些键被按下，哪些没有。
- en: 'This next function is the one which does all the hard work. The `update` function
    will be called once on every single frame of our game loop. Add the code that
    follows and we will then examine it in detail. If you followed along with the
    previous eight functions and you remember how we animated the clouds for the **Timber!!!**
    project, you will probably find most of the following code quite understandable:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是做所有繁重工作的函数。 “update”函数将在我们游戏循环的每一帧上调用一次。添加接下来的代码，然后我们将详细讨论它。如果你跟着前面的八个函数，并且记得我们如何为“Timber!!!”项目中的云动画，你可能会发现以下大部分代码都很容易理解：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first portion of the previous code moves the player sprite. The four `if`
    statements check which of the movement-related `Boolean` variables (`m_LeftPressed`,
    `m_RightPressed`, `m_UpPressed`, `m_DownPressed`) are true and changes `m_Position.x`
    and `m_Position.y` accordingly. The same formula to calculate the amount to move
    as the Timber!!! project is used.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第一部分移动了玩家精灵。四个“if”语句检查与移动相关的“布尔”变量（“m_LeftPressed”，“m_RightPressed”，“m_UpPressed”，“m_DownPressed”）中哪些是true，并相应地更改“m_Position.x”和“m_Position.y”。与“Timber!!!”项目相同的计算移动量的公式被使用。
- en: '`position (+ or -) speed * elapsed time.`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: “位置（+或-）速度*经过的时间。”
- en: After these four `if` statements, `m_Sprite.setPosition` is called and `m_Position`
    is passed in. The sprite has now been adjusted by exactly the right amount for
    that one frame.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个“if”语句之后，调用“m_Sprite.setPosition”并传入“m_Position”。精灵现在已经根据该帧的正确量进行了调整。
- en: 'The next four `if` statements check whether `m_Position.x` or `m_Position.y`
    are beyond any of the edges of the current arena. Remember that the confines of
    the current arena were stored in `m_Arena` in the `spawn` function. Let''s look
    at the first of these four `if` statements in order to understand them all:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个“if”语句检查“m_Position.x”或“m_Position.y”是否超出了当前竞技场的任何边缘。请记住，当前竞技场的范围是在“spawn”函数中存储在“m_Arena”中的。让我们看看这四个“if”语句中的第一个，以便理解它们所有的含义：
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous code tests to see if `m_position.x` is greater than `m_Arena.width`
    minus the size of a tile (`m_TileSize`). As we will see when we create the background
    graphics, this calculation will detect the player straying into the wall.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码测试了 `m_position.x` 是否大于 `m_Arena.width` 减去一个瓷砖的大小（`m_TileSize`）。当我们创建背景图形时，这个计算将检测玩家是否偏离墙壁。
- en: When the `if` statement is true, the calculation `m_Arena.width - m_TileSize`
    is used to initialize `m_Position.x`. This makes the center of the player graphic
    unable to stray past the left-hand edge of the right-hand wall.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `if` 语句为真时，计算 `m_Arena.width - m_TileSize` 用于初始化 `m_Position.x`。这使得玩家图形的中心无法偏离右侧墙壁的左侧边缘。
- en: The next three `if` statements that follow the one we have just discussed do
    the same thing for the other three walls.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论过的 `if` 语句后面的下三个 `if` 语句对其他三面墙做了同样的事情。
- en: The last two lines of code calculate and set the angle that the player sprite
    is rotated to (facing). The line of code might look a little complex, but it is
    simply using the position of the crosshair (`mousePosition.x` and `mousePosition.y`)
    and the center of the screen (`m_Resolution.x` and `m_Resolution.y`) in a tried
    and tested trigonometric function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后两行计算并设置玩家精灵的旋转角度（面向）。这行代码可能看起来有点复杂，但它只是使用了十分成熟的三角函数，即使用了准星的位置（`mousePosition.x`
    和 `mousePosition.y`）和屏幕中心（`m_Resolution.x` 和 `m_Resolution.y`）。
- en: How `atan` uses these coordinates along with Pi (3.141) is quite complicated,
    and that is why it is wrapped up in a handy function for us. If you want to explore
    trigonometric functions in more detail you can do so at [http://www.cplusplus.com/reference/cmath/](http://www.cplusplus.com/reference/cmath/).The
    last three functions for the `Player` class make the player 20% faster, have 20%
    more health, and increase the player's health by the amount passed in, respectively.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`atan` 如何使用这些坐标以及 Pi（3.141）是非常复杂的，这就是为什么它被包装在一个方便的函数中供我们使用。如果您想更详细地探索三角函数，可以在[http://www.cplusplus.com/reference/cmath/](http://www.cplusplus.com/reference/cmath/)上这样做。`Player`
    类的最后三个函数使玩家速度提高 20%，生命值增加 20%，并分别增加传入的玩家生命值。'
- en: 'Add this code at the end of the `Player.cpp` file and then we will take a closer
    look:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到 `Player.cpp` 文件的末尾，然后我们将仔细查看：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '}'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: In the previous code, the `upgradeSpeed` and `upgradeHealth` functions increase
    the values stored in `m_Speed` and `m_MaxHealth,` respectively. The values are
    increased by 20% by multiplying the starting values by 0.2 and adding them to
    the current values. These functions will be called from the `main` function when
    the player is choosing what attributes of their character they wish to improve
    between levels.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`upgradeSpeed` 和 `upgradeHealth` 函数分别增加了存储在 `m_Speed` 和 `m_MaxHealth`
    中的值。这些值通过将起始值乘以 0.2 并加上当前值来增加 20%。这些函数将在玩家在关卡之间选择要改进的角色属性时，从 `main` 函数中调用。
- en: The `increaseHealthLevel` takes an `int` value from `main` in the `amount` parameter.
    This `int` value will be provided by a class called `Pickup` that we will write
    in [Chapter 9](ch09.html "Chapter 9. Collision Detection, Pickups, and Bullets"),
    *Collision Detection, Pick-ups, and Bullets*. The `m_Health` member variable is
    increased by the passed in value. There is a catch for the player, however. The
    `if` statement checks whether `m_Health` has exceeded `m_MaxHealth`, and if it
    has, sets it to `m_MaxHealth`. This means the player cannot simply gain infinite
    health from pick-ups. They must instead carefully balance the upgrades they choose
    between levels.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`increaseHealthLevel` 从 `main` 中的 `amount` 参数中获取一个 `int` 值。这个 `int` 值将由一个名为
    `Pickup` 的类提供，我们将在[第9章](ch09.html "第9章。碰撞检测、拾取物品和子弹")中编写，*碰撞检测、拾取物品和子弹*。`m_Health`
    成员变量增加了传入的值。然而，对于玩家来说有一个陷阱。`if` 语句检查 `m_Health` 是否超过了 `m_MaxHealth`，如果超过了，则将其设置为
    `m_MaxHealth`。这意味着玩家不能简单地从拾取物品中获得无限的生命值。他们必须在关卡之间谨慎平衡他们选择的升级。'
- en: Of course, our `Player` class can't actually do anything until we instantiate
    it and put it to work in our game loop. Before we do that, let's take a look at
    the concept of a game camera.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的 `Player` 类实际上无法做任何事情，直到我们实例化它并在游戏循环中让它工作。在这之前，让我们先了解一下游戏摄像机的概念。
- en: Controlling the game camera with SFML View
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML View控制游戏摄像机
- en: In my opinion, the SFML `View` class is one of the neatest classes. If after
    finishing this book you make games without using a media or gaming library, you
    will really notice the absence of `View`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，SFML `View` 类是最整洁的类之一。如果在完成本书后，您制作游戏而不使用媒体或游戏库，您将真正注意到缺少 `View`。
- en: The `View` class allows us to consider our game as taking place in its own world,
    with its own properties. What do I mean? When we create a game, we are usually
    trying to create a virtual world. That virtual world rarely, if ever, is measured
    in pixels and rarely, if ever, will that world be exactly the same number of pixels
    as the player's monitor. We need a way to abstract the virtual world we are building,
    so that it can be whatever size or shape we like.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 类允许我们将游戏视为发生在自己的世界中，具有自己的属性。我是什么意思？当我们创建游戏时，通常是在尝试创建一个虚拟世界。那个虚拟世界很少，如果有的话，是以像素为单位的，很少，如果有的话，会与玩家的显示器像素数完全相同。我们需要一种方式来抽象我们正在构建的虚拟世界，以便它可以是我们喜欢的任何大小或形状。'
- en: Another way to think of SFML `View` is as a camera through which the player
    views a part of our virtual world. Most games will have more than one camera or
    view of the world.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待SFML `View` 的方式是作为玩家查看我们虚拟世界的一部分的摄像机。大多数游戏都会有多个摄像机或对世界的视图。
- en: For example, consider a split screen game where two players can be in different
    parts of the same world, at different times.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个分屏游戏，两个玩家可以在同一个世界的不同部分，不同时间。
- en: Or consider a game where there is a small area of the screen that represents
    the entire game world but at a very high level, or zoomed out, like a mini map.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 或者考虑一个游戏，屏幕上有一个小区域代表整个游戏世界，但是在非常高的层次上，或者缩小，就像一个迷你地图。
- en: Even if our games are much simpler than the previous two examples and don't
    need split screens or mini maps, we will likely want to create a world that is
    bigger than the screen it is being played on. This is, of course, the case with
    Zombie Arena.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的游戏比前两个示例简单得多，不需要分屏或迷你地图，我们可能还是想要创建一个比正在播放的屏幕更大的世界。当然，这就是僵尸竞技场的情况。
- en: And if we are constantly moving the game camera around to show different parts
    of the virtual world (usually tracking the player) what happens to the HUD? If
    we draw the score and other on-screen HUD info and then we scroll the world around
    to follow the player, then the score will move relative to that camera.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不断地移动游戏摄像机以显示虚拟世界的不同部分（通常是跟踪玩家），HUD会发生什么？如果我们绘制分数和其他屏幕HUD信息，然后滚动世界以跟随玩家，那么分数将相对于该摄像机移动。
- en: The SFML `View` class easily enables all these features and solves the problem
    with very straightforward code. The trick is to create an instance of `View` for
    each and every camera. Perhaps a `View` for the mini map, a `View` for the scrolling
    game world, and then a `View` for the HUD.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: SFML `View`类很容易实现所有这些功能，并且通过非常简单的代码解决了这个问题。关键是为每个摄像机创建一个`View`实例。也许为迷你地图创建一个`View`，为滚动游戏世界创建一个`View`，然后为HUD创建一个`View`。
- en: The instances of `View` can be moved around, sized, and positioned as required.
    So the main `View` following the game can track the player, the mini-map view
    can remain in a fixed zoomed-out, small corner of the screen, while the HUD can
    overlay the entire screen and never move, despite the fact that the main `View`
    can go wherever the player goes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`的实例可以根据需要移动、调整大小和定位。因此，主`View`可以跟踪玩家，迷你地图视图可以保持在屏幕的固定缩小角落，而HUD可以覆盖整个屏幕并且永远不会移动，尽管主`View`可以随着玩家的移动而移动。'
- en: Let's look at some code using a few instances of View.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用几个`View`实例的代码。
- en: Tip
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This code is to introduce the `View` class. Don't add this code to the Zombie
    Arena project.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是为了介绍`View`类。不要将此代码添加到僵尸竞技场项目中。
- en: 'Create and initialize a few instances of View:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并初始化几个`View`实例：
- en: '[PRE32]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The previous code creates two `View` objects that fill a 1920 x 1080 monitor.
    Now we can do some magic with `mainView` while leaving `hudView` completely alone:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了两个填充1920 x 1080监视器的`View`对象。现在我们可以在保持`hudView`完全不变的情况下对`mainView`进行一些魔术操作：
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we manipulate the properties of a View, we do so as shown previously.
    When we draw sprites, text, or other objects to a view, we must specifically set
    the view as the current view for the window:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们操纵视图的属性时，我们就像之前展示的那样。当我们向视图绘制精灵、文本或其他对象时，我们必须明确将视图设置为窗口的当前视图：
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can draw everything we want into that view:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在该视图中绘制我们想要的一切：
- en: '[PRE35]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The player might be at any coordinate whatsoever. It doesn't matter because
    `mainView` is centered around the graphic.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可能在任何坐标。这并不重要，因为`mainView`是围绕图形中心的。
- en: 'Now we can draw the HUD into `hudView`. Note that, just as we draw individual
    elements (background, game objects, text, and so on) in layers from back to front,
    we also draw views from back to front as well. Hence a HUD is drawn after the
    main game:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将HUD绘制到`hudView`中。请注意，就像我们按照从后到前的顺序绘制单个元素（背景、游戏对象、文本等）一样，我们也按照从后到前的顺序绘制视图。因此，HUD在主游戏之后绘制：
- en: '[PRE36]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we can draw or show the window and all its views for the current frame
    in the usual way:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以以通常的方式绘制或显示窗口和当前帧的所有视图：
- en: '[PRE37]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to take your understanding of SFML View further than is necessary
    for this project, including how to achieve split screen and mini maps, then the
    best guide on the Web is on the official SFML website at [http://www.sfml-dev.org/tutorials/2.0/graphics-view.php](http://www.sfml-dev.org/tutorials/2.0/graphics-view.php).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想要深入了解SFML View，超出了这个项目所需的范围，包括如何实现分屏和迷你地图，那么Web上最好的指南是在官方SFML网站上[http://www.sfml-dev.org/tutorials/2.0/graphics-view.php](http://www.sfml-dev.org/tutorials/2.0/graphics-view.php)上。 '
- en: Now we have learnt about `View`, we can start coding the Zombie Arena `main`
    function and use our first `View` for real. In [Chapter 10](ch10.html "Chapter 10. Layering
    Views and Implementing the HUD"), *Layering Views and Implementing the HUD*, we
    will introduce a second instance of `View` for the HUD, fix it, and layer it over
    the top of the main `View`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`View`，我们可以开始编写僵尸竞技场`main`函数，并真正使用我们的第一个`View`。在[第10章](ch10.html "第10章。分层视图和实现HUD")中，*分层视图和实现HUD*，我们将为HUD介绍第二个`View`实例，修复它，并将其层叠在主`View`的顶部。
- en: Starting the Zombie Arena game engine
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动僵尸竞技场游戏引擎
- en: In this game, we will need a slightly upgraded game engine in `main`. In particular,
    we will have an enumeration called `state` which will track what the current state
    of the game is. Then, throughout `main`, we can wrap parts of our code so that
    different things happen in different states.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将需要一个稍微升级的游戏引擎在`main`中。特别是，我们将有一个名为`state`的枚举，它将跟踪游戏的当前状态。然后，在整个`main`中，我们可以包装我们的代码的部分，以便在不同的状态下发生不同的事情。
- en: Right-click on the `HelloSFML` file in the **Solution Explorer** and select
    **Rename**. Change the name to `ZombieArena.cpp`. This will be the file that contains
    our `main` function and the code that instantiates and controls all our classes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击`HelloSFML`文件，然后选择**重命名**。将名称更改为`ZombieArena.cpp`。这将是包含我们的`main`函数和实例化和控制所有类的代码的文件。
- en: We begin with the now familiar `main` function and some include directives.
    Note the addition of an include directive for the `Player` class.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从现在熟悉的`main`函数和一些包含指令开始。请注意，增加了一个`Player`类的包含指令。
- en: 'Add the code following to the `ZombieArena.cpp` file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ZombieArena.cpp`文件中：
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous code has nothing new in it except that the `#include "Player.h"`
    line means we can now use the `Player` class within our code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码除了`#include "Player.h"`行之外没有任何新内容，这意味着我们现在可以在我们的代码中使用`Player`类。
- en: Let's flesh out some more of our game engine. This next code does quite a lot.
    Be sure to read the comments when you add the code to get an idea of what is going
    on. We will then go through it in detail.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们充实一下我们的游戏引擎。接下来的代码做了很多事情。在添加代码时，请务必阅读注释，以了解发生了什么。然后我们将详细讨论它。
- en: 'Add the highlighted code at the start of the `main` function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的开头添加突出显示的代码：
- en: '[PRE39]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s run through each section of the code that we just entered. Just inside
    the main function we have this code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们刚刚输入的代码的每个部分。在`main`函数的内部，我们有这段代码：
- en: '[PRE40]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous code creates a new enumeration class called `State`. Then the code
    creates an instance of `State` called `state`. The `state` enumeration can now
    be one of four values, as defined in the declaration. Those values are `PAUSED`,
    `LEVELING_UP`, `GAME_OVER`, and `PLAYING`. These four values will be just what
    we need for keeping track and responding to the different states that the game
    can be in at any given time. Note that it is not possible for `state` to hold
    more than one value at a time.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个名为`State`的新枚举类。然后代码创建了一个名为`state`的`State`实例。`state`枚举现在可以是声明中定义的四个值之一。这些值是`PAUSED`、`LEVELING_UP`、`GAME_OVER`和`PLAYING`。这四个值将正是我们需要的，用于跟踪和响应游戏在任何给定时间可能处于的不同状态。请注意，`state`不可能同时保存多个值。
- en: 'Immediately after, we add the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们添加以下代码：
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The previous code declares a `Vector2f` called `resolution`. We initialize the
    two variables of `resolution` (`x` and `y`) by calling the `VideoMode::getDesktopMode`
    function for both `width` and `height`. The `resolution` object now holds the
    resolution of the monitor on which the game is running. The final line of code
    creates a new `RenderWindow` called `window` using the appropriate resolution.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了一个名为`resolution`的`Vector2f`。我们通过调用`VideoMode::getDesktopMode`函数来初始化`resolution`的两个变量（`x`和`y`）分别为`width`和`height`。`resolution`对象现在保存了游戏运行的显示器的分辨率。最后一行代码使用适当的分辨率创建了一个名为`window`的新`RenderWindow`。
- en: 'This next code creates an SFML `View` object. The view is positioned (initially)
    at the exact coordinates of the pixels of the monitor. If we were to use this
    `View` to do some drawing in this current position it would have no effect whatsoever.
    However, we will eventually start to move this view to focus on the parts of our
    game world that the player needs to see. Then, when we start to use a second `View`
    that remains fixed (for the HUD), we will see how this `View` can track the action
    while the other remains static to display the HUD:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码创建了一个SFML `View`对象。视图的位置（最初）位于显示器像素的确切坐标处。如果我们要在当前位置使用这个`View`进行一些绘图，它将完全没有任何效果。然而，我们最终将开始移动这个视图，以便关注玩家需要看到的游戏世界的部分。然后，当我们开始使用一个保持固定的第二个`View`（用于HUD）时，我们将看到这个`View`如何跟踪动作，而另一个保持静态以显示HUD：
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we create a `Clock` to do our timing and a `Time` object called `gameTimeTotal`
    that will keep a running total of the game time that has elapsed. As the project
    progresses we will introduce more variables and objects to handle timing:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Clock`来处理计时和一个名为`gameTimeTotal`的`Time`对象，它将保持游戏经过的总时间。随着项目的进展，我们将引入更多的变量和对象来处理计时：
- en: '[PRE43]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next code declares two vectors. One holding two floats, called `mouseWorldPosition`,
    and one holding two integers, called `mouseScreenPosition`. The mouse pointer
    is something of an anomaly because it exists in two different coordinate spaces.
    You could think of these as parallel universes if you like. First, as the player
    moves around the world we will need to keep track of where the crosshair is in
    that world. These will be floating point coordinates and will be stored in `mouseWorldCoordinates`.
    Of course the actual pixel coordinates of the monitor itself never change. They
    will always be 0,0 to horizontal resolution-1, vertical resolution-1\. We will
    track the mouse pointer position relative to this coordinate space using the integers
    stored in `mouseScreenPosition`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码声明了两个向量。一个包含两个浮点数，名为`mouseWorldPosition`，另一个包含两个整数，名为`mouseScreenPosition`。鼠标指针有点反常，因为它存在于两个不同的坐标空间。如果你愿意，你可以把它们想象成平行宇宙。首先，当玩家在世界中移动时，我们需要跟踪十字准星在世界中的位置。这些将是浮点坐标，并将存储在`mouseWorldCoordinates`中。当然，显示器本身的实际像素坐标永远不会改变。它们将始终是0,0到水平分辨率-1，垂直分辨率-1。我们将使用存储在`mouseScreenPosition`中的整数来跟踪鼠标指针相对于这个坐标空间的位置：
- en: '[PRE44]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we get to use our `Player` class. This line of code will cause the
    constructor function (`Player::Player`) to execute. Refer to `Player.cpp` if you
    want to refresh your memory about this function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们要使用我们的`Player`类。这行代码将导致构造函数（`Player::Player`）执行。如果您想要刷新对这个函数的记忆，请参考`Player.cpp`：
- en: '[PRE45]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This `IntRect` object will hold starting horizontal and vertical coordinates
    as well as a width and a height. Once initialized, we will be able to access the
    size and location details of the current arena with code such as `arena.left`,
    `arena.top`, `arena.width,` and `arena.height`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IntRect`对象将保存起始的水平和垂直坐标以及宽度和高度。一旦初始化，我们将能够通过诸如`arena.left`、`arena.top`、`arena.width`和`arena.height`的代码访问当前竞技场的大小和位置详情：
- en: '[PRE46]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last part of the code that we added previously is, of course, our main
    game loop:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前添加的代码的最后部分当然是我们的主游戏循环：
- en: '[PRE47]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You have probably noticed that the code is getting quite long. Let's talk about
    this inconvenience.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，代码变得相当长了。让我们谈谈这种不便之处。
- en: Managing the code files
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理代码文件
- en: One of the advantages of abstraction using classes and functions is that the
    length (number of lines) of our code files can be reduced. Even though we will
    be using more than a dozen code files for this project, the length of the code
    in `ZombieArena.cpp` will still get a little unwieldy towards the end. In the
    final project, we will look at even more ways to abstract and manage our code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类和函数进行抽象的一个优点是，我们的代码文件的长度（行数）可以减少。尽管我们将在这个项目中使用超过十几个代码文件，但`ZombieArena.cpp`中的代码长度在最后仍然会变得有点难以控制。在最终项目中，我们将探讨更多抽象和管理代码的方法。
- en: 'For now, use this tip to keep things manageable. Notice on the left hand side
    of the code editor in Visual Studio, there are a number of **+** and - signs,
    one of which is shown in this next image:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个提示来保持事情的可管理性。请注意，在Visual Studio的代码编辑器的左侧，有许多**+**和-符号，其中一个显示在下一个图像中：
- en: '![Managing the code files](img/image_06_004.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![管理代码文件](img/image_06_004.jpg)'
- en: There will be one sign for each block (`if`, `while`, `for`, and so on) of the
    code. You can expand and collapse these blocks by clicking on the + and - signs.
    I recommend keeping all the code not currently under discussion, collapsed. This
    will make things much clearer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码块（`if`、`while`、`for`等）都会有一个符号。您可以通过单击+和-符号来展开和折叠这些块。我建议将当前不在讨论中的所有代码都折叠起来。这将使事情变得更清晰。
- en: 'Furthermore, we can create our own collapsible blocks. I suggest making a collapsible
    block out of all the code before the start of the main game loop. To do so, highlight
    the code, **right-click,** and choose **Outlining** | **Hide Selection**, as shown
    in the next image:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以创建自己的可折叠块。我建议将主游戏循环开始之前的所有代码制作成一个可折叠块。为此，选择代码，**右键单击**，然后选择**Outlining**
    | **Hide Selection**，如下图所示：
- en: '![Managing the code files](img/image_06_005.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![管理代码文件](img/image_06_005.jpg)'
- en: 'Now you can click the + and the - sign to expand and contract the block. Each
    time we add code before the main game loop (and that will be quite often) you
    can expand the code, add the new lines, and then collapse it again. This next
    image is what the code looks like when it is collapsed:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以单击+和-符号来展开和收缩块。每次我们在主游戏循环之前添加代码（这将经常发生），您可以展开代码，添加新行，然后再次折叠。当折叠时，代码看起来像下面这张图片：
- en: '![Managing the code files](img/image_06_006.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![管理代码文件](img/image_06_006.jpg)'
- en: This is much more manageable than it was before.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以前更容易管理。
- en: Starting coding the main game loop
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写主游戏循环
- en: As you can see, the last part of the previous code is the game loop, `while
    (window.isOpen()){}`. It is this that we turn our attention to now. Specifically,
    we will be coding the input-handling section of the game loop.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面代码的最后部分是游戏循环，`while (window.isOpen()){}`。现在我们将把注意力转向这一部分。具体来说，我们将编写游戏循环的输入处理部分。
- en: The next code that we will add is quite long. There is nothing complicated about
    it, and we will examine it all in a minute.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的下一个代码非常长。这并不复杂，我们将在一分钟内仔细研究它。
- en: 'Add the highlighted code only, which is shown in the following code, into the
    main game loop:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加下面代码中显示的突出显示的代码到主游戏循环中：
- en: '[PRE48]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the previous code, we instantiate an object of type `Event`. We will use
    `event`, as we did in the Timber!!! project, to poll for system events. To do
    so, we wrap the rest of the code from the previous block in a `while` loop with
    the condition `window.pollEvent(event)`. This will keep looping, for each frame,
    until there are no more events to process.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实例化了一个`Event`类型的对象。我们将使用`event`，就像在Timber!!!项目中一样，来轮询系统事件。为此，我们将前一个块的其余代码放入一个带有条件`window.pollEvent(event)`的`while`循环中。这将在每一帧中保持循环，直到没有更多事件需要处理为止。
- en: Inside this `while` loop, we handle the events we are interested in. First,
    we test for `Event::KeyPressed` events. If the ***Enter*** key is pressed while
    the game is in the `PLAYING` state then we switch `state` to `PAUSED`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`while`循环内，我们处理我们感兴趣的事件。首先，我们测试`Event::KeyPressed`事件。如果在游戏处于`PLAYING`状态时按下***Enter***键，那么我们将`state`切换到`PAUSED`。
- en: If the ***Enter*** key is pressed while the game is in the `PAUSED` state then
    we switch `state` to `PLAYING` and restart `clock`. The reason we restart `clock`
    after switching from `PAUSED` to `PLAYING` is because, while the game is paused,
    the elapsed time still accumulates. If we didn't restart the clock all our objects
    would update their locations as if the frame had just taken a very long time.
    This will become more apparent as we flesh out the rest of the code in this file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在游戏处于`PAUSED`状态时按下***Enter***键，那么我们将`state`切换到`PLAYING`并重新启动`clock`。在从`PAUSED`切换到`PLAYING`后重新启动`clock`的原因是，当游戏暂停时，经过的时间仍然会累积。如果我们不重新启动时钟，那么所有对象会更新它们的位置，就好像帧花了很长时间。随着我们在这个文件中完善其余代码，这一点将变得更加明显。
- en: We then have an `else if` test to see if the *Enter* key was pressed while the
    game was in the `GAME_OVER` state. If it was, then `state` is changed to `LEVELING_UP`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个`else if`测试，看看在`GAME_OVER`状态下是否按下了*Enter*键。如果是的话，那么`state`将被改变为`LEVELING_UP`。
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `GAME_OVER` state is the state where the home screen is displayed.
    So the `GAME_OVER` state is the state after the player has just died and also
    when the player first runs the app. The first thing that the player gets to do
    each game is to pick an attribute to improve (level up).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`GAME_OVER`状态是显示主屏幕的状态。因此，`GAME_OVER`状态是玩家刚刚死亡后以及玩家第一次运行应用程序时的状态。每个游戏中玩家首先要做的事情是选择一个属性来提升（升级）。
- en: In the previous code there is a final `if` condition to test if the state is
    `PLAYING`. This `if` block is empty, and we will add code to it throughout the
    project.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个最终的`if`条件来测试状态是否为`PLAYING`。这个`if`块是空的，我们将在整个项目中添加代码到其中。
- en: Tip
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we will add code to lots of different parts of this file throughout the project,
    it is therefore worthwhile taking time to understand the different states our
    game can be in and where we handle them. It will also be very beneficial to collapse
    and expand the different `if`, `else`, and `while` blocks as and when appropriate.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在整个项目中的许多不同部分添加代码到这个文件，因此值得花时间了解游戏可能处于的不同状态以及我们在哪里处理它们。根据需要，折叠和展开不同的`if`、`else`和`while`块也会非常有益。
- en: Take some time to thoroughly familiarize yourself with the `while`, `if`, and
    `else if` blocks we have just coded. We will be referring back to them regularly.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间彻底熟悉我们刚刚编写的`while`、`if`和`else if`块。我们将经常参考它们。
- en: 'Next, immediately after the previous code and still inside the game loop, still
    dealing with handling input, add this highlighted code. Note the existing code
    (not highlighted) that shows exactly where the new code goes:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在前面的代码之后，仍然在游戏循环内，仍然在处理输入，添加这段突出显示的代码。注意现有的代码（未突出显示）显示了新代码的确切位置：
- en: '[PRE49]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the previous code, we first test to see if the player has pressed the ***Esc***
    key. If it is pressed, the game window will be closed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先测试玩家是否按下了***Esc***键。如果按下，游戏窗口将被关闭。
- en: Next, within one big `if(state == State::PLAYING)` block we check each of the 
    ***W*, *A*, *S*, and *D*** keys in turn. If a key is pressed, we call the appropriate
    `player.move...` function. If it is not, we call the related `player.stop...`
    function.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个大的`if(state == State::PLAYING)`块内，我们依次检查***W*、*A*、*S*和*D***键。如果按下某个键，我们调用相应的`player.move...`函数。如果没有按下，则调用相关的`player.stop...`函数。
- en: This code ensures that, in each and every frame, the player object will be updated
    with exactly which of the ***W*, A**, *S*, *D* keys are pressed and which are
    not. The `player.move...` and `player.stop...` functions store the information
    in the member Boolean variables (`m_LeftPressed`, `m_RightPressed`, `m_UpPressed`
    `,` and `m_DownPressed`). The `Player` class then responds to the value of these
    Booleans, in each frame, in the `player.update` function which we will call in
    the update section of the game loop.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确保在每一帧中，玩家对象将准确更新哪些***W*、A**、*S*、*D*键被按下，哪些没有被按下。`player.move...`和`player.stop...`函数将信息存储在成员布尔变量（`m_LeftPressed`、`m_RightPressed`、`m_UpPressed`、`m_DownPressed`）中。然后`Player`类会根据这些布尔值在每帧中响应`player.update`函数，我们将在游戏循环的更新部分调用它。
- en: 'Now we can handle the keyboard input to enable the player to level up at the
    start of each game and in between each wave. Add and study the following highlighted
    code and we will then discuss it:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理键盘输入，以便玩家在每局游戏开始和每波之间升级。添加并学习下面突出显示的代码，然后我们将讨论它。
- en: '[PRE50]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, which is all wrapped in a test to see if the current
    value of `state` is `LEVELING_UP`, we handle the keyboard keys *1, 2, 3, 4, 5,*
    and *6*. In the `if` block for each, we simply set `state` to `State::PLAYING`.
    We will add code to deal with each level up option later in [Chapter 11](ch11.html
    "Chapter 11. Sound Effects, File I/O, and Finishing the Game"), *Sound Effects,
    File I/O, and Finishing the Game*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，所有代码都包含在一个测试中，以查看`state`的当前值是否为`LEVELING_UP`，我们处理键盘键*1、2、3、4、5*和*6*。在每个`if`块中，我们只需将`state`设置为`State::PLAYING`。我们将在[第11章](ch11.html
    "第11章。音效、文件I/O和完成游戏")*音效、文件I/O和完成游戏*中稍后添加处理每个升级选项的代码。
- en: 'What this code does is this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是：
- en: If the `state` is `LEVELING_UP`, wait for either the *1, 2, 3, 4, 5* or *6*
    key to be pressed.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`state`是`LEVELING_UP`，等待按下*1、2、3、4、5*或*6*键。
- en: When pressed, change `state` to `PLAYING`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下时，将`state`更改为`PLAYING`。
- en: When the state changes, still within the `if (state == State::LEVELING_UP)`
    block, the nested `if(state == State::PLAYING)` block will run.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当状态改变时，在`if (state == State::LEVELING_UP)`块内，嵌套的`if(state == State::PLAYING)`块将运行。
- en: Within this block, we set the location and size of `arena`, the `tileSize` to
    `50`, pass all the information in to `player.spawn,` and restart `clock`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此块中，我们设置`arena`的位置和大小，`tileSize`为`50`，将所有信息传递给`player.spawn`，并重新启动`clock`。
- en: Now we have an actual spawned player object that is aware of its environment
    and can respond to key presses. We can now update the scene on each pass through
    the loop.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个真正的生成的玩家对象，它知道自己的环境并可以响应按键。我们现在可以在每次循环中更新场景。
- en: 'Be sure to neatly collapse the code from the input handling part of the game
    loop as we are done with that, for now. The next code is in the update part of
    the game loop. Add and study the highlighted code and then we can discuss it:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将游戏循环的输入处理部分的代码整理好，因为我们现在已经完成了。接下来的代码在游戏循环的更新部分。添加并学习下面突出显示的代码，然后我们可以讨论它：
- en: '[PRE51]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First note that all the previous code is wrapped in a test to make sure the
    game is in the `PLAYING` state. We don't want this code to run if the game is
    paused, over, or if the player is choosing what to level up.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意，所有先前的代码都包含在一个测试中，以确保游戏处于`PLAYING`状态。如果游戏暂停、结束或玩家正在选择升级，我们不希望这段代码运行。
- en: 'First, we restart the clock and store the time that the previous frame took
    in the `dt` variable:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重新启动时钟，并将上一帧所用的时间存储在`dt`变量中：
- en: '[PRE52]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we add the time that the previous frame took onto the accumulated time
    the game has been running for, as held by `gameTimeTotal`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将上一帧所用的时间添加到游戏已运行的累积时间`gameTimeTotal`中：
- en: '[PRE53]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we initialize a `float` called `dtAsSeconds` with the value returned by
    the `dt.AsSeconds` function. For most frames this will be a fraction of one. This
    is perfect for passing into the `player.update` function to be used to calculate
    how much to move the player sprite.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`dt.AsSeconds`函数返回的值初始化一个名为`dtAsSeconds`的`float`。对于大多数帧，这将是一个小数。这非常适合传递给`player.update`函数，用于计算玩家精灵的移动量。
- en: Now we can initialize `mouseScreenPosition` using the function `MOUSE::getPosition`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`MOUSE::getPosition`函数初始化`mouseScreenPosition`。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering about the slightly unusual syntax for getting the position
    of the mouse? This is called a **static function**. If we define a function in
    a class with the static keyword, we are able to call that function using the class
    name and without an instance of the class. C++ OOP has loads of quirks and rules
    like this. We will see many more as we progress.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对获取鼠标位置的略微不寻常的语法感到好奇？这被称为**静态函数**。如果我们在一个类中用`static`关键字定义一个函数，我们可以使用类名调用该函数，而无需类的实例。C++面向对象编程有很多这样的怪癖和规则。随着我们的学习，我们会看到更多。
- en: We then initialize `mouseWorldPosition` using the SFML `mapPixelToCoords` function
    on `window`. We discussed this function when talking about the `View` class earlier
    in the chapter.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用SFML的`mapPixelToCoords`函数在`window`上初始化`mouseWorldPosition`。我们在本章前面讨论了这个函数时，正在讨论`View`类。
- en: At this point, we are now able to call `player.update` and pass in `dtAsSeconds`
    and the position of the mouse, as is required.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们现在可以调用`player.update`并传入`dtAsSeconds`和鼠标的位置，这是必需的。
- en: We store the player's new center in a `Vector2f` called `playerPosition`. At
    the moment, this is unused, but we will have a use for this later in the project.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将玩家的新中心存储在名为`playerPosition`的`Vector2f`中。目前，这是未使用的，但在项目的后期我们会用到它。
- en: We can then center the view around the center of the players up-to-date position
    with the code, `mainView.setCenter(player.getCenter())`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用代码`mainView.setCenter(player.getCenter())`将视图居中于玩家最新位置的中心。
- en: 'We are now in a position to draw the player to the screen. Add this highlighted
    code which splits the draw section of the main game loop into different states:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将玩家绘制到屏幕上。添加这个突出显示的代码，将主游戏循环的绘制部分分成不同的状态：
- en: '[PRE54]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Within the `if(state == State::PLAYING)` section of the previous code, we clear
    the screen, set the view of the window to `mainView`, and then draw the player
    sprite with `window.draw(player.getSprite())`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`if(state == State::PLAYING)`部分，我们清除屏幕，将窗口视图设置为`mainView`，然后用`window.draw(player.getSprite())`绘制玩家精灵。
- en: After all the different states have been handled, the code shows the scene in
    the usual manner with `window.display();`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有不同的状态之后，代码以通常的方式显示场景，使用`window.display();`。
- en: You can run the game and see our player character spin around in response to
    moving the mouse.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏，看到我们的玩家角色在响应鼠标移动时旋转。
- en: Tip
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you run the game, you need to press *Enter* to start the game and then
    a number from *1* to *6* to simulate choosing an upgrade option. Then the game
    will start.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行游戏时，您需要按*Enter*来开始游戏，然后输入*1*到*6*之间的数字来模拟选择升级选项。然后游戏将开始。
- en: 'You can also move the player around within the (empty) 500 x 500 pixel arena.
    You can see our lonely player in the center of the screen, as shown next:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在（空的）500 x 500像素的竞技场内移动玩家。您可以在屏幕中央看到我们孤独的玩家，如下所示：
- en: '![Starting coding the main game loop](img/image_06_007.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![开始编写主游戏循环](img/image_06_007.jpg)'
- en: You can't, however, get any sense of movement because we haven't implemented
    the background. We will do so in the next chapter.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您无法感受到任何移动，因为我们还没有实现背景。我们将在下一章中实现。
- en: FAQ
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I notice we have coded quite a few functions of the `Player` class that we
    don't use.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 问题）我注意到我们已经编写了许多`Player`类的函数，但我们并没有使用。
- en: A) Rather than keep coming back to the `Player` class, we have added the entire
    code that we will need throughout the project. By the end of [Chapter 11](ch11.html
    "Chapter 11. Sound Effects, File I/O, and Finishing the Game"), *Sound Effects,
    File I/O, and Finishing the Game,* we will have made full use of all the functions.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 答案）我们不再需要不断返回`Player`类，我们已经添加了整个代码，这是我们在整个项目中需要的。到[第11章](ch11.html "第11章。音效，文件I/O和完成游戏")结束时，*音效，文件I/O和完成游戏*，我们将充分利用所有这些功能。
- en: Q) I have learnt other languages and OOP seems much simpler in C++.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 问题）我学过其他语言，C++中的OOP看起来简单得多。
- en: A) This was an introduction to OOP and its basic fundamentals. There is more
    to it than this. We will learn more OOP concepts and details throughout the book.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 答案）这是面向对象编程及其基本原理的介绍。它不仅仅是这样。我们将在整本书中学习更多面向对象编程的概念和细节。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Phew! That was a long one. We have learned a lot in this chapter. We have discovered
    the basics of OOP, including how to use encapsulation to control how code outside
    of our classes can access the member variables. We built our first real class,
    `Player`, and put it to use in the start of what will become our new game, Zombie
    Arena.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这是一个漫长的过程。在本章中，我们学到了很多。我们发现了面向对象编程的基础知识，包括如何使用封装来控制类外部代码如何访问成员变量。我们建立了我们的第一个真正的类`Player`，并在即将成为我们新游戏Zombie
    Arena的开始中使用了它。
- en: Don't concern yourself too much if some of the details around OOP and classes
    are not entirely clear. The reason I say this is because we will spend the rest
    of the book making classes, and the more we use them the clearer they will become.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果围绕OOP和类的一些细节不是很清楚，不要太担心。我这么说的原因是因为我们将在本书的剩余部分中制作类，我们使用它们越多，它们就会变得越清晰。
- en: In the next chapter, we will build our arena background by exploring what sprite
    sheets are. We will also learn about C++ references that allow us to manipulate
    variables, even when they are out of scope (in another function).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索精灵表来构建我们的竞技场背景。我们还将学习C++引用，它允许我们操纵变量，即使它们超出了范围（在另一个函数中）。
