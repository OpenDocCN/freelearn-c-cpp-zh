- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Working with Open Asset Import Library
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Open Asset Import Library进行工作
- en: 'Welcome to *Mastering C++ Game Animations*! Are you the kind of person who
    looks at the animated models in a computer or console game, or a 3D animation
    tool, and asks yourself questions like:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到《精通C++游戏动画》！你是一个那种看着电脑或控制台游戏中的动画模型，或者3D动画工具，并对自己提出问题的人吗？
- en: How does this work? How do they do this? Could I do this myself, too?
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是怎么工作的？他们是怎么做到的？我自己也能做到吗？
- en: If so, this book will take you in the right direction to achieving this. In
    the next 14 chapters, you will learn how to create your own little game character
    model viewer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，这本书将指引你走向实现这一目标的方向。在接下来的14章中，你将学习如何创建自己的小游戏角色模型查看器。
- en: The book starts with loading a file using Open Asset Import Library, converting
    the data structures from the importer library into more efficient data structures
    for rendering, and rendering the character model with a simple OpenGL or Vulkan
    renderer. You will also learn how to optimize data updates and rendering by relocating
    computational load to the GPU in the form of GPU-based lookup tables and compute
    shaders.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从使用Open Asset Import Library加载文件开始，将导入库中的数据结构转换为更高效的渲染数据结构，并使用简单的OpenGL或Vulkan渲染器渲染角色模型。你还将学习如何通过将计算负载转移到GPU上的基于GPU的查找表和计算着色器来优化数据更新和渲染。
- en: For the character animations, you will not only dive into normal animation blending
    but also be introduced to state-based animation control, additive animation blending
    to move the head independently of the rest of the body, and facial animations.
    You will also learn how to control the behavior of the instances by using a simplified
    version of behavior trees and implement interaction between the instances on the
    screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角色动画，你不仅将深入了解正常的动画混合，还将介绍基于状态的动画控制、添加动画混合以独立于身体其他部分移动头部，以及面部动画。你还将学习如何使用简化版的行为树来控制实例的行为，并在屏幕上的实例之间实现交互。
- en: To give a proper home to the game characters, you will learn how to load a game
    map into the application. Moving around in the game map will be enhanced by adding
    collision detection, inverse kinematics for the character feet, and simple navigation
    to let the instances run around fully on their own in the virtual world.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给游戏角色一个合适的家园，你将学习如何将游戏地图加载到应用程序中。在游戏地图中移动将通过添加碰撞检测、角色脚部的逆运动学以及简单的导航来增强，让实例能够在虚拟世界中完全自主地四处移动。
- en: In addition to the animations, features such as interactive selection by using
    the mouse, saving and loading the configuration to a file to allow working on
    larger virtual worlds, and handling different cameras in the virtual world are
    introduced. Also, a graphical, node-based configuration will be implemented, enabling
    you to change the behavior of the instances in a non-programming way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动画之外，还介绍了使用鼠标进行交互式选择、将配置保存到文件以允许在更大的虚拟世界中工作，以及处理虚拟世界中的不同摄像头等功能。此外，还将实现基于图形的、基于节点的配置，使你能够以非编程的方式更改实例的行为。
- en: With all these steps combined, your virtual characters in the virtual world
    will come closer to real game characters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合所有这些步骤，你虚拟世界中的虚拟角色将更接近真实的游戏角色。
- en: Join our community on Discord
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: '![](img/QR_code_Discord.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_code_Discord.png)'
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)。
- en: Every journey starts with the first step, so welcome to *Chapter 1*! This chapter
    will set the foundation for the animation application, as you will get an insight
    into how to load a model file from your computer into the program, position the
    instance in the vast emptiness of the virtual world, and play the animations that
    are included in the file. By the end of this chapter, your game character model
    will be able to jump, run, or walk on the screen, maybe surrounded by non-animated
    models or other static objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每一次旅程都始于第一步，所以欢迎来到第一章！本章将为动画应用程序奠定基础，因为你将了解如何将模型文件从你的电脑加载到程序中，在虚拟世界的浩瀚空虚中定位实例，并播放文件中包含的动画。到本章结束时，你的游戏角色模型将能够在屏幕上跳跃、奔跑或行走，可能周围围绕着非动画模型或其他静态对象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Animating game characters – a primer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏角色动画——入门
- en: What is Open Asset Import Library?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Open Asset Import Library 是什么？
- en: Loading a model file
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模型文件
- en: Extending the UI with an Open File dialog
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Open File 对话框扩展 UI
- en: Adding and removing model instances dynamically
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态添加和删除模型实例
- en: As we will use open source software and platform-independent libraries in this
    book, you should be able to compile and run the code “out of the box” on Windows
    and Linux. You will find a detailed list of the required software and libraries,
    plus their installation, in the following *Technical requirements* section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书将使用开源软件和平台无关的库，因此您应该能够在 Windows 和 Linux 上“即开即用”地编译和运行代码。您将在以下 *技术要求* 部分找到所需软件和库的详细列表，以及它们的安装说明。
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: A PC with Windows or Linux, and the tools listed later in this section
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 Windows 或 Linux 的 PC，以及本节后面列出的工具
- en: Git for source-code management
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 用于源代码管理
- en: A text editor (such as Notepad++ or Kate) or a full IDE (such as Visual Studio
    2022 for Windows, or Eclipse/KDevelop for Linux)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器（如 Notepad++ 或 Kate）或完整的 IDE（如 Windows 的 Visual Studio 2022 或 Linux 的 Eclipse/KDevelop）
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A recent C++ compiler is required to compile the code. In the current CMake
    build system, C++17 is configured, but the code is known to work with newer C++
    standards, up to and including C++26 (although the compiler must support those
    standards).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码需要最近版本的 C++ 编译器。在当前的 CMake 构建系统中，已配置为 C++17，但已知代码可以与更新的 C++ 标准兼容，包括但不限于
    C++26（尽管编译器必须支持这些标准）。
- en: Now, let’s get the source code for this book and start unpacking the code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取这本书的源代码并开始解压代码。
- en: Getting the source code and the basic tools
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源代码和基本工具
- en: 'The code for this book is hosted on GitHub, which you can find here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码托管在 GitHub 上，您可以通过以下链接找到：
- en: '[https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming)'
- en: You need to install Git since the build system utilizes Git to download the
    third-party projects used in the examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建系统使用 Git 下载示例中使用的第三方项目，因此您需要安装 Git。
- en: 'On Linux systems, use your package manager. For Ubuntu, the following line
    installs Git:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，使用您的包管理器。对于 Ubuntu，以下行安装 Git：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Windows, you can download Git here: [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，您可以从这里下载 Git：[https://git-scm.com/downloads](https://git-scm.com/downloads)。
- en: To unpack the code, you can use any of the following two methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压代码，您可以使用以下两种方法中的任何一种。
- en: Getting the code using Git
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Git 获取代码
- en: To get the code in the book, you should use Git. Using Git offers you additional
    features, such as creating a local branch for your changes, keeping track of your
    progress, and comparing your updates to the example code. Also, you can easily
    revert changes if you have broken the code during the exploration of the source
    code, or while working on the practical sessions at the end of each chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取书中的代码，您应该使用 Git。使用 Git 可以为您提供额外的功能，例如为您的更改创建本地分支，跟踪您的进度，并将您的更新与示例代码进行比较。此外，如果您在探索源代码或在实际章节末尾的实践环节中破坏了代码，您可以轻松地撤销更改。
- en: 'You can get a local checkout of the code in a specific location on your system
    either through the Git GUI, by cloning the repository in Visual Studio 2022, or
    by executing the following command in a CMD:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 Git GUI、在 Visual Studio 2022 中克隆存储库或在 CMD 中执行以下命令来在系统中的特定位置获取代码的本地签出：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please make sure that you use a path without spaces or special characters such
    as umlauts as this might confuse some compilers and development environments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您使用没有空格或特殊字符（如重音符号）的路径，因为这可能会使某些编译器和开发环境产生混淆。
- en: Getting the code as a ZIP file
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以 ZIP 文件形式获取代码
- en: Although Git is recommended, you can also download the code as a ZIP file from
    GitHub. You will need to unpack the ZIP file to a location of your choice on your
    system. Also, make sure that the path the ZIP file is unpacked to contains no
    spaces or special characters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然推荐使用 Git，但您也可以从 GitHub 下载代码的 ZIP 文件。您需要将 ZIP 文件解压到系统上的某个位置。此外，请确保解压 ZIP 文件的路径中不包含空格或特殊字符。
- en: Before we can use the code from the book, some tools and libraries must be installed.
    We will start with the Windows installation, followed by the Linux installation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用书中的代码之前，必须安装一些工具和库。我们将从 Windows 安装开始，然后是 Linux 安装。
- en: Installing the required tools and libraries for Windows
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Windows 所需的工具和库
- en: To compile the example code on a Windows machine, I recommend using Visual Studio
    2022 as the IDE since it contains all you need for a quick start. Using other
    IDEs like Eclipse, Rider, or KDevelop is no problem as the build is managed by
    CMake, but you may need to install a C++ compiler like MSYS2 plus the compiler
    packages as an additional dependency.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 机器上编译示例代码，我建议使用 Visual Studio 2022 作为 IDE，因为它包含了快速开始所需的所有内容。使用其他
    IDE，如 Eclipse、Rider 或 KDevelop，也没有问题，因为构建由 CMake 管理，但您可能需要安装一个 C++ 编译器，如 MSYS2，以及编译器包作为附加依赖项。
- en: Installing Visual Studio 2022 on Windows
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Visual Studio 2022
- en: If you want to use Visual Studio for the example files and don’t have it installed
    yet, download the free Community Edition of Visual Studio at [https://visualstudio.microsoft.com/de/downloads/](https://visualstudio.microsoft.com/de/downloads/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 Visual Studio 处理示例文件但尚未安装，请从 [https://visualstudio.microsoft.com/de/downloads/](https://visualstudio.microsoft.com/de/downloads/)
    下载免费的 Visual Studio 社区版。
- en: 'Then, follow these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下步骤操作：
- en: 'Choose the **Desktop development with C++** option so that the C++ compiler
    and the other required tools are installed on your machine:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**使用 C++ 进行桌面开发**选项，以便将 C++ 编译器和其他所需工具安装到您的计算机上：
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B22428_01_01.png)'
- en: 'Figure 1.1: Installing the C++ desktop development in Visual Studio 2022'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：在 Visual Studio 2022 中安装 C++ 桌面开发
- en: 'Then, under **Individual components**, also check the **C++ CMake tools for
    Windows** option:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**单独的组件**下，也勾选**C++ CMake 工具为 Windows**选项：
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  自动生成的描述](img/B22428_01_02.png)'
- en: 'Figure 1.2: Check the box for CMake tools for Windows to be installed in Visual
    Studio 2022'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：勾选 CMake 工具为 Windows 安装在 Visual Studio 2022 中的复选框
- en: Finish the installation of Visual Studio, start it, and skip the initial project
    selection screen.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成Visual Studio的安装，启动它，并跳过初始项目选择屏幕。
- en: Enabling long path names on Windows
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上启用长路径名
- en: When using a fresh installation of Windows 10 or 11, the maximum path length
    for files is 260 characters. Depending on the location of the folder containing
    the code for the book, Visual Studio 2022 might run into errors caused by paths
    for temporary build folders exceeding the 260 characters limit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Windows 10 或 11 的全新安装时，文件的路径最大长度为 260 个字符。根据包含本书代码的文件夹位置，Visual Studio 2022
    可能会遇到由于临时构建文件夹路径超过 260 个字符限制而导致的错误。
- en: 'To enable long path names, the **Windows Registry** needs to be adjusted. A
    simple way is to create a text file with the `.reg` extension, for instance, `long-paths.reg`,
    and copy the following content to the file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用长路径名，需要调整**Windows 注册表**。一种简单的方法是创建一个具有 `.reg` 扩展名的文本文件，例如，`long-paths.reg`，并将以下内容复制到文件中：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A double-click on the file will automatically start the **Windows Registry Editor**
    to import the settings to the Windows Registry. After confirming both the **UAC**
    dialog and the following warning dialogs by clicking **Yes**, the Registry Editor
    will import the new settings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 双击文件将自动启动**Windows 注册表编辑器**以将设置导入 Windows 注册表。通过单击**是**确认**UAC**对话框和以下警告对话框后，注册表编辑器将导入新设置。
- en: Now, reboot the PC to activate the long path names and continue with the installations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动计算机以激活长路径名并继续安装。
- en: Downloading Open Asset Import Library
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载 Open Asset Import Library
- en: 'For Windows, Open Asset Import Library must be built and installed from the
    source files. Clone the repository from [https://github.com/assimp/assimp](https://github.com/assimp/assimp)
    in a new Visual Studio 2022 project, as shown in *Figure 1.3*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，Open Asset Import Library 必须从源文件构建和安装。如*图 1.3*所示，从 [https://github.com/assimp/assimp](https://github.com/assimp/assimp)
    克隆仓库到一个新的 Visual Studio 2022 项目中：
- en: '![](img/B22428_01_03.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_03.png)'
- en: 'Figure 1.3: Cloning the asset importer GitHub repository within Visual Studio
    2022'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：在 Visual Studio 2022 中克隆资产导入 GitHub 仓库
- en: 'As an alternative, you can create a clone from a Git Bash, or via the Git GUI:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，您可以从 Git Bash 或通过 Git GUI 创建克隆：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Configuring the build
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置构建
- en: We need to make a few adjustments to create a static library instead of a dynamic
    library. Using a static library makes the build process easier for us, as we don’t
    have to worry about an additional DLL file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些调整来创建静态库而不是动态库。使用静态库使我们的构建过程更容易，因为我们不需要担心额外的 DLL 文件。
- en: 'To change the CMake settings, choose the following option after right-clicking
    on the `CMakeLists.txt` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 CMake 设置，在 `CMakeLists.txt` 文件上右键单击后选择以下选项：
- en: '![](img/B22428_01_04.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_04.png)'
- en: 'Figure 1.4: Changing the CMake settings for the asset importer'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：更改资产导入器的 CMake 设置
- en: 'In the **Configuration** tab of Visual Studio 2022 that appears, change the
    configuration name to `x64-RelWithDebInfo`, and change the configuration type
    to `RelWithDebInfo`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的 Visual Studio 2022 的 **配置** 选项卡中，将配置名称更改为 `x64-RelWithDebInfo`，并将配置类型更改为
    `RelWithDebInfo`：
- en: '![](img/B22428_01_05.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_05.png)'
- en: 'Figure 1.5: Modifying the current configuration of the asset importer'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：修改资产导入器的当前配置
- en: By using `RelWithDebInfo`, a release version with debug information will be
    created. The resulting executable will be optimized by the compiler, but the file
    still contains data to allow debugging the program in case of problems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RelWithDebInfo`，将创建一个带有调试信息的发布版本。编译器将优化生成的可执行文件，但文件仍然包含数据，以便在出现问题时允许调试程序。
- en: 'Next, change the following settings in the CMake settings. You can use the
    search field on the bottom left, named **Filter variables...**, to search for
    the specified setting:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 CMake 设置中更改以下设置。您可以使用左下角的搜索字段，命名为 **Filter variables...**，来搜索指定的设置：
- en: 'Disable building a shared library:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用构建共享库：
- en: '![](img/B22428_01_06.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_06.png)'
- en: 'Figure 1.6: Switching the setting to create a static library'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：切换设置以创建静态库
- en: 'Change the linking of the C runtime:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改 C 运行时的链接：
- en: '![](img/B22428_01_07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_07.png)'
- en: 'Figure 1.7: Linking the C runtime statically'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：静态链接 C 运行时
- en: 'Remove the library suffix to create a file name without the compiler version:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除库后缀以创建不带编译器版本的文件名：
- en: '![](img/B22428_01_08.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_08.png)'
- en: 'Figure 1.8: Removing the suffix of the created file'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：移除创建的文件的后缀
- en: Next, select **Build** and then **Install** in the context menu of the `CMakeLists.txt`
    file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `CMakeLists.txt` 文件的上下文菜单中选择 **Build** 和 **Install**。
- en: 'After the installation is finished, the following folder structure will be
    generated:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，将生成以下文件夹结构：
- en: '![](img/B22428_01_09.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_09.png)'
- en: 'Figure 1.9: Asset importer library and includes'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：资产导入器库和包含文件
- en: We have to make all the files discussed in this section available for all examples
    in the book. To do this, two options are available – copy the files to a fixed
    path or add an environment variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使本节中讨论的所有文件对书中的所有示例都可用。为此，有两种选择 - 将文件复制到固定路径或添加环境变量。
- en: Copying the Assimp files
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制 Assimp 文件
- en: 'First, create this folder on your computer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的计算机上创建此文件夹：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, copy the two folders `lib` and `include` into it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将两个文件夹 `lib` 和 `include` 复制进去：
- en: '![](img/B22428_01_10.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_10.png)'
- en: 'Figure 1.10: The two folders have been copied to the Program Files folder'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：两个文件夹已复制到 Program Files 文件夹
- en: The CMake search script for Assimp will try to find the static library and the
    header files in this folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 搜索脚本将尝试在此文件夹中查找 Assimp 的静态库和头文件。
- en: Adding an environment variable to help CMake find the files
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加环境变量以帮助 CMake 查找文件
- en: 'As an alternative solution, you can create a folder on your PC wherever you
    want, for instance, to `D:\assimp`. Then, copy the folders `lib` and `include`
    into the folder and set the environment variable **ASSIMP_ROOT** to the location
    of the created folder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种解决方案，您可以在您的 PC 上创建一个文件夹，例如，到 `D:\assimp`。然后，将文件夹 `lib` 和 `include` 复制到该文件夹中，并将环境变量
    **ASSIMP_ROOT** 设置为创建的文件夹位置：
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_11.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B22428_01_11.png)'
- en: 'Figure 1.11: The environment variable ASSIMP_ROOT pointing to a folder on the
    PC'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：环境变量 ASSIMP_ROOT 指向 PC 上的文件夹
- en: '*Please remember that you have to restart Visual Studio 2022 after setting
    the environment variable.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，您必须在设置环境变量后重新启动 Visual Studio 2022。*'
- en: Installing the Vulkan SDK on Windows
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Vulkan SDK
- en: 'For Vulkan support, you also need to have the Vulkan SDK installed. Get it
    here: [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan支持，你还需要安装Vulkan SDK。在此处获取：[https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home)。
- en: 'Do a default installation, and make sure to add **GLM headers.** and **Vulkan
    Memory Allocator header.**, as the CMake search scripts will use them if the Vulkan
    SDK is installed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进行默认安装，并确保添加 **GLM头文件** 和 **Vulkan内存分配器头文件**，因为如果安装了Vulkan SDK，CMake搜索脚本将使用它们：
- en: '![](img/B22428_01_12.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_01_12.png)'
- en: 'Figure 1.12: Adding GLM and VMA during Vulkan SDK installation'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：在Vulkan SDK安装过程中添加GLM和VMA
- en: Make sure to restart Visual Studio 2022 after installing the Vulkan SDK to allow
    detecting the Vulkan SDK header files and environment variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Vulkan SDK后，请确保重启Visual Studio 2022，以便检测Vulkan SDK头文件和环境变量。
- en: Compiling and starting the example code
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和启动示例代码
- en: 'Running the examples can be done in two different ways: following the book
    example by example or compiling all the code at once to browse all the examples.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例可以通过两种不同的方式完成：按照书中的示例逐个进行，或者一次性编译所有代码以浏览所有示例。
- en: 'Compiling the code can be done using the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤编译代码：
- en: 'To open an example project, choose **Open a local folder** from the Visual
    Studio 2022 start screen or **Open CMake** from the **File** menu of Visual Studio
    2022, then navigate to the folder with the example code you want to compile, or
    to the top-level folder of the example code if you want to compile all examples
    at once. Visual Studio will automatically detect and configure CMake in the selected
    folder for you. The last line of the output window should be as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开示例项目，从Visual Studio 2022的启动屏幕中选择**打开本地文件夹**，或从Visual Studio 2022的**文件**菜单中选择**打开CMake**，然后导航到要编译的示例代码所在的文件夹，或者如果您想一次性编译所有示例，则导航到示例代码的顶级文件夹。Visual
    Studio将自动检测并为您配置所选文件夹中的CMake。输出窗口的最后一行应如下所示：
- en: '[PRE5]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This confirms the successful run of the CMake file generation.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这确认了CMake文件生成的成功运行。
- en: 'Now, set the startup item by right-clicking on the `CMakeLists.txt` file –
    this step is required to build and run the project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过右键单击`CMakeLists.txt`文件设置启动项——这一步是构建和运行项目所必需的：
- en: '![](img/B22428_01_13.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_01_13.png)'
- en: 'Figure 1.13: Configuring the startup item in Visual Studio 2022'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：在 Visual Studio 2022 中配置启动项
- en: 'After setting the startup item, we can build the current project. Right-click
    on the `CMakeLists.txt` file and choose **Build**:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置启动项后，我们可以构建当前项目。右键单击`CMakeLists.txt`文件并选择**构建**：
- en: '![](img/B22428_01_14.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_01_14.png)'
- en: 'Figure 1.14: Build the project in Visual Studio 2022'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：在 Visual Studio 2022 中构建项目
- en: 'After the compilation succeeds, start the program in a non-debug build by using
    the unfilled green arrow:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译成功后，使用未填充的绿色箭头以非调试构建启动程序：
- en: '![](img/B22428_01_15.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_01_15.png)'
- en: 'Figure 1.15: Start the compiled program without debugging in Visual Studio
    2022'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15：在 Visual Studio 2022 中启动编译后的程序，不进行调试
- en: If you are a Linux user, you can follow the explanation in the following section
    to get all the tools and libraries onto your system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名Linux用户，你可以按照以下章节的解释将所有工具和库安装到你的系统上。
- en: Installing the required tools and libraries for Linux
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Linux安装所需的工具和库
- en: Modern Linux distributions already contain most of the tools needed to compile
    the example code for the book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux发行版已经包含了编译本书示例代码所需的大部分工具。
- en: Downloading Open Asset Import Library
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载Open Asset Import Library
- en: 'For the common Linux distributions, Assimp should be available from the package
    manager. For Ubuntu, you need to install the Assimp development package:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见的Linux发行版，Assimp应该可以从包管理器中获取。对于Ubuntu，你需要安装Assimp开发包：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing a C++ compiler and the required libraries on Linux
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 C++ 编译器和所需的库
- en: 'If you use Ubuntu Linux, all required dependencies can be installed by using
    the integrated package manager. Use this command to install the packages for the
    OpenGL-based examples:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Ubuntu Linux，所有必需的依赖项都可以通过集成包管理器安装。使用此命令安装基于OpenGL的示例的包：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To use Clang as a compiler, instead of GCC, you can use this command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Clang作为编译器而不是GCC，可以使用此命令：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you plan to build the Vulkan examples, these additional packages are required
    and should be installed to get the most out of the Vulkan code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建Vulkan示例，则需要这些额外的包，并且应该安装它们以充分利用Vulkan代码：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to use the latest Vulkan SDK instead of the Ubuntu version, you
    can download the package from the **LunarG** website:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用最新的 Vulkan SDK 而不是 Ubuntu 版本，可以从 **LunarG** 网站下载该包：
- en: '[https://vulkan.lunarg.com/sdk/home#linux](https://vulkan.lunarg.com/sdk/home#linux)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://vulkan.lunarg.com/sdk/home#linux](https://vulkan.lunarg.com/sdk/home#linux)'
- en: 'For other Linux distributions, the package manager and the names of the packages
    may differ. For instance, on an Arch-based system, this command line will install
    all required packages to build the OpenGL examples:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他 Linux 发行版，包管理器和包的名称可能不同。例如，在基于 Arch 的系统上，以下命令行将安装构建 OpenGL 示例所需的所有包：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the Vulkan examples, these additional packages are required on Arch-based
    installations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan 示例，在基于 Arch 的安装上还需要以下额外的包：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compiling the examples via the command line on Linux
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上通过命令行编译示例
- en: 'The examples can be compiled directly on the command line, without using an
    IDE or editor. To build a single example, change into the chapter and example
    subfolders of the folder containing the cloned repository, create a new subfolder
    named `build`, and change into the new subfolder:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例可以直接在命令行编译，无需使用 IDE 或编辑器。要构建单个示例，切换到包含克隆仓库的文件夹的章节和示例子文件夹，创建一个名为 `build` 的新子文件夹，并切换到新子文件夹：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To compile all examples at once, create the `build` folder in the top-level
    folder of the example code and then change into the new subfolder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性编译所有示例，请在示例代码的顶级文件夹中创建一个 `build` 文件夹，然后切换到新的子文件夹。
- en: 'Then, run CMake to create the files required to build the code with the `ninja`
    build tool:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 CMake 以创建使用 `ninja` 构建工具构建代码所需的文件：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The two dots at the end are needed; CMake needs the path to the `CMakeLists.txt`
    file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的两个点是需要保留的；CMake 需要指向 `CMakeLists.txt` 文件的路径。
- en: 'If you build a single example, let `ninja` compile the code and run the generated
    executable file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建单个示例，让 `ninja` 编译代码并运行生成的可执行文件：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If all the required tools and libraries are installed and the compilation is
    successful, an application window should open.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有必需的工具和库都已安装且编译成功，应该会打开一个应用程序窗口。
- en: When building all examples at once, a new folder named `bin` will be created
    inside the top-level folder, containing a subfolder for every chapter and in every
    chapter’s folder the two subfolders for the two examples of that chapter, similar
    to the source-code structures.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性构建所有示例时，在顶级文件夹内将创建一个名为 `bin` 的新文件夹，其中包含每个章节的子文件夹，每个章节的文件夹中包含该章节的两个示例的子文件夹，类似于源代码结构。
- en: In case of build errors, you need to check the requirements again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现构建错误，您需要再次检查需求。
- en: If you want to use an IDE, you can continue with the installation of Eclipse.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 IDE，可以继续安装 Eclipse。
- en: Installing Eclipse on Linux
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Eclipse
- en: 'If you want to compile the example code with the Eclipse IDE on Linux, some
    extra steps are required:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Linux 上的 Eclipse IDE 中编译示例代码，需要执行一些额外的步骤：
- en: Download and install **Eclipse IDE for C/C++ Developers** from [https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/)
    下载并安装 **Eclipse IDE for C/C++ Developers**。
- en: 'After installing Eclipse, head to the marketplace under **Help**:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Eclipse 后，转到 **帮助** 下的市场：
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_16.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B22428_01_16.png)'
- en: 'Figure 1.16: Accessing the Eclipse marketplace'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：访问 Eclipse 市场place
- en: 'Install the **cmake4eclipse** and **CMake Editor** packages. The first one
    enables CMake support in Eclipse, with all the features we need, and the second
    one adds syntax coloring to the CMake files. The extra colors make it more convenient
    to edit the files:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **cmake4eclipse** 和 **CMake 编辑器** 包。第一个包在 Eclipse 中启用 CMake 支持，包含我们需要的所有功能，第二个包为
    CMake 文件添加语法高亮。额外的颜色使得编辑文件更加方便：
- en: '![](img/B22428_01_17.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_17.png)'
- en: 'Figure 1.17: Installing the CMake Editor and cmake4eclipse'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17：安装 CMake 编辑器和 cmake4eclipse
- en: 'Compiling and starting the example code can be done in the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和启动示例代码可以按照以下步骤进行：
- en: Select **Open Project from File System** from the **File** menu.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **文件** 菜单中选择 **从文件系统打开项目**。
- en: 'Choose **Directory...** and navigate to the folder with the source code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **目录...** 并导航到包含源代码的文件夹：
- en: If you want to build all examples at once, select the top-level source folder,
    press **Deselect All**, and select only the first project.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要一次性构建所有示例，请选择顶级源文件夹，按下**取消选择所有**，然后仅选择第一个项目。
- en: To build only a single example, you can either use **Deselect All** on the top-level
    folder and select only the example you want to build, or you can descend into
    the folder for the specific example.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想构建单个示例，你可以要么在顶级文件夹中使用**取消选择所有**并仅选择你想要构建的示例，要么进入特定示例的文件夹。
- en: Click on **Finish** to open the project.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**以打开项目。
- en: Next, choose **Build Project** from the context of the project folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从项目文件夹的上下文中选择**构建项目**。
- en: 'You may need to switch the console output to show the current build messages.
    Use the small arrow with the tooltip **Display Selected Console**:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要切换控制台输出以显示当前的构建消息。使用带有工具提示**显示所选控制台**的小箭头：
- en: '![](img/B22428_01_18.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_18.png)'
- en: 'Figure 1.18: Selecting the right output to see the build messages'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：选择正确的输出以查看构建消息
- en: If Eclipse does not refresh the project content after the build, choose **Refresh**
    from the context menu of the project folder, or press *F5*.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Eclipse在构建后没有刷新项目内容，请从项目文件夹的上下文菜单中选择**刷新**，或者按*F5*。
- en: Choose **Run As**, and select the second option, **Local C/C++ application**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**运行方式**，然后选择第二个选项，**本地C/C++应用程序**。
- en: Select the **Main** executable from the window to run the program.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从窗口中选择**主**可执行文件以运行程序。
- en: '![](img/B22428_01_19.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_19.png)'
- en: 'Figure 1.19: Choosing the Main executable to run the compiled application'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19：选择主可执行文件以运行编译的应用程序
- en: As the last step of the preparations, we look at the organization of the code
    in the GitHub repository of the book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为准备工作的最后一步，我们来看看本书GitHub仓库中代码的组织结构。
- en: Code organization in this book
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本书中的代码组织
- en: The code for every chapter is stored in the GitHub repository, in a separate
    folder with the relevant chapter number. The number uses two digits to get the
    ordering right. Inside each folder, one or more subfolders can be found. These
    subfolders contain the code of the chapter, depending on the progress of that
    specific chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章的代码都存储在GitHub仓库中，在一个与相关章节编号对应的单独文件夹中。编号使用两位数字以确保正确的排序。在每个文件夹内部，可以找到一个或多个子文件夹。这些子文件夹包含该章节的代码，具体取决于该章节的进度。
- en: For all chapters, we put the `Main.cpp` class and the CMake configuration file,
    `CMakeLists.txt`, into the project root folder. Inside the `cmake` folder, helper
    scripts for CMake are stored. These files are required to find additional header
    and library files.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有章节，我们将`Main.cpp`类和CMake配置文件`CMakeLists.txt`放入项目根文件夹中。在`cmake`文件夹中，存储了CMake的辅助脚本。这些文件是查找额外的头文件和库文件所必需的。
- en: All C++ classes are located inside folders, collecting the classes of the objects
    we create. The `Window` class will be stored in the `window` subfolder to hold
    all files related to the class itself, and the same applies to tools – the logger,
    the model classes, and the renderer-related classes. After you have all the required
    code and tools installed, let’s get a general idea of what game character animations
    are about.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有C++类都位于文件夹内部，收集我们创建的对象的类。`Window`类将被存储在`window`子文件夹中，以保存与该类本身相关的所有文件，工具也是如此——记录器、模型类和与渲染器相关的类。在你安装了所有必需的代码和工具之后，让我们来了解一下游戏角色动画是什么。
- en: Animating game characters – a primer
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏角色动画入门
- en: Moving a game character around in a virtual world with lots of different animations,
    changeable outfits, a collision detection system for other characters and the
    environment, and maybe even interaction with other characters looks nice and simple
    when playing a game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个拥有众多不同动画、可更换服装、其他角色和环境碰撞检测系统，甚至可能与其他角色互动的虚拟世界中移动游戏角色，当玩游戏时看起来既美观又简单。
- en: But the mathematics and techniques behind the smoothly animated game characters
    are extensive and complex. Every movement, animation, action, or state change
    of the character involves a long journey until the final image is rendered to
    the screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，背后使游戏角色平滑动画的数学和技术是广泛且复杂的。角色的每一个动作、动画、行为或状态变化都涉及一段漫长的旅程，直到最终图像渲染到屏幕上。
- en: Let’s look at a high-level explanation of animations first. If you already know
    the details, you can skip to the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们来看一下动画的高级解释。如果你已经了解了细节，你可以跳到下一节。
- en: About nodes, bones, skeletal animation, and skinning
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于节点、骨骼、骨骼动画和蒙皮
- en: The building blocks of an animated three-dimensional character model are the
    so-called **nodes**. A node can be compared to a joint in the virtual body of
    the character, like the shoulder or hip.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 动画三维角色模型的构建块是所谓的**节点**。节点可以比作角色虚拟身体中的关节，例如肩膀或臀部。
- en: All nodes in the character model are connected in the form of a virtual skeleton,
    forming the **bones** of the model. By attaching child nodes to a node, modeling
    an arm with a hand and fingers, or a leg with a foot and toes – or even an entire
    human-like skeleton – is no problem. The starting point of the virtual skeleton
    is the so-called root node. The root node has no parent node and is used as the
    starting point for animations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 角色模型中的所有节点以虚拟骨骼的形式连接，形成模型的**骨骼**。通过将子节点附加到节点上，可以建模带有手和手指的臂部，或带有脚和脚趾的腿部——甚至整个类似人类的骨骼——这都不是问题。虚拟骨骼的起点是所谓的根节点。根节点没有父节点，并用作动画的起点。
- en: Usually, the level of detail does not reach the details of a skeleton in a real-world
    object since many of the real bones are static or play only a minor role in muscle
    or pose changes during animation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，细节级别不会达到真实世界中骨骼的细节，因为许多真实骨骼在动画中是静态的或在肌肉或姿势变化中只起次要作用。
- en: 'The virtual skeleton of the character model can be animated by rotating nodes
    around their center point – and thus rotating the bone to all attached child nodes
    around the center point of this node. Just imagine raising your arm a bit: your
    upper arm will rotate around your shoulder joint, and the lower arm, hand, and
    finger follow the shoulder rotation. This kind of animation is called a **skeletal
    animation**.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 角色模型的虚拟骨骼可以通过围绕其中心点旋转节点来动画化——从而旋转骨骼，使其所有附加的子节点围绕此节点的中心点旋转。只需想象稍微抬起手臂：上臂将围绕肩膀关节旋转，而前臂、手和手指则跟随肩膀的旋转。这种动画称为**骨骼动画**。
- en: A character needs to be stored in a more or less natural pose in the file, which
    is called the reference pose, or **bind pose**. You will find most models in a
    **T-pose** where both arms create a horizontal line, and sometimes see the **A-pose**,
    where the position of the arms of the skeleton resembles the uppercase letter
    A.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 角色需要在文件中以或多或少自然的姿势存储，这被称为参考姿势或**绑定姿势**。你会在大多数模型中发现**T-姿势**，其中双臂形成一条水平线，有时会看到**A-姿势**，其中骨骼手臂的位置类似于大写字母A。
- en: To animate a character, the transforms of each node between the position in
    the bind pose and the desired position in an animation pose need to be changed.
    Since the transformation of a node needs to be calculated in the local coordinates
    of that specific node, an **inverse bind matrix** per node exists to transform
    between local and world coordinates.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化一个角色，需要在绑定姿势位置和动画姿势中期望的位置之间改变每个节点的变换。由于节点的变换需要在特定节点的局部坐标中进行计算，因此每个节点存在一个**逆绑定矩阵**，用于在局部坐标和世界坐标之间进行转换。
- en: The animations themselves are stored in animation **clips**. An animation clip
    does not contain node transforms for every possible time of the animation but
    only for specific time points. Only the node transforms at so-called **key frames**
    are stored in the animation clip data, resulting in less data usage. Node positions
    between two key frames are interpolated using linear interpolation for translation
    and scaling, and spherical linear interpolation (SLERP) for rotations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 动画本身存储在动画**剪辑**中。一个动画剪辑不包含动画每个可能时间点的节点变换，而只包含特定时间点的变换。只有所谓的**关键帧**处的节点变换存储在动画剪辑数据中，从而减少了数据使用。两个关键帧之间的节点位置使用线性插值进行平移和缩放，以及球面线性插值（SLERP）进行旋转。
- en: By using interpolation between two key frames, the skeleton can be brought into
    virtually any pose between the two stored poses. By interpolating between key
    frames or even interpolated poses of different animation clips, **blending** between
    the two poses can be achieved, Blending can be used to change the animation clip
    of a model without visual distortion, for instance, to create a smooth transition
    between a walking and a running animation clip.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在两个关键帧之间进行插值，可以将骨骼带入两个存储姿势之间的任何虚拟姿势。通过在关键帧之间或不同动画剪辑的插值姿势之间进行插值，可以实现两种姿势之间的**混合**。混合可以用来改变模型的动画剪辑，而不会产生视觉扭曲，例如，在行走和跑步动画剪辑之间创建平滑过渡。
- en: The virtual skin of a character model is called a **mesh**, and applying a mesh
    to a skeleton in the vertex shader of the rendering pipeline is called **skinning**.
    To give the virtual skin a natural appearance, every vertex of the mesh uses **weights**
    to handle the influence of surrounding nodes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 角色模型的虚拟皮肤被称为**网格**，在渲染管道的顶点着色器中将网格应用于骨骼称为**蒙皮**。为了使虚拟皮肤看起来自然，网格的每个顶点都使用**权重**来处理周围节点的影响。
- en: 'These weights are used as a factor for node transforms: the higher the node
    weight, the more transforms of that node will be applied to the vertex, and vice
    versa. By using the node weights, the effects of expanding and compressing the
    skin and underlying muscles of the virtual body can be modeled with good precision.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权重被用作节点变换的因素：节点权重越高，该节点的变换应用到顶点的次数就越多，反之亦然。通过使用节点权重，可以以良好的精度模拟虚拟身体皮肤和下肌肉的膨胀和压缩效果。
- en: In the glTF file format, four weights per vertex are used, but other file formats
    with more weights also exist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在glTF文件格式中，每个顶点使用四个权重，但其他具有更多权重的文件格式也存在。
- en: There is a special kind of animation called a **morph animation**. In a morph
    animation, parts of a mesh are replaced, and the vertex positions can be interpolated
    between the different meshes. Morph animations are used to model facial expressions,
    updating only parts of a character model’s face instead of the entire model. By
    replacing only parts of the mesh but keeping the skeletal information unchanged,
    morph animations can be easily added to skeletal animations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的动画称为**形变动画**。在形变动画中，网格的部分被替换，顶点位置可以在不同的网格之间进行插值。形变动画用于建模面部表情，仅更新角色模型面部的一部分而不是整个模型。通过仅替换网格的一部分但保持骨骼信息不变，可以轻松地将形变动画添加到骨骼动画中。
- en: 'Another form of animation is the so-called **additive animation**. Additive
    animations are some sort of mix between skeletal and morph animations: by adding
    the difference between the current pose and the bind pose to the skeletal animation
    clip, the animations of the additive clip are modeled on top of the skeletal animation,
    but only for the nodes that are changed in the additive animation clip.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种动画形式被称为**加法动画**。加法动画是骨骼动画和形变动画之间的一种混合：通过将当前姿势与绑定姿势之间的差异添加到骨骼动画剪辑中，加法剪辑的动画是在骨骼动画之上建模的，但仅限于在加法动画剪辑中发生变化的节点。
- en: Additive animations are used to move only specific parts of a character independently
    of the main skeletal animation. For instance, the skeletal animation contains
    only the walking or running part of the body, while the additive animation clip
    changes only the head or hands. Now the character can move the head to look around,
    without the need to create walking and running animations containing all possible
    head movements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 加法动画用于仅独立移动角色的特定部分，而不依赖于主要的骨骼动画。例如，骨骼动画仅包含身体的行走或跑步部分，而加法动画剪辑仅改变头部或手部。现在，角色可以移动头部四处张望，而无需创建包含所有可能头部动作的行走和跑步动画。
- en: The combination of skeletal, morph, and additive animation enables us to build
    powerful and natural-looking characters for our virtual world, allowing the model
    to walk or run beside us, follow our movements with the head, and use facial morph
    animations to speak all at the same time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼、形变和加法动画的结合使我们能够为虚拟世界构建强大且自然的人物，使模型能够在我们身边行走或奔跑，用头部跟随我们的动作，并使用面部形变动画同时说话。
- en: 'Now let us look at the general workflow for creating character model animations.
    We can divide the animation workflow into two parts: preparation and updates.
    While the preparation part is needed only once while loading the model, updates
    are usually made for every frame drawn to the screen.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建角色模型动画的一般工作流程。我们可以将动画工作流程分为两部分：准备和更新。虽然准备部分在加载模型时只需要一次，但更新通常用于每帧绘制到屏幕上的内容。
- en: We will dive into the preparation process of the model first.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将深入了解模型的准备过程。
- en: Preparing the data for efficient usage
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据以实现高效使用
- en: Game character models are stored in single files, or as a collection of files,
    each for a specific purpose. For instance, model and texture data could reside
    in separate files, allowing artists to change the images independently of the
    model vertices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏角色模型存储在单个文件中，或作为一组文件，每个文件用于特定目的。例如，模型和纹理数据可以存储在单独的文件中，允许艺术家独立于模型顶点更改图像。
- en: 'The following steps must be done in the application before the file in the
    model data can be used for animation and rendering:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型数据文件可用于动画和渲染之前，必须在应用程序中完成以下步骤：
- en: As the first step in the preparation phase, these files must be loaded into
    the memory of the computer. Depending on the implementation in the game, partial
    loading is possible, adding only the elements of the character model that are
    needed at a specific level, or in a specific part of the virtual world.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备阶段的第一步，这些文件必须加载到计算机的内存中。根据游戏中的实现，可以实现部分加载，仅添加特定级别或虚拟世界特定部分所需的字符模型元素。
- en: Then, the data needs to be pre-processed. The representation of the data in
    the files on disk may be optimized in terms of saving space, but for efficient
    manipulation and rendering, a different kind of optimization is required.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，需要对数据进行预处理。磁盘上文件中的数据表示可能在节省空间方面进行了优化，但为了高效的操作和渲染，需要不同的优化方式。
- en: For example, different rendering APIs, like OpenGL, Vulkan, and DirectX, may
    need slightly different representations of vertex or texture data, or shader code
    to be uploaded to the GPU. Instead of storing the different versions in the model
    file, a generic representation may be used. The required adjustments or conversions
    will be done after loading.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不同的渲染API，如OpenGL、Vulkan和DirectX，可能需要稍微不同的顶点或纹理数据表示，或者需要上传到GPU的着色器代码。而不是在模型文件中存储不同的版本，可以使用通用表示。所需的调整或转换将在加载后进行。
- en: As the last step, static data like vertex data or textures will be uploaded
    to the GPU, and other static and variable data parts are stored in C++ classes
    and objects.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，静态数据如顶点数据或纹理将被上传到GPU，其他静态和变量数据部分存储在C++类和对象中。
- en: At this point, the model is ready to use. With the first appearance of that
    character on the screen, a continuously running task of data updates is needed.
    These per-frame tasks are required for states that change at runtime, such as
    positions or animation poses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，模型准备就绪可以使用。随着该角色在屏幕上的首次出现，需要持续运行的数据更新任务。这些每帧任务对于在运行时改变的状态，如位置或动画姿态，是必需的。
- en: Updating character data
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新角色数据
- en: Since the data of the character is split between main memory and GPU memory,
    the game or animation program must sample, extract, convert, and upload data for
    every single frame the character is drawn to the screen.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于角色的数据分布在主内存和GPU内存之间，游戏或动画程序必须为角色在屏幕上绘制的每一帧采样、提取、转换和上传数据。
- en: For instance, the key-frame data of the animations needs to be updated according
    to the animation clip to be shown and the time since the last frame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，动画的关键帧数据需要根据要显示的动画片段和自上一帧以来经过的时间进行更新。
- en: 'The following steps must be done in every frame to create the pixels of a single
    model instance for a specific time point of a selected animation clip:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中必须执行以下步骤以创建特定动画片段选定时间点的单个模型实例的像素：
- en: Blending between different animation clips could be requested by the program
    flow, and additional animation parts may be needed, like additive blending for
    the head or the hands, or facial animations to allow a facial expression for the
    character. So, we extract rotation, translation, and scaling for all nodes at
    the specified replay time from all animation clips and combine the per-clip node
    transformsations into a final transformation matrix for every node.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序流程可能要求在不同动画片段之间进行混合，可能需要额外的动画部分，如头部或手部的加法混合，或面部动画以允许角色有面部表情。因此，我们从所有动画片段中提取指定回放时间点的所有节点的旋转、平移和缩放，并将每个片段的节点变换组合成每个节点的最终变换矩阵。
- en: After the animation data is sampled and combined, the skeleton of the character
    needs to be adjusted. According to the animation data, every virtual bone must
    be translated, rotated, and scaled to reach the desired destination.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画数据被采样和组合之后，需要调整角色的骨骼。根据动画数据，每个虚拟骨骼必须进行平移、旋转和缩放，以达到预期的目标位置。
- en: Also, the world position of the character may need to be updated. World position
    changes can occur in different forms, like running around, jumping, or falling
    down. Knowing the exact position of all characters is an important part of the
    remaining steps.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，角色的世界位置可能需要更新。世界位置的变化可能以不同的形式发生，如跑步、跳跃或跌倒。知道所有角色的确切位置是剩余步骤中的重要部分。
- en: Once bone positions and the world position of the character have been determined,
    collision detection can run. The collision detection checks if the character intersects
    with other characters or environmental objects like the floor and walls, or even
    if the character was hit by a projectile. As a reaction to the collision detection
    results, adjustments to the character properties, like position, or animation
    clip may be triggered.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了骨骼位置和角色的世界位置，就可以运行碰撞检测。碰撞检测会检查角色是否与其它角色或环境对象（如地板和墙壁）相交，或者角色是否被投射物击中。作为对碰撞检测结果的反应，可能会触发对角色属性（如位置）或动画剪辑的调整。
- en: Having the collision data at hand, inverse kinematics adjustments may run. Adjusting
    the skeleton data of the character could be needed to avoid character limbs intersecting
    with the wall or the floor, or to level the feet position on uneven ground.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手头有碰撞数据的情况下，可以运行逆运动学调整。调整角色骨骼数据可能是必要的，以避免角色肢体与墙壁或地板相交，或者为了在凹凸不平的地面上调整脚部位置。
- en: Now, the pure CPU part of the character update is nearly over. As a final step
    from the CPU side, the updated animation data is uploaded to the GPU and the render
    commands are issued. By storing the dynamic character data in the GPU, the rendering
    itself can run without much additional workload from the CPU.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，角色更新的纯CPU部分几乎已经完成。作为CPU端的最后一步，更新的动画数据被上传到GPU，并发出渲染命令。通过在GPU中存储动态角色数据，渲染本身可以运行而无需从CPU获得大量额外的工作负载。
- en: On the GPU, the vertex shader transforms the incoming vertex data according
    to the properties of the current view, like distances or perspective distortion.
    After other possible shader stages, the fragment shader receives the data from
    the rasterization stage of the GPU and draws the pixels to the output framebuffer.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GPU上，顶点着色器根据当前视图的属性（如距离或透视扭曲）转换传入的顶点数据。在可能的着色器阶段之后，片段着色器从GPU的栅格化阶段接收数据，并将像素绘制到输出帧缓冲区。
- en: After all pixels of the level data, characters, and the HUD, as well as maybe
    additional debug data, have been sent to the GPU, the visible and the drawing
    buffers are swapped – at this point, the character appears on the screen, at the
    position and in the animated pose we expect to see.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将所有层级数据、字符、HUD以及可能的其他调试数据发送到GPU之后，可见和绘图缓冲区被交换——在这个时候，角色出现在屏幕上，位于我们期望看到的那个位置，并以我们期望的动画姿态出现。
- en: In between all these update steps, compute shaders may run on the GPU to calculate
    data. Running compute shaders allows the program to offload the calculations for
    multiple characters, freeing the CPU to work on other parts of the game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更新步骤之间，计算着色器可能会在GPU上运行以计算数据。运行计算着色器允许程序将多个角色的计算工作卸载，从而释放CPU来处理游戏的其它部分。
- en: As you can see, a lot of work is needed until you see a game character running
    around in the virtual world. Let’s now start the journey into character animation
    with an overview of Open Asset Import Library.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，直到你在虚拟世界中看到游戏角色四处奔跑，还有很多工作要做。现在，让我们通过Open Asset Import Library的概述开始角色动画之旅。
- en: What is Open Asset Import Library?
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Open Asset Import Library是什么？
- en: '**Open Asset Import Library**, in short **Assimp**, is a cross-platform library
    to import and convert 3D model files. The different file formats are converted
    into a hierarchical data structure, enabling a programmer to support a wider range
    of model formats in a single, comprehensive way.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Open Asset Import Library**，简称**Assimp**，是一个跨平台库，用于导入和转换3D模型文件。不同的文件格式被转换为层次化数据结构，使程序员能够以单一、综合的方式支持更广泛范围的模型格式。'
- en: '*Figure 1.20* shows the key elements and their relationships:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.20* 展示了关键元素及其关系：'
- en: '![](img/B22428_01_20.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_01_20.png)'
- en: 'Figure 1.20: A simplified version of Assimp’s data structures'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.20：Assimp数据结构的简化版本
- en: 'Let us take a closer look at these data structures and their functions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些数据结构和它们的功能：
- en: '`aiScene` is the central element of Assimp’s data structure. The root node
    entry, all information about the polygonal meshes, the materials, and the animations
    are stored in the `aiScene` element.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aiScene`是Assimp数据结构的核心元素。根节点条目、关于多边形网格、材质和动画的所有信息都存储在`aiScene`元素中。'
- en: 'The root node of `aiScene` points to a structure called `aiNode`. In every
    `aiNode`, possible child nodes are stored, eventually creating a node tree. Also,
    a transform matrix resides in the `aiNode` structure, defining the local transformation,
    relative to the parent node. This matrix is called the TRS matrix for the three
    possible transformations: translation, rotation, and scale, in this order. By
    combining the TRS transforms from the root node down to every node of the skeleton,
    the final world position of a node can be calculated only by using the world position
    of the root node and the local transformations of every node in the skeleton hierarchy.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aiScene` 的根节点指向一个名为 `aiNode` 的结构。在每一个 `aiNode` 中，存储了可能的子节点，最终创建了一个节点树。此外，`aiNode`
    结构中还有一个变换矩阵，定义了相对于父节点的局部变换。这个矩阵被称为 TRS 矩阵，用于三种可能的变换：平移、旋转和缩放，顺序如下。通过将根节点到骨架中每个节点的
    TRS 变换组合起来，可以仅使用根节点的世界位置和骨架层次结构中每个节点的局部变换来计算节点的最终世界位置。'
- en: The node name is used in other structs, like the bones or the animations, to
    refer back to this specific node. For the vertices of the node, an index to the
    corresponding `aiMesh` structure in `aiScene` is stored here.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点名用于其他结构，如骨骼或动画，以引用此特定节点。对于节点的顶点，存储了 `aiScene` 中对应 `aiMesh` 结构的索引。
- en: All data that will be drawn on the screen is stored in `aiMesh` structs. Every
    mesh consists of a number of so-called faces, usually triangles. For every vertex
    of every face, important data like the vertices, normals, and texture coordinates
    are stored directly in `aiMesh`. The drawing order of the vertices is stored separately
    as indices in the other structures, allowing features like space-saving reuse
    of vertices.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有将在屏幕上绘制的数据都存储在 `aiMesh` 结构中。每个网格由所谓的面组成，通常是三角形。对于每个面的每个顶点，重要的数据如顶点、法线和纹理坐标都直接存储在
    `aiMesh` 中。顶点的绘制顺序作为索引存储在其他结构中，这允许像节省空间地重用顶点这样的特性。
- en: For animations, the model “skeleton” consists of bones, stored in `aiBone` structs.
    Here, the offset matrix defines the offset between the position in mesh space
    and the bind pose in bone space (in the glTF file format, this is the “inverse
    bind matrix”). Additionally, ,several value pairs are stored for every vertex,
    each containing a node index and a weight value. In every pair, the weight value
    specifies the fraction of the nodes movement that is applied to the vertex.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于动画，模型“骨架”由骨骼组成，存储在 `aiBone` 结构中。在这里，偏移矩阵定义了网格空间中的位置与骨骼空间中的绑定姿态（在 glTF 文件格式中，这是“逆绑定矩阵”）之间的偏移。此外，每个顶点存储了几个值对，每个值对包含一个节点索引和一个权重值。在每一对中，权重值指定了应用于顶点的节点移动的分数。
- en: The position of every vertex in the `Assimp` meshes can be bound to up to four
    bones, and the influence of each of these four bones on the final vertex position
    can be controlled by a weight value between `0` and `1`. The weight is used as
    a scaling factor for the transformations of the specified bone – a value of `1`
    means that the vertex makes the same transformations as the bone, and for a value
    of `0`, the vertex ignores the transforms of the bone.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assimp` 网格中每个顶点的位置可以绑定到最多四个骨骼上，并且可以通过介于 `0` 和 `1` 之间的权重值来控制这些四个骨骼对最终顶点位置的影响。权重用作指定骨骼变换的缩放因子——值为
    `1` 表示顶点执行与骨骼相同的变换，而对于值为 `0`，顶点忽略骨骼的变换。'
- en: On the right side of *Figure 1.20*, the data for animations is shown. The `aiAnimation`
    struct contains the animation channels for bones and meshes, the overall duration
    of the specific animation, and the number of frames per second for this animation.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *图 1.20* 的右侧，显示了动画的数据。`aiAnimation` 结构包含骨骼和网格的动画通道、特定动画的总持续时间以及每秒的帧数。
- en: As an example for the animations, we will look at the `aiNodeAnim` struct. This
    struct consists of key frames with rotations, translations, or scales to apply
    to a specific node. The node name in the `aiNode` struct is used to find the corresponding
    bone to animate.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为动画的示例，我们将查看 `aiNodeAnim` 结构。这个结构由应用于特定节点的旋转、平移或缩放的关键帧组成。`aiNode` 结构中的节点名用于找到要动画化的对应骨骼。
- en: 'Currently, more than 50 different file formats are known to Assimp. Some notable
    examples are listed here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Assimp 已知超过 50 种不同的文件格式。以下是一些显著的例子：
- en: Autodesk 3D Studio (`.3ds`), AutoCAD (`.dxf`), and FBX (`.fbx`)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autodesk 3D Studio (`.3ds`)、AutoCAD (`.dxf`) 和 FBX (`.fbx`)
- en: Collada (`.dae`) and glTF (`.gltf` and `.glb`), managed by the Khronos Group
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Collada (`.dae`) 和 glTF (`.gltf` 和 `.glb`), 由 Khronos Group 管理
- en: Wavefront vertices (`.obj`) plus materials (`.mat`)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront 顶点 (`.obj`) 加上材质 (`.mat`)
- en: STL files, mostly known from 3D printing (`.stl`)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 文件，主要来自 3D 打印 (`.stl`)
- en: Game engine formats, i.e., from Quake (`.md3`/`.md5`), or Half-Life (`.mdl`)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏引擎格式，即来自 Quake (`.md3`/`.md5`) 或 Half-Life (`.mdl`)
- en: Even though the number of formats is impressive, it needs to be stated that
    not all models you find can be imported into the application by using `Assimp`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管格式数量令人印象深刻，但需要指出的是，并非所有找到的模型都可以通过使用 `Assimp` 导入到应用程序中。
- en: Several of these file formats are reverse-engineered from closed source applications,
    and only a subset of versions work. Other formats are open source, like Collada
    or glTF, but some of those formats are also constantly evolving. Also, not all
    new features have yet been implemented in `Assimp`. So, even with a versatile
    asset import library like `Assimp`, you may end up with a model that fails to
    be imported, produces “vertex garbage” on screen, or is missing some of its properties.
    Nevertheless, `Assimp` is currently the best open source solution to load many
    different game and non-game 3D models into your own application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件格式中的几个是从封闭源应用程序中逆向工程得到的，并且只有版本的一个子集可以工作。其他格式是开源的，如 Collada 或 glTF，但其中一些格式也在不断演变。此外，`Assimp`
    中尚未实现所有新功能。因此，即使有像 `Assimp` 这样通用的资产导入库，你也可能遇到无法导入的模型，屏幕上产生“顶点垃圾”，或者丢失一些属性的情况。尽管如此，`Assimp`
    目前是加载许多不同游戏和非游戏 3D 模型到您自己的应用程序中的最佳开源解决方案。
- en: Loading a model file with `Assimp` boils down to importing the `aiScene` object
    of a file, checking for the existence of other data types, and importing that
    data into the application. In the next section, we will do a short walk-through
    of the steps to load a model file with `Assimp`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Assimp` 加载模型文件归结为导入文件的 `aiScene` 对象，检查其他数据类型的存在，并将该数据导入应用程序。在下一节中，我们将简要介绍使用
    `Assimp` 加载模型文件的步骤。
- en: The complete source code for the application can be found in the folder `chapter01`,
    the subfolder `01_opengl_assimp` for OpenGL, and the subfolder `02_vulkan_assimp`
    for Vulkan.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的完整源代码可以在 `chapter01` 文件夹中找到，OpenGL 的子文件夹为 `01_opengl_assimp`，Vulkan 的子文件夹为
    `02_vulkan_assimp`。
- en: Loading a model file
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载模型文件
- en: 'To load a model file with Open Asset Import Library, we must include the following
    three headers in the implementation file of the `AssimpModel` model loading class
    in the `model` folder:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Open Asset Import Library 加载模型文件，我们必须在 `model` 文件夹中 `AssimpModel` 模型加载类的实现文件中包含以下三个头文件：
- en: '[PRE15]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create an `Assimp::Importer` instance in the `loadModel()` method,
    and use the importer to load a file from disk:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `loadModel()` 方法中创建一个 `Assimp::Importer` 实例，并使用导入器从磁盘加载文件：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We hand over the file name of the asset file we want to load, plus the two values
    `aiProcess_Triangulate` and `aiProcess_GenNormals` as optional postprocessing
    flags.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递要加载的资产文件的文件名，以及两个值 `aiProcess_Triangulate` 和 `aiProcess_GenNormals` 作为可选的后处理标志。
- en: The first flag, `aiProcess_Triangulate`, instructs `Assimp` to triangulate all
    polygons with more than three vertices, if those polygons exist in the file. Since
    our basic renderer only understands triangles, a polygon with more than three
    vertices would cause graphical errors.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标志 `aiProcess_Triangulate` 指示 `Assimp` 将文件中所有具有超过三个顶点的多边形进行三角化。由于我们的基本渲染器只理解三角形，具有超过三个顶点的多边形将导致图形错误。
- en: Using `aiProcess_GenNormals` as the import flag ensures that all triangles have
    normal vectors. Default normal vectors pointing upward from the surface of the
    triangle will be created only if no normal vector is found. Existing normals are
    not changed by the flag.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `aiProcess_GenNormals` 作为导入标志确保所有三角形都有法向量。只有在没有找到法向量的情况下，才会创建默认的法向量，指向三角形表面向上。现有的法向量不会被标志更改。
- en: 'Next, we must check if the import was successful:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须检查导入是否成功：
- en: '[PRE17]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We assume a failed import if the scene pointer itself is a `nullptr`, the scene
    is marked as incomplete by the importer, or the scene has no root node defined.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景指针本身是 `nullptr`，导入器将场景标记为不完整，或者场景没有定义根节点，我们假设导入失败。
- en: After the model file has been loaded successfully, we will scan the model for
    embedded textures.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 模型文件成功加载后，我们将扫描模型以查找嵌入的纹理。
- en: Loading embedded textures
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载嵌入的纹理
- en: Some model formats can embed the textures into the object file. If the function
    call to `HasTextures()` returns `true`, we loop over all textures of the model
    file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模型格式可以将纹理嵌入到对象文件中。如果对`HasTextures()`函数的调用返回`true`，我们将遍历模型文件中的所有纹理。
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the loop, we extract the texture name, height, and width, as well as
    the pixel data of the texture. The texture name is only for information purposes,
    since the data is embedded into the model file, but having the name is helpful
    while debugging problems:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们提取纹理名称、高度和宽度，以及纹理的像素数据。纹理名称仅用于信息目的，因为数据已嵌入到模型文件中，但拥有名称在调试问题时很有帮助：
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we create a shared pointer and try to import the texture data. If the
    import fails with an unexpected error, we stop loading the model:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个共享指针并尝试导入纹理数据。如果导入因意外错误而失败，我们将停止加载模型：
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Embedded textures are references in the format `*10` – a star plus the index
    number of the texture. So, we create the internal name and insert the shared pointer
    into a `std::unordered_map`, mapping the texture name to our data object containing
    the texture data:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入的纹理是格式为`*10`的引用——一个星号加上纹理的索引号。因此，我们创建内部名称并将共享指针插入到`std::unordered_map`中，将纹理名称映射到包含纹理数据的我们的数据对象：
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In addition to any embedded textures, a placeholder texture will be added:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 除了任何嵌入的纹理外，还将添加一个占位符纹理：
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Placeholder textures for objects are common in many game engines, showing objects
    with missing textures, instead of a black object or random data from the GPU memory.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏引擎中，对象占位符纹理很常见，用于显示缺少纹理的对象，而不是一个黑色对象或GPU内存中的随机数据。
- en: Parsing the node hierarchy
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析节点层次结构
- en: 'After checking for embedded textures, we continue by processing all nodes.
    Due to the hierarchical organization, we take a recursive approach here. As the
    first step, we create an object for the root node:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了嵌入的纹理之后，我们继续处理所有节点。由于具有层次结构，我们在这里采用递归方法。作为第一步，我们为根节点创建一个对象：
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An `AssimpNode` object contains data about the position, rotation, and scaling
    of one of the model parts in the virtual world. This transformation data also
    includes the position, rotation, and scale of its parent node, moving all the
    nodes to their intended position.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpNode`对象包含有关虚拟世界中模型部分之一的定位、旋转和缩放的数据。这种转换数据还包括其父节点的位置、旋转和缩放，将所有节点移动到它们预期的位置。'
- en: 'Then, this new root node will be used as the basis to collect all child nodes,
    grandchild nodes, and so on:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个新的根节点将被用作收集所有子节点、孙子节点等的基础：
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `processNode()` method, four tasks are done for every node:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`processNode()`方法内部，对每个节点执行四个任务：
- en: Collecting the mesh data itself, like vertex positions, normals, or texture
    coordinates
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集网格数据本身，如顶点位置、法线或纹理坐标
- en: Collecting external textures from materials
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从材质中收集外部纹理
- en: Collecting bones for skeletal animations
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集用于骨骼动画的骨骼
- en: Descending into the hierarchy to process the child nodes of this node
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入层次结构以处理此节点的子节点
- en: 'We start by iterating through all meshes of the node:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历节点的所有网格：
- en: '[PRE25]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `AssimpMesh` class contains the logic to extract vertex data, textures,
    and bones. We simply create a local `mesh` instance and let the `processMesh()`
    method do all the extraction work for us:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpMesh`类包含提取顶点数据、纹理和骨骼的逻辑。我们简单地创建一个本地的`mesh`实例，并让`processMesh()`方法为我们完成所有提取工作：'
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After the Assimp mesh has been processed, we add the converted mesh data, the
    collected textures, and the bones to the data structures of the model itself:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完Assimp网格后，我们将转换后的网格数据、收集到的纹理和骨骼添加到模型本身的数据结构中：
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we store the current node in a node map and a node list:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将当前节点存储在节点映射和节点列表中：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Saving the same node in two different data structures is needed to speed up
    the access during different phases of the program.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在程序的不同阶段加快访问速度，需要在两个不同的数据结构中保存相同的节点：
- en: 'The `mNodeMap` contains the nodes in a `std::unordered_map`, allowing us to
    access any node by its node name in constant time. But a huge disadvantage is
    that a `std::unordered_map` does not preserve the insertion order by default.
    Using a `std::map` would not help either since all entries of a `std::map` will
    be sorted by the key in ascending order. We could solve the sorting issue by using
    a custom comparator function for the map, but since we are also accessing the
    nodes based on the index position, a second data structure will be used: the `mNodeList`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`mNodeMap`以`std::unordered_map`的形式包含节点，允许我们以常数时间通过节点名称访问任何节点。但一个巨大的缺点是`std::unordered_map`默认不保留插入顺序。使用`std::map`也不会有帮助，因为`std::map`的所有条目都将按键的升序排序。我们可以通过为映射使用自定义比较函数来解决排序问题，但由于我们也是根据索引位置访问节点，因此将使用第二个数据结构：`mNodeList`。'
- en: In the `mNodeList`, all nodes are stored in a flat but hierarchical order, guaranteeing
    us to access any of the nodes before its child nodes. This way, the `mNodeList`
    is fast when it comes to updates that need to be done in all nodes. We can just
    iterate from start to end through the vector.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mNodeList`中，所有节点以平坦但层次化的顺序存储，这保证了我们可以在其子节点之前访问任何节点。这样，当需要对所有节点进行更新时，`mNodeList`运行速度快。我们可以简单地通过向量从开始到结束迭代。
- en: 'At the end of `processNode()`, we check for child nodes, and process any child
    nodes we find in a recursive manner:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`processNode()`的末尾，我们检查子节点，并以递归方式处理找到的任何子节点：
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After processing all nodes in the hierarchy, we have collected all meshes, textures,
    and skeletal data from the model.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完层次结构中的所有节点后，我们从模型中收集了所有网格、纹理和骨骼数据。
- en: Adding vertex buffers for the meshes
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为网格添加顶点缓冲区
- en: 'Back in the `loadModel()` method, we create a combined vertex and index buffer
    object for every mesh, upload the extracted vertex data, and store the buffer
    in a `std::vector` called `mVertexBuffers`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadModel()`方法中，我们为每个网格创建一个组合的顶点和索引缓冲区对象，上传提取的顶点数据，并将缓冲区存储在名为`mVertexBuffers`的`std::vector`中：
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To draw the imported model, we can now simply iterate over the `mModelMeshes`
    vector and use the `drawIndirect()` call of the `VertexIndexBuffer` class to draw
    all triangles of this specific mesh with only a single draw command. The method
    is called “indirect” because Assimp stores the model data internally as vertices
    plus indices, and we draw the triangles in the indirect mode, via the indices.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制导入的模型，我们现在可以简单地遍历`mModelMeshes`向量，并使用`VertexIndexBuffer`类的`drawIndirect()`调用，通过单个绘制命令绘制该特定网格的所有三角形。该方法被称为“间接”，因为Assimp将模型数据内部存储为顶点加索引，我们通过索引以间接模式绘制三角形。
- en: In addition, an instanced version of the draw call is available, named `drawIndirectInstanced()`.
    Instanced drawing allows us to draw several instances of the same mesh on different
    positions of the screen, but the workload of creating the extra triangles is done
    by the GPU, not the CPU.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`drawIndirectInstanced()`的实例化绘制调用版本。实例化绘制允许我们在屏幕的不同位置绘制相同网格的多个实例，但创建额外三角形的负载由GPU而不是CPU完成。
- en: Importing animations
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入动画
- en: 'As the last step of the model-loading process, we check for animations and
    iterate over the internal data structure of the animations in the model file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模型加载过程的最后一步，我们检查动画并遍历模型文件中动画的内部数据结构：
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For every animation we find, we create an object of the class `AssimpAnimClip`,
    and add all channels of the current animation clip:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们找到的每个动画，我们创建一个`AssimpAnimClip`类的对象，并添加当前动画剪辑的所有通道：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Some models do not specify a name for the animation clip, so we set the name
    to the number of the clip if the name is empty:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模型没有为动画剪辑指定名称，因此如果名称为空，我们将名称设置为剪辑的编号：
- en: '[PRE33]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Having distinctive clip names is a requirement for the UI to select the animations
    by name.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 具有独特的剪辑名称是UI通过名称选择动画的要求。
- en: 'Finally, we store the clips in the `mAnimClips` vector:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将剪辑存储在`mAnimClips`向量中：
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, all relevant data of the model has been loaded, extracted, and
    converted. As stated at the end of the *What is Open Asset Import Library?* section,
    the quality of the imported data depends on various factors, particularly the
    compatibility with `Assimp`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，模型的所有相关数据已经加载、提取和转换。正如在*什么是Open Asset Import Library?*部分结束时所述，导入数据的质量取决于各种因素，尤其是与`Assimp`的兼容性。
- en: Checking the code for all the details
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码以获取所有细节
- en: You should take a look at the implementation of the other classes prefixed with
    “Assimp” in the `model` folder, and the implementations of the extraction methods
    in these classes. In general, the methods simply read out the C-style data structures
    from `Assimp`, constructing custom C++ classes. The data for the mesh is converted
    into GLM types, allowing us to do a simple upload to the GPU, instead of a time-consuming
    change at every draw.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该查看`model`文件夹中带有“Assimp”前缀的其他类的实现，以及这些类中提取方法的实现。一般来说，这些方法只是从`Assimp`中读取C风格的数据结构，构建自定义的C++类。网格数据被转换为GLM类型，这使得我们可以简单地将其上传到GPU，而不是在每次绘制时进行耗时的更改。
- en: 'Now that we have the basics ready to open a model file, we run into a simple
    but essential problem: *The file name for the model file is hardcoded*.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了基本功能来打开模型文件，我们遇到了一个简单但基本的问题：*模型文件的文件名是硬编码的*。
- en: Rather than hardcode the path to our model file for loading, let’s add the ability
    to browse for a file. A simple way to load a specific model from a file into the
    application is with an “Open File” dialog, allowing us to choose the file we want
    to import. To achieve the seamless integration of such a dialog into the program,
    we will use an ImGui-based solution, instead of an OS-native dialog.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是硬编码我们的模型文件路径以进行加载，让我们添加浏览文件的能力。将特定模型从文件加载到应用程序中的简单方法是通过“打开文件”对话框，允许我们选择要导入的文件。为了实现此类对话框与程序的无缝集成，我们将使用基于ImGui的解决方案，而不是使用原生操作系统对话框。
- en: Extending the UI with an Open File dialog
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过打开文件对话框扩展UI
- en: ImGui can be used to create simple UIs like in our animation application, but
    the code can be also extended to build different kinds of tools. For our application,
    a dialog to choose a file on the system is helpful to load models at runtime,
    freeing us of hardcoding the model names in the code or using models as command-line
    parameters when starting the application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ImGui可以用来创建简单的UI，就像我们在动画应用程序中做的那样，但代码也可以扩展来构建不同类型的工具。对于我们的应用程序，一个用于在系统中选择文件的对话框有助于在运行时加载模型，使我们免于在代码中硬编码模型名称或在使用命令行参数启动应用程序时使用模型。
- en: Various ImGui-based file dialogs exist; a nice and easy-to-integrate file dialog
    can be found in the GitHub repository of Stephane Cuillerdier at [https://github.com/aiekick/ImGuiFileDialog](https://github.com/aiekick/ImGuiFileDialog).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种基于ImGui的文件对话框；一个既好又易于集成的文件对话框可以在Stephane Cuillerdier的GitHub仓库[https://github.com/aiekick/ImGuiFileDialog](https://github.com/aiekick/ImGuiFileDialog)中找到。
- en: For a simple integration of the file dialog, we will use CMake’s `FetchContent`
    to download and build the code.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件对话框的简单集成，我们将使用CMake的`FetchContent`来下载和构建代码。
- en: Integrating the file dialog into CMakeLists.txt
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件对话框集成到CMakeLists.txt中
- en: 'First, we add a new `FetchContent` block into the `CMakeLists.txt` file, right
    below the end of the ImGui fetching:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`CMakeLists.txt`文件中添加一个新的`FetchContent`块，位于ImGui获取的末尾下方：
- en: '[PRE35]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We “short-cut” the configure and build commands here, since we only want to
    have the source code available, instead of building a standalone version of the
    file dialog.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里“简化”了配置和构建命令，因为我们只想让源代码可用，而不是构建一个独立的文件对话框版本。
- en: Unfortunately, the initial configuration still needs the location of the ImGui
    headers. Since the `FetchContent` block does not allow setting additional compiler
    options, we need a small hack to alter the value of the CMake property `COMPILE_OPTIONS`
    during the fetch process.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，初始配置仍然需要ImGui头文件的路径。由于`FetchContent`块不允许设置额外的编译选项，我们需要一个小技巧来在获取过程中更改CMake属性`COMPILE_OPTIONS`的值。
- en: 'To do so, we save the current state of `COMPILE_OPTIONS` in a new CMake variable
    called `current_compile_options`. Then, we adjust the compile options to include
    the headers from the ImGui source folder in the search list:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将`COMPILE_OPTIONS`的当前状态保存在一个新的CMake变量`current_compile_options`中。然后，我们调整编译选项以将ImGui源文件夹中的头文件包含在搜索列表中：
- en: '[PRE36]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can trigger the download and initialization of the file dialog source:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以触发文件对话框源代码的下载和初始化：
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To avoid further confusion in the build system, we set the `COMPILE_OPTIONS`
    property back to its saved state, and also unset the variable we used to save
    the state:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在构建系统中造成进一步的混淆，我们将`COMPILE_OPTIONS`属性恢复到其保存的状态，并取消设置我们用来保存状态的变量：
- en: '[PRE38]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In Visual Studio 2022, a new CMake configuration run is triggered automatically.
    In Eclipse, a new run of CMake must be triggered via the **Build Project** option
    in the right-click context menu of the project.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，新的CMake配置运行会自动触发。在Eclipse中，必须通过项目右键上下文菜单中的**构建项目**选项来手动触发CMake的新运行。
- en: Including the functionality of the file dialog is easy; the UI class needs to
    be extended by only a couple of lines.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件对话框的功能很简单；UI类只需要扩展几行代码。
- en: Using the ImGui file dialog
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ImGui文件对话框
- en: 'We can place the dialog code anywhere in the code of the `createFrame()` method
    of the `UserInterface` class in the `UserInterface.cpp` file within the folder
    `opengl`. First, we add an `ImGui::Button` named `"Import Model"`. This button
    will open a modal version of the dialog:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`UserInterface`类在`UserInterface.cpp`文件中的`createFrame()`方法代码的任何位置放置对话框代码。首先，我们添加一个名为“导入模型”的`ImGui::Button`。此按钮将打开对话框的模态版本：
- en: '[PRE39]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This button configures a special `FileDialogConfig` property of the file dialog.
    The `config.path` entry sets the path to open to the current path where the executable
    was started, while `countSelectionMax` tells the dialog to accept only a single
    file to be selected. Setting `flags` to `ImGuiFileDialogFlags_Modal` presents
    the file dialog on top of all other ImGui windows.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮配置文件对话框的特殊`FileDialogConfig`属性。`config.path`条目将打开路径设置为可执行文件启动的当前路径，而`countSelectionMax`告诉对话框只接受单个文件被选中。将`flags`设置为`ImGuiFileDialogFlags_Modal`将文件对话框显示在所有其他ImGui窗口之上。
- en: When the flags are set, `OpenDialog()` is called to open a dialog instance with
    the internal name `"ChooseModelFile"` as the first parameter; the window title
    `"Choose Model File"` as the second parameter; a filter to show all files, regardless
    of the file extensions, as the third parameter; and the configuration property
    as the last parameter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置标志时，调用`OpenDialog()`以内部名称为第一个参数`"ChooseModelFile"`打开对话框实例；窗口标题为第二个参数`"选择模型文件"`；第三个参数为显示所有文件（无论文件扩展名）的过滤器；最后一个参数为配置属性。
- en: Setting the internal name of the dialog to open in the `Display()` call allows
    us to define multiple open file dialogs, depending on the requirements of the
    program in the specific situation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Display()`调用中将对话框的内部名称设置为打开，允许我们根据特定情况下程序的需求定义多个打开文件对话框。
- en: 'Right after the button, the file dialog itself is defined:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮之后，文件对话框本身被定义：
- en: '[PRE40]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code for the file dialog follows the ImGui coding style. The first `if`
    around the `Display()` call returns `true` if the dialog is shown, that is, after
    the above `"Import Model"` button has been clicked. Then, the dialog code reacts
    by setting `IsOk()` to `true` after the `"OK"` button of the dialog has been clicked,
    allowing us to insert actions to take on the selected file. The final `Close()`
    call closes the dialog when a file has been selected.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框的代码遵循ImGui编码风格。围绕`Display()`调用的第一个`if`语句返回`true`表示对话框被显示，即在上面的“导入模型”按钮被点击之后。然后，对话框代码通过在对话框的“确定”按钮被点击后设置`IsOk()`为`true`来做出反应，允许我们在选定的文件上插入要执行的操作。最后的`Close()`调用在选择了文件后关闭对话框。
- en: Before we check the return value of the file dialog, we take a look at the file
    extension filter. Showing all files could make it difficult to find the file we
    want to load.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查文件对话框的返回值之前，我们先看看文件扩展名过滤器。显示所有文件可能会使得找到我们想要加载的文件变得困难。
- en: Adding a filter to show only supported file types
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加过滤器以仅显示支持的文件类型
- en: 'The `filter` field of the file dialog allows quite complex configurations,
    but we will check only three of them: a single filter, a group of extensions,
    and a regular expression-style filter.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框的`filter`字段允许相当复杂的配置，但我们将检查其中的三个：单个过滤器、一组扩展名和正则表达式风格的过滤器。
- en: Adding a single filter
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加单个过滤器
- en: 'The code in the *Using the ImGui file dialog* section already shows a single
    filter:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用ImGui文件对话框*部分中的代码已经展示了单个过滤器：
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This filter simply means “anything after the last dot of the file name,” so
    you will see all the visible files in the current folder.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器简单来说就是“文件名中最后一个点之后的所有内容”，所以你会看到当前文件夹中所有的可见文件。
- en: 'You can also specify a single extension here, and only files with this one
    extension are shown:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里指定单个扩展名，并且只显示具有此扩展名的文件：
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note on case sensitivity
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大小写敏感性的说明
- en: In Linux, filtering is case sensitive.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，过滤是大小写敏感的。
- en: So, the `.jpg` filter will *not* show a file named `IMAGE.JPG`!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`.jpg`过滤器将**不会**显示名为`IMAGE.JPG`的文件！
- en: Adding a group of filters
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一组过滤器
- en: 'Grouping file extensions into a single filter works by separating them with
    a comma:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用逗号分隔将文件扩展名分组到一个过滤器中：
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, this may not work as intended – you can still choose only one extension
    from the group, showing only files with the specific extension in the current
    folder. Allowing only one file extension from a group can be used for **Save File**
    dialogs, forcing the user to choose a specific file format from a list of available
    formats.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能不会按预期工作——你仍然只能从组中选择一个扩展名，只显示当前文件夹中具有特定扩展名的文件。仅允许从组中选择一个文件扩展名可以用于**保存文件**对话框，强制用户从可用格式列表中选择一个特定文件格式。
- en: Adding a regular expression-style filter
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加正则表达式风格的过滤器
- en: 'The most useful variant for the filter is the regular expression style:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过滤器来说，最有用的变体是正则表达式风格：
- en: '[PRE44]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the string `"Supported Types"` will be shown as a filter in the dialog,
    and all files with the file extension named in the curly braces are shown.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，字符串`"支持类型"`将作为对话框中的过滤器显示，并显示所有具有括号中命名的文件扩展名的文件。
- en: 'You could also add multiple regular expression filters, separated by commas,
    to create a drop-down list of various file types. This line would enable you to
    choose between a couple of pictures, the textual and binary glTF formats, and
    all files:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以添加多个正则表达式过滤器，用逗号分隔，以创建一个包含各种文件类型的下拉列表。这一行将允许你从几幅图片、文本和二进制glTF格式以及所有文件中进行选择：
- en: '[PRE45]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since the filter field of the `OpenDialog()` call is a pointer to a character
    array, the filter list could even be created dynamically. Depending on the state
    of the program, the file types you want the user to select, and so on, you can
    present various filter options.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`OpenDialog()`调用的过滤器字段是一个指向字符数组的指针，过滤器列表甚至可以动态创建。根据程序的状态、用户想要选择的文件类型等因素，你可以展示各种过滤器选项。
- en: Having the file dialog open with a (possibly limited) amount of file types presented
    to the user, let’s complete the code handling the file selected by the user.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件对话框打开，向用户展示（可能有限制的）文件类型时，让我们完成处理用户选择的文件的代码。
- en: Loading the model file
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载模型文件
- en: 'If a file was selected and the `OK` button was pressed, or the file name was
    double-clicked, the name including the full path of the chosen file is available
    by calling `GetFilePathName()`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了文件并按下了`OK`按钮，或者文件名被双击，可以通过调用`GetFilePathName()`获取所选文件的完整路径名：
- en: '[PRE46]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For a clear separation of concerns, the UI code does not handle the loading
    process itself. Instead, a simple lambda-based callback is created, and we call
    this callback with the name of the model:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰地区分关注点，UI代码本身不处理加载过程。相反，创建了一个基于lambda的简单回调，我们用模型名称调用这个回调：
- en: '[PRE47]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The callback to add a new model is defined in the file `ModelAndInstanceData.h`
    in the `model` folder:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新模型的回调函数定义在`model`文件夹中的`ModelAndInstanceData.h`文件里：
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'During initialization of the renderer, the callback function is bound to the
    method `addModel()` of the renderer class via a lambda:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器初始化期间，回调函数通过lambda绑定到渲染器类的`addModel()`方法：
- en: '[PRE49]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, when a file has been selected, the renderer is doing all the “dirty work”
    of importing the new model, signaling back if the model import was successful.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当文件被选中时，渲染器正在做所有导入新模型的“脏活”，如果模型导入成功，则返回信号。
- en: Right now, the return value of the callback only adjusts the position in the
    list of models. But it could be used to give feedback to the user – an error message
    popup can be presented if the model file could not be opened, or the same model
    file was already loaded.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，回调函数的返回值仅调整模型列表中的位置。但它可以用来向用户反馈——如果模型文件无法打开，可以显示错误消息弹出窗口，或者相同的模型文件已经被加载。
- en: Drawing the model to the screen
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模型绘制到屏幕上
- en: 'The process of drawing the model in the renderer is simple:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中绘制模型的流程很简单：
- en: Get the smart pointer that points to the `Assimp` model.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取指向`Assimp`模型的智能指针。
- en: If the model is animated, update the animation with the delta time between the
    last frame and this frame, and collect the new bone matrices.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型是动画的，更新动画，使用上一帧和当前帧之间的时间差，并收集新的骨骼矩阵。
- en: If the model is not animated, simply get the node matrices of the instances.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型不是动画的，只需获取实例的节点矩阵。
- en: Upload the matrix data to the shader storage buffer on the shader.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵数据上传到着色器上的着色器存储缓冲区。
- en: Issue a draw call to the graphics API.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向图形API发出绘制调用。
- en: The custom classes handle all other steps required to draw the model, like uploading
    the vertex data or binding the correct texture for the mesh to draw next.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类处理绘制模型所需的所有其他步骤，例如上传顶点数据或绑定正确的纹理以绘制下一个网格。
- en: Loading and drawing a single file is already cool. But to use the full power
    of `Assimp`, we will allow adding and deleting different models and model instances
    at program runtime.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和绘制单个文件已经非常酷了。但为了充分利用 `Assimp` 的功能，我们将在程序运行时允许添加和删除不同的模型和模型实例。
- en: Adding and removing model instances dynamically
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态添加和删除模型实例
- en: 'Supporting multiple instances from multiple models was done by creating the
    class `AssimpInstance` in the `model` folder. Every `AssimpInstance` contains
    a smart pointer to access its base model, including the nodes and bones. Adding
    multiple instances of the same model requires one of two options to handle nodes
    and bones: using a copy of the node data structures in every instance or sharing
    the model’s nodes across all instances.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `model` 文件夹中创建 `AssimpInstance` 类来支持来自多个模型的多实例。每个 `AssimpInstance` 包含一个智能指针以访问其基础模型，包括节点和骨骼。添加相同模型的多个实例需要处理节点和骨骼的两个选项之一：在每个实例中使用节点数据结构的副本，或者在整个实例之间共享模型的节点。
- en: To avoid the duplication of all nodes in every instance, we will reuse the nodes
    of the model during the calculation of each final node position for the frame.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在每个实例中重复所有节点，我们将在计算每个最终节点位置时重用模型中的节点。
- en: Reusing the bones for the sake of simplicity
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了简化起见重用骨骼
- en: 'To calculate the nodes during animation in the `updateAnimation()` method,
    we iterate the channels of the clip and use the model’s corresponding node:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateAnimation()` 方法中计算动画期间的节点，我们遍历剪辑的通道并使用模型的对应节点：
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The position, rotation, or scale of every node change:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的位置、旋转或缩放发生变化：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For the root node, the local transformation of the instance is applied to the
    root transform matrix of the model:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根节点，实例的局部变换应用于模型的根变换矩阵：
- en: '[PRE52]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, the node properties are used to generate the final position of the bone,
    using the stored offset matrix from the corresponding bone and the local transformation
    matrix of the node.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用存储的对应骨骼的偏移矩阵和节点的局部变换矩阵，利用节点属性生成骨骼的最终位置。
- en: 'First, we get the node corresponding to the bone of the model:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取模型中对应骨骼的节点：
- en: '[PRE53]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we update the matrix containing the translation, rotation, and scale
    properties of the node (hence the three letters **TRS** in the name):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新包含节点平移、旋转和缩放属性的矩阵（因此名称中的三个字母 **TRS** 代表变换、旋转和缩放）：
- en: '[PRE54]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Calling `updateTRSMatrix()` also retrieves the TRS matrix of the parent node
    and multiplies the local TRS matrix by the parent node’s TRS matrix. Combining
    the local TRS matrix with its parent node matrix makes sure that all nodes will
    inherit the transformations from all previous nodes in the model’s skeleton hierarchy.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `updateTRSMatrix()` 也会检索父节点的 TRS 矩阵，并将局部 TRS 矩阵与父节点的 TRS 矩阵相乘。将局部 TRS 矩阵与其父节点矩阵结合确保所有节点都会从模型骨架层次结构中的所有先前节点继承变换。
- en: 'Finally, we multiply the TRS matrix of the current node by the bone offset
    matrix for the node to compute the final world position for every node:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将当前节点的 TRS 矩阵与节点的骨骼偏移矩阵相乘，以计算每个节点的最终世界位置：
- en: '[PRE55]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Reusing the model nodes works fine unless you plan to add a parallel (multi-threaded)
    calculation of instance animations: if more than one thread accesses the nodes
    of the model at the same time, at least one thread is modifying the node properties
    while other threads are reading the data, thus a so-called data race may occur,
    leading to a possible mix-up of the old and new data.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你计划添加实例动画的并行（多线程）计算，否则重用模型节点是可行的：如果有多个线程同时访问模型的节点，至少有一个线程正在修改节点属性，而其他线程正在读取数据，因此可能会发生所谓的数据竞争，导致新旧数据的混淆。
- en: So, when using a multi-threading version of the code, a local copy of the node
    list will be required. The additional node map can be generated from the node
    list with a simple iteration over the list, adding the nodes by their names to
    a map.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用代码的多线程版本时，需要一个节点的本地副本。可以通过简单遍历列表并按名称将节点添加到映射中来生成额外的节点映射。
- en: Storing instance-specific settings
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储实例特定的设置
- en: 'The remaining per-instance settings are stored in the struct `InstanceSettings`,
    defined in the file `InstanceSettings.h` in the `model` folder:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的每个实例设置存储在`InstanceSettings`结构体中，该结构体在`model`文件夹中的`InstanceSettings.h`文件中定义：
- en: '[PRE56]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the first three variables, `isWorldPosition`, `isWorldRotation`, and `isScale`,
    the rotation, translation, and uniform scale of the instance are stored. The prefix
    `is` does not mean “it is” in this context but is the abbreviation of the struct
    name to have distinct variable names.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个变量`isWorldPosition`、`isWorldRotation`和`isScale`中，存储了实例的旋转、平移和均匀缩放。这里的`is`前缀并不表示“它是”，而是结构体名称的缩写，以具有不同的变量名。
- en: The fourth variable, `isSwapYZAxis`, has been added for tools using a different
    coordinate system. While we are using the Y axis as the vertical axis, several
    tools used (and still use) a coordinate system where the Z axis is vertical, and
    the Y axis is one of the horizontal axes. To change the coordinate systems, a
    simple rotation matrix will be applied if `isSwapYZAxis` is set to `true`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个变量`isSwapYZAxis`是为了使用不同坐标系统的工具而添加的。虽然我们使用Y轴作为垂直轴，但一些工具（以及仍在使用）使用一个坐标系统，其中Z轴是垂直的，而Y轴是水平轴之一。如果将`isSwapYZAxis`设置为`true`，则将应用一个简单的旋转矩阵来更改坐标系统。
- en: The remaining three variables, `isAnimClipNr`, `isAnimPlayTimePos`, and `isAnimSpeedFactor`,
    are also quite self-explanatory. These variables are used to control the animation
    parameters of the instance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的三个变量`isAnimClipNr`、`isAnimPlayTimePos`和`isAnimSpeedFactor`也非常直观。这些变量用于控制实例的动画参数。
- en: Using the `AssimpModel` and `AsssimpInstance` classes will help us to develop
    a simple way to add and delete models and instances.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AssimpModel`和`AsssimpInstance`类将帮助我们以简单的方式添加和删除模型和实例。
- en: Dynamic model and instance management
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态模型和实例管理
- en: 'The first building block of dynamic management is the struct `ModelAndInstanceData`,
    defined in the file `ModelAndInstanceData.h` in the `model` folder. A variable
    of this struct is maintained by the renderer, used during the `draw()` call, and
    also handed over to the UI:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 动态管理的第一个构建块是`ModelAndInstanceData`结构体，该结构体在`model`文件夹中的`ModelAndInstanceData.h`文件中定义。该结构体的一个变量由渲染器维护，在`draw()`调用期间使用，并且也传递给UI：
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first vector, `miModelList`, contains all loaded models in the order of
    their addition. This list is shown in the UI as a list of currently loaded models.
    By using `miSelectedModel`, we keep track of which model is selected in the UI.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个向量`miModelList`包含所有按添加顺序加载的模型。此列表在UI中以当前加载的模型列表的形式显示。通过使用`miSelectedModel`，我们跟踪UI中选定的模型。
- en: 'Next, we maintain two separate data structures for the instances:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们维护两个独立的数据结构来存储实例：
- en: '[PRE58]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The instance is stored in two different kinds of structures for the same reasons
    as the node map and node list – depending on the requirements, accessing the instances
    in one or the other data structure will be faster and/or simpler.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 实例存储在两种不同的结构中，原因与节点图和节点列表相同——根据需求，访问一个或另一个数据结构中的实例将更快或更简单。
- en: The `miAssimpInstances` is a normal `std::vector`, where all instances of all
    models are stored. The instances vector is used to create the list of instances
    in the UI, retaining the order of addition. If instances or models are removed,
    the instances vector will be cleaned, still keeping the order of the remaining
    models.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`miAssimpInstances`是一个普通的`std::vector`，其中存储了所有模型的全部实例。实例向量用于在UI中创建实例列表，保留添加顺序。如果删除实例或模型，实例向量将被清理，但仍保持剩余模型的顺序。'
- en: For `miAssimpInstancesPerModel`, the reason is different. When we want to draw
    the models in the renderer, we need all instances of a specific model to collect
    the bone matrices for animated models, and the normal node matrices for non-animated
    models. Sorting or filtering the `miAssimpInstances` vector on every draw call
    would be quite expensive on the CPU side, so the separate structure helps us here.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`miAssimpInstancesPerModel`，原因不同。当我们想在渲染器中绘制模型时，我们需要收集特定模型的全部实例的骨骼矩阵（对于动画模型）和普通节点矩阵（对于非动画模型）。在每次绘制调用中对`miAssimpInstances`向量进行排序或过滤在CPU端会相当昂贵，因此单独的结构体在这里帮助我们。
- en: 'At the end of the `ModelAndInstanceData` struct, some callback variables are
    defined:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ModelAndInstanceData`结构体的末尾，定义了一些回调变量：
- en: '[PRE59]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These callbacks are used to move the job of creating or deleting models and
    instances from the UI back to the renderer. The UI is not the right place to adjust
    the data structures for models and instances, so these tasks will be forwarded
    to the renderer.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调用于将创建或删除模型和实例的工作从 UI 返回到渲染器。UI 不是调整模型和实例数据结构的正确地方，因此这些任务将被转发到渲染器。
- en: 'The callbacks themselves are C++-style function pointers, created with `std::function`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 回调本身是 C++ 风格的函数指针，使用 `std::function` 创建：
- en: '[PRE60]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Going back to the renderer, we look at the `addModel()` method that is called
    from the UI, as mentioned in the section *Loading the model file*.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 回到渲染器，我们查看在 *加载模型文件* 部分中提到的从 UI 调用的 `addModel()` 方法。
- en: 'The `addModel()` method for the OpenGL renderer looks like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 渲染器的 `addModel()` 方法看起来像这样：
- en: '[PRE61]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: First, we check if the model has been already loaded. To avoid confusion, a
    model file can be loaded only once. Having the exact same model file loaded twice
    (or more times) makes little sense.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查模型是否已经被加载。为了避免混淆，模型文件只能加载一次。将完全相同的模型文件加载两次（或更多次）几乎没有意义。
- en: 'Now, we try to load the specified model file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们尝试加载指定的模型文件：
- en: '[PRE62]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When the loading fails, the model also returns `false` to the caller, even though
    the return value is not used currently.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载失败时，模型也会将 `false` 返回给调用者，尽管当前没有使用返回值。
- en: 'If the model file can be loaded, it will be placed into a `std::vector` of
    models:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型文件可以加载，它将被放置到模型的 `std::vector` 中：
- en: '[PRE63]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: From this list, the UI generates the combo box with the currently loaded model.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中，UI 生成当前加载的模型的组合框。
- en: 'We also add an instance of the model and return the information about a successfully
    loaded model to the caller:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个模型实例，并将成功加载的模型的信息返回给调用者：
- en: '[PRE64]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For a loaded model to be helpful, we need to create at least one instance, so
    we have something to render in the world. We use the already implemented way of
    creating a first instance, instead of having a separate solution.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使加载的模型有用，我们需要至少创建一个实例，这样我们就有东西可以在世界中渲染。我们使用已经实现的方式来创建第一个实例，而不是有一个单独的解决方案。
- en: 'The `addInstance()` method is also only a couple of lines long:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`addInstance()` 方法也只有几行长：'
- en: '[PRE65]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The signature of the method shows that we return the created instance to the
    caller. Even though the instance will be added to the internal data structures,
    getting the new instance from the method may be handy, i.e., when the instance
    should be further adjusted.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的签名显示，我们将创建的实例返回给调用者。尽管实例将被添加到内部数据结构中，但从方法中获取新实例可能很方便，即当实例需要进一步调整时。
- en: 'First, we create a new smart pointer of an `AssimpInstance` object:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `AssimpInstance` 对象的新智能指针：
- en: '[PRE66]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here, the base model is given as the only parameter. The constructor of the
    `AssimpInstance` class has three additional parameters with default values set:
    the initial position, rotation, and scale. Setting these parameters may be useful
    in the future, but to create a single instance, they can be omitted.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，基础模型作为唯一参数给出。`AssimpInstance` 类的构造函数有三个额外的参数，并设置了默认值：初始位置、旋转和缩放。设置这些参数可能在将来是有用的，但为了创建单个实例，它们可以被省略。
- en: 'Now, the new instance is inserted into two data structures, `miAssimpInstances`
    and `miAssimpInstancesPerModel`, of the struct `ModelAndInstanceData`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新实例被插入到 `ModelAndInstanceData` 结构体的两个数据结构 `miAssimpInstances` 和 `miAssimpInstancesPerModel`
    中：
- en: '[PRE67]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As the last steps, we update the triangle count shown in the UI and return the
    newly created instance
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后几步，我们更新 UI 中显示的三角形计数，并返回新创建的实例
- en: '[PRE68]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Deleting models and instances follows broadly the same path. The UI triggers
    the action via the callback; the renderer searches for the instance, or the model
    and all instances of that model, and removes them from the data structures.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 删除模型和实例大致遵循相同的路径。UI 通过回调触发操作；渲染器搜索实例，或该模型的所有实例，并将它们从数据结构中删除。
- en: Drawing all instances
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制所有实例
- en: 'The process of drawing the instances of the `Assimp` models has not changed
    much. We need to loop over all model instances, instead of just a single model.
    We use an “instanced” type of call to the graphics API that draws all instances
    of one `Assimp` model directly on the GPU:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 `Assimp` 模型实例的过程没有太大变化。我们需要遍历所有模型实例，而不仅仅是单个模型。我们使用一种“实例化”类型的图形 API 调用，直接在
    GPU 上绘制一个 `Assimp` 模型的所有实例：
- en: Iterate over the `miAssimpInstancesPerModel` map to find all instances of a
    specific model.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `miAssimpInstancesPerModel` 映射以找到特定模型的全部实例。
- en: If the model is animated, update the animation with the delta time between the
    last frame and this frame, and collect the new bone matrices.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型是动画的，则使用上一帧和当前帧之间的时间差更新动画，并收集新的骨骼矩阵。
- en: If the model is not animated, simply get the node matrices of the instances.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型不是动画的，则只需获取实例的节点矩阵。
- en: Upload the matrix data to the shader storage buffer on the shader.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩阵数据上传到着色器上的着色器存储缓冲区。
- en: Issue an instanced draw call to the graphics API.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向图形 API 发出实例绘制调用。
- en: For *step 5* of the list, it is mandatory to have the exact count of the instances
    per model available as quickly as possible. The fastest way to get the number
    of instances is to measure the size of each vector in the `miAssimpInstancesPerModel`
    map.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的*第 5 步*，必须尽快获得每个模型实例的确切数量。获取实例数量的最快方法是通过测量 `miAssimpInstancesPerModel`
    映射中每个向量的大小。
- en: If we use the unsorted `miAssimpInstances` vector to draw the instances instead,
    collecting all instances of the same model type would require extra work. Iterating
    over the `miAssimpInstances` vector to find all instances of the same model and
    adding these instances to temporary data structures costs precious time. This
    strategy would lower the maximum number of frames per second we could achieve.
    In order to use instanced draw calls, we need to process instances grouped by
    their associated model. So, we are drawing all instances by using the `miAssimpInstancesPerModel`
    vector.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用未排序的 `miAssimpInstances` 向量来绘制实例而不是实例，则需要额外的工作来收集相同模型类型的所有实例。遍历 `miAssimpInstances`
    向量以找到相同模型的实例并将这些实例添加到临时数据结构中会花费宝贵的时间。这种策略会降低我们能够达到的最大每秒帧数。为了使用实例绘制调用，我们需要按关联的模型分组处理实例。因此，我们使用
    `miAssimpInstancesPerModel` 向量绘制所有实例。
- en: '*Figure 1.21* shows the application after loading the example model from the
    `assets` folder and spawning a number of instances:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.21* 显示了从 `assets` 文件夹加载示例模型并生成多个实例后的应用程序：'
- en: '![](img/B22428_01_21.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21](img/B22428_01_21.png)'
- en: 'Figure 1.21: Multiple instances of the example animated character model'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21：示例动画角色模型的多个实例
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took the first steps toward mastering C++ game animation
    programming by using **Open Asset Importer Library**, or `Assimp`. `Assimp` enables
    us to simplify and accelerate the path to animating and rendering model instances.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用**Open Asset Importer Library**，或 `Assimp`，迈出了掌握 C++ 游戏动画编程的第一步。`Assimp`使我们能够简化并加速动画和渲染模型实例的路径。
- en: We started by looking at the general data structures of the `Assimp` library,
    how to parse the different parts of a file, and in which order. Next, we added
    a nice ImGui-based file dialog to the code, allowing us to select files in an
    interactive manner, instead of having to hardcode one or more model files we wish
    to open. At the end of the chapter, we explored how to add or remove models and
    instances at runtime, enabling us to create a more “crowded” virtual world.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看 `Assimp` 库的一般数据结构，如何解析文件的不同部分以及顺序。接下来，我们在代码中添加了一个基于 ImGui 的文件对话框，允许我们以交互式方式选择文件，而不是必须硬编码一个或多个我们希望打开的模型文件。在章节末尾，我们探讨了如何在运行时添加或删除模型和实例，使我们能够创建一个更“拥挤”的虚拟世界。
- en: In [*Chapter 2*](Chapter_2.xhtml), we will move the computational load to calculate
    the model matrices from the CPU to the GPU, allowing us to have more CPU power
    left to do amazing things in our virtual world.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](Chapter_2.xhtml)中，我们将计算模型矩阵的计算负载从 CPU 转移到 GPU，这样我们就可以保留更多的 CPU 力量来在我们的虚拟世界中完成令人惊叹的事情。
- en: Practical sessions
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: You will see this section at the end of every chapter in the book. Here, I will
    add a bunch of suggestions and exercises that you can try out with the code on
    GitHub.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书每一章的末尾看到这个部分。在这里，我将添加一些建议和练习，你可以使用 GitHub 上的代码尝试。
- en: 'You could try to do the following:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试以下操作：
- en: Add more controls to the animations, like the play direction, one/time vs. loop
    play, or even ping-pong replay, alternating between forward and backward replay
    of the chosen animation.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向动画添加更多控件，如播放方向、单次/循环播放，甚至乒乓回放，在所选动画的前进和后退播放之间交替。
- en: Add an animation slider that lets you choose to show the frame at some point
    in time of an animation.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个动画滑块，让您可以选择显示动画中某个时间点的帧。
- en: Search for model files on the internet. Try out which models work, or to which
    extent they work. You do not have to limit this search to game character models;
    you can also search for game maps in compatible formats, or 3D-printable objects.
    Remember to adjust the file dialog filter to show the additional file formats.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上搜索模型文件。尝试不同的模型，看看它们的效果如何。你不必将搜索范围仅限于游戏角色模型；也可以搜索兼容格式的游戏地图或3D打印对象。记得调整文件对话框过滤器以显示额外的文件格式。
- en: Additional resources
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'For further reading, please take a look at the following resources:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阅读，请查看以下资源：
- en: 'Microsoft on path length limit: [https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry](https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软关于路径长度限制的信息：[https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry](https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry)
- en: 'Assimp GitHub repository: [https://github.com/assimp/assimp](https://github.com/assimp/assimp)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Assimp GitHub 仓库：[https://github.com/assimp/assimp](https://github.com/assimp/assimp)
- en: 'Assimp documentation: [https://assimp-docs.readthedocs.io/en/latest/](https://assimp-docs.readthedocs.io/en/latest/)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Assimp 文档：[https://assimp-docs.readthedocs.io/en/latest/](https://assimp-docs.readthedocs.io/en/latest/)
- en: 'Learn OpenGL section on Assimp: [https://learnopengl.com/Model-Loading/Assimp](https://learnopengl.com/Model-Loading/Assimp)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Assimp 在 Learn OpenGL 中的部分：[https://learnopengl.com/Model-Loading/Assimp](https://learnopengl.com/Model-Loading/Assimp)
- en: 'Skeletal animation tutorial: [https://www.ogldev.org/www/tutorial38/tutorial38.html](https://www.ogldev.org/www/tutorial38/tutorial38.html)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼动画教程：[https://www.ogldev.org/www/tutorial38/tutorial38.html](https://www.ogldev.org/www/tutorial38/tutorial38.html)
