- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Thread Safety and Concurrency with the STL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 STL 的线程安全和并发
- en: This chapter explores concurrency within the C++ **Standard Template Library**
    (**STL**). The chapter begins by building a solid foundational understanding of
    thread safety, race conditions, and their inherent risks. We then shift to the
    STL, decoding its thread safety guarantees and spotlighting its potential pitfalls.
    As we proceed, readers will gain insights into the array of synchronization tools
    available in C++, mastering their application to safeguard STL containers in multi-threaded
    environments. Upon concluding this chapter, readers can ensure data consistency
    and stability in concurrent C++ applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 C++ **标准模板库**（**STL**）中的并发。本章首先构建了对线程安全、竞态条件和它们固有风险的坚实基础理解。然后，我们转向 STL，解码其线程安全保证，并突出其潜在陷阱。随着我们的深入，读者将了解
    C++ 中可用的各种同步工具，掌握它们在多线程环境中的应用，以保护 STL 容器。完成本章后，读者可以确保在并发 C++ 应用程序中数据的一致性和稳定性。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Concurrency versus thread safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发与线程安全
- en: Understanding thread safety
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程安全
- en: Race conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件
- en: Mutexes and locks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁和锁
- en: STL containers and thread safety
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 容器和线程安全
- en: Specific container concerns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定容器问题
- en: Concurrency support within the STL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 中的并发支持
- en: Using `std::thread`, `std::async`, `std::future`, and thread-local storage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::thread`、`std::async`、`std::future` 和线程局部存储
- en: Concurrent data structures in the STL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 中的并发数据结构
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Concurrency versus thread safety
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与线程安全
- en: '**Concurrency** is the concept of multiple tasks executing in overlapping periods.
    These tasks can either run at the same time on different processing units or might
    interleave on a single processing unit. The main goal of concurrency is to increase
    the system’s responsiveness and throughput. Concurrency is beneficial in various
    scenarios, such as when designing servers that handle multiple simultaneous client
    requests or in user interfaces that must remain responsive while processing tasks
    in the background.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是多个任务在重叠时间段内执行的概念。这些任务可以在不同的处理单元上同时运行，或者可能在单个处理单元上交错运行。并发的目标是提高系统的响应性和吞吐量。并发在各种场景中都有益，例如设计处理多个同时客户端请求的服务器或在后台处理任务的同时必须保持用户界面响应。'
- en: 'In C++, concurrency can manifest in multiple forms: multi-threading, where
    separate threads of execution run (potentially) in parallel, or asynchronous programming,
    in which specific tasks are offloaded to be executed later.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，并发可以以多种形式体现：多线程，其中独立的执行线程（可能）并行运行，或者异步编程，其中特定任务被卸载以供稍后执行。
- en: In C++, it’s crucial to understand that concurrency and **thread safety** are
    related but distinct concepts. Concurrency refers to the program’s ability to
    execute multiple sequences of operations simultaneously, which can be achieved
    through multi-threading or other parallel execution techniques. However, being
    concurrent does not inherently guarantee thread safety. Thread safety is the property
    that ensures code functions correctly when accessed by multiple threads concurrently.
    This involves carefully managing shared resources, synchronizing data access,
    and avoiding race conditions. Achieving thread safety in a concurrent environment
    is a challenging aspect of C++ programming. It requires deliberate design choices
    and the use of specific mechanisms, such as mutexes, locks, and atomic operations,
    to prevent data corruption and ensure consistent behavior across all threads.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，理解并发和 **线程安全** 是相关但不同的概念至关重要。并发指的是程序同时执行多个操作序列的能力，这可以通过多线程或其他并行执行技术实现。然而，并发本身并不保证线程安全。线程安全是确保代码在多个线程并发访问时正确运行的属性。这涉及到仔细管理共享资源、同步数据访问和避免竞态条件。在并发环境中实现线程安全是
    C++ 编程的一个挑战性方面。它需要明确的设计选择和使用特定的机制，如互斥锁、锁和原子操作，以防止数据损坏并确保所有线程的一致行为。
- en: Thread safety – a pillar for stable concurrency
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全——稳定并发的支柱
- en: '**Thread safety** refers to the capability of a piece of code to function correctly
    when accessed by multiple threads concurrently. It ensures that shared data maintain
    their integrity and that the results remain consistent. Thread safety doesn’t
    inherently mean a function or method is lock-free or lacks performance bottlenecks;
    instead, it signifies that concurrent access won’t lead to unpredictable results
    or compromise data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程安全**指的是代码在多个线程并发访问时正确运行的能力。它确保共享数据保持其完整性，结果保持一致。线程安全并不本质上意味着函数或方法是无锁的或没有性能瓶颈；相反，它表示并发访问不会导致不可预测的结果或损害数据。'
- en: 'Consider an analogy: If **concurrency** were akin to a busy city intersection,
    then thread safety would be the traffic signals ensuring that cars (threads) don’t
    crash into each other.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类比：如果**并发**类似于繁忙的城市交叉口，那么线程安全就是交通信号灯，确保汽车（线程）不会相互碰撞。
- en: The interplay of concurrency and thread safety
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发和线程安全之间的相互作用
- en: While both concepts are intertwined, they serve different purposes. Concurrency
    focuses on designing systems to perform multiple tasks in overlapping time frames,
    aiming for improved performance and responsiveness. Thread safety, on the other
    hand, is all about correctness. It’s about ensuring they don’t step on each other’s
    toes when these concurrent tasks interact with shared resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个概念相互交织，但它们服务于不同的目的。并发关注于设计系统以在重叠的时间框架内执行多个任务，旨在提高性能和响应速度。另一方面，线程安全完全是关于正确性的。它关乎确保这些并发任务在交互共享资源时不会相互干扰。
- en: 'Let’s consider a simple example: a counter class in C++. Concurrency might
    involve incrementing the counter’s value from multiple threads. However, if the
    counter’s increment operation isn’t thread-safe, two threads might read the same
    value simultaneously, increment it, and then write back the same incremented value.
    In such a case, despite trying to be faster using concurrency, the counter would
    end up missing counts, leading to incorrect results.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子：C++中的计数器类。并发可能涉及从多个线程中增加计数器的值。然而，如果计数器的增加操作不是线程安全的，两个线程可能会同时读取相同的值，增加它，然后写回相同的增加后的值。在这种情况下，尽管试图通过并发来提高速度，但计数器最终会丢失计数，导致结果不正确。
- en: Challenges and rewards
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战与回报
- en: Introducing concurrency can undoubtedly make applications faster and more responsive.
    However, it also introduces complexities. Managing multiple threads with issues
    such as deadlocks and race conditions can be challenging.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 引入并发无疑可以使应用程序更快、更响应。然而，它也引入了复杂性。管理多个线程，处理死锁和竞态条件等问题可能具有挑战性。
- en: But, when done right, the rewards are substantial. Programs become more efficient,
    potentially utilizing all available processing units fully. Applications can be
    more responsive, leading to improved user experiences. Concurrent programming
    is no longer a choice but is necessary for many modern high-performance applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果做得正确，回报是巨大的。程序变得更加高效，可能充分利用所有可用的处理单元。应用程序可以更加响应，从而提高用户体验。并发编程不再是选择，而是许多现代高性能应用程序的必要条件。
- en: Concurrency without thread safety – a recipe for chaos
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有线程安全的并发 – 混乱的配方
- en: Imagine a world where every task tries to execute itself as fast as possible
    without coordination. In such a world, tasks might collide, disrupt each other,
    and produce nonsensical outcomes. That’s what concurrent programming without thread
    safety looks like. It’s a realm where speed is prioritized over correctness, often
    leading to chaos.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个世界，每个任务都试图尽可能快地执行自己，而不进行协调。在这样的世界里，任务可能会相互碰撞，相互干扰，并产生无意义的输出。这就是没有线程安全的并发编程的样子。这是一个优先考虑速度而非正确性的领域，通常会导致混乱。
- en: As a C++ developer, the key is to find the right balance. While striving for
    high concurrency to make applications fast, investing in thread safety mechanisms
    is equally crucial to ensure correctness.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名C++开发者，关键是要找到正确的平衡。在追求高并发以使应用程序快速的同时，投资于线程安全机制同样至关重要，以确保正确性。
- en: Understanding the difference between concurrency and thread safety sets the
    stage for the following sections. We’ll be looking at the tools and constructs
    provided by the STL to achieve high concurrency and ensure thread safety.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并发和线程安全之间的区别为以下章节奠定了基础。我们将探讨STL提供的工具和结构，以实现高并发并确保线程安全。
- en: Understanding thread safety
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程安全
- en: Executing multiple simultaneous tasks can lead to boosted performance and responsiveness.
    Ensuring thread safety, especially when using the STL, becomes paramount. If overlooked,
    the dream of seamless concurrency can quickly morph into the nightmare of data
    inconsistency and unpredictable behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行多个同时任务可以提高性能和响应速度。确保线程安全，尤其是在使用 STL 时，变得至关重要。如果被忽视，无缝并发的梦想可能会迅速变成数据不一致和不可预测行为的噩梦。
- en: Thread safety in STL containers – laying the groundwork
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL 容器中的线程安全——奠定基础
- en: The allure of the STL lies in its rich ensemble of containers, which offer a
    smooth experience for storing and managing data. But the moment we introduce multiple
    threads, potential dangers loom.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的吸引力在于其丰富的容器集合，它们为存储和管理数据提供了流畅的体验。但是，一旦引入多个线程，潜在的危险就会浮现。
- en: 'Thread safety is primarily about ensuring that your code behaves predictably
    and correctly when accessed by multiple threads, even when those threads overlap.
    For STL containers, the basic guarantee is simple: simultaneous read-only access
    to containers is safe. However, once you introduce writes (modifications), things
    get intricate.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全主要关于确保当多个线程访问时，你的代码表现出可预测和正确的行为，即使这些线程是重叠的。对于 STL 容器来说，基本保证很简单：容器的同时只读访问是安全的。然而，一旦引入写入（修改），事情就变得复杂了。
- en: It’s critical to understand that while STL containers have thread-safe read
    operations, write operations don’t. If one thread is updating a container, no
    other thread should be reading or writing to it. Otherwise, we’re courting disaster
    or, in technical jargon, **undefined behavior**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要：虽然 STL 容器具有线程安全的读取操作，但写入操作则不是。如果一个线程正在更新一个容器，那么没有其他线程应该读取或写入它。否则，我们就是在招致灾难，或者用技术术语来说，就是**未定义行为**。
- en: Grasping the thread-safe nature of STL algorithms
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 STL 算法的线程安全特性
- en: If STL containers are the soul of the library, algorithms are undoubtedly its
    beating heart. They’re responsible for the STL’s rich functionality, from searching
    and sorting to transforming data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 STL 容器是库的灵魂，那么算法无疑是其跳动的心脏。它们负责 STL 的丰富功能，从搜索和排序到数据转换。
- en: 'Here’s the catch: STL algorithms are functions, and their thread safety isn’t
    determined by the algorithm itself but by the data they operate on. If an algorithm
    operates on shared data across threads without adequate synchronization, you’re
    setting the stage for race conditions, even if that algorithm only reads data.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个问题：STL 算法是函数，它们的线程安全性不是由算法本身决定的，而是由它们操作的数据决定的。如果一个算法在没有适当同步的情况下操作跨线程的共享数据，你就是在为竞态条件做准备，即使该算法只读取数据。
- en: Consider the scenario where you’re using `std::find` across multiple threads.
    While the algorithm is inherently safe for concurrent read operations, the results
    could be skewed if another thread modifies the data during the search.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，你在多个线程中使用 `std::find`。虽然该算法对于并发读取操作本质上是安全的，但如果在搜索过程中另一个线程修改了数据，结果可能会偏斜。
- en: Race conditions – the ghosts in the machine
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件——机器中的幽灵
- en: Race conditions keep concurrent programmers up at night. A **race condition**
    occurs when the behavior of your software depends on the relative timing of events,
    such as the order in which threads are scheduled. The consequences range from
    benign (slightly incorrect data) to catastrophic (complete data corruption or
    application crashes).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件让并发程序员夜不能寐。当你的软件的行为依赖于事件相对时间顺序，例如线程调度的顺序时，就会发生**竞态条件**。后果从无害（轻微错误的数据）到灾难性（完全数据损坏或应用程序崩溃）不等。
- en: Using the STL in a multi-threaded environment without the proper precautions
    can introduce race conditions. For instance, imagine two threads simultaneously
    pushing elements onto a `std::vector`. Without synchronization, the internal memory
    of the vector could become corrupted, leading to a host of problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中使用 STL 而没有采取适当的预防措施可能会引入竞态条件。例如，想象两个线程同时向一个 `std::vector` 推送元素。如果没有同步，向量的内部内存可能会损坏，导致一系列问题。
- en: 'Let’s look at a simple race condition. In this example, we will use two threads
    to increment a counter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的竞态条件。在这个例子中，我们将使用两个线程来增加一个计数器：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is a possible example output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可能的输出示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A race condition occurs because both threads access and modify the shared variable
    counter simultaneously without any synchronization mechanism (such as **mutexes**
    or **locks**). Due to the lack of synchronization, the two threads may read, increment,
    and write back the value of the counter in an unpredictable order. This leads
    to the final value of the counter being unpredictable and usually less than the
    expected 200,000, as some increments are lost. Running this program multiple times
    will likely yield different results for the final value of the counter due to
    the race condition. To resolve this issue, proper synchronization mechanisms,
    such as mutexes, should be used to ensure that only one thread modifies the shared
    variable at a time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件发生是因为两个线程同时访问和修改共享变量counter，而没有任何同步机制（如**互斥锁**或**锁**）。由于缺乏同步，两个线程可能以不可预测的顺序读取、增加并写回计数器的值。这导致计数器的最终值不可预测，通常小于预期的200,000，因为一些增加丢失了。由于竞争条件，多次运行此程序可能会得到不同的计数器最终值。为了解决这个问题，应使用适当的同步机制，如互斥锁，以确保一次只有一个线程修改共享变量。
- en: Safeguarding concurrency – the way forward
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护并发——前进的道路
- en: It’s evident that merely understanding thread safety is half the battle. As
    we progress through this chapter, we’ll arm you with the tools and techniques
    to tackle race conditions head-on, master the synchronization mechanisms at your
    disposal, and ensure that your STL-powered multi-threaded applications stand as
    bastions of stability and consistency.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，仅仅理解线程安全性只是战斗的一半。随着我们进入本章，我们将为您提供工具和技术来直面竞争条件，掌握可用的同步机制，并确保您的基于STL的多线程应用程序成为稳定性和一致性的堡垒。
- en: Race conditions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争条件
- en: A race condition in programming occurs when the behavior of a system depends
    on the relative timing of multiple threads or processes. In such scenarios, the
    system’s outcome becomes unpredictable because different threads may access and
    modify shared data concurrently without proper synchronization. This can lead
    to inconsistent or erroneous results, as the final state of the data depends on
    the order in which the threads execute, which cannot be determined in advance.
    Race conditions are a common issue in concurrent programming. They can be particularly
    challenging to detect and resolve, requiring careful design and synchronization
    mechanisms to ensure correct and predictable program behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，当系统的行为依赖于多个线程或进程的相对时间顺序时，就会发生竞争条件。在这种情况下，系统的结果变得不可预测，因为不同的线程可能在不适当的同步下同时访问和修改共享数据。这可能导致不一致或错误的结果，因为数据的最终状态取决于线程执行的顺序，而这个顺序无法提前确定。竞争条件是并发编程中常见的问题。它们可能特别具有挑战性，需要仔细的设计和同步机制来确保正确的和可预测的程序行为。
- en: Steering clear of a silent peril – race conditions in the STL
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免无声的陷阱——STL中的竞争条件
- en: As you journey into concurrent programming, race conditions represent one of
    the most subtle yet treacherous pitfalls. Though silent in their manifestation,
    they can cause unexpected and, at times, bewildering results. Recognizing and
    sidestepping these race conditions, especially within the realm of the STL, is
    crucial to crafting robust multi-threaded applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进入并发编程之旅时，竞争条件代表了一个最微妙但最危险的陷阱之一。尽管它们的表现在沉默中，但它们可能导致意外和有时令人困惑的结果。识别并避开这些竞争条件，尤其是在STL领域，对于构建健壮的多线程应用程序至关重要。
- en: The anatomy of a race condition in the STL
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL中竞争条件的解剖
- en: At its core, a race condition materializes when the behavior of your application
    hinges on the sequence or timing of uncontrollable events. In the STL context,
    this typically arises when multiple threads access shared data in an uncoordinated
    fashion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，当您的应用程序的行为取决于不可控事件的序列或时机时，竞争条件就会出现。在STL的上下文中，这通常发生在多个线程以无协调的方式访问共享数据时。
- en: Imagine a scenario where two threads, in an unfortunate coincidence, try to
    insert elements into the same position of `std::vector` concurrently or consider
    another instance where one thread reads from `std::unordered_map` while another
    erases an element. What is the outcome? Undefined behavior, which in the world
    of C++, is the equivalent of opening Pandora’s box.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，其中两个线程不幸地同时尝试将元素插入`std::vector`的相同位置，或者考虑另一个实例，其中一个线程从`std::unordered_map`中读取，而另一个线程删除一个元素。结果会怎样？未定义的行为，在C++的世界里，这相当于打开了潘多拉的盒子。
- en: More than meets the eye
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超出表面
- en: Race conditions are especially treacherous due to their unpredictable nature.
    While a concurrent application may seem to work flawlessly in one run, slight
    changes in thread execution timings can lead to entirely different results in
    the next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件由于其不可预测性而特别危险。虽然并发应用程序可能在一次运行中看似完美无缺，但线程执行时间上的微小变化可能导致下一次运行时出现完全不同的结果。
- en: Beyond erratic behavior, race conditions with STL containers and algorithms
    can lead to more sinister problems. Data corruption, memory leaks, and crashes
    are just the tip of the iceberg. Given their elusive and intermittent appearance,
    these issues can be challenging to debug.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常行为外，STL容器和算法中的竞态条件还可能导致更严重的问题。数据损坏、内存泄漏和崩溃只是冰山一角。鉴于这些问题难以捉摸和间歇性出现，调试这些问题可能具有挑战性。
- en: Anticipating race conditions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测竞态条件
- en: 'Forewarned is forearmed. By familiarizing yourself with common scenarios where
    race conditions manifest in the STL, you position yourself to tackle them preemptively:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有备无患。通过熟悉STL中竞态条件出现的常见场景，你可以提前应对这些问题：
- en: '`std::vector` and `std::string`, automatically resize when their capacity is
    exceeded. If two threads simultaneously trigger a resize, the internal state could
    be left in turmoil.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`和`std::string`，当它们的容量超过时，会自动调整大小。如果两个线程同时触发调整大小，内部状态可能会陷入混乱。'
- en: '**Iterator invalidation**: Modifying containers often invalidates existing
    iterators. If one thread traverses using an iterator while another modifies the
    container, the first thread’s iterator can end up in no-man’s-land.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器失效**：修改容器通常会使得现有的迭代器失效。如果一个线程使用迭代器遍历容器，而另一个线程正在修改容器，那么第一个线程的迭代器可能会陷入无人之地。'
- en: '**Algorithm assumptions**: STL algorithms make certain assumptions about the
    data they operate upon. Concurrent modifications can violate these assumptions,
    leading to incorrect results or infinite loops.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法假设**：STL算法对其操作的数据做出某些假设。并发修改可能会违反这些假设，导致结果错误或无限循环。'
- en: Safeguarding your code – a proactive stance
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护你的代码——采取主动立场
- en: Having acquainted ourselves with the potential hotspots, the natural progression
    is to fortify our code against these hazards. The essence lies in synchronization.
    We can effectively thwart race conditions by ensuring that only one thread can
    access shared data or perform certain operations simultaneously.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了潜在的“热点”之后，自然地，我们需要加强我们的代码以抵御这些危险。关键在于同步。我们可以通过确保只有一个线程可以同时访问共享数据或执行某些操作来有效地防止竞态条件。
- en: However, indiscriminate synchronization can lead to performance bottlenecks,
    rendering the benefits of concurrency moot. The key is to strike a balance, applying
    synchronization judiciously.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不加区分的同步可能导致性能瓶颈，使并发的优势化为乌有。关键在于找到平衡点，审慎地应用同步。
- en: We’ll introduce a robust arsenal of tools and techniques as we move further
    into this chapter. From mutexes to locks, you’ll acquire the means to detect and
    effectively neutralize race conditions, ensuring your STL-driven applications
    are swift and steadfast.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入本章，我们将介绍一系列强大工具和技术。从互斥锁到锁，你将掌握检测和有效中和竞态条件的方法，确保你的STL驱动应用程序快速且稳定。
- en: Are you ready to conquer the challenges of concurrent programming with the STL?
    Let’s navigate this landscape together, ensuring your software remains consistent,
    reliable, and race condition-free.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好用STL征服并发编程的挑战了吗？让我们共同探索这个领域，确保你的软件保持一致性、可靠性和无竞态条件。
- en: Mutexes and locks
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁和锁
- en: A **mutex**, short for **mutual exclusion**, is akin to a digital gatekeeper.
    It regulates access, ensuring that at any given moment, only a single thread can
    enter its protected domain, eliminating the chaos of concurrent access. Imagine
    a high-stakes auction room where only one person can place a bid at any instant,
    thereby preventing overlap and conflict. That’s the function of a mutex in the
    world of multi-threaded applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁**，简称**互斥**，类似于一个数字守门人。它调节访问，确保在任何给定时刻，只有一个线程可以进入其受保护的领域，消除并发访问的混乱。想象一下一个高风险的拍卖室，在任何时刻只能有一个人出价，从而防止重叠和冲突。这就是多线程应用程序中互斥锁的功能。'
- en: Within the C++ Standard Library, the header `<mutex>` bestows several types
    of mutexes upon us. The most commonly used among them is `std::mutex`. This basic
    mutex is a versatile tool suitable for many synchronization needs. A pair of operations—`lock()`
    and `unlock()`—provides a straightforward means to guard shared resources.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++标准库中，头文件`<mutex>`赋予我们几种类型的互斥锁。其中最常用的是`std::mutex`。这是一个多用途的工具，适用于许多同步需求。一对操作——`lock()`和`unlock()`——提供了一种简单的方法来保护共享资源。
- en: From manual to automatic – lock guards and unique locks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从手动到自动 - 锁保护与独特锁
- en: Manually locking and unlocking mutexes can be error-prone. There’s always the
    lurking danger of forgetting to unlock a mutex, leading to a deadlock. Enter lock
    guards and unique locks; these simplify mutex management by embracing the **resource
    acquisition is initialization** (**RAII**) principle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 手动锁定和解锁互斥锁可能会出错。总会有忘记解锁互斥锁的潜在危险，导致死锁。这时就出现了锁保护与独特锁；它们通过采用**资源获取即初始化（RAII**）原则简化了互斥锁的管理。
- en: '`std::lock_guard` is a lightweight wrapper that automatically manages the mutex’s
    state. Once a lock guard acquires a mutex, it guarantees its release when the
    lock guard’s scope ends. This eliminates the risk of forgetting to release the
    mutex.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::lock_guard`是一个轻量级包装器，它自动管理互斥锁的状态。一旦锁保护器获取了互斥锁，它就保证在锁保护器的作用域结束时释放它。这消除了忘记释放互斥锁的风险。'
- en: On the other hand, `std::unique_lock` is a bit more flexible. Besides the automatic
    lock management that `lock_guard` offers, `unique_lock` provides manual control,
    deferred locking, and even the ability to transfer ownership of a mutex. This
    makes it suitable for more complex synchronization scenarios.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::unique_lock`要灵活一些。除了`lock_guard`提供的自动锁定管理外，`unique_lock`还提供了手动控制、延迟锁定以及转移互斥锁所有权的能力。这使得它适用于更复杂的同步场景。
- en: Avoiding the stalemate – deadlock prevention
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免僵局 - 死锁预防
- en: Imagine a scenario where two threads are in a standoff, each expecting the other
    to relinquish a resource. As a result, both are stuck in a perpetual waiting,
    leading to a classic deadlock. This situation isn’t merely hypothetical, especially
    when mutexes are involved, as they can inadvertently create such a deadlock if
    not managed carefully. When multiple mutexes are involved, it is essential to
    adopt strategies to avoid deadlocks. One common approach is always to acquire
    the mutexes in the same order, regardless of which thread you are in. But when
    this isn’t feasible, `std::lock` comes to the rescue. It’s designed to lock multiple
    mutexes simultaneously without the risk of causing a deadlock.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，其中两个线程处于僵持状态，每个线程都期待对方释放资源。结果，两者都陷入永久的等待，导致经典的死锁。这种情况并非纯粹假设，尤其是在涉及互斥锁的情况下，因为如果不小心管理，它们可能会无意中造成这样的死锁。当涉及多个互斥锁时，采用避免死锁的策略至关重要。一种常见的方法是始终以相同的顺序获取互斥锁，无论你在哪个线程中。但是，当这不可行时，`std::lock`就派上用场了。它设计用来同时锁定多个互斥锁，而不会造成死锁的风险。
- en: Incorporating mutexes with STL containers
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将互斥锁与STL容器结合使用
- en: With the knowledge of mutexes, lock guards, unique locks, and deadlock prevention
    techniques, integrating these synchronization tools with STL containers becomes
    an intuitive exercise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了互斥锁、锁保护、独特锁和死锁预防技术之后，将这些同步工具与STL容器集成变得直观起来。
- en: For instance, protecting `std::vector` from concurrent access might involve
    placing `std::lock_guard` at every function that modifies or accesses the vector.
    Similarly, if multiple operations on `std::unordered_map` must be executed atomically,
    `std::unique_lock` can offer protection and the flexibility to manually control
    the lock’s state when needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了保护`std::vector`免受并发访问，可能需要在修改或访问向量的每个函数中放置`std::lock_guard`。同样，如果必须在`std::unordered_map`上执行多个原子操作，`std::unique_lock`可以提供保护，并在需要时手动控制锁的状态的灵活性。
- en: With the tools of mutexes and locks in hand, threading in the STL no longer
    feels like treading on thin ice. By ensuring the reasonable and consistent application
    of these synchronization primitives, you can harness the full power of concurrency
    while keeping the pitfalls of race conditions and deadlocks at bay.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有互斥锁和锁的工具后，STL中的线程编程不再像在薄冰上行走。通过确保这些同步原语的合理和一致应用，你可以充分利用并发能力，同时避免竞争条件和死锁的陷阱。
- en: In the following sections, we’ll continue our exploration, specifically focusing
    on the unique challenges and considerations when threading with specific STL containers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续我们的探索，特别关注在特定 STL 容器中进行线程操作时遇到的独特挑战和考虑因素。
- en: STL containers and thread safety
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL 容器和线程安全
- en: When discussing STL containers, assuming a blanket level of thread safety across
    all of them is tempting. However, such assumptions can be misleading. By default,
    STL containers are not thread-safe for modifications, meaning if one thread modifies
    a container, other threads simultaneously accessing it might lead to undefined
    behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论 STL 容器时，假设它们在所有容器中都具备相同的线程安全性是诱人的。然而，这样的假设可能会误导。默认情况下，STL 容器在修改时不是线程安全的，这意味着如果一个线程正在修改一个容器，同时其他线程也在访问它，可能会导致未定义的行为。
- en: However, some inherent guarantees exist. For instance, it is safe for multiple
    threads to simultaneously read from an STL container, as long as no thread is
    modifying it. This is often referred to as **read concurrency**. Yet, the moment
    even a single thread tries to change the container while others read, we’re back
    in the dangerous territory of race conditions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一些内在的保证。例如，只要没有线程正在修改它，多个线程同时从 STL 容器中读取是安全的。这通常被称为**读并发**。然而，当甚至有一个线程试图在其他人读取时更改容器，我们就会回到危险的竞争条件领域。
- en: When safety needs reinforcements – concurrent modifications
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当安全需求需要加固时——并发修改
- en: While reading concurrently is safe, modifications bring a different set of challenges.
    Suppose two or more threads attempt to modify an STL container simultaneously.
    In that case, the behavior becomes undefined unless synchronization mechanisms
    (such as those we explored with mutexes and locks) are used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并发读取是安全的，但修改会带来不同的挑战。假设两个或更多线程同时尝试修改 STL 容器，那么除非使用同步机制（例如我们用互斥锁和锁探索过的那些），否则行为将是未定义的。
- en: Take the case of `std::vector`. A race condition emerges if one thread appends
    an element using `push_back` while another tries to remove one with `pop_back`
    without a mutex guarding these operations. The vector’s size could change mid-operation,
    or memory could be reallocated, leading to crashes or data inconsistencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `std::vector` 为例。如果在没有互斥锁保护这些操作的情况下，一个线程使用 `push_back` 添加元素，而另一个线程尝试使用 `pop_back`
    移除元素，就会产生竞争条件。向量的大小可能在操作过程中改变，或者内存可能被重新分配，导致崩溃或数据不一致。
- en: Container iterators – the fragile bridge
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器迭代器——脆弱的桥梁
- en: Iterators are fundamental to STL containers, providing a means to traverse and
    manipulate container elements. However, iterators are fragile when it comes to
    concurrency. If a thread modifies the container in a way that causes reallocation
    or restructuring, other threads’ iterators might become invalidated. Using invalidated
    iterators is, yet again, undefined behavior.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是 STL 容器的基石，提供了遍历和操作容器元素的手段。然而，当涉及到并发时，迭代器是脆弱的。如果一个线程以导致重新分配或结构重组的方式修改容器，其他线程的迭代器可能会失效。使用失效的迭代器是，再次强调，未定义的行为。
- en: For example, in containers such as `std::list` or `std::map`, adding an element
    won’t invalidate the existing iterators. However, with `std::vector`, a reallocation
    triggered when the vector exceeds its current capacity can invalidate all existing
    iterators. Being aware of these nuances is crucial when orchestrating multi-threaded
    operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `std::list` 或 `std::map` 等容器中，添加元素不会使现有的迭代器失效。然而，在 `std::vector` 中，当向量超出其当前容量时触发的重新分配可能会使所有现有的迭代器失效。在安排多线程操作时，意识到这些细微差别至关重要。
- en: Containers with a built-in shield – concurrent containers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有内置保护机制的容器——并发容器
- en: In recognizing the challenges developers face when synchronizing standard STL
    containers, the library introduced concurrent containers. These containers, such
    as `std::atomic` and those in the `concurrency` namespace (for some compilers),
    come with built-in synchronization, offering thread-safe operations at the potential
    cost of performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在认识到开发者在同步标准 STL 容器时面临的挑战时，该库引入了并发容器。这些容器，例如 `std::atomic` 以及某些编译器的 `concurrency`
    命名空间中的容器（对于某些编译器），都内置了同步机制，以性能的潜在代价提供线程安全的操作。
- en: It’s important to note that these containers might not provide the same interface
    or performance characteristics as their standard STL counterparts. They are specialized
    tools that are ideal for scenarios where the overhead of manual synchronization
    might be too significant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些容器可能不会提供与它们的标准STL对应物相同的接口或性能特性。它们是针对手动同步开销可能过于显著的场景而专门设计的工具。
- en: While STL containers bring a world of convenience and efficiency to C++ programming,
    they come with the responsibility of understanding their threading characteristics.
    By discerning when and where explicit synchronization is required and leveraging
    the tools and techniques at our disposal, we can ensure that our multi-threaded
    applications remain robust, efficient, and free of concurrency-induced bugs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STL容器为C++编程带来了极大的便利和效率，但它们也带来了理解其线程特性的责任。通过判断何时何地需要显式同步，并利用我们可用的工具和技术，我们可以确保我们的多线程应用程序保持健壮、高效，并且没有由并发引起的错误。
- en: Specific container concerns
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定容器问题
- en: Different STL container types present unique challenges and considerations in
    a multi-threaded environment. The thread safety of operations on these containers
    is not inherently guaranteed, making their use in concurrent scenarios a matter
    of careful planning. For instance, containers such as `std::vector` or `std::map`
    might behave unpredictably when simultaneously accessed or modified from multiple
    threads, leading to data corruption or race conditions. In contrast, containers
    such as `std::atomic` are designed for safe concurrent operations on individual
    elements, but they don’t safeguard the container’s structure as a whole. Therefore,
    understanding the specific threading implications of each STL container type is
    essential. Developers must implement appropriate locking mechanisms or use thread-safe
    variants where necessary to ensure data integrity and correct program behavior
    in a multi-threaded environment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的STL容器类型在多线程环境中具有独特的挑战和考虑因素。对这些容器上的操作的安全性不是固有的保证，因此在并发场景中使用它们是一个需要仔细规划的问题。例如，`std::vector`
    或 `std::map` 等容器在同时被多个线程访问或修改时可能会表现出不可预测的行为，导致数据损坏或竞争条件。相比之下，`std::atomic` 等容器是为在单个元素上安全进行并发操作而设计的，但它们并不保护容器结构的整体安全性。因此，了解每个STL容器类型的特定线程影响是至关重要的。开发人员必须实现适当的锁定机制或在必要时使用线程安全变体，以确保在多线程环境中数据完整性和正确的程序行为。
- en: Behaviors of std::vector in multi-threading
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::vector 在多线程中的行为
- en: '`std::vector` is a widely-used STL container that acts as a dynamic array,
    adjusting its size as needed. Its contiguous memory allocation provides advantages
    such as cache locality. However, in multi-threaded scenarios, challenges arise.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 是一种广泛使用的STL容器，充当动态数组，根据需要调整其大小。其连续内存分配提供了诸如缓存局部性等优势。然而，在多线程场景中，会面临挑战。'
- en: For example, when a vector’s capacity is surpassed and reallocates memory, all
    associated iterators, pointers, and references can be invalidated. If one thread
    iterates the vector while another prompts a reallocation (adding elements beyond
    its limit), this can lead to issues. To prevent such scenarios, synchronization
    mechanisms should be implemented during operations that trigger reallocations
    when multiple threads access the vector.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当向量的容量超出并重新分配内存时，所有相关的迭代器、指针和引用都可能失效。如果一个线程正在迭代向量，而另一个线程触发重新分配（添加超出其限制的元素），这可能会导致问题。为了防止此类情况，应在多个线程访问向量时触发重新分配的操作期间实现同步机制。
- en: Characteristics of std::list in concurrency
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::list 在并发中的特性
- en: '`std::list`, which is a doubly-linked list, has behaviors that are beneficial
    in multi-threaded situations but also require caution. A key advantage is that
    insertions or deletions do not invalidate iterators unless they target the specific
    removed element, making some operations naturally thread-safe.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`，作为一种双链表，在多线程情况下具有有益的行为，但也需要谨慎。一个关键优势是，除非目标特定的被删除元素，否则插入或删除操作不会使迭代器失效，这使得某些操作自然地线程安全。'
- en: However, there’s a need for caution. While iterators may remain intact, concurrent
    modifications can alter the sequence of elements, resulting in inconsistent outcomes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要谨慎行事。虽然迭代器可能保持不变，但并发修改可能会改变元素的顺序，导致结果不一致。
- en: Considerations with associative containers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联容器的考虑因素
- en: Containers such as `std::set`, `std::map`, `std::multiset`, and `std::multimap`
    order elements based on their keys. This ensures organized data retrieval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::set`、`std::map`、`std::multiset`和`std::multimap`这样的容器根据它们的键对元素进行排序。这确保了有组织的数据检索。
- en: In multi-threaded situations, this trait presents challenges. Concurrent element
    insertions might result in an unpredictable final sequence. Additionally, concurrent
    removals can give rise to race conditions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程情况下，这个特性会带来挑战。并发的元素插入可能会导致不可预测的最终序列。此外，并发的删除可能会引发竞争条件。
- en: Concurrency aspects of unordered containers
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无序容器的并发方面
- en: The unordered versions of associative containers, such as `std::unordered_set`
    and `std::unordered_map`, do not keep elements in a defined order. However, they
    are not exempt from multi-threading issues. These containers leverage hashing,
    and element additions might trigger rehashing to optimize performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无序版本的关联容器，如`std::unordered_set`和`std::unordered_map`，不按定义的顺序保持元素。然而，它们并不免除多线程问题。这些容器利用散列，元素添加可能会触发重新散列以优化性能。
- en: Rehashing can lead to iterator invalidation. Hence, despite their unordered
    nature, careful handling is necessary during concurrent operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重新散列可能导致迭代器失效。因此，尽管它们是无序的，但在并发操作期间仍需谨慎处理。
- en: Insights into container adaptors
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器的见解
- en: The STL provides container adaptors such as `std::stack`, `std::queue`, and
    `std::priority_queue`. These don’t possess their storage and instead encapsulate
    other containers. Their thread safety properties depend on the containers they
    are based on. For example, an instance of `std::stack` that utilizes `std::vector`
    would have the same reallocation and iterator invalidation issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了容器适配器，如`std::stack`、`std::queue`和`std::priority_queue`。它们没有自己的存储，而是封装了其他容器。它们的线程安全性取决于它们所基于的容器。例如，使用`std::vector`的`std::stack`实例将会有相同的重新分配和迭代器失效问题。
- en: Being informed about the specific behaviors of each STL container is vital for
    developing thread-safe C++ programs. While the STL delivers numerous tools with
    distinct advantages, they also have challenges in multi-threaded contexts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 了解每个STL容器的具体行为对于开发线程安全的C++程序至关重要。虽然STL提供了具有不同优势的众多工具，但在多线程环境中它们也面临挑战。
- en: Concurrency support within the STL
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL中的并发支持
- en: The STL has evolved significantly, transforming from a collection of data structures
    and algorithms into a comprehensive library incorporating advanced constructs
    for concurrent programming. This expansion responds to the increasing demand for
    efficient and robust multi-threaded applications, especially in the era of multi-core
    processors. Modern software development frequently requires leveraging the power
    of concurrency to enhance performance and responsiveness. As such, a deep understanding
    of the STL’s concurrency support is beneficial and essential for developers looking
    to optimize their applications in this multi-threaded landscape.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: STL已经发生了显著的变化，从数据结构和算法的集合转变为一个综合库，其中包含了用于并发编程的高级构造。这种扩展是为了响应对高效和健壮的多线程应用程序的需求，尤其是在多核处理器的时代。现代软件开发通常需要利用并发的力量来提高性能和响应速度。因此，对STL并发支持的深入理解对希望优化其应用程序的并发环境中的开发者来说是有益的和必要的。
- en: This section will examine the concurrency features integrated within the STL.
    This includes a detailed examination of thread management, asynchronous tasks,
    atomic operations, and challenges with utilizing concurrency.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将检查STL中集成的并发功能。这包括对线程管理、异步任务、原子操作以及利用并发时的挑战的详细审查。
- en: The STL’s offerings in the area of concurrency are not just about facilitating
    multi-threading but are also about doing it in an effective and manageable way.
    This section is designed to provide a comprehensive understanding of these tools,
    enabling you to write high-performance, scalable, and reliable C++ applications
    in today’s computationally demanding world.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: STL在并发领域的提供不仅仅是为了促进多线程，还在于以有效和可管理的方式进行。本节旨在提供对这些工具的全面理解，使您能够编写在当今计算需求日益增长的世界中高性能、可扩展和可靠的C++应用程序。
- en: Introduction to threads
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程简介
- en: 'At the heart of concurrent programming lies the concept of threads. Within
    the STL, this is represented by `std::thread`. This class offers a straightforward
    interface for creating and overseeing threads. Initiating a new thread is essentially
    about defining a function or a callable entity and passing it to the thread constructor.
    After executing your task, you can join (await its conclusion) or detach (permit
    its independent execution) the thread. However, here’s a word of caution: manually
    handling threads requires careful attention. It’s imperative to ensure all threads
    are correctly joined or detached to avoid potential issues, including lingering
    threads.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的核心是线程的概念。在STL中，这由`std::thread`表示。这个类提供了一个创建和监管线程的简单接口。启动一个新线程本质上就是定义一个函数或可调用实体，并将其传递给线程构造函数。在执行完任务后，你可以连接（等待其完成）或分离（允许其独立执行）线程。然而，这里有一个警告：手动处理线程需要仔细注意。确保所有线程都正确连接或分离是必要的，以避免潜在的问题，包括悬挂线程。
- en: The advent of asynchronous tasks
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步任务的出现
- en: Direct thread management provides considerable control, but the STL introduces
    `std::async` and `std::future` for tasks that don’t require such meticulous oversight.
    These constructs enable developers to delegate tasks for potential parallel execution
    without the intricacies of direct thread oversight. The function `std::async`
    initiates a task, and its resultant `std::future` offers a method to fetch the
    result when it’s ready. This fosters more organized code, mainly when the focus
    is on task-centric parallelism.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 直接线程管理提供了相当的控制力，但STL引入了`std::async`和`std::future`来处理那些不需要如此细致监管的任务。这些构造函数使开发者能够将任务委托给潜在的并行执行，而无需直接线程监管的复杂性。`std::async`函数启动一个任务，其结果`std::future`提供了一个在任务准备好时获取结果的方法。这促进了更有序的代码，尤其是在关注以任务为中心的并行性时。
- en: Atomic operations
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子操作
- en: The STL provides a robust solution through atomic operations for inefficient,
    low-overhead operations, where the locking mechanisms may appear disproportionate.
    The atomic operations, encapsulated within the `std::atomic` class template, play
    a pivotal role in concurrent programming by guaranteeing the atomicity of operations
    in fundamental data types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: STL通过原子操作为低开销操作提供了一种强大的解决方案，在这些操作中，锁定机制可能显得不成比例。封装在`std::atomic`类模板中的原子操作在并发编程中发挥着关键作用，通过保证基本数据类型操作的原子性。
- en: '`std::atomic` is designed to ensure that operations on basic types, such as
    integers and pointers, are executed as indivisible units. This atomicity is crucial
    in multi-threaded environments, as it prevents the potential hazards of interrupted
    operations, which can lead to inconsistent or corrupt data states. By ensuring
    that these operations are completed without interruption, `std::atomic` obviates
    the need for traditional locking mechanisms, such as mutexes, thereby enhancing
    performance by reducing the overhead associated with lock contention and context
    switching.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`旨在确保对基本类型（如整数和指针）的操作作为不可分割的单元执行。这种原子性在多线程环境中至关重要，因为它防止了中断操作可能带来的潜在风险，这些风险可能导致数据状态不一致或损坏。通过确保这些操作在没有中断的情况下完成，`std::atomic`消除了对传统锁定机制（如互斥锁）的需求，从而通过减少与锁定竞争和上下文切换相关的开销来提高性能。'
- en: However, it is essential to note that using atomic operations requires careful
    consideration and an understanding of their characteristics and limitations. While
    they provide a mechanism for lock-free programming, atomic operations are not
    a panacea for all concurrency problems. Developers must know the memory order
    constraints and the potential performance implications on different hardware architectures.
    In particular, the choice between memory orderings (such as `memory_order_relaxed`,
    `memory_order_acquire`, `memory_order_release`, etc.) demands a thorough understanding
    of the synchronization requirements and the trade-offs involved.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，使用原子操作需要仔细考虑，并理解它们的特性和限制。虽然它们提供了一种无锁编程的机制，但原子操作并不是所有并发问题的万能药。开发者必须了解内存顺序约束以及在不同硬件架构上的潜在性能影响。特别是，在内存排序（如`memory_order_relaxed`、`memory_order_acquire`、`memory_order_release`等）之间的选择，需要彻底理解同步需求和涉及的权衡。
- en: Memory orderings, such as `memory_order_relaxed`, `memory_order_acquire`, and
    `memory_order_release`, dictate how operations on atomic variables are ordered
    with respect to other memory operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 内存排序，例如`memory_order_relaxed`、`memory_order_acquire`和`memory_order_release`，决定了原子变量上的操作相对于其他内存操作是如何排序的。
- en: Choosing the correct memory ordering is crucial for ensuring the desired level
    of synchronization while balancing performance. For instance, `memory_order_relaxed`
    offers minimal synchronization and imposes no ordering constraints on memory operations,
    leading to higher performance but at the risk of allowing other threads to see
    operations in a different order. On the other hand, `memory_order_acquire` and
    `memory_order_release` provide stronger guarantees about the ordering of reads
    and writes, which is essential for correctly implementing lock-free data structures
    and algorithms but can come with a performance cost, especially in systems with
    weak memory models.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的内存排序对于确保所需的同步级别并平衡性能至关重要。例如，`memory_order_relaxed`提供最小的同步，不对内存操作施加排序约束，从而带来更高的性能，但同时也存在风险，即允许其他线程以不同的顺序看到操作。另一方面，`memory_order_acquire`和`memory_order_release`提供了关于读写排序的更强保证，这对于正确实现无锁数据结构和算法至关重要，但可能会带来性能成本，尤其是在内存模型较弱的系统中。
- en: The trade-offs involved in these decisions are significant. A more relaxed memory
    ordering can lead to performance gains but also introduce subtle bugs if the program’s
    correctness relies on certain memory ordering guarantees. Conversely, opting for
    stronger memory orderings can simplify the reasoning about the correctness of
    concurrent code but may lead to decreased performance due to additional memory
    synchronization barriers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策中涉及到的权衡是重大的。更宽松的内存排序可能导致性能提升，但也可能引入微妙的bug，如果程序的正确性依赖于某些内存排序保证的话。相反，选择更强的内存排序可以简化关于并发代码正确性的推理，但可能会因为额外的内存同步屏障而导致性能下降。
- en: Therefore, developers must be aware of the synchronization requirements of their
    specific application and understand how their choice of memory ordering will interact
    with the underlying hardware architecture. This knowledge is critical for writing
    efficient and correct concurrent programs in C++.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发者必须了解他们特定应用程序的同步需求，并理解他们的内存排序选择如何与底层硬件架构交互。这种知识对于编写高效的C++并发程序至关重要。
- en: Potential concurrent challenges
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的并发挑战
- en: Concurrency, though powerful, isn’t devoid of challenges. Developers might confront
    deadlocks, race conditions, and resource contention. Deadlocks transpire when
    multiple threads indefinitely wait for each other to release resources. Race conditions
    can give rise to erratic bugs stemming from unforeseen overlaps in thread operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并发编程功能强大，但并非没有挑战。开发者可能会遇到死锁、竞态条件和资源竞争。死锁发生在多个线程无限期地等待彼此释放资源时。竞态条件可能导致由线程操作中的不可预见重叠引起的异常bug。
- en: '**False sharing** is another notable challenge. It happens when different threads
    modify data situated in the same cache line. This can hamper performance because
    even if threads modify distinct data, their memory closeness can trigger redundant
    cache invalidations. Awareness and prudence can aid in sidestepping these challenges.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存伪共享**是另一个显著的挑战。当不同的线程修改位于同一缓存行中的数据时，就会发生这种情况。这可能会影响性能，因为即使线程修改不同的数据，它们的内存接近性也可能触发多余的缓存失效。意识和谨慎可以帮助避开这些挑战。'
- en: Using the STL’s concurrency features
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL的并发特性
- en: The STL provides a range of tools for concurrent programming, spanning from
    the initiation of threads to the assurance of atomic tasks. These tools cater
    to a variety of requirements. Nevertheless, it’s vital to employ them judiciously.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了用于并发编程的一系列工具，从线程的启动到原子任务的保证。这些工具满足各种需求。然而，明智地使用它们是至关重要的。
- en: Concurrency promises enhanced performance and nimble applications but comes
    with complexities and potential bugs. In concurrency, knowing what tools are available
    is a necessary starting point, but effectively using them requires ongoing trial
    and learning.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程承诺提升性能和灵活的应用，但同时也伴随着复杂性和潜在的bug。在并发编程中，了解可用的工具是一个必要的起点，但有效地使用它们需要持续的试验和学习。
- en: 'The following C++ code example illustrates the STL’s various concurrency features.
    This example encompasses thread creation, asynchronous task execution, and atomic
    operations while highlighting the importance of proper thread management and the
    potential pitfalls of concurrency:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 C++ 代码示例展示了 STL 的各种并发功能。此示例包括线程创建、异步任务执行和原子操作，同时强调了适当线程管理的重要性以及并发可能存在的陷阱：
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we did the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下几件事：
- en: Created a thread using `std::thread` that sleeps for a given number of seconds
    and then prints a message.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::thread` 创建一个线程，该线程休眠指定的时间然后打印一条消息。
- en: Used `std::async` to perform a computation in a potentially parallel manner,
    and we used `std::future` to obtain the result once it was ready.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::async` 以可能并行的方式执行计算，并使用 `std::future` 在准备好后获取结果。
- en: Demonstrated using `std::atomic` to perform an atomic increment operation within
    multiple threads.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::atomic` 在多个线程中执行原子递增操作。
- en: Ensured that all threads are correctly joined to avoid dangling threads.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有线程都正确连接，以避免悬挂线程。
- en: This code is a simple demonstration and serves as a starting point for understanding
    concurrency in C++. Developers must further explore and handle more complex scenarios,
    including synchronization, preventing deadlocks, and avoiding race conditions
    and false sharing for robust concurrent applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个简单的演示，作为理解 C++ 中并发的基础。开发者必须进一步探索和处理更复杂的场景，包括同步、防止死锁以及避免竞争条件和虚假共享，以构建健壮的并发应用程序。
- en: Using std::thread, std::async, std::future, and thread -local storage
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::thread、std::async、std::future 和线程局部存储
- en: 'Let’s look at four core components of C++’s concurrency toolkit: `std::thread`,
    `std::async`, `std::future`, and thread-local storage. Each of these elements
    is vital for facilitating multi-threaded programming in C++. `std::thread` is
    the foundation, allowing for the creation and management of threads. `std::async`
    and `std::future` work in tandem to asynchronously execute tasks and retrieve
    their results in a controlled manner, offering a higher level of abstraction over
    raw threads. Thread-local storage, on the other hand, provides a unique data instance
    for each thread. This is crucial for avoiding data conflicts in a concurrent environment.
    This section aims to comprehensively understand these tools, demonstrating how
    they can be used effectively to write robust, efficient, and thread-safe C++ applications.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 C++ 并发工具箱的四个核心组件：`std::thread`、`std::async`、`std::future` 和线程局部存储。这些元素对于促进
    C++ 的多线程编程至关重要。`std::thread` 是基础，允许创建和管理线程。`std::async` 和 `std::future` 协同工作，以异步执行任务并以受控的方式检索其结果，提供了比原始线程更高的抽象级别。另一方面，线程局部存储为每个线程提供独特的数据实例。这在并发环境中避免数据冲突至关重要。本节旨在全面理解这些工具，展示如何有效地使用它们来编写健壮、高效且线程安全的
    C++ 应用程序。
- en: Initiating threads using std::thread
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::thread 启动线程
- en: 'A primary tool in the realm of concurrency within C++ is `std::thread`. This
    class allows developers to concurrently run procedures by starting distinct threads
    for execution. To launch a new thread, pass a callable entity (such as a function
    or a lambda) to the `std::thread` constructor. For instance, to print “Hello,
    Concurrent World!” from an independent thread, see the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 的并发领域，`std::thread` 是一个主要工具。这个类允许开发者通过启动不同的线程来并发运行程序。要启动一个新线程，将可调用实体（如函数或
    lambda）传递给 `std::thread` 构造函数。例如，要从独立线程打印“Hello, Concurrent World!”，请参阅以下示例：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Utilizing the `join()` function ensures that the main thread waits until `my_thread`
    completes. There’s also `detach()`, which lets the primary thread progress without
    delay. However, the careful management of detached threads is crucial to avoid
    unexpected behavior.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `join()` 函数确保主线程等待 `my_thread` 完成。还有 `detach()`，它允许主线程无延迟地继续。然而，仔细管理分离的线程对于避免意外行为至关重要。
- en: Managing asynchronous operations with std::async and std::future
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::async 和 std::future 管理异步操作
- en: Though `std::thread` offers significant capabilities, direct thread management
    can be intricate. The STL presents an elevated abstraction for administering potential
    parallel operations through `std::async` and `std::future`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::thread` 提供了显著的能力，但直接线程管理可能很复杂。STL 通过 `std::async` 和 `std::future` 提供了一种高级抽象，用于管理潜在的并行操作。
- en: 'The approach is clear-cut: assign a task to `std::async` and retrieve a `std::future`
    object that will eventually contain that task’s result. This division allows the
    primary thread to either continue or optionally await the outcome using the `get()`
    method of `std::future`, as shown in the following code example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 方法非常明确：将任务分配给 `std::async` 并检索一个最终将包含该任务结果的 `std::future` 对象。这种划分允许主线程继续执行或可选地使用
    `std::future` 的 `get()` 方法等待结果，如下面的代码示例所示：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `std::async` and `std::future` are designed to work well together
    to help manage asynchronous operations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`std::async` 和 `std::future` 被设计成可以很好地协同工作，以帮助管理异步操作。
- en: Preserving data consistency using thread-local storage
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线程局部存储来保持数据一致性
- en: Ensuring distinct data storage for each thread to avoid overlap and maintain
    data consistency in concurrent programming can be challenging. This is addressed
    by **thread-local** **storage** (**TLS**).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中确保每个线程有独立的数据存储以避免重叠并保持数据一致性可能具有挑战性。这通过 **线程局部存储**（**TLS**）得到解决。
- en: 'Using the `thread_local` keyword when declaring a variable ensures a unique
    instance of that variable for each thread. This is instrumental in sustaining
    data consistency and circumventing the issues associated with shared data access:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时使用 `thread_local` 关键字确保每个线程都有一个该变量的唯一实例。这在维持数据一致性并避免与共享数据访问相关的问题中起着至关重要的作用：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `thread_counter` is instantiated for each thread, shielding it from inter-thread
    interference.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`thread_counter` 为每个线程实例化，从而防止线程间的干扰。
- en: Integrating tools for proficient concurrency
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成用于熟练并发编程的工具
- en: With `std::thread`, `std::async`, `std::future`, and TLS, you are prepared to
    navigate various concurrent programming situations in C++. The STL offers the
    requisite tools for delegating tasks for parallel execution or adeptly managing
    thread-specific data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `std::thread`、`std::async`、`std::future` 和 TLS，你准备好在 C++ 中导航各种并发编程场景。STL
    提供了委托任务以进行并行执行或巧妙管理线程特定数据的必要工具。
- en: It’s pivotal to note that while initiating threads or tasks is straightforward,
    ensuring synchronized operations devoid of contention, deadlocks, or data races
    demands attentiveness and continual refinement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意，虽然启动线程或任务很简单，但确保同步操作无争用、无死锁或无数据竞争需要关注和持续改进。
- en: Retaining the foundational insights from this segment is paramount as we transition
    to the subsequent sections that review the STL’s concurrent data structures. Concurrent
    programming is an evolving landscape, and mastering each tool and concept augments
    your capacity to develop efficient and stable concurrent applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡到后续部分，这些部分将回顾 STL 的并发数据结构时，保留这一段的基础洞察至关重要。并发编程是一个不断发展的领域，掌握每个工具和概念可以增强你开发高效和稳定并发应用的能力。
- en: 'Let’s walk through a code example that illustrates the use of `std::thread`,
    `std::async`, `std::future`, and TLS to concurrently execute tasks and manage
    per-thread data:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来了解如何使用 `std::thread`、`std::async`、`std::future` 和 TLS 来并发执行任务和管理每个线程的数据：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code, we did the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们做了以下操作：
- en: Created a thread to print a message to the console using `std::thread`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::thread` 创建了一个线程来向控制台打印消息。
- en: Used `std::async` to perform an asynchronous operation that returns a string.
    The result is accessed via a `std::future` object.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::async` 执行一个异步操作，该操作返回一个字符串。结果通过 `std::future` 对象访问。
- en: Demonstrated the use of TLS with the `thread_local` keyword to maintain a separate
    counter for each thread.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `thread_local` 关键字演示了 TLS 的使用，以为每个线程维护一个单独的计数器。
- en: Started multiple threads, each incrementing its local counter, to show how TLS
    variables are instantiated for each thread.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动了多个线程，每个线程增加其局部计数器，以展示 TLS 变量是如何为每个线程实例化的。
- en: This example encapsulates the essentials of concurrent programming with the
    STL, from thread creation and synchronization to data isolation with TLS. While
    these mechanisms simplify parallel execution, we must exercise careful judgment
    to prevent concurrency-related issues, such as deadlocks and race conditions.
    The upcoming sections will explore STL’s concurrent data structures, which build
    upon these foundational concepts to enable the creation of robust concurrent programs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例封装了使用 STL 进行并发编程的要点，从线程创建和同步到使用 TLS 的数据隔离。虽然这些机制简化了并行执行，但我们必须谨慎判断以防止与并发相关的问题，如死锁和竞态条件。接下来的章节将探讨
    STL 的并发数据结构，这些数据结构基于这些基础概念，以实现健壮并发程序的创作。
- en: Concurrent data structures in the STL
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL中的并发数据结构
- en: The STL provides a variety of data structures, but not all are inherently suited
    for concurrent access. Understanding how to effectively utilize and adapt these
    data structures for safe and efficient use in a multi-threaded context is crucial.
    We will examine the thread safety aspects of common STL data structures, discuss
    the appropriate use cases for each in a concurrent environment, and explore the
    strategies to ensure safe and effective concurrent access. This section is designed
    to equip developers with the knowledge to leverage STL data structures to maximize
    performance while maintaining data integrity in a multi-threaded landscape.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了各种数据结构，但并非所有数据结构都天生适合并发访问。理解如何有效地利用和调整这些数据结构，以确保在多线程环境中的安全和高效使用，至关重要。我们将检查常见
    STL 数据结构的线程安全性方面，讨论在并发环境中每个数据结构的适当使用案例，并探索确保安全和有效并发访问的策略。本节旨在为开发者提供利用 STL 数据结构以最大化性能同时保持数据完整性的多线程环境下的知识。
- en: The STL’s concurrency-optimized containers
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL的并发优化容器
- en: While the STL provides many containers, not all are optimized for concurrent
    access. However, with the increasing demand for concurrent programming, specific
    concurrency-friendly containers have made their way into the repertoire of many
    C++ programmers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STL提供了许多容器，但并非所有都针对并发访问进行了优化。然而，随着对并发编程需求的增加，特定的并发友好型容器已经进入了许多C++程序员的工具箱。
- en: One notable example is `std::shared_timed_mutex` and its sibling `std::shared_mutex`
    (from C++17 onwards). These synchronization primitives allow multiple threads
    to read shared data simultaneously while ensuring exclusive access for writing.
    This is particularly handy when read operations are more frequent than writes,
    such as in caching scenarios.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的例子是 `std::shared_timed_mutex` 及其兄弟 `std::shared_mutex`（从 C++17 开始）。这些同步原语允许多个线程同时读取共享数据，同时确保写入时的独占访问。这在读取操作比写入操作更频繁的情况下特别有用，例如在缓存场景中。
- en: 'Consider a situation where you have `std::map` storing configuration data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，你有一个存储配置数据的 `std::map`：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To read from this map, multiple threads can acquire a shared lock:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这个映射中读取，多个线程可以获取共享锁：
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, for writing, a unique lock ensures exclusive access:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于写入，唯一锁确保了独占访问：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While not a container, `std::shared_timed_mutex` can protect any STL container,
    ensuring concurrent read access while serializing writes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::shared_timed_mutex` 不是一个容器，但它可以保护任何 STL 容器，确保并发读取访问同时序列化写入。
- en: Striving for maximum efficiency in concurrent environments
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在并发环境中追求最大效率
- en: Concurrency isn’t just about making operations thread-safe but is also about
    achieving better performance. As you’ve seen, atomic types and concurrency-optimized
    containers help ensure safety, but there’s more to it than that. Fine-tuning performance
    may involve considering lock contention, avoiding false sharing, and minimizing
    synchronization overhead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 并发不仅仅是使操作线程安全，也是关于实现更好的性能。正如你所看到的，原子类型和并发优化的容器有助于确保安全性，但还有更多。微调性能可能需要考虑锁竞争、避免伪共享和最小化同步开销。
- en: 'A few tips for maximizing efficiency include the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些提高效率的技巧：
- en: '**Limit the scope of locks**: While locks are essential for ensuring data consistency,
    holding them for extended durations can impede performance. Ensure you’re only
    holding locks for the necessary duration.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制锁的范围**：虽然锁对于确保数据一致性至关重要，但长时间持有锁可能会阻碍性能。确保你只持有锁的必要时间。'
- en: '**Choose the right data structure**: Containers optimized for concurrency might
    offer better performance for multi-threaded applications, even if they might be
    slower in single-threaded scenarios.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择合适的数据结构**：针对并发优化的容器可能为多线程应用程序提供更好的性能，即使它们在单线程场景中可能较慢。'
- en: '**Consider granularity**: Think about the granularity of your locks. Sometimes,
    a finer-grained lock (protecting just a part of your data) can perform better
    than a coarser-grained one (protecting the entire data structure).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑粒度**：考虑你锁的粒度。有时，一个更细粒度的锁（仅保护数据的一部分）可能比一个更粗粒度的锁（保护整个数据结构）表现更好。'
- en: Best practices in action
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践在行动
- en: Let’s look at a code example demonstrating best practices in using STL containers
    in a concurrent environment, focusing on performance optimization techniques such
    as minimizing lock scope, selecting appropriate data structures, and considering
    lock granularity.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例，该示例展示了在并发环境中使用 STL 容器的最佳实践，重点关注性能优化技术，如最小化锁的作用域、选择合适的数据结构和考虑锁的粒度。
- en: 'First, we will write a concurrency-optimized container, specifically `ConcurrentVector`,
    designed to handle multi-threaded environments effectively. This custom container
    class, which is templated to hold elements of any type (`T`), encapsulates a standard
    `std::vector` for data storage while employing `std::shared_mutex` to manage concurrent
    access (we will break this example up into a few sections. For the complete code,
    please refer to the book''s GitHub repository):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个并发优化的容器，具体为 `ConcurrentVector`，旨在有效地处理多线程环境。这个自定义容器类，模板化以容纳任何类型的元素（`T`），封装了一个标准的
    `std::vector` 用于数据存储，同时使用 `std::shared_mutex` 来管理并发访问（我们将此示例分成几个部分。对于完整的代码，请参阅书籍的
    GitHub 仓库）：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will write the function `performConcurrentOperations`, which will
    demonstrate the practical application of our `ConcurrentVector` class in a multi-threaded
    context. This function accepts a reference to `ConcurrentVector<int>` and initiates
    two parallel operations using C++ standard threads:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `performConcurrentOperations` 函数，该函数将演示我们的 `ConcurrentVector` 类在多线程环境中的实际应用。此函数接受
    `ConcurrentVector<int>` 的引用，并使用 C++ 标准线程启动两个并行操作：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we write `main()` to drive the program:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写 `main()` 来驱动程序：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the example output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In total, in the preceding code example, we did the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们做了以下操作：
- en: We have defined a `ConcurrentVector` template class that mimics a concurrency-optimized
    container, which internally uses `std::shared_mutex` to enable fine-grained control
    over read and write operations.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `ConcurrentVector` 模板类，它模拟了一个并发优化的容器，内部使用 `std::shared_mutex` 来实现读写操作的细粒度控制。
- en: The `insert` method uses a unique lock to ensure exclusive access during write
    operations, but the lock is held only for the insert duration, minimizing the
    lock scope.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert` 方法使用一个独特的锁来确保在写操作期间具有独占访问权限，但锁仅保留在插入期间，最小化锁的作用域。'
- en: The `find` and `size` methods use shared locks, allowing for concurrent reads,
    demonstrating the use of shared locking to enable higher read throughput.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find` 和 `size` 方法使用共享锁，允许并发读取，展示了使用共享锁来提高读取吞吐量的应用。'
- en: A writer thread and a reader thread were created to perform concurrent insertions
    and searches on the `ConcurrentVector` instance, showcasing the container’s ability
    to handle concurrent operations.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个写线程和一个读线程来对 `ConcurrentVector` 实例执行并发插入和搜索操作，展示了容器处理并发操作的能力。
- en: This example illustrates critical considerations for optimizing concurrent performance,
    such as limiting the duration of locks, choosing appropriate concurrency-friendly
    data structures, and using fine-grained locking to protect smaller sections of
    the data. These practices are crucial for intermediate-level C++ developers looking
    to enhance the performance of multi-threaded applications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了优化并发性能的关键考虑因素，例如限制锁的持续时间、选择合适的并发友好型数据结构以及使用细粒度锁来保护数据的小部分。这些实践对于希望提高多线程应用程序性能的中级
    C++ 开发者至关重要。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed the intricacies of thread safety and concurrency within
    the STL. We started by distinguishing between concurrency and thread safety, underscoring
    that while related, each serves a distinct purpose. Our journey began with a foundational
    understanding of thread safety as a pillar for stable concurrency and how the
    lack thereof can lead to unpredictable software behavior. We examined the interplay
    between these concepts, addressing the challenges and highlighting the rewards
    of concurrent programming when thread safety is maintained.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了STL中线程安全和并发的复杂性。我们首先区分了并发和线程安全，强调虽然它们相关，但各自都服务于不同的目的。我们的旅程从对线程安全作为稳定并发支柱的基础理解开始，探讨了缺乏线程安全可能导致不可预测的软件行为。我们考察了这些概念之间的相互作用，讨论了在保持线程安全的情况下并发编程的挑战和回报。
- en: We looked into the thread-safe nature of STL containers and algorithms, dissecting
    race conditions and the techniques to anticipate and guard against them. The chapter
    provided detailed insights into the behaviors of various STL containers under
    multi-threaded scenarios, from `std::vector` to `std::list` and associative to
    unordered containers. We also uncovered the concurrency aspects of container adaptors,
    asserting that knowledge is power when writing concurrent applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了STL容器和算法的线程安全特性，分析了竞争条件以及预测和防范这些条件的技术。本章提供了关于各种STL容器在多线程场景下行为的详细见解，从`std::vector`到`std::list`，再到关联容器和无序容器。我们还揭示了容器适配器的并发方面，断言在编写并发应用程序时，知识就是力量。
- en: 'We’ve been equipped with the core tools: `std::thread`, `std::async`, `std::future`,
    and TLS. With these, we initiated threads, managed asynchronous operations, and
    preserved data consistency across threads. These capabilities have prepared us
    for proficient concurrency about safety and performance.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配备了核心工具：`std::thread`、`std::async`、`std::future`和TLS。有了这些，我们启动了线程，管理异步操作，并在线程之间保持数据一致性。这些能力使我们能够熟练地处理关于安全和性能的并发。
- en: The chapter examined the STL’s atomic types and concurrency-optimized containers,
    providing tips for maximizing efficiency in concurrent environments. These insights
    are pivotal for developing high-performance, thread-safe applications using the
    STL.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了STL的原子类型和针对并发优化的容器，提供了在并发环境中最大化效率的技巧。这些见解对于使用STL开发高性能、线程安全的应用程序至关重要。
- en: The knowledge imparted in this chapter is essential because thread safety and
    efficient concurrency are critical for modern C++ developers. As multi-core and
    multi-threaded applications become the norm, it is crucial to understand these
    principles to be able to leverage the full power of the STL.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章传授的知识至关重要，因为线程安全和高效的并发对于现代C++开发者至关重要。随着多核和多线程应用程序成为常态，理解这些原则对于能够充分利用STL的全部功能至关重要。
- en: In the next chapter, we will dig further into advanced STL usage. We will introduce
    concepts and robust template features, allowing for more precise type checks at
    compile-time. We will learn how to refine the constraints in STL algorithms and
    effectively use these constraints to enhance data structures with explicit requirements.
    Moreover, we will explore the integration of the STL with coroutines, assessing
    the potential synergies with ranges and views and preparing for the paradigm shift
    that awaits in contemporary C++ programming.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步深入探讨STL的高级用法。我们将介绍概念和强大的模板特性，允许在编译时进行更精确的类型检查。我们将学习如何细化STL算法中的约束，并有效地使用这些约束来增强具有显式要求的数据结构。此外，我们还将探索STL与协程的集成，评估与范围和视图的潜在协同作用，并为当代C++编程中即将到来的范式转变做好准备。
