["```cpp\nvoid func1() {\n  auto i = 0;\n  std::cout << \"func1(): \" << std::addressof(i) << '\\n';\n}\nvoid func2() {\n  auto i = 0;\n  std::cout << \"func2(): \" << std::addressof(i) << '\\n';\n  func1();\n}\n\nint main() { \n  auto i = 0; \n  std::cout << \"main():  \" << std::addressof(i) << '\\n'; \n  func2();\n  func1(); \n} \n```", "```cpp\nmain():  0x7ea075ac \nfunc2(): 0x7ea07594 \nfunc1(): 0x7ea0757c \nfunc1(): 0x7ea07594 \n```", "```cpp\nvoid func(std::byte* stack_bottom_addr) { \n  std::byte data[1024];     \n  std::cout << stack_bottom_addr - data << '\\n'; \n  func(stack_bottom_addr); \n} \n\nint main() { \n  std::byte b; \n  func(&b); \n} \n```", "```cpp\n... \n8378667 \n8379755 \n8380843 \n```", "```cpp\n$ ulimit -s\n$ 8192 \n```", "```cpp\nauto* user = new User{\"John\"};  // allocate and construct \nuser->print_name();             // use object \ndelete user;                    // destruct and deallocate \n```", "```cpp\nauto* memory = std::malloc(sizeof(User));\nauto* user = ::new (memory) User(\"john\"); \n```", "```cpp\nuser->~User();\nstd::free(memory); \n```", "```cpp\nauto* memory = std::malloc(sizeof(User));\nauto* user_ptr = reinterpret_cast<User*>(memory);\nstd::uninitialized_fill_n(user_ptr, 1, User{\"john\"});\nstd::destroy_at(user_ptr);\nstd::free(memory); \n```", "```cpp\nstd::construct_at(user_ptr, User{\"john\"});        // C++20 \n```", "```cpp\nauto operator new(size_t size) -> void* { \n  void* p = std::malloc(size); \n  std::cout << \"allocated \" << size << \" byte(s)\\n\"; \n  return p; \n} \n\nauto operator delete(void* p) noexcept -> void { \n  std::cout << \"deleted memory\\n\"; \n  return std::free(p); \n} \n```", "```cpp\nauto* p = new char{'a'}; // Outputs \"allocated 1 byte(s)\"\ndelete p;                // Outputs \"deleted memory\" \n```", "```cpp\nauto operator new[](size_t size) -> void* {\n  void* p = std::malloc(size); \n  std::cout << \"allocated \" << size << \" byte(s) with new[]\\n\"; \n  return p; \n} \n\nauto operator delete[](void* p) noexcept -> void { \n  std::cout << \"deleted memory with delete[]\\n\"; \n  return std::free(p); \n} \n```", "```cpp\nclass Document { \n// ...\npublic:  \n  auto operator new(size_t size) -> void* {\n    return ::operator new(size);\n  } \n  auto operator delete(void* p) -> void {\n    ::operator delete(p); \n  } \n}; \n```", "```cpp\nauto* p = new Document{}; // Uses class-specific operator new\ndelete p; \n```", "```cpp\nauto* p = ::new Document{}; // Uses global operator new\n::delete p; \n```", "```cpp\n// Possible output is 4  \nstd::cout << alignof(int) << '\\n'; \n```", "```cpp\nbool is_aligned(void* ptr, std::size_t alignment) {\n  assert(ptr != nullptr);\n  assert(std::has_single_bit(alignment)); // Power of 2\n  auto s = std::numeric_limits<std::size_t>::max();\n  auto aligned_ptr = ptr;\n  std::align(alignment, 1, aligned_ptr, s);\n  return ptr == aligned_ptr;\n} \n```", "```cpp\nauto* p = new int{};\nassert(is_aligned(p, 4ul)); // True \n```", "```cpp\nauto* p = new char{}; \nauto max_alignment = alignof(std::max_align_t);\nassert(is_aligned(p, max_alignment)); // True \n```", "```cpp\nauto* p1 = new char{'a'};\nauto* p2 = new char{'b'}; \n```", "```cpp\nalignas(64) int x{};\nalignas(64) int y{};\n// x and y will be placed on different cache lines \n```", "```cpp\nstruct alignas(64) CacheLine {\n    std::byte data[64];\n}; \n```", "```cpp\nint main() {\n  auto x = CacheLine{};\n  auto y = CacheLine{};\n  assert(is_aligned(&x, 64));\n  assert(is_aligned(&y, 64));\n  // ...\n} \n```", "```cpp\nconstexpr auto ps = std::size_t{4096};      // Page size\nstruct alignas(ps) Page {\n    std::byte data_[ps];\n};\nauto* page = new Page{};                    // Memory page\nassert(is_aligned(page, ps));               // True\n// Use page ...\ndelete page; \n```", "```cpp\nclass Document { \n  bool is_cached_{}; \n  double rank_{}; \n  int id_{}; \n};\nstd::cout << sizeof(Document) << '\\n'; // Possible output is 24 \n```", "```cpp\nclass Document {\n  bool is_cached_{};\n  std::byte padding1[7]; // Invisible padding inserted by compiler\n  double rank_{};\n  int id_{};\n  std::byte padding2[4]; // Invisible padding inserted by compiler\n}; \n```", "```cpp\n// Version 2 of Document class\nclass Document {\n  double rank_{}; // Rearranged data members\n  int id_{};\n  bool is_cached_{};\n}; \n```", "```cpp\n// Version 2 of Document class after padding\nclass Document { \n  double rank_{}; \n  int id_{}; \n  bool is_cached_{}; \n  std::byte padding[3]; // Invisible padding inserted by compiler \n}; \n```", "```cpp\nstd::cout << sizeof(Document) << '\\n'; // Possible output is 16 \n```", "```cpp\n{\n  auto user = User{};\n} // user automatically destroys when it goes out of scope \n```", "```cpp\nstatic auto user = User{}; \n```", "```cpp\nclass Game {\n  User user; // A Game object owns the User object\n  // ...\n}; \n```", "```cpp\nauto* user = new User{}; // Who owns user now? \n```", "```cpp\nauto func() {\n  auto v = std::vector<int>{1, 2, 3, 4, 5};\n} \n```", "```cpp\nauto send_request(const std::string& request) { \n  auto connection = open_connection(\"http://www.example.com/\"); \n  send_request(connection, request); \n  close(connection); \n} \n```", "```cpp\nclass RAIIConnection { \npublic: \n  explicit RAIIConnection(const std::string& url) \n      : connection_{open_connection(url)} {} \n  ~RAIIConnection() { \n    try { \n      close(connection_);       \n    } \n    catch (const std::exception&) { \n      // Handle error, but never throw from a destructor \n    } \n  }\n  auto& get() { return connection_; } \n\nprivate:  \n  Connection connection_; \n}; \n```", "```cpp\nauto send_request(const std::string& request) { \n  auto connection = RAIIConnection(\"http://www.example.com/\"); \n  send_request(connection.get(), request); \n  // No need to close the connection, it is automatically handled \n  // by the RAIIConnection destructor \n} \n```", "```cpp\nauto owner = std::make_unique<User>(\"John\");\nauto new_owner = std::move(owner); // Transfer ownership \n```", "```cpp\nauto operator new(size_t size) -> void* { \n  void* p = std::malloc(size); \n  std::cout << \"allocated \" << size << \" byte(s)\" << '\\n'; \n  return p; \n} \nauto operator delete(void* p) noexcept -> void { \n  std::cout << \"deleted memory\\n\"; \n  return std::free(p); \n} \n```", "```cpp\nint main() { \n  auto i = std::make_shared<double>(42.0); \n  return 0; \n} \n```", "```cpp\nallocated 32 bytes \ndeleted memory \n```", "```cpp\nint main() { \n  auto i = std::shared_ptr<double>{new double{42.0}}; \n  return 0; \n} \n```", "```cpp\nallocated 4 bytes \nallocated 32 bytes \ndeleted memory \ndeleted memory \n```", "```cpp\nauto i = std::make_shared<int>(10); \nauto weak_i = std::weak_ptr<int>{i};\n\n// Maybe i.reset() happens here so that the int is deleted... \nif (auto shared_i = weak_i.lock()) { \n  // We managed to convert our weak pointer to a shared pointer \n  std::cout << *shared_i << '\\n'; \n} \nelse { \n  std::cout << \"weak_i has expired, shared_ptr was nullptr\\n\"; \n} \n```", "```cpp\nauto allocated = size_t{0}; \n// Overload operator new and delete to track allocations \nvoid* operator new(size_t size) {  \n  void* p = std::malloc(size); \n  allocated += size; \n  return p; \n} \n\nvoid operator delete(void* p) noexcept { \n  return std::free(p); \n} \n\nint main() { \n  allocated = 0; \n  auto s = std::string{\"\"}; // Elaborate with different string sizes \n\n  std::cout << \"stack space = \" << sizeof(s) \n    << \", heap space = \" << allocated \n    << \", capacity = \" << s.capacity() << '\\n'; \n} \n```", "```cpp\nstack space = 24, heap space = 0, capacity = 22 \n```", "```cpp\nauto s = std::string{\"1234567890123456789012\"}; \n```", "```cpp\nauto s = std::string{\"12345678901234567890123\"}; \n```", "```cpp\nstack space = 24, heap space = 32, capacity = 31 \n```", "```cpp\nstruct Long { \n  size_t capacity_{}; \n  size_t size_{}; \n  char* data_{}; \n}; \n```", "```cpp\nstruct Short { \n  unsigned char size_{};\n  char data_[23]{}; \n}; \n```", "```cpp\nunion u_ { \n  Short short_layout_; \n  Long long_layout_; \n}; \n```", "```cpp\ntemplate <size_t N> \nclass Arena { \n  static constexpr size_t alignment = alignof(std::max_align_t); \npublic: \n  Arena() noexcept : ptr_(buffer_) {} \n  Arena(const Arena&) = delete; \n  Arena& operator=(const Arena&) = delete; \n\n  auto reset() noexcept { ptr_ = buffer_; } \n  static constexpr auto size() noexcept { return N; } \n  auto used() const noexcept {\n    return static_cast<size_t>(ptr_ - buffer_); \n  } \n  auto allocate(size_t n) -> std::byte*; \n  auto deallocate(std::byte* p, size_t n) noexcept -> void; \n\nprivate: \n  static auto align_up(size_t n) noexcept -> size_t { \n    return (n + (alignment-1)) & ~(alignment-1); \n  } \n  auto pointer_in_buffer(const std::byte* p) const noexcept -> bool {\n    return std::uintptr_t(p) >= std::uintptr_t(buffer_) &&\n           std::uintptr_t(p) < std::uintptr_t(buffer_) + N;\n  } \n  alignas(alignment) std::byte buffer_[N]; \n  std::byte* ptr_{}; \n}; \n```", "```cpp\ntemplate<size_t N> \nauto Arena<N>::allocate(size_t n) -> std::byte* { \n  const auto aligned_n = align_up(n); \n  const auto available_bytes =  \n    static_cast<decltype(aligned_n)>(buffer_ + N - ptr_); \n  if (available_bytes >= aligned_n) { \n    auto* r = ptr_; \n    ptr_ += aligned_n; \n    return r; \n  } \n  return static_cast<std::byte*>(::operator new(n)); \n} \n```", "```cpp\ntemplate<size_t N> \nauto Arena<N>::deallocate(std::byte* p, size_t n) noexcept -> void { \n  if (pointer_in_buffer(p)) { \n    n = align_up(n); \n    if (p + n == ptr_) { \n      ptr_ = p; \n    } \n  } \n  else { \n    ::operator delete(p);\n  }\n} \n```", "```cpp\nauto user_arena = Arena<1024>{}; \n\nclass User { \npublic: \n  auto operator new(size_t size) -> void* { \n    return user_arena.allocate(size); \n  } \n  auto operator delete(void* p) -> void { \n    user_arena.deallocate(static_cast<std::byte*>(p), sizeof(User)); \n  } \n  auto operator new[](size_t size) -> void* { \n    return user_arena.allocate(size); \n  } \n  auto operator delete[](void* p, size_t size) -> void { \n    user_arena.deallocate(static_cast<std::byte*>(p), size); \n  } \nprivate:\n  int id_{};\n}; \n\nint main() { \n  // No dynamic memory is allocated when we create the users \n  auto user1 = new User{}; \n  delete user1; \n\n  auto users = new User[10]; \n  delete [] users; \n\n  auto user2 = std::make_unique<User>(); \n  return 0; \n} \n```", "```cpp\nauto user = std::make_shared<User>(); \n```", "```cpp\nauto users = std::vector<User>{};\nusers.reserve(10); \n```", "```cpp\ntemplate<typename T> \nstruct Alloc {  \n  using value_type = T; \n  Alloc(); \n  template<typename U> Alloc(const Alloc<U>&); \n  T* allocate(size_t n); \n  auto deallocate(T*, size_t) const noexcept -> void; \n}; \ntemplate<typename T> \nauto operator==(const Alloc<T>&, const Alloc<T>&) -> bool;   \ntemplate<typename T> \nauto operator!=(const Alloc<T>&, const Alloc<T>&) -> bool; \n```", "```cpp\ntemplate <class T>  \nstruct Mallocator { \n\n  using value_type = T; \n  Mallocator() = default;\n\n  template <class U>  \n  Mallocator(const Mallocator<U>&) noexcept {} \n\n  template <class U>  \n  auto operator==(const Mallocator<U>&) const noexcept {  \n    return true;  \n  } \n\n  template <class U>  \n  auto operator!=(const Mallocator<U>&) const noexcept {  \n    return false;  \n  } \n\n  auto allocate(size_t n) const -> T* { \n    if (n == 0) {  \n      return nullptr;  \n    } \n    if (n > std::numeric_limits<size_t>::max() / sizeof(T)) { \n      throw std::bad_array_new_length{}; \n    } \n    void* const pv = malloc(n * sizeof(T)); \n    if (pv == nullptr) {  \n      throw std::bad_alloc{};  \n    } \n    return static_cast<T*>(pv); \n  } \n  auto deallocate(T* p, size_t) const noexcept -> void { \n    free(p); \n  } \n}; \n```", "```cpp\ntemplate <class T, size_t N> \nstruct ShortAlloc { \n\n  using value_type = T; \n  using arena_type = Arena<N>; \n\n  ShortAlloc(const ShortAlloc&) = default; \n  ShortAlloc& operator=(const ShortAlloc&) = default; \n\n  ShortAlloc(arena_type& arena) noexcept : arena_{&arena} { }\n\n  template <class U>\n  ShortAlloc(const ShortAlloc<U, N>& other) noexcept\n      : arena_{other.arena_} {}\n\n  template <class U> struct rebind {\n    using other = ShortAlloc<U, N>;\n  };\n  auto allocate(size_t n) -> T* {\n    return reinterpret_cast<T*>(arena_->allocate(n*sizeof(T)));\n  }\n  auto deallocate(T* p, size_t n) noexcept -> void {\n    arena_->deallocate(reinterpret_cast<std::byte*>(p), n*sizeof(T));\n  }\n  template <class U, size_t M>\n  auto operator==(const ShortAlloc<U, M>& other) const noexcept {\n    return N == M && arena_ == other.arena_;\n  }\n  template <class U, size_t M>\n  auto operator!=(const ShortAlloc<U, M>& other) const noexcept {\n    return !(*this == other);\n  }\n  template <class U, size_t M> friend struct ShortAlloc;\nprivate:\n  arena_type* arena_;\n}; \n```", "```cpp\nint main() { \n\n  using SmallSet =  \n    std::set<int, std::less<int>, ShortAlloc<int, 512>>; \n\n  auto stack_arena = SmallSet::allocator_type::arena_type{}; \n  auto unique_numbers = SmallSet{stack_arena}; \n\n  // Read numbers from stdin \n  auto n = int{}; \n  while (std::cin >> n)\n    unique_numbers.insert(n); \n\n  // Print unique numbers  \n  for (const auto& number : unique_numbers)\n    std::cout << number << '\\n'; \n} \n```", "```cpp\nvoid process(std::vector<int>& buffer) {\n  // ...\n}\nauto some_func() {\n  auto vec = std::vector<int>(64);\n  process(vec);\u00a0\n  // ...\n} \n```", "```cpp\nusing MyAlloc = ShortAlloc<int, 512>;  // Our custom allocator\nauto some_func() {\n  auto arena = MyAlloc::arena_type();\n  auto vec = std::vector<int, MyAlloc>(64, arena);\n  process(vec);\n  // ...\n} \n```", "```cpp\nerror: invalid initialization of reference of type 'const std::vector<int>&' from expression of type 'std::vector<int, ShortAlloc<int, 512> > \n```", "```cpp\nstd::cout << sizeof(std::vector<int>) << '\\n';\n// Possible output: 24\nstd::cout << sizeof(std::vector<int, MyAlloc>) << '\\n';\n// Possible output: 32 \n```", "```cpp\nauto v1 = std::vector<int>{};             // Uses std::allocator\nauto v2 = std::pmr::vector<int>{/*...*/}; // Uses polymorphic_allocator \n```", "```cpp\nint main() {\n  auto buffer = std::array<std::byte, 512>{};\n  auto resource = std::pmr::monotonic_buffer_resource{\n    buffer.data(), buffer.size(), std::pmr::new_delete_resource()};\n  auto unique_numbers = std::pmr::set<int>{&resource};\n  auto n = int{};\n  while (std::cin >> n) {\n    unique_numbers.insert(n);\n  }\n  for (const auto& number : unique_numbers) {\n    std::cout << number << '\\n';\n  }\n} \n```", "```cpp\nclass PrintingResource : public std::pmr::memory_resource {\npublic:\n  PrintingResource() : res_{std::pmr::get_default_resource()} {}\nprivate:\n  void* do_allocate(std::size_t bytes, std::size_t alignment)override {\n    std::cout << \"allocate: \" << bytes << '\\n';\n    return res_->allocate(bytes, alignment);\n  }\n  void do_deallocate(void* p, std::size_t bytes,\n                     std::size_t alignment) override {\n    std::cout << \"deallocate: \" << bytes << '\\n';\n    return res_->deallocate(p, bytes, alignment);\n  }\n  bool do_is_equal(const std::pmr::memory_resource& other) \n    const noexcept override {\n    return (this == &other);\n  }\n  std::pmr::memory_resource* res_;  // Default resource\n}; \n```", "```cpp\nauto res = PrintingResource{};\nauto vec = std::pmr::vector<int>{&res};\nvec.emplace_back(1);\nvec.emplace_back(2); \n```", "```cpp\nallocate: 4\nallocate: 8\ndeallocate: 4\ndeallocate: 8 \n```", "```cpp\nauto create_vec() -> std::pmr::vector<int> {\n  auto resource = PrintingResource{};\n  auto vec = std::pmr::vector<int>{&resource}; // Raw pointer\n  return vec;                                  // Ops! resource\n}                                              // destroyed here \nauto vec = create_vec();\nvec.emplace_back(1);                           // Undefined behavior \n```"]