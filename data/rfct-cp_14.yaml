- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Version Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: In software development, maintaining a clean commit history is essential for
    producing enduring and coherent code. This chapter emphasizes that a well-organized
    commit history is fundamental to robust software engineering. By focusing on version
    control, particularly through clear commit summaries and messages, we will explore
    the techniques and intentional practices needed to achieve clarity and precision.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，保持清晰的提交历史对于生产持久且连贯的代码至关重要。本章强调，一个良好的提交历史对于稳健的软件工程是基础性的。通过关注版本控制，特别是通过清晰的提交摘要和消息，我们将探讨实现清晰和精确所需的技术和有意为之的实践。
- en: Committing code is like adding individual threads to the overall narrative of
    a project’s development. Each commit, with its summary and message, contributes
    to the understanding of the project’s history and future direction. Maintaining
    a clean commit history goes beyond organizational neatness; it embodies effective
    communication among developers, facilitates seamless collaboration, and enables
    quick navigation through the project’s development history.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 提交代码就像向项目开发的整体叙事中添加个别线索。每个提交，包括其摘要和消息，都为理解项目的历史和未来方向做出了贡献。保持清晰的提交历史不仅仅是组织上的整洁；它体现了开发者之间有效的沟通，促进了无缝的协作，并使快速导航项目开发历史成为可能。
- en: In the following sections, we will examine what makes a “good” commit, focusing
    on attributes that bring clarity, purpose, and utility to commit messages. This
    exploration goes beyond the basics, delving into strategic documentation of code
    changes and insights gained through tools such as Git. With illustrative examples,
    we will see how well-crafted commit histories can transform understanding, aid
    in debugging, and streamline the review process by clearly conveying the rationale
    behind code alterations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨“良好的”提交的特点，重点关注为提交消息带来清晰性、目的性和实用性的属性。这一探索超越了基础层面，深入到代码变更的战略性文档和通过Git等工具获得的见解。通过示例，我们将看到精心构建的提交历史如何改变理解，帮助调试，并通过清晰地传达代码变更背后的理由来简化审查流程。
- en: Advancing further, we will decode the Conventional Commits specification, a
    structured framework designed to standardize commit messages, thereby infusing
    them with predictability and machine-parseable clarity. This section illuminates
    the symbiotic relationship between commit message structure and automated tooling,
    showcasing how adherence to such conventions can dramatically enhance project
    maintainability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推进，我们将解码常规提交规范，这是一个旨在标准化提交消息的结构化框架，从而赋予它们可预测性和机器可解析的清晰度。本节阐明了提交消息结构与自动化工具之间的共生关系，展示了遵守此类规范如何显著提高项目的可维护性。
- en: As we progress, the narrative unfolds to reveal the practicalities of enforcing
    these best practices through the lens of commit linting. Here, we delve into the
    integration of automated tools within **Continuous Integration** (**CI**) workflows,
    demonstrating how such mechanisms serve as vigilant guardians of commit quality,
    ensuring consistency and compliance with established norms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们前进，叙事展开，揭示了通过提交linting的视角来实施这些最佳实践的实际性。在这里，我们深入探讨自动化工具在**持续集成**（**CI**）工作流程中的集成，展示了这些机制如何作为提交质量的警觉守护者，确保一致性和符合既定规范。
- en: This chapter goes beyond explaining the mechanics of version control; it invites
    you to view crafting clean commit histories as a vital part of software craftsmanship.
    By following the principles and practices discussed here, developers and teams
    can improve their code repositories’ quality and create an environment that promotes
    innovation, collaboration, and efficiency. As we explore this chapter, remember
    that a clear commit history reflects our dedication to excellence in software
    development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不仅解释了版本控制的机制；它还邀请你将构建清晰的提交历史视为软件工艺的重要组成部分。通过遵循这里讨论的原则和实践，开发者和团队能够提高代码库的质量，并创造一个促进创新、协作和效率的环境。在我们探索本章时，请记住，清晰的提交历史反映了我们在软件开发中追求卓越的承诺。
- en: What is a good commit?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是良好的提交？
- en: At the heart of effective version control practices lies the concept of a “good
    commit,” a fundamental unit of change that embodies the principles of clarity,
    atomicity, and purposefulness within the code base. Understanding what constitutes
    a good commit is essential for developers who strive to maintain a clean, navigable,
    and informative project history. This section delves into the key attributes that
    define the quality of a commit, offering insights into how developers can enhance
    their version control practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的版本控制实践的核心在于“良好的提交”这一概念，它是变化的基本单元，体现了代码库中的清晰性、原子性和目的性原则。理解构成良好提交的要素对于力求保持项目历史清晰、可导航和富有信息性的开发者至关重要。本节深入探讨了定义提交质量的关键属性，并提供了开发者如何提升其版本控制实践的见解。
- en: The principle of singular focus
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一焦点原则
- en: A good commit adheres to the principle of atomicity, meaning it encapsulates
    a single logical change within the code base. This singular focus ensures that
    each commit is independently meaningful and that the project can be safely and
    easily reverted or modified by reverting or adjusting individual commits. Atomic
    commits simplify code review processes, making it easier for team members to understand
    and evaluate each change without the noise of unrelated modifications. For example,
    instead of combining a new feature implementation with a separate bug fix in one
    commit, they should be split into two distinct commits, each with its clear purpose
    and scope.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的提交遵循原子性原则，意味着它封装了代码库中的单个逻辑变更。这种单一焦点确保每个提交都具有独立的意义，并且可以通过回滚或调整单个提交来安全且轻松地回滚或修改项目。原子提交简化了代码审查过程，使团队成员更容易理解和评估每个变更，而无需处理无关的修改。例如，不应将新功能实现与单独的bug修复合并到一个提交中，而应将它们分成两个不同的提交，每个提交都有其明确的目的和范围。
- en: The art of communication
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沟通的艺术
- en: The essence of a good commit also lies in its clarity, particularly evident
    in the commit message. A clear commit message succinctly describes the what and
    the why of the change, serving as concise documentation for future reference.
    This clarity extends beyond the immediate team, aiding anyone who interacts with
    the code base, including new team members, external collaborators, and even the
    future self. This becomes especially important when revisiting the code base after
    a prolonged period, as the commit messages serve as a historical record of the
    project’s evolution. This approach is crucial for open source projects because
    it allows contributors to understand the context and rationale behind the changes,
    thereby fostering a collaborative and inclusive environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 良好提交的本质也在于其清晰性，尤其是在提交信息中表现得尤为明显。清晰的提交信息简洁地描述了变更的内容和原因，作为未来参考的简要文档。这种清晰性不仅限于团队内部，还帮助任何与代码库互动的人，包括新团队成员、外部合作者和未来的自己。当在长时间后重新访问代码库时，提交信息作为项目演变的记录尤为重要。这种方法对于开源项目至关重要，因为它允许贡献者理解变更的背景和理由，从而营造一个协作和包容的环境。
- en: 'A well-structured commit message typically includes a concise title line summarizing
    the change, followed by a blank line and a more detailed explanation if necessary.
    The explanation can delve into the rationale behind the change, any implications
    it might have, and any additional context that helps understand the commit’s purpose.
    It is recommended to keep the subject line up to 50 characters. This ensures that
    the message fits within the standard width of most terminals, is not terminated
    by GitHub or other platforms, and is easily scannable. GitHub truncates subjects
    shorter than 72 characters, so 72 will be a hard limit and 50 a soft one. For
    example, the commit message `feat: added a lots of needed include directives to
    make things compile properly` will be truncated by GitHub as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '结构良好的提交信息通常包括一个简洁的标题行，总结变更内容，随后是一个空行，如果需要，可以是一个更详细的解释。解释可以深入到变更背后的理由，可能产生的影响，以及有助于理解提交目的的任何附加背景信息。建议将主题行控制在50个字符以内。这确保信息适合大多数终端的标准宽度，不会被GitHub或其他平台截断，并且易于扫描。GitHub截断小于72个字符的主题行，因此72将是硬性限制，50将是软性限制。例如，提交信息`feat:
    added a lots of needed include directives to make things compile properly`将被GitHub截断如下：'
- en: '![Figure 14.1 – Truncated commit message](img/B19606_13_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 截断的提交信息](img/B19606_13_01.jpg)'
- en: Figure 14.1 – Truncated commit message
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 截断的提交信息
- en: GitHub truncates the last word, `properly`, and in order to read it, developers
    will have to click on the commit message. This is not a big deal but it is a small
    inconvenience that can be easily avoided by keeping the subject line short.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub会截断最后一个单词“properly”，为了阅读它，开发者必须点击提交消息。这并不是什么大问题，但这是一个可以通过保持主题行简短来避免的小不便。
- en: More importantly, it forces the author to be concise and to the point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这迫使作者简洁并直截了当。
- en: Other useful practices include using the imperative mood in the subject line,
    which is a common convention in commit messages. This means that the subject line
    should be phrased as a command or instruction, such as `fix the bug` or `add the
    feature`. This style of writing is more direct and aligns with the idea that a
    commit represents a change that is being applied to the code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的实践包括在主题行中使用祈使语气，这是提交消息中的常见约定。这意味着主题行应该以命令或指示的形式表达，例如“修复bug”或“添加功能”。这种写作风格更直接，与提交代表对代码库应用更改的想法相一致。
- en: Prefer not to end the subject line with a period, as it is not a complete sentence
    and does not help to keep the message short. The body of the commit message can
    provide additional context, such as the motivation for the change, the problem
    it solves, and any relevant details about the implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在主题行末尾使用句号，因为它不是一个完整的句子，并且不会有助于保持消息简短。提交消息的正文可以提供额外的上下文，例如变更的动机、解决的问题以及与实现相关的任何相关细节。
- en: Prefer to wrap the body at 72 characters, because Git does not wrap text for
    you. It is a common convention and it makes the message more readable in various
    contexts, such as terminal windows, text editors, and version control tools. It
    can be easily achieved by configuring your code editor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将正文包裹在72个字符以内，因为Git不会为你自动换行文本。这是一个常见的约定，它使得消息在各种环境中（如终端窗口、文本编辑器和版本控制工具）更易于阅读。这可以通过配置你的代码编辑器轻松实现。
- en: Therefore, the moment spent in reflection before finalizing a commit is not
    just about ensuring the clarity of the message; it is about reaffirming the value
    and intent behind the changes themselves. It is an opportunity to ensure that
    each contribution to the code base is deliberate, meaningful, and aligned with
    the project’s objectives. In this light, taking the time to craft a precise and
    informative commit message is not only a good practice but a testament to the
    developer’s commitment to quality and collaboration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在最终确定提交之前花时间进行反思，不仅是为了确保消息的清晰性，而且是为了重申更改本身的价值和意图。这是一个确保代码库的每个贡献都是深思熟虑、有意义的并与项目目标一致的机会。从这个角度来看，花时间编写精确且信息丰富的提交消息不仅是一种良好的实践，也是开发者对质量和协作承诺的证明。
- en: The art of refinement
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精益求精的艺术
- en: Before merging feature branches into the `main` branch, it’s prudent for developers
    to consider the cleanliness and clarity of their commit history. Squashing intermediate
    commits is a thoughtful practice that streamlines the commit log, making it more
    readable and meaningful for anyone who explores the project history.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在将功能分支合并到`main`分支之前，开发者考虑提交历史的整洁性和清晰性是明智的。合并中间提交是一个深思熟虑的实践，它简化了提交日志，使其对探索项目历史的任何人来说都更易于阅读和有意义。
- en: When you’re on the verge of integrating your work, take a moment to reflect
    on the commit messages that have accumulated during development. Ask yourself
    whether each commit message adds value to the understanding of the project’s evolution
    or whether it merely clutters the history with redundant or overly granular details.
    In many cases, the iterative steps you took to arrive at the final solution—such
    as minor bug fixes, adjustments in response to code reviews, or corrections to
    unit tests—may not hold significant value for other contributors or for the future
    you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你即将集成你的工作成果时，花点时间反思一下开发过程中积累的提交消息。问问自己，每个提交消息是否为理解项目演变过程增加了价值，或者它只是用冗余或过于详细的细节使历史记录变得杂乱。在许多情况下，你为了达到最终解决方案所采取的迭代步骤（如微小的错误修复、对代码审查的响应调整或单元测试的纠正）可能对其他贡献者或未来的你并没有太大的价值。
- en: Consider a commit history filled with messages such as `fix bug`, `fix unit
    test`, or multiple `fix cr` entries. Such messages, while indicative of the development
    process, do not necessarily provide meaningful insights into the changes or their
    impact on the project. Squashing these intermediate commits into a single, well-crafted
    commit not only tidies up the commit log but also ensures that each entry in the
    history conveys a significant step in the project’s development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个提交历史，其中包含诸如`修复错误`、`修复单元测试`或多个`修复cr`条目之类的消息。虽然这些消息表明了开发过程，但并不一定提供对更改或它们对项目影响的深刻见解。将这些中间提交压缩成一个精心制作的单个提交不仅整理了提交日志，还确保历史记录中的每个条目都传达了项目开发中的一个重要步骤。
- en: By squashing commits, you consolidate these iterative changes into a cohesive
    narrative that highlights the introduction of a new feature, the resolution of
    a significant bug, or the implementation of a crucial refactor. This curated history
    aids both current contributors and future maintainers in navigating and understanding
    the project’s progression, enhancing collaboration and efficiency.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过压缩提交，您可以将这些迭代更改整合成一个连贯的故事，突出新功能的引入、重大错误的解决或关键重构的实施。这种精心编排的历史记录有助于当前贡献者和未来的维护者导航和理解项目的进展，提高协作和效率。
- en: In summary, before merging, consider the broader perspective of the project’s
    commit history. Squashing intermediate commits is a practice in mindfulness, ensuring
    that the commit log remains a valuable and navigable resource for all contributors,
    encapsulating the essence of each change in a clear and concise manner.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在合并之前，考虑项目提交历史的更广泛视角。压缩中间提交是一种正念的实践，确保提交日志始终是所有贡献者宝贵的可导航资源，以清晰简洁的方式封装每个更改的精髓。
- en: Conventional Commits specification
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的提交规范
- en: Consistency in commit messages and structures across a project enhances readability
    and predictability, making it easier for team members to navigate the project
    history. Adhering to a predefined format or set of conventions, such as the Conventional
    Commits specification, ensures that commit messages are uniformly structured and
    informative. These might include starting commit messages with a verb in the imperative
    mood, specifying the type of change (e.g., `fix`, `feat`, or `refactor`), and
    optionally including a scope to clarify what part of the project is affected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中的提交信息和结构上保持一致性，可以提高可读性和可预测性，使团队成员更容易导航项目历史。遵循预定义的格式或一组约定，如传统的提交规范，确保提交信息结构统一且信息丰富。这些可能包括以祈使语气开始的提交信息，指定更改类型（例如，`fix`、`feat`或`refactor`），以及可选地包括范围以阐明受影响的项目的哪个部分。
- en: Linking code to context
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码与上下文联系起来
- en: A good commit enhances traceability by linking the code change to its broader
    context, such as a ticket in the project’s issue-tracking system or relevant documentation.
    Including references in commit messages creates a tangible connection between
    the technical implementation and the requirements or issues it addresses, facilitating
    better understanding and tracking of project progress.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的提交通过将代码更改与其更广泛的上下文联系起来，如项目问题跟踪系统中的票据或相关文档，从而增强了可追溯性。在提交信息中包含引用，在技术实现与其解决的问题或需求之间建立了有形的联系，有助于更好地理解和跟踪项目进度。
- en: 'Incorporating issue tracker IDs, ticket numbers, or other relevant identifiers
    in commit messages can significantly improve the traceability of changes and the
    ease with which they can be related to the project’s objectives or reported issues.
    It often looks similar to `fix(FP-1234): corrected the user authentication flow`,
    where `FP-1234` is the ticket number in the issue-tracking system.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交信息中包含问题跟踪器ID、票据编号或其他相关标识符可以显著提高更改的可追溯性和它们与项目目标或报告问题相关联的便捷性。它通常看起来类似于`fix(FP-1234)：修复了用户身份验证流程`，其中`FP-1234`是问题跟踪系统中的票据编号。
- en: In essence, a good commit acts as a coherent, self-contained story within the
    broader narrative of a project’s development history. By adhering to these principles,
    developers not only contribute to the maintainability and readability of the code
    base but also foster a culture of meticulousness and accountability in version
    control practices. Through the disciplined creation of good commits, the project’s
    history becomes a valuable asset for collaboration, review, and understanding
    the evolution of the software.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，一个好的提交在项目开发历史的更广泛叙事中充当一个连贯的、自包含的故事。通过遵循这些原则，开发者不仅有助于提高代码库的可维护性和可读性，而且促进了版本控制实践中严谨性和责任感的文化。通过有纪律地创建良好的提交，项目的历史成为协作、审查和理解软件演变的有价值资产。
- en: One of the best ways to create good commit messages is by following the Conventional
    Commits specification. The Conventional Commits specification stands as a structured
    framework for commit message formatting, designed with the dual aim of simplifying
    the process of creating readable commit logs and enabling automated tooling to
    facilitate version management and release note generation. This specification
    delineates a standardized format for commit messages, intending to clearly communicate
    the nature and intent of changes within a version control system, such as Git.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建良好的提交信息的一种最佳方式是遵循常规提交规范。常规提交规范作为一个结构化框架，用于提交信息格式化，旨在简化创建可读提交日志的过程，并使自动化工具能够促进版本管理和发布说明的生成。本规范定义了提交信息的标准化格式，旨在在版本控制系统（如Git）中清楚地传达变更的性质和意图。
- en: Overview and intent
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述和意图
- en: 'At its core, the Conventional Commits specification prescribes a format that
    includes a type, an optional scope, and a succinct description. The format typically
    follows this structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，常规提交规范规定了包括类型、可选范围和简洁描述的格式。格式通常遵循以下结构：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *type* categorizes the commit according to the nature of the change it introduces,
    such as `feat` for a new feature or `fix` for a bug fix. The *scope*, though optional,
    provides additional contextual information, often indicating the part of the code
    base affected by the change. The *description* offers a concise summary of the
    change, crafted in an imperative mood.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类型根据引入变更的性质对提交进行分类，例如`feat`表示新功能或`fix`表示错误修复。范围虽然可选，但提供了额外的上下文信息，通常指示受变更影响的代码库部分。描述提供了变更的简洁总结，以祈使语气编写。
- en: Options and usage
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项和用法
- en: 'Commit linting, particularly when adhering to the Conventional Commits specification,
    ensures that commits are structured in a clear, predictable, and useful manner.
    Here are some examples of commits that comply with commit linting rules, showcasing
    various types of changes that might occur in a software project:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 提交检查，尤其是在遵循常规提交规范时，确保提交以清晰、可预测和有用的方式结构化。以下是一些符合提交检查规则的提交示例，展示了在软件项目中可能发生的各种类型的变化：
- en: 'Adding a new feature:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新功能：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This commit message indicates that a new feature (`feat`) has been added, (specifically,
    biometric authentication support) and the scope of this feature is within the
    authentication module of the application.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此提交信息表明已添加新功能（具体为生物识别认证支持），并且该功能的范围在应用程序的认证模块内。
- en: 'Fixing a bug:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, a bug fix (`fix`) is being committed, addressing a race condition issue
    within the `database` module, particularly in the process of user data retrieval.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，一个错误修复（`fix`）正在提交，解决`database`模块中的竞争条件问题，特别是在用户数据检索过程中。
- en: 'Improving documentation:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进文档：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example shows a documentation update (`docs`), with the changes made to
    the project’s README file to update the installation instructions.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此示例展示了文档更新（`docs`），包括对项目README文件的更改，以更新安装说明。
- en: 'Code refactoring:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this commit, existing code has been refactored (`refactor`) without adding
    any new features or fixing any bugs. The scope of the refactoring is the UI, specifically
    simplifying the logic used in a `button` component.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这次提交中，现有代码已被重构（`refactor`），但没有添加任何新功能或修复任何错误。重构的范围是用户界面（UI），具体是简化了`button`组件中使用的逻辑。
- en: 'Style adjustments:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式调整：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This commit message signifies a styling change (`style`), where unused CSS classes
    are being removed. It’s worth noting that this type of commit does not affect
    the functionality of the code.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此提交信息表示一个样式变更（`style`），其中正在删除未使用的 CSS 类。值得注意的是，此类提交不会影响代码的功能。
- en: 'Adding tests:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加测试：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, new tests (`test`) have been added for a new user endpoint in the API,
    indicating an enhancement in the project’s test coverage.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，为 API 中的新用户端点添加了新的测试（`test`），这表明项目测试覆盖率有所提升。
- en: 'Chore tasks:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This commit represents a chore (`chore`), typically a maintenance or setup task
    that doesn’t directly modify the source code or add functionality, such as updating
    a build script for deployment.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此提交代表一个任务（`chore`），通常是一个维护或设置任务，它不会直接修改源代码或添加功能，例如更新部署的构建脚本。
- en: 'Breaking change:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性变更：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another method to indicate a breaking change is by adding an exclamation mark
    (`!`) after the type and scope but before the colon in the commit message. This
    method is succinct and visually noticeable:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种表示破坏性变更的方法是在提交信息中的类型和作用域之后但冒号之前添加一个感叹号（`!`）。这种方法简洁且视觉上明显：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This commit introduces a new feature (`feat`) related to the database schema
    of the user’s table but also includes a breaking change.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此提交引入了一个与用户表数据库模式相关的新功能（`feat`），但也包括一个破坏性变更。
- en: These examples illustrate how commit linting, guided by the Conventional Commits
    specification, facilitates clear, structured, and informative commit messages
    that enhance project maintainability and collaboration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明了由 Conventional Commits 规范指导的提交清理如何促进清晰、结构化和信息丰富的提交信息，从而增强项目的可维护性和协作。
- en: Origins and adoption
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源起和采用
- en: The Conventional Commits specification was inspired by the need to streamline
    the creation of readable and automated changelogs. It builds upon earlier practices
    from the AngularJS team and has since been adopted by various open source and
    enterprise projects seeking to standardize commit messaging for improved project
    maintainability and collaboration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Conventional Commits 规范的灵感来源于简化可读和自动化的变更日志的需求。它建立在 AngularJS 团队早期实践的基础上，并已被寻求标准化提交信息以改善项目可维护性和协作的多个开源和企业项目采用。
- en: Advantages of Conventional Commits
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Conventional Commits 的优势
- en: 'Adhering to the Conventional Commits specification offers numerous benefits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 Conventional Commits 规范提供了许多好处：
- en: '**Automated Semver handling**: By categorizing commits, tools can automatically
    determine version bumps based on the semantic meaning of changes, adhering to
    **Semantic Versioning** (**Semver**) principles'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化 Semver 处理**：通过分类提交，工具可以根据变化的语义意义自动确定版本升级，遵循 **语义版本控制**（**Semver**）原则。'
- en: '**Streamlined release notes**: Automated tools can generate comprehensive and
    clear release notes and changelogs by parsing structured commit messages, significantly
    reducing manual effort and enhancing release documentation'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化版发布说明**：通过解析结构化提交信息，自动化工具可以生成全面且清晰的发布说明和变更日志，显著减少手动工作并增强发布文档。'
- en: '**Enhanced readability**: The standardized format improves the readability
    of commit history, making it easier for developers to navigate and understand
    project evolution'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可读性**：标准化的格式提高了提交历史记录的可读性，使开发者更容易导航和理解项目演变。'
- en: '**Facilitated code reviews**: The clear categorization and description of changes
    aid in the code review process, enabling reviewers to quickly grasp the scope
    and intent of changes'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进代码审查**：清晰的分类和描述有助于代码审查过程，使审查者能够快速掌握变更的范围和意图。'
- en: Commitlint – enforcing commit message standards
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Commitlint – 强制执行提交信息标准
- en: Commitlint is a powerful, configurable tool designed to enforce commit message
    conventions, ensuring consistency and clarity across a project’s commit history.
    It plays a crucial role in maintaining a clean, readable, and meaningful commit
    log, particularly when used in conjunction with conventions such as the Conventional
    Commits specification. This section provides a comprehensive guide on how to install,
    configure, and use commitlint to check commit messages locally, fostering a disciplined
    approach to version control and collaboration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 是一个强大且可配置的工具，旨在强制执行提交信息约定，确保项目提交历史的一致性和清晰性。它在维护一个干净、易读且富有意义的提交日志中起着至关重要的作用，尤其是在与如
    Conventional Commits 规范等约定一起使用时。本节提供了如何安装、配置和使用 commitlint 检查本地提交信息的全面指南，从而培养对版本控制和协作的纪律性方法。
- en: Installation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Commitlint is typically installed via npm, the package manager for Node.js.
    To get started, you’ll need to have Node.js and npm installed on your development
    machine. Once set up, you can install commitlint and its conventional `config`
    package by running the following commands in your project’s root directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 通常通过 npm 安装，这是 Node.js 的包管理器。要开始，你需要在你的开发机器上安装 Node.js 和 npm。一旦设置好，你可以在项目根目录中运行以下命令来安装
    commitlint 和其常规 `config` 包：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command installs commitlint and the conventional commits configuration
    as development dependencies in your project, making them available for use in
    the local development environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 commitlint 和常规提交配置作为开发依赖项安装到你的项目中，使它们在本地开发环境中可用。
- en: Configuration
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'After installation, commitlint requires a configuration file to define the
    rules it will enforce. The most straightforward way to configure commitlint is
    by using the conventional commits configuration, which aligns with the Conventional
    Commits specification. Create a file named `commitlint.config.js` in your project’s
    root directory, and add the following content:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，commitlint 需要一个配置文件来定义它将强制执行的规则。配置 commitlint 最直接的方法是使用常规提交配置，这与常规提交规范相一致。在你的项目根目录中创建一个名为
    `commitlint.config.js` 的文件，并添加以下内容：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This configuration instructs commitlint to use the standard rules provided by
    the Conventional Commits configuration, which include checks for the structure,
    types, and scopes of commit messages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置指示 commitlint 使用由常规提交配置提供的标准规则，包括对提交信息结构、类型和作用域的检查。
- en: Local usage
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地使用
- en: To check commit messages locally, you can use commitlint in conjunction with
    Husky, a tool for managing Git hooks. Husky can be configured to trigger commitlint
    to evaluate commit messages before they are committed, providing immediate feedback
    to the developer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地检查提交信息，你可以使用与 Husky 结合的 commitlint，Husky 是一个用于管理 Git 钩子的工具。Husky 可以配置为在提交之前触发
    commitlint 来评估提交信息，为开发者提供即时反馈。
- en: 'First, install Husky as a development dependency:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 Husky 作为开发依赖项安装：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let us check local commits with commitlint:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 commitlint 检查本地提交：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `--from HEAD~1` and `--to HEAD` specify the range of commits
    to check, and `--verbose` provides detailed output. If the commit message does
    not adhere to the specified conventions, commitlint will output an error message,
    indicating the violations that need to be addressed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`--from HEAD~1` 和 `--to HEAD` 指定了要检查的提交范围，而 `--verbose` 提供了详细的输出。如果提交信息不符合指定的规范，commitlint
    将输出错误信息，指出需要解决的问题。
- en: 'Let us add a bad commit message and check it with commitlint:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个糟糕的提交信息并使用 commitlint 检查它：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Commitlint can be integrated as a Git hook by adding the following configuration
    to your `package.json` file or by creating a `.huskyrc` file with the same content:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将以下配置添加到你的 `package.json` 文件中或创建一个包含相同内容的 `.huskyrc` 文件来将 commitlint 集成为
    Git 钩子：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This configuration sets up a pre-commit hook that invokes commitlint with the
    commit message that is about to be committed. If the commit message does not meet
    the specified standards, commitlint will reject the commit, and the developer
    will need to revise the message accordingly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置设置了一个预提交钩子，它会在提交即将被提交时调用 commitlint。如果提交信息不符合指定的标准，commitlint 将拒绝提交，开发者需要相应地修改信息。
- en: Customizing rules
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义规则
- en: Commitlint offers a wide array of configuration and customization options, allowing
    teams to tailor commit message validation rules to fit their specific project
    requirements and workflows. This flexibility ensures that commitlint can be adapted
    to support various commit conventions beyond the standard Conventional Commits
    format, providing a robust framework for enforcing consistent and meaningful commit
    messages across diverse development environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 提供了广泛的配置和自定义选项，允许团队根据他们的特定项目需求和工作流程定制提交信息验证规则。这种灵活性确保了 commitlint
    可以适应支持各种提交规范，而不仅仅是标准的常规提交格式，为在多样化的开发环境中强制执行一致且有意义的提交信息提供了一个强大的框架。
- en: Basic configuration
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本配置
- en: 'The basic configuration of commitlint involves setting up a `commitlint.config.js`
    file in your project’s root directory. This file serves as the central point for
    defining the rules and conventions that commitlint will enforce. At its simplest,
    the configuration might extend a predefined set of rules, such as those provided
    by `@commitlint/config-conventional`, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 的基本配置涉及在项目的根目录中设置一个 `commitlint.config.js` 文件。该文件作为定义 commitlint
    将强制执行的规则和约定的中心点。在最简单的情况下，配置可能扩展一个预定义的规则集，例如由 `@commitlint/config-conventional`
    提供的规则，如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This configuration instructs commitlint to use the conventional commit message
    rules, enforcing a standard structure and set of types for commit messages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置指示 commitlint 使用常规提交消息规则，强制执行提交消息的标准结构和类型集。
- en: Custom rule configuration
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义规则配置
- en: 'Commitlint’s real power lies in its ability to customize rules to match specific
    project needs. Each rule in commitlint is identified by a string key and can be
    configured with an array specifying the rule’s level, applicability, and, in some
    cases, additional options or values. The rule configuration array generally follows
    the format `[level,` `applicability, value]`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 的真正力量在于其能够自定义规则以匹配特定项目需求的能力。commitlint 中的每个规则都由一个字符串键标识，并且可以使用一个数组进行配置，指定规则的级别、适用性和在某些情况下，附加选项或值。规则配置数组通常遵循以下格式
    `[级别,` `适用性, 值]`：
- en: '`0` = disabled, `1` = warning, and `2` = error)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` = 禁用，`1` = 警告，和 `2` = 错误）'
- en: '`''always''` or `''never''`)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''always''` 或 `''never''`)'
- en: '**Value**: Additional parameters or options for the rule, varying by rule'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：规则的附加参数或选项，根据规则而异'
- en: 'For example, to enforce that commit messages must start with a type followed
    by a colon and a space, you could configure the `type-enum` rule as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了强制提交消息必须以类型后跟冒号和空格开始，您可以按如下方式配置 `type-enum` 规则：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This configuration sets the rule level to error (`2`), specifies that the rule
    should always be applied, and defines a list of acceptable types for commit messages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将规则级别设置为错误（`2`），指定规则应始终应用，并定义了提交消息的可接受类型列表。
- en: Scope and subject configuration
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域和主题配置
- en: 'Commitlint also allows for detailed configuration of commit message scopes
    and subjects. For instance, you can enforce specific scopes or require that commit
    message subjects do not end with a period:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint 允许对提交消息的作用域和主题进行详细配置。例如，您可以强制执行特定的作用域或要求提交消息的主题不以句号结尾：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This setup mandates that commits must use one of the predefined scopes and that
    the subject line must not end with a period.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置强制要求提交必须使用预定义的作用域之一，并且主题行不得以句号结尾。
- en: Customizing and sharing configurations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义和共享配置
- en: 'For projects or organizations with unique commit message conventions, custom
    configurations can be defined and, if needed, shared across multiple projects.
    You can create a dedicated npm package for your commitlint configuration, allowing
    teams to easily extend this shared configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有独特提交消息约定的项目或组织，可以定义自定义配置，并在需要时跨多个项目共享。您可以为您的 commitlint 配置创建一个专门的 npm 包，使团队能够轻松扩展此共享配置：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This approach promotes consistency across projects and simplifies the management
    of commit message rules within an organization.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法促进了项目之间的连贯性，并简化了组织内部提交消息规则的管理。
- en: Integration with CI
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 CI 集成
- en: Ensuring the enforcement of commitlint via CI is a crucial practice in maintaining
    high-quality commit messages across a project. While local Git hooks, such as
    those managed by Husky, offer a first line of defense by checking commit messages
    on the developer’s machine, they are not infallible. Developers might intentionally
    or accidentally disable Git hooks, and **Integrated Development Environments**
    (**IDEs**) or text editors might not be properly configured to enforce these hooks
    or might encounter issues that lead to their malfunction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 CI 确保执行 Commitlint 是维护项目内高质量提交消息的关键实践。虽然本地 Git 钩子，如由 Husky 管理的钩子，通过在开发者的机器上检查提交消息提供了一道防线，但它们并非万无一失。开发者可能有意或无意地禁用
    Git 钩子，**集成开发环境**（**IDEs**）或文本编辑器可能没有正确配置以强制执行这些钩子，或者可能遇到导致其故障的问题。
- en: Given these potential gaps in local enforcement, CI serves as the authoritative
    source of truth, providing a centralized, consistent platform for verifying commit
    messages against the project’s standards. By integrating commitlint into the CI
    pipeline, projects ensure that every commit, regardless of its origin or the method
    used to submit it, adheres to the defined commit message conventions before it
    is merged into the main code base. This CI-based enforcement fosters a culture
    of discipline and accountability, ensuring that all contributions, regardless
    of their source, meet the project’s quality standards.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些本地执行中的潜在差距，CI充当了权威的真实来源，提供了一个集中、一致的平台，用于验证提交信息是否符合项目标准。通过将commitlint集成到CI管道中，项目确保每个提交，无论其来源或提交它的方法如何，在合并到主代码库之前都遵循定义的提交信息约定。这种基于CI的执行促进了纪律和责任感的氛围，确保所有贡献，无论其来源如何，都符合项目的质量标准。
- en: Integrating commitlint into CI with GitHub Actions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GitHub Actions将commitlint集成到CI中
- en: GitHub Actions offers a straightforward and powerful platform for integrating
    commitlint into your CI workflow. The following example demonstrates how to set
    up a GitHub action to enforce commit message standards using commitlint on every
    push or pull request targeting the `main` branch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions提供了一个简单而强大的平台，用于将commitlint集成到您的CI工作流程中。以下示例演示了如何设置GitHub操作，以使用commitlint在每次推送或针对`main`分支的pull
    request时强制执行提交信息标准。
- en: 'First, create a new file in your repository under `.github/workflows/commitlint.yml`
    with the following content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的仓库中的`.github/workflows/commitlint.yml`下创建一个新文件，内容如下：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This workflow defines a job named `commitlint` that triggers on pushes and
    pull requests to the `main` branch. The only configuration that I would like to
    highlight is `failOnWarnings: true`, which configures the action to fail the job
    if any commitlint warnings are encountered. This ensures strict adherence to the
    commit message standards by treating warnings with the same severity as errors.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '此工作流程定义了一个名为`commitlint`的作业，它在推送和pull request到`main`分支时触发。我想强调的唯一配置是`failOnWarnings:
    true`，它配置操作在遇到任何commitlint警告时失败。这确保了通过将警告视为与错误相同的严重性来严格遵循提交信息标准。'
- en: 'Let us create a bad commit message and open a PR to see how the action works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个糟糕的提交信息并打开一个PR来查看操作是如何工作的：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After we open a PR, we will see that the action has failed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开一个PR之后，我们会看到操作失败了：
- en: '![Figure 14.2 – Commitlint action failed](img/B19606_13_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – Commitlint操作失败](img/B19606_13_02.jpg)'
- en: Figure 14.2 – Commitlint action failed
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – Commitlint操作失败
- en: 'The logs will show the reason for the failure in the same format as the local
    check:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 日志将以与本地检查相同的格式显示失败原因：
- en: '![Figure 14.3 – Commitlint action log failed](img/B19606_13_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – Commitlint操作日志失败](img/B19606_13_03.jpg)'
- en: Figure 14.3 – Commitlint action log failed
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – Commitlint操作日志失败
- en: By incorporating this workflow into your project, you ensure that every commit
    is scrutinized for adherence to your commit message standards before it becomes
    part of the `main` branch. This CI-based check acts as a final gatekeeper, reinforcing
    the importance of well-structured commit messages and maintaining the integrity
    of the project’s commit history.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此工作流程集成到您的项目中，您确保每个提交在成为`main`分支的一部分之前都会被仔细检查是否符合您的提交信息标准。这个基于CI的检查充当最后的守门人，强化了良好结构化提交信息的重要性，并维护了项目提交历史的完整性。
- en: Commitlint’s configurability and customization options provide a powerful platform
    for enforcing commit message standards tailored to a project’s or organization’s
    specific needs. By leveraging these capabilities, teams can ensure that their
    commit logs remain clear, consistent, and meaningful, thereby enhancing project
    maintainability and collaboration. Whether adhering to widely accepted conventions
    such as the Conventional Commits specification or defining a set of custom rules,
    commitlint offers the flexibility and control needed to maintain a high-quality
    commit history.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Commitlint的可配置性和定制选项提供了一个强大的平台，用于执行针对项目或组织特定需求的提交信息标准。通过利用这些功能，团队可以确保他们的提交日志保持清晰、一致和有意义，从而提高项目的可维护性和协作性。无论是遵循广泛接受的约定，如常规提交规范，还是定义一组自定义规则，commitlint都提供了维护高质量提交历史所需的灵活性和控制力。
- en: Generating changelogs
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成变更日志
- en: Automatic changelog generation is a method where software tools automatically
    create a log of changes made to a project, categorizing and listing updates, fixes,
    and features. This process is favored for its efficiency and consistency, ensuring
    that all significant modifications are documented systematically. We’ll explore
    this concept through GitCliff, a tool that parses structured commit messages to
    generate detailed changelogs, aiding in transparent project management and communication.
    GitCliff’s utility in this process exemplifies its role in automating and streamlining
    project documentation tasks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成变更日志是一种方法，其中软件工具自动创建项目更改的日志，对更新、修复和功能进行分类和列出。这个过程因其效率和一致性而受到青睐，确保所有重大修改都得到系统性的记录。我们将通过GitCliff来探讨这个概念，GitCliff是一个解析结构化提交消息以生成详细变更日志的工具，有助于透明的项目管理与沟通。GitCliff在这个过程中所发挥的作用体现了其在自动化和简化项目文档任务中的作用。
- en: Installation
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'GitCliff is written in Rust and can be installed using Cargo, the Rust package
    manager. To install GitCliff, ensure that you have Rust and Cargo installed on
    your system, and then run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: GitCliff是用Rust编写的，可以使用Rust包管理器Cargo进行安装。要安装GitCliff，请确保您的系统已安装Rust和Cargo，然后运行以下命令：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After installing Rust, you can install GitCliff using Cargo:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Rust后，您可以使用Cargo安装GitCliff：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last configuration step is to initialize GitCliff in your project:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步配置是将GitCliff初始化到您的项目中：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This generates a default configuration file, `.cliff.toml`, in the root of your
    project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您项目的根目录中生成一个默认配置文件，`.cliff.toml`。
- en: GitCliff usage
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitCliff使用
- en: 'After installing and initializing GitCliff, you can generate a changelog by
    running the following command in your project’s root directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并初始化GitCliff后，您可以在项目根目录中运行以下命令来生成变更日志：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The tool generates a Markdown file with the changelog, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 工具会生成一个包含变更日志的Markdown文件，如下所示：
- en: '![Figure 14.4 – Generated changelog](img/B19606_13_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 生成变更日志](img/B19606_13_04.jpg)'
- en: Figure 14.4 – Generated changelog
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 生成变更日志
- en: The log contains a list of changes, categorized by type, and it highlights breaking
    changes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 日志包含按类型分类的更改列表，并突出显示破坏性更改。
- en: 'Let us add a release tag and generate a changelog for the release:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个发布标签并生成发布变更日志：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The changelog will now contain the release tag and the changes since the last
    release:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的变更日志将包含发布标签和自上次发布以来的更改：
- en: '![Figure 14.5 – Generated changelog with release tag](img/B19606_13_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 包含发布标签的生成变更日志](img/B19606_13_05.jpg)'
- en: Figure 14.5 – Generated changelog with release tag
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 包含发布标签的生成变更日志
- en: 'We can introduce a breaking change and bump the version:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入破坏性更改并提升版本：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, GitCliff has detected the breaking change and bumped the version
    to 2.0.0:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，GitCliff已经检测到破坏性更改并将版本提升到2.0.0：
- en: '![Figure 14.6 – Generated changelog with breaking change](img/B19606_13_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 包含破坏性更改的生成变更日志](img/B19606_13_06.jpg)'
- en: Figure 14.6 – Generated changelog with breaking change
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 包含破坏性更改的生成变更日志
- en: In the preceding sections, we have comprehensively explored the significant
    functionalities of `git-cliff`, revealing its substantial utility in automating
    change log generation. This tool distinguishes itself not only through its capacity
    to streamline the documentation process but also through its seamless integration
    with CI platforms, including but not limited to GitHub. Such integration ensures
    that changelogs are consistently synchronized with the latest project developments,
    thereby maintaining the accuracy and relevance of project documentation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经全面探讨了`git-cliff`的重要功能，揭示了它在自动化变更日志生成方面的巨大效用。这个工具不仅因其能够简化文档流程而脱颖而出，还因其与CI平台的无缝集成而著称，包括但不限于GitHub。这种集成确保了变更日志与最新的项目发展保持一致，从而保持了项目文档的准确性和相关性。
- en: An equally noteworthy feature of git-cliff is the extensive customization it
    offers for changelog generation. Users are afforded the flexibility to tailor
    the format, content, and presentation of changelogs to meet specific project requirements
    or personal preferences. This high degree of customizability ensures that the
    output not only aligns with but also enhances the project’s documentation standards.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: git-cliff的另一个同样值得注意的特性是它在生成变更日志方面提供的广泛定制功能。用户可以灵活地调整变更日志的格式、内容和展示方式，以满足特定项目需求或个人偏好。这种高度的可定制性确保了输出不仅与项目文档标准保持一致，而且还能提升项目文档标准。
- en: Given the depth of functionality and the potential benefits that git-cliff offers,
    those interested in leveraging this tool to its fullest are encouraged to consult
    the official documentation. This resource is a treasure trove of detailed information,
    covering the breadth of features, configurations, and best practices associated
    with git-cliff. Engaging with the official documentation will not only solidify
    your understanding of the tool but also equip you with the knowledge to implement
    it effectively in your projects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到git-cliff提供的功能深度和潜在好处，那些希望充分利用此工具的人被鼓励查阅官方文档。这个资源是一个信息宝库，涵盖了与git-cliff相关的所有功能、配置和最佳实践的广泛内容。与官方文档的互动不仅将巩固你对工具的理解，还将为你提供在项目中有效实施它的知识。
- en: To summarize, having delved into the major capabilities and advantages of git-cliff,
    the path forward for those looking to integrate this tool into their development
    workflow is through a thorough exploration of the official documentation. This
    exploration promises to extend your proficiency in utilizing git-cliff, ensuring
    that you can fully harness its capabilities to enhance your project’s change log
    generation and documentation processes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在深入了解了git-cliff的主要功能和优势之后，那些希望将此工具集成到他们的开发工作流程中的人，应该通过彻底研究官方文档来继续前进。这次探索承诺将扩展你在使用git-cliff方面的熟练度，确保你能够充分利用其功能来增强你项目的变更日志生成和文档流程。
- en: Utilizing git-bisect in bug hunting
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用git-bisect进行错误查找
- en: During the process of software development, the task of identifying and rectifying
    bugs is paramount to ensure the stability and reliability of the application.
    Among the arsenal available to developers for this purpose, `git-bisect` stands
    out as a powerful tool, specifically designed for the task of isolating the commit
    that introduced a bug into the code base.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的过程中，识别和修复错误的任务对于确保应用程序的稳定性和可靠性至关重要。在开发者可用的工具中，`git-bisect`因其专门用于隔离将错误引入代码库的提交的强大功能而脱颖而出。
- en: Embedded within the Git version control system, `git-bisect` is a utility based
    on the binary search algorithm. It aids developers in sifting through a potentially
    vast commit history to pinpoint the exact change that caused a regression or introduced
    an error. By adopting a divide-and-conquer strategy, `git-bisect` significantly
    streamlines the debugging process, making it an efficient approach to troubleshooting.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Git版本控制系统内嵌的`git-bisect`是一个基于二分搜索算法的实用工具。它帮助开发者筛选大量的提交历史，以确定导致回归或引入错误的精确变更。通过采用分而治之的策略，`git-bisect`显著简化了调试过程，使其成为故障排除的高效方法。
- en: 'The journey with `git-bisect` begins by establishing two critical points in
    the project’s timeline: a commit where the bug is known to be absent (referred
    to as `good`) and a commit where the bug is confirmed to be present (`bad`). With
    these markers set, `git-bisect` proceeds to check out a commit that lies midway
    between the `good` and `bad` commits. This step requires the developer to test
    the current state of the application to determine whether the bug is present or
    not.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git-bisect`的旅程从确定项目时间线中的两个关键点开始：一个已知没有错误的提交（称为`good`）和一个已知存在错误的提交（称为`bad`）。设置这些标记后，`git-bisect`将检查出位于`good`和`bad`提交之间的一个提交。这一步需要开发者测试当前应用程序的状态，以确定是否存在错误。
- en: The iterative process involves `git-bisect` selecting a new commit based on
    the developer’s feedback, and continually narrowing down the search area by halving
    it with each step. The cycle of testing and feedback continues until `git-bisect`
    successfully isolates the commit that introduced the bug, effectively zeroing
    in on the root cause with minimal manual review.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代过程涉及`git-bisect`根据开发者的反馈选择一个新的提交，并通过每次将搜索区域减半来不断缩小搜索范围。测试和反馈的循环继续进行，直到`git-bisect`成功隔离出引入错误的提交，有效地将注意力集中在根本原因上，并最小化手动审查。
- en: The efficiency of `git-bisect` lies in its ability to reduce the number of commits
    that need to be scrutinized manually, thus conserving valuable development time.
    Its methodical approach ensures precision in identifying the problematic commit,
    which is crucial for understanding the context of the bug and formulating an effective
    fix. Being an integral part of the Git ecosystem, `git-bisect` seamlessly fits
    into the developer’s existing workflow, offering a familiar and straightforward
    interface for debugging.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`git-bisect`的效率在于其减少需要手动审查的提交数量的能力，从而节省宝贵的发展时间。其系统性的方法确保在识别有问题的提交时精确无误，这对于理解错误的上下文和制定有效的修复方案至关重要。作为Git生态系统的一部分，`git-bisect`无缝地融入开发者的现有工作流程，提供了一个熟悉且直观的调试界面。'
- en: To optimize the effectiveness of `git-bisect`, it is imperative to use a reliable
    and accurate test case for evaluating each commit. This ensures that the feedback
    provided to `git-bisect` correctly reflects the presence or absence of the bug,
    thereby preventing misidentification. Maintaining a clean and logical commit history,
    where each commit encapsulates a single change, enhances the tool’s efficiency.
    Furthermore, automating the testing process within the `git-bisect` session, when
    feasible, can expedite the bug-hunting endeavor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化`git-bisect`的有效性，使用一个可靠且准确的测试用例来评估每个提交至关重要。这确保了提供给`git-bisect`的反馈正确反映了错误的存不存在，从而防止误识别。保持干净且逻辑清晰的提交历史，其中每个提交封装一个单一的变化，可以增强工具的效率。此外，在可行的情况下，在`git-bisect`会话中自动化测试过程，可以加快错误搜索的进程。
- en: 'Consider a scenario where a regression is detected in a feature that was previously
    functioning correctly. It happens often when certain tests are running only at
    night. The task is to identify the commit responsible for this regression using
    `git-bisect`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，一个之前运行正常的功能检测到回归。这种情况通常发生在某些测试只在夜间运行时发生。任务是使用`git-bisect`识别出导致这种回归的提交：
- en: Start the `bisect` session with `git` `bisect start`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git` `bisect start`开始`bisect`会话。
- en: Mark the commit in which the bug is present as `git bisect bad <commit hash>`
    (usually, it is `HEAD`).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存在错误的提交标记为`git bisect bad <commit hash>`（通常为`HEAD`）。
- en: Identify a commit in the past where the feature worked correctly and mark it
    as `good` using `git bisect` `good <commit-hash>`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定一个过去功能正常的工作提交，并使用`git bisect good <commit-hash>`将其标记为`good`。
- en: '`git-bisect` will then check out a commit halfway between the `good` and `bad`
    commits. Test this commit to see whether the bug exists.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后`git-bisect`将检查位于`good`和`bad`提交中间的提交。测试这个提交以查看是否存在错误。
- en: Based on the test outcome, mark the commit as `good` or `bad`. `git-bisect`
    uses this feedback to narrow down the search space and selects a new commit for
    testing.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据测试结果，将提交标记为`good`或`bad`。`git-bisect`使用此反馈来缩小搜索范围，并选择一个新的提交进行测试。
- en: Repeat the testing and marking process until `git-bisect` identifies the commit
    that introduced the bug.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复测试和标记过程，直到`git-bisect`识别出引入错误的提交。
- en: Once the problematic commit is identified, developers can examine the changes
    introduced in that commit to understand the cause of the bug and proceed with
    developing a fix.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了有问题的提交，开发者可以检查该提交中引入的变化，以了解错误的起因，并继续开发修复方案。
- en: 'To demonstrate how it works, I cloned the master branch of the `rapidjson`
    library a bug and put it in the middle of the local repo. The Git log looks as
    follows, where `Bad commit (6 hours ago) <f-squirrel>` is the `bad` one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其工作原理，我克隆了`rapidjson`库的master分支，引入了一个错误并将其放在本地仓库的中间。Git日志如下，其中`Bad commit
    (6 hours ago) <f-squirrel>`是错误的提交：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let us start bisecting by marking `good` and `bad` commits:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过标记`good`和`bad`提交开始二分查找：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I have prepared a script that checks whether the bug is present in the current
    commit. The script is called `test.sh` and looks as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一个脚本，用于检查当前提交中是否存在错误。该脚本名为`test.sh`，如下所示：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Every time I run the script, I mark the commit as `good` or `bad`. After a
    few iterations, I have found the commit that introduced the bug:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行脚本时，我都会将提交标记为`good`或`bad`。经过几次迭代后，我找到了引入错误的提交：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we run the test script again, we will see that the bug is present in the
    commit:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试脚本，我们会看到错误存在于以下提交中：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once we finish our bug hunt, we can reset the `bisect` session with `git` `bisect
    reset`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成错误搜索，可以使用`git` `bisect reset`重置`bisect`会话。
- en: 'Jumping between commits for a user is a useful functionality but not the only
    one. `git-bisect` can be automated with a script that will run the tests and mark
    the commits as good or bad based on the test results. Note that the script should
    return `0` if the commit is good and `1` if the commit is bad. The script will
    run until the bug is found and the `bisect` session will be reset. For our repository,
    it will look as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，在提交之间跳转是一个有用的功能，但并非唯一的功能。可以使用脚本自动化`git-bisect`，该脚本将运行测试并根据测试结果将提交标记为良好或不良。请注意，如果提交良好，脚本应返回`0`；如果提交不良，则返回`1`。脚本将一直运行，直到找到错误并将`bisect`会话重置。对于我们的仓库，它将如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`git-bisect` is an indispensable debugging tool within the Git suite, offering
    a systematic and efficient approach to identifying bug-inducing commits. Its integration
    into the development workflow, combined with the practice of maintaining a clear
    commit history and employing automated tests, makes it a highly effective solution
    for maintaining code quality and stability.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`git-bisect`是Git套件中不可或缺的调试工具，提供了一种系统化和高效的识别导致错误提交的方法。将其集成到开发工作流程中，结合维护清晰的提交历史和采用自动化测试的实践，使其成为维护代码质量和稳定性的高度有效解决方案。'
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter dedicated to version control, we embarked on an insightful journey
    through the core principles and practices that underpin effective software version
    management. Central to our exploration was the adoption of conventional commits,
    a structured approach to commit messaging that enhances readability and facilitates
    automated processing of commit logs. This practice, grounded in a standardized
    format for commit messages, enables teams to convey the nature and intent of changes
    with clarity and precision.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于版本控制的探讨中，我们深入了解了支撑有效软件版本管理的基本原则和实践。我们探索的核心是采用传统提交，这是一种结构化的提交信息方法，它提高了可读性并促进了提交日志的自动化处理。这种基于提交信息标准化格式的实践，使团队能够清晰、精确地传达变更的性质和意图。
- en: We also delved into SemVer, a methodology designed to manage version numbers
    in a meaningful way. SemVer’s systematic approach to versioning, based on the
    significance of changes in the code base, provides clear guidelines on when and
    how version numbers should be incremented. This method offers a transparent framework
    for version control, ensuring compatibility and facilitating effective dependency
    management within and across projects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了SemVer，这是一种旨在以有意义的方式管理版本号的方法。基于代码库中变更的重要性，SemVer的系统化版本管理方法提供了关于何时以及如何递增版本号的明确指南。这种方法为版本控制提供了一个透明的框架，确保了项目内和项目间的兼容性，并促进了有效的依赖关系管理。
- en: The chapter further introduced change log creation tools, with a particular
    focus on git-cliff, a versatile tool that automates the generation of detailed
    and customizable change logs from Git history. These tools streamline the documentation
    process, ensuring that project stakeholders are well informed about the changes,
    features, and fixes introduced with each new version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了变更日志创建工具，特别关注git-cliff，这是一个多功能的工具，可以从Git历史中自动生成详细和可定制的变更日志。这些工具简化了文档过程，确保项目利益相关者充分了解每个新版本引入的变化、功能和修复。
- en: A significant portion of the chapter was dedicated to debugging techniques,
    highlighting the utility of `git-bisect` in the process of isolating bugs. `git-bisect`,
    through its binary search algorithm, enables developers to efficiently pinpoint
    the commit that introduced a bug, thereby significantly reducing the time and
    effort required for troubleshooting.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都致力于调试技术，突出了`git-bisect`在隔离错误过程中的实用性。通过其二分搜索算法，`git-bisect`使开发者能够高效地定位引入错误的提交，从而显著减少故障排除所需的时间和精力。
- en: In summary, this chapter provided a comprehensive overview of version control
    practices, emphasizing the importance of structured commit messages, strategic
    versioning, automated changelog generation, and efficient debugging techniques.
    By adopting these practices, development teams can enhance collaboration, maintain
    code base integrity, and ensure the delivery of high-quality software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章全面概述了版本控制实践，强调了结构化提交信息、策略性版本管理、自动生成变更日志和高效调试技术的重要性。通过采用这些实践，开发团队能够增强协作，维护代码库的完整性，并确保交付高质量的软件。
- en: 'In the next chapter, we will turn our attention to a critical aspect of the
    development process: code reviews. We will examine the importance of code reviews
    in ensuring code quality, fostering team collaboration, and enhancing overall
    productivity. By understanding best practices and effective strategies for conducting
    thorough and constructive code reviews, you will be well equipped to elevate the
    standards of your code base and contribute more effectively to your team’s success.
    Stay tuned as we embark on this insightful journey into the art and science of
    code reviews.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注开发过程中的一个关键方面：代码审查。我们将探讨代码审查在确保代码质量、促进团队协作和提升整体生产力方面的重要性。通过了解进行彻底和建设性代码审查的最佳实践和有效策略，你将充分准备好提升你的代码库标准，并更有效地为团队的成功做出贡献。敬请期待，我们将开始这段探索代码审查艺术与科学的精彩旅程。
