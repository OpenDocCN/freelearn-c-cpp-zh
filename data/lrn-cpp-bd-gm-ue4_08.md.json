["```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Avatar.generated.h\"\n\nUCLASS()\nclass GOLDENEGG_API AAvatar : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AAvatar();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n};\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AAvatar : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AAvatar();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    // New! These 2 new member function declarations \n    // they will be used to move our player around! \n    void MoveForward(float amount);\n    void MoveRight(float amount);\n\n}; \n```", "```cpp\n  check(PlayerInputComponent);\n    PlayerInputComponent->BindAxis(\"Forward\", this,\n        &AAvatar::MoveForward);\n    PlayerInputComponent->BindAxis(\"Strafe\", this, &AAvatar::MoveRight);\n```", "```cpp\nvoid AAvatar::MoveForward( float amount ) \n{ \n  // Don't enter the body of this function if Controller is \n  // not set up yet, or if the amount to move is equal to 0 \n  if( Controller && amount ) \n  { \n    FVector fwd = GetActorForwardVector(); \n    // we call AddMovementInput to actually move the \n    // player by `amount` in the `fwd` direction \n    AddMovementInput(fwd, amount); \n  } \n} \n\nvoid AAvatar::MoveRight( float amount ) \n{ \n  if( Controller && amount ) \n  { \n    FVector right = GetActorRightVector(); \n    AddMovementInput(right, amount); \n  } \n} \n```", "```cpp\nvoid AAvatar::MoveLeft( float amount ) \n{ \n  if( Controller && amount ) \n  { \n    FVector left = -GetActorRightVector(); \n    AddMovementInput(left, amount); \n  } \n} \nvoid AAvatar::MoveBack( float amount ) \n{ \n  if( Controller && amount ) \n  { \n    FVector back = -GetActorForwardVector(); \n    AddMovementInput(back, amount); \n  } \n} \n```", "```cpp\nvoid Yaw( float amount ); \nvoid Pitch( float amount ); \n```", "```cpp\nvoid AAvatar::Yaw(float amount)\n{\n    AddControllerYawInput(200.f * amount * GetWorld()->GetDeltaSeconds());\n}\nvoid AAvatar::Pitch(float amount)\n{\n    AddControllerPitchInput(200.f * amount * GetWorld()->GetDeltaSeconds());\n}\n```", "```cpp\nvoid AAvatar::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{ \n  // .. as before, plus: \n  PlayerInputComponent->BindAxis(\"Yaw\", this, &AAvatar::Yaw);\n  PlayerInputComponent->BindAxis(\"Pitch\", this, &AAvatar::Pitch); \n} \n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API ANPC : public ACharacter\n{\n    GENERATED_BODY()\n\n    // This is the NPC's message that he has to tell us. \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        NPCMessage)\n        FString NpcMessage;\n    // When you create a blueprint from this class, you want to be  \n    // able to edit that message in blueprints, \n    // that's why we have the EditAnywhere and BlueprintReadWrite  \n    // properties. \npublic:\n    // Sets default values for this character's properties\n    ANPC();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n};\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AMyHUD : public AHUD\n{\n    GENERATED_BODY()\npublic:\n    // The font used to render the text in the HUD. \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = HUDFont)\n    UFont* hudFont;\n    // Add this function to be able to draw to the HUD! \n    virtual void DrawHUD() override;\n};\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n    // call superclass DrawHUD() function first \n    Super::DrawHUD();\n    // then proceed to draw your stuff. \n    // we can draw lines.. \n    DrawLine(200, 300, 400, 500, FLinearColor::Blue);\n    // and we can draw text! \n    const FVector2D ViewportSize = FVector2D(GEngine->GameViewport->Viewport->GetSizeXY());\n    DrawText(\"Greetings from Unreal!\", FLinearColor::White, ViewportSize.X/2, ViewportSize.Y/2, hudFont);\n}\n```", "```cpp\n    const FVector2D ViewportSize = FVector2D(GEngine->GameViewport->Viewport->GetSizeXY());\n    const FString message(\"Greetings from Unreal!\");\n    float messageWidth = 0;\n    float messageHeight = 0;\n    GetTextSize(message, messageWidth, messageHeight, hudFont);\n    DrawText(message, FLinearColor::White, (ViewportSize.X - messageWidth) / 2, (ViewportSize.Y - messageHeight) / 2, hudFont);\n```", "```cpp\nstruct Message \n{ \n  FString message; \n  float time; \n  FColor color; \n  Message() \n  { \n    // Set the default time. \n    time = 5.f; \n    color = FColor::White; \n  } \n  Message( FString iMessage, float iTime, FColor iColor ) \n  { \n    message = iMessage; \n    time = iTime; \n    color = iColor; \n  } \n}; \n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AMyHUD : public AHUD\n{\n    GENERATED_BODY()\npublic:\n    // The font used to render the text in the HUD. \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = HUDFont)\n        UFont* hudFont;\n    // New! An array of messages for display \n    TArray<Message> messages;\n    virtual void DrawHUD() override;\n    // New! A function to be able to add a message to display \n    void addMessage(Message msg);\n};\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n    Super::DrawHUD();\n    // iterate from back to front thru the list, so if we remove \n    // an item while iterating, there won't be any problems \n    for (int c = messages.Num() - 1; c >= 0; c--)\n    {\n        // draw the background box the right size \n        // for the message \n        float outputWidth, outputHeight, pad = 10.f;\n        GetTextSize(messages[c].message, outputWidth, outputHeight,\n            hudFont, 1.f);\n\n        float messageH = outputHeight + 2.f*pad;\n        float x = 0.f, y = c * messageH;\n\n        // black backing \n        DrawRect(FLinearColor::Black, x, y, Canvas->SizeX, messageH\n        );\n        // draw our message using the hudFont \n        DrawText(messages[c].message, messages[c].color, x + pad, y +\n            pad, hudFont);\n\n        // reduce lifetime by the time that passed since last  \n        // frame. \n        messages[c].time -= GetWorld()->GetDeltaSeconds();\n\n        // if the message's time is up, remove it \n        if (messages[c].time < 0)\n        {\n            messages.RemoveAt(c);\n        }\n    }\n}\n\nvoid AMyHUD::addMessage(Message msg)\n{\n    messages.Add(msg);\n}\n```", "```cpp\nUCLASS() class GOLDENEGG_API ANPC : public ACharacter {\n    GENERATED_BODY()\n\npublic:\n    // The sphere that the player can collide with tob\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\n        Collision)\n        USphereComponent* ProxSphere;\n    // This is the NPC's message that he has to tell us. \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        NPCMessage)\n        FString NpcMessage; // The corresponding body of this function is \n                            // ANPC::Prox_Implementation, __not__ ANPC::Prox()! \n                            // This is a bit weird and not what you'd expect, \n                            // but it happens because this is a BlueprintNativeEvent \n    UFUNCTION(BlueprintNativeEvent, Category = \"Collision\")\n        void Prox(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n            int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n    // You shouldn't need this unless you get a compiler error that it can't find this function.\n    virtual int Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n        int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    // Sets default values for this character's properties\n    ANPC(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "```cpp\nANPC::ANPC(const FObjectInitializer& ObjectInitializer)\n : Super(ObjectInitializer)\n{\n ProxSphere = ObjectInitializer.CreateDefaultSubobject<USphereComponent>(this,\n TEXT(\"Proximity Sphere\"));\n ProxSphere->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n ProxSphere->SetSphereRadius(32.0f);\n // Code to make ANPC::Prox() run when this proximity sphere \n // overlaps another actor. \n ProxSphere->OnComponentBeginOverlap.AddDynamic(this, &ANPC::Prox);\n NpcMessage = \"Hi, I'm Owen\";//default message, can be edited \n // in blueprints \n}\n\n// Note! Although this was declared ANPC::Prox() in the header, \n// it is now ANPC::Prox_Implementation here. \nint ANPC::Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) \n{ \n    // This is where our code will go for what happens \n    // when there is an intersection \n    return 0;\n} \n```", "```cpp\nint ANPC::Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n    int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{ \n    // if the overlapped actor is not the player, \n    // you should just simply return from the function \n    if( Cast<AAvatar>( OtherActor ) == nullptr ) { \n        return -1; \n    } \n    APlayerController* PController = GetWorld()->GetFirstPlayerController(); \n    if( PController ) \n    { \n        AMyHUD * hud = Cast<AMyHUD>( PController->GetHUD() ); \n        hud->addMessage( Message( NpcMessage, 5.f, FColor::White ) ); \n    } \n    return 0;\n} \n```", "```cpp\n#include \"Avatar.h\"\n#include \"MyHud.h\"\n```", "```cpp\n// This is the NPC's name \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NPCMessage) \nFString name; \n```", "```cpp\nname + FString(\": \") + NpcMessage\n```", "```cpp\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NPCMessage) \nUTexture2D* Face; \n```", "```cpp\nUTexture2D* tex; \n```", "```cpp\nDrawTexture( messages[c].tex, x, y, messageH, messageH, 0, 0, 1, 1  \n   );\n```", "```cpp\nvoid AMyHUD::DrawHealthbar()\n{\n    // Draw the healthbar. \n    AAvatar *avatar = Cast<AAvatar>(\nb        UGameplayStatics::GetPlayerPawn(GetWorld(), 0));\n    float barWidth = 200, barHeight = 50, barPad = 12, barMargin = 50;\n    float percHp = avatar->Hp / avatar->MaxHp;\n    const FVector2D ViewportSize = FVector2D(GEngine->GameViewport->Viewport->GetSizeXY());\n    DrawRect(FLinearColor(0, 0, 0, 1), ViewportSize.X - barWidth -\n        barPad - barMargin, ViewportSize.Y - barHeight - barPad -\n        barMargin, barWidth + 2 * barPad, barHeight + 2 * barPad);  DrawRect(FLinearColor(1 - percHp, percHp, 0, 1), ViewportSize.X\n            - barWidth - barMargin, ViewportSize.Y - barHeight - barMargin,\n            barWidth*percHp, barHeight);\n}\n```", "```cpp\n#include \"Kismet/GameplayStatics.h\"\n#include \"Avatar.h\"\n```"]