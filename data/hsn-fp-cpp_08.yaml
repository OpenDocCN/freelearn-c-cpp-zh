- en: Thinking in Functions - from Data in to Data out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从输入数据到输出数据的函数思维
- en: In my journey toward understanding functional programming, I hit a difficult
    hurdle—my mind was trained in a completely different style of programming. Let's
    call it imperative object-oriented programming. So, how could I shift my thought
    patterns from thinking in objects to thinking in functions? And how could I mix
    these two in a good way?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我迈向理解函数式编程的旅程中，我遇到了一个困难的障碍——我的思维是在完全不同的编程风格中训练的。我们称之为命令式面向对象编程。那么，我如何将我的思维模式从对象思考转变为函数思考？我如何以一种良好的方式将这两者结合起来？
- en: I first looked into functional programming resources. Unfortunately, most of
    them are focused on the mathematics and the inner beauty of the concepts—which
    is great for anyone who can already think in these terms. But what if you're just
    trying to learn them? Is going through mathematical theories the only way to learn?
    While I like math, I'm rusty at it, and I'd rather find more practical ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先研究了函数式编程资源。不幸的是，其中大多数都集中在数学和概念的内在美上，这对于那些已经能够以这些术语思考的人来说是很好的。但是，如果你只是想学习它们呢？难道只能通过数学理论来学习吗？虽然我喜欢数学，但我已经生疏了，我宁愿找到更实际的方法。
- en: I've then been exposed to various ways of writing code through events such as
    Coderetreats, Coding Dojos, or pair programming with programmers from around Europe.
    And I realized, little by little, that there's a simple approach to fixing this
    problem—just focus on inputs and outputs instead of focusing on the model between
    them. That's a much more concrete and practical way to learn to think in functions,
    and this is what we'll explore next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经接触过各种编写代码的方式，比如Coderetreats、Coding Dojos，或者与来自欧洲各地的程序员进行配对编程。我逐渐意识到，解决这个问题的一个简单方法是专注于输入和输出，而不是专注于它们之间的模型。这是学习以函数思考的一个更具体和实际的方法，接下来我们将探讨这个问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of a functional mindset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数思维的基础。
- en: Relearning how to identify data in and data out for features and taking advantage
    of type inference
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新学习如何识别功能的输入和输出数据，并利用类型推断
- en: Defining data transformations as pure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换定义为纯函数
- en: How to use typical data transformations such as a map, reduce, filter, and more
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用典型的数据转换，比如map、reduce、filter等
- en: How to use the functional mindset to solve a problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用函数思维解决问题
- en: Designing error management for code designed around functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为围绕函数设计的代码设计错误管理
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个支持C++ 17的编译器。我使用的是GCC 7.3.0。
- en: The code can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp),
    in the `Chapter06` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在GitHub上找到[https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)，在`Chapter06`文件夹中。它包括并使用了`doctest`，这是一个单头开源单元测试库。您可以在其GitHub存储库上找到它[https://github.com/onqtam/doctest](https://github.com/onqtam/doctest)。
- en: From data in to data out through functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过函数从输入数据到输出数据
- en: My computer programming education, and my focus as a programmer, was mostly
    on writing code rather than deeply understanding input and output data. This focus
    changed when I learned **test-driven development** (**TDD**), since this practice
    forces the programmer to start from inputs and outputs. Through applying an extreme
    form called **TDD As If You Meant It**, I gained a new appreciation for the core
    definition of a program—something that takes input data and returns output data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计算机编程教育和作为程序员的重点大多是编写代码，而不是深入理解输入和输出数据。当我学习测试驱动开发（TDD）时，这种重点发生了变化，因为这种实践迫使程序员从输入和输出开始。通过应用一种称为“TDD
    As If You Meant It”的极端形式，我对程序的核心定义有了新的认识——接受输入数据并返回输出数据。
- en: 'It wasn''t easy, though. My training was pushing me back to thinking of the
    things that form the program. But then, I realized that those things can just
    be pure functions. After all, any program can be written as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不容易。我的训练使我重新思考构成程序的事物。但后来，我意识到这些事物只是纯函数。毕竟，任何程序都可以按照以下方式编写：
- en: A set of pure functions, as previously defined
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组纯函数，如前所定义
- en: A set of functions that interact with **input/output** (**I/O**)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组与输入/输出（I/O）交互的函数
- en: If we reduce the program to the minimum and separate everything that is I/O,
    figure out the I/O for the rest of the program, and write pure functions for everything
    we can, we've just made our first steps for thinking in functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将程序简化到最小，并将所有I/O分开，找出其余程序的I/O，并为我们能够的一切编写纯函数，我们刚刚迈出了以函数思考的第一步。
- en: 'The next question is—what should those functions be? In this chapter, we will
    look into the simplest way of designing with functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是——这些函数应该是什么？在本章中，我们将探讨最简单的使用函数进行设计的方法：
- en: Start from data in.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入数据开始。
- en: Define the data out.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义输出数据。
- en: Define a series of transformations (pure functions) that turn the data in into
    the data out step by step.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步定义一系列转换（纯函数），将输入数据转换为输出数据。
- en: Let's see a few examples contrasting the two approaches of writing the program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些对比两种编写程序的方法的例子。
- en: A worked example of imperative versus functional style
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式与函数式风格的工作示例
- en: To show the differences between approaches, we will need to use a problem. I
    like practicing new programming techniques using problems derived from games.
    On the one hand, it's a fun domain that I don't work with very often. On the other
    hand, games provide a lot of challenges that common business applications don't,
    thereby allowing us to explore new ideas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示不同的方法之间的差异，我们需要使用一个问题。我喜欢使用从游戏中衍生出的问题来练习新的编程技术。一方面，这是一个我不经常接触的有趣领域。另一方面，游戏提供了许多常见的商业应用所没有的挑战，从而使我们能够探索新的想法。
- en: In the following section, we will look at one problem that allows people to
    learn how to start thinking in functions—**the tic-tac-toe result ****problem**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看一个问题，让人们学会如何开始以函数的方式思考——**井字棋结果**问题。
- en: Tic-tac-toe result
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字棋结果
- en: The tic-tac-toe result problem has the following requirements—given a tic-tac-toe
    board that's either empty or already has moves, print out the result of the game,
    if the game has ended, or print out the game that is still in progress.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋结果问题有以下要求——给定一个可能为空的井字棋棋盘或已经有了棋子的棋盘，打印出游戏的结果，如果游戏已经结束，或者打印出仍在进行中的游戏。
- en: It looks as if the problem is fairly simple, yet it will show us a fundamental
    difference between the functional and imperative **object-oriented** (**OO**)
    approaches.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来问题似乎相当简单，但它将向我们展示功能和命令式**面向对象**（**OO**）方法之间的根本区别。
- en: If we approach the problem from an OO perspective, we're already considering
    some objects to define—a game, a player, a board, maybe some representation for
    `X` and `O` (which I call tokens), and so on. We might then be looking at how
    to connect these objects—a game has two players and a board, and the board has
    tokens or empty fields on it and so on. As you can see, there's a lot of representation
    involved. Then, we need to implement a `computeResult` method somewhere that returns `GameState`,
    either `XWon`, `OWon`, `draw`, or `InProgress`. At first glance, it looks as if
    `computeResult` fits into the `Game` class. That method will probably need to
    loop inside `Board`, use some conditional statements, and return the corresponding
    `GameState`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从面向对象的角度来解决问题，我们已经在考虑一些要定义的对象——一个游戏，一个玩家，一个棋盘，也许一些代表`X`和`O`的表示（我称之为标记），等等。然后，我们可能会考虑如何连接这些对象——一个游戏有两个玩家和一个棋盘，棋盘上有标记或空格等等。正如你所看到的，这涉及到很多表示。然后，我们需要在某个地方实现一个`computeResult`方法，返回`GameState`，要么是`XWon`，`OWon`，`draw`，要么是`InProgress`。乍一看，`computeResult`似乎适合于`Game`类。该方法可能需要在`Board`内部循环，使用一些条件语句，并返回相应的`GameState`。
- en: 'Instead of using the OO approach, we''ll use a few strict steps to help us
    think differently about the code structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些严格的步骤来帮助我们以不同的方式思考代码结构，而不是使用面向对象的方法：
- en: Clearly define the input; give examples.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清晰地定义输入；给出例子。
- en: Clearly define the output; give examples.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清晰地定义输出；给出例子。
- en: Identify a chain of functional transformations that you can apply to the input
    data to turn it into the output data.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别一系列功能转换，你可以将其应用于输入数据，将其转换为输出数据。
- en: Before we move on, please be aware that this mindset change requires a bit of
    knowledge and practice. We will look into the most common transformations to provide
    you with a good start, but you will need to try this method for yourself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请注意，这种心态的改变需要一些知识和实践。我们将研究最常见的转换，为您提供一个良好的开始，但您需要尝试这种方法。
- en: Inputs and outputs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出。
- en: The first lesson we learned as programmers is that any program has an input
    and an output. We then proceed to focus the rest of our careers on what happens
    between the input and the output, in the code itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为程序员学到的第一课是任何程序都有输入和输出。然后我们继续把我们的职业生涯的其余部分放在输入和输出之间发生的事情上，即代码本身。
- en: Input and output deserve more attention from programmers, though, because they
    define the requirements of our software. And we know that the biggest waste in
    software is to implement something that works perfectly but doesn't do what it
    was supposed to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，输入和输出值得程序员更多的关注，因为它们定义了我们软件的要求。我们知道，软件中最大的浪费是实现了完美的功能，但却没有完成它应该完成的任务。
- en: I've noticed that it's very difficult for programmers to go back to thinking
    in terms of input and output. The seemingly simple question of what the input
    and what the output for a given feature should be often leaves them baffled and
    confused. So, let's look in detail at the input and output data for our problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到程序员很难重新开始思考输入和输出。对于给定功能的输入和输出应该是什么的看似简单的问题经常让他们感到困惑和困惑。所以，让我们详细看看我们问题的输入和输出数据。
- en: At this point, we will do something unexpected. I've learned a neat trick from
    business analysts—it's best to start from the output when analyzing a feature
    because the output tends to be smaller and clearer than the input data. So, let's
    do that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将做一些意想不到的事情。我从业务分析师那里学到了一个很棒的技巧——在分析一个功能时最好从输出开始，因为输出往往比输入数据更小更清晰。所以，让我们这样做。
- en: What is the output data?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出数据是什么？
- en: 'What do we expect as outputs? Given that the board can have anything on it,
    or nothing at all, we are looking at the following possibilities:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望什么样的输出？鉴于棋盘上可以有任何东西，或者根本没有东西，我们正在考虑以下可能性：
- en: '*Game not started*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏未开始*'
- en: '*Game in progress*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏正在进行中*'
- en: '`X` won'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`赢了'
- en: '`O` won'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O`赢了'
- en: Draw
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平局
- en: See, the output is simple! Now, we can see how the input data relates with these
    possibilities.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看，输出很简单！现在，我们可以看到输入数据与这些可能性之间的关系。
- en: What is the input data?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入数据是什么？
- en: 'In this case, the input data is in the problem statement—our input is a board
    with moves on it. But let''s look at some examples. The simplest example is an
    empty board:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入数据在问题陈述中——我们的输入是一个有棋子的棋盘。但让我们看一些例子。最简单的例子是一个空棋盘：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For clarity, we use `_` to represent an empty space on the board.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们使用`_`来表示棋盘上的空格。
- en: The empty board corresponds, of course, to the *game not started* output.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，空白的棋盘对应于“游戏未开始”的输出。
- en: 'That''s simple enough. Now, let''s see one with a few moves on it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够简单了。现在，让我们看一个上面有几步的例子：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both `X` and `O` have made their moves, but the game is still in progress.
    There are many examples we can provide of *game in progress*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`X`和`O`都已经走了他们的步子，但游戏仍在进行中。我们可以提供许多*进行中的游戏*的例子：'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s another example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few examples that could never happen in a tic-tac-toe game, such
    as this one:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例子在井字棋游戏中永远不会发生，比如这个：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, `X` has made four moves, while `O` has made only one, which is
    something the tic-tac-toe rules wouldn't allow. We will ignore this situation
    for now and just return a *game in progress*. You can, however, implement your
    own algorithm for this once we finish the rest of the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`X`已经走了四步，而`O`只走了一步，这是井字棋规则不允许的。我们现在将忽略这种情况，只返回一个*进行中的游戏*。不过，一旦我们完成了代码的其余部分，你可以自己实现这个算法。
- en: 'Let''s see a game won by `X`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`X`赢得的游戏：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`X` wins because the first line is filled. Are there other ways in which `X`
    can win? Yes, on a column:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`X`赢了，因为第一行被填满了。`X`还有其他赢的方式吗？是的，在一列上：'
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It could also win on the main diagonal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以在主对角线上获胜：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s a win for `X` on the secondary diagonal:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`X`在次对角线上的胜利：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we have examples where `O` wins by filling a line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们有`O`通过填充一条线获胜的例子：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s a win by filling a column:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过填充一列获胜的情况：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s a win by the main diagonal for `O`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`O`在主对角线上的胜利：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here''s a win via the secondary diagonal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过次对角线获胜的情况：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'How about a game that ends in a draw? That''s easy—all the squares are filled
    but there''s no winner:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，怎么样才能结束成为平局呢？很简单——所有的方格都被填满了，但没有赢家：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've looked at examples for all possible outputs. Now, it's time to look at
    data transformations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了所有可能的输出的例子。现在是时候看看数据转换了。
- en: Data transformations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据转换
- en: How can we transform the input into the output? To do this, we'll have to pick
    one of the possible outputs to tackle first. The easiest one for now is the case
    when `X` wins. So, how can `X` win?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将输入转换为输出？为了做到这一点，我们将不得不选择一个可能的输出来先解决。现在最容易的是`X`获胜的情况。那么，`X`怎么赢？
- en: 'According to the rules of the game, `X` wins if either a line, a column, or
    a diagonal in the board is filled with `X`. Let''s write down all the possible
    cases. `X` wins if any of the following happen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据游戏规则，如果棋盘上的一条线、一列或一条对角线被`X`填满，`X`就赢了。让我们写下所有可能的情况。如果发生以下任何一种情况，`X`就赢了：
- en: Any line is filled with `X` OR
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一条线都被`X`填满了，或者
- en: Any column is filled with `X` OR
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一列都被`X`填满，或者
- en: The main diagonal is filled with `X` OR
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主对角线被`X`填满，或者
- en: The secondary diagonal is filled with `X`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次对角线被`X`填满了。
- en: 'To implement this, we need a few things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一些东西：
- en: Get all the lines from the board.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从棋盘上得到所有的线。
- en: Get all the columns from the board.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从棋盘上得到所有的列。
- en: Get the main and the secondary diagonal from the board.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从棋盘上得到主对角线和次对角线。
- en: If any of them are filled with `X`, `X` won!
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们中的任何一个被`X`填满了，`X`就赢了！
- en: 'We can write this in another way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用另一种方式来写这个：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What does `filledWithX` mean? Let''s take an example; we are looking for lines
    such as this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`filledWithX`是什么意思？让我们举个例子；我们正在寻找这样的线：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are not looking for lines such as `X O X` or `X _ X`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在寻找`X O X`或`X _ X`这样的线。
- en: 'It sounds like we are checking whether all the tokens on the line, column,
    or diagonal are `''X''`. Let''s visualize this check as a transformation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来我们正在检查一条线、一列或一条对角线上的所有标记是否都是`'X'`。让我们将这个检查视为一个转换：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, our set of transformations becomes this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的转换集合变成了这样：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One question remains—how can we get the lines, the columns, and the diagonals?
    We can look at this problem separately, in the same way we looked at the big problem.
    Our input is definitely the board. Our output is a list formed of first line,
    second line, and third line, first column, second column, and third column, main
    diagonal, and the secondary diagonal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题——我们如何得到线、列和对角线？我们可以分别看待这个问题，就像我们看待大问题一样。我们的输入肯定是棋盘。我们的输出是由第一行、第二行和第三行、第一列、第二列和第三列、主对角线和次对角线组成的列表。
- en: The next question is, what defines a line? Well, we know how to get the first
    line—we use the `[0, 0]`, `[0, 1]`, and `[0, 2]` coordinates. The second line
    has the `[1, 0]`, `[1, 1]`, and `[1, 2]` coordinates. What about a column? Well,
    the first column has the `[1, 0]`, `[1, 1]`, and `[2, 1]` coordinates. And, as
    we'll see, the diagonals are also defined by specific coordinate sets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是，什么定义了一条线？嗯，我们知道如何得到第一条线——我们使用`[0, 0]`，`[0, 1]`和`[0, 2]`坐标。第二条线有`[1, 0]`，`[1,
    1]`和`[1, 2]`坐标。列呢？嗯，第一列有`[1, 0]`，`[1, 1]`和`[2, 1]`坐标。而且，正如我们将看到的，对角线也是由特定的坐标集定义的。
- en: 'So, what did we learn? We learned that to get the lines, columns, and diagonals,
    we need the following transformation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们学到了什么？我们学到了为了得到线、列和对角线，我们需要以下的转换：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That concludes our analysis. It's time to move on to implementation. All the
    previous transformations can be expressed in code by using functional constructs.
    In fact, some of the transformations are so common that they're already implemented
    in the standard library. Let's see how we can use them!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的分析。现在是时候转向实现了。所有之前的转换都可以通过使用函数式构造来用代码表达。事实上，一些转换是如此常见，以至于它们已经在标准库中实现了。让我们看看我们如何可以使用它们！
- en: Using all_of for filledWithX
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`all_of`来判断是否被`X`填满
- en: 'The first transformation we''ll look at is `all_of`. Given a collection and
    a function that returns a Boolean (also called a **logical predicate**), `all_of`
    applies the predicate to every element of the collection and returns the logical
    AND between the results. Let''s see a few examples:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的第一个转换是`all_of`。给定一个集合和一个返回布尔值的函数（也称为**逻辑谓词**），`all_of`将谓词应用于集合的每个元素，并返回结果的逻辑与。让我们看一些例子：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `all_of` function takes two iterators defining the beginning and end of
    a range and a predicate as parameters. The iterators are useful when you want
    to apply the transformation to a subset of a collection. Since I usually use it
    on full collections, I find it annoying to write `collection.begin()` and `collection.end()`
    repeatedly. Thus, I implement my own simplified `all_of_collection` version that
    takes the whole collection and takes care of the rest:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`all_of`函数接受两个定义范围开始和结束的迭代器和一个谓词作为参数。当你想将转换应用于集合的子集时，迭代器是有用的。由于我通常在整个集合上使用它，我发现反复写`collection.begin()`和`collection.end()`很烦人。因此，我实现了自己简化的`all_of_collection`版本，它接受整个集合并处理其余部分：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Knowing this transformation, it''s easy to write our `lineFilledWithX` function—we
    turn the collection of tokens into a collection of Booleans specifying whether
    the token is `X`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这个转换后，编写我们的`lineFilledWithX`函数很容易-我们将标记的集合转换为指定标记是否为`X`的布尔值的集合：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And that's it! We can ascertain whether our line is filled with `X`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们可以确定我们的线是否填满了`X`。
- en: 'Before we move on, let''s make a few simple adjustments. First, let''s make
    the code clearer by naming our `vector<char>` type:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们做一些简单的调整。首先，通过为我们的`vector<char>`类型命名来使代码更清晰：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, let''s check that the code works fine for the negative scenarios as well.
    If `Line` is not filled with the `X` token, `lineFilledWithX` should return `false`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们检查代码是否对负面情况也能正常工作。如果`Line`没有填满`X`标记，`lineFilledWithX`应该返回`false`：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, an astute reader will notice that we will need the same function for
    the `O` wins condition. We now know how to do that—remember the power of argument
    binding. We just need to extract a `lineFilledWith` function and obtain the `lineFilledWithX`
    and `lineFilledWithO` functions by binding the `tokenToCheck` parameter to the `X` and
    `O` token values, respectively:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个敏锐的读者会注意到我们需要相同的函数来满足`O`获胜的条件。我们现在知道如何做到这一点-记住参数绑定的力量。我们只需要提取一个`lineFilledWith`函数，并通过将`tokenToCheck`参数绑定到`X`和`O`标记值，分别获得`lineFilledWithX`和`lineFilledWithO`函数：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's recap—we have a `Line` data structure, and we have a function that can
    check whether the line is filled with `X` or `O`. We used the `all_of` function
    to do the heavy lifting for us; we just had to define the logic of our tic-tac-toe
    line.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下-我们有一个`Line`数据结构，我们有一个可以检查该行是否填满`X`或`O`的函数。我们使用`all_of`函数来为我们做繁重的工作；我们只需要定义我们的井字棋线的逻辑。
- en: It's time to move forward. We need to turn our board into a collection of lines,
    formed out of the three lines, the three columns, and the two diagonals. To do
    so, we need to visit another functional transformation, `map`, which is implemented
    in **Standard Template Library** (**STL**) as the `transform` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候继续前进了。我们需要将我们的棋盘转换为线的集合，由三条线、三列和两条对角线组成。为此，我们需要使用另一个函数式转换`map`，它在STL中实现为`transform`函数。
- en: Using map/transform
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map/transform
- en: 'We now need to write a function that turns the board into a list of lines,
    columns, and diagonals; therefore, we could use a transformation that takes a
    collection and turns it into another collection. This transformation is called
    `map` in general functional programming, and is implemented as `transform` in
    STL. To understand it, we will use a simple example; given a vector of characters,
    let''s replace each character with `''a''`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写一个将棋盘转换为线、列和对角线列表的函数；因此，我们可以使用一个将集合转换为另一个集合的转换。这种转换通常在函数式编程中称为`map`，在STL中实现为`transform`。为了理解它，我们将使用一个简单的例子；给定一个字符向量，让我们用`'a'`替换每个字符：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While it works, the previous code sample is naive because it initializes the
    `aaa` vector with values that are overwritten afterward. We can avoid this issue
    by first reserving `3` elements in the `aaa` vector, and then use `back_inserter`
    so that `transform` automatically calls `push_back` on the `aaa` vector:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它有效，但前面的代码示例是天真的，因为它用稍后被覆盖的值初始化了`aaa`向量。我们可以通过首先在`aaa`向量中保留`3`个元素，然后使用`back_inserter`来避免这个问题，这样`transform`就会自动在`aaa`向量上调用`push_back`：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, `transform` is based on iterators in the same way `all_of` works.
    By now, you will have noticed that I like to keep things simple and focused on
    what we are trying to accomplish. There is no need to write this all the time;
    instead, we can implement our own simplified version that works on a full collection
    and takes care of all the rituals surrounding this function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`transform`基于迭代器，就像`all_of`一样。到目前为止，你可能已经注意到我喜欢保持事情简单，专注于我们要完成的任务。没有必要一直写这些；相反，我们可以实现我们自己的简化版本，它可以在整个集合上工作，并处理围绕此函数的所有仪式。
- en: Simplifying transform
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化转换
- en: 'Let''s try to implement the `transform_all` function in the simplest way possible:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以最简单的方式实现`transform_all`函数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unfortunately, we hit a snag when we try to implement it in this way—we need
    a type for the destination collection. The natural way of doing this is to use
    C++ templates and pass in the `Destination` type parameter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们尝试以这种方式实现它时，我们需要一个目标集合的类型。这样做的自然方式是使用C++模板并传递`Destination`类型参数：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This works fine for any collection that has a `push_back` function. A nice
    side effect is that we can use it to concatenate the resulting characters in `string`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于任何具有`push_back`函数的集合都有效。一个很好的副作用是，我们可以用它来连接`string`中的结果字符：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using `transform_all` with `string` allows us to do things such as turning
    lowercase characters into uppercase characters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`transform_all`与`string`允许我们做一些事情，比如将小写字符转换为大写字符：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But that''s not all—the output type doesn''t necessarily have to be the same
    as the input:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部-输出类型不一定要与输入相同：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `transform` function is therefore very useful whenever we need to transform
    a collection into another, be it the same type or different types. With the support
    of `back_inserter`, it can also be used for `string` outputs, thereby enabling
    the implementation of string representations for any type of collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`transform`函数在我们需要将一个集合转换为另一个集合时非常有用，无论是相同类型还是不同类型。在`back_inserter`的支持下，它还可以用于`string`输出，从而实现对任何类型集合的字符串表示的实现。
- en: We now know how to use transform. So, let's go back to our problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何使用transform了。所以，让我们回到我们的问题。
- en: Our coordinates
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的坐标
- en: 'Our transformation starts by computing coordinates. So, let''s define them
    first. The STL `pair` type is a simple representation for coordinates:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的转换从计算坐标开始。因此，让我们首先定义它们。STL `pair`类型是坐标的简单表示：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Getting a line from board and coordinates
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从板和坐标获取一条线
- en: 'Assuming we built the list of coordinates for a line, column, or diagonal,
    we need to transform the collection of tokens into the `Line` parameter. That''s
    easily done with our `transformAll` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经为一条线、一列或一条对角线构建了坐标列表，我们需要将令牌的集合转换为`Line`参数。这很容易通过我们的`transformAll`函数完成：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `projectCoordinates` lambda takes the board and a list of coordinates, and
    returns the list of elements from the board that corresponds to those coordinates.
    We use `transformAll` on the coordinates list, and a transformation that takes
    two parameters—the `board` parameter and a `coordinate` parameter. However, `transformAll`
    requires a lambda with a single parameter, a `Coordinate` value. Therefore, we
    have to either capture the value of the board or use partial application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`projectCoordinates` lambda接受板和坐标列表，并返回与这些坐标对应的板元素列表。我们在坐标列表上使用`transformAll`，并使用一个接受两个参数的转换——`board`参数和`coordinate`参数。然而，`transformAll`需要一个带有单个参数的lambda，即`Coordinate`值。因此，我们必须要么捕获板的值，要么使用部分应用。'
- en: We now just have to build our list of coordinates for lines, columns, and diagonals!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要构建我们的线、列和对角线的坐标列表了！
- en: Getting a line from the board
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从板上得到一条线
- en: 'We can easily get a line from the board by using the previous function, `projectCoordinates`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用前一个函数`projectCoordinates`轻松地从板上得到一条线：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `line` lambda takes `board` and `lineIndex`, builds the line coordinates
    list, and uses `projectCoordinates` to return the line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`line` lambda接受`board`和`lineIndex`，构建线坐标列表，并使用`projectCoordinates`返回线。'
- en: 'So, how do we build the line coordinates? Well, since we have `lineIndex` and `Coordinate` as
    a pair, we need to call `make_pair` on `(lineIndex, 0)`, on `(lineIndex, 1)`,
    and on `(lineIndex, 2)`. This looks like a `transform` call as well; the input
    is a `{0, 1, 2}` collection, and the transformation is `make_pair(lineIndex, index)`.
    Let''s write it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何构建线坐标？嗯，由于我们有`lineIndex`和`Coordinate`作为一对，我们需要在`(lineIndex, 0)`、`(lineIndex,
    1)`和`(lineIndex, 2)`上调用`make_pair`。这看起来也像是一个`transform`调用；输入是一个`{0, 1, 2}`集合，转换是`make_pair(lineIndex,
    index)`。让我们写一下：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Ranges
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'But what is `{0, 1, 2}`? In other programming languages, we could use the concept
    of ranges; for example, in Groovy, we could write the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`{0, 1, 2}`是什么？在其他编程语言中，我们可以使用范围的概念；例如，在Groovy中，我们可以编写以下内容：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ranges are very useful, and they were adopted in the C++ 20 standard. We will
    discuss them in [Chapter 14](1edd5963-94e4-48dc-830f-8f201b3a39c7.xhtml), *Lazy
    Evaluation Using the Ranges Library*. Until then, we will write our own function, `toRange`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 范围非常有用，并且已经在C++ 20标准中被采用。我们将在[第14章](1edd5963-94e4-48dc-830f-8f201b3a39c7.xhtml)中讨论它们，*使用Ranges库进行惰性求值*。在那之前，我们将编写我们自己的`toRange`函数：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`toRange` takes a collection as input and creates `range` from `0` to `collection.size()`.
    So, let''s use it in our code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`toRange`接受一个集合作为输入，并从`0`到`collection.size()`创建`range`。因此，让我们在我们的代码中使用它：'
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have all the elements in place, so it's time to look at the columns.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经把所有元素都放在了正确的位置，所以现在是时候看看列了。
- en: Getting the columns
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取列
- en: 'The code for getting a column is very similar to the one for a line, except
    that we keep `columnIndex` instead of `lineIndex`. We just need to pass it as
    a parameter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列的代码与获取线的代码非常相似，只是我们保留`columnIndex`而不是`lineIndex`。我们只需要将其作为参数传递：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Isn't this cool? With a few functions, and the help of standard functional transformations,
    we can build complex behavior in our code. The diagonals are a breeze now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很酷吗？通过几个函数和标准的函数变换，我们可以在我们的代码中构建复杂的行为。现在对角线变得轻而易举了。
- en: Getting the diagonals
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对角线
- en: 'The main diagonal is defined by equal line and column coordinates. It''s pretty
    easy to use the same mechanic as before to read it; we build the pairs of equal
    indices and pass them to the `projectCoordinates` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 主对角线由相等的行和列坐标定义。使用与之前相同的机制读取它非常容易；我们构建相等索引的对，并将它们传递给`projectCoordinates`函数：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What about the secondary diagonal? Well, the sum of coordinates is always equal
    to the size of the `board` parameter. In C++, we also need to take into account
    the 0-based index, so we need a well-placed adjustment by `1` when building the
    list of coordinates:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对于次对角线呢？嗯，坐标的总和总是等于`board`参数的大小。在C++中，我们还需要考虑基于0的索引，因此在构建坐标列表时，我们需要通过`1`进行适当的调整：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Getting all lines, all columns, and all diagonals
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有线、所有列和所有对角线
- en: 'With this being said, we can now build a collection of all lines, columns, and
    diagonals. There are multiple ways to do that; since I''m going for a general
    solution written in functional style, I will use `transform` again. We need to
    transform the `(0..board.size())` range into the list of lines and the list of
    columns respectively. Then, we need to return a collection containing the main
    and secondary diagonals:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我们现在可以构建所有线、列和对角线的集合了。有多种方法可以做到这一点；因为我要写一个以函数式风格编写的通用解决方案，我将再次使用`transform`。我们需要将`(0..board.size())`范围转换为相应的线列表和列列表。然后，我们需要返回一个包含主对角线和次对角线的集合：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We just need one more thing—a way to concatenate the three collections. Since
    the vector doesn''t have this implemented, the recommended solution is to use
    `insert` and `move_iterator`, thus moving the items from the second collection
    at the end of the first collection:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一件事情——一种连接这三个集合的方法。由于向量没有实现这个功能，推荐的解决方案是使用`insert`和`move_iterator`，从而将第二个集合的项目移动到第一个集合的末尾：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we just combine the three collections into two steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需将这三个集合合并为两个步骤：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now get the full list of lines, columns, and diagonals from the board,
    as you can see in the following tests:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从棋盘中获取所有行、列和对角线的完整列表，就像你在下面的测试中看到的那样：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's only one more step left in finding out whether `X` has won. We have
    the list of all lines, columns, and diagonals. We know how to check that a line
    is filled with `X`. We just need to check whether any of the lines from the list
    are filled with `X`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在找出`X`是否获胜的最后一步中只剩下一个任务。我们有所有行、列和对角线的列表。我们知道如何检查一行是否被`X`填满。我们只需要检查列表中的任何一行是否被`X`填满。
- en: Using any_of to check whether X has won
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用any_of来检查X是否获胜
- en: 'Similar to `all_of`, another functional construct helps us to express an OR
    condition between predicates applied on a collection. In STL, this construct is
    implemented in the `any_of` function. Let''s see it in action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`all_of`，另一个函数构造帮助我们在集合上应用的谓词之间表达OR条件。在STL中，这个构造是在`any_of`函数中实现的。让我们看看它的作用：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Like the other higher-level functions we saw in this chapter, it uses iterators
    for the beginning and the end of the collection. As usual, I like to keep things
    simple; since I typically use `any_of` on full collections, I like to implement
    my helper function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们在本章中看到的其他高级函数一样，它使用迭代器作为集合的开始和结束。像往常一样，我喜欢保持简单；因为我通常在完整集合上使用`any_of`，我喜欢实现我的辅助函数：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We just need to use it on our list to check whether `X` is the winner:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在我们的列表上使用它来检查`X`是否是赢家：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This concludes our solution for the winning condition for `X`. Before we move
    on, it would be nice to be able to display the board on the console. It's now
    time to use the close cousin of `map`/`transform`—`reduce`, or, as it's known
    in STL, `accumulate`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`X`获胜条件的解决方案。在我们继续之前，能够在控制台上显示棋盘将是很好的。现在是使用`map`/`transform`的近亲——`reduce`的时候了，或者在STL中被称为`accumulate`。
- en: Using reduce/accumulate to display the board
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reduce/accumulate来显示棋盘
- en: 'We would like to display the board on the console. Normally, we would use a
    mutable function such as `cout` to do that; however, remember how we discussed
    that while we need to keep parts of our program mutable, such as those calling
    `cout`, we should limit them to a minimum. So, what would the alternative be?
    Well, we need to think about inputs and outputs once again—we want to write a
    function that takes `board` as input and returns a `string` representation that
    we can display by using a mutable function such as `cout`. Let''s write what we
    want in the form of a test:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在控制台上显示棋盘。通常，我们会使用可变函数，比如`cout`来做到这一点；然而，记住我们讨论过，虽然我们需要保持程序的某些部分可变，比如调用`cout`的部分，但我们应该将它们限制在最小范围内。那么，替代方案是什么呢？嗯，我们需要再次考虑输入和输出——我们想要编写一个以`board`作为输入并返回`string`表示的函数，我们可以通过使用可变函数，比如`cout`来显示它。让我们以测试的形式写出我们想要的：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To obtain this result, we first need to transform each line from `board` into
    its `string` representation. Our line is `vector<char>` and we need to turn it
    into `string`; while there are many ways of doing this, please allow me to use
    the `transformAll` function with a `string` output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这个结果，我们首先需要将`board`中的每一行转换为它的`string`表示。我们的行是`vector<char>`，我们需要将它转换为`string`；虽然有很多方法可以做到这一点，但请允许我使用带有`string`输出的`transformAll`函数：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this function written, we can easily turn a board into `vector<string>`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，我们可以轻松地将一个棋盘转换为`vector<string>`：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The final step is to combine these strings with `\n` between them. We often
    need to combine elements of a collection in various ways; that's where `reduce`
    comes into play. In functional programming, `reduce` is an operation that takes
    a collection, an initial value (for example, empty `strings`), and an accumulation
    function. The function takes two parameters, performs an operation on them, and
    returns a new value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是用`\n`将这些字符串组合起来。我们经常需要以各种方式组合集合的元素；这就是`reduce`发挥作用的地方。在函数式编程中，`reduce`是一个接受集合、初始值（例如，空的`strings`）和累积函数的操作。该函数接受两个参数，对它们执行操作，并返回一个新值。
- en: 'Let''s see a few examples. First, there''s the classic example of adding a
    vector of numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子。首先是添加一个数字向量的经典例子：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following shows us what to do if we need to add the vector with an initial
    value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下向我们展示了如果需要添加具有初始值的向量应该怎么做：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Similarly, we can concatenate `strings`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以连接`strings`：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Alternatively, we can add a prefix:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以添加一个前缀：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As usual, I prefer a simplified implementation that works on a full collection
    and uses a default value as an initial value. With a bit of `decltype` magic,
    it''s easy to implement it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们在整个集合上使用默认值作为初始值的简化实现一样，我更喜欢使用`decltype`魔术来实现它：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This just leaves us with one task—writing an implementation of concatenate
    that combines the `string` lines using a newline character:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这只留下了我们的最后一个任务——编写一个连接`string`行的实现，使用换行符：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can now use `cout << boardToString` to display our board. Once again, we
    used a few functional transformations and very little custom code to put everything
    together. That's quite nice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`cout << boardToString`来显示我们的棋盘。再次，我们使用了一些函数变换和非常少的自定义代码来将一切整合在一起。这非常好。
- en: The `map`/`reduce` combination, or, as it's known in STL, `transform`/`accumulate`,
    is very powerful and very common in functional programming. We often need to start
    from a collection, transform it into another collection multiple times, and then
    combine the elements of the collection. It's such a powerful concept that it's
    at the heart of big data analysis, using tools such as Apache Hadoop, albeit scaled
    at the level of machines. This shows that by mastering these transformations,
    you might end up applying them in unexpected situations, making you an indispensable
    problem solver. Cool, isn't it?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`/`reduce`组合，或者在STL中被称为`transform`/`accumulate`，是功能性编程中非常强大且非常常见的。我们经常需要从一个集合开始，多次将其转换为另一个集合，然后再组合集合的元素。这是一个如此强大的概念，以至于它是大数据分析的核心，使用诸如Apache
    Hadoop之类的工具，尽管在机器级别上进行了扩展。这表明，通过掌握这些转换，您可能最终会在意想不到的情况下应用它们，使自己成为一个不可或缺的问题解决者。很酷，不是吗？'
- en: Using find_if to display specific win details
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`find_if`来显示特定的赢的细节
- en: We are happy now that we have solved the tic-tac-toe result problem for `X`.
    However, as always, requirements change; we need now to not only say whether `X`
    won, but also how—on which line, or column, or diagonal.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在很高兴，因为我们已经解决了`X`的井字游戏结果问题。然而，正如总是一样，需求会发生变化；我们现在不仅需要说`X`是否赢了，还需要说赢了在哪里——在哪一行、或列、或对角线。
- en: 'Fortunately, we already have most of the elements in place. Since they are
    very small functions, we just need to recombine them in a way that helps us. Let''s
    think again in terms of data—our input data is now a collection of lines, columns,
    and diagonals; our result should be something such as `X` won *on first line*.
    We just need to enhance our data structure to contain information about each line;
    let''s use `map`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有了大部分元素。由于它们都是非常小的函数，我们只需要以一种有助于我们的方式重新组合它们。让我们再次从数据的角度思考——我们的输入数据现在是一组行、列和对角线；我们的结果应该是类似于`X`赢*在第一行*的信息。我们只需要增强我们的数据结构，以包含有关每行的信息；让我们使用`map`：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We know how to find out where `X` won—through our `lineFilledWithX` predicate
    function. Now, we just need to search in the map for the line that fits the `lineFilledWithX`
    predicate and return the corresponding message.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何找出`X`是如何赢的——通过我们的`lineFilledWithX`谓词函数。现在，我们只需要在地图中搜索符合`lineFilledWithX`谓词的行，并返回相应的消息。
- en: 'Once again, this is a common operation in functional programming. In STL, it''s
    implemented with the `find_if` function. Let''s see it in action:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是功能性编程中的一个常见操作。在STL中，它是用`find_if`函数实现的。让我们看看它的运行情况：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`find_if` looks in a collection based on a predicate and returns a pointer
    to the result, or a pointer to the `end()` iterator if nothing is found.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_if`根据谓词在集合中查找并返回结果的指针，如果找不到任何内容，则返回指向`end()`迭代器的指针。'
- en: 'As usual, let''s do our wrapper implementation that allows a search in a whole
    collection. We need to represent the `not found` value in a way; fortunately,
    we can use the optional type from STL:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们实现一个允许在整个集合中搜索的包装器。我们需要以某种方式表示`not found`的值；幸运的是，我们可以使用STL中的可选类型：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can easily implement the new requirement. We can find the line that
    is filled with `X` by using our newly implemented `findInCollection` function
    and return the corresponding description. We can therefore tell the user how `X`
    won—on a line, on a column, or on a diagonal:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松实现新的要求。我们可以使用我们新实现的`findInCollection`函数找到被`X`填满的行，并返回相应的描述。因此，我们可以告诉用户`X`是如何赢的——是在一行、一列还是对角线上：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We should, of course, generate the map from the board instead of hardcoding
    it. I will leave this exercise to the reader; just use our favorite `transform`
    function again.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该从棋盘生成地图，而不是硬编码。我将把这个练习留给读者；只需再次使用我们最喜欢的`transform`函数即可。
- en: Completing our solution
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的解决方案
- en: While we have implemented the solution for `X` wins, we now need to look into
    the other possible outputs. Let's take the easiest one first—`O` wins.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经为`X`赢实现了解决方案，但现在我们需要研究其他可能的输出。让我们先来看最简单的一个——`O`赢。
- en: Checking whether O has won
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查`O`是否赢了
- en: 'Checking whether `O` has won is easy—we just need a small change in our functions.
    We need a new function, `oWins`, that checks whether any line, column, or diagonal
    is filled with the `O` token:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`O`是否赢很容易——我们只需要在我们的函数中做一个小改变。我们需要一个新函数`oWins`，它检查任何一行、一列或对角线是否被`O`填满：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We use the same implementation as for `xWins`, with just a slight change in
    the lambda that is passed as the parameter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与`xWins`相同的实现，只是在作为参数传递的lambda中稍作修改。
- en: Checking for draw using none_of
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`none_of`检查平局
- en: 'What about `draw`? Well, a draw happens when the `board` parameter is full
    and neither `X` nor `O` has won:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`平局`呢？嗯，当`board`参数已满且既没有`X`也没有`O`赢时，就会出现平局：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What does a full board mean? It means that every line is full:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 满棋盘意味着每一行都已满：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And how do we know whether the line is full? Well, we know that if none of
    the tokens from the line are the empty (`'' ''`) token, the line is full. As you
    probably expect by now, there is a function in STL called `none_of` that can check
    this for us:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何知道一行是否已满？嗯，我们知道如果行中的任何一个标记都不是空（`' '`）标记，那么该行就是满的。正如您现在可能期望的那样，STL中有一个名为`none_of`的函数，可以为我们检查这一点：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Checking for game in progress
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查游戏是否正在进行中
- en: 'The final case is when the game is still in progress. The simplest way is just
    to check that the game was not won and the board is not full yet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是游戏仍在进行中。最简单的方法就是检查游戏是否没有赢，且棋盘还没有满：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Congratulations, we've done it! We've implemented the tic-tac-toe result problem
    using a number of functional transformations; a few lambdas of our own. But, more
    importantly, we've learned how to start thinking as a functional programmer—clearly
    defining the input data, clearly defining the output data, and figuring out the
    transformations that can turn the input data into the required output data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们做到了！我们使用了许多功能转换来实现了井字游戏结果问题；还有我们自己的一些lambda。但更重要的是，我们学会了如何开始像一个功能性程序员一样思考——清晰地定义输入数据，清晰地定义输出数据，并找出可以将输入数据转换为所需输出数据的转换。
- en: Error management using optional types
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可选类型进行错误管理
- en: By now, we have a small program written in functional style. But what about
    the error cases? How do we deal with them?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经用函数式风格编写了一个小程序。但是错误情况怎么处理呢？
- en: It's obvious that we can still use the C++ mechanisms—return values or exceptions.
    But functional programming also looks at another way—treating errors as data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们仍然可以使用C++机制——返回值或异常。但是函数式编程还可以看作另一种方式——将错误视为数据。
- en: 'We already saw an example of this technique when we implemented our `find_if`
    wrapper:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实现`find_if`包装器时已经看到了这种技术的一个例子：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Instead of throwing an exception or returning `collection.end()`, which is a
    local value, we used the `optional` type. As stated in its name, the optional
    type represents a variable that may, or may not, have a value. An optional value
    can be initialized, either with a value supported by the underlying type, or with
    `nullopt`—a default non-value, so to speak.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`optional`类型，而不是抛出异常或返回`collection.end()`，这是一个本地值。如其名称所示，optional类型表示一个可能有值，也可能没有值的变量。可选值可以被初始化，可以使用底层类型支持的值，也可以使用`nullopt`——一个默认的非值，可以这么说。
- en: 'When encountering an optional value in our code, we need to take it into account,
    as we did in the function checking how `X` won:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当在我们的代码中遇到可选值时，我们需要考虑它，就像我们在检查`X`赢得函数中所做的那样：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Therefore, the *not found* condition is not an error; instead, it''s a normal
    part of our code and of our data. Indeed, another way of dealing with this condition
    is to enhance `findInCollection` to return a specified value when nothing is found:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“未找到”条件不是错误；相反，它是我们代码和数据的正常部分。事实上，处理这种情况的另一种方法是增强`findInCollection`，在未找到时返回指定的值：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now use `findInCollectionWithDefault` to obtain an `X did not win` message when
    we call `howDidXWin` on a board where `X` did not win:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`findInCollectionWithDefault`来在`X`没有赢得情况下调用`howDidXWin`时获得一个`X没有赢`的消息：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: My best advice is this—use exceptions for all exceptional situations, and make
    everything else part of your data structures. Use optional types, or transformations
    with default values. You'll be surprised by how easy and natural error management
    becomes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我最好的建议是这样——对所有异常情况使用异常，并将其他所有情况作为数据结构的一部分。使用可选类型，或者带有默认值的转换。你会惊讶于错误管理变得多么容易和自然。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot of ground in this chapter! We went through a journey of
    discovery—we started by listing the outputs and corresponding inputs for our problem,
    decomposed them, and figured out how to transform the inputs in the requisite
    outputs. We saw how small functions and the functional operations give us agility
    when new features are requested. We saw how to use `any`, `all`, `none`, `find_if`,
    `map`/`transform`, and `reduce`/`accumulate`, and how to use optional types or
    default values to support all possible cases in our code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容！我们经历了一次发现之旅——我们首先列出了问题的输出和相应的输入，对它们进行了分解，并找出了如何将输入转换为所需的输出。我们看到了当需要新功能时，小函数和函数操作如何给我们带来灵活性。我们看到了如何使用`any`、`all`、`none`、`find_if`、`map`/`transform`和`reduce`/`accumulate`，以及如何使用可选类型或默认值来支持代码中的所有可能情况。
- en: Now that we have an idea of how to write code in functional style, it's time
    to see how this approach fits with OO programming in the next chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何以函数式风格编写代码，是时候在下一章中看看这种方法如何与面向对象编程结合了。
