- en: Creating a Graphical User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形用户界面
- en: In games, user interaction is an extremely important part of the design. Being
    able to provide the user with visual information and a visual selection of choices
    is where the **Graphical User Interface** (**GUI**) comes in. Like many other
    systems discussed in this book, there are existing libraries available for use.
    One of the most commonly known in the open source game development world is **Crazy
    Eddies GUI** (**CEGUI**). While CEGUI is a very robust GUI system implementation,
    with that robustness comes complexity, and to be honest, most of the time you
    will really just need a text label, a simple button, and maybe a checkbox and
    icon support. With these simple building blocks, you can create a lot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，用户交互是设计中非常重要的一部分。能够为用户提供视觉信息和视觉选择的能力是**图形用户界面**（**GUI**）的作用所在。与本书中讨论的许多其他系统一样，已经有现成的库可供使用。在开源游戏开发世界中最常见的一个是**Crazy
    Eddies GUI**（**CEGUI**）。虽然CEGUI是一个非常强大的GUI系统实现，但随着这种强大性而来的是复杂性，老实说，大多数时候你真的只需要一个文本标签、一个简单的按钮，也许还有一个复选框和图标支持。有了这些简单的构建模块，你就可以创建很多东西。
- en: 'In this chapter, we will construct the building blocks and create a simple
    GUI system. It should be noted that creating a complete, production-ready GUI
    system from scratch is an enormous task, not one for a single chapter. So, we
    will focus on the core concepts and build a system that can be extended and scaled
    later on. Our GUI will not use any API specifics and will continue to build off
    of the created structure from previous chapters. The topics covered in this chapter
    are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建基本组件并创建一个简单的GUI系统。需要注意的是，从头开始创建一个完整的、可生产的GUI系统是一项艰巨的任务，不是一个单独的章节可以完成的。因此，我们将专注于核心概念，并构建一个可以在以后扩展和扩展的系统。我们的GUI将不使用任何API特定内容，并将继续构建前几章创建的结构。本章涉及的主题如下：
- en: Coordinate systems and positioning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标系统和定位
- en: Adding control logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加控制逻辑
- en: Rendering the GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染GUI
- en: The complete code example for this chapter can be found in the `Chapter06` folder
    in the code repository. For brevity's sake, I will be omitting some of the non-essential
    lines of code from the sections and may jump around files and classes more frequently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码示例可以在代码存储库的`Chapter06`文件夹中找到。为了简洁起见，我将省略一些非必要的代码行，并可能更频繁地跳转文件和类。
- en: Coordinate systems and positioning
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系统和定位
- en: One of the most important parts of every GUI system is how objects/elements
    are positioned on the screen. For the most part, graphics APIs use coordinates
    known as screen space, usually expressed in an absolute range [-1, 1]. While this
    is good for rendering, this can cause some issues when trying to develop our GUI
    system. Let's take, for example, the idea of using an absolute system. In this
    system, we would explicitly set each element in the GUI to a real pixel coordinate.
    This could be very simple to implement, but would only work if the game's resolution
    stayed the same. If at any time we changed the resolution, the elements would
    stay locked to their pixel coordinates and would not scale to match the new resolution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GUI系统中最重要的部分之一是对象/元素在屏幕上的位置。在大多数情况下，图形API使用称为屏幕空间的坐标，通常表示为绝对范围[-1,1]。虽然这对于渲染是很好的，但在尝试开发我们的GUI系统时可能会引起一些问题。例如，让我们以使用绝对系统的想法为例。在这个系统中，我们将明确地将GUI中的每个元素设置为真实的像素坐标。这可能很容易实现，但只有在游戏的分辨率保持不变的情况下才能工作。如果我们在任何时候改变分辨率，元素将保持锁定在其像素坐标上，并且不会按比例缩放以匹配新的分辨率。
- en: Another option would be to create a relative system, where each GUI element's
    position would be described in relation to other elements or screen locations.
    This approach is much better than an absolute system but still poses some scaling
    issues. For example, if we had an element that we placed at the top left of the
    screen, with a small offset, if at any time the game's resolution changed, the
    spacing that we used would change as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个相对系统，其中每个GUI元素的位置都是相对于其他元素或屏幕位置描述的。这种方法比绝对系统好得多，但仍然存在一些缩放问题。例如，如果我们在屏幕的左上角放置了一个带有小偏移的元素，如果游戏的分辨率在任何时候发生了变化，我们使用的间距也会发生变化。
- en: 'What we are going to build is a somewhat similar approach employed by CEGUI,
    which is a combination of the two solutions mentioned previously. While we are
    at it, we are also going to add another common convention used in modern GUIs:
    containing grouped elements in *panels*. There are a couple of good reasons why
    we want to group our GUI elements in panels. The first is that if we wanted to
    move a bunch of elements, say a status bar with health, ammo, and items indicators,
    if we group them in a panel, we only have to move the panel and all the elements
    will follow, correctly positioned. Which brings us to reason two: by grouping
    elements together in panels, we can define the position of the elements relative
    to the panel''s position, as opposed to setting the elements positions as pixel
    coordinates or even relative to a screen location.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的是CEGUI所采用的一种类似方法，这是前面提到的两种解决方案的结合。与此同时，我们还将添加现代GUI中使用的另一个常见约定：将组合的元素包含在*面板*中。我们希望将GUI元素分组在面板中有几个很好的理由。首先，如果我们想移动一堆元素，比如一个带有健康、弹药和物品指示器的状态栏，如果我们将它们分组在一个面板中，我们只需要移动面板，所有元素都会正确地跟随移动。这就引出了第二个原因：通过在面板中将元素分组在一起，我们可以定义元素相对于面板位置的位置，而不是将元素位置设置为像素坐标或相对于屏幕位置。
- en: 'The following is a diagram depicting this design layout:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述此设计布局的图表：
- en: '![](img/00836859-220f-4875-a4cd-a99dcc87cd00.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00836859-220f-4875-a4cd-a99dcc87cd00.png)'
- en: As you can see, a combination of relative and absolute positioning is used,
    but this time the relative starting point is not the origin **[0,0]** of the entire
    screen, but the origin **[0,0]** of our panel. While the panel's origin point
    already has some coordinates on the screen, we don't use those for setting the
    position of the element.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用了相对和绝对定位的组合，但这次相对起始点不是整个屏幕的原点**[0,0]**，而是我们面板的原点**[0,0]**。虽然面板的原点在屏幕上已经有一些坐标，但我们不使用它们来设置元素的位置。
- en: 'In theory, we now have scalable elements inside the panel(s), but we still
    need a way to *lock* or *stickie* panels in place, regardless of the screen resolution.
    This is where the concept of GUI anchor systems comes in. Chances are, if you
    have ever worked with a GUI before, you have seen anchors in action. In our example,
    we are going to slightly simplify the concept for the sake of time. In our system,
    every panel will have the ability to set its origin relative to one of five anchor
    points: top left, top right, bottom left, bottom right, and center.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们现在在面板内有可扩展的元素，但我们仍然需要一种方法来*锁定*或*固定*面板的位置，而不受屏幕分辨率的影响。这就是GUI锚点系统的概念发挥作用的地方。如果您以前使用过GUI，很可能已经看到过锚点的作用。在我们的例子中，为了节省时间，我们将稍微简化这个概念。在我们的系统中，每个面板都将能够将其原点相对于五个锚点之一设置：左上、右上、左下、右下和中心。
- en: 'The following diagram demonstrates this concept:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表演示了这个概念：
- en: '![](img/6b2ce10a-aa70-43a8-bdfe-a91cdf9d5897.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b2ce10a-aa70-43a8-bdfe-a91cdf9d5897.png)'
- en: 'OK, so how do we implement these concepts and design them in code? Let start
    with a `IGUIElement` class that all other elements will inherit from. Take a look
    at the `IGUIElement` class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么我们如何在代码中实现这些概念并设计它们呢？让我们从一个所有其他元素都将继承的`IGUIElement`类开始。看一下`IGUIElement`类：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To start with, our elements are not that complicated. Each element will have
    an `Update()` function, as well as a getter function to return the position of
    the element. We will be expanding on this class later on in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的元素并不复杂。每个元素都将有一个`Update()`函数，以及一个getter函数来返回元素的位置。我们将在本章后面扩展这个类。
- en: 'The next part of the system we can implement is the concept of panels. Let''s
    start by taking a look at the header file of `IGUIPanel.h`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现系统的下一部分是面板的概念。让我们从`IGUIPanel.h`的头文件开始看一下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The file starts off with the declaration of an `enum class` called `GUIAnchorPos`;
    this `enum` will give the elements access to the calculated anchor points. We
    are making this an enum class instead of just an `enum` inside of the `IGUIPanel`
    class, as this will allow elements to access the anchor points without the need
    for an `IGUIPanel` instance. Later on, we will see a function that connects these
    enumerated values to the screen positions that have been calculated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以声明一个名为`GUIAnchorPos`的`enum class`开始；这个`enum`将给元素们访问计算出的锚点的权限。我们将这个`enum`类作为`IGUIPanel`类内部的一个`enum`，而不是一个`IGUIPanel`实例的需要，这样可以让元素们在不需要`IGUIPanel`实例的情况下访问锚点。后面，我们将看到一个将这些枚举值连接到已计算出的屏幕位置的函数。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next part of the file that is of interest is the constructor. Here, we
    are requesting a vector 4 to be passed in to define the bounds of the panel to
    be created. Next, we are requesting a vector two for the panel anchor''s origin
    location, as well as a vector two to provide the offset or *padding* for the panel''s
    position. You will also notice that we are also providing some defaults for each
    parameter. We are doing this for a couple of reasons, but the biggest one is that
    we want to be able to create GUI elements and attach them to a panel by default.
    By providing defaults, if we do create a GUI element and there is no existing
    panel to attach it to, we can create one without the need to pass in values when
    it''s created. We will revisit this later on in the chapter. Let''s move on to
    the implementation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中感兴趣的下一部分是构造函数。在这里，我们要求传入一个vector 4来定义要创建的面板的边界。接下来，我们要求一个vector two来定义面板锚点的原点位置，以及一个vector
    two来提供面板位置的偏移或*填充*。您还会注意到，我们还为每个参数提供了一些默认值。我们这样做有几个原因，但最重要的原因是我们希望能够默认创建GUI元素并将它们附加到面板上。通过提供默认值，如果我们创建了一个GUI元素，而没有现有的面板可以附加它，我们可以在创建时不需要传入值来创建一个面板。我们将在本章后面重新讨论这个问题。让我们继续实现：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the implementation of the `IGUIPanel` constructor, the first thing we will
    calculate is the panel's position on the screen. We do this by adding the panel's
    anchor point with the offset that has been passed in and storing it in the protected
    member variable `m_Pos`. Next, we calculate the panel's width and height; we do
    this using the bounds values being passed in. We store them in protected member
    variables named `m_panelWidth` and `m_panelHeight` respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`IGUIPanel`构造函数的实现，我们首先要计算的是面板在屏幕上的位置。我们通过将面板的锚点与传入的偏移相加来实现这一点，并将其存储在受保护的成员变量`m_Pos`中。接下来，我们计算面板的宽度和高度；我们使用传入的边界值来实现这一点。我们分别将它们存储在名为`m_panelWidth`和`m_panelHeight`的受保护成员变量中。
- en: 'Now that we have the panel constructor in place, we can move on to setting
    up how the panels will hold their elements. To accomplish this, we simply create
    a vector of `IGUIElements` pointers called `m_GUIElementList`. We can then start
    to create some public methods to access and manipulate the panel''s element list:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了面板构造函数，我们可以继续设置面板如何保存它们的元素。为了实现这一点，我们简单地创建了一个名为`m_GUIElementList`的`IGUIElements`指针的向量。然后我们可以开始创建一些公共方法来访问和操作面板的元素列表：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, in the `IGUIPanel.cpp` file, we create an `AddGUIElement()` function
    to add new elements to the panel. This function implements a call to the `push_back()`
    method of the panel''s element list, pushing in the giving `GUIElement` reference:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`IGUIPanel.cpp`文件中，我们创建一个`AddGUIElement()`函数来向面板添加新元素。这个函数实现了对面板元素列表的`push_back()`方法的调用，将给定的`GUIElement`引用推入其中：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Jumping to the `IGUIPanel.h` file, we implement a getter function, `GetGUIElementList()`,
    to provide public access to the private element list:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到`IGUIPanel.h`文件，我们实现了一个getter函数`GetGUIElementList()`，以提供对私有元素列表的公共访问：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Switching back to the `IGUIPanel.cpp` file, we can look at the implementation
    of the `Update()` function for the panel class. This update will step through
    the panel''s element list and then call the `Update()` function for each of the
    elements in the list. This will allow the panel to control the updates of its
    elements, and provides the structure for implementing concepts such as pausing
    element updates on the panel being hidden:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回`IGUIPanel.cpp`文件，我们可以查看面板类的`Update()`函数的实现。这个更新将遍历面板的元素列表，然后调用列表中每个元素的`Update()`函数。这将允许面板控制其元素的更新，并为实现诸如在面板隐藏时暂停元素更新等概念提供结构：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we need to remember to clean up all the elements belonging to the panel
    when the destructor is called. To do this, we are going to use the `for_each()`
    method of the `standard` library. We are using this method mostly because this
    is an example and due to the sheer fact that I want to introduce you to it. The
    `for_each()` method takes three parameters. The first two are applied to the range,
    and the third is the function to execute. In our example, we are going to call
    `default_delete()` on each element we step through, and again we are using this
    method as a means to introduce you to the function. The `default_delete()` function
    is actually a function object class, whose function-like invocation takes a templated
    object type and deletes it. This can be compared the non-specialized version that
    simply uses delete for the delete operation or the specialization for arrays,
    `delete[]`. This class is specifically designed to be used with `unique_ptr` and
    provides a way to delete `unique_ptr` objects with no overhead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要记住在调用析构函数时清理属于面板的所有元素。为此，我们将使用`standard`库的`for_each()`方法。我们主要使用这个方法是因为这是一个例子，而且我想向你介绍它。`for_each()`方法接受三个参数。前两个应用于范围，第三个是要执行的函数。在我们的例子中，我们将在我们遍历的每个元素上调用`default_delete()`，再次使用这个方法是为了向你介绍这个函数。`default_delete()`函数实际上是一个函数对象类，其类似函数的调用接受一个模板化的对象类型并删除它。这可以与简单使用delete进行删除操作的非专门化版本或用于数组的专门化版本`delete[]`进行比较。这个类专门设计用于与`unique_ptr`一起使用，并提供了一种在没有开销的情况下删除`unique_ptr`对象的方法。
- en: 'OK, now that we have the `IGUIPanel` class in place, we can move on to constructing
    some more complex elements needed for our GUI system. For this example, we will
    add a basic button with label support:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经放置了`IGUIPanel`类，我们可以继续构建我们GUI系统所需的更复杂的元素。在这个例子中，我们将添加一个带有标签支持的基本按钮：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `IGUIButton.h` file, we can see that the button inherits from our basic
    `IGUIElement`. This of course means we have access to all the functions and protected
    members of the parent class, including the `m_position` and `GetPosition()` functions,
    so we do not redefine them here. While we are looking at the `IGUIButton.h`, we
    can also peek at the constructor, where we are defining what the button will require
    to be passed in when creating. In our example button, we are looking for the bounds
    (size) of the button, the position, a texture to use when drawing the button,
    a label for the button (text to be displayed), the font to use for the label,
    the scale of the font (which we give as a default of `1.0f`), and finally a panel
    to add the button to which we default to `NULL` unless otherwise specified. We
    will take a deeper look at these parameters as we continue on with the chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IGUIButton.h`文件中，我们可以看到按钮继承自我们基本的`IGUIElement`。这当然意味着我们可以访问父类的所有函数和受保护的成员，包括`m_position`和`GetPosition()`函数，因此我们不在这里重新定义它们。当我们查看`IGUIButton.h`时，我们还可以看一下构造函数，在那里我们定义了创建按钮时需要传入的内容。在我们的示例按钮中，我们正在寻找按钮的边界（大小），位置，绘制按钮时要使用的纹理，按钮的标签（要显示的文本），用于标签的字体，字体的比例（我们默认为`1.0f`），最后是要将按钮添加到的面板，默认为`NULL`，除非另有说明。随着我们继续本章，我们将更深入地研究这些参数。
- en: 'Shifting to the implementation of the constructor, in the `IGUIButton.cpp` before `IGUIButton::IGUIButton(glm::vec4
    & bounds, glm::vec2 & position, std::string label, GLTexture * texture, SpriteFont*
    font, glm::vec2& fontScale, IGUIPanel* panel)`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的实现方面，在`IGUIButton.cpp`中，在`IGUIButton::IGUIButton(glm::vec4 & bounds, glm::vec2
    & position, std::string label, GLTexture * texture, SpriteFont* font, glm::vec2&
    fontScale, IGUIPanel* panel)`之前：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the most part, we are just setting the internal member variables to the
    passed in values, but the one thing of note is how we handle the panel value.
    In the constructor body, we perform a check to see if the value stored in `m_panel`
    is not null. If this check is true, we can move on to setting the position of
    the button element relative to the panel''s position. We do this by first calling
    the panel''s `GetPosition()` function, adding the returned value to our passed
    in position value, and saving that calculation in the `m_position` member variable.
    This will give us, partially, what we want by setting the position of our button
    to the relation origin of the panel, but since the origin of our default panel
    elements is the lower left corner, the outcome would be the button being placed
    at the bottom of the panel. This is not necessarily the desired behavior. To correct
    this, we need to calculate our button''s new *y* axis value based on the top of
    the panel, and of course any already existing elements in the panel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在大部分情况下，我们只是将内部成员变量设置为传入的值，但值得注意的是我们如何处理面板的值。在构造函数体中，我们进行了一个检查，看看`m_panel`中存储的值是否为空。如果这个检查为真，我们可以继续设置按钮元素相对于面板位置的位置。我们首先调用面板的`GetPosition()`函数，将返回的值添加到我们传入的位置值中，并将该计算保存在`m_position`成员变量中。这将部分地通过将按钮的位置设置为面板的关系原点来给我们想要的东西，但由于默认面板元素的原点是左下角，结果是按钮被放置在面板的底部。这不一定是期望的行为。为了纠正这一点，我们需要根据面板的顶部计算按钮的新*y*轴值，当然还有面板中已经存在的元素：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we want to check if the panel we are adding the button to has any existing
    elements in it already. We do this by checking the panel's vector with the `GetGUIElementList().empty()`
    function. If the panel's element list is not empty, we then need the position
    the of the last element in the panel's list. We do this by creating a temporary
    element called `lastElement` and assigning it to the last element in the panel's
    list using `GetGUIElementList().back()`. With the element stored, we can then
    use it to calculate the button's *y* axis value. We do this by subtracting the
    stored element's *y* axis value from the stored element's height (`GetBounds().w`)
    and a default padding value, which we are setting at `10.0f` in this example.
    In a full GUI implementation, you would want to make this padding value dynamic.
    Finally, if the panel is empty, and this is the first element, we set the button's
    *y* axis by calculating the panel's height (`GetBounds()->w`) minus the new button's
    height. This will place the button element at the very top of the panel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要检查我们要添加按钮的面板是否已经有任何现有元素。我们通过检查面板的向量和`GetGUIElementList().empty()`函数来实现这一点。如果面板的元素列表不为空，我们需要获取面板列表中最后一个元素的位置。我们通过创建一个临时元素`lastElement`并使用`GetGUIElementList().back()`将其赋值为面板列表中的最后一个元素来实现这一点。有了存储的元素，我们可以用它来计算按钮的*y*轴值。我们通过从存储的元素的*y*轴值减去存储的元素的高度(`GetBounds().w`)和一个默认的填充值来实现这一点，在这个例子中我们将填充值设置为`10.0f`。在完整的GUI实现中，您可能希望使这个填充值动态化。最后，如果面板是空的，并且这是第一个元素，我们通过计算面板的高度(`GetBounds()->w`)减去新按钮的高度来设置按钮的*y*轴。这将把按钮元素放在面板的顶部。
- en: 'We now have a panel system with an element class and an implemented button
    element created. The last thing we need to do is build a high-level class to glue
    the system together. We are going to create an `IGUI` class that will house panels,
    provide access to the GUI methods to other game systems, and, as we will see in
    the next sections, provide input, update, and draw mechanisms. Let''s jump into
    the constructor implementation in the `IGUI.cpp` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个带有元素类和实现的按钮元素的面板系统。我们需要做的最后一件事是构建一个高级类来将系统粘合在一起。我们将创建一个`IGUI`类，它将容纳面板，为其他游戏系统提供对GUI方法的访问，并且，正如我们将在接下来的部分中看到的，提供输入、更新和绘制机制。让我们跳转到`IGUI.cpp`文件中的构造函数实现：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the constructor for the `IGUI` class, we are going to define the anchor
    points that we will use for all the panels held by the `IGUI` instance. We are
    going to store these values in private member variables: `m_BL` for the bottom
    left of the screen, `m_BR` for the bottom right of the screen, `m_TL` for the
    top left, `m_TR` for the top right, and `m_C` for the center of the screen. We
    use the set `m_window` Window object to return the width and height of the screen
    used to calculate the anchor points. We will see how these points are used to
    provide anchors to the panels later in the class.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IGUI`类的构造函数中，我们将定义我们将用于`IGUI`实例中保存的所有面板的锚点。我们将把这些值存储在私有成员变量中：`m_BL`表示屏幕左下角，`m_BR`表示屏幕右下角，`m_TL`表示屏幕左上角，`m_TR`表示屏幕右上角，`m_C`表示屏幕中心。我们使用设置`m_window`窗口对象来返回用于计算锚点的屏幕的宽度和高度。我们将看到这些点如何用于后面的课程中为面板提供锚点。
- en: 'Next, let''s look at the functions we will use to add the elements and panels
    to the `IGUI` instances:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下我们将用来将元素和面板添加到`IGUI`实例中的函数。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Starting with the `AddGUIElement` function, this function, as its name implies,
    adds a GUI element to the GUI. By default, the element will be added to the first
    panel found in the GUI''s panel list, which is stored in the `m_GUIPanelsList`
    vector. If the panel list is empty we then create a new panel, add it to the list,
    and then finally add the element to that panel:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从`AddGUIElement`函数开始，这个函数，正如它的名字所暗示的那样，将一个GUI元素添加到GUI中。默认情况下，元素将被添加到GUI的面板列表中找到的第一个面板中，这些面板存储在`m_GUIPanelsList`向量中。如果面板列表为空，我们将创建一个新的面板，将其添加到列表中，然后最终将元素添加到该面板中：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AddGUIPanel()` function is very simple. We take the passed in `IGUIPanel`
    object and add it to the GUI's panel list using the `push_back()` vector method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddGUIPanel()`函数非常简单。我们使用`push_back()`向量方法将传入的`IGUIPanel`对象添加到GUI的面板列表中。'
- en: 'The last part of the positioning system that we need to look at is the `GetAnchorPos()`
    function. This function will return the panel''s anchor position based on the
    calculated screen values, which we saw previously in the `IGUI` constructor and
    the size of the panel itself:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的定位系统的最后一部分是`GetAnchorPos()`函数。这个函数将根据之前在`IGUI`构造函数中看到的计算屏幕值和面板本身的大小返回面板的锚点位置：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start off by passing in two values. The first is `GUIAnchorPos`, which you
    might remember from earlier on in the chapter when we defined an `enum` class
    in the `IGUIPanel.h` file. The second is the bounds of the panel, described with
    a vector four object. Inside the function, we have a switch case statement which
    we are using to determine what anchor point to calculate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先传入两个值。第一个是`GUIAnchorPos`，您可能还记得在`IGUIPanel.h`文件中定义`enum`类时在本章前面的部分。第二个是用四个向量对象描述的面板的边界。在函数内部，我们有一个switch
    case语句，我们使用它来确定要计算的锚点。
- en: If the case matches the `TopRight` enum value, first we modify the *y* axis
    value of the anchor point. We do this because we use the bottom left corner as
    the default origin, so we need to modify this so the top left corner is the new
    origin for the anchor point. Next, we modify the *x* axis value of the anchor
    point. We do this because we need to move the anchor point in from the top right
    corner of the screen by the width of the panel object. If we don't modify the
    *x* axis value, the panel will draw off screen to the right.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况匹配`TopRight`枚举值，首先我们修改锚点的*y*轴值。我们这样做是因为我们使用左下角作为默认原点，所以我们需要修改这一点，使得左上角成为锚点的新原点。接下来，我们修改锚点的*x*轴值。我们这样做是因为我们需要将锚点从屏幕的右上角移动到面板对象的宽度。如果我们不修改*x*轴值，面板将绘制到屏幕右侧。
- en: Next, if the case matches the TopLeft enum value, we modify the *y* axis value
    of the anchor point. As stated previously, we do this to account for the origin
    of our coordinate system being the lower left-hand corner. We do not have to modify
    the *x* axis value this time, since when we draw left to right, our panel will
    appear on screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果情况匹配`TopLeft`枚举值，我们修改锚点的*y*轴值。如前所述，我们这样做是为了考虑我们的坐标系的原点位于左下角。这次我们不需要修改*x*轴的值，因为当我们从左到右绘制时，我们的面板将出现在屏幕上。
- en: If the case matches the `BottomRight` enum value, we need to modify the *x*
    axis value. As mentioned before, we need to move the anchor point to the left
    by the width of the panel, to make sure the panel will draw on the screen. We
    do not need to modify the *y* axis this time, since the anchor will match the
    default coordinate system's *y* origin of the bottom of the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况匹配`BottomRight`枚举值，我们需要修改*x*轴的值。如前所述，我们需要将锚点向左移动面板的宽度，以确保面板绘制在屏幕上。这次我们不需要修改*y*轴的值，因为锚点将匹配默认坐标系的屏幕底部的*y*原点。
- en: If the case matches the `BottomLeft` enum value, we simply return the anchor
    point unmodified since it matches the default origin of the coordinate system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况匹配`BottomLeft`枚举值，我们只需返回未修改的锚点，因为它与坐标系的默认原点匹配。
- en: Finally, if the case matches the `Center` enum value, we will only modify the
    *y* axis value since we only have to account for the default origin being in the
    lower left corner. The *x* axis value calculated in the constructor will move
    the panel to the right to position it properly in the center of the screen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果情况匹配`Center`枚举值，我们只会修改*y*轴的值，因为我们只需要考虑默认原点位于屏幕左下角。构造函数中计算的*x*轴值将使面板向右移动，以正确地将其定位在屏幕中心。
- en: That takes care of the positioning and anchor system for our GUI system. We
    now have a solid framework to continue building on throughout the rest of the
    chapter. Next, we will look at how we can add input control to our GUI system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了我们的GUI系统的定位和锚点系统。我们现在有了一个坚实的框架，可以在本章的其余部分继续构建。接下来，我们将看看如何将输入控制添加到我们的GUI系统中。
- en: Adding control logic
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制逻辑
- en: A GUI is much more than just what you can see on screen. There is also logic
    running behind the scenes, so to speak, that provides the functionality needed
    to interact with objects. Handling what happens if a mouse is moved over an element,
    if a checkbox is selected, or if a button is clicked is all part of the GUI input
    system. In this section, we are going to construct the necessary architecture
    to handle mouse input for our GUI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GUI远不止是屏幕上所见的。在幕后还有逻辑运行，提供与对象交互所需的功能。处理鼠标移动到元素上时发生的情况，复选框被选中时发生的情况，或者按钮被点击时发生的情况，都是GUI输入系统的一部分。在本节中，我们将构建处理GUI鼠标输入所需的架构。
- en: While there are a few different ways we could implement the system to handle
    input for our GUI, I think this is a perfect opportunity to introduce you to one
    of my favorite programming patterns, the Observer. The `Observer` is one of the
    most widely known patterns from the **Gang of Four**. The `Observer` is so commonly
    used that Java has a core library dedicated to it, `java.util.Observer` and C#
    has it incorporated into the language itself in the form of the event keyword.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以以几种不同的方式实现处理GUI输入的系统，但我认为这是一个完美的机会，可以向您介绍我最喜欢的编程模式之一，即观察者模式。观察者是**四人帮**中最广为人知的模式之一。观察者如此常用，以至于Java有一个专门的核心库`java.util.Observer`，而C#则将其纳入语言本身，以事件关键字的形式。
- en: 'I think the easiest way to explain the `Observer` pattern is that when you
    have objects doing various things that are of interest to another class or object,
    you can *subscribe* to *events* and get notified when these objects perform their
    interesting functions. It''s very likely you have seen and/or used the `Observer`
    pattern before in your development adventures. In fact, we have seen it already
    in this book. The SDL library uses its own `Observer` pattern for handling input.
    We tap into it to perform tasks based on the user''s input. The following is the
    SDL event implementation we use to handle our game input:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为解释观察者模式最简单的方法是，当您有对象执行另一个类或对象感兴趣的各种操作时，您可以*订阅* *事件*，并在这些对象执行其有趣功能时得到通知。很可能您在开发过程中已经见过并/或使用过观察者模式。事实上，我们在本书中已经见过它。SDL库使用自己的观察者模式来处理输入。我们利用它来根据用户的输入执行任务。以下是我们用来处理游戏输入的SDL事件实现：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What we are going to build is something a little more basic, but it will provide
    you with a good understanding of how you can implement an input system for a GUI,
    and you can hopefully familiarize yourself with a flexible pattern for future
    development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的东西可能有点基础，但它将让您了解如何为GUI实现输入系统，并且您可以希望熟悉一种灵活的模式，以便未来的开发。
- en: 'To start with, inside the `IGUIElement` header file, we create a new `enum`
    class called `GUIEvent`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`IGUIElement`头文件中，我们创建一个名为`GUIEvent`的新`enum`类：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This `enum` class defines the different types of events that our GUI elements
    can listen for. Next, still in our `IGUIElement` class header file, we need to
    add a completely virtual function, `OnNotify()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`enum`类定义了我们的GUI元素可以监听的不同类型的事件。接下来，在我们的`IGUIElement`类头文件中，我们需要添加一个完全虚拟的函数`OnNotify()`：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This function will be overridden by each of the element types and will be called
    when events occur. The elements that have this function implemented can *listen *to
    the events that matter to them and perform actions as necessary. `OnNotify()`
    takes two parameters: an `IGUIElement()` which defines which element is affected,
    and the event type. These two parameters will give us all the information we need
    to determine what to do with each event sent.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将被每种元素类型覆盖，并在事件发生时调用。实现了这个函数的元素可以*监听*对它们重要的事件，并根据需要执行操作。`OnNotify()`接受两个参数：一个定义受影响的元素的`IGUIElement()`，以及事件类型。这两个参数将为我们提供确定如何处理发送的每个事件的所有所需信息。
- en: 'Let''s take a look at the `OnNotify()` implementation in our `IGUIButton()`
    object class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`IGUIButton()`对象类中`OnNotify()`的实现：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `IGUIButton::OnNotify` implementation, we can listen to different types
    of events being passed in. In this example case, we are checking if the event
    passed in is a `HoverOver` event. If it is, we add a comment for where we will
    perform any actions we need to when the button is hovered over. That''s really
    it when it comes to setting up the *listener*. Next, we need to connect our GUI
    input system to the current input system and start sending out the event notifications.
    Let''s move on and look at the `CheckInput()` function implementation in the `IGUI`
    object class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IGUIButton::OnNotify`的实现中，我们可以监听传入的不同类型的事件。在这个例子中，我们正在检查传入的事件是否是`HoverOver`事件。如果是，我们会添加一个注释，说明当按钮悬停时我们需要执行的任何操作。这就是设置*listener*的全部内容。接下来，我们需要将我们的GUI输入系统连接到当前输入系统，并开始发送事件通知。让我们继续看看`IGUI`对象类中`CheckInput()`函数的实现：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will take a look at it piece by piece. To start with, we get the current
    mouse coordinates from the passed in `InputManager` object and save them to temporary
    variables:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步查看它。首先，我们从传入的`InputManager`对象中获取当前鼠标坐标，并将它们保存到临时变量中：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to use a nested `for` loop to step through all the panels in
    the GUI and, in turn, all the elements attached to each one of those panels:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用嵌套的`for`循环来遍历GUI中的所有面板，依次遍历每个面板上附加的所有元素：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside of the nested loop, we are going to do a simple *hit* test to see if
    we are in the button''s bound. However, first, we need to do a quick calculation.
    In the coordinate and position section earlier in this chapter, you might remember
    we made a conversion to have the anchor point''s *y* axis moved to the top left
    corner. Now we need to do the opposite and convert the *y* axis of the element''s
    position back to the lower left corner. The reason we need to do this is so the
    mouse cursor''s screen coordinate system is in the same as the buttons position:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套循环内，我们将进行一个简单的*hit*测试，以查看我们是否在按钮的边界内。然而，首先，我们需要进行一个快速的计算。在本章的坐标和位置部分中，您可能还记得我们进行了一个转换，将锚点的*y*轴移动到左上角。现在我们需要做相反的操作，将元素位置的*y*轴转换回到左下角。我们之所以需要这样做，是因为鼠标光标的屏幕坐标系统与按钮位置相同：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last thing we need to do in the loop is to perform the actual *hit* or
    bounds check. To do this, we check and see if the mouse cursor''s, *x* axis value
    is within the button''s screen area. We also check the same thing on the *y* axis
    using the converted *y* values from earlier. If all these conditions are met,
    then we can send a `HoverOver` event notification to the element:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中我们需要做的最后一件事是执行实际的*hit*或边界检查。为此，我们检查并查看鼠标光标的*x*轴值是否在按钮的屏幕区域内。我们还使用之前转换的*y*值在*y*轴上进行相同的检查。如果所有这些条件都满足，那么我们可以向元素发送一个`HoverOver`事件通知：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With that, we have, while crude, a working event system. The last piece of
    the puzzle we need to put in place is connecting it to the current input handling
    system of the game engine. To do that, we add one simple line to the `CheckInput()`
    function of the `ExampleScreen` class, `m_gui->CheckInput(m_game->GetInputManager());`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们虽然粗糙，但已经有了一个工作的事件系统。我们需要放置的最后一块拼图是将其连接到游戏引擎的当前输入处理系统。为此，我们在`ExampleScreen`类的`CheckInput()`函数中添加一行简单的代码，`m_gui->CheckInput(m_game->GetInputManager());`：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That takes care of the logic implementation for this chapter's example. There
    is definitely room for refactoring and tuning, but this should provide you with
    a good starting point to expand upon. I would recommend going through the next
    steps and adding more functionality, maybe even new elements to work with. In
    the next section, we are going to close out the chapter by adding rendering to
    our GUI system and finally drawing our example on the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本章示例的逻辑实现。肯定还有重构和调优的空间，但这应该为您提供了一个扩展的良好起点。我建议您继续进行下一步，并添加更多功能，甚至可能添加新的元素来使用。在下一节中，我们将通过向我们的GUI系统添加渲染并最终在屏幕上绘制示例来结束本章。
- en: Rendering the GUI
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染GUI
- en: With all the positioning and input logic in place, we can now finish up our
    GUI system by implementing some basic rendering. The good news is we already have
    a strong infrastructure for our main rendering that we built earlier on in the
    book. We are going to tap into this infrastructure to render our GUI on the screen.
    Basically, you have two real choices when it comes to rendering the GUI. You could
    render the GUI to a texture and then blend the created texture into your final
    drawn scene. The other option is to render everything as geometry in each frame
    on top of your scene. Both have their issues, but I would argue that in most cases
    creating a texture and blending that texture will be slower than rendering the
    GUI elements as geometry.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有的定位和输入逻辑，我们现在可以通过实现一些基本的渲染来完成我们的GUI系统。好消息是，我们在书中前面已经建立了一个强大的主要渲染基础设施。我们将利用这个基础设施在屏幕上渲染我们的GUI。基本上，在渲染GUI时有两种选择。您可以将GUI渲染到纹理中，然后将创建的纹理混合到最终绘制的场景中。另一个选择是在每一帧中将所有内容作为几何体渲染在场景的顶部。两者都有各自的问题，但我认为在大多数情况下，创建纹理并混合该纹理会比将GUI元素渲染为几何体要慢。
- en: To keep things slightly simple and to focus more on the implementation, we start
    with an easier approach and render each of the elements separately. This, of course,
    is not the most performance-friendly way of rendering if we have lots of elements
    in the GUI. In our example, we will not have a large number of elements, and if
    you are building something such as a start game/menu GUI, this solution in its
    current form will be more than sufficient. Keep an eye on your framerate, as if
    you notice a drop then chances are you have too many draw calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持事情稍微简单，并更专注于实现，我们从一个更简单的方法开始，分别渲染每个元素。当然，如果GUI中有大量元素，这并不是最友好的性能渲染方式。在我们的示例中，我们不会有大量元素，如果您正在构建类似开始游戏/菜单GUI的东西，当前形式的解决方案将是完全足够的。注意您的帧率，如果注意到下降，那么很可能是有太多的绘制调用。
- en: The best way we can approach our solution is to use the same approach we took
    when rendering our models, with some slight differences. We will use shaders again
    to draw the geometry, as this will provide us with lots of control and the ability
    to perform any blend, masks, patterns, and effects we might want to add. For our
    GUI example, we are going to reuse our texture vertex and fragment shaders from
    the previous chapters. In the next chapter, we are going to dive deeper into advanced
    shaders and drawing techniques.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用与渲染模型时相同的方法来处理我们的解决方案，只是有些细微差异。我们将再次使用着色器来绘制几何图形，因为这将为我们提供大量控制和执行任何混合、蒙版、图案和效果的能力。对于我们的GUI示例，我们将重用前几章的纹理顶点和片段着色器。在下一章中，我们将深入探讨高级着色器和绘图技术。
- en: 'So, let''s dive into the implementation. Add this to the `IGUI.h` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们深入实现。将这些添加到`IGUI.h`文件中：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then add this in the constructor for the `IGUI` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`IGUI`对象的构造函数中添加这个：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we are specifying a shader texture program, a sprite batch, and a 2D camera.
    This camera is slightly different to the 3D version we created earlier in the
    book. I won't go too deep into the 2D camera since its slightly out of the scope
    of this chapter, but I will mention that the major change is that we are constructing
    an orthographic matrix for 2D drawing. We are giving each GUI instance its own
    shader, camera, and sprite batch. It will be up to the instance to handle the
    final setup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了一个着色器纹理程序、一个精灵批处理和一个2D相机。这个相机与我们在本书前面创建的3D版本略有不同。我不会深入讨论2D相机，因为它略微超出了本章的范围，但我会提到主要的变化是我们正在为2D绘图构建正交矩阵。我们为每个GUI实例提供自己的着色器、相机和精灵批处理。最终设置将由实例来处理。
- en: 'The `ExampleGUI` is the implementation of the `IGUI` class for our example.
    Taking a look at the `OnInit()` function, we can see the setup of these resources:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExampleGUI`是我们示例中`IGUI`类的实现。看一下`OnInit()`函数，我们可以看到这些资源的设置：'
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will break it down piece by piece. To start with, we need to compile the
    `Shaders` we need for our GUI, so we add the attributes we need for the shaders,
    and finally link them for use. This should be familiar:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个分解。首先，我们需要编译我们GUI所需的`Shaders`，所以我们添加着色器所需的属性，最后将它们链接以供使用。这应该很熟悉：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then call `Init` on our 2D camera instance, passing the screen width and
    height. After the `Init`, we then set the position of the camera to the middle
    of the screen by dividing the screen''s height and width values in half:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在2D相机实例上调用`Init`，传递屏幕宽度和高度。在`Init`之后，我们将相机的位置设置为屏幕中间，通过将屏幕的高度和宽度值除以2：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have the shader program, the sprite batch, and camera setup, we
    move on to the creation of the GUI elements. First up is the panel element, which
    we create using the architecture we created earlier in the chapter. We set its
    anchor point as the bottom left of the screen. Once the panel is created, we add
    it to the GUI instance by calling the `AddGUIPanel` function that the class has
    inherited:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了着色器程序、精灵批处理和相机设置，我们继续创建GUI元素。首先是面板元素，我们使用之前在本章创建的架构来创建它。我们将其锚点设置为屏幕的左下角。面板创建完成后，我们通过调用类继承的`AddGUIPanel`函数将其添加到GUI实例中：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the panel created and added to the GUI instance''s panel list, we then
    add a button to that panel. To do that, we first create a temporary variable to
    hold the texture we want to load for this button. Then we create the button itself.
    We again use the structure we built earlier on in the chapter. We pass in the
    label of `My Button` and the texture we just loaded. Once complete, we call the
    `AddGUIElement()` function and add the button to the panel:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 面板创建并添加到GUI实例的面板列表后，我们将一个按钮添加到该面板。为此，我们首先创建一个临时变量来保存我们想要为此按钮加载的纹理。然后我们创建按钮本身。我们再次使用本章前面构建的结构。我们传入标签`My
    Button`和刚刚加载的纹理。完成后，我们调用`AddGUIElement()`函数并将按钮添加到面板：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now our elements are in place, and the rendering components have been created
    and set up, we can finalize the rendering pipeline for the GUI system. To do this,
    we are going to fall back on the inheritance structure we have created in our
    objects. To start the draw call chain, we begin with the `ExampleGUI` class and
    its `Draw()` function implementation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的元素已经就位，渲染组件已经创建并设置好，我们可以为GUI系统最终确定渲染流程。为了做到这一点，我们将回归到我们在对象中创建的继承结构。要开始绘制调用链，我们从`ExampleGUI`类和它的`Draw()`函数实现开始：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Focusing on an important aspect of our GUI implementation, we begin the `Draw()`
    function by specifying the shader program we want to use when rendering the GUI
    elements. Next, we start the sprite batch that will be used for the GUI elements.
    Then, between the start of the sprite batch and the end of the sprite batch, we
    use a `for` loop to step through all the panels in the GUI's panel list and call
    its `Draw()` function implementation. Once the `for` loop has completed, we then
    end the sprite batch, call the `BatchRender()` method to render all the objects
    in the batch, and finally close out the function by calling the `UnUse()` method
    on our shader program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关注我们GUI实现的一个重要方面，我们首先在`Draw()`函数中指定我们在渲染GUI元素时要使用的着色器程序。接下来，我们启动将用于GUI元素的精灵批次。然后，在精灵批次的开始和结束之间，我们使用一个`for`循环来遍历GUI面板列表中的所有面板，并调用其`Draw()`函数的实现。一旦`for`循环完成，我们就结束了精灵批次，调用`BatchRender()`方法来渲染批次中的所有对象，最后通过在着色器程序上调用`UnUse()`方法来关闭函数。
- en: 'Let''s go down one level in the draw chain and look at the IGUIPanel''s Draw
    function implementations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在绘制链中再往下一级，并查看IGUIPanel的Draw函数实现：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `IGUIPanel::Draw()` function, we start by adding the panel itself to
    the sprite batch that we passed in from the calling object. This will draw a slightly
    opaque black background. Ideally, you want to make the texture used for the background
    a non-hardcoded value and allow it to be set for each instance. After we have
    added the panel to the sprite batch for drawing, we again use a `for` loop to
    step through each element in the panel's element list and call its `Draw()` function
    implementation. This effectively pushes its use to the next layer down in the
    draw chain.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IGUIPanel::Draw()`函数中，我们首先将面板本身添加到从调用对象传入的精灵批次中。这将绘制一个略带不透明的黑色背景。理想情况下，您希望使用于背景的纹理成为一个非硬编码的值，并允许为每个实例进行设置。在我们将面板添加到用于绘制的精灵批次后，我们再次使用`for`循环来遍历面板元素列表中的每个元素，并调用其`Draw()`函数的实现。这实际上将其使用推到了绘制链中的下一层。
- en: 'For the `IGUIElement` class, we simply create a pure virtual function that
    the elements inheriting will have to implement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`IGUIElement`类，我们只需创建一个纯虚函数，继承该函数的元素将不得不实现：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So this means we can now step down to the last link in our draw chain example
    and look at the `IGUIButton::Draw()` function implementation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以进入我们绘制链示例中的最后一个链接，并查看`IGUIButton::Draw()`函数的实现：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, this implementation of the functions is not too complicated. We are adding
    the element to the sprite batch passed in by the calling object to be drawn. The
    effect of this is that all panels and their elements will be added to a single
    GUI instance's sprite batch, which will be far more performant than each panel
    and object drawing itself in sequence. The last code block in the `Draw()` function
    is a call to a Sprite Font instance's `Draw()` method. I won't go into detail
    about how the Sprite Font class works since it is out of the scope of this chapter,
    but have a look at the code files to understand how things are working under its
    hood. The role of the `SpriteFont` class is much like the `Sprite` class, except
    it provides a means to draw fonts/text on screen. Here in this example, we are
    using it to draw the label for the button.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些函数的实现并不太复杂。我们将元素添加到由调用对象传入的精灵批次中以进行绘制。这样做的效果是，所有面板及其元素将被添加到单个GUI实例的精灵批次中，这将比每个面板和对象依次绘制自身要更高效。`Draw()`函数中的最后一个代码块是对Sprite
    Font实例的`Draw()`方法的调用。我不会详细介绍Sprite Font类的工作原理，因为这超出了本章的范围，但请查看代码文件以了解其内部工作原理。`SpriteFont`类的作用与`Sprite`类类似，只是它提供了在屏幕上绘制字体/文本的方法。在这个例子中，我们使用它来绘制按钮的标签。
- en: 'That wraps up the draw chain. All we need to do now is connect the GUI''s head
    `Draw()` call to the main game''s `Draw()` call. To do this, we add one line to
    call the `Draw()` method of the GUI''s instance in the `ExampleScreen` class''s
    `Draw()` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了绘制链。现在我们只需要将GUI的头部`Draw()`调用连接到主游戏的`Draw()`调用。为此，在`ExampleScreen`类的`Draw()`函数中添加一行调用GUI实例的`Draw()`方法：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, I am happy to say, we have a simple but complete, working GUI system in
    place. You can run the example demo to see the completed GUI running. If you want
    to see how the panel is effected by each of the defined anchor points, you just
    need to change the `BookEngine::GUIAnchorPos` value when setting the panel in
    the `ExampleGUI` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我很高兴地说，我们已经有了一个简单但完整的工作GUI系统。您可以运行示例演示来查看已完成的GUI运行情况。如果您想要查看面板如何受到每个定义的锚点的影响，您只需要在`ExampleGUI`类中设置面板时更改`BookEngine::GUIAnchorPos`的值：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following are screenshots of the GUI in action, with its anchor points
    changed to `BottomLeft`, `BottomRight`, `TopLeft`, `TopRight`, and `Center`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GUI在运行中的屏幕截图，其锚点已更改为`BottomLeft`、`BottomRight`、`TopLeft`、`TopRight`和`Center`：
- en: 'The screenshot for `BottomRight` is as shown in the following figure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`BottomRight`的屏幕截图如下图所示：'
- en: '![](img/0595a630-669f-412c-adb4-9e951d649152.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0595a630-669f-412c-adb4-9e951d649152.png)'
- en: 'The screenshot for `BottomLeft` is as shown in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`BottomLeft`的屏幕截图如下图所示：'
- en: '![](img/8ee5b8ea-aa35-454f-8e9a-c4fcf8a37907.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ee5b8ea-aa35-454f-8e9a-c4fcf8a37907.png)'
- en: 'The screenshot for `TopLeft` is as shown in the following figure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopLeft`的屏幕截图如下图所示：'
- en: '![](img/ebbf1359-bb61-446e-9caa-461cc74cab06.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebbf1359-bb61-446e-9caa-461cc74cab06.png)'
- en: 'The screenshot for `TopRight` is as shown in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopRight`的屏幕截图如下图所示：'
- en: '![](img/770ecc8b-c2d8-4e5f-bfca-eed425cd420c.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/770ecc8b-c2d8-4e5f-bfca-eed425cd420c.png)'
- en: 'The screenshot for `Center` is as shown in the following figure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Center`的屏幕截图如下图所示：'
- en: '![](img/14a196c6-26aa-4e71-a784-45126f8d26d3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14a196c6-26aa-4e71-a784-45126f8d26d3.png)'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a large amount of information. We discussed the
    different aspects needed to create a GUI. We walked through its implementation,
    diving deep into the core architecture behind a working GUI. We developed a panel
    and element architecture complete with anchor points for controlling positioning.
    We implemented a user input structure using the `Observer` design pattern and
    rounded it out by coding up the rendering pipe needed to display the GUI elements
    on the screen. In the next chapter, we will dive deep into some of the advanced
    rendering techniques used in game development.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量信息。我们讨论了创建GUI所需的不同方面。我们深入探讨了工作GUI背后的核心架构。我们开发了一个面板和元素架构，包括用于控制定位的锚点。我们使用“观察者”设计模式实现了用户输入结构，并通过编写渲染管道来显示屏幕上的GUI元素。在下一章中，我们将深入探讨游戏开发中使用的一些高级渲染技术。
