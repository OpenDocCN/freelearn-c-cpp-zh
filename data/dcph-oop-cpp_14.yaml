- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Understanding STL Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 STL 基础
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts by delving into a core C++ library that has become thoroughly
    integrated into the common usage of the language. We will explore the **Standard
    Template Library** (**STL**) in C++ by examining a subset of this library, representing
    common utilities that can both simplify our programming and make our code more
    easily understood by others who are undoubtedly familiar with the STL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们扩展 C++ 编程知识库的追求，通过深入研究一个核心 C++ 库，该库已经彻底融入了语言的常见用法。我们将通过检查该库的子集来探索 C++
    中的 **标准模板库** (**STL**)，这些子集代表了一些常见的工具，它们既可以简化我们的编程，也可以使熟悉 STL 的他人更容易理解我们的代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Surveying the contents and purpose of the STL in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述 C++ 中 STL 的内容和目的
- en: Understanding how to use essential STL containers – `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, `map`, and `map` using a functor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用基本 STL 容器 – `list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`、`map`
    和 `map` 通过一个函数对象使用
- en: Customizing STL containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 STL 容器
- en: By the end of this chapter, you will be able to utilize core STL classes to
    enhance your programming skills. Because you already understand the essential
    C++ language and OOP features in which libraries are built, you will see that
    you now have the ability to navigate and understand nearly any C++ class library,
    including the STL. By gaining familiarity with the STL, you will be able to enhance
    your programming repertoire significantly and become a more savvy and valuable
    programmer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够利用核心 STL 类来提高你的编程技能。因为你已经理解了构建库所必需的基本 C++ 语言和面向对象编程特性，你会发现你现在有能力导航和理解几乎任何
    C++ 类库，包括 STL。通过熟悉 STL，你将能够显著扩展你的编程知识库，并成为一个更加精明和有价值的程序员。
- en: Let’s increase our C++ toolkit by examining a very heavily utilized class library,
    the STL.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查一个高度使用的类库——STL，来增加我们的 C++ 工具箱。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter14` in a file named `Chp14-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14)。每个完整程序示例都可以在
    GitHub 仓库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述
    GitHub 目录下的 `Chapter14` 子目录中找到，文件名为 `Chp14-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3PCL5IJ](https://bit.ly/3PCL5IJ).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址观看：[https://bit.ly/3PCL5IJ](https://bit.ly/3PCL5IJ)。
- en: Surveying the contents and purpose of the STL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述 STL 的内容和目的
- en: 'The **Standard Template Library** in C++ is a library of standard classes and
    utilities that extend the C++ language. The use of the STL is so pervasive that
    it is as though the STL is a part of the language itself; it is an essential and
    integral part of C++. The STL in C++ has four key components comprising the library:
    **containers**, **iterators**, **functions**, and **algorithms**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的 **标准模板库** 是一个标准类和工具的库，它扩展了 C++ 语言。STL 的使用非常普遍，以至于它似乎成了语言本身的一部分；它是 C++
    的一个基本且不可或缺的部分。C++ 中的 STL 由四个关键组件组成，构成了库：**容器**、**迭代器**、**函数**和**算法**。
- en: The STL has additionally influenced the C++ Standard Library in providing a
    set of programming standards; the two libraries actually share common features
    and components, most notably containers and iterators. We’ve already utilized
    components from the Standard Library, namely `<iostream>` for IOStreams, `<exception>`
    for exception handling, and `<new>` for operators `new()` and `delete()`. In this
    chapter, we will explore many overlapping components between the STL and the Standard
    Library in C++.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STL还影响了C++标准库，提供了编程标准的一套；这两个库实际上共享一些共同的特征和组件，最显著的是容器和迭代器。我们已经使用了标准库的组件，例如`<iostream>`用于IOStreams，`<exception>`用于异常处理，以及`<new>`用于`new()`和`delete()`运算符。在本章中，我们将探讨STL和C++标准库之间的许多重叠组件。
- en: 'The STL has a full line of **container** classes. These classes encapsulate
    traditional data structures to allow similar items to be collected together and
    uniformly processed. There are several categories of container classes – sequential,
    associative, and unordered. Let’s summarize these categories and provide a few
    examples of each:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: STL拥有一系列完整的**容器**类。这些类封装了传统的数据结构，以便将相似的项目收集在一起并统一处理。容器类分为几个类别——顺序、关联和无序。让我们总结这些类别，并给出每个类别的几个示例：
- en: '`list`, `queue`, or `stack`. It is interesting to note that `queue` and `stack`
    can be thought of as a customized or adaptive interface for a more basic container,
    such as a `list`. Nonetheless, a `queue` and `stack` still provide sequential
    access to their elements.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`、`queue`或`stack`。值得注意的是，`queue`和`stack`可以被视为对更基本容器（如`list`）的定制或自适应接口。尽管如此，`queue`和`stack`仍然提供对其元素的顺序访问。'
- en: '`set` or `map`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`或`map`。'
- en: '`unordered_set` or `unordered_map`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_set`或`unordered_map`。'
- en: In order for these container classes to be potentially used for any data type
    (and to preserve strong type checking), templates are utilized to abstract and
    genericize the data types of the collected items. In fact, we built our own container
    classes using templates in [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working
    with Templates*, including `LinkList` and `Array`, so we already have a basic
    understanding of templatized container classes!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些容器类能够用于任何数据类型（并保持强类型检查），我们使用了模板来抽象和泛化收集项的数据类型。实际上，我们在[*第13章*](B19087_13.xhtml#_idTextAnchor561)“使用模板”中使用了模板构建了自己的容器类，包括`LinkList`和`Array`，因此我们已经对模板化的容器类有了基本了解！
- en: Additionally, the STL provides a full complement of **iterators**, which allow
    us to *walk through* or traverse containers. Iterators keep track of our current
    place without corrupting the content or ordering of the respective collections
    of objects. We will see how iterators allow us to process container classes more
    safely within the STL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，STL还提供了一套完整的**迭代器**，使我们能够“遍历”或遍历容器。迭代器跟踪我们的当前位置，而不会破坏相应对象集合的内容或顺序。我们将看到迭代器如何使我们能够在STL中更安全地处理容器类。
- en: The STL also contains a plentiful supply of useful **algorithms**. Examples
    include sorting, counting the number of elements in a collection that may satisfy
    a condition, searching for particular elements or subsequences within elements,
    or copying elements in a variety of manners. Additional examples of algorithms
    include modifying a sequence of objects (replacing, swapping, and removing values),
    partitioning sets into ranges, or merging sets back together. Moreover, the STL
    contains many other useful algorithms and utilities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: STL还包含大量有用的**算法**。例如，排序、计算可能满足条件的集合中元素的数量、在元素内搜索特定元素或子序列，或以各种方式复制元素。其他算法示例包括修改对象序列（替换、交换和删除值）、将集合划分为范围，或将集合合并在一起。此外，STL还包含许多其他有用的算法和实用工具。
- en: Lastly, the STL includes functions. Actually, it would be more correct to say
    that the STL includes `operator()` (the function call operator), and by doing
    so, allow us to achieve parameterized flexibility through a function pointer.
    Though this is not an elementary feature of the STL we will immediately (or often)
    use, we will see one small, simple example of a functor in this chapter coupled
    with an STL container class, in the upcoming section *Examining STL map using
    a functor*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，STL包括函数。实际上，更准确的说法是STL包括`operator()`（函数调用运算符），通过这样做，我们可以通过函数指针实现参数化的灵活性。尽管这不是STL的初级特性，我们将在本章中看到一个与STL容器类结合的小型、简单的示例，在即将到来的部分*使用函数对象检查STL
    map*中。
- en: In this chapter, we will focus on the container class section of the STL. Though
    we won’t examine every STL container class in the STL, we will review a healthy
    assortment of these classes. We will notice that some of these container classes
    are similar to classes that we have built together in previous chapters of this
    book. Incidentally, during the incremental chapter progressions of this book,
    we have also built up our C++ language and OOP skills, which are necessary to
    decode a C++ class library such as STL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注 STL 的容器类部分。尽管我们不会检查 STL 中的每个容器类，但我们将回顾这些类中的大量内容。我们会注意到，其中一些容器类与我们在这本书的前几章中一起构建的类相似。顺便提一下，在本书的增量章节进展中，我们也构建了
    C++ 语言和 OOP 技能，这些技能是解码像 STL 这样的 C++ 类库所必需的。
- en: Let’s move forward to take a look at selective STL classes and test our C++
    knowledge as we interpret each class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看选择性的 STL 类，并在解释每个类的同时检验我们的 C++ 知识。
- en: Understanding how to use essential STL containers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何使用基本的 STL 容器
- en: In this section, we will put our C++ skills to the test by decoding various
    STL container classes. We will see that language features we have mastered, from
    core C++ syntax to OOP skills, have put us in a position to easily interpret the
    various components of STL we will now examine. Most notably, we will put our knowledge
    of templates to use! Our knowledge of encapsulation and inheritance, for example,
    will guide us to understand how to use various methods in STL classes. However,
    we will notice that virtual functions and abstract classes are extremely rare
    in the STL. The best way to gain competence with a new class within the STL will
    be to embrace the documentation detailing each class. With knowledge of C++, we
    can easily navigate through a given class to decode how to use it successfully.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过解码各种 STL 容器类来检验我们的 C++ 技能。我们将看到，从核心 C++ 语法到 OOP 技能，我们已经掌握的语言特性使我们能够轻松地解释我们现在将要检查的
    STL 的各种组件。最值得注意的是，我们将运用我们的模板知识！例如，我们的封装和继承知识将指导我们理解如何在 STL 类中使用各种方法。然而，我们会注意到，在
    STL 中虚拟函数和抽象类非常罕见。掌握 STL 中新类的能力的最佳方式是拥抱详细说明每个类的文档。有了 C++ 的知识，我们可以轻松地导航到给定的类，解码如何成功使用它。
- en: The container classes in the C++ STL implement various `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, and `map`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL 中的容器类实现了各种 `list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`
    和 `map`。
- en: Let’s begin by examining how to utilize a very basic STL container, `list`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查如何利用一个非常基本的 STL 容器 `list` 开始。
- en: Using STL list
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL list
- en: The STL `list` class encapsulates the data structures necessary to implement
    a linked list. We can say that `list` implements the Abstract Data Type of a linked
    list. Recall that we have made our own linked list by creating `LinkedListElement`
    and `LinkedList` classes in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing
    Hierarchies with Inheritance*. STL `list` allows for easy insertion, deletion,
    and sorting of elements. Direct access to individual elements (known as *random
    access*) is not supported. Rather, you must iteratively traverse past a prior
    item in the linked list until you reach the desired item. STL `list` is a good
    example of a sequential container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `list` 类封装了实现链表所需的数据结构。我们可以这样说，`list` 实现了链表的抽象数据类型。回想一下，我们在 [*第 6 章*](B19087_06.xhtml#_idTextAnchor314)，*使用继承实现层次结构*
    中通过创建 `LinkedListElement` 和 `LinkedList` 类来构建了自己的链表。STL `list` 允许轻松地插入、删除和排序元素。不支持对单个元素的直接访问（称为
    *随机访问*）。相反，你必须迭代地遍历链表中的前一个项目，直到达到所需的项目。STL `list` 是顺序容器的一个很好的例子。
- en: STL `list` actually supports bidirectional sequential access to its elements
    (it is implemented using a doubly-linked list). The STL additionally offers `forward_list`,
    allowing unidirectional sequential access to its elements with a smaller footprint
    than `list`; `forward_list` is implemented using a singly-linked list (much like
    our `LinkedList` class).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `list` 实际上支持对其元素的 bidirectional sequential access（它使用双链表实现）。STL 还提供了 `forward_list`，允许以比
    `list` 更小的内存占用对元素进行 unidirectional sequential access；`forward_list` 使用单链表实现（就像我们的
    `LinkedList` 类一样）。
- en: The STL `list` class has an assortment of member functions; we’ll start by taking
    a look at a few popular methods in this example to get familiar with basic STL
    container class usage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `list` 类有许多成员函数；我们将从这个例子中开始，看看一些流行的函数，以熟悉基本 STL 容器类的使用。
- en: 'Now, let’s take a look at how we can utilize the STL `list` class. This example
    can be found, as a full working program with necessary class definitions, in our
    GitHub as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何利用 STL `list` 类。这个例子可以在我们的 GitHub 上找到，作为一个完整的、带有必要类定义的工作程序，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s examine the aforementioned program segment, where we create and utilize
    an STL `list`. First, we `#include <list>` to include the appropriate STL header
    file. We also add `using std::list;` to include `list` from the standard namespace.
    Now, in `main()`, we can instantiate a list using `list<Student> studentBody;`.
    Our list will contain `Student` instances. Then, we create `Student s1` on the
    stack and `Student *s2` on the heap using an allocation with `new()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查上述程序段，其中我们创建并使用了一个 STL `list`。首先，我们 `#include <list>` 来包含适当的 STL 头文件。我们还添加
    `using std::list;` 以从标准命名空间包含 `list`。现在，在 `main()` 中，我们可以使用 `list<Student> studentBody;`
    实例化一个列表。我们的列表将包含 `Student` 实例。然后，我们使用 `new()` 分配在栈上创建 `Student s1` 和在堆上创建 `Student
    *s2`。
- en: Next, we use `list::push_back()` to add both `s1` and `*s2` to the list. Notice
    that we are passing objects to `push_back()`. As we add `Student` instances to
    the `studentBody` list, the list will make copies of the objects internally and
    will properly clean up these objects when they are no longer members of the list.
    We need to keep in mind that if any of our instances have been allocated on the
    heap, such as `*s2`, we must delete our copy of that instance when we are done
    with it at the end of `main()`. Looking ahead to the end of `main()`, we can see
    that we appropriately `delete s2;`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `list::push_back()` 将 `s1` 和 `*s2` 都添加到列表中。注意，我们正在将对象传递给 `push_back()`。当我们将
    `Student` 实例添加到 `studentBody` 列表中时，列表将内部复制这些对象，并在它们不再是列表的成员时适当地清理这些对象。我们需要记住，如果我们的任何实例已经在堆上分配，例如
    `*s2`，那么在 `main()` 结束时，我们必须删除该实例的副本。展望 `main()` 的结尾，我们可以看到我们适当地 `delete s2;`。
- en: Next, we add three more students to the list. These `Student` instances do not
    have local identifiers. These students are instantiated within the call to `push_back()`,
    for example, `studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++",
    "178PSU"));`. Here, we are instantiating an *anonymous (stack) object* that will
    be properly popped off the stack and destructed once the call to `push_back()`
    concludes. Keep in mind, `push_back()` will also create its own local copy for
    these instances for their life expectancy within the `list`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将另外三个学生添加到列表中。这些 `Student` 实例没有局部标识符。这些学生是在 `push_back()` 调用中实例化的，例如，`studentBody.push_back(Student("Hana",
    "Sato", 'U', "Dr.", 3.8, "C++", "178PSU"));`。在这里，我们实例化了一个 *匿名（栈）对象*，它将在 `push_back()`
    调用结束时从栈中正确弹出并销毁。请注意，`push_back()` 还将为这些实例创建它们在 `list` 中的生命周期内的本地副本。
- en: Now, in a while loop, we repeatedly check whether the list is `empty()` and
    if not, we examine the `front()` item and call our `Student::Print()` method.
    We then use `pop_front()` to remove that item from the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在一个 while 循环中，我们反复检查列表是否 `empty()`，如果不是，我们检查 `front()` 项并调用我们的 `Student::Print()`
    方法。然后我们使用 `pop_front()` 从列表中移除该项。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have deciphered a simple STL `list` class, let us move forward to
    understand the idea of an `iterator` to complement a container such as `list`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解析了一个简单的 STL `list` 类，让我们继续了解 `iterator` 的概念，以补充像 `list` 这样的容器。
- en: Using STL iterator
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL 迭代器
- en: Quite often, we will need a non-destructive way to iterate through a collection
    of objects. For example, it is important to maintain the first, last, and current
    position in a given container, especially if the set may be accessed by more than
    one method, class, or thread. Using an **iterator**, the STL provides a common
    means to traverse any container class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很频繁地，我们需要一种非破坏性的方法来遍历一组对象。例如，在给定的容器中维护第一个、最后一个和当前位置很重要，特别是如果该集合可能被多个方法、类或线程访问。使用
    **迭代器**，STL 提供了一种遍历任何容器类的通用方法。
- en: The use of iterators has definite benefits. A class can create an `iterator`
    that points to the first member in a collection. Iterators can then be moved to
    successive next members of the collection. Iterators can provide access to elements
    pointed to by the `iterator`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的使用具有明显的优势。一个类可以创建一个指向集合中第一个成员的 `iterator`。然后迭代器可以被移动到集合的后续下一个成员。迭代器可以提供对由
    `iterator` 指向的元素访问。
- en: Overall, the state information of a container can be maintained by an `iterator`.
    Iterators provide a safe means for interleaved access by abstracting the state
    information away from the container and instead into the iterator class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，一个容器的状态信息可以通过 `iterator` 维护。迭代器提供了一种安全的方法，通过将状态信息从容器抽象出来，而不是放入迭代器类中，来实现交错访问。
- en: We can think of an iterator as a bookmark within a book that two or more people
    are referencing. The first person reads the book sequentially, leaving the bookmark
    neatly where they expect to continue reading. While they step away, another person
    looks up an important item in the book and moves the bookmark to another location
    in the book to save their spot. When the first person returns, they find that
    they have lost their current location and are not where they expect to be. Each
    user should have had their own bookmark or iterator. The analogy is that an iterator
    (ideally) allows safe interleaved access to a resource that may be handled by
    multiple components within an application. Without an iterator, you may unintentionally
    modify a container without another user’s knowledge. STL iterators mostly, but
    not always, live up to this ideal goal.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将迭代器想象成一本书中的书签，两个人或更多人正在参考。第一个人按顺序阅读书籍，将书签整洁地放在他们期望继续阅读的地方。当第一个人离开时，另一个人在书中查找一个重要项目，并将书签移动到书中的另一个位置以保存他们的位置。当第一个人回来时，他们会发现自己失去了当前的位置，并不在他们期望的地方。每个用户都应该有自己的书签或迭代器。这个类比是，迭代器（理想情况下）允许安全地交错访问可能由应用程序中的多个组件处理的一个资源。如果没有迭代器，你可能会无意中修改一个容器，而其他用户并不知道。STL
    迭代器大多数情况下，但并非总是，能够达到这个理想目标。
- en: 'Let’s take a look at how we can utilize an STL `iterator`. This example can
    be found as a complete program in our GitHub as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用 STL `iterator`。这个例子可以在我们的 GitHub 上作为一个完整的程序找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s take a look at our previously defined code segment. Here, we include both
    the `<list>` and `<iterator>` headers from the STL. We also add `using std::list;`
    and `using std::iterator;` to include `list` and `iterator` from the standard
    namespace. As in our previous `main()` function, we instantiate a `list` that
    can contain `Student` instances using `list<Student> studentbody;`. We then instantiate
    several `Student` instances and add them to the list using `push_back()`. Again,
    notice that several `Student` instances are *anonymous objects*, having no local
    identifier in `main()`. These instances will be popped off the stack when `push_back()`
    completes. This is no problem, as `push_back()` will create local copies for the
    list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看之前定义的代码段。在这里，我们包含了 STL 中的 `<list>` 和 `<iterator>` 头文件。我们还添加了 `using std::list;`
    和 `using std::iterator;` 来包含标准命名空间中的 `list` 和 `iterator`。与之前的 `main()` 函数一样，我们使用
    `list<Student> studentbody;` 实例化了一个可以包含 `Student` 实例的 `list`。然后我们实例化几个 `Student`
    实例，并使用 `push_back()` 将它们添加到列表中。再次注意，几个 `Student` 实例是 *匿名对象*，在 `main()` 中没有局部标识符。这些实例将在
    `push_back()` 完成时从栈中弹出。这没有问题，因为 `push_back()` 将为列表创建局部副本。
- en: Now, we can sort the list using `studentBody.sort();`. It is important to note
    that this `list` method required us to overload `operator<` to provide a means
    of comparison between two `Student` instances. Luckily, we have! We have chosen
    to implement `operator<` by comparing `gpa`, but it could also have used `studentId`
    for comparison.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `studentBody.sort();` 对列表进行排序。需要注意的是，这个 `list` 方法要求我们重载 `operator<`
    以提供两个 `Student` 实例之间比较的方法。幸运的是，我们已经做到了！我们选择通过比较 `gpa` 来实现 `operator<`，但它也可以使用
    `studentId` 进行比较。
- en: Now that we have a `list`, we can create an `iterator` and establish it to refer
    to the first item of the `list`. We do so by declaring `list <Student>::iterator
    listIter = studentBody.begin();`. With the iterator established, we can use it
    to safely loop through the `list` from start (as it is initialized) to `end()`.
    We assign a local reference variable `temp` to the loop iteration’s current first
    element in the list with `Student &temp = *listIter;`. We then call a method on
    this instance with `temp.EarnPhD();`, and then we increment our iterator by one
    element using `++listIter;`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`list`，我们可以创建一个`iterator`并将其设置为指向`list`的第一个项目。我们通过声明`list <Student>::iterator
    listIter = studentBody.begin();`来这样做。一旦建立了迭代器，我们就可以使用它安全地从开始（因为它被初始化）到`end()`循环遍历`list`。我们通过`Student
    &temp = *listIter;`将局部引用变量`temp`赋值给列表循环迭代的当前第一个元素。然后我们通过`temp.EarnPhD();`在这个实例上调用一个方法，然后通过`++listIter;`将迭代器增加一个元素。
- en: In the subsequent loop, we simplify our declaration of the iterator using `auto`.
    The `auto` keyword allows the type of the iterator to be determined by its initial
    usage. Within this loop, we also eliminate the usage of `temp` – we simply deference
    the iterator first within parentheses and then invoke `Print()` by using `(*autoIter).Print()`.
    Using `++autoIter` simply advances to the next item in our list for processing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的循环中，我们使用 `auto` 简化了迭代器的声明。`auto` 关键字允许迭代器的类型由其初始使用确定。在这个循环中，我们还消除了对 `temp`
    的使用——我们只需在括号内取消迭代器的引用，然后使用 `(*autoIter).Print()` 调用 `Print()`。使用 `++autoIter`
    简单地前进到列表中的下一个项目以进行处理。
- en: 'Let’s take a look at the sorted output for this program (sorted by `gpa`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的排序输出（按 `gpa` 排序）：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have seen an `iterator` class in action, let’s investigate a variety
    of additional STL container classes, starting with `vector`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`iterator`类的实际应用，让我们来调查一些额外的 STL 容器类，从`vector`开始。
- en: Using STL vector
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL `vector`
- en: The STL `vector` class implements the Abstract Data Type of a dynamic array.
    Recall that we have made our own dynamic array by creating an `Array` class in
    [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*. The
    STL version, however, will be far more extensive.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `vector` 类实现了动态数组的抽象数据类型。回想一下，我们在 [*第 13 章*](B19087_13.xhtml#_idTextAnchor561)，*使用模板*
    中通过创建一个 `Array` 类来创建了自己的动态数组。然而，STL 版本将更加广泛。
- en: The `vector` (dynamic or resizable array) will expand as necessary to accommodate
    additional elements beyond its initial size. The `vector` class allows direct
    (that is, *random access*) to elements by overloading `operator[]`. A `vector`
    allows elements to be accessed in constant time through direct access. It is not
    necessary to walk past all prior elements to access an element at a specific index.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`（动态或可调整大小的数组）将根据需要扩展以容纳超出其初始大小的额外元素。`vector`类通过重载`operator[]`允许直接（即*随机访问*）访问元素。访问特定索引的元素不需要遍历所有先前元素。'
- en: However, adding elements in the middle of a `vector` is time-consuming. That
    is, adding to any location other than the end of the `vector` requires all elements
    past the insertion point to be internally shuffled; it may also require an internal
    resizing of the `vector`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`vector`的中间添加元素是耗时的。也就是说，除了在`vector`的末尾添加之外，还需要将插入点之后的所有元素在内部重新排列；这还可能需要`vector`的内部调整大小。
- en: Clearly, `list` and `vector`, by comparison, have different strengths and weaknesses.
    Each is geared to different requirements of a collection of data. We can choose
    the one that best fits our needs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，与`list`和`vector`相比，它们有不同的优点和缺点。每个都是针对数据集合的不同需求而设计的。我们可以选择最适合我们需求的一个。
- en: 'Let’s take a look at an assortment of common `vector` member functions. This
    is far from a complete list:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的`vector`成员函数。这远非一个完整的列表：
- en: '![](img/Figure_14.1_B19087.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_14.1_B19087.jpg)'
- en: The STL `vector` class additionally includes overloaded `operator=` (assignment
    replaces destination vector with source vector), `operator==` (comparison of vectors,
    element by element), and `operator[]` (returns a reference to the requested location,
    that is, writable memory).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `vector` 类还包括重载的 `operator=`（赋值用源 `vector` 替换目标 `vector`），`operator==`（逐元素比较向量），和
    `operator[]`（返回对请求位置的引用，即可写内存）。
- en: 'Let’s take a look at how we can utilize the STL `vector` class with some of
    its basic operations. This example can be found, as a full working program, in
    our GitHub as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用 STL `vector` 类及其基本操作。这个例子可以作为完整的程序在 GitHub 上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previously listed code segment, we `#include <vector>` to include the
    appropriate STL header file. We also add `using std::vector;` to include `vector`
    from the standard namespace. Now, in `main()`, we can instantiate two vectors
    using `vector<Student> studentBody1, studentBody2;`. We can then use the `vector::push_back()`
    method to add several `Student` instances in succession to our first `vector`.
    Again, notice that the `Student` instances are *anonymous objects* in `main()`.
    That is, there is no local identifier that references them – they are created
    only to be placed into our vector, which makes a local copy of each instance upon
    insertion. Once we have elements in our vector, we then loop through our first
    `vector`, printing each `Student` using `studentBody1[i].Print();`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的代码段中，我们 `#include <vector>` 以包含适当的 STL 头文件。我们还添加 `using std::vector;`
    以从标准命名空间包含 `vector`。现在，在 `main()` 中，我们可以使用 `vector<Student> studentBody1, studentBody2;`
    实例化两个向量。然后，我们可以使用 `vector::push_back()` 方法连续将几个 `Student` 实例添加到我们的第一个向量中。再次注意，`Student`
    实例在 `main()` 中是 *匿名对象*。也就是说，没有局部标识符引用它们——它们仅被创建以放入我们的向量中，在插入时为每个实例创建局部副本。一旦我们在向量中有元素，我们就遍历第一个向量，使用
    `studentBody1[i].Print();` 打印每个 `Student`。
- en: Next, we demonstrate the overloaded assignment operator for `vector` by assigning
    one vector to another using `studentBody1 = studentBody2;`. Here, we make a deep
    copy from right to left in the assignment. We can then test whether the two vectors
    are equal using the overloaded comparison operator within a conditional statement,
    that is, `if (studentBody1 == studentBody2)`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 `studentBody1 = studentBody2;` 将一个向量赋值给另一个向量来演示 `vector` 的重载赋值运算符。在这里，我们在赋值过程中从右向左进行深度复制。然后，我们可以使用条件语句中的重载比较运算符来测试两个向量是否相等，即
    `if (studentBody1 == studentBody2);`。
- en: We then apply `EarnPhD()` to the contents of the second vector in a `for` loop
    using an iterator specified with `auto iter = studentBody2.begin();`. The `auto`
    keyword allows the type of the iterator to be determined by its initial usage.
    We then print out the contents of our second vector using a preferred range-for
    loop (as well as using `auto` to simplify the variable type in the range-for loop).
    Finally, we look through our first `vector`, testing whether it is `empty()`,
    and then clear elements one by one using `studentBody1.clear();`. We have now
    seen a sampling of the `vector` methods and their capabilities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `auto iter = studentBody2.begin();` 指定的迭代器在 `for` 循环中对第二个向量的内容应用 `EarnPhD()`。`auto`
    关键字允许迭代器的类型由其初始使用确定。然后，我们使用首选的范围-for 循环（以及使用 `auto` 简化范围-for 循环中的变量类型）打印出第二个向量的内容。最后，我们检查第一个
    `vector` 是否为 `empty()`，然后使用 `studentBody1.clear();` 逐个清除元素。我们现在已经看到了 `vector`
    方法和它们的功能的样本。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, let’s investigate the STL `deque` class to further our knowledge of STL
    containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调查 STL `deque` 类，以进一步了解 STL 容器。
- en: Using STL deque
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL deque
- en: The STL `deque` class (pronounced *deck*) implements the Abstract Data Type
    of a double-ended queue. This ADT extends the notion that a queue is first in,
    first out. Instead, the `deque` class allows greater flexibility. Adding elements
    at either end of a `deque` is quick. Adding elements in the middle of a `deque`
    is time-consuming. A `deque` is a sequential container, though more flexible than
    a `list`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: STL `deque` 类（发音为 *deck*）实现了双端队列的抽象数据类型。这种 ADT 扩展了队列是先进先出的概念。相反，`deque` 类提供了更大的灵活性。在
    `deque` 的两端添加元素是快速的。在 `deque` 的中间添加元素是耗时的。`deque` 是一个顺序容器，尽管比列表更灵活。
- en: You might imagine that a `deque` is a specialization of a `queue`; it is not.
    Instead, the flexible `deque` class will serve as a basis to implement other container
    classes, which we will see shortly. In these cases, private inheritance will allow
    us to conceal `deque` as an underlying implementation (with vast functionality)
    for more restrictive, specialized classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象`deque`是`queue`的一个特殊化；它不是。相反，灵活的`deque`类将作为实现其他容器类的基础，我们很快就会看到。在这些情况下，私有继承将允许我们隐藏`deque`作为底层实现（具有广泛的功能）以供更限制性、特殊化的类使用。
- en: 'Let’s take a look at an assortment of common `deque` member functions. This
    is far from a complete list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的`deque`成员函数。这远非一个完整的列表：
- en: '![](img/Figure_14.2_B19087.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_14.2_B19087.jpg)'
- en: The STL `deque` class additionally includes overloaded `operator=` (assignment
    of the source to destination deque) and `operator[]` (returns a reference to requested
    location – writable memory).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`deque`类还包括重载的`operator=`（源到目标`deque`的赋值）和`operator[]`（返回请求位置的引用——可写内存）。
- en: 'Let’s take a look at how we can utilize the STL `deque` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用STL的`deque`类。这个例子作为一个完整的程序可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previously listed code segment, we `#include <deque>` to include the
    appropriate STL header file. We also add `using std::deque;` to include `deque`
    from the standard namespace. Now, in `main()`, we can instantiate a `deque` to
    contain `Student` instances using `deque<Student> studentBody;`. We then call
    either `deque::push_back()` or `deque::push_front()` to add several `Student`
    instances (some anonymous objects) to our `deque`. We are getting the hang of
    this! Now, we insert a `Student` one position past the front of our deque using
    `studentBody.insert(std::next(studentBody.begin()), Student("Anne", "Brennan",
    'B', "Ms.", 3.9, "C++", "299CU"));`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的代码段中，我们`#include <deque>`来包含适当的STL头文件。我们还添加了`using std::deque;`来从标准命名空间包含`deque`。现在，在`main()`中，我们可以实例化一个`deque`来包含`Student`实例，使用`deque<Student>
    studentBody;`。然后我们调用`deque::push_back()`或`deque::push_front()`来向我们的`deque`添加几个`Student`实例（一些匿名对象）。我们正在掌握这个！现在，我们使用`studentBody.insert(std::next(studentBody.begin()),
    Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));`在`deque`的前端之后插入一个`Student`。
- en: Next, we take advantage of overloaded `operator[]` to insert a `Student` into
    our deque using `studentBody[0] = s1;`. Please be warned that `operator[]` does
    not do any bounds checking on our deque! In this statement, we insert `Student`
    `s1` into the 0th position in the `deque`, instead of the `Student` that once
    occupied that position. A safer bet is to use the `deque::at()` method, which
    will incorporate bounds checking. Regarding the aforementioned assignment, we
    also want to ensure that `operator=` has been overloaded for both `Person` and
    `Student`, as each class has dynamically allocated data members.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们利用重载的`operator[]`将一个`Student`插入到我们的`deque`中，使用`studentBody[0] = s1;`。请务必注意，`operator[]`对我们的`deque`不进行任何边界检查！在这个语句中，我们将`Student`
    `s1`插入到`deque`的第0个位置，而不是曾经占据那个位置的`Student`。一个更安全的做法是使用`deque::at()`方法，它将包含边界检查。关于上述赋值，我们还想确保`operator=`已经为`Person`和`Student`两个类重载，因为每个类都有动态分配的数据成员。
- en: Now, we loop through until our `deque` is `empty()`, extracting and printing
    the front element of the deque using `studentBody.front().Print();`. With each
    iteration, we also pop the front item from our `deque` using `studentBody.pop_front();`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们循环直到我们的`deque`为`empty()`，使用`studentBody.front().Print();`提取并打印`deque`的前端元素。在每次迭代中，我们也会使用`studentBody.pop_front();`从`deque`中弹出前端的项目。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a feel for a `deque`, let’s next investigate the STL `stack`
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对`deque`有了感觉，接下来让我们研究一下STL的`stack`类。
- en: Using STL stack
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL栈
- en: The STL `stack` class implements the Abstract Data Type of a stack. The stack
    ADT supports the `stack` includes a public interface that does not advertise its
    underlying implementation. After all, a stack might change its implementation;
    the ADTs usage should not depend in any manner on its underlying implementation.
    The STL `stack` is considered an adaptive interface of a basic sequential container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `stack` 类实现了栈的抽象数据类型。栈 ADT 包含一个公共接口，该接口不公开其底层实现。毕竟，栈可能会更改其实现；ADT 的使用不应以任何方式依赖于其底层实现。STL
    的 `stack` 被视为基本顺序容器的自适应接口。
- en: Recall that we have made our own `Stack` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*, using a private base class of `LinkedList`.
    The STL version will be more extensive; interestingly, it is implemented using
    `deque` as its underlying private base class. With `deque` as a private base class
    of the STL `stack`, the more versatile underlying capabilities of `deque` are
    hidden; only the applicable methods are used to implement the stack’s public interface.
    Also, because the means of implementation is hidden, a `stack` may be implemented
    using another container class at a later date without impacting its usage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在 [*第 6 章*](B19087_06.xhtml#_idTextAnchor314)，*使用继承实现层次结构* 中创建了自己的 `Stack`
    类，使用 `LinkedList` 作为私有基类。STL 版本将更加丰富；有趣的是，它使用 `deque` 作为其底层的私有基类。由于 `deque` 是
    STL `stack` 的私有基类，`deque` 的更多通用底层能力被隐藏；只使用适用的方法来实现栈的公共接口。此外，由于实现方式被隐藏，`stack`
    可以在以后使用另一个容器类实现，而不会影响其使用。
- en: 'Let’s take a look at an assortment of common `stack` member functions. This
    is far from a complete list. It is important to note that the public interface
    for `stack` is far smaller than that of its private base class, `deque`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的 `stack` 成员函数。这远非一个完整的列表。重要的是要注意，`stack` 的公共接口远小于其私有基类 `deque` 的接口：
- en: '![](img/Figure_14.3_B19087.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.3_B19087.jpg)'
- en: The STL `stack` class additionally includes overloaded `operator=` (assignment
    of source to destination stack), `operator==` and `operator!=` (equality/inequality
    of two stacks), and `operator<` , `operator>`, `operator<=`, and `operator>=`
    (comparison of stacks).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `stack` 类还包括重载的 `operator=`（源栈到目标栈的赋值）、`operator==` 和 `operator!=`（两个栈的相等/不等）、以及
    `operator<`、`operator>`、`operator<=` 和 `operator>=`（栈的比较）。
- en: 'Let’s take a look at how we can utilize the STL `stack` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用 STL 的 `stack` 类。这个例子可以作为完整的工作程序在我们的 GitHub 上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp)'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned code segment, we `#include <stack>` to include the appropriate
    STL header file. We also add `using std::stack;` to include `stack` from the standard
    namespace. Now, in `main()`, we can instantiate a `stack` to contain `Student`
    instances using `stack<Student> studentBody;`. We then call `stack::push()` to
    add several `Student` instances to our `stack`. Notice that we are using the traditional
    `push()` method, which contributes to the ADT of a stack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码段中，我们 `#include <stack>` 包含适当的 STL 头文件。我们还添加 `using std::stack;` 来包含标准命名空间中的
    `stack`。现在，在 `main()` 中，我们可以使用 `stack<Student> studentBody;` 实例化一个 `stack` 来包含
    `Student` 实例。然后，我们调用 `stack::push()` 向我们的 `stack` 添加几个 `Student` 实例。注意，我们正在使用传统的
    `push()` 方法，这有助于栈的 ADT。
- en: We then loop through our `stack` while it is not `empty()`. Our goal is to access
    and print the top element using `studentBody.top().Print();`. We then neatly pop
    our top element off the stack using `studentBody.pop();`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `stack` 不为 `empty()` 时循环遍历。我们的目标是使用 `studentBody.top().Print();` 访问并打印栈顶元素。然后，我们使用
    `studentBody.pop();` 整洁地弹出栈顶元素。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, let’s investigate the STL `queue` class to further increase our STL container
    repertoire.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们研究 STL 的 `queue` 类，以进一步丰富我们的 STL 容器系列。
- en: Using STL queue
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL 队列
- en: The STL `queue` class implements the ADT of a queue. As the stereotypical queue
    class, STL’s `queue` class supports the **first in, first out** (**FIFO**) order
    of insertion and removal of members.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`queue`类实现了队列ADT。作为典型的队列类，STL的`queue`类支持成员插入和删除的**先进先出**（**FIFO**）顺序。
- en: Recall that we made our own `Queue` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*; we derived our `Queue` from our `LinkedList`
    class using private inheritance. The STL version will be more extensive; the STL
    `queue` class is implemented using `deque` as its underlying implementation (also
    using private inheritance). Remember, because the means of implementation are
    hidden with private inheritance, a `queue` may be implemented using another data
    type at a later date without impacting its public interface. The STL `queue` class
    is another example of an adaptive interface for a basic sequential container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在[*第6章*](B19087_06.xhtml#_idTextAnchor314)中自己实现了`Queue`类，*使用继承实现层次结构*；我们使用私有继承从`LinkedList`类派生我们的`Queue`。STL版本将更加丰富；STL的`queue`类使用`deque`作为其底层实现（也使用私有继承）。记住，由于实现方式通过私有继承被隐藏，`queue`可以在以后使用其他数据类型实现，而不会影响其公共接口。STL的`queue`类是基本顺序容器的一个自适应接口的另一个例子。
- en: 'Let’s take a look at an assortment of common `queue` member functions. This
    is far from a complete list. It is important to note that the public interface
    of `queue` is far smaller than that of its private base class, `deque`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的`queue`成员函数。这远非一个完整的列表。重要的是要注意，`queue`的公共接口远小于其私有基类`deque`的接口：
- en: '![](img/Figure_14.4_B19087.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_14.4_B19087.jpg)'
- en: The STL `queue` class additionally includes overloaded `operator=` (assignment
    of source to destination queue), `operator==` and `operator!=` (equality/inequality
    of two queues), and `operator<` , `operator>`, `operator<=`, and `operator>=`
    (comparison of queues).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`queue`类还包括重载的`operator=`（源队列到目标队列的赋值），`operator==`和`operator!=`（两个队列的相等/不等），以及`operator<`，`operator>`，`operator<=`和`operator>=`（队列的比较）。
- en: 'Let’s take a look at how we can utilize the STL `queue` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用STL的`queue`类。这个例子可以作为完整的工作程序在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp)'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code segment, we first `#include <queue>` to include the appropriate
    STL header file. We also add `using std::queue;` to include `queue` from the standard
    namespace. Now, in `main()`, we can instantiate a `queue` to contain `Student`
    instances using `queue<Student> studentBody;`. We then call `queue::push()` to
    add several `Student` instances to our `queue`. Recall that with the queue ADT,
    `push()` implies that we are adding an element at the end of the queue. Some programmers
    prefer the term *enqueue* to describe this operation; however, the STL has selected
    to name this operation `push()`. With the `queue` ADT, `pop()` will remove an
    item from the front of the queue; a better term is *dequeue*, however, that is
    not what the STL has chosen. We can adapt.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们首先`#include <queue>`来包含适当的STL头文件。我们还添加了`using std::queue;`以从标准命名空间中包含`queue`。现在，在`main()`中，我们可以使用`queue<Student>
    studentBody;`来实例化一个`queue`以包含`Student`实例。然后我们调用`queue::push()`来将几个`Student`实例添加到我们的`queue`中。回想一下，在队列ADT中，`push()`意味着我们在队列的末尾添加一个元素。一些程序员更喜欢使用术语*enqueue*来描述这个操作；然而，STL选择了将此操作命名为`push()`。在队列ADT中，`pop()`将从队列的前端移除一个项目；一个更好的术语是*dequeue*，但STL并没有选择这个术语。我们可以适应。
- en: We then loop through our `queue` while it is not `empty()`. Our goal is to access
    and print the front element using `studentBody.front().Print();`. We then neatly
    pop our front element off the `queue` using `studentBody.pop();`. Our work is
    complete.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`queue`不为`empty()`时循环遍历。我们的目标是使用`studentBody.front().Print();`访问并打印前端的元素。然后我们使用`studentBody.pop();`整洁地从`queue`中移除前端元素。我们的工作就完成了。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have tried a `queue`, let’s investigate the STL `priority_queue`
    class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了`queue`，让我们来调查STL的`priority_queue`类。
- en: Using STL priority queue
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL优先队列
- en: The STL `priority_queue` class implements the Abstract Data Type of a priority
    queue. The priority queue ADT supports a modified FIFO order of insertion and
    removal of members; the elements are *weighted*. The front element is of the largest
    value (determined by overloaded `operator<`) and the rest of the elements follow
    in sequence from the next greatest to the least. The STL `priority_queue` class
    is considered an adaptive interface for a sequential container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`priority_queue`类实现了优先队列的抽象数据类型。优先队列ADT支持修改后的FIFO插入和删除成员的顺序；元素是*加权*的。最前面的元素是最大值（由重载的`operator<`确定）并且其余元素按照从大到小的顺序依次排列。STL的`priority_queue`类被认为是顺序容器的自适应接口。
- en: 'Recall that we implemented our own `PriorityQueue` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*. We used public inheritance to allow
    our `PriorityQueue` to specialize our `Queue` class, adding additional methods
    to support the priority (weighted) enqueuing scheme. The underlying implementation
    of `Queue` (with private base class `LinkedList`) was hidden. By using public
    inheritance, we allowed our `PriorityQueue` to be able to be generalized as a
    `Queue` through upcasting (which we understood once we learned about polymorphism
    and virtual functions in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing
    Dynamic Binding through Polymorphism*). We made an acceptable design choice: *PriorityQueue
    Is-A* (specialization of) *Queue* and at times may be treated in its more general
    form. We also recall that neither a `Queue` nor a `PriorityQueue` could be upcast
    to their underlying implementation of a `LinkedList`, as `Queue` was derived privately
    from `LinkedList`; we cannot upcast past a non-public inheritance boundary.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在[*第6章*](B19087_06.xhtml#_idTextAnchor314)，*通过继承实现层次结构*中实现了自己的`PriorityQueue`类。我们使用公有继承来允许我们的`PriorityQueue`专门化我们的`Queue`类，添加额外的支持优先级（加权）入队方案的方法。`Queue`的底层实现（带有私有基类`LinkedList`）是隐藏的。通过使用公有继承，我们允许我们的`PriorityQueue`能够通过向上转型（在我们学习了[*第7章*](B19087_07.xhtml#_idTextAnchor366)，*通过多态利用动态绑定）后作为`Queue`使用。我们做出了一个可接受的设计选择：*PriorityQueue
    Is-A*（专门化）*Queue*，有时可以以更通用的形式处理。我们还回忆起，`Queue`和`PriorityQueue`都不能向上转型到其底层实现`LinkedList`，因为`Queue`是私有地从`LinkedList`派生的；我们不能越过非公有继承边界进行向上转型。
- en: Contrastingly, the STL version of `priority_queue` is implemented using the
    STL `vector` as its underlying implementation. Recall that because the means of
    implementation is hidden, a `priority_queue` may be implemented using another
    data type at a later date without impacting its public interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，STL版本的`priority_queue`使用STL的`vector`作为其底层实现。回想一下，由于实现方式是隐藏的，`priority_queue`可能在以后使用其他数据类型实现，而不会影响其公共接口。
- en: An STL `priority_queue` allows an inspection, but not a modification, of the
    top element. The STL `priority_queue` does not allow insertion through its elements.
    That is, elements may only be added resulting in an order from greatest to least.
    Accordingly, the top element may be inspected, and the top element may be removed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`priority_queue`允许检查，但不允许修改，最顶端的元素。STL的`priority_queue`不允许通过其元素进行插入。也就是说，只能添加元素以产生从大到小的顺序。因此，可以检查最顶端的元素，并且可以移除最顶端的元素。
- en: 'Let’s take a look at an assortment of common `priority_queue` member functions.
    This is not a complete list. It is important to note that the public interface
    of `priority_queue` is far smaller than that of its private base class, `vector`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的`priority_queue`成员函数。这不是一个完整的列表。重要的是要注意，`priority_queue`的公共接口远小于其私有基类`vector`：
- en: '![](img/Figure_14.5_B19087.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_14.5_B19087.jpg)'
- en: Unlike the previously examined container classes, the STL `priority_queue` does
    not overload operators, including `operator=`, `operator==`, and `operator<`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前检查的容器类不同，STL的`priority_queue`没有重载运算符，包括`operator=`, `operator==`, 和 `operator<`。
- en: The most interesting method of `priority_queue` is that of `void emplace(args);`.
    This is the member function that allows the priority enqueuing mechanism to add
    items to this ADT. We also notice that `top()` must be used to return the top
    element (versus `front()`, which a `queue` utilizes). But then again, an STL `priority_queue`
    is not implemented using a `queue`). To utilize `priority_queue`, we `#include
    <queue>`, just as we would for a `queue`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority_queue` 最有趣的方法是 `void emplace(args);`。这是允许优先级入队机制向此 ADT 添加项的成员函数。我们还注意到必须使用
    `top()` 来返回顶部元素（与 `queue` 使用的 `front()` 相比）。但是，STL 的 `priority_queue` 并不是使用 `queue`
    实现的。要利用 `priority_queue`，我们需要 `#include <queue>`，就像我们为 `queue` 做的那样。'
- en: Because the usage of `priority_queue` is so similar to `queue`, we will instead
    explore it further, programming-wise, in our question set at the end of this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `priority_queue` 的使用与 `queue` 非常相似，因此我们将在本章末尾的问题集中进一步探讨其编程方面的应用。
- en: Now that we have seen many examples of sequential container types in STL (including
    adaptive interfaces), let’s next investigate the STL `map` class, an associative
    container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了许多 STL 中的顺序容器类型示例（包括自适应接口），接下来让我们研究 STL 的 `map` 类，这是一个关联容器。
- en: Examining STL map
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 STL `map`
- en: The STL `map` class implements the Abstract Data Type of a hash table. The class
    `map` allows for elements in the hash table or map to be stored and retrieved
    quickly using a `multimap` can be used instead should there be more than one piece
    of data that needs to be associated with a single key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `map` 类实现了哈希表的抽象数据类型。`map` 类允许在哈希表或映射中快速存储和检索元素。如果需要将多个数据项与单个键关联起来，可以使用
    `multimap`。
- en: Hash tables (maps) are fast for storage and lookup of data. The performance
    is a guaranteed *O(log(n))*. The STL `map` is considered an associative container,
    as it associates a key to a value to quickly retrieve a value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表（映射）在存储和查找数据方面非常快。性能保证为 *O(log(n))*。STL 的 `map` 被视为关联容器，因为它将键与值关联起来，以便快速检索值。
- en: 'Let’s take a look at an assortment of common `map` member functions. This is
    not a complete list:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的 `map` 成员函数。这不是一个完整的列表：
- en: '![](img/Figure_14.6_B19087.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_14.6_B19087.jpg)'
- en: The STL class map additionally includes overloaded operator `operator==` (comparison
    of maps, element by element) implemented as a global function. STL map also includes
    overloaded `operator[]` (returns a reference to the map element associated with
    a key that is used as an index; this is writable memory).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: STL 类 `map` 还包括重载的运算符 `operator==`（逐元素比较映射）作为全局函数实现。STL `map` 还包括重载的 `operator[]`（返回与用作索引的键关联的映射元素引用；这是可写内存）。
- en: 'Let’s take a look at how we can utilize the STL `map` class. This example can
    be found, as a full working program, in our GitHub as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用 STL 的 `map` 类。这个示例可以作为完整的可工作程序在我们的 GitHub 上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp)'
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s examine the preceding code segments. Again, we include the applicable
    header file with `#include <map>`. We also add `using std::map;` and `using std::pair;`
    to include `map` and `pair` from the standard namespace. Next, we instantiate
    four `Student` instances. Next, we create three `pair` instances to associate
    a grouping between each Student and its key (that is, with their respective `studentId`)
    using the declaration `pair<string, Student> studentPair1 (s1.GetStudentId(),
    s1);`. This may seem confusing to read, but let’s break this declaration down
    into its components. Here, the instance’s data type is `pair<string, Student>`,
    the variable name is `studentPair1`, and `(s1.GetStudentId(), s1)` are the arguments
    passed to the specific `pair` instance’s constructor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码段。同样，我们包含适用的头文件 `#include <map>`。我们还添加了 `using std::map;` 和 `using
    std::pair;` 以包含标准命名空间中的 `map` 和 `pair`。接下来，我们创建了四个 `Student` 实例。然后，我们创建了三个 `pair`
    实例，用于将每个学生与其键（即他们的相应 `studentId`）关联起来，使用声明 `pair<string, Student> studentPair1
    (s1.GetStudentId(), s1);`。这可能会让人感到困惑，但让我们把这个声明分解成其组成部分。在这里，实例的数据类型是 `pair<string,
    Student>`，变量名是 `studentPair1`，`(s1.GetStudentId(), s1)` 是传递给特定 `pair` 实例构造函数的参数。
- en: We will be making a hash table (`map`) of `Student` instances to be indexed
    by a key (which is their `studentId`). Next, we declare a `map` to hold the collection
    of `Student` instances with `map<string, Student> studentBody;`. Here, we indicate
    that the association between the key and element will be between a `string` and
    a `Student`. We then declare a map iterator with `map<string, Student>::iterator
    mapIter;` using the same data types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个以键（即他们的 `studentId`）为索引的 `Student` 实例的哈希表（`map`）。接下来，我们声明一个 `map` 来存储
    `Student` 实例的集合，使用 `map<string, Student> studentBody;`。在这里，我们表明键和元素之间的关联将是一个 `string`
    和一个 `Student`。然后，我们使用相同的数据类型声明一个 map 迭代器 `map<string, Student>::iterator mapIter;`。
- en: 'Now, we simply insert the three `pair` instances into the `map`. An example
    of this insertion is `studentBody.insert(studentPair1);`. We then insert a fourth
    `Student`, `s4`, into the `map` using the map’s overloaded `operator[]` with the
    following statement: `studentBody[s4.GetStudentId()] = s4;`. Notice that the `studentId`
    is used as the index value in `operator[]`; this value will become the key value
    for the `Student` in the hash table.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将三个 `pair` 实例插入到 `map` 中。例如，`studentBody.insert(studentPair1);` 就是一个这样的插入操作。然后，我们使用
    `map` 的重载 `operator[]` 将第四个 `Student`，`s4`，插入到 `map` 中，如下所示：`studentBody[s4.GetStudentId()]
    = s4;`。请注意，`studentId` 被用作 `operator[]` 中的索引值；这个值将成为哈希表中 `Student` 的键值。
- en: Next, we declare and establish the map iterator to the beginning of the `map`
    and then process the `map` while it is not at the `end()`. Within the loop, we
    set a variable, `temp`, to the `pair` at the front of the map, indicated by the
    map iterator. We also set `tempS` as a temporary reference to a `Student` in the
    `map`, which is indicated by `temp.second` (the second value in the current `pair`
    managed by the map iterator). We now can print out each `Student` instance’s `studentId`
    (the key, which is a `string`) using `temp.first` (the first item in the current
    `pair`). In the same statement, we can then print out each `Student` instance’s
    `firstName` using `temp.second.GetFirstName()` (since the `Student` corresponding
    to the key is the second item in the current `pair`). Similarly, we could also
    use `tempS.GetLastName()` to print a student’s `lastName`, as `tempS` was previously
    initialized to the second element in the current `pair` at the beginning of each
    loop iteration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明并设置 map 迭代器到 `map` 的开始处，然后处理 `map`，直到它到达 `end()`。在循环中，我们将一个变量 `temp`
    设置为地图前端的 `pair`，由地图迭代器指示。我们还设置 `tempS` 作为 `map` 中一个 `Student` 的临时引用，由 `temp.second`（当前由地图迭代器管理的
    `pair` 中的第二个值）指示。现在我们可以使用 `temp.first`（当前 `pair` 中的第一个项目）打印出每个 `Student` 实例的 `studentId`（键，它是一个
    `string`）。在同一个语句中，我们可以使用 `temp.second.GetFirstName()` 打印出每个 `Student` 实例的 `firstName`（因为与键对应的
    `Student` 是当前 `pair` 中的第二个项目）。同样，我们也可以使用 `tempS.GetLastName()` 打印一个学生的 `lastName`，因为
    `tempS` 在每次循环迭代的开始时被初始化为当前 `pair` 中的第二个元素。
- en: Finally, as an alternative to the more tedious approach demonstrated previously
    used to iterate through the `map` (taking apart the `pair` manually), let’s examine
    the final loop in our program. Here, we utilize a range-for loop to process the
    `map`. The use of `auto` with `&[id, student]` will specify the type of data that
    we will iterate. The brackets (`[]`) will decompose the `pair`, binding the iterative
    elements to `id` and `student`, respectively, as identifiers. Notice the ease
    at which we can now iterate over the `studentBody` map.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为之前演示的更繁琐的通过 `map` 迭代的方法的替代方案，让我们检查程序中的最后一个循环。在这里，我们使用范围-for 循环来处理 `map`。使用
    `auto` 与 `&[id, student]` 将指定我们将迭代的类型数据。括号（`[]`）将分解 `pair`，将迭代元素分别绑定到 `id` 和 `student`
    作为标识符。注意我们现在迭代 `studentBody` map 的简便性。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let’s take a look at an alternative with an STL `map`, which will introduce
    us to the STL `functor` concept.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 STL `map` 的一个替代方案，这将介绍我们到 STL `functor` 概念。
- en: Examining STL map using a functor
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数对象检查 STL map
- en: The STL `map` class has great flexibility, like many STL classes. In our past
    `map` example, we assumed that a means for comparison was present in our `Student`
    class. We had, after all, overloaded `operator<` for two `Student` instances.
    What happens, however, if we cannot revise a class that has not provided this
    overloaded operator and we also choose not to overload `operator<` as an external
    function?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `map` 类具有很大的灵活性，就像许多 STL 类一样。在我们之前的 `map` 示例中，我们假设 `Student` 类中存在一种比较方法。毕竟，我们已经为两个
    `Student` 实例重载了 `operator<`。然而，如果我们不能修改一个没有提供这个重载操作符的类，并且我们也不选择将 `operator<` 作为外部函数重载，会发生什么呢？
- en: Fortunately, we may specify a third data type for the template type expansion
    when instantiating a `map` or map iterator. This additional data type will be
    a specific type of class, known as a functor. A `operator()`. It is within overloaded
    `operator()` that we will provide a means of comparison for the objects in question.
    A functor essentially simulates encapsulating a function pointer by overloading
    `operator()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在实例化 `map` 或 map 迭代器时，我们可以指定一个第三种数据类型用于模板类型扩展。这种额外的数据类型将是一种特定的类，称为函数对象。一个
    `operator()`。正是在重载的 `operator()` 中，我们将提供对相关对象的比较方法。函数对象本质上通过重载 `operator()` 来模拟封装函数指针。
- en: 'Let’s take a look at how we might revise our `map` example to utilize a simple
    functor. This example can be found, as a full working program, in our GitHub as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何修改我们的 `map` 示例以利用一个简单的函数对象。这个例子可以作为完整的程序在 GitHub 上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp)'
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previously mentioned code fragment, we first introduce a user defined
    type of `comparison`. This can be a `class` or a `struct`. Within this structure
    definition, we have overloaded the function call operator (`operator()`) and provided
    a means of comparison between two `string` keys for `Student` instances. This
    comparison will allow `Student` instances to be inserted in an order determined
    by the comparison functor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的代码片段中，我们首先引入了一个用户定义的 `comparison` 类型。这可以是一个 `class` 或 `struct`。在这个结构定义中，我们重载了函数调用操作符
    (`operator()`)，并为 `Student` 实例的两个 `string` 键提供了一个比较方法。这种比较将允许 `Student` 实例按照比较函数对象的顺序插入。
- en: Now, when we instantiate our `map` and map iterators, we specify as the third
    parameter for the template type expansion our `comparison` type (the functor).
    And, neatly embedded within this type is the overloaded function call operator,
    `operator()`, which will provide our needed comparison. The remaining code will
    be similar to our original `map` program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们实例化我们的 `map` 和 map 迭代器时，我们将模板类型扩展的第三个参数指定为我们的 `comparison` 类型（函数对象）。并且，在这个类型中巧妙地嵌入了一个重载的函数调用操作符
    `operator()`，它将提供所需的比较。剩余的代码将与我们的原始 `map` 程序类似。
- en: Certainly, functors may be used in additional, more advanced ways beyond what
    we have seen here with the container class `map`. Nonetheless, you now have a
    flavor for how a functor can apply to the STL.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数对象可以以比我们在这里看到的容器类 `map` 更多的方式使用，更高级的方式。不过，你现在已经对函数对象如何应用于 STL 有了一定的了解。
- en: Now that we have seen how to utilize a variety of STL container classes, let’s
    consider why we may want to customize an STL class, and how to do so.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何利用各种 STL 容器类，让我们考虑为什么我们可能想要自定义一个 STL 类，以及如何做到这一点。
- en: Customizing STL containers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 STL 容器
- en: Most classes in C++ can be customized in some fashion, including classes in
    the STL. However, we must be aware of design decisions made within the STL that
    will limit how we may customize these components. Because the STL container classes
    purposely do not include virtual destructors or other virtual functions, we should
    not use specialization via public inheritance to extend these classes. Note that
    C++ will not stop us, but we know from [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366),
    *Using Dynamic Binding through Polymorphism*, that we should never override non-virtual
    functions. STL’s choice to not include virtual destructors and other virtual functions
    to allow further specialization of these classes was a solid design choice made
    long ago when STL containers were crafted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数C++类都可以以某种方式自定义，包括STL中的类。然而，我们必须意识到STL内部做出的设计决策，这些决策将限制我们如何自定义这些组件。因为STL容器类故意不包含虚析构函数或其他虚函数，所以我们不应该通过公有继承来对这些类进行特殊化。请注意，C++不会阻止我们这样做，但我们从[*第7章*](B19087_07.xhtml#_idTextAnchor366)，*通过多态使用动态绑定*中了解到，我们永远不应该重写非虚函数。STL选择不包含虚析构函数和其他虚函数，以允许对这些类进行进一步的特殊化，这是很久以前在STL容器被设计时做出的一个稳健的设计选择。
- en: We could, however, use private or protected inheritance, or the concepts of
    containment or association to use an STL container class as a building block.
    That is, to hide the underlying implementation of a new class, where the STL provides
    a solid, yet hidden implementation for the new class. We would simply provide
    our own public interface for the new class and, under the hood, delegate the work
    to our underlying implementation (whether that be a private or protected base
    class, or a contained or associated object).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用私有或保护继承，或者使用包含或关联的概念，将STL容器类作为构建块来使用。也就是说，为了隐藏新类的底层实现，其中STL为新类提供了一个稳健且隐藏的实现。我们只需为新类提供一个自己的公共接口，并在幕后将工作委托给我们的底层实现（无论是私有或保护基类，还是包含或关联的对象）。
- en: Extreme care and caution must be taken when extending any template class, including
    those in the STL using private or protected base classes. This caution will also
    apply to containing or associating to other template classes. Template classes
    are generally not compiled (or syntax checked) until an instance of the template
    class with a specific type is created. This means that any derived or wrapper
    classes that are created can only be fully tested when instances of specific types
    are created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展任何模板类时，包括使用私有或保护基类的STL中的模板类，必须非常小心和谨慎。这种谨慎也适用于包含或关联到其他模板类。模板类通常只有在创建了具有特定类型的模板类实例之后才会编译（或进行语法检查）。这意味着创建的任何派生或包装类只能在创建了特定类型的实例后才能完全测试。
- en: Appropriate overloaded operators will need to be put in place for new classes
    so that these operators will work automatically with customized types. Keep in
    mind that some operator functions, such as `operator=`, are not explicitly inherited
    from base to derived class and need to be written with each new class. This is
    appropriate since derived classes will likely have more work to accomplish than
    found in the generalized versions of `operator=`. Remember, if you cannot modify
    the class definition of a class requiring a selected overloaded operator, you
    must implement that operator function as an external function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新类，需要放置适当的重载运算符，以便这些运算符可以自动与自定义类型一起工作。请记住，某些运算符函数，如`operator=`，并不是从基类显式继承到派生类的，并且需要为每个新类编写。这是合适的，因为派生类可能需要完成比`operator=`的通用版本更多的工作。记住，如果你不能修改需要选择重载运算符的类的定义，你必须将该运算符函数实现为一个外部函数。
- en: In addition to customizing containers, we may also choose to augment an algorithm
    based on an existing algorithm within the STL. In this case, we would use one
    of the many STL functions as part of a new algorithm’s underlying implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自定义容器外，我们还可以选择增强STL中现有算法的算法。在这种情况下，我们会使用许多STL函数之一作为新算法底层实现的一部分。
- en: Customizing classes from existing libraries comes up routinely in programming.
    For example, consider how we extended the Standard Library `exception` class to
    create customized exceptions in [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions* (though that scenario utilized public inheritance, which
    will not apply to customizing STL classes). Keep in mind that the STL offers a
    very full complement of container classes. Rarely will you find the need to augment
    STL classes – perhaps only with a very domain-specific class need. Nonetheless,
    you now know the caveats involved in customizing STL classes. Remember, care and
    caution must always be used when augmenting a class. We can now see the need to
    employ proper OO component testing for any classes we create.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，从现有库中定制类是常见的。例如，考虑我们如何在[*第 11 章*](B19087_11.xhtml#_idTextAnchor488)“处理异常”中扩展标准库
    `exception` 类以创建自定义异常（尽管该场景使用了公有继承，这不会应用于自定义 STL 类）。记住，STL 提供了一套非常完整的容器类。你很少需要增强
    STL 类——可能只有针对特定领域需求的类。然而，你现在知道定制 STL 类所涉及的风险。记住，在增强类时必须小心谨慎。我们现在可以看到，为任何我们创建的类进行适当的面向对象组件测试是必要的。
- en: We have now considered how to potentially customize STL container classes and
    algorithms within our programs. We have also seen quite a few STL container class
    examples in action. Let us now briefly recap these concepts before moving forward
    to our next chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了如何在我们的程序中自定义 STL 容器类和算法。我们也看到了许多 STL 容器类的实际应用示例。现在，在进入下一章之前，让我们简要回顾这些概念。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have furthered our C++ knowledge beyond OOP language features
    to gain familiarity with the C++ Standard Template Library. As this library is
    used so commonly in C++, it is essential that we understand both the scope and
    breadth of the classes it contains. We are now prepared to utilize these useful,
    well-tested classes in our code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将 C++ 知识扩展到面向对象语言特性之外，以熟悉 C++ 标准模板库。由于这个库在 C++ 中使用非常普遍，因此了解它包含的类的范围和广度至关重要。我们现在准备在我们的代码中使用这些有用且经过良好测试的类。
- en: We have looked at quite a few STL examples; by examining selective STL classes,
    we should feel empowered to understand the remainder of the STL (or any C++ library)
    on our own.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了相当多的 STL 示例；通过检查选定的 STL 类，我们应该能够独立理解 STL 的其余部分（或任何 C++ 库）。
- en: We have seen how to use common and essential STL classes such as `list`, `iterator`,
    `vector`, `deque`, `stack`, `queue`, `priority_queue`, and `map`. We have also
    seen how to utilize a functor in conjunction with a container class. We have been
    reminded that we now have the tools to potentially customize any class, even those
    from class libraries such as STL through private or protected inheritance, or
    with containment or association.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用常见的和基本的 STL 类，如 `list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`
    和 `map`。我们还看到了如何结合容器类使用函数对象。我们被提醒，我们现在有工具可以定制任何类，甚至可以通过私有或保护继承，或者通过包含或关联来定制来自类库（如
    STL）的类。
- en: We have additionally seen through examining selected STL classes that we have
    the skills to understand the remaining depth and breadth of the STL, as well as
    decode many additional class libraries that are available to us. As we navigate
    the prototypes of each member function, we notice key language concepts, such
    as the use of `const`, or that a method returns a reference to an object representing
    writable memory. Each prototype reveals the mechanics for the usage of the new
    class. It is very exciting to have come this far with our programming endeavors!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查选定的 STL 类，我们还看到我们有能力理解 STL 的剩余深度和广度，以及解码许多对我们可用的其他类库。在我们导航每个成员函数的原型时，我们注意到关键语言概念，例如使用
    `const`，或者一个方法返回一个指向表示可写内存的对象的引用。每个原型都揭示了新类使用的机制。在编程努力中走到这一步是非常令人兴奋的！
- en: We have now added additional, useful features to our C++ repertoire through
    browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures)
    will ensure that our code can easily be understood by other programmers who are
    also undoubtedly using the STL. Relying on the well-tested STL for these common
    containers and utilities ensures that our code remains more bug-free.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 C++ 中浏览 STL，我们已经通过 C++ 增加了额外的、有用的功能到我们的 C++ 资料库。使用 STL（封装传统数据结构）将确保我们的代码可以轻松被其他无疑也在使用
    STL 的程序员理解。依赖经过良好测试的 STL 来确保这些常见容器和实用工具，可以确保我们的代码更加无错误。
- en: We are now ready to continue forward with [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655),
    *Testing Classes and Components*. We want to complement our C++ programming skills
    with useful OO component testing skills. Testing skills will help us understand
    whether we have created, extended, or augmented classes in a robust fashion. These
    skills will make us better programmers. Let’s continue onward!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备继续前进到[*第15章*](B19087_15.xhtml#_idTextAnchor655)，*测试类和组件*。我们希望用有用的OO组件测试技能来补充我们的C++编程技能。测试技能将帮助我们了解我们是否以健壮的方式创建了、扩展了或增强了类。这些技能将使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Replace your template `Array` class from your exercise from [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*, with an STL `vector`. Create a `vector` of `Student`
    instances. Use `vector` operations to insert, retrieve, print, compare, and remove
    objects from the vector. Alternatively, utilize an STL `list`. Use this opportunity
    to utilize the STL documentation to navigate the full set of operations available
    for these classes.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用从[*第13章*](B19087_13.xhtml#_idTextAnchor561)的练习中替换你的模板`Array`类，即*使用模板*。创建一个`Student`实例的`vector`。使用`vector`操作在向量中插入、检索、打印、比较和删除对象。或者，使用STL的`list`。利用这个机会使用STL文档来导航这些类可用的全部操作集。
- en: a. Consider what operators, if any, you will need to overload. Consider whether
    you will need an `iterator` to provide safe interleaved access to your collection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a. 考虑是否需要重载运算符。考虑是否需要一个`iterator`来提供对集合的安全交错访问。
- en: b. Create a second `vector` of `Student` instances. Assign one to another. Print
    both vectors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b. 创建第二个`Student`实例的`vector`。将一个赋值给另一个。打印两个向量。
- en: Modify the `map` from this chapter to index the hash table (map) of `Student`
    instances based on `lastName` rather than `studentId`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章中的`map`修改为根据`lastName`而不是`studentId`索引`Student`实例的哈希表（map）。
- en: Modify the `queue` example from this chapter to instead utilize `priority_queue`.
    Be sure to make use of the priority enqueueing mechanism `priority_queue::emplace()`
    to add elements into the `priority_queue`. You will also need to utilize `top()`
    instead of `front()`. Note that `priority_queue` can be found in the `<queue>`
    header file.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章中的`queue`示例修改为使用`priority_queue`。确保使用优先入队机制`priority_queue::emplace()`将元素添加到`priority_queue`中。你还需要使用`top()`而不是`front()`。注意，`priority_queue`可以在`<queue>`头文件中找到。
- en: Try out an STL algorithm using `sort()`. Be sure to `#include <algorithm>`.
    Sort an array of integers. Keep in mind that many containers have sorting mechanisms
    built in, but native collection types, such as a language-supplied array, will
    not (which is why you should use a basic array of integers).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`sort()`算法。确保包含`#include <algorithm>`。对一个整数数组进行排序。记住，许多容器都有内置的排序机制，但本地集合类型，如语言提供的数组，则没有（这就是为什么你应该使用基本整数数组）。
