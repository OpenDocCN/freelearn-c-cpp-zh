["```cpp\n    #include <iostream>\n    #include <algorithm>\n    #include <vector>\n    #include <random>\n    #include <numeric>\n    // Given a set of service times, computes the service times for all users\n    template<typename T>\n    auto compute_waiting_times(std::vector<T>& service_times)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> W(service_times.size());\n    \u00a0\u00a0\u00a0\u00a0W[0] = 0;\n\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < service_times.size(); i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0W[i] = W[i - 1] + service_times[i - 1];\n    \u00a0\u00a0\u00a0\u00a0return W;\n    }\n    // Generic function to print a vector\n    template<typename T>\n    void print_vector(std::vector<T>& V)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    template<typename T>\n    void compute_and_print_waiting_times(std::vector<T>& service_times)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto waiting_times = compute_waiting_times<int>(service_times);\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Service times: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<T>(service_times);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Waiting times: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<T>(waiting_times);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Average waiting time = \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< std::accumulate(waiting_times.begin(), \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 waiting_times.end(), 0.0) /\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0waiting_times.size();\n    \u00a0\u00a0\u00a0\u00a0std::cout<< std::endl;\n    }\n    ```", "```cpp\n    void shortest_job_first(size_t size)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> service_times;\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, size);\n    \u00a0\u00a0\u00a0\u00a0// Insert random elements as service times\n    \u00a0\u00a0\u00a0\u00a0service_times.reserve(size);\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0service_times.push_back(uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0compute_and_print_waiting_times<int>(service_times);\n    \u00a0\u00a0\u00a0\u00a0// Reorder the elements in the queue\n    \u00a0\u00a0\u00a0\u00a0std::sort(service_times.begin(), service_times.end());\n    \u00a0\u00a0\u00a0\u00a0compute_and_print_waiting_times<int>(service_times);\n    }\n    int main(int argc, char* argv[])\n    {\n    \u00a0\u00a0\u00a0\u00a0shortest_job_first(10);\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <algorithm>\n    #include <vector>\n    #include <random>\n    #include <numeric>\n    template <typename weight_type, \n    \u00a0\u00a0\u00a0\u00a0typename value_type, \n    \u00a0\u00a0\u00a0\u00a0typename fractional_type>\n    struct Object\n    {\n    \u00a0\u00a0\u00a0\u00a0using Wtype = weight_type;\n    \u00a0\u00a0\u00a0\u00a0using Vtype = value_type;\n    \u00a0\u00a0\u00a0\u00a0using Ftype = fractional_type;\n    \u00a0\u00a0\u00a0\u00a0Wtype weight;\n    \u00a0\u00a0\u00a0\u00a0Vtype value;\n    \u00a0\u00a0\u00a0\u00a0Ftype value_per_unit_weight;\n    \u00a0\u00a0\u00a0\u00a0// NOTE: The following overloads are to be used for std::sort() and I/O\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Object<Wtype,Vtype,Ftype>& obj) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// An object is better or worse than another object only on the\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// basis of its value per unit weight\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->value_per_unit_weight < obj.value_per_unit_weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator== (const Object<Wtype, Vtype, Ftype>& obj) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// An object is equivalent to another object only if \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// its value per unit weight is equal\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->value_per_unit_weight == obj.value_per_unit_weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so an object can be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// e.g. Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename Wtype,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typename Vtype,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typename Ftype>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<<(std::ostream& os, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const Object<Wtype,Vtype,Ftype>& obj);\n    };\n    template <typename Wtype,\n    \u00a0\u00a0\u00a0\u00a0typename Vtype,\n    \u00a0\u00a0\u00a0\u00a0typename Ftype>\n    std::ostream& operator<<(std::ostream& os, const Object<Wtype,Vtype,Ftype>& obj)\n    {\n    \u00a0\u00a0\u00a0\u00a0os << \"Value: \"<<obj.value \n    \u00a0\u00a0\u00a0\u00a0<< \"\\t Weight: \" << obj.weight\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<<\"\\t Value/Unit Weight: \" << obj.value_per_unit_weight;\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename weight_type, \n    \u00a0\u00a0\u00a0\u00a0typename value_type, \n    \u00a0\u00a0\u00a0\u00a0typename fractional_type>\n    auto fill_knapsack(std::vector<Object<weight_type, value_type,fractional_type>>& objects, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight_type knapsack_capacity)\n    {\n\n    \u00a0\u00a0\u00a0\u00a0std::vector<Object<weight_type, value_type, fractional_type>> knapsack_contents;\n    \u00a0\u00a0\u00a0\u00a0knapsack_contents.reserve(objects.size());\n\n    \u00a0\u00a0\u00a0\u00a0// Sort objects in the decreasing order\n    \u00a0\u00a0\u00a0\u00a0std::sort(objects.begin(), objects.end());\n    \u00a0\u00a0\u00a0\u00a0std::reverse(objects.begin(), objects.end());\n    \u00a0\u00a0\u00a0\u00a0// Add the 'best' objects to the knapsack\n    \u00a0\u00a0\u00a0\u00a0auto current_object = objects.begin();\n    \u00a0\u00a0\u00a0\u00a0weight_type current_total_weight = 0;\n    \u00a0\u00a0\u00a0\u00a0while (current_total_weight <= knapsack_capacity && \n    current_object != objects.end())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0knapsack_contents.push_back(*current_object);\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_total_weight += current_object->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_object++;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Since the last object overflows the knapsack, adjust weight\n    \u00a0\u00a0\u00a0\u00a0auto weight_of_last_obj_to_remove = current_total_weight - knapsack_capacity;\n    \u00a0\u00a0\u00a0\u00a0knapsack_contents.back().weight -= weight_of_last_obj_to_remove;\n    \u00a0\u00a0\u00a0\u00a0knapsack_contents.back().value -= knapsack_contents.back().value_per_unit_weight * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight_of_last_obj_to_remove;\n    \u00a0\u00a0\u00a0\u00a0return knapsack_contents;\n    }\n    ```", "```cpp\n    void test_fractional_knapsack(unsigned num_objects, unsigned knapsack_capacity)\n    {\n    \u00a0\u00a0\u00a0\u00a0using weight_type = unsigned;\n    \u00a0\u00a0\u00a0\u00a0using value_type = double;\n    \u00a0\u00a0\u00a0\u00a0using fractional_type = double;\n    \u00a0\u00a0\u00a0\u00a0// Initialize the Random Number Generator\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> \n    uniform_dist(1, num_objects);\n\n    \u00a0\u00a0\u00a0\u00a0// Create a vector of objects\n    \u00a0\u00a0\u00a0\u00a0std::vector<Object<weight_type, value_type, fractional_type>> objects;\n    \u00a0\u00a0\u00a0\u00a0objects.reserve(num_objects);\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < num_objects; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Every object is initialized with a random weight and value\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto weight = uniform_dist(rand);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto value = uniform_dist(rand);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto obj = Object<weight_type, value_type, fractional_type> { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0static_cast<weight_type>(weight), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0static_cast<value_type>(value), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0static_cast<fractional_type>(value) / weight \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0objects.push_back(obj);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Display the set of objects\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Objects available: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto& o : objects)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << o << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0// Arbitrarily assuming that the total knapsack capacity is 25 units\n    \u00a0\u00a0\u00a0\u00a0auto solution = fill_knapsack(objects, knapsack_capacity);\n    \u00a0\u00a0\u00a0\u00a0// Display items selected to be in the knapsack\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Objects selected to be in the knapsack (max capacity = \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< knapsack_capacity<< \"):\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto& o : solution)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << o << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    int main(int argc, char* argv[])\n    {\n    \u00a0\u00a0\u00a0\u00a0test_fractional_knapsack(10, 25);\n    }\n    ```", "```cpp\n    #include<iostream>\n    #include<vector>\n    #include<algorithm>\n    #include<queue>\n    #include<map>\n    template <typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    class SimpleDisjointSet\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0struct Node\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T data;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node(T _data) : data(_data)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool operator!=(const Node& n) const\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->data != n.data;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0// Store the forest\n    \u00a0\u00a0\u00a0\u00a0std::vector<Node> nodes;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> parent;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> rank;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0SimpleDisjointSet(size_t N)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nodes.reserve(N);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent.reserve(N);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rank.reserve(N);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_set(const T& x)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nodes.emplace_back(x);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent.emplace_back(nodes.size() - 1);\u00a0\u00a0\u00a0\u00a0// the parent is the node itself\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rank.emplace_back(0);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the initial rank for all nodes is 0\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0auto find(T x)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Find the node that contains element 'x'\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto node_it = std::find_if(nodes.begin(), nodes.end(), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[x](auto n) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{return n.data == x; });\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto node_idx = std::distance(nodes.begin(), node_it);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto parent_idx = parent[node_idx];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Traverse the tree till we reach the root\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (parent_idx != node_idx)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node_idx = parent_idx;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent_idx = parent[node_idx];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return parent_idx;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0// Union the sets X and Y belong to\n    \u00a0\u00a0\u00a0\u00a0void union_sets(T x, T y)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto root_x = find(x);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto root_y = find(y);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If both X and Y are in the same set, do nothing and return\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (root_x == root_y)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If X and Y are in different sets, merge the set with lower rank \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// into the set with higher rank\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (rank[root_x] > rank[root_y]) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent[root_y] = parent[root_x];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rank[root_x]++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent[root_x] = parent[root_y];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rank[root_y]++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template<typename T>\n    struct Edge \n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i <<\":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N): V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V && e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto& e:edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private: \n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    // Since a tree is also a graph, we can reuse the Graph class\n    // However, the result graph should have no cycles\n    template<typename T>\n    Graph<T> minimum_spanning_tree(const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Create a min-heap for the edges\n    \u00a0\u00a0\u00a0\u00a0std::priority_queue<Edge<T>, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>>, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::greater<Edge<T>>> edge_min_heap;\n    \u00a0\u00a0\u00a0\u00a0// Add all edges in the min-heap\n    \u00a0\u00a0\u00a0\u00a0for (auto& e : G.edges()) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_min_heap.push(e);\n    \u00a0\u00a0\u00a0\u00a0// First step: add all elements to their own sets\n    \u00a0\u00a0\u00a0\u00a0auto N = G.vertices();\n    \u00a0\u00a0\u00a0\u00a0SimpleDisjointSet<size_t> dset(N);\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < N; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dset.add_set(i);\n\n    \u00a0\u00a0\u00a0\u00a0// Second step: start merging sets\n    \u00a0\u00a0\u00a0\u00a0Graph<T> MST(N);\n    \u00a0\u00a0\u00a0\u00a0while (!edge_min_heap.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto e = edge_min_heap.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_min_heap.pop();\n    // Merge the two trees and add edge to the MST only if the two vertices of the edge belong to different trees in the MST\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dset.find(e.src) != dset.find(e.dest))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MST.add_edge(Edge <T>{e.src, e.dest, e.weight});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dset.union_sets(e.src, e.dest); \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return MST;\n    }\n    ```", "```cpp\n     int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto& j: i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original Graph\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << G;\n    \u00a0\u00a0\u00a0\u00a0auto MST = minimum_spanning_tree(G);\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl << \"Minimum Spanning Tree\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << MST;\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <unordered_map>\n    #include <set>\n    #include <map>\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    template <typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    // Initialize the colors that will be used to color the vertices\n    std::unordered_map<size_t, std::string> color_map = {\n    \u00a0\u00a0\u00a0\u00a0{1, \"Red\"},\n    \u00a0\u00a0\u00a0\u00a0{2, \"Blue\"},\n    \u00a0\u00a0\u00a0\u00a0{3, \"Green\"},\n    \u00a0\u00a0\u00a0\u00a0{4, \"Yellow\"},\n    \u00a0\u00a0\u00a0\u00a0{5, \"Black\"},\n    \u00a0\u00a0\u00a0\u00a0{6, \"White\"}\n    };\n    ```", "```cpp\n    void print_colors(std::vector<size_t>& colors)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i=1; i<colors.size(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \": \" << color_map[colors[i]] << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    template<typename T>\n    auto greedy_coloring(const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto size = G.vertices();\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> assigned_colors(size);\n    \u00a0\u00a0\u00a0\u00a0// Let us start coloring with vertex number 1\\. \n    \u00a0\u00a0\u00a0\u00a0// Note that this choice is arbirary.\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto outgoing_edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::set<size_t> neighbour_colors;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : outgoing_edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto dest_color = assigned_colors[e.dest];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0neighbour_colors.insert(dest_color);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Find the smallest unassigned color \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// that is not currently used by any neighbor\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto smallest_unassigned_color = 1;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest_unassigned_color <= color_map.size();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest_unassigned_color++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (neighbour_colors.find(smallest_unassigned_color) == \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0neighbour_colors.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assigned_colors[i] = smallest_unassigned_color;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return assigned_colors;\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = size_t;\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original Graph: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto colors = greedy_coloring<T>(G);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Vertex Colors: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_colors(colors);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```"]