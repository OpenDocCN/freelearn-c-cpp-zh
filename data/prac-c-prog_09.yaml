- en: Sorting and Searching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和搜索
- en: 'Searching, as the name suggests, is the process of locating a specific element
    in a group of elements. Searching can be broadly classified as one of the following
    two types:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，搜索是定位一组元素中特定元素的过程。搜索可以大致分为以下两种类型：
- en: '**Linear searching**: Where each element in the list is sequentially searched
    to find the desired item.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性搜索**：在列表中逐个元素顺序搜索以找到所需项。'
- en: '**Binary search**: Where the list is assumed to already be sorted, and the
    middle value of the list is compared with the item to be searched to determine
    which half of the list needs to be considered for searching the item. The process
    of dividing the list continues until the item is found.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二分搜索**：假设列表已经排序，将列表的中间值与要搜索的项进行比较，以确定需要考虑搜索项的列表哪一半。列表分割的过程会持续进行，直到找到项。'
- en: 'Sorting, on the other hand, is the procedure of arranging certain elements
    in a certain order. The order can be ascending, descending, or in another specific
    order. Not only can the individual numerals and strings be sorted, but even records
    can be sorted. Records are sorted on the basis of some key that is unique to every
    record. These are the two main categories of sorting:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，排序是将某些元素按特定顺序排列的过程。顺序可以是升序、降序或另一个特定顺序。不仅可以对单个数字和字符串进行排序，还可以对记录进行排序。记录是根据每个记录独特的键进行排序的。这些是排序的两个主要类别：
- en: '**Internal sorting**: Where all the elements that are being sorted are uploaded
    together in the primary memory'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部排序**：所有要排序的元素都一起上传到主存储器'
- en: '**External sorting**: Where some elements to be sorted are uploaded to the
    primary memory, and the rest are kept in auxiliary memory, such as on a hard disk
    or pen drive'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部排序**：一些要排序的元素上传到主存储器，其余的保持在辅助存储器中，例如硬盘或U盘'
- en: To be able to conduct effective searches, we need to know how to sort data.
    Sorting is essential because it makes the task of searching quite easy and fast.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够进行有效的搜索，我们需要知道如何排序数据。排序是必要的，因为它使得搜索任务变得非常容易和快速。
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下菜谱：
- en: Searching for an item using binary search
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二分搜索搜索项
- en: Arranging numbers in ascending order using bubble sort
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用冒泡排序按升序排列数字
- en: Arranging numbers in ascending order using insertion sort
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插入排序按升序排列数字
- en: Arranging numbers in ascending order using quick sort
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速排序按升序排列数字
- en: Arranging numbers in descending order using heap sort
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆排序按降序排列数字
- en: Let's begin with the first recipe!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个菜谱开始！
- en: Searching for an item using binary search
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二分搜索搜索项
- en: Binary search uses the *divide and conquer* approach. The item to be searched for
    is compared with the middle item in an array or file. This helps in determining
    which half of the array or file might contain the item being searched for. After
    that, the middle value of the half that was considered is compared with the item
    being searched for to determine which quarter part of the array or file might
    contain the item being searched for. The process continues until either the item
    being searched for is found, or no more divisions of the array or file are possible,
    in which case, it is understood that the item being searched for is not present
    in the file or array.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索使用**分而治之**的方法。要搜索的项与数组或文件中的中间项进行比较。这有助于确定数组的哪一半或文件可能包含要搜索的项。之后，将考虑的半个数组的中间值与要搜索的项进行比较，以确定数组的哪四分之一可能包含要搜索的项。这个过程会持续进行，直到找到要搜索的项，或者无法再对数组或文件进行分割，在这种情况下，可以理解为要搜索的项不在文件或数组中。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Consider an array is `arr` of size `len` elements. We want to search for a
    number, `numb`, in this array, `arr`. Here are the steps to search for `numb` in
    the `arr` array using binary search:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个大小为`len`的元素数组`arr`。我们想要在这个数组中搜索一个数字`numb`。以下是使用二分搜索在`arr`数组中搜索`numb`的步骤：
- en: Initialize two variables, `lower` and `upper`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化两个变量，`lower`和`upper`。
- en: Calculate the middle location of the array.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数组的中间位置。
- en: If the value to search, `numb`, is found at location `arr[mid]` then display
    `Value found` and exit (that is, jump to *step 8*).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要搜索的值`numb`在位置`arr[mid]`找到，则显示`Value found`并退出（即跳转到*步骤8*）。
- en: If your search value is larger than the array's middle value, confine the search
    to the lower half of the array. So, set the lower limit of the array to the array's
    middle value.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的搜索值大于数组的中间值，将搜索范围限制在数组的下半部分。因此，将数组的下限设置为数组的中间值。
- en: If your search value is smaller than the array's middle value, confine the search
    to the upper half of the array. So, set the upper limit of the array to the array's middle value.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的搜索值小于数组的中间值，将搜索范围限制在数组的上半部分。因此，将数组的上限设置为数组的中间值。
- en: Repeat *steps 3* through *5* as long as `upper>=lower`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要`upper>=lower`，就重复步骤3到5。
- en: The execution will proceed with this step only if the value is not found. Then
    display `Value not found` and exit.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在找不到值的情况下，才会执行此步骤。然后显示`Value not found`并退出。
- en: Exit.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出。
- en: 'The program for searching for an element in a sorted array using the binary
    search technique is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分搜索技术在排序数组中搜索元素的程序如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s define a macro called `max` of size 20 and an array, `arr`, of size
    `max`, that is, 20 elements (you can increase the value of the `max` macro to
    any larger value as desired). Next, we will specify the length of the array. Let''s
    say that the length you entered is 8, which is then assigned to the `len` variable.
    When prompted, enter the specified number of sorted elements. The sorted elements
    you enter will be assigned to the `arr` array, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个大小为20的宏`max`和一个大小为`max`的数组`arr`，即20个元素（你可以将`max`宏的值增加到任何更大的值）。接下来，我们将指定数组的长度。假设你输入的长度是8，然后分配给`len`变量。当被提示时，输入指定的排序元素数量。你输入的排序元素将被分配给`arr`数组，如下所示：
- en: '![](img/604e1956-f828-45c2-b3b5-bdb2d59af980.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/604e1956-f828-45c2-b3b5-bdb2d59af980.png)'
- en: Figure 9.1
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1
- en: Then, you will be prompted to enter the number you want to search for in the
    sorted array. Let's say you picked 45; this number will be assigned to the `numb`
    variable. We will invoke the `binary_search` function and all three items – the `arr` array, the
    `numb` variable containing the number to search for, and the length of the array
    in `len` – are passed to the function. The `arr`, `numb`, and `len` arguments will
    be assigned to the `arr`, `pnumb`, and `plen` parameters respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将被提示输入你想要在排序数组中搜索的数字。假设你选择了45；这个数字将被分配给`numb`变量。我们将调用`binary_search`函数，并将三个项目——包含要搜索的数字的`arr`数组、包含数字的`numb`变量以及数组的长度`len`——传递给函数。`arr`、`numb`和`len`参数将分别分配给`arr`、`pnumb`和`plen`参数。
- en: 'In the `binary_search` function, we will initialize two variables: `lindex` to
    `0` and `uindex` to `7`, that is, equal to the length of the array; these two
    indexes represent the lower and upper index locations of the array respectively.
    Because arrays are zero-based, the eighth element of the array will be found at
    index location 7\. We''ll set a `while` loop to execute for as long as the value
    of `uindex` is greater than or equal to the value of `lindex`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`binary_search`函数中，我们将初始化两个变量：`lindex`设置为`0`和`uindex`设置为`7`，即等于数组的长度；这两个索引分别代表数组的下标和上标位置。因为数组是基于0的，所以数组的第八个元素将在索引位置7。我们将设置一个`while`循环，只要`uindex`的值大于或等于`lindex`的值就执行。
- en: 'To compare the search value with the middle value of the array, we will first
    compute the middle value; sum the values of `lindex` and `uindex`, and divide
    the result by 2\. The output of (0+7)/2 is 3\. Then, compare the value of the `numb`
    variable, that is, 45, with the value at location `arr[3]`, derived from your
    computation, that is, with 34 (see *Figure 9.2*):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要将搜索值与数组的中间值进行比较，我们首先计算中间值；将`lindex`和`uindex`的值相加，然后除以2。`(0+7)/2`的结果是3。然后，将`numb`变量的值，即45，与计算得出的位置`arr[3]`的值进行比较，即与34（见图9.2）进行比较：
- en: '![](img/c26702a9-b1d5-4cc9-94f7-1207bf5ebbfc.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c26702a9-b1d5-4cc9-94f7-1207bf5ebbfc.png)'
- en: Figure 9.2
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2
- en: Because 45 is greater than 34, we will have to continue our search in the lower
    half of the array. However, since our list is sorted in ascending order, we can
    now concentrate our search in the lower half of the array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为45大于34，所以我们必须继续在数组的下半部分进行搜索。然而，由于我们的列表是按升序排序的，我们现在可以集中搜索数组的下半部分。
- en: 'Now, the value of `lindex` is set equal to `mid+1`, that is, 4\. Again, execute
    the `while` loop because `uindex`, that is, 7, is still greater than `lindex`.
    We will now compute the middle value of the upper half of the array: (4+7)/2 =
    5\. The search value 45 will be compared with `arr[5]`, that is, with 80\. Because
    45 is smaller than 80, we will continue our search in the lower half of the array,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`lindex`的值设置为`mid+1`，即等于4。再次执行`while`循环，因为`uindex`，即7，仍然大于`lindex`。我们现在将计算数组上半部分的中值：(4+7)/2
    = 5。搜索值45将与`arr[5]`进行比较，即与80进行比较。因为45小于80，我们将继续在数组的下半部分进行搜索，如下所示：
- en: '![](img/a65e061e-bb41-48f0-8581-08c737362a8f.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a65e061e-bb41-48f0-8581-08c737362a8f.png)'
- en: Figure 9.3
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3
- en: Next, the value of `uindex` is set equal to `mid-1`, that is, equal to 4\. And
    the value of `lindex` from our previous computation is also 4\. We will again
    execute the `while` loop because 4=4\. The middle value of the array will be computed
    as (4+4)/2, that is, the search value 45 will be compared with `arr[4]`, which
    is 60.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`uindex`的值设置为`mid-1`，即等于4。我们之前计算的`lindex`的值也是4。由于4等于4，我们将会再次执行`while`循环。数组的中值将被计算为(4+4)/2，即搜索值45将与`arr[4]`进行比较，而`arr[4]`的值是60。
- en: Because 45 < 60, the value of `uindex` will be set to `mid-1`, that is, equal
    to 3\. The `while` loop will exit because our `uindex (3)` is not greater than
    our `lindex (4)` any more. The `binary_search` function will return the `nfound`
    variable to the `main` function. The `nfound` variable contains some garbage value,
    which is then assigned to the `found` variable in the `main` function. In the
    `main` function, the values in the `found` and `numb` variables are compared.
    Because the garbage value is not equal to the value in the `numb` variable, 45,
    a message, `Value 45 is not found in the list` will be displayed on the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为45 < 60，所以`uindex`的值将被设置为`mid-1`，即等于3。`while`循环将退出，因为我们的`uindex (3)`不再大于我们的`lindex
    (4)`。`binary_search`函数将`nfound`变量返回到`main`函数。`nfound`变量包含一些垃圾值，然后在`main`函数中将这些值分配给`found`变量。在`main`函数中，`found`和`numb`变量中的值将被比较。因为垃圾值不等于`numb`变量中的值45，屏幕上将会显示消息“Value
    45 is not found in the list”。
- en: 'Suppose you want to search for the value 15 now. The values of `lindex` and
    `uindex` will again be 0 and 7 initially. The `while` loop will execute and the
    middle value will be computed as (0+7)/2, which will be 3\. The value of 15 will
    be compared with the corresponding location, `arr[3]`, that is, with 34\. The
    value of 15 is smaller than 34, so the upper half of the array will be considered
    to continue the binary search, as shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在想要搜索值15。`lindex`和`uindex`的初始值将再次是0和7。`while`循环将会执行，中值将被计算为(0+7)/2，这将得到3。值15将与相应的位置`arr[3]`进行比较，即与34进行比较。值15小于34，因此将考虑数组的上半部分以继续二分搜索，如图所示：
- en: '![](img/d08a84d2-5560-45b2-aa60-11594e9e73cc.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d08a84d2-5560-45b2-aa60-11594e9e73cc.png)'
- en: Figure 9.4
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4
- en: The value of the `uindex` variable is set equal to `mid-1`, that is, 2\. Because
    `uindex` is still greater than `lindex`, that is, 2 >=0, the `while` loop will
    execute again. Again, the middle value is computed as (0+2)/2, which is 1\. This
    means that 15 is compared with the `arr[1]` element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将`uindex`变量的值设置为`mid-1`，即等于2。因为`uindex`仍然大于`lindex`，即2 >= 0，`while`循环将再次执行。再次，中值被计算为(0+2)/2，即1。这意味着15将与`arr[1]`元素进行比较。
- en: The value at the `arr[1]` location is 15 only; hence, the `nfound` variable
    is set to 15 in the `binary_search` function and the `nfound` variable is returned
    to the `main` function. In the `main` function, the value of the `nfound` variable
    will be assigned to the `found` variable. Because the value in the `found` and
    `numb` variables are the same, the message `Value 15 is found in the list` will
    be displayed onscreen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`arr[1]`位置上的值仅为15；因此，在`binary_search`函数中将`nfound`变量设置为15，并将`nfound`变量返回到`main`函数。在`main`函数中，`nfound`变量的值将被分配给`found`变量。因为`found`和`numb`变量中的值相同，屏幕上将会显示消息“Value
    15 is found in the list”。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `binarysearch.c` program has successfully
    been compiled into an EXE file, that is, to the `binarysearch.exe` file. On executing
    the executable file, if we try searching for a value that is not found in the
    list, we get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下所示截图。因为没有错误出现在编译过程中，这意味着`binarysearch.c`程序已经成功编译成EXE文件，即`binarysearch.exe`文件。在执行可执行文件时，如果我们尝试搜索列表中不存在的值，我们会得到以下输出：
- en: '![](img/6226a1e8-49aa-46e0-8ecb-5517477411cb.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6226a1e8-49aa-46e0-8ecb-5517477411cb.png)'
- en: Figure 9.5
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5
- en: 'If we run the executable file again and enter a number that exists in the array,
    we may get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行可执行文件并输入数组中存在的数字，我们可能会得到以下输出：
- en: '![](img/1e5e64bd-0eb0-425b-b4b8-31ef42248e3c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e5e64bd-0eb0-425b-b4b8-31ef42248e3c.png)'
- en: Figure 9.6
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6
- en: Voilà! We've successfully used binary search to locate an item in a sorted array.
    Now let's move on to the next recipe!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用二分搜索在有序数组中定位一个项目。现在让我们继续下一个菜谱！
- en: Arranging numbers in ascending order using bubble sort
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用冒泡排序按升序排列数字
- en: In this recipe, we will learn how to arrange some integers in ascending order
    using the bubble sort technique. In this technique, the first element is compared
    with the second, the second is compared with the third, the third with the fourth,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用冒泡排序技术按升序排列一些整数。在这个技术中，第一个元素与第二个元素进行比较，第二个元素与第三个元素进行比较，第三个元素与第四个元素进行比较，依此类推。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Consider an array, `arr`, of size `len` elements. We want to arrange elements
    of the `arr` array in ascending order. Here are the steps to do so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个大小为`len`个元素的数组`arr`。我们想要按升序排列`arr`数组中的元素。以下是这样做的方法：
- en: Initialize a variable, say `i`, to `len -2`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个变量，例如`i`，为`len -2`。
- en: Follow and repeat *steps 3* through *5* as long as `i >=1`.  The value of `i`
    will be decremented by 1 after every iteration, that is, `i=len-2`, `len-3`, `len-4`,
    `....1`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤3*到*5*，直到`i >=1`。每次迭代后，`i`的值将减1，即`i=len-2`，`len-3`，`len-4`，……，`1`。
- en: Initialize another variable, `j`, to `0`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化另一个变量，`j`，为`0`。
- en: Repeat *step 5* to `j<=i`. The value of `j` will increase after every iteration,
    that is,  `j=1`, `2... i`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤5*到`j<=i`。每次迭代后，`j`的值将增加，即`j=1`，`2`，……，`i`。
- en: If `arr[j] > arr[j+1]`, then interchange the two values.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`arr[j] > arr[j+1]`，则交换这两个值。
- en: Exit the search.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出搜索。
- en: 'The program for sorting elements of an integer array using the bubble sort
    technique is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒泡排序技术对整数数组元素进行排序的程序如下：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We will start by defining a macro, `max`, of value 20\. You can always increase
    the value of `max` as required. Then, we will define an array, `arr`, of size
    `max`, that is, of size 20\. You will be asked how many values you want to sort.
    Assuming that you want to sort seven elements, the value you entered will be assigned
    to the `len` variable. You will be prompted to enter the values to be sorted,
    which will then be assigned to the `arr` array. The seven values to be sorted
    in the `arr` array might appear as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个值为20的宏`max`。您可以根据需要始终增加`max`的值。然后，我们将定义一个大小为`max`的数组`arr`，即大小为20。您将被询问您想要排序多少个值。假设您想要排序七个元素，您输入的值将被分配给`len`变量。您将被提示输入要排序的值，然后这些值将被分配给`arr`数组。`arr`数组中要排序的七个值可能如下所示：
- en: '![](img/de0e68f8-499b-445a-8ca8-b1b614368e38.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de0e68f8-499b-445a-8ca8-b1b614368e38.png)'
- en: Figure 9.7
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7
- en: 'Now, we will run two nested `for` loops: the outer `for` loop will execute
    from `len-2`, that is, from value 5 to 1 in descending order, and the inner `for`
    loop will execute for the value from 0 to `i`. That means, in the first iteration,
    the value of `i` will be 5, so the inner `for` `j` loop will execute from 0 to
    5\. Within the inner `for` loop, the first value of `arr` will be compared with
    the second, the second value with the third, and so on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行两个嵌套的`for`循环：外层`for`循环将从`len-2`开始执行，即从值5到1按降序执行，内层`for`循环将执行从0到`i`的值。这意味着，在第一次迭代中，`i`的值将是5，所以内层`for`
    `j`循环将执行从0到5。在内层`for`循环中，`arr`的第一个值将与第二个值进行比较，第二个值与第三个值进行比较，依此类推：
- en: '![](img/09a44130-05b3-4c2d-90ea-30bc3bd454ce.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09a44130-05b3-4c2d-90ea-30bc3bd454ce.png)'
- en: Figure 9.8
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8
- en: The tendency is to keep the value at the lower index smaller than the value
    at the higher index. If the first value is larger than the second, they will change
    places; and if the first value is already smaller than the second value, then
    the next two values in line, that is, the second and third values, are taken for
    consideration. Similarly, if the second value is larger than the third, they too
    will swap places; if not, then the next set of values, that is, the third and
    fourth values, will be compared. The process will continue until the last pair,
    that is, the sixth and seventh values in our case, are compared.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势是保持较低索引处的值小于较高索引处的值。如果第一个值大于第二个值，它们将交换位置；如果第一个值已经小于第二个值，那么接下来要考虑的是下一对值，即第二个和第三个值。同样，如果第二个值大于第三个值，它们也会交换位置；如果不是，那么接下来要比较的将是下一组值，即第三个和第四个值。这个过程将持续进行，直到最后一对值，即在我们的例子中是第六个和第七个值，进行比较。
- en: 'The entire first iteration of comparisons is illustrated as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 整个第一次比较迭代过程如下所示：
- en: '![](img/3e5c9d5f-d2a1-4148-9778-e05077f1b7bc.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e5c9d5f-d2a1-4148-9778-e05077f1b7bc.png)'
- en: Figure 9.9
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9
- en: 'You can see that after the first iteration, the largest value has bubbled down
    to the bottom of the list. Now, the value of the outer loop, that is, the value
    of `i` will be decremented by 1, making it 4\. Consequently, the value of `j`
    in the inner loop will make the `for` loop run from value 0 to 4\. It also means
    that now, the first value will be compared with the second, the second with the
    third, and so on. Finally, the fifth value (that is, the value at index location
    4) will be compared with the sixth value (that is, the value at index location
    5). The last element at index location 6 will not be compared as it is already
    at its correct destination:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在第一次迭代后，最大的值已经冒泡到列表的底部。现在，外循环的值，即`i`的值将减1，变为4。因此，内循环中的`j`值将使`for`循环从值0运行到4。这也意味着现在，第一个值将与第二个值进行比较，第二个值与第三个值进行比较，依此类推。最后，第五个值（即索引位置4的值）将与第六个值（即索引位置5的值）进行比较。索引位置6的最后元素不会进行比较，因为它已经处于正确的位置：
- en: '![](img/21954200-2d6c-445d-8fc6-b91aa6f851d5.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21954200-2d6c-445d-8fc6-b91aa6f851d5.png)'
- en: Figure 9.10
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10
- en: 'Again, after the second iteration, the value of the outer loop will be decremented
    by 1, making it 3\. As a result, the value of `j` in the inner loop will make
    the `for` loop run from value 0 to 3\. In the last, the fourth value, that is,
    the value at index location 3, will be compared with the fifth value. The last
    two elements at index location 5 and 6 are not compared as both are at their correct
    destination:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在第二次迭代后，外循环的值将减1，变为3。因此，内循环中的`j`值将使`for`循环从值0运行到3。最后，第四个值（即索引位置3的值）将与第五个值进行比较。索引位置5和6的最后两个元素不会进行比较，因为它们都处于正确的位置：
- en: '![](img/643fb9eb-beb2-4646-b5e1-22768ada794d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/643fb9eb-beb2-4646-b5e1-22768ada794d.png)'
- en: Figure 9.11
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11
- en: 'After the third iteration, the value of `i` will be decremented by 1, making
    it 2\. Hence, the value of `j` will make the `for` loop run from value 0 to 2\.
    The last three elements at index location 4, 5, and 6 are not compared as they
    already are at their correct destination:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 经过第三次迭代后，`i`的值将减1，变为2。因此，`j`的值将使`for`循环从值0运行到2。索引位置4、5和6的最后三个元素不会进行比较，因为它们已经处于正确的位置：
- en: '![](img/d0b5615f-1fe5-42b7-9beb-bdadd83d7853.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0b5615f-1fe5-42b7-9beb-bdadd83d7853.png)'
- en: Figure 9.12
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12
- en: 'After the fourth iteration, the value of `i` will be decremented again, making
    it 1\. So, the value of `j` in the inner loop will make the `for` loop run from
    value 0 to 1\. The last four elements are not compared as they already are at
    their final destination:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 经过第四次迭代后，`i`的值再次减1，变为1。因此，内循环中的`j`值将使`for`循环从值0运行到1。最后四个元素不会进行比较，因为它们已经处于最终位置：
- en: '![](img/14eae109-5066-420b-8a9c-b6bc6cb4f7f7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14eae109-5066-420b-8a9c-b6bc6cb4f7f7.png)'
- en: Figure 9.13
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13
- en: 'So, after five iterations, we have successfully arranged the numbers in our
    array in ascending order. The program is compiled using GCC with the following
    statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过五次迭代，我们已经成功将数组中的数字按升序排列。程序使用GCC编译，以下为编译语句：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because no error appears on compilation, that means the `bubblesort.c` program has
    successfully been compiled into the `bubblesort.exe` file. On executing this file,
    it will ask us to specify how many numbers there are to be sorted.  Then the program
    will prompt us to enter the numbers to be sorted. After entering the numbers,
    they will appear sorted in ascending order, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译过程中没有出现错误，这意味着`bubblesort.c`程序已成功编译成`bubblesort.exe`文件。在执行此文件时，它会要求我们指定要排序的数字数量。然后程序会提示我们输入要排序的数字。输入数字后，它们将以升序排列，如下面的截图所示：
- en: '![](img/c0402903-a353-43ca-b18a-0bfc1feae139.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0402903-a353-43ca-b18a-0bfc1feae139.png)'
- en: Figure 9.14
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14
- en: Voilà! We've successfully used the bubble sort technique to arrange numbers
    in ascending order.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用冒泡排序技术将数字按升序排列。
- en: Now let's move on to the next recipe!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个菜谱！
- en: Arranging numbers in ascending order using insertion sort
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插入排序按升序排列数字
- en: In this sorting technique, a region of the array, which might be the lower or
    upper part, is considered as sorted. An element outside the sorted region is picked
    up and its appropriate place is searched for in the sorted region (so that even
    after the insertion of this element, the region remains sorted) and the element
    is inserted there, hence the name insertion sort.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种排序技术中，数组的一个区域，可能是下或上部分，被认为是已排序的。从排序区域外选取一个元素，并在排序区域中搜索其适当的位置（以便在插入此元素后，该区域仍然保持排序），然后将该元素插入其中，因此得名插入排序。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到的...
- en: We will create a function for insertion sort called `InsertionSort`, which we
    will invoke as follows, where `arr` is the array to be sorted and consists of
    `n` number of elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`InsertionSort`的插入排序函数，如下所示调用，其中`arr`是要排序的数组，包含`n`个元素。
- en: 'Here are the steps that are followed in the `InsertionSort` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InsertionSort`方法中遵循的步骤如下：
- en: Initialize a variable, say `i`, to `1`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个变量，比如说`i`，初始化为`1`。
- en: Repeat steps 2 to 5 `n-1` times, that is, while `i >= n-1`. The value of `i`
    is incremented by 1 after every iteration, `i=1,2,3 .... n-1`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到5共`n-1`次，即当`i >= n-1`时。在每次迭代后，`i`的值增加1，`i=1,2,3 .... n-1`。
- en: Initialize a variable, `j`, to the value of `i`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个变量，`j`，为其值`i`。
- en: Repeat the following step 5  for `j=i` to `j >=0`. The value of `j` is decremented
    by 1 after every iteration, that is, `j=i, i-1, i-2, ....0`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以下步骤5次，对于`j=i`到`j >=0`。在每次迭代后，`j`的值减1，即`j=i, i-1, i-2, ....0`。
- en: If `arr[j] <arr[j-1]`, then interchange the values.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`arr[j] < arr[j-1]`，则交换这两个值。
- en: 'The program for sorting the elements of an integer array using the insertion
    sort technique is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插入排序技术对整数数组元素进行排序的程序如下：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s assume that the numbers that we need to sort are not greater than 20;
    so we will define a macro of size `20`. You can always assign any value to this
    macro. Next, we will define an integer array, `arr`, of size `max`. You will be
    prompted to enter how many numbers you wanted to sort. Let''s say we want to sort
    eight values; so the value `8` entered by us will be assigned to a variable, `len`.
    Thereafter, you will be asked to enter the eight values that need to be sorted.
    So, let''s say we entered the following values, which were assigned to the `arr` array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要排序的数字不超过20；因此我们将定义一个大小为`20`的宏。你可以始终为这个宏分配任何值。接下来，我们将定义一个大小为`max`的整数数组`arr`。你将被提示输入要排序的数字数量。假设我们想要排序八个值；因此我们输入的`8`将被分配给变量`len`。然后，你将被要求输入需要排序的八个值。所以，假设我们输入了以下值，这些值被分配给`arr`数组：
- en: '![](img/a86bec8f-48b0-479d-96f1-05df34a7301c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a86bec8f-48b0-479d-96f1-05df34a7301c.png)'
- en: Figure 9.15
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15
- en: 'In this sorting method, we will take the help of a nested loop, where the outer
    loop, `i`, runs from 1 to 7 and the inner loop, `j`, runs from the value beginning
    from `i` to its value is more than 0\. So, in the first iteration of the nested
    loop, the inner loop will execute only once where the value of i will be 1\. The
    value at the `arr[1]` index location is compared with that at `arr[0]`. The tendency
    is to keep the lower value at the top, so if the value at `arr[1]` is greater
    than that at `arr[0]`, the place of the two values will be interchanged. Because
    15 is greater than 9 (on the left side of *Figure 9.16*), the values in the two
    index locations will be interchanged (on the right side of *Figure 9.16*) as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种排序方法中，我们将借助嵌套循环，外循环`i`从1运行到7，内循环`j`从`i`的值开始运行，直到其值大于0。因此，在嵌套循环的第一次迭代中，内循环只会执行一次，此时`i`的值为1。`arr[1]`索引位置上的值将与`arr[0]`上的值进行比较。趋势是保持较低值在顶部，所以如果`arr[1]`上的值大于`arr[0]`上的值，这两个值的位将互换。因为15大于9（在*图9.16*的左侧），所以两个索引位置上的值将按照以下方式互换（在*图9.16*的右侧）：
- en: '![](img/d5191979-73c5-4453-9559-f762fec22845.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5191979-73c5-4453-9559-f762fec22845.png)'
- en: Figure 9.16
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16
- en: 'After the first iteration, the value of `i` will be incremented to 2 and the
    inner loop, `j`, will run from the value of 2 to 1, that is, the inner loop will
    execute twice: once with the value of `j` equal to 2 and then when the value of
    `j` is decremented to 1\. Within the inner loop, the value at `arr[2]` will be
    compared with that at `arr[1]`. In addition, the value at `arr[1]` will be compared
    with that at `arr[0]`. If `arr[2] < arr[1]`, then interchanging of the values
    will take place. Similarly, if `arr[1] < arr[0]`, interchanging of their values
    will take place.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代之后，`i`的值将增加至2，内循环`j`将从2的值运行到1，即内循环将执行两次：一次是`j`的值为2时，然后当`j`的值减少到1时。在内循环中，`arr[2]`上的值将与`arr[1]`上的值进行比较。此外，`arr[1]`上的值将与`arr[0]`上的值进行比较。如果`arr[2]
    < arr[1]`，则将发生值的互换。同样，如果`arr[1] < arr[0]`，则它们的值将互换。
- en: 'The value at `arr[2]` that is 10 is less than the value at `arr[1]`, that is,
    15; so these values will interchange places (see *Figure 9.17*). After interchanging
    the values, we find that the value at `arr[1]` is greater than the value at `arr[0]`.
    So, no interchanging will take place now. *Figure 9.17* shows the procedure of
    the second iteration:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr[2]`上的值为10，小于`arr[1]`上的值，即15；因此这些值将互换位置（见*图9.17*）。在值互换后，我们发现`arr[1]`上的值大于`arr[0]`上的值。所以，现在不会发生互换。*图9.17*显示了第二次迭代的步骤：'
- en: '![](img/e70e5208-1fa6-4987-a754-2bfddf215e47.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e70e5208-1fa6-4987-a754-2bfddf215e47.png)'
- en: Figure 9.17
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17
- en: 'After the second iteration, the value of `i` will be incremented to 3 and the
    value of `j` will run from the values of 3 to 1\. Hence, the interchanging of
    values will take place if the following conditions are met:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次迭代之后，`i`的值将增加至3，而`j`的值将从3开始运行，直到1。因此，如果满足以下条件，将发生值的互换：
- en: If `arr[3] < arr[2]`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[3] < arr[2]`
- en: If `arr[2] < arr[1]`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[2] < arr[1]`
- en: If `arr[1] < arr[0]`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[1] < arr[0]`
- en: 'You can see in *Figure 9.18(a)* that `arr[3]`, that is, 5, is smaller than
    `arr[2]`, that is, 15, so their values will be interchanged. Similarly, the values
    at `arr[2]` and `arr[1]`, and then `arr[1]` and `arr[0]`, will also be interchanged
    (see *Figure 9.18(b)* and *(c)*, respectively). *Figure 9.18(d)* shows the array
    after all the interchanges have been performed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*图9.18(a)*中看到，`arr[3]`，即5，小于`arr[2]`，即15，因此它们的值将会互换。同样，`arr[2]`和`arr[1]`以及`arr[1]`和`arr[0]`的值也将互换（分别见*图9.18(b)*和*(c)*）。*图9.18(d)*显示了所有互换操作完成后的数组：
- en: '![](img/e2aa3af3-9f83-454d-9b44-53603ff62a2b.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2aa3af3-9f83-454d-9b44-53603ff62a2b.png)'
- en: Figure 9.18
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18
- en: 'After the third iteration, the value of `i` will be incremented to 4 and the
    value of `j` will run from the values of 4 to 1\. So interchanging of values will
    take place if the following conditions are met:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次迭代之后，`i`的值将增加至4，而`j`的值将从4开始运行，直到1。如果满足以下条件，将发生值的互换：
- en: If `arr[4] < arr[3]`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[4] < arr[3]`
- en: If `arr[3] < arr[2]`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[3] < arr[2]`
- en: If `arr[2] < arr[1]`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[2] < arr[1]`
- en: If `arr[1] < arr[0]`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arr[1] < arr[0]`
- en: 'You can see in *Figure 9.19* that the main tendency of all these comparisons
    is to bring the lower values above the larger values in the array:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*图9.19*中看到，所有这些比较的主要趋势是将数组中的较低值移到较高值之上：
- en: '![](img/5c103079-3748-40b2-9037-2aa67993adae.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c103079-3748-40b2-9037-2aa67993adae.png)'
- en: Figure 9.19
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19
- en: The same procedure will be followed for the rest of the elements in the array.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的其余元素，将遵循相同的程序。
- en: 'The program is compiled using GCC with the following statement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用以下语句使用GCC编译：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because no error appears on compilation, that means the `insertionsort.c` program has
    successfully been compiled into the `insertionsort.exe` file. On execution, it
    will ask you to specify how many numbers have to be sorted. Following this, the
    program will prompt us to enter the numbers to be sorted. After entering the numbers,
    they will appear sorted in ascending order, as shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译过程中没有出现错误，这意味着`insertionsort.c`程序已成功编译成`insertionsort.exe`文件。在执行时，它将要求你指定要排序的数字数量。随后，程序将提示我们输入要排序的数字。输入数字后，它们将以升序显示，如下面的截图所示：
- en: '![](img/69789e87-788c-480c-968b-70fa81397958.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69789e87-788c-480c-968b-70fa81397958.png)'
- en: Figure 9.20
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20
- en: Voilà! We've successfully used insertion sort to arrange numbers in ascending
    order.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用插入排序将数字按升序排列。
- en: Now let's move on to the next recipe!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个菜谱！
- en: Arranging numbers in ascending order using quick sort
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用快速排序按升序排列数字
- en: Quick sort is a divide-and-conquer algorithm. It divides an array on the basis
    of a pivot, where the pivot is an element in the array, in order that all the
    elements smaller than the pivot are placed before the pivot and all the larger
    ones are placed after it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种分而治之的算法。它根据枢轴将数组分割，其中枢轴是数组中的一个元素，以便所有小于枢轴的元素都放在枢轴之前，而所有大于枢轴的元素都放在枢轴之后。
- en: So, at the location of the pivot, the array is divided into two subarrays. The
    process of finding the pivot is repeated on both the arrays. The two arrays are
    further subdivided on the basis of the pivot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在枢轴的位置，数组被分割成两个子数组。在两个数组上重复寻找枢轴的过程。根据枢轴进一步将两个数组细分。
- en: Hence, quick sort is a recursive procedure and the procedure of dividing the
    arrays into subarrays continues recursively until the subarray has only one element.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，快速排序是一个递归过程，将数组分割成子数组的递归过程会一直持续到子数组只有一个元素为止。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The quick sort process comprises the following important tasks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序过程包括以下重要任务：
- en: Finding the pivot
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找枢轴
- en: Splitting the array at the location of the pivot
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在枢轴位置分割数组
- en: We will be using two methods: `QuickSort` and `FindingPivot`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种方法：`QuickSort`和`FindingPivot`。
- en: Quick sort
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: 'This method takes an array or subarray into consideration. It invokes the method
    to find the pivot of the array or subarray and splits the array or subarray on
    the basis of the pivot. Here is its syntax:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法考虑一个数组或子数组。它调用方法来找到数组或子数组的枢轴，并根据枢轴分割数组或子数组。以下是其语法：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `arr` is the array consisting of `n` elements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`arr`是由`n`个元素组成的数组。
- en: 'This is how we use this method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用此方法的方式：
- en: Let `l=1` and `u=n`, where `l` and `u` represent the lower and upper index location,
    respectively, of the array.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 令`l=1`和`u=n`，其中`l`和`u`分别代表数组的较低和较高索引位置。
- en: Push `l` into `stack1`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`l`推入`stack1`。
- en: Push `u` into `stack2`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`u`推入`stack2`。
- en: While `stack1` or `stack2` is not empty, repeat steps 5 through 10.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`stack1`或`stack2`不为空时，重复步骤5至10。
- en: Pop the lower index location of the array from `stack1` into variable `s`, that
    is, `s` becomes the lower index location of the array to be sorted.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组`stack1`的较低索引位置弹出并放入变量`s`中，即`s`变为待排序数组的较低索引位置。
- en: Pop the upper index location from `stack2` into the variable `e`, that is, the
    `e` variable will get the upper index location of the array.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`stack2`中弹出较高索引位置到变量`e`中，即`e`变量将获得数组的较高索引位置。
- en: 'Find out the pivot by invoking the `FindingPivot` method as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式调用`FindingPivot`方法来找出枢轴：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Recall that a pivot point is an index location in the array where the elements
    smaller than the pivot are before it and elements larger than the pivot are after
    it. The array is split at the pivot point and the quick sort method is recursively
    applied on the two halves individually.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，枢轴点是指数组中的一个索引位置，其中小于枢轴的元素在它之前，而大于枢轴的元素在它之后。数组在枢轴点处被分割，然后对两个子数组分别递归地应用快速排序方法。
- en: Once the pivot is known, divide the array into two halves. One array will have
    values from `s` (the lower index location) to `pivot-1`, and another array with
    the elements ranges from `pivot+1` to `e` (the upper index location).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了枢轴，将数组分为两个部分。一个数组将包含从 `s`（下标位置）到 `pivot-1` 的值，另一个数组将包含从 `pivot+1` 到 `e`（上标位置）的元素。
- en: For the first half of the array, push `s` into `stack1` and `pivot-1` into `stack2`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于数组的上半部分，将 `s` 推入 `stack1`，将 `pivot-1` 推入 `stack2`。
- en: For the second half of the array, push `pivot+1` into `stack1` and `e` into
    `stack2`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于数组的下半部分，将 `pivot+1` 推入 `stack1`，将 `e` 推入 `stack2`。
- en: FindingPivot
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FindingPivot
- en: 'This method finds the pivot of the array or subarray. Here is its syntax:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于找到数组或子数组的枢轴。以下是它的语法：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `arr` represents the array of `n` elements, `start` represents the starting
    index location of the array, and `end` represents the ending index location of
    the array.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`arr` 代表包含 `n` 个元素的数组，`start` 代表数组的起始索引位置，而 `end` 代表数组的结束索引位置。
- en: 'This is how we use this method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用此方法：
- en: Repeat *steps 2* through *8* of the `QuickSort` method.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 `QuickSort` 方法的第 2 步至第 8 步。
- en: Store the value of the `start` variable in another variable, say, `lower`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `start` 变量的值存储在另一个变量中，例如 `lower`。
- en: Start from the right index location and move to the left. Initially, the first
    element is the pivot. The tendency is to keep the elements larger than the pivot
    on the right-hand side of the pivot and the elements smaller than the pivot on
    the left-hand side.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右索引位置开始，向左移动。最初，第一个元素是枢轴。趋势是将大于枢轴的元素保持在枢轴的右侧，将小于枢轴的元素保持在枢轴的左侧。
- en: If `lower=end`, that means, we found the pivot. The pivot is equal to the value
    of lower. Return `lower` as the location of the pivot element.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `lower=end`，这意味着我们找到了枢轴。枢轴等于 `lower` 的值。将 `lower` 返回为枢轴元素的索引位置。
- en: If `arr[lower] > arr[end]`, then interchange the values' places. Now, move from
    left to right comparing each value with the pivot, and move up until we get the
    value lower than the value of pivot.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `arr[lower] > arr[end]`，则交换这两个值的顺序。现在，从左到右比较每个值与枢轴，直到我们得到一个小于枢轴值的值。
- en: 'While `arr[start] <= arr[lower]` and `lower != start`, repeat:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `arr[start] <= arr[lower]` 且 `lower != start` 时，重复：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `lower=start` then pivot is lower. Return `lower` as the location of the
    pivot element.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `lower=start`，则枢轴是 `lower`。将 `lower` 返回为枢轴元素的索引位置。
- en: If `arr[start] > arr[lower]`, then interchange the values' places.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `arr[start] > arr[lower]`，则交换这两个值的顺序。
- en: 'The program for sorting elements of an integer array using the quick sort technique
    is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速排序技术对整数数组元素进行排序的程序如下：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You will be asked to specify how many numbers you require to be sorted. Suppose
    we want to sort 8 numbers; the value 8 entered by the user will be assigned to
    the `len` variable. A `for` loop is executed enabling us to enter the number to
    be sorted. The values we enter will be assigned to the `arr` array as shown in
    *Figure 9.21*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求指定需要排序的数字数量。假设我们想要排序 8 个数字；用户输入的值 8 将被分配给 `len` 变量。执行一个 `for` 循环，使我们能够输入要排序的数字。我们输入的值将按照
    *图 9.21* 所示分配给 `arr` 数组。
- en: Two variables, `lindex` and `uindex`, are initialized to represent the desired
    first and last index of the array, that is 0 and 7, respectively. The `lindex`
    and `uindex` locations are supposed to keep the smallest and largest values in
    the array. The values of `lindex` and `uindex`, that is, 0 and 7, will be pushed
    to the stack. In the `pushstk1` function, the value of the top index, whose default
    value is -1, is incremented to 0 and the value of `lindex` is assigned to the `stack1`
    array at the `[0]` index location. Similarly, in the  `pushstk2` function, the
    value of the `top2` index is also incremented to 0, and the value of `uindex`
    is assigned to the `stack2` array at the `[0]` location.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量，`lindex` 和 `uindex`，被初始化以表示数组所需的首个和最后一个索引，分别是 0 和 7。`lindex` 和 `uindex`
    的位置应该保留数组中的最小和最大值。`lindex` 和 `uindex` 的值，即 0 和 7，将被推入栈中。在 `pushstk1` 函数中，顶部索引的值（默认为
    -1）增加至 0，并将 `lindex` 的值赋给 `stack1` 数组的 `[0]` 索引位置。同样，在 `pushstk2` 函数中，`top2` 索引的值也增加至
    0，并将 `uindex` 的值赋给 `stack2` 数组的 `[0]` 位置。
- en: A while loop is set to execute for as long as the value of `top1` is not equal
    to 1\. That means, until `stack1` is empty, the program will keep executing. Within
    the while loop, the values pushed in `stack1` and `stack2` are popped and assigned
    to the two variables of `sindex` and `eindex`, respectively. These variables represent
    the starting and ending index locations of the array or the part of the array
    that we want to sort using `quick sort`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个 while 循环，直到 `top1` 的值不等于 1。这意味着，直到 `stack1` 为空，程序将继续执行。在 while 循环内，`stack1`
    和 `stack2` 中推入的值将被弹出并分配给两个变量 `sindex` 和 `eindex`，分别。这些变量代表我们想要使用快速排序对数组或数组的一部分进行排序的起始和结束索引位置。
- en: '`stack1` and `stack2` contain the values of 0 and 7, respectively, which are
    popped and assigned to `sindex` and `eindex`, respectively. The quick function
    is invoked and the values in `sindex` and `eindex` are passed to an argument.
    In the quick functions, the values of `sindex` and `eindex` arguments are assigned
    to the two parameters of `si` and `ei`, respectively.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack1` 和 `stack2` 分别包含 0 和 7 的值，这些值被弹出并分别分配给 `sindex` 和 `eindex`。调用 quick
    函数，并将 `sindex` 和 `eindex` 的值传递给参数。在 quick 函数中，`sindex` 和 `eindex` 参数的值分别分配给 `si`
    和 `ei` 这两个参数。'
- en: 'Within the quick function, the value of `si`, that is 0, is assigned to another
    variable, `li`. A while loop is executed in an infinite loop. Within the while
    loop, another while loop is set to execute that will make `ei` move toward the
    left, that is, it will make the value of `ei` decrement until the element at the `arr[ei]` location
    is greater than the `arr[li]` location:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 quick 函数内，`si` 的值，即 0，被分配给另一个变量 `li`。执行一个无限循环的 while 循环。在 while 循环内，设置另一个
    while 循环，将使 `ei` 向左移动，即，它将使 `ei` 的值递减，直到 `arr[ei]` 位置处的元素大于 `arr[li]` 位置处的元素：
- en: '![](img/e627ced9-1f08-4264-853c-2d5b850186ab.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e627ced9-1f08-4264-853c-2d5b850186ab.png)'
- en: Figure 9.21
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21
- en: 'Because `arr[ei] < arr[si]`, interchanging of their values will take place
    (see *Figure 9.22(a)*). After interchanging the values at `arr[ei]` and `arr[si]`,
    the `arr` array will appear as shown in *Figure 9.22(b)*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `arr[ei] < arr[si]`，将它们的值进行交换（见 *图 9.22(a)*）。在 `arr[ei]` 和 `arr[si]` 交换值后，`arr`
    数组将如图 *图 9.22(b)* 所示：
- en: '![](img/1088c771-3bba-4f76-aea6-20574c843f42.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1088c771-3bba-4f76-aea6-20574c843f42.png)'
- en: Figure 9.22
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22
- en: 'After interchanging of values, the index location number of `ei`, that is 7,
    will be assigned to `li`. Another while loop is set to execute while `arr[si]`
    is smaller than `arr[li]`, where `li` represents the `ei` index currently; and
    within the `while` loop, the location of the `si` index pointer is incremented. 
    That is, the `si` index pointer is moved right to `arr[si] < arr[li]`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 交换值后，`ei` 的索引位置号，即 7，将被分配给 `li`。然后设置另一个 while 循环，在 `arr[si]` 小于 `li` 时执行，其中
    `li` 代表当前的 `ei` 索引；在 while 循环内，`si` 索引指针的位置增加。也就是说，`si` 索引指针向右移动到 `arr[si] < arr[li]`：
- en: '![](img/89babd95-8687-4e6c-a655-51b466712c3a.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89babd95-8687-4e6c-a655-51b466712c3a.png)'
- en: Figure 9.23
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23
- en: 'Now, the following things will happen:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下事情将会发生：
- en: Because `arr[si] < arr[ei]` (that is, 4 < 6), `si` will move right by one location
    to `arr[1]`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si] < arr[ei]`（即 4 < 6），`si` 将向右移动一个位置到 `arr[1]`
- en: Because `arr[si] < arr[ei]` (that is, now 3 < 6), `si` will again move right
    by one location to `arr[2]`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si] < arr[ei]`（即现在 3 < 6），`si` 将再次向右移动一个位置到 `arr[2]`
- en: Because `arr[si] < arr[ei]` (that is, now 0 < 6), `si` will again move right
    by one location to `arr[3]`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si] < arr[ei]`（即现在 0 < 6），`si` 将再次向右移动一个位置到 `arr[3]`
- en: Because `arr[si]  < arr[ei]` (that is, now 2 < 6), `si` will again move right
    by one location to `arr[``4]`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]  < arr[ei]`（即现在 2 < 6），`si` 将再次向右移动一个位置到 `arr[4]`
- en: 'Because `arr[si]  > arr[ei]` (that is, now 7 > 6), interchanging of their values
    will take place (see *Figure 9.24*):'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]  > arr[ei]`（即现在 7 > 6），将它们的值进行交换（见 *图 9.24*）：
- en: '![](img/e80eeb8c-8814-4b76-a4b2-7d9eb2db7bd4.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e80eeb8c-8814-4b76-a4b2-7d9eb2db7bd4.png)'
- en: Figure 9.24
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24
- en: 'After interchanging of values at `arr[ei]` and `arr[si]`, the location number
    of `arr[si]`, that is, 4, will be assigned to `li`. The process is repeated; that
    is, again a while loop is set to execute while `arr[ei] > arr[si]`. Within the
    while loop, the location of `ei` is decremented, or it moves to the left:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `arr[ei]` 和 `arr[si]` 交换值后，`arr[si]` 的位置号，即 4，将被分配给 `li`。过程重复；也就是说，再次设置一个
    while 循环来执行，直到 `arr[ei] > arr[si]`。在 while 循环内，`ei` 的位置递减，或者它向左移动：
- en: '![](img/0d9f4606-4863-48dd-a7fa-f6c6df23254a.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d9f4606-4863-48dd-a7fa-f6c6df23254a.png)'
- en: Figure 9.25
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25
- en: While comparing `arr[ei]` and `arr[si]`, we will find that `arr[ei] > arr[si]`
    (7 > 6), so `ei` will be decremented to value 6 (see *Figure 9.26(a)*). Again,
    because `arr[ei] < arr[si]` (1 < 6), interchanging of values of these index locations
    will take place (see *Figure 9.26(b)*). The location number of `ei`, 6 now, will
    be assigned to variable `li`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较`arr[ei]`和`arr[si]`时，我们会发现`arr[ei] > arr[si]`（7 > 6），因此`ei`将递减到值6（参见*图9.26(a)*）。再次，因为`arr[ei]
    < arr[si]`（1 < 6），这些索引位置的值将进行交换（参见*图9.26(b)*）。现在`ei`的位置号6将被分配给变量`li`。
- en: 'Another while loop is set to execute while `arr[si] < arr[ei]` (remember the
    location number of ei is assigned to li). The following things will happen in
    this while loop:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 设置另一个while循环，在`arr[si] < arr[ei]`（记住`ei`的位置号被分配给`li`）的情况下执行。在这个while循环中将会发生以下事情：
- en: Because `arr[si] < arr[ei]` (that is, 1 < 6), `si` will move right to `arr[5]`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`arr[si] < arr[ei]`（即1 < 6），`si`将向右移动到`arr[5]`。
- en: Because still `arr[si] < arr[ei]` (that is, 5 < 6), `si` will move right to
    `arr[6]`
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为仍然`arr[si] < arr[ei]`（即5 < 6），`si`将向右移动到`arr[6]`。
- en: Because now the location of `ei` and `si` are the same, the quick function will
    terminate returning the number 6 to the `main` function (see *Figure 9.26(c)*).
    So, the number 6 will become the pivot of the `arr` array.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为现在`ei`和`si`的位置相同，快速函数将终止并返回数字6到`main`函数（参见*图9.26(c)*）。因此，数字6将成为`arr`数组的枢轴。
- en: '![](img/7e20269a-2da5-4c6a-bc04-00f9ec8a9f96.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e20269a-2da5-4c6a-bc04-00f9ec8a9f96.png)'
- en: Figure 9.26
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26
- en: 'Two `if` statements are executed and the array is split into two parts: the
    first part ranges from `arr[0]` to `arr[5]` and the other part from `arr[7]` to
    `arr[7]`, that is, of a single element. The first and last index values of the
    two parts of the array are pushed to the stack.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了两个`if`语句，数组被分成两部分：第一部分从`arr[0]`到`arr[5]`，另一部分从`arr[7]`到`arr[7]`，即一个单独的元素。数组的两部分的第一和最后一个索引值被推入栈中。
- en: The first and last index locations of the second part of the array, that is,
    7, will be pushed to both `stack1` and `stack2`. The first and last index locations
    of the first part of array, that is, 0 and 5, will also be pushed to `stack1`
    and `stack2`, respectively (see *Figure 9.27*).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的第二部分的第一和最后一个索引位置，即7，将被推入`stack1`和`stack2`。数组的第一部分的第一和最后一个索引位置，即0和5，也将分别推入`stack1`和`stack2`（参见*图9.27*）。
- en: '![](img/e8953bcd-c548-4235-8612-40cee58289f8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8953bcd-c548-4235-8612-40cee58289f8.png)'
- en: Figure 9.27
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27
- en: The complete quick sort technique is applied on both halves of the array. Again,
    the two halves will be partitioned into two more parts and again the quick sort
    technique is applied on those two parts, and so on.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的快速排序技术在数组的两个半部分上应用。再次，这两个半部分将被进一步分割成两个更小的部分，然后再次在这些两个部分上应用快速排序技术，以此类推。
- en: The outer while loop repeats and the `popstk1()` and `popstk2()` functions will
    be invoked to pop off the values in the `stack1` and `stack2` arrays. The values
    of the `top1` and `top2` indices are 1, so the values at the `stack1[1]` and `stack2[1]`
    index locations are picked up and assigned to the two variables, `sindex` and
    `eindex`, respectively. Again, the `quick()` function is invoked and the two variables,
    `sindex` and `eindex`, are passed to it. In the quick function, the values of
    the `sindex` and `eindex` arguments are assigned to the `si` and `ei` parameters
    respectively
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 外层while循环重复执行，并将`popstk1()`和`popstk2()`函数调用来弹出`stack1`和`stack2`数组中的值。`top1`和`top2`索引的值都是1，所以`stack1[1]`和`stack2[1]`索引位置的值被取出并分别分配给两个变量，`sindex`和`eindex`。再次调用`quick()`函数，并将两个变量`sindex`和`eindex`传递给它。在`quick()`函数中，`sindex`和`eindex`参数的值分别被分配给`si`和`ei`。
- en: Within the `quick()` function, the value of the `si` variable, that is, 0, is
    assigned to another variable, `li`. A while loop is executed in an infinite loop.
    Within the while loop, another while loop is set to execute that will make the
    `ei` index location to move toward the left, that is, it will make the value of
    the `ei` index variable decrement for the time the element at the `arr[ei]` location
    is greater than the `arr[si]` location (see *Figure 9.28(a)*). Because `arr[ei]
    > arr[si]`, the value of the `ei` variable will be decremented to 4 (see *Figure
    9.28(b)*). Now, we find that `arr[ei]`, that is, 1 is less than `arr[si]`, that
    is, 4, so interchanging of their values will take place. After interchanging the
    values at that `arr[ei]` and `arr[si]` index locations, the `arr` array will appear
    as shown in *Figure 9.28(c)*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `quick()` 函数内，`si` 变量的值，即 0，被分配给另一个变量 `li`。执行一个无限循环的 while 循环。在 while 循环内，设置另一个
    while 循环，将使 `ei` 索引位置向左移动，即它将使 `ei` 索引变量的值减少，直到 `arr[ei]` 位置的元素大于 `arr[si]` 位置的元素（参见
    *图 9.28(a)*）。因为 `arr[ei] > arr[si]`，所以 `ei` 变量的值将减少到 4（参见 *图 9.28(b)*）。现在，我们发现
    `arr[ei]`，即 1，小于 `arr[si]`，即 4，所以它们的值将交换。在交换 `arr[ei]` 和 `arr[si]` 索引位置的值后，`arr`
    数组将如 *图 9.28(c)* 所示。
- en: 'After interchanging the values, the value of the `ei` variable is assigned
    to the `li` variable, that is, 4, is assigned to the `li` variable. Another while
    loop is set to execute while the `arr[si]` element is smaller than `arr[li]`,
    where `li` represents the `si` index currently; and within the while loop, the
    value of the `si` index pointer is incremented. The following things will happen:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 交换值后，`ei` 变量的值被分配给 `li` 变量，即 4 被分配给 `li` 变量。设置另一个 while 循环，在 `arr[si]` 元素小于
    `arr[li]` 时执行，其中 `li` 代表当前的 `si` 索引；在 while 循环内，`si` 索引指针的值增加。以下事情将会发生：
- en: Because `arr[si]`, that is, 1, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 1.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]`，即 1，小于 `arr[ei]`，即 4，所以 `si` 将增加到值为 1。
- en: Because `arr[si]`, that is, 3, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 2.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]`，即 3，小于 `arr[ei]`，即 4，所以 `si` 将增加到值为 2。
- en: Because `arr[si]`, that is, 0, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 3.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]`，即 0，小于 `arr[ei]`，即 4，所以 `si` 将增加到值为 3。
- en: Because `arr[si]`, that is, 2, is less than `arr[ei]`, that is, 6, `si` will
    be incremented to a value of 4.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `arr[si]`，即 2，小于 `arr[ei]`，即 6，所以 `si` 将增加到值为 4。
- en: 'Because the values of the `ei` and `si` variables have become the same, the
    `quick()` function will terminate, returning the value `4` to the `main` function
    (see *Figure 9.28(d )*):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `ei` 和 `si` 变量的值已经相同，`quick()` 函数将终止，将值 `4` 返回到 `main` 函数（参见 *图 9.28(d)*）：
- en: '![](img/072b772e-ffa9-4f1b-9f87-5dfc45027f75.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/072b772e-ffa9-4f1b-9f87-5dfc45027f75.png)'
- en: Figure 9.28
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28
- en: 'On returning to the `main` function, two `if` statements are executed and the
    array is split into two parts: the first part ranges from the `arr[0]` to the
    `arr[3]` index locations, and the other part will range from the `arr[5]` to the `arr[5]`
    index locations, that is, of a single element. The starting and ending index values
    of the two parts of the array are pushed to the stack. The starting and ending
    index locations of the second part of the array (that is, 5 and 5) will be pushed
    to `stack1` and `stack2`, respectively. Similarly, the starting and ending index
    locations of the first part of the array (that is, 0 and 3) are pushed to `stack1`
    and `stack2`, respectively (see *Figure 9.29*).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回 `main` 函数时，执行了两个 `if` 语句，并将数组分成两部分：第一部分从 `arr[0]` 到 `arr[3]` 索引位置，另一部分将从
    `arr[5]` 到 `arr[5]` 索引位置，即一个单独的元素。数组的两部分起始和结束索引值被推送到栈中。数组的第二部分的起始和结束索引位置（即 5 和
    5）分别推送到 `stack1` 和 `stack2`。同样，数组的第一个部分的起始和结束索引位置（即 0 和 3）分别推送到 `stack1` 和 `stack2`（参见
    *图 9.29*）。
- en: '![](img/b09305c2-b399-4692-b702-80b1576dd369.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b09305c2-b399-4692-b702-80b1576dd369.png)'
- en: Figure 9.29
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29
- en: The whole quick sort technique is applied on all the partitions of the array
    until the stacks are empty. That is, the outer while loop repeats and the `popstk1()`
    and `popstk2()` functions will be invoked to pop off the values in the `stack1`
    and `stack2` arrays. Again, the `quick()` function is invoked and the two variables, `sindex`
    and `eindex`, that are popped from the stack are passed to it. The procedure continues
    until the whole array is sorted.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 整个快速排序技术被应用于数组的所有分区，直到栈为空。也就是说，外层 while 循环重复，`popstk1()` 和 `popstk2()` 函数将被调用以弹出
    `stack1` 和 `stack2` 数组中的值。再次调用 `quick()` 函数，并将从栈中弹出的两个变量 `sindex` 和 `eindex` 传递给它。这个过程会一直持续到整个数组被排序。
- en: 'The program is compiled using GCC using the following statement:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用以下语句使用 GCC 编译：
- en: '[PRE10]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because no error appears on compilation, that means the `quick sort.c` program has
    successfully been compiled into the `quick sort.exe` file. On executing the file,
    it will ask you to specify how many numbers there are to be sorted. Following
    this, the program will prompt you to enter the numbers to be sorted. After entering
    the numbers, they will appear sorted in ascending order, as shown in the following
    screenshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译过程中没有出现错误，这意味着 `quick sort.c` 程序已成功编译成 `quick sort.exe` 文件。在执行文件时，它会要求您指定要排序的数字数量。随后，程序将提示您输入要排序的数字。输入数字后，它们将按升序排列，如下面的截图所示：
- en: '![](img/c9792887-0876-48b9-8964-6d652097e9e9.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9792887-0876-48b9-8964-6d652097e9e9.png)'
- en: Figure 9.30
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.30
- en: Voilà! We have successfully arranged the numbers in our array using quick sort.
    Now let's move on to the next recipe!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用快速排序将数组中的数字排列好了。现在让我们继续下一个菜谱！
- en: Arranging numbers in descending order using heap sort
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用堆排序对数字进行降序排列
- en: In this recipe, we will learn to arrange some integers in descending order using
    the heap sort technique.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用堆排序技术将一些整数按降序排列。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The heap sort method is divided into the following two tasks:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序方法被分为以下两个任务：
- en: Creating a max-heap
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最大堆
- en: Deleting the max-heap
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除最大堆
- en: Let's start with creating a max-heap.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建最大堆开始。
- en: Creating a max-heap
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建最大堆
- en: 'The following steps are followed for creating a max-heap:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建最大堆的以下步骤：
- en: The user is asked to enter a number. The number is used to create a heap. The
    number entered by the user is assigned to an array heap at index location `x`,
    where `x` begins with a value of 0 and increments after every insertion.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入一个数字。该数字用于创建一个堆。用户输入的数字被分配到数组堆的索引位置 `x`，其中 `x` 的初始值为 0，并在每次插入后递增。
- en: 'The newly inserted number is compared with the element of its parent node.
    Because we are making use of a max-heap, we need to maintain a rule: the value
    of the parent node should be always larger than its child node. The location of
    the parent node is computed using the formula `parent=(x-1)/2`, where `x` represents
    the index location where the new node is inserted.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新插入的数字与其父节点的元素进行比较。因为我们正在使用最大堆，所以需要遵循一个规则：父节点的值应该始终大于其子节点。父节点的位置通过公式 `parent=(x-1)/2`
    计算，其中 `x` 代表新节点插入的索引位置。
- en: Check if the value of the new node is greater than the value of its parent.
    Interchange the values of `heap[parent]` and `heap[x]` with the help of an extra
    variable.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新节点的值是否大于其父节点的值。通过一个额外的变量交换 `heap[parent]` 和 `heap[x]` 的值。
- en: Recursively check the value of the parent of the parent node to see whether
    the property of the max-heap is maintained or not.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归检查父节点的父节点的值，以查看最大堆的性质是否得到保持。
- en: Once the heap is made, the second task of deleting the max-heap will begin.
    Every time a node is deleted from a max-heap, the deleted node is kept in another
    array, say `arr`, that will contain the sorted elements. The task of deleting
    the max-heap is repeated as many times as the number of elements present in the
    max-heap.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆被创建，删除最大堆的第二项任务将开始。每次从最大堆中删除一个节点时，删除的节点将被保存在另一个数组中，例如 `arr`，该数组将包含排序后的元素。删除最大堆的任务将重复执行，直到最大堆中存在多少个元素。
- en: Deleting the max-heap
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除最大堆
- en: 'Three variables, `leftchild`, `rightchild`, and `root`, are initialized as
    follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 三个变量 `leftchild`、`rightchild` 和 `root` 的初始化如下：
- en: '[PRE11]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following steps are performed to delete a max-heap:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最大堆的以下步骤：
- en: The element at the root node is temporarily assigned to the `n` variable.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根节点处的元素临时分配给 `n` 变量。
- en: The last element of the heap is placed at the root node.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆的最后一个元素放置在根节点。
- en: If the value of the last index location is 1 or 2, that is, if the heap has
    only  1 or 2 elements left, then return to the caller with the `n` variable.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最后一个索引位置的值为1或2，即堆只剩下1或2个元素，则使用`n`变量返回调用者。
- en: Since the last element is placed at the root node, reduce the size of the heap
    by 1.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于最后一个元素放置在根节点，减少堆的大小1。
- en: To maintain the max-heap property, repeat *steps 6* through *9* while `rightchild
    <=last`. Recall, the property of the max-heap is that the value of the parent
    node should be always larger than its children node.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持最大堆的性质，在`rightchild <= last`的情况下重复执行*步骤6*至*9*。回想一下，最大堆的性质是父节点的值应该始终大于其子节点。
- en: Calculate the `leftchild` and `rightchild` locations.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算左子节点`leftchild`和右子节点`rightchild`的位置。
- en: If `heap[root] > heap[leftchild] && heap[root] > heap[rightchild]`, return `n`
    and exit.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`heap[root] > heap[leftchild] && heap[root] > heap[rightchild]`，则返回`n`并退出。
- en: If the value of the left child is greater than the value of the right child,
    then interchange the value of the root and that of the left child. The root will
    come down at the left child to check whether the max-heap property is maintained
    or not.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果左子节点的值大于右子节点的值，则交换根节点和左子节点的值。根节点将下降到左子节点以检查最大堆的性质是否得到保持。
- en: If the value of the right child is greater than the value of the left child,
    then interchange the value of the root and that of the right child. The root will
    come down at the right child to check whether the max-heap property is maintained
    or not.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果右子节点的值大于左子节点的值，则交换根节点和右子节点的值。根节点将下降到右子节点以检查最大堆的性质是否得到保持。
- en: When all the elements of the max-heap are over, that means the `arr` array will
    have all the sorted elements. So, the final step is to print the `arr` array, which
    contains the sorted elements.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当最大堆的所有元素都处理完毕时，这意味着`arr`数组将包含所有已排序的元素。因此，最后一步是打印`arr`数组，其中包含已排序的元素。
- en: 'The program for sorting elements of an integer array using the heap sort technique
    is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆排序技术对整数数组元素进行排序的程序如下：
- en: '[PRE12]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A heap is a complete binary tree that can be either a max-heap or a min-heap.
    The max-heap has the property that the key value of any node must be greater than
    or equal to the key values of its children. In the min-heap, the key value of
    any node must be lower than or equal to the values of its children.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个完全二叉树，可以是最大堆或最小堆。最大堆具有这样的性质：任何节点的键值必须大于或等于其子节点的键值。在最小堆中，任何节点的键值必须小于或等于其子节点的值。
- en: 'In this recipe, we will learn to create a max-heap of the following list of
    integers:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建以下整数列表的最大堆：
- en: '| 5 | 2 | 9 | 3 | 1 | 4 | 6 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | 9 | 3 | 1 | 4 | 6 |'
- en: 'In this heap sort method, the binary tree is constructed in the form of an
    array. In heap sort, the values in the array are added one by one, keeping the
    max-heap property true (that is, the key value of any node should be larger than
    or equal to its children). While adding the elements of the array, we keep track
    of the key value of the parent node with `(x-1)/2`, where `x` is the element whose
    parent is to be found. If the element inserted in the heap is larger than the
    key value of its parent, then interchanging takes place. For example, suppose
    the first key value entered is `5` (it is considered as the root); it is stored
    as the first element of the array, that is, `heap[0]`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个堆排序方法中，二叉树以数组的形式构建。在堆排序中，数组中的值一个接一个地添加，保持最大堆性质为真（即任何节点的键值应该大于或等于其子节点）。在添加数组元素时，我们使用`(x-1)/2`跟踪父节点的键值，其中`x`是要找到父节点的元素。如果插入堆中的元素大于其父节点的键值，则进行交换。例如，假设第一个键值输入是`5`（它被认为是根）；它被存储为数组的第一个元素，即`heap[0]`：
- en: '![](img/69ee9c11-e051-4096-90a4-99d3e54ec928.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ee9c11-e051-4096-90a4-99d3e54ec928.png)'
- en: Figure 9.31
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31
- en: 'Then 2 is added to it as a left child. The first child will always be added
    to the left. When another value is entered, it is entered at the location of `heap[1]`.
    After insertion, its parent node location is computed with `(x-1)/2`, where `x`
    is 1\. So, the parent comes out to be location 0\. So, `heap[1]` is compared with
    its parent element, `heap[0]`. If the key element of the parent element, `heap[0]`,
    is larger than `heap[1]`, then we move further; else, we interchange their key
    values. In our example, the second element is 2, so no interchanging is required:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将2添加为其左子节点。第一个子节点总是添加到左边。当输入另一个值时，它被输入到`heap[1]`的位置。插入后，使用`(x-1)/2`计算其父节点位置，其中`x`是1。因此，父节点是位置0。所以，`heap[1]`与其父元素`heap[0]`进行比较。如果父元素`heap[0]`的关键元素大于`heap[1]`，则继续进行；否则，交换它们的关键值。在我们的例子中，第二个元素是2，所以不需要交换：
- en: '![](img/fc9cd259-968f-459e-a7fd-f08fd05312d1.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc9cd259-968f-459e-a7fd-f08fd05312d1.png)'
- en: Figure 9.32
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32
- en: 'Now, we move to enter the third element. The third element is 9, and it is
    added as a right child of node 5 (see *Figure 9.33 (a)*). In the array, it is
    stored at the location of `heap[2]`. Again, its parent element location is computed
    by `(x-1)/2`, which again comes out to be 0\. In keeping the property of max-heap
    (that the value of the parent node should be larger than or equal to its children),
    we compare the key values of the `heap[0]` and `heap[2]` elements. Because `heap[0]`
    is less than `heap[2]`, it is violating the max-heap property. Thus, the key values
    of `heap[0]` and `heap[2]` will be interchanged, as shown in *Figure 9.33(b)*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入第三个元素。第三个元素是9，它被添加为节点5的右子节点（见图9.33(a)）。在数组中，它被存储在`heap[2]`的位置。再次，使用`(x-1)/2`计算其父元素的位置，结果再次是0。为了保持最大堆的性质（父节点的值应该大于或等于其子节点），我们比较`heap[0]`和`heap[2]`元素的关键值。因为`heap[0]`小于`heap[2]`，它违反了最大堆的性质。因此，`heap[0]`和`heap[2]`的关键值将进行交换，如图9.33(b)所示：
- en: '![](img/2e51762b-43ab-457f-96d9-d548cc542d72.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e51762b-43ab-457f-96d9-d548cc542d72.png)'
- en: Figure 9.33
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33
- en: 'Then 3 is added as a left child of node 2, as shown in *Figure 9.34(a)*. In
    the array, the new value is inserted at the index location of `heap[3]`. Again,
    its parent element location is computed using the formula `(x-1)/2`, where `x`
    represents the index location where new value is inserted, that is, 3\. The parent
    element location is computed as 1\. In keeping with the property of max-heap,
    `heap[1]` must be larger than or equal to `heap[3]`.  But because `heap[1]` is
    less than `heap[3]`, it is violating the max-heap property. Thus, the key values
    of `heap[1]` and `heap[3]` will be interchanged, as shown in *Figure 9.34(b)*:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后3被添加为节点2的左子节点，如图9.34(a)所示。在数组中，新值被插入到`heap[3]`的索引位置。再次，使用公式`(x-1)/2`计算其父元素的位置，其中`x`代表新值插入的索引位置，即3。父元素的位置计算为1。根据最大堆的性质，`heap[1]`必须大于或等于`heap[3]`。但是因为`heap[1]`小于`heap[3]`，它违反了最大堆的性质。因此，`heap[1]`和`heap[3]`的关键值将进行交换，如图9.34(b)所示：
- en: '![](img/c166c522-7cb4-4d22-97d8-e891bf871a2b.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c166c522-7cb4-4d22-97d8-e891bf871a2b.png)'
- en: Figure 9.34
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34
- en: 'Now, 1 is added as the right child of node 3\. In the array, the new value
    is inserted at the index location of `heap[4]`. Because the property of max-heap
    is still maintained, no interchanging is required:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，1被添加为节点3的右子节点。在数组中，新值被插入到`heap[4]`的索引位置。因为最大堆的性质仍然保持，不需要交换：
- en: '![](img/4a0b1159-5f92-4079-9fc8-6c1c3c1437d3.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a0b1159-5f92-4079-9fc8-6c1c3c1437d3.png)'
- en: Figure 9.35
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35
- en: 'The next value is 4, which is added as the left child of node 5\. In the array,
    the new value is inserted at the index location of `heap[5]`. Again, the property
    of max-heap is maintained, so no interchanging is required:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个值是4，它被添加为节点5的左子节点。在数组中，新值被插入到`heap[5]`的索引位置。再次，最大堆的性质得到保持，因此不需要交换：
- en: '![](img/a6a6fcc9-92d7-4aa1-a716-8ee75eca2a48.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6a6fcc9-92d7-4aa1-a716-8ee75eca2a48.png)'
- en: Figure 9.36
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36
- en: 'Next, 6 is added as the right child of node 5 (see *Figure 9.37 (a)*). In the
    array, it is inserted at the index location of `heap[6]`. Again, its parent element
    location is computed using the formula `(x-1)/2`. The parent element location
    is computed as 2\. In keeping with the property of max-heap, `heap[2]` must be
    larger than or equal to `heap[6]`. But because `heap[2]` is less than `heap[6]`,
    it is violating the max-heap property; so the key values of `heap[2]` and `heap[6]`
    will be interchanged, as shown in *Figure 9.37(b)*:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将6添加为节点5的右子节点（见*图9.37(a)*）。在数组中，它被插入到`heap[6]`的索引位置。再次，使用公式`(x-1)/2`计算父元素位置。父元素位置计算为2。根据最大堆的性质，`heap[2]`必须大于或等于`heap[6]`。但是因为`heap[2]`小于`heap[6]`，它违反了最大堆的性质；因此，`heap[2]`和`heap[6]`的键值将被交换，如图*图9.37(b)*所示：
- en: '![](img/7bf8345c-b7ea-4eea-8af7-e25f26064948.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bf8345c-b7ea-4eea-8af7-e25f26064948.png)'
- en: Figure 9.37
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37
- en: 'Once the max-heap is made, we perform heap sort by repeating the following
    three steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了最大堆，我们就通过重复以下三个步骤进行堆排序：
- en: Removing its root element (and storing it in the sorted array)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其根元素（并将其存储在排序数组中）
- en: Replacing the root element of the tree (array) by the last node value and removing
    the last node (decrementing the size of the array)
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树的根元素（数组）替换为最后一个节点值，并移除最后一个节点（减少数组的大小）
- en: Reshuffling the key values to maintain the heap property
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新整理键值以保持堆的性质
- en: 'In the following *Figure 9.38(a)*, you can see that the root element, that
    is, 9, is deleted and is stored in another array called `arr`. The `arr` array
    will contain the sorted elements. The root element is replaced by the last element
    of the tree. The last element of the tree is 5, so it is removed from the `heap[6]`
    index location and is assigned to the root, that is, at `heap[0]`. Now, the property
    of heap is no longer true. So, the values of node elements  5  and 6 are interchanged (see
    *Figure 9.38(b)*):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的*图9.38(a)*中，你可以看到根元素，即9，被删除并存储在另一个名为`arr`的数组中。`arr`数组将包含排序后的元素。根元素被替换为树的最后一个元素。树的最后一个元素是5，因此它从`heap[6]`索引位置移除并分配给根，即`heap[0]`。现在，堆的性质不再成立。因此，节点元素5和6的值被交换（见*图9.38(b)*）：
- en: '![](img/15867e24-2047-4b90-9f90-bf75253904b4.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15867e24-2047-4b90-9f90-bf75253904b4.png)'
- en: Figure 9.38
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38
- en: 'Now the process is repeated again, removing the key element of the root node
    and replacing its value with the last node and reshuffling the heap. That is,
    the root node element 6 is removed and is assigned to the sorted array, `arr`.
    And the root node is replaced by the last element of the tree that is by 4 (see
    *Figure 9.39(a)*). By putting the value 4 at the root, the property of heap is
    no longer true. So  to maintain the property of heap, the value 4 is brought down
    that is the values of node elements 4 and 5 are interchanged, as shown in *Figure
    9.39(b)*):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次重复这个过程，移除根节点的键元素，并用最后一个节点的值替换它，然后重新整理堆。也就是说，移除根节点元素6并将其分配给排序数组`arr`。然后，根节点被替换为树的最后一个元素，即4（见*图9.39(a)*）。将值4放在根节点后，堆的性质不再成立。因此，为了保持堆的性质，将值4向下移动，即节点元素4和5的值被交换，如图*9.39(b)*所示）：
- en: '![](img/ff7795a5-45d4-45b6-b804-87b70c96c25c.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff7795a5-45d4-45b6-b804-87b70c96c25c.png)'
- en: Figure 9.39
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39
- en: 'The steps are repeated to get the array sorted in descending order, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这些步骤以按降序对数组进行排序，如下所示：
- en: '![](img/4a503124-9549-4214-b3da-66f621191962.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a503124-9549-4214-b3da-66f621191962.png)'
- en: Figure 9.40
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40
- en: 'The program is compiled using GCC using the following statement:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句使用GCC编译程序：
- en: '[PRE13]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because no error appears on compilation, this means the `heapsort.c` program has
    successfully been compiled into the `heapsort.exe` file. On executing the file,
    it will ask us to specify how many numbers there are to be sorted. Following this,
    the program will prompt us to enter the numbers to be sorted. After entering the
    numbers, they will appear sorted in descending order, as shown in the following
    screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译时没有出现错误，这意味着`heapsort.c`程序已成功编译成`heapsort.exe`文件。在执行文件时，它会要求我们指定要排序的数字数量。随后，程序将提示我们输入要排序的数字。输入数字后，它们将按降序排列，如下面的屏幕截图所示：
- en: '![](img/629e44a5-848b-4668-882e-d5763c804ee4.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/629e44a5-848b-4668-882e-d5763c804ee4.png)'
- en: Figure 9.41
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.41
- en: Voilà! We have successfully arranged numbers in descending order using heap
    sort.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用堆排序将数字按降序排列。
- en: See also
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more sorting methods like selection, merge, shell and radix sort visit
    *Appendix A* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多如选择、归并、希尔和基数排序等排序方法，请访问此链接上的*附录A*：[https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf).
