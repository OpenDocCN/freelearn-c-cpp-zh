- en: Using Compute Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing a particle simulation with the compute shader
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器实现粒子模拟
- en: Creating a fractal texture using the compute shader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器创建分形纹理
- en: Using the compute shader for cloth simulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器进行布料模拟
- en: Implementing an edge detection filter with the compute shader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器实现边缘检测滤波器
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Compute shaders** were introduced into OpenGL with version 4.3\. A compute
    shader is a shader stage that can be used for arbitrary computation. It provides
    the ability to leverage the GPU and its inherent parallelism for general computing
    tasks that might have previously been implemented in serial on the CPU. The compute
    shader is most useful for tasks that are not directly related to rendering, such
    as physical simulation.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算着色器**是在OpenGL 4.3版本中引入的。计算着色器是一个可以用于任意计算的着色器阶段。它提供了利用GPU及其固有的并行性来执行通用计算任务的能力，这些任务可能之前是在CPU上串行实现的。计算着色器对于与渲染无直接关系的任务最有用，例如物理模拟。'
- en: Although APIs such as OpenCL and CUDA are already available for general purpose
    computation on the GPU, they are completely separate from OpenGL. Compute shaders
    are integrated directly within OpenGL, and therefore are more suitable for general
    computing tasks that are more closely related to graphics rendering.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OpenCL和CUDA等API已经可用于在GPU上执行通用计算，但它们与OpenGL完全独立。计算着色器直接集成在OpenGL中，因此更适合与图形渲染更紧密相关的通用计算任务。
- en: The compute shader is not a traditional shader stage in the same sense as the
    fragment or vertex shader. It is not executed in response to rendering commands.
    In fact, when a compute shader is linked with a vertex, fragment, or other shader
    stages, it is effectively inert when drawing commands are executed. The only way
    to execute the compute shader is via the OpenGL `glDispatchCompute` or `glDispatchComputeIndirect` command.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器在相同的意义上不是传统着色器阶段，如片段着色器或顶点着色器。它不会在响应渲染命令时执行。实际上，当计算着色器与顶点、片段或其他着色器阶段链接时，在执行绘图命令时它是无反应的。执行计算着色器的唯一方法是使用OpenGL的`glDispatchCompute`或`glDispatchComputeIndirect`命令。
- en: Compute shaders do not have any direct user-defined inputs and no outputs at
    all. Shaders get its work by fetching data directly from memory using image-access
    functions such as the image load/store operations, or via shader storage buffer
    objects. Similarly, it provides its results by writing to the same or other objects.
    The only non-user-defined inputs to a compute shader are a set of variables that
    determine where the shader invocation is within its *space* of execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器没有任何直接的用户定义输入，也没有任何输出。着色器通过使用图像访问函数（如图像加载/存储操作）直接从内存中获取其工作，或者通过着色器存储缓冲区对象。同样，它通过写入相同或其他的对象来提供其结果。计算着色器的唯一非用户定义输入是一组变量，这些变量决定了着色器调用在其执行空间中的位置。
- en: The number of invocations of the compute shader is completely user defined.
    It is not tied in any way to the number of vertices or fragments being rendered.
    We specify the number of invocations by defining the number of work groups, and
    the number of invocations within each work group.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器的调用次数完全由用户定义。它与渲染的顶点或片段的数量没有任何关联。我们通过定义工作组的数量以及每个工作组内的调用次数来指定调用次数。
- en: Compute space and work groups
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算空间和工作组
- en: The number of invocations of a compute shader is governed by the user-defined
    compute space. This space is divided into a number of work groups. Each work group
    is then broken down into a number of invocations. We think of this in terms of
    the global compute space (all shader invocations) and the local work group space
    (the invocations within a particular work group). The compute space can be defined
    as a one-, two-, or three-dimensional space.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器的调用次数由用户定义的计算空间控制。这个空间被划分为多个工作组。然后，每个工作组被分解为多个调用。我们将这个概念视为全局计算空间（所有着色器调用）和局部工作组空间（特定工作组内的调用）。计算空间可以定义为一维、二维或三维空间。
- en: Technically, it is always defined as a three-dimensional space, but any of the
    three dimensions can be defined with a size of one (1), which effectively removes
    that dimension.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，它始终被定义为三维空间，但任何三个维度都可以定义为大小为1（1），这实际上消除了该维度。
- en: 'For example, a one-dimensional compute space with five work groups and three
    invocations per work group could be represented as the following diagram. The
    thicker lines represent the work groups, and the thinner lines represent the invocations
    within each work group:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个具有五个工作组和每个工作组三次调用的单维计算空间可以表示为以下图示。较粗的线条代表工作组，较细的线条代表每个工作组内的调用：
- en: '![](img/76d4aaa8-3781-48d8-adc3-e2440c174a9a.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76d4aaa8-3781-48d8-adc3-e2440c174a9a.png)'
- en: In this case, we have *5 * 3 = 15* shader invocations. The grey shaded invocation
    is in work group **2**, and within that work group is invocation **1** (the invocations
    are indexed starting at **0**). We can also refer to that invocation with a global
    index of 7 by indexing the total number of invocations starting at zero. The global
    index determines an invocation's location within the global compute space, rather
    than just within the work group.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有 *5 * 3 = 15* 着色器调用。灰色着色的调用在工作组 **2** 中，并且在该工作组内是调用 **1**（调用从 **0**
    开始索引）。我们也可以通过从零开始索引总调用数来用全局索引7引用该调用。全局索引确定了一个调用在全局计算空间中的位置，而不仅仅是工作组内。
- en: It is determined by taking the product of work group (**2**) and index the number
    of invocations per work group (**3**), plus the local invocation index (**1**)
    that is *2 * 3 + 1 = 7*. The **global index** is simply the index of each invocation
    in the global compute space, starting at zero on the left and counting from there.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它是通过将工作组数量（**2**）与每个工作组的调用索引数（**3**）相乘，再加上局部调用索引（**1**），即 *2 * 3 + 1 = 7* 得出的。**全局索引**简单地是全局计算空间中每个调用的索引，从左侧的零开始计数。
- en: 'The following diagram shows a representation of a two-dimensional compute space
    where the space is divided into 20 work groups, four in the *x* direction and
    five in the *y* direction. Each work group is then divided into nine invocations,
    three in the *x* direction and three in the *y* direction:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了二维计算空间的表示，其中空间被划分为20个工作组，*x* 方向上有4个，*y* 方向上有5个。然后每个工作组被划分为九次调用，*x* 方向上三次，*y*
    方向上三次：
- en: '![](img/9eb7b3f7-073b-42b8-beb7-1c1c5b0612af.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eb7b3f7-073b-42b8-beb7-1c1c5b0612af.png)'
- en: The cell that is shaded in gray represents invocation (0, 1) within the work
    group (2, 0). The total number of compute shader invocations in this example is
    then *20 * 9 = 180*. The global index of this shaded invocation is (6, 1). As
    with the one-dimensional case, we can think of this index as a global compute
    space (without the work groups), and it can be computed (for each dimension) by
    the number of invocations per work group times the work group index, plus the
    local invocation index. For the *x* dimension, this would be *3 * 2 + 0 = 6*,
    and for the *y* dimension it is *3 * 0 + 1 = 1*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 被灰色着色的单元格代表工作组（2, 0）内的调用（0, 1）。在这个例子中，计算着色器调用的总数是 *20 * 9 = 180*。这个着色调用的全局索引是（6,
    1）。与一维情况一样，我们可以将这个索引视为一个全局计算空间（没有工作组），并且可以通过每个工作组的调用数乘以工作组索引，再加上局部调用索引来计算（对于每个维度）。对于
    *x* 维度，这将等于 *3 * 2 + 0 = 6*，而对于 *y* 维度则是 *3 * 0 + 1 = 1*。
- en: The same idea can extend in a straightforward manner to a three-dimensional
    compute space. In general, we choose the dimensionality based on the data to be
    processed. For example, if I'm working on the physics of a particle simulation,
    I would just have a list of particles to process, so a one-dimensional compute
    space might make sense. On the other hand, if I'm processing a cloth simulation,
    the data will have a grid structure, so a two-dimensional compute space would
    be appropriate.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法可以简单地扩展到三维计算空间。一般来说，我们根据要处理的数据选择维度。例如，如果我正在处理粒子物理学的物理，我可能只有一个粒子列表要处理，因此单维计算空间可能是有意义的。另一方面，如果我正在处理布料模拟，数据将具有网格结构，因此二维计算空间是合适的。
- en: There are limits to the total number of work groups and local shader invocations.
    These can be queried (via `glGetInteger*`) using the `GL_MAX_COMPUTE_WORK_GROUP_COUNT`, `GL_MAX_COMPUTE_WORK_GROUP_SIZE`,
    and `GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS `parameters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 工作组总数和局部着色器调用的数量是有限制的。这些可以通过使用`GL_MAX_COMPUTE_WORK_GROUP_COUNT`、`GL_MAX_COMPUTE_WORK_GROUP_SIZE`和`GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`参数（通过`glGetInteger*`查询）来获取。
- en: The order of execution of the work groups and thereby the individual shader
    invocations is unspecified and the system can execute them in any order. Therefore,
    we shouldn't rely on any particular ordering of the work groups. Local invocations
    within a particular work group will be executed in parallel (if possible). Therefore,
    any communication between invocations should be done with great care. Invocations
    within a work group can communicate via shared local data, but invocations should
    not (in general) communicate with invocations in other work groups without the
    consideration of the various pitfalls involved such as deadlock and data races.
    In fact, those can also be issues for local shared data within a work group as
    well, and care must be taken to avoid these problems. In general, for reasons
    of efficiency, it is best to only attempt communication within a work group. As
    with any kind of parallel programming, "there be dragons here."
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工作组的执行顺序以及因此的单独着色器调用的顺序是不确定的，系统可以以任何顺序执行它们。因此，我们不应该依赖于工作组的任何特定顺序。特定工作组内的局部调用将并行执行（如果可能）。因此，调用之间的任何通信都应该非常小心。工作组内的调用可以通过共享局部数据通信，但调用（通常）不应与其他工作组的调用通信，除非考虑到涉及的各种陷阱，如死锁和数据竞争。实际上，这些问题也可能出现在工作组内的局部共享数据中，因此必须小心避免这些问题。一般来说，出于效率的考虑，最好只在工作组内尝试通信。与任何类型的并行编程一样，“这里可能有龙。”
- en: OpenGL provides a number of atomic operations and memory barriers that can help
    with the communication between invocations. We'll see some examples in the recipes
    that follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL提供了一些原子操作和内存屏障，可以帮助调用之间的通信。我们将在接下来的食谱中看到一些示例。
- en: Executing the compute shader
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行计算着色器
- en: 'When we execute the compute shader, we define the compute space. The number
    of work groups are determined by the parameters to `glDispatchCompute`. For example,
    to execute the compute shader with a two-dimensional compute space with `4` work
    groups in the *x* dimension and `5` work groups in the *y* dimension (matching
    the preceding diagram), we''d use the following call:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行计算着色器时，我们定义计算空间。工作组的数量由`glDispatchCompute`的参数确定。例如，为了使用二维计算空间执行计算着色器，其中*x*维度有`4`个工作组，*y*维度有`5`个工作组（与前面的图匹配），我们将使用以下调用：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The number of local invocations within each work group is not specified on
    the OpenGL side. Instead, it is specified within the compute shader itself with
    a layout specifier. For example, here, we specify nine local invocations per work
    group, `3` in the *x* direction and `3` in the *y* direction:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL方面，每个工作组中局部调用的数量没有指定。相反，它由计算着色器本身中的布局指定符指定。例如，在这里，我们指定每个工作组有九个局部调用，*x*方向上`3`个，*y*方向上`3`个：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The size in the *z* dimension can be left out (the default is one).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在*z*维度的大小可以省略（默认为`1`）。
- en: 'When a particular invocation of the compute shader is executing, it usually
    needs to determine where it is within the global compute space. GLSL provides
    a number of built-in input variables that help with this. Most of them are listed
    in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算着色器的特定调用正在执行时，它通常需要确定自己在全局计算空间中的位置。GLSL提供了一些内置输入变量来帮助实现这一点。其中大部分列在下面的表格中：
- en: '| **Variable** | **Type** | **Meaning** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **类型** | **含义** |'
- en: '| `gl_WorkGroupSize` | `uvec3` | The number of invocations per work group in
    each dimension—the same as what is defined in the layout specifier. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `gl_WorkGroupSize` | `uvec3` | 每个维度中每个工作组的调用数——与布局指定符中定义的相同。|'
- en: '| `gl_NumWorkGroups` | `uvec3` | The total number of work groups in each dimension.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `gl_NumWorkGroups` | `uvec3` | 每个维度中工作组的总数。|'
- en: '| `gl_WorkGroupID` | `uvec3` | The index of the current work group for this
    shader invocation. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `gl_WorkGroupID` | `uvec3` | 对于这个着色器调用，当前工作组的索引。|'
- en: '| `gl_LocalInvocationID` | `uvec3` | The index of the current invocation within
    the current work group. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `gl_LocalInvocationID` | `uvec3` | 当前调用在当前工作组中的索引。|'
- en: '| `gl_GlobalInvocationID` | `uvec3` | The index of the current invocation within
    the global compute space. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `gl_GlobalInvocationID` | `uvec3` | 当前调用在全局计算空间中的索引。|'
- en: 'The last one in the preceding table, `gl_GlobalInvocationID`, is computed in
    the following way (each operation is component-wise):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个表格中的最后一个变量，`gl_GlobalInvocationID`，是按照以下方式计算的（每个操作都是分量级的）：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This helps us to locate the current invocation within the global compute space
    (refer to the preceding examples).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们在全局计算空间中定位当前调用（参考前面的示例）。
- en: GLSL also defines `gl_LocalInvocationIndex`, which is a flattened form of `gl_LocalInvocationID`.
    It can help when multidimensional data is provided in a linear buffer, but is
    not used in any of the examples that follow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 还定义了 `gl_LocalInvocationIndex`，它是 `gl_LocalInvocationID` 的扁平化形式。当在线性缓冲区中提供多维数据时，它可能会有所帮助，但在随后的任何示例中都没有使用。
- en: Implementing a particle simulation with the compute shader
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器实现粒子模拟
- en: In this recipe, we'll implement a simple particle simulation. We'll have the
    compute shader handle the physics computations and update the particle positions
    directly. Then, we'll just render the particles as points. Without the compute
    shader, we'd need to update the positions on the CPU by stepping through the array
    of particles and updating each position in a serial fashion, or by making use
    of transform feedback, as shown in the *Creating a particle system using transform
    feedback* recipe in [Chapter 9](5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml), *Using
    Noise in Shaders*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个简单的粒子模拟。我们将让计算着色器处理物理计算并直接更新粒子位置。然后，我们只需将粒子渲染为点。如果没有计算着色器，我们就需要在
    CPU 上通过遍历粒子数组并按顺序更新每个位置来更新位置，或者利用变换反馈，如第 9 章“使用噪声在着色器中”中 *创建使用变换反馈的粒子系统* 菜谱所示。
- en: Doing such animations with vertex shaders is sometimes counterintuitive and
    requires some additional work (such as transform feedback setup). With the compute
    shader, we can do the particle physics in parallel on the GPU, and customize our
    compute space to get the most "bang for the buck" out of our GPU.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶点着色器进行此类动画有时是不直观的，需要做一些额外的工作（如变换反馈设置）。有了计算着色器，我们可以在 GPU 上并行处理粒子物理，并定制我们的计算空间，以从
    GPU 中获得最大的“性价比”。
- en: 'The following image shows our particle simulation running with one million
    particles. Each particle is rendered as a 1 x 1 point. The particles are partially
    transparent, and the particle attractors are rendered as small 5 x 5 squares (barely
    visible):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们的粒子模拟运行，使用了百万个粒子。每个粒子被渲染为一个 1 x 1 的点。粒子部分透明，粒子吸引子被渲染为小的 5 x 5 正方形（几乎看不见）：
- en: '![](img/9f182425-bc66-4943-a13d-2dfff2ed8b51.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f182425-bc66-4943-a13d-2dfff2ed8b51.png)'
- en: These simulations can create beautiful, abstract figures, and are a lot of fun
    to produce.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟可以创建出美丽、抽象的图形，制作起来也非常有趣。
- en: 'For our simulation, we''ll define a set of attractors (two in this case, but
    you can create more), which I''ll call the **black holes**. They will be the only
    objects that affect our particles and they''ll apply a force on each particle
    that is inversely proportional to the distance between the particle and the black
    hole. More formally, the force on each particle will be determined by the following
    equation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模拟，我们将定义一组吸引子（在这个例子中有两个，但你可以创建更多），我将它们称为**黑洞**。它们将是唯一影响我们粒子的对象，并且它们将对每个粒子施加与粒子与黑洞之间距离成反比的力。更正式地说，每个粒子的力将由以下方程确定：
- en: '![](img/267ba104-508c-4177-ad32-043acae98a17.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/267ba104-508c-4177-ad32-043acae98a17.png)'
- en: '*N* is the number of black holes (attractors), *r[i]* is the vector between
    the *i*^(th) attractor and the particle (determined by the position of the attractor
    minus the particle position), and *G[i]* is the strength of the *i*^(th) attractor.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* 是黑洞（吸引子）的数量，*r[i]* 是第 *i* 个吸引子与粒子之间的向量（由吸引子的位置减去粒子的位置确定），*G[i]* 是第 *i*
    个吸引子的强度。'
- en: 'To implement the simulation, we compute the force on each particle and then
    update the position by integrating the Newtonian equations of motion. There are
    a number of well-studied numerical techniques for integrating the equations of
    motion. For this simulation, the simple Euler method is sufficient. With the Euler
    method, the position of the particle at time *t + Δt* is given by the following
    equation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现模拟，我们计算每个粒子的力，然后通过积分牛顿运动方程来更新位置。对于积分运动方程，存在许多经过充分研究的数值技术。对于这个模拟，简单的欧拉方法就足够了。使用欧拉方法，时间
    *t + Δt* 时粒子的位置由以下方程给出：
- en: '![](img/1b1a4e59-6e5f-44cd-a3c3-ec3d262ceb1e.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b1a4e59-6e5f-44cd-a3c3-ec3d262ceb1e.png)'
- en: '*P* is the position of the particle, *v* is the velocity, and *a* is the acceleration.
    Similarly, the updated velocity is determined by the following equation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 是粒子的位置，*v* 是速度，*a* 是加速度。同样，更新的速度由以下方程确定：'
- en: '![](img/9cde8466-8277-4e9e-a6e7-8abf54393bbf.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cde8466-8277-4e9e-a6e7-8abf54393bbf.png)'
- en: These equations are derived from a Taylor expansion of the position function
    about time *t*. The result is dependent upon the size of the time step (*Δt*),
    and is more accurate when the time step is very small.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程是从关于时间*t*的位置函数的泰勒展开中推导出来的。结果取决于时间步长的大小（*Δt*），当时间步长非常小的时候更准确。
- en: The acceleration is directly proportional to the force on the particle, so by
    calculating the force on the particle (using the preceding equation), we essentially
    have a value for the acceleration. To simulate the particle's motion, we track
    its position and velocity, determine the force on the particle due to the black
    holes, and then update the position and velocity using the equations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度与粒子上的力成正比，因此通过计算粒子上的力（使用前面的方程），我们本质上得到了加速度的值。为了模拟粒子的运动，我们跟踪其位置和速度，确定粒子由于黑洞而产生的力，然后使用方程更新位置和速度。
- en: We'll use the compute shader to implement the physics here. Since we're just
    working with a list of particles, we'll use a one-dimensional compute space, and
    work groups of about 1,000 particles each. Each invocation of the compute shader
    will be responsible for updating the position of a single particle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用计算着色器来实现这里的物理。由于我们只是处理粒子列表，我们将使用一维计算空间，并且每个工作组大约有1,000个粒子。计算着色器的每次调用将负责更新单个粒子的位置。
- en: We'll use shader storage buffer objects to track the positions and velocities,
    and when rendering the particles themselves, we can just render directly from
    the position buffer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用着色器存储缓冲区对象来跟踪位置和速度，并且在渲染粒子本身时，我们可以直接从位置缓冲区渲染。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'On the OpenGL side, we need a buffer for the position of the particles and
    a buffer for the velocity. Create a buffer containing the initial positions of
    the particles and a buffer with zeroes for the initial velocities. We''ll use
    four component positions and velocities for this example in order to avoid issues
    with data layouts. For example, to create the buffer for the positions, we might
    do something as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL方面，我们需要一个粒子位置的缓冲区和速度的缓冲区。创建一个包含粒子初始位置的缓冲区和一个初始速度为零的缓冲区。为了避免数据布局问题，本例中将使用四个分量的位置和速度。例如，要创建位置缓冲区，我们可能做如下操作：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use a similar process for the velocity data, but bind it to index one of the
    `GL_SHADER_STORAGE_BUFFER` binding location:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于速度数据，使用类似的过程，但将其绑定到`GL_SHADER_STORAGE_BUFFER`绑定位置的索引一：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Set up a vertex array object that uses the same position buffer as its data
    source for the vertex position.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为顶点位置设置一个使用与数据源相同的顶点缓冲区的顶点数组对象。
- en: To render the points, set up a vertex and fragment shader pair that just produces
    a solid color. Enable blending and set up a standard blending function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染点，设置一个仅产生纯色的顶点和片段着色器对。启用混合并设置标准混合函数。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We''ll use the compute shader for updating the positions of the particles:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用计算着色器来更新粒子的位置：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the render routine, invoke the compute shader to update the particle positions:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染例程中，调用计算着色器来更新粒子位置：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, make sure that all data has been written out to the buffer by invoking
    a memory barrier:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，确保通过调用内存屏障来将所有数据写入缓冲区：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, render the particles using data in the position buffer.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用位置缓冲区中的数据渲染粒子。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The compute shader starts by defining the number of invocations per work group
    using the layout specifier:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器首先使用布局指定符定义每个工作组的调用次数：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This specifies `1000` invocations per work group in the *x* dimension. You can
    choose a value for this that makes the most sense for the hardware you're running.
    Just make sure to adjust the number of work groups appropriately. The default
    size for each dimension is one so we don't need to specify the size of the *y*
    and *z* directions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了在*x*维度上每个工作组的`1000`次调用。你可以选择一个对你所运行的硬件最有意义的值。只需确保适当地调整工作组的数量。每个维度的默认大小为1，因此我们不需要指定*y*和*z*方向的大小。
- en: Then, we have a set of uniform variables that define the simulation parameters.
    `Gravity1` and `Gravity2` are the strengths of the two black holes (`G`, in the
    preceding equation), and `BlackHolePos1` and `BlackHolePos2` are their positions.
    `ParticleInvMass` is the inverse of the mass of each particle, which is used to
    convert force to acceleration. Finally, `DeltaT` is the time-step size, which
    is used in the Euler method for the integration of the equations of motion.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一组定义模拟参数的均匀变量。`Gravity1` 和 `Gravity2` 是两个黑洞的强度（在先前的方程中为 `G`），而 `BlackHolePos1`
    和 `BlackHolePos2` 是它们的位置。`ParticleInvMass` 是每个粒子质量的倒数，用于将力转换为加速度。最后，`DeltaT` 是时间步长的大小，用于在欧拉法中积分运动方程。
- en: The buffers for position and velocity are declared next. Note that the binding
    values here match those that we used on the OpenGL side when initializing the
    buffers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明位置和速度的缓冲区。注意，这里的绑定值与我们初始化缓冲区时在 OpenGL 端使用的值匹配。
- en: Within the main function, we start by determining the index of the particle
    for which this invocation is responsible for. Since we're working with a linear
    list of particles, and the number
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先确定这个调用负责的粒子的索引。由于我们正在处理粒子的线性列表，并且粒子的数量
- en: of particles is the same as the number of shader invocations, what we want is
    the index within the global range of invocations. This index is available via
    the built-in
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的数量与着色器调用的数量相同，我们想要的是全局调用范围内的索引。这个索引可以通过内置
- en: '`gl_GlobalInvocationID.x` input variable. We use the global index here because
    it is the index within the entire buffer that we need, not the index within our
    work group, which would only reference a portion of the entire array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_GlobalInvocationID.x` 输入变量。我们在这里使用全局索引，因为我们需要的索引是在整个缓冲区内的索引，而不是工作组内的索引，后者只会引用整个数组的一部分。'
- en: Next, we retrieve the position and velocity from their buffers, and compute
    the force due to each black hole, storing the sum in the `force` variable. Then,
    we convert the force to acceleration and update the particle's position and velocity
    using the Euler method. We write to the same location from which we read previously.
    Since invocations do not share data, this is safe.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从它们的缓冲区中检索位置和速度，并计算每个黑洞产生的力，将总和存储在 `force` 变量中。然后，我们将力转换为加速度，并使用欧拉法更新粒子的位置和速度。我们写入之前读取的相同位置。由于调用不共享数据，这是安全的。
- en: In the render routine, we invoke the compute shader (step *2* in the *How to
    do it... *section), defining the number of work groups per dimension. In the compute
    shader, we specified a work group size of `1000`. Since we want one invocation
    per particle, we divide the total number of particles by `1000` to determine the
    number of work groups.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染例程中，我们调用计算着色器（在“如何做...”部分的步骤 *2*），定义每个维度的每个工作组的数量。在计算着色器中，我们指定了工作组大小为 `1000`。由于我们希望每个粒子有一个调用，我们将粒子总数除以
    `1000` 以确定工作组的数量。
- en: Finally, in step *3*, before rendering the particles, we need to invoke a memory
    barrier to ensure that all compute shader writes have fully executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤 *3* 中，在渲染粒子之前，我们需要调用一个内存屏障来确保所有计算着色器的写入都已完全执行。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter11/sceneparticles.cpp` file in the example code.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter11/sceneparticles.cpp` 文件。
- en: Refer to [Chapter 9](5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml), *Using Noise
    in Shaders*, for other particle simulations. Most of these have been implemented
    using transform feedback, but could instead be implemented using the compute shader.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 9 章 [使用噪声在着色器中](5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml)，了解其他粒子模拟。这些中的大多数都使用变换反馈实现，但也可以使用计算着色器实现。
- en: Creating a fractal texture using the compute shader
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器创建分形纹理
- en: 'The Mandelbrot set is based on iterations of the following complex polynomial:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗集基于以下复数多项式的迭代：
- en: '![](img/4a042f57-0298-4f05-af19-f4767eca21ac.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a042f57-0298-4f05-af19-f4767eca21ac.png)'
- en: '*z* and *c* are complex numbers. Starting with the value *z = 0 + 0i*, we apply
    the iteration repeatedly until a maximum number of iterations is reached or the
    value of *z* exceeds a specified maximum. For a given value of *c*, if the iteration
    remains stable (*z* doesn''t increase above the maximum) the point is inside the
    Mandelbrot set and we color the position corresponding to *c* black. Otherwise,
    we color the point based on the number of iterations it took for the value to
    exceed the maximum.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*和*c*是复数。从值*z = 0 + 0i*开始，我们重复应用迭代，直到达到最大迭代次数或*z*的值超过指定的最大值。对于给定的*c*值，如果迭代保持稳定（*z*的值不增加超过最大值），则该点是曼德布罗特集内部，我们用黑色着色与*c*相对应的位置。否则，我们根据值超过最大值所需的迭代次数来着色该点。'
- en: 'In the following image, the image of the Mandelbrot set is applied as a texture
    to a cube:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，曼德布罗特集的图像被作为纹理应用到立方体上：
- en: '![](img/4b5984d3-0446-42fb-9653-fc62fdba21de.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b5984d3-0446-42fb-9653-fc62fdba21de.png)'
- en: We'll use the compute shader to evaluate the Mandelbrot set. Since this is another
    image-based technique, we'll use a two-dimensional compute space with one compute
    shader invocation per pixel. Each invocation can work independently, and doesn't
    need to share any data with other invocations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用计算着色器来评估曼德布罗特集。由于这是一种基于图像的技术，我们将使用一个二维计算空间，每个像素有一个计算着色器调用。每个调用可以独立工作，并且不需要与其他调用共享任何数据。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a texture to store the results of our fractal calculation. The image
    should be bound to the image texture unit `0` using `glBindImageTexture`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个纹理来存储我们的分形计算结果。该图像应使用`glBindImageTexture`绑定到图像纹理单元`0`：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the compute shader, we start by defining the number of shader invocations
    per work group:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算着色器中，我们首先定义每个工作组的着色器调用次数：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we declare the output image as well as some other uniform variables:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明输出图像以及其他一些统一变量：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We define a function to compute the number of iterations for a given position
    on the complex plane:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个函数来计算复平面上给定位置的迭代次数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the main function, we start by computing the size of a pixel in the complex
    space:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先计算复空间中像素的大小：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we determine the value of `c` for this invocation:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们确定这次调用的`c`值：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we call the `mandelbrot` function and determine the color based on the
    number of iterations:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用`mandelbrot`函数并根据迭代次数确定颜色：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then write the color to the output image:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们将颜色写入输出图像：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the render function of the OpenGL program, we execute the compute shader
    with one invocation per texel, and call `glMemoryBarrier`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL程序的渲染函数中，我们针对每个texel执行计算着色器，并调用`glMemoryBarrier`：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, we render the scene, applying the texture to the appropriate objects.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们渲染场景，将纹理应用到适当的对象上。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 2, the `ColorImg` uniform variable is the output image. It is defined
    to be located at the image texture unit `0` (via the `binding` layout option).
    Also note that the format is `rgb8`, which must be the same as what is used in
    the `glTexStorage2D` call when creating the texture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，`ColorImg`统一变量是输出图像。它被定义为位于图像纹理单元`0`（通过`binding`布局选项）。此外，请注意格式是`rgb8`，这必须与创建纹理时在`glTexStorage2D`调用中使用的格式相同。
- en: '`MAX_ITERATIONS` is the maximum number of iterations of the complex polynomial
    mentioned earlier. `CompWindow` is the region of complex space with which we are
    working on. The first two components `CompWindow.xy` are the real and imaginary
    parts of the lower-left corner of the window, and `CompWindow.zw` is the upper
    right corner. `Width` and `Height` define the size of the texture image.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX_ITERATIONS`是前面提到的复多项式的最大迭代次数。`CompWindow`是我们正在工作的复空间区域。窗口的左下角的前两个组件`CompWindow.xy`是窗口的实部和虚部，而`CompWindow.zw`是右上角。`Width`和`Height`定义了纹理图像的大小。'
- en: The `mandelbrot` function (step 3) takes a value for `c` as the parameter, and
    repeatedly iterates the complex function until either a maximum number of iterations
    is reached, or the absolute value of `z` becomes greater than `2`. Note that here,
    we avoid computing the square root and just compare the absolute value squared
    with `4`. The function returns the total number of iterations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot`函数（步骤3）接受一个值*c*作为参数，并重复迭代复函数，直到达到最大迭代次数或`z`的绝对值大于`2`。注意，在这里，我们避免计算平方根，只是比较绝对值的平方与`4`。该函数返回总的迭代次数。'
- en: Within the main function (step 4), we start by computing the size of a pixel
    within the complex window (`dx`, `dy`). This is just the size of the window divided
    by the number of texels in each dimension.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数（第4步）中，我们首先计算复窗口内像素的大小（`dx`，`dy`）。这仅仅是窗口大小除以每个维度的texel数量。
- en: The compute shader invocation is responsible for the texel located at `gl_GlobalInvocationID.xy`.
    We compute the point on the complex plane that corresponds to this texel next.
    For the *x* position (real axis), we take the size of the texel in that direction
    (`dx`) times `gl_GlobalInvocationID.x` (which gives us the distance from the left
    edge of the window), plus the position of the left edge of the window (`CompWindow.x`).
    A similar calculation is done for the y position (imaginary axis).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器调用负责位于`gl_GlobalInvocationID.xy`的texel。接下来，我们计算与该texel对应的复平面上的点。对于*x*位置（实轴），我们取该方向上texel的大小（`dx`）乘以`gl_GlobalInvocationID.x`（这给出了窗口左侧边缘的距离），再加上窗口左侧边缘的位置（`CompWindow.x`）。对于y位置（虚轴）也进行类似的计算。
- en: In step 6, we call the `mandelbrot` function with the value for `c` that was
    just determined, and determine a color based on the number of iterations returned.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们使用刚刚确定的`c`值调用`mandelbrot`函数，并根据返回的迭代次数确定颜色。
- en: In step 7, we apply the color to the output image at `gl_GlobalInvocationID.xy` using `imageStore`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步，我们使用`imageStore`将颜色应用到输出图像的`gl_GlobalInvocationID.xy`位置。
- en: In the OpenGL render function (step 8), we dispatch the compute shader with
    enough invocations so that there is one invocation per texel. The `glMemoryBarrier` call
    assures that all writes to the output image are complete before continuing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL渲染函数（第8步）中，我们使用足够的调用次数来分配计算着色器，使得每个texel有一个调用。`glMemoryBarrier`调用确保在继续之前所有对输出图像的写入都已完成。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Prior to the advent of the compute shader, we might have chosen to do this using
    the fragment shader. However, the compute shader gives us a bit more flexibility
    in defining how the work is allocated on the GPU. We can also gain memory efficiency
    by avoiding the overhead of a complete FBO for the purposes of a single texture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算着色器出现之前，我们可能会选择使用片段着色器来完成这项工作。然而，计算着色器为我们提供了更多的灵活性，以定义如何在GPU上分配工作。我们还可以通过避免为单个纹理的完整FBO开销来提高内存效率。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter11/scenemandelbrot.cpp` file in the example code
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter11/scenemandelbrot.cpp`文件
- en: Using the compute shader for cloth simulation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器进行布料模拟
- en: 'The compute shader is well-suited for harnessing the GPU for physical simulation.
    Cloth simulation is a prime example. In this recipe, we''ll implement a simple
    particle-spring-based cloth simulation using the compute shader. The following
    is an image of the simulation of a cloth hanging by five pins (you''ll have to
    imagine it animating):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器非常适合利用GPU进行物理模拟。布料模拟是一个很好的例子。在这个菜谱中，我们将使用计算着色器实现一个基于粒子-弹簧的简单布料模拟。以下是一张布料通过五个钉子悬挂的模拟图像（您需要想象它在动画化）：
- en: '![](img/49737ff4-333c-43cc-a4d7-0fcd197f0d1d.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49737ff4-333c-43cc-a4d7-0fcd197f0d1d.png)'
- en: 'A common way to represent cloth is with a particle-spring lattice. The cloth
    is composed of a 2D grid of point masses, each connected to its eight neighboring
    masses with idealized springs. The following diagram represents one of the point
    masses (center) connected to its neighboring masses. The lines represent the springs.
    The dark lines are the horizontal/vertical springs and the dashed lines are the
    diagonal springs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表示布料的一种常见方式是使用粒子-弹簧晶格。布料由一个二维的点质量网格组成，每个点质量通过理想化的弹簧与其八个相邻的质量连接。以下图表示了一个点质量（中心）与其相邻质量连接的情况。线条代表弹簧。深色线条是水平/垂直弹簧，虚线是斜向弹簧：
- en: '![](img/f16c5ecd-b843-4421-9401-0ec1bb8d1fe4.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f16c5ecd-b843-4421-9401-0ec1bb8d1fe4.png)'
- en: 'The total force on a particle is the sum of the forces produced by the eight
    springs to which it is connected. The force for a single spring is given by the
    following equation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个粒子的总力是连接到它的八个弹簧产生的力的总和。单个弹簧的力由以下方程给出：
- en: '![](img/91f33d6d-afec-42fc-9255-69d96af6732c.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91f33d6d-afec-42fc-9255-69d96af6732c.png)'
- en: '*K* is the stiffness of the spring, *R* is the rest-length of the spring (the
    length where the spring applies zero force), and *r* is the vector between the
    neighboring particle and the particle (the neighbor''s position minus the particle''s
    position).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*K* 是弹簧的刚度，*R* 是弹簧的静止长度（弹簧施加零力的长度），而 *r* 是相邻粒子与粒子之间的矢量（相邻粒子的位置减去粒子的位置）。'
- en: Similar to the previous recipe, the process is simply to compute the total force
    on each particle and then integrate Newton's equations of motion using our favorite
    integration. Again, we'll use the Euler method for this example. For details on
    the Euler method, refer to the previous *Implementing a particle simulation with
    the compute shader *recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方类似，过程仅仅是计算每个粒子的总力，然后使用我们喜欢的积分方法积分牛顿运动方程。再次强调，我们将使用欧拉法来演示这个例子。有关欧拉法的详细信息，请参阅之前的*使用计算着色器实现粒子模拟*配方。
- en: This particle-spring lattice is obviously a two-dimensional structure, so it
    makes sense to map it to a two-dimensional compute space. We'll define rectangular
    work groups and use one shader invocation per particle. Each invocation needs
    to read the positions of its eight neighbors, compute the force on the particle,
    and update the particle's position and velocity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个粒子-弹簧晶格显然是一个二维结构，因此将其映射到二维计算空间是有意义的。我们将定义矩形工作组，并为每个粒子使用一个着色器调用。每个调用需要读取其八个邻居的位置，计算粒子的力，并更新粒子的位置和速度。
- en: Note that, in this case, each invocation needs to read the positions of the
    neighboring particles. Those neighboring particles will be updated by other shader
    invocations. Since we can't rely on any execution order for the shader invocations,
    we can't read and write directly to the same buffer. If we were to do so, we wouldn't
    know for sure whether we were reading the original positions of the neighbors
    or their updated positions. To avoid this problem, we'll use pairs of buffers.
    For each simulation step, one buffer will be designated for reading and the other
    for writing, then we'll swap them for the next step, and repeat.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，每个调用都需要读取相邻粒子的位置。这些相邻粒子将由其他着色器调用更新。由于我们不能依赖于着色器调用的任何执行顺序，我们不能直接读写同一个缓冲区。如果我们这样做，我们就无法确定我们是在读取邻居的原始位置还是它们更新的位置。为了避免这个问题，我们将使用成对的缓冲区。对于每个模拟步骤，一个缓冲区将指定为读取，另一个为写入，然后我们将在下一步中交换它们，并重复此过程。
- en: It might be possible to read/write to the same buffer with careful use of local
    shared memory; however, there is still the issue of the particles along the edges
    of the work group. Their neighbor's positions are managed by another work group,
    and again, we have the same problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细使用局部共享内存，可能能够读写同一个缓冲区；然而，仍然存在工作组边缘的粒子问题。它们的邻居位置由另一个工作组管理，再次，我们面临相同的问题。
- en: 'This simulation tends to be quite sensitive to numerical noise, so we need
    to use a very small integration time step. A value of around `0.000005` works
    well. Additionally, the simulation looks better when we apply a damping force
    to simulate air resistance. A good way to simulate air resistance is to add a
    force that is proportional to and in the opposite direction to the velocity, as
    in the following equation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟对数值噪声非常敏感，因此我们需要使用一个非常小的积分时间步长。大约 `0.000005` 的值效果很好。此外，当我们将阻尼力应用于模拟空气阻力时，模拟看起来会更好。模拟空气阻力的一种好方法是添加一个与速度成正比且方向相反的力，如下面的方程所示：
- en: '![](img/b4b10f92-db5d-47fb-8084-9d301c77303f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4b10f92-db5d-47fb-8084-9d301c77303f.png)'
- en: '*D* is the strength of the damping force and *v* is the velocity of the particle.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*D* 是阻尼力的强度，而 *v* 是粒子的速度。'
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start by setting up two buffers for the particle position and two for the particle
    velocity. We'll bind them to the `GL_SHADER_STORAGE_BUFFER` indexed binding point
    at indices `0` and `1` for the position buffers and `2` and `3` for the velocity
    buffers. The data layout in these buffers is important. We'll lay out the particle
    positions/velocities in row-major order starting at the lower left and proceeding
    to the upper right of the lattice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为粒子位置和速度设置两个缓冲区。我们将它们绑定到 `GL_SHADER_STORAGE_BUFFER` 索引绑定点，索引 `0` 和 `1` 用于位置缓冲区，`2`
    和 `3` 用于速度缓冲区。这些缓冲区中的数据布局很重要。我们将以行主序的顺序从格子的左下角开始布局粒子位置/速度，一直延伸到右上角。
- en: We'll also set up a vertex array object for drawing the cloth using the particle
    positions as triangle vertices. We may also need buffers for normal vectors and
    texture coordinates. For brevity, I'll omit them from this discussion, but the
    example code for this book includes them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置一个顶点数组对象，用于使用粒子位置作为三角形顶点绘制布料。我们可能还需要缓冲区来存储法向量和纹理坐标。为了简洁，我将省略这些内容，但本书的示例代码中包含了它们。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the compute shader, we start by defining the number of invocations per work
    group:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算着色器中，我们首先定义每个工作组中的调用次数：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we define a set of uniform variables for the simulation parameters:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一组用于模拟参数的统一变量：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, declare the shader storage buffer pairs for the position and velocity:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明位置和速度的着色器存储缓冲区对：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the main function, we get the position of the particle for which this invocation
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们获取此调用负责的粒子的位置：
- en: 'is responsible for:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负责：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initialize our force with the force due to gravity:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用重力产生的力初始化我们的力：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the force due to the particle before this one:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之前的粒子上添加力：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Repeat the preceding steps for the following particles and to the left and
    right. Then, add the force due to the particle that is diagonally above and to
    the left:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下粒子以及左侧和右侧的粒子重复前面的步骤。然后，添加来自左上方的粒子的力：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Repeat the preceding steps for the other three diagonally connected particles.
    Then, add the damping force:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其他三个对角连接的粒子重复前面的步骤。然后，添加阻尼力：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we integrate the equations of motion using the Euler method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用欧拉方法积分运动方程：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we pin some of the top verts so that they do not move:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将一些顶点固定，以便它们不会移动：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Within the OpenGL render function, we invoke the compute shader so that each
    work group is responsible for 100 particles. Since the time step size is so small,
    we need to execute the process many times (`1000`), each time swapping the input
    and output buffers:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenGL 渲染函数中，我们调用计算着色器，以便每个工作组负责 100 个粒子。由于时间步长非常小，我们需要多次执行此过程（`1000` 次），每次交换输入和输出缓冲区：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we render the cloth using the position data from the position buffer.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用位置缓冲区中的位置数据渲染布料。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We use `100` invocations per work group, `10` in each dimension. The first
    statement in the compute shader defines the number of invocations per work group:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个工作组中使用 `100` 个调用，每个维度 `10` 个。计算着色器中的第一个语句定义了每个工作组中的调用次数：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The uniform variables that follow define the constants in the force equations
    and the rest the lengths for each of the horizontal, vertical, and diagonal springs.
    The time step size is `DeltaT`. The position and velocity buffers are declared
    next. We define the position buffers at binding indexes `0` and `1`, and the velocity
    buffers at indexes `2` and `3`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的统一变量定义了力方程中的常数以及每个水平、垂直和对角弹簧的长度。时间步长大小是 `DeltaT`。接下来声明位置和速度缓冲区。我们定义位置缓冲区在绑定索引
    `0` 和 `1`，速度缓冲区在索引 `2` 和 `3`。
- en: In the main function (step 4), we start by determining the number of particles
    in each dimension. This is going to be the same as the number of work groups times
    the work group size. Next, we determine the index of the particle for which this
    invocation is responsible for. Since the particles are organized in the buffers
    in row-major order, we compute the index by the global invocation ID in the *y*
    direction times the number of particles in the *x* dimension, plus the global
    invocation ID in the *x* direction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数（步骤 4）中，我们首先确定每个维度的粒子数量。这将与工作组的数量乘以工作组大小相同。接下来，我们确定此调用负责的粒子的索引。由于粒子在缓冲区中按行主序组织，我们通过
    *y* 方向的全局调用 ID 乘以 *x* 维度的粒子数量，再加上 *x* 方向的全局调用 ID 来计算索引。
- en: In step 5, we initialize our force with the gravitational force, `Gravity` times
    the mass of a particle (`ParticleMass`). Note that it's not really necessary here
    to multiply by the mass since all particles have the same mass. We could just
    pre-multiply the mass into the gravitational constant.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 5 中，我们使用重力，`Gravity` 乘以粒子的质量（`ParticleMass`）来初始化我们的力。请注意，在这里乘以质量实际上并不是必需的，因为所有粒子都有相同的质量。我们只需预先将质量乘入重力常数。
- en: In steps 6 and 7, we add the force on this particle due to each of the eight
    neighboring particles connected by virtual springs. For each spring, we add the
    force due to that spring. However, we first need to check to see if we are on
    the edge of the lattice. If we are, there may not be a neighboring particle (see
    the following diagram).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6和7中，我们添加了由虚拟弹簧连接的每个相邻粒子对当前粒子的力。对于每根弹簧，我们添加由该弹簧产生的力。然而，我们首先需要检查我们是否位于晶格的边缘。如果是，可能没有相邻的粒子（参见以下图示）。
- en: 'For example, in the preceding code, when computing the force due to the preceding
    spring/particle, we verify that `gl_GlobalInvocationID.y` is less than the number
    of particles in the *y* dimension minus one. If that is true, there must be a
    particle above this one. Otherwise, the current particle is on the top edge of
    the lattice and there is no neighboring particle above it. (Essentially, `gl_GlobalInvocationID`
    contains the particle''s location in the overall lattice.) We can do a similar
    test for the other three horizontal/vertical directions. When computing the force
    for the diagonally connected particles, we need to check that we''re not on a
    horizontal and a vertical edge. For example, in the preceding code, we''re looking
    for the particle that is above and to the left, so we check that `gl_GlobalInvocationID.x`
    is greater than zero (not on the left edge), and that `gl_GlobalInvocationID.y`
    is less than the number of particles in the y direction minus one (not on the
    top edge):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的代码中，当计算前面弹簧/粒子的力时，我们验证`gl_GlobalInvocationID.y`是否小于*y*维度中粒子数量的减一。如果是这样，那么必须有一个粒子位于这个粒子上方。否则，当前粒子位于晶格的顶部边缘，上方没有相邻的粒子。（本质上，`gl_GlobalInvocationID`包含了粒子在整体晶格中的位置。）我们可以对其他三个水平/垂直方向进行类似的测试。当计算对角连接的粒子的力时，我们需要检查我们是否不在水平和垂直边缘上。例如，在上面的代码中，我们正在寻找位于上方和左方的粒子，因此我们检查`gl_GlobalInvocationID.x`是否大于零（不在左边边缘），以及`gl_GlobalInvocationID.y`是否小于y方向中粒子数量的减一（不在顶部边缘）：
- en: '![](img/bb92f5f0-56e7-447f-a321-ca314767ae5d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb92f5f0-56e7-447f-a321-ca314767ae5d.png)'
- en: Once we verify that the neighboring particle exists, we compute the force due
    to the spring connected to that particle and add it to the total force. We organized
    our particles in row-major order in the buffer. Therefore, to access the position
    of the neighboring particle, we take the index of the current particle and add/subtract
    the number of particles in the *x* direction to move vertically, and/or add/subtract
    one to move horizontally.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了相邻粒子的存在，我们就计算连接到该粒子的弹簧产生的力，并将其添加到总力中。我们在缓冲区中按行主序组织粒子。因此，要访问相邻粒子的位置，我们取当前粒子的索引，并添加/减去*x*方向中粒子数量以垂直移动，以及/或添加/减去一个以水平移动。
- en: In step 8, we apply the damping force that simulates air resistance by adding
    to the total force `DampingConst` times the velocity. The minus sign here assures
    that the force is in the opposite direction of the velocity.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤8中，我们通过将速度乘以阻尼系数`DampingConst`来添加模拟空气阻力的阻尼力，并将其添加到总力中。这里的负号确保力与速度方向相反。
- en: In step 9, we apply the Euler method to update the position and velocity based
    on the force. We multiply the force by the inverse of the particle mass to get
    the acceleration, then store the results of the Euler integration into the corresponding
    positions in the output buffers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤9中，我们应用欧拉方法根据力更新位置和速度。我们将力乘以粒子质量的倒数以获得加速度，然后将欧拉积分的结果存储到输出缓冲区中相应的位置。
- en: Finally, in step 10, we reset the position of the particle if it is located
    at one of the five pin positions at the top of the cloth.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤10中，如果粒子位于布料顶部的五个固定位置之一，我们重置粒子的位置。
- en: Within the OpenGL render function (step 11), we invoke the compute shader multiple
    times, switching the input/output buffers after each invocation. After calling
    `glDispatchCompute`, we issue a `glMemoryBarrier` call to make sure that all shader
    writes have completed before swapping the buffers. Once that is complete, we go
    ahead and render the cloth using the positions from the shader storage buffer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL渲染函数（步骤11）中，我们多次调用计算着色器，每次调用后切换输入/输出缓冲区。在调用`glDispatchCompute`之后，我们发出`glMemoryBarrier`调用以确保在交换缓冲区之前所有着色器写入都已完成。一旦完成，我们就使用着色器存储缓冲区中的位置渲染布料。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For rendering, it is useful to have normal vectors. One option is to create
    another compute shader to recalculate the normal vectors after the positions are
    updated. For example, we might execute the preceding compute shader 1,000 times,
    dispatch the other compute shader once to update the normals, and then render
    the cloth.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染，拥有法向量是有用的。一个选项是创建另一个计算着色器，在位置更新后重新计算法向量。例如，我们可能执行前面的计算着色器1,000次，然后一次调度其他计算着色器来更新法向量，接着渲染布料。
- en: Additionally, we may be able to achieve better performance with the use of local
    shared data within the work group. In the preceding implementation, the position
    of each particle is read a maximum of eight times. Each read can be costly in
    terms of execution time. It is faster to read from memory that is closer to the
    GPU. One way to achieve this is to read data into local shared memory once, and
    then read from the shared memory for subsequent reads. In the next recipe, we'll
    see an example of how this is done. It would be straightforward to update this
    recipe in a similar way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能通过在工作组内使用局部共享数据来获得更好的性能。在前面的实现中，每个粒子的位置最多被读取八次。每次读取在执行时间上可能都是昂贵的。从更接近GPU的内存读取会更快。实现这一点的办法是一次性将数据读入局部共享内存，然后从共享内存中进行后续读取。在下一个配方中，我们将看到一个如何这样做的例子。以类似的方式更新这个配方将是直接的。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter11/scenecloth.cpp` file in the example code
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter11/scenecloth.cpp` 文件
- en: The *Implementing an edge detection filter with the compute shader* recipe
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用计算着色器实现边缘检测滤波器* 的配方'
- en: Implementing an edge detection filter with the compute shader
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器实现边缘检测滤波器
- en: In the *Applying an edge detection filter* recipe in [Chapter 6](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml),
    *Image Processing and Screen Space Techniques*, we saw an example of how to implement
    edge detection using the fragment shader. The fragment shader is well-suited for
    many image-processing operations, because we can trigger the execution of the
    fragment shader for each pixel by rendering a screen-filling quad. Since image
    processing filters are often applied to the result of a render, we can render
    to a texture, then invoke the fragment shader for each screen pixel (by rendering
    a quad), and each fragment shader invocation is then responsible for processing
    a single pixel. Each invocation might need to read from several locations in the
    (rendered) image texture, and a texel might be read multiple times from different
    invocations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml)的 *应用边缘检测滤波器* 配方中，我们看到了如何使用片段着色器实现边缘检测的例子。片段着色器非常适合许多图像处理操作，因为我们可以通过渲染一个填充屏幕的四边形来触发每个像素的片段着色器执行。由于图像处理滤波器通常应用于渲染结果，我们可以将渲染输出到纹理中，然后对每个屏幕像素（通过渲染一个四边形）调用片段着色器，每个片段着色器的调用负责处理单个像素。每次调用可能需要从（渲染的）图像纹理的几个位置读取，并且一个纹理元素可能被不同的调用多次读取。
- en: This works well for many situations, but the fragment shader was not designed
    for image processing. With the compute shader, we can have more fine-grained control
    over the distribution of shader invocations, and we can make use of local shared
    memory to gain a bit more efficiency with data reads.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很多情况下都很好用，但片段着色器并不是为图像处理设计的。使用计算着色器，我们可以对着色器调用的分布有更精细的控制，并且我们可以利用局部共享内存来在数据读取上获得更多的效率。
- en: In this example, we'll re-implement the edge detection filter using the compute
    shader. We'll make use of local (work group) shared memory to gain additional
    speed. Since this local memory is closer to the GPU, memory access is faster than
    it would be when reading directly from the shader storage buffers (or textures).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用计算着色器重新实现边缘检测滤波器。我们将利用局部（工作组）共享内存来获得额外的速度。由于这种局部内存更接近GPU，内存访问比直接从着色器存储缓冲区（或纹理）读取要快。
- en: 'As with the previous recipe, we''ll implement this using the Sobel operator,
    which is made up of two 3 x 3 filter kernels which is, shown as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的配方一样，我们将使用Sobel算子来实现这个功能，它由两个3 x 3的滤波内核组成，如下所示：
- en: '![](img/14262d3a-5189-4b11-a0ce-31960810877c.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14262d3a-5189-4b11-a0ce-31960810877c.png)'
- en: For details on the Sobel operator, refer to [Chapter 6](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml),
    *Image Processing and Screen Space Techniques*. The key point here is that in
    order to compute the result for a given pixel, we need to read the values of the
    eight neighboring pixels. This means that the value of each pixel needs to be
    fetched up to eight times (when processing the neighbors of that pixel). To gain
    some additional speed, we'll copy the needed data into local shared memory so
    that, within a work group, we can read from the shared memory rather than fetching
    it from the shader storage buffer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Sobel算子的详细信息，请参阅第6章，*图像处理和屏幕空间技术*。这里的关键点是，为了计算给定像素的结果，我们需要读取八个相邻像素的值。这意味着每个像素的值需要被提取多达八次（当处理该像素的邻居时）。为了获得一些额外的速度，我们将所需数据复制到本地共享内存中，这样在工作组内，我们可以从共享内存中读取而不是从着色器存储缓冲区中提取。
- en: Work group shared memory is generally faster to access than texture or shader
    storage memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 工作组共享内存通常比纹理或着色器存储内存更快访问。
- en: In this example, we'll use one compute shader invocation per pixel, and a 2D
    work group size of 25 x 25\. Before computing the Sobel operator, we'll copy the
    corresponding pixel values into local shared memory for the work group. For each
    pixel, in order to compute the filter, we need to read the values of the eight
    neighboring pixels. In order to do so for the pixels on the edge of the work group,
    we need to include in our local memory an extra strip of pixels outside the edges
    of the work group. Therefore, for a work group size of 25 x 25, we'll need a storage
    size of 27 x 27.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将为每个像素使用一个计算着色器调用，并且使用25 x 25的2D工作组大小。在计算Sobel算子之前，我们将相应的像素值复制到工作组的本地共享内存中。对于每个像素，为了计算滤波器，我们需要读取八个相邻像素的值。为了处理工作组边缘的像素，我们需要在我们的本地内存中包含一个额外的像素条，超出工作组的边缘。因此，对于25
    x 25的工作组大小，我们需要27 x 27的存储大小。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start by setting up for rendering to a **framebuffer object** (**FBO**) with
    a color texture attached; we'll render the raw pre-filtered image to this texture.
    Create a second texture to receive the output from the edge-detection filter.
    Bind this latter texture to unit `0`. We'll use this as the output from the compute
    shader. Bind the FBO texture to image texture unit `0`, and the second texture
    to image texture unit `1` using `glBindImageTexture`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置渲染到**帧缓冲对象**（**FBO**）并附加一个颜色纹理；我们将把原始预过滤图像渲染到这个纹理上。创建第二个纹理以接收边缘检测滤波器的输出。将这个纹理绑定到单元`0`。我们将使用这个作为计算着色器的输出。使用`glBindImageTexture`将FBO纹理绑定到图像纹理单元`0`，并将第二个纹理绑定到图像纹理单元`1`。
- en: Next, set up a vertex/fragment shader pair for rendering directly to the FBO,
    and for rendering a full-screen texture.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置一个用于直接渲染到FBO以及渲染全屏纹理的顶点/片段着色器对。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the compute shader, as usual, we start by defining the number of shader
    invocations per work group:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算着色器中，像往常一样，我们首先定义每个工作组的着色器调用次数：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we declare uniform variables for our input and output images and for
    the edge detection threshold. The input image is the rendered image from the FBO,
    and the output image will be the result of the edge detection filter:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明用于输入和输出图像以及边缘检测阈值的统一变量。输入图像是从FBO渲染的图像，输出图像将是边缘检测滤波器的结果：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we declare our work group''s shared memory, which is an array of size
    27 x 27:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明我们的工作组共享内存，它是一个大小为27 x 27的数组：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We also define a function for computing the luminance of a pixel called `luminance`.
    Since the same function was used in several previous recipes, this need not be
    repeated here.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个用于计算像素亮度的函数，称为`luminance`。由于相同的函数在几个先前的菜谱中使用，这里不需要重复。
- en: 'Next, we define a function that applies the Sobel filter to the pixel that
    corresponds to this shader invocation. It reads directly from the local shared
    data:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数，该函数将Sobel滤波器应用于与这个着色器调用对应的像素。它直接从本地共享数据中读取：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the main function, we start by copying the luminance for this pixel into
    the shared memory array:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先将此像素的亮度复制到共享内存数组中：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we're on the edge of the work group, we need to copy one or more additional
    pixels into the shared memory array in order to fill out the pixels around the
    edge. So, we need to determine whether or not we're on the edge of the work group
    (by examining `gl_LocalInvocationID`), and then determine which pixels we're responsible
    for copying. This is not complex, but is fairly involved and lengthy, due to the
    fact that we also must determine whether or not that external pixel actually exists.
    For example, if this work group is on the edge of the global image, then some
    of the edge pixels don't exist (are outside of the image). Due to its length,
    I won't include that code here. For full details, grab the code for this book
    from the GitHub site.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在工作组的边缘，我们需要将一个或多个额外的像素复制到共享内存数组中，以便填充边缘周围的像素。因此，我们需要确定我们是否在工作组的边缘（通过检查
    `gl_LocalInvocationID`），然后确定我们负责复制的像素。这并不复杂，但由于我们还需要确定外部像素是否实际存在，所以相当复杂且冗长。例如，如果此工作组位于全局图像的边缘，则一些边缘像素不存在（位于图像之外）。由于其长度，我不会在这里包含那段代码。有关完整详情，请从
    GitHub 网站获取此书的代码。
- en: 'Once we''ve copied the data for which this shader invocation is responsible,
    we need to wait for other invocations to do the same, so here we invoke a barrier.
    Then, we call our `applyFilter` function to compute the filter and write the results
    to the output image:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们复制了此着色器调用负责的数据，我们需要等待其他调用执行相同的操作，因此在这里我们调用一个屏障。然后，我们调用我们的 `applyFilter`
    函数来计算过滤器并将结果写入输出图像：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the OpenGL render function, we start by rendering the scene to the FBO,
    then dispatch the compute shader, and wait for it to finish all of its writes
    to the output image:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenGL 渲染函数中，我们首先将场景渲染到 FBO，然后调度计算着色器，并等待它完成对输出图像的所有写入操作：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, we render the output image to the screen via a full-screen quad.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过全屏四边形将输出图像渲染到屏幕上。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we specify 625 shader invocations per work group, 25 in each dimension.
    Depending on the system on which the code is running, this could be changed to
    better match the hardware available.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们指定每个工作组 625 次着色器调用，每个维度 25 次。根据代码运行的系统，这可能需要更改以更好地匹配可用的硬件。
- en: The uniform `image2D` variables (step 2) are the input and output images. Note
    the binding locations indicated in the layout qualifier. These correspond to the
    image units specified in the `glBindImageTexture` call within the main OpenGL
    program. The input image should contain the rendered scene, and corresponds to
    the image texture bound to the FBO. The output image will receive the result of
    the filter. Also note the use of `rgb8` as the format. This must be the same as
    the format used when creating the image using `glTexStorage2D`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 `image2D` 变量（步骤 2）是输入和输出图像。注意布局限定符中指示的绑定位置。这些对应于 `glBindImageTexture` 调用中指定的图像单元。输入图像应包含渲染的场景，对应于绑定到
    FBO 的图像纹理。输出图像将接收过滤器的结果。请注意使用 `rgb8` 作为格式。这必须与使用 `glTexStorage2D` 创建图像时使用的格式相同。
- en: The `localData` array is declared in step 3 with the shared qualifier. This
    is our work group's local shared memory. The size is 27 x 27 in order to include
    an extra strip, one pixel wide along the edges. We store the luminance of all
    of the pixels in the work group here, plus the luminance for a strip of surrounding
    pixels of width one.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`localData` 数组在步骤 3 中声明为具有共享限定符。这是我们工作组的本地共享内存。其大小为 27 x 27，以便包括一个额外的条带，边缘宽度为
    1 像素。我们在这里存储工作组中所有像素的亮度，以及宽度为 1 的周围像素条的亮度。'
- en: 'The `applyFilter` function (step 5) is where the Sobel operator is computed
    using the data in `localData`. It is fairly straightforward, except for an offset
    that needs to be applied due to the extra strip around the edges. The luminance
    of the pixel that this invocation is responsible for is located at:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyFilter` 函数（步骤 5）是计算 Sobel 算子，使用的是 `localData` 中的数据。这相当直接，除了由于边缘额外的条带而需要应用的一个偏移量。负责此调用的像素的亮度位于：'
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Without the extra strip of pixels, we could just use `gl_LocalInvocationID`,
    but here we need to add an offset of one in each dimension.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有额外的像素条带，我们就可以直接使用 `gl_LocalInvocationID`，但在这里我们需要在每个维度上添加一个偏移量为一的值。
- en: The next few statements just compute the Sobel operator, and determine the magnitude
    of the gradient, stored in `g`. This is done by reading the luminance of the eight
    nearby pixels, reading from the `localData` shared array.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个语句只是计算Sobel算子，并确定梯度的幅度，存储在`g`中。这是通过读取八个附近像素的亮度，从共享数组`localData`中读取来完成的。
- en: At the end of the `applyFilter` function, we write to `OutputImg` as the result
    of the filter. This is either (1,1,1,1) or (0,0,0,1), depending on whether `g`
    is above the threshold or not. Note that here, we use `gl_GlobalInvocationID`
    as the location in the output image. The global ID is appropriate for determining
    the location within the global image, while the local ID tells us where we are
    within the local work group, and is more appropriate for access to the local shared
    array.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`applyFilter`函数的末尾，我们将结果写入`OutputImg`。这要么是(1,1,1,1)，要么是(0,0,0,1)，具体取决于`g`是否超过阈值。注意，在这里，我们使用`gl_GlobalInvocationID`作为输出图像中的位置。全局ID适用于确定全局图像中的位置，而局部ID告诉我们我们在局部工作组中的位置，更适合访问局部共享数组。
- en: In the main function (step 6), we compute the luminance of the pixel corresponding
    to this invocation (at `gl_GlobalInvocationID`) and store it in the local shared
    memory (`localData`) at `gl_LocalInvocationID + 1`. Again, the `+ 1` is due to
    the additional space for the edge pixels.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数（步骤6）中，我们计算与此次调用对应的像素（在`gl_GlobalInvocationID`）的亮度，并将其存储在本地共享内存（`localData`）中，位置为`gl_LocalInvocationID
    + 1`。同样，`+ 1`是由于边缘像素的额外空间。
- en: The next step (step 7) is to copy the edge pixels. We only do so if this invocation
    is on the edge of the work group. Additionally, we need to determine if the edge
    pixels actually exist or not. For details on this, refer to the code that accompanies
    this book.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步（步骤7）是复制边缘像素。我们只有在此次调用位于工作组边缘时才这样做。此外，我们还需要确定边缘像素实际上是否存在。有关详细信息，请参阅本书附带的代码。
- en: In step 8, we call the GLSL barrier function. This synchronizes all shader invocations
    within the work group to this point in the code, assuring that all writes to the
    local shared data have completed. Without calling the barrier function, there's
    no guarantee that all shader invocations will have finished writing to `localData`,
    and therefore the data might be incomplete. It is interesting (and instructive)
    to remove this call and observe the results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤8中，我们调用GLSL屏障函数。这同步了工作组内所有着色器调用到代码的这个点，确保所有对局部共享数据的写入都已完成。如果不调用屏障函数，则无法保证所有着色器调用都会完成对`localData`的写入，因此数据可能是不完整的。移除此调用并观察结果是有趣的（也是富有教育意义的）。
- en: Finally, we call `applyFilter` to compute the Sobel operator and write to the
    output image.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`applyFilter`来计算Sobel算子并将其写入输出图像。
- en: Within the OpenGL render function, we dispatch the compute shader so that there
    are enough work groups to cover the image. Since the work group size is 25 x 25,
    we invoke *width/25* work groups in the *x* dimension and *height/25* in the *y*.
    The result is one shader invocation per pixel in the input/output image.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL渲染函数中，我们调度计算着色器，以便有足够的工作组来覆盖图像。由于工作组大小为25 x 25，我们在*x*维度上调用`width/25`个工作组，在*y*维度上调用`height/25`个工作组。结果是输入/输出图像中的每个像素都有一个着色器调用。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is a straightforward example of the use of local shared memory. It is only
    slightly complicated by the fact that we need to deal with the extra row/column
    of pixels. In general, however, local shared data can be used for any type of
    communication between invocations within a work group. In this case, the data
    is not used for communication, but is instead used to increase efficiency by decreasing
    the global number of reads from the image.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个使用局部共享内存的简单示例。它仅因我们需要处理额外的行/列像素而略显复杂。然而，一般来说，局部共享数据可以用于工作组内调用之间的任何类型的通信。在这种情况下，数据不是用于通信，而是通过减少从图像的全局读取次数来提高效率。 '
- en: Note that there are (sometimes stringent) limits on the size of shared memory.
    We can use `GL_MAX_COMPUTE_SHARED_MEMORY_SIZE` (via `glGetInteger*`) to query
    the maximum size available on the current hardware. The minimum required by the
    OpenGL specification is 32 KB.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，共享内存的大小（有时是严格的）有限。我们可以使用`GL_MAX_COMPUTE_SHARED_MEMORY_SIZE`（通过`glGetInteger*`）来查询当前硬件上可用的最大大小。OpenGL规范要求的最小大小是32
    KB。
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter11/sceneedge.cpp` file in the example code
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter11/sceneedge.cpp`文件
- en: The *Applying an edge detection filter* recipe in [Chapter 6](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml),
    *Image Processing and Screen Space Techniques*
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml)的*应用边缘检测过滤器*菜谱中，*图像处理和屏幕空间技术*
