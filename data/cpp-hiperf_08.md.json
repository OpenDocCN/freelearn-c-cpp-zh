["```cpp\n// pow_n accepts any number type \ntemplate <typename T> \nauto pow_n(const T& v, int n) { \n  auto product = T{1}; \n  for (int i = 0; i < n; ++i) { \n    product *= v; \n  }\n  return product; \n} \n```", "```cpp\nauto x = pow_n<float>(2.0f, 3); // x is a float \nauto y = pow_n<int>(3, 3);      // y is an int \n```", "```cpp\nauto x = pow_n(2.0f, 3);  // x is a float \nauto y = pow_n(3, 3);     // y is an int \n```", "```cpp\n// Rectangle can be of any type \ntemplate <typename T> \nclass Rectangle { \npublic: \n  Rectangle(T x, T y, T w, T h) : x_{x}, y_{y}, w_{w}, h_{h} {} \n  auto area() const { return w_ * h_; } \n  auto width() const { return w_; } \n  auto height() const { return h_; } \nprivate:\n  T x_{}, y_{}, w_{}, h_{}; \n}; \n```", "```cpp\nauto r1 = Rectangle<float>{2.0f, 2.0f, 4.0f, 4.0f}; \n```", "```cpp\nauto r2 = Rectangle{-2, -2, 4, 4};   // Rectangle<int> \n```", "```cpp\ntemplate <typename T> \nauto is_square(const Rectangle<T>& r) { \n  return r.width() == r.height(); \n} \n```", "```cpp\ntemplate <int N, typename T> \nauto const_pow_n(const T& v) { \n  auto product = T{1}; \n  for (int i = 0; i < N; ++i) { \n    product *= v; \n  }\n  return product; \n} \n```", "```cpp\nauto x2 = const_pow_n<2>(4.0f);   // Square\nauto x3 = const_pow_n<3>(4.0f);   // Cube \n```", "```cpp\ntemplate<>\nauto const_pow_n<2, int>(const int& v) {\n  return v * v;\n} \n```", "```cpp\nauto a = pow_n(42, 3);          // 1\\. Generate new function\nauto b = pow_n(42.f, 2);        // 2\\. Generate new function\nauto c = pow_n(17.f, 5);        // 3.\nauto d = const_pow_n<2>(42.f);  // 4\\. Generate new function\nauto e = const_pow_n<2>(99.f);  // 5.\nauto f = const_pow_n<3>(42.f);  // 6\\. Generate new function \n```", "```cpp\nauto pow_n__float(float v, int n) {/*...*/}   // Used by: 1\nauto pow_n__int(int v, int n) {/*...*/}       // Used by: 2 and 3\nauto const_pow_n__2_float (float v) {/*...*/} // Used by: 4 and 5\nauto const_pow_n__3_float(float v) {/*...*/}  // Used by: 6 \n```", "```cpp\ntemplate <typename T>\nauto pow_n(const T& v, int n) { \n  // ... \n```", "```cpp\nauto pow_n(const auto& v, int n) { // Declares a function template\n  // ... \n```", "```cpp\nauto pow_n(const auto& v, int n) {\n  auto product = T{1}; // Error: What is T?\n  for (int i = 0; i < n; ++i) { \n    product *= v; \n  } \n  return product;\n} \n```", "```cpp\nauto pow_n(const auto& v, int n) {\n  auto product = decltype(v){1};   // Instead of T{1}\n  for (int i = 0; i < n; ++i) { product *= v; } \n  return product;\n} \n```", "```cpp\nauto pow_n(const auto& v, int n) {\n  decltype(v) product{1};\n  for (int i = 0; i < n; ++i) { product *= v; } // Error!\n  return product;\n} \n```", "```cpp\ntypename std::remove_cvref<decltype(v)>::type product{1}; \n```", "```cpp\nauto pow_n = []<class T>(const T& v, int n) { \n  auto product = T{1};\n  for (int i = 0; i < n; ++i) { product *= v; }\n  return product;\n}; \n```", "```cpp\nauto same_type = std::is_same_v<uint8_t, unsigned char>; \nauto is_float_or_double = std::is_floating_point_v<decltype(3.f)>; \n```", "```cpp\nclass Planet {};\nclass Mars : public Planet {};\nclass Sun {};\nstatic_assert(std::is_base_of_v<Planet, Mars>);\nstatic_assert(!std::is_base_of_v<Planet, Sun>); \n```", "```cpp\n// Examples of type traits which transforms types\nusing value_type = std::remove_pointer_t<int*>;  // -> int\nusing ptr_type = std::add_pointer_t<float>;      // -> float* \n```", "```cpp\ntemplate<typename T>\nauto sign_func(T v) -> int {\n  if (std::is_unsigned_v<T>) { \n    return 1; \n  } \n  return v < 0 ? -1 : 1; \n} \n```", "```cpp\nauto unsigned_v = uint32_t{42};\nauto sign = sign_func(unsigned_v); \n```", "```cpp\nint sign_func(uint32_t v) {\n  if (true) { \n    return 1; \n  } \n  return v < 0 ? -1 : 1; \n} \n```", "```cpp\nauto signed_v = int32_t{-42}; \nauto sign = sign_func(signed_v); \n```", "```cpp\nint sign_func(int32_t v) {\n  if (false) { \n    return 1; \n  } \n  return v < 0 ? -1 : 1; \n} \n```", "```cpp\nconstexpr auto v = 43 + 12; // Constant expression \n```", "```cpp\nconstexpr auto sum(int x, int y, int z) { return x + y + z; } \n```", "```cpp\nconstexpr auto value = sum(3, 4, 5); \n```", "```cpp\nconst auto value = 12; \n```", "```cpp\nauto value = sum(3, 4, 5); // value is not constexpr \n```", "```cpp\nint x, y, z; \nstd::cin >> x >> y >> z;      // Get user input\nauto value = sum(x, y, z); \n```", "```cpp\nconsteval auto sum(int x, int y, int z) { return x + y + z; } \n```", "```cpp\nconstexpr auto s = sum(1, 2, 3); // OK\nauto x = 10;\nauto s = sum(x, 2, 3);           // Error, expression is not const \n```", "```cpp\nint x, y, z; \nstd::cin >> x >> y >> z; \nconstexpr auto s = sum(x, y, z); // Error \n```", "```cpp\nstruct Bear { auto roar() const { std::cout << \"roar\\n\"; } }; \nstruct Duck { auto quack() const { std::cout << \"quack\\n\"; } }; \ntemplate <typename Animal> \nauto speak(const Animal& a) { \n  if (std::is_same_v<Animal, Bear>) { a.roar(); } \n  else if (std::is_same_v<Animal, Duck>) { a.quack(); } \n} \n```", "```cpp\nauto bear = Bear{};\nspeak(bear); \n```", "```cpp\nauto speak(const Bear& a) {\n  if (true) { a.roar(); }\n  else if (false) { a.quack(); } // This line will not compile\n} \n```", "```cpp\ntemplate <typename Animal> \nauto speak(const Animal& a) { \n  if constexpr (std::is_same_v<Animal, Bear>) { a.roar(); } \n  else if constexpr (std::is_same_v<Animal, Duck>) { a.quack(); } \n} \n```", "```cpp\nauto bear = Bear{};\nspeak(bear); \n```", "```cpp\nauto speak(const Bear& animal) { animal.roar(); } \n```", "```cpp\nauto duck = Duck{};\nspeak(duck); \n```", "```cpp\nauto speak(const Duck& animal) { animal.quack(); } \n```", "```cpp\nspeak(42); \n```", "```cpp\nauto speak(const int& animal) {} \n```", "```cpp\ntemplate <typename Animal> \nauto speak(const Animal& a) { \n  if constexpr (std::is_same_v<Animal, Bear>) { a.roar(); } \n  else if constexpr (std::is_same_v<Animal, Duck>) { a.quack(); }\n  else { static_assert(false); } // Trig compilation error\n} \n```", "```cpp\nstruct AnimalBase {\n  virtual ~AnimalBase() {}\n  virtual auto speak() const -> void {}\n};\nstruct Bear : public AnimalBase {\n  auto roar() const { std::cout << \"roar\\n\"; } \n  auto speak() const -> void override { roar(); }\n};\nstruct Duck : public AnimalBase {\n  auto quack() const { std::cout << \"quack\\n\"; }\n  auto speak() const -> void override { quack(); }\n}; \nauto speak(const AnimalBase& a) { \n  a.speak();\n} \n```", "```cpp\ntemplate <typename T> \nauto generic_mod(const T& v, const T& n) -> T {\n  assert(n != 0);\n  if (std::is_floating_point_v<T>) { return std::fmod(v, n); }\n  else { return v % n; }\n} \n```", "```cpp\nauto generic_mod(const float& v, const float& n) -> float {\n  assert(n != 0);\n  if (true) { return std::fmod(v, n); }\n  else { return v % n; } // Will not compile\n} \n```", "```cpp\ntemplate <typename T> \nauto generic_mod(const T& v, const T& n) -> T { \n  assert(n != 0);\n  if constexpr (std::is_floating_point_v<T>) {\n    return std::fmod(v, n);\n  } else {                 // If T is a floating point,\n    return v % n;          // this code is eradicated\n  }\n} \n```", "```cpp\nauto generic_mod(const float& v, const float& n) -> float { \n  assert(n != 0);\n  return std::fmod(v, n); \n} \n```", "```cpp\ntemplate <typename T> \nauto pow_n(const T& v, int n) { \n  assert(n >= 0); // Only works for positive numbers \n  auto product = T{1}; \n  for (int i = 0; i < n; ++i) {\n    product *= v; \n  }\n  return product; \n} \n```", "```cpp\ntemplate <int N, typename T>\nauto const_pow_n(const T& v) {\n  static_assert(N >= 0, \"N must be positive\"); \n  auto product = T{1}; \n  for (int i = 0; i < N; ++i) { \n    product *= v; \n  } \n  return product; \n}\nauto x = const_pow_n<5>(2);  // Compiles, N is positive\nauto y = const_pow_n<-1>(2); // Does not compile, N is negative \n```", "```cpp\ntemplate <typename T>\nclass Point2D {\npublic:\n  Point2D(T x, T y) : x_{x}, y_{y} {}\n  auto x() { return x_; }\n  auto y() { return y_; }\n  // ...\nprivate:\n  T x_{};\n  T y_{};\n}; \n```", "```cpp\nauto dist(auto p1, auto p2) {\n  auto a = p1.x() - p2.x();\n  auto b = p1.y() - p2.y();\n  return std::sqrt(a*a + b*b);\n} \n```", "```cpp\nint main() {\n  auto p1 = Point2D{2, 2};\n  auto p2 = Point2D{6, 5};\n  auto d = dist(p1, p2);\n  std::cout << d;\n} \n```", "```cpp\nauto dist(auto p1, auto p2) // Interface part \n```", "```cpp\n auto d = dist(3, 4); \n```", "```cpp\nauto dist(int p1, int p2) {\n  auto a = p1.x() \u2013 p2.x();  // Will generate an error:\n  auto b = p1.y() \u2013 p2.y();  // int does not have x() and y()\n  return std::sqrt(a*a + b*b);\n} \n```", "```cpp\nerror: member reference base type 'int' is not a structure or union\nauto a = p1.x() \u2013 p2.y(); \n```", "```cpp\nint main() {\n  auto from = Point2D{\"2.0\", \"2.0\"}; // Ouch!\n  auto to = Point2D{\"6.0\", \"5.0\"};   // Point2D<const char*>\n  auto d = dist(from, to);\n  std::cout << d;\n} \n```", "```cpp\ntemplate <typename T>\nconcept FloatingPoint = std::is_floating_point_v<T>; \n```", "```cpp\ntemplate <typename T>\nconcept Number = FloatingPoint<T> || std::is_integral_v<T>; \n```", "```cpp\ntemplate<typename T>\nconcept range = requires(T& t) {\n  ranges::begin(t);\n  ranges::end(t);\n}; \n```", "```cpp\ntemplate <typename T>\nrequires std::integral<T>\nauto mod(T v, T n) { \n  return v % n;\n} \n```", "```cpp\ntemplate <typename T>\nrequires std::integral<T>\nstruct Foo {\n  T value;\n}; \n```", "```cpp\ntemplate <std::integral T>\nauto mod(T v, T n) { \n  return v % n;\n} \n```", "```cpp\ntemplate <std::integral T>\nstruct Foo {\n  T value;\n}; \n```", "```cpp\nauto mod(std::integral auto v, std::integral auto n) {\n  return v % n;\n} \n```", "```cpp\nstd::integral auto mod(std::integral auto v, std::integral auto n) {\n  return v % n;\n} \n```", "```cpp\ntemplate <typename T> \nauto generic_mod(T v, T n) -> T { \n  if constexpr (std::is_floating_point_v<T>) {\n    return std::fmod(v, n);\n  } else {\n    return v % n;\n  } \n} \n```", "```cpp\ntemplate <std::integral T>\nauto generic_mod(T v, T n) -> T {             // Integral version\n  return v % n;\n}\ntemplate <std::floating_point T>\nauto generic_mod(T v, T n) -> T {             // Floating point version\n  return std::fmod(v, n);\n} \n```", "```cpp\ntemplate <typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>; \n```", "```cpp\ntemplate <typename T>\nconcept Point = requires(T p) {\n  requires std::is_same_v<decltype(p.x()), decltype(p.y())>;\n  requires Arithmetic<decltype(p.x())>;\n}; \n```", "```cpp\nauto dist(Point auto p1, Point auto p2) {\n  // Same as before ... \n```", "```cpp\nstd::floating_point auto dist(Point auto p1, Point auto p2) { \n  auto a = p1.x() - p2.x();\n  auto b = p1.y() - p2.y();\n  return std::sqrt(a*a + b*b);\n} \n```", "```cpp\nauto p1 = Point2D{\"2.0\", \"2.0\"}; // How can we prevent this? \n```", "```cpp\ntemplate <Arithmetic T> // T is now constrained!\nclass Point2D {\npublic:\n  Point2D(T x, T y) : x_{x}, y_{y} {}\n  auto x() { return x_; }\n  auto y() { return y_; }\n  // ...\nprivate:\n  T x_{};\n  T y_{};\n}; \n```", "```cpp\nconst auto& v = get_by_id(42); // What can I do with v? \n```", "```cpp\nconst Person auto& v = get_by_id(42);\nv.get_name(); \n```", "```cpp\ntemplate <typename T> constexpr auto make_false() { return false; }\ntemplate <typename Dst, typename Src> \nauto safe_cast(const Src& v) -> Dst{ \n  using namespace std;\n  constexpr auto is_same_type = is_same_v<Src, Dst>;\n  constexpr auto is_pointer_to_pointer =  \n    is_pointer_v<Src> && is_pointer_v<Dst>; \n  constexpr auto is_float_to_float =  \n    is_floating_point_v<Src> && is_floating_point_v<Dst>; \n  constexpr auto is_number_to_number =  \n    is_arithmetic_v<Src> && is_arithmetic_v<Dst>; \n  constexpr auto is_intptr_to_ptr = \n    (is_same_v<uintptr_t,Src> || is_same_v<intptr_t,Src>)\n    && is_pointer_v<Dst>;\n  constexpr auto is_ptr_to_intptr =\n    is_pointer_v<Src> &&\n    (is_same_v<uintptr_t,Dst> || is_same_v<intptr_t,Dst>); \n```", "```cpp\n if constexpr(is_same_type) { \n    return v; \n  }\n  else if constexpr(is_intptr_to_ptr || is_ptr_to_intptr){\n    return reinterpret_cast<Dst>(v); \n  } \n  else if constexpr(is_pointer_to_pointer) { \n    assert(dynamic_cast<Dst>(v) != nullptr); \n    return static_cast<Dst>(v); \n  } \n  else if constexpr (is_float_to_float) { \n    auto casted = static_cast<Dst>(v); \n    auto casted_back = static_cast<Src>(v); \n    assert(!isnan(casted_back) && !isinf(casted_back)); \n    return casted; \n  }  \n  else if constexpr (is_number_to_number) { \n    auto casted = static_cast<Dst>(v); \n    auto casted_back = static_cast<Src>(casted); \n    assert(casted == casted_back); \n    return casted; \n  } \n  else {\n    static_assert(make_false<Src>(),\"CastError\");\n    return Dst{}; // This can never happen, \n    // the static_assert should have failed \n  }\n} \n```", "```cpp\nauto x = safe_cast<int>(42.0f); \n```", "```cpp\n// type To is an integer\nassert(dynamic_cast<int>(v) != nullptr); // Does not compile \n```", "```cpp\nauto safe_cast(const float& v) -> int {\n  constexpr auto is_same_type = false;\n  constexpr auto is_pointer_to_pointer = false;\n  constexpr auto is_float_to_float = false;\n  constexpr auto is_number_to_number = true;\n  constexpr auto is_intptr_to_ptr = false;\n  constexpr auto is_ptr_to_intptr = false\n  if constexpr(is_same_type) { /* Eradicated */ }\n  else if constexpr(is_intptr_to_ptr||is_ptr_to_intptr){/* Eradicated */}\n  else if constexpr(is_pointer_to_pointer) {/* Eradicated */}\n  else if constexpr(is_float_to_float) {/* Eradicated */}\n  else if constexpr(is_number_to_number) {\n    auto casted = static_cast<int>(v);\n    auto casted_back = static_cast<float>(casted);\n    assert(casted == casted_back);\n    return casted;\n  }\n  else { /* Eradicated */ }\n} \n```", "```cpp\n// External function which loads a bitmap from the filesystem\nauto load_bitmap_from_filesystem(const char* path) -> Bitmap {/* ... */}\n// Bitmap cache \nauto get_bitmap_resource(const std::string& path) -> const Bitmap& { \n  // Static storage of all loaded bitmaps\n  static auto loaded = std::unordered_map<std::string, Bitmap>{};\n  // If the bitmap is already in loaded_bitmaps, return it\n  if (loaded.count(path) > 0) {\n    return loaded.at(path);\n  } \n  // The bitmap isn't already loaded, load and return it \n  auto bitmap = load_bitmap_from_filesystem(path.c_str());\n  loaded.emplace(path, std::move(bitmap)); \n  return loaded.at(path); \n} \n```", "```cpp\nauto draw_something() {\n  const auto& bm = get_bitmap_resource(\"my_bitmap.png\");\n  draw_bitmap(bm);\n}\nauto draw_something_again() {\n  const auto& bm = get_bitmap_resource(\"my_bitmap.png\");\n  draw_bitmap(bm);\n} \n```", "```cpp\nconstexpr auto hash_function(const char* str) -> size_t {\n  auto sum = size_t{0};\n  for (auto ptr = str; *ptr != '\\0'; ++ptr)\n    sum += *ptr;\n  return sum;\n} \n```", "```cpp\nauto hash = hash_function(\"abc\"); \n```", "```cpp\nauto hash = size_t{294}; \n```", "```cpp\nclass PrehashedString {\npublic:\n  template <size_t N>\n  constexpr PrehashedString(const char(&str)[N])\n      : hash_{hash_function(&str[0])}, size_{N - 1},\n      // The subtraction is to avoid null at end\n        strptr_{&str[0]} {}\n  auto operator==(const PrehashedString& s) const {\n    return\n      size_ == s.size_ &&\n      std::equal(c_str(), c_str() + size_, s.c_str());\n  }\n  auto operator!=(const PrehashedString& s) const {\n    return !(*this == s); }\n  constexpr auto size()const{ return size_; }\n  constexpr auto get_hash()const{ return hash_; }\n  constexpr auto c_str()const->const char*{ return strptr_; }\nprivate:\n  size_t hash_{};\n  size_t size_{};\n  const char* strptr_{nullptr};\n};\nnamespace std {\ntemplate <>\nstruct hash<PrehashedString> {\n  constexpr auto operator()(const PrehashedString& s) const {\n    return s.get_hash();\n  }\n};\n} // namespace std \n```", "```cpp\n// This compiles\nauto prehashed_string = PrehashedString{\"my_string\"};\n// This does not compile\n// The prehashed_string object would be broken if the str is modified\nauto str = std::string{\"my_string\"};\nauto prehashed_string = PrehashedString{str.c_str()};\n// This does not compile.\n// The prehashed_string object would be broken if the strptr is deleted\nauto* strptr = new char[5];\nauto prehashed_string = PrehashedString{strptr}; \n```", "```cpp\nauto test_prehashed_string() {\n  const auto& hash_fn = std::hash<PrehashedString>{};\n  const auto& str = PrehashedString(\"abc\");\n  return hash_fn(str);\n} \n```", "```cpp\nmov eax, 294\nret \n```", "```cpp\n// Bitmap cache\nauto get_bitmap_resource(const PrehashedString& path) -> const Bitmap& \n{\n  // Static storage of all loaded bitmaps\n  static auto loaded_bitmaps =\n    std::unordered_map<PrehashedString, Bitmap>{};\n  // If the bitmap is already in loaded_bitmaps, return it\n  if (loaded_bitmaps.count(path) > 0) {\n    return loaded_bitmaps.at(path);\n  }\n  // The bitmap isn't already loaded, load and return it\n  auto bitmap = load_bitmap_from_filesystem(path.c_str());\n  loaded_bitmaps.emplace(path, std::move(bitmap));\n  return loaded_bitmaps.at(path);\n} \n```", "```cpp\nauto test_get_bitmap_resource() { return get_bitmap_resource(\"abc\"); } \n```", "```cpp\n.quad   294                     # 0x126 \n```", "```cpp\n.quad   291                     # 0x123 \n```"]