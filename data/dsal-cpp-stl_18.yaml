- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Type Traits and Policies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型特性和策略
- en: This chapter covers compile-time type information (type traits) and modular,
    policy-based design in C++. It will showcase how they empower metaprogramming
    and foster versatile code design when working with the C++ **Standard Template
    Library** (**STL**) data types and algorithms. It also discusses policies, presenting
    a strategy to customize the behavior in templated code without altering core logic.
    Through real-world examples, hands-on implementation techniques, and best practices,
    you will harness the potential of these powerful C++ tools with the STL, creating
    adaptable and optimized software components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 C++ 中的编译时类型信息（类型特性）以及基于策略的模块化设计。它将展示如何通过使用 C++ **标准模板库**（**STL**）的数据类型和算法来增强元编程能力，并促进灵活的代码设计。它还讨论了策略，提出了一种在不改变核心逻辑的情况下定制模板代码行为的方法。通过实际案例、动手实现技术和最佳实践，您将利用这些强大的
    C++ 工具与 STL 结合，创建可适应和优化的软件组件。
- en: 'This chapter will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Understanding and using type traits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用类型特性
- en: Utilizing type traits with the STL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用类型特性与 STL
- en: Understanding and using policies in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用 C++ 中的策略
- en: Using policies with the STL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略与 STL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Understanding and using type traits
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用类型特性
- en: When writing generic code in C++, there’s often a need to gather information
    about types without knowing the specifics of those types in advance. Enter **type
    traits**—a toolkit for querying and manipulating type information at compile time.
    Think of them as inspectors that report on the characteristics of types, allowing
    you to make informed decisions in your code based on those reports.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中编写泛型代码时，通常需要在不知道类型具体信息的情况下收集有关类型的信息。这时就出现了 **类型特性**——一个用于在编译时查询和操作类型信息的工具集。把它们想象成报告类型特性的检查员，允许您根据这些报告在代码中做出明智的决策。
- en: 'C++’s STL provides a rich collection of type traits in the `<type_traits>`
    header. These traits can answer questions such as: Is a particular type a pointer?
    An integer? Is it arithmetic? Can it be default-constructed? For instance, `std::is_integral<T>::value`
    will return `true` if `T` is an integral type or `false` otherwise.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的 STL 在 `<type_traits>` 头文件中提供了一组丰富的类型特性。这些特性可以回答诸如：特定类型是否为指针？是否为整数？是否为算术类型？是否可以默认构造？例如，`std::is_integral<T>::value`
    如果 `T` 是整型类型则返回 `true`，否则返回 `false`。
- en: Enhancing code adaptability with type traits
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型特性提高代码适应性
- en: Type traits aren’t just a means of introspection; they’re enablers of adaptability.
    By understanding the properties of types, you can design algorithms and data structures
    that adjust their behavior accordingly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性不仅仅是内省的手段；它们是适应性的推动者。通过理解类型的属性，您可以设计出能够相应调整其行为的算法和数据结构。
- en: Consider a generic function that must operate differently for pointers and non-pointer
    types. With the help of `std::is_pointer<T>::value`, you can conditionally execute
    code paths using `if constexpr` statements, tailoring the behavior at compile
    time. This creates cleaner and more intuitive code and results in optimal performance,
    as the unnecessary code paths are pruned away during compilation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个必须针对指针和非指针类型执行不同操作的泛型函数。借助 `std::is_pointer<T>::value`，您可以使用 `if constexpr`
    语句有条件地执行代码路径，在编译时定制行为。这会创建更清晰、更直观的代码，并导致最佳性能，因为编译过程中会剪枝掉不必要的代码路径。
- en: Another everyday use case is optimizing storage in generic containers. For instance,
    if a type is trivially destructible (without custom destruction logic), you can
    safely skip calling its destructor, leading to performance gains. Here, `std::is_trivially_destructible<T>::value`
    comes to the rescue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个日常用例是优化泛型容器的存储。例如，如果一个类型是平凡可析构的（没有自定义析构逻辑），您可以安全地跳过调用其析构函数，从而提高性能。在这里，`std::is_trivially_destructible<T>::value`
    就能派上用场。
- en: Empowering metaprogramming with type traits
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型特性增强元编程
- en: '**Metaprogramming**, the act of writing code that generates or manipulates
    other code, is a hallmark of advanced C++ programming. Type traits are invaluable
    tools in this area, enabling richer and more expressive compile-time computations.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**，即编写生成或操作其他代码的代码，是高级C++编程的一个标志。类型特性是这个领域中的无价工具，它使编译时的计算更加丰富和表达。'
- en: A classic metaprogramming problem is factorial calculation at compile time.
    While this can be achieved through template recursion, the real challenge is to
    halt the recursion for non-integer types. This is where `std::is_integral<T>::value`
    proves its worth, ensuring that the computation only progresses for valid types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时阶乘计算是一个经典的元编程问题。虽然这可以通过模板递归实现，但真正的挑战在于如何为非整型类型停止递归。这正是`std::is_integral<T>::value`证明其价值的地方，确保计算只对有效类型进行。
- en: Another powerful facet is using type traits with `static_assert` to enforce
    constraints. If you’re writing a template function that should only accept arithmetic
    types, a simple static assertion with `std::is_arithmetic<T>::value` can ensure
    the code won’t compile for unsuitable types, providing clear and immediate feedback
    to the developer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个强大的方面是使用类型特性与`static_assert`来强制约束。如果你正在编写一个只应接受算术类型的模板函数，一个简单的使用`std::is_arithmetic<T>::value`的静态断言可以确保代码不会为不合适的类型编译，为开发者提供清晰且及时的反馈。
- en: Toward more informed and adaptable code
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向更信息化和可适应的代码迈进
- en: As you master type traits, remember these tools are not just about querying
    type properties. They leverage that knowledge to craft more robust, adaptable,
    and efficient code. Whether you aim for ultimate performance, cleaner interfaces,
    or just the satisfaction of metaprogramming mastery, type traits are ready to
    assist.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你精通类型特性时，请记住这些工具不仅仅是关于查询类型属性。它们利用这些知识来构建更健壮、更可适应和更高效的代码。无论你追求的是极致性能、更干净的接口，还是元编程掌握的满足感，类型特性都准备帮助你。
- en: In the following sections, we’ll further explore how type traits synergize with
    policies and, more importantly, how to craft your own type traits and policies,
    tailoring them to fit the unique demands of your projects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步探讨类型特性如何与策略协同工作，更重要的是，我们将探讨如何创建自己的类型特性和策略，以适应你项目的独特需求。
- en: Utilizing type traits with the STL
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用STL中的类型特性
- en: Utilizing type traits with STL data types and algorithms is a powerful technique
    that enhances the efficiency and correctness of C++ programming. When applied
    to STL data types, type traits enable a deeper understanding of the characteristics
    of these types, such as their size, alignment, or whether they are fundamental
    types. This insight can significantly optimize data storage and access patterns,
    leading to better memory management and performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 利用STL数据类型和算法中的类型特性是一种强大的技术，它增强了C++编程的效率和正确性。当应用于STL数据类型时，类型特性使开发者能够更深入地理解这些类型的特征，例如它们的大小、对齐或是否是基本类型。这种洞察力可以显著优化数据存储和访问模式，从而实现更好的内存管理和性能。
- en: In the context of STL algorithms, type traits are instrumental in selecting
    the most appropriate algorithm or optimizing its behavior based on the properties
    of the types involved. For example, knowing whether a type supports certain operations
    can allow algorithms to bypass unnecessary checks or use more efficient techniques.
    This boosts performance and ensures that algorithms with various types behave
    as expected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL算法的上下文中，类型特性在根据涉及类型的属性选择最合适的算法或优化其行为方面起着关键作用。例如，知道一个类型是否支持某些操作可以使算法跳过不必要的检查或使用更有效的方法。这提高了性能并确保了具有各种类型的算法按预期行为。
- en: Applying type traits in STL data types and algorithms is essential to advanced
    C++ programming, enabling developers to write more efficient, robust, and adaptable
    code. Let’s begin to discover the full potential of type traits in the context
    of the STL’s data types and algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL数据类型和算法中应用类型特性对于高级C++编程至关重要，它使开发者能够编写更高效、健壮和可适应的代码。让我们开始探索STL数据类型和算法中类型特性的全部潜力。
- en: Working with data types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数据类型一起工作
- en: Understanding and utilizing type traits is important for writing robust and
    adaptable code. Type traits, a part of the STL, allow programmers to query and
    interact with types at compile time, fostering type safety and efficiency.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和利用类型特性对于编写健壮和可适应的代码非常重要。类型特性，作为STL的一部分，允许程序员在编译时查询和交互类型，促进类型安全和效率。
- en: Type traits offer the compile-time introspection of types, enabling programmers
    to write generic and type-safe code. They are particularly useful in template
    metaprogramming, where operations depend on type properties. By leveraging type
    traits, developers can ascertain type properties, such as whether a type is an
    integer, floating-point, or whether it supports certain operations. We can also
    tailor code behavior based on type characteristics without incurring runtime costs
    or use them to write more straightforward, more maintainable code that automatically
    adapts to different types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性提供了类型的编译时内省，使程序员能够编写通用和类型安全的代码。它们在模板元编程中特别有用，其中操作依赖于类型属性。通过利用类型特性，开发者可以确定类型属性，例如类型是否为整数、浮点数，或者它是否支持某些操作。我们还可以根据类型特征定制代码行为，而无需承担运行时成本，或者使用它们来编写更简单、更易于维护的代码，这些代码可以自动适应不同的类型。
- en: 'Consider a scenario where we need a function template to process numerical
    data, but the processing differs for integer and floating-point types. Using type
    traits, we can create a specialized behavior for each type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，我们需要一个函数模板来处理数值数据，但对于整数和浮点数类型，处理方式不同。使用类型特性，我们可以为每种类型创建特定的行为：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `std::is_integral_v` and `std::is_floating_point_v` are type
    traits that assess whether `T` is an integer or floating-point type, respectively.
    The `if constexpr` construct enables compile-time decision-making, ensuring that
    only the relevant code block for the type `T` is compiled. This approach makes
    the code type safe and optimizes performance by avoiding unnecessary checks at
    runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`std::is_integral_v` 和 `std::is_floating_point_v` 是评估 `T` 是否为整数或浮点类型的类型特性。`if
    constexpr` 构造允许编译时决策，确保仅编译与类型 `T` 相关的相关代码块。这种方法使代码类型安全，并通过避免运行时不必要的检查来优化性能。
- en: Utilizing type traits with STL data types enhances code reliability, efficiency,
    and maintainability. Next, let’s explore more advanced uses of type traits, such
    as how they can be combined with other template techniques to build sophisticated,
    type-aware algorithms and data structures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 利用类型特性与 STL 数据类型结合可以增强代码的可靠性、效率和可维护性。接下来，让我们探索类型特性的更多高级用法，例如它们如何与其他模板技术结合来构建复杂、类型感知的算法和数据结构。
- en: Working with algorithms
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法一起工作
- en: In addition to their indispensable role in crafting adaptable code and enabling
    metaprogramming, type traits also play a crucial role in conjunction with STL
    algorithms. This synergy between type traits and algorithms empowers us to write
    highly versatile and type-aware code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在构建可适应的代码和启用元编程中不可或缺的作用外，类型特性在与 STL 算法结合时也发挥着至关重要的作用。类型特性和算法之间的这种协同作用使我们能够编写高度灵活和类型感知的代码。
- en: Type traits for algorithm customization
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法定制的类型特性
- en: STL algorithms often operate on generic data structures, ranging from sorting
    to searching. The ability to customize the behavior of these algorithms based
    on the properties of the elements they process is essential for writing efficient
    and flexible code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: STL 算法通常在泛型数据结构上操作，从排序到搜索。根据它们处理元素的属性来定制这些算法的行为对于编写高效和灵活的代码至关重要。
- en: 'Consider the `std::sort` algorithm, which can sort elements in a container.
    By employing type traits, we can make it more versatile. For instance, you may
    want to sort elements in descending order for types that support it (e.g., integers)
    while leaving the order unchanged for others. Using `std::is_integral<T>::value`,
    you can conditionally pass a custom comparison function to `std::sort`, tailoring
    the sorting behavior to the type being sorted as the following code illustrates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `std::sort` 算法为例，它可以对一个容器中的元素进行排序。通过使用类型特性，我们可以使其更加灵活。例如，你可能希望对于支持降序排序的类型（例如整数）进行降序排序，而对于其他类型则保持顺序不变。使用
    `std::is_integral<T>::value`，你可以有条件地向 `std::sort` 传递一个自定义的比较函数，根据排序的类型定制排序行为，以下代码示例说明了这一点：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This approach demonstrates how type traits can lead to more efficient code by
    eliminating unnecessary conditionals at runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法展示了类型特性如何通过在运行时消除不必要的条件来提高代码的效率。
- en: Ensuring algorithm compatibility
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保算法兼容性
- en: 'Consider an algorithm that processes a collection of objects to demonstrate
    the power of type traits with user-defined types. This algorithm requires that
    the objects provide a specific interface, for instance, a `serialize` method for
    converting the object state to a string. By employing type traits, we can ensure
    that the algorithm is only used with types that conform to this requirement at
    compile time:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个处理对象集合的算法，以展示类型特性在用户定义类型中的强大功能。此算法要求对象提供特定的接口，例如，一个将对象状态转换为字符串的 `serialize`
    方法。通过使用类型特性，我们可以确保算法仅在编译时使用符合此要求的类型：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the example output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `has_serialize` is a custom type trait that checks for the
    existence of a `serialize` method. The `processCollection` function template uses
    this trait to enforce that it is only used with types that provide this method.
    The `static_assert` generates a clear compile-time error message if an incompatible
    type is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`has_serialize` 是一个自定义的类型特性，用于检查是否存在 `serialize` 方法。`processCollection`
    函数模板使用此特性来强制只使用提供此方法的类型。如果使用了不兼容的类型，`static_assert` 会生成一个清晰的编译时错误信息。
- en: Developers can create more robust and self-documenting code by enforcing algorithm
    compatibility with custom types using type traits. This approach ensures that
    constraints are clearly defined and checked at compile time, preventing runtime
    errors and leading to more predictable and reliable software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过使用类型特性强制算法与自定义类型兼容，从而创建出更健壮且具有自文档特性的代码。这种方法确保了约束在编译时被明确定义和检查，防止了运行时错误，并导致了更可预测和可靠的软件。
- en: Optimizing algorithms for specific types
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为特定类型优化算法
- en: Efficiency is a critical concern in algorithm design. Type traits can help optimize
    algorithms for specific types by choosing the most efficient implementation based
    on type properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 效率是算法设计中的一个关键考虑因素。类型特性可以通过根据类型属性选择最有效的实现来帮助优化针对特定类型的算法。
- en: For example, consider an algorithm that calculates the sum of elements in a
    container. If the element type is integral, you can use a more efficient integer-based
    accumulator, while for floating-point types, you may prefer a floating-point accumulator.
    Type traits such as `std::is_integral<T>::value` can guide your choice of accumulator
    type, resulting in more efficient calculations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个计算容器中元素总和的算法。如果元素类型是整型，你可以使用基于整数的更有效的累加器，而对于浮点类型，你可能更喜欢浮点累加器。像 `std::is_integral<T>::value`
    这样的类型特性可以指导你选择累加器类型，从而实现更高效的计算。
- en: Type traits combined with STL algorithms enable you to create type-aware and
    efficient code. You can take full advantage of the STL while crafting robust and
    high-performance C++ applications by customizing algorithm behavior, ensuring
    compatibility, and optimizing for specific types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型特性与 STL 算法结合使用，可以使你创建出类型感知且高效的代码。通过定制算法行为、确保兼容性以及针对特定类型进行优化，你可以在构建健壮且高性能的
    C++ 应用程序的同时充分利用 STL。
- en: Understanding and using policies in C++
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用 C++ 中的策略
- en: Policy-based design is a design paradigm in C++ that emphasizes modularity and
    flexibility without sacrificing performance. It revolves around decomposing a
    software component’s behavior into interchangeable policies. These policies dictate
    how specific actions are executed. By choosing different policies, the behavior
    of a component can be modified without changing its fundamental logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计是 C++ 中的一种设计范式，它强调模块化和灵活性，同时不牺牲性能。它围绕将软件组件的行为分解为可互换的策略展开。这些策略决定了特定动作的执行方式。通过选择不同的策略，可以修改组件的行为，而无需更改其基本逻辑。
- en: Benefits with respect to the STL
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 STL 相关的优势
- en: In the context of the STL, a policy-based design is particularly relevant. The
    STL is inherently generic and designed to meet a broad spectrum of programming
    needs. Implementing policies can significantly enhance its versatility, allowing
    for precise customization to specific use cases. For example, the container memory
    allocation strategy can be defined as a policy. Whether employing the standard
    allocator, a pool allocator, or a custom stack-based allocator, you can simply
    insert the desired policy, and the container adjusts without modifying its primary
    logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL的上下文中，基于策略的设计尤其相关。STL本质上是通用的，旨在满足广泛的编程需求。实现策略可以显著增强其通用性，允许针对特定用例进行精确定制。例如，容器内存分配策略可以定义为一种策略。无论是使用标准分配器、池分配器还是自定义基于栈的分配器，只需简单地插入所需的策略，容器就会进行调整，而无需修改其基本逻辑。
- en: Moreover, policies can be tailored for performance in particular contexts. A
    sorting algorithm could utilize varied comparison strategies depending on the
    data type. Rather than drafting multiple iterations of the algorithm, one can
    design a single version and replace the comparison policy as required.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，策略可以根据特定上下文进行性能定制。排序算法可以根据数据类型使用不同的比较策略。而不是制定多个算法迭代，可以设计一个版本，并根据需要替换比较策略。
- en: 'Here’s a C++ code example demonstrating this concept:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示这个概念的C++代码示例：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the example output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we have two comparison policies: `NumericComparison` for numeric
    types and `StringComparison` for strings. The `sortWithPolicy` function is a template
    that takes a comparison policy as an argument, allowing the same sorting function
    to be used with different data types and comparison strategies. The numeric data
    is sorted in ascending order, while the strings are sorted based on their length,
    demonstrating the flexibility of using policies to tailor sorting behavior.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个比较策略：`NumericComparison`用于数值类型和`StringComparison`用于字符串。`sortWithPolicy`函数是一个模板，它接受一个比较策略作为参数，允许使用相同的排序函数与不同的数据类型和比较策略一起使用。数值数据按升序排序，而字符串则根据其长度排序，展示了使用策略定制排序行为的灵活性。
- en: Building modular components using policies
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用策略构建模块化组件
- en: 'Consider designing a templated data structure, such as a hash table. Policies
    can dictate multiple elements of this hash table: the hashing technique, the collision
    resolution method, or the memory allocation approach. By segregating these as
    individual, switchable policies, the hash table can be fine-tuned to specific
    requirements without altering its core functionality.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设计一个模板化的数据结构，例如哈希表。策略可以指定哈希表的多项元素：哈希技术、冲突解决方法或内存分配方法。通过将这些作为单独的可切换策略进行分离，哈希表可以根据特定要求进行微调，而无需改变其核心功能。
- en: This modularity also encourages code reusability. A well-crafted policy can
    be applied across various components, ensuring code consistency and easier maintenance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化也鼓励代码的可重用性。一个精心设计的策略可以应用于各种组件，确保代码的一致性和易于维护。
- en: Potential challenges
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜在的挑战
- en: While policy-based design offers numerous advantages, it presents particular
    challenges. One of the primary concerns is guaranteeing policy compatibility with
    the main component logic. Although a component might be structured to accommodate
    diverse policies, each must conform to a predetermined interface or standard.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于策略的设计提供了许多优势，但也带来了特定的挑战。其中主要关注的是确保策略与主要组件逻辑的兼容性。尽管一个组件可能被设计成可以容纳多种策略，但每种策略都必须符合预定的接口或标准。
- en: Documentation also emerges as a challenge. Given the increased flexibility that
    policies provide, it’s essential to meticulously document the expected behaviors,
    interfaces, and each policy’s implications, enabling users to make knowledgeable
    choices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文档也成为一个挑战。鉴于策略提供的灵活性增加，详细记录预期的行为、接口以及每个策略的影响变得至关重要，使用户能够做出明智的选择。
- en: The role of policies in modern C++
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略在现代C++中的作用
- en: As C++ progresses, the shift toward more generic and adaptable components becomes
    evident. Policy-based design is pivotal in this evolution, enabling developers
    to devise components prioritizing modularity and performance. Gaining proficiency
    in this design approach will empower you to produce software that not only endures
    but also efficiently adapts to changing needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++ 的发展，向更通用和适应性强组件的转变变得明显。基于策略的设计在这一演变中至关重要，它使开发者能够设计优先考虑模块化和性能的组件。掌握这种设计方法将使你能够生产出不仅能够持久存在，而且能够高效适应不断变化需求的软件。
- en: In the upcoming sections, we’ll examine the practical aspects of implementing
    type traits and policies, laying a robust groundwork for their practical application
    in your projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将检查实现类型特性和策略的实际方面，为它们在你的项目中的实际应用打下坚实的基础。
- en: Using policies with the STL
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用策略与 STL
- en: In exploring policy-based design, we’ve established how this design paradigm
    fosters modularity and flexibility in C++ software components. Now, let’s get
    into the specifics of how policies can be effectively employed to enhance the
    functionality and adaptability of STL data types, contributing to more efficient
    and customized solutions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索基于策略的设计时，我们已经建立了这种设计范式如何促进 C++ 软件组件的模块化和灵活性。现在，让我们具体探讨如何有效地使用策略来增强 STL 数据类型的功能性和适应性，从而为更高效和定制的解决方案做出贡献。
- en: Memory allocation policies
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配策略
- en: One of the most pertinent applications of policies in the context of STL data
    types is the management of memory allocation. Consider a scenario where you must
    optimize memory allocation for a specific container, such as a `std::vector` instance.
    By introducing memory allocation policies, you can tailor the container’s memory
    management strategy to your requirements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 数据类型的背景下，策略的最相关应用之一是内存分配的管理。考虑这样一个场景，你必须优化特定容器的内存分配，例如一个 `std::vector`
    实例。通过引入内存分配策略，你可以根据需求定制容器的内存管理策略。
- en: 'For instance, you may have a specialized memory allocator optimized for your
    application’s specific use case. Instead of modifying the container’s internal
    logic, you can seamlessly integrate this custom allocator as a policy. This way,
    the `std::vector` instance can efficiently use your custom allocator without requiring
    fundamental code changes, as illustrated here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个针对你的应用程序特定用例优化的专用内存分配器。而不是修改容器的内部逻辑，你可以无缝地将这个自定义分配器作为策略集成。这样，`std::vector`
    实例可以高效地使用你的自定义分配器，而不需要基本的代码更改，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This template class accepts a type `T` and an allocator policy, defaulted to
    `std::allocator<T>`. The critical point is that such a design allows for seamless
    integration of custom memory allocation strategies without altering the fundamental
    code structure of the container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板类接受一个类型 `T` 和一个分配器策略，默认为 `std::allocator<T>`。关键点在于这种设计允许在不改变容器的基本代码结构的情况下，无缝集成自定义内存分配策略。
- en: Sorting policies for versatile algorithms
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用算法的排序策略
- en: STL algorithms, including sorting algorithms, often work with various data types.
    Policies offer an elegant solution when different comparison strategies are needed
    for sorting. Rather than creating multiple sorting algorithm versions, you can
    design a single algorithm and introduce a comparison policy as required.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: STL 算法，包括排序算法，通常与各种数据类型一起工作。当需要不同的比较策略进行排序时，策略提供了一个优雅的解决方案。而不是创建多个排序算法版本，你可以设计一个单一的算法，并在需要时引入比较策略。
- en: 'Let’s take the example of a sorting algorithm. Using a comparison policy, you
    can sort elements differently based on the data type. This approach streamlines
    your code base and avoids code duplication:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以排序算法为例。使用比较策略，你可以根据数据类型的不同对元素进行不同的排序。这种方法简化了你的代码库，避免了代码重复：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example showcases a templated `customSort` function, demonstrating how
    a default comparison policy can be overridden to tailor the sorting behavior for
    different data types. This approach exemplifies a powerful strategy for creating
    versatile, maintainable, and efficient sorting algorithms within the STL framework,
    showcasing the benefits of policy-based design in C++ programming.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了模板化的 `customSort` 函数，展示了如何覆盖默认的比较策略以定制不同数据类型的排序行为。这种方法展示了在 STL 框架内创建通用、可维护和高效排序算法的强大策略，展示了基于策略设计的
    C++ 编程的优势。
- en: Fine-tuning data structures with policies
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用策略微调数据结构
- en: When designing custom data structures that mimic STL containers, you can leverage
    policies to fine-tune their behavior. Imagine building a hash table. Policies
    can govern critical aspects such as the hashing technique, collision resolution
    method, or memory allocation approach.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计模仿 STL 容器的自定义数据结构时，你可以利用策略来微调其行为。想象一下构建一个哈希表。策略可以控制关键方面，如哈希技术、冲突解决方法或内存分配方法。
- en: By isolating these functionalities as individual, interchangeable policies,
    you create a hash table that can be adapted to specific use cases without altering
    its core logic. This modular approach simplifies maintenance, as you can adjust
    individual policies as needed, keeping the rest of the structure intact.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些功能作为独立的、可互换的策略进行隔离，你可以创建一个可以适应特定用例而不改变其核心逻辑的哈希表。这种模块化方法简化了维护工作，因为你可以根据需要调整单个策略，同时保持其余结构完整。
- en: 'Let’s look at an example of how custom hash tables can be tailored for enhanced
    interaction with STL types and algorithms through policy-based design. This approach
    allows the behavior of the hash table (such as the hashing mechanism, collision
    resolution strategy, or memory management) to be defined by policies, making the
    data structure flexible and adaptable to different use cases:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明如何通过基于策略的设计来定制自定义哈希表，以增强与 STL 类型及算法的交互。这种方法允许通过策略定义哈希表的行为（例如哈希机制、冲突解决策略或内存管理），使数据结构灵活且适应不同的用例：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`DefaultHashPolicy` and `SeparateChainingPolicy` are default policies for hashing
    and collision resolution in this example. The `CustomHashTable` template class
    can be instantiated with different policies as required, making it highly versatile
    and compatible with various STL types and algorithms. This policy-based design
    enables fine-grained control over the behavior and characteristics of the hash
    table.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DefaultHashPolicy` 和 `SeparateChainingPolicy` 是哈希和冲突解决的默认策略。`CustomHashTable`
    模板类可以根据需要实例化不同的策略，使其非常灵活且与各种 STL 类型及算法兼容。这种基于策略的设计允许对哈希表的行为和特性进行精细控制。
- en: Policies in C++ offer a powerful toolset to enhance the adaptability and performance
    of STL data types. Whether it’s optimizing memory allocation, customizing sorting
    strategies, or tailoring data structures to specific needs, policies enable us
    to modularly extend the capabilities of the STL components while maintaining code
    consistency and reusability.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的策略提供了一套强大的工具集，可以增强 STL 数据类型的适应性和性能。无论是优化内存分配、定制排序策略还是定制满足特定需求的数据结构，策略使我们能够模块化扩展
    STL 组件的功能，同时保持代码的一致性和可重用性。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the intricacies of type traits and policies
    within the context of the C++ STL. We began by examining type traits, which serve
    as a toolkit for compile-time type inspection, allowing us to make decisions in
    our code based on type characteristics. Through exploring various type traits
    provided in the `<type_traits>` header, we learned how to determine whether a
    type is a pointer, an integer, arithmetic, default-constructible, and more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 C++ STL 上下文中的类型特性和策略的复杂性。我们首先检查了类型特性，它作为编译时类型检查的工具包，使我们能够根据类型特征在代码中做出决策。通过探索
    `<type_traits>` 头文件中提供的各种类型特性，我们学习了如何确定一个类型是否是指针、整数、算术类型、默认可构造的等等。
- en: Next, we investigated how type traits enhance code adaptability, enabling us
    to tailor the behavior of our algorithms and data structures. We saw firsthand
    how traits such as `std::is_pointer` and `std::is_trivially_destructible` can
    optimize performance by informing our code to behave differently based on type
    properties.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了类型特性如何增强代码的适应性，使我们能够定制算法和数据结构的行为。我们亲身体验了诸如 `std::is_pointer` 和 `std::is_trivially_destructible`
    这样的特性如何通过通知我们的代码根据类型属性采取不同的行为来优化性能。
- en: We then transitioned to policies, exploring their role in enabling modularity
    and flexibility in design without compromising performance. We recognized the
    benefits of policy-based design in STL applications, such as customizing memory
    allocation and sorting strategies. The modularity of policy-based components was
    highlighted as a means for fine-tuning behavior and encouraging code reusability.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向策略，探讨了它们在实现设计模块化和灵活性方面的作用，同时不牺牲性能。我们认识到基于策略的设计在 STL 应用中的好处，例如定制内存分配和排序策略。基于策略组件的模块化被强调为微调行为和鼓励代码重用的一种手段。
- en: The utility of this chapter lies in its potential to enhance our coding practices.
    We can write more robust, adaptable, and efficient code using type traits. At
    the same time, policies allow us to construct flexible, modular components tailored
    to various requirements without fundamental changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实用性在于其潜力可以提升我们的编码实践。我们可以利用类型特性编写更健壮、更适应性强和更高效的代码。同时，策略使我们能够构建灵活、模块化的组件，以满足各种需求，而无需进行根本性的改变。
- en: In the next chapter, [*Chapter 19*](B21945_19.xhtml#_idTextAnchor679), *Exception
    Safety*, we will build upon the knowledge acquired here by learning about the
    guarantees provided by the STL regarding exceptions. We will start by understanding
    the basics of exception safety, focusing on the pivotal role of program invariants
    and resource integrity in robust software design. We will examine strong exception
    safety, exploring how to build STL containers that offer unwavering guarantees.
    Finally, we’ll discuss the impact of `noexcept` on STL operations, further preparing
    us to write reliable and efficient C++ code that stands resilient in the face
    of exceptions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第19章*](B21945_19.xhtml#_idTextAnchor679)，*异常安全性*中，我们将通过学习 STL 关于异常提供的保证来扩展在这里获得的知识。我们将从理解异常安全性的基础知识开始，重点关注程序不变性和资源完整性在健壮软件设计中的关键作用。我们将探讨强异常安全性，研究如何构建提供坚定不移保证的
    STL 容器。最后，我们将讨论 `noexcept` 对 STL 操作的影响，进一步为我们编写可靠且高效的 C++ 代码做好准备，使其在面对异常时能够坚韧不拔。
- en: 'Part 5: STL Data Structures and Algorithms: Under the Hood'
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：STL 数据结构和算法：内部机制
- en: We conclude our exploration of STL data structures and algorithms by getting
    into some of its more advanced usage patterns. We will venture beyond the surface
    into the mechanics and guarantees that enable robust, concurrent C++ applications.
    We will start by discovering exception safety, detailing the levels of guarantees
    provided by STL components and strategies for writing exception-safe code with
    an emphasis on the impact of noexcept.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过探讨 STL 数据结构和算法的一些更高级的使用模式来结束对 STL 数据结构和算法的探索。我们将深入到其机制和保证中，这些机制和保证使得健壮、并发的
    C++ 应用程序成为可能。我们将从发现异常安全性开始，详细说明 STL 组件提供的保证级别，以及编写具有重点的异常安全代码的策略，强调 noexcept 的影响。
- en: We then venture into areas of thread safety and concurrency, dissecting the
    delicate balance between concurrent execution and the thread safety of STL containers
    and algorithms. We will gain actionable insights on race conditions, the prudent
    use of mutexes and locks, and the thread-safe application of STL containers, highlighting
    specific concerns and detailed insights into their behaviors in multithreaded
    environments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨线程安全和并发领域，剖析并发执行与 STL 容器和算法的线程安全之间的微妙平衡。我们将获得关于竞争条件、谨慎使用互斥锁和锁以及 STL
    容器的线程安全应用的实际见解，突出具体关注点和多线程环境中它们行为的详细洞察。
- en: Next, we will introduce the interaction of STL with modern C++ features like
    concepts and coroutines, showcasing how these features refine template usage and
    enable asynchronous programming with STL.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 STL 与现代 C++ 功能（如概念和协程）的交互，展示这些功能如何精炼模板的使用，并使 STL 能够进行异步编程。
- en: Finally, we will dive into parallel algorithms, discussing the incorporation
    of execution policies, the impact of constexpr, and performance considerations
    when employing parallelism in STL. This part of the book equips readers with the
    advanced knowledge to exploit the full potential of the STL in concurrent and
    parallel environments, ensuring their code is efficient, safe, and modern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入探讨并行算法，讨论执行策略的整合、constexpr 的影响，以及在 STL 中使用并行性时的性能考虑。本书的这一部分为读者提供了利用
    STL 在并发和并行环境中的全部潜力的高级知识，确保他们的代码高效、安全且现代。
- en: 'This part has the following chapters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 19*](B21945_19.xhtml#_idTextAnchor679)*: Exception Safety*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第19章*](B21945_19.xhtml#_idTextAnchor679)*：异常安全性*'
- en: '[*Chapter 20*](B21945_20.xhtml#_idTextAnchor696)*: Thread Safety and Concurrency
    with the STL*'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第20章*](B21945_20.xhtml#_idTextAnchor696)*：使用 STL 的线程安全和并发*'
- en: '[*Chapter 21*](B21945_21.xhtml#_idTextAnchor745)*: STL Interaction with Concepts
    and Coroutines*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第21章*](B21945_21.xhtml#_idTextAnchor745)*：STL 与概念和协程的交互*'
- en: '[*Chapter 22*](B21945_22.xhtml#_idTextAnchor762)*: Parallel Algorithms with
    the STL*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第22章*](B21945_22.xhtml#_idTextAnchor762)*：使用 STL 的并行算法*'
