- en: Chapter 1. The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 基础
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating an endpoint
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建端点
- en: Creating an active socket
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主动套接字
- en: Creating a passive socket
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建被动套接字
- en: Resolving a DNS name
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析DNS名称
- en: Binding a socket to an endpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将套接字绑定到端点
- en: Connecting a socket
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接套接字
- en: Accepting connections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受连接
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Computer networks and communication protocols significantly increase capabilities
    of modern software, allowing different applications or separate parts of the same
    application to communicate with each other to achieve a common goal. Some applications
    have communication as their main function, for example, instant messengers, e-mail
    servers and clients, file download software, and so on. Others have the network
    communication layer as a fundamental component, on top of which the main functionality
    is built. Some of the examples of such applications are web browsers, network
    file systems, distributed database management systems, media streaming software,
    online games, offline games with multiplayer over the network option support,
    and many others. Besides, nowadays almost any application in addition to its main
    functionality provides supplementary functions, involving network communication.
    The most prominent examples of such functions are online registration and automatic
    software update. In the latter case, the update package is downloaded from the
    application developer's remote server and installed on the user's computer or
    mobile device.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络和通信协议显著提高了现代软件的能力，允许不同的应用程序或同一应用程序的独立部分相互通信，以实现共同的目标。有些应用程序以通信为主要功能，例如，即时通讯工具、电子邮件服务器和客户端、文件下载软件等。其他应用程序将网络通信层作为基本组件，在其之上构建主要功能。这类应用程序的例子包括网络浏览器、网络文件系统、分布式数据库管理系统、媒体流软件、在线游戏、支持网络多人游戏的离线游戏，以及许多其他应用。此外，如今几乎任何应用程序除了其主要功能外，还提供补充功能，包括网络通信。这类功能中最突出的例子是在线注册和自动软件更新。在后一种情况下，更新包从应用程序开发者的远程服务器下载，并安装到用户的计算机或移动设备上。
- en: The application that consists of two or more parts, each of which runs on a
    separate computing device, and communicates with other parts over a computer network
    is called a **distributed application**. For example, a web server and a web browser
    together can be considered as one complex distributed application. The browser
    running on a user's computer communicates with the web server running on a different
    remote computer in order to achieve a common goal—to transmit and display a web
    page requested by the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个或更多部分组成的应用程序，每一部分都在独立的计算设备上运行，并通过计算机网络与其他部分进行通信，这种应用程序被称为**分布式应用程序**。例如，一个网络服务器和一个网络浏览器可以共同被视为一个复杂的分布式应用程序。运行在用户计算机上的浏览器与运行在不同远程计算机上的网络服务器进行通信，以实现一个共同的目标——传输和显示用户请求的网页。
- en: 'Distributed applications provide significant benefits as compared to traditional
    applications running on a single computer. The most valuable of them are the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与在单台计算机上运行的传统应用程序相比，分布式应用程序提供了显著的好处。其中最有价值的是以下几项：
- en: Ability to transmit data between two or more remote computing devices. This
    is absolutely obvious and the most valuable benefit of distributed software.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个或更多远程计算设备之间传输数据的能力。这是分布式软件绝对明显且最有价值的优势。
- en: Ability to connect computers in a network and install special software on them,
    creating powerful computing systems that can perform tasks that can't otherwise
    be performed on a single computer in an adequate amount of time.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在网络中的计算机上连接并安装特殊软件，创建能够执行在单台计算机上无法在足够的时间内完成的任务的强大计算系统。
- en: Ability to effectively store and share data in a network. In a computer network,
    a single device can be used as data storage to store big amounts of data and other
    devices can easily request some portions of that data when necessary without the
    need to keep the copy of all data on each device. As an example, consider large
    datacenters hosting hundreds of millions of websites. The end user can request
    the web page they need anytime by sending the request to the server over the network
    (usually, the Internet). There is no need to keep the copy of the website on the
    user's device. There is a single storage of the data (a website) and millions
    of users can request the data from that storage if and when this information is
    needed.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在网络中有效地存储和共享数据。在计算机网络中，单个设备可以用作数据存储来存储大量数据，而其他设备可以在必要时轻松请求该数据的一部分，而无需在每个设备上保留所有数据的副本。例如，考虑拥有数亿个网站的大型数据中心。最终用户可以通过将请求发送到服务器（通常是互联网）来随时请求所需的网页。无需在用户的设备上保留网站的副本。有一个单一的数据存储（一个网站），数百万用户可以在需要时从这个存储中请求数据。
- en: For two applications running on different computing devices to communicate with
    each other, they need to agree on a communication protocol. Of course, the developer
    of the distributed application is free to implement his or her own protocol. However,
    this would be rarely the case at least for two reasons. First, developing such
    a protocol is an enormously complex and time-consuming task. Secondly, such protocols
    are already defined, standardized, and even implemented in all popular operating
    systems including Windows, Mac OS X, and majority of the distributions of Linux.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行在不同计算设备上的两个应用程序要相互通信，它们需要就通信协议达成一致。当然，分布式应用程序的开发者可以自由实现自己的协议。然而，至少有两个原因使得这种情况很少发生。首先，开发这样的协议是一项极其复杂且耗时的任务。其次，这样的协议已经定义、标准化，并且甚至已经在包括Windows、Mac
    OS X和大多数Linux发行版在内的所有流行操作系统中实现。
- en: These protocols are defined by the TCP/IP standard. Don't be fooled by the standard's
    name; it defines not only TCP and IP but many more other protocols, comprising
    a TCP/IP protocol stack with one or more protocols on each level of the stack.
    Distributed software developers usually deal with transport level protocols such
    as TCP or UDP. Lower layer protocols are usually hidden from the developer and
    are handled by the operating system and network devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议由TCP/IP标准定义。不要被标准的名称所迷惑；它不仅定义了TCP和IP，还定义了许多其他协议，包括一个TCP/IP协议栈，其中每个层级都包含一个或多个协议。分布式软件开发者通常处理传输层协议，如TCP或UDP。底层协议通常对开发者隐藏，并由操作系统和网络设备处理。
- en: In this book, we only touch upon TCP and UDP protocols that satisfy the needs
    of most developers of distributed software. If the reader is not familiar with
    the TCP/IP protocol stack, the OSI model, or TCP and UDP protocols, it's highly
    advised to read some theory on these topics. Though this book provides some brief
    information about them, it is mostly focused on practical aspects of using TCP
    and UDP protocols in distributed software development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们仅涉及满足大多数分布式软件开发者需求的TCP和UDP协议。如果读者对TCP/IP协议栈、OSI模型或TCP和UDP协议不熟悉，强烈建议阅读这些主题的相关理论。尽管本书提供了关于这些主题的一些简要信息，但它主要关注在分布式软件开发中使用TCP和UDP协议的实践方面。
- en: 'The TCP protocol is a transport layer protocol with the following characteristics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TCP协议是一种传输层协议，具有以下特点：
- en: It's reliable, which means that this protocol guarantees delivery of the messages
    in proper order or a notification that the message has not been delivered. The
    protocol includes error handling mechanisms, which frees the developer from the
    need to implement them in the application.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是可靠的，这意味着该协议保证消息按正确顺序交付或通知消息未交付。该协议包括错误处理机制，从而免去了开发者需要在应用程序中实现这些机制的需求。
- en: It assumes logical connection establishment. Before one application can communicate
    with another over the TCP protocol, it must establish a logical connection by
    exchanging service messages according to the standard.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设建立逻辑连接。在应用程序可以通过TCP协议相互通信之前，它必须通过按照标准交换服务消息来建立逻辑连接。
- en: It assumes the point-to-point communication model. That is, only two applications
    can communicate over a single connection. No multicast messaging is supported.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设点对点通信模型。也就是说，只有两个应用程序可以通过单个连接进行通信。不支持多播消息。
- en: It is stream-oriented. This means that the data being sent by one application
    to another is interpreted by the protocol as a stream of bytes. In practice, it
    means that if a sender application sends a particular block of data, there is
    no guarantee that it will be delivered to the receiver application as the same
    block of data in a single turn, that is, the sent message may be broken into as
    many parts as the protocol *wants* and each of them will be delivered separately,
    though in correct order.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是面向流的。这意味着一个应用程序向另一个应用程序发送的数据被协议解释为字节流。在实践中，这意味着如果一个发送应用程序发送特定块的数据，不能保证它将以相同的块数据在单次传输中送达接收应用程序，也就是说，发送的消息可能会被分割成协议*想要*的那么多部分，并且每一部分都将单独发送，尽管它们是按正确顺序发送的。
- en: 'The UDP protocol is a transport layer protocol having different (in some sense
    opposite) characteristics from those of the TCP protocol. The following are its
    characteristics:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: UDP协议是一种传输层协议，其特性与TCP协议的特性（在某种程度上是相反的）。以下是其特性：
- en: It's unreliable, which means that if a sender sends a message over a UDP protocol,
    there is no guarantee that the message will be delivered. The protocol won't try
    to detect or fix any errors. The developer is responsible for all error handling.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是不可靠的，这意味着如果发送者通过UDP协议发送消息，不能保证消息会被送达。该协议不会尝试检测或修复任何错误。错误处理的责任完全在开发者。
- en: It's connectionless, meaning that no connection establishment is needed before
    the applications can communicate.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无连接的，这意味着在应用程序可以通信之前不需要建立连接。
- en: It supports both one-to-one and one-to-many communication models. Multicast
    messages are supported by the protocol.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持一对一和一对多通信模型。该协议支持多播消息。
- en: It's datagram oriented. This means that the protocol interprets data as messages
    of a particular size and will try to deliver them as a whole. The message (datagram)
    either will be delivered as a whole, or if the protocol fails to do that won't
    be delivered at all.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是面向数据报的。这意味着协议将数据解释为特定大小的消息，并尝试将它们作为一个整体交付。消息（数据报）要么作为一个整体交付，要么如果协议未能做到这一点，则根本不会交付。
- en: Because the UDP protocol is unreliable, it is usually used in reliable local
    networks. To use it for communication over the Internet (which is an unreliable
    network), the developer must implement error handling mechanisms in its application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP协议是不可靠的，它通常用于可靠的本地网络。要在互联网（一个不可靠的网络）上进行通信，开发者必须在应用程序中实现错误处理机制。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When there is a need to communicate over the Internet, the TCP protocol is most
    often the best choice due to its reliability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要通过互联网进行通信时，由于可靠性，TCP协议通常是最佳选择。
- en: As it has already been mentioned, both TCP and UDP protocols and the underlying
    protocols required by them are implemented by most popular operating systems.
    A developer of a distributed application is provided an API through which it can
    use protocols implementation. The TCP/IP standard does not standardize the protocol
    API implementation; therefore, several API implementations exist. However, the
    one based on **Berkeley Sockets API** is the most widely used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经提到的，TCP和UDP协议以及它们所需的底层协议由大多数流行的操作系统实现。分布式应用程序的开发者通过API可以使用协议实现。TCP/IP标准没有标准化协议API实现；因此，存在几个API实现。然而，基于**伯克利套接字API**的实现是最广泛使用的。
- en: Berkeley Sockets API is the name of one of the many possible implementations
    of TCP and UDP protocols' API. This API was developed at the Berkeley University
    of California, USA (hence the name) in the early 1980s. It is built around a concept
    of an abstract object called a **socket**. Such a name was given to this object
    in order to draw the analogy with a usual electrical socket. However, this idea
    seems to have somewhat failed due to the fact that Berkeley Sockets turned out
    to be a significantly more complex concept.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 伯克利套接字API是TCP和UDP协议API的许多可能实现之一。这个API是在美国加利福尼亚大学伯克利分校（因此得名）的20世纪80年代初开发的。它围绕一个称为**套接字**的抽象对象的概念构建。这个名称是为了将这个对象与常见的电气插座类比。然而，由于伯克利套接字最终证明是一个显著更复杂的概念，这个想法似乎有些失败。
- en: Now Windows, Mac OS X, and Linux operating systems all have this API implemented
    (though with some minor variations) and software developers can use it to consume
    TCP and UDP protocols' functionality when developing distributed applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Windows、Mac OS X和Linux操作系统都实现了这个API（尽管有一些细微的差异），软件开发者可以使用它来在开发分布式应用程序时使用TCP和UDP协议的功能。
- en: '![Introduction](img/B00298_01_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/B00298_01_01.jpg)'
- en: Though very popular and widely used, Sockets API has several flaws. First, because
    it was designed as a very generic API that should support many different protocols,
    it is quite complex and somewhat difficult to use. The second flaw is that this
    is a C-style functional API with a poor type system, which makes it error prone
    and even more difficult to use. For example, Sockets API doesn't provide a separate
    type representing a socket. Instead, the built-in type `int` is used, which means
    that by mistake any value of the `int` type can be passed as an argument to the
    function expecting a socket, and the compiler won't detect the mistake. This may
    lead to run-time crashes, the root cause of which is hard to find.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常流行且广泛使用，但套接字API有几个缺陷。首先，因为它被设计为一个非常通用的API，应该支持许多不同的协议，所以它相当复杂，并且有些难以使用。第二个缺陷是，这是一个C风格的函数式API，类型系统较差，这使得它容易出错，并且更加难以使用。例如，套接字API没有提供表示套接字的单独类型。相反，使用内置类型`int`，这意味着任何`int`类型的值都可能错误地传递给期望套接字的函数，而编译器不会检测到这个错误。这可能导致运行时崩溃，其根本原因很难找到。
- en: 'Network programming is inherently complex and doing it with a low-level C-style
    socket API makes it even more complex and error prone. Boost.Asio is an O-O C++
    library that is, just like raw Sockets API, built around the concept of a *socket*.
    Roughly speaking, Boost.Asio wraps raw Sockets API and provides the developer
    with O-O interface to it. It is intended to simplify network programming in several
    ways as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程本身就很复杂，而使用低级的C风格套接字API则使其更加复杂且容易出错。Boost.Asio是一个面向对象的C++库，就像原始的套接字API一样，它围绕套接字的概念构建。简而言之，Boost.Asio封装了原始套接字API，并为开发者提供了面向对象的接口。它旨在以下几种方式中简化网络编程：
- en: It hides the raw C-style API and providing a user with an object-oriented API
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它隐藏了原始的C风格API，并为用户提供了一个面向对象的API
- en: It provides a rich-type system, which makes code more readable and allows it
    to catch many errors at compilation time
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个丰富的类型系统，这使得代码更易于阅读，并允许在编译时捕获许多错误
- en: As Boost.Asio is a cross-platform library, it simplifies development of cross-platform
    distributed applications
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Boost.Asio是一个跨平台库，它简化了跨平台分布式应用程序的开发
- en: It provides auxiliary functionality such as scatter-gather I/O operations, stream-based
    I/O, exception-based error handling, and others
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了辅助功能，例如散列-聚集I/O操作、基于流的I/O、基于异常的错误处理以及其他功能
- en: The library is designed so that it can be relatively easily extended to add
    new custom functionality
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库的设计使其可以相对容易地扩展以添加新的自定义功能
- en: This chapter introduces essential Boost.Asio classes and demonstrates how to
    perform basic operations with them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Boost.Asio的基本类，并演示了如何使用它们执行基本操作。
- en: Creating an endpoint
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建端点
- en: A typical client application, before it can communicate with a server application
    to consume its services, must obtain the IP address of the host on which the server
    application is running and the protocol port number associated with it. A pair
    of values consisting of an IP address and a protocol port number that uniquely
    identifies a particular application running on a particular host in a computer
    network is called an **endpoint**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的客户端应用程序，在它能够与服务器应用程序通信以使用其服务之前，必须获取服务器应用程序运行的主机的IP地址以及与其关联的协议端口号。由一个IP地址和一个协议端口号组成的值对，该值对唯一标识了计算机网络上特定主机上运行的特定应用程序，被称为**端点**。
- en: The client application will usually obtain the IP address and the port number
    identifying the server application either from the user directly through the application
    UI or as command-line arguments or will read it from the application's configuration
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序通常会从用户直接通过应用程序UI或作为命令行参数获取服务器应用程序的IP地址和端口号，或者从应用程序的配置文件中读取。
- en: The IP address can be represented as a string containing an address in dot-decimal
    notation if it is an IPv4 address (for example, `192.168.10.112`) or in hexadecimal
    notation if it is an IPv6 address (for example, `FE36::0404:C3FA:EF1E:3829`).
    Besides, the server IP address can be provided to the client application in an
    indirect form, as a string containing a DNS name (for example, `localhost` or
    [www.google.com](http://www.google.com)). Another way to represent an IP address
    is an integer value. The IPv4 address is represented as a 32-bit integer and IPv6
    as a 64-bit integer. However, due to poor readability and memorability this representation
    is used extremely rarely.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址可以表示为一个包含点十进制表示法的地址的字符串，如果它是IPv4地址（例如，`192.168.10.112`），或者如果它是IPv6地址（例如，`FE36::0404:C3FA:EF1E:3829`），则使用十六进制表示法。此外，服务器IP地址可以以间接形式提供给客户端应用程序，即包含DNS名称的字符串（例如，`localhost`或[www.google.com](http://www.google.com)）。另一种表示IP地址的方法是整数值。IPv4地址表示为32位整数，IPv6表示为64位整数。然而，由于可读性和可记忆性较差，这种表示法使用得非常少。
- en: If the client application is provided with a DNS name before it can communicate
    with the server application, it must resolve the DNS name to obtain the actual
    IP address of the host running the server application. Sometimes, the DNS name
    may map to multiple IP addresses, in which case the client may want to try addresses
    one by one until it finds the one that works. We'll consider a recipe describing
    how to resolve DNS names with Boost.Asio later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在客户端应用程序能够与服务器应用程序通信之前提供了DNS名称，它必须解析该DNS名称以获取运行服务器应用程序的主机的实际IP地址。有时，DNS名称可能映射到多个IP地址，在这种情况下，客户端可能需要逐个尝试地址，直到找到可以工作的地址。我们将在本章后面考虑一个描述如何使用Boost.Asio解析DNS名称的配方。
- en: The server application needs to deal with endpoints too. It uses the endpoint
    to specify to the operating system on which the IP address and protocol port it
    wants to listen for incoming messages from the clients. If the host running the
    server application has only one network interface and a single IP address assigned
    to it, the server application has only one option as to on which address to listen.
    However, sometimes the host might have more than one network interface and correspondingly
    more than one IP address. In this situation, the server application encounters
    a difficult problem of selecting an appropriate IP address on which to listen
    for incoming messages. The problem is that the application knows nothing about
    details such as underlying IP protocol settings, packet routing rules, DNS names
    which are mapped to the corresponding IP addresses, and so on. Therefore, it is
    quite a complex task (and sometimes even not solvable) for the server application
    to foresee through which IP address the messages sent by clients will be delivered
    to the host.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序还需要处理端点。它使用端点来指定操作系统，它希望监听来自客户端的IP地址和协议端口号。如果运行服务器应用程序的主机只有一个网络接口并且分配给它一个IP地址，那么服务器应用程序在哪个地址上监听只有一个选择。然而，有时主机可能有多个网络接口和相应的多个IP地址。在这种情况下，服务器应用程序面临着一个难题，即选择一个合适的IP地址来监听传入的消息。问题是应用程序对诸如底层IP协议设置、数据包路由规则、映射到相应IP地址的DNS名称等细节一无所知。因此，对于服务器应用程序来说，预见客户端发送的消息将通过哪个IP地址发送到主机是一个相当复杂（有时甚至无法解决）的任务。
- en: If the server application chooses only one IP address to listen for incoming
    messages, it may miss messages routed to other IP addresses of the host. Therefore,
    the server application usually wants to listen on all IP addresses available on
    the host. This guarantees that the server application will receive all messages
    arriving at any IP address and the particular protocol port.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器应用程序只选择一个IP地址来监听传入的消息，它可能会错过路由到主机其他IP地址的消息。因此，服务器应用程序通常希望监听主机上可用的所有IP地址。这保证了服务器应用程序将接收到达任何IP地址和特定协议端口号的所有消息。
- en: 'To sum up, the endpoints serve two goals:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，端点有两个目标：
- en: The client application uses an endpoint to designate a particular server application
    it wants to communicate with.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用端点来指定它想要与之通信的特定服务器应用程序。
- en: The server application uses an endpoint to specify a local IP address and a
    port number on which it wants to receive incoming messages from clients. If there
    is more than one IP address on the host, the server application will want to create
    a special endpoint representing all IP addresses at once.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应用程序使用端点来指定它希望接收来自客户端的传入消息的本地IP地址和端口号。如果主机上有多个IP地址，服务器应用程序将希望创建一个特殊的端点，以一次表示所有IP地址。
- en: This recipe explains how to create endpoints in Boost.Asio both in client and
    server applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱解释了如何在客户端和服务器应用程序中创建端点。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before creating the endpoint, the client application must obtain the raw IP
    address and the protocol port number designating the server it will communicate
    with. The server application on the other hand, as it usually listens for incoming
    messages on all IP addresses, only needs to obtain a port number on which to listen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建端点之前，客户端应用程序必须获取表示它将与之通信的服务器的原始IP地址和协议端口号。另一方面，由于服务器应用程序通常在所有IP地址上监听传入消息，因此它只需要获取一个监听端口号。
- en: Here, we don't consider how the application obtains a raw IP address or a port
    number. In the following recipes, we assume that the IP address and the port number
    have already been obtained by the application and are available at the beginning
    of the corresponding algorithm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不考虑应用程序如何获取原始IP地址或端口号。在下面的菜谱中，我们假设IP地址和端口号已经被应用程序获取，并在相应算法的开始时可用。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following algorithms and corresponding code samples demonstrate two common
    scenarios of creating an endpoint. The first one demonstrates how the client application
    can create an endpoint to specify the server it wants to communicate with. The
    second one demonstrates how the server application creates an endpoint to specify
    on which IP addresses and port it wants to listen for incoming messages from clients.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法和相应的代码示例演示了创建端点的两种常见场景。第一个示例演示了客户端应用程序如何创建端点以指定它想要与之通信的服务器。第二个示例演示了服务器应用程序如何创建端点以指定它希望在哪些IP地址和端口号上监听来自客户端的传入消息。
- en: Creating an endpoint in the client to designate the server
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端创建端点以指定服务器
- en: 'The following algorithm describes steps required to perform in the client application
    to create an endpoint designating a server application the client wants to communicate
    with. Initially, the IP address is represented as a string in the dot-decimal
    notation if this is an IPv4 address or in hexadecimal notation if this is an IPv6
    address:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在客户端应用程序中执行以创建指定客户端想要通信的服务器应用程序的端点的步骤。最初，如果这是一个IPv4地址，则IP地址以点分十进制表示法表示为字符串；如果这是一个IPv6地址，则表示为十六进制表示法：
- en: Obtain the server application's IP address and port number. The IP address should
    be specified as a string in the dot-decimal (IPv4) or hexadecimal (IPv6) notation.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器应用程序的IP地址和端口号。IP地址应指定为点分十进制（IPv4）或十六进制（IPv6）表示法的字符串。
- en: Represent the raw IP address as an object of the `asio::ip::address` class.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始IP地址表示为`asio::ip::address`类的对象。
- en: Instantiate the object of the `asio::ip::tcp::endpoint` class from the address
    object created in step 2 and a port number.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤2中创建的地址对象和端口号实例化`asio::ip::tcp::endpoint`类对象。
- en: The endpoint is ready to be used to designate the server application in Boost.Asio
    communication related methods.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点已准备好用于在Boost.Asio通信相关方法中指定服务器应用程序。
- en: 'The following code sample demonstrates possible implementation of the algorithm:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the server endpoint
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务器端点
- en: 'The following algorithm describes steps required to perform in a server application
    to create an endpoint specifying all IP addresses available on the host and a
    port number on which the server application wants to listen for incoming messages
    from the clients:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在服务器应用程序中执行以创建端点的步骤，该端点指定主机上可用的所有IP地址以及服务器应用程序希望监听来自客户端的传入消息的端口号：
- en: Obtain the protocol port number on which the server will listen for incoming
    requests.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器将监听传入请求的协议端口号。
- en: Create a special instance of the `asio::ip::address` object representing all
    IP addresses available on the host running the server.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示服务器运行的主机上所有可用IP地址的`asio::ip::address`对象的特殊实例。
- en: Instantiate an object of the `asio::ip::tcp::endpoint` class from the address
    object created in step 2 and a port number.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第二步中创建的地址对象和一个端口号中实例化一个`asio::ip::tcp::endpoint`类的对象。
- en: The endpoint is ready to be used to specify to the operating system that the
    server wants to listen for incoming messages on all IP addresses and a particular
    protocol port number.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点已准备好用于指定给操作系统，服务器希望监听所有IP地址和特定协议端口号上的传入消息。
- en: 'The following code sample demonstrates possible implementation of the algorithm.
    Note that it is assumed that the server application is going to communicate over
    the IPv6 protocol:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现。请注意，假设服务器应用程序将通过IPv6协议进行通信：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's consider the first code sample. The algorithm it implements is applicable
    in an application playing a role of a client that is an application that actively
    initiates the communication session with a server. The client application needs
    to be provided an IP address and a protocol port number of the server. Here we
    assume that those values have already been obtained and are available at the beginning
    of the algorithm, which makes step 1 details a given.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第一个代码示例。它实现的算法适用于充当客户端的应用程序，这是一个主动与服务器建立通信会话的应用程序。客户端应用程序需要提供服务器的一个IP地址和协议端口号。这里我们假设这些值已经获得，并在算法开始时可用，这使得第一步的细节是已知的。
- en: 'Having obtained the raw IP address, the client application must represent it
    in terms of the Boost.Asio type system. Boost.Asio provides three classes used
    to represent an IP address:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 获得原始IP地址后，客户端应用程序必须以Boost.Asio类型系统的术语表示它。Boost.Asio提供了三个用于表示IP地址的类：
- en: '`asio::ip::address_v4`: This represents an IPv4 address'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::address_v4`: 这代表一个IPv4地址'
- en: '`asio::ip::address_v6`: This represents an IPv6 address'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::address_v6`: 这代表一个IPv6地址'
- en: '`asio::ip::address`: This IP-protocol-version-agnostic class can represent
    both IPv4 and IPv6 addresses'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::address`: 这个与IP协议版本无关的类可以表示IPv4和IPv6地址'
- en: In our sample, we use the `asio::ip::address` class, which makes the client
    application IP-protocol-version-agnostic. This means that it can transparently
    work with both IPv4 and IPv6 servers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`asio::ip::address`类，这使得客户端应用程序与IP协议版本无关。这意味着它可以透明地与IPv4和IPv6服务器一起工作。
- en: 'In step 2, we use the `asio::ip::address` class''s static method, `from_string()`.
    This method accepts a raw IP address represented as a string, parses and validates
    the string, instantiates an object of the `asio::ip::address` class, and returns
    it to the caller. This method has four overloads. In our sample we use this one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用`asio::ip::address`类的静态方法`from_string()`。此方法接受一个以字符串形式表示的原始IP地址，解析并验证该字符串，实例化一个`asio::ip::address`类的对象，并将其返回给调用者。此方法有四个重载。在我们的示例中，我们使用这个方法：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method is very useful as it checks whether the string passed to it as an
    argument contains a valid IPv4 or IPv6 address and if it does, instantiates a
    corresponding object. If the address is invalid, the method will designate an
    error through the second argument. It means that this function can be used to
    validate the raw user input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法非常有用，因为它检查传递给它的字符串参数是否包含有效的IPv4或IPv6地址，如果是，则实例化相应的对象。如果地址无效，该方法将通过第二个参数指定一个错误。这意味着此函数可以用于验证原始用户输入。
- en: In step 3, we instantiate an object of the `boost::asio::ip::tcp::endpoint`
    class, passing the IP address and a protocol port number to its constructor. Now,
    the `ep` object can be used to designate a server application in the Boost.Asio
    communication related functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们实例化一个`boost::asio::ip::tcp::endpoint`类的对象，将其构造函数传递IP地址和协议端口号。现在，`ep`对象可以用于在Boost.Asio通信相关函数中指定服务器应用程序。
- en: The second sample has a similar idea, although it somewhat differs from the
    first one. The server application is usually provided only with the protocol port
    number on which it should listen for incoming messages. The IP address is not
    provided because the server application usually wants to listen for the incoming
    messages on all IP addresses available on the host, not only on a specific one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例有类似的想法，尽管它与第一个示例略有不同。服务器应用程序通常只提供它应该监听传入消息的协议端口号。不提供IP地址，因为服务器应用程序通常希望监听主机上所有可用的IP地址上的传入消息，而不仅仅是特定的一个。
- en: To represent the concept of *all IP addresses available on the host*, the classes
    `asio::ip::address_v4` and `asio::ip::address_v6` provide a static method `any()`,
    which instantiates a special object of corresponding class representing the concept.
    In step 2, we use the `any()` method of the `asio::ip::address_v6` class to instantiate
    such a special object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示 *主机上所有可用的 IP 地址* 的概念，`asio::ip::address_v4` 和 `asio::ip::address_v6` 类提供了一个静态方法
    `any()`，它实例化了一个代表该概念的相应类的特殊对象。在第 2 步中，我们使用了 `asio::ip::address_v6` 类的 `any()`
    方法来实例化这样一个特殊对象。
- en: Note that the IP-protocol-version-agnostic class `asio::ip::address` does not
    provide the `any()` method. The server application must explicitly specify whether
    it wants to receive requests either on IPv4 or on IPv6 addresses by using the
    object returned by the `any()` method of either the `asio::ip::address_v4` or
    `asio::ip::address_v6` class correspondingly. In step 2 of our second sample,
    we assume that our server communicates over IPv6 protocol and therefore called
    the `any()` method of the `asio::ip::address_v6` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IP 协议版本无关的类 `asio::ip::address` 不提供 `any()` 方法。服务器应用程序必须明确指定它是否想要通过 `asio::ip::address_v4`
    或 `asio::ip::address_v6` 类的 `any()` 方法返回的对象来接收 IPv4 或 IPv6 地址上的请求。在我们的第二个示例的第
    2 步中，我们假设我们的服务器通过 IPv6 协议进行通信，因此调用了 `asio::ip::address_v6` 类的 `any()` 方法。
- en: In step 3, we create an endpoint object which represents all IP addresses available
    on the host and a particular protocol port number.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们创建了一个端点对象，它代表主机上所有可用的 IP 地址和特定的协议端口号。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In both our previous samples we used the `endpoint` class declared in the scope
    of the `asio::ip::tcp` class. If we look at the declaration of the `asio::ip::tcp`
    class, we''ll see something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的两个示例中，我们使用了在 `asio::ip::tcp` 类作用域中声明的 `endpoint` 类。如果我们查看 `asio::ip::tcp`
    类的声明，我们会看到如下内容：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It means that this `endpoint` class is a specialization of the `basic_endpoint<>`
    template class that is intended for use in clients and servers communicating over
    the TCP protocol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个 `endpoint` 类是 `basic_endpoint<>` 模板类的特化，旨在用于通过 TCP 协议进行通信的客户端和服务器。
- en: 'However, creating endpoints that can be used in clients and servers that communicate
    over the UDP protocol is just as easy. To represent such an endpoint, we need
    to use the `endpoint` class declared in the scope of the `asio::ip::udp` class.
    The following code snippet demonstrates how this `endpoint` class is declared:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建可用于通过 UDP 协议进行通信的客户端和服务器端点的过程同样简单。为了表示这样的端点，我们需要使用在 `asio::ip::udp` 类作用域中声明的
    `endpoint` 类。以下代码片段演示了如何声明这个 `endpoint` 类：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, if we want to create an endpoint in our client application to
    designate a server with which we want to communicate over the UDP protocol, we
    would only slightly change the implementation of step 3 in our sample. This is
    how that step would look like with changes highlighted:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在客户端应用程序中创建一个端点，指定我们想要通过 UDP 协议与之通信的服务器，我们只需稍微更改我们示例中步骤 3 的实现。以下是更改后的步骤，其中更改部分已突出显示：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All other code would not need to be changed as it is transport protocol independent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有代码都不需要更改，因为它们与传输协议无关。
- en: The same trivial change in the implementation of step 3 in our second sample
    is required to switch from a server communicating over TCP to one communicating
    over UDP.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第二个示例的实现中，步骤 3 的相同微小更改即可从使用 TCP 通信的服务器切换到使用 UDP 通信的服务器。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Binding a socket to an endpoint* recipe explains how the endpoint object
    is used in a server application
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将套接字绑定到端点* 菜单解释了在服务器应用程序中如何使用端点对象'
- en: The *Connecting a socket* recipe explains how the endpoint object is used in
    a client application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接套接字* 菜单解释了在客户端应用程序中如何使用端点对象'
- en: Creating an active socket
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建活动套接字
- en: The TCP/IP standard tells us nothing about sockets. Moreover, it tells us almost
    nothing about how to implement the TCP or UDP protocol software API through which
    this software functionality can be consumed by the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 标准对我们关于套接字的内容没有说明。此外，它几乎没有告诉我们如何实现 TCP 或 UDP 协议软件 API，通过这个 API，应用程序可以消费这些软件功能。
- en: If we look at section 3.8, *Interface*, of the RFC document *#793* which describes
    the TCP protocol, we'll find out that it contains only functional requirements
    of a minimal set of functions that the TCP protocol software API must provide.
    A developer of the protocol software is given full control over all other aspects
    of the API, such as the structure of the API, names of the functions comprising
    the API, the object model, the abstractions involved, additional auxiliary functions,
    and so on. Every developer of the TCP protocol software is free to choose the
    way to implement the interface to his or her protocol implementation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看RFC文档*#793*的第3.8节*接口*，该文档描述了TCP协议，我们会发现它只包含TCP协议软件API必须提供的最小功能集的功能要求。协议软件的开发者对API的所有其他方面拥有完全控制权，例如API的结构、组成API的函数的名称、对象模型、涉及的抽象、附加辅助函数等。每个TCP协议软件的开发者都可以自由选择实现其协议接口的方式。
- en: 'The same story applies with the UDP protocol: only a small set of functional
    requirements of mandatory operations are described in the RFC document *#768*
    devoted to it. The control of all other aspects of the UDP protocol software API
    is reserved for the developer of this API.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UDP协议，情况也是一样的：RFC文档*#768*中只描述了它的一小部分功能要求，该文档专门针对它。UDP协议软件API的所有其他方面的控制权都保留给了该API的开发者。
- en: As it has already been mentioned in the introduction to this chapter, Berkeley
    Sockets API is the most popular TCP and UDP protocols' API. It is designed around
    the concept of a socket—an abstract object representing a communication session
    context. Before we can perform any network I/O operations, we must first allocate
    a socket object and then associate each I/O operation with it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中已提到的，伯克利套接字API是最流行的TCP和UDP协议的API。它是围绕套接字的概念设计的——一个表示通信会话上下文的抽象对象。在我们能够执行任何网络I/O操作之前，我们必须首先分配一个套接字对象，然后将每个I/O操作与之关联。
- en: Boost.Asio borrows many concepts from Berkeley Sockets API and is so much similar
    to it that we can call it "an object oriented Berkeley Sockets API". The Boost.Asio
    library includes a class representing a socket concept, which provides interface
    methods similar to those found in Berkeley Sockets API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio借鉴了许多伯克利套接字API的概念，并且与之非常相似，我们可以称之为“面向对象的伯克利套接字API”。Boost.Asio库包括一个代表套接字概念的类，它提供了与伯克利套接字API中找到的类似接口方法。
- en: Basically, there are two types of sockets. A socket intended to be used to send
    and receive data to and from a remote application or to initiate a connection
    establishment process with it is called an **active socket**, whereas a **passive
    socket** is the one used to passively wait for incoming connection requests from
    remote applications. Passive sockets don't take part in user data transmission.
    We'll talk about passive sockets later in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，有两种类型的套接字。一种是为了发送和接收数据到远程应用程序或与之建立连接建立过程的套接字被称为**活动套接字**，而**被动套接字**是用来被动等待来自远程应用程序的连接请求的。被动套接字不参与用户数据传输。我们将在本章后面讨论被动套接字。
- en: This recipe explains how to create and open an active socket.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱解释了如何创建和打开活动套接字。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following algorithm describes the steps required to perform in a client
    application to create and open an active socket:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在客户端应用程序中执行以创建和打开活动套接字所需的步骤：
- en: Create an instance of the `asio::io_service` class or use the one that has been
    created earlier.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`asio::io_service`类的实例或使用之前创建的实例。
- en: Create an object of the class that represents the transport layer protocol (TCP
    or UDP) and the version of the underlying IP protocol (IPv4 or IPv6) over which
    the socket is intended to communicate.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表传输层协议（TCP或UDP）以及套接字打算通信的底层IP协议（IPv4或IPv6）版本的类的对象。
- en: Create an object representing a socket corresponding to the required protocol
    type. Pass the object of `asio::io_service` class to the socket's constructor.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表所需协议类型的套接字的实例。将`asio::io_service`类的对象传递给套接字构造函数。
- en: Call the socket's `open()` method, passing the object representing the protocol
    created in step 2 as an argument.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用套接字的`open()`方法，传递代表步骤2中创建的协议的对象作为参数。
- en: 'The following code sample demonstrates possible implementation of the algorithm.
    It is assumed that the socket is intended to be used to communicate over the TCP
    protocol and IPv4 as the underlying protocol:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现。假设套接字打算用于通过 TCP 协议和 IPv4 作为底层协议进行通信：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we instantiate an object of the `asio::io_service` class. This class
    is a central component in the Boost.Asio I/O infrastructure. It provides access
    to the network I/O services of the underlying operating system. Boost.Asio sockets
    get access to those services through the object of this class. Therefore, all
    socket class constructors require an object of `asio::io_service` as an argument.
    We'll consider the `asio::io_service` class in more detail in the following chapters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们实例化 `asio::io_service` 类的一个对象。这个类是 Boost.Asio I/O 基础设施的一个核心组件。它提供了对底层操作系统的网络
    I/O 服务的访问。Boost.Asio 套接字通过这个类的对象访问这些服务。因此，所有套接字类构造函数都需要一个 `asio::io_service` 对象作为参数。我们将在接下来的章节中更详细地考虑
    `asio::io_service` 类。
- en: In the next step, we create an instance of the `asio::ip::tcp` class. This class
    represents a TCP protocol. It provides no functionality, but rather acts like
    a data structure that contains a set of values that describe the protocol.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们创建 `asio::ip::tcp` 类的一个实例。这个类代表一个 TCP 协议。它不提供任何功能，而更像是一个包含描述协议的一组值的结构。
- en: The `asio::ip::tcp` class doesn't have a public constructor. Instead, it provides
    two static methods, `asio::ip::tcp::v4()` and `asio::ip::tcp::v6()`, that return
    an object of the `asio::ip::tcp` class representing the TCP protocol with the
    underlying IPv4 or IPv6 protocol correspondingly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp` 类没有公共构造函数。相反，它提供了两个静态方法，`asio::ip::tcp::v4()` 和 `asio::ip::tcp::v6()`，它们返回一个
    `asio::ip::tcp` 类的对象，该对象代表使用底层 IPv4 或 IPv6 协议的 TCP 协议。'
- en: 'Besides, the `asio::ip::tcp` class contains declarations of some basic types
    intended to be used with the TCP protocol. Among them are `asio::tcp::endpoint`,
    `asio::tcp::socket`, `asio::tcp::acceptor`, and others. Let''s have a look at
    those declarations found in the `boost/asio/ip/tcp.hpp` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`asio::ip::tcp` 类包含了一些基本类型的声明，这些类型旨在与 TCP 协议一起使用。其中包含 `asio::tcp::endpoint`、`asio::tcp::socket`、`asio::tcp::acceptor`
    以及其他类型。让我们看看在 `boost/asio/ip/tcp.hpp` 文件中找到的这些声明：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In step 3, we create an instance of the `asio::ip::tcp::socket` class, passing
    the object of the `asio::io_service` class to its constructor as an argument.
    Note that this constructor does not allocate the underlying operating system's
    socket object. The real operating system's socket is allocated in step 4 when
    we call the `open()` method and pass an object specifying protocol to it as an
    argument.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们创建 `asio::ip::tcp::socket` 类的一个实例，将 `asio::io_service` 类的对象作为参数传递给其构造函数。注意，这个构造函数不会分配底层操作系统的套接字对象。真正的操作系统套接字是在步骤
    4 中分配的，当我们调用 `open()` 方法并将指定协议的对象作为参数传递给它时。
- en: In Boost.Asio, *opening* a socket means associating it with full set of parameters
    describing a specific protocol over which the socket is intended to be communicating.
    When the Boost.Asio socket object is provided with these parameters, it has enough
    information to allocate a real socket object of the underlying operating system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost.Asio 中，*打开* 套接字意味着将其与描述特定协议的完整参数集关联起来，该协议是套接字打算通过它进行通信的。当 Boost.Asio
    套接字对象提供这些参数时，它有足够的信息来分配底层操作系统的真实套接字对象。
- en: 'The `asio::ip::tcp::socket` class provides another constructor that accepts
    a protocol object as an argument. This constructor constructs a socket object
    and opens it. Note that this constructor throws an exception of the type `boost::system::system_error`
    if it fails. Here is a sample demonstrating how we could combine steps 3 and 4
    from the previous sample:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::socket` 类提供了一个接受协议对象作为参数的构造函数。这个构造函数构建一个套接字对象并打开它。注意，如果这个构造函数失败，它会抛出一个类型为
    `boost::system::system_error` 的异常。以下是一个示例，展示了我们如何将上一个示例中的步骤 3 和 4 结合起来：'
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The previous sample demonstrates how to create an active socket intended to
    communicate over the TCP protocol. The process of creating a socket intended for
    communication over the UDP protocol is almost identical.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了如何创建一个用于通过 TCP 协议通信的主动套接字。创建用于通过 UDP 协议通信的套接字的过程几乎相同。
- en: 'The following sample demonstrates how to create an active UDP socket. It is
    assumed that the socket is going to be used to communicate over the UDP protocol
    with IPv6 as the underlying protocol. No explanation is provided with the sample
    because it is very similar to the previous one and therefore should not be difficult
    to understand:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何创建一个活动 UDP 套接字。假设该套接字将用于通过 UDP 协议与 IPv6 作为底层协议进行通信。由于示例与上一个示例非常相似，因此不需要提供解释，应该不难理解：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a passive socket* recipe, as its name suggests, provides discussion
    of passive sockets and demonstrates their use
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个被动套接字* 烹饪法，正如其名称所暗示的，提供了对被动套接字的讨论，并展示了它们的使用'
- en: The *Connecting a socket* recipe explains one of the uses of active sockets,
    namely connecting to the remote application
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接套接字* 烹饪法解释了活动套接字的一种用途，即连接到远程应用程序'
- en: Creating a passive socket
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个被动套接字
- en: 'A passive socket or acceptor socket is a type of socket that is used to wait
    for connection establishment requests from remote applications that communicate
    over the TCP protocol. This definition has two important implications:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 被动套接字或接受器套接字是一种用于等待通过 TCP 协议与远程应用程序建立连接请求的套接字类型。这个定义有两个重要的含义：
- en: Passive sockets are used only in server applications or hybrid applications
    that may play both roles of the client and server.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动套接字仅在服务器应用程序或可能同时扮演客户端和服务器角色的混合应用程序中使用。
- en: Passive sockets are defined only for the TCP protocol. As the UDP protocol doesn't
    imply connection establishment, there is no need for a passive socket when communication
    is performed over UDP.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动套接字仅适用于 TCP 协议。由于 UDP 协议不涉及连接建立，因此在通过 UDP 进行通信时不需要被动套接字。
- en: This recipe explains how to create and open a passive socket in Boost.Asio.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本烹饪法解释了如何在 Boost.Asio 中创建和打开一个被动套接字。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In Boost.Asio a passive socket is represented by the `asio::ip::tcp::acceptor`
    class. The name of the class suggests the key function of the objects of the class—to
    listen for and *accept* or handle incoming connection requests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost.Asio 中，被动套接字由 `asio::ip::tcp::acceptor` 类表示。类的名称暗示了该类对象的关键功能——监听并 *接受*
    或处理传入的连接请求。
- en: 'The following algorithm describes the steps required to perform to create an
    acceptor socket:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了执行创建接受器套接字所需的步骤：
- en: Create an instance of the `asio::io_service` class or use the one that has been
    created earlier.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `asio::io_service` 类的实例或使用之前已创建的实例。
- en: Create an object of the `asio::ip::tcp` class that represents the TCP protocol
    and the required version of the underlying IP protocol (IPv4 or IPv6).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表 TCP 协议及其所需底层 IP 协议版本（IPv4 或 IPv6）的 `asio::ip::tcp` 类的对象。
- en: Create an object of the `asio::ip::tcp::acceptor` class representing an acceptor
    socket, passing the object of the `asio::io_service` class to its constructor.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表接受器套接字的 `asio::ip::tcp::acceptor` 类的对象，将 `asio::io_service` 类的对象传递给其构造函数。
- en: Call the acceptor socket's `open()` method, passing the object representing
    the protocol created in step 2 as an argument.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用接受器套接字的 `open()` 方法，将代表步骤 2 中创建的协议的对象作为参数传递。
- en: 'The following code sample demonstrates the possible implementation of the algorithm.
    It is assumed that the acceptor socket is intended to be used over the TCP protocol
    and IPv6 as the underlying protocol:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现。假设接受器套接字打算在 TCP 协议和 IPv6 作为底层协议的情况下使用：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because an acceptor socket is very similar to an active socket, the procedure
    of creating them is almost identical. Therefore, here we only shortly go through
    the sample code. For more details about each step and each object involved in
    the procedure, please refer to the *Creating an active socket* recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接受器套接字与活动套接字非常相似，因此创建它们的程序几乎相同。因此，这里我们只简要地浏览一下示例代码。有关每个步骤和每个对象在程序中的详细说明，请参阅
    *创建一个活动套接字* 烹饪法。
- en: In step 1, we create an instance of the `asio::io_service` class. This class
    is needed by all Boost.Asio components that need access to the services of the
    underlying operating system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们创建一个 `asio::io_service` 类的实例。这个类是所有需要访问底层操作系统服务的 Boost.Asio 组件所需要的。
- en: In step 2, we create an object representing a TCP protocol with IPv6 as its
    underlying protocol.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 中，我们创建了一个代表具有 IPv6 作为底层协议的 TCP 协议的对象。
- en: Then in step 3, we create an instance of the `asio::ip::tcp::acceptor` class,
    passing an object of the `asio::io_service` class as an argument to its constructor.
    Just as in the case of an active socket, this constructor instantiates an object
    of Boost.Asio the `asio::ip::tcp::acceptor` class, but does not allocate the actual
    socket object of the underlying operating system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在步骤3中，我们创建`asio::ip::tcp::acceptor`类的实例，将其构造函数的参数传递给`asio::io_service`类的对象。正如在活动套接字的情况下，这个构造函数实例化了Boost.Asio的`asio::ip::tcp::acceptor`类对象，但并没有分配底层操作系统的实际套接字对象。
- en: The operating system socket object is allocated in step 4, where we open the
    acceptor socket object, calling its `open()` method and passing the protocol object
    to it as an argument. If the call succeeds, the acceptor socket object is opened
    and can be used to start listening for incoming connection requests. Otherwise,
    the `ec` object of the `boost::system::error_code` class will contain error information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统套接字对象在步骤4中分配，在那里我们打开接受器套接字对象，调用其`open()`方法并将协议对象作为参数传递给它。如果调用成功，接受器套接字对象将被打开并可用于开始监听传入的连接请求。否则，`boost::system::error_code`类的`ec`对象将包含错误信息。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an active socket* recipe provides more details about the `asio::io_service`
    and `asio::ip::tcp` classes
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “创建一个活动套接字”配方提供了更多关于`asio::io_service`和`asio::ip::tcp`类的详细信息。
- en: Resolving a DNS name
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析DNS名称
- en: Raw IP addresses are very inconvenient for humans to perceive and remember,
    especially if they are IPv6 addresses. Take a look at `192.168.10.123` (IPv4)
    or `8fee:9930:4545:a:105:f8ff:fe21:67cf` (IPv6). Remembering those sequences of
    numbers and letters could be a challenge for anyone.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原始IP地址对人类来说非常不便感知和记忆，尤其是如果它们是IPv6地址。看看`192.168.10.123`（IPv4）或`8fee:9930:4545:a:105:f8ff:fe21:67cf`（IPv6）。记住这些数字和字母的序列可能对任何人都是一个挑战。
- en: To enable labeling the devices in a network with human-friendly names, the **Domain
    Name System** (**DNS**) was introduced. In short, DNS is a distributed naming
    system that allows associating human-friendly names with devices in a computer
    network. A **DNS name** or a **domain name** is a string that represents a name
    of a device in the computer network.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使网络中的设备能够用人类友好的名称进行标记，引入了**域名系统**（**DNS**）。简而言之，DNS是一个分布式命名系统，允许将人类友好的名称与计算机网络中的设备关联起来。**DNS名称**或**域名**是一个表示计算机网络中设备名称的字符串。
- en: To be precise, a DNS name is an alias for one or more IP addresses but not the
    devices. It doesn't name a particular physical device but an IP address that can
    be assigned to a device. Thus, DNS introduces a level of indirection in addressing
    a particular server application in the network.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要精确地说，DNS名称是一个或多个IP地址的别名，而不是设备。它并不指代特定的物理设备，而是指可以分配给设备的IP地址。因此，DNS在指定网络中特定服务器应用时引入了间接层次。
- en: DNS acts as a distributed database storing mappings of DNS names to corresponding
    IP addresses and providing an interface, allowing querying the IP addresses to
    which a particular DNS name is mapped. The process of transforming a DNS name
    into corresponding IP addresses is called a **DNS name resolution**. Modern network
    operating systems contain functionality that can query DNS to resolve DNS names
    and provides the interface that can be used by applications to perform DNS name
    resolution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: DNS充当一个分布式数据库，存储DNS名称到相应IP地址的映射，并提供一个接口，允许查询映射到特定DNS名称的IP地址。将DNS名称转换为相应IP地址的过程称为**DNS名称解析**。现代网络操作系统包含可以查询DNS以解析DNS名称并提供应用程序用于执行DNS名称解析的接口的功能。
- en: When given a DNS name, before a client can communicate with a corresponding
    server application, it must first resolve the name to obtain IP addresses associated
    with that name.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定一个DNS名称时，在客户端能够与相应的服务器应用通信之前，它必须首先解析该名称以获取与该名称关联的IP地址。
- en: This recipe explains how to perform a DNS name resolution with Boost.Asio.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方解释了如何使用Boost.Asio执行DNS名称解析。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following algorithm describes steps required to perform in a client application
    in order to resolve a DNS name to obtain IP addresses (zero or more) of hosts
    (zero or more) running the server application that the client application wants
    to communicate with:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在客户端应用中执行以解析DNS名称以获取主机（零个或多个）运行的服务器应用（零个或多个）的IP地址（零个或多个）所需的步骤：
- en: Obtain the DNS name and the protocol port number designating the server application
    and represent them as strings.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指定服务器应用程序的DNS名称和协议端口号，并将它们表示为字符串。
- en: Create an instance of the `asio::io_service` class or use the one that has been
    created earlier.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`asio::io_service`类的实例或使用之前创建的实例。
- en: Create an object of the `resolver::query` class representing a DNS name resolution
    query.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示DNS名称解析查询的`resolver::query`类的对象。
- en: Create an instance of DNS name resolver class suitable for the necessary protocol.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个适合所需协议的DNS名称解析器类的实例。
- en: Call the resolver's `resolve()` method, passing a query object created in step
    3 to it as an argument.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用解析器的`resolve()`方法，将第3步中创建的查询对象作为参数传递给它。
- en: 'The following code sample demonstrates the possible implementation of the algorithm.
    It is assumed that the client application is intended to communicate with the
    server application over the TCP protocol and IPv6 as the underlying protocol.
    Besides, it is assumed that the server DNS name and a port number have already
    been obtained and represented as strings by the client application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现。假设客户端应用程序旨在通过TCP协议和IPv6作为底层协议与服务器应用程序通信。此外，假设服务器DNS名称和端口号已经由客户端应用程序获取，并以字符串的形式表示：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we begin by obtaining a DNS name and a protocol port number and representing
    them as strings. Usually, these parameters are supplied by a user through the
    client application's UI or as command-line arguments. The process of obtaining
    and validating these parameters is behind the scope of this recipe; therefore,
    here we assume that they are available at the beginning of the sample.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们首先获取一个DNS名称和一个协议端口号，并将它们表示为字符串。通常，这些参数是由用户通过客户端应用程序的UI或作为命令行参数提供的。获取和验证这些参数的过程超出了本食谱的范围；因此，在这里我们假设它们在样本开始时是可用的。
- en: Then, in step 2, we create an instance of the `asio::io_service` class that
    is used by the resolver to access underlying OS's services during a DNS name resolution
    process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第2步中，我们创建了一个`asio::io_service`类的实例，该实例由解析器在DNS名称解析过程中用于访问底层操作系统的服务。
- en: In step 3 we create an object of the `asio::ip::tcp::resolver::query` class.
    This object represents a query to the DNS. It contains a DNS name to resolve,
    a port number that will be used to construct an endpoint object after the DNS
    name resolution and a set of flags controlling some specific aspects of resolution
    process, represented as a bitmap. All these values are passed to the query class's
    constructor. Because the service is specified as a protocol port number (in our
    case, `3333`) and not as a service name (for example, HTTP, FTP, and so on), we
    passed the `asio::ip::tcp::resolver::query::numeric_service` flag to explicitly
    inform the query object about that, so that it properly parses the port number
    value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们创建了一个`asio::ip::tcp::resolver::query`类的对象。这个对象代表了对DNS的查询。它包含一个要解析的DNS名称，一个在DNS名称解析后用于构建端点对象的端口号，以及一组控制解析过程某些特定方面的标志，这些标志以位图的形式表示。所有这些值都传递给了查询类构造函数。因为服务被指定为协议端口号（在我们的例子中，是`3333`），而不是服务名称（例如，HTTP、FTP等），所以我们传递了`asio::ip::tcp::resolver::query::numeric_service`标志，以明确告知查询对象这一点，使其能够正确解析端口号值。
- en: In step 4, we create an instance of the `asio::ip::tcp::resolver` class. This
    class provides the DNS name resolution functionality. To perform the resolution,
    it requires services of the underlying operating system and it gets access to
    them through the object of the `asio::io_services` class being passed to its constructor
    as an argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们创建了一个`asio::ip::tcp::resolver`类的实例。这个类提供了DNS名称解析功能。为了执行解析，它需要底层操作系统的服务，并且它通过传递给其构造函数的`asio::io_services`类对象来访问这些服务。
- en: The DNS name resolution is performed in step 5 in the resolver object's `resolve()`
    method. The method overload we use in our sample accepts objects of the `asio::ip::tcp::resolver::query`
    and `system::error_code` classes. The latter object will contain information describing
    the error if the method fails.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: DNS名称解析在第5步中通过解析器对象的`resolve()`方法执行。我们在样本中使用的重载方法接受`asio::ip::tcp::resolver::query`和`system::error_code`类的对象。后者将包含描述错误的信息，如果方法失败。
- en: If successful, the method returns an object of the `asio::ip::tcp::resolver::iterator`
    class, which is an iterator pointing to the first element of a collection representing
    resolution results. The collection contains objects of the `asio::ip::basic_resolver_entry<tcp>`
    class. There are as many objects in the collection as the total number of IP addresses
    that resolution yielded. Each collection element contains an object of the `asio::ip::tcp::endpoint`
    class instantiated from one IP address resulting from the resolution process and
    a port number provided with the corresponding `query` object. The `endpoint` object
    can be accessed through the `asio::ip::basic_resolver_entry<tcp>::endopoint()`
    getter method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，该方法返回一个 `asio::ip::tcp::resolver::iterator` 类型的对象，该迭代器指向表示解析结果的集合的第一个元素。该集合包含
    `asio::ip::basic_resolver_entry<tcp>` 类型的对象。集合中的对象数量与解析产生的总IP地址数量相同。每个集合元素包含一个由解析过程生成的IP地址实例化的
    `asio::ip::tcp::endpoint` 类对象和一个与相应 `query` 对象提供的端口号。可以通过 `asio::ip::basic_resolver_entry<tcp>::endpoint()`
    获取器方法访问 `endpoint` 对象。
- en: 'The default-constructed object of the `asio::ip::tcp::resolver::iterator` class
    represents an end iterator. Consider the following sample demonstrating how we
    can iterate through the elements of the collection representing the DNS name resolution
    process results and how to access the resulting endpoint objects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::resolver::iterator` 类型的默认构造对象表示一个结束迭代器。以下示例演示了如何遍历表示DNS名称解析过程结果的集合元素，以及如何访问结果端点对象：'
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, when a DNS name of the host running the server application is resolved
    to more than one IP address and correspondingly to more than one endpoint, the
    client application doesn't know which one of the multiple endpoints to prefer.
    The common approach in this case is to try to communicate with each endpoint one
    by one, until the desired response is received.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当运行服务器应用程序的主机DNS名称解析为多个IP地址，并相应地解析为多个端点时，客户端应用程序不知道应该选择多个端点中的哪一个。在这种情况下，常见的做法是逐个尝试与每个端点通信，直到收到期望的响应。
- en: Note that when the DNS name is mapped to more than one IP address and some of
    them are IPv4 and others are IPv6 addresses, the DNS name may be resolved either
    to the IPv4 address or to the IPv6 address or to both. Therefore, the resulting
    collection may contain endpoints representing both IPv4 and IPv6 addresses.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当DNS名称映射到多个IP地址，其中一些是IPv4地址，而另一些是IPv6地址时，DNS名称可能解析为IPv4地址、IPv6地址或两者。因此，结果集合可能包含表示IPv4和IPv6地址的端点。
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'To resolve a DNS name and obtain a collection of endpoints that can be used
    in the client that is intended to communicate over the UDP protocol, the code
    is very similar. The sample is given here with differences highlighted and without
    explanation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析DNS名称并获取可用于通过UDP协议通信的客户端的端点集合，代码非常相似。以下给出了示例，其中突出显示了差异，但没有解释：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an endpoint* recipe provides more information on endpoints
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建端点* 菜单提供了更多关于端点的信息'
- en: For more information on DNS and domain names, refer to the specification of
    the system that can be found in the RFC *#1034* and RFC *#1035* documents
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关DNS和域名的更多信息，请参阅RFC *#1034* 和RFC *#1035* 文档中可找到的系统规范
- en: Binding a socket to an endpoint
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将套接字绑定到端点
- en: Before an active socket can communicate with a remote application or a passive
    socket can accept incoming connection requests, they must be associated with a
    particular local IP address (or multiple addresses) and a protocol port number,
    that is, an endpoint. The process of associating a socket with a particular endpoint
    is called **binding**. When a socket is bound to an endpoint, all network packets
    coming into the host from the network with that endpoint as their target address
    will be redirected to that particular socket by the operating system. Likewise,
    all the data coming out from a socket bound to a particular endpoint will be output
    from the host to the network through a network interface associated with the corresponding
    IP address specified in that endpoint.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个活跃的套接字能够与远程应用程序通信或一个被动套接字能够接受传入的连接请求之前，它们必须与特定的本地IP地址（或多个地址）和一个协议端口号关联，即端点。将套接字与特定端点关联的过程称为**绑定**。当一个套接字绑定到端点时，所有以该端点为目标地址的网络数据包将由操作系统重定向到该特定套接字。同样，从绑定到特定端点的套接字输出的所有数据将通过与该端点中指定的IP地址关联的网络接口从主机发送到网络。
- en: Some operations bind unbound sockets implicitly. For example, an operation that
    connects an unbound active socket to a remote application, binds it implicitly
    to an IP address and a protocol port number chosen by the underlying operating
    system. Usually, the client application doesn't need to explicitly bind an active
    socket to a specific endpoint just because it doesn't need that specific endpoint
    to communicate with the server; it only needs *any* endpoint for that purpose.
    Therefore, it usually delegates the right to choose the IP address and the port
    number to which the socket should be bound to the operating system. However, in
    some special cases, the client application might need to use a specific IP address
    and a protocol port number to communicate with the remote application and therefore
    will bind its socket explicitly to that specific endpoint. We wouldn't consider
    these cases in our book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作会隐式地绑定未绑定的套接字。例如，将未绑定的活跃套接字连接到远程应用程序的操作，会隐式地将它绑定到由底层操作系统选择的IP地址和协议端口号。通常，客户端应用程序不需要显式地将活跃套接字绑定到特定的端点，因为它不需要特定的端点与服务器通信；它只需要*任何*端点即可。因此，它通常将选择套接字应绑定的IP地址和端口号的权利委托给操作系统。然而，在某些特殊情况下，客户端应用程序可能需要使用特定的IP地址和协议端口号与远程应用程序通信，因此将显式地将其套接字绑定到该特定端点。我们不会在我们的书中考虑这些情况。
- en: When socket binding is delegated to the operating system, there is no guarantee
    that it will be bound to the same endpoint each time. Even if there is a single
    network interface and a single IP address on the host, the socket may be bound
    to a different protocol port number every time the implicit binding is performed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字绑定委托给操作系统时，无法保证每次都会绑定到相同的端点。即使主机上只有一个网络接口和一个IP地址，套接字在每次进行隐式绑定时也可能绑定到不同的协议端口号。
- en: Unlike client applications that usually don't care through which IP address
    and protocol port number its active socket will be communicating with the remote
    application, the server application usually needs to bind its acceptor socket
    to a particular endpoint explicitly. This is explained by the fact that the server's
    endpoint must be known to all the clients that want to communicate with it and
    should stay the same after the server application is restarted.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常不关心其活跃套接字将通过哪个IP地址和协议端口号与远程应用程序通信的客户端应用程序不同，服务器应用程序通常需要显式地将其接受器套接字绑定到特定的端点。这一点可以通过服务器端点必须为所有希望与其通信的客户端所知，并且在服务器应用程序重启后应保持不变的事实来解释。
- en: This recipe explains how to bind a socket to particular endpoint with Boost.Asio.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱解释了如何使用Boost.Asio将套接字绑定到特定的端点。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following algorithm describes steps required to create an acceptor socket
    and to bind it to an endpoint designating all IP addresses available on the host
    and a particular protocol port number in the IPv4 TCP server application:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在IPv4 TCP服务器应用程序中创建接受器套接字并将其绑定到指定主机上所有可用IP地址和特定协议端口号的端点的步骤：
- en: Obtain the protocol port number on which the server should listen for incoming
    connection requests.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器应监听传入连接请求的协议端口号。
- en: Create an endpoint that represents all IP addresses available on the host and
    the protocol port number obtained in the step 1.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点，代表主机上所有可用 IP 地址和步骤 1 中获取的协议端口号。
- en: Create and open an acceptor socket.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并打开接受者套接字。
- en: Call the acceptor socket's `bind()` method, passing the endpoint object as an
    argument to it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用接受者套接字的 `bind()` 方法，将端点对象作为参数传递给它。
- en: 'The following code sample demonstrates possible implementation of the algorithm.
    It is assumed that the protocol port number has already been obtained by the application:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现。假设协议端口号已经由应用程序获取：
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We begin by obtaining a protocol port number in step 1\. The process of obtaining
    this parameter is beyond the scope of this recipe; therefore, here we assume that
    the port number has already been obtained and is available at the beginning of
    the sample.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在步骤 1 中获取一个协议端口号。获取此参数的过程超出了本菜谱的范围；因此，在此我们假设端口号已经获取并且可以在示例开始时使用。
- en: In step 2 we create an endpoint representing all IP addresses available on the
    host and the specified port number.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 中，我们创建了一个代表主机上所有可用 IP 地址和指定端口号的端点。
- en: In step 3 we instantiate and open the acceptor socket. The endpoint we created
    in step 2 contains information about the transport protocol and the version of
    the underlying IP protocol (IPv4). Therefore, we don't need to create another
    object representing the protocol to pass it to the acceptor socket's constructor.
    Instead, we use the endpoint's `protocol()` method, which returns an object of
    the `asio::ip::tcp` class representing the corresponding protocols.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们实例化并打开接受者套接字。我们创建的端点包含有关传输协议和底层 IP 协议版本（IPv4）的信息。因此，我们不需要创建另一个代表协议的对象并将其传递给接受者套接字构造函数。相反，我们使用端点的
    `protocol()` 方法，该方法返回一个 `asio::ip::tcp` 类的对象，代表相应的协议。
- en: The binding is performed in step 4\. This is quite a simple operation. We call
    the acceptor socket's `bind()` method, passing an object representing an endpoint
    to which the acceptor socket should be bound as an argument of the method. If
    the call succeeds, the acceptor socket is bound to the corresponding endpoint
    and is ready to start listening for incoming connection requests on that endpoint.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定操作在步骤 4 中执行。这是一个相当简单的操作。我们调用接受者套接字的 `bind()` 方法，将代表应绑定到接受者套接字的端点的对象作为方法的参数。如果调用成功，接受者套接字将绑定到相应的端点，并准备好在该端点上开始监听传入的连接请求。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com](http://www.packtpub.com) 下载您购买的所有 Packt 出版物的示例代码文件。如果您在其他地方购买了此书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给您。
- en: There's more…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'UDP servers don''t establish connections and use active sockets to wait for
    incoming requests. The process of binding an active socket is very similar to
    binding an acceptor socket. Here, we present a sample code demonstrating how to
    bind a UDP active socket to an endpoint designating all IP addresses available
    on the host and a particular protocol port number. The code is provided without
    explanation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 服务器不建立连接，并使用活动套接字等待传入请求。绑定活动套接字的过程与绑定接受者套接字的过程非常相似。在此，我们提供了一个示例代码，展示了如何将
    UDP 活动套接字绑定到指定主机上所有可用 IP 地址和特定协议端口号的端点。代码提供时未加解释：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: The *Creating an endpoint* recipe provides more information on endpoints
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建端点* 菜单提供了有关端点的更多信息'
- en: The *Creating an active socket* recipe provides more details about the `asio::io_service`
    and `asio::ip::tcp` classes and demonstrates how to create and open an active
    socket
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建活动套接字* 菜单提供了有关 `asio::io_service` 和 `asio::ip::tcp` 类的更多详细信息，并演示了如何创建和打开活动套接字'
- en: The *Creating a passive socket* recipe provides information about passive sockets
    and demonstrates how to create and open them
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建被动套接字* 菜单提供了有关被动套接字的信息，并演示了如何创建和打开它们'
- en: Connecting a socket
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接套接字
- en: Before a TCP socket can be used to communicate with a remote application, it
    must establish a *logical connection* with it. According to the TCP protocol,
    the *connection establishment process* lies in exchanging of service messages
    between two applications, which, if succeeds, results in two applications being
    *logically connected* and ready for communication with each other.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个TCP套接字可以使用来与远程应用程序通信之前，它必须与它建立一个*逻辑连接*。根据TCP协议，*连接建立过程*在于两个应用程序之间交换服务消息，如果成功，则导致两个应用程序*逻辑连接*并准备好相互通信。
- en: Roughly, the connection establishment process looks like this. The client application,
    when it wants to communicate with the server application, creates and opens an
    active socket and issues a `connect()` command on it, specifying a target server
    application with an endpoint object. This leads to a connection establishment
    request message being sent to the server application over the network. The server
    application receives the request and creates an active socket on its side, marking
    it as connected to a specific client and replies back to the client with the message
    acknowledging that connection is successfully set up on the server side. Next,
    the client having received the acknowledgement from the server, marks its socket
    as connected to the server, and sends one more message to it acknowledging that
    the connection is successfully set up on the client side. When the server receives
    the acknowledgement message from the client, the logical connection between two
    applications is considered established.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，连接建立过程看起来是这样的。当客户端应用程序想要与服务器应用程序通信时，它会创建并打开一个活跃的套接字，并在其上发出一个`connect()`命令，指定一个带有端点对象的目标服务器应用程序。这导致一个连接建立请求消息通过网络发送到服务器应用程序。服务器应用程序接收请求并在其端创建一个活跃的套接字，将其标记为连接到特定的客户端，并回复客户端，确认服务器端已成功建立连接。接下来，客户端收到服务器的确认后，将其套接字标记为连接到服务器，并向它发送一条确认消息，确认客户端端已成功建立连接。当服务器收到客户端的确认消息时，两个应用程序之间的逻辑连接被认为是建立的。
- en: The point-to-point communication model is assumed between two connected sockets.
    This means that if socket A is connected to socket B, both can only communicate
    with each other and cannot communicate with any other socket C. Before socket
    A can communicate with socket C, it must close the connection with socket B and
    establish a new connection with socket C.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个连接的套接字之间是点对点通信模型。这意味着如果套接字A连接到套接字B，那么它们只能相互通信，不能与任何其他套接字C通信。在套接字A能够与套接字C通信之前，它必须关闭与套接字B的连接，并与套接字C建立一个新的连接。
- en: This recipe explains how to synchronously connect a socket to a remote application
    with Boost.Asio.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱解释了如何使用Boost.Asio同步地将套接字连接到远程应用程序。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following algorithm descries steps required to perform in the TCP client
    application to connect an active socket to the server application:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了在TCP客户端应用程序中执行连接活跃套接字到服务器应用程序所需的步骤：
- en: Obtain the target server application's IP address and a protocol port number.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取目标服务器应用程序的IP地址和协议端口号。
- en: Create an object of the `asio::ip::tcp::endpoint` class from the IP address
    and the protocol port number obtained in step 1.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1中获取的IP地址和协议端口号创建一个`asio::ip::tcp::endpoint`类的对象。
- en: Create and open an active socket.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并打开一个活跃的套接字。
- en: Call the socket's `connect()` method specifying the endpoint object created
    in step 2 as an argument.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用套接字的`connect()`方法，将步骤2中创建的端点对象作为参数。
- en: If the method succeeds, the socket is considered connected and can be used to
    send and receive data to and from the server.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该方法成功，套接字被认为是连接的，并且可以用来向服务器发送和接收数据。
- en: 'The following code sample demonstrates a possible implementation of the algorithm:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we begin with obtaining the target server's IP address and a protocol
    port number. The process of obtaining these parameters is beyond the scope of
    this recipe; therefore, here we assume that they have already been obtained and
    are available at the beginning of our sample.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们从目标服务器获取IP地址和协议端口号。获取这些参数的过程超出了本食谱的范围；因此，在此我们假设它们已经获取并且在我们样本的开始时可用。
- en: In step 2, we create an object of the `asio::ip::tcp::endpoint` class designating
    the target server application to which we are going to connect.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们创建一个`asio::ip::tcp::endpoint`类的对象，指定我们打算连接的目标服务器应用程序。
- en: Then, in step 3 an active socket is instantiated and opened.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第3步中，实例化并打开一个活动套接字。
- en: In step 4, we call the socket's `connect()` method, passing an endpoint object
    designating the target server to it as an argument. This function connects the
    socket to the server. The connection is performed synchronously, which means that
    the method blocks the caller thread until either the connection operation is established
    or an error occurs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们调用套接字的`connect()`方法，将一个指定目标服务器的端点对象作为参数传递给它。这个函数将套接字连接到服务器。连接是同步进行的，这意味着该方法会阻塞调用线程，直到连接操作建立或发生错误。
- en: Note that we didn't bind the socket to any local endpoint before connecting
    it. This doesn't mean that the socket stays unbound. Before performing the connection
    establishment procedure, the socket's `connect()` method will bind the socket
    to the endpoint consisting of an IP address and a protocol port number chosen
    by the operating system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在连接之前，我们没有将套接字绑定到任何本地端点。这并不意味着套接字保持未绑定状态。在执行连接建立过程之前，套接字的`connect()`方法会将套接字绑定到操作系统选择的由IP地址和协议端口号组成的端点。
- en: Another thing to note in this sample is that we use an overload of the `connect()`
    method that throws an exception of the `boost::system::system_error` type if the
    operation fails, and so does overload of the `asio::ip::address::from_string()`
    static method we use in step 2\. Therefore, both calls are enclosed in a `try`
    block. Both methods have overloads that don't throw exceptions and accept an object
    of the `boost::system::error_code` class, which is used to conduct error information
    to the caller in case the operation fails. However, in this case, using exceptions
    to handle errors makes code better structured.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，还有一点需要注意，我们使用了一个`connect()`方法的重载版本，如果操作失败，它会抛出一个`boost::system::system_error`类型的异常，同样，我们在第2步中使用的`asio::ip::address::from_string()`静态方法的重载版本也是如此。因此，这两个调用都被包含在一个`try`块中。这两个方法都有不抛出异常的重载版本，并接受一个`boost::system::error_code`类的对象，该对象用于在操作失败时将错误信息传递给调用者。然而，在这种情况下，使用异常来处理错误可以使代码结构更清晰。
- en: There's more…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous code sample showed how to connect a socket to a specific server
    application designated by an endpoint when an IP address and a protocol port number
    are provided to the client application explicitly. However, sometimes the client
    application is provided with a DNS name that may be mapped to one or more IP addresses.
    In this case, we first need to resolve the DNS name using the `resolve()` method
    provided by the `asio::ip::tcp::resolver` class. This method resolves a DNS name,
    creates an object of the `asio::ip::tcp::endpoint` class from each IP address
    resulted from resolution, puts all endpoint objects in a collection, and returns
    an object of the `asio::ip::tcp::resolver::iterator` class, which is an iterator
    pointing to the first element in the collection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例展示了当客户端应用程序明确提供了IP地址和协议端口号时，如何将套接字连接到由端点指定的特定服务器应用程序。然而，有时客户端应用程序会提供一个DNS名称，该名称可能映射到一个或多个IP地址。在这种情况下，我们首先需要使用`asio::ip::tcp::resolver`类提供的`resolve()`方法解析DNS名称。此方法解析DNS名称，从解析结果中的每个IP地址创建一个`asio::ip::tcp::endpoint`类的对象，将所有端点对象放入一个集合中，并返回一个`asio::ip::tcp::resolver::iterator`类的对象，该迭代器指向集合中的第一个元素。
- en: When a DNS name resolves to multiple IP addresses, the client application—when
    deciding to which one to connect—usually has no reasons to prefer one IP address
    to any other. The common approach in this situation is to iterate through endpoints
    in the collection and try to connect to each of them one by one until the connection
    succeeds. Boost.Asio provides auxiliary functionality that implements this approach.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当DNS名称解析为多个IP地址时，客户端应用程序在决定连接到哪一个时，通常没有理由偏好任何一个IP地址。在这种情况下，常见的做法是遍历集合中的端点，并尝试逐个连接到它们，直到连接成功。Boost.Asio提供了实现此方法的辅助功能。
- en: The free function `asio::connect()` accepts an active socket object and an object
    of the `asio::ip::tcp::resolver::iterator` class as input arguments, iterates
    over a collection of endpoints, and tries to connect the socket to each endpoint.
    The function stops iteration, and returns when it either successfully connects
    a socket to one of the endpoints or when it has tried all the endpoints and failed
    to connect the socket to all of them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 自由函数`asio::connect()`接受一个活动套接字对象和一个`asio::ip::tcp::resolver::iterator`类对象作为输入参数，遍历一组端点，并尝试将套接字连接到每个端点。该函数在成功将套接字连接到其中一个端点或尝试了所有端点但未能将套接字连接到所有端点时停止迭代，并返回。
- en: 'The following algorithm demonstrates steps required to connect a socket to
    a server application represented by a DNS name and a protocol port number:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法演示了连接套接字到由DNS名称和协议端口号表示的服务器应用程序所需的步骤：
- en: Obtain the DNS name of a host running the server application and the server's
    port number and represent them as strings.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取运行服务器应用程序的主机的DNS名称和服务器端口号，并将它们表示为字符串。
- en: Resolve a DNS name using the `asio::ip::tcp::resolver` class.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`asio::ip::tcp::resolver`类解析DNS名称。
- en: Create an active socket without opening it.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个未打开的活动套接字。
- en: Call the `asio::connect()` function passing a socket object and an iterator
    object obtained in step 2 to it as arguments.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字对象和在第2步中获得的迭代器对象作为参数传递给`asio::connect()`函数。
- en: 'The following code sample demonstrates possible implementation of the algorithm:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了算法的可能实现：
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that in step 3, we don't open the socket when we create it. This is because
    we don't know the version of IP addresses to which the provided DNS name will
    resolve. The `asio::connect()` function opens the socket before connecting it
    to each endpoint specifying proper protocol object and closes it if the connection
    fails.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第3步中，我们创建套接字时不会打开它。这是因为我们不知道提供的DNS名称将解析到的IP地址版本。`asio::connect()`函数在将套接字连接到每个指定了正确协议对象的端点之前打开套接字，如果连接失败则关闭它。
- en: All other steps in the code sample should not be difficult to understand, therefore
    no explanation is provided.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例中的所有其他步骤都不难理解，因此没有提供解释。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an endpoint* recipe provides more information on endpoints
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建端点*菜谱提供了更多关于端点的信息。'
- en: The *Creating an active socket* recipe explains how to create and open a socket
    and provides more details about the `asio::io_service` class
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建活动套接字*菜谱解释了如何创建和打开套接字，并提供了关于`asio::io_service`类的更多详细信息。'
- en: The *Resolving a DNS name* recipe explains how to use a resolver class to resolve
    a DNS name
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解析DNS名称*菜谱解释了如何使用解析器类解析DNS名称。'
- en: The *Binding a socket* recipe provides more information about socket binding
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定套接字*菜谱提供了更多关于套接字绑定的信息。'
- en: Accepting connections
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受连接
- en: When the client application wants to communicate to the server application over
    a TCP protocol, it first needs to establish a logical connection with that server.
    In order to do that, the client allocates an active socket and issues a connect
    command on it (for example by calling the `connect()` method on the socket object),
    which leads to a connection establishment request message being sent to the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端应用程序想要通过TCP协议与服务器应用程序通信时，它首先需要与该服务器建立一个逻辑连接。为了做到这一点，客户端分配一个活动套接字并在其上发出连接命令（例如通过在套接字对象上调用`connect()`方法），这将导致连接建立请求消息被发送到服务器。
- en: On the server side, some arrangements must be performed before the server application
    can accept and handle the connection requests arriving from the clients. Before
    that, all connection requests targeted at this server application are rejected
    by the operating system.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，在服务器应用程序能够接受和处理来自客户端的连接请求之前，必须进行一些安排。在此之前，所有针对此服务器应用程序的连接请求都被操作系统拒绝。
- en: First, the server application creates and opens an acceptor socket and binds
    it to the particular endpoint. At this point, the client's connection requests
    arriving at the acceptor socket's endpoint are still rejected by the operating
    system. For the operating system to start accepting connection requests targeted
    at particular endpoint associated with particular acceptor socket, that acceptor
    socket must be switched into listening mode. After that, the operating system
    allocates a queue for pending connection requests associated with this acceptor
    socket and starts accepting connection request addressed to it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器应用程序创建并打开一个接受器套接字，并将其绑定到特定的端点。在此阶段，到达接受器套接字端点的客户端连接请求仍然被操作系统拒绝。为了使操作系统开始接受针对与特定接受器套接字关联的特定端点的连接请求，该接受器套接字必须切换到监听模式。之后，操作系统为与该接受器套接字关联的挂起连接请求分配一个队列，并开始接受针对它的连接请求。
- en: When a new connection request arrives, it is initially received by the operating
    system, which puts it to the pending connection requests queue associated with
    an acceptor socket being the connection request's target. When in the queue, the
    connection request is available to the server application for processing. The
    server application, when ready to process the next connection request, de-queues
    one and processes it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的连接请求到达时，它最初由操作系统接收，并将其放入与接受器套接字关联的挂起连接请求队列中。在队列中，连接请求可供服务器应用程序处理。当服务器应用程序准备好处理下一个连接请求时，它将出队一个并处理它。
- en: Note that the acceptor socket is only used to establish connections with client
    applications and is not used in the further communication process. When processing
    a pending connection request, the acceptor socket allocates a new active socket,
    binds it to an endpoint chosen by the operating system, and connects it to the
    corresponding client application that has issued that connection request. Then,
    this new active socket is ready to be used for communication with the client.
    The acceptor socket becomes available to process the next pending connection request.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接受器套接字仅用于与客户端应用程序建立连接，并在后续的通信过程中不被使用。在处理挂起的连接请求时，接受器套接字分配一个新的活动套接字，将其绑定到操作系统选择的端点，并将其连接到已发出该连接请求的相应客户端应用程序。然后，这个新的活动套接字就准备好用于与客户端进行通信。接受器套接字可用于处理下一个挂起的连接请求。
- en: This recipe describes how to switch an acceptor socket into listening mode and
    accept incoming connection requests in a TCP server application using Boost.Asio.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱描述了如何在TCP服务器应用程序中使用Boost.Asio将接受器套接字切换到监听模式并接受传入的连接请求。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following algorithm describes how to set up an acceptor socket so that
    it starts listening for incoming connections and then how to use it to synchronously
    process the pending connection request. The algorithm assumes that only one incoming
    connection will be processed in synchronous mode:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了如何设置接受器套接字，使其开始监听传入的连接，然后如何使用它来同步处理挂起的连接请求。该算法假设在同步模式下只处理一个传入连接：
- en: Obtain the port number on which the server will receive incoming connection
    requests.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器将接收传入连接请求的端口号。
- en: Create a server endpoint.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个服务器端点。
- en: Instantiate and open an acceptor socket.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化和打开一个接受器套接字。
- en: Bind the acceptor socket to the server endpoint created in step 2.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接受器套接字绑定到步骤2中创建的服务器端点。
- en: Call the acceptor socket's `listen()` method to make it start listening for
    incoming connection requests on the endpoint.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用接受器套接字的`listen()`方法，使其开始监听端点上的传入连接请求。
- en: Instantiate an active socket object.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个活动套接字对象。
- en: When ready to process a connection request, call the acceptor socket's `accept()`
    method passing an active socket object created in step 6 as an argument.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当准备好处理连接请求时，调用接受器套接字的`accept()`方法，并将步骤6中创建的活动套接字对象作为参数传递。
- en: If the call succeeds, the active socket is connected to the client application
    and is ready to be used for communication with it.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用成功，活动套接字将连接到客户端应用程序，并准备好与其进行通信。
- en: 'The following code sample demonstrates possible implementation of the server
    application that follows the algorithm. Here, we assume that the server is intended
    to communicate over the TCP protocol with IPv4 as the underlying protocol:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了遵循该算法的服务器应用程序的可能实现。在此，我们假设服务器旨在通过TCP协议与IPv4作为底层协议进行通信：
- en: '[PRE18]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we obtain the protocol port number to which the server application
    binds its acceptor socket. Here, we assume that the port number has already been
    obtained and is available at the beginning of the sample.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们获取服务器应用程序绑定其接受者套接字的协议端口号。在这里，我们假设端口号已经获取并且可以在示例开始时使用。
- en: In step 2, we create a server endpoint that designates all IP addresses available
    on the host running the server application and a specific protocol port number.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们创建一个服务器端点，指定运行服务器应用程序的主机上可用的所有IP地址和特定的协议端口号。
- en: Then in step 3, we instantiate and open an acceptor socket and bind it to the
    server endpoint in step 4.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中，我们实例化并打开一个接受者套接字，并在步骤4中将它绑定到服务器端点。
- en: In step 5, we call the acceptor's `listen()` method passing the BACKLOG_SIZE
    constant value as an argument. This call switches the acceptor socket into the
    state in which it listens for incoming connection requests. Unless we call the
    `listen()` method on the acceptor object, all connection requests arriving at
    corresponding endpoint will be rejected by the operating system network software.
    The application must explicitly notify the operating system that it wants to start
    listening for incoming connection requests on specific endpoint by this call.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤5中，我们调用接受者的`listen()`方法，将BACKLOG_SIZE常量值作为参数传递。此调用将接受者套接字切换到监听传入连接请求的状态。除非我们在接受者对象上调用`listen()`方法，否则所有到达相应端点的连接请求都将被操作系统网络软件拒绝。应用程序必须通过此调用显式通知操作系统，它希望开始在特定端点上监听传入的连接请求。
- en: The argument that the `listen()` method accepts as an argument specifies the
    size of the queue maintained by the operating system to which it puts connection
    requests arriving from the clients. The requests stay in the queue and are waiting
    for the server application to de-queue and process them. When the queue becomes
    full, the new connection requests are rejected by the operating system.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()`方法接受的参数指定了操作系统维护的队列的大小，该队列用于存放来自客户端的连接请求。请求保持在队列中，等待服务器应用程序将其出队并处理。当队列满时，操作系统将拒绝新的连接请求。'
- en: In step 6, we create an active socket object without opening it. We'll need
    it in step 7.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6中，我们创建一个活动套接字对象，但不打开它。我们将在步骤7中使用它。
- en: In step 7, we call the acceptor socket's `accept()` method. This method accepts
    an active socket as an argument and performs several operations. First, it checks
    the queue associated with the acceptor socket containing pending connection requests.
    If the queue is empty, the method blocks execution until a new connection request
    arrives to an endpoint to which the acceptor socket is bound and the operating
    system puts it in the queue.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤7中，我们调用接受者套接字的`accept()`方法。此方法接受一个活动套接字作为参数并执行几个操作。首先，它检查与接受者套接字关联的包含挂起连接请求的队列。如果队列为空，则方法会阻塞执行，直到新的连接请求到达接受者套接字绑定的端点，并且操作系统将其放入队列。
- en: If at least one connection request is available in the queue, the one on the
    top of the queue is extracted from it and processed. The active socket that was
    passed to the `accept()` method as an argument is connected to the corresponding
    client application which issued the connection request.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列中至少有一个连接请求可用，则队列顶部的请求将被提取出来并处理。传递给`accept()`方法作为参数的活动套接字将连接到发出连接请求的相应客户端应用程序。
- en: If the connection establishment process succeeds, the `accept()` method returns
    and the active socket is opened and connected to the client application and can
    be used to send data to and receive data from it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接建立过程成功，`accept()`方法将返回，活动套接字将被打开并连接到客户端应用程序，可以用来向其发送数据并接收数据。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the acceptor socket doesn't connect itself to the client application
    while processing a connection request. Instead, it opens and connects another
    active socket, which is then used for communication with the client application.
    The acceptor socket only listens for and processes (accepts) incoming connection
    requests.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在处理连接请求时，接受者套接字不会自己连接到客户端应用程序。相反，它打开并连接另一个活动套接字，然后使用该套接字与客户端应用程序进行通信。接受者套接字只监听和处理（接受）传入的连接请求。
- en: Note that UDP servers don't use acceptor sockets because the UDP protocol doesn't
    imply connection establishment. Instead, an active socket is used that is bound
    to an endpoint and listens for incoming I/O messages, and this same active socket
    is used for communication.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，UDP 服务器不使用接受器套接字，因为 UDP 协议不涉及连接建立。相反，使用一个绑定到端点并监听传入 I/O 消息的活动套接字，并且这个相同的活动套接字用于通信。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a passive socket* recipe provides information about passive sockets
    and demonstrates how to create and open them
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建被动套接字* 菜单提供了关于被动套接字的信息，并演示了如何创建和打开它们'
- en: The *Creating an endpoint* recipe provides more information on endpoints
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建端点* 菜单提供了更多关于端点的信息'
- en: The *Creating an active socket* recipe explains how to create and open a socket
    and provides more details about the `asio::io_service` class
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建活动套接字* 菜单解释了如何创建和打开套接字，并提供了关于 `asio::io_service` 类的更多细节'
- en: The *Binding a socket* recipe provides more information about socket binding
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定套接字* 菜单提供了更多关于套接字绑定的信息'
