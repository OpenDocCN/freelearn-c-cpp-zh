- en: Chapter 5. Data Binding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。数据绑定
- en: In the preceding two chapters, we looked at XAML and the way user interface
    elements are constructed and laid out with the help of the layout panels. The
    user interface, however, is just the first step. Some data must be set upon the
    UI to make up an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们看了XAML以及如何使用布局面板构建和布局用户界面元素。然而，用户界面只是第一步。必须在UI上设置一些数据来构成应用程序。
- en: There are several ways of getting data to the controls. The simplest, perhaps,
    and most direct is the one we've been using so far; getting a reference to a control
    and changing the relevant property. If we needed some text to be placed in a `TextBox`,
    we would simply change its `Text` property when needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将数据传递给控件。最简单、直接的方法可能是我们迄今为止一直在使用的方法；获取对控件的引用并在需要时更改相关属性。如果我们需要将一些文本放置在`TextBox`中，我们只需在需要时更改其`Text`属性。
- en: This certainly works and when working with the Win32 API for UI purposes, there
    is really no other way. But this is tedious at best, and involves an unmanageable
    maintenance headache at worst. Data is not the only thing that needs to be taken
    care of. Element states, such as enabled/disabled and checked/unchecked need to
    be examined and perhaps dynamically changed. In WinRT, much of this chore is handled
    with data binding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然有效，当使用Win32 API进行UI目的时，确实没有其他方法。但这充其量是繁琐的，最糟糕的是会导致难以管理的维护头痛。不仅需要处理数据，还需要检查并可能动态更改元素状态，例如启用/禁用和选中/未选中。在WinRT中，大部分这些工作都是通过数据绑定来处理的。
- en: Understanding data binding
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据绑定
- en: Data binding is essentially simple—one property changes in some object (source)
    and another property in another object (target) reflects the change in some meaningful
    way. Coupled with data templates, data binding provides a compelling and powerful
    way to visualize and interact with data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定基本上很简单——某个对象（源）中的一个属性发生变化，另一个对象（目标）中的另一个属性以某种有意义的方式反映这种变化。结合数据模板，数据绑定提供了一种引人注目且强大的可视化和与数据交互的方式。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Those familiar with WPF or Silverlight will find WinRT data binding very familiar.
    There are some changes, mostly omissions, from WinRT, making data binding a bit
    less powerful than in WPF/Silverlight. Still, it's much better than manually transferring
    and synchronizing data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉WPF或Silverlight的人会发现WinRT数据绑定非常熟悉。在WinRT中有一些更改，主要是省略，使数据绑定比在WPF/Silverlight中稍微不那么强大。但是，它仍然比手动传输和同步数据要好得多。
- en: Data binding in WinRT leads to one of the well-known patterns for working with
    data and UI in a seamless manner, known as **Model-View-ViewModel** (**MVVM**),
    which we'll briefly discuss at the end of this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT中的数据绑定导致了一种以无缝方式处理数据和UI的众所周知的模式之一，称为**Model-View-ViewModel**（**MVVM**），我们将在本章末尾简要讨论。
- en: Data binding concepts
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定概念
- en: 'We''ll start by examining some of the basic terms associated with data binding,
    with the WinRT specifics added:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查与数据绑定相关的一些基本术语，添加WinRT特定内容：
- en: '**Source**: The object whose property is monitored for changes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：要监视其属性以进行更改的对象。'
- en: '**Source path**: The property on the source object to monitor.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源路径**：要监视的源对象上的属性。'
- en: '**Target**: The object whose property is changed when the source changes. In
    WinRT, the target property must be a dependency property (as we''ll see later
    on).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标：当源发生变化时，其属性发生变化的对象。在WinRT中，目标属性必须是一个依赖属性（我们稍后会看到）。
- en: '**Binding mode**: Indicates the direction of the binding.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定模式**：指示绑定的方向。'
- en: 'Possible values are (all from the `Windows::UI::Xaml::Data::BindingMode` enumeration)
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的值（均来自`Windows::UI::Xaml::Data::BindingMode`枚举）如下：
- en: '`OneWay`: Source changes update the target'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneWay`：源更改更新目标'
- en: '`TwoWay`: Source and target update each other'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TwoWay`：源和目标相互更新'
- en: '`OneTime`: Source updates the target just once'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneTime`：源仅更新一次目标'
- en: Data binding is specified (most of the time) in XAML, providing a declarative
    and convenient way to connect to data. This has the direct effect of minimizing
    code writing for managing the element state and exchanging data between controls
    and data objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定通常（大部分时间）在XAML中指定，提供了一种声明性和便捷的连接数据的方式。这直接减少了管理元素状态和控件与数据对象之间交换数据的编写代码量。
- en: Element-to-element binding
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素到元素的绑定
- en: 'The first binding scenario we''ll examine is the way in which we can connect
    elements together without writing any code—by performing data binding between
    required properties. Consider the following two elements:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查的绑定场景是如何在不编写任何代码的情况下连接元素在一起的方式——通过在所需属性之间执行数据绑定。考虑以下两个元素：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Suppose we wanted the `FontSize` of the `TextBlock` to be changed, based on
    the current `Value` of the `Slider`. How would we go about doing that?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望根据`Slider`的当前`Value`来更改`TextBlock`的`FontSize`。我们该如何做呢？
- en: The obvious approach would be to use events. We can react to the `ValueChanged`
    event of the `Slider` and modify the `FontSize` property value of the `TextBlock`
    to be equal to the `Value` of the `Slider`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的方法是使用事件。我们可以对`Slider`的`ValueChanged`事件做出反应，并修改`TextBlock`的`FontSize`属性值，使其等于`Slider`的`Value`。
- en: 'This certainly works, but it has a few drawbacks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然有效，但有一些缺点：
- en: C++ code needs to be written for this to work. This is a shame, because no real
    data is used—this is just UI behavior. Perhaps a designer could take care of that
    if he/she could just use XAML and not code.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写C++代码才能使其工作。这很遗憾，因为这里并没有使用真正的数据，这只是UI行为。也许设计师可以负责这一点，如果他/她只能使用XAML而不是代码。
- en: Such logic may change in the future. creating a maintenance headache—remember
    that a typical user interface will contain many such interactions—the C++ developer
    does not really want to be concerned about every such little detail.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的逻辑可能会在将来发生变化，造成维护上的困扰——请记住，典型的用户界面将包含许多这样的交互——C++开发人员实际上并不想关心每一个这样的小细节。
- en: 'Data binding provides an elegant solution. Here''s the `FontSize` setting of
    `TextBlock` that''s needed to make this idea work, without requiring any C++ code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定提供了一个优雅的解决方案。这是使这个想法工作所需的`TextBlock`的`FontSize`设置，而不需要任何C++代码：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The data binding expression must be specified on the target property, using
    the `{Binding}` markup extension. The `Path` property indicates the source property
    to look for (`Slider::Value` in this case), and `ElementName` is the property
    to use if the source object is an element on the current page (in this case, the
    `Slider` is named `_slider`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定表达式必须在目标属性上使用`{Binding}`标记扩展。`Path`属性指示要查找的源属性（在这种情况下是`Slider::Value`），如果源对象是当前页面上的元素，则`ElementName`是要使用的属性（在这种情况下，`Slider`被命名为`_slider`）。
- en: 'Running this shows the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行结果如下：
- en: '![Element-to-element binding](img/5022_05_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![元素到元素绑定](img/5022_05_01.jpg)'
- en: Dragging the slider changes the text size automatically; this is the power of
    data binding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动滑块会自动更改文本大小；这就是数据绑定的强大之处。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Path` property of `Binding` can be omitted if its value is the first argument.
    This means the previous binding expression is equivalent to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Binding`的`Path`属性的值是第一个参数，则可以省略。这意味着前一个绑定表达式等同于以下内容：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is more convenient and will be used most of the time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这更方便，大多数情况下会使用。
- en: 'The same expression can be achieved with a code, such as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的表达式可以通过代码实现，例如：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code assumes `_tb` is the name of the `TextBlock` in question. This is certainly
    more verbose, and is actually used only in specific scenarios (which we'll examine
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设`_tb`是相关`TextBlock`的名称。这显然更冗长，实际上只在特定情况下使用（我们将在[第6章](ch06.html "第6章。组件、模板和自定义元素")中进行检查，*组件、模板和自定义元素*）。
- en: 'Let''s add another element, a `TextBox`, whose `Text` should reflect the current
    font size of the `TextBlock`. We''ll use data binding as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加另一个元素，一个`TextBox`，其`Text`应该反映`TextBlock`的当前字体大小。我们也将使用数据绑定：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This works. But if we change the actual text of the `TextBox` to a different
    number, the font size does not change. Why?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以工作。但是，如果我们更改`TextBox`的实际文本为不同的数字，字体大小不会改变。为什么？
- en: 'The reason is that the binding is by default one way. To specify a two-way
    binding, we need to change the `Mode` property of the binding:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是绑定默认是单向的。要指定双向绑定，我们需要更改绑定的`Mode`属性：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, changing the `TextBox` and moving the focus to another control (such as
    by pressing *Tab* on the keyboard or touching some other element), changes the
    `FontSize` value of the `TextBlock`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更改`TextBox`并将焦点移动到另一个控件（例如通过键盘上的*Tab*键或触摸其他元素），会更改`TextBlock`的`FontSize`值。
- en: Object-to-element binding
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象到元素绑定
- en: Although an element-to-element binding is sometimes useful, the classic data
    binding scenario involves a source, which is a regular, non-UI object, and a target,
    which is a UI element. The binding expression itself is similar to the element-to-element
    binding case; but naturally the `ElementName` property cannot be used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管元素到元素的绑定有时很有用，但经典的数据绑定场景涉及一个源，即常规的非UI对象，以及一个目标，即UI元素。绑定表达式本身类似于元素到元素绑定的情况；但自然地，不能使用`ElementName`属性。
- en: 'The first step is to create an object that can support data binding. This must
    be a WinRT class that''s decorated with the `Bindable` attribute. The bindings
    themselves are on properties (as always). Here''s a simple `Person` class declaration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个可以支持数据绑定的对象。这必须是一个带有`Bindable`属性的WinRT类。绑定本身是在属性上的（一如既往）。以下是一个简单的`Person`类声明：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code uses auto-implemented properties, which will suffice for
    now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了自动实现的属性，现在足够了。
- en: 'We can create such an object in XAML as a resource, and then use the `Binding::Source`
    property to hook up the binding itself. First, two `Person` objects are created
    as resources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在XAML中创建这样的对象作为资源，然后使用`Binding::Source`属性来连接绑定本身。首先，两个`Person`对象被创建为资源：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we can bind these objects to elements as follows (all inside a `StackPanel`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将这些对象绑定到元素，如下所示（都在`StackPanel`内）：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Source` property refers to the object being bound; a `Person` instance
    in this case. Here''s the resulting UI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Source`属性指的是被绑定的对象；在这种情况下是一个`Person`实例。以下是结果UI：'
- en: '![Object-to-element binding](img/5022_05_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![对象到元素绑定](img/5022_05_02.jpg)'
- en: Note that `Source` is specified in each and every binding expression. Without
    it, the binding would simply fail, as there is no source object to bind to.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Source`在每个绑定表达式中都有指定。如果没有它，绑定将会失败，因为没有源对象可以绑定。
- en: 'Since the source is identical for all three elements, it would be beneficial
    to be able to specify the source just once, and allow all relevant elements to
    bind to it automatically without needing to specify the source explicitly. Fortunately,
    this is possible using the `FrameworkElement::DataContext` property. The rule
    is simple, if a source is not specified explicitly in a binding expression, a
    `DataContext` that is not a `nullptr` is searched in the visual tree, from the
    target element until one is found or the root of the visual tree is reached (typically
    a `Page` or a `UserControl`). If a `DataContext` is found, it becomes the source
    of the binding. Here''s an example that sets the `DataContext` on a parent `StackPanel`
    to be used by its children (whether immediate or not):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有三个元素的源都是相同的，因此可以一次性指定源，并允许所有相关元素自动绑定到它，而无需显式指定源，这将是有益的。幸运的是，使用`FrameworkElement::DataContext`属性是可能的。规则很简单，如果在绑定表达式中没有显式指定源，将在可视树中从目标元素开始搜索`DataContext`，直到找到一个或者到达可视树的根（通常是`Page`或`UserControl`）。如果找到`DataContext`，它将成为绑定的源。以下是一个示例，它将`DataContext`设置为父`StackPanel`上的一个用于其子元素（无论是直接的还是不直接的）的示例：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the result (after some font size tweaks):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果（经过一些字体大小调整）：
- en: '![Object-to-element binding](img/5022_05_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![对象到元素绑定](img/5022_05_03.jpg)'
- en: The binding expressions work correctly, because the implicit source is the `Person`
    object whose key is `p2`. Without the `DataContext`, all these bindings would
    silently fail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定表达式工作正常，因为隐式源是`Person`对象，其键是`p2`。如果没有`DataContext`，所有这些绑定都会悄悄失败。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the data binding expressions are simplified with `DataContext`. They're
    saying something such as, "I don't care what the source is, as long as there's
    a property named `<Fill in property name>` on some `DataContext` that's in scope."
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据绑定表达式如何通过`DataContext`简化。它们表达的意思是，“我不在乎源是什么，只要在范围内有一个名为`<填写属性名称>`的`DataContext`属性。”
- en: The idea of a `DataContext` is a powerful one and, in fact, using the `Source`
    property is rare.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataContext`的概念是强大的，事实上，很少使用`Source`属性。'
- en: Of course, setting a `Source` or `DataContext` in XAML to a predefined resource
    is rare as well. Setting the `DataContext` is usually done via code by getting
    relevant data from a data source, such as a local database or a web service. But
    it works regardless of where or how the `DataContext` is set.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在XAML中将`Source`或`DataContext`设置为预定义资源也是罕见的。通常通过代码获取相关数据源，如本地数据库或Web服务，来设置`DataContext`。但无论`DataContext`在何处或如何设置，它都能正常工作。
- en: Binding failures
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定失败
- en: 'Bindings are loosely typed—properties are specified as strings, and can be
    misspelled. For example, writing `FirstNam` instead of `FirstName` in the previous
    examples does not cause any exception to be thrown; the binding silently fails.
    The only other indication that something went wrong can be found in the **Visual
    Studio Output** window (**View** | **Output** from the menu) if the program is
    run under a debugger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是松散类型的——属性被指定为字符串，并且可能拼写错误。例如，在前面的示例中写`FirstNam`而不是`FirstName`不会引发任何异常；绑定会悄悄失败。如果程序在调试器下运行，则可以在**Visual
    Studio输出**窗口（菜单中的**查看** | **输出**）中找到发生错误的唯一指示。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This text pinpoints the exact problem, specifying the property name to bind,
    the source object type, and the details about the target. This should help to
    fix the spelling mistake.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字准确定位了确切的问题，指定了要绑定的属性名称，源对象类型以及有关目标的详细信息。这应该有助于修复拼写错误。
- en: Why is no exception thrown? The reason is that a data binding may fail at some
    point in time, and that's ok, because the conditions for this binding have not
    been met yet; there may be some information that is retrieved from a database,
    or from a web service, for instance. When the data is finally available, those
    bindings suddenly begin to work correctly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有抛出异常？原因是数据绑定可能在某个时间点失败，这没关系，因为此时尚未满足此绑定的条件；例如，可能有一些信息是从数据库或Web服务中检索的。当数据最终可用时，这些绑定突然开始正常工作。
- en: This means true debugging of data binding expressions is not possible. A nice
    feature would be the ability to place a breakpoint in the XAML binding expression.
    This is currently unsupported, although it is graphically possible to place a
    breakpoint on a binding, it would simply never fire. This feature is available
    in Silverlight 5; hopefully, it will be supported in a future release of WinRT.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无法真正调试数据绑定表达式。一个很好的功能是能够在XAML绑定表达式中设置断点。目前不支持这一功能，尽管在图形上可以在绑定上设置断点，但它根本不会触发。这个功能在Silverlight
    5中可用；希望它会在未来的WinRT版本中得到支持。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One way to debug data bindings is by using value converters, discussed later
    in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 调试数据绑定的一种方法是使用值转换器，稍后在本章中讨论。
- en: Change notifications
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改通知
- en: 'Data binding supports three modes for binding: one way, two way, and one time.
    Up until now the binding occurred when the page first loads and remains unchanged
    after that. What happens if we change a property value on a `Person` object after
    the bindings are in place?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定支持三种绑定模式：单向，双向和一次性。直到现在，绑定发生在页面首次加载时，并在此后保持不变。如果在绑定已经就位后改变`Person`对象上的属性值会发生什么？
- en: 'After adding a simple button, the `Click` event handler does the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加一个简单的按钮后，`Click`事件处理程序执行以下操作：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the `Person` instance was defined as a resource (uncommon, but possible),
    it's extracted from the `Resources` property of the page by using the specified
    key (`p1`). Then the `BirthYear` property is incremented.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Person`实例被定义为资源（不常见，但可能），它通过使用指定的键（`p1`）从页面的`Resources`属性中提取。然后递增`BirthYear`属性。
- en: Running the application shows no visual change. Setting a breakpoint in the
    `Click` handler confirms it's actually called, and the `BirthYear` is changed,
    but the binding seems to have no effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时没有视觉变化。在`Click`处理程序中设置断点确认它实际上被调用了，并且`BirthYear`已更改，但绑定似乎没有效果。
- en: 'The reason for this is the way the `BirthYear` property is currently implemented:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`BirthYear`属性当前的实现方式：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a trivial implementation that uses a private field behind the scenes.
    The problem is that when the property changes, nobody knows about it; specifically,
    the binding system has no idea anything has happened.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用私有字段在后台实现的琐碎实现。问题在于当属性改变时，没有人知道；具体来说，绑定系统不知道发生了什么。
- en: 'To change that, a data object should implement the `Windows::UI::Xaml::Data::INotifyPropertyChanged`
    interface. This interface is queried by the binding system and, if found, registers
    for the `PropertyChanged` event (the only member of that interface). Here''s a
    revised declaration of the `Person` class, focusing on the `BirthYear` property:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这一点，数据对象应该实现`Windows::UI::Xaml::Data::INotifyPropertyChanged`接口。绑定系统会查询此接口，如果找到，就会注册`PropertyChanged`事件（该接口的唯一成员）。以下是`Person`类的修订声明，重点是`BirthYear`属性：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The getter is implemented inline, and the setter is implemented in the CPP
    file, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: getter是内联实现的，setter在CPP文件中实现如下：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `PropertyChanged` event is raised, accepting a `PropertyChangedEventArgs`
    object that accepts the changed property name. Now, running the application and
    clicking on the button shows an incremented birth year, as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyChanged` 事件被触发，接受一个 `PropertyChangedEventArgs` 对象，该对象接受了更改的属性名称。现在，运行应用程序并点击按钮会显示一个增加的出生年份，如预期的那样。'
- en: 'This effectively means that every property should be implemented in a similar
    fashion; declaring a private field and raising the `PropertyChanged` event in
    the setter. Here''s a revised `FirstName` property implementation (this time implemented
    inline):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着每个属性都应该以类似的方式实现；在 setter 中声明一个私有字段并在其中引发 `PropertyChanged` 事件。这是 `FirstName`
    属性的修订实现（这次是内联实现）：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`_firstName` is a private `String^` field defined within the class as well.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`_firstName` 是类内部定义的私有 `String^` 字段。'
- en: Binding to collections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到集合
- en: The previous examples used a property that binds to a single object. As we've
    seen in the previous chapter, a bunch of controls deriving from `ItemsControl`
    can present information for more than one data item. It stands to reason that
    these controls should bind to a collection of data items, such as a collection
    of the `Person` objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了绑定到单个对象的属性。正如我们在前一章中看到的，从 `ItemsControl` 派生的一堆控件可以呈现多个数据项的信息。这些控件应该绑定到数据项的集合，比如
    `Person` 对象的集合。
- en: 'The property to be used for binding purposes is `ItemsSource`. This should
    be set to a collection, typically `IVector<T>`. Here''s an example of some `Person`
    objects bound to a `ListView` (a constructor was added to person for convenient
    initialization):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用于绑定目的的属性是 `ItemsSource`。这应该设置为一个集合，通常是 `IVector<T>`。这是一些 `Person` 对象绑定到 `ListView`
    的例子（为方便初始化，`Person` 添加了一个构造函数）：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To set up the binding, we can use an explicit assignment to the `ListView::ItemsSource`
    property:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置绑定，我们可以使用显式赋值给 `ListView::ItemsSource` 属性：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An (elegant and preferred) alternative is to bind `ItemsSource` to something
    related to the `DataContext`. For example, the `ListView` markup can start with
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个（优雅且首选的）替代方法是将 `ItemsSource` 绑定到与 `DataContext` 相关的内容。例如，`ListView` 的标记可以从这里开始：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that `ItemsSource` is bound to whatever the `DataContext` is (should
    be a collection in this case). The lack of a property path means the object itself.
    With this markup, the binding is done with the following simple code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `ItemsSource` 绑定到 `DataContext` 是什么（在这种情况下应该是一个集合）。缺少属性路径意味着对象本身。使用这个标记，绑定是通过以下简单的代码完成的：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To view the actual `Person` objects, `ItemsControl` provides the `ItemTemplate`
    property, which is a `DataTemplate` object that defines how `Person` objects are
    displayed. By default (without a `DataTemplate`), the type name is shown or another
    string representation of the object (if it has one) is used. This is rarely useful.
    A simple alternative is using the `DisplayMemberPath` property to show a specific
    property on the data object (such as `FirstName` for `Person` objects). A much
    more powerful way would be to use a `DataTemplate`, providing a customizable user
    interface for each item connected to the actual object via data binding. Here''s
    an example for our `ListView` of people:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际的 `Person` 对象，`ItemsControl` 提供了 `ItemTemplate` 属性，它是一个 `DataTemplate`
    对象，定义了如何显示 `Person` 对象。默认情况下（没有 `DataTemplate`），会显示类型名称或对象的另一个字符串表示（如果有的话）。这很少有用。一个简单的替代方法是使用
    `DisplayMemberPath` 属性来显示数据对象上的特定属性（例如 `Person` 对象的 `FirstName`）。一个更强大的方法是使用 `DataTemplate`，为每个通过数据绑定连接到实际对象的可自定义用户界面提供。这是我们
    `ListView` 的一个例子：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The binding expressions inside the `DataTemplate` reach out to the relevant
    properties on the data object itself. Here''s the resulting `ListView`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplate` 中的绑定表达式可以访问数据对象本身的相关属性。这是生成的 `ListView`：'
- en: '![Binding to collections](img/5022_05_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![绑定到集合](img/5022_05_04.jpg)'
- en: Customizing a data view
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据视图
- en: Data templates provide a powerful way to visualize and interact with data, partly
    because of the power of data binding. Sometimes, however, more customization is
    needed. For example, in a list of the `Book` objects, every book that's currently
    on sale should be displayed with a different color, or have some special animation,
    and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模板提供了一种强大的方式来可视化和与数据交互，部分是因为数据绑定的强大功能。然而，有时需要更多的自定义。例如，在 `Book` 对象的列表中，当前打折的每本书都应该以不同的颜色显示，或者有一些特殊的动画等等。
- en: The following sections describe some ways of customizing data templates.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了一些自定义数据模板的方法。
- en: Value converters
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值转换器
- en: Value converters are types that implement the `Windows::UI::Xaml::Data::IValueConverter`
    interface. This interface provides a way to convert one value to another value,
    which can be of different types. Suppose we want to show a collection of books,
    but those that are on sale should have a slightly different look. With plain data
    templates, this is difficult, unless there are specific `Book` properties that
    have visual impact (such as a color or brush); this is unlikely, as data objects
    should be concerned about the data and not about how to display the data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器是实现 `Windows::UI::Xaml::Data::IValueConverter` 接口的类型。该接口提供了一种将一个值转换为另一个值的方式，这两个值可以是不同类型的。假设我们想要显示一组书籍，但是打折的书应该有略微不同的外观。使用普通的数据模板，这很困难，除非有特定的
    `Book` 属性对可视化有影响（比如颜色或画笔）；这是不太可能的，因为数据对象应该关心数据，而不是如何显示数据。
- en: 'Here''s the definition of the `Book` class (change notifications are not implemented
    to simplify the example):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Book` 类的定义（为简化示例，未实现更改通知）：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Value converters provide an elegant solution that keeps the object (`Book`
    in this example) decoupled from the way it''s presented. Here''s a basic `Book`
    data template:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器提供了一个优雅的解决方案，使对象（在这个例子中是 `Book`）与其呈现方式解耦。这是一个基本的 `Book` 数据模板：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how the books are shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是书籍的显示方式：
- en: '![Value converters](img/5022_05_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![值转换器](img/5022_05_05.jpg)'
- en: Suppose we would like to use a green background for books that are on sale.
    What we don't want to do is add a `Background` property to the `Book` class. Instead,
    a value converter will be used to convert the `IsOnSale` property (a Boolean)
    to a `Brush` object, suitable for a property related to the `Background` property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为打折的书籍使用绿色背景。我们不想在`Book`类中添加`Background`属性。相反，将使用值转换器将`IsOnSale`属性（布尔值）转换为适用于`Background`属性的`Brush`对象。
- en: 'First, the declaration of our value converter is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的值转换器的声明如下：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two methods to implement:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来实现：
- en: '`Convert`: Used when binding from source to target (the usual way)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Convert`：从源到目标绑定时使用（通常的方式）'
- en: '`ConvertBack`: Relevant for two-way bindings only'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConvertBack`：仅适用于双向绑定'
- en: 'In our case, the binding we use is the one-way binding only, so `ConvertBack`
    can simply return `nullptr` or throw an exception. Here''s the implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用的是单向绑定，所以`ConvertBack`可以简单地返回`nullptr`或抛出异常。这是实现：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Two brushes are created in the constructor; one for regular books (transparent)
    and the other for books on sale (green). The `Convert` method is called with the
    `value` parameter being the `IsOnSale` property of the book in question. How this
    happens will become clear soon enough. The method simply looks at the Boolean
    value and returns the appropriate brush. This conversion is from a Boolean value
    to a `Brush`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中创建了两个画笔；一个用于普通书籍（透明），另一个用于打折书籍（绿色）。调用`Convert`方法时，`value`参数是所讨论书籍的`IsOnSale`属性。这将很快变得清楚。该方法只是查看布尔值并返回适当的画笔。这种转换是从布尔值到`Brush`。
- en: 'The next step would be to actually create an instance of the converter. This
    is typically done in XAML, making the converter a resource:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是实际创建转换器的实例。这通常是在XAML中完成的，将转换器作为资源：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, for the final connection, use an appropriate property to bind to `IsOnSale`
    and supply a converter for the operation. In our case, `Border` (part of the `DataTemplate`)
    will do very nicely:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了最终连接，使用适当的属性绑定到`IsOnSale`并为操作提供一个转换器。在我们的情况下，`Border`（`DataTemplate`的一部分）非常合适：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without the converter, the binding would simply fail, as there's no way a Boolean
    can be converted to a `Brush` automatically. The converter has been passed the
    value of `IsOnSale` and should return something appropriate to the target property
    for the conversion to succeed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有转换器，绑定将会失败，因为没有办法自动将布尔值转换为`Brush`。转换器已经传递了`IsOnSale`的值，并且应该返回适合目标属性的内容以使转换成功。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to use a `Binding` expression without `Path` (without `IsOnSale`
    in this example). The result is that the entire object (`Book`) is passed as the
    value argument for the converter. This can help in making decisions that are based
    on more than one property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不带`Path`（在此示例中不带`IsOnSale`）的`Binding`表达式。结果是整个对象（`Book`）作为转换器的值参数传递。这有助于基于多个属性做出决策。
- en: 'Here''s the result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Value converters](img/5022_05_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![值转换器](img/5022_05_06.jpg)'
- en: 'Let''s add a small image next to a book that is on sale. How would we do that?
    We can certainly add an image, but it must be shown only when the book is on sale.
    We can use a (somewhat classic) converter, changing from Boolean to the `Visibility`
    enumeration and vice versa:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在打折的书旁边添加一个小图片。我们可以添加一张图片，但只有当书打折时才显示。我们可以使用（有点经典的）转换器，从布尔值转换为`Visibility`枚举，反之亦然：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this in place, we can create an instance as a resource in the usual way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以像通常一样在资源中创建一个实例：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we can add an image to the third column, visible only when needed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在需要时向第三列添加一张图片：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Value converters](img/5022_05_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![值转换器](img/5022_05_07.jpg)'
- en: Value converters are extremely powerful, because they can leverage code to achieve
    visual changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器非常强大，因为它们可以利用代码实现视觉变化。
- en: Other parameters for Convert and ConvertBack
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Convert和ConvertBack的其他参数
- en: '`Convert` and `ConvertBack` accept more parameters, not just the value. Here''s
    the complete list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`和`ConvertBack`接受更多参数，不仅仅是值。以下是完整列表：'
- en: '`value`: The `value` argument (first) is the most important one for the `Convert`/`ConvertBack`
    method. There are three other arguments as well.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：`value`参数（第一个）对于`Convert`/`ConvertBack`方法非常重要。还有其他三个参数。'
- en: '`targetType`: This indicates what''s the expected object type that should be
    returned. This can be used for checking if the converter is used correctly (in
    our example, `OnSaleToBrushConverter` would have a `Brush` type as `targetType`
    for the `Convert` method). The other possible use of this argument is in the case
    of a more complex value converter that may deal with multiple return types and
    may need to know about the current request.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetType`：这表示应返回的预期对象类型。这可用于检查转换器是否正确使用（在我们的示例中，`OnSaleToBrushConverter`的`Convert`方法的`targetType`将是`Brush`类型）。此参数的另一个可能用途是在更复杂的值转换器的情况下，可能需要处理多个返回类型并且可能需要了解当前请求。'
- en: '`parameter`: This is a free parameter that can be passed via the `Binding`
    expression with the `ConverterParameter` property. This can be useful for customizing
    a value converter on a binding expression basis.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter`：这是一个自由参数，可以通过`Binding`表达式的`ConverterParameter`属性传递。这对于根据绑定表达式自定义值转换器很有用。'
- en: '`culture`: This receives whatever the `ConverterLanguage` property of the `Binding`
    expression has. This can be used to return different values based on a language,
    which is really just another string that can be passed along to the converter.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`culture`：这接收`Binding`表达式的`ConverterLanguage`属性的内容。这可用于根据语言返回不同的值，这实际上只是可以传递给转换器的另一个字符串。'
- en: Data template selectors
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模板选择器
- en: In more extreme cases, the changes needed from `DataTemplate` may be too dramatic
    for value converters to be useful. If very different templates are needed by different
    objects (in the same collection), data template selectors may be a better alternative.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在更极端的情况下，从`DataTemplate`所需的更改可能对值转换器没有用。如果不同的对象（在同一集合中）需要非常不同的模板，数据模板选择器可能是一个更好的选择。
- en: 'A data template selector is a class that derives from `Windows::UI::Xaml::Controls::DataTemplateSelector`
    (not a control, despite the namespace) and overrides the `SelectTemplateCore`
    method defined as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模板选择器是一个从`Windows::UI::Xaml::Controls::DataTemplateSelector`派生的类（尽管命名空间不同，但它不是一个控件），并重写了以下定义的`SelectTemplateCore`方法：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The method needs to return a `DataTemplate` that corresponds to the `item` argument.
    In the preceding examples, each item is `Book`; the code would look at some `Book`
    properties and conclude which `DataTemplate` should be used. This could also be
    based in some way on the `container` argument, which is the actual control hosting
    these objects (`ListView` in our example).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法需要返回与`item`参数对应的`DataTemplate`。在前面的示例中，每个项目都是`Book`；代码将查看一些`Book`属性，并得出应该使用哪个`DataTemplate`。这也可以基于`container`参数，在这种情况下，它是实际托管这些对象的控件（在我们的示例中是`ListView`）。
- en: Next, an instance of this class is created in XAML (similar to a value converter),
    and the instance is set to the `ItemsControl::ItemTemplateSelector` property.
    If this is set, the `ItemTemplate` cannot be set at the same time, as it would
    conflict with the logic the template selector uses.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在XAML中创建此类的一个实例（类似于值转换器），并将该实例设置为`ItemsControl::ItemTemplateSelector`属性。如果设置了这个属性，`ItemTemplate`不能同时设置，因为它会与模板选择器使用的逻辑冲突。
- en: Commands
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: 'The traditional way of connecting a piece of user interface to some logic is
    through events. The canonical example is a button—when clicked, some action is
    undertaken, hopefully accomplishing some goal the user has intended. Although
    WinRT supports this model completely (as other UI frameworks do), it has its drawbacks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户界面的一部分连接到某些逻辑的传统方法是通过事件。典型的例子是按钮——当点击时，会执行一些操作，希望实现用户打算的某个目标。尽管WinRT完全支持这种模型（就像其他UI框架一样），但它也有缺点：
- en: The event handler is part of the "code behind" where the UI is declared, typically
    a `Page` or a `UserControl`. This makes it difficult to call from other objects
    that may want to invoke the same piece of logic.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序是“代码后台”的一部分，其中声明了UI，通常是`Page`或`UserControl`。这使得从可能希望调用相同逻辑的其他对象中调用它变得困难。
- en: The aforementioned button may disappear and be replaced by a different control.
    This would require the event hooking code to potentially change. What if we wanted
    more than one control to invoke the same functionality?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面提到的按钮可能会消失并被不同的控件替换。这将需要潜在地更改事件挂钩代码。如果我们希望多个控件调用相同的功能怎么办？
- en: An action may not be allowed at some state—the button (or whatever) needs to
    be disabled or enabled at the right time. This adds management overhead to the
    developer—the need to track the state and change it for all UI elements that invoke
    the same functionality.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些状态下可能不允许执行操作——按钮（或其他任何东西）需要在正确的时间被禁用或启用。这给开发人员增加了管理开销——需要跟踪状态并为调用相同功能的所有UI元素更改它。
- en: An event handler is just a method—there's no easy way to pick it up and save
    it somewhere, such as for undo/redo purposes.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序只是一个方法——没有简单的方法来捕获它并将其保存在某个地方，例如用于撤销/重做的目的。
- en: It's difficult to test application logic without using an actual user interface,
    because logic and UI are intertwined.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有使用实际用户界面的情况下测试应用程序逻辑是困难的，因为逻辑和UI是交织在一起的。
- en: These and other more subtle issues make working with event handlers less than
    ideal, especially when application logic is involved. If some event is just intended
    for usability enhancement or for otherwise serving the UI alone, this is not usually
    a concern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他更微妙的问题使得处理事件处理程序不太理想，特别是涉及应用程序逻辑时。如果某些事件只是为了增强可用性或仅为了服务UI，通常不会引起关注。
- en: The typical solution to this UI logic coupling is the concept of commands. This
    follows the famous "command design pattern" that abstracts away the application
    logic into distinct objects. Being an object, a command can be invoked from multiple
    locations, saved in lists (for example, for undo purposes), and so on. It can
    even indicate whether it's allowed in certain times or not, freeing other entities
    from taking care of the actual enabling or disabling of controls that may be bound
    to that command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此UI逻辑耦合的典型方法是命令的概念。这遵循了著名的“命令设计模式”，将应用程序逻辑抽象为不同的对象。作为一个对象，命令可以从多个位置调用，保存在列表中（例如，用于撤销目的），等等。它甚至可以指示在某些时间是否允许，从而使其他实体免于处理可能绑定到该命令的控件的实际启用或禁用。
- en: 'WinRT defines a basic command support with the `Windows::UI::Xaml::Input::ICommand`
    interface. `ICommand` has two methods and an event:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT使用`Windows::UI::Xaml::Input::ICommand`接口定义了基本的命令支持。`ICommand`有两个方法和一个事件：
- en: '**The** `Execute` **method**: This executes the command in question. It accepts
    a parameter that can be anything that can be used as an argument to the command.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Execute`方法**：执行所讨论的命令。它接受一个参数，可以是任何可以用作命令参数的东西。'
- en: '**The** `CanExecute` **method**: This method indicates whether this command
    is available at this time or not. WinRT uses this as a hint for enabling or disabling
    the command source.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`CanExecute`方法**：此方法指示此命令在此时是否可用。WinRT将此作为启用或禁用命令源的提示。'
- en: '**The** `CanExecuteChanged` **event**: This is raised by the command to let
    WinRT know that it should call `CanExecute` again, because the availability of
    the command may have changed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`CanExecuteChanged`事件**：这由命令引发，让WinRT知道它应该再次调用`CanExecute`，因为命令的可用性可能已经改变。'
- en: Various controls have a `Command` property (of the type `ICommand`) that can
    be set up (typically using data binding) to point to an object implemented by
    `ICommand` (and a `CommandParameter` that allows passing some information to the
    command). The canonical example being the classic `Button`. When the button is
    clicked, the hooked command's `Execute` method is called. This means no `Click`
    handler is needed to set this up.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 各种控件都有一个`Command`属性（类型为`ICommand`），可以设置（通常使用数据绑定）指向由`ICommand`实现的对象的对象（和一个`CommandParameter`，允许将一些信息传递给命令）。经典的例子是经典的`Button`。当按钮被点击时，将调用挂接命令的`Execute`方法。这意味着不需要设置`Click`处理程序。
- en: 'WinRT does not provide any implementation for `ICommand`. It''s up to the developer
    to create appropriate implementations. Here''s a simple implementation of a command
    that''s used for incrementing the birth year of a person:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT没有为`ICommand`提供任何实现。开发人员需要创建适当的实现。下面是一个简单的用于增加一个人出生年份的命令的实现：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the implementation is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this work we can create a command source, such as a button and fill
    in the command details as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们可以创建一个命令源，比如一个按钮，并填写命令的细节如下：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a command within a `Command` property is unusual, the typical way of
    being bound to an appropriate property on a ViewModel, as we'll see in the next
    section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Command`属性中创建一个命令是不寻常的，通常的方式是绑定到ViewModel上的适当属性，我们将在下一节中看到。
- en: Introduction to MVVM
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM简介
- en: 'Commands are just one aspect of more general patterns for dealing with user
    interface in non-trivial applications. To that end, a number of UI design patterns
    are available, such as **Model View Controller** (**MVC**), **Model View Presenter**
    (**MVP**), and **Model-View-ViewModel** (**MVVM**). All have something in common:
    the separation of the actual UI (view) from the application logic (controller,
    presenter, and view model) and the underlying data (model).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 命令只是处理非平凡应用程序中用户界面更一般模式的一个方面。为此，有许多UI设计模式可用，如**模型视图控制器**（**MVC**）、**模型视图呈现器**（**MVP**）和**模型-视图-视图模型**（**MVVM**）。所有这些都有共同之处：将实际UI（视图）与应用程序逻辑（控制器、呈现器和视图模型）以及底层数据（模型）分离。
- en: The MVVM pattern popularized by WPF and Silverlight leverages the power of data
    binding and commands to create decoupling between the UI (View) and the data (Model)
    by using an intermediary (View Model).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: WPF和Silverlight推广的MVVM模式利用数据绑定和命令的力量，通过使用中介（视图模型）在UI（视图）和数据（模型）之间创建解耦。
- en: MVVM constituents
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM组成部分
- en: MVVM has three participants. The model represents the data or business logic.
    This may consist of types that may be written in standard C++, without any regard
    to WinRT. It's typically neutral; that is, it knows nothing of how it's going
    to be used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM有三个参与者。模型代表数据或业务逻辑。这可能包括可以用标准C++编写的类型，而不考虑WinRT。它通常是中立的；也就是说，它不知道它将如何被使用。
- en: The view is the actual UI. It should display relevant parts of the model and
    provide the required interactive functionality. The view should not have a direct
    knowledge of the model, and this is where data binding comes in. All bindings
    access a property without explicitly knowing what type of object sits at the other
    end. This magic is satisfied at runtime by setting the view's `DataContext` to
    the object providing the data; this is the ViewModel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是实际的UI。它应该显示模型的相关部分并提供所需的交互功能。视图不应直接了解模型，这就是数据绑定的作用。所有绑定都访问一个属性，而不明确知道另一端是什么类型的对象。这种魔术在运行时通过将视图的`DataContext`设置为提供数据的对象来满足；这就是ViewModel。
- en: 'The ViewModel is the glue that hands out the required data to the view (based
    on the model). The ViewModel is just that—a model for the view. It has several
    responsibilities:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel是将所需数据分发给视图（基于模型）的粘合剂。ViewModel就是这样——视图的模型。它有几个责任：
- en: Expose properties that allow binding in the view. This may be just by accessing
    properties on the model (if it's written with WinRT), but may be more involved
    if the model exposes data in another way (such as with methods) or types that
    need translation, such as `std::vector<T>` that needs to be returned as `IVector<T>`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中公开允许绑定的属性。这可能只是通过访问模型上的属性（如果它是用WinRT编写的），但如果模型以另一种方式公开数据（比如使用方法）或需要翻译的类型，比如需要返回为`IVector<T>`的`std::vector<T>`，可能会更复杂。
- en: Expose commands (`ICommand`) to be invoked by elements in the view.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开命令（`ICommand`）以供视图中的元素调用。
- en: Maintain a relevant state for the view.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护视图的相关状态。
- en: 'The entire relationship between model, view, and view model can be summarized
    with the following diagram:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和视图模型之间的整个关系可以用以下图表来总结：
- en: '![MVVM constituents](img/5022_05_08.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM组成部分](img/5022_05_08.jpg)'
- en: Building an MVVM framework
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建MVVM框架
- en: It should be clear at this point that MVVM-based applications have a lot of
    elements in common, such as change notifications and commands. It would be beneficiary
    to create a reusable framework that we can simply leverage in many applications.
    Although there are several good frameworks out there (most are free), they are
    based around .NET, meaning they cannot be used in a C++ app because they are not
    exposed as a WinRT component, and even if they did, a C++ app must pay the price
    of the .NET CLR. Building such a framework ourselves is not too difficult and
    will enhance our understanding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上应该很清楚，基于MVVM的应用程序有很多共同的元素，比如变更通知和命令。创建一个可在许多应用程序中简单利用的可重用框架将是有益的。虽然有几个很好的框架（大多是免费的），它们都是基于.NET的，这意味着它们不能在C++应用程序中使用，因为它们没有作为WinRT组件公开，即使它们这样做了，C++应用程序也必须付出.NET
    CLR的代价。自己构建这样的框架并不太困难，而且会增强我们的理解。
- en: 'The first thing we''ll tackle is the desired ability of objects to implement
    the `INotifyPropertyChanged` interface so that they can raise the `PropertyChanged`
    event when any property is changed. We can achieve this with the following WinRT
    class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的第一件事是希望对象能够实现`INotifyPropertyChanged`接口，以便它们在任何属性更改时都能引发`PropertyChanged`事件。我们可以用以下WinRT类来实现这一点：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the implementation is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The inheritance from `DependencyObject` may seem redundant, but it's actually
    necessary to circumvent one deficiency in current WinRT support—any regular class
    has to be sealed, making it useless as a base class. Any class inheriting from
    `DependencyObject` can remain unsealed—exactly what we want.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从`DependencyObject`继承可能看起来是多余的，但实际上这是必要的，以规避当前WinRT支持中的一个不足之处——任何常规类都必须是密封的，使其作为基类毫无用处。任何从`DependencyObject`继承的类都可以保持未密封状态——这正是我们想要的。
- en: The `ObservableObject` class seems very simple and perhaps not worth as a separate
    class. But we can add to it common functionalities that any derived classes can
    benefit from. For example, we can support the `ICustomPropertyProvider` interface—this
    interface allows the object to support dynamic properties that are not statically
    part of the type (the interested reader can find more information in the MSDN
    documentation).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableObject`类似乎非常简单，也许不值得作为一个单独的类。但我们可以为其添加任何派生类都可以受益的常见功能。例如，我们可以支持`ICustomPropertyProvider`接口——该接口允许对象支持动态属性，这些属性在类型中并非静态部分（感兴趣的读者可以在MSDN文档中找到更多信息）。'
- en: 'Concrete types may use `ObservableObject` with code similar to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型可以使用类似以下代码的`ObservableObject`：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next thing to take care of is commands. As we''ve seen, we can create a
    command by implementing `ICommand`, and this is sometimes necessary. An alternative
    would be to create a more generic class that uses delegates to call whatever code
    we want in response to the `Execute` and `CanExecute` methods of a command. Here''s
    an example of such a command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要处理的是命令。正如我们所见，我们可以通过实现`ICommand`来创建一个命令，有时这是必要的。另一种方法是创建一个更通用的类，该类使用委托来调用我们想要响应`Execute`和`CanExecute`方法的任何代码。以下是这样一个命令的示例：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The class takes advantage of delegates, accepting two in the constructor; the
    first for executing a command, and the second to indicate whether the command
    is enabled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该类利用委托，构造函数中接受两个委托；第一个用于执行命令，第二个用于指示命令是否启用。
- en: 'Here''s a ViewModel that exposes a command to make a book loaned:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个公开命令以使书籍被借出的ViewModel：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The command is created in the constructor of a ViewModel:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是在ViewModel的构造函数中创建的：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ViewModel is control (view) free, meaning we can construct it without any
    visible user interface. It exposes properties for data binding to a relevant view
    and commands to execute actions from the view. The actual action would typically
    modify some state in the appropriate model.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel是无控制（视图）的，这意味着我们可以在没有任何可见用户界面的情况下构建它。它公开了用于数据绑定到相关视图的属性和用于执行来自视图的操作的命令。实际操作通常会修改适当模型中的某些状态。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is typically a one-to-one mapping between a view and a ViewModel. Although
    sometimes it's possible to share, this is not recommended.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和ViewModel之间通常是一对一的映射。虽然有时可以共享，但不建议这样做。
- en: More on MVVM
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关MVVM的更多信息
- en: This was a quick tour of MVVM. Since this is a well-known pattern (thanks to
    its use in WPF and Silverlight), there's a lot of material on the web. Some things
    that can be added include a navigation-aware ViewModel (so that a `Frame` control
    is not accessed directly), a ViewModel locator service that allows easier binding
    between a view, and its corresponding ViewModel, and more.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MVVM的快速介绍。由于这是一种众所周知的模式（多亏了它在WPF和Silverlight中的使用），因此网络上有很多相关资料。可以添加的一些内容包括支持导航的ViewModel（以便不直接访问`Frame`控件）、ViewModel定位器服务（允许更轻松地在视图和其对应的ViewModel之间进行绑定）等。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A good start for more information on MVVM is available on Wikipedia at [http://en.wikipedia.org/wiki/Model_View_ViewModel](http://en.wikipedia.org/wiki/Model_View_ViewModel).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MVVM的更多信息，请参阅维基百科[http://en.wikipedia.org/wiki/Model_View_ViewModel](http://en.wikipedia.org/wiki/Model_View_ViewModel)。
- en: An implementation of a WinRT MVVM framework in C++ is somewhat awkward, as it's
    not (currently) possible to expose such a framework as a Windows Runtime Component,
    but only as a C++ static or dynamic library.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中实现WinRT MVVM框架有些麻烦，因为（目前）不可能将这样的框架公开为Windows运行时组件，而只能作为C++静态或动态库。
- en: Regardless, the separation between data and view is an important one and will
    benefit all but the simplest of applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，数据和视图之间的分离是重要的，除了最简单的应用程序外，所有应用程序都将受益。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw what data binding is and how to use it. Data binding
    is an extremely powerful concept and its implementation in WinRT is pretty strong.
    Developers coming from a Win32 or MFC background should realize that a different
    approach is required for connecting display to data. Data binding provides a declarative
    model that supports separation between data and display, so the application logic
    only works with the data and will not really care which controls (if any) bind
    to that data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了数据绑定是什么以及如何使用它。数据绑定是一个非常强大的概念，在WinRT中的实现非常强大。来自Win32或MFC背景的开发人员应该意识到，连接显示和数据需要采用不同的方法。数据绑定提供了一种声明性模型，支持数据和显示之间的分离，因此应用程序逻辑只处理数据，实际上并不关心哪些控件（如果有）绑定到该数据。
- en: MVVM concepts make this separation clearer and establish a foundation for incrementally
    enhancing an application without increasing maintenance headaches and logical
    complexity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM概念使这种分离更加清晰，并为逐步增强应用程序奠定了基础，而不会增加维护头疼和逻辑复杂性。
- en: In the next chapter, we'll take a look at building reusable WinRT components,
    as well as custom elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何构建可重用的WinRT组件，以及自定义元素。
