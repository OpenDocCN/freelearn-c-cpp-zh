- en: Advanced Gameplay Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级游戏系统
- en: Games are more than just simple mechanics and underlying engines. They are made
    up of complex gameplay systems that allow us to interact with the game world,
    making us feel included and immersed. These systems often take large amounts of
    time and developer expertise to implement. In this chapter, we will look at a
    couple of these advanced gameplay systems and how we can give ourselves a layer
    of help when implementing them in our own projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏不仅仅是简单的机制和基础引擎。它们由复杂的游戏系统组成，使我们能够与游戏世界互动，让我们感到被包容和沉浸其中。这些系统通常需要大量的时间和开发者专业知识来实现。在本章中，我们将看一下一些高级游戏系统以及在我们自己的项目中实现它们时如何给自己一层帮助。
- en: 'This chapter includes the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Implementing a scripting language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现脚本语言
- en: Building a dialog system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建对话系统
- en: Scripting quests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本任务
- en: Implementing a scripting language
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现脚本语言
- en: As mentioned previously, implementing an advanced gameplay system can often
    take many coding hours and could require the developer to have expertise in that
    specific system. We can, however, make this a little easier on ourselves and others
    working on the project by including support for a scripting language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，实现一个高级游戏系统通常需要许多编码小时，并且可能需要开发人员对该特定系统具有专业知识。然而，我们可以通过包含对脚本语言的支持来使这一切变得更容易，对我们自己和其他人在项目上的工作也更容易。
- en: Why a scripting language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用脚本语言
- en: You may be wondering why we are spending time talking about scripting languages
    when this is a book about C++ after all. Why incorporate a scripting language?
    Couldn't we just build the whole engine and game in C++? Yes, we could! However,
    once you start to work on larger and larger projects, you will quickly notice
    the amount of time lost to compiling and re-compiling every time you need to make
    a change. While there are some ways to get around this, like breaking the game
    and engine into smaller modules and loading them dynamically, or using a JSON
    or XML descriptive file system, techniques like these cannot provide all the benefits
    of implementing a scripting system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道，既然这是一本关于C++的书，为什么我们要花时间谈论脚本语言呢？为什么要加入脚本语言？我们难道不能只用C++来构建整个引擎和游戏吗？是的，我们可以！然而，一旦你开始着手更大的项目，你会很快注意到每次需要进行更改时所花费的编译和重新编译的时间。虽然有一些方法可以解决这个问题，比如将游戏和引擎分成较小的模块并动态加载它们，或者使用JSON或XML描述性文件系统，但是这些技术不能提供实现脚本系统的所有好处。
- en: So, what are the benefits of adding a scripting language to your game engine?
    Well, first, most scripting languages you will use are interpreted languages,
    meaning unlike C++, you do not have to compile the code. Instead, your code is
    loaded and executed at runtime. The big advantage to this is you can make changes
    to a script file and quickly see the results without having to recompile the entire
    game. In fact, you could reload the script on the fly while the game is running
    and see the changes immediately. Another possible benefit of using a scripting
    language is the perceived ease of use when compared to a language like C++. Most
    scripting languages are dynamically typed, with a simplified syntax and structure.
    This can open up opportunities for the creative side of the team, such as artists
    and designers, to be able to make small changes to the project without the need
    to understand the complexity of a language like C++. Imagine a GUI designer being
    able to create, place, and modify GUI elements without the need to know how the
    IGUI framework is implemented. Adding scripting support also opens up a path to
    the community content support—think maps, levels, and items all designed by the
    players of the game. This is becoming a huge selling point for new games and provides
    some possible longevity to your title. On the topic of longevity, the implementation
    of DLC can be done through scripts. This allows for quicker development turnaround
    and can be dropped into the game without the need for a hefty patch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将脚本语言添加到游戏引擎中有什么好处呢？首先，你将使用的大多数脚本语言都是解释性语言，这意味着与C++不同，你不需要编译代码。相反，你的代码在运行时加载和执行。这样做的一个巨大优势是你可以对脚本文件进行更改并快速看到结果，而无需重新编译整个游戏。事实上，你可以在游戏运行时重新加载脚本并立即看到更改。使用脚本语言的另一个可能好处是相对于C++这样的语言，它被认为更易于使用。大多数脚本语言都是动态类型的，具有简化的语法和结构。这可以为团队的创造性一面，比如艺术家和设计师，提供机会，他们可以在不需要理解C++这样的语言复杂性的情况下对项目进行小的更改。想象一下GUI设计师能够创建、放置和修改GUI元素，而无需知道IGUI框架是如何实现的。添加脚本支持还为社区内容支持打开了一条道路——想象一下地图、关卡和物品都是由游戏玩家设计的。这对于新游戏来说已经成为一个巨大的卖点，并为你的游戏提供了一些可能的长期性。在谈到长期性时，DLC的实施可以通过脚本完成。这可以实现更快的开发周转，并且可以在不需要庞大补丁的情况下投入游戏中。
- en: Those are some of the benefits of using a scripting language, but they are not
    always the best solution in every situation. Scripting languages are notorious
    for running slower than native code, and as we know, performance matters when
    building games. So, when should you use a script instead of using C++? We will
    take a closer look at some system examples, but as a simple rule to follow, you
    should always use C++ for anything that can be considered CPU intensive. Program
    flow and other high-level logic are great candidates for a script. Let's take
    a look at where scripts can be used in our game engine components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用脚本语言的一些好处，但并不总是在每种情况下都是最佳解决方案。脚本语言以运行速度较慢而臭名昭著，正如我们所知，性能在构建游戏时很重要。那么，什么时候应该使用脚本而不是使用C++呢？我们将更仔细地看一些系统示例，但作为一个简单的遵循规则，你应该总是使用C++来处理任何可以被认为是CPU密集型的东西。程序流程和其他高级逻辑是脚本的绝佳候选对象。让我们看看脚本可以在我们的游戏引擎组件中使用的地方。
- en: Let's start with the physics components. Of course, when we think of physics,
    we immediately think of heavy CPU usage. For the most part, this is true. The
    heart of the physics system should be constructed in C++, but there are opportunities
    to introduce scripting into this system as well. Take, for instance, the concept
    of physics materials. We can define the materials' properties in a script—things
    like mass, friction, viscosity, and so on. We can even modify these values from
    inside the script itself. Another potential use of scripts in the physics system
    would be defining the response to collisions. We could handle the generation of
    sounds, special effects, and other events, all from within the script.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从物理组件开始。当然，当我们想到物理时，我们立刻想到大量的CPU使用。在大多数情况下，这是正确的。物理系统的核心应该是用C++构建的，但也有机会在这个系统中引入脚本。例如，物理材料的概念。我们可以在脚本中定义材料的属性，比如质量，摩擦力，粘度等。我们甚至可以从脚本内部修改这些值。物理系统中脚本的另一个潜在用途是定义碰撞的响应。我们可以处理声音的生成，特效和其他事件，都可以在脚本中完成。
- en: How about the AI system? This is arguably one of the most common uses for a
    scripting language in game engines, and one we will look at deeper in the next
    chapter. A lot of the components of the AI system can be moved into scripts. These
    include things like complex behavior definitions, the specification of AI objectives,
    inter-AI communication, the definition of AI personalities and traits, plus much
    more. While the list is large, you should note that the examples given are not
    CPU intensive, and again the complex components of the AI system such as pathfinding,
    fuzzy logic, and other intensive algorithms should be handled in C++ code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么AI系统呢？这可以说是游戏引擎中脚本语言最常见的用途之一，我们将在下一章更深入地研究这一点。AI系统的许多组件可以移入脚本中。这些包括复杂的行为定义，AI目标的规定，AI之间的通信，AI个性和特征的定义，以及更多。虽然列表很长，但你应该注意到给出的示例并不占用CPU，并且AI系统的复杂组件，如路径查找，模糊逻辑和其他密集算法应该在C++代码中处理。
- en: You can even add scripting to systems seemingly CPU and GPU heavy, such as the
    graphics engine. Scripts can handle the setting of lighting parameters, adjust
    effects like fog, and even add and remove gameplay elements from the screen. As
    you can see, there is very little in the engine that cannot be supplemented with
    some form of script abstraction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将脚本添加到看似CPU和GPU密集的系统中，比如图形引擎。脚本可以处理设置光照参数，调整雾等效果，甚至在屏幕上添加和删除游戏元素。正如你所看到的，引擎中几乎没有什么是不能用某种形式的脚本抽象来补充的。
- en: So, what scripting language should you use? There are a lot of options out there,
    from game-specific languages such as GameMonkey (which appears to be defunct at
    the time of writing this book), to more general languages such as Python and JavaScript.
    The choice really depends on your specific needs. While languages like Python
    and JavaScript have some amazing features, they add more complexity to learning
    and execution to get those features. For our example in this book, we are going
    to use a language called Lua. Lua has been around for many years, and while its
    popularity has seen a decline in recent years, it has a very strong track record
    in the game development industry. In the next part of this chapter, we will get
    to know Lua a little better, and see how we can incorporate it into our existing
    engine systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该使用哪种脚本语言？有很多选择，从游戏特定的语言，如GameMonkey（在撰写本书时似乎已经停用），到更通用的语言，如Python和JavaScript。选择取决于你的具体需求。虽然Python和JavaScript等语言具有一些令人惊叹的功能，但为了获得这些功能，学习和执行会更加复杂。在本书的示例中，我们将使用一种称为Lua的语言。Lua已经存在多年，虽然近年来其流行度有所下降，但在游戏开发行业中有着非常强大的记录。在本章的下一部分，我们将更好地了解Lua，并看看如何将其纳入我们现有的引擎系统中。
- en: Introducing LUA
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍LUA
- en: Lua, pronounced LOO-ah, is a lightweight, embeddable scripting language. It
    supports modern programming methodologies such as object-oriented, data-driven,
    functional, and procedural programming. Lua is a portable language that is able
    to be built on almost every system that provides a standard C compiler. Lua runs
    on all flavors of Unix, Windows, and Mac. Lua can even be found on mobile devices
    running Android, iOS, Windows Phone, and Symbian. This makes it a great fit for
    most gaming titles and is one of the main reasons that companies including Blizzard
    Entertainment have used it for titles such as World of Warcraft. Lua is also free,
    is distributed under an MIT permissions license, and may be used for any commercial
    purpose with no cost incurred.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lua，发音为LOO-ah，是一种轻量级的可嵌入脚本语言。它支持现代编程方法论，如面向对象，数据驱动，函数式和过程式编程。Lua是一种可移植的语言，几乎可以在提供标准C编译器的所有系统上构建。Lua可以在各种Unix，Windows和Mac系统上运行。Lua甚至可以在运行Android，iOS，Windows
    Phone和Symbian的移动设备上找到。这使得它非常适合大多数游戏标题，并且是包括暴雪娱乐在内的公司使用它的主要原因之一，例如《魔兽世界》。Lua也是免费的，根据MIT权限许可分发，并且可以用于任何商业目的而不产生任何费用。
- en: Lua is also a simple but powerful language. In Lua, there's just a single data
    structure referred to as a **table**. This table data structure can be used like
    a simple array, a key-value dictionary, and we can even implement a form of OOP
    by using tables as prototypes. This is very similar to doing OPP in other languages
    such as JavaScript.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Lua也是一种简单但强大的语言。在Lua中，只有一种数据结构被称为**table**。这种表数据结构可以像简单数组一样使用，也可以像键值字典一样使用，我们甚至可以使用表作为原型来实现一种面向对象编程。这与在其他语言中进行OOP非常相似，比如JavaScript。
- en: While we won't go through the language in full detail, there are some great
    resources available for that, including the Lua documentation website. What we
    will do is skim over some of the key language concepts that we will see in action
    throughout the examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细介绍语言，但有一些很好的资源可供参考，包括Lua文档网站。我们将简要介绍一些关键的语言概念，这些概念将在示例中得到体现。
- en: 'Let''s start with variables and simple program flow. In Lua, all numbers are
    doubles. You assign a number with the following syntax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从变量和简单的程序流开始。在Lua中，所有数字都是双精度浮点数。您可以使用以下语法分配一个数字：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the lack of a type identifier and a semicolon to denote the statement
    end.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意缺少类型标识符和分号来表示语句结束。
- en: 'Strings in Lua can be defined in a few ways. You can define them with single
    quotes, such as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Lua中的字符串可以用几种方式定义。您可以用单引号定义它们，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also use double quotes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用双引号：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For a string that spans multiple lines, you can use double square brackets
    to denote the start and end of the string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跨多行的字符串，您可以使用双方括号来表示字符串的开始和结束：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lua is a garbage collected language. You can remove a definition by setting
    the object to `nil`, the equivalent to *NULL* in C++:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Lua是一种垃圾收集语言。您可以通过将对象设置为`nil`来删除定义，这相当于C++中的*NULL*：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Statement blocks in Lua are denoted with language keywords such as `do` and
    `end`. A `while` loop block would look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Lua中的语句块用语言关键字来表示，比如`do`和`end`。`while`循环块将如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may notice we used number `+ 1` here, as there are no increment and decrement
    operators (`++`, `--`) in the Lua language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们在这里使用了`number + 1`，因为Lua语言中没有增量和减量运算符(`++`，`--`)。
- en: 'An `if` condition code block would look something like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件代码块将如下所示：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Functions in Lua are constructed in a similar fashion, using end to denote
    the completion of the functions code statement block. A simple function to calculate
    Fibonacci numbers would look similar to the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Lua中的函数构造方式类似，使用end来表示函数代码语句块的完成。一个简单的计算斐波那契数的函数将类似于以下示例：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As mentioned, tables are the only compound data structure in the Lua language.
    They are considered associative array objects, very similar to JavaScript objects.
    Tables are hash lookup dictionaries that can also be treated as lists. Using a
    table as a map/dictionary would look like the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，表是Lua语言中唯一的复合数据结构。它们被视为关联数组对象，非常类似于JavaScript对象。表是哈希查找字典，也可以被视为列表。使用表作为映射/字典的示例如下：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also use the JavaScript-like dot notation when working with tables.
    For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表时，您还可以使用类似JavaScript的点表示法。例如：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This removes `key2` from the table.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从表中删除`key2`。
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This adds a new key/value pair to the table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向表中添加一个新的键/值对。
- en: That concludes our very quick look at Lua language specifics; you will have
    the chance to learn more as we build out our examples. If you want to know more
    about Lua, I would again recommend reading through the documentation on the official
    website [http://www.lua.org/manual/5.3/](http://www.lua.org/manual/5.3/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Lua语言特定内容的快速介绍；随着我们构建示例，您将有机会了解更多。如果您想了解更多关于Lua的信息，我再次建议阅读官方网站上的文档[http://www.lua.org/manual/5.3/](http://www.lua.org/manual/5.3/)。
- en: In the next section, we will look at the process of including Lua language support
    in our example game engine project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何在我们的示例游戏引擎项目中包含Lua语言支持的过程。
- en: Implementing LUA
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现LUA
- en: In order for us to use Lua in our example engine, we need to take a few steps.
    First, we will need to obtain the Lua interpreter as a library that we can then
    include in our project. Next, we will have to obtain, or build our own, helper
    bridge to make the interaction between our C++ code and the Lua scripts easier.
    Finally, we will have to *expose* or *bind* functions, variables, and other objects
    that we wish to have access to our Lua scripts. While these steps might be slightly
    different for each implementation, this will provide us with a good starting point
    for our next examples.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的示例引擎中使用Lua，我们需要采取一些步骤。首先，我们需要获取Lua解释器作为一个库，然后将其包含在我们的项目中。接下来，我们将不得不获取或构建我们自己的辅助桥梁，以使我们的C++代码和Lua脚本之间的交互更容易。最后，我们将不得不*公开*或*绑定*函数、变量和其他对象，以便我们的Lua脚本可以访问它们。虽然这些步骤对于每个实现可能略有不同，但这将为我们的下一个示例提供一个很好的起点。
- en: To start with, we will need a copy of Lua as a library that we can use in our
    engine. For our examples, we are going to use Lua 5.3.4, which at the time of
    writing is the latest version of the language. I have opted to use a dynamic library
    in the examples. You can download both the dynamic and static version of the library,
    as well as the necessary include files, at the precompiled binaries page on the
    Lua project site ([http://luabinaries.sourceforge.net/](http://luabinaries.sourceforge.net/)).
    Once you have the precompiled library downloaded, extract it and then include
    the necessary files in our project. I am not going to go through the process of
    including a library in our project again. If you do need a refresher, flip back
    to [Chapter 2](190c5e44-8ae4-4747-8ff6-9540fabb79eb.xhtml), *Understanding Libraries*,
    where we walked through the steps in detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个Lua库的副本，以便在我们的引擎中使用。在我们的示例中，我们将使用Lua 5.3.4，这是当时的最新版本。我选择在示例中使用动态库。您可以在Lua项目网站的预编译二进制文件页面([http://luabinaries.sourceforge.net/](http://luabinaries.sourceforge.net/))上下载动态和静态版本的库，以及必要的包含文件。下载预编译库后，解压缩并将必要的文件包含在我们的项目中。我不打算再次详细介绍如何在项目中包含库。如果您需要复习，请翻回到[第2章](190c5e44-8ae4-4747-8ff6-9540fabb79eb.xhtml)，*理解库*，在那里我们详细介绍了步骤。
- en: As with other examples we have seen throughout the book, it is sometimes important
    to create helper classes and functions to allow easier interop between various
    libraries and components. This is again the case when we are working with Lua.
    To make the interaction easier for us as developers, we need to create a bridge
    class and functions to provide the functionality we need. We could build this
    bridge using the interface provided by Lua itself, which has great documentation,
    but there is also the option of using one of the numerous libraries available,
    which were created for this purpose. For the examples in this chapter and throughout
    the rest of the book, I have chosen to use the `sol2` library ([https://github.com/ThePhD/sol2](https://github.com/ThePhD/sol2)
    ), as this library is lightweight (a header only library), fast, and provides
    all the features we will need for our examples. Having this library in place will
    abstract a lot of the maintenance of the bridge and allow us to focus on implementation.
    To use the library in our project, all we have to do is copy the single header
    implementation into our `include` folder, and it will be ready to use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在整本书中看到的其他示例一样，有时创建辅助类和函数以允许各种库和组件之间更容易地进行交互是很重要的。当我们使用Lua时，这又是一个例子。为了使开发者更容易地进行交互，我们需要创建一个桥接类和函数来提供我们需要的功能。我们可以使用Lua本身提供的接口来构建这个桥接，Lua有很好的文档，但也可以选择使用为此目的创建的众多库之一。在本章和整本书的示例中，我选择使用`sol2`库（[https://github.com/ThePhD/sol2](https://github.com/ThePhD/sol2)），因为这个库是轻量级的（只有一个头文件），速度快，并且提供了我们示例中需要的所有功能。有了这个库，我们可以抽象出很多桥接的维护工作，并专注于实现。要在我们的项目中使用这个库，我们只需要将单个头文件实现复制到我们的`include`文件夹中，它就可以使用了。
- en: Now that we have the Lua engine and the `sol2` bridge library in place, we can
    move on to the last step, the implementation of the scripts. As mentioned, in
    order for us to use the underlying game engine components, they have to be exposed
    to Lua first. This is where the `sol2` library fits in. To demonstrate how this
    can be accomplished in our example engine, I have created a little project called
    `Bind_Example`. You can find the full source code in the `Chapter08` folder in
    the code repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Lua引擎和`sol2`桥接库，我们可以继续进行最后一步，实现脚本。如前所述，为了我们能够使用底层游戏引擎组件，它们必须首先暴露给Lua。这就是`sol2`库的作用所在。为了演示在我们的示例引擎中如何实现这一点，我创建了一个名为`Bind_Example`的小项目。您可以在代码存储库的`Chapter08`文件夹中找到完整的源代码。
- en: 'To get started, let''s first look at the Lua script itself. In this case, I
    have called mine `BindExample.lua`, and have placed it in the `Scripts` folder
    of my example projects parent directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下Lua脚本本身。在这种情况下，我把我的脚本命名为`BindExample.lua`，并将它放在示例项目父目录的`Scripts`文件夹中：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, our Lua script is quite basic. We have a table named `player`
    with two elements. An element with the key `name` and the value `Bob`, and an
    element with the key `isSpawned` and a value of `false`. Next, we have a simple
    Lua function named `fib`. This function will calculate all the numbers in the
    Fibonacci sequence up to the number passed in. I thought it would be fun to sneak
    a little math in for this example. I should note that this calculation can become
    quite processor intense the higher the sequence, so if you want it to process
    quickly, don't pass in a number larger than, say, 20.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的Lua脚本非常基本。我们有一个名为`player`的表，有两个元素。一个带有键`name`和值`Bob`的元素，以及一个带有键`isSpawned`和值`false`的元素。接下来，我们有一个名为`fib`的简单Lua函数。这个函数将计算斐波那契数列中直到传入的数字的所有数字。我觉得在这个例子中加入一点数学会很有趣。我应该指出，这个计算在序列越高时可能会变得相当消耗处理器，所以如果您希望它快速处理，请不要传入一个大于，比如说，20的数字。
- en: This gives us some quick example Lua code to work with. Now we need to connect
    our program and its logic to this newly created script. For this example, we will
    add this connection code to our `GameplayScreen` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一些快速的Lua代码示例来使用。现在我们需要将我们的程序和它的逻辑连接到这个新创建的脚本中。在这个示例中，我们将把这个连接代码添加到我们的`GameplayScreen`类中。
- en: 'We start out by adding the necessary include for the `sol2` library:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了`sol2`库的必要包含：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will create the Lua state. A `state` in Lua can be considered analogous
    to an operation environment for your code. Think of it as a virtual machine. This
    `state` is where your code will be executed, and it is through this `state` that
    you will have access to the code running within:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建Lua状态。在Lua中，`state`可以被视为代码的操作环境。将其视为虚拟机。这个`state`是您的代码将被执行的地方，也是通过这个`state`您将能够访问正在运行的代码的地方：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then open a few helper libraries that we will need for our Lua code interaction.
    These libraries can be thought of as the equivalent of `#include` in C++. The
    Lua philosophy is to keep the core small, and to offer more functionality through
    these libraries:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打开了一些我们在Lua代码交互中需要的辅助库。这些库可以被视为C++中`#include`的等价物。Lua的理念是保持核心的精简，并通过这些库提供更多的功能：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we have opened the libraries, we can then move on to loading the actual
    Lua script file. We do this by calling the `script_file` method of the Lua `state`
    we created previously. This method takes one parameter: the location of the file
    as a string. When this method is executed, the file will be loaded and executed
    automatically:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开了库之后，我们可以继续加载实际的Lua脚本文件。我们通过调用之前创建的Lua`state`的`script_file`方法来实现这一点。这个方法接受一个参数：文件的位置作为一个字符串。当执行这个方法时，文件将被自动加载和执行：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the script now loaded, we can begin to interact with it. First, let''s
    look at how we can pull data out of a variable (table) in Lua and use it in our
    C++ code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经加载，我们可以开始与它交互。首先，让我们看看如何从Lua的变量（表）中提取数据并在我们的C++代码中使用它：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The process of retrieving data from the Lua script is quite simple. In this
    case, we are creating a string called `stringFromLua` and assigning it the value
    stored in the Lua table players' `name` element. The syntax looks similar to calling
    an array element, but here we are specifying the element with a string. If we
    wanted the `isSpawned` element values, we would use `lua["player"]["isSpawned"]`,
    which in our case would currently return a Boolean value of `false`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从Lua脚本中检索数据的过程非常简单。在这种情况下，我们创建了一个名为`stringFromLua`的字符串，并将其赋值为Lua表players的`name`元素中存储的值。语法看起来类似于调用数组元素，但在这里我们用字符串指定元素。如果我们想要`isSpawned`元素的值，我们将使用`lua["player"]["isSpawned"]`，在我们的例子中，这将当前返回一个布尔值`false`。
- en: 'Calling a Lua function is just as easy and quite similar to retrieving values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用Lua函数和检索值一样简单，而且非常类似：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we are creating a variable of the type double, called `numberFromLua`,
    and assigning it the value of the return from the Lua function `fib`. Here, we
    specify the function name as a string, `fib`, and we then specify any parameters
    needed by that function. In this example, we are passing in the value of 20 to
    calculate the Fibonacci sequence up to the twentieth number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`numberFromLua`的双精度类型的变量，并将其赋值为Lua函数`fib`的返回值。在这里，我们将函数名指定为一个字符串`fib`，然后指定该函数需要的任何参数。在这个例子中，我们传入值20来计算斐波那契数列直到第20个数字。
- en: 'If you run the `Bind_Example` project, you will see the following output in
    the engine''s command window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`Bind_Example`项目，你将在引擎的命令窗口中看到以下输出：
- en: '![](img/5c1eeb50-54c3-410b-bb35-75080880eaef.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c1eeb50-54c3-410b-bb35-75080880eaef.png)'
- en: While this covers the basics of the interaction between our C++ code and the
    Lua scripting system, there is a lot more to be discovered. In the next few sections,
    we will look at ways to utilize this scripting structure to augment various advanced
    gameplay systems and provide us with a flexible way to expand our gaming projects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这涵盖了我们的C++代码与Lua脚本系统之间的交互基础知识，但还有很多可以发现的地方。在接下来的几节中，我们将探讨如何利用这种脚本结构来增强各种高级游戏系统，并为我们提供一种灵活的方式来扩展我们的游戏项目。
- en: Building a dialog system
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建对话系统
- en: One of the most common forms of interacting with the game world is through some
    form of dialog. Being able to communicate with `NPC` classes, getting information
    and quests, and of course, driving the story narrative through dialog is a must
    in most modern game titles. While you could easily hardcode interactions, this
    approach would leave us with very little flexibility. Each time we wanted to make
    a slight change to any dialog or interaction, we would have to open up the source
    code, dig through the project, make any necessary changes, and then recompile
    to see the effects. Obviously, this is a tedious process. Just think about how
    many games you have played where spelling, grammar, or other errors appeared.
    The good news is there is another approach we can take. Using a scripting language,
    such as Lua, we can drive our interactions in a dynamic way, which will allow
    us to make quick changes without the need for the tedious process described previously.
    In this section, we will look at the detailed process of building a dialog system
    that, at a high-level description, will load a script, attach it to an `NPC`,
    present dialog with choices to the player, and, finally, drive a dialog tree based
    on the returned player input.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏世界互动的最常见形式之一是通过某种对话形式。能够与`NPC`类进行交流，获取信息和任务，当然，通过对话推动故事叙述在大多数现代游戏标题中都是必不可少的。虽然你可以轻松地硬编码交互，但这种方法会让我们的灵活性非常有限。每次我们想要对任何对话或交互进行轻微更改时，我们都必须打开源代码，搜索项目，进行必要的更改，然后重新编译以查看效果。显然，这是一个繁琐的过程。想想你玩过多少游戏出现拼写、语法或其他错误。好消息是我们还有另一种方法。使用Lua这样的脚本语言，我们可以以动态方式驱动我们的交互，这将允许我们快速进行更改，而无需进行先前描述的繁琐过程。在本节中，我们将详细介绍构建对话系统的过程，它在高层描述上将加载一个脚本，将其附加到一个`NPC`，向玩家呈现带有选择的对话，最后，根据返回的玩家输入驱动对话树。
- en: Constructing the C++ infrastructure
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C++基础设施
- en: To start, we will need to build the infrastructure in our example engine to
    support the scripting of the dialog system. There are quite literally thousands
    of different ways that you could approach this implementation. For our example,
    I am going to do my best to keep it simple. We are going to use some of the techniques
    and patterns we have learned throughout the previous chapters, including the state
    and update patterns, as well as the GUI system we built to handle interactions
    and display.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的示例引擎中构建基础设施，以支持对话系统的脚本化。实际上有成千上万种不同的方法可以实现这个实现。对于我们的示例，我会尽力保持简单。我们将使用我们在之前章节中学到的一些技术和模式，包括状态和更新模式，以及我们构建的GUI系统来处理交互和显示。
- en: 'They say a picture is worth a thousand words, so to give you a general idea
    of how this system is going to be connected, let''s take a look at a code map
    diagram that depicts the connections between all the classes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说一张图片胜过千言万语，所以为了让你对这个系统的连接方式有一个大致的了解，让我们来看一下一个代码映射图，它描述了所有类之间的连接：
- en: '![](img/c014d784-590f-4a51-aba9-60a48686ceb6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c014d784-590f-4a51-aba9-60a48686ceb6.png)'
- en: There is a bit going on here, so we will break it down class by class. To begin,
    let's look at the `DialogGUI` class. This class builds off of the IGUI example
    we built in a previous chapter. Since we have already gone through the design
    of the IGUI class in depth, we will only cover the specific aspects we are adding
    to provide the functionality we need for our dialog system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些事情要做，所以我们将逐个类地分解它。首先，让我们看一下`DialogGUI`类。这个类是基于我们在之前章节中构建的IGUI示例。由于我们已经深入讨论了IGUI类的设计，我们只会涵盖我们添加的特定方面，以提供我们对话系统所需的功能。
- en: 'First, we will need a few variables to hold the dialog and any choices that
    we want to provide the player with. In `DialogGUI.h`, we have the following: the
    vector of `IGUILabel` objects for the choices and a single `IGUILabel` for the
    dialog. For the implementation of the `IGUILabel` class, take a look at its source
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些变量来保存对话和我们想要为玩家提供的任何选择。在`DialogGUI.h`中，我们有以下内容：选择的`IGUILabel`对象的向量和对话的单个`IGUILabel`。有关`IGUILabel`类的实现，请查看其源代码：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will need to add a few new functions to provide us with the needed
    interaction for our GUI and the data being provided from the scripts. To do this,
    we will add three methods to our `DialogGUI` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些新的函数，为我们的GUI提供所需的交互和脚本提供的数据。为此，我们将在`DialogGUI`类中添加三种方法：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `SetDialog` function, as its name suggests, will handle the setting of
    the dialog text for each of the interaction screens. The function takes only one
    parameter, the text we want to place on the GUI for this interaction:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDialog`函数，顾名思义，将处理为每个交互屏幕设置对话框文本的工作。该函数只接受一个参数，即我们想要放置在GUI上的交互文本：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the function body, we are assigning the `m_dialog` label variable to a new
    instance of an `IGUILabel` object. The constructor should look similar to the
    `IGUIButton` seen previously, where the text value is passed in. Finally, we add
    the label to the GUI panel by calling the `AddGUIElement` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们将`m_dialog`标签变量分配给`IGUILabel`对象的新实例。构造函数应该类似于之前看到的`IGUIButton`，其中传入了文本值。最后，我们通过调用`AddGUIElement`方法将标签添加到GUI面板中。
- en: 'The `SetOption` function, again as its name suggests, sets the text for each
    option on the current interaction screen. This function takes two parameters.
    The first is the text we want to set the `IGUILabel` to, and the second is the
    choice number, which is its number in the list of choice options being presented.
    We use this to see which option has been selected:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetOption`函数，顾名思义，再次设置当前交互屏幕上每个选项的文本。此函数接受两个参数。第一个是我们要将`IGUILabel`设置为的文本，第二个是选择编号，它是在呈现的选择选项列表中的编号。我们使用这个来查看选择了哪个选项：'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the function body, we are doing a very similar process to the `SetDialog`
    function. The difference here is we are going to be adding the `IGUILabel` instance
    to the choices vector. First, we perform a little trick to increase the size of
    the vector by one, and this will then allow us to assign the new label instance
    to the vector position at the choice number value passed in. Finally, we add the
    `IGUILabel` to the panel with the `AddGUIElement` method call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们正在执行与`SetDialog`函数非常相似的过程。这里的区别在于，我们将向选择向量添加`IGUILabel`实例。首先，我们进行一个小技巧，将向量的大小增加一，然后这将允许我们将新的标签实例分配给传入的选择编号值的向量位置。最后，我们通过调用`AddGUIElement`方法将`IGUILabel`添加到面板中。
- en: 'The last function we add to the `DialogGUI` class is the `RemoveAllPanelElements`,
    which of course will handle removing all the elements we have added to the current
    dialog screen. We are removing the elements so we can reuse the panel and avoid
    recreating the panel each time we change interactions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`DialogGUI`类的最后一个函数是`RemoveAllPanelElements`，它当然将处理删除我们添加到当前对话框屏幕的所有元素。我们正在删除这些元素，以便我们可以重用面板并避免每次更改交互时重新创建面板：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `RemoveAllGUIElements` function in turn just calls the same method on the
    `m_panel` object. The `IGUIPanel` class'' implementation simply calls the clear
    method on the vector, removing all of its elements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveAllGUIElements`函数反过来只是调用`m_panel`对象上的相同方法。`IGUIPanel`类的实现只是调用向量上的clear方法，删除所有元素：'
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That takes care of the GUI setup for our dialog system, so now we can move on
    to building the `NPC` class which will handle the majority of the script to engine
    bridging.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了对话系统的GUI设置，现在我们可以继续构建`NPC`类，该类将处理大部分脚本到引擎的桥接。
- en: 'As I mentioned previously, we are going to be employing some of the patterns
    we learned in previous examples to help us build our dialog system. To help us
    control when we are constructing the GUI elements and when we are waiting for
    the player to make a choice, we are going to use a finite-state machine coupled
    with an update pattern. To start with, in the `NPC.h` file we have the `enum`
    that will define the states we will use. In this case, we have only two states,
    `Display` and `WaitingForInput`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们将利用之前学到的一些模式来帮助我们构建对话系统。为了帮助我们控制何时构建GUI元素以及何时等待玩家做出选择，我们将使用有限状态机和更新模式。首先，在`NPC.h`文件中，我们有一个将定义我们将使用的状态的`enum`。在这种情况下，我们只有两个状态，`Display`和`WaitingForInput`：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, we will also need a way to track the states, so we have an `InteractionState`
    variable called `currentState` that we will set to the state we are currently
    in. Later, we will see the completion of this state machine in the `Update` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要一种方式来跟踪状态，所以我们有一个名为`currentState`的`InteractionState`变量，我们将把它设置为我们当前所处的状态。稍后，我们将在`Update`函数中看到这个状态机的完成：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need a variable for holding our Lua state, which we saw in the previous
    section of this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个变量来保存我们的Lua状态，这是本章前一节中看到的：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You might recall from the code map diagram shown earlier that our `NPC` will
    have an instance of a `DialogGUI` for handling the displaying of the dialog content
    and interaction with the player, so we will also need a variable to hold it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得之前显示的代码映射图中，我们的`NPC`将拥有一个`DialogGUI`的实例，用于处理对话内容的显示和与玩家的交互，因此我们还需要一个变量来保存它：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moving on to the implementation of the `NPC` class, we first will look at the
    constructor for the class in the `NPC.cpp` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现`NPC`类，我们首先将查看`NPC.cpp`文件中该类的构造函数：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The constructor takes a single parameter, a reference to the dialog instance
    we will be using for our interaction. We set this reference to the member variable
    `m_gui` for later use. We then handle the loading of the Lua script we will use.
    Finally, we set the current state of our internal state machine to the `Display`
    state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数，即我们将用于交互的对话实例的引用。我们将此引用设置为成员变量 `m_gui` 以供以后使用。然后，我们处理将要使用的 Lua 脚本的加载。最后，我们将内部状态机的当前状态设置为
    `Display` 状态。
- en: 'Let''s revisit our code map to see the different connections we need to implement
    for passing the `NPC` class'' loaded script information to the GUI instance we
    have attached to:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新查看我们的代码地图，看看我们需要实现的不同连接，以将 `NPC` 类的加载的脚本信息传递给我们已附加的 GUI 实例：
- en: '![](img/eae789ce-a9e9-4382-b250-d184582e7da9.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae789ce-a9e9-4382-b250-d184582e7da9.png)'
- en: 'As we can see, we have two methods that are handling the connection. The `Say`
    function is the simplest of the two. Here, the `NPC` class is just calling the
    `SetDialog` method on the attached GUI, passing along a string containing the
    dialog to display:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有两个处理连接的方法。`Say` 函数是其中较简单的一个。在这里，`NPC` 类只是在附加的 GUI 上调用 `SetDialog`
    方法，传递包含要显示的对话的字符串：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `PresentOptions` function has slightly more to it. To start, the function
    retrieves a table from the Lua script that denotes the choices for this current
    interaction, and we will see how this is set up in the script shortly. Next, we
    are going to iterate through the table, if it is valid, and simply call the `SetOption`
    method on the attached GUI, passing along the choice text as a string and the
    choice number used for selection:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`PresentOptions` 函数稍微复杂一些。首先，该函数从 Lua 脚本中检索一个表，该表表示当前交互的选择，我们很快就会看到脚本是如何设置的。接下来，我们将遍历该表（如果它是有效的），并简单地在附加的
    GUI 上调用 `SetOption` 方法，传递选择文本作为字符串和用于选择的选择编号：'
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last piece of our engine side of the dialog system we need to put in place
    is the `Update` method. This method, as we have seen many times, will drive the
    system forward. By connecting to the existing `Update` event system of the engine,
    our `NPC ` class'' `Update` method will be able to control what is happening with
    our dialog system on each frame:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要放置在引擎端对话系统的最后一部分是 `Update` 方法。正如我们已经多次看到的那样，这个方法将推动系统向前。通过连接到引擎的现有 `Update`
    事件系统，我们的 `NPC` 类的 `Update` 方法将能够控制每一帧对话系统中发生的事情：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As with our previous finite-state machine implementation, we are going to use
    a switch case to determine what code should be run based on the current state
    we are in. For this example, our `Display` state is where we are going to call
    our connecting methods `Say` and `PresentOptions`. Here, the `Say` call is passing,
    alone, the text it is pulling from the script file that has been loaded. We will
    see how this works in the script next. If, in this example, we are in the `WaitingForInput`
    state, we are going to iterate through each of the choices we have loaded and
    see if the player has selected any of them yet. If one is found, we are going
    to call back to the script and tell it which choice has been selected. We are
    then going to switch our state to the `Display` state, which will kick off the
    loading of the next dialog screen. Then, we will clear our choices vector in the
    attached `DisplayGUI`, allowing it to be then loaded with the next set of choices,
    and finally calling the `RemoveAllPanelElements` method to clean up our GUI for
    reuse.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的有限状态机实现一样，我们将使用 switch case 来确定基于当前状态应该运行什么代码。在这个例子中，我们的 `Display` 状态是我们将调用连接方法
    `Say` 和 `PresentOptions` 的地方。在这里，`Say` 调用单独传递了它从已加载的脚本文件中提取的文本。我们将在接下来的脚本中看到这是如何工作的。如果在这个例子中，我们处于
    `WaitingForInput` 状态，我们将遍历我们已加载的每个选择，并查看玩家是否已经选择了其中任何一个。如果找到了一个，我们将回调脚本并告诉它已选择了哪个选项。然后，我们将切换我们的状态到
    `Display` 状态，这将启动加载下一个对话屏幕。然后，我们将清除附加的 `DisplayGUI` 中的选择向量，允许它随后加载下一组选择，并最后调用
    `RemoveAllPanelElements` 方法来清理我们的 GUI 以便重用。
- en: With the `Update` method in place, we now have all the framework set up to handle
    the loading, displaying, and input handling needed for our `NPC` interaction scripts.
    Next, we will look at how we can construct one of these scripts to use with our
    engine's newly created dialog system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `Update` 方法，我们现在已经设置好了处理加载、显示和输入处理所需的框架，用于我们的 `NPC` 交互脚本。接下来，我们将看看如何构建其中一个这样的脚本，以便与我们引擎新创建的对话系统一起使用。
- en: Creating a dialog tree script
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对话树脚本
- en: 'A dialog or conversation tree can be thought of as the determined flow of an
    interaction. In essence, it works by first providing a statement, then, based
    on a selection of presented responses, the interaction can branch off into different
    paths. A visual representation of how our example dialog flow is determined is
    pictured in the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对话或会话树可以被视为交互的确定流程。实质上，它首先提供一个陈述，然后，基于呈现的响应选择，交互可以分支出不同的路径。我们示例对话流程的可视化表示如下图所示：
- en: '![](img/6ce1e167-083a-4863-a04d-41230fa52cf7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ce1e167-083a-4863-a04d-41230fa52cf7.png)'
- en: 'Here, we are beginning the dialog tree with an intro. The user is then presented
    with two choices: **Yes, need help** and **No, leave me alone**. If the user selects
    the **Yes** path, then we move on to the **Express helpfulness** dialog. If the
    user selects **No**, we move to the **Goodbye man** dialog. From the **Express
    helpfulness** dialog, we present three choices: **Okay**, **Start over**, and
    **Weak**. Based on the choice, we then move again to the next stage of the dialog
    tree. **Okay** leads to the **leave nice** dialog. **Weak** leads to the **Goodbye
    man** dialog, and **Start over**, well, starts over. This is a basic example,
    but it demonstrates the overall concept of how dialog trees work.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以一个介绍开始对话树。然后用户被呈现两个选择：**是，需要帮助**和**不，离开我**。如果用户选择**是**路径，那么我们继续到**表达帮助**对话。如果用户选择**不**，我们移动到**再见**对话。从**表达帮助**对话，我们呈现三个选择：**好的**，**重新开始**和**虚弱**。根据选择，我们再次移动到对话树的下一个阶段。**好的**导致**离开愉快**对话。**虚弱**导致**再见**对话，**重新开始**，嗯，重新开始。这是一个基本的例子，但它演示了对话树如何工作的整体概念。
- en: 'Now let''s take a look at how we can implement this example tree in our Lua
    scripting engine. The following is the full script, and we will dive into the
    details next:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在我们的Lua脚本引擎中实现这个示例树。以下是完整的脚本，我们将在接下来的部分深入了解细节：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the whole script is not that long. We have a few concepts that
    make this script work. First is a very simple version of a state machine. We have
    a variable called `CurrentDialog`, and this variable will point to the active
    dialog. At the very end of our script we are initially setting this to the `intro`
    dialog object, which will kick off the dialog tree upon the loading of the script.
    The next important concept we have in our script design is the concept of every
    interaction screen being described as a table object. Let''s take a look at the
    intro dialog table as an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，整个脚本并不长。我们有一些概念使得这个脚本工作。首先是一个非常简单的状态机版本。我们有一个名为`CurrentDialog`的变量，这个变量将指向活动对话。在我们的脚本的最后，我们最初将其设置为`intro`对话对象，这将在加载脚本时启动对话树。我们在脚本设计中的下一个重要概念是将每个交互屏幕描述为一个表对象。让我们以介绍对话表为例。
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each dialog table object has a `Say` element, and this element is the text that
    will be displayed when the `Say` function asks the script for its dialog content.
    Next, we have two optional elements, but that are required if you want to have
    an interaction with the player. The first is a nested table called `choices`,
    which has elements that house the choices that will be presented to the player
    when requested by the dialog system. The second option element is actually a function.
    This function is called when the user selects a choice, and is comprised of some
    `if` statements. These `if` statements will test which choice has been selected,
    and based on that choice, will set the `CurrentDialog` object to the next dialog
    on the path of the dialog tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话表对象都有一个`Say`元素，这个元素是当`Say`函数询问脚本其对话内容时将显示的文本。接下来，我们有两个可选元素，但如果你想与玩家进行交互，这些元素是必需的。第一个是一个名为`choices`的嵌套表，其中包含了对话系统在玩家请求时将呈现给玩家的选择。第二个可选元素实际上是一个函数。当用户选择一个选项时，将调用此函数，并由一些`if`语句组成。这些`if`语句将测试选择了哪个选项，并根据选择将`CurrentDialog`对象设置为对话树路径上的下一个对话。
- en: That's really it. The greatest bonus of designing our dialog tree system this
    way is that, with very little guidance, even a non-programmer could design a simple
    script like the one previously shown.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。以这种方式设计我们的对话树系统的最大优点是，即使没有太多指导，甚至非程序员也可以设计一个像之前展示的简单脚本。
- en: 'If you go ahead and run the `Dialog_Example` project using the `Chapter08`
    solution, you will see this script in action and will be able to interact with
    it. Following are a few screenshots showing what the output would look like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续使用`Chapter08`解决方案运行`Dialog_Example`项目，你将看到这个脚本的运行并能与之交互。以下是一些截图，展示输出的样子：
- en: '![](img/90b8913b-b9d6-4f62-9c06-f50dcb30720d.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90b8913b-b9d6-4f62-9c06-f50dcb30720d.png)'
- en: Although this is a simple system implementation, it is very flexible. It should
    be noted again that these scripts do not need to be recompiled to make changes.
    Try it for yourself. Make some changes to the `NPC.lua` file, rerun the example
    program, and you will see your changes appear.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的系统实现，但它非常灵活。再次需要指出的是，这些脚本不需要重新编译即可进行更改。自己试试吧。对`NPC.lua`文件进行一些更改，重新运行示例程序，你会看到你的更改出现。
- en: In the next section, we will see how we can take the inclusion of a scripting
    system even further by implementing a quest system driven by Lua scripts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过Lua脚本实现一个由任务系统驱动的对话树。
- en: Scripting quests
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本任务
- en: Another very common advanced gameplay system is the quest system. While more
    commonly seen in role-playing games, quests can appear in other genres as well.
    Often, these other genres will disguise a quest system by referring to it as a
    different name. For example, some games have challenges, which in essence are
    really the same as quests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的高级游戏玩法系统是任务系统。虽然任务更常见于角色扮演游戏中，但也可以出现在其他类型的游戏中。通常，这些其他类型会通过不同的名称来掩饰任务系统。例如，一些游戏有挑战，本质上与任务是一样的。
- en: A quest can be simply thought of as an attempt to achieve a specific outcome.
    Typically, a quest will involve a certain number of steps that must be conducted
    before the quest will be considered complete. Some types of common quests include
    kill quests, where players typically will have to kill a specific number of enemies,
    commonly referred to as **grinding**, and **delivery** quests, where a player
    will have to play the role of courier and often has to travel to new locations
    in the game world to deliver goods. This, of course, is a great way to get the
    player to travel to the next desired location without forcing them. In gathering
    quests, a player will have to collect a certain amount of a specific item. In
    escort quests, often dreaded by players because of historically bad implementations,
    players often have to accompany an `NPC` to a new location while protecting them
    from harm. Lastly, hybrid quests are often a mix of the mentioned types, and are
    more typically longer quests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以简单地被认为是为了实现特定结果而进行的尝试。通常，任务将涉及必须在任务被视为完成之前进行的一定数量的步骤。一些常见类型的任务包括击杀任务，玩家通常必须击败一定数量的敌人，通常被称为**刷怪**，以及**交付**任务，玩家必须扮演信使的角色，并经常需要前往游戏世界的新位置交付货物。当然，这是一个很好的方式，可以让玩家前往下一个期望的位置而不强迫他们。在收集任务中，玩家必须收集一定数量的特定物品。在护送任务中，玩家经常因为历史上糟糕的实现而感到害怕，玩家经常必须陪同一个`NPC`前往新的位置，并保护他们免受伤害。最后，混合任务通常是上述类型的混合，并且通常是更长的任务。
- en: Another common part of a quest system is the support for what is referred to
    as a quest chain or quest line. In a quest chain, the completion of each quest
    is a prerequisite for beginning the next quest in the sequence. These quests often
    involve more and more complex quests as the player progresses through the chain.
    These quests are a great way to reveal a plotline gradually.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 任务系统的另一个常见部分是支持所谓的任务链或任务线。在任务链中，每个任务的完成都是开始序列中下一个任务的先决条件。随着玩家在任务链中的进展，这些任务通常涉及越来越复杂的任务。这些任务是逐渐揭示情节的一个很好的方式。
- en: That explains what quests are. In the next section, we will discuss a few different
    ways we can add support for quests in our game projects. However, before we look
    at the specifics of implementation, it is useful for us to define what we expect
    each quest object to require.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了任务是什么。在下一节中，我们将讨论在我们的游戏项目中添加任务支持的几种不同方式。然而，在我们查看实现的具体细节之前，对于我们来说定义每个任务对象需要的是很有用的。
- en: 'For the sake of our simple examples, we will assume that quest objects will
    be comprised of the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将假设任务对象将由以下内容组成：
- en: '**A quest name**: The name of the quest'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务名称**：任务的名称'
- en: '**Objectives**: The actions that must be taken to complete the quest'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：完成任务所必须采取的行动'
- en: '**Reward(s)**: What the player will receive for completing the task'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奖励**：玩家完成任务后将获得的奖励'
- en: '**Description**: A little information about the quest, maybe some backstory
    as to why the player is undertaking the task'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：关于任务的一些信息，也许是玩家为什么要承担这项任务的背景故事'
- en: '**Quest giver**: The `NPC` that gave the quest'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务给予者**：给予任务的`NPC`'
- en: With these simple elements, we can construct our basic quest system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些简单的元素，我们就可以构建我们的基本任务系统。
- en: As we have seen in previous gameplay system examples, there are many different
    ways we could approach the implementation of our quest system in the example engine.
    Let's now take a brief look at a few and discuss their merits and pitfalls.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在先前的游戏玩法系统示例中所看到的，我们可以以许多不同的方式来实现我们在示例引擎中的任务系统。现在让我们简要地看一下其中的一些，并讨论它们的优点和缺点。
- en: In engine support
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引擎支持
- en: 'One way we could go about supporting a quest system would to be to build it
    into the game engine itself. The entire system would be designed close to the
    engine code and in the native engine language, in our case C++. We would create
    an infrastructure to support the quest using techniques we have seen numerous
    times. Using inheritance, we could expose the basic functions and variables needed
    and let the developer build this construct. A simple, high-level quest class might
    then look similar to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们支持任务系统的一种方式是将其构建到游戏引擎本身中。整个系统将设计得靠近引擎代码，并且使用本机引擎语言，对于我们来说是C++。我们将创建基础设施来支持任务，使用我们已经多次看到的技术。通过继承，我们可以公开所需的基本函数和变量，并让开发人员构建这个结构。然后，一个简单的高级任务类可能看起来类似于以下内容：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, this is just meant to be a simple demonstration, and in this case,
    we will skip the implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的演示，而在这种情况下，我们将跳过实现。
- en: The pros of this implementation approach are that it is writing in native code,
    meaning it will run fast, and it's close to the engine, meaning it will have greater
    access to the underlying systems without the need of interface layers or other
    libraries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法的优点是它是用本机代码编写的，意味着它将运行得很快，并且它靠近引擎，这意味着它将更容易地访问底层系统，而无需接口层或其他库的需要。
- en: The cons of this implementation approach include that as it's part of the game
    engine or game code itself, and this means that any changes that are made will
    need to be recompiled. This also makes it harder for non-coders to add their own
    ideas for quests or to handle the expansion of the quest system after release.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法的缺点包括，因为它是游戏引擎或游戏代码的一部分，这意味着任何更改都需要重新编译。这也使得非编程人员难以添加他们自己的任务想法，或者在发布后处理任务系统的扩展。
- en: While this approach does work, it's more suited to smaller projects where you
    will not have to, or want to, make changes to the quests or system once it is
    in place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法确实有效，但更适用于较小的项目，在这些项目中，一旦任务或系统就位，您将不需要或不想要对其进行更改。
- en: Engine/script bridge
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引擎/脚本桥
- en: This approach is the same approach we took to implement our `NPC` dialog system
    earlier. In this design, we create an interface class that handles the loading
    of the scripts and the passing of data to and from the quest scripts. Since we
    have seen a similar implementation before, I will skip the example code here and
    instead move on to the pros and cons of this approach.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们之前实现`NPC`对话系统的方法相同。在这种设计中，我们创建一个处理脚本加载和数据传递的接口类。由于我们之前已经看到了类似的实现，我将跳过这里的示例代码，而是继续讨论这种方法的优缺点。
- en: The pros of this implementation approach include flexibility when compared to
    the engine only implementation. If we want to make any changes, we simply need
    to load up the script in an editor, make the changes, and reload the game. This
    again also makes it far more accessible for non-coders to create their own quests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法的优点包括与仅引擎实现相比的灵活性。如果我们想要进行任何更改，我们只需要在编辑器中加载脚本，进行更改，然后重新加载游戏。这也使得非编码人员更容易创建自己的任务。
- en: The cons of this implementation approach include that it is still partially
    tied to the engine itself. The scripts can only have access to elements and functions
    exposed by the engines interface. If you wanted to add more functionality to a
    quest, you would have to build that into the engine side before any scripts could
    make use of it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法的缺点包括它仍然部分地与引擎本身相关。脚本只能访问引擎接口公开的元素和函数。如果您想要为任务添加更多功能，您必须在脚本使用之前将其构建到引擎端。
- en: This approach is better suited to larger projects, but as noted, still has its
    drawbacks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更适合于较大的项目，但如前所述，仍然有其缺点。
- en: Script-based system
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于脚本的系统
- en: Another approach we can take is to build the entire system within our scripting
    language, with only generic methods exposed from the engine. These generic methods
    would likely be good candidates for template functions. In this approach, the
    quests system internals and quest scripts alike would be written in the scripting
    language. Each quest written in a script would include a reference to the quest
    system script that would handle the management. This approach is very similar
    to the engine only approach; it's just been moved out of the engine and into the
    scripting system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的另一种方法是在我们的脚本语言中构建整个系统，只从引擎中公开通用方法。这些通用方法很可能是模板函数的良好候选者。在这种方法中，任务系统的内部和任务脚本都将用脚本语言编写。在脚本中编写的每个任务都将包括对处理管理的任务系统脚本的引用。这种方法与仅引擎方法非常相似；它只是从引擎中移出，并进入脚本系统。
- en: 'Let''s take a look at a simple version of the quest system script. Some pieces
    are omitted for brevity''s sake:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简化版本的任务系统脚本。出于简洁起见，有些部分被省略了：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, I have omitted a few functions to save space, but the core components
    needed to understand the system are here. First, we have a function that creates
    a new quest, taking in the name, objective, description, and quest giver. We then
    have the accept function that sets the quest to active. Notice how we are using
    the key/pair lookup method to iterate through our tables—we will do this a lot.
    Then we have a function to turn in the quest, and finally a simple function that
    returns all the quest information. The functions not depicted here are for getting
    and setting the various objective values for the quest. For the full implementation,
    take a look at the `Quest_Example` project in the `Chapter08` folder of the code
    repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我省略了一些函数以节省空间，但理解系统所需的核心组件都在这里。首先，我们有一个创建新任务的函数，接受名称、目标、描述和任务给予者。然后我们有接受函数，将任务设置为活动状态。请注意，我们使用键/值查找方法来遍历我们的表
    - 我们会经常这样做。然后我们有一个完成任务的函数，最后是一个简单的返回所有任务信息的函数。这里没有描绘的函数是用于获取和设置任务各种目标值的。要查看完整的实现，请查看代码存储库的`Chapter08`文件夹中的`Quest_Example`项目。
- en: 'Now, with the quest system script in place, we have a few options. First, we
    could just add this system to other scripts by using the Lua build in the `require`
    system which would allow us to use the script in other scripts. The syntax for
    this looks like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了任务系统脚本，我们有几个选择。首先，我们可以通过使用Lua内置的`require`系统将此系统添加到其他脚本中，这将允许我们在其他脚本中使用该脚本。这样做的语法如下：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Or we could simply load the script in our game engine and use an interface,
    like we did in the previous example, and interact with our quest system that way.
    With this flexibility, the choice is up to the developer and situation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以简单地在游戏引擎中加载脚本并使用接口，就像我们在上一个示例中所做的那样，并以这种方式与我们的任务系统交互。有了这种灵活性，选择权在于开发人员和情况。
- en: The pros of this implementation approach include great flexibility. In this
    approach, changes not only to the quest but the quest system itself can be modified
    on the fly without the need to rebuild the game or engine. This is often a method
    that is used to include downloadable content (DLC), game modifications (mods),
    and other extra content after a product's release.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法的优点包括极大的灵活性。在这种方法中，不仅可以修改任务，还可以在不需要重新构建游戏或引擎的情况下即时修改任务系统本身。这通常是在产品发布后包含可下载内容（DLC）、游戏修改（mod）和其他额外内容的方法。
- en: The cons of this implementation include, although it is very flexible, the addition
    of an extra layer of complexity. It can also be slower because the system is writing
    in a scripting language that is interpreted, and performance can take a hit. It
    also requires developers to have greater knowledge of the scripting language and
    can require more learning time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的缺点包括，尽管它非常灵活，但增加了额外的复杂性。它也可能会更慢，因为系统是用解释性的脚本语言编写的，性能可能会受到影响。它还要求开发人员对脚本语言有更多的了解，并可能需要更多的学习时间。
- en: Like the other approaches, this one, too, has its place and time. While I tend
    to lean towards a system like this in larger projects, if the team is not prepared,
    this approach could add more overhead then ease of use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他方法一样，这种方法也有其适用的场合和时间。虽然我倾向于在较大的项目中使用这样的系统，但如果团队没有准备好，这种方法可能会增加更多的开销而不是简化使用。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a great deal when it comes to implementing advanced
    gameplay systems. We dove deep into how you can include a scripting language like
    Lua in your game projects. Then we built on that knowledge to examine ways of
    implementing dialog and quest systems into our example engine. While we did discuss
    a lot, we have barely scratched the surface of this topic. In the next chapter,
    we will continue to build on this newfound knowledge to construct some artificial
    intelligence for our games.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当涉及到实施高级游戏玩法系统时，我们涵盖了大量内容。我们深入探讨了如何在游戏项目中包含像Lua这样的脚本语言。然后我们在这些知识的基础上，探讨了实施对话和任务系统到我们示例引擎中的方法。虽然我们讨论了很多内容，但我们只是触及了这个主题的表面。在下一章中，我们将继续基于这些新知识，为我们的游戏构建一些人工智能。
