- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 入门
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating a project for a basic application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基本应用程序创建项目
- en: Creating a project for a screensaver application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为屏幕保护程序应用程序创建项目
- en: Creating a project for an iOS touch application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 iOS 触摸应用程序创建项目
- en: Understanding the basic structure of an application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用程序的基本结构
- en: Responding to mouse input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应鼠标输入
- en: Responding to key input
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应键盘输入
- en: Responding to touch input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应触摸输入
- en: Accessing the files dropped onto the application window
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问拖放到应用程序窗口上的文件
- en: Adjusting a scene after resizing the window
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整场景以适应窗口大小
- en: Using resources on Windows
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上使用资源
- en: Using resources on OSX and iOS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OSX 和 iOS 上使用资源
- en: Using assets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资产
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we'll learn the fundamentals of creating applications using
    Cinder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用 Cinder 创建应用程序的基础知识。
- en: We'll start by creating different types of applications on the different platforms
    that Cinder supports using a powerful tool called TinderBox.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用一个名为 TinderBox 的强大工具在不同的平台上创建 Cinder 支持的不同类型的应用程序。
- en: We'll cover the basic structure of an application and see how to respond to
    user input events.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍应用程序的基本结构，并查看如何响应用户输入事件。
- en: Finally, we will learn how to use resources on Windows and Mac.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何在 Windows 和 Mac 上使用资源。
- en: Creating a project for a basic application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为基本应用程序创建项目
- en: In this recipe, we'll learn how to create a project for a basic desktop application
    for Windows and Mac OSX.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何为 Windows 和 Mac OSX 的基本桌面应用程序创建项目。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Projects can be created using a powerful tool called TinderBox. TinderBox comes
    bundled in your Cinder download and contains templates for creating projects for
    different applications for both Microsoft Visual C++ 2010 and OSX Xcode.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个名为 TinderBox 的强大工具来创建项目。TinderBox 包含在您的 Cinder 下载中，并为 Microsoft Visual
    C++ 2010 和 OSX Xcode 提供了创建不同应用程序项目的模板。
- en: To find Tinderbox, go to your Cinder folder, inside which you will find a folder
    named `tools` with, TinderBox application in it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 Tinderbox，请转到您的 Cinder 文件夹，其中包含一个名为 `tools` 的文件夹，其中包含 TinderBox 应用程序。
- en: '![Getting ready](img/8703OS_1_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/8703OS_1_1.jpg)'
- en: The first time you open TinderBox, you'll be asked to specify the folder where
    you installed Cinder. You'll need to do this only the first time you open TinderBox.
    If you need to redefine the location of Cinder installation, you can do so by
    selecting the **File** menu and then **Preferences** on Windows or selecting the
    **TinderBox** menu and then **Preferences** on OS X.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次打开 TinderBox 时，您将被要求指定 Cinder 的安装文件夹。您只需在第一次打开 TinderBox 时这样做。如果您需要重新定义 Cinder
    安装的位置，您可以通过选择**文件**菜单然后选择**首选项**在 Windows 上，或者在 OS X 上选择**TinderBox**菜单然后选择**首选项**来完成。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    for the easy creation of projects. Perform the following steps to create a project
    for a basic application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 TinderBox，这是一个与 Cinder 一起捆绑提供的实用工具，它允许轻松创建项目。按照以下步骤创建一个基本应用程序的项目：
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **BasicApp** as **Target** and **OpenGL** as **Template**, as shown
    in the following screenshot:![How to do it…](img/8703OS_1_2.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 TinderBox 并选择您项目的位置。在主 **TinderBox** 窗口中，选择**目标**为 **BasicApp**，**模板**为 **OpenGL**，如下面的截图所示：![如何操作…](img/8703OS_1_2.jpg)
- en: Choose your project's location. The **Naming Prefix** and **Project Name** fields
    will default to the project's name, as shown in the following screenshot:![How
    to do it…](img/8703OS_1_3.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您项目的位置。**命名前缀**和**项目名称**字段将默认为项目名称，如下面的截图所示：![如何操作…](img/8703OS_1_3.jpg)
- en: Select the compilers you want to use for your project, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.![How to do it…](img/8703OS_1_4.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您项目要使用的编译器，可以是 Microsoft Visual C++ 2010 和/或 OS X Xcode。![如何操作…](img/8703OS_1_4.jpg)
- en: Click on the **Create** button and TinderBox will show you the folder where
    your new project is located. TinderBox will remain open; you can close it now.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮，TinderBox 将显示您新项目所在的文件夹。TinderBox 将保持打开状态；您现在可以关闭它。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: TinderBox will create the selected projects for the chosen platforms (Visual
    C++ 2010 and OS X Xcode) and create references to the compiled Cinder library.
    It will also create the application's class as a subclass of `ci::app::AppBasic`.
    It will also create some sample code with a basic example to help you get started.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TinderBox将为所选平台（Visual C++ 2010和OS X Xcode）创建所选项目，并创建编译的Cinder库的引用。它还将创建应用程序类，并将其作为`ci::app::AppBasic`的子类。它还将创建一些带有基本示例的示例代码，以帮助你开始。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Your project name and naming prefix will be, by default, the name of the folder
    in which the project is being created. You can edit this if you want, but always
    make sure both **Project Name** and **Naming Prefix** fields do not have spaces
    as you might get errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你的项目名称和命名前缀将是创建项目所在的文件夹名称。如果你想编辑，可以这样做，但请确保**项目名称**和**命名前缀**字段没有空格，否则可能会出错。
- en: The naming prefix will be used to name your application's class by adding the
    `App` suffix. For example, if you set your **Naming Prefix** field as `MyCinderTest`,
    your application's class will be `MyCinderTestApp`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命名前缀将被用来通过添加`App`后缀来命名你的应用程序类。例如，如果你将**命名前缀**字段设置为`MyCinderTest`，你的应用程序类将是`MyCinderTestApp`。
- en: Creating a project for a screensaver application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建屏幕保护程序应用程序的项目
- en: In this recipe, we will learn how to create a project for a desktop screensaver
    for both Windows and Mac OS X.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为Windows和Mac OS X创建桌面屏幕保护程序的项目。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To get ready with TinderBox, please refer to the *Getting ready* section of
    the previous *Creating a project for a basic application* recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备好使用TinderBox，请参阅上一节“为基本应用程序创建项目”中的“准备就绪”部分。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    easy creation of projects. Perform the following steps to create a project for
    a screensaver application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TinderBox，这是一个与Cinder捆绑提供的实用工具，它允许轻松创建项目。按照以下步骤创建一个屏幕保护程序应用程序的项目：
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **Screensaver** as **Target** and **OpenGL** as **Template**, as
    shown in the following screenshot:![How to do it…](img/8703OS_1_5.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开TinderBox并选择你的项目位置。在主**TinderBox**窗口中选择**屏幕保护程序**作为**目标**，选择**OpenGL**作为**模板**，如图所示：![如何操作…](img/8703OS_1_5.jpg)
- en: Select the compilers you want to create a project to, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建项目的编译器，可以是Microsoft Visual C++ 2010和/或OS X Xcode。
- en: Click on **Create** and TinderBox will direct you to the folder where your project
    was created.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**，TinderBox将引导你到创建项目所在的文件夹。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: TinderBox will create both a project for you and link it against the compiled
    Cinder library. It will also create the application's class and make it a subclass
    of `ci::app::AppScreenSaver`, which is the class with all the basic functionality
    for a screensaver application. It will also create some sample code with a basic
    example to help you get started.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TinderBox将为你创建一个项目，并将其链接到编译的Cinder库。它还将创建应用程序类，并将其作为`ci::app::AppScreenSaver`的子类，这是具有屏幕保护程序应用程序所有基本功能的类。它还将创建一些带有基本示例的示例代码，以帮助你开始。
- en: Creating a project for an iOS touch application
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建iOS触摸应用程序的项目
- en: In this recipe, we'll learn how to create a project for an application that
    runs on iOS devices such as iPhone and iPad.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为在iOS设备（如iPhone和iPad）上运行的应用程序创建项目。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To get ready with TinderBox, please refer to the *Getting ready* section of
    the *Creating a project for a basic application* recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备好使用TinderBox，请参阅“为基本应用程序创建项目”食谱中的“准备就绪”部分。
- en: Please note that the iOS touch application will only work on iOS devices such
    as iPhones and iPads, and that the projects created with TinderBox will be for
    OSX Xcode only.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，iOS触摸应用程序只能在iOS设备（如iPhone和iPad）上运行，并且使用TinderBox创建的项目仅适用于OSX Xcode。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    easy creation of projects. Perform the following steps to create a project for
    an iOS touch application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TinderBox，这是一个与Cinder捆绑提供的实用工具，它允许轻松创建项目。按照以下步骤创建一个iOS触摸应用程序的项目：
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **Cocoa Touch** as **Target** and **Simple** as **Template**, as
    shown in the following screenshot:![How to do it…](img/8703OS_1_6.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开TinderBox，选择您项目的位置。在主**TinderBox**窗口中，选择**Cocoa Touch**作为**目标**，选择**简单**作为**模板**，如图所示：![如何实现…](img/8703OS_1_6.jpg)
- en: Select the compilers you want to create a project to, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要创建项目的编译器，无论是Microsoft Visual C++ 2010还是OS X Xcode。
- en: Click on **Create** and TinderBox will direct you to the folder where your project
    was created.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**，TinderBox将指导您到创建项目所在的文件夹。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: TinderBox will create an OS X Xcode project and create the references to link
    against the compiled Cinder library. It will also create the application's class
    as a subclass of `ci::app::AppCocoaTouch`, which is the class with all the basic
    functionality for a screensaver application. It will also create some sample code
    with a basic example to help you get started.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TinderBox将创建一个OS X Xcode项目，并创建对编译后的Cinder库的引用。它还将创建应用程序类，作为`ci::app::AppCocoaTouch`的子类，这是具有屏幕保护程序应用程序所有基本功能的类。它还将创建一些带有基本示例的示例代码，以帮助您开始。
- en: This application is built on top of Apple's Cocoa Touch framework to create
    iOS applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序基于苹果的Cocoa Touch框架构建，用于创建iOS应用程序。
- en: Understanding the basic structure of an application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序的基本结构
- en: 'Your application''s class can have several methods that will be called at different
    points during the execution of the program. The following table lists these methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序类可以在程序执行的不同点调用多个方法。以下表格列出了这些方法：
- en: '| Method | Usage |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用途 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `prepareSettings` | This method is called once at the very beginning of the
    application, before creating the renderer. Here, we may define several parameters
    of the application before the application gets initialized, such as the frame
    rate or the size of the window. If none are specified, the application will initialize
    with default values. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `prepareSettings` | 此方法在应用程序初始化之前，在创建渲染器之前被调用一次。在这里，我们可以在应用程序初始化之前定义一些参数，例如帧率或窗口大小。如果没有指定，应用程序将使用默认值初始化。|'
- en: '| `setup` | This method is called once at the beginning of the application
    lifecycle. Here, you initialize all members and prepare the application for running.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `setup` | 此方法在应用程序生命周期开始时仅被调用一次。在这里，您初始化所有成员并为应用程序的运行做准备。|'
- en: '| `update` | This method is called in a loop during the application''s runtime
    before the `draw` method. It is used to animate and update the states of the application''s
    components. Even though you may update them during the `draw` method, it is recommended
    you keep the update and drawing routines separate as a matter of organization.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 此方法在应用程序运行期间循环调用，在`draw`方法之前。它用于动画和更新应用程序组件的状态。尽管您可以在`draw`方法中更新它们，但出于组织上的考虑，建议您将更新和绘图例程分开。|'
- en: '| `draw` | This method is called in a loop during the application''s runtime
    after the update. All drawing code should be placed here. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `draw` | 此方法在应用程序运行期间更新之后循环调用。所有绘图代码都应该放在这里。|'
- en: '| `shutdown` | This method is called just before the application exits. Use
    it to do any necessary cleanup such as freeing memory and allocated resources
    or shutting down hardware devices. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `shutdown` | 此方法在应用程序退出之前被调用。使用它来执行任何必要的清理，例如释放内存和分配的资源或关闭硬件设备。|'
- en: To execute our code, we must overwrite these methods with our own code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行我们的代码，我们必须用我们自己的代码覆盖这些方法。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is not mandatory to override all of the preceding methods; you can use the
    ones that your application requires specifically. For example, if you do not want
    to do any drawing, you may omit the `draw` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不必覆盖所有前面的方法；您可以使用应用程序特定需要的那些。例如，如果您不想进行任何绘图，可以省略`draw`方法。
- en: In this recipe and for the sake of learning, we will implement all of them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，为了学习目的，我们将实现所有这些方法。
- en: 'Declare the following methods in your class declaration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的类声明中声明以下方法：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will implement several methods that make up the basic structure of an application.
    Perform the following steps to do so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现几个方法，这些方法构成了应用程序的基本结构。执行以下步骤以实现：
- en: 'Implement the `prepareSettings` method. Here we can define, for example, the
    size of the window, its title, and the frame rate:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`prepareSettings`方法。在这里，我们可以定义，例如，窗口的大小、其标题和帧率：
- en: '[PRE1]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the `setup` method. Here we should initialize all members of the
    application''s class. For example, to initialize capturing from a webcam we would
    declare the following members:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setup`方法。在这里，我们应该初始化应用程序类的所有成员。例如，为了初始化从网络摄像头捕获，我们会声明以下成员：
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `update` method. As an example, we will print the current frame
    count to the console:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现更新`update`方法。例如，我们将打印当前帧数到控制台：
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the `draw` method with all the drawing commands. Here we clear the
    background with black and draw a red circle:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有绘图命令实现`draw`方法。在这里，我们用黑色清除背景并绘制一个红色圆圈：
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implement the `shutdown` method. This method should take code for doing cleanup,
    for example, to shut down threads or save the state of your application.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现关闭`shutdown`方法。此方法应包含清理代码，例如，关闭线程或保存应用程序的状态。
- en: 'Here''s a sample code for saving some parameters in an XML format:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个将一些参数保存为XML格式的示例代码：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our application's superclass implements the preceding methods as virtual empty
    methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的超类实现了前面的方法作为虚拟空方法。
- en: When the application runs, these methods are called, calling our own code we
    implemented or the parent class' empty method if we didn't.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，会调用这些方法，调用我们实现的代码或如果未实现，则调用父类的空方法。
- en: In step 1 we defined several application parameters in the `prepareSettings`
    method. It is not recommended to use the `setup` method to initialize these parameters,
    as it means that the renderer has to be initialized with the default values and
    then readjusted during the setup. The result is extra initialization time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们在`prepareSettings`方法中定义了几个应用程序参数。不建议使用`setup`方法来初始化这些参数，因为这意味着渲染器必须使用默认值初始化，然后在设置过程中进行调整。结果是额外的初始化时间。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are other callbacks that respond to user input such as mouse and keyboard
    events, resizing of the window, and dragging files onto the application window.
    These are described in more detail in the *Responding to mouse input*, *Responding
    to key input*, *Responding to touch input*, *Accessing files dragged on the application
    window*, and *Adjusting a scene after resizing the window* recipes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他回调响应用户输入，如鼠标和键盘事件、窗口大小调整以及将文件拖放到应用程序窗口上。这些在*响应鼠标输入*、*响应键盘输入*、*响应触摸输入*、*访问拖放到应用程序窗口上的文件*和*调整窗口大小后的场景*配方中进行了更详细的描述。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn how to create a basic app with TinderBox, read the *Creating a project
    for a basic application* recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用TinderBox创建基本应用程序，请阅读*为基本应用程序创建项目*配方。
- en: Responding to mouse input
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应鼠标输入
- en: An application can respond to mouse interaction through several event handlers
    that are called depending on the action being performed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过几个事件处理程序响应鼠标交互，这些处理程序根据执行的操作而调用。
- en: 'The existing handlers that respond to mouse interaction are listed in the following
    table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了响应鼠标交互的现有处理程序：
- en: '| Method | Usage |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mouseDown` | This is called when the user presses a mouse button |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `mouseDown` | 当用户按下鼠标按钮时调用 |'
- en: '| `mouseUp` | This is called when the user releases a mouse button |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `mouseUp` | 当用户释放鼠标按钮时调用 |'
- en: '| `mouseWheel` | This is called when the user rotates the mouse wheel |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `mouseWheel` | 当用户旋转鼠标滚轮时调用 |'
- en: '| `mouseMove` | This is called when the mouse is moved without any button pressed
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `mouseMove` | 当鼠标移动而没有按钮按下时调用 |'
- en: '| `mouseDrag` | This is called when the mouse is moved with any button pressed
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `mouseDrag` | 当鼠标移动时按下任何按钮时调用 |'
- en: It is not mandatory to implement all of the preceding methods; you can implement
    only the ones required by your application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实现前面的所有方法不是强制性的；您只需实现应用程序所需的方法。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Implement the necessary event handlers according to the mouse events you need
    to respond to. For example, to create an application that responds to all available
    mouse events, you must implement the following code inside your main class declaration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您需要响应的鼠标事件实现必要的处理程序。例如，要创建一个响应所有可用鼠标事件的应用程序，您必须在主类声明中实现以下代码：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `MouseEvent` object passed as a parameter contains information about the
    mouse event.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递的`MouseEvent`对象包含有关鼠标事件的信息。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will learn how to work with the `ci::app::MouseEvent` class to respond to
    mouse events. Perform the following steps to do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 `ci::app::MouseEvent` 类来响应鼠标事件。执行以下步骤来完成此操作：
- en: 'To get the position where the event has happened, in terms of screen coordinates,
    we can type in the following line of code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取事件发生的屏幕坐标位置，可以输入以下代码行：
- en: '[PRE7]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or we can get the separate x and y coordinates by calling the `getX` and `getY`
    methods:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以通过调用 `getX` 和 `getY` 方法来获取单独的 x 和 y 坐标：
- en: '[PRE8]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `MouseEvent` object also lets us know which mouse button triggered the event
    by calling the `isLeft`, `isMiddle`, or `isRight` methods. They return a `bool`
    value indicating if it was the left, middle, or right button, respectively.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MouseEvent` 对象还通过调用 `isLeft`、`isMiddle` 或 `isRight` 方法来告诉我们哪个鼠标按钮触发了事件。它们返回一个
    `bool` 值，分别指示是否是左键、中键或右键。'
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To know if the event was triggered by pressing a mouse button, we can call the
    `isLeftDown`, `isRightDown`, and `isMiddleDown` methods that return `true` depending
    on whether the left, right, or middle buttons of the mouse were pressed.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要知道事件是否是由按下鼠标按钮触发的，我们可以调用 `isLeftDown`、`isRightDown` 和 `isMiddleDown` 方法，这些方法根据鼠标的左键、右键或中键是否被按下返回
    `true`。
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getWheelIncrement` method returns a `float` value with the movement increment
    of the mouse wheel.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getWheelIncrement` 方法返回一个表示鼠标滚轮移动增量的 `float` 值。'
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is also possible to know if a special key was being pressed during the event.
    The `isShiftDown` method returns `true` if the *Shift* key was pressed, the `isAltDown`
    method returns `true` if the *Alt* key was pressed, `isControlDown` returns `true`
    if the *control* key was pressed, and `isMetaDown` returns `true` if the Windows
    key was pressed on Windows or the *option* key was pressed on OS X, `isAccelDown`
    returns `true` if the *Ctrl* key was pressed on Windows or the *command* key was
    pressed on OS X.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以知道在事件期间是否按下了特殊键。`isShiftDown` 方法在按下 *Shift* 键时返回 `true`，`isAltDown` 方法在按下
    *Alt* 键时返回 `true`，`isControlDown` 在按下 *control* 键时返回 `true`，`isMetaDown` 在 Windows
    上按下 Windows 键或在 OS X 上按下 *option* 键时返回 `true`，`isAccelDown` 在 Windows 上按下 *Ctrl*
    键或在 OS X 上按下 *command* 键时返回 `true`。
- en: How it works
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: A Cinder application responds internally to the system's native mouse events.
    It then creates a `ci::app::MouseEvent` object using the native information and
    calls the necessary mouse event handlers of our application's class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder 应用内部响应系统的原生鼠标事件。然后，它使用原生信息创建一个 `ci::app::MouseEvent` 对象，并调用应用程序类必要的鼠标事件处理器。
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is also possible to access the native modifier mask by calling the `getNativeModifiers`
    method. These are platform-specific values that Cinder uses internally and may
    be of use for advanced uses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过调用 `getNativeModifiers` 方法来访问原生修饰符掩码。这些是 Cinder 内部使用的平台特定值，可能对高级应用有所帮助。
- en: Responding to key input
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应按键输入
- en: A Cinder application can respond to key events through several callbacks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder 应用可以通过多个回调来响应按键事件。
- en: 'The available callbacks that get called by keyboard interaction are listed
    in the following table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了由键盘交互触发的可用回调：
- en: '| Method | Usage |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `keyDown` | This is called when the user first presses a key and called repeatedly
    if a key is kept pressed. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `keyDown` | 当用户首次按下键时调用，如果键被持续按下，则重复调用。 |'
- en: '| `keyUp` | This is called when a key is released. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `keyUp` | 当按键释放时调用。 |'
- en: Both these methods receive a `ci::app::KeyEvent` object as a parameter with
    information about the event such as the key code being pressed or if any special
    key (such as *Shift* or *control*) is being pressed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都接收一个 `ci::app::KeyEvent` 对象作为参数，其中包含有关事件的信息，例如按下的键码或是否按下了任何特殊键（如 *Shift*
    或 *control*）。
- en: It is not mandatory to implement all of the preceding key event handlers; you
    can implement only the ones that your application requires.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有前面的按键事件处理器不是强制性的；你可以只实现应用程序需要的那些。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Implement the necessary event handlers according to what key events you need
    to respond to. For example, to create an application that responds to both key
    down and key up events, you must declare the following methods:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要响应的按键事件实现必要的事件处理器。例如，要创建一个响应键按下和键释放事件的程序，必须声明以下方法：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ci::app::KeyEvent` parameter contains information about the key event.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::app::KeyEvent` 参数包含有关按键事件的信息。'
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will learn how to work with the `ci::app::KeyEvent` class to learn how to
    understand key events. Perform the following steps to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 `ci::app::KeyEvent` 类来了解如何理解按键事件。执行以下步骤：
- en: 'To get the ASCII code of the character that triggered the key event, you can
    type in the following line of code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取触发按键事件的字符的ASCII码，你可以输入以下代码行：
- en: '[PRE13]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To respond to special keys that do not map to the ASCII character table, we
    must call the `getCode` method that retrieves an `int` value that can be mapped
    to a character table in the `ci::app::KeyEvent` class. To test, for example, if
    the key event was triggered by the *Esc* key you can type in the following line
    of code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要响应不映射到ASCII字符表的特殊键，我们必须调用 `getCode` 方法，该方法检索一个可以映射到 `ci::app::KeyEvent` 类中字符表的
    `int` 值。例如，要测试按键事件是否由 *Esc* 键触发，你可以输入以下代码行：
- en: '[PRE14]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`escPressed` will be `true` if the escape key triggered the event, or `false`
    otherwise.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果Esc键触发了事件，则 `escPressed` 将为 `true`，否则为 `false`。
- en: The `ci::app::KeyEvent` parameter also has information about modifier keys that
    were pressed during the event. The `isShiftDown` method returns `true` if the
    *Shift* key was pressed, `isAltDown` returns `true` if the *Alt* key was pressed,
    `isControlDown` returns `true` if the *control* key was pressed, `isMetaDown`
    returns `true` if the Windows key was pressed on Windows or the *command* key
    was pressed on OS X, and `isAccelDown` returns `true` if the *Ctrl* key was pressed
    on Windows or the *command* key was pressed on OS X.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ci::app::KeyEvent` 参数还包含有关在事件期间按下的修饰键的信息。`isShiftDown` 方法在按下 *Shift* 键时返回
    `true`，`isAltDown` 在按下 *Alt* 键时返回 `true`，`isControlDown` 在按下 *control* 键时返回 `true`，`isMetaDown`
    在Windows上按下Windows键或在OS X上按下 *command* 键时返回 `true`，而 `isAccelDown` 在Windows上按下
    *Ctrl* 键或在OS X上按下 *command* 键时返回 `true`。'
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A Cinder application responds internally to the system's native key events.
    When receiving a native key event, it creates a `ci::app::KeyEvent` object based
    on the native information and calls the correspondent callback on our application's
    class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序内部响应系统的原生按键事件。当接收到原生按键事件时，它基于原生信息创建一个 `ci::app::KeyEvent` 对象，并在我们的应用程序类上调用相应的回调。
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is also possible to access the native key code by calling the `getNativeKeyCode`
    method. This method returns an `int` value with the native, platform-specific
    code of the key. It can be important for advanced uses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过调用 `getNativeKeyCode` 方法来访问原生键码。此方法返回一个包含键的原生、平台特定代码的 `int` 值。对于高级用途来说，这可能很重要。
- en: Responding to touch input
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应触摸输入
- en: A Cinder application can receive several touch events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序可以接收多个触摸事件。
- en: 'The available touch event handlers that get called by touch interaction are
    listed in the following table:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中列出了由触摸交互调用的可用触摸事件处理器：
- en: '| Method | Usage |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `touchesBegan` | This is called when new touches are detected |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `touchesBegan` | 当检测到新的触摸时调用此方法 |'
- en: '| `touchesMoved` | This is called when existing touches move |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `touchesMoved` | 当现有触摸移动时调用此方法 |'
- en: '| `touchesEnded` | This is called when existing touches are removed |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `touchesEnded` | 当现有触摸被移除时调用此方法 |'
- en: All of the preceding methods receive a `ci::app::TouchEvent` object as a parameter
    with a `std::vector` of `ci::app::TouchEvent::Touch` objects with information
    about each touch detected. Since many devices can detect and respond to several
    touches simultaneously, it is possible and common for a touch event to contain
    several touches.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面方法都接收一个 `ci::app::TouchEvent` 对象作为参数，该对象包含一个 `std::vector`，其中包含 `ci::app::TouchEvent::Touch`
    对象，包含每个检测到的触摸信息。由于许多设备可以同时检测和响应多个触摸，因此触摸事件可能包含多个触摸是可能且常见的。
- en: It is not mandatory to implement all of the preceding event handlers; you can
    use the ones your application requires specifically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有前面的事件处理器不是强制性的；你可以使用你应用程序特别需要的那些。
- en: Cinder applications can respond to touch events on any touch-enabled device
    running Windows 7, OS X, or iOS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序可以响应在运行Windows 7、OS X或iOS的任何触摸设备上的触摸事件。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Implement the necessary touch event handlers according to the touch events
    you want to respond to. For example, to respond to all available touch events
    (touches added, touches moved, and touches removed), you would need to declare
    and implement the following methods:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要响应的触摸事件实现必要的触摸事件处理器。例如，要响应所有可用的触摸事件（触摸添加、触摸移动和触摸移除），你需要声明并实现以下方法：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will learn how to work with the `ci::app::TouchEvent` class to understand
    touch events. Perform the following steps to do so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用`ci::app::TouchEvent`类来理解触摸事件。执行以下步骤来完成此操作：
- en: 'To access the list of touches, you can type in the following line of code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问触摸列表，您可以输入以下代码行：
- en: '[PRE16]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Iterate through the container to access each individual element.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遍历容器以访问每个单独的元素。
- en: '[PRE17]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can get the position of a touch by calling the `getPos` method that returns
    a `Vec2f` value with its position or using the `getX` and `getY` methods to receive
    the x and y coordinates separately, for example:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过调用返回包含其位置的`Vec2f`值的`getPos`方法来获取触摸的位置，或者使用`getX`和`getY`方法分别接收x和y坐标，例如：
- en: '[PRE18]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `getId` method returns a `uint32_t` value with a unique ID for the `touch`
    object. This ID is persistent throughout the lifecycle of the touch, which means
    you can use it to keep track of a specific touch as you access it on the different
    touch events.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getId`方法返回一个包含`touch`对象的唯一ID的`uint32_t`值。此ID在触摸的生命周期内是持久的，这意味着您可以使用它来跟踪在不同的触摸事件中访问的特定触摸。'
- en: For example, to make an application where we draw lines using our fingers, we
    can create `std::map` that associates each line, in the form of a `ci::PolyLine<Vec2f>`
    object, with a `uint32_t` key with the unique ID of a touch.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要创建一个我们可以用手指画线的应用程序，我们可以创建一个`std::map`，将每条线（以`ci::PolyLine<Vec2f>`对象的形式）与一个`uint32_t`键关联，该键是触摸的唯一ID。
- en: 'We need to include the file with `std::map` and `PolyLine` to our project by
    adding the following code snippet to the beginning of the source file:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要通过在源文件开头添加以下代码片段将包含`std::map`和`PolyLine`的文件包含到我们的项目中：
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now declare the container:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以声明容器：
- en: '[PRE20]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `touchesBegan` method we create a new line for each detected touch and
    map it to the unique ID of each touch:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesBegan`方法中，我们为每个检测到的触摸创建一条新线并将其映射到每个触摸的唯一ID：
- en: '[PRE21]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `touchesMoved` method, we add the position of each touch to its corresponding
    line:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesMoved`方法中，我们将每个触摸的位置添加到其对应的线条中：
- en: '[PRE22]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `touchesEnded` method, we remove the line that corresponds to a touch
    being removed:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesEnded`方法中，我们移除与被移除的触摸对应的线条：
- en: '[PRE23]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the lines can be drawn. Here we clear the background with black and
    draw the lines with in white. The following is the implementation of the `draw`
    method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以绘制线条。在这里，我们用黑色清除背景，用白色绘制线条。以下是对`draw`方法的实现：
- en: '[PRE24]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is a screenshot of our app running after drawing some lines:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们绘制了一些线条后应用程序运行的截图：
- en: '![How to do it…](img/8703OS_1_7.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_1_7.jpg)'
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A Cinder application responds internally to the system calls for any touch event.
    It will then create a `ci::app::TouchEvent` object with information about the
    event and call the corresponding event handler in our application's class. The
    way to respond to touch events becomes uniform across the Windows and Mac platforms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序会内部响应系统对任何触摸事件的调用。然后，它将创建一个包含事件信息的`ci::app::TouchEvent`对象，并调用我们应用程序类中的相应事件处理器。在Windows和Mac平台上，响应触摸事件的方式变得统一。
- en: The `ci::app::TouchEvent` class contains only one accessor method that returns
    a `const` reference to a `std::vector<TouchEvent::Touch>` container. This container
    has one `ci::app::TouchEvent::Touch` object for each detected touch and contains
    information about the touch.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::app::TouchEvent`类只包含一个访问器方法，该方法返回一个对`std::vector<TouchEvent::Touch>`容器的`const`引用。该容器为每个检测到的触摸包含一个`ci::app::TouchEvent::Touch`对象，并包含有关触摸的信息。'
- en: The `ci::app::TouchEvent::Touch` object contains information about the touch
    including position and previous position, unique ID, the time stamp, and a pointer
    to the native event object which maps to `UITouch` on Cocoa Touch and `TOUCHPOINT`
    on Windows 7.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::app::TouchEvent::Touch`对象包含有关触摸的信息，包括位置和前一个位置、唯一ID、时间戳以及指向原生事件对象的指针，该指针映射到Cocoa
    Touch上的`UITouch`和Windows 7上的`TOUCHPOINT`。'
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: At any time, it is also possible to get a container with all active touches
    by calling the `getActiveTouches` method. It returns a `const` reference to a
    `std::vector<TouchEvent::Touch>` container. It offers flexibility when working
    with touch applications as it can be accessed outside the touch event methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，也可以通过调用`getActiveTouches`方法来获取所有活动触摸的容器。它返回一个对`std::vector<TouchEvent::Touch>`容器的`const`引用。当处理触摸应用程序时，它提供了灵活性，因为它可以在触摸事件方法之外访问。
- en: 'For example, if you want to draw a solid red circle around each active touch,
    you can add the following code snippet to your `draw` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在每个活动触摸周围绘制一个实心红色圆圈，你可以在你的`draw`方法中添加以下代码片段：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Accessing files dropped onto the application window
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问拖放到应用程序窗口上的文件
- en: Cinder applications can respond to files dropped onto the application window
    through the callback, `fileDrop` . This method takes a `ci::app::FileDropEvent`
    object as a parameter with information about the event.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序可以通过`fileDrop`回调来响应拖放到应用程序窗口上的文件。此方法接受一个包含事件信息的`ci::app::FileDropEvent`对象作为参数。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Your application must implement a `fileDrop` method which takes a `ci::app::FileDropEvent`
    object as a parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序必须实现一个接受`ci::app::FileDropEvent`对象作为参数的`fileDrop`方法。
- en: 'Add the following method to the application''s class declaration:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到应用程序的类声明中：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will learn how to work with the `ci::app::FileDropEvent` object to work
    with file drop events. Perform the following steps to do so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用`ci::app::FileDropEvent`对象来处理文件拖放事件。执行以下步骤：
- en: 'In the method implementation you can use the `ci::app::FileDropEvent` parameter
    to access the list of files dropped onto the application by calling the `getFiles`
    method. This method returns a `conststd::vector` container with `fs::path` objects:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法实现中，你可以通过调用`getFiles`方法来访问应用程序上拖放的文件列表，使用`ci::app::FileDropEvent`参数。此方法返回一个包含`fs::path`对象的`conststd::vector`容器：
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The position where the files were dropped onto the window can be accessed through
    the following callback methods:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件被拖放到窗口中的位置可以通过以下回调方法访问：
- en: 'To get a `ci::Vec2i` object with the position of the files dropped, type in
    the following line of code:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取包含文件拖放位置的`ci::Vec2i`对象，请输入以下代码行：
- en: '[PRE28]'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To get the x and y coordinates separately, you can use the `getX` and `getY`
    methods, for example:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分别获取x和y坐标，你可以使用`getX`和`getY`方法，例如：
- en: '[PRE29]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can find the number of dropped files by using the `getNumFiles` method:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过使用`getNumFiles`方法来查找拖放文件的数量：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To access a specific file, if you already know its index, you can use the `getFile`
    method and pass the index as a parameter.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问特定文件，如果你已经知道它的索引，你可以使用`getFile`方法并将索引作为参数传递。
- en: 'For example, to access the file with an index of `2`, you can use the following
    line of code:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要访问索引为`2`的文件，你可以使用以下代码行：
- en: '[PRE31]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Cinder application will respond to the system's native event for file drops.
    It will then create a `ci::app::FileDropEvent` object with information about the
    event and call the `fileDrop` callback in our application. This way Cinder creates
    a uniform way of responding to file drop events across the Windows and OS X platforms.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序将响应系统的本地文件拖放事件。然后，它将创建一个包含事件信息的`ci::app::FileDropEvent`对象，并在我们的应用程序中调用`fileDrop`回调。这样，Cinder在Windows和OS
    X平台之间创建了一种统一的响应文件拖放事件的方式。
- en: There's more…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Cinder uses `ci::fs::path` objects to define paths. These are `typedef` instances
    of `boost::filesystem::path` objects and allow for much greater flexibility when
    working with paths. To learn more about the `fs::path` objects, please refer to
    the `boost::filesystem` library reference, available at [http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder使用`ci::fs::path`对象来定义路径。这些是`boost::filesystem::path`对象的`typedef`实例，在处理路径时提供了更大的灵活性。要了解更多关于`fs::path`对象的信息，请参阅[http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm)上的`boost::filesystem`库参考。
- en: Adjusting a scene after resizing the window
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整窗口大小后的场景调整
- en: Cinder applications can respond to resizing the window by implementing the resize
    event. This method takes a `ci::app::ResizeEvent` parameter with information about
    the event.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序可以通过实现调整大小事件来响应窗口调整大小。此方法接受一个包含事件信息的`ci::app::ResizeEvent`参数。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If your application doesn''t have a `resize` method, implement one. In the
    application''s class declaration, add the following line of code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序没有`resize`方法，请实现一个。在应用程序的类声明中添加以下代码行：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the method's implementation, you can use the `ResizeEvent` parameter to find
    information about the window's new size and format.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法实现中，你可以使用`ResizeEvent`参数来获取关于窗口新大小和格式的信息。
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will learn how to work with the `ci::app::ResizeEvent` parameter to respond
    to window resize events. Perform the following steps to do so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用`ci::app::ResizeEvent`参数来响应窗口大小调整事件。执行以下步骤：
- en: To find the new size of the window, you can use the `getSize` method which returns
    a `ci::Vec2iwith` object, the window's width as the x component, and the height
    as the y component.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到窗口的新大小，你可以使用`getSize`方法，该方法返回一个`ci::Vec2iwith`对象，窗口的宽度作为x分量，高度作为y分量。
- en: '[PRE33]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `getWidth and getHeight` methods both return `int` values with the window''s
    width and height respectively, for example:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getWidth`和`getHeight`方法都返回`int`值，分别代表窗口的宽度和高度，例如：'
- en: '[PRE34]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `getAspectRatio` method returns a `float` value with the aspect ratio of
    the window, which is the ratio between its width and height:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAspectRatio`方法返回一个`float`值，表示窗口的宽高比，即其宽度和高度的比例：'
- en: '[PRE35]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Any element on screen that needs adjusting must use the new window size to
    recalculate its properties. For example, to have a rectangle that is drawn at
    the center of the window with a 20 pixel margin on all sides, we must first declare
    a `ci::Rectf` object in the class declaration:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何需要调整的屏幕元素都必须使用新的窗口大小来重新计算其属性。例如，为了有一个在窗口中心绘制且所有边都有20像素边距的矩形，我们必须首先在类声明中声明一个`ci::Rectf`对象：
- en: '[PRE36]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the setup we set its properties so that it has a 20 pixel margin on all
    sides from the window:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置中，我们设置其属性，使其在窗口的所有边都有20像素的边距：
- en: '[PRE37]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To draw the rectangle with a red color, add the following code snippet to the
    `draw` method:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要用红色绘制矩形，请将以下代码片段添加到`draw`方法中：
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `resize` method, we must recalculate the rectangle properties so that
    it resizes itself to maintain the 20 pixel margin on all sides of the window:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resize`方法中，我们必须重新计算矩形的属性，以便它调整大小以保持窗口所有边的20像素边距：
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the application and resize the window. The rectangle will maintain its relative
    size and position according to the window size.![How to do it…](img/8703OS_1_8.jpg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并调整窗口大小。矩形将根据窗口大小保持其相对大小和位置。![如何操作…](img/8703OS_1_8.jpg)
- en: How it works…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A Cinder application responds internally to the system's window resize events.
    It will then create the `ci::app::ResizeEvent` object and call the `resize` method
    on our application's class. This way Cinder creates a uniform way of dealing with
    resize events across the Windows and Mac platforms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder应用程序会内部响应系统的窗口大小调整事件。然后它将创建`ci::app::ResizeEvent`对象，并在我们的应用程序类上调用`resize`方法。这样Cinder创建了一种在Windows和Mac平台之间处理大小调整事件的一致方式。
- en: Using resources on Windows
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上使用资源
- en: It is common for Windows applications to use external files either to load images,
    play audio or video, or to load or save settings on XML files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows应用程序来说，使用外部文件来加载图像、播放音频或视频，或在XML文件中加载或保存设置是很常见的。
- en: Resources are external files to your application that are embedded in the application's
    executable file. Resource files are hidden from the user to avoid alterations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是应用程序的外部文件，它们嵌入在应用程序的可执行文件中。资源文件对用户隐藏，以避免修改。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Resources should be stored in a folder named `resources` in your project folder.
    If this folder does not exist, create it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 资源应存储在项目文件夹中名为`resources`的文件夹中。如果此文件夹不存在，请创建它。
- en: Resources on Windows must be referenced in a file called `Resources.rc`. This
    file should be placed next to the Visual C++ solution in the `vc10` folder. If
    this file does not exist, you must create it as an empty file. If the `resources.rs`
    file is not included already in your project solution, you must add it by right-clicking
    on the **Resources** filter and choosing **Add** and then **ExistingItem**. Navigate
    to the file and select it. As a convention, this file should be kept in the same
    folder as the project solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，资源必须在名为`Resources.rc`的文件中引用。此文件应放置在`vc10`文件夹中，紧邻Visual C++解决方案。如果此文件不存在，你必须创建它作为一个空文件。如果`resources.rs`文件尚未包含在你的项目解决方案中，你必须通过右键单击**资源**过滤器并选择**添加**然后**现有项**来添加它。导航到该文件并选择它。按照惯例，此文件应与项目解决方案在同一文件夹中。
- en: How to do it…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will use Visual C++ 2010 to add resources to our applications on Windows.
    Perform the following steps to do so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Visual C++ 2010向Windows应用程序添加资源。执行以下步骤：
- en: Open the Visual C++ solution and open the `resources.h` file inside the **Header
    Files** filter.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**头文件**过滤器中打开Visual C++解决方案，并打开`resources.h`文件。
- en: Add the `#pragma once` macro to your file to prevent it from being included
    more than once in your project and include the `CinderResources.h` file.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `#pragma once` 宏添加到你的文件中，以防止它在你的项目中多次包含，并包含 `CinderResources.h` 文件。
- en: '[PRE40]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On Windows, each resource must have a unique ID number. As a convention, the
    IDs are defined as sequential numbers starting from 128, but you can use other
    IDs if it suits you better. Make sure to never use the same ID twice. You must
    also define a type string. The type string is used to identify resources of the
    same type, for example, the string `IMAGE` may be used when declaring image resources,
    `VIDEO` for declaring video resources, and so on.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，每个资源都必须有一个唯一的 ID 号。按照惯例，ID 被定义为从 128 开始的连续数字，但如果你有更好的选择，可以使用其他 ID。务必确保不要重复使用相同的
    ID。你还必须定义一个类型字符串。类型字符串用于识别同一类型的资源，例如，在声明图像资源时可以使用字符串 `IMAGE`，声明视频资源时使用 `VIDEO`
    等。
- en: To simplify writing multiplatform code, Cinder has a macro for declaring resources
    that can be used on both Windows and Mac.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化编写多平台代码，Cinder 有一个宏可以声明在 Windows 和 Mac 上都可以使用的资源。
- en: 'For example, to declare the resource of an image file named `image.png`, we
    would type in the following line of code:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要声明名为 `image.png` 的图像文件的资源，我们会在以下代码行中输入：
- en: '[PRE41]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first parameter of the `CINDER_RESOURCE` macro is the relative path to the
    folder where the resource file is, in this case the default `resources` folder.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CINDER_RESOURCE` 宏的第一个参数是资源文件所在文件夹的相对路径，在这种情况下是默认的 `resources` 文件夹。'
- en: The second parameter is the name of the file, and after that comes the unique
    ID of this resource, and finally its type string.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个参数是文件名，之后是此资源的唯一 ID，最后是其类型字符串。
- en: 'Now we need to add our `resources` macro to the `resources.rs` file, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的 `resources` 宏添加到 `resources.rs` 文件中，如下所示：
- en: '[PRE42]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This resource is now ready to be used in our application. To load this image
    into `ci::gl::Texture` we simply include the `Texture.h` file in our application''s
    source code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此资源现在已准备好在我们的应用程序中使用。要将此图像加载到 `ci::gl::Texture` 中，我们只需在我们的应用程序源代码中包含 `Texture.h`
    文件：
- en: '[PRE43]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now declare the texture:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以声明纹理：
- en: '[PRE44]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the setup, we create the texture by loading the resource:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中，我们通过加载资源创建纹理：
- en: '[PRE45]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The texture is now ready to be drawn on screen. To draw the image at position
    (20, 20), we will type in the following line of code inside the `draw` method:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纹理现在已准备好在屏幕上绘制。要在位置 (20, 20) 绘制图像，我们将在 `draw` 方法内部输入以下代码行：
- en: '[PRE46]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `resources.rc` file is used by a resource compiler to embed resources into
    the executable file as binary data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources.rc` 文件由资源编译器使用，将资源嵌入到可执行文件中作为二进制数据。'
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Cinder allows writing code to use resources that is coherent across all supported
    platforms, but the way resources are handled on Windows and OS X/iOS is slightly
    different. To learn how to use resources on a Mac, please read the *Using resources
    on iOS and OS X* recipe.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder 允许编写代码以使用资源，这些资源在所有支持的平台上是一致的，但在 Windows 和 OS X/iOS 上处理资源的方式略有不同。要了解如何在
    Mac 上使用资源，请阅读 *在 iOS 和 OS X 上使用资源* 烹饪配方。
- en: Using resources on iOS and OS X
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 iOS 和 OS X 上使用资源
- en: It is common for Windows applications to use external files either to load images,
    play audio or video, or to load or save settings on XML files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 应用程序来说，使用外部文件来加载图像、播放音频或视频，或在 XML 文件上加载或保存设置是很常见的。
- en: Resources are external files to your application that are included in the applications
    bundle. Resource files are hidden from the user to avoid alterations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是应用程序外部文件，包含在应用程序包中。资源文件对用户隐藏，以避免修改。
- en: Cinder allows writing code to use resources that is equal when writing Windows
    or Mac applications, but the way resources are handled is slightly different.
    To learn how to use resources on Windows, please read the *Using resources on
    Windows* recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder 允许编写代码以使用资源，这种方式在编写 Windows 或 Mac 应用程序时是相同的，但处理资源的方式略有不同。要了解如何在 Windows
    上使用资源，请阅读 *在 Windows 上使用资源* 烹饪配方。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Resources should be stored in a folder named `resources` in your `project` folder.
    If this folder does not exist, create it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 应将资源存储在 `project` 文件夹中名为 `resources` 的文件夹中。如果此文件夹不存在，请创建它。
- en: How to do it…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will use Xcode to add resources to our application on iOS and OS X. Perform
    the following steps to do so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Xcode 在 iOS 和 OS X 上添加资源到我们的应用程序。执行以下步骤：
- en: Place any resource file you wish to use in the `resources` folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何你希望使用的资源文件放置在 `resources` 文件夹中。
- en: Add these files to your project by right-clicking on the **Resources** filter
    in your Xcode project and selecting **Add** and then **ExistingFiles**, navigate
    to the `resources` folder, and select the resource files you wish to add.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Xcode 项目的 **Resources** 过滤器上右键单击并选择 **添加** 然后选择 **现有文件**，导航到 `resources`
    文件夹，并选择你想要添加的资源文件。
- en: 'To load a resource in your code, you use the `loadResource` method and pass
    the name of the resource file. For example, to load an image named `image.png`,
    you should first create the `gl::Texture` member in the class declaration:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在你的代码中加载资源，你使用 `loadResource` 方法并传递资源文件的名称。例如，要加载名为 `image.png` 的图像，你应在类声明中首先创建
    `gl::Texture` 成员：
- en: '[PRE47]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `setup` method, we initialize the texture with the following resource:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，我们使用以下资源初始化纹理：
- en: '[PRE48]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The texture is now ready to be drawn in the window. To draw it at position
    (20, 20), type in the following line of code inside the `draw` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纹理现在已准备好在窗口中绘制。要在位置 (20, 20) 绘制它，请在 `draw` 方法中输入以下代码行：
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: On iOS and OS X, applications are actually folders that contain all the necessary
    files to run the application, such as the Unix executable file, the frameworks
    used, and the resources. You can access the content of these folders by clicking
    on any Mac application and selecting **Show Package Contents**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 和 OS X 上，应用程序实际上是包含运行应用程序所需所有文件的文件夹，例如 Unix 可执行文件、使用的框架和资源。你可以通过点击任何 Mac
    应用程序并选择 **显示包内容** 来访问这些文件夹的内容。
- en: When you add resources to the `resources` folder in your Xcode project, these
    files are copied during the build stage to the `resources` folder of your application
    bundle.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的 Xcode 项目中的 `resources` 文件夹中添加资源时，这些文件会在构建阶段被复制到你的应用程序包的 `resources` 文件夹中。
- en: There's more...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容……
- en: You can also load resources using the same `loadResource` method that is used
    in Windows applications. This is very useful when writing cross-platform applications
    so that no changes are necessary in your code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用在 Windows 应用程序中使用的相同 `loadResource` 方法来加载资源。这对于编写跨平台应用程序非常有用，这样你的代码就不需要做任何更改。
- en: 'You should create the `resource` macro in the `Resources.h` file, and add the
    unique resource ID and its type string. For example, to load the image `image.png`,
    you can type in the following code snippet:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `Resources.h` 文件中创建 `resource` 宏，并添加唯一资源 ID 及其类型字符串。例如，要加载图像 `image.png`，你可以输入以下代码片段：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And this is what the `Resources.rc` file should look like:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Resources.rc` 文件应该看起来像的：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the preceding example to load an image, the only difference is that we
    would load the texture with the following line of code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的示例来加载图像，唯一的区别是我们将使用以下代码行来加载纹理：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The resource unique ID and type string will be ignored in Mac applications,
    but adding them allows creating code that is cross-platform.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 资源唯一 ID 和类型字符串在 Mac 应用程序中将被忽略，但添加它们允许创建跨平台代码。
- en: Using assets
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源
- en: In this recipe, we will learn how we can load and use assets.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习我们如何加载和使用资源。
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As an example for this recipe, we will load and display an asset image.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个菜谱的示例，我们将加载并显示一个资源图像。
- en: Place an image file inside the `assets` folder in your project directory and
    name it `image.png`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中的 `assets` 文件夹内放置一个图像文件，并将其命名为 `image.png`。
- en: 'Include the following files at the top of your source code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的源代码顶部包含以下文件：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Also add the following useful `using` statements:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 还应添加以下有用的 `using` 语句：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it…
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'As an example, we will learn how we can load and display an image asset. Perform
    the following steps to do so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将学习我们如何加载并显示图像资源。执行以下步骤：
- en: 'Declare a `ci::gl::Texture` object:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `ci::gl::Texture` 对象：
- en: '[PRE55]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `setup` method let's load the image asset. We will use a `try/catch`
    block in if it is not possible to load the asset.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，让我们加载图像资源。如果无法加载资源，我们将使用 `try/catch` 块。
- en: '[PRE56]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `draw` method we will draw the texture. We will use an `if` statement
    to check if the texture has been successfully initialized:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，我们将绘制纹理。我们将使用一个 `if` 语句来检查纹理是否已成功初始化：
- en: '[PRE57]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The first application uses an asset Cinder, which will try to find its default
    `assets` folder. It will begin by searching the executable or application bundle
    folder, depending on the platform, and continue searching its parent's folder
    up to five levels. This is done to accommodate for different project setups.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应用使用了一个名为Cinder的资产，它将尝试找到其默认的`assets`文件夹。它将首先在可执行文件或应用程序包文件夹中搜索，具体取决于平台，然后继续向上搜索其父文件夹，最多五层。这样做是为了适应不同的项目设置。
- en: There's more…
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can add an additional `assets` folder using the `addAssetDirectory` method,
    which takes a `ci::fs::path` object as a parameter. Every time Cinder searches
    for an asset, it will first look in its default `asset` folder and then in every
    folder the user may have added.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`addAssetDirectory`方法添加一个额外的`assets`文件夹，该方法接受一个`ci::fs::path`对象作为参数。每次Cinder搜索资产时，它都会首先在其默认的`asset`文件夹中查找，然后查找用户可能添加的每个文件夹。
- en: 'You can also create subfolders inside the `assets` folder, for example, if
    our image was inside a subfolder named `My Images`, we would type in the following
    code snippet in the `setup` method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`assets`文件夹内创建子文件夹，例如，如果我们的图片位于名为`My Images`的子文件夹中，我们就会在`setup`方法中输入以下代码片段：
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It is also possible to know the path where a specific folder lies. To do this,
    use the `getAssetPath` method, which takes a `ci::fs::path` object as a parameter
    with the name of the file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以知道特定文件夹的路径。为此，使用`getAssetPath`方法，该方法接受一个带有文件名的`ci::fs::path`对象作为参数。
