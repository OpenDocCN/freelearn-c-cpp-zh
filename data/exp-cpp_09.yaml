- en: Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: '**Object-Oriented Programming** (**OOP**) provides us with a way of thinking
    about objects, thus expressing the real world in terms of classes and their relationships.
    Functional programming is a completely different programming paradigm as it allows
    us to concentrate on the *functional* structure rather than the *physical* structure
    of code. Learning and using functional programming are useful in two ways. First,
    it is a new paradigm that forces you to think very differently. Solving problems
    requires having flexible thinking. People that are attached to a single paradigm
    tend to provide similar solutions to any problem, while most elegant solutions
    require a wider approach. Mastering functional programming provides developers
    with a new skill that helps them provide even better solutions to problems. Secondly,
    using functional programming reduces the number of bugs in software. One of the
    biggest reasons for that functional programming''s unique approach: it decomposes
    programs into functions, each of which doesn''t modify the state of the data.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）为我们提供了一种思考对象的方式，从而以类和它们的关系来表达现实世界。函数式编程是一种完全不同的编程范式，因为它允许我们专注于*功能*结构而不是代码的*物理*结构。学习和使用函数式编程有两种用途。首先，它是一种迫使你以非常不同的方式思考的新范式。解决问题需要灵活的思维。附着于单一范式的人往往对任何问题提供类似的解决方案，而大多数优雅的解决方案需要更广泛的方法。掌握函数式编程为开发人员提供了一种新的技能，帮助他们提供更好的解决方案。其次，使用函数式编程可以减少软件中的错误数量。其中最大的原因之一是函数式编程的独特方法：它将程序分解为函数，每个函数都不修改数据的状态。'
- en: We will discuss the fundamental blocks of functional programming in this chapter,
    along with ranges. Introduced in C++20, ranges provide us with a great way to
    compose algorithms so that they work with collections of data. Composing algorithms
    so that we can apply them to this collection of data sequentially is at the heart
    of functional programming. That's why we'll also discuss ranges in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数式编程的基本模块，以及范围。在C++20中引入的范围为我们提供了一种很好的方式，以便将算法组合起来，使它们能够处理数据集合。将算法组合起来，以便我们可以将它们顺序应用于这些数据集合，这是函数式编程的核心。这就是为什么我们在本章中还将讨论范围。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程介绍
- en: Introduction to the ranges library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍范围库
- en: Pure functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Higher-order functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Delving more deeply into recursion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入递归
- en: Metaprogramming in functional C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式C++中的元编程
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler, along with the `-std=c++2a` option, will be used to compile
    the examples in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，将使用g++编译器以及`-std=c++2a`选项。
- en: You can find the source files for this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章的源文件。
- en: Unveiling functional programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示函数式编程
- en: As we mentioned earlier, functional programming is a programming paradigm. You
    can think of a paradigm as a way of thinking when constructing programs. C++ is
    a multi-paradigm language. We can use it to develop programs in a procedural paradigm,
    that is, by executing statements one after one another. In Chapter 3, *Details
    of Object-Oriented Programming*, we discussed the object-oriented approach, which
    involves decomposing a complex system into intercommunicating objects. Functional
    programming, on the other hand, encourages us to decompose the system into functions
    rather than objects. It operates with expressions rather than statements. Basically,
    you take something as input and pass it to a function that produces an output.
    This can then be used as input for another function. This might seem simple at
    first, but functional programming incorporates several rules and practices that
    feel hard to grasp initially. However, when you manage this, your brain will unlock
    a new way of thinking – the functional way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，函数式编程是一种编程范式。您可以将范式视为构建程序时的一种思维方式。C++是一种多范式语言。我们可以使用它以过程范式开发程序，即通过依次执行语句来执行。在第3章《面向对象编程的细节》中，我们讨论了面向对象的方法，它涉及将复杂系统分解为相互通信的对象。另一方面，函数式编程鼓励我们将系统分解为函数而不是对象。它使用表达式而不是语句。基本上，您将某些东西作为输入，并将其传递给生成输出的函数。然后可以将其用作另一个函数的输入。这乍看起来可能很简单，但函数式编程包含了一些一开始感觉难以掌握的规则和实践。然而，当您掌握了这一点，您的大脑将解锁一种新的思维方式——函数式方式。
- en: To make this a bit clearer, let's start with an example that will demonstrate
    the essence of functional programming. Let's suppose we have been given a list
    of integers and need to count the number of even numbers in it. The only catch
    is that there are several such vectors. We should count the even numbers in all
    vectors separately and produce a result as a new vector containing the results
    of the calculation for each input vector.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更清晰，让我们从一个示例开始，它将演示函数式编程的本质。假设我们已经获得了一个整数列表，并且需要计算其中偶数的数量。唯一的问题是有几个这样的向量。我们应该分别计算所有向量中的偶数，并将结果作为一个新向量产生，其中包含对每个输入向量的计算结果。
- en: 'The input is provided as a matrix, that is, a vector of vectors. The simplest
    way to express this in C++ is by using the following type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以矩阵形式提供，即向量的向量。在C++中表达这一点的最简单方式是使用以下类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can simplify the preceding code even more by using type aliases, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用类型别名来进一步简化前面的代码，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is an illustration of this problem. We have a bunch of vectors
    containing integers, and as a result we should get a vector containing a count
    of even numbers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个问题的一个例子。我们有一堆包含整数的向量，结果应该是一个包含偶数的计数的向量：
- en: '![](img/6afeff6f-80a2-4fdc-a80e-d758cdcac856.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6afeff6f-80a2-4fdc-a80e-d758cdcac856.png)'
- en: 'Look at the following function. It takes a vector of integer vectors (also
    known as a matrix) as its argument. The function counts the number of even numbers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下函数。它以整数向量的向量（也称为矩阵）作为其参数。该函数计算偶数的数量：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding function keeps a separate vector to store the count of even numbers
    for each vector. The input is provided as a vector of vectors, which is why the
    function loops over the first vector to retrieve the inner vectors. For each retrieved
    vector, it loops over it and increments a counter each time it encounters an even
    number in the vector. After completing the loop for each vector, the final result
    is pushed to the vector containing the list of numbers. While you might wish to
    go back to the preceding example and make the code better, we'll move on for now
    and decompose it into smaller functions. First, we move the portion of the code
    responsible for counting the even numbers into a separate function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数保留了一个单独的向量，用于存储每个向量中偶数的计数。输入以向量的形式提供，这就是为什么函数循环遍历第一个向量以检索内部向量。对于每个检索到的向量，它循环遍历并在向量中每次遇到偶数时递增计数器。在完成每个向量的循环后，最终结果被推送到包含数字列表的向量中。虽然您可能希望回到前面的示例并改进代码，但我们现在将继续并将其分解为更小的函数。首先，我们将负责计算偶数数量的代码部分移入一个单独的函数中。
- en: 'Let''s name it `count_evens`, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其命名为`count_evens`，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note how we applied the `count_if()` algorithm. It takes two iterators and puts
    them at the beginning and the end of the container, respectively. It also takes
    a third parameter, a *unary predicate*, which is called for each element of the
    collection. We passed a lambda as a unary predicate. You can use any other callable
    entity too, such as a function pointer, an `std::` function, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何应用`count_if()`算法。它接受两个迭代器，并将它们分别放在容器的开头和结尾。它还接受第三个参数，一个*一元谓词*，它对集合的每个元素进行调用。我们传递了一个lambda作为一元谓词。您也可以使用任何其他可调用实体，例如函数指针、`std::`函数等。
- en: 'Now that we have a separate counting function, we can call it in the original
    `count_all_evens()` function. The following implementation of `count_all_evens()`
    expresses functional programming in C++:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个单独的计数函数，我们可以在原始的`count_all_evens()`函数中调用它。以下是C++中函数式编程的实现：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before delving into the preceding code, let's agree on the first thing that
    catches our eye – not the weird use of the `|` operator, but the conciseness of
    the code. Compare it to the version of the code we introduced at the beginning
    of this section. They both do the same job, but the second one – the functional
    one – does it more concisely. Also, note that the function doesn't keep or change
    any state. It has no side-effects. This is crucial in functional programming because
    a function must be a *pure* function. It takes an argument, then processes it
    without modifying it, and returns a new value (usually based on the input). The
    first challenge in functional programming is decomposing a task into smaller independent
    functions that are easily composed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究前面的代码之前，让我们先就引起我们注意的第一件事达成一致——不是`|`运算符的奇怪用法，而是代码的简洁性。将其与我们在本节开头介绍的代码版本进行比较。它们都完成了同样的工作，但第二个——函数式的代码——更加简洁。还要注意的是，该函数不保留或更改任何状态。它没有副作用。这在函数式编程中至关重要，因为函数必须是*纯*函数。它接受一个参数，然后在不修改它的情况下对其进行处理，并返回一个新值（通常基于输入）。函数式编程的第一个挑战是将任务分解为更小的独立函数，然后轻松地将它们组合在一起。
- en: 'Although we came to the functional solution from an imperative one, it''s not
    the right way to use it when leveraging the functional programming paradigm. Instead
    of writing the imperative code first and modifying it to get the functional version,
    you should change the way you think and how you approach the problem. You should
    tame the process of thinking functionally. The problem of counting all the even
    numbers leads to our solving the problem for one vector. If we can find a way
    to solve the problem for a single vector, we can solve the problem for all the
    vectors.  The `count_evens()` function takes a vector and produces a single value,
    as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们是从命令式的解决方案转向函数式的解决方案，但这并不是在利用函数式编程范式时的正确方式。与其首先编写命令式代码，然后修改它以获得函数式版本，不如改变您的思维方式和解决问题的方式。您应该驯服思考函数式的过程。计算所有偶数的问题导致我们解决了一个向量的问题。如果我们能找到一种方法来解决单个向量的问题，我们就能解决所有向量的问题。`count_evens()`函数接受一个向量并产生一个单个值，如下截图所示：
- en: '![](img/f23fba4f-7441-4785-94ef-d67480148d5e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f23fba4f-7441-4785-94ef-d67480148d5e.png)'
- en: 'After solving the problem for one vector, we should move on to the original
    problem by applying the solution to all the vectors. The `std::transform()` function
    essentially does what we need: it takes a function that can be applied to a single
    value and transforms it in order to process a collection. The following image
    illustrates how we use it to implement a function (`count_all_evens`) that can
    process a collection of items from functions (`count_evens`) that process only
    one item at a time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了一个向量的问题后，我们应该继续将解决方案应用于所有向量的原始问题。`std::transform()`函数基本上做了我们需要的事情：它接受一个可以应用于单个值的函数，并将其转换为处理集合的方式。以下图片说明了我们如何使用它来实现一个函数(`count_all_evens`)，该函数可以处理来自只处理一个项目的函数(`count_evens`)的函数的项目集合：
- en: '![](img/9fa67593-d788-4281-a47a-f8e9a968a285.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fa67593-d788-4281-a47a-f8e9a968a285.png)'
- en: Splitting bigger problems into smaller, independent tasks is at the heart of
    functional programming. Each function is specialized to do one simple enough task
    without realizing the original problem. Functions are then composed together to
    generate a collection of transformed items from the raw initial input.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将更大的问题分解为更小的、独立的任务是函数式编程的核心。每个函数都专门用于执行一个足够简单的任务，而不会意识到原始问题。然后将函数组合在一起，以从原始输入生成一系列转换后的项目。
- en: Now, the final version of the `count_all_evens()` function leverages ranges.
    Let's find out what they are and how to use them because we will need them in
    further examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`count_all_evens()`函数的最终版本利用了范围。让我们找出它们是什么以及如何使用它们，因为我们将在后续示例中需要它们。
- en: Using ranges
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围
- en: Ranges are tied to views. We will examine them both in this section. We discussed
    STL containers and algorithms in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),
    *Digging into Data Structures and Algorithms in STL*. They provide us with a generic
    approach to composing and working with collections of objects. As you already
    know, we use iterators a lot to loop over containers and work with their elements.
    Iterators are tools that allow us to have loose coupling between algorithms and
    containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 范围与视图相关联。我们将在本节中同时研究它们。我们在[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)中讨论了STL容器和算法，*深入研究STL中的数据结构和算法*。它们为我们提供了一种通用的方法来组合和处理对象集合。正如您已经知道的那样，我们经常使用迭代器来循环遍历容器并处理它们的元素。迭代器是一种工具，允许我们在算法和容器之间实现松耦合。
- en: 'For example, earlier, we applied `count_if()` to the vector, but `count_if()`
    is not aware of what container it is was applied to. Take a look at the following
    declaration of `count_if()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，之前，我们对向量应用了`count_if()`，但`count_if()`不知道它被应用到了什么容器。看一下`count_if()`的以下声明：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, besides its verbose declaration, which is specific to C++, `count_if()`
    doesn't take a container as an argument. Instead, it operates with iterators –
    specifically, input iterators.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，除了其特定于C++的冗长声明之外，`count_if()`不接受容器作为参数。相反，它使用迭代器 - 具体来说，输入迭代器。
- en: An input iterator supports iterating forward using the `++` operator and accessing
    each element using the `*` operator. We also can compare input iterators using
    the `==` and `!=` relationships.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输入迭代器支持使用`++`运算符向前迭代，并使用`*`运算符访问每个元素。我们还可以使用`==`和`!=`关系比较输入迭代器。
- en: 'Algorithms iterate over containers without actually knowing the exact type
    of the container. We can use `count_if()` on any entity that has a beginning and
    an end, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在不知道容器的确切类型的情况下迭代容器。我们可以在任何具有开始和结束的实体上使用`count_if()`，如下所示：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Besides their generic nature, algorithms don''t compose well. Usually, we apply
    an algorithm to a collection and store the result of the algorithm as another
    collection that we can apply to more algorithms in the same manner at a later
    date. We use `std::transform()` to put the results into another container. For
    example, the following code defines a vector of Products:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的通用性，算法不太容易组合。通常，我们将算法应用于一个集合，并将算法的结果存储为另一个集合，以便在以后的某个日期应用更多的算法。我们使用`std::transform()`将结果放入另一个容器中。例如，以下代码定义了一个产品的向量：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose that the project has been developed by a different team of programmers
    and they chose to keep the name of a product as any number; for example, 1 is
    for an apple, 2 is for a peach, and so on. This means that `vec` will contain
    `Product` instances, each of which will have a number character in its `name`
    field (whereas the name''s type is `std::string` – this is why we keep the number
    as a character instead of its integer value). Now, our task is to transform the
    names of Products from numbers into full strings (`apple`, `peach`, and so on).
    We can use `std::transform` for this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设项目是由不同的程序员团队开发的，并且他们选择将产品的名称保留为任何数字；例如，1代表苹果，2代表桃子，依此类推。这意味着`vec`将包含`Product`实例，每个实例的`name`字段中将有一个数字字符（而名称的类型是`std::string`
    - 这就是为什么我们将数字保留为字符而不是其整数值）。现在，我们的任务是将产品的名称从数字转换为完整的字符串（`apple`，`peach`等）。我们可以使用`std::transform`来实现：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After executing the preceding code, the `full_named_products` vector will contain
    Products with full product names. Now, to filter out all the apples and copy them
    to a vector of apples, we need to use `std::copy_if`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，`full_named_products`向量将包含具有完整产品名称的产品。现在，要过滤出所有的苹果并将它们复制到一个苹果向量中，我们需要使用`std::copy_if`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One of the biggest disadvantages of the preceding code examples is the lack
    of nice composition until the introduction of ranges. Ranges provide us with an
    elegant way to work with container elements and compose algorithms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码示例的最大缺点之一是缺乏良好的组合，直到引入范围。范围为我们提供了一种优雅的方式来处理容器元素和组合算法。
- en: 'Simply put, a range is a traversable entity; that is, a range has a `begin()`
    and an `end()`, much like the containers we''ve worked with so far. In these terms,
    every STL container can be treated as a range. STL algorithms are redefined to
    take ranges as direct arguments. By doing this, they allow us to pass a result
    from one algorithm directly to the other instead of storing intermediary results
    in local variables. For instance, `std::transform`, which we used earlier with
    a `begin()` and an `end()`, has the following form if applied to a range (the
    following code is pseudocode). By using ranges, we can rewrite the previous example
    in the following way:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，范围是一个可遍历的实体；也就是说，一个范围有一个`begin()`和一个`end()`，就像我们迄今为止使用的容器一样。在这些术语中，每个STL容器都可以被视为一个范围。STL算法被重新定义为直接接受范围作为参数。通过这样做，它们允许我们将一个算法的结果直接传递给另一个算法，而不是将中间结果存储在本地变量中。例如，`std::transform`，我们之前使用`begin()`和`end()`，如果应用于一个范围，将具有以下形式（以下代码是伪代码）。通过使用范围，我们可以以以下方式重写前面的示例：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't forget to import the `<ranges>` header. The transform function will return
    a range containing `Product` pointers whose names are normalized; that is, the
    numeric value is replaced with a string value.The filter function will then take
    the result and return the range of products that have `apple` as their name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记导入`<ranges>`头文件。transform函数将返回一个包含已标准化名称的`Product`指针的范围；也就是说，数值将被替换为字符串值。filter函数将接受结果并返回具有`apple`作为名称的产品范围。
- en: Note that we simplified these code examples by omitting `std::ranges::views` from
    in front of the `filter` and `transform` functions. Use them as `std::ranges::views::filter`
    and `std::ranges::views::transform`, accordingly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过省略 `std::ranges::views` 在 `filter` 和 `transform` 函数前面的部分来简化了这些代码示例。分别使用
    `std::ranges::views::filter` 和 `std::ranges::views::transform`。
- en: 'Finally, the overloaded operator, `**|**`, which we used in the example at
    the beginning of this chapter, allows us to pipe ranges together. This way, we
    can compose algorithms to produce a final result, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在本章开头的示例中使用的重载运算符 `**|**` 允许我们将范围串联在一起。这样，我们可以组合算法以产生最终结果，如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We used piping instead of nesting function calls. This might be confusing at
    first because we used to use the `|` operator as a bitwise OR. Whenever you see
    it applied to a collection, it refers to piping ranges.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用管道而不是嵌套函数调用。这可能一开始会让人困惑，因为我们习惯将 `|` 运算符用作按位或。每当你看到它应用于集合时，它指的是管道范围。
- en: The `|` operator is inspired by the Unix shell pipe operator. In Unix, we can
    pipe the results of several processes together; for example, `ls -l | grep cpp
    | less` will find `cpp` in the result of the `ls` command and show the final result
    one screen at a time using the `less` program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 运算符受 Unix shell 管道运算符的启发。在 Unix 中，我们可以将多个进程的结果串联在一起；例如，`ls -l | grep cpp
    | less` 将在 `ls` 命令的结果中查找 `cpp`，并使用 `less` 程序逐屏显示最终结果。'
- en: 'As we already stated, a range is an abstraction over a collection. This doesn''t
    mean it''s a collection. That''s why the previous example doesn''t carry any overhead –
    it just passes a range from a function to function, where the range just provides
    the beginning and the end of a collection. Also, it allows us to access the underlying
    collection elements. The following diagram illuminates this idea:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，范围是对集合的抽象。这并不意味着它是一个集合。这就是为什么前面的示例没有带来任何额外开销 - 它只是从一个函数传递到另一个函数的范围，其中范围只提供了集合的开始和结束。它还允许我们访问底层集合元素。以下图解释了这个想法：
- en: '![](img/fa625af2-3795-4fd4-b089-5a72113aa071.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa625af2-3795-4fd4-b089-5a72113aa071.png)'
- en: 'The function (either **transform** or **filter**) returns a range structure
    instead of a collection. The `begin()` iterator of the range will point to the
    element in the source collection that satisfies the predicate. The range''s iterator
    is a proxy object: it differs from a regular iterator in that it points to an
    element that satisfies the given predicate. We sometimes refer to them as **smart
    iterators **because, every time we advance it (by incrementing, for example),
    it finds the next element in the collection that satisfies the predicate. What''s
    more interesting is that the "smartness" of the iterator depends on the kind of
    function we apply to the collection. For example, the `filter()` function returns
    a range that has smart iterators for their increment operator. This is mostly
    because the result of a filter might contain fewer elements than the original
    collection. Transform, on the other hand, doesn''t return a result with a reduced
    number of elements – it just transforms the elements. This means that a range
    that''s returned by transform has the same functionality for increment/decrement
    operations, but the element access will differ. For each access, the smart iterator
    of the range will return the transformed element from the original collection.
    In other words, it simply implements the `*()` operator for the iterator, similar
    to what can be seen in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（无论是 **transform** 还是 **filter**）返回的是一个范围结构而不是一个集合。范围的 `begin()` 迭代器将指向满足谓词的源集合中的元素。范围的迭代器是一个代理对象：它与常规迭代器不同，因为它指向满足给定谓词的元素。我们有时将它们称为
    **智能迭代器**，因为每次我们推进它（例如通过增量），它都会找到满足谓词的集合中的下一个元素。更有趣的是，迭代器的“智能性”取决于我们应用于集合的函数类型。例如，`filter()`
    函数返回一个具有智能迭代器的范围，用于它们的增量运算符。这主要是因为过滤的结果可能包含比原始集合更少的元素。另一方面，transform 不会返回具有减少元素数量的结果
    - 它只是转换元素。这意味着由 transform 返回的范围对于增量/减量操作具有相同的功能，但元素访问将不同。对于每次访问，范围的智能迭代器将从原始集合中返回转换的元素。换句话说，它只是为迭代器实现了
    `*()` 运算符，类似于下面的代码片段中所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, we are creating a new *view* of the collection rather than a new collection
    of transformed elements. The same applies to `filter` and other functions. More
    interestingly, range views leverage *lazy evaluation*. For our preceding example,
    even if we have two range transformations, the result is produced by evaluating
    them in a single pass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了集合的新 *视图* 而不是转换元素的新集合。`filter` 和其他函数也是如此。更有趣的是，范围视图利用了 *惰性评估*。对于我们之前的示例，即使我们有两个范围转换，结果也是通过在单次遍历中评估它们来产生的。
- en: In the example with `transform` and `filter`, each of the functions defines
    a view, but they don't modify or evaluate anything. When we assign the result
    to the result collection, the vector is constructed from the view by accessing
    each element. That's where the evaluation happens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `transform` 和 `filter` 的示例中，每个函数都定义了一个视图，但它们不会修改或评估任何内容。当我们将结果分配给结果集合时，向量是从视图中访问每个元素来构造的。这就是评估发生的地方。
- en: It's as simple as that – ranges provide us with function composition with lazy
    evaluation. We briefly touched on the toolset that's used in functional programming
    earlier. Now, let's find out about the benefits of the paradigm.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单 - 范围为我们提供了惰性评估的函数组合。我们之前简要介绍了函数式编程中使用的工具集。现在，让我们了解一下这种范式的好处。
- en: Why use functional programming?
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数式编程？
- en: First of all, functional programming introduces conciseness. The code is much
    shorter compared to its imperative counterparts. It provides simple but highly
    expressive tools. When there's less code, fewer bugs will crop up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数式编程引入了简洁性。与命令式对应物相比，代码要短得多。它提供了简单但高度表达的工具。当代码更少时，错误就会更少出现。
- en: Functions don't mutate anything, which makes it much easier to parallelize them.
    This is one of the main concerns in concurrent programs because concurrent tasks
    need to share mutable data between them. Most of the time, you have to explicitly
    synchronize threads using primitives such as mutexes. Functional programming frees
    us from explicit synchronization and we can run the code on multiple threads without
    adapting it. In [chapter 8](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),* Digging
    into Data Structures*, we will discuss data races in detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不会改变任何东西，这使得并行化变得更加容易。这是并发程序中的主要问题之一，因为并发任务需要在它们之间共享可变数据。大多数情况下，您必须使用诸如互斥锁之类的原语来显式同步线程。函数式编程使我们摆脱了显式同步，我们可以在多个线程上运行代码而无需进行调整。在[第8章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)，*深入数据结构*中，我们将详细讨论数据竞争。
- en: The functional paradigm considers all functions as *pure*; that is, functions
    that do not mutate the program state. They simply take input, transform it in
    a user-defined manner, and provide an output. A pure function generates the same
    result for the same input, independent of how many times it has been invoked.
    Whenever we speak about functional programming, we should take all pure functions
    into account by default.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式范式将所有函数视为*纯*函数；也就是说，不会改变程序状态的函数。它们只是接受输入，以用户定义的方式进行转换，并提供输出。对于相同的输入，纯函数生成相同的结果，不受调用次数的影响。每当我们谈论函数式编程时，我们应该默认考虑所有纯函数。
- en: 'The following function takes a `double` as its input and returns its square:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数以`double`作为输入，并返回其平方：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing solely pure functions might feel like intentionally making the program
    run slower.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 仅编写纯函数可能会让程序运行变慢。
- en: Some compilers, such as GCC, provide attributes that help the compiler optimize
    the code. For example, the `[[gnu::pure]]` attribute tells the compiler that the
    function can be considered a pure function. This will reassure the compiler that
    the function doesn't access any global variable and that the function's result
    depends solely on its input.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器，如GCC，提供了帮助编译器优化代码的属性。例如，`[[gnu::pure]]`属性告诉编译器该函数可以被视为纯函数。这将让编译器放心，函数不会访问任何全局变量，函数的结果仅取决于其输入。
- en: 'There are numerous scenarios where a *regular* function could bring a faster
    solution. However, in order to adapt to the paradigm, you should force yourself
    to think functionally. For example, the following program declares a vector and
    calculates the square roots of its elements:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，*常规*函数可能会带来更快的解决方案。然而，为了适应这种范式，您应该强迫自己以函数式思维。例如，以下程序声明了一个向量，并计算了其元素的平方根：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we''re passing the vector by reference. This means that, if we change
    it in the function, we change the original collection. This obviously isn''t a
    pure function because it mutates the input vector. A functional alternative would
    return the transformed elements in a new vector, leaving the input untouched:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过引用传递向量。这意味着，如果我们在函数中对它进行更改，就会改变原始集合。显然，这不是一个纯函数，因为它改变了输入向量。函数式的替代方法是在一个新的向量中返回转换后的元素，保持输入不变：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An even better example of functional thinking is to solve a smaller problem
    and apply it to the collection. The smaller problem, in this case, is calculating
    the square root of a single number, which is already implemented as `std::sqrt`.
    Applying it to the collection is done with `std::ranges::views::transform`, as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式思维的一个更好的例子是解决一个较小的问题，并将其应用到集合中。在这种情况下，较小的问题是计算单个数字的平方根，这已经实现为`std::sqrt`。将其应用到集合中是通过`std::ranges::views::transform`完成的，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we already know, by using ranges we can avoid storing intermediary objects.
    In the previous example, we applied `transform` directly to the vector. `transform`
    returns a view, but not a full collection consisting of the transformed elements
    of the source vector. The actual transformed copies of elements are made when
    we construct the `result` vector. Also, note that `std::sqrt` is considered to
    be a pure function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，通过使用范围，我们可以避免存储中间对象。在前面的例子中，我们直接将`transform`应用于向量。`transform`返回一个视图，而不是由源向量的转换元素组成的完整集合。当我们构造`result`向量时，实际的转换副本才会产生。另外，请注意`std::sqrt`被认为是一个纯函数。
- en: The example that we solved at the beginning of this chapter gave us the necessary
    perspective for functional programming. To get a better grasp of this paradigm,
    we should become familiar with its principles. In the next section, we will delve
    into the principles of functional programming so that you have an even better
    idea of how and when to use the paradigm.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时我们解决的例子为我们提供了函数式编程所需的视角。为了更好地掌握这种范式，我们应该熟悉它的原则。在下一节中，我们将深入探讨函数式编程的原则，以便您更好地了解何时以及如何使用这种范式。
- en: Principles of functional programming
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程原则
- en: Although the functional paradigm is old (it was born in the 1950s), it didn't
    take the world of programming by storm. Most of the dominant paradigms these days
    include imperative and object-oriented languages. As we've stated many times in
    this and many other books, C++ is a **multi-paradigm language**. That's the beauty
    of studying C++; we can tune it to fit almost every environment. Grasping the
    paradigm is not an easy task. You have to feel it and apply it until you finally
    start thinking in terms of the paradigm. After that, you will see solutions to
    regular tasks in a matter of seconds.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数式范式很古老（诞生于20世纪50年代），但它并没有在编程世界中掀起风暴。如我们在本书和其他许多书中多次声明的那样，C++是一种**多范式语言**。这就是学习C++的美妙之处；我们可以调整它以适应几乎每个环境。掌握这种范式并不是一件容易的事。您必须感受它并应用它，直到最终开始以这种范式思考。之后，您将能够在几秒钟内找到常规任务的解决方案。
- en: If you can remember when you first time learned about object-oriented programming,
    you might recall the principles that made you struggle a bit before you could
    unlock the true potential of OOP. The same is true for functional programming.
    In this section, we are going to discuss the basic concepts of functional programming
    that will be the base for further development. You can apply (or have already
    done so) some of these concepts without actually using the functional paradigm.
    However, try to put some effort into understanding and applying each of the following
    principles.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得第一次学习面向对象编程时，您可能会记得在能够发挥面向对象编程的真正潜力之前，您可能会有些挣扎。函数式编程也是如此。在本节中，我们将讨论函数式编程的基本概念，这将成为进一步发展的基础。您可以应用（或已经这样做）其中一些概念，而实际上并没有使用函数式范例。然而，请努力理解和应用以下每个原则。
- en: Pure functions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: As we mentioned previously, a *function is pure if it doesn't mutate the state*.
    Pure functions can be treated as less performant compared to their non-pure counterparts;
    however, they are great as they avoid most of the bugs that can arise in code
    due to state modifications. The bugs are related to the program state in some
    way. Obviously, programs work with data, so they compose state-modifying functionality
    that leads to some expected results for the end user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，*如果函数不改变状态，则函数是纯的*。与非纯函数相比，纯函数可能被视为性能较差；然而，它们非常好，因为它们避免了由于状态修改而导致的代码中可能出现的大多数错误。这些错误与程序状态有关。显然，程序处理数据，因此它们组成修改状态的功能，从而为最终用户产生一些预期的结果。
- en: In object-oriented programming, we decompose the program into objects, each
    of which has a list of special features. One of the fundamental features of an
    object in OOP is its *state*. Modifying an object's state by sending messages
    to it (in other words, calling its methods) is crucial in OOP. Usually, a member
    function invocation leads to the object state's modification. In functional programming,
    we organize code into a collection of pure functions, each of which has its own
    purpose and is independent of the others.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们将程序分解为对象，每个对象都有一系列特殊功能。面向对象编程中对象的一个基本特征是其*状态*。通过向对象发送消息（换句话说，调用其方法）来修改对象的状态在面向对象编程中至关重要。通常，成员函数调用会导致对象状态的修改。在函数式编程中，我们将代码组织成一组纯函数，每个函数都有自己的目的，并且独立于其他函数。
- en: 'Let''s take a look at a simple example, just to make this concept clear. Let''s
    say we''re dealing with user objects in a program and each user object contains
    the age associated with the user. The `User` type is described as a `struct` in
    the following code block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，只是为了让这个概念清晰起来。假设我们在程序中处理用户对象，每个用户对象都包含与用户相关的年龄。`User`类型在以下代码块中被描述为`struct`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a need to update users'' ages on a yearly basis. Let''s suppose we
    have a function that is being invoked for each `User` object once a year. The
    following function takes a `User` object as input and increases its `age` by `1`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要每年更新用户的年龄。假设我们有一个函数，每年为每个`User`对象调用一次。以下函数接受一个`User`对象作为输入，并将其`age`增加`1`：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `update_age()` function takes the input by reference and updates the original
    object. This is not the case in functional programming. Instead of taking the
    original object by reference and mutating its value, the following pure function
    returns a totally different `user` object with the same properties, except for
    the updated `age` property:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_age()`函数通过引用接受输入并更新原始对象。这在函数式编程中并不适用。这个纯函数不是通过引用获取原始对象并改变其值，而是返回一个完全不同的`user`对象，具有相同的属性，除了更新的`age`属性：'
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Though it seems inefficient compared to `update_age()`, one of the pros of
    this approach is that it makes operations crystal clear (this is really useful
    when we''re debugging code). Now, it''s guaranteed that `pure_update_age()` won''t
    modify the original object. We can modify the preceding code so that it will take
    the object by value. This way, we will skip creating the `tmp` object as the argument
    itself represents a copy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与`update_age()`相比似乎效率低下，但这种方法的优点之一是它使操作变得非常清晰（在调试代码时非常有用）。现在，可以保证`pure_update_age()`不会修改原始对象。我们可以修改前面的代码，使其按值传递对象。这样，我们将跳过创建`tmp`对象，因为参数本身就代表了一个副本：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If a pure function is called multiple times with the same arguments, it must
    return the same result every time. The following code demonstrates that our `pure_update_age()`
    function returns the same value when it''s given the same input:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个纯函数使用相同的参数多次调用，它必须每次返回相同的结果。以下代码演示了我们的`pure_update_age()`函数在给定相同输入时返回相同的值：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is a great benefit for a function to behave the same way each time it is
    called for the same input data. This means we can design the logic of the application
    by decomposing it into smaller functions, each of which has an exact and clear
    purpose. However, there is overhead for the pure function in terms of the additional
    temporary object. A regular design involves having a centralized store that contains
    the program state, which is updated indirectly by pure functions. After each pure
    function invocation, the function returns the modified object as a new object
    that can be stored if necessary. You can think of it as tweaking the code to omit
    passing the entire object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数来说，每次针对相同的输入数据调用时都表现相同是一个很大的好处。这意味着我们可以通过将应用程序的逻辑分解为更小的函数来设计它，每个函数都有一个确切而清晰的目的。然而，纯函数在额外临时对象方面存在开销。常规设计涉及具有包含程序状态的集中存储，该状态通过纯函数间接更新。在每次纯函数调用之后，函数将修改后的对象作为可能需要存储的新对象返回。您可以将其视为调整代码以省略传递整个对象。
- en: Higher-order functions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: In functional programming, functions are considered *first-class* objects (you
    might encounter first-class citizens as well). This means we should treat them
    as objects rather than a set of instructions. What difference does this make to
    us? Well, the only thing that is important at this point for a function to be
    treated as an object is the ability to pass it to other functions. Functions that
    take other functions as arguments are called **higher-order** **functions**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数被视为*一等*对象（你可能也会遇到一等公民）。这意味着我们应该将它们视为对象，而不是一组指令。这对我们有什么区别？嗯，在这一点上，函数被视为对象的唯一重要之处是能够将其传递给其他函数。接受其他函数作为参数的函数被称为**高阶函数**。
- en: 'It''s not uncommon for C++ programmers to pass one function into another. Here''s
    how this can be done the old-school way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员将一个函数传递到另一个函数是很常见的。以下是以老式方式实现的方法：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we declared a pointer to a function. `PF` represents
    a type definition for the function, takes one integer parameter, and doesn't return
    any value. The previous example is a popular way of passing pointers functions
    to other functions as arguments. We treat the function as an object. However,
    this depends on what we understand by an *object.*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个指向函数的指针。`PF`代表函数的类型定义，接受一个整数参数，并且不返回任何值。前面的例子是将指针函数传递给其他函数作为参数的一种常见方式。我们将函数视为对象。然而，这取决于我们对*对象*的理解。
- en: 'In the previous chapters, we defined an object as something that has a state.
    This means that, if we treat a function as an object, we should also be able to
    somehow change its state if needed. For function pointers, this isn''t the case.
    Here''s a better way to pass a function to another function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们将对象定义为具有状态的东西。这意味着，如果我们将函数视为对象，我们也应该能够在需要时以某种方式改变它的状态。对于函数指针来说，情况并非如此。以下是将函数传递给另一个函数的更好方法：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Take a good look at the preceding code . It declares a class that has an overloaded
    `operator()`. Whenever we overload the operator of a class, we make it *callable*.
    And as obvious as it may sound, anything that is callable is treated as a function.
    So, an object of a class that has an overloaded `operator()` could be considered
    a function (sometimes. it''s referred to as a *functor*). This is like a trick
    in a way because instead of making a function an object, we made an object callable.
    However, this allowed us to achieve what we were looking for: a function that
    has a state. The following client code demonstrates that a `Function` object has
    a state:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的代码。它声明了一个具有重载`operator()`的类。每当我们重载一个类的运算符时，我们使它变得*可调用*。尽管听起来很明显，但任何可调用的东西都被视为函数。因此，具有重载`operator()`的类的对象可以被视为函数（有时被称为*函数对象*）。这在某种程度上有点像一个技巧，因为我们不是将函数变成对象，而是使对象可调用。然而，这使我们能够实现我们想要的东西：具有状态的函数。以下客户端代码演示了`Function`对象具有状态：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By doing this, we can, for example, track how many times the function has been
    called. Here''s a simple example that tracks the number of calls:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以跟踪函数被调用的次数。以下是一个跟踪调用次数的简单示例：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, `std::function`, which is defined in the `<functional>` header in
    the following code, demonstrates another way of defining a higher-order function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`std::function`，它在以下代码中的`<functional>`头文件中定义，展示了另一种定义高阶函数的方法：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `function_object` is called (using `operator()`), it delegates the call
    to the `print_it` function. `std::function` encapsulates any function and allows
    it to work with it as an object (and pass it to other functions as well).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`function_object`（使用`operator()`）时，它将调用`print_it`函数。`std::function`封装了任何函数，并允许将其作为对象使用（以及将其传递给其他函数）。
- en: 'The functions in the preceding examples that took other functions as arguments
    are all examples of higher-order functions. A function that returns a function
    is also called a higher-order function. To sum this up, a higher-order function
    is a function that takes or returns another function or functions. Take a look
    at the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，接受其他函数作为参数的函数都是高阶函数的例子。返回函数的函数也被称为高阶函数。总之，高阶函数是接受或返回另一个函数或多个函数的函数。看一下以下例子：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`get_multiplier()` returns a lambda wrapped in `std::function`. Then, we call
    the result, just like we would call a regular function. The `get_multiplier()` function
    is a higher-order function. We can implement **currying** using a higher-order
    function, similar to what we did in the preceding example. In functional programming,
    currying is where we make a function take several arguments into several functions,
    each of which takes a single argument; for example, making `multiply(3, 5)` into
    `multiply(3)(5)`. Here''s how we can achieve this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_multiplier()`返回一个包装在`std::function`中的lambda。然后，我们调用结果，就像调用普通函数一样。`get_multiplier()`函数是一个高阶函数。我们可以使用高阶函数来实现**柯里化**，类似于我们在前面的例子中所做的。在函数式编程中，柯里化是指我们将一个函数的多个参数转换为多个函数，每个函数只接受一个参数；例如，将`multiply(3,
    5)`转换为`multiply(3)(5)`。以下是我们如何实现这一点：'
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`multiply()` takes one argument and returns a function that also takes a single
    argument. Pay attention to the lambda capture: it captures the value of `a` so
    that it can multiply it by `b` in its body.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiply()`接受一个参数，并返回一个也接受单个参数的函数。注意lambda捕获：它捕获了`a`的值，以便在其主体中将其乘以`b`。'
- en: Currying is a reference to logician Haskell Curry. The Haskell, Brook, and Curry
    programming languages are also named after him.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是对逻辑学家 Haskell Curry 的致敬。Haskell、Brook 和 Curry 编程语言也以他的名字命名。
- en: 'One of the most useful features of currying is having abstract functions that
    we can compose together. We can create specialized versions of `multiply()` and
    pass them to other functions, or use them wherever they''re applicable. This can
    be seen in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化最有用的特性之一是拥有我们可以组合在一起的抽象函数。我们可以创建`multiply()`的专门版本，并将它们传递给其他函数，或者在适用的地方使用它们。这可以在以下代码中看到：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You must''ve used a higher-order function when working with the STL. Many STL
    algorithms take predicates to filter out or process collections of objects. For
    example, the `std::find_if` function finds the element that satisfies the passed
    predicate object, as shown in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用STL时，您一定会使用高阶函数。许多STL算法使用谓词来过滤或处理对象集合。例如，`std::find_if`函数找到满足传递的谓词对象的元素，如下例所示：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`std::find_if` takes a lambda as its predicate and calls it for all the elements
    in the vector. Whichever element satisfies the condition is returned as the requested
    one.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::find_if`以lambda作为其谓词，并对向量中的所有元素调用它。满足条件的任何元素都将作为请求的元素返回。'
- en: 'Another example of a higher-order function would be `std::transform`, which
    we introduced at the beginning of this chapter (not to be confused with `ranges::view::transform`).
    Let''s use it to transform a string into uppercase letters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个高阶函数的例子是`std::transform`，我们在本章开头介绍过（不要与`ranges::view::transform`混淆）。让我们使用它将字符串转换为大写字母：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The third parameter is the beginning of the container and is where the `std::transform`
    function inserts its current results.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是容器的开始，是`std::transform`函数插入其当前结果的位置。
- en: Folding
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠
- en: Folding (or reduction) is the process of combining a collection of values together
    to generate a reduced number of results. Most of the time, we're speaking about
    a single result. Folding abstracts the process of iterating over structures that
    are recursive in nature. For example, a linked list or a vector has a recursive
    nature in terms of element access. While the recursive nature of the vector is
    arguable, we will consider it recursive since it allows us to access its elements
    by repeatedly incrementing the index. To work with such structures, we usually
    keep track of the result at each step and process the next item to be combined
    with the previous result later. Folding is called *left* or *right* folding based
    on the direction we process the collection elements in.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠（或减少）是将一组值组合在一起以生成减少数量的结果的过程。大多数情况下，我们说的是单个结果。折叠抽象了迭代具有递归性质的结构的过程。例如，链表或向量在元素访问方面具有递归性质。虽然向量的递归性质是有争议的，但我们将考虑它是递归的，因为它允许我们通过重复增加索引来访问其元素。为了处理这样的结构，我们通常在每一步中跟踪结果，并处理稍后要与先前结果组合的下一个项目。根据我们处理集合元素的方向，折叠称为*左*或*右*折叠。
- en: 'For example, the `std::accumulate` function (another example of a higher-order
    function) is a perfect example of folding functionality because it combines values
    in the collection. Take a look at the following simple example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::accumulate`函数（另一个高阶函数的例子）是折叠功能的完美例子，因为它结合了集合中的值。看一个简单的例子：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last argument to the function is the accumulator. This is the initial value
    that should be used as the previous value for the first element of the collection.
    The preceding code calculates the sum of the vector elements. It''s the default
    behavior of the `std::accumulate` function. As we mentioned previously, it is
    a higher-order function, which implies that a function could be passed as its
    argument. This will then be called for each element to produce the desired result.
    For example, let''s find the product of the `elems` vector we declared previously:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一个参数是累加器。这是应该用作集合的第一个元素的先前值的初始值。前面的代码计算了向量元素的和。这是`std::accumulate`函数的默认行为。正如我们之前提到的，它是一个高阶函数，这意味着可以将一个函数作为其参数传递。然后将为每个元素调用该函数以产生所需的结果。例如，让我们找到先前声明的`elems`向量的乘积：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It takes a binary operation; that is, a function with two arguments. The first
    argument of the operation is the previous value that''s been calculated so far,
    while the second argument is the current value. The result of the binary operation
    will be the previous value for the next step. The preceding code can be rewritten
    in a concise way using one of the existing operations in the STL:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它采用二进制操作；也就是说，具有两个参数的函数。操作的第一个参数是到目前为止已经计算的先前值，而第二个参数是当前值。二进制操作的结果将是下一步的先前值。可以使用STL中的现有操作之一简洁地重写前面的代码：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A better alternative to the `std::accumulate` function is the `std::reduce`
    function. `reduce()` is similar to `accumulate()`, except it doesn''t keep the
    order of the operation; that is, it doesn''t necessarily process the collection
    elements sequentially. You can pass an execution policy to the `std::reduce` function
    and change its behavior, say, to processing elements in parallel. Here''s how
    the reduce function can be applied to the `elems` vector from the previous example
    using the parallel execution policy:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::accumulate`函数的更好替代品是`std::reduce`函数。`reduce()`类似于`accumulate()`，只是它不保留操作的顺序；也就是说，它不一定按顺序处理集合元素。您可以向`std::reduce`函数传递执行策略并更改其行为，例如并行处理元素。以下是如何使用并行执行策略将reduce函数应用于先前示例中的`elems`向量：'
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Though `std::reduce` seems faster compared to `std::accumulate`, you should
    be careful when using it with non-commutative binary operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`std::reduce`与`std::accumulate`相比似乎更快，但在使用非交换二进制操作时，您应该小心。
- en: Folding and recursion go hand in hand. Recursive functions also solve a problem
    by decomposing it into smaller tasks and solving them one by one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠和递归是相辅相成的。递归函数也通过将问题分解为较小的任务并逐个解决它们来解决问题。
- en: Diving deeper into recursion
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入递归
- en: 'We''ve already discussed the main features of a recursive function in [Chapter
    2](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml), *Low-level Programming with C++*.
    Let''s take a look at the following simple example of calculating the factorial
    of a number recursively:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml) *使用C++进行低级编程*中讨论了递归函数的主要特点。让我们来看一个简单的递归计算阶乘的例子：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Recursive functions provide elegant solutions compared to their iterative counterparts.
    However, you should carefully approach the decision to use recursion. One of the
    most popular issues with recursive functions is stack overflows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数相对于它们的迭代对应物提供了优雅的解决方案。然而，你应该谨慎地考虑使用递归的决定。递归函数最常见的问题之一是堆栈溢出。
- en: Head recursion
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头递归
- en: 'Head recursion is the regular recursion that we are already familiar with.
    In the preceding example, the factorial function behaves as a head recursive function,
    meaning that it makes the recursive call before processing the result at the current
    step. Take a look at the following line from the factorial function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 头递归是我们已经熟悉的常规递归。在前面的例子中，阶乘函数表现为头递归函数，意味着在处理当前步骤的结果之前进行递归调用。看一下阶乘函数中的以下一行：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To find and return the result of the product, the function factorial is called
    with a reduced argument, that is, `(n - 1)`. This means that the product (the
    `*` operator) is kind of *on hold* and is waiting for its second argument to be
    returned by `factorial(n - 1)`. The stack grows in line with the number of recursive
    calls to the function. Let''s try to compare the recursive factorial implementation
    with the following iterative approach:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到并返回乘积的结果，函数阶乘以减小的参数（即`(n - 1)`）被调用。这意味着乘积（`*`运算符）有点像*暂停*，正在等待它的第二个参数由`factorial(n
    - 1)`返回。堆栈随着对函数的递归调用次数的增加而增长。让我们尝试将递归阶乘实现与以下迭代方法进行比较：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: One of the main differences here is the fact that we store the result of the
    product at each step in the same variable (named `result`). With this in mind,
    let's try to decompose the recursive implementation of the factorial function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个主要区别是我们在相同的变量（名为`result`）中存储了每一步的乘积的结果。有了这个想法，让我们试着分解阶乘函数的递归实现。
- en: It's clear that each function call takes up a specified space on the stack.
    Each result at each step should be stored somewhere on the stack. Although we
    know that it should, and even must, be the same variable, the recursive function
    doesn't care; it allocates space for its variables. The counter-intuitiveness
    of regular recursive functions prompts us to find a solution that somehow knows
    that the result of each recursive call should be stored in the same place.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，每个函数调用在堆栈上占据了指定的空间。每一步的结果都应该存储在堆栈的某个地方。尽管我们知道应该，甚至必须是相同的变量，但递归函数并不在乎；它为它的变量分配空间。常规递归函数的反直觉性促使我们寻找一个解决方案，以某种方式知道每次递归调用的结果应该存储在同一个地方。
- en: Tail recursion
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归
- en: 'Tail recursion is the solution to the problem of having multiple unnecessary
    variables that we deal with in recursive functions. The basic idea of tail-recursive
    functions is doing the actual processing before the recursive call. Here''s how
    we can transform the factorial function into a tail-recursive one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是解决递归函数中存在多个不必要变量的问题的方法。尾递归函数的基本思想是在递归调用之前进行实际处理。以下是我们如何将阶乘函数转换为尾递归函数：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Pay attention to the new argument of the function. Carefully reading the preceding
    code gives us a basic idea of the tail-recursion that''s occurring: the processing
    is done before the recursive call. Before `tail_factorial` is called again in
    its body, the current result is calculated (`n * result`) and passed to it.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数的新参数。仔细阅读前面的代码给了我们尾递归正在发生的基本概念：在递归调用之前进行处理。在`tail_factorial`再次在其主体中被调用之前，当前结果被计算（`n
    * result`）并传递给它。
- en: While this idea might not seem fascinating, it is really efficient if **Tail
    Call Optimization (TCO)** is supported by the compiler. TCO basically involves
    knowing that the second argument of the factorial function (the tail) can be stored
    at the same location for every recursive call. This allows for the stack to stay
    the same size, independent of the number of recursive calls.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个想法可能看起来并不吸引人，但如果编译器支持**尾调用优化（TCO）**，它确实非常高效。TCO基本上涉及知道阶乘函数的第二个参数（尾部）可以在每次递归调用时存储在相同的位置。这允许堆栈保持相同的大小，独立于递归调用的次数。
- en: Speaking of compiler optimizations, we can't omit template metaprogramming.
    We're mentioning it here alongisde compiler optimizations because we can treat
    metaprogramming as the biggest optimization that can be done to the program. It's
    always better to do calculations at compile time than at runtime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 说到编译器优化，我们不能忽略模板元编程。我们将它与编译器优化一起提到，因为我们可以将元编程视为可以对程序进行的最大优化。在编译时进行计算总是比在运行时更好。
- en: Metaprogramming in functional C++
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式C++中的元编程
- en: 'Metaprogramming can be treated as another programming paradigm. It''s a totally
    different approach to coding because we are not dealing with the regular process
    of programming. By a regular process, we mean the three phases that a program
    goes through in its lifetime: coding, compiling, and running. It''s obvious that
    a program does what it''s supposed to do when it is executed. An executable is
    generated by the compiler through compilation and linking. Metaprogramming, on
    the other hand, is where the code is being *executed* during the compilation of
    the code. This might sound magical if you are dealing with it for the first time.
    How can we execute code if the program doesn''t even exist yet? Recalling what
    we learned about templates in [Chapter 4](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml),
    *Understanding and Designing Templates*, we know that the compiler processes them
    with more than one pass. In the first pass, the compiler defines the necessary
    types and parameters that are used in the template class or function. With the
    next pass, the compiler starts to compile them in the way we''re familiar with;
    that is, it generates some code that will be linked by the linker to produce the
    final executable file.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程可以被视为另一种编程范式。这是一种完全不同的编码方法，因为我们不再处理常规的编程过程。通过常规过程，我们指的是程序在其生命周期中经历的三个阶段：编码、编译和运行。显然，当程序被执行时，它会按照预期的方式执行。通过编译和链接，编译器生成可执行文件。另一方面，元编程是代码在编译代码期间被*执行*的地方。如果你第一次接触这个，这可能听起来有点神奇。如果程序甚至还不存在，我们怎么能执行代码呢？回想一下我们在[第4章](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml)中学到的关于模板的知识，*理解和设计模板*，我们知道编译器会对模板进行多次处理。在第一次通过中，编译器定义了模板类或函数中使用的必要类型和参数。在下一次通过中，编译器开始以我们熟悉的方式编译它们；也就是说，它生成一些代码，这些代码将由链接器链接以生成最终的可执行文件。
- en: Since metaprogramming is something that happens during code compilation, we
    should already have an idea of which concepts and constructs of the language are
    used. Anything that can be calculated at compile-time can be used as a metaprogramming
    construct, such as templates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元编程是在代码编译期间发生的事情，我们应该已经对所使用的语言的概念和结构有所了解。任何可以在编译时计算的东西都可以用作元编程构造，比如模板。
- en: 'Here''s the classic mind-blowing example of metaprogramming in C++:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C++中经典的令人惊叹的元编程示例：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why would we bother to write so much code just for a factorial that we wrote
    in the previous section in fewer than five lines of code? The reason is due to
    its efficiency. While it will take a little bit more time to compile the code,
    it is super efficient compared to the normal factorial function (implemented either
    recursively or iteratively). And the reason behind this efficiency is the fact
    that the actual calculation of the factorial is happening at compile time. That
    is, when the executable is run, the results are already ready to use. We just
    used the calculated value when we run the program; no calculation happens at runtime.
    If you're seeing this code for the first time, the following explanation will
    make you fall in love with metaprogramming.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要写这么多代码来计算阶乘，而在上一节中我们只用不到五行的代码就写出了？原因在于它的效率。虽然编译代码需要花费一点时间，但与普通的阶乘函数（递归或迭代实现）相比，它的效率非常高。这种效率的原因在于阶乘的实际计算是在编译时发生的。也就是说，当可执行文件运行时，结果已经准备好了。我们只是在运行程序时使用了计算出的值；运行时不会发生计算。如果你是第一次看到这段代码，下面的解释会让你爱上元编程。
- en: 'Let''s decompose and analyze the preceding code in detail. First of all, the
    `MetaFactorial` template is declared with a single `enum` with a `value` property.
    This `enum` is chosen solely because its properties are calculated at compile
    time. So, whenever we access the value property of `MetaFactorial`, it is already
    being calculated (evaluated) at compile time. Take a look at the actual value
    of the enumeration. It makes a recursive dependency from the same `MetaFactorial`
    class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分解和分析前面的代码。首先，`MetaFactorial` 模板声明为带有单个 `value` 属性的 `enum`。之所以选择这个 `enum`，仅仅是因为它的属性是在编译时计算的。因此，每当我们访问
    `MetaFactorial` 的 value 属性时，它已经在编译时被计算（评估）了。看一下枚举的实际值。它从相同的 `MetaFactorial` 类中进行了递归依赖：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Some of you may have already noticed the trick here. `MetaFactorial<N - 1>`
    is not the same struct as `MetaFactorial<N>`. Although it has the same name, each
    template with a different type or value is generated as a separate new type. So,
    let''s say we call something like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能已经注意到了这里的技巧。`MetaFactorial<N - 1>` 不是与 `MetaFactorial<N>` 相同的结构。尽管它们有相同的名称，但每个具有不同类型或值的模板都会生成一个单独的新类型。因此，假设我们调用类似以下的内容：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the hard-working compiler generates three different structs for each
    value (the following is some pseudocode representing how we should picture the
    compiler working):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，勤奋的编译器为每个值生成了三个不同的结构（以下是一些伪代码，表示我们应该如何想象编译器的工作）：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the next pass, the compiler replaces each of the generated struct''s values
    with their respective numeric values, as shown in the following pseudocode:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次通过中，编译器将用其相应的数值替换生成的结构的每个值，如下伪代码所示：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, the compiler removes the unused generated structs, leaving only `MetaFactorial<3>`,
    which is, again, only used as `MetaFactorial<3>::value`. This can also be optimized.
    By doing this, we get the following result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器删除未使用的生成的结构，只留下 `MetaFactorial<3>`，再次只用作 `MetaFactorial<3>::value`。这也可以进行优化。通过这样做，我们得到以下结果：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Compare this with the previous line we had:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与我们之前的一行进行比较：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That's the beauty of metaprogramming F— it's done at compile time and leaves
    no trace, like a ninja. The compilation takes longer but the execution of the
    program is the fastest it can possibly be compared to regular solutions. We suggest
    that you try implementing meta-versions of other cost-expensive calculations,
    such as calculating the n^(th) Fibonacci number. It's not as easy as coding for
    *runtime* rather than *compile-time*, but you already have a sense of its power.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是元编程的美妙之处——它是在编译时完成的，不留痕迹，就像忍者一样。编译时间会更长，但程序的执行速度是可能的情况下最快的，与常规解决方案相比。我们建议您尝试实现其他成本昂贵的计算的元版本，比如计算第n个斐波那契数。这并不像为*运行时*而不是*编译时*编写代码那么容易，但您已经感受到了它的力量。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got a new perspective when it comes to using C++. As a multi-paradigm
    language, it can be used as a functional programming language.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们对使用C++有了新的视角。作为一种多范式语言，它可以被用作函数式编程语言。
- en: We learned the main principles of functional programming, such as pure functions,
    higher-order functions, and folding. Pure functions are functions that do not
    mutate the state. One of the pros of pure functions is that they leave fewer bugs
    that would otherwise be introduced because of state mutations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了函数式编程的主要原则，比如纯函数、高阶函数和折叠。纯函数是不会改变状态的函数。纯函数的优点之一是它们留下的错误较少，否则会因为状态的改变而引入错误。
- en: Higher-order functions are functions that take or return other functions. Other
    than in functional programming, C++ programmers use higher-order functions when
    dealing with the STL.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是接受或返回其他函数的函数。除了在函数式编程中，C++程序员在处理STL时也使用高阶函数。
- en: Pure functions, along with higher-order functions, allow us to decompose the
    whole application into a big *assembly line* of functions. Each function in this
    assembly line is responsible for receiving data and returning a new, modified
    version of the original data (without mutating the original state). When combined,
    these functions provide a well-coordinated line of tasks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数以及高阶函数使我们能够将整个应用程序分解为一系列函数的*装配线*。这个装配线中的每个函数负责接收数据并返回原始数据的新修改版本（而不是改变原始状态）。当结合在一起时，这些函数提供了一个良好协调的任务线。
- en: In the next chapter, we will dive into multithreaded programming and discuss
    the thread support library components that were introduced in C++.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨多线程编程，并讨论在C++中引入的线程支持库组件。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: List the advantages of ranges.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出范围的优势。
- en: What functions are known to be pure?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些函数被认为是纯函数？
- en: What's the difference between a pure virtual function and a pure function in
    terms of functional programming?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数式编程方面，纯虚函数和纯函数之间有什么区别？
- en: What is folding?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是折叠？
- en: What is the advantage of tail recursion over head recursion?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾递归相对于头递归的优势是什么？
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding what was covered in this chapter, please take
    a look at the following links:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖内容的更多信息，请查看以下链接：
- en: '*Learning C++ Functional Programming* by Wisnu Anggoro: [https://www.packtpub.com/application-development/learning-c-functional-programming](https://www.packtpub.com/application-development/learning-c-functional-programming)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习C++函数式编程* 作者Wisnu Anggoro：[https://www.packtpub.com/application-development/learning-c-functional-programming](https://www.packtpub.com/application-development/learning-c-functional-programming)'
- en: '*Functional Programming in C++: How to Improve Your C++ Programs Using Functional
    Techniques* by Ivan Cukic: [https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/](https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在C++中的函数式编程：如何利用函数式技术改进您的C++程序* 作者伊万·库奇克（Ivan Cukic）：[https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/](https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/)'
