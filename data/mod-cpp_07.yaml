- en: Diagnostics and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断和调试
- en: Software is complex; however, well you design your code, at some point you'll
    have to debug it, whether during the normal testing phases of developing your
    code, or when a bug report has been issued. It's prudent to design your code to
    make testing and debugging as straightforward as possible. This means adding tracing
    and reporting code, determining invariants and pre- and post-conditions, so that
    you have a starting point to test your code, and writing functions with understandable
    and meaningful error codes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是复杂的；无论您设计代码有多好，都会有一些时候需要调试它，无论是在开发代码的正常测试阶段还是在发出错误报告时。最好设计代码以尽可能简单地进行测试和调试。这意味着添加跟踪和报告代码，确定不变量和前后条件，以便您有一个测试代码的起点，并编写具有可理解和有意义的错误代码的函数。
- en: Preparing your code
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备您的代码
- en: The C++ and C Standard Libraries have a wide range of functions that allow you
    to apply tracing and reporting functions so that you can test if code is handling
    data in expected ways. Much of these facilities use conditional compilation so
    that the reporting only occurs in debug builds, but if you provide the traces
    with meaningful messages they will form part of the documentation of your code.
    Before you can report on the behavior of your code, you first have to know what
    to expect from it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++和C标准库有许多函数，允许您应用跟踪和报告函数，以便测试代码是否以预期方式处理数据。许多这些设施使用条件编译，以便报告仅在调试构建中发生，但如果您提供了有意义的跟踪消息，它们将成为您的代码文档的一部分。在您可以报告代码行为之前，您首先必须知道对其有何期望。
- en: Invariants and conditions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变量和条件
- en: 'Class invariants are conditions, the object state, that you know remain true.
    During a method call the object state will change, possibly to something that
    invalidates the object, but once a public method has completed, the object state
    must be left in a consistent state. There is no guarantee what order the user
    will call methods on a class, or even if they call methods at all, so an object
    must be usable whatever methods the user calls. The invariant aspects of an object
    applies on a method calls level: between method calls the object must be consistent
    and usable.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类不变量是您知道保持不变的对象状态的条件。在调用方法期间，对象状态将发生变化，可能变为使对象无效的状态，但一旦公共方法完成，对象状态必须保持一致。用户调用类的方法的顺序没有保证，甚至他们是否调用方法都不确定，因此对象必须在用户调用任何方法时都可用。对象的不变方面适用于方法调用级别：在方法调用之间，对象必须保持一致和可用。
- en: 'For example, imagine you have a class that represents a date: it holds a day
    number between 1 and 31, a month number between 1 and 12, and a year number. The
    class invariant is that, whatever you do to objects of the date class, it will
    always hold a valid date. This means that users can safely use objects of your
    date class. It also means that other methods on the class (say, a method to determine
    how many days between two dates, `operator-`) can assume that the values in the
    date objects are valid, so those methods do not have to check the validity of
    the data they act upon.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下您有一个表示日期的类：它保存了1到31之间的日期号，1到12之间的月份号和年份号。类不变条件是，无论您对日期类的对象做什么，它始终保持有效日期。这意味着用户可以安全地使用您的日期类的对象。这也意味着类的其他方法（比如，确定两个日期之间有多少天的方法，`operator-`）可以假定日期对象中的值是有效的，因此这些方法不必检查它们作用的数据的有效性。
- en: 'However, a valid date is more than the ranges 1 to 31 for days and 1 to 12
    for months, because not every month has 31 days. So, if you have a valid date,
    say 5 April 1997, and you call a `set_day` method to set the day number to 31,
    the class invariant condition has been violated since 31 April is not a valid
    date. If you want to change the values in a date object, the only safe way to
    do this is to change all the values: the day, month, and year--at the same time,
    because this is the only way to maintain the class invariance.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有效日期不仅仅是1到31的范围，因为并非每个月都有31天。因此，如果您有一个有效日期，比如1997年4月5日，并调用`set_day`方法将日期号设置为31，那么类不变条件就被违反了，因为4月31日不是有效日期。如果您想更改日期对象中的值，唯一安全的方法是同时更改所有值：日期、月份和年份，因为这是保持类不变性的唯一方法。
- en: One approach is to define a private method in debug builds that tests the invariant
    conditions for the class and ensures with asserts (see later) that the invariants
    are maintained. You can call such a method before a publicly-accessible method
    leaves to ensure that the object remains in a consistent state. Methods should
    also have defined pre- and post-conditions. Pre-conditions are conditions that
    you mandate are true before the method is called, and post-conditions are conditions
    that you guarantee are true after the method has completed. For the methods on
    a class, the class invariants are pre-conditions (because the state of the object
    should be consistent before the method is called) and the invariants are also
    a post-condition (because after the method has finished the object state should
    be consistent).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在调试构建中定义一个私有方法，测试类的不变条件，并确保使用断言（见后文）来维护不变量。您可以在公开可访问的方法离开之前调用此类方法，以确保对象保持一致状态。方法还应该具有定义的前后条件。前置条件是您要求在调用方法之前为真的条件，后置条件是您保证在方法完成后为真的条件。对于类的方法，类不变量是前置条件（因为在调用方法之前对象的状态应该是一致的），不变量也是后置条件（因为在方法完成后对象状态应该是一致的）。
- en: There are also pre-conditions that are the responsibility of the caller of a
    method. The pre-condition is a documented responsibility that the caller ensures.
    For example, the date class will have a pre-condition that day numbers are between
    1 and 31\. This simplifies the class code because methods that take a day number
    can assume that values passed are never out of range (although, because some months
    have fewer than 31 days, values may still not be valid). Again, in debug builds
    you can use asserts to check that such pre-conditions are true, and the tests
    in the assert will be compiled away in the release build. At the end of a method
    there will be post-conditions, that is, the class invariants will be maintained
    (and the state of the object will be valid), and the return value will be valid.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些是方法的调用者的先决条件。先决条件是调用者确保的已记录的责任。例如，日期类将有一个先决条件，即日期数字在1和31之间。这简化了类代码，因为接受日期数字的方法可以假定传递的值永远不会超出范围（尽管由于某些月份少于31天，值可能仍然无效）。同样，在调试构建中，您可以使用断言来检查这些先决条件是否为真，并且断言中的测试将在发布构建中被编译掉。在方法的末尾将有后置条件，即将保持类不变式（对象的状态将有效），并且返回值将有效。
- en: Conditional compilation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编译
- en: As explained in [Chapter 1](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Starting
    with C++*, when your C++ program is compiled there is a pre-compilation step that
    collates all the file included in a C++ source file into a single file, which
    is then compiled. The pre-processor also expands macros and, depending on the
    value of symbols, includes some code and exclude others code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)中所述，*从C++开始*，当编译您的C++程序时，会有一个预编译步骤，将包含在C++源文件中的所有文件汇总到一个单个文件中，然后进行编译。预处理器还会展开宏，并根据符号的值包含一些代码和排除其他代码。
- en: In its simplest form, conditional compilation brackets code with `#ifdef` and
    `#endif` (and optionally using `#else`), so that the code between these directives
    is only compiled if the specified symbol has been defined.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，条件编译用`#ifdef`和`#endif`括起代码（可选地使用`#else`），因此只有在指定的符号已定义时才编译这些指令之间的代码。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are guaranteed that only one of these lines will be compiled, and you are
    guaranteed that at least one of them will be compiled. If the symbol `TEST` is
    defined then the first line will be compiled and, as far as the compiler is concerned,
    the second line does not exist. If the symbol `TEST` is not defined, then the
    second line will be compiled. If you want to type these lines in the opposite
    order, you can use the `#ifndef` directive. The text provided through the conditional
    compilation can be C++ code, or it can be defined using other symbols in the current
    translation unit with `#define` or undefined existing symbols with `#undef`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以确保只有这些行中的一行将被编译，并且至少有一行将被编译。如果定义了符号`TEST`，则将编译第一行，并且对于编译器而言，第二行不存在。如果未定义符号`TEST`，则将编译第二行。如果要以相反的顺序输入这些行，可以使用`#ifndef`指令。通过条件编译提供的文本可以是C++代码，也可以使用当前翻译单元中的其他符号使用`#define`定义，或使用`#undef`未定义现有符号。
- en: 'The `#ifdef` directive simply determines if the symbol exists: it does not
    test its value. The `#if` directive allows you to test an expression. You can
    set a symbol to have a value and compile specific code depending on the value.
    The expression must be integral, so a single `#if` block can test for several
    values using `#if` and multiple `#elif` directives and (at most) one `#else`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`#ifdef`指令只是确定符号是否存在：它不测试其值。`#if`指令允许您测试表达式。您可以设置一个符号具有一个值，并根据该值编译特定的代码。表达式必须是整数，因此单个`#if`块可以使用`#if`和多个`#elif`指令测试多个值，并且（最多）一个`#else`：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the symbol is not defined then the `#if` directive treats the symbol as having
    a value of `0`; if you want to distinguish between these cases you can use the
    `defined` operator to test if a symbol is defined. At most, only one of the sections
    in the `#if`/`#endif` block will be compiled, and if a value is not matched then
    no code will be compiled. The expression can be a macro, in which case the macro
    will be expanded before the condition is tested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义符号，则`#if`指令将该符号视为具有值`0`；如果要区分这些情况，可以使用`defined`运算符测试符号是否已定义。最多，`#if`/`#endif`块中的部分将被编译，如果值不匹配，则不会编译任何代码。表达式可以是宏，此时在测试条件之前将展开该宏。
- en: 'There are three ways to define a symbol. The first way is out of your control:
    the compiler will define some symbols (typically with the `__` or `_` prefix)
    that give you information about the compiler and the compilation process. Some
    of these symbols will be described in a later section. The other two ways are
    entirely under your control--you can define symbols in a source file (or header
    file) using `#define` or you can define them on the command line using the `/D`
    switch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义符号有三种方式。第一种方式是无法控制的：编译器会定义一些符号（通常带有`__`或`_`前缀），这些符号提供关于编译器和编译过程的信息。其中一些符号将在后面的部分中描述。另外两种方式完全由您控制
    - 您可以在源文件（或头文件）中使用`#define`定义符号，也可以使用`/D`开关在命令行上定义它们：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will compile the source code with the symbol `TEST` set to a value of `1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用符号`TEST`设置为`1`的值编译源代码。
- en: 'You will typically use conditional compilation to provide code that should
    not be used in production code, for example, extra tracing code to use in debug
    mode or when you are testing code. For example, imagine you have library code
    to return data from a database, but you suspect that the SQL statement in the
    library function is faulty and returning too many values. Here, you may decide
    to test, add code to log the number of values returned:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用条件编译来提供不应在生产代码中使用的代码，例如，在调试模式下使用的额外跟踪代码或测试代码。例如，假设您有一个库代码用于从数据库返回数据，但您怀疑库函数中的SQL语句有问题并返回了太多的值。在这种情况下，您可能决定测试，添加代码来记录返回的值的数量：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Trace messages like this pollute your user interface and you will want to avoid
    them in production code. However, in debugging they can be invaluable in determining
    where problems are occurring.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的跟踪消息会污染您的用户界面，并且您希望在生产代码中避免它们。然而，在调试中，它们可以帮助您确定问题发生的位置。
- en: Any code that you call in debug mode, conditional code should be `const` methods
    (here `vector::size`), that is, they should not affect the state of any objects
    or the application data. You must ensure that the logic of your code is *exactly*
    the same in debug mode as in release mode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下调用的任何代码，条件代码应该是`const`方法（这里是`vector::size`），也就是说，它们不应该影响任何对象或应用程序数据的状态。您必须确保您的代码在调试模式和发布模式下的逻辑*完全*相同。
- en: Using pragmas
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pragma
- en: Pragmas are compiler-specific and often are concerned with the technical details
    about the code sections in the object files. There are a couple of Visual C++
    pragmas that are useful in debugging code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pragma是特定于编译器的，通常涉及到目标文件中代码部分的技术细节。在调试代码中，有几个Visual C++的pragma是有用的。
- en: In general, you will want your code to compile with as few warnings as possible.
    The default warning for the Visual C++ compiler is `/W1`, which means that only
    the most severe warnings are listed. Increasing the value to 2, 3, or the highest
    value of 4 progressively increases the number of warnings that are given during
    a compilation. Using `/Wall` will give level-4 warnings and warnings that have
    been disabled by default. This last option, even for the simplest code, will produce
    a screen full of warnings. When you have hundreds of warnings useful error messages
    will be hidden between the reams of unimportant warnings. Since the C++ Standard
    Library is complex and uses some code that is decades old, there are some constructs
    that the compiler will warn you about. To prevent these warnings polluting the
    output from your builds, specific warnings in selective files have been disabled.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您希望您的代码尽可能少地产生警告。Visual C++编译器的默认警告是`/W1`，这意味着只列出最严重的警告。将值增加到2、3或最高值4会逐渐增加编译过程中产生的警告数量。使用`/Wall`将会产生4级警告和默认情况下被禁用的警告。即使对于最简单的代码，这个选项也会产生一屏幕的警告。当您有数百个警告时，有用的错误消息将被隐藏在大量不重要的警告之间。由于C++标准库非常复杂，并且使用了一些几十年前的代码，编译器会对一些构造发出警告。为了防止这些警告污染您的构建输出，特定文件中的特定警告已被禁用。
- en: If you are supporting older library code, you may find that the code compiles
    with warnings. You may be tempted to reduce the warning levels using the compiler
    `/W` switch, but that will suppress all warnings higher than the ones you enable,
    and it applies equally to your code as to the library code that you may be including
    into your project. The `warning` pragma gives you a lot more flexibility. There
    are two ways to call this--you can reset the warning level to override the compiler
    `/W` switch and you can change the warning level of a particular warning or disable
    the warning reporting altogether.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您支持旧的库代码，您可能会发现代码编译时会产生警告。您可能会想要使用编译器的`/W`开关来降低警告级别，但这将抑制所有高于您启用的警告，并且同样适用于您的代码以及您可能包含到项目中的库代码。`warning`
    pragma给了您更多的灵活性。有两种调用方式--您可以重置警告级别以覆盖编译器的`/W`开关，也可以更改特定警告的警告级别或完全禁用警告报告。
- en: 'For example, at the top of the `<iostream>` header is the line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`<iostream>`头文件的顶部是这样一行：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This says store the current warning level and, for the rest of this file (or
    until it is changed), make the warning level 3\. At the bottom of the file is
    the line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示存储当前的警告级别，并在本文件的其余部分（或直到它被更改）中将警告级别设置为3。文件底部是这样一行：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This restores the warning level to that stored earlier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将恢复到之前存储的警告级别。
- en: 'You can also change how one or more warnings are reported. For example, at
    the top of `<istream>` is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以更改一个或多个警告的报告方式。例如，在`<istream>`的顶部是：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first part of this `pragma` is the specifier `disable`, which indicates
    that reporting of a warning type (in this case, 4189) is disabled. If you choose,
    you can change the warning level of a warning by using the warning level (`1`,
    `2`, `3`, or `4`) as the specifier. One use for this is to lower the warning level
    just for a piece of code that you are working on and then return it to its default
    level after the code. For example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pragma`的第一部分是指定符`disable`，表示禁用了某种警告类型的报告（在本例中是4189）。如果您愿意，您可以通过使用警告级别（`1`、`2`、`3`或`4`）作为指定符来改变警告的级别。其中一个用途是在您正在处理的代码片段中降低警告级别，然后在代码完成后将其恢复到默认级别。例如：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function shifts a char right by 8 bits, which will generate the level-1
    warning 4333 (*right shift by too large amount, data loss*). This is a problem
    and needs to be fixed, but for the time being, you want to compile the code without
    warnings from this code and so the warning level is changed to level 2\. Using
    the default warning level (`/W1`) the warning will not be shown. However, if you
    compile with a more sensitive warning level (for example, `/W2`) then this warning
    will be reported. This change in the warning level is only temporary because the
    last line resets the warning level back to its default (which is 1). In this case,
    the warning level is increased, meaning that you will only see it with a more
    sensitive warning level on the compiler. You can also reduce the warning level,
    which means that the warning is more likely to be reported. You can even change
    a warning level to `error` so the code will not compile while warnings of this
    type exist in the code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将char右移8位，这将生成级别1警告4333（*右移位数过大，数据丢失*）。这是一个问题，需要修复，但暂时，您希望编译代码时不会收到来自此代码的警告，因此将警告级别更改为级别2。使用默认警告级别（`/W1`）时，不会显示警告。但是，如果使用更敏感的警告级别（例如，`/W2`）进行编译，则会报告此警告。警告级别的更改仅是临时的，因为最后一行将警告级别重置为其默认值（即1）。在这种情况下，警告级别增加，这意味着只有在编译器上使用更敏感的警告级别时才会看到它。您还可以降低警告级别，这意味着更有可能报告警告。您甚至可以将警告级别更改为`error`，以便在代码中存在此类型的警告时无法编译。
- en: Adding informational messages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加信息性消息
- en: As you test and debug code you will inevitably come across places where you
    can see a potential problem but it has low priority compared to what you are working
    on. It is important to make a note of the issue so that you can address the problem
    at a later stage. In Visual C++, there are two ways to do this in a benign way
    and two ways that will generate an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试和调试代码时，您不可避免地会遇到一些潜在问题，但与您正在处理的问题相比，它的优先级较低。重要的是要记录下问题，以便以后解决问题。在Visual C++中，有两种以温和方式记录问题的方法，还有两种会生成错误的方法。
- en: 'The first way is to add a `TODO:` comment, shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是添加一个`TODO:`注释，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Visual Studio editor has a tool window called the **Task List**. This lists
    the comments in the project that start with one of the predetermined tasks (the
    defaults are `TODO`, `HACK`, and `UNDONE`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio编辑器有一个名为**任务列表**的工具窗口。这列出了项目中以预定任务之一开头的注释（默认为`TODO`、`HACK`和`UNDONE`）。
- en: If the Task List window is not visible, enable it via the View menu. The default
    setting in Visual Studio 2015 is to enable tasks in C++. This is not the case
    for earlier versions, but it can be enabled through the Tools menu, Options dialog
    and then Text Editor, C/C++, Formatting, View by setting Enumerate Comment Tasks
    to Yes. The list of task labels can be found on the Options dialog under the Environment,
    Task List item.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务列表窗口不可见，请通过“视图”菜单启用它。在Visual Studio 2015中，默认设置为启用C++中的任务。对于早期版本来说并非如此，但可以通过“工具”菜单、“选项”对话框，然后“文本编辑器”、“C/C++”、“格式”、“查看”设置“枚举注释任务”为“是”来启用它。任务标签列表可以在“选项”对话框的“环境”、“任务列表”项目下找到。
- en: The Task List lists the tasks with the file and line number, and you can open
    the file and locate the comment by double-clicking on an entry.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表会列出文件和行号，您可以通过双击条目来打开文件并定位注释。
- en: 'The second way to identify code that needs attention is the `message` pragma.
    As the name suggests, this simply allows you to place an informational message
    in your code. When the compiler comes across this pragma it simply puts the message
    on the output stream. Consider the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 识别需要关注的代码的第二种方法是`message`编译指示。顾名思义，这只是允许您在代码中放置信息性消息。当编译器遇到此编译指示时，它只是将消息放在输出流中。考虑以下代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the `test.cpp` file is compiled with this code and `/W1` (the default) warning
    level, the output will be something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此代码编译`test.cpp`文件并且使用默认的`/W1`警告级别，则输出将类似于以下内容：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the string is printed just as the compiler sees it, and there
    is no indication of the file or line number in contrast to the warning message.
    There are ways to address this using compiler symbols.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，字符串会按照编译器看到的方式打印出来，与警告消息相比，没有文件或行号的指示。有办法使用编译器符号来解决这个问题。
- en: 'If the condition is important, you''ll want to issue an error and one way to
    do this is with the `#error` directive. When the compiler reaches this directive,
    it will issue an error. This is a serious action, so you will only use it when
    there is another option. You''ll most likely want to use it with a conditional
    compilation. A typical use is for code that can only be compiled with a C++ compiler:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件很重要，您将希望发出错误，一种方法是使用`#error`指令。当编译器到达此指令时，它将发出一个错误。这是一个严重的操作，因此只有在没有其他选项时才会使用它。您很可能希望将其与条件编译一起使用。典型用法是只能使用C++编译器编译的代码：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you compile a file with this code using the `/Tc` switch to compile code
    as C then the `__cplusplus` preprocessor symbol will not be defined and an error
    will be generated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`/Tc`开关编译此代码文件作为C代码，则`__cplusplus`预处理符号将不会被定义，并且会生成错误。
- en: 'C++11 adds a new directive called `static_assert`. This is called like a function
    (and *calls* are terminated with a semicolon), but it is not a function because
    it is only used at compile time. Further, the directive can be used in places
    where function calls are not used. The directive has two parameters: an expression
    and a string literal. If the expression is `false` then the string literal will
    be outputted at compile time with the source file and line number and an error
    will be generated. At the simplest level, you could use this to issue a message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C++11添加了一个名为`static_assert`的新指令。这类似于函数调用（*调用*以分号结束），但它不是函数，因为它只在编译时使用。此外，该指令可以用于不使用函数调用的地方。该指令有两个参数：一个表达式和一个字符串字面值。如果表达式为`false`，则字符串字面值将在编译时与源文件和行号一起输出，并生成错误。在最简单的级别上，您可以使用它来发出消息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the first parameter is `false`, the directive will issue the error message
    during compilation. The same thing could be achieved with the `#error` directive.
    The `<type_traits>` library has various predicates for testing the properties
    of types. For example, the `is_class` template class has a simple template parameter
    that is a type, and if the type is a `class` then the `static` member `value`
    is set to `true`. If you have a templated function that should only be instantiated
    for classes, you could add this `static_assert`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个参数是`false`，指令将在编译期间发出错误消息。使用`#error`指令也可以实现相同的效果。`<type_traits>`库具有用于测试类型属性的各种谓词。例如，`is_class`模板类具有一个简单的模板参数，即类型，如果该类型是`class`，则`static`成员`value`设置为`true`。如果您有一个应该只对类进行实例化的模板函数，您可以添加这个`static_assert`：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At compile time, the compiler will attempt to instantiate the function and
    instantiate `is_class` on that type using `value` to determine if the compilation
    should continue. For example, the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，编译器将尝试实例化函数并使用`value`在该类型上实例化`is_class`来确定是否应该继续编译。例如，以下代码：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first line will compile correctly because the compiler will instantiate
    a function, `func<string>,` and the parameter is a `class`. However, the second
    line will not compile because the function instantiated is `func<const char*>`
    and `const char*` is not a `class`. The output is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将正确编译，因为编译器将实例化一个函数`func<string>`，参数是一个`class`。然而，第二行将无法编译，因为实例化的函数是`func<const
    char*>`，而`const char*`不是一个`class`。输出是：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `static_assert` is on *line 25*, and hence this generates the error that
    `T must be a class`. *Line 39* is the first call to `func<const char*>` and gives
    context to the error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert`在*第25行*，因此会生成`T must be a class`的错误。*第39行*是对`func<const char*>`的第一个调用，并为错误提供了上下文。'
- en: Compiler switches for debugging
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试的编译器开关
- en: To allow you to single-step through a program with a debugger, you have to provide
    information to allow the debugger to associate machine code with source code.
    At the very least, this means switching off all optimizations, since in an attempt
    to optimize code the C++ compiler will rearrange code. Optimizations are switched
    off by default (so the using the `/Od` switch is redundant), but clearly, to be
    able to debug a process and single-step through C++ code you need to remove all
    the `/O` optimization switches.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让调试器能够逐步执行程序，您必须提供信息，以便调试器将机器代码与源代码关联起来。至少，这意味着关闭所有优化，因为C++编译器在尝试优化代码时会重新排列代码。优化默认关闭（因此使用`/Od`开关是多余的），但显然，为了能够调试进程并逐步执行C++代码，您需要删除所有`/O`优化开关。
- en: Since the C++ Standard Library uses the C Runtime, you will need to compile
    your code to use the latter's debug builds. The switch you use depends on whether
    you are building a process or **Dynamic Link Library** (**DLL**), and whether
    you will statically link the C runtime or access it through a DLL. If you are
    compiling a process, you use `/MDd` to get the debug version of the C runtime
    in a DLL, and if you use `/MTd` you will get the debug version of the static linked
    C runtime. If you are writing a dynamic linked library, you have to use `/LDd`
    in addition to one of the C runtime switches (`/MTd` is the default). These switches
    will define a pre-processor symbol called `_DEBUG`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++标准库使用C运行时，您需要编译您的代码以使用后者的调试版本。您使用的开关取决于您是构建进程还是**动态链接库**（**DLL**），以及您是静态链接C运行时还是通过DLL访问它。如果您正在编译一个进程，您可以使用`/MDd`来获取C运行时的调试版本在DLL中，如果您使用`/MTd`，您将获得静态链接C运行时的调试版本。如果您正在编写一个动态链接库，您必须使用`/LDd`以及一个C运行时开关（`/MTd`是默认值）。这些开关将定义一个名为`_DEBUG`的预处理器符号。
- en: 'A debugger will need to know debugger symbolic information--the names and types
    of variables and the names of functions and line numbers associated with code.
    The accepted way to do this is through a file called a **program database**, with
    an extension of `pdb`. You use one of the `/Z` switches to generate a `pdb` file:
    the `/Zi` or `/ZI` switch will create two files, one with a name starting with
    `VC` (for example `VC140.pdb`) that contains the debugging information for all
    of the `obj` files, and a file with the name of the project that contains debugging
    for the process. If you compile without linking (`/c`) then only the first file
    is created. The Visual C++ project wizard will use `/Od /MDd /ZI` by default for
    debug builds. The `/ZI` switch means that a program database is created in a format
    that allows the Visual C++ debugger to perform `Edit` and `Continue`, that is,
    you can change some code and continue to single-step through the code without
    recompiling. When you compile for a release build, the wizard will use the `/O2
    /MD /Zi` switches, which means that the code is optimized for speed but a program
    database (without `Edit` and `Continue` support) will still be created. The code
    does not need the program database to run (in fact, you should not distribute
    it with your code), but it is useful if you have a crash report and need to run
    the release build code under the debugger.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器需要知道调试器符号信息--变量的名称和类型，函数的名称和与代码相关联的行号。通过名为**程序数据库**的文件来完成这一点，扩展名为`pdb`。您可以使用`/Z`开关之一来生成`pdb`文件：`/Zi`或`/ZI`开关将创建两个文件，一个文件名以`VC`开头（例如`VC140.pdb`），其中包含所有`obj`文件的调试信息，以及一个文件名为项目名称，其中包含进程的调试信息。如果您编译而不链接（`/c`），那么只会创建第一个文件。Visual
    C++项目向导默认使用`/Od /MDd /ZI`进行调试构建。`/ZI`开关意味着以一种允许Visual C++调试器执行`编辑`和`继续`的格式创建程序数据库，也就是说，您可以更改一些代码并继续逐步执行代码而无需重新编译。当您为发布构建编译时，向导将使用`/O2
    /MD /Zi`开关，这意味着代码经过了速度优化，但仍将创建一个程序数据库（不支持`编辑`和`继续`）。代码不需要程序数据库来运行（实际上，您不应该将其与代码一起分发），但如果您有崩溃报告并需要在调试器下运行发布构建代码，它将非常有用。
- en: These `/Z` compiler switches assume the linker is run with the `/debug` switch
    (and if the compiler invokes the linker it will pass this switch). The linker
    will create the project program database from the debug information in the `VC`
    program database file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`/Z`编译器开关假定链接器使用`/debug`开关运行（如果编译器调用链接器，它将传递这个开关）。链接器将从`VC`程序数据库文件中的调试信息创建项目程序数据库。
- en: This raises the question of why a release build file will need a program database.
    If you run a program under the debugger and look at the call stack, you will often
    see a long list of stack frames in operating system files. These usually have
    fairly meaningless names made up of the DLL name and some numbers and characters.
    It is possible to install the symbols (the `pdb` files) for Windows or, if they
    are not installed, instruct the Visual C++ debugger to download the symbols for
    a library being used from a computer on the network called a **symbol server**.
    These symbols are not the source code for the library, but they do give you the
    names of the functions and the types of the parameters, which gives you additional
    information about the state of the call stack at the point where you are single
    stepping.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题，为什么发布构建文件需要一个程序数据库。如果你在调试器下运行程序并查看调用堆栈，你经常会看到操作系统文件中的一长串堆栈帧。这些通常有着由DLL名称和一些数字和字符组成的相当无意义的名称。可以安装Windows的符号（`pdb`文件），或者如果它们没有安装，可以指示Visual
    C++调试器从网络上的一台计算机上下载正在使用的库的符号，这被称为**符号服务器**。这些符号不是库的源代码，但它们确实给出了函数的名称和参数的类型，这为你提供了有关在你单步执行时调用堆栈状态的额外信息。
- en: Pre-processor symbols
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理符号
- en: To get access to the tracing, asserts, and reporting facilities in your code,
    you have to enable the debugging runtime library, and this is done by using the
    `/MDd`, `/MTd`, or `/LDd` compiler switches, which will define the `_DEBUG` pre-processor
    symbol. The `_DEBUG` pre-processor symbol enables a lot of facilities, and conversely,
    not defining this symbol will help in optimizing your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用跟踪、断言和报告功能，你必须启用调试运行库，这可以通过使用`/MDd`、`/MTd`或`/LDd`编译器开关来实现，这将定义`_DEBUG`预处理符号。`_DEBUG`预处理符号启用了许多功能，相反，不定义这个符号将有助于优化你的代码。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The C++ compiler will also provide information through some standard pre-processor
    symbols. Most of these are useful only for library writers, but there are some
    that you may want to use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器还将通过一些标准预处理符号提供信息。其中大多数只对库编写者有用，但也有一些你可能想要使用的。
- en: 'The ANSI standard says that the `__cplusplus` symbol should be defined when
    the compiler is compiling code as C++ (rather than C), and it also specifies that
    the `__FILE__` symbol should contain the name of the file and that `__LINE__`
    symbol will have the line number at the point where you access it. The `__func__`
    symbol will have the current function name. This means that you can create tracing
    code like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI标准规定，当编译器编译代码为C++（而不是C）时，应该定义`__cplusplus`符号，它还指定`__FILE__`符号应该包含文件名，`__LINE__`符号将包含你访问它的地方的行号。`__func__`符号将包含当前函数名。这意味着你可以创建如下的跟踪代码：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this code is compiled for debugging (for example, `/MTd`) then the `cout`
    line will be put inline whenever `TRACE` is used; if the code is not compiled
    for debugging then `TRACE` will do nothing. The `__func__` symbol is simply the
    function name, it is not qualified, so if you use it in a class method it will
    provide no information about the class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码是为调试而编译的（例如，`/MTd`），那么`cout`行将在使用`TRACE`时被内联；如果代码不是为调试而编译的，那么`TRACE`将不起作用。`__func__`符号只是函数名，它没有限定，所以如果你在类方法中使用它，它将不提供关于类的任何信息。
- en: Visual C++ also defines Microsoft-specific symbols. The `__FUNCSIG__` symbol
    gives the complete signature including the class name (and any `namespace` names),
    the return type, and parameters. If you just want the fully qualified name, then
    you can use the `__FUNCTION__` symbol. A symbol that you will see frequently in
    the Windows header files is `_MSC_VER`. This has a number that is the version
    of the current C++ compiler, and it is used with a conditional compilation so
    that newer language features are only compiled with a compiler that supports them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++还定义了微软特定的符号。`__FUNCSIG__`符号提供了完整的签名，包括类名（和任何`namespace`名称）、返回类型和参数。如果你只想要完全限定的名称，那么你可以使用`__FUNCTION__`符号。在Windows头文件中经常看到的一个符号是`_MSC_VER`。这是当前C++编译器版本的数字，它与条件编译一起使用，以便只有支持它们的编译器才能编译新的语言特性。
- en: The Visual C++ project pages define *build macros* with names like `$(ProjectDir)`
    and `$(Configuration)`. These are used only by the MSBuild tool so they are not
    automatically available in a source file during compilation, however, if you set
    a pre-processor symbol to the value of a build macro, the value will be available
    through that symbol at compile time. The system environment variables are also
    available as build macros, so it is possible to use them to influence the build.
    For example, on Windows the system environment variable `USERNAME` has the name
    of the current logged on user so you could use it to set a symbol and then access
    that at compile time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++项目页面定义了类似`$(ProjectDir)`和`$(Configuration)`的*构建宏*。这些只被MSBuild工具使用，因此在编译期间在源文件中它们不会自动可用，但是，如果你将一个预处理器符号设置为构建宏的值，那么该值将在编译时通过该符号可用。系统环境变量也可以作为构建宏使用，因此可以使用它们来影响构建。例如，在Windows上，系统环境变量`USERNAME`包含当前登录用户的名称，因此你可以使用它来设置一个符号，然后在编译时访问它。
- en: 'In the Visual C++ project pages, you can add a **Preprocessor Definition**
    on the C/C++ preprocessor project page called:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual C++项目页面上，你可以在C/C++预处理器项目页面上添加一个**预处理器定义**，名为：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in your code, you could add a line using this symbol:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的代码中，你可以添加一行使用这个符号：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you are using a make file, or just invoking `cl` from the command line,
    you can add a switch to define the symbol like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用一个make文件，或者只是从命令行调用`cl`，您可以添加一个开关来定义符号，如下所示：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Escaping the double quotes here is important because without them the quotes
    are eaten by the compiler.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里转义双引号很重要，因为没有它们，引号会被编译器吞掉。
- en: 'Earlier, you saw how the `#pragma message` and `#error` directives can be used
    to put messages into the output stream of the compiler. When you compile code
    in Visual Studio the compiler and linker outputs will appear in the output window.
    If the message is in the form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您已经看到了如何使用`#pragma message`和`#error`指令将消息放入编译器的输出流中。在Visual Studio中编译代码时，编译器和链接器的输出将显示在输出窗口中。如果消息的形式是：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: where `path_to_source_file` is the full path to the file, `line` is the line
    number where the `message` appears. Then, when you double click on this line in
    the output window, the file will be loaded (if not already) and the insertion
    point placed on the line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`path_to_source_file`是文件的完整路径，`line`是`message`出现的行号。然后，当您在输出窗口中双击此行时，文件将被加载（如果尚未加载），并且插入点将放在该行上。
- en: 'The `__FILE__` and `__LINE__` symbols provide you with the information that
    you need to make `#pragma message` and `#error` directives more useful. Outputting
    `__FILE__` is simple because it is a string and C++ will concatenate string literals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__FILE__`和`__LINE__`符号为您提供了使`#pragma message`和`#error`指令更有用的信息。输出`__FILE__`很简单，因为它是一个字符串，C++会连接字符串文字：'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The macro is called as part of the pragma to format the message correctly;
    however, you cannot call the pragma from a macro because the `#` has a special
    purpose (that will be of use in a moment). The result of this code will be something
    like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 宏作为`#pragma`的一部分来调用以正确格式化消息；但是，您不能从宏中调用`#pragma`，因为`#`有特殊用途（稍后将会用到）。这段代码的结果将类似于：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Outputting `__LINE__` via a macro requires a bit more work because it holds
    a number. This issue is a common one in C, so there is a standard solution using
    two macros and the stringing operator, `#`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过宏输出`__LINE__`需要更多的工作，因为它保存一个数字。这个问题在C中很常见，因此有一个使用两个宏和字符串化运算符`#`的标准解决方案。
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `STRING` macro is used to expand the `__LINE__` symbol to a number and the
    `STRING2` macro to stringify the number. The `AT_FILE` macro formats the entire
    string in the correct format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRING`宏用于将`__LINE__`符号扩展为数字，`STRING2`宏用于将数字字符串化。`AT_FILE`宏以正确的格式格式化整个字符串。'
- en: Producing diagnostic messages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成诊断消息
- en: The effective use of diagnostic messages is a broad topic, so this section will
    just give you the basics. When you design your code, you should make it easy to
    write diagnostic messages, for example, providing mechanisms to dump the contents
    of an object and providing access to the code that tests for class invariants
    and pre- and post-conditions. You should also analyze the code to make sure that
    appropriate messages are logged. For example, issuing a diagnostic message in
    a loop will often fill up your log files, making it difficult to read the other
    messages in the log file. However, the fact that something is consistently failing
    in a loop may in itself be an important diagnostic, as may be the number of attempts
    to carry out a failing act, so you may want to record that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用诊断消息是一个广泛的话题，所以本节只会给出基础知识。当设计代码时，应该使编写诊断消息变得容易，例如，提供转储对象内容的机制，并提供访问测试类不变量和前后条件的代码。您还应该分析代码，以确保记录适当的消息。例如，在循环中发出诊断消息通常会填满日志文件，使得难以阅读日志文件中的其他消息。然而，循环中一直出现故障可能本身就是一个重要的诊断，尝试执行失败操作的次数也可能是一个重要的诊断，因此您可能希望记录下来。
- en: Using `cout` for diagnostic messages has the advantage of integrating these
    messages with your user output, so that you can see the final effects of the intermediate
    results. The disadvantage is that the diagnostic messages are integrated with
    the user output, and since there are usually a large number of diagnostic messages,
    these will completely swamp the user output of your program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cout`输出诊断消息的优点是将这些消息与用户输出集成在一起，这样您可以看到中间结果的最终效果。缺点是诊断消息与用户输出集成在一起，而且通常有大量的诊断消息，这些消息将完全淹没程序的用户输出。
- en: C++ has two stream objects that you can use instead of `cout`. The `clog` and
    `cerr` stream objects will write character data to the standard error stream (the
    C stream pointer `stderr`), which will usually show on the console as if you are
    using `cout` (which outputs to the standard output stream, the C stream pointer
    `stdout`), but you can redirect it elsewhere. The difference between `clog` and
    `cerr` is that `clog` uses buffered output, which is potentially better-performing
    than the unbuffered `cerr`. However, there is the danger that the data may be
    lost if the application stops unexpectedly without flushing the buffer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++有两个流对象可以代替`cout`。`clog`和`cerr`流对象将字符数据写入标准错误流（C流指针`stderr`），通常会显示在控制台上，就好像您使用`cout`（输出到标准输出流，C流指针`stdout`），但您可以将其重定向到其他地方。`clog`和`cerr`之间的区别在于`clog`使用缓冲输出，这可能比未缓冲的`cerr`性能更好。但是，如果应用程序在没有刷新缓冲区的情况下意外停止，数据可能会丢失。
- en: Since the `clog` and `cerr` stream objects are available in release builds as
    well as debug builds, you should use them only for messages that you are happy
    that your end user will see. This makes them inappropriate for trace messages
    (which will be covered shortly). Instead, you should use them for diagnostic messages
    that the user will be in a position to address (perhaps a file cannot be found
    or the process does not have the security access to perform an action).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`clog`和`cerr`流对象在发布版本和调试版本中都可用，因此应该仅用于您希望最终用户看到的消息。这使它们不适合用于跟踪消息（稍后将介绍）。相反，您应该将它们用于用户能够解决的诊断消息（例如，找不到文件或进程没有安全访问权限执行操作）。
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code opens a file in two steps (rather than using the constructor) and
    the `open` method will return `false` if the file cannot be opened. The code checks
    to see if opening the file was successful, and if it fails, it will tell the user
    via the `clog` object and then return from whatever function contains the code,
    as the `file` object is now invalid and cannot be used. The `clog` object is buffered
    but in this case we want to inform the user immediately, and this is performed
    by the `endl` manipulator, which inserts a newline in the stream and then flushes
    the stream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码以两个步骤打开文件（而不是使用构造函数），`open`方法如果文件无法打开将返回`false`。代码检查是否成功打开文件，如果失败，它将通过`clog`对象告知用户，然后从包含代码的任何函数返回，因为`file`对象现在无效且无法使用。`clog`对象是缓冲的，但在这种情况下，我们希望立即通知用户，这是通过`endl`操作器执行的，它在流中插入一个换行符，然后刷新流。
- en: 'By default, the `clog` and `cerr` stream objects will output to the standard
    error stream and this means that for a console application you can separate out
    the output stream and error stream by redirecting the streams. On the command-line,
    the standard streams can be redirected by using a value of 0 for `stdin`, 1 for
    `stdout,` and 2 for `stderr` and the redirection operator `>`. For example, an
    application `app.exe` could have this code in the `main` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`clog`和`cerr`流对象将输出到标准错误流，这意味着对于控制台应用程序，您可以通过重定向流来分离输出流和错误流。在命令行上，可以使用`stdin`的值为0，`stdout`的值为1，`stderr`的值为2以及重定向操作符`>`来重定向标准流。例如，应用程序`app.exe`可以在`main`函数中包含以下代码：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `cerr` object is not buffered so whether you use `n` or `endl` for a newline
    is irrelevant. When you run this on the command line, you''ll see something like
    this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`cerr`对象不是缓冲的，因此无论您使用`n`还是`endl`进行换行都无关紧要。当您在命令行上运行此代码时，您将看到类似以下的内容：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To redirect a stream to a file, redirect the stream handle (1 for `stdout`,
    2 for `stderr`) to the file; the console will open the file and write the stream
    to the file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将流重定向到文件，请将流句柄（`stdout`的值为1，`stderr`的值为2）重定向到文件；控制台将打开文件并将流写入文件。
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the last chapter showed, C++ stream objects are layered so that calls to
    insert data into a stream will write the data to the underlying stream object,
    depending on the type of stream, with or without buffering. This stream buffer
    object is obtained, and replaced, using the `rdbuf` method. If you want the `clog`
    object redirected to a file by the application, you can write code like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一章所示，C++流对象是分层的，因此向流中插入数据的调用将根据流的类型将数据写入底层流对象，有或没有缓冲。使用`rdbuf`方法获取和替换此流缓冲对象。如果要将`clog`对象重定向到应用程序的文件中，可以编写以下代码：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code the application code will be in the `run_code` function, and the
    rest of the code sets up the `clog` object to redirect to files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，应用程序代码将位于`run_code`函数中，其余代码设置`clog`对象以重定向到文件。
- en: Note that the file is explicitly closed when the `run_code` function returns
    (the application has finished); this is not entirely necessarily because the `ofstream`
    destructor will close the file, and in this case this will happen when the `main`
    function returns. The last line is important. The standard stream objects are
    created before the `main` function is called, and they will be destroyed sometime
    after the `main` function returns, that is, well after the file objects have been
    destroyed. To prevent the `clog` object accessing the destroyed file object, the
    `rdbuf` method is called passing `nullptr` to indicate that there is no buffer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`run_code`函数返回（应用程序已完成）时，文件会被显式关闭；这并不完全必要，因为`ofstream`析构函数将关闭文件，在这种情况下，当`main`函数返回时将会发生。最后一行很重要。标准流对象是在调用`main`函数之前创建的，并且它们将在`main`函数返回后的某个时候被销毁，也就是说，在文件对象被销毁之后。为了防止`clog`对象访问已销毁的文件对象，调用`rdbuf`方法并传递`nullptr`来指示没有缓冲区。
- en: Trace messages with the C runtime
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C运行时的跟踪消息
- en: Often you will want to test your code by running the application in real time
    and output the *trace messages* to test that your algorithms work. Sometimes you
    will want to test the order that functions are called (for example, that correct
    branching occurs in a `switch` statement or in an `if` statement), and in other
    cases you'll want to test intermediate values to see that the input data is correct
    and the calculations on that data are correct.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望通过实时运行应用程序并输出*跟踪消息*来测试您的代码，以测试您的算法是否有效。有时，您会希望测试函数的调用顺序（例如，在`switch`语句或`if`语句中正确分支的发生），在其他情况下，您会希望测试中间值，以确保输入数据正确并且对该数据的计算正确。
- en: Trace messages can produce a lot of data, so it is unwise to send these to the
    console. It is extremely important that trace messages are only produced in debug
    builds. If you leave trace messages in product code, it could seriously impact
    the performance of your application (as will be explained later). Further, trace
    messages are unlikely to be localized, nor will they be checked to see if they
    contain information that could be used to reverse-engineer your algorithms. One
    final issue with trace messages in release builds is that your client will think
    that you are providing them with code that has not been completely tested. It
    is important, then, that trace messages are only generated in debug builds, when
    the `_DEBUG` symbol is defined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪消息可能会产生大量数据，因此将这些消息发送到控制台是不明智的。跟踪消息仅在调试构建中生成非常重要。如果在产品代码中保留跟踪消息，可能会严重影响应用程序的性能（稍后将进行解释）。此外，跟踪消息不太可能被本地化，也不会被检查以查看它们是否包含可用于反向工程您的算法的信息。在发布构建中跟踪消息的另一个问题是，您的客户将认为您正在为他们提供尚未完全测试的代码。因此，非常重要的是，只有在调试构建中定义了`_DEBUG`符号时，才会生成跟踪消息。
- en: The C Runtime provides a series of macros with names starting with `_RPT` that
    can be used to trace messages when `_DEBUG` is defined. There are `char` and wide
    char versions of these macros, and there are versions that will report just the
    trace messages and others that will report the message and the location (source
    file and line number) of the message. Ultimately these macros will call a function
    called `_CrtDbgReport` that will generate the message with the settings that have
    been determined elsewhere.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时提供了一系列以`_RPT`开头的宏，当定义了`_DEBUG`时可以用于跟踪消息。这些宏有`char`和宽字符版本，还有一些版本只报告跟踪消息，另一些版本报告消息和消息的位置（源文件和行号）。最终，这些宏将调用一个名为`_CrtDbgReport`的函数，该函数将使用在其他地方确定的设置生成消息。
- en: 'The `_RPTn` macros (where `n` is `0`, `1`, `2`, `3`, `4`, or `5`) will take
    a format string and 0 to 5 parameters that will be put into the string before
    being reported. The first parameter of the macros indicates the type of message
    to report: `_CRT_WARN`, `_CRT_ERROR`, or `_CRT_ASSERT`. The last two of these
    categories are the same and refer to asserts, which will be covered in a later
    section. The second parameter of the report macros is a format string, which will
    then be followed by the required number of parameters. The `_RPTFn` macros are
    the same format but will report the source file and line number as well as the
    formatted message.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`_RPTn`宏（其中`n`为`0`、`1`、`2`、`3`、`4`或`5`）将接受一个格式字符串和0到5个参数，这些参数将在报告之前放入字符串中。宏的第一个参数表示要报告的消息类型：`_CRT_WARN`、`_CRT_ERROR`或`_CRT_ASSERT`。这些类别中的最后两个是相同的，指的是断言，这将在后面的部分中介绍。报告宏的第二个参数是格式字符串，然后是所需数量的参数。`_RPTFn`宏的格式相同，但还会报告源文件和行号以及格式化的消息。'
- en: 'The default action is that `_CRT_WARN` messages will produce no output and
    the `_CRT_ERROR` and `_CRT_ASSERT` messages will generate a popup window to allow
    you to abort or debug the application. You can change the response to any of these
    message categories by calling the `_CrtSetReportMode` function and providing the
    category and a value indicating the action to take. If you use `_CRTDBG_MODE_DEBUG`
    then the message will be written to the debugger output window. If you use `_CRTDBG_MODE_FILE`
    then the message will be written to a file that you can open and pass the handle
    to the `_CrtSetReportFile` function. (You can also use `_CRTDBG_FILE_STDERR` or
    `_CRTDBG_FILE_STDOUT` as the file handle to send the message to the standard output
    or the error output.) If you use `_CRTDBG_MODE_WNDW` as the report mode then the
    message will be displayed using the Abort/Retry/Ignore dialog box. Since this
    will pause the current thread of execution, it should only be used for assert
    messages (the default action):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作是`_CRT_WARN`消息不会产生输出，而`_CRT_ERROR`和`_CRT_ASSERT`消息将生成一个弹出窗口，允许您中止或调试应用程序。您可以通过调用`_CrtSetReportMode`函数并提供类别和指示要采取的操作的值来更改这些消息类别的响应。如果使用`_CRTDBG_MODE_DEBUG`，则消息将写入调试器输出窗口。如果使用`_CRTDBG_MODE_FILE`，则消息将写入一个文件，您可以打开并将句柄传递给`_CrtSetReportFile`函数。（您还可以使用`_CRTDBG_FILE_STDERR`或`_CRTDBG_FILE_STDOUT`作为文件句柄，将消息发送到标准输出或错误输出。）如果将`_CRTDBG_MODE_WNDW`作为报告模式，则消息将使用中止/重试/忽略对话框显示。由于这将暂停当前的执行线程，因此应仅用于断言消息（默认操作）：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you do not provide the `n` in the messages then the next message will be
    appended to the end of your message, and in most cases this is not what you want
    (although you could justify this for a series of calls to the `_RPTn` macros,
    where the last one is terminated with `n`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在消息中不提供`n`，则下一条消息将附加到您的消息末尾，在大多数情况下，这不是您想要的（尽管您可以为对`_RPTn`宏的一系列调用辩解，最后一个使用`n`终止）。
- en: The Visual Studio output window is shown when you compile a project (to show
    it at debug time select the Output option in the View menu), and at the top is
    a combo box labelled Show output from, which will be usually set to Build. If
    you set this to Debug then you will see the debugging messages generated during
    a debugging session. These will include messages about loading debugging symbols
    and messages redirected from the `_RPTn` macros to the output window.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译项目时，Visual Studio输出窗口会显示（在View菜单中选择Output选项以在调试时显示），顶部有一个标有“显示输出来自”的组合框，通常设置为Build。如果将其设置为Debug，则将在调试会话期间看到生成的调试消息。这些消息将包括有关加载调试符号的消息以及从`_RPTn`宏重定向到输出窗口的消息。
- en: 'If you prefer the messages to be directed to a file then you need to open the
    file with the Win32 `CreateFile` function and use the handle from that function
    in a call to the `_CrtSetReportFile` function. To do this, you will need to include
    the Windows header files:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将消息定向到文件，则需要使用Win32的`CreateFile`函数打开文件，并在调用`_CrtSetReportFile`函数时使用该函数的句柄。为此，您需要包含Windows头文件：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `WIN32_LEAN_AND_MEAN` macro will reduce the size of the Windows files included.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIN32_LEAN_AND_MEAN`宏将减小包含的Windows文件的大小。'
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code will direct the warning messages to the text file `log.txt` which
    will be created new every time the application is run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将警告消息定向到文本文件`log.txt`，每次应用程序运行时都会创建新的文件。
- en: Tracing messages with Windows
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Windows跟踪消息
- en: The `OutputDebugString` function is used to send messages to a debugger. The
    function does this through a *shared memory section* called `DBWIN_BUFFER`. Shared
    memory means that any process can access this memory, and so Windows provides
    two *event objects* called `DBWIN_BUFFER_READY` and `DBWIN_DATA_READY` that control
    read and write access to this memory. These event objects are shared between processes
    and can be in a signalled or unsignalled state. A debugger will indicate that
    it is no longer using the shared memory by signalling the `DBWIN_BUFFER_READY`
    event, at which point the `OutputDebugString` function can write the data to the
    shared memory. The debugger will wait on the `DBWIN_DATA_READY` event, which will
    be signalled by the `OutputDebugString` function when it has finished writing
    to the memory and it is safe to read the buffer. The data written to the memory
    section will be the process ID of the process that called the `OutputDebugString`
    function, followed by a string of up to 4 KB of data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutputDebugString`函数用于向调试器发送消息。该函数通过名为`DBWIN_BUFFER`的*共享内存区域*执行此操作。共享内存意味着任何进程都可以访问该内存，因此Windows提供了两个名为`DBWIN_BUFFER_READY`和`DBWIN_DATA_READY`的*事件对象*来控制对该内存的读写访问。这些事件对象在进程之间共享，并且可以处于已发信号或未发信号状态。调试器将通过发信号的`DBWIN_BUFFER_READY`事件指示它不再使用共享内存，此时`OutputDebugString`函数可以将数据写入共享内存。调试器将等待`DBWIN_DATA_READY`事件，当`OutputDebugString`函数完成对内存的写入并且可以安全地读取缓冲区时，该事件将被`OutputDebugString`函数发出信号。写入内存区域的数据将是调用`OutputDebugString`函数的进程ID，后跟长达4
    KB的数据字符串。'
- en: 'The problem is that when you call the `OutputDebugString` function it will
    wait on the `DBWIN_BUFFER_READY` event, which means that when you use this function
    you are coupling the performance of your application to the performance of another
    process, which is usually a debugger (but may not be). It is very easy to write
    a process to access the `DBWIN_BUFFER` shared memory section and get access to
    the associated event objects, so it may be possible that your production code
    will run on a machine where someone has such an application running. For this
    reason, it is vitally important that you use conditional compilation so that the
    `OutputDebugString` function is only used in debug builds--code that will never
    be released to your customers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当调用`OutputDebugString`函数时，它将等待`DBWIN_BUFFER_READY`事件，这意味着当您使用此函数时，您正在将应用程序的性能与另一个进程的性能（通常是调试器，但也可能不是）耦合在一起。编写一个进程来访问`DBWIN_BUFFER`共享内存区域并访问相关的事件对象非常容易，因此可能会出现您的生产代码在运行具有此类应用程序的机器上。因此，非常重要的是您使用条件编译，以便`OutputDebugString`函数仅在调试版本中使用--不会发布给您的客户的代码：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will need to include the `windows.h` header file to compile this code. As
    for the `_RPT` example, you will have to run this code under a debugger to see
    the output, or have an application like **DebugView** (available from Microsoft's
    Technet website) running.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码需要包含`windows.h`头文件。至于`_RPT`示例，您将需要在调试器下运行此代码以查看输出，或者运行类似**DebugView**（可从微软的Technet网站获取）的应用程序。
- en: Windows provides the `DBWinMutex` mutex object to act as an overall *key* to
    accessing this shared memory and event objects. As the name suggests, when you
    have a handle to a mutex you will have mutually exclusive access to the resource.
    The problem is that processes do not have to have a handle to this mutex to use
    these resources and consequently you have no guarantee that, if your application
    thinks it has exclusive access that it will really have exclusive access.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Windows提供了`DBWinMutex`互斥对象，用作访问此共享内存和事件对象的整体*关键*。顾名思义，当您拥有互斥体的句柄时，您将对资源具有互斥访问权限。问题在于，进程不必拥有此互斥体的句柄即可使用这些资源，因此您无法保证，如果您的应用程序认为它具有独占访问权限，它是否真的具有独占访问权限。
- en: Using asserts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言
- en: 'An assert checks that a condition is true. The assertion means just that: the
    program should not continue if the condition is not true. Clearly asserts should
    not be called in release code and hence conditional compilation must be used.
    Asserts should be used to check for conditions that should never happen: never
    events. Since the conditions do not happen there should be no need for asserts
    in release builds.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 断言检查条件是否为真。断言的意思就是：如果条件不为真，程序就不应该继续执行。显然，断言不应该在发布代码中调用，因此必须使用条件编译。断言应该用于检查永远不会发生的条件：永远不会发生的事件。由于条件不会发生，因此在发布版本中不需要断言。
- en: The C Runtime provides the `assert` macro that is available through the `<cassert>`
    header file. The macro, and any functions called in the expression passed as its
    only parameter, will be called unless the `NDEBUG` symbol is defined. That is,
    you do not have to define the `_DEBUG` symbol to use asserts and you should have
    taken extra action to explicitly prevent `assert` from being called.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时提供了通过`<cassert>`头文件可用的`assert`宏。除非定义了`NDEBUG`符号，否则将调用该宏以及作为其唯一参数传递的表达式中调用的任何函数。也就是说，您不必定义`_DEBUG`符号来使用断言，并且应该采取额外的措施来明确阻止调用`assert`。
- en: It is worth re-iterating this. The `assert` macro is defined even if `_DEBUG`
    is not defined, so an assert could be called in release code. To prevent this
    from happening you must define the `NDEBUG` symbol in a release build. Conversely,
    you can define the `NDEBUG` symbol in a debug build so that you can use tracing
    but do not have to use asserting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次强调。即使未定义`_DEBUG`，`assert`宏也是定义的，因此断言可能会在发布代码中调用。为了防止这种情况发生，您必须在发布版本中定义`NDEBUG`符号。相反，您可以在调试版本中定义`NDEBUG`符号，以便您可以使用跟踪，但不必使用断言。
- en: 'Typically, you will use asserts in debug builds to check that pre- and post-conditions
    are met in a function and that class invariant conditions are fulfilled. For example,
    you may have a binary buffer that has a special value at the tenth byte position
    and so have written a function to extract that byte:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将在调试版本中使用断言来检查函数中是否满足前置条件和后置条件，以及是否满足类不变条件。例如，您可能有一个二进制缓冲区，在第十个字节位置有一个特殊值，因此编写了一个提取该字节的函数：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the calls to `assert` are used to check that the pointer is not `nullptr`
    and that the buffer is big enough. If these asserts are true, then it means that
    it is safe to access the tenth byte through the pointer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对`assert`的调用用于检查指针不是`nullptr`，并且缓冲区足够大。如果这些断言为真，则意味着可以通过指针安全地访问第十个字节。
- en: Although it is not strictly necessary in this code, the assertion expressions
    are given in parentheses. It is good to get into the habit of doing this because
    `assert` is a macro and so a comma in the expression will be treated as a macro
    parameter separator; the parentheses protected against this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这段代码中严格来说不是必需的，但是断言表达式是用括号括起来的。养成这样做的习惯是很好的，因为`assert`是一个宏，所以表达式中的逗号将被视为宏参数分隔符；括号可以防止这种情况发生。
- en: 'Since the `assert` macro will be defined in release builds by default, you
    will have to disable them by defining `NDEBUG` on the compiler command line, in
    your make file, or you may want to use conditional compilation explicitly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`assert`宏将默认在发布版本中定义，因此您将需要通过在编译器命令行上定义`NDEBUG`来禁用它们，在您的make文件中，或者您可能希望明确使用条件编译：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If an assert is called and it fails, then an assert message is printed at the
    console along with source file and line number information and then the process
    is terminated with a call to `abort`. If the process is built with release build
    standard libraries then the process `abort` is straightforward, however, if the
    debug builds are used then the user will see the standard Abort/Retry/Ignore message
    box where the Abort and Ignore options abort the process. The Retry option will
    use **Just-in-Time** (**JIT**) debugging to attach the registered debugger to
    the process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用断言并失败，则会在控制台上打印断言消息，以及源文件和行号信息，然后通过调用`abort`终止进程。如果进程是使用发布版本的标准库构建的，则进程`abort`是直接的，但是如果使用调试构建，则用户将看到标准的中止/重试/忽略消息框，其中中止和忽略选项将中止进程。重试选项将使用**即时**（**JIT**）调试将注册的调试器附加到进程。
- en: In contrast, the `_ASSERT` and `_ASSERTE` macros are only defined when `_DEBUG`
    is defined, so these macros will not be available in release builds. Both macros
    take an expression and generate an assert message when the expression is `false`.
    The message for the `_ASSERT` macro will include the source file and line number
    and a message stating that the assertion failed. The message for the `_ASSERTE`
    macro is similar but includes the expression that failed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当定义了`_DEBUG`时，`_ASSERT`和`_ASSERTE`宏才被定义，因此这些宏在发布版本中将不可用。这两个宏都接受一个表达式，并在表达式为`false`时生成一个断言消息。`_ASSERT`宏的消息将包括源文件和行号，以及一个说明断言失败的消息。`_ASSERTE`宏的消息类似，但包括失败的表达式。
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code sets the reporting mode so that the failed assert will be a message
    printed on the console (rather than the default, which is the Abort/Retry/Ignore
    dialog). Since the variable is clearly less than 100, the assert will fail and
    so the process will terminate and the following message will be printed on the
    console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了报告模式，以便失败的断言将作为消息打印在控制台上（而不是默认的中止/重试/忽略对话框）。由于变量显然小于100，断言将失败，因此进程将终止，并且以下消息将打印在控制台上：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Abort/Retry/Ignore dialog gives the person, testing the application, the
    option of attaching the debugger to the process. If you decide that the failure
    of the assertion is heinous you can force the debugger to attach to the process
    by calling `_CrtDbgBreak`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 中止/重试/忽略对话框为测试应用程序的人提供了将调试器附加到进程的选项。如果您决定断言的失败是可恶的，您可以通过调用`_CrtDbgBreak`强制调试器附加到进程。
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You do not need to use conditional compilation because in release builds the
    `_CrtDbgBreak` function is a no-operation. In a debug build, this code will trigger
    JIT debugging, which gives you the option to close the application or launch the
    debugger, and if you choose the latter, the registered JIT debugger will be started.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用条件编译，因为在发布版本中，`_CrtDbgBreak`函数是一个无操作。在调试构建中，此代码将触发JIT调试，这将给您关闭应用程序或启动调试器的选项，如果选择后者，则注册的JIT调试器将启动。
- en: Application termination
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: The `main` function is the entry point for your application. However, this isn't
    called directly by the operating system because C++ will perform initialization
    before `main` is called. This includes constructing the Standard Library global
    objects (`cin`, `cout`, `cerr`, `clog,` and the wide character versions) and there
    is a whole host of initialization that is performed for the C Runtime Library
    that underpins C++ libraries. Further, there are the global and static objects
    that your code creates. When the `main` function returns, the destructors of global
    and static objects will have to be called and a clean-up performed on the C runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数是应用程序的入口点。但是，操作系统不会直接调用它，因为C++会在调用`main`之前执行初始化。这包括构造标准库的全局对象（`cin`、`cout`、`cerr`、`clog`和宽字符版本），以及为支持C++库的C运行时库执行的一系列初始化。此外，还有代码创建的全局和静态对象。当`main`函数返回时，将必须调用全局和静态对象的析构函数，并在C运行时上执行清理。'
- en: There are several ways to stop a process deliberately. The simplest is to return
    from the `main` function, but this assumes that there is a simple route back to
    the `main` function from the point that your code wants to finish the process.
    Of course, process termination must be ordered and you should avoid writing code
    where it is normal to stop the process anywhere in the code. However, if you have
    a situation where data is corrupted and unrecoverable and any other action could
    damage more data, you may have no option other than to terminate the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以有意终止进程。最简单的方法是从`main`函数返回，但这假设从代码希望完成进程的地方返回到`main`函数有一个简单的路径。当然，进程终止必须是有序的，您应该避免编写在代码的任何地方停止进程是正常的代码。但是，如果您遇到数据损坏且无法恢复的情况，而且任何其他操作都可能损坏更多数据，那么除了终止应用程序外可能别无选择。
- en: The `<cstdlib>` header file provides access to the header files to the functions
    that allow you to terminate and to handle the termination of an application. When
    a C++ program closes down normally, the C++ infrastructure will call the destructors
    of the objects created in the `main` function (in the reverse order to their construction)
    and the destructors of `static` objects (which may have been created in functions
    other than the `main` function). The `atexit` function allows you to register
    functions (that have no parameters and no return value) that will be called after
    the `main` function completes and `static` object destructors have been called.
    You can register more than one function by calling this function several times,
    and at termination the functions will be called in reverse order to their registering.
    After the functions registered with the `atexit` function have been called, the
    destructors of any global objects will be called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cstdlib>`头文件提供了访问允许您终止和处理应用程序终止的函数的头文件。当C++程序正常关闭时，C++基础设施将调用在`main`函数中创建的对象的析构函数（按照它们构造的相反顺序）和`static`对象的析构函数（可能是在`main`函数之外的函数中创建的）。`atexit`函数允许您注册函数（没有参数和返回值）在`main`函数完成和调用`static`对象析构函数之后调用。您可以通过多次调用此函数注册多个函数，并在终止时按照它们注册的相反顺序调用这些函数。在调用`atexit`函数注册的函数之后，将调用任何全局对象的析构函数。'
- en: There is also a Microsoft function called `_onexit` that also allows you to
    register functions to be called during normal termination.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`_onexit`的Microsoft函数，它也允许您注册在正常终止期间调用的函数。
- en: The `exit` and `_exit` functions perform a normal exit of a process, that is,
    they clean up the C runtime and flush any open files before shutting down the
    process. The `exit` function does additional work by calling any registered termination
    functions; the `_exit` function does not call these termination functions and
    so is a quick exit. These functions will not call the destructors of temporary
    or automatic objects, so if you use stack objects to manage resources, you will
    have to explicitly call the destructor code before calling `exit`. However, the
    destructors of static and global objects will be called.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`和`_exit`函数执行进程的正常退出，即在关闭进程之前清理C运行时并刷新任何打开的文件。`exit`函数通过调用任何已注册的终止函数执行额外的工作；`_exit`函数不调用这些终止函数，因此是一个快速退出。这些函数不会调用临时或自动对象的析构函数，因此如果您使用堆栈对象来管理资源，您必须在调用`exit`之前显式调用析构函数代码。但是，静态和全局对象的析构函数将被调用。'
- en: The `quick_exit` function causes normal shutdown, but it does not call any destructors
    nor flush any streams, so there is no resource clean up. The functions registered
    with `atexit` are not called, but you can register that termination functions
    are called by registering them with the `at_quick_exit` function. After calling
    these termination functions, the `quick_exit` function calls the `_Exit` function
    that shuts down the process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_exit`函数导致正常关闭，但不调用任何析构函数，也不刷新任何流，因此没有资源清理。`atexit`注册的函数不会被调用，但您可以通过使用`at_quick_exit`函数注册终止函数来调用它们。在调用这些终止函数之后，`quick_exit`函数调用关闭进程的`_Exit`函数。'
- en: You can also call the `terminate` function to close down a process with no clean
    up. This process will call a function that has been registered with the `set_terminate`
    function and then calls the `abort` function. If an exception occurs in the program
    and is not caught--and hence propagates to the `main` function - the C++ infrastructure
    will call the `terminate` function. The `abort` function is the most severe of
    mechanisms that terminate a process. This function will exit the process without
    calling the destructors of objects or performing any other clean up. The function
    raises the `SIGABORT` signal and so it is possible to register a function with
    the `signal` function, which will be called before the process terminates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调用`terminate`函数来关闭一个没有清理的进程。这个进程将调用一个已经注册了`set_terminate`函数的函数，然后调用`abort`函数。如果程序中发生异常并且没有被捕获
    - 因此传播到`main`函数 - C++基础设施将调用`terminate`函数。`abort`函数是终止进程的最严重的机制。这个函数将在不调用对象的析构函数或执行任何其他清理的情况下退出进程。该函数会引发`SIGABORT`信号，因此可以使用`signal`函数注册一个在进程终止之前调用的函数。
- en: Error values
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误值
- en: Some functions are designed to perform an action and return a value based on
    that action, for example, `sqrt` will return the square root of a number. Other
    functions perform more complex operations and use the return value to indicate
    whether the function was successful. There is no common convention about such
    error values, so if a function returns a simple integer there is no guarantee
    that the values one library uses have the same meaning as values returned from
    functions in another library. This means that you have to examine carefully the
    documentation for any library code that you use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数旨在执行操作并根据该操作返回一个值，例如，`sqrt`将返回一个数字的平方根。其他函数执行更复杂的操作，并使用返回值指示函数是否成功。关于这种错误值，没有共同的约定，因此如果一个函数返回一个简单的整数，就不能保证一个库使用的值与另一个库中的函数返回的值具有相同的含义。这意味着您必须仔细检查您使用的任何库代码的文档。
- en: Windows does provide common error values, which can be found in the `winerror.h`
    header file, and the functions in the Windows **Software Development Kit** (**SDK**)
    only return values in this file. If you write library code that will be used exclusively
    in Windows applications, consider using the error values in this file because
    you can use the Win32 `FormatMessage` function to obtain a description of the
    error, as explained in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Windows提供了常见的错误值，可以在`winerror.h`头文件中找到，Windows **软件开发工具包**（**SDK**）中的函数只返回此文件中的值。如果您编写的库代码将专门用于Windows应用程序，请考虑使用此文件中的错误值，因为您可以使用Win32的`FormatMessage`函数来获取错误的描述，如下一节所述。
- en: The C Runtime Library provides a global variable called `errno` (in fact it
    is a macro that you can treat as a variable). C functions will return a value
    to indicate that they have failed and you access the `errno` value to determine
    what the error was. The `<errno.h>` header file defines the standard POSIX error
    values. The `errno` variable does not indicate success, it only indicates errors,
    so you should only access it when a function has indicated that there is an error.
    The `strerror` function will return a C string with a description of the error
    value that you pass as a parameter; these messages are localized according to
    the current C locale set through a call to the `setlocale` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时库提供了一个名为“errno”的全局变量（实际上它是一个宏，您可以将其视为变量）。 C函数将返回一个值来指示它们已经失败，并且您可以访问“errno”值来确定错误是什么。
    “<errno.h>”头文件定义了标准的POSIX错误值。“errno”变量不表示成功，它只表示错误，因此只有在函数指示存在错误时才应该访问它。“strerror”函数将返回一个C字符串，其中包含您作为参数传递的错误值的描述；这些消息根据通过调用“setlocale”函数设置的当前C语言环境进行本地化。
- en: Obtaining message descriptions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取消息描述
- en: 'To obtain the description at runtime for a Win32 error code you use the Win32
    `FormatMessage` function. This will get the description for a system message or
    for a custom message (described in the next section). If you want to use a custom
    message you have to load the executable (or DLL) that has the message resource
    bound to it and pass the `HMODULE` handle to the `FormatMessage` function. If
    you want to get the description of a system message you do not need to load a
    module because Windows will do this for you. For example, if you call the Win32
    `CreateFile` function to open a file and the file cannot be found, the function
    will return a value of `INVALID_HANDLE_VALUE,` indicating that there is an error.
    To get details of the error you call the `GetLastError` function (which returns
    a 32-bit unsigned value sometimes called `DWORD` or `HRESULT`). You can then pass
    the error value to `FormatMessage`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时获取Win32错误代码的描述，您可以使用Win32“FormatMessage”函数。这将获取系统消息或自定义消息的描述（在下一节中描述）。如果要使用自定义消息，则必须加载具有绑定到其上的消息资源的可执行文件（或DLL），并将“HMODULE”句柄传递给“FormatMessage”函数。如果要获取系统消息的描述，则不需要加载模块，因为Windows会为您执行此操作。例如，如果调用Win32“CreateFile”函数打开一个文件并且找不到文件，函数将返回一个“INVALID_HANDLE_VALUE”的值，表示存在错误。要获取错误的详细信息，您可以调用“GetLastError”函数（它返回一个32位无符号值，有时称为“DWORD”或“HRESULT”）。然后，您可以将错误值传递给“FormatMessage”：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code tries to open a file that does not exist and obtains the error value
    associated with the failure (this will be a value of `ERROR_FILE_NOT_FOUND`).
    The code then calls the `FormatMessage` function to get the string describing
    the error. The first parameter of the function is a flag that indicates how the
    function should work; in this case, the `FORMAT_MESSAGE_FROM_SYSTEM` flag says
    that the error is a system error and the `FORMAT_MESSAGE_ALLOCATE_BUFFER` flag
    says that the function should allocate a buffer large enough to hold the string
    using the Win32 `LocalAlloc` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码尝试打开一个不存在的文件，并获取与失败相关的错误值（这将是一个“ERROR_FILE_NOT_FOUND”值）。然后，代码调用“FormatMessage”函数获取描述错误的字符串。函数的第一个参数是一个标志，指示函数应该如何工作；在这种情况下，“FORMAT_MESSAGE_FROM_SYSTEM”标志表示错误是系统错误，“FORMAT_MESSAGE_ALLOCATE_BUFFER”标志表示函数应该使用Win32“LocalAlloc”函数分配足够大的缓冲区来容纳字符串。
- en: If the error is a custom value that you have defined then you should use the
    `FORMAT_MESSAGE_FROM_HMODULE` flag, open the file with `LoadLibrary` and use the
    resulting `HMODULE` as the parameter passed in through the second parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误是您定义的自定义值，则应使用“FORMAT_MESSAGE_FROM_HMODULE”标志，使用“LoadLibrary”打开文件，并使用生成的“HMODULE”作为通过第二个参数传递的参数。
- en: 'The third parameter is the error message number (from `GetLastError`) and the
    fourth is a `LANGID` that indicates the language ID to use (in this case `LANG_USER_DEFAULT`
    to get the language ID for the current logged on user). The `FormatMessage` function
    will generate a formatted for the error value, and this string may have replacement
    parameters. The formatted string is returned in a buffer and you have two options:
    you can allocate a character buffer and pass the pointer in as the fifth and the
    length as the sixth parameter, or you can request the function to allocate a buffer
    using the `LocalAlloc` function as in this example. To get access to a function
    allocated buffer you pass the *address* of a pointer variable via the fifth parameter.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是错误消息编号（来自“GetLastError”），第四个是指示要使用的语言ID的“LANGID”（在这种情况下，使用“LANG_USER_DEFAULT”获取当前登录用户的语言ID）。
    “FormatMessage”函数将为错误值生成一个格式化的字符串，这个字符串可能有替换参数。格式化的字符串以缓冲区的形式返回，您有两个选项：您可以分配一个字符缓冲区，并将指针作为第五个参数传递，长度作为第六个参数传递，或者您可以请求函数使用“LocalAlloc”函数分配一个缓冲区，就像这个例子中一样。要访问函数分配的缓冲区，您通过第五个参数传递指针变量的*地址*。
- en: Note that the fifth parameter is used to either take a pointer to a user allocated
    buffer, or returns the address of system allocated buffer, and this is why in
    this case the pointer to pointer has to be cast.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第五个参数用于接受指向用户分配的缓冲区的指针，或者返回系统分配的缓冲区的地址，这就是为什么在这种情况下必须对指针进行转换的原因。
- en: 'Some format strings may have parameters, and if so, the values are passed in
    through an array in the seventh parameter (in this case, no array is passed).
    The result of the preceding code is the string:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 某些格式字符串可能有参数，如果有，这些值将通过第七个参数中的数组传递（在这种情况下，没有传递数组）。前面代码的结果是字符串：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the message compiler, resource files, and the `FormatMessage`, you can
    provide a mechanism to return error values from your functions and then convert
    these to localized strings according to the current locale.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息编译器、资源文件和“FormatMessage”，您可以提供一种机制，从您的函数返回错误值，然后根据当前语言环境将其转换为本地化字符串。
- en: Using the Message Compiler
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息编译器
- en: The previous example showed that you can obtain localized strings for Win32
    errors, but that you can also create your own errors and provide localized strings
    that are bound as resources to your process or library. If you intend to report
    errors to the end user, you have to make sure that the descriptions are localized.
    Windows provides a tool called the Message Compiler (`mc.exe`) that will take
    a text file with entries for messages in various languages and compile them into
    binary resources that can be bound to a module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，您可以获取Win32错误的本地化字符串，但也可以创建自己的错误并提供绑定为资源的本地化字符串以报告错误给最终用户，您必须确保描述已本地化。Windows提供了一个名为消息编译器（`mc.exe`）的工具，它将接受包含各种语言中消息条目的文本文件，并将它们编译成可以绑定到模块的二进制资源。
- en: 'For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This defines three localized strings for the same message. The messages here
    are simple strings, but you can define format messages with placeholders that
    can be provided at runtime. The *neutral* language is US English, and in addition
    we define strings for British English, and French. The names used for the languages
    are defined in the `LanguageNames` lines at the top of the file. These entries
    have the name that will be used later in the file, the code page for the language,
    and the name of the binary resource that will contain the message resource.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这为相同消息定义了三个本地化字符串。这里的消息是简单的字符串，但您可以定义带有占位符的格式消息，这些占位符可以在运行时提供。*中性*语言是美国英语，此外我们还为英国英语和法语定义了字符串。语言的名称在文件顶部的`LanguageNames`行中定义。这些条目具有稍后在文件中使用的名称，语言的代码页以及将包含消息资源的二进制资源的名称。
- en: 'The `MessageId` is the identifier that will be used by the `FormatMessage`
    function, and the `SymbolicName` is a pre-processor symbol that will be defined
    in a header file, so that you can use this message in your C++ code rather than
    the number. This file is compiled by passing it to the command line utility `mc.exe`,
    which will create five files: a header file with the definition of the symbol,
    three binary sources (`MSG00001.bin`, which is created by default for the neutral
    language, and `MSG00409.bin` and `MSG0040C.bin,` which are created because of
    the `LanguageNames` lines), and a resource compiler file.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageId`是`FormatMessage`函数将使用的标识符，`SymbolicName`是一个预处理器符号，将在头文件中定义，以便您可以在C++代码中使用此消息而不是数字。通过将此文件传递给命令行实用程序`mc.exe`来编译此文件，将创建五个文件：一个具有符号定义的头文件，三个二进制源文件（`MSG00001.bin`，默认情况下为中性语言创建，以及`MSG00409.bin`和`MSG0040C.bin`，由于`LanguageNames`行而创建），以及一个资源编译器文件。'
- en: 'For this example, the resource compiler file (with extension `.rc`) will contain:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，资源编译器文件（扩展名为`.rc`）将包含：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a standard resource file that can be compiled by the Windows SDK resource
    compiler (`rc.exe`), which will compile the message resources into a `.res` file
    that can be bound to an executable or DLL. A process or DLL that has a resource
    of type `11` bound to it can be used by the `FormatMessage` function as a source
    of descriptive error strings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的资源文件，可以通过Windows SDK资源编译器（`rc.exe`）编译，该编译器将消息资源编译成一个`.res`文件，可以绑定到可执行文件或DLL。具有类型`11`的资源的进程或DLL可以被`FormatMessage`函数用作描述性错误字符串的来源。
- en: Typically, you will not use a message ID of 1 because it is unlikely to be unique
    and you are likely to want to take advantage of the *facility code* and *severity
    code* (for details of facility code, look in the `winerror.h` header file). Further,
    to indicate that the message is not Windows you can set the customer bit of the
    error code using the `/c` switch when you run `mc.exe`. This will mean that your
    error code will not be a simple value like 1, but this should not matter because
    your code will use the symbol defined in the header file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会使用消息ID 1，因为它不太可能是唯一的，您可能希望利用*设施代码*和*严重代码*（有关设施代码的详细信息，请查看`winerror.h`头文件）。此外，为了指示消息不是Windows，您可以在运行`mc.exe`时使用`/c`开关设置错误代码的客户位。这意味着您的错误代码不会是简单的值，比如1，但这不重要，因为您的代码将使用头文件中定义的符号。
- en: C++ exceptions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++异常
- en: As the name suggests, exceptions are for exceptional conditions. They are not
    normal conditions. They are not conditions that you want to occur but they are
    conditions that may happen. Any exceptional condition will often mean that your
    data will be in an inconsistent state, so using exceptions means that you need
    to think in transactional terms, that is, an operation either succeeds, or the
    state of an object should remain the same as it was before the operation was attempted.
    When an exception occurs in a code block, everything that happened in the code
    block will be invalid. If the code block is part of a wider code block (say, a
    function that is a series of function calls by another function) then the work
    in that other code block will be invalid. This means that the exception may propagate
    out to other code blocks further up the call stack, invalidating the objects that
    depend on the operation being successful. At some point, the exceptional condition
    will be recoverable, so you will want to prevent the exception going further.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，异常是用于异常情况的。它们不是正常情况。它们不是您希望发生的情况，但它们可能会发生。任何异常情况通常意味着您的数据将处于不一致的状态，因此使用异常意味着您需要以事务性术语思考，即，操作要么成功，要么对象的状态应保持与尝试操作之前相同。当代码块中发生异常时，代码块中发生的所有事情都将无效。如果代码块是更广泛代码块的一部分（比如，由另一个函数调用的一系列函数调用的函数），那么另一个代码块中的工作将无效。这意味着异常可能传播到调用堆栈更高处的其他代码块，使依赖于操作成功的对象无效。在某个时候，异常情况将是可恢复的，因此您将希望阻止异常进一步传播。
- en: Exception specifications
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常规范
- en: Exception specifications are deprecated in C++11 but you may see them in earlier
    code. A specification is through the `throw` expression applied to a function
    declaration giving the exceptions that can be thrown from the function. The `throw`
    specification can be an ellipsis, which means that the function can throw exceptions
    but the type is not specified. If the specification is empty then it means the
    function won't throw exceptions, and this is the same as using the `noexcept`
    specifier in C++11.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 异常规范在C++11中已被弃用，但您可能会在早期的代码中看到它们。规范是通过应用于函数声明的`throw`表达式来指定可以从函数中抛出的异常。`throw`规范可以是省略号，这意味着函数可以抛出异常，但类型未指定。如果规范为空，则意味着函数不会抛出异常，这与在C++11中使用`noexcept`指定符相同。
- en: The `noexcept` specifier tells the compiler that exception handling is not required,
    so if an exception does occur in the function the exception will not be bubbled
    out of the function and the `terminate` function will be called immediately. In
    this situation, there is no guarantee that the destructors of the automatic objects
    are called.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`指定符告诉编译器不需要异常处理，因此如果函数中发生异常，异常将不会从函数中冒出，并且将立即调用`terminate`函数。在这种情况下，不能保证自动对象的析构函数被调用。'
- en: C++ exception syntax
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++异常语法
- en: 'In C++, an exceptional situation is generated by throwing an exception object.
    That exception object can be anything you like: an object, a pointer, or a built-in
    type, but because exceptions may be handled by code written by other people it
    is best to standardize the objects that are used to represent exceptions. For
    this, the Standard Library provides the `exception` class, which can be used as
    a base class.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，异常情况是通过抛出异常对象来生成的。该异常对象可以是任何你喜欢的东西：一个对象，一个指针，或者一个内置类型，但是因为异常可能会被其他人编写的代码处理，最好是标准化用于表示异常的对象。为此，标准库提供了`exception`类，它可以用作基类。
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code tests the parameter and if it is zero then it throws an exception.
    Four examples are given and all are valid C++, but only the last version is acceptable
    because it uses a Standard Library class (or one derived from the Standard Library
    classes) and it follows the convention that exceptions are thrown by value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码测试参数，如果为零，则抛出异常。给出了四个例子，所有都是有效的C++，但只有最后一个版本是可接受的，因为它使用了一个标准库类（或者从标准库类派生的类），并且遵循了异常通过值抛出的约定。
- en: When an exception is thrown, the exception handling infrastructure takes over.
    Execution will stop in the current code block and the exception will be propagated
    up the call stack. As the exception propagates through a code block, all the automatic
    objects will be destroyed, but objects created on the heap in the code black will
    not be destroyed. This is a process called **stack unwinding,** whereby each stack
    frame is cleaned up as much as possible before the exception moves to the stack
    frame above it in the call stack. If the exception is not caught, it will propagate
    up to the `main` function, at which point the `terminate` function will be called
    to handle the exception (and hence it will terminate the process).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，异常处理基础设施接管。执行将停止在当前代码块中，并且异常将向上传播到调用堆栈。随着异常在代码块中传播，所有自动对象将被销毁，但是在代码块中在堆上创建的对象将不会被销毁。这是一个称为**堆栈展开**的过程，即在异常移动到调用堆栈中的上面的堆栈帧之前，尽可能清理每个堆栈帧。如果异常没有被捕获，它将传播到`main`函数，此时将调用`terminate`函数来处理异常（因此将终止进程）。
- en: 'You can protect code to handle propagated exceptions. Code is protected with
    a `try` block and it is caught with an associated `catch` block:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保护代码以处理传播的异常。代码受到`try`块的保护，并且通过相关的`catch`块捕获：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unlike other code blocks in C++, braces are mandatory even if the `try` and
    `catch` blocks contain single lines of code. In the preceding code the second
    call to the `reciprocal` function will throw an exception. The exception will
    halt the execution of any more code in the block, so the third call to the `reciprocal`
    function will not occur. Instead, the exception propagates out of the code block.
    The `try` block is the scope of the objects defined between the braces, and this
    means that the destructors of these objects will be called (`s` and `v`). Control
    is then passed to the associated `catch` blocks, and in this case, there is just
    one handler. The `catch` block is a separate block to the `try` block, so you
    cannot access any variables defined in the `try` block. This makes sense because
    when an exception is generated the entire code block is *tainted* so you cannot
    trust any object created in that block. This code uses the accepted convention,
    that is, exceptions are caught by reference, so that the actual exception object,
    and not a copy, is caught.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++中的其他代码块不同，即使`try`和`catch`块只包含单行代码，花括号也是必需的。在前面的代码中，对`reciprocal`函数的第二次调用将引发异常。异常将停止代码块中的任何更多代码的执行，因此不会发生对`reciprocal`函数的第三次调用。相反，异常传播出代码块。`try`块是在花括号之间定义的对象的作用域，这意味着这些对象的析构函数将被调用（`s`和`v`）。然后控制传递给相关的`catch`块，在这种情况下，只有一个处理程序。`catch`块是`try`块的一个单独的块，因此您不能访问在`try`块中定义的任何变量。这是有道理的，因为当生成异常时，整个代码块都是*被污染的*，因此您不能信任在该块中创建的任何对象。这段代码使用了被接受的约定，即异常是通过引用捕获的，这样就可以捕获实际的异常对象，而不是副本。
- en: 'The convention is: throw my value, catch-by-reference.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 约定是：抛出我的值，通过引用捕获。
- en: 'The Standard Library provides a function called `uncaught_exception`, which
    returns `true` if an exception has been thrown but not yet handled. It may seem
    odd to be able to test for this since no code other than the exception infrastructure
    will be called when an exception has occurred (for example the `catch` handlers)
    and you should put exception code there. However, there *is* other code that is
    called when an exception is thrown: the destructors of automatic objects that
    are destroyed during the stack clear up. The `uncaught_exception` function should
    be used in a destructor to determine if the object is being destroyed due to an
    exception rather than normal object destruction due to an object going out of
    scope or being deleted. For example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一个名为`uncaught_exception`的函数，如果异常已被抛出但尚未处理，则返回`true`。测试这一点似乎有点奇怪，因为除了异常基础设施之外，当异常发生时不会调用任何代码（例如`catch`处理程序），您应该将异常代码放在那里。然而，当异常被抛出时确实有其他代码被调用：在堆栈清除期间被销毁的自动对象的析构函数。`uncaught_exception`函数应该在析构函数中使用，以确定对象是否因异常而被销毁，而不是因对象超出范围或被删除而进行正常对象销毁。例如：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This simple object indicates if it is being destroyed because of exception
    stack unwinding. It can be tested like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的对象指示它是否因异常堆栈展开而被销毁。可以这样测试：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `f` function will throw an exception only if it is called with a `true`
    value. The `main` function calls `f` twice, once with a value of `false` (so the
    exception is not thrown in `f`) and a second time with `true`. The output is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`函数只有在用`true`值调用时才会抛出异常。`main`函数调用`f`两次，一次使用`false`值（所以`f`中不会抛出异常），第二次使用`true`。输出结果是：'
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first-time `f` is called, the `test` object is destroyed normally, so `uncaught_exception`
    will return `false`. The second-time `f` is called the `test` object in the function
    is being destroyed before the exception has been caught, so `uncaught_exception`
    will return `true`. Since an exception is thrown, the execution leaves the `try`
    block and so the `test` object in the `try` block is destroyed and `uncaught_exception`
    will return `true`. Finally, when the exception has been handled and control returns
    to code after the `catch` block, the `test` object created on the stack in the
    `main` function will be destroyed when the `main` function returns and so `uncaught_exception`
    will return `false`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`f`时，`test`对象被正常销毁，所以`uncaught_exception`将返回`false`。第二次调用`f`时，函数中的`test`对象在异常被捕获之前被销毁，所以`uncaught_exception`将返回`true`。由于抛出了异常，执行离开`try`块，所以`try`块中的`test`对象被销毁，`uncaught_exception`将返回`true`。最后，当异常被处理并控制返回到`catch`块后的代码时，`main`函数中堆栈中创建的`test`对象将在`main`函数返回时被销毁，所以`uncaught_exception`将返回`false`。
- en: Standard exception classes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准异常类
- en: 'The `exception` class is a simple container for a C string: the string is passed
    as a constructor parameter and is available through the `what` accessor. The Standard
    Library declares the exception class in the `<exception>` library, and you are
    encouraged to derive your own exception classes from this. The Standard Library
    provides the following derived classes; most are defined in `<stdexcept>`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`exception`类是一个简单的C字符串容器：字符串作为构造函数参数传递，并通过`what`访问器可用。标准库在`<exception>`库中声明了异常类，并鼓励您从中派生自己的异常类。标准库提供以下派生类；大多数在`<stdexcept>`中定义。'
- en: '| **Class** | **Thrown** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **抛出** |'
- en: '| `bad_alloc` | When the `new` operator has been unable to allocate memory
    (in `<new>`) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '`bad_alloc` | 当`new`操作符无法分配内存时（在`<new>`中）'
- en: '| `bad_array_new_length` | When the `new` operator has been asked to create
    an array with an invalid length (in `<new>`) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '`bad_array_new_length` | 当`new`操作符被要求创建一个无效长度的数组时（在`<new>`中）'
- en: '| `bad_cast` | When `dynamic_cast` to a reference type fails (in `<typeinfo>`)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '`bad_cast` | 当`dynamic_cast`到引用类型失败时（在`<typeinfo>`中）'
- en: '| `bad_exception` | An unexpected condition has occurred (in `<exception>`)
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `bad_exception` | 发生意外情况（在`<exception>`中）'
- en: '| `bad_function_call` | Invoked an empty `function` object (in `<functional>`)
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '`bad_function_call` | 调用空的`function`对象（在`<functional>`中）'
- en: '| `bad_typeid` | When the argument of `typeid` is null (in `<typeinfo>`) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '`bad_typeid` | 当`typeid`的参数为空时（在`<typeinfo>`中）'
- en: '| `bad_weak_ptr` | When accessing a weak pointer, which refers to an already
    destroyed object (in `<memory>`) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '`bad_weak_ptr` | 访问指向已销毁对象的弱指针时（在`<memory>`中）'
- en: '| `domain_error` | When an attempt is made to perform an operation outside
    the domain on which the operation is defined |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '`domain_error` | 当尝试在操作定义的域之外执行操作时'
- en: '| `invalid_argument` | When an invalid value has been used for a parameter
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `invalid_argument` | 参数使用了无效值时'
- en: '| `length_error` | When an attempt has been made to exceed the length defined
    for an object |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '`length_error` | 当尝试超出对象定义的长度时'
- en: '| `logic_error` | When there is a logic error, for example, class invariants
    or pre-conditions |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '`logic_error` | 当出现逻辑错误时，例如，类不变量或前置条件'
- en: '| `out_of_range` | When an attempt has been made to access elements outside
    of the range defined for the object |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '`out_of_range` | 当尝试访问对象定义范围之外的元素时'
- en: '| `overflow_error` | When a calculation results in a value bigger than the
    destination type |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '`overflow_error` | 当计算结果大于目标类型时'
- en: '| `range_error` | When a calculation results in a value outside the range for
    the type |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '`range_error` | 当计算结果超出类型范围时'
- en: '| `runtime_error` | When an error occurs outside the scope of the code |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '`runtime_error` | 当错误发生在代码范围之外时'
- en: '| `system_error` | Base class to wrap operating system errors (in `<system_error>`)
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '`system_error` | 包装操作系统错误的基类（在`<system_error>`中）'
- en: '| `underflow_error` | When a calculation results in an underflow |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '`underflow_error` | 当计算结果为下溢时'
- en: All the classes, mentioned in the preceding table, have a constructor that takes
    a `const char*` or a `const string&` parameter, in contrast to the `exception`
    class that takes a C string (hence the base class is constructed using the `c_str`
    method if the description is passed through a `string` object). There are no wide
    character versions, so if you want to construct an exception description from
    a wide character string you have to convert it. Also, note that the standard exception
    classes only have one constructor parameter, and this is available through the
    inherited `what` accessor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中提到的所有类都有一个构造函数，它接受`const char*`或`const string&`参数，与接受C字符串的`exception`类相反（因此如果通过`string`对象传递描述，则使用`c_str`方法构造基类）。没有宽字符版本，因此如果要从宽字符字符串构造异常描述，必须将其转换。还要注意，标准异常类只有一个构造函数参数，并且可以通过继承的`what`访问器获得。
- en: There is no absolute rule about the data that an exception can hold. You can
    derive a class from `exception` and construct it with whatever values you want
    to make available to the exception handler.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常可以保存的数据没有绝对规则。您可以从`exception`派生一个类，并使用您想要提供给异常处理程序的任何值构造它。
- en: Catching exceptions by type
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按类型捕获异常
- en: There can be more than one `catch` block with each `try` block, which means
    that you can tailor the exception handling according to the exception type. The
    types of the parameters in the `catch` clauses will be tested against the type
    of the exception in the order that they are declared. The exception will be handled
    by the first handler that matches the exception type, or is a base class. This
    highlights the convention to catch the exception object via a reference. If you
    catch as a base class object a copy will be made, slicing the derived class object.
    In many cases code, will throw objects of a type derived from the `exception`
    class so it means that a catch handler for `exception` will catch all exceptions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`try`块可以有多个`catch`块，这意味着可以根据异常类型定制异常处理。`catch`子句中的参数类型将按照它们声明的顺序与异常类型进行测试。异常将由与异常类型匹配的第一个处理程序处理，或者是一个基类。这强调了通过引用捕获异常对象的约定。如果以基类对象捕获，将会进行复制，从而切割派生类对象。在许多情况下，代码将抛出从`exception`类派生的类型的对象，这意味着`exception`的catch处理程序将捕获所有异常。
- en: 'Since code can throw any object, it is possible that an exception will propagate
    out of the handler. C++ allows you to catch everything by using an ellipses in
    the `catch` clause. Clearly, you should order the `catch` handlers from the most
    derived to the least derived and (if you use it) with the ellipses handler at
    the end:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码可以抛出任何对象，因此可能会有异常传播出处理程序。C++允许您使用省略号在`catch`子句中捕获所有内容。显然，应该按照最派生到最不派生的顺序对`catch`处理程序进行排序，并且（如果使用）将省略号处理程序放在最后：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the guarded code does not throw an exception, then the `catch` blocks are
    not executed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果受保护的代码没有引发异常，则不会执行`catch`块。
- en: When your handler examines the exception, it may decide that it does not want
    to suppress the exception; this is called rethrowing the exception. To do this,
    you can use the `throw` statement without an operand (this is only allowed in
    a `catch` handler), which will rethrow the actual exception object that was caught,
    and not a copy.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理程序检查异常时，可能会决定不想抑制异常；这称为重新引发异常。为此，可以在没有操作数的情况下使用`throw`语句（这仅允许在`catch`处理程序中），这将重新引发实际捕获的异常对象，而不是副本。
- en: 'Exceptions are thread-based and so it is difficult to propagate an exception
    to another thread. The `exception_ptr` class (in `<exception>`) provides shared
    ownership semantics for an exception object of any type. You can get a shared
    copy of an exception object by calling the `make_exception_ptr` object, or you
    can even get a shared copy of the exception being handled in a `catch` block using
    `current_exception`. Both functions return an `exception_ptr` object. An `exception_ptr`
    object can hold an exception of any kind, not just those derived from the `exception`
    class, so getting information from the wrapped exception is specific to the exception
    type. The `exception_ptr` object knows nothing about these details, so instead
    you can pass it to `rethrow_exception` in the context where you want to use the
    shared exception (another thread) and then catch the appropriate exception object.
    In the following code, there are two threads running. The `first_thread` function
    runs on one thread and the `second_thread` function on the other:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是基于线程的，因此很难将异常传播到另一个线程。`exception_ptr`类（在`<exception>`中）为任何类型的异常对象提供了共享所有权语义。您可以通过调用`make_exception_ptr`对象获取异常对象的共享副本，或者甚至可以在`catch`块中使用`current_exception`获取正在处理的异常的共享副本。这两个函数都返回一个`exception_ptr`对象。`exception_ptr`对象可以保存任何类型的异常，而不仅仅是从`exception`类派生的异常，因此从包装的异常中获取信息是特定于异常类型的。`exception_ptr`对象对这些细节一无所知，因此您可以将其传递给`rethrow_exception`，在您想要使用共享异常的上下文中（另一个线程），然后捕获适当的异常对象。在以下代码中，有两个线程在运行。`first_thread`函数在一个线程上运行，`second_thread`函数在另一个线程上运行：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code looks like it is using `exception_ptr` as a pointer. In fact,
    `eptr` is created as a global object and the assignment to `nullptr` uses the
    copy constructor to create an empty object (where the wrapped exception is `nullptr`).
    Similarly, the comparison with `nullptr` actually tests the wrapped exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来像是将`exception_ptr`用作指针。实际上，`eptr`被创建为全局对象，并且对`nullptr`的赋值使用复制构造函数创建一个空对象（其中包装的异常为`nullptr`）。类似地，与`nullptr`的比较实际上测试了包装的异常。
- en: This book is not about C++ threading, so we won't go into the details of the
    signalling between two threads. This code shows that a shared copy of an exception,
    *any exception*, can be stored in one context and then rethrown and processed
    in another context.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及C++线程处理，因此我们不会详细介绍两个线程之间的信号传递。这段代码表明，*任何异常*的共享副本可以存储在一个上下文中，然后在另一个上下文中重新引发和处理。
- en: Function try blocks
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数尝试块
- en: 'You may decide that you want to protect an entire function with a `try` block,
    in which case you could write code like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会决定要用`try`块保护整个函数，在这种情况下，你可以编写如下代码：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This uses the `reciprocal` function, as defined earlier, that will throw an
    `exception` if the parameter is zero. An alternative syntax for this is:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了之前定义的`reciprocal`函数，如果参数为零，它将抛出一个`exception`。这的另一种语法是：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This looks rather odd because the function prototype is followed immediately
    by the `try... catch` block and there is no outer set of braces. The function
    body is the code in the `try` block; when this code completes the function returns.
    If the function returns a value, it must do it in the `try` block. In most cases,
    you will find that this syntax makes your code less readable, but there is one
    situation where it may be useful--for initializer lists in constructors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当奇怪，因为函数原型紧接着就是`try... catch`块，而且没有外部的大括号。函数体就是`try`块中的代码；当这段代码完成时，函数就会返回。如果函数返回一个值，它必须在`try`块中返回。在大多数情况下，你会发现这种语法会使你的代码变得不太可读，但有一种情况下它可能会有用--用于构造函数中的初始化列表。
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this code, we wrap a `double` value that is simply the reciprocal of the
    parameter passed to the constructor. The data member is initialized by calling
    the `reciprocal` function in the initializer list. Since this is outside of the
    constructor body, an exception that occurs here will be passed straight to the
    code that calls the constructor. If you want to do some additional processing,
    then you could call the reciprocal function inside the constructor body:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们封装了一个`double`值，它只是构造函数传递的参数的倒数。数据成员通过在初始化列表中调用`reciprocal`函数进行初始化。由于这是在构造函数体之外，发生在这里的任何异常都将直接传递给调用构造函数的代码。如果你想进行一些额外的处理，那么你可以在构造函数体内调用倒数函数：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is important to note that the exception will be automatically rethrown because
    any exception in a constructor means that the object is invalid. However, this
    does allow you to do some additional processing, if necessary. This solution will
    not work for exceptions thrown in a base object constructor because, although
    you can call a base constructor in the derived constructor body, the compiler
    will call the default constructor automatically. If you want the compiler to call
    a constructor other than the default constructor you have to call it in the initializer
    list. An alternative syntax to providing exception code in the `inverse` constructor
    is to use function `try` blocks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，异常将被自动重新抛出，因为构造函数中的任何异常意味着对象是无效的。然而，这确实允许你进行一些额外的处理，如果有必要的话。这种解决方案对于在基对象构造函数中抛出的异常是行不通的，因为虽然你可以在派生构造函数体中调用基构造函数，但编译器会自动调用默认构造函数。如果你希望编译器调用除默认构造函数之外的构造函数，你必须在初始化列表中调用它。在`inverse`构造函数中提供异常代码的另一种语法是使用函数`try`块：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This looks a little cluttered, but the constructor body is still after the initializer
    list giving an initial value to the `recip` data member. Any exception from the
    call to `reciprocal` will be caught and automatically rethrown after processing.
    The initializer list can contain calls to the base class and any of the data members
    and all will be protected with the `try` block.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点凌乱，但构造函数体仍然在初始化列表之后，给`recip`数据成员赋予初始值。对`reciprocal`的调用引发的任何异常都将被捕获并在处理后自动重新抛出。初始化列表可以包含对基类和任何数据成员的调用，所有这些都将受到`try`块的保护。
- en: System errors
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统错误
- en: The `<system_error>` library defines a series of classes to encapsulate system
    errors. The `error_category` class provides a mechanism to convert numeric error
    values into localized descriptive strings. Two objects are available through the
    `generic_category` and `system_category` functions in `<system_error>`, and `<ios>`
    has a function called `isostream_category`; all of these functions return an `error_category`
    object. The `error_category` class has a method called `message` that returns
    a string description of the error number you pass as the parameter. The object
    returned from the `generic_category` function will return the descriptive string
    for a POSIX error, so you can use it to get a description for an `errno` value.
    The object returned from the `system_category` function will return an error description
    via the Win32 `FormatMessage` function using `FORMAT_MESSAGE_FROM_SYSTEM` for
    the flags parameter, and hence this can be used to get the descriptive message
    for a Windows error message in a `string` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`<system_error>`库定义了一系列类来封装系统错误。`error_category`类提供了将数值错误值转换为本地化描述字符串的机制。通过`<system_error>`中的`generic_category`和`system_category`函数可以获得两个对象；`<ios>`中有一个名为`isostream_category`的函数；所有这些函数都返回一个`error_category`对象。`error_category`类有一个名为`message`的方法，它返回你传递的错误号的字符串描述。从`generic_category`函数返回的对象将返回POSIX错误的描述字符串，因此你可以用它来获取`errno`值的描述。从`system_category`函数返回的对象将通过Win32的`FormatMessage`函数返回一个错误描述，使用`FORMAT_MESSAGE_FROM_SYSTEM`作为标志参数，因此这可以用来获取Windows错误消息的描述信息。'
- en: Note that `message` has no extra parameters to pass in values for a Win32 error
    message that takes parameters. Consequently, in those situations you will get
    back a message that has formatting placeholders.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`message`没有额外的参数来传递值，用于传递参数的Win32错误消息。因此，在这些情况下，你将得到一个带有格式化占位符的消息。
- en: In spite of the name, the `isostream_category` object essentially returns the
    same descriptions as the `generic_category` object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字上看起来不同，`isostream_category`对象实质上返回与`generic_category`对象相同的描述。
- en: 'The `system_error` exception is a class that reports one of the values described
    by one of the `error_category` objects. For example, this is the example used
    earlier for `FormatMessage` but re-written using `system_error`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_error`异常是一个报告由`error_category`对象描述的值之一的类。例如，这是之前使用`FormatMessage`的示例，但是使用`system_error`重新编写：'
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `system_error` constructor used here has the error value as the first parameter
    (a `ulong` returned from the Win32 function `GetLastError`) and a `system_category`
    object used to convert the error value to a descriptive string when the `system_error::what`
    method is called.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`system_error`构造函数的第一个参数是错误值（从Win32函数`GetLastError`返回的`ulong`），第二个参数是`system_category`对象，用于在调用`system_error::what`方法时将错误值转换为描述性字符串。
- en: Nested exceptions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套异常
- en: 'A `catch` block may rethrow the current exception by calling `throw` without
    any operand, and there will be stack unwinding until the next `try` block is reached
    in the call stack. You can also rethrow the current exception *nested inside*
    another exception. This is achieved by calling the `throw_with_nested` function
    (in `<exception>`) and passing the new exception. The function calls `current_exception`
    and wraps the exception object in a nested exception along with the parameter,
    which is then thrown. A `try` block further up the call stack can catch this exception,
    but it can only access the outer exception; it has no direct access to the inner
    exception. Instead, the inner exception can be thrown with a call to `rethrow_if_nested`.
    For example, here is another version of code to open a file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块可以通过调用`throw`而不带任何操作数来重新抛出当前异常，并且会进行堆栈展开，直到在调用堆栈中到达下一个`try`块。您还可以将当前异常*嵌套*在另一个异常内。这是通过调用`throw_with_nested`函数（在`<exception>`中）并传递新异常来实现的。该函数调用`current_exception`并将异常对象与参数一起包装成嵌套异常，然后抛出。调用堆栈上方的`try`块可以捕获此异常，但它只能访问外部异常；它无法直接访问内部异常。相反，可以通过调用`rethrow_if_nested`来抛出内部异常。例如，这是另一个打开文件的代码版本：'
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The code opens a file, and if the file does not exist then a state bit is set
    (you can test the bits later with a call to the `rdstat` method). The next line
    indicates the values of the state bits that should be handled by the class throwing
    an exception, and in this case the `ios_base::failbit` is provided. If the constructor
    failed to open the file then this bit will be set, so the `exceptions` method
    will respond by throwing an exception. In this example, the exception is caught
    and wrapped into a nested exception. The outer exception is a `system_error` exception,
    which is initialized with an error value of `ENOENT` (which means that the file
    does not exist) and an `error_category` object to interpret it, passing the name
    of the file as additional information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打开一个文件，如果文件不存在，则设置一个状态位（稍后可以使用`rdstat`方法测试位）。下一行指示应该由抛出异常的类处理的状态位的值，在这种情况下，提供了`ios_base::failbit`。如果构造函数未能打开文件，则将设置此位，因此`exceptions`方法将通过抛出异常来响应。在这个例子中，异常被捕获并包装成嵌套异常。外部异常是一个`system_error`异常，它初始化为一个`ENOENT`的错误值（表示文件不存在），并使用一个`error_category`对象来解释它，传递文件名作为额外信息。
- en: 'This function can be called like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以这样调用：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The exception caught here can be accessed, but it just gives information about
    the outer object:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里捕获的异常可以被访问，但它只提供有关外部对象的信息：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This message is constructed by the `system_error` object using the additional
    information passed to its constructor and the description from the category object.
    To get the inner object in a nested exception you have to tell the system to throw
    the inner exception with a call to `rethrow_if_nested`. So, instead of printing
    out the outer exception, you call a function like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息是由`system_error`对象构造的，使用传递给它构造函数的额外信息和类别对象的描述。要获取嵌套异常中的内部对象，您必须告诉系统通过调用`rethrow_if_nested`来抛出内部异常。因此，不是打印外部异常，而是调用这样的一个函数：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This prints the description for the outer exception and then calls `rethrow_if_nested,`
    which will only throw the exception if it is nested. If so, it throws the inner
    exception, which is then caught and recursively calls the `print_exception` function.
    The result is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印外部异常的描述，然后调用`rethrow_if_nested`，只有在异常是嵌套的情况下才会抛出异常。如果是这样，它会抛出内部异常，然后被捕获并递归调用`print_exception`函数。结果是：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The last line is the inner exception which was thrown when the `ifstream::exception`
    method was called.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是在调用`ifstream::exception`方法时抛出的内部异常。
- en: Structured Exception Handling
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化异常处理
- en: Native exceptions in Windows are **Structured Exceptions Handling** (**SEH**)
    and Visual C++ has a language extension to allow you to catch these exceptions.
    It is important to understand that they are not the same as C++ exceptions, which
    are considered by the compiler to be *synchronous*, that is, the compiler knows
    if a method may (or specifically, will not) throw a C++ exception, and it uses
    this information when analysing code. C++ exceptions are also caught by type.
    SEH is not a C++ concept, so the compiler treats structured exceptions as being
    *asynchronous*, meaning it treats any code within an SEH protected block as potentially
    raising a structured exception, and hence the compiler cannot perform optimizations.
    SEH exceptions are also caught by exception code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Windows中的本机异常是**结构化异常处理**（**SEH**），Visual C++有一种语言扩展，允许您捕获这些异常。重要的是要理解它们与C++异常不同，编译器认为它们是*同步*的，也就是说，编译器知道方法是否（或者特别地，不会）抛出C++异常，并且在分析代码时使用这些信息。C++异常也是按类型捕获的。SEH不是C++概念，因此编译器将结构化异常视为*异步*，这意味着它将任何在受SEH保护的块中的代码视为可能引发结构化异常，因此编译器无法执行优化。SEH异常也是按异常代码捕获的。
- en: The language extensions for SEH are extensions to Microsoft C/C++, that is,
    they can be used in C as well as C++ so the handling infrastructure does not know
    about object destructors. Additionally, when you catch an SEH exception, no assumptions
    are made about the state of the stack or any other part of your process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: SEH的语言扩展是Microsoft C/C++的扩展，也就是说，它们可以在C和C++中使用，因此处理基础设施不知道对象析构函数。此外，当您捕获SEH异常时，不会对堆栈或进程的任何其他部分的状态做出任何假设。
- en: Although most Windows functions will catch the SEH exceptions generated by the
    kernel in an appropriate way, some purposely allow them to propagate (for example,
    the **Remote Procedure Calls** (**RPC**) functions, or those used for memory management).
    With some Windows functions you can explicitly request that errors are handled
    with SEH exceptions. For example, the `HeapCreate` set of functions will allow
    a Windows application to create a private heap, and you can pass the `HEAP_GENERATE_EXCEPTIONS`
    flag to indicate that errors in creating the heap, and allocating, or reallocating
    memory in a private heap, will generate an SEH exception. This is because the
    developer calling these functions may regard the failure to be so serious that
    it is not recoverable, and hence the process should terminate. Since an SEH is
    such a serious situation, you should review carefully whether it is appropriate
    (which is not entirely impossible) to do much more than report details of the
    exception and terminate the process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数Windows函数会以适当的方式捕获内核生成的SEH异常，但有些故意允许它们传播（例如，**远程过程调用**（**RPC**）函数，或用于内存管理的函数）。对于某些Windows函数，您可以显式请求使用SEH异常处理错误。例如，`HeapCreate`函数集将允许Windows应用程序创建私有堆，并且您可以传递`HEAP_GENERATE_EXCEPTIONS`标志，以指示在创建堆以及在私有堆中分配或重新分配内存时生成SEH异常。这是因为调用这些函数的开发人员可能认为失败是如此严重，以至于无法恢复，因此进程应该终止。由于SEH是如此严重的情况，您应该仔细审查是否适当（这并非完全不可能）做更多事情，而不仅仅是报告异常的详细信息并终止进程。
- en: 'SEH exceptions are essentially low-level operating system exceptions, but it
    is important to be familiar with the syntax because it looks similar to C++ exceptions.
    For example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: SEH异常本质上是低级操作系统异常，但熟悉其语法很重要，因为它看起来类似于C++异常。例如：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The SEH exception code is highlighted here. This code uses the Windows `VirtualAlloc`
    function to reserve a number of pages of memory. Reserving does not allocate the
    memory, that action has to be carried out in a separate operation called **committing
    the memory**. Windows will reserve (and commit) memory in blocks called **pages**
    and on most systems a page is 4096 bytes, as assumed here. The call to the `VirtualAlloc`
    function indicates that it should reserve ten pages of 4096 bytes, which will
    be committed (and used) later.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里突出显示了SEH异常代码。此代码使用Windows的`VirtualAlloc`函数来保留一定数量的内存页。保留不会分配内存，该操作必须在称为**提交内存**的单独操作中执行。Windows将以称为**页**的块中保留（和提交）内存，在大多数系统上，一页为4096字节，如此处所假设的。对`VirtualAlloc`函数的调用指示它应该保留4096字节的十页，这些页将在以后被提交（和使用）。
- en: The first parameter to `VirtualAlloc` indicates the location of the memory,
    but since we are reserving memory, this is unimportant so `nullptr` is passed.
    If the reserving succeeds, then a pointer is returned to the memory. The `for`
    loop simply writes data to the memory one byte at a time. The highlighted code
    protects this memory access with structured exception handling. The protected
    block starts with the `__try` keyword. When an SEH is raised, execution passes
    to the `__except` block. This is very different to the `catch` block in C++ exceptions.
    Firstly, `__except` exception handler receives one of three values to indicate
    how it should behave. Only if this is `EXCEPTION_EXECUTE_HANDLER` will the code
    in the handler block be run (in this code, to shut down the process abruptly).
    If the value is `EXCEPTION_CONTINUE_SEARCH` then the exception is not recognized
    and the search will continue up the stack, *but without C++ stack unwinding*.
    The surprising value is `EXCEPTION_CONTINUE_EXECUTION,` because this dismisses
    the exception and execution in the `__try` block will continue. *You cannot do
    this with C++ exceptions*. Typically, SEH code will use an exception filter function
    to determine what action is required of the `__except` handler. In this code,
    this filter is called `exception_filter,` which is passed the exception code obtained
    by calling the Windows function `GetExceptionCode`. This syntax is important because
    this function can only be called in the `__except` context.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAlloc`的第一个参数表示内存的位置，但由于我们正在保留内存，所以这并不重要，所以传递了`nullptr`。如果保留成功，那么将返回指向内存的指针。`for`循环只是一次写入一个字节的数据到内存中。突出显示的代码使用结构化异常处理来保护内存访问。受保护的块以`__try`关键字开始。当发生SEH时，执行将传递到`__except`块。这与C++异常中的`catch`块非常不同。首先，`__except`异常处理程序接收三个值中的一个，以指示它应该如何行为。只有当这是`EXCEPTION_EXECUTE_HANDLER`时，处理程序块中的代码才会运行（在此代码中，以突然关闭进程）。如果值是`EXCEPTION_CONTINUE_SEARCH`，则异常不被识别，搜索将继续上升堆栈，*但不会进行C++堆栈展开*。令人惊讶的值是`EXCEPTION_CONTINUE_EXECUTION`，因为这会解除异常，`__try`块中的执行将继续。*你不能用C++异常做到这一点*。通常，SEH代码将使用异常过滤器函数来确定`__except`处理程序所需的操作。在此代码中，此过滤器称为`exception_filter`，它通过调用Windows函数`GetExceptionCode`获取的异常代码。这种语法很重要，因为此函数只能在`__except`上下文中调用。'
- en: 'The first time the loop runs no memory will have been committed and so the
    code that writes to the memory will raise an exception: a page fault. Execution
    will pass to the exception handler and through to `exception_filter`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次循环运行时，不会有任何内存被提交，因此写入内存的代码将引发异常：页面错误。执行将传递到异常处理程序，然后通过`exception_filter`：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is important in SEH code to only handle exceptions that you know about, and
    only consume the exception if you know that the condition has been completely
    addressed. If you access Windows memory that has not been committed, the operating
    system generates an exception called a page fault. In this code, the exception
    code is tested to see if it is a page fault, and if not, the filter returns telling
    the exception handler to run the code in the exception handler block that terminates
    the process. If the exception is a page fault then we can commit the next page.
    First, there is a test to see if the page number is within the range that we will
    use (if not, then close down the process). Then, the next page is committed with
    another call to `VirtualAlloc` to identify the page to commit and the number of
    bytes in that page. If the function succeeds, it will return a pointer to the
    committed page or a null value. Only if committing the page has succeeded will
    the filter return a value of `EXCEPTION_CONTINUE_EXECUTION`, indicating that the
    exception has been handled and execution can continue at the point the exception
    was raised. This code is a standard way to use `VirtualAlloc` because it means
    that memory pages are only committed when, and if, they are needed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在SEH代码中，只处理你知道的异常很重要，只有在你知道条件已完全解决时才消耗异常。如果访问尚未提交的Windows内存，则操作系统会生成一个称为页面错误的异常。在这段代码中，异常代码被测试，以查看是否是页面错误，如果不是，则过滤器返回告诉异常处理程序运行异常处理程序块中终止进程的代码。如果异常是页面错误，那么我们可以提交下一页。首先，测试页面编号是否在我们将使用的范围内（如果不是，则关闭进程）。然后，使用另一个调用`VirtualAlloc`来标识要提交的页面和该页面中的字节数来提交下一页。如果函数成功，它将返回指向提交页面的指针或空值。只有在提交页面成功后，过滤器才会返回`EXCEPTION_CONTINUE_EXECUTION`的值，表示已处理异常，并且可以在引发异常的点继续执行。这段代码是使用`VirtualAlloc`的标准方式，因为这意味着只有在需要时才会提交内存页面。
- en: SEH also has the concept of termination handlers. When execution leaves the
    `__try` block of code through a call to `return`, or by completing all of the
    code in the block, or by calling the Microsoft extension `__leave` instruction,
    or has raised an SEH, then the termination handler block of code marked with `__finally`
    is called. Since the termination handler is always called, regardless of how the
    `__try` block is exited, it is possible to use this as a way to release resources.
    However, because SEH does not do C++ stack unwinding (nor call destructors), this
    means that you cannot use this code in a function that has C++ objects. In fact,
    the compiler will refuse to compile a function that has SEH and created C++ objects,
    either on the function stack or allocated on the heap. (You can, however, use
    global objects or objects allocated in calling functions and passed in as parameters.)
    The `__try`/`__finally` construct looks useful, but is constrained by the requirement
    that you cannot use it with code that creates C++ objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: SEH还有终止处理程序的概念。当执行通过调用`return`离开`__try`代码块，或者通过完成块中的所有代码，或者通过调用Microsoft扩展`__leave`指令，或者引发了SEH时，标有`__finally`的终止处理程序代码块将被调用。由于终止处理程序始终被调用，无论`__try`块如何退出，可以将其用作释放资源的一种方式。但是，由于SEH不执行C++堆栈展开（也不调用析构函数），这意味着你不能在具有C++对象的函数中使用此代码。实际上，编译器将拒绝编译具有SEH并创建C++对象的函数，无论是在函数堆栈上还是在堆上分配的对象。（但是，你可以使用全局对象或在调用函数中分配并作为参数传递的对象。）`__try`/`__finally`结构看起来很有用，但受到不能与创建C++对象的代码一起使用的要求的限制。
- en: Compiler exception switches
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器异常开关
- en: At this point, it is worth explaining why you have compiled your code with the
    `/EHsc` switch. The simple answer is, if you do not use this switch the compiler
    will issue a warning from the Standard Library code, and as the Standard Library
    uses exceptions you must use the `/EHsc` switch. The warning tells you to do this,
    so that is what you do.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得解释一下为什么要使用`/EHsc`开关编译代码。简单的答案是，如果不使用此开关，编译器将从标准库代码发出警告，由于标准库使用异常，因此必须使用`/EHsc`开关。警告告诉你要这样做，所以你就这样做了。
- en: The long answer is that the `/EH` switch has three arguments that you can use
    to influence how exceptions are handled. Using the `s` argument tells the compiler
    to provide the infrastructure for synchronous exceptions, that is, C++ exceptions
    that may be thrown in a `try` block and handled in a `catch` block, and that have
    stack unwinding that calls the destructors of automatic C++ objects. The `c` argument
    indicates that `extern C` functions (that is, all the Windows SDK functions) never
    throw C++ exceptions (and hence the compiler can do an additional level of optimization).
    Hence, you can compile Standard Library code with either `/EHs` or `/EHsc`, but
    the latter will generate more optimized code. There is an additional argument,
    where `/EHa` indicates that the code will catch *both* synchronous and asynchronous
    exceptions (SEH) with `try`/`catch` blocks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 长答案是`/EH`开关有三个参数，可以影响异常处理的方式。使用`s`参数告诉编译器提供同步异常的基础设施，即，在`try`块中可能抛出并在`catch`块中处理的C++异常，并且具有调用自动C++对象析构函数的堆栈展开。`c`参数表示`extern
    C`函数（即所有Windows SDK函数）永远不会抛出C++异常（因此编译器可以进行额外级别的优化）。因此，你可以使用`/EHs`或`/EHsc`编译标准库代码，但后者将生成更多优化的代码。还有一个额外的参数，其中`/EHa`表示代码将使用`try`/`catch`块捕获*同步和异步异常（SEH）。
- en: Mixing C++ and SEH exception handling
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合C++和SEH异常处理
- en: The `RaiseException` Windows function will throw an SEH exception. The first
    parameter is the exception code and the second indicates if the process can continue
    after this exception is handled (`0` means it can). The third and fourth parameters
    give additional information about the exception. The fourth parameter is a pointer
    to an array with these additional parameters and the number of parameters is given
    in the third parameter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`RaiseException` Windows函数将引发一个SEH异常。第一个参数是异常代码，第二个参数指示在处理此异常后进程是否可以继续（`0`表示可以）。第三个和第四个参数提供有关异常的其他信息。第四个参数是指向包含这些附加参数的数组的指针，并且参数的数量在第三个参数中给出。'
- en: 'With `/EHa`, you can write code like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`/EHa`，您可以编写如下的代码：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The problem with this code is that it handles all SEH exceptions. This is quite
    dangerous because some SEH exceptions may indicate that the process state is corrupted,
    so it is dangerous for the process to continue. The C Runtime Library provides
    a function called `_set_se_translator` that provides a mechanism to indicate which
    SEH exceptions are handled by `try`. This function is passed a pointer by a function
    that you write with this prototype:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于它处理了所有SEH异常。这是非常危险的，因为一些SEH异常可能表明进程状态已损坏，因此进程继续运行是危险的。C运行时库提供了一个名为`_set_se_translator`的函数，它提供了一种指示哪些SEH异常由`try`处理的机制。该函数通过您编写的具有此原型的函数传递一个指针：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first parameter is the exception code (which will be returned from the
    `GetExceptionCode` function) and the second parameter is the return from the `GetExceptionInformation`
    function and has any additional parameters associated with the exception (for
    example, those passed through the third and fourth parameters in `RaiseException`).
    You can use these values to throw a C++ exception in place of the SEH. If you
    provide this function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是异常代码（将从`GetExceptionCode`函数返回），第二个参数是`GetExceptionInformation`函数的返回值，并带有与异常相关的任何附加参数（例如，通过`RaiseException`的第三个和第四个参数传递的参数）。您可以使用这些值来抛出C++异常来代替SEH。如果您提供此函数：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can now register the function before handling an SEH exception:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在处理SEH异常之前注册该函数：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this code, the `RaiseException` function is raising a custom SEH with a
    value of 1\. This translation is perhaps not the most useful, but it illustrates
    the point. The `winnt.h` header file defines the exception code for the standard
    SEH exceptions that can be raised in Windows code. A more useful translation function
    would be:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`RaiseException`函数正在引发一个值为1的自定义SEH。这种转换可能并不是最有用的，但它说明了这一点。`winnt.h`头文件定义了可以在Windows代码中引发的标准SEH异常的异常代码。一个更有用的转换函数可能是：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This allows you to call the reciprocal function as following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以调用以下的逆函数：
- en: '[PRE68]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Writing exception-safe classes
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异常安全类
- en: In general, when you write classes, you should ensure that you protect the users
    of your classes from exceptions. Exceptions are not an error propagation mechanism.
    If a method on your class fails but is recoverable (the object state is left consistent)
    then you should use the return value (most likely an error code) to indicate this.
    Exceptions are for exceptional situations, those that have invalidated data and
    where, at the point where the exception is raised, the situation is unrecoverable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当您编写类时，应确保保护类的用户免受异常的影响。异常不是错误传播机制。如果您的类上的方法失败但是可恢复的（对象状态保持一致），那么您应该使用返回值（很可能是错误代码）来指示这一点。异常是用于异常情况的，这些情况已经使数据无效，并且在引发异常的地方，情况是无法恢复的。
- en: When an exception occurs in your code, you have three options. Firstly, you
    can allow the exception to propagate up the call stack and put the responsibility
    of handling the exception on the calling code. This means that you call code without
    guarding by `try` blocks, even though the code is documented as being able to
    throw exceptions. In this situation, you must be reassured that the exception
    makes sense to the calling code. For example, if your class is documented as a
    network class and uses a temporary file to buffer some data received from the
    network, if the file access code throws an exception, the exception object will
    not make sense to code that calls your code, because that client code thinks that
    your class is about accessing network data, not file data. If, however, the network
    code throws an error, it may make sense to allow those exceptions to propagate
    to calling code, especially if they refer to errors that require external action
    (say, a network cable is unplugged or there is a security issue).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码发生异常时，您有三个选择。首先，您可以允许异常在调用堆栈上传播，并将处理异常的责任放在调用代码上。这意味着您调用的代码没有通过`try`块进行保护，即使该代码被记录为可能引发异常。在这种情况下，您必须确保异常对调用代码是有意义的。例如，如果您的类被记录为网络类，并使用临时文件来缓冲从网络接收到的一些数据，如果文件访问代码引发异常，异常对象对调用您的代码的代码将没有意义，因为该客户端代码认为您的类是关于访问网络数据，而不是文件数据。然而，如果网络代码引发错误，允许这些异常传播到调用代码可能是有意义的，特别是如果它们涉及需要外部操作的错误（比如，网络电缆被拔掉或存在安全问题）。
- en: In this case, you can apply your second option, which is to protect code that
    can throw exceptions with a `try` block, catch known exceptions, and throw a more
    appropriate exception, perhaps nesting the original exception so that the calling
    code can do more detailed analysis. If the exception is one that makes sense to
    your calling code, you may allow it to propagate out, but catching the original
    exception allows you to take additional action before you rethrow it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以应用第二个选项，即使用`try`块保护可能引发异常的代码，捕获已知异常，并抛出更合适的异常，可能嵌套原始异常，以便调用代码可以进行更详细的分析。如果异常对您的调用代码有意义，您可以允许其传播出去，但捕获原始异常允许您在重新引发之前采取额外的操作。
- en: Using the buffered network data example, you could decide that since there is
    an error in the file buffering, it means that you cannot read any more network
    data, so your exception handling code should shut down the network access in a
    graceful way. The error occurred in the file code, not the network code, so an
    abrupt shutdown of the network is not justified, and it makes more sense to allow
    the current network action to complete (but ignore the data), so that no errors
    are propagated back to the network code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓冲网络数据的示例，您可以决定由于文件缓冲中存在错误，这意味着您无法再读取任何网络数据，因此您的异常处理代码应以一种优雅的方式关闭网络访问。错误发生在文件代码中，而不是网络代码中，因此不合理地突然关闭网络，并且更合理的是允许当前网络操作完成（但忽略数据），以便不会将错误传播回网络代码。
- en: The final option is to protect all code with a `try` block, and catch and consume
    exceptions, so that calling code completes without throwing an exception. There
    are two main situations where this is appropriate. Firstly, the error may be recoverable,
    and so in the `catch` clause you can take steps to address the issue. In the buffered
    network data example, when opening a temporary file, if you get an error that
    a file with the requested name already exists, you can simply use another name
    and try again. The user of your code does not need to know that this problem occurred
    (although, it may make sense to trace this error so that you can investigate the
    issue in the testing phase of your code). If the error is not recoverable, it
    may make more sense to invalidate the state of your object and return an error
    code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选择是用`try`块保护所有代码，并捕获和消耗异常，以便调用代码在不抛出异常的情况下完成。这种情况适用于两种主要情况。首先，错误可能是可恢复的，因此在`catch`子句中，您可以采取措施来解决问题。在缓冲网络数据的示例中，当打开临时文件时，如果出现请求的名称已存在的文件的错误，您可以简单地使用另一个名称并重试。您的代码使用者不需要知道发生了这个问题（尽管在代码测试阶段跟踪此错误可能是有意义的，以便您可以调查问题）。如果错误是不可恢复的，可能更合理的是使对象的状态无效并返回错误代码。
- en: Your code should utilize the behavior of the C++ exception infrastructure, which
    guarantees that automatic objects are destroyed. Therefore, when you use memory
    or other appropriate resources, you should wrap them in smart pointers whenever
    possible so that if an exception is thrown then the resource is released by the
    smart pointer destructor. Classes that use Resource Acquisition Is Initialization
    (RAII) are `vector`, `string`, `fstream,` and the `make_shared` function, so if
    the object construction (or the function call) is successful, it means that the
    resource has been acquired, and you can use the resource through these objects.
    These classes are also **Resource Release Destruction** (**RRD**), which means
    that the resource is released when the object is destroyed. The smart pointer
    classes, `unique_ptr` and `shared_ptr`, are not RAII because they simply wrap
    the resource and the allocation of resources is carried out separately by other
    code. However, these classes are RRD, so you can be assured that if an exception
    is thrown the resource is released.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该利用C++异常基础设施的行为，该基础设施保证自动对象被销毁。因此，当您使用内存或其他适当的资源时，应尽可能将它们包装在智能指针中，以便如果抛出异常，则资源将由智能指针析构函数释放。使用资源获取即初始化（RAII）的类有`vector`、`string`、`fstream`和`make_shared`函数，因此如果对象构造（或函数调用）成功，这意味着已经获取了资源，并且您可以通过这些对象使用资源。这些类也是**资源释放销毁**（**RRD**），这意味着当对象被销毁时，资源将被释放。智能指针类`unique_ptr`和`shared_ptr`不是RAII，因为它们只是包装资源，资源的分配是由其他代码单独执行的。但是，这些类是RRD，因此您可以放心，如果抛出异常，资源将被释放。
- en: Exception handling can offer three levels of exception safety. At the safest
    level of the scale is the *no-fail* method and function. This is the code that
    does not throw exceptions and does not allow exceptions to propagate. Such code
    will guarantee that class invariants are maintained and that the object state
    will be consistent. No-fail code is not achieved by simply catching all exceptions
    and consuming them, instead, you have to protect all code and catch, and handle,
    all exceptions to ensure that the object is left in a consistent state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可以提供三个级别的异常安全性。在最安全级别的标度上是*无故障*方法和函数。这是不会抛出异常并且不允许异常传播的代码。这样的代码将保证类不变量被维护，并且对象状态将保持一致。无故障代码不是通过简单地捕获所有异常并消耗它们来实现的，而是必须保护所有代码并捕获和处理所有异常，以确保对象处于一致的状态。
- en: All built-in C++ types are no-fail. You also have a guarantee that all Standard
    Library types have no-fail destructors, but since containers will call the contained
    object destructors when instances are destroyed, this means that you have to ensure
    that the types you write to put in containers also have a no-fail destructor.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置的C++类型都是无故障的。您还有一个保证，所有标准库类型都有无故障的析构函数，但由于容器在销毁实例时会调用包含对象的析构函数，这意味着您必须确保放入容器中的类型也具有无故障的析构函数。
- en: 'Writing no-fail types can involve quite detailed code, so another option is
    the *strong guarantee*. Such code will throw exceptions, but they ensure that
    no memory is leaked and that when an exception is thrown the object will be in
    the same state as when the method was called. This is essentially a transactional
    operation: either the object is modified or it is left unmodified, as if no attempt
    was made to perform the operation. In most cases methods, this will offer a *basic
    guarantee* of exception safety. In this case, there is a guarantee that whatever
    happens no memory is leaked, but when an exception is thrown, the object may be
    left in an inconsistent state, so the calling code should handle the exception
    by discarding the object.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 写入无故障类型可能涉及相当详细的代码，因此另一个选择是*强保证*。这样的代码会抛出异常，但它们确保没有内存泄漏，并且当抛出异常时，对象将处于与调用方法时相同的状态。这本质上是一个事务性操作：要么对象被修改，要么保持不变，就好像没有尝试执行操作一样。在大多数情况下的方法中，这将提供异常安全的*基本保证*。在这种情况下，无论发生什么，都保证没有内存泄漏，但是当抛出异常时，对象可能处于不一致的状态，因此调用代码应该通过丢弃对象来处理异常。
- en: Documentation is important. If the object methods are marked with `throw` or
    `noexcept` then you know it is no-fail. You should only assume the strong guarantee
    if the documentation says so. Otherwise, you can assume that objects will have
    the basic guarantee of exception safety, and if an exception is thrown the object
    is invalid.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 文档很重要。如果对象方法标有`throw`或`noexcept`，那么您就知道它是无故障的。只有在文档中明确说明如此时，您才能假设有强保证。否则，您可以假设对象将具有异常安全的基本保证，如果抛出异常，则对象无效。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: When you write your C++ code you should always have one eye looking towards
    the testing and debugging of your code. The ideal way to prevent the need to debug
    code is to write robust, well-designed code. Ideals are difficult to achieve,
    so it is better to write code that is easy for you to diagnose issues and easy
    to debug with. The C Runtime and the C++ Standard Library provides a wide range
    of facilities to enable you to trace and report issues, and through error code
    handling and exceptions you have a rich collection of tools to report and handle
    the failure of functions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写C++代码时，您应该始终关注测试和调试代码。防止调试代码的理想方式是编写健壮、设计良好的代码。理想很难实现，因此最好编写易于诊断问题和易于调试的代码。C运行时和C++标准库提供了广泛的设施，使您能够跟踪和报告问题，并通过错误代码处理和异常，您有丰富的工具集来报告和处理函数的失败。
- en: After reading this book you should be aware that the C++ language and Standard
    Library provide a rich, flexible, and powerful way to write code. What's more,
    once you know how to use the language and its libraries, C++ is a pleasure to
    use.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本书后，您应该意识到C++语言和标准库提供了一种丰富、灵活和强大的编写代码的方式。更重要的是，一旦您知道如何使用语言和其库，C++就是一种乐趣。
