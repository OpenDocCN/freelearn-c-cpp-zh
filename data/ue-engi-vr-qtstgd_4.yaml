- en: User Interface and User Experience inside VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR内的用户界面和用户体验
- en: Thinking about our users and building our game systems with them in mind is
    just a small part of the overall process we need to go through to ensure that
    our game is an enjoyable experience for the widest range of players. **Human-Centered
    Design** (**HCD**) is just the first step in the greater design process called
    **User Experience** (**UX**) design. When we think about the whole user experience,
    we are really looking at not only the people who are using our game, but also
    at what we can do to improve how they use it. By thinking through the lens of
    UX, we hope to build a game that addresses all of the player's needs, is easy
    to use, and that the player never wants to put down.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的用户，并从他们的角度构建我们的游戏系统，这只是确保我们的游戏成为最广泛玩家群体享受体验的整体过程中的一小部分。**以人为中心的设计**（**HCD**）是更大设计过程，即**用户体验**（**UX**）设计的第一步。当我们思考整个用户体验时，我们实际上不仅关注使用我们游戏的人，还关注我们如何改进他们使用游戏的方式。通过UX的视角思考，我们希望构建一个满足所有玩家需求、易于使用且玩家不愿放下的游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is UX design?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是UX设计？
- en: The seven aspects of UX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UX的七个方面
- en: User interfaces in VR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VR中的用户界面
- en: Designing the UI for *Server 17*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为*Server 17*设计UI
- en: What is UX design?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是UX设计？
- en: The term UX design is not a new term, even though its use has become more popular
    in recent years. Coined by Don Norman during his time at Apple, it is an umbrella
    term for the many ways in which people interact with machines. It also refers
    to the idea of seeing things from the user's perspective. In the game industry,
    UX tends to go hand in hand with user interface design since players often interact
    with a piece of software purely through its interface. Yet the development of
    virtual reality and its ability to give players a large amount of choice in how
    they interact with a game world has led companies to rethink how they view this
    field. How do you think about the user experience in a game when the player can
    interact with the world without a traditional UI? This is where the UX designer
    really comes into their own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管近年来其使用变得更加普遍，但UX设计这个术语并不是一个新词。它是由Don Norman在苹果公司工作时提出的，是一个涵盖人们与机器互动的许多方式的通用术语。它还指从用户的角度看问题的想法。在游戏行业中，UX通常与用户界面设计紧密相连，因为玩家通常只通过界面与软件互动。然而，虚拟现实的发展及其为玩家提供大量选择如何与游戏世界互动的能力，导致公司重新思考他们对这个领域的看法。当玩家可以无需传统UI与游戏世界互动时，你如何看待游戏中的用户体验？这正是UX设计师真正发挥其作用的地方。
- en: 'A UX designer is a designer who is responsible for the look, feel, and usability
    of the product. Yet, even this definition is lacking since, until recently, UX
    design in video games pretty much meant focusing on the user interface. In virtual
    reality development, UX design covers several more topics, such as story experience,
    control schemes, player safety, accessibility, and more. A UX designer should
    be concerned with seven different aspects of the game. The game needs to have
    the following characteristics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UX设计师是一个负责产品外观、感觉和可用性的设计师。然而，即使这个定义也有不足之处，因为直到最近，游戏中的UX设计基本上意味着专注于用户界面。在虚拟现实开发中，UX设计涵盖了更多主题，如故事体验、控制方案、玩家安全、可访问性等。UX设计师应该关注游戏的七个不同方面。游戏需要具备以下特点：
- en: '**Useful**: Does the game provide the user with the experience they are looking
    for? There is no reason to bring a game or product to market if it isn''t useful
    to someone. In UX design, we use the Discovery and Empathy stages of HCD to discover
    how useful what we are designing will be for our users.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有用性**：游戏是否为用户提供他们所寻找的体验？如果一个游戏或产品对某人没有用处，就没有理由将其推向市场。在UX设计中，我们使用HCD的发现和同理心阶段来发现我们正在设计的内容对我们用户的有用性。'
- en: '**Usable**: Can the user achieve their objectives while using the product?
    A game cannot be successful if it is difficult to play or understand. There are
    many factors that contribute to a video game''s usability, such as the controls,
    character animation, difficulty, and more.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：用户在使用产品时能否实现他们的目标？如果一个游戏难以玩或理解，它就不会成功。有许多因素会影响视频游戏的可用性，例如控制、角色动画、难度等。'
- en: '**Accessible**: Accessibility continues to be an important part of user experience
    design. Users with different ability levels should be able to play your game,
    and the experience you offer should be accessible to anyone. When we sit down
    and design for accessibility, we often find that we improve the experience for
    everyone. Several organizations have released developer resources to help bring
    more accessible games to market, such as [https://accessible.games/](https://accessible.games/)
    and [http://gameaccessibilityguidelines.com/](http://gameaccessibilityguidelines.com/).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性**：可访问性一直是用户体验设计的重要组成部分。不同能力水平的用户都应能够玩你的游戏，你提供的服务应让任何人都能访问。当我们坐下来为可访问性设计时，我们经常发现我们为每个人改善了体验。一些组织已经发布了开发者资源，以帮助将更多可访问的游戏推向市场，例如[https://accessible.games/](https://accessible.games/)和[http://gameaccessibilityguidelines.com/](http://gameaccessibilityguidelines.com/)。'
- en: '**Desirable**: Desirability refers to the marketing, branding, and aesthetic
    of a game or franchise. When we design for desirability, we want to create an
    image or emotional attachment that players want. The goal is to create a game
    experience that players will brag about and create a desire for that game in their
    friends.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吸引力**：吸引力指的是游戏或系列产品的市场营销、品牌和美学。当我们为吸引力设计时，我们希望创造一个玩家想要的图像或情感依恋。目标是创造一个玩家会吹嘘的游戏体验，并在他们的朋友中产生对该游戏的渴望。'
- en: '**Findable**: Findability refers to how easy a game is to find and purchase,
    but it also refers to how easy it is to find experiences contained within it the
    game. Imagine that a player purchases the latest arena shooter. They are excited
    to play with their friends, so they load the game, but can''t seem to find the
    play button or the options to customize the controls. They search through countless
    menus that allow them to make a character and tweak the sound, but just can''t
    get to the point where they can play with their buddies. Finally, they just give
    up and drop the controller. As developers, the last thing we want to is waste
    our players'' time and cause them frustration. This is why findability is so important.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可发现性**：可发现性指的是游戏找到和购买有多容易，但也指的是在游戏中找到体验有多容易。想象一下，一个玩家购买了最新的竞技场射击游戏。他们很兴奋地想和朋友们一起玩，所以他们加载了游戏，但似乎找不到播放按钮或自定义控制选项。他们搜索了无数菜单，允许他们创建角色和调整音效，但就是无法达到可以和朋友们一起玩的地步。最后，他们只是放弃了，扔掉了控制器。作为开发者，我们最不希望的就是浪费玩家的时间并让他们感到沮丧。这就是为什么可发现性如此重要的原因。'
- en: '**Valuable**: Players often find value based on factors such as online capabilities,
    hours of gameplay, announced features, and difficulty. The more value the player
    sees in the game, the more likely they are to purchase it. Terefore, the main
    goal of us designers is to have players see the value in our games and purchase
    them so that we can continue to design and create more experiences.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宝贵**：玩家通常会根据在线能力、游戏时长、宣布的功能和难度等因素来寻找价值。玩家在游戏中看到的价值越多，他们购买的可能性就越大。因此，我们设计师的主要目标是让玩家看到我们游戏的价值，并购买它们，这样我们才能继续设计和创造更多体验。'
- en: '**Credible**: This is the players'' ability to trust the developer to deliver
    the experience and features they have been promised. Credibility is an important
    commodity in the game industry, and one that we have seen publishers/developers
    take for granted in recent years. We only have one chance for our game to make
    a good first impression, and most players never give a product a second chance.
    This is especially important for smaller independent developers who rely on reputation
    and word of mouth to sell their games.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可信度**：这是玩家信任开发者能够交付他们承诺的体验和功能的能力。可信度是游戏行业的重要商品，近年来我们看到了出版商/开发者将其视为理所当然。我们的游戏只有一次机会给玩家留下良好的第一印象，而大多数玩家永远不会给产品第二次机会。这对依赖声誉和口碑来销售游戏的独立小型开发者来说尤为重要。'
- en: 'Together, these seven aspects of game design create the basis for a way to
    think about the user experience. When we design games with our players'' needs,
    goals, and overall experience in mind, we create products that are fun, memorable,
    and successful in the marketplace. With this idea in mind, let''s move on to creating
    the next portion of *Server 17*: the user interface elements that will be critical
    for controlling the experience and for conveying necessary information to the
    player.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些七个方面的游戏设计共同构成了思考用户体验的基础。当我们考虑到玩家的需求、目标和整体体验来设计游戏时，我们创造出的产品在市场上既有趣、又难忘、又成功。带着这个想法，让我们继续创建*Server
    17*的下一部分：那些对控制体验和向玩家传达必要信息至关重要的用户界面元素。
- en: User interfaces in VR
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR中的用户界面
- en: 'As we have seen, interaction in VR goes beyond what we are used to in traditional
    applications and video games. The player has near total immersion in the game
    world and can reach out and touch many of the objects they wish to interact with.
    This ability to interact directly with the environment opens many avenues for
    interface design while also presenting several challenges. One such challenge
    is that HUD elements that are displayed along the edges of a screen appear distorted
    and out of position in VR. Such elements can also break the immersion of the VR
    experience, depending on the story and setting. To solve the interface problem,
    most VR developers have moved away from these interfaces in favor of using information
    elements embedded within the game world. These can be broken down into the following
    three categories:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，VR中的交互超越了我们在传统应用程序和视频游戏中的习惯。玩家在游戏世界中几乎完全沉浸其中，可以伸手触摸他们想要与之互动的许多物体。这种直接与环境互动的能力为界面设计开辟了许多途径，同时也提出了几个挑战。其中一个挑战是，显示在屏幕边缘的HUD元素在VR中会扭曲并偏离位置。这些元素也可能根据故事和设置破坏VR体验的沉浸感。为了解决界面问题，大多数VR开发者已经远离了这些界面，转而使用嵌入在游戏世界中的信息元素。这些可以归纳为以下三个类别：
- en: Diagetic
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断性
- en: Spatial
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间
- en: Meta
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meta
- en: 'Let''s take a look at diagetic interfaces, as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看诊断性界面，如下面的截图所示：
- en: '![](img/7066e1e6-1815-4cb2-a3e9-3062b080572a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7066e1e6-1815-4cb2-a3e9-3062b080572a.png)'
- en: The Server 17 level clock
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Server 17关卡时钟
- en: Diagetic interface elements exist within the game world and provide the player
    with information directly from the environment. The map the player carries in
    *Minecraft* or *Firewatch,* the energy bars built into the suit of Isaac Clarke
    in *Dead Space*, and the watch that the player refers to in the *Metro* games
    are all examples of information being provided to the player by contextual clues
    inside the environment. Diagetic interfaces are preferred in virtual reality as
    they promote immersion and do not create any ill effects for the player.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断性界面元素存在于游戏世界中，并直接从环境中向玩家提供信息。玩家携带的地图，例如在*Minecraft*或*Firewatch*中，Isaac Clarke在*Dead
    Space*套装中嵌入的能量条，以及玩家在*Metro*游戏中提到的手表，都是环境内部通过上下文线索向玩家提供信息的例子。在虚拟现实中，诊断性界面更受欢迎，因为它们促进了沉浸感，并且不会对玩家产生任何不良影响。
- en: 'Next up are spatial interfaces, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是空间界面，如下面的截图所示：
- en: '![](img/490564ad-6e47-4930-bc02-b0fd2b764187.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/490564ad-6e47-4930-bc02-b0fd2b764187.png)'
- en: Spatial interface elements in Tribe XR
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Tribe XR中的空间界面元素
- en: Sometimes the best way to provide information to the player is to have it floating
    right in front of their face. Spatial interface elements float at designated world
    coordinates in the game world, waiting for the player to read or interact with
    them. We see these interfaces in many current VR titles—for example, the song
    menu in *Beat Saber,* the track selection interface in *Tribe XR,* and the ammo
    counters in *Robo Recall*. Spatial interface elements perform well in virtual
    reality as they blend in with the virtual world and often mimic traditional UI
    elements that players are used to using.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时向玩家提供信息最好的方式就是让它直接浮现在他们面前。空间界面元素在游戏世界中以指定的世界坐标浮动，等待玩家阅读或与之互动。我们在许多当前的VR游戏中看到这些界面——例如，*Beat
    Saber*中的歌曲菜单，*Tribe XR*中的曲目选择界面，以及*Robo Recall*中的弹药计数器。空间界面元素在虚拟现实中表现良好，因为它们与虚拟世界融合在一起，并且经常模仿玩家习惯使用的传统UI元素。
- en: 'Finally, we have meta interfaces:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有元界面：
- en: '![](img/57241460-c0fd-48fd-96e3-5aac07e5f805.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57241460-c0fd-48fd-96e3-5aac07e5f805.png)'
- en: Interface elements in *Robo Recall*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*Robo Recall*中的界面元素'
- en: Meta interface elements are defined as two-dimensional elements that are displayed
    as an overlay on the player's vision, but that are not persistent like a standard
    interface. These are often used to convey temporary information, such as damage,
    without a more permanent presence on the screen. The most common use of this type
    of interface is a blood splatter or red tinted vision to display damage in games
    such as *Gorn* and *Robo Recall*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 元界面元素被定义为在玩家视野上显示为叠加元素的两维元素，但它们不像标准界面那样持久。这些元素通常用于传达临时信息，例如伤害，而不在屏幕上留下更持久的存在。这种类型界面的最常见用途是在游戏如*Gorn*和*Robo
    Recall*中显示血迹或红色调的视野来显示伤害。
- en: Designing the UI elements for Server 17
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Server 17的UI元素
- en: Taking what we now know about user experience and interfaces, let's apply that
    knowledge to creating some UI elements for *Server 17*. For our first-time VR
    user, our interface elements should probably be diagetic for both ease of use
    and to preserve immersion in our Sci-Fi environment. We need to display our level
    timer so that the player knows how much time they have left. We also might need
    to rethink how the tools station is used to streamline the station interface.
    As always, remember to test with your user group along the way along the way and
    remember that you are designing the game to maximize their enjoyment!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解用户体验和界面之后，让我们将这些知识应用到为*Server 17*创建一些UI元素上。对于我们的首次VR用户，我们的界面元素可能应该是对白的，以便于使用并保持我们在科幻环境中的沉浸感。我们需要显示关卡计时器，以便玩家知道他们还剩下多少时间。我们可能还需要重新思考工具站的使用方式，以简化站界面。一如既往，记得在整个过程中测试你的用户群体，并记住你正在设计游戏以最大化他们的乐趣！
- en: Displaying the level timer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示关卡计时器
- en: 'Let''s start by designing the level timer, as shown in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设计关卡计时器开始，如下面的图所示：
- en: '![](img/66937198-9e35-4a40-8f10-8e5809738feb.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66937198-9e35-4a40-8f10-8e5809738feb.png)'
- en: Level timer wireframe created using a basic UI wireframe software
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本的UI线框软件创建的关卡计时器线框
- en: To keep the timer as simple as possible, we need to create something that is
    easily seen from anywhere in the level and does not take the player out of the
    experience. First, our timer should be digital to fit the Sci-Fi setting of our
    game. Second, it should be located in a place that the player finds natural to
    look at and can be easily found anywhere in the level. Finally, it should be able
    to display minutes and seconds, rather than just seconds, to fit the player's
    expectation of what a timer is. This is what I think would make a good solution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计时器尽可能简单，我们需要创建一个可以从关卡中的任何地方轻松看到且不会让玩家脱离体验的东西。首先，我们的计时器应该是数字的，以符合我们游戏的科幻背景。其次，它应该位于玩家觉得自然且易于在关卡中找到的位置。最后，它应该能够显示分钟和秒，而不仅仅是秒，以符合玩家对计时器的期望。这就是我认为的好解决方案。
- en: Creating a diagetic timer element will preserve the Sci-Fi experience for the
    player, as well as create something that is easy to read. We can locate our widget
    above the puzzle itself and allow it to rotate to always face the player. This
    will meet all of our criteria and create something that is fun and fits with our
    theme.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个对白计时器元素将保留玩家的科幻体验，同时也能创建出易于阅读的东西。我们可以将我们的小部件放置在谜题上方，并允许它旋转以始终面向玩家。这将满足我们所有的标准，并创造出既有趣又符合我们主题的东西。
- en: Our timer solution will consist of two different parts. The first is an **Unreal
    Motion Graphics** (**UMG**) widget scripted to calculate the level time. The second
    piece will be a class blueprint that displays our 2D widget in our 3D level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间解决方案将包括两个不同的部分。第一部分是一个用于计算关卡时间的脚本化**Unreal Motion Graphics**（**UMG**）小部件。第二部分将是一个类蓝图，用于在3D关卡中显示我们的2D小部件。
- en: When preparing for this book, I was asked by several people to discuss the difference
    between 2D and 3D interface assets in VR. 2D interface elements work in virtual
    reality as long as they exist as spatial or diagetic components. 3D pieces, such
    as the button and tool station we developed in the last chapter, work as well,
    specifically because they are diagetic in nature. The most important consideration
    should always be your players and their expectations. Research and testing will
    always help you design the best solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备这本书时，有几个人要求我讨论VR中2D和3D界面资产之间的区别。2D界面元素只要作为空间或对白组件存在，就可以在虚拟现实中工作。3D组件，如我们在上一章中开发的按钮和工具站，同样有效，特别是因为它们本质上是对白的。始终最重要的考虑因素应该是你的玩家和他们的期望。研究和测试将始终帮助你设计出最佳解决方案。
- en: 'We will start by creating the UMG widget, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建UMG小部件，如下面的截图所示：
- en: '![](img/b820f9ed-369c-4071-89eb-6159c698528b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b820f9ed-369c-4071-89eb-6159c698528b.png)'
- en: The UMG widget canvas
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: UMG小部件画布
- en: 'To create a UMG widget, go through the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建UMG小部件，请按照以下步骤操作：
- en: Right-click in the Content Browser, mouse over the User Interface option, and
    select Widget Blueprint. Name the new widget `LevelTimer`. Double-click the new
    blueprint to open it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击，将鼠标悬停在“用户界面”选项上，并选择“小部件蓝图”。将新小部件命名为“LevelTimer”。双击新蓝图以打开它。
- en: Our design consists of two text components, one a label and one that is updated
    every frame to display the time. Create the first one by using the Palette panel
    to find the Text component and dragging it on to the Canvas Panel.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的设计由两个文本组件组成，一个是标签，另一个是每帧更新以显示时间的组件。通过使用调色板面板找到文本组件并将其拖动到画布面板上创建第一个组件。
- en: In the Details panel, change the name to `TraceLabel`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板中，将名称更改为“TraceLabel”。
- en: In the Slot section of the Details panel, click the Anchors drop-down menu and
    choose the center option. This will keep it centered within our class blueprint.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板的“槽”部分，点击“锚点”下拉菜单并选择居中选项。这将使它在我们的类蓝图内保持居中。
- en: Change the Position X value to -150 and the Position Y value to -125.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“位置X”值更改为-150，将“位置Y”值更改为-125。
- en: Change the Size X value to 300 and the Size Y value to 100.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“大小X”值更改为300，将“大小Y”值更改为100。
- en: In the Appearance section of the Details panel, change the color of the text
    to something bright. I went with a green color, but feel free to change it to
    whatever you might like.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板的“外观”部分，将文本颜色更改为鲜艳的颜色。我选择了绿色，但您可以根据自己的喜好进行更改。
- en: In the Font portion of the Appearance section, change the Size value to 48.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“外观”部分的“字体”部分，将大小值更改为48。
- en: Finally, change the Justification option to center.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“对齐”选项更改为居中。
- en: With our font option set, we can now update the text. In the Content section
    of the Details panel, change the Text value to `TRACE ACTIVE`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好字体选项后，我们现在可以更新文本。在详细信息面板的“内容”部分，将文本值更改为“TRACE ACTIVE”。
- en: Create the second Text component and name it `TimerDisplay`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个文本组件并将其命名为“TimerDisplay”。
- en: Just like before, click the Anchors drop-down menu and change it to the center
    option.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，点击“锚点”下拉菜单并将其更改为居中选项。
- en: Change the Position X value to -150 and the Position Y value to -50.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“位置X”值更改为-150，将“位置Y”值更改为-50。
- en: Change the Size X value to 300 and the Size Y value to 100.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“大小X”值更改为300，将“大小Y”值更改为100。
- en: In the Appearance section of the Details panel, change the color to the same
    value that you used in step 7.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板的“外观”部分，将颜色更改为与步骤7中使用的相同值。
- en: In the Font portion of the Appearance section, change the Size value to 48.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“外观”部分的“字体”部分，将大小值更改为48。
- en: Change the Justification to center.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“对齐”更改为居中。
- en: In the content section of the panel, change the Text value to "MM:SS".
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板的内容部分，将文本值更改为“MM:SS”。
- en: 'Now we need to program the Text value to update and display the time remaining
    in our level. To do this we will create a bit of programming called a Bind. Click
    the Bind drop-down list to the right of the Text value and choose Create Binding,
    as shown in the following screenshot:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要编程文本值以更新并显示我们关卡中剩余的时间。为此，我们将创建一段称为绑定的编程。单击文本值右侧的“绑定”下拉列表，并选择创建绑定，如下面的截图所示：
- en: '![](img/8828118d-6dc4-4e72-8f98-9d0e660849aa.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8828118d-6dc4-4e72-8f98-9d0e660849aa.png)'
- en: Display Level Time binding
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显示级别时间绑定
- en: Let's start with a bit of housekeeping. In the Functions section of the My Blueprint
    panel, right-click on the name of our binding and choose the Rename option. Change
    the name to Display Level Time.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一些基础工作开始。在“我的蓝图”面板的“函数”部分，右键单击我们绑定的名称，并选择重命名选项。将名称更改为“Display Level Time”。
- en: This binding needs to be able to take the level time that is measured in seconds,
    convert it to minutes and seconds, and then display it as a string. The first
    step will be to create a new float variable that will hold our level time. Over
    in the Variables section of the My Blueprint panel, create a new float variable
    and name it Level Time.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此绑定需要能够接受以秒为单位测量的级别时间，将其转换为分钟和秒，然后将其作为字符串显示。第一步是创建一个新的浮点变量来存储我们的级别时间。在“我的蓝图”面板的“变量”部分创建一个新的浮点变量，并将其命名为“Level
    Time”。
- en: Drag a copy of our new variable into the blueprint, and choose Get from the
    menu. From here, we will delve a bit into Unreal's timespan system. We will use
    a node called Time Seconds to String to convert our seconds that are stored in
    Level Time to a string that is in the m*inutes:seconds:milliseconds* format. From
    there, we can convert the new string into text and feed it into our text component.
    Right-click and search for the Time Seconds to String node and connect Level Time
    to the In Seconds input.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们新变量的副本拖动到蓝图上，并从菜单中选择获取。从这里，我们将稍微深入了解Unreal的时间跨度系统。我们将使用一个名为Time Seconds to
    String的节点将存储在Level Time中的秒转换为以*m:秒:毫秒*格式的字符串。从那里，我们可以将新的字符串转换为文本并将其输入到我们的文本组件中。右键单击并搜索Time
    Seconds to String节点，并将Level Time连接到In Seconds输入。
- en: 'From there, plug the output from Time Seconds to String into the Return input
    and Unreal will create the translate node for us, as shown in the following screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，将Time Seconds to String的输出连接到Return输入，Unreal会为我们创建翻译节点，如下面的截图所示：
- en: '![](img/9af03543-6f9c-476b-8ec8-95ec18934eb6.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9af03543-6f9c-476b-8ec8-95ec18934eb6.png)'
- en: Event graph for level timer widget
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡计时器小部件的事件图
- en: Now to finish the setup for our timer. We will need to cast to `S17GameState`
    to retrieve the value of GameTime and that as our value for the Level Time. This
    allows us to change the value in one place and have it affect the timer automatically.
    Click over to the Event Graph for our widget and drag an execute line off the
    Event Construct node. Search for Cast To S17GameState.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来完成计时器的设置。我们需要将`S17GameState`转换为以检索GameTime的值，并将其作为Level Time的值。这允许我们在一个地方更改值，并自动影响计时器。切换到我们的小部件的事件图，从Event
    Construct节点拖出一条执行线。搜索Cast To S17GameState。
- en: Let's set up the cast. Drag a connection from the Object input, and search for
    the Get Game State node. With this defined, we can now pretend to be the Game
    State and retrieve the value of GameTime. Drag a connection from the `S17GameState`
    output and search for the Get Game Time node.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置cast。从对象输入拖动一个连接，并搜索Get Game State节点。定义好后，我们现在可以假装自己是游戏状态并检索GameTime的值。从`S17GameState`输出拖动一个连接并搜索Get
    Game Time节点。
- en: Lastly, we need to store the value of GameTime inside our Level Time node. Drag
    a copy of the Level Time variable into the blueprint and choose the set option,
    Connect this to the execute output from our cast node and connect the output from
    getting the value of GameTime into the float input for Level Time.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将GameTime的值存储在我们的Level Time节点中。将Level Time变量的副本拖动到蓝图上，并选择设置选项，将其连接到我们的cast节点的执行输出，并将获取GameTime值的输出连接到Level
    Time的浮点输入。
- en: To finally make our timer work, every tick we will quickly calculate the new
    time for Level Time. Combined with our Bind function, this will display the current
    remaining level time in our widget. Grab a copy of the Level Time variable and
    drag it into our blueprint. Choose Get from the menu and position it near the
    Event Tick node.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最终使计时器工作，我们将在每个tick中快速计算Level Time的新时间。结合我们的Bind函数，这将显示当前剩余关卡时间在我们的小部件中。获取Level
    Time变量的副本并将其拖动到我们的蓝图上。从菜单中选择获取，并将其放置在Event Tick节点附近。
- en: Drag another copy of the Level Time into the blueprint, only this time, choose
    Set from the menu. Connect this to the execute output from Event Tick.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Level Time的另一个副本拖动到蓝图上，这次从菜单中选择设置。将其连接到Event Tick的执行输出。
- en: Math time! We will use the In Delta Seconds output from Event Tick to calculate
    the time remaining in the level by subtracting it from the current value of Level
    Time. Drag a line off from the get Level Time node and search for `Float-Float`.
    Make sure the first value in this new node is Level Time and connect the In Delta
    Second output to the second input. Connect the output of this node to the float
    input on the set Level Time.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数学时间！我们将使用Event Tick的In Delta Seconds输出通过从Level Time的当前值中减去它来计算关卡剩余时间。从get Level
    Time节点拖出一条线并搜索`Float-Float`。确保这个新节点中的第一个值是Level Time，并将In Delta Second输出连接到第二个输入。将此节点的输出连接到set
    Level Time的浮点输入。
- en: With our timer functionality all set up, all that remains to do is display it
    in the level. To do this, we will make use of a class blueprint that contains
    a `Widget` component. This component allows us to display a 2D interface element
    in 3D space by projecting the widget on-to a plane. We can then position this
    plane over the puzzle and program it to always rotate to face the player. In this
    way, we can guarantee that the player can always see our countdown clock.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计时器功能全部设置完成后，剩下的就是将其显示在关卡中。为此，我们将使用一个包含 Widget 组件的类蓝图。该组件允许我们在 3D 空间中显示
    2D 界面元素，通过将 widget 投影到一个平面上。然后我们可以将这个平面放置在谜题上方，并编程使其始终旋转以面对玩家。这样，我们可以保证玩家始终可以看到我们的倒计时时钟。
- en: 'Start by creating a new Class Blueprint extended from Actor and name it `3dLevelTimer`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的从 Actor 扩展的 Class Blueprint 并命名为 `3dLevelTimer`：
- en: '![](img/aa2b415c-5c85-400e-98a7-0c68a910defc.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa2b415c-5c85-400e-98a7-0c68a910defc.png)'
- en: 3dLevelTimer function
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 3dLevelTimer 函数
- en: 'Let''s add the Widget component by going through the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤添加 Widget 组件：
- en: In the Viewport section of our blueprint, click the Add Component button and
    search for the Widget component. Add it to the blueprint and name it Display Widget.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的蓝图视图中，点击添加组件按钮并搜索 Widget 组件。将其添加到蓝图并命名为 Display Widget。
- en: Click on the new Display Widget in the Components panel. In the Details panel,
    find the Widget Class option in the User Interface section of the menu. Click
    the drop-down menu and select the Level Timer widget we created earlier.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中点击新的显示 Widget。在详细信息面板中，在菜单的用户界面部分找到 Widget 类选项。点击下拉菜单并选择我们之前创建的关卡计时器 widget。
- en: Next, we will create a new function to handle the rotation of the widget. In
    the Functions section of the My Blueprints panel, click the + function button.
    Name the new function Update Rotation.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的函数来处理 widget 的旋转。在 My Blueprints 面板的 Functions 部分中，点击 + 函数按钮。将新函数命名为
    Update Rotation。
- en: The purpose of the Update Rotation function is to find the location of the player's
    camera and rotate the widget around to face it so that our player can always look
    and see how much time is left. Start the function by dragging a line from the
    start node and searching for the IsValid node. We only want the widget to worry
    about rotating if the player is in the level.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Update Rotation 函数的目的是找到玩家摄像机的位置，并将 widget 旋转以面对它，这样我们的玩家就可以始终看到剩余时间。通过从起始节点拖动一条线并搜索
    IsValid 节点来启动该函数。我们只想让 widget 在玩家处于关卡时才关注旋转。
- en: From IsValid, drag a line from the IsValid output, and search for the SetWorldRotation
    node that references the Display Widget. Right-click on the New Rotation input
    and split the struct pin. We will need this for later.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 IsValid 拖动一条线从 IsValid 输出，并搜索引用 Display Widget 的 SetWorldRotation 节点。右键单击新旋转输入并拆分结构引脚。我们稍后会用到这个。
- en: Going back to the IsValid node, we still need to find the Input Object. Drag
    a line off the input, and search for the Get Player Camera Manager node. This
    node will provide the input for IsValid, as well as the node we will create in
    the next step.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 IsValid 节点，我们仍然需要找到输入对象。从输入拖动一条线，并搜索 Get Player Camera Manager 节点。此节点将为
    IsValid 提供输入，以及我们将在下一步创建的节点。
- en: Dragging another connection from the Get Player Camera Manager node, search
    for Get Camera Location. This will be the start location for finding our look
    at rotation.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Get Player Camera Manager 节点拖动另一个连接，搜索 Get Camera Location。这将是我们寻找注视旋转的起始位置。
- en: From the Return Value of Get Camera Location, drag a line and create a Find
    Look At Rotation node. To get the Target for our new node, we will need to drag
    a reference to our Display Widget into the blueprint from the Components panel.
    From this, create a Get World Location node and connect its output to the Target
    input on Find Look At Rotation.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Get Camera Location 的返回值拖动一条线并创建一个 Find Look At Rotation 节点。为了获取新节点的目标，我们需要从组件面板中将
    Display Widget 的引用拖入蓝图。从那里，创建一个 Get World Location 节点并将其输出连接到 Find Look At Rotation
    的目标输入。
- en: Almost there! Right-click on the Return Value pin from the Find Look At Rotation
    node and split the struct. We only need to work with the Yaw value. If we work
    with the Yaw as it is, our widget will be rotated backwards. We can correct this
    with a little bit of math. Drag a connection from the Return Value Z output and
    create a Float+Float node. Set the second value to `180`. Plug the output into
    the New Rotation Z input on the Set World Rotation node.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几乎完成了！在`Find Look At Rotation`节点的返回值引脚上右键单击，并拆分结构。我们只需要处理偏航值。如果我们以当前的形式处理偏航，我们的小部件将会反向旋转。我们可以通过一点数学来纠正这个问题。从返回值Z输出拖动一个连接并创建一个`Float+Float`节点。将第二个值设置为`180`。将输出连接到`Set
    World Rotation`节点的`New Rotation Z`输入。
- en: Time to add the new function to the Event Graph. Drag a copy of the UpdateRotation
    function into the blueprint and connect it to a copy of the Event Tick node. We
    are ready to test!
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将新功能添加到事件图了。将`UpdateRotation`函数的副本拖动到蓝图上，并将其连接到事件节点的副本。我们现在可以测试了！
- en: Programming complete! Drag a copy of the `3dLevelTimer` into your test level,
    and position it above the puzzle. Now test the new feature on yourself, as well
    as on your potential users. Pay attention to their feedback and adjust the size,
    color, and location of the timer as needed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编程完成！将`3dLevelTimer`的副本拖动到你的测试关卡中，并将其放置在谜题上方。现在亲自测试这个新功能，以及你的潜在用户。注意他们的反馈，并根据需要调整计时器的大小、颜色和位置。
- en: Redesigning the tool experience
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新设计工具体验
- en: 'Having applied user experience design principles to our level timer, let''s
    go back and take a look at the Tools Station we created in the last chapter. When
    testing with my users, I discovered that it was not intuitive for the player to
    have to head for a tool station every time they wanted to rotate the puzzle, especially
    within a timed experience. When we receive feedback like this, there is only one
    solution: redesign! Let''s look at the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在将用户体验设计原则应用于我们的关卡计时器后，让我们回到上一章中创建的工具站。在测试中，我发现玩家每次想要旋转谜题时都必须前往工具站，这在计时体验中尤其不直观。当我们收到这样的反馈时，只有一个解决方案：重新设计！让我们看看以下图表：
- en: '![](img/9a5cbf13-6473-4b3d-ba9f-ba0e3c03306a.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a5cbf13-6473-4b3d-ba9f-ba0e3c03306a.png)'
- en: New tools menu wireframe
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 新工具菜单线框
- en: After a couple of rounds of testing and interviews with my players, it became
    clear that having to go back to the tool station to rotate the puzzle (and use
    other future tools) was adding a step where there didn't need to be one. The tool
    station itself was a neat idea, but it didn't bring any additional value to the
    game experience. In fact, it made the experience less usable. The new goal will
    be to redesign the station as a tool menu that will be connected to the player's
    controller. This menu could be opened at any time or location and used in the
    same manner as the tool station, without having to move.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在与我的玩家进行几轮测试和访谈后，很明显，不得不回到工具站去旋转谜题（以及使用其他未来工具）增加了一个不必要的步骤。工具站本身是一个不错的主意，但它并没有为游戏体验带来任何额外的价值。事实上，它使体验变得不那么易用。新的目标将是重新设计这个站为一个与玩家控制器相连的工具菜单。这个菜单可以在任何时间或地点打开，并以与工具站相同的方式使用，无需移动。
- en: 'It will need to be built in two parts, similar to the level timer. The first
    will be a 2D widget that will contain all the functionality. The second will be
    a 3D widget that we can display whenever a button on the controller is pressed.
    We can see this setup in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要分为两部分来构建，类似于关卡计时器。第一部分将是一个包含所有功能的2D小部件。第二部分将是一个3D小部件，我们可以在按下控制器上的按钮时显示它。我们可以在以下屏幕截图中看到这个设置：
- en: '![](img/e8e10ee5-d9ba-4aad-8dc2-feff45a5fa7e.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8e10ee5-d9ba-4aad-8dc2-feff45a5fa7e.png)'
- en: The completed ToolsWidget interface
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的`ToolsWidget`界面
- en: 'Start by creating a new blueprint widget and naming it `ToolsWidget`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的蓝图小部件，并将其命名为`ToolsWidget`：
- en: Right-click in the Content Browser and create a new blueprint widget named `ToolsWidget`.
    Double-click the blueprint to open the UMG editor.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击并创建一个名为`ToolsWidget`的新蓝图小部件。双击蓝图以打开UMG编辑器。
- en: This time when we make our widget, we are going to take a more organized approach.
    Start by searching the Palette for the Image component. Drag it on to the Canvas
    Panel and change the Anchors option in the Details panel to the center. Change
    its name to `Background`. This will give our menu a nice background color.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次当我们创建小部件时，我们将采取更组织化的方法。首先，在调色板中搜索图像组件。将其拖到画布面板上，并在详细信息面板中将锚点选项更改为居中。将其名称更改为
    `Background`。这将给我们的菜单一个很好的背景颜色。
- en: Change the Position X and Position Y values to `-62.5`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位置 X 和位置 Y 的值更改为 `-62.5`。
- en: Change the Size X and Size Y values to `125`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大小 X 和大小 Y 的值更改为 `125`。
- en: Time to choose the color. Choose your new color with the Color and Opacity option.
    Setting your Alpha value to `0.5` gives it a nice Sci-Fi technology feel.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候选择颜色了。使用颜色和透明度选项选择您的新颜色。将 Alpha 值设置为 `0.5` 会给它一种不错的科幻科技感。
- en: Now we are going to create a Vertical Box component and add it to the Canvas panel.
    Don't forget to change its Anchors option to center.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个垂直框组件并将其添加到画布面板中。别忘了将其锚点选项更改为居中。
- en: Like the Background, change the Position X and Position Y values to `-62.5`,
    as well as the Size X and Size Y values to `125`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与背景一样，将位置 X 和位置 Y 的值更改为 `-62.5`，以及大小 X 和大小 Y 的值更改为 `125`。
- en: The Vertical Box organizes every component we place in it equally throughout
    the vertical space. We will use this to keep our buttons perfectly distributed
    in the menu. Start by dragging a Text component into the Vertical Box. Change
    the Horizontal Alignment to center and the Font Size to `14`. Set the Text to
    say Tools Menu.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直框将我们放置其中的每个组件在垂直空间中均匀组织。我们将使用这一点来确保我们的按钮在菜单中完美分布。首先，将文本组件拖到垂直框中。将水平对齐设置为居中，字体大小设置为
    `14`。将文本设置为工具菜单。
- en: Now we are going to add a few buttons. Two will be used to rotate the puzzle
    left and right. We will also build two buttons that can be used to program additional
    tools in the future. Head to the Palette and search for the Button component.
    Drag two copies into the Vertical Box. In the Details panel, change the Padding
    value of both buttons to `5`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加一些按钮。其中两个将用于左右旋转拼图。我们还将构建两个按钮，将来可以用来编程额外的工具。转到调色板并搜索按钮组件。将两个副本拖到垂直框中。在详细信息面板中，将两个按钮的填充值更改为
    `5`。
- en: Name the first button `Tools1_BTN` and the second button `Tools2_BTN`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个按钮命名为 `Tools1_BTN`，第二个按钮命名为 `Tools2_BTN`。
- en: Each button now needs a text label. Use the Palette to find the Text component
    and drag one on to each of our buttons. For each one, change the Font Size to
    `10`. Change the Text to Tool 1 and Tool 2.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个按钮现在都需要一个文本标签。使用调色板找到文本组件，并将其拖到每个按钮上。对于每个按钮，将字体大小更改为 `10`。将文本更改为工具 1 和工具 2。
- en: Now we will use a Horizontal Box to organize our rotation buttons. Use the search
    box in the Palette panel to find the Horizontal Box and drag a copy into our Vertical
    Box. In the Details panel, set the Size option to Fill.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用水平框来组织我们的旋转按钮。使用调色板面板中的搜索框找到水平框，并将其拖到我们的垂直框中。在详细信息面板中，将大小选项设置为填充。
- en: Drag two copies of the Button component into the Horizontal Box. Name the first
    button `Left_BTN` and the second `Right_BTN`. Set the Padding to `5` and Size
    option to Fill.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮组件拖到水平框中。将第一个按钮命名为 `Left_BTN`，第二个命名为 `Right_BTN`。设置填充为 `5`，大小选项为填充。
- en: Add a label to each button. Drag a Text component on to the left button. Set
    the Font Size to `10` and change the Text value to `<---`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个按钮添加标签。将文本组件拖到左侧按钮上。将字体大小设置为 `10`，并将文本值更改为 `<---`。
- en: Do the same for the right button, but set the Text value to `--->`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对右边的按钮也进行相同的操作，但将文本值设置为 `--->`。
- en: 'We now have a nice basic interface that is ready to be programmed. The plan
    is to program the left and right puzzle rotation buttons in a similar fashion
    to the tool station we created earlier. The additional tool buttons that we created
    will be left without functionality for the time being. Time to take a look at
    the code, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本界面，准备好进行编程。计划以与之前创建的工具站类似的方式编程左右拼图旋转按钮。我们创建的额外工具按钮将暂时不添加功能。现在是时候查看以下截图所示的代码了：
- en: '![](img/fc5d3ec1-9845-4a7f-a602-b7e6c57dac9c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc5d3ec1-9845-4a7f-a602-b7e6c57dac9c.png)'
- en: ToolsWidget programming blueprint
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ToolsWidget 编程蓝图
- en: 'To be able to rotate our puzzle, we first need to find a reference to it by
    going through the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够旋转我们的拼图，我们首先需要通过以下步骤找到它的引用：
- en: We need to be able to find the puzzle that is in our level as soon as the interface
    is created. To do this, we will use the Event Construct node. Head over to the
    Graph, and create one using the Palette panel, if there isn't one already there.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在界面创建时就能找到我们关卡中的谜题。为此，我们将使用事件构造节点。转到图，如果还没有，使用调色板面板创建一个。
- en: To find the puzzle, we are going to use a node called Get All Actors of Class.
    This node is able to find every copy of a specific class inside your level and
    dump it into a temporary array. Drag an execute line from Event Construct and
    drop it. Search for Get All Actors of Class, and set the Actor Class option to
    PuzzleCubeTest.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到谜题，我们将使用一个名为Get All Actors of Class的节点。这个节点能够找到你关卡中特定类的每个副本，并将其放入一个临时数组中。从事件构造拖一条执行线，并将其放下。搜索“Get
    All Actors of Class”，并将Actor Class选项设置为PuzzleCubeTest。
- en: The Out Actors output gives us an array containing any instances of PuzzleCubeTest.
    In this case, there is only one. To access it, we will use the Get (a copy) node.
    Drag a line from the Out Actors output, and create one using the menu. The node
    will access index 0, the first slot in the array, which should contain our one
    and only reference to PuzzleCubeTest.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Out Actors输出给我们一个包含PuzzleCubeTest任何实例的数组。在这种情况下，只有一个。要访问它，我们将使用Get (a copy)节点。从Out
    Actors输出拖一条线，并使用菜单创建一个。该节点将访问索引0，数组中的第一个槽位，应该包含我们对PuzzleCubeTest的唯一引用。
- en: Drag a line from the output of the Get node and choose Promote to Variable from
    the menu. This will place our puzzle reference in a variable we can use. Name
    the new variable ActivePuzzle. Connect the execute output from the event to the
    Set node that was created for our new variable.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从获取节点的输出拖一条线，并从菜单中选择提升到变量。这将把我们的谜题引用放在一个我们可以使用的变量中。将新变量命名为ActivePuzzle。将事件的执行输出连接到为我们新变量创建的设置节点。
- en: With our puzzle reference in place, it is now time to create the rotation. Just
    like when we created our 3D button, we will use the In Delta Time output from
    the node to control our rotation. Create an Event Tick node if there is not one
    already in the blueprint.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置好谜题引用后，现在是我们创建旋转的时候了。就像我们创建3D按钮时一样，我们将使用节点的In Delta Time输出来控制我们的旋转。如果蓝图里还没有，创建一个事件计时节点。
- en: Since we have to check for a button press for both the left and right button,
    we will need to use a Sequence node. Drag a line from the execute output of the
    Event Tick node, and create the Sequence node.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们必须检查左右按钮的按键，我们需要使用一个序列节点。从事件计时节点的执行输出拖一条线，并创建一个序列节点。
- en: The Then 0 branch will handle the Left button, and we will use the same technique
    we used when we created the original rotation code. Drag a line off the Then 0
    output, and create a Gate node.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Then 0分支将处理左键，我们将使用创建原始旋转代码时使用的相同技术。从Then 0输出拖一条线，并创建一个门节点。
- en: Now we need a pressed and a released event to control the opening and closing
    of the gate. Head over to the Variables section of the My Blueprints panel and
    click on Left_BTN. Scroll to the bottom of the Details panel and click the + button
    next to the On Pressed and On Released options. Connect the On Pressed event to
    the Open input on the gate. Finally, connect the On Released event to the Close
    input.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个按下和释放的事件来控制门的开启和关闭。转到我的蓝图面板的变量部分，点击Left_BTN。滚动到详细信息面板的底部，点击On Pressed和On
    Released选项旁边的+按钮。将On Pressed事件连接到门的打开输入。最后，将On Released事件连接到关闭输入。
- en: We need to program the actual rotation using the AddActorLocalRotation node.
    Drag a line from the Exit output of the gate, and create the node. For the Target,
    head over to the Variables section and grab the Active Puzzle variable. Bring
    it into the blueprint and select Get from the menu. Plug it into the Target input
    on AddActorLocalRotation.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用AddActorLocalRotation节点来编程实际的旋转。从门的退出输出拖一条线，并创建该节点。对于目标，转到变量部分，获取Active
    Puzzle变量。将其拖入蓝图，并从菜单中选择获取。将其插入到AddActorLocalRotation的目标输入上。
- en: To get our Delta Rotation, we will multiply the change in time by a rotation
    speed. Create a new Float variable and name it Rotation Speed. Bring it into the
    blueprint and choose the Get option. Drag a line from its output, and create a
    Make Rotator node. Lastly, move the connection from the X input to the Z input.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取我们的Delta旋转，我们将时间变化乘以旋转速度。创建一个新的Float变量，并将其命名为旋转速度。将其拖入蓝图，并选择获取选项。从其输出拖一条线，创建一个Make
    Rotator节点。最后，将连接从X输入移动到Z输入。
- en: Drag from the output of Make Rotator and connect a Scale Rotator node. This
    node takes a rotator and multiplies it by a float value. Connect the float input
    to the In Delta Seconds output from Event Tick.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Make Rotator的输出拖动并连接一个Scale Rotator节点。此节点接受一个旋转器并将其乘以一个浮点值。将浮点输入连接到Event Tick的In
    Delta Seconds输出。
- en: 'Finally, connect the output of the Scale Rotator to the Delta Rotation input
    for AddActorLocalRotation, as shown in the following screenshot:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将Scale Rotator的输出连接到AddActorLocalRotation的Delta Rotation输入，如图所示：
- en: '![](img/be612489-1035-4223-af8c-2bca2df87f43.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be612489-1035-4223-af8c-2bca2df87f43.png)'
- en: ToolsWidget puzzle rotation code
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ToolsWidget拼图旋转代码
- en: Repeat the steps from step 7 to step 12 for the Then 1 branch to program the
    right button, but this time add a `Float * Float` node between the Rotation Speed
    and the Make Rotator node. Set the second value to -1 to change the direction
    of the rotation.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Then 1分支，重复从步骤7到步骤12的步骤来编程右键，但这次在Rotation Speed和Make Rotator节点之间添加一个`Float
    * Float`节点。将第二个值设置为-1以改变旋转方向。
- en: 'With the tools widget built and programmed, it''s time to build the 3D widget
    to display it inside the level. We are going to use the same process we used to
    display the timer widget in the level, but this time, we will attach the 3D widget
    to the motion controller to give the feel of a wrist-mounted display, as shown
    in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 工具Widget构建和编程完成后，是时候构建3D小部件以在级别内显示它了。我们将使用与在级别中显示计时器小部件相同的流程，但这次，我们将3D小部件附加到动作控制器上，以提供手腕式显示的感觉，如图所示：
- en: '![](img/a7778402-ac38-48b4-9587-0c1e7a03d959.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7778402-ac38-48b4-9587-0c1e7a03d959.png)'
- en: The ToolsWidget in action, mounted to the player's wrist
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 工具Widget在实际操作中，安装在玩家的手腕上
- en: 'Right-click in the Content Browser and create a new Class Blueprint based on
    the Actor. Name it `3dToolsWidget`, double-click to open it, then go through the
    following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击并创建一个新的基于Actor的Class Blueprint。将其命名为`3dToolsWidget`，双击打开它，然后执行以下步骤：
- en: In the Components panel, use the Add Component button to add a Widget component
    to the Viewport.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中，使用添加组件按钮向视图中添加一个Widget组件。
- en: In the Details panel, rename this to `ToolsWidget`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”面板中，将其重命名为`ToolsWidget`。
- en: In the User Interface section of Details, click on the Widget Class drop-down
    menu, and choose our `ToolsWidget` interface.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“用户界面”部分的“详细信息”中，单击Widget Class下拉菜单，并选择我们的`ToolsWidget`界面。
- en: Set the X and Y values for the Draw Size to `125`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绘制大小X和Y值设置为`125`。
- en: Time to add the interface to our `Server17PlayerPawn`. Find the player pawn
    in the Content Browser and double-click it to open it.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将界面添加到我们的`Server17PlayerPawn`中了。在内容浏览器中找到玩家角色，双击它以打开它。
- en: Let's add the interface to the motion controller. Click the Add Component button
    and search for the Child Actor component. Name it `ChildActor_ToolsWidget` and
    make it a child of `MotionController_L` in the hierarchy.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将界面添加到动作控制器中。单击添加组件按钮并搜索子演员组件。将其命名为`ChildActor_ToolsWidget`并将其设置为层次结构中的`MotionController_L`的子项。
- en: In the Details panel, set the Child Actor Class option to `3dToolsWidget`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”面板中，将“子演员类”选项设置为`3dToolsWidget`。
- en: In the Viewport, use the move and rotate tools to position the widget at the
    left wrist, similar to a wristwatch. If you prefer to type the values in yourself,
    set the location values to *X=5*, *Y=-5*, and *Z=0*. For the rotation values,
    use *X=180*, *Y=0*, and *Z=-90*.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中，使用移动和旋转工具将小部件定位在左侧手腕处，类似于手表。如果您喜欢自己输入值，将位置值设置为*X=5*，*Y=-5*，和*Z=0*。对于旋转值，使用*X=180*，*Y=0*，和*Z=-90*。
- en: Since our interface display is quite large on the player's wrist, change the
    Scale values to *0.2*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的界面显示在玩家手腕上相当大，将缩放值更改为*0.2*。
- en: 'By default, motion controllers do not have a way to interact with 2D interface
    elements since they were originally designed for mouse interaction. To add this
    functionality, we need to use a Widget Interaction component. This component was
    designed by Epic Games to be the bridge between VR controllers and traditional
    interfaces, and just takes a little setup to use. Start by adding a Widget Interaction
    component to the `Server17PlayerPawn`, as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，动作控制器没有与2D界面元素交互的方式，因为它们最初是为鼠标交互设计的。为了添加此功能，我们需要使用一个Widget Interaction组件。这个组件是由Epic
    Games设计的，作为VR控制器和传统界面之间的桥梁，并且只需要一点设置即可使用。首先，将一个Widget Interaction组件添加到`Server17PlayerPawn`中，如图所示：
- en: '![](img/49ffdb9c-bd53-4bef-ac5a-aa79d9c555ac.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49ffdb9c-bd53-4bef-ac5a-aa79d9c555ac.png)'
- en: Widget Interaction component
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Widget Interaction组件
- en: 'We will add one of these components to each motion controller:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向每个运动控制器添加以下组件之一：
- en: In the Components panel, use the Add Component button to add two copies of the
    Widget Interaction component. Make one a child of MotionController_L and name
    it Widget Interaction L. Make the other a child of MotionController_R and name
    it Widget Interaction R. This will give the functionality to both hands.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中，使用添加组件按钮添加两个 Widget Interaction 组件的副本。将一个作为 MotionController_L 的子组件，命名为
    Widget Interaction L。将另一个作为 MotionController_R 的子组件，命名为 Widget Interaction R。这将赋予双手功能。
- en: The Widget Interaction component allows us to simulate a mouse pointer. We can
    also simulate a mouse click with just a little bit of code. Head over to the Event
    Graph for our player pawn and locate our trigger code. We can add the functionality
    on the end of the existing sequence. Drag an execute line from from the end of
    the left trigger sequence, drop it, and search for the Press Pointer Key (Widget
    Interaction L) node. Use the Key drop-down list to choose the Left Mouse Button.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Widget Interaction 组件允许我们模拟鼠标指针。我们还可以通过一点代码模拟鼠标点击。前往我们的玩家 pawn 的事件图，并定位我们的触发代码。我们可以在现有序列的末尾添加功能。从左触发序列的末尾拖动一条执行线，放下它，并搜索
    Press Pointer Key (Widget Interaction L) 节点。使用键下拉列表选择左鼠标按钮。
- en: Drag a line from the output from the reference to Widget Interaction L that
    we just created, and search for the Release Pointer key node. Set the Key drop-down
    menu to Left Mouse Button, and connect an execute line back to the End Drag node.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们刚刚创建的 Widget Interaction L 的输出拖动一条线，并搜索 Release Pointer 键节点。将键下拉菜单设置为左鼠标按钮，并将执行线连接回
    End Drag 节点。
- en: Repeat the process for Widget Interaction R to give the same functionality to
    our right trigger.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的右触发器重复此过程，以赋予相同的函数功能。
- en: 'At this point, we can test our interface. Make sure that the rotate functionality
    is working and that the position at the left wrist is correct. There is one more
    bit of programming to do to finish this menu. Let''s make it so that the menu
    can be toggled on and off using the menu button on the motion controller. This
    way, a player can hide it if they are not using it. To do this, we will need to
    use the MotionController (L) Shoulder event, as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以测试我们的界面。确保旋转功能正常工作，并且左手腕的位置正确。为了完成此菜单，我们还需要进行一些编程。让我们使其可以通过运动控制器上的菜单按钮切换开和关。这样，玩家可以在不使用时隐藏它。为此，我们需要使用
    MotionController (L) 肩部事件，如下面的截图所示：
- en: '![](img/35d13d92-8bb2-4de1-9587-1c7de716d6c6.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35d13d92-8bb2-4de1-9587-1c7de716d6c6.png)'
- en: ToolsWidget toggle code
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 工具小部件切换代码
- en: 'Start by creating the event node by going through the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过以下步骤创建事件节点：
- en: Right-click in the Event Graph for `Server17PlayerPawn` , and search for the MotionController
    (L) Shoulder event. Create it and position it near the rest of our button code.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Event Graph 的 `Server17PlayerPawn` 上右键单击，并搜索 MotionController (L) 肩部事件。创建它并将其放置在我们按钮代码的附近。
- en: Drag an execution line from the Pressed output and drop it. Search for the Toggle
    Visibility (ChildActor_ToolsWidget) and place it in the blueprint.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从按下输出拖动一条执行线并将其放下。搜索 Toggle Visibility (ChildActor_ToolsWidget) 并将其放置在蓝图上。
- en: Go back to the Viewport for our player pawn, and click on the ChildActor_ToolsWidget.
    In the Details panel, turn off the Visibility option.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回我们的玩家 pawn 视口，并点击 ChildActor_ToolsWidget。在详细信息面板中，关闭可见性选项。
- en: And done! We have now constructed two different interface elements that make
    more use of 2D menu components, and we have learned how to display them in a 3D
    space. We have programmed them to interact with the world and added the ability
    to simulate mouse interaction to our motion controllers so that we can use them.
    Just think of all the great interactive menus you could now create for your virtual
    reality experiences, using either 3D objects or 2D interfaces!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！我们现在已经构建了两个不同的界面元素，它们更多地使用了 2D 菜单组件，并且我们学习了如何在 3D 空间中显示它们。我们编程了它们以与世界交互，并添加了模拟鼠标交互的能力，以便我们可以使用它们。只需想想你现在可以为你的虚拟现实体验创建的所有伟大的交互式菜单，无论是使用
    3D 对象还是 2D 界面！
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about user experience and how HCD is just one small
    part of this much larger field. We explored the field of UX design and how VR
    has caused it to expand beyond traditional interface interactions. We also learned
    about the seven aspects of user experience that are important. From there, we
    took a look at the different types of user interfaces and learned what works best
    in virtual reality. Finally, we applied our new knowledge of user experience and
    VR-ready interfaces to design and create the interface widgets for our level.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了用户体验以及HCD只是这个更大领域中的一小部分。我们探讨了用户体验设计的领域，以及VR如何使其超越了传统的界面交互。我们还学习了用户体验的七个重要方面。从那里，我们审视了不同类型的用户界面，并了解了在虚拟现实中什么最有效。最后，我们将我们对用户体验和VR兼容界面的新知识应用于设计和创建我们级别的界面小部件。
- en: In the next chapter, we will discuss how to create eye-popping visual elements
    for virtual reality games. Like gameplay elements and user interfaces, art for
    VR games has different requirements than art created for traditional video games.
    Optimization is key to keeping performance high and our player comfortable. We
    will look at some techniques for creating our lighting and visual effects, as
    well as what is needed to make the most of our static meshes and materials.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何为虚拟现实游戏创建令人眼前一亮的视觉元素。就像游戏玩法元素和用户界面一样，VR游戏的美术创作与传统视频游戏美术创作有不同的要求。优化是保持性能高和玩家舒适的关键。我们将探讨一些创建我们的照明和视觉效果的技术，以及充分利用我们的静态网格和材料所需的内容。
