["```cpp\n#include <iostream>\nint main() {\n  std::cout << \"Hello, World!\" << std::endl;\n  return 0;\n}\n```", "```cpp\n#include <iostream>\nint main(int argc, char* argv[]) {\n std::cout << \"The number of passed arguments is: \" << argc << std::endl;\n std::cout << \"Arguments are: \" << std::endl;\n for (int ix = 1; ix < argc; ++ix) {\n   std::cout << argv[ix] << std::endl;\n }\n return 0;\n}\n```", "```cpp\n$ my-program argument1 hello world --some-option\n```", "```cpp\nThe number of passed arguments is: 5\nArguments are:\nargument1\nhello\nworld\n--some-option\n```", "```cpp\n#include <iostream>\n\nvoid foo() {\n  std::cout << \"Risky foo\" << std::endl;\n}\n\n// trying to call the foo() outside of the main() function\nfoo();\n\nint main() {\n  std::cout << \"Calling main\" << std::endl;\n  return 0;\n}\n```", "```cpp\n#include <iostream>\n\nstruct BeforeMain {\n  BeforeMain() {\n std::cout << \"Constructing BeforeMain\" << std::endl;\n }\n};\n\nBeforeMain b;\n\nint main() {\n  std::cout << \"Calling main()\" << std::endl;\n  return 0;\n}\n```", "```cpp\nConstructing BeforeMain\nCalling main()\n```", "```cpp\nstruct BeforeMain {\n  // constructor code omitted for brevity\n void test() {\n std::cout << \"test function\" << std::endl;\n }\n};\n\nBeforeMain b;\nb.test(); // compiler error\n\nint main() {\n  // code omitted for brevity\n}\n```", "```cpp\nvoid __libc_start_main() {\n  BeforeMain b;\n  main();\n}\n__libc_start_main(); // call the entry point\n```", "```cpp\nint main() {\n  // works fine without a return statement\n}\n```", "```cpp\n// C++11\nauto foo() -> int {\n  std::cout << \"foo in alternative function syntax\" << std::endl;\n  return 0; } // C++14 auto foo() {\n  std::cout << \"In C++14 syntax\" << std::endl;\n  return 0;\n}\n```", "```cpp\nauto get_ratio(bool minimum) {\n  if (minimum) {\n return 12; // deduces return type int\n  }\n return 18; // fine: get_ratio's return type is already deduced to int\n}\n```", "```cpp\nauto main() {\n  std::cout << get_ratio(true);\n  return 0;\n}\n```", "```cpp\nauto get_ratio(bool precise = false) {\n  if (precise) {\n    // returns a float value\n    return 4.114f;\n  }\n  return 4; // returns an int value\n}\n```", "```cpp\nint double_it(int number) {\n  return number * 2;\n}\n\nconstexpr int triple_it(int number) {\n  return number * 3;\n}\n\nint main() {\n  int doubled = double_it(42);\n  int tripled = triple_it(42);\n  int test{0};\n  std::cin >> test; \n  int another_tripled = triple_it(test);\n} \n```", "```cpp\nint main() {\n  int doubled = double_it(42);\n int tripled = 126; // 42 * 3  int test = 0;  std::cin >> test;\n  int another_tripled = triple_it(test);\n}\n```", "```cpp\nvoid print_number(int num) {\n std::cout << num << std::endl;\n print_number(num + 1); // recursive call\n}\n```", "```cpp\nvoid print_number(int num) {\n if (num > 100) return; // base case\n  std::cout << num << std::endl;\n print_number(num + 1); // recursive call\n}\n```", "```cpp\nint sum(int n, int m) { return n + m; }\nint max(int x, int y) { \n  int res = x > y ? x : y; \n  return res;\n}\nint calculate(int a, int b) {\n  return sum(a, b) + max(a, b);\n}\n\nint main() {\n  auto result = calculate(11, 22);\n  std::cout << result; // outputs 55\n}\n```", "```cpp\nvar a = 12;\na = \"Hello, World!\";\na = 3.14;\n```", "```cpp\nauto a = 12;\nauto b = \"Hello, World!\";\nauto c = 3.14;\n```", "```cpp\n#include <iostream>\n#include <type_traits>\n\nstruct Point {\n  float x;\n  float y;\n};\n\nint main() {\n  std::cout << std::is_fundamental_v<Point> << \" \"\n            << std::is_fundamental_v<int> << \" \"\n            << std::is_compound_v<Point> << \" \"\n            << std::is_compound_v<int> << std::endl;\n}\n```", "```cpp\ntemplate <class T>\ninline constexpr bool is_fundamental_v = is_fundamental<T>::value;\ntemplate <class T>\ninline constexpr bool is_compound_v = is_compound<T>::value;\n```", "```cpp\nchar ch = 65;\nstd::cout << ch; // prints A\n```", "```cpp\nint answer = 42;\nstd::cout << &answer;\n```", "```cpp\n0x7ffee1bd2adc\n```", "```cpp\nint* ptr = &answer;\n```", "```cpp\nint ivar = 26;\nchar ch = 't';\ndouble d = 3.14;\n```", "```cpp\nint* ptr = &ivar;\nchar* pch = &ch;\ndouble* pd = &d;\n```", "```cpp\nstd::cout << *ptr; // prints 26\n```", "```cpp\nint ivar = 26;\nchar* p = (char*)&ivar;\n```", "```cpp\n// the first byte\n*p;\n// the second byte\n*(p + 1);\n// the third byte\n*(p + 2);\n\n// dangerous stuff, the previous byte\n*(p - 1);\n```", "```cpp\nshort* sh = (short*)&ivar;\nstd::cout << *sh; // print the value in the first two bytes of ivar\nstd::cout << *(sh + 1); // print the value in the last two bytes of ivar\n```", "```cpp\nstd::cout << sizeof(ptr) << \" = \" << sizeof(pch) << \" = \" << sizeof(pd);\n```", "```cpp\n#include <iostream>\nint max(int a, int b) { return a > b ? a : b; }\nint main() {\n  std::cout << \"The maximum of 11 and 22 is: \" << max(11, 22);\n}\n```", "```cpp\nint max(int a, int b) {\n // allocate space for the \"a\" argument\n // allocate space for the \"b\" argument\n  return a > b ? a : b;\n // deallocate the space for the \"b\" argument\n // deallocate the space for the \"a\" argument\n}\n```", "```cpp\n#include <cstdlib>\nstruct Point {\n  float x;\n  float y;\n};\n\nint main() {\n std::malloc(sizeof(Point));\n}\n```", "```cpp\nvoid* raw = std::malloc(sizeof(Point)); Point* p = static_cast<Point*>(raw); \n```", "```cpp\nPoint* p = static_cast<Point*>(std::malloc(sizeof(Point))); \n```", "```cpp\nPoint* p = new Point;\n```", "```cpp\n(*p).x = 0.24;\n```", "```cpp\np->x = 0.24;\n```", "```cpp\nint arr[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n```", "```cpp\nstd::cout << *(arr + 2);\n```", "```cpp\nstd::cout << *(arr + 0);\nstd::cout << *arr;\nstd::cout << arr[0];\n```", "```cpp\nstd::cout << *(2 + arr);\n```", "```cpp\nstd::cout << 2[arr];\n```", "```cpp\nint* arr = new int[10];\narr[4] = 2; // the same as *(arr + 4) = 2 \n```", "```cpp\nint divide(int a, int b) {\n if (b == 0) {\n    throw std::invalid_argument(\"The divisor is zero\");\n  }\n  return a / b;\n}\n```", "```cpp\nint max(int a, int b) {\n  int max;\n if (a > b) {\n    // the if block\n    max = a;\n } else {\n    // the else block\n    max = b;\n  }\n  return max;\n}\n```", "```cpp\na = b + 2 * c - 1;\n```", "```cpp\nmov rax, b; copy the contents of \"b\" \n          ; located in the memory to the register rax\nmov rbx, c; the same for the \"c\" to be able to calculate 2 * c\nmul rbx, 2; multiply the value of the rbx register with \n          ; immediate value 2 (2 * c)\nadd rax, rbx; add rax (b) with rbx (2*c) and store back in the rax\nsub rax, 1; subtract 1 from rax\nmov a, rax; copy the contents of rax to the \"a\" located in the memory\n```", "```cpp\nmov rax, 2\nmov rbx, 0\njmp UNANSWERED\nadd rbx, 42; will be skipped\nUNANSWERED:\n  add rax, 1\n  ; ...\n```", "```cpp\nmov rax, max; copy the \"max\" into the rax register\nmov rbx, a\nmov rdx, b\ncmp rbx, rdx; compare the values of rbx and rdx (a and b)\njg GREATER; jump if rbx is greater than rdx (a > b)\njl LESSOREQUAL; jump if rbx is lesser than\nGREATER:\n  mov rax, rbx; max = a\nLESSOREQUAL:\n  mov rax, rdx; max = b\n```", "```cpp\nswitch (age) {\ncase 18:\n  can_drink = false;\n  can_code = true;\n  break;\ncase 21: \n  can_drink = true;\n  can_code = true;\n break;\ndefault: \n  can_drink = false;\n}\n```", "```cpp\ncmp rax, 18\nje CASE_18\ncmp rax, 21\nje CASE_21\nje CASE_DEFAULT\nCASE_18:\n  mov rbx, 0; cannot drink\n  mov rdx, 1; can code\n  jmp BEYOND_SWITCH; break\nCASE_21:\n mov rbx, 1\n mov rdx, 1\n jmp BEYOND_SWITCH\nCASE_DEFAULT:\n mov rbx, 0\nBEYOND_SWITCH:\n  ; ....\n```", "```cpp\nint get_answer() { return 42; }\nint (*fp)() = &get_answer;\n// int (*fp)() = get_answer; same as &get_answer\n```", "```cpp\nget_answer(); // returns 42\nfp(); // returns 42\n```", "```cpp\n#include <unordered_map>\nint add(int a, int b) { return a + b; }\nint subtract(int a, int b) { return a - b; }\nint multiply(int a, int b) { return a * b; }\nint divide(int a, int b) { return (b == 0) ? 0 : a / b; }\n\nint main() {\n std::unordered_map<char, int (*)(int, int)> operations;\n operations['+'] = &add;\n operations['-'] = &subtract;\n operations['*'] = &multiply;\n operations['/'] = &divide;\n  // read the input \n  char op;\n  int num1, num2;\n  std::cin >> num1 >> num2 >> op;\n  // perform the operation, as follows\n operations[op](num1, num2);\n}\n\n```", "```cpp\nif (op == '+') {\n  add(num1, num2);\n} else if (op == '-') {\n  subtract(num1, num2);\n} else if (op == '*') {\n  ...\n```", "```cpp\noperations[op](num1, num2);\n```", "```cpp\n#include <functional>\n#include <unordered_map>\n// add, subtract, multiply and divide declarations omitted for brevity\nint main() {\n  std::unordered_map<char, std::function<int(int, int)> > operations;\n  operations['+'] = &add;\n  // ...\n}\n```", "```cpp\n// code omitted for brevity\nstd::cin >> num1 >> num2 >> op;\ntry {\n operations[op](num1, num2);\n} catch (std::bad_function_call e) {\n  // handle the exception\n  std::cout << \"Invalid operation\";\n}\n```", "```cpp\nstd::unordered_map<char, std::function<int(int, int)> > operations;\noperations['+'] = [](int a, int b) { return a + b; }\noperations['-'] = [](int a, int b) { return a * b; }\n// ...\nstd::cin >> num1 >> num2 >> op;\ntry {\n  operations[op](num1, num2);\n} catch (std::bad_functional_call e) {\n  // ...\n}\n```", "```cpp\nauto num = 0;\nauto sum = 0;\nwhile (num <= 10) {\n  sum += num;\n  ++num;\n}\n```", "```cpp\nmov rax, 0; the sum\nmov rcx, 0; the num\nLOOP:\n  cmp rbx, 10\n  jg END; jump to the END if num is greater than 10\n  add rax, rcx; add to sum\n  inc rcx; increment num\n  jmp LOOP; repeat\nEND:\n  ...\n```", "```cpp\nauto sum = 0;\nwhile (auto num = 0; num <= 10) {\n  sum += num;\n  ++num;\n}\n```", "```cpp\nint get_absolute(int num) {\n  if (int neg = -num; neg < 0) {\n    return -neg;\n  }\n  return num;\n}\n```", "```cpp\nfor (auto& op: operations) {\n  std::cout << op.second(num1, num2);\n}\n```", "```cpp\nfor (auto& [op, func]: operations) {\n  std::cout << func(num1, num2);\n}\n```"]