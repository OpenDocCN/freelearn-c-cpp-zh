- en: Advanced Tools and Upcoming Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级工具和即将推出的功能
- en: WebAssembly's ecosystem is constantly growing and evolving. Developers have
    seen the potential for WebAssembly. They build tools to improve the development
    experience or output Wasm modules from their language of choice (albeit with some
    limitations).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的生态系统不断增长和发展。开发人员已经看到了WebAssembly的潜力。他们构建工具来改善开发体验或从他们选择的语言输出Wasm模块（尽管有一些限制）。
- en: In this chapter, we'll evaluate the underlying technologies that make WebAssembly
    tick. We'll also review tools you can use in the browser and cover an advanced
    use case that utilizes Web Workers. Finally, we'll quickly review upcoming features
    and proposals that are on the roadmap for WebAssembly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将评估使WebAssembly运行的基础技术。我们还将审查您可以在浏览器中使用的工具，并介绍一种利用Web Workers的高级用例。最后，我们将快速审查即将推出的功能和WebAssembly路线图上的提案。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下内容：
- en: How WABT and Binaryen fit into the build process and what they can be used for
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WABT和Binaryen如何适应构建过程以及它们可以用于什么
- en: How to compile a WebAssembly module using LLVM (rather than Emscripten)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用LLVM编译WebAssembly模块（而不是Emscripten）
- en: Online tools such as WasmFiddle and other useful tooling online
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WasmFiddle等在线工具和其他有用的在线工具
- en: How to utilize Web Workers to run WebAssembly in parallel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用Web Workers并行运行WebAssembly
- en: Upcoming features (proposed and in progress) that will be integrated into WebAssembly
    in the future
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来将集成到WebAssembly中的功能（提议和进行中）
- en: WABT and Binaryen
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WABT和Binaryen
- en: WABT and Binaryen allow developers to work with source files and develop tooling
    for WebAssembly. If you're interested in working with WebAssembly at a lower level,
    these tools provide the means for accomplishing such a goal. In this section,
    we'll evaluate these tools in greater detail and review the purpose and capabilities
    of each one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WABT和Binaryen允许开发人员使用源文件并开发WebAssembly工具。如果您有兴趣以更低的级别使用WebAssembly，这些工具提供了实现这一目标的手段。在本节中，我们将更详细地评估这些工具，并审查每个工具的目的和功能。
- en: WABT – the WebAssembly binary toolkit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WABT-WebAssembly二进制工具包
- en: WABT's focus is on the manipulation of WebAssembly binary (`.wasm`) files and
    text (`.wat`) files, as well as conversion between the two formats. WABT provides
    tools to translate **Wat to Wasm** (**wat2wasm**) and vice versa (**wasm2wat**),
    as well as a tool to convert a Wasm file to a C source and header file (**wasm2c**).
    You can view the entire list of tools in the README file of the WABT GitHub repository
    at [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WABT的重点是对WebAssembly二进制（.wasm）文件和文本（.wat）文件进行操作，以及在这两种格式之间进行转换。WABT提供了将Wat转换为Wasm（wat2wasm）和反之（wasm2wat）的工具，以及将Wasm文件转换为C源文件和头文件（wasm2c）的工具。您可以在WABT
    GitHub存储库的README文件中查看所有工具的完整列表[https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)。
- en: 'One example use case of WABT is the *WebAssembly Toolkit for VS Code* extension
    we installed in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. The extension depends on WABT to view the text
    format associated with a `.wasm` file. The repository provides links to wat2wasm
    and wasm2wat demos, which you can use to test the validity of a Wat program or
    interact with a compiled binary using JavaScript. The following screenshot contains
    the Wat and JavaScript instantiation code from the wat2wasm demo:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WABT的一个示例用例是我们在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)中安装的*VS Code
    WebAssembly Toolkit*扩展，*设置开发环境*。该扩展依赖于WABT来查看与.wasm文件相关联的文本格式。存储库提供了wat2wasm和wasm2wat演示的链接，您可以使用这些演示来测试Wat程序的有效性或使用JavaScript与编译后的二进制文件进行交互。以下屏幕截图包含wat2wasm演示中的Wat和JavaScript实例化代码：
- en: '![](img/0c941193-4415-400d-9085-4d78bd80a19a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c941193-4415-400d-9085-4d78bd80a19a.png)'
- en: Wat and JavaScript loading code from wat2wasm's "simple" example
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: wat2wasm的Wat和JavaScript加载代码的“simple”示例
- en: In line `3` of the JS panel, you may have noticed that the `addTwo()` function
    from `wasmInstance.exports` isn't prefixed with a `_`. Emscripten adds the `_`
    automatically in the compilation process. You could omit the `_` by converting
    the `.wasm` file to a `.wat`, updating the function names, and converting it back
    to `.wasm` using the WABT, although this wouldn't be very practical. The WABT
    simplifies the process of transforming text format to binary format and vice versa.
    If you want to build compilation tooling for WebAssembly, you'd use Binaryen,
    which we will cover next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS面板的第3行中，您可能已经注意到`wasmInstance.exports`中的`addTwo()`函数没有前缀`_`。Emscripten在编译过程中会自动添加`_`。您可以通过将.wasm文件转换为.wat文件，更新函数名称，然后使用WABT将其转换回.wasm文件来省略`_`，尽管这不太实用。WABT简化了将文本格式转换为二进制格式和反之的过程。如果您想构建WebAssembly的编译工具，您将使用Binaryen，我们将在下一节中介绍。
- en: Binaryen
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Binaryen
- en: 'Binaryen''s GitHub page at [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)
    describes Binaryen as a compiler and toolchain infrastructure library for WebAssembly,
    written in C++. It aims to make compiling to WebAssembly easy, fast, and effective.
    It achieves these aims by providing a simple C API, an internal IR, and an optimizer.
    Just as with the WABT, Binaryen provides an extensive suite of tools for developing
    WebAssembly tooling. The following list describes a subset of the tools that Binaryen
    provides:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Binaryen的GitHub页面[https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)将Binaryen描述为用C++编写的WebAssembly编译器和工具链基础库。它旨在使编译到WebAssembly变得简单、快速和有效。它通过提供简单的C
    API、内部IR和优化器来实现这些目标。与WABT一样，Binaryen提供了一套广泛的工具，用于开发WebAssembly工具。以下列表描述了Binaryen提供的一部分工具：
- en: '**wasm-shell**: Tool capable of loading and interpreting WebAssembly'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm-shell**：能够加载和解释WebAssembly'
- en: '**asm2wasm**: Compiles asm.js code to a Wasm module'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**asm2wasm**：将asm.js代码编译为Wasm模块'
- en: '**wasm2js**: Compiles a Wasm module to JavaScript'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm2js**：将Wasm模块编译为JavaScript'
- en: '**wasm-merge**: Combines multiple Wasm files into one'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm-merge**：将多个Wasm文件合并为一个'
- en: '**wasm.js**: JavaScript library that includes the Binaryen interpreter, asm2wasm,
    the Wat parser, and other Binaryen tools'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasm.js**：包括Binaryen解释器、asm2wasm、Wat解析器和其他Binaryen工具的JavaScript库'
- en: '**binaryen.js**: JavaScript library that provides a JavaScript interface for
    the Binaryen toolchain'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**binaryen.js**：提供Binaryen工具链的JavaScript接口的JavaScript库'
- en: The wasm.js and binaryen.js tools are of particular interest for JavaScript
    developers interested in building WebAssembly tooling. The `binaryen.js` library
    is available as an `npm` package ([https://www.npmjs.com/package/binaryen](https://www.npmjs.com/package/binaryen)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: wasm.js和binaryen.js工具对于对构建WebAssembly工具感兴趣的JavaScript开发人员特别有吸引力。`binaryen.js`库可作为`npm`包使用（[https://www.npmjs.com/package/binaryen](https://www.npmjs.com/package/binaryen)）。
- en: An excellent example of `binaryen.js` usage is AssemblyScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)).
    AssemblyScript is a strictly typed subset of TypeScript that generates WebAssembly
    modules. The library comes packaged with a CLI to quickly scaffold new projects
    and manage the build step. In the *Compiling with LLVM *section, we'll cover how
    to compile Wasm modules using LLVM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`binaryen.js`的一个很好的示例是AssemblyScript（[https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)）。AssemblyScript是TypeScript的严格类型子集，可生成WebAssembly模块。该库附带了一个CLI，可以快速搭建新项目并管理构建步骤。在*使用LLVM编译*部分，我们将介绍如何使用LLVM编译Wasm模块。'
- en: Compiling with LLVM
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM编译
- en: In [Chapter 1, ](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)*What is WebAssembly?*,
    we discussed the relationship between Emscripten's EMSDK and LLVM. Emscripten
    uses LLVM and Clang to compile C/C++ down to LLVM bitcode. The Emscripten compiler
    (`emcc`) compiles that bitcode to asm.js, which is passed to Binaryen to generate
    a Wasm file. If you're interested in using LLVM, you can compile C/C++ to Wasm
    without installing the EMSDK. In this section, we will review the process for
    enabling Wasm compilation using LLVM. After compiling some example C++ code to
    a Wasm file, we'll try it out in the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)中，我们讨论了Emscripten的EMSDK和LLVM之间的关系。Emscripten使用LLVM和Clang将C/C++编译为LLVM位码。Emscripten编译器（`emcc`）将该位码编译为asm.js，然后传递给Binaryen生成Wasm文件。如果您有兴趣使用LLVM，可以在不安装EMSDK的情况下将C/C++编译为Wasm。在本节中，我们将回顾使用LLVM启用Wasm编译的过程。在将一些示例C++代码编译为Wasm文件后，我们将在浏览器中尝试它。
- en: The installation process
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装过程
- en: 'If you want to compile WebAssembly modules using LLVM, several tools need to
    be installed and configured. Getting these tools working together correctly can
    be an arduous and time-consuming process. Fortunately, someone went through the
    trouble of making this process much simpler. Daniel Wirtz created an `npm` package
    named `webassembly` ([https://www.npmjs.com/package/webassembly](https://www.npmjs.com/package/webassembly))
    that can perform the following operations (with the corresponding CLI commands):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用LLVM编译WebAssembly模块，需要安装和配置多个工具。使这些工具正确配合工作可能是一个费时费力的过程。幸运的是，有人经历了这个麻烦，使这个过程变得简单得多。Daniel
    Wirtz创建了一个名为`webassembly`的`npm`包（[https://www.npmjs.com/package/webassembly](https://www.npmjs.com/package/webassembly)），可以执行以下操作（带有相应的CLI命令）：
- en: Compile C/C++ code to a WebAssembly module (`wa compile`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将C/C++代码编译为WebAssembly模块（`wa compile`）
- en: Link multiple WebAssembly modules to one (`wa link`)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个WebAssembly模块链接到一个模块（`wa link`）
- en: Decompile a WebAssembly module to text format (`wa disassemble`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WebAssembly模块反汇编为文本格式（`wa disassemble`）
- en: Assemble WebAssembly text format to a module (`wa assemble`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WebAssembly文本格式组装为模块（`wa assemble`）
- en: 'The library is using Binaryen, Clang, LLVM, and additional LLVM tools behind
    the scenes. We''ll install this package globally to ensure we have access to the
    `wa` command. To install, open a terminal instance and run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该库在后台使用Binaryen、Clang、LLVM和其他LLVM工具。我们将全局安装此包，以确保我们可以访问`wa`命令。要安装，请打开终端实例并运行以下命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It may take a few minutes to install any required dependencies. Once complete,
    run the following command to validate the installation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的依赖可能需要几分钟。完成后，运行以下命令验证安装：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see the following in terminal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到以下内容：
- en: '![](img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png)'
- en: Output of the wa command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: wa命令的输出
- en: You should be ready to start compiling Wasm modules. Let's move on to the example
    code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该准备好开始编译Wasm模块了。让我们继续进行示例代码。
- en: The example code
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: To test out the compiler, we're going to use a slightly modified version of
    the `without-glue.c` file from the *Interacting with JavaScript without glue code*
    section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. The code for this section is located in the
    `/chapter-10-advanced-tools/compile-with-llvm` directory of the `learn-webassembly`
    repository. Follow the following instructions to create the files necessary for
    the compiler test. Let's start with the C++ file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试编译器，我们将使用[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中*无需胶水代码与JavaScript交互*部分的`without-glue.c`文件的稍作修改的版本。此部分的代码位于`learn-webassembly`存储库的`/chapter-10-advanced-tools/compile-with-llvm`目录中。按照以下说明创建编译器测试所需的文件。让我们从C++文件开始。
- en: The C++ file
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++文件
- en: 'Create a new directory in your `/book-examples` directory named `/compile-with-llvm`.
    Create a new file in the `/compile-with-llvm` directory named `main.cpp` and populate
    it with the following contents:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`/book-examples`目录中创建一个名为`/compile-with-llvm`的新目录。在`/compile-with-llvm`目录中创建一个名为`main.cpp`的新文件，并填充以下内容：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code in this file is almost identical to the contents of `without-glue.c`
    from [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. The comments have been removed from the file and the imported/exported
    functions are wrapped in an `extern "C"` block. The `__attribute__((visibility("default")))`
    lines are macro statements (similar to `EMSCRIPTEN_KEEPALIVE`) that ensure the
    functions aren't removed from the compiled output during the dead-code elimination
    step. Just as with prior examples, we'll interact with the compiled Wasm module
    through an HTML file. Let's create that next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中的代码与[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中的`without-glue.c`的内容几乎相同，*创建和加载WebAssembly模块*。文件中的注释已被删除，并且导入/导出的函数被包装在`extern
    "C"`块中。`__attribute__((visibility("default")))`行是宏语句（类似于`EMSCRIPTEN_KEEPALIVE`），它们确保在死代码消除步骤期间不会从编译输出中删除这些函数。与之前的示例一样，我们将通过HTML文件与编译后的Wasm模块进行交互。让我们接下来创建这个文件。
- en: The HTML file
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML文件
- en: 'Create a file named `index.html` in the `/compile-with-llvm` directory and
    populate it with the following contents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/compile-with-llvm`目录中创建一个名为`index.html`的文件，并填充以下内容：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The contents of this file are very similar to the `without-glue.html` file from
    [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. Instead of using the `loadWasm()` function from the `/common/load-wasm.js`
    file, we're using the `WebAssembly.instantiateStreaming()` function. This allows
    us to omit an additional `<script>` element and serve the files directly from
    the `/compile-with-llvm` directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容与[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中的`without-glue.html`文件非常相似，*创建和加载WebAssembly模块*。我们不再使用`/common/load-wasm.js`文件中的`loadWasm()`函数，而是使用`WebAssembly.instantiateStreaming()`函数。这使我们可以省略一个额外的`<script>`元素，并直接从`/compile-with-llvm`目录中提供文件。
- en: The `_` is omitted from the `jsFillRect` and `jsClearRect` functions passed
    into the `importObj`. We can omit the `_` for the functions present on the `instance.exports`
    object as well. LLVM doesn't prefix any of the data/functions passed in or out
    of the module with a `_`. In the next section, we'll compile `main.cpp` and interact
    with the resultant Wasm file in the browser.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给`importObj`的`jsFillRect`和`jsClearRect`函数中省略了`_`。我们也可以在`instance.exports`对象中省略这些函数的`_`。LLVM不会在模块中传入或传出的数据/函数前缀中使用`_`。在下一节中，我们将编译`main.cpp`并在浏览器中与生成的Wasm文件交互。
- en: Compiling and running the example
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行示例
- en: 'We installed the `webassembly npm` package with the `-g` flag, so the `wa`
    command should be available in the terminal. Open a terminal instance in the `/compile-with-llvm`
    directory and run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`webassembly npm`包，并带有`-g`标志，因此终端中应该可以使用`wa`命令。在`/compile-with-llvm`目录中打开一个终端实例，并运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see a file named `main.wasm` appear in the `compile-with-llvm` folder
    of VS Code''s file explorer. To ensure the Wasm module compiled correctly, run
    the following command within the `/compile-with-llvm` directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会在VS Code的文件资源管理器中的`compile-with-llvm`文件夹中看到一个名为`main.wasm`的文件。为了确保Wasm模块编译正确，运行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中导航到`http://127.0.0.1:8080/index.html`，您应该会看到以下内容：
- en: '![](img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png)'
- en: LLVM compiled module running in the browser
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的LLVM编译模块
- en: Online tooling
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线工具
- en: The installation and configuration process for compiling WebAssembly modules
    locally is, admittedly, a little cumbersome. Fortunately, there are several online
    tools available that allow you to develop and interact with WebAssembly in the
    browser. In this section, we'll review those tools and discuss the functionality
    each one provides.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本地编译WebAssembly模块的安装和配置过程，诚然有点繁琐。幸运的是，有几种在线工具可供您在浏览器中开发和交互使用WebAssembly。在本节中，我们将回顾这些工具，并讨论它们各自提供的功能。
- en: WasmFiddle
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WasmFiddle
- en: In the *Connecting the dots with WasmFiddle* section in [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements
    of WebAssembly* *- Wat, Wasm, and the JavaScript API*, we used WasmFiddle to compile
    a simple C function to Wasm and interact with it using JavaScript. WasmFiddle
    provides a C/C++ editor, JavaScript editor, Wat/x86 viewer, and JavaScript output
    panel. You can also interact with the `<canvas>` if desired. WasmFiddle uses LLVM
    to generate the Wasm modules, which is why the imports and exports aren't prefixed
    with a `_`. You can interact with WasmFiddle at [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml)的*用WasmFiddle连接各部分*部分中，*WebAssembly的要素*
    *- Wat，Wasm和JavaScript API*，我们使用WasmFiddle将一个简单的C函数编译为Wasm，并使用JavaScript进行交互。WasmFiddle提供了C/C++编辑器，JavaScript编辑器，Wat/x86查看器和JavaScript输出面板。如果需要，还可以与`<canvas>`进行交互。WasmFiddle使用LLVM生成Wasm模块，这就是为什么导入和导出不会以`_`为前缀。您可以在[https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)上使用WasmFiddle。
- en: WebAssembly Explorer
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly Explorer
- en: 'WebAssembly Explorer, located at [https://mbebenita.github.io/WasmExplorer](https://mbebenita.github.io/WasmExplorer),
    provides similar functionality to WasmFiddle. It allows you to compile C or C++
    to a Wasm module and view the corresponding Wat. However, WebAssembly Explorer
    provides additional functionality not present in WasmFiddle. For example, you
    can compile C or C++ to Wasm and view the corresponding Firefox x86 and LLVM x86
    code. You can select from a list of code examples and specify the optimization
    level (`-O` flag in `emcc`). It also provides a button that allows you to import
    the code into WasmFiddle:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Explorer位于[https://mbebenita.github.io/WasmExplorer](https://mbebenita.github.io/WasmExplorer)，提供了与WasmFiddle类似的功能。它允许您将C或C++编译为Wasm模块，并查看相应的Wat。但是，WebAssembly
    Explorer提供了WasmFiddle中没有的额外功能。例如，您可以将C或C++编译为Wasm，并查看相应的Firefox x86和LLVM x86代码。您可以从代码示例列表中进行选择，并指定优化级别（`emcc`中的`-O`标志）。它还提供了一个按钮，允许您将代码导入到WasmFiddle中：
- en: '![](img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png)'
- en: Screenshot of WebAssembly Explorer
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Explorer的屏幕截图
- en: WebAssembly Studio
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly Studio
- en: 'WebAssembly Studio, located at [https://webassembly.studio](https://webassembly.studio),
    is a feature-rich editor and development environment. You can create C, Rust,
    and AssemblyScript projects. It provides the capabilities to build and run code
    within the browser and integrates well with GitHub. WebAssembly Studio enables
    you to build a web application without having to install and configure the required
    WebAssembly tooling locally:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 位于[https://webassembly.studio](https://webassembly.studio)的WebAssembly Studio是一个功能丰富的编辑器和开发环境。您可以创建C、Rust和AssemblyScript项目。它提供了在浏览器中构建和运行代码的能力，并与GitHub很好地集成。WebAssembly
    Studio使您能够构建Web应用程序，而无需在本地安装和配置所需的WebAssembly工具：
- en: '![](img/586895b5-ace5-4179-9423-bae1c39361ce.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/586895b5-ace5-4179-9423-bae1c39361ce.png)'
- en: Screenshot of WebAssembly Studio
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly Studio的屏幕截图
- en: In the next section, we'll demonstrate how to add parallelism to your WebAssembly
    application with Web Workers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用Web Workers为您的WebAssembly应用程序添加并行性。
- en: Parallel Wasm with Web Workers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web Workers实现并行Wasm
- en: The process of building a complex application that performs heavy computation
    or other resource-intensive work can benefit greatly from using **threads**. Threads
    allow you to perform operations in parallel by dividing functionality among tasks
    that run independently. At of writing this, support for threads in WebAssembly
    is in the *Feature Proposal* phase. In this phase, the specification hasn't been
    written and the feature isn't implemented. Fortunately, JavaScript provides threading
    capabilities in the form of Web Workers. In this section, we'll demonstrate how
    to use JavaScript's Web Workers API to interact with Wasm modules in separate
    threads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建执行大量计算或其他资源密集型工作的复杂应用程序的过程可以从使用**线程**中受益。线程允许您通过将功能分配给独立运行的任务来并行执行操作。在撰写本文时，WebAssembly中的线程支持处于*功能提案*阶段。在此阶段，规范尚未编写，功能尚未实现。幸运的是，JavaScript提供了Web
    Workers形式的线程功能。在本节中，我们将演示如何使用JavaScript的Web Workers API与单独的线程中的Wasm模块进行交互。
- en: Web Workers and WebAssembly
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers和WebAssembly
- en: Web Workers allow you to utilize threads in the browser, which can improve the
    performance of your application by offloading some of the logic from the main
    (UI) thread. Worker threads are also capable of performing I/O using `XMLHttpRequest`.
    Worker threads communicate with the main thread by posting messages to an event
    handler.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers允许您在浏览器中利用线程，可以通过将一些逻辑从主（UI）线程中卸载来提高应用程序的性能。工作线程还能够使用`XMLHttpRequest`执行I/O操作。工作线程通过将消息发布到事件处理程序与主线程通信。
- en: Web Workers allow us to load Wasm modules into separate threads and perform
    operations that don't hinder the performance of the UI. Web Workers do have some
    limitations. They're unable to directly manipulate the DOM or access some of the
    methods and properties on the `window` object. The messages passed between threads
    must be serialized objects, which means you can't pass functions. Now that you
    know what a worker is, let's discuss how to create one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers允许我们将Wasm模块加载到单独的线程中，并执行不会影响UI性能的操作。Web Workers确实有一些限制。它们无法直接操作DOM或访问`window`对象上的某些方法和属性。线程之间传递的消息必须是序列化对象，这意味着你不能传递函数。现在你知道了worker是什么，让我们讨论如何创建一个。
- en: Creating a worker
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个工作线程
- en: Before you can create a worker, you need a JavaScript file with code that runs
    in the worker thread. You can see a simple example of a worker definition file
    at [https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js](https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js).
    The file should contain a `message` event listener that performs operations when
    messages are received from other threads and responds accordingly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建工作线程之前，您需要一个包含在工作线程中运行的代码的JavaScript文件。您可以在[https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js](https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js)上看到一个简单的工作定义文件的示例。该文件应包含一个`message`事件侦听器，当从其他线程接收到消息时执行操作并做出相应响应。
- en: Once that file is created, you're ready to use it with a worker. A worker is
    created by passing a URL argument to the `Worker()` constructor. The URL can be
    a string representing the name of the file with your worker definition code, or
    constructed using a `Blob`. The `Blob` technique can be useful if you're fetching
    the worker definition code from a server. The example application demonstrates
    how to use both approaches. Let's move on to the process of integrating WebAssembly
    with Web Workers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了该文件后，您就可以使用它来创建一个工作线程。通过将URL参数传递给`Worker()`构造函数来创建工作线程。URL可以是表示包含工作定义代码的文件名称的字符串，也可以使用`Blob`构造。如果您从服务器获取工作定义代码，则`Blob`技术可能很有用。示例应用程序演示了如何同时使用这两种方法。让我们继续介绍如何将WebAssembly与Web
    Workers集成的过程。
- en: The WebAssembly workflow
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly工作流程
- en: 'In order to utilize Wasm modules in separate threads, the Wasm file must be
    compiled in the main thread and instantiated in a Web Worker. Let''s review this
    process in more detail:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单独的线程中利用Wasm模块，必须在主线程中编译Wasm文件，并在Web Worker中实例化。让我们更详细地审查这个过程：
- en: A new Web Worker (we'll refer to it as `wasmWorker`) is created using the `Worker()`
    constructor.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Worker()`构造函数创建了一个新的Web Worker（我们将其称为`wasmWorker`）。
- en: A fetch call is made to retrieve a `.wasm` file and the `arrayBuffer()` function
    is called on the response.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出fetch调用以检索`.wasm`文件，并在响应上调用`arrayBuffer()`函数。
- en: The resolved value of the `arrayBuffer()` function is passed to the `WebAssembly.compile()`
    function.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`arrayBuffer()`函数的解析值传递给`WebAssembly.compile()`函数。'
- en: The `WebAssembly.compile()` function resolves with a `WebAssembly.Module` instance,
    which is included in the body of a message posted to the `wasmWorker` using the
    `postMessage()` function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebAssembly.compile()`函数解析为`WebAssembly.Module`实例，并使用`postMessage()`函数将其包含在发送到`wasmWorker`的消息体中。'
- en: Within `wasmWorker`, the `WebAssembly.Module` instance from the message body
    is passed to the `WebAssembly.instantiate()` function, which resolves with a `WebAssembly.Instance`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wasmWorker`中，从消息体中传递给`WebAssembly.instantiate()`函数的`WebAssembly.Module`实例，将解析为一个`WebAssembly.Instance`。
- en: The `WebAssembly.Instance` exports object is assigned to a local variable in
    `wasmWorker` and is used to call Wasm functions.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance`导出对象被分配给`wasmWorker`中的一个本地变量，并用于调用Wasm函数。'
- en: To call a function from the `wasmWorker` Wasm instance, you post a message to
    the worker thread with any arguments to pass to the Wasm function. Then, `wasmWorker`
    executes the function and passes the results back to the main thread. That's the
    crux of how threads are utilized in the context of Web Workers. Before we move
    on to the example application, you may need to address a limitation that Google
    Chrome imposes. Follow the instructions in the *Limitations in Google Chrome *section
    to ensure the example application works successfully.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`wasmWorker`的Wasm实例中调用函数，你需要向工作线程发送一个消息，其中包含要传递给Wasm函数的任何参数。然后，`wasmWorker`执行该函数，并将结果传递回主线程。这就是在Web
    Workers的上下文中如何利用线程的关键。在我们继续进行示例应用程序之前，你可能需要解决谷歌Chrome施加的一个限制。请按照“谷歌Chrome中的限制”部分中的说明，确保示例应用程序能够成功运行。
- en: Limitations in Google Chrome
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌Chrome中的限制
- en: 'Google Chrome places a restriction on what can be included in the body of a
    Web Worker''s `postMessage()` function. If you tried to send a compiled `WebAssembly.Module`
    to a worker, you''d get an error and the operation would be unsuccessful. You
    can override this by setting a flag. To enable this functionality, open Google
    Chrome and enter `chrome://flags` in the address bar. Type `cloning` in the search
    box at the top of the page. You should see a list item titled WebAssembly structured
    cloning support. Select the Enabled option from the dropdown next to the list
    item and press the RELAUNCH NOW button when prompted:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌Chrome对Web Worker的`postMessage()`函数的主体中可以包含什么施加了限制。如果你尝试将编译后的`WebAssembly.Module`发送到工作线程，你将收到错误消息，并且操作将不成功。你可以通过设置一个标志来覆盖这一限制。要启用此功能，请打开谷歌Chrome，并在地址栏中输入`chrome://flags`。在页面顶部的搜索框中输入`cloning`。你应该看到一个名为WebAssembly
    structured cloning support的列表项。从下拉菜单中选择Enabled选项，并在提示时点击RELAUNCH NOW按钮：
- en: '![](img/077e795e-460d-413b-b6f4-cf82e5e797b0.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/077e795e-460d-413b-b6f4-cf82e5e797b0.png)'
- en: Updating the WebAssembly flag in Google Chrome
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌Chrome中更新WebAssembly标志
- en: After Chrome restarts, you can run the example application without issue. If
    you're using Mozilla Firefox, no action is required. It supports this feature
    by default. Let's move on to the example application that demonstrates the use
    of WebAssembly in threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome重新启动后，你可以无问题地运行示例应用程序。如果你使用Mozilla Firefox，则无需任何操作。它默认支持此功能。让我们继续进行示例应用程序，演示在线程中使用WebAssembly的用法。
- en: Overview of the code
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码概述
- en: The example application isn't much of an application. It's a simple form that
    accepts two input values and returns the sum or difference of these two values.
    The add and subtract operations are each exported from their own Wasm module instantiated
    in a worker thread. The example may be contrived, but it effectively demonstrates
    how to integrate WebAssembly into Web Workers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序并不是一个真正的应用程序。它是一个简单的表单，接受两个输入值，并返回这两个值的和或差。加法和减法操作分别从它们自己的Wasm模块中导出，并在工作线程中实例化。这个示例可能是刻意构造的，但它有效地演示了如何将WebAssembly集成到Web
    Workers中。
- en: The code for this section is located in the `/chapter-10-advanced-tools/parallel-wasm`
    directory of the `learn-webassembly` repository. The following sections walk through
    each section of the code base and describe how to build the application from scratch.
    If you wish to follow along, create a folder in your `/book-examples` directory
    named `/parallel-wasm`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的代码位于`learn-webassembly`存储库的`/chapter-10-advanced-tools/parallel-wasm`目录中。接下来的部分将逐步介绍代码库的每个部分，并描述如何从头开始构建应用程序。如果你想跟着做，可以在你的`/book-examples`目录中创建一个名为`/parallel-wasm`的文件夹。
- en: The C code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C代码
- en: 'The example uses two worker threads: one for addition and another for subtraction.
    Consequently, we''ll need two separate Wasm modules. Create a folder named `/lib`
    in your `/parallel-wasm` directory. Within the `/lib` directory, create a file
    named `add.c` and populate it with the following contents:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用了两个工作线程：一个用于加法，另一个用于减法。因此，我们需要两个单独的Wasm模块。在你的`/parallel-wasm`目录中创建一个名为`/lib`的文件夹。在`/lib`目录中，创建一个名为`add.c`的文件，并填充以下内容：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create another file in `/lib` named `subtract.c` and populate it with the following
    contents:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/lib`中创建另一个名为`subtract.c`的文件，并填充以下内容：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the function name in both files is `calculate`. This was done so we
    don't have to write any conditional logic within the worker code to determine
    the Wasm function to call. The algebraic operation is tied to a worker, so when
    we need to add two numbers, the `_calculate()` function will be called in the
    `addWorker`. This will become clearer when we review the JavaScript portion of
    the code, which we'll cover next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个文件中的函数名都是`calculate`。这样做是为了避免在工作代码中编写任何条件逻辑来确定要调用的Wasm函数。代数运算与工作线程相关联，因此当我们需要加两个数字时，将在`addWorker`中调用`_calculate()`函数。当我们查看代码的JavaScript部分时，这将变得更清晰。
- en: The JavaScript code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript代码
- en: Before we dig into the JavaScript code, create a folder named `/src` in your
    `/parallel-wasm` directory. Let's start with the file containing the code that
    runs in the worker thread.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究JavaScript代码之前，在你的`/parallel-wasm`目录中创建一个名为`/src`的文件夹。让我们从包含在工作线程中运行的代码的文件开始。
- en: Defining thread execution in worker.js
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在worker.js中定义线程执行
- en: 'Create a new file in the `/src` directory named `worker.js` and populate it
    with the following contents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/src`目录中创建一个名为`worker.js`的新文件，并填充以下内容：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is encapsulated within the event listener for the `message` event (`self.addEventListener(...)`),
    which is raised when the `postMessage()` function is called on the corresponding
    worker. The `event` parameter in the event listener's callback function contains
    a `data` property with the contents of the message. All of the messages passed
    between threads in the application follow the **Flux Standard Action** (**FSA**)
    convention. Objects that adhere to this convention have a `type` and `payload`
    property, where `type` is a string and `payload` can be of any type. You can read
    more about the FSA at [https://github.com/redux-utilities/flux-standard-action](https://github.com/redux-utilities/flux-standard-action).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码封装在`message`事件的事件监听器中（`self.addEventListener(...)`），当对应的worker上调用`postMessage()`函数时会触发该事件。事件监听器的回调函数中的`event`参数包含一个`data`属性，其中包含消息的内容。应用程序中线程之间传递的所有消息都遵循**Flux
    Standard Action**（**FSA**）约定。遵循此约定的对象具有`type`和`payload`属性，其中`type`是一个字符串，`payload`可以是任何类型。您可以在[https://github.com/redux-utilities/flux-standard-action](https://github.com/redux-utilities/flux-standard-action)上了解更多关于FSA的信息。
- en: You can use any format or structure for the data you pass using the `postMessage()`
    function, as long as the data is serializable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`postMessage()`函数传递的数据的任何格式或结构，只要数据是可序列化的。
- en: The `switch` statement executes an action based on the message's `type` value,
    which is a string. If the `type` is `'COMPILE_WASM_REQUEST'`, the `WebAssembly.instantiate()`
    function is called with the `payload` from the message and `importObj`. The `exports`
    object of the result is assigned to the local `wasmInstance` variable for later
    use. If the `type` is `'CALC_REQUEST'`, the `wasmInstance._calculate()` function
    is called with the `firstVal` and `secondVal` values from the `payload` object.
    The calculation code should shed some light on why the function was named `_calculate()`
    instead of `_add()` or `_subtract()`. By using a general name, the worker doesn't
    care what operation it's performing, it just calls the function to get the result.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句根据消息的`type`值执行操作，该值是一个字符串。如果`type`是`''COMPILE_WASM_REQUEST''`，则调用`WebAssembly.instantiate()`函数，传入消息的`payload`和`importObj`。结果的`exports`对象分配给本地的`wasmInstance`变量以供以后使用。如果`type`是`''CALC_REQUEST''`，则使用`payload`对象中的`firstVal`和`secondVal`值调用`wasmInstance._calculate()`函数。计算代码应该解释为什么函数被命名为`_calculate()`而不是`_add()`或`_subtract()`。通过使用一个通用名称，工作线程不关心它执行的是什么操作，它只是调用函数以获得结果。'
- en: In both cases, the worker posts a message back to the main thread using the
    `postMessage()` function. I used a `REQUEST`/`RESPONSE` convention for the `type`
    property value. This allows you to quickly identify which thread the messages
    are originating from. Messages sent from the main thread end with `_REQUEST` in
    the `type` while responses coming from the worker threads end with `_RESPONSE`.
    Let's move on to the WebAssembly interaction code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，工作线程都使用`postMessage()`函数向主线程发送消息。我使用了`REQUEST`/`RESPONSE`约定来表示`type`属性的值。这使您可以快速识别消息的来源线程。从主线程发送的消息以`_REQUEST`结尾，而来自工作线程的响应以`_RESPONSE`结尾。让我们继续进行WebAssembly交互代码。
- en: Interacting with Wasm in WasmWorker.js
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WasmWorker.js中与Wasm交互
- en: 'Create a new file in the `/src` directory named `WasmWorker.js` and populate
    it with the following contents:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/src`目录中创建一个名为`WasmWorker.js`的新文件，并填充以下内容：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `WasmWorker` class manages a worker thread associated with a Wasm file.
    In the `WasmWorker` constructor, a new `Worker` is created and default event listeners
    are added for the `error` and `message` events. The `initialize()` function fetches
    the `.wasm` file associated with the `name` argument, compiles it, and sends the
    resultant `WebAssembly.Module` instance to the worker thread to be instantiated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WasmWorker`类管理与Wasm文件关联的工作线程。在`WasmWorker`构造函数中，创建一个新的`Worker`，并为`error`和`message`事件添加了默认的事件监听器。`initialize()`函数获取与`name`参数关联的`.wasm`文件，编译它，并将结果的`WebAssembly.Module`实例发送到工作线程以进行实例化。'
- en: The `addListenerForType()` function is used to specify a `callback` function
    (`listener`) to execute when the `type` field in the message response matches
    the `type` argument passed to the function. This is required to capture the result
    of the `_calculate()` function from the worker thread.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`addListenerForType()`函数用于指定一个`callback`函数（`listener`），当消息响应中的`type`字段与传递给函数的`type`参数匹配时执行。这是为了捕获来自工作线程的`_calculate()`函数的结果。'
- en: Finally, the `calculate()` function in `WasmWorker` posts a message to the worker
    thread with the `firstVal` and `secondVal` arguments passed in from the `<input>`
    elements on the `<form>`. Let's move on to the application loading code to see
    how `WasmWorker` interacts with the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`WasmWorker`中的`calculate()`函数向工作线程发送一条消息，消息中包括从`<form>`中的`<input>`元素传入的`firstVal`和`secondVal`参数。让我们继续看应用加载代码，以了解`WasmWorker`如何与UI交互。
- en: Loading the application in index.js
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在index.js中加载应用程序
- en: 'Create a new file in the `/src` directory named `index.js` and populate it
    with the following contents:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/src`目录中创建一个名为`index.js`的新文件，并填充以下内容：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The application entry point is the `loadPage()` function. Before we dig into
    the worker initialization code, let''s discuss the `getWorkerUrl()` function.
    Earlier in this section, we learned that you can pass a string representing a
    filename or a URL created from a `Blob` to the `Worker()` constructor. The following
    example code demonstrates the first technique:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点是`loadPage()`函数。在我们深入讨论工作线程初始化代码之前，让我们讨论一下`getWorkerUrl()`函数。在本节的前面，我们了解到可以将表示文件名的字符串或从`Blob`创建的URL传递给`Worker()`构造函数。以下示例代码演示了第一种技术：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second technique is demonstrated in the `if (isBlob === 'true')` block of
    the `getWorkerUrl()` function. If the current `window.location` value ends with
    `?blob=true`, the URL passed to the `Worker()` constructor is created from a `Blob`.
    The only noticeable difference is the `document.title` value, which updates to
    reflect the URL type. Let's jump back to the `loadPage()` function to discuss
    the initialization code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术在`getWorkerUrl()`函数的`if (isBlob === 'true')`块中进行演示。如果当前的`window.location`值以`?blob=true`结尾，那么传递给`Worker()`构造函数的URL将从`Blob`创建。唯一显着的区别是`document.title`的值，它会更新以反映URL类型。让我们回到`loadPage()`函数，讨论初始化代码。
- en: 'After an event listener is added to the Reset button in the `loadPage()` function,
    two `WasmWorker` instances are created: `addWorker` and `subtractWorker`. Each
    worker is passed to the `initializeWorker()` function as the `wasmWorker` argument.
    In `initializeWorker()`, the `wasmWorker.initialize()` function is called to instantiate
    the Wasm module. The `wasmWorker.addListenerForType()` function is called to set
    the value of the Result `<input>` to the value returned from the `_calculate()`
    function in the corresponding worker. Finally, an event listener is added to the
    `click` event of the `<button>` that either adds or subtracts the `firstVal` and
    `secondVal` `<input>` values (based on the `name` argument). That''s it for the
    JavaScript code. Let''s create an HTML and CSS file, then move on to the build
    step.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadPage()`函数中为重置按钮添加事件侦听器后，创建了两个`WasmWorker`实例：`addWorker`和`subtractWorker`。每个worker都作为`wasmWorker`参数传递给`initializeWorker()`函数。在`initializeWorker()`中，调用`wasmWorker.initialize()`函数来实例化Wasm模块。调用`wasmWorker.addListenerForType()`函数来将Result
    `<input>`的值设置为对应worker中`_calculate()`函数返回的值。最后，为`<button>`的`click`事件添加了一个事件侦听器，该事件要么将`firstVal`和`secondVal`
    `<input>`值相加，要么相减（基于`name`参数）。这就是JavaScript代码的全部内容。让我们创建一个HTML和CSS文件，然后继续进行构建步骤。
- en: The web assets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web资产
- en: 'We need an HTML file to act as the entry point to the application. Create a
    file in the `/src` directory named `index.html` and populate it with the following
    contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个HTML文件作为应用程序的入口点。在`/src`目录中创建一个名为`index.html`的文件，并填充以下内容：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The application consists of a `<form>` with three `<input>` elements and a block
    of three `<button>` elements. The first two `<input>` elements correspond to the
    `firstVal` and `secondVal` properties included in the `payload` sent to either
    worker thread. The final `<input>` is read-only and displays the result of either
    operation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序由一个带有三个`<input>`元素和一个包含三个`<button>`元素的块组成。前两个`<input>`元素对应于`payload`中包含的`firstVal`和`secondVal`属性，这些属性发送到任一工作线程。最后一个`<input>`是只读的，并显示任一操作的结果。
- en: The block of `<button>` elements below the `<form>` perform operations on the
    `<input>` values. The first two `<button>` elements send the `<input>` values
    to either the `addWorker` or `subtractWorker` thread (depending on which button
    was pressed). The final `<button>` sets all of the `<input>` values to `0`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<form>`下面的一组`<button>`元素对`<input>`值执行操作。前两个`<button>`元素将`<input>`值发送到`addWorker`或`subtractWorker`线程（取决于按下哪个按钮）。最后一个`<button>`将所有`<input>`值设置为`0`。
- en: 'The application is initialized in the `<script>` tag in the last line before
    the `</body>` closing tag. Just as with Cook the Books, the `type="module"` attribute
    allows us to use the `import`/`export` syntax available in newer browsers. Finally,
    we need to add some styles to the application. Create a file in the `/src` directory
    named `styles.css` and populate it with the following contents:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在`</body>`结束标记之前的最后一行的`<script>`标记中初始化。与Cook the Books一样，`type="module"`属性允许我们在较新的浏览器中使用`import`/`export`语法。最后，我们需要为应用程序添加一些样式。在`/src`目录中创建一个名为`styles.css`的文件，并填充以下内容：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's the last file we need to create, but not the last one required to run
    the application. We still need to generate Wasm files from the C files in the
    `/lib` directory. Let's move on to the build step.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要创建的最后一个文件，但不是运行应用程序所需的最后一个文件。我们仍然需要从`/lib`目录中的C文件生成Wasm文件。让我们继续进行构建步骤。
- en: Building and running the application
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: With the code written, it's time to build and test the application. After completing
    the build step, we'll interact with the running application and review how to
    troubleshoot Web Workers using the browser's development tools.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编写完成后，现在是时候构建和测试应用程序了。完成构建步骤后，我们将与正在运行的应用程序进行交互，并回顾如何使用浏览器的开发工具来排除Web Workers的故障。
- en: Compiling the C files
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译C文件
- en: 'We need to compile each C file to a separate `.wasm` file, which means the
    command needed to perform the compilation step is verbose. To perform the build,
    open a terminal instance in your `/parallel-wasm` directory and run the following
    commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个C文件编译为单独的`.wasm`文件，这意味着执行编译步骤所需的命令是冗长的。要执行构建，请在`/parallel-wasm`目录中打开一个终端实例，并运行以下命令：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see two new files in the `/src` directory: `calc-add.wasm` and `calc-subtract.wasm`.
    With the required files in place, it''s time to test out the application.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`/src`目录中看到两个新文件：`calc-add.wasm`和`calc-subtract.wasm`。有了所需的文件，现在是时候测试应用程序了。
- en: Interacting with the application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与应用程序交互
- en: 'Open a terminal instance in the `/parallel-wasm` directory and run the following
    command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/parallel-wasm`目录中打开一个终端实例，并运行以下命令：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在浏览器中导航到`http://127.0.0.1:8080/index.html`，您应该会看到这个：
- en: '![](img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png)'
- en: ￼Wasm Workers application running in the browser
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的Wasm Workers应用程序
- en: 'Try changing the values in the First Value and Second Value inputs and pressing
    the Add and Subtract buttons. The Result input should update with the calculated
    result. If you navigate to `http://127.0.0.1:8080/index.html?blob=true`, the URL
    argument passed to the `Worker()` constructor will use a `Blob` instead of the
    filename. The tab should change to reflect that the `Blob` technique is used to
    construct the URL:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改第一个值和第二个值输入中的值，然后按“添加”和“减去”按钮。结果输入应该更新为计算结果。如果您导航到`http://127.0.0.1:8080/index.html?blob=true`，传递给`Worker()`构造函数的URL参数将使用`Blob`而不是文件名。选项卡应更改以反映使用`Blob`技术来构造URL：
- en: '![](img/06832741-0c1c-40a3-9b02-e6694db0942c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06832741-0c1c-40a3-9b02-e6694db0942c.png)'
- en: Tab title updated to reflect the Blob URL technique
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡标题已更新以反映Blob URL技术
- en: Debugging Web Workers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Web Workers
- en: 'You can set breakpoints and interact with worker threads using the browser''s
    development tools. In Google Chrome, open Developer Tools and select the Sources
    tab. The file list panel should contain two instances of `worker.js`. The debugger
    panel contains a Threads section with the `main` thread and two `worker.js` threads.
    The following screenshot indicates the thread debugging elements within the Chrome
    Developer Tools panel for the running application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用浏览器的开发工具设置断点并与工作线程进行交互。在Google Chrome中，打开开发者工具并选择“源”选项卡。文件列表面板应包含两个`worker.js`实例。调试器面板包含一个“线程”部分，其中包含“主”线程和两个“worker.js”线程。以下屏幕截图显示了Chrome开发者工具面板中用于运行应用程序的线程调试元素：
- en: '![](img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png)'
- en: Thread debugging tools in the Chrome Developer Tools panel
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具面板中的线程调试工具
- en: 'In Firefox, worker debugging is done in separate Developer Tools windows. To
    see this in action, open Developer Tools in Firefox and select the Debugger panel.
    Click on one of the `worker.js` list items in the Workers panel. A new Developer
    Tools window should appear that corresponds with the selected worker. The following
    screenshot shows a separate Developer Tools window for one of the `worker.js`
    instances selected from the Workers panel:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，worker调试是在单独的开发者工具窗口中完成的。要查看此操作，请在Firefox中打开开发者工具，并选择调试器面板。单击Workers面板中的`worker.js`列表项之一。应该会出现一个新的开发者工具窗口，对应于所选的worker。以下屏幕截图显示了从Workers面板中选择的`worker.js`实例的单独开发者工具窗口：
- en: '![](img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png)'
- en: Thread debugging tools in the Firefox Developer Tools panel
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox开发者工具面板中的线程调试工具
- en: In the next section, we'll discuss some of the upcoming features of WebAssembly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些即将推出的WebAssembly功能。
- en: Upcoming features
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将推出的功能
- en: There are several upcoming WebAssembly features in various phases of the standardization
    process. Some of them are more impactful than others, but all of them are valuable
    improvements. In this section, we'll describe the standardization process and
    review a subset of the features that represent a significant shift in WebAssembly's
    capabilities. Most of the content in this section was referenced from Colin Eberhardt's
    blog post titled *The future of WebAssembly - A look at upcoming features and
    proposals*. The post can be found at [https://blog.scottlogic.com/2018/07/20/wasm-future.html](https://blog.scottlogic.com/2018/07/20/wasm-future.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个即将推出的WebAssembly功能处于标准化过程的各个阶段。其中一些比其他功能更具影响力，但它们都是有价值的改进。在本节中，我们将描述标准化过程，并审查代表WebAssembly能力显著转变的一些功能的子集。本节大部分内容引用自Colin
    Eberhardt的博客文章，标题为*WebAssembly的未来-即将推出的功能和提案*。该文章可以在[https://blog.scottlogic.com/2018/07/20/wasm-future.html](https://blog.scottlogic.com/2018/07/20/wasm-future.html)找到。
- en: The standardization process
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化过程
- en: 'The WebAssembly W3C Process documentation at [https://github.com/WebAssembly/meetings/blob/master/process/phases.md](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)
    describes the six phases (from 0 to 5) of the standardization process. The following
    list provides brief descriptions of each of these phases:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly W3C流程文档位于[https://github.com/WebAssembly/meetings/blob/master/process/phases.md](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)，描述了标准化过程的六个阶段（从0到5）。以下列表提供了对每个阶段的简要描述：
- en: '**Phase 0\. Pre-Proposal**: A WebAssembly **Community Group** (**CG**) member
    has an idea, and the CG votes on whether to move it to Phase 1.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第0阶段。预提案**：WebAssembly**社区组**（**CG**）成员有一个想法，并且CG投票决定是否将其移至第1阶段。'
- en: '**Phase 1\. Feature Proposal**: The pre-proposal process has succeeded and
    a repository is created in the WebAssembly organization on GitHub to document
    the feature.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1阶段。功能提案**：预提案过程已成功，并在GitHub的WebAssembly组织中创建了一个存储库以记录该功能。'
- en: '**Phase 2\. Proposed Spec Text Available**: The full proposed spec text is
    available, possible implementations are prototyped, and a test suite is added.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2阶段。提议的规范文本可用**：完整的提议规范文本可用，可能的实现已经原型化，并添加了测试套件。'
- en: '**Phase 3\. Implementation Phase**: Embedders implement the feature, the repository
    is updated to include revisions to the formalization, and the spec is updated
    to include implementation of the feature in the reference interpreter.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3阶段。实施阶段**：嵌入器实施该功能，存储库已更新以包括对规范的修订，并且规范已更新以包括对参考解释器中功能的实施。'
- en: '**Phase 4\. Standardize the Feature**: If two or more Web VMs and at least
    one toolchain implement the feature, the feature is fully handed off to the WebAssembly
    **Working Group** (**WG**).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4阶段。标准化功能**：如果两个或两个以上的Web VM和至少一个工具链实现了该功能，则该功能将完全移交给WebAssembly**工作组**（**WG**）。'
- en: '**Phase 5\. The Feature is Standardized**: The WG members have reached consensus
    that the feature is complete.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5阶段。功能已标准化**：WG成员已达成共识，该功能已完成。'
- en: Now that you're familiar with the phases associated with the standardization
    process, let's move on to the threads proposal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了与标准化过程相关的阶段，让我们继续讨论线程提案。
- en: Threads
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: In the previous section, we used Web Workers to move Wasm modules into worker
    threads, which allowed us to call Wasm functions without blocking the main thread.
    However, passing messages between worker threads has performance limitations.
    In an effort to address this issue, a threads feature was proposed for WebAssembly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用Web Workers将Wasm模块移动到工作线程中，这样我们就可以调用Wasm函数而不会阻塞主线程。然而，在工作线程之间传递消息存在性能限制。为了解决这个问题，提出了一个WebAssembly的线程功能。
- en: 'The proposal, currently in Phase 1, is described in detail at [https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md).
    Per the proposal documentation, the threads feature adds a new shared linear memory
    type and some new operations for atomic memory access. This proposal is relatively
    limited in scope. Eberhardt provides the following elaboration in his blog post:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该提案目前处于第一阶段，详细描述在[https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md)。根据提案文件，线程功能添加了一个新的共享线性内存类型和一些新的原子内存访问操作。这个提案在范围上相对有限。Eberhardt在他的博客文章中提供了以下阐述：
- en: '"Notably, this proposal does not introduce a mechanism for creating threads
    (which has caused a lot of debate) instead this functionality is supplied by the
    host. Within the context of wasm executed by the browser this will be the familiar
    WebWorkers."'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “值得注意的是，这个提案并没有引入创建线程的机制（这引起了很多争论），而是由主机提供这个功能。在浏览器中执行的wasm的上下文中，这将是熟悉的WebWorkers。”
- en: Although the feature wouldn't allow for the creation of threads, it provides
    a simpler way of sharing data between the worker threads we create in JavaScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个功能不允许创建线程，但它提供了一种更简单的方法来在JavaScript中创建的工作线程之间共享数据。
- en: Host bindings
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机绑定
- en: 'The host bindings proposal, which is also in Phase 1, would address a significant
    limitation of WebAssembly when used in the browser: DOM manipulation. The proposal
    documentation at [https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md)
    provides the following list of goals for this feature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 主机绑定提案，也处于第一阶段，将解决WebAssembly在浏览器中使用时的一个重要限制：DOM操作。该提案文件在[https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md)中提供了该功能的以下目标列表：
- en: '**Ergonomics**: Allow WebAssembly modules to create, pass around, call, and
    manipulate JavaScript + DOM objects'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人机工程学**：允许WebAssembly模块创建、传递、调用和操作JavaScript + DOM对象'
- en: '**Speed**: Allow JS/DOM or other host calls to be well optimized'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：允许JS/DOM或其他主机调用进行优化'
- en: '**Platform consistency**: Allow WebIDL to be used to annotate Wasm imports/exports
    (via a tool)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台一致性**：允许使用WebIDL来注释Wasm的导入/导出（通过工具）'
- en: '**Incrementalism**: Provide a strategy that is polyfillable'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式**：提供一种可填充的策略'
- en: Improving WebAssembly's interoperability with JavaScript and Web APIs would
    simplify the development process considerably. It would also eliminate the need
    for the "glue" code that tools such as Emscripten provide.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 改进WebAssembly与JavaScript和Web API的互操作性将大大简化开发过程。它还将消除诸如Emscripten等工具提供的“胶水”代码的需求。
- en: Garbage collection
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: 'The **garbage collection** (**GC**) proposal is currently in Phase 1\. We discussed
    garbage collection in the *What are the Limitations?* section of [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What
    is WebAssembly?* The proposal documentation at [https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md)
    provides an extensive overview of the feature and describes the elements that
    need to be added to the specification. Eberhardt provides the following description
    of the proposal in his blog post:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾回收**（**GC**）提案目前处于第一阶段。我们在[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)的*WebAssembly是什么？*部分讨论了垃圾回收。提案文件在[https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md)中提供了该功能的广泛概述，并描述了需要添加到规范中的元素。Eberhardt在他的博客文章中对提案进行了以下描述：'
- en: '"This proposal adds GC capabilities to WebAssembly. Interestingly, it will
    not have its own GC, instead it will integrate with the GC provided by the host
    environment. This makes a lot of sense as this, and various other proposals (host
    bindings, reference types), are designed to improve the interop with the host,
    making it easier to share state and call APIs. Having a single GC to manage memory
    makes this much easier."'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “这个提案为WebAssembly添加了GC功能。有趣的是，它不会有自己的GC，而是将与主机环境提供的GC集成。这是有道理的，因为这个提案和其他各种提案（主机绑定，引用类型）旨在改进与主机的互操作性，使共享状态和调用API变得更容易。拥有一个单一的GC来管理内存会使这一切变得更容易。”
- en: 'This feature will require a great deal of effort to implement, but adding it
    to WebAssembly will be worth the effort. Let''s wrap up this section with a feature
    currently in the implementation phase: reference types.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能将需要大量的工作来实现，但将其添加到WebAssembly中将是值得的。让我们用一个当前正在实施阶段的功能来结束这一节：引用类型。
- en: Reference types
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Reference types, currently in Phase 3, form the basis for the host bindings
    and GC features. The proposal documentation at [https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)
    describes the addition of a new type, `anyref`, which can be used as both a value
    type and a table element type. The `anyref` type allows you to pass a JavaScript
    object to a Wasm module. Eberhardt describes the implications of this feature
    in his blog post:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型，目前处于第三阶段，构成了主机绑定和GC功能的基础。提案文档位于[https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)，描述了添加一个新类型`anyref`，它可以作为值类型和表元素类型使用。`anyref`类型允许您将JavaScript对象传递给Wasm模块。Eberhardt在他的博客文章中描述了这一功能的影响：
- en: '"The wasm module can''t really do much with the object via the anyref type.
    What''s more important is that the module is holding a reference to a garbage
    collected object on the JS heap, meaning they need to be traced during wasm execution.
    This proposal is seen as a stepping-stone towards the more significant garbage
    collection proposal."'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “通过anyref类型，wasm模块实际上无法对对象执行太多操作。更重要的是，模块持有对JS堆中的垃圾收集对象的引用，这意味着它们在wasm执行期间需要被跟踪。这个提案被视为通往更重要的垃圾收集提案的一个垫脚石。”
- en: There are several other exciting features in the pipeline for WebAssembly. The
    WebAssembly CG and WG are devoting their time and resources to making these features
    a reality. You can view all of the proposals at the WebAssembly organization page
    on GitHub, located at [https://github.com/WebAssembly](https://github.com/WebAssembly).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly还有其他一些令人兴奋的功能正在开发中。WebAssembly CG和WG正在投入他们的时间和资源，使这些功能成为现实。您可以在GitHub上的WebAssembly组织页面上查看所有提案，网址为[https://github.com/WebAssembly](https://github.com/WebAssembly)。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed advanced tools and an alternate compilation method
    for WebAssembly. We learned about WABT and Binaryen's role in the WebAssembly
    development process and the functionality they provide. We compiled a Wasm module
    with LLVM through the use of the WebAssembly `npm` package and interacted with
    the result in the browser. We reviewed some of the WebAssembly tooling available
    online and created a simple application that uses Web Workers to store Wasm modules
    in separate threads. Finally, we discussed the upcoming features of WebAssembly
    and the standardization process. Now that you've gained a greater understanding
    of WebAssembly, go out there and build something!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们回顾了WebAssembly的高级工具和另一种编译方法。我们了解了WABT和Binaryen在WebAssembly开发过程中的作用以及它们提供的功能。我们通过使用WebAssembly的`npm`包，使用LLVM编译了一个Wasm模块，并在浏览器中与结果进行了交互。我们回顾了一些在线可用的WebAssembly工具，并创建了一个简单的应用程序，使用Web
    Workers将Wasm模块存储在单独的线程中。最后，我们讨论了WebAssembly的即将推出的功能和标准化过程。现在你对WebAssembly有了更深入的了解，可以开始构建一些东西了！
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does WABT stand for?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WABT代表什么？
- en: What three elements does Binaryen provide to make compiling to WebAssembly *easy*,
    *fast*, and *effective*?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Binaryen提供了哪三个元素，使编译到WebAssembly变得*简单*、*快速*和*有效*？
- en: What is the main difference between modules compiled using Emscripten versus
    LLVM with regard to the `importObj`/`exports`?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Emscripten和LLVM编译的模块在`importObj`/`exports`方面的主要区别是什么？
- en: Which online tool allows you to use AssemblyScript?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个在线工具允许您使用AssemblyScript？
- en: What are the two types of arguments you can pass to the `Worker()` constructor?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以传递给`Worker()`构造函数的两种参数类型是什么？
- en: What convention was used for passing messages between the main thread and worker
    threads?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程和工作线程之间传递消息使用了什么约定？
- en: How many phases are in the WebAssembly standardization process?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly标准化过程中有多少个阶段？
- en: What is the name of the new type defined in the reference types feature?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用类型功能中定义的新类型的名称是什么？
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A crash course in memory management: [https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理速成课： [https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management)
- en: MDN Web Workers API: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN Web Workers API: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
- en: WebAssembly - Web Workers: [https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a](https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly - Web Workers: [https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a](https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a)
