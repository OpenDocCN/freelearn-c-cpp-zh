- en: Managing Events, Custom Signals, and Slots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理事件、自定义信号和槽
- en: This chapter introduces the concept of events. To maintain a working state,
    messages are passed around from the windowing system to the application, and within
    the application itself. These messages may contain data that could be useful when
    delivered at some destination. The messages being talked about here are referred
    to as events in Qt.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了事件的概念。为了保持工作状态，消息从窗口系统传递到应用程序，并在应用程序内部传递。这些消息可能包含在某个目的地交付时可能有用的数据。这里讨论的消息在
    Qt 中被称为事件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Event handlers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: Drag and drop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖放
- en: Custom signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义信号
- en: Events
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: In Qt, all events that occur are encapsulated in objects that inherit from the `QEvent` abstract
    class. An example of an event that has occurred is when a window has been resized
    or moved. The change in the state of the application will be noticed, and an appropriate
    `QEvent` object will be created to represent it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，所有发生的事件都被封装在继承自 `QEvent` 抽象类的对象中。一个发生事件的例子是窗口被调整大小或移动。应用程序状态的改变将被注意到，并将创建一个适当的
    `QEvent` 对象来表示它。
- en: The application event loop delivers this object to certain objects that inherit
    from `QObject`. This `QEvent` object is handled by means of a method call that
    will be invoked.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的事件循环将此对象传递给继承自 `QObject` 的某些对象。这个 `QEvent` 对象将通过调用一个将被调用的方法来处理。
- en: There are different types of events. When a mouse is clicked, a `QMouseEvent`
    object is created to represent this. The object will contain additional information,
    such as the specific mouse button that was clicked, together with the location
    where that event occurred.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的事件。当鼠标被点击时，将创建一个 `QMouseEvent` 对象来表示这个事件。该对象将包含额外的信息，例如被点击的具体鼠标按钮以及事件发生的位置。
- en: Event handlers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: All `QObjects` have an `event()` method that receives events. For `QWidgets`,
    this method will relay the event object to more specific event handlers. It is
    possible to redefine what an event handler should do by sub-classing the widget
    of interest and re-implementing that event handler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `QObjects` 都有一个 `event()` 方法，它接收事件。对于 `QWidgets`，此方法将事件对象传递给更具体的事件处理程序。可以通过子类化感兴趣的控件并重新实现该事件处理程序来重新定义事件处理程序应该做什么。
- en: Let's create an application where we shall re-implement an event handler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，我们将重新实现一个事件处理程序。
- en: 'Create a folder containing the `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`
    files. The `mainwindow.h` file should contain the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含 `main.cpp`、`mainwindow.cpp` 和 `mainwindow.h` 文件的文件夹。`mainwindow.h` 文件应包含以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have only sub-classed `QMainWindow`. A default constructor
    is declared and the event handler that we want to override, or re-implement, is
    the `moveEvent(QMoveEvent *event)` handler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只对 `QMainWindow` 进行了子类化。声明了一个默认构造函数，并重写或重新实现了我们想要重写的事件处理程序，即 `moveEvent(QMoveEvent
    *event)` 处理程序。
- en: When a window is moved, the `event()` method of the `QMainWindow` object will
    be called. The event will be further encapsulated in a `QMoveEvent` object and
    forwarded to the `moveEvent()` event handler. Since we are interested in changing
    the behavior of the window when it is moved, we define our own `moveEvent()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口被移动时，`QMainWindow` 对象的 `event()` 方法将被调用。事件将被进一步封装在 `QMoveEvent` 对象中，并转发给
    `moveEvent()` 事件处理程序。由于我们感兴趣的是在窗口移动时改变窗口的行为，我们定义了自己的 `moveEvent()`。
- en: 'Add the following lines of code to `mainwindow.cpp`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到 `mainwindow.cpp` 中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the default constructor, the title of the window is set. The event object
    carries the coordinates of where the window currently is. Then `event->pos().x()`
    is called to obtain the *x *coordinate, likewise the *y* coordinate is obtained
    by calling `event->pos().y()`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认构造函数中，设置了窗口的标题。事件对象携带窗口当前所在位置的坐标。然后调用 `event->pos().x()` 获取 *x* 坐标，同样通过调用
    `event->pos().y()` 获取 *y* 坐标。
- en: We convert `yCord` and `xCord` to text and store them in `text`. To access the
    status bar of the window, `statusBar()` is called and `text` is passed to the
    `showMessage()` method of the status bar object returned from the call to `statusBar()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `yCord` 和 `xCord` 转换为文本，并存储在 `text` 中。要访问窗口的状态栏，调用 `statusBar()` 并将 `text`
    传递给从 `statusBar()` 调用返回的状态栏对象的 `showMessage()` 方法。
- en: 'The `main.cpp` file will contain, as usual, the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp` 文件将包含以下代码，如往常一样：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the application. Note how the status bar changes when you move
    the application window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。注意当移动应用程序窗口时状态栏的变化。
- en: Here are two screenshots showing how the status bar, located at the bottom of
    the window, changed when the window was moved.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个屏幕截图显示了当窗口移动时，位于窗口底部的状态栏如何变化。
- en: 'The first state of the window is shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的第一个状态显示在下述屏幕截图：
- en: '![](img/dcc84278-9975-45c0-ae38-1367731496d0.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcc84278-9975-45c0-ae38-1367731496d0.png)'
- en: 'When the window was moved, it later showed the output as shown in the following
    screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口被移动时，稍后显示了如下所示的输出：
- en: '![](img/94e24190-451d-4f1a-8523-1fd3787c6caf.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94e24190-451d-4f1a-8523-1fd3787c6caf.png)'
- en: Note the very bottom of the window and how it has changed. Continuously move
    the window around and observe how the status bar changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意窗口的底部以及其变化。持续移动窗口并观察状态栏的变化。
- en: Let's write another example to improve our understanding of Qt events.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个例子来提高我们对Qt事件的理解。
- en: Apart from the events generated by the windowing system, other events are generated
    by Qt. The example here will illustrate how to tell Qt to send our application
    timer-based events at certain intervals.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由窗口系统生成的事件外，Qt还会生成其他事件。以下示例将说明如何让Qt在特定间隔发送基于定时器的应用程序事件。
- en: As usual, we shall start with the three main files we usually create, that is,
    `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`. The project builds upon the
    previous example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将从通常创建的三个主要文件开始，即`main.cpp`、`mainwindow.cpp`和`mainwindow.h`。项目基于之前的示例。
- en: 'In the `mainwindow.h` file, insert the following lines of codes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainwindow.h`文件中，插入以下代码行：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To receive the timer events, we shall implement our own `timerEvent` method,
    which will be the destination of the event that is given off when a timer expires.
    That is the essence of adding the void `timerEvent(QTimerEvent *event)` signature.
    The `QLabel` `currentDateTimeLabel` instance will be used to display the date
    and time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收定时器事件，我们将实现自己的`timerEvent`方法，这将作为定时器到期时发出的事件的目的地。这就是添加void `timerEvent(QTimerEvent
    *event)`签名的基本原理。`QLabel` `currentDateTimeLabel`实例将用于显示日期和时间。
- en: 'In the `mainwindow.cpp` file, the default constructor is defined by the following
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainwindow.cpp`文件中，默认构造函数由以下代码定义：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The title for the window is set. An instance of `QLabel` is created and the
    call to `setAlignment` ensures that its content says centered. Then `currentDateTimeLabel`
    is passed to the `setCentralWidget()` method. The `startTimer(1000)` method starts
    a timer and will trigger a `QTimerEvent` object every second, represented by `1000`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的标题已设置。创建了一个`QLabel`实例，并通过调用`setAlignment`确保其内容居中。然后`currentDateTimeLabel`传递给`setCentralWidget()`方法。`startTimer(1000)`方法启动一个定时器，并且每秒触发一个`QTimerEvent`对象，表示为`1000`。
- en: For each second, we now need to define what should happen by re-implementing
    the `timerEvent()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一秒，我们现在需要通过重新实现`timerEvent()`方法来定义应该发生什么。
- en: 'Add the following code to `mainwindow.cpp`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`mainwindow.cpp`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Every second, the `timerEvent()` will be called and passed an instance of `QTimerEvent`.
    The `Q_UNUSED (event)` is used to keep the compiler from complaining that `event()` is
    not being used in any way. A string representation of the current date and time
    is passed to `dateTime` and set as the text for the `currentDateTimeLabel` instance
    variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒，`timerEvent()`将被调用并传递一个`QTimerEvent`实例。`Q_UNUSED(event)`用于防止编译器抱怨`event()`没有被以任何方式使用。当前日期和时间的字符串表示形式传递给`dateTime`并设置为`currentDateTimeLabel`实例变量的文本。
- en: 'The `main.cpp` file remains the same as before. As a reference it is presented
    once more, as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`文件与之前相同。作为参考，以下代码再次呈现，如下所示：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile and run the application, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序，如下所示：
- en: '![](img/7c283a6a-eaf6-4f51-9148-708fddfb35ab.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c283a6a-eaf6-4f51-9148-708fddfb35ab.png)'
- en: The application will initially show the text, current date, and time, but after
    a second it should change and display the updated time. Every second that passes
    will cause text to be updated too.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最初将显示文本、当前日期和时间，但一秒后应更改并显示更新的时间。每过去一秒，文本也会更新。
- en: Drag and drop
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: In this section, we shall put together a simple application that can handle
    drag and drop operations from an external source into an application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将组合一个简单的应用程序，它可以处理从外部源到应用程序中的拖放操作。
- en: The application is a small text editor. When a text file is dropped into the
    text area, it will open and insert the contents of that text file into the text
    area. The status of the window will show the number of characters in the text
    area, which is an instance of a `QTextEdit`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是一个小型文本编辑器。当文本文件被拖放到文本区域时，它将打开并将该文本文件的內容插入到文本区域中。窗口的状态将显示文本区域的字符数，这是一个
    `QTextEdit` 的实例。
- en: This example application also illustrates a very important point about events.
    To customize a widget, one has to change the existing behavior of that widget
    by overriding its event handlers. Signals and slots are not considered when trying
    to customize widgets (except events).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序还说明了关于事件的一个非常重要的观点。要自定义小部件，必须通过重写其事件处理程序来改变该小部件的现有行为。在尝试自定义小部件时（除了事件外），不考虑信号和槽。
- en: 'To begin this project, perform the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此项目，请执行以下步骤：
- en: Create a new folder with a name of your choice
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个您选择的名称的新文件夹
- en: Create the `main.cpp`, `mainwindow.cpp`, `mainwindow.h`, `dragTextEdit.h`, and
    `dragTextEdit.cpp` files
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main.cpp`、`mainwindow.cpp`、`mainwindow.h`、`dragTextEdit.h` 和 `dragTextEdit.cpp`
    文件
- en: The `dragTextEdit.h` and `dragTextEdit.cpp` files will contain the definition
    of our custom widget. The `mainwindow.cpp` and `mainwindow.h` files will be used
    to construct the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragTextEdit.h` 和 `dragTextEdit.cpp` 文件将包含我们自定义小部件的定义。`mainwindow.cpp` 和 `mainwindow.h`
    文件将用于构建应用程序。'
- en: 'Let''s start with the custom `QTextEdit` widget. Insert the following lines
    of code into `dragTextEdit.h`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从自定义的 `QTextEdit` 小部件开始。将以下代码行插入到 `dragTextEdit.h`：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `DragTextEdit` custom widget, inherits from `QTextEdit`. The default constructor
    is declared. In order to accept a drop event, we need to override the following
    methods to ensure proper behavior, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DragTextEdit` 自定义小部件继承自 `QTextEdit`。声明了默认构造函数。为了接受拖放事件，我们需要重写以下方法以确保适当的行为，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that the header file has been created, open the `dragTextEdit.cpp` file
    and add the definition of the default constructor, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了头文件，打开 `dragTextEdit.cpp` 文件并添加默认构造函数的定义，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `#include` directive imports the header file, after which the default constructor
    is defined. In order for our widget to accept a drop event, we need to say so
    by calling the `setAcceptDrops(true)` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` 指令导入头文件，之后定义默认构造函数。为了使我们的小部件能够接受拖放事件，我们需要通过调用 `setAcceptDrops(true)`
    方法来声明这一点。'
- en: 'We now have to add the definition of the methods we want to override. Add the
    following lines to `dragTextEdit.cpp`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须添加我们想要重写的函数的定义。将以下行添加到 `dragTextEdit.cpp`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These event handlers deal with the major steps involved when there is going
    to be a drop action. The  `acceptProposedAction()` method is called on the event
    object in the `dragEnterEvent()` and `dragMoveEvent()` methods. These events are
    called when the cursor in drag mode is on the boundary of the widget that calls
    the `setAcceptDrops()` method. If you refuse to call the `acceptProposedAction()`
    method, the drop behavior may misbehave.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件处理程序处理将要进行拖放操作时涉及的主要步骤。在 `dragEnterEvent()` 和 `dragMoveEvent()` 方法中，会调用事件对象上的
    `acceptProposedAction()` 方法。这些事件在拖动模式下的光标位于调用 `setAcceptDrops()` 方法的窗口边界时被调用。如果您拒绝调用
    `acceptProposedAction()` 方法，拖放行为可能会出现异常。
- en: The `dragMoveEvent()` event handler is called when the cursor is within the
    widget of interest. But to define what happens when the drop event happens we
    need to define the `dropEvent()` handler.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标在感兴趣的小部件内时，会调用 `dragMoveEvent()` 事件处理程序。但为了定义拖放事件发生时会发生什么，我们需要定义 `dropEvent()`
    处理程序。
- en: 'Add the following code to `dragTextEdit.cpp`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `dragTextEdit.cpp`：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The mime data of the file, encapsulated within the event object, is obtained
    by calling `event->mimeData()`. If it contains text data, we extract the contents
    of the file and call the `setText()` method belonging to `QTextEdit`. This will
    populate the `DragTextEdit` instance with that text. Note the fact that we continue
    to call `event->acceptProposedAction()` to tell Qt that we have handled this event.
    If, on the other hand, `event->ignore()` is called, it is taken as an unwanted
    event or action and is, as such, propagated to a parent widget.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`event->mimeData()`从事件对象中获取文件的mime数据。如果它包含文本数据，我们将提取文件的正文并调用`QTextEdit`的`setText()`方法。这将用该文本填充`DragTextEdit`实例。请注意，我们继续调用`event->acceptProposedAction()`来告诉Qt我们已经处理了这个事件。另一方面，如果调用`event->ignore()`，它被视为不受欢迎的事件或操作，因此被传播到父小部件。
- en: This completes the implementation of custom `QTextEdit`. Now we need to create
    `mainwindow.h` and `mainwindow.cpp` that will construct the main application window
    and make use of `DragTextEdit`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了自定义`QTextEdit`的实现。现在我们需要创建`mainwindow.h`和`mainwindow.cpp`，它们将构建主应用程序窗口并使用`DragTextEdit`。
- en: 'Create the `mainwindow.h` file and insert the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`mainwindow.h`文件并插入以下代码：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `QMainWindow`, `QLabel` class with the other usual classes are imported
    along with the `dragTextEdit.h` header file, which allows the inclusion of our
    custom class. A slot that will be called **anytime text** is added or removed
    from the `DragTextEdit` widget and is declared. Lastly, an instance of `DragTextEdit`
    is created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`QMainWindow`、`QLabel`类和其他常用类，以及`dragTextEdit.h`头文件，这允许包含我们的自定义类。声明一个将在任何文本被添加到或从`DragTextEdit`小部件中删除时被调用的槽。最后，创建一个`DragTextEdit`实例。
- en: 'Create and open the `mainwindow.cpp` file and insert the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并打开`mainwindow.cpp`文件，并插入以下代码：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the constructor,  `QWidget` and the `QVBoxLayout` objects are created to
    hold the main widget and layout. This widget will then be inserted with the call
    to `setCentralWdiget()`, as shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，创建`QWidget`和`QVBoxLayout`对象以容纳主小部件和布局。然后通过调用`setCentralWdiget()`将此小部件插入，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An instance of the  `DragTextEdit` custom class is created and passed to `slateDragTextEdit`.
    This widget is added to our main layout, as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`DragTextEdit`自定义类的实例，并将其传递给`slateDragTextEdit`。此小部件被添加到我们的主布局中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The status bar of the window is set to `0`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的状态栏设置为`0`。
- en: Anytime the `slateDragTextEdit` emits the `textChanged()` signal, a call to
    the `updateStatusBar()` slot will be called. In this slot, the characters within
    `slateDragTextEdit` will be extracted and counted. The status bar will thus be
    updated when a character is added to or removed from `slateDragTextEdit`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`slateDragTextEdit`发出`textChanged()`信号时，都会调用`updateStatusBar()`槽。在这个槽中，将从`slateDragTextEdit`中提取并计算字符。因此，当字符被添加到或从`slateDragTextEdit`中删除时，状态栏将被更新。
- en: 'The `main.cpp` file will contain only the following few lines of code to instantiate
    the window and display it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`文件将只包含以下几行代码来实例化窗口并显示它：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the end of the project, you should have five (5) files in your folder. To
    compile the project, issue the following commands within the folder on the command
    line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结束时，你应该在你的文件夹中有五个（5）个文件。要在命令行中编译项目，请在文件夹内执行以下命令：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Don''t forget to add `QT += widgets` to the generated `.pro` file. The `.pro`
    file should contain the header files and program files. It should look like the
    following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`QT += widgets`添加到生成的`.pro`文件中。`.pro`文件应包含头文件和程序文件。它应该如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Continue to issue the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行以下命令：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A running program will look like the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的程序将如下截图所示：
- en: '![](img/fff52ff4-47db-48f9-a15a-5483b1fbb4f3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fff52ff4-47db-48f9-a15a-5483b1fbb4f3.png)'
- en: Since there are no characters when the program is executed, the status bar will
    read 0, as in the preceding screenshot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序执行时没有字符，状态栏将显示0，如前述截图所示。
- en: 'Type some input into the text area and find out how, with every keystroke,
    the status bar is updated, as we have in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本区域中输入一些输入，并找出每次按键时状态栏是如何更新的，如下面的截图所示：
- en: '![](img/9eed95ff-fa3c-443f-8852-bd80c08131f6.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9eed95ff-fa3c-443f-8852-bd80c08131f6.png)'
- en: 'The example in this section illustrates how the text area can accept items
    external to the application. Drag and drop any  text (`.txt`) file, or any file
    containing text, onto the text area and see how its content is used to populate
    the textbox, as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例说明了文本区域如何接受应用程序外部的项目。将任何文本（`.txt`）文件或包含文本的任何文件拖放到文本区域，看看其内容是如何用于填充文本框的，如下面的截图所示：
- en: '![](img/0d887219-00d7-4797-aab9-a5177730da6d.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d887219-00d7-4797-aab9-a5177730da6d.png)'
- en: 'From the preceding screenshot, the content of the `sometext.txt` file, which
    contains text, will be pasted into the text area as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，包含文本的`sometext.txt`文件的内容将被粘贴到文本区域中，如下面的截图所示：
- en: '![](img/2767e320-a8e6-4759-a354-a33fcb5ab6c3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2767e320-a8e6-4759-a354-a33fcb5ab6c3.png)'
- en: Experiment by removing the call to `acceptProposedAction()` and `accept()` and
    see how the drag and drop changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除对`acceptProposedAction()`和`accept()`的调用进行实验，看看拖放是如何变化的。
- en: The last section of this chapter will touch on the creation of a custom signal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将涉及自定义信号的制作。
- en: Custom signals
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义信号
- en: In previous chapters, we saw how to use slots and create custom slots to implement
    some functionality in response to a signal being emitted. Now, in this section,
    we will look at how to create custom signals that can be emitted and connected
    to other slots.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用槽和创建自定义槽来在信号发出时实现一些功能。现在，在本节中，我们将探讨如何创建可以发出并连接到其他槽的自定义信号。
- en: To create a custom signal, one needs to declare a method signature and mark
    it as a signal with the aid of the `Q_OBJECT` macro. When declared, signals don't
    have a return type, but they can accept parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义信号，需要声明一个方法签名并使用`Q_OBJECT`宏将其标记为信号。声明时，信号没有返回类型，但可以接受参数。
- en: Let's get our feet wet with a project. As usual, a new folder should be created
    with the three (3) files, namely, `main.cpp`, `mainwindow.cpp`, and `mainwindow.h`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个项目来实践一下。像往常一样，应该创建一个包含三个（3）个文件的新文件夹，即`main.cpp`、`mainwindow.cpp`和`mainwindow.h`。
- en: In this example, we shall override `mousePressEvent` and emit a custom signal
    that will be connected to a slot to perform a number of updates on a window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将重写`mousePressEvent`并发出一个自定义信号，该信号将连接到一个槽以在窗口上执行多个更新。
- en: 'In the `mainwindow.h` file, insert the following lines of code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainwindow.h`文件中，插入以下代码行：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The custom signal here is declared with the following lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此处自定义信号使用以下行声明：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When this signal is emitted, it will pass an instance of `QPoint` as an argument.
    If we didn't want our signal to pass any argument, it would have been written
    with as `void` `mouseMoved()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当此信号发出时，它将传递一个`QPoint`实例作为参数。如果我们不想我们的信号传递任何参数，它将用`void` `mouseMoved()`编写。
- en: Custom signals should return nothing. The signal will be emitted when we re-implement
    the `mousePressEvent()` handler.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义信号不应返回任何内容。当我们在`mousePressEvent()`处理程序中重新实现时，将发出信号。
- en: The `void updateMousePosition(QPoint pos)`, slot will be connected to the custom
    signal. Its definition is found in `mainwindow.cpp`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`void updateMousePosition(QPoint pos)`，槽将连接到自定义信号。其定义可在`mainwindow.cpp`中找到。'
- en: The member pointer, `mousePosition`, will display the coordinates of the mouse
    when it is clicked.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 成员指针`mousePosition`将在鼠标点击时显示鼠标的坐标。
- en: 'In the `mainwindow.cpp` file, we shall define three (3) methods. These are
    the default constructor, the slot `updateMousePosition()`, and the `mousePressEvent()
    override` methods, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainwindow.cpp`文件中，我们将定义三个（3）方法。这些是默认构造函数、槽`updateMousePosition()`和`mousePressEvent()`重写方法，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `include` statement has to be at the very top of the file. In this `override` method,
    we obtain the coordinate where the mouse press event was generated by calling
    `event->pos()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`语句必须位于文件的顶部。在此`override`方法中，我们通过调用`event->pos()`来获取鼠标按下事件生成的坐标。'
- en: The points `x` and `y` coordinates are obtained by calling `x()` and `y()`,
    respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`x()`和`y()`分别获得`x`和`y`坐标。
- en: The `emit mouseMoved(event->pos())` line is used to emit the signal we declared
    in the header file. Furthermore, `event->pos()` will return a `QPoint` object,
    which conforms with the signature of the signal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit mouseMoved(event->pos())`行用于发出在头文件中声明的信号。此外，`event->pos()`将返回一个`QPoint`对象，该对象符合信号的签名。'
- en: 'The following screenshot shows how the slot is defined in the `mainwindow.cpp`
    file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在`mainwindow.cpp`文件中定义的槽：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `QPoint` instance is received by the slot as a parameter. It's `x` and `y`
    coordinates are obtained by calling `point.x()` and `point.y()`, respectively.
    A `QString` instance `text` is used to concatenate the two values, `xCord` and
    `yCord`, into a longer string.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽接收 `QPoint` 实例作为参数。通过调用 `point.x()` 和 `point.y()` 分别获取其 `x` 和 `y` 坐标。使用 `QString`
    实例 `text` 将两个值 `xCord` 和 `yCord` 连接到一个更长的字符串中。
- en: The `QLabel` instance, `mousePosition`, will be used to display this coordinate
    by calling its `setText()` method. Similarly, the status bar of the window will
    be set by calling `statusBar()->showMessage(text)`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 `QLabel` 实例 `mousePosition` 通过调用其 `setText()` 方法来显示此坐标。同样，可以通过调用 `statusBar()->showMessage(text)`
    来设置窗口的状态栏。
- en: 'To do the plumbing of connecting the custom signal to our slot, we need to
    define the default constructor. Add the following lines to `mainwindow.cpp`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要将自定义信号连接到我们的插槽进行管道连接，我们需要定义默认构造函数。将以下行添加到 `mainwindow.cpp` 中：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like we have been doing, the `windowCentralWidget` is used as the main widget
    in our application. `QLabel` is added to its layout, `innerLayout`. The status
    bar is given an initial value of `"Ready"`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，`windowCentralWidget` 被用作我们应用程序中的主小部件。向其布局 `innerLayout` 中添加了 `QLabel`，并将状态栏的初始值设置为
    `"Ready"`。
- en: The `mouseMoved(QPoint)` signal is connected to the `updateMousePosition(QPoint)`
    slot.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `mouseMoved(QPoint)` 信号连接到 `updateMousePosition(QPoint)` 插槽。
- en: 'In the `main.cpp` file, we shall instantiate our window and start the main
    event loop, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 文件中，我们将实例化我们的窗口并启动主事件循环，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile and run the executable, as shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图编译并运行可执行文件：
- en: '![](img/d1da79e9-cc58-4aff-b720-ea53646bf223.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1da79e9-cc58-4aff-b720-ea53646bf223.png)'
- en: The status bar reads Ready, while the `QLabel` making up the main widget in
    the window reads Mouse Position. Now, click on any part within the window, and
    see the status bar and label change to display the coordinates of the mouse where
    the click was generated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏显示 "Ready"，而组成窗口主小部件的 `QLabel` 显示 "鼠标位置"。现在，点击窗口内的任何部分，并查看状态栏和标签更改以显示鼠标点击处的坐标。
- en: 'See the following screenshot as an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图为例：
- en: '![](img/51548fa3-126b-4072-8339-236bb3314c50.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51548fa3-126b-4072-8339-236bb3314c50.png)'
- en: The location of the cursor is 145, 157, where 145 is on the *x* axi*s* and 157
    is on the *y* axis. When the cursor is moved, this value will not change. However,
    when the mouse is clicked, the `mouseMoved()` signal will be emitted along with
    the coordinates to update the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 光标的位置是 145，157，其中 145 位于 *x* 轴上，157 位于 *y* 轴上。当光标移动时，此值不会改变。然而，当鼠标点击时，将发出 `mouseMoved()`
    信号，并带有坐标以更新屏幕。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter shed more light on how to use events in Qt. We understood the different
    situations that call for the use of events instead of the signal-slot mechanism.
    The first examples touched on how to override and implement custom event handlers.
    The events we implemented captured the position of a window and also redefined
    what should happen every second in an example application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进一步阐述了如何在 Qt 中使用事件。我们了解了在不同情况下使用事件而不是信号-槽机制的不同情况。最初的例子涉及如何覆盖和实现自定义事件处理程序。我们实现的事件捕获了窗口的位置，并在示例应用程序中重新定义了每秒应发生的事情。
- en: With the aid of events, we also implemented a simple drop event in the drag
    and drop action, where a simple text editor was created to accept files that are
    dropped in the text area. Lastly, the chapter illustrated how to create a custom
    signal that is emitted when an event occurs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在拖放操作中，借助事件，我们还实现了一个简单的放下事件，创建了一个简单的文本编辑器来接受在文本区域中放下的文件。最后，本章说明了如何创建在事件发生时发出的自定义信号。
- en: In [Chapter 6](bfdfd852-205f-4c4b-bb41-d798fdc865f7.xhtml), *Connecting Qt with
    Databases*, we will focus on the various ways to store data and retrieve it when
    building Qt applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](bfdfd852-205f-4c4b-bb41-d798fdc865f7.xhtml)，*将 Qt 与数据库连接*，我们将关注在构建
    Qt 应用程序时存储数据和检索数据的各种方法。
