- en: Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: C++ allows you to create your own types. These custom types can have operators
    and can be converted to other types; indeed, they can be used like built-in types
    with the behavior that you define. This facility uses a language feature called
    classes. The advantage of being able to define your own types is that you can
    encapsulate data in objects of your chosen type, and use the type to manage the
    lifetime of that data. You can also define the actions that can be performed on
    that data. In other words, you are able to define custom types that have state
    and behavior, which is the basis of object-orientated programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您创建自己的类型。这些自定义类型可以具有运算符，并且可以转换为其他类型；实际上，它们可以像内置类型一样使用，具有您定义的行为。这个功能使用了一个称为类的语言特性。能够定义自己的类型的优势在于，您可以将数据封装在您选择的类型的对象中，并使用该类型来管理该数据的生命周期。您还可以定义可以对该数据执行的操作。换句话说，您可以定义具有状态和行为的自定义类型，这是面向对象编程的基础。
- en: Writing classes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写类
- en: When you use built-in types, the data is directly available to whatever code
    has access to that data. C++ provides a mechanism (`const`) to prevent write access,
    but any code can use `const_cast` to cast away `const`-ness. Your data could be
    complex, such as a pointer to a file mapped into memory with the intention that
    your code will change a few bytes and then write the file back to disk. Such raw
    pointers are dangerous because other code with access to the pointer could change
    part of the buffer that should not be changed. What is needed is a mechanism to
    encapsulate the data into a type that knows what bytes to change, and only allow
    that type to access the data. This is the basic idea behind classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用内置类型时，数据直接可供访问该数据的任何代码。C++提供了一种机制（`const`）来防止写访问，但任何代码都可以使用`const_cast`来去除`const`。您的数据可能很复杂，例如指向映射到内存中的文件的指针，意图是您的代码将更改一些字节，然后将文件写回磁盘。这样的原始指针是危险的，因为其他代码可以访问指针并更改不应更改的缓冲区的一部分。需要的是一种将数据封装到了解要更改哪些字节的类型中，并且只允许该类型访问数据的机制。这是类的基本思想。
- en: Reviewing structures
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾结构
- en: 'We have already seen one mechanism in C++ to encapsulate data: `struct`. A
    structure allows you to declare data members that are built-in types, pointers,
    or references. When you create a variable from that `struct`, you are creating
    an **instance** of the structure, also known as an **object**. You can create
    variables that are references to this object or pointers that point to the object.
    You can even pass the object by value to a function where the compiler will make
    a copy of the object (it will call the *copy constructor* for the `struct`).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了C++中封装数据的一种机制：`struct`。结构允许您声明内置类型、指针或引用的数据成员。当您从该`struct`创建变量时，您正在创建该结构的**实例**，也称为**对象**。您可以创建引用该对象的变量或指向该对象的指针。甚至可以将对象按值传递给函数，编译器将对对象进行复制（它将调用`struct`的*复制构造函数*）。
- en: We have seen that with a `struct` any code that has access to an instance (even
    through a pointer or reference) can access the members of the object (although
    this can be changed). Used like this, a `struct` can be thought of as **aggregate**
    types containing the state.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对于`struct`，任何可以访问实例的代码（甚至通过指针或引用）都可以访问对象的成员（尽管这可能会改变）。这样使用，`struct`可以被视为包含状态的**聚合**类型。
- en: The members of an instance of a `struct` can be initialized by accessing them
    directly with the dot operator or using the `->` operator through a pointer to
    the object. We have also seen that you can initialize an instance of a `struct`
    with an initializer list (in braces). This is quite restrictive because the initializer
    list has to match the data members in the `struct`. In [Chapter 2](6ebba475-440c-4e33-acb1-094670bf962e.xhtml),
    *Working with Memory, Arrays, and Pointers*, you saw that you can have a pointer
    as a member of a `struct`, but you have to explicitly take appropriate action
    to release the memory pointed to by the pointer; if you don't, then this could
    result in a memory leak.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`的实例的成员可以通过直接使用点运算符初始化，也可以通过指向对象的指针使用`->`运算符进行初始化。我们还看到，您可以使用初始化器列表（在大括号中）初始化`struct`的实例。这是相当受限制的，因为初始化器列表必须与`struct`中的数据成员匹配。在[第2章](6ebba475-440c-4e33-acb1-094670bf962e.xhtml)中，*使用内存、数组和指针*，您看到可以将指针作为`struct`的成员，但必须明确采取适当的操作来释放指针指向的内存；如果不这样做，可能会导致内存泄漏。'
- en: A `struct` is one of the class types that you can use in C++; the other two
    are `union` and `class`. Custom types defined as `struct` or `class` can have
    behaviors as well as state, and C++ allows you to define some special functions
    to control how instances are created and destroyed, copied, and converted. Furthermore,
    you can define operators on a `struct` or `class` type so that you can use the
    operators on instances in a similar way to using the operators on built-in types.
    There is a difference between `struct` and `class` which we will address later,
    but in general the rest of the chapter will be about classes and when a `class`
    is mentioned you can usually assume the same applies to a `struct` as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`是您可以在C++中使用的类类型之一；另外两个是`union`和`class`。定义为`struct`或`class`的自定义类型也可以具有行为和状态，C++允许您定义一些特殊函数来控制实例的创建和销毁、复制和转换。此外，您可以在`struct`或`class`类型上定义运算符，以便您可以在实例上使用运算符，类似于在内置类型上使用运算符。`struct`和`class`之间存在差异，我们将在后面讨论，但总的来说，本章的其余部分将涉及类，当提到`class`时，通常可以假定相同的内容也适用于`struct`。'
- en: Defining classes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: A class is defined in a statement, and it will define its members in a block
    with multiple statements enclosed by braces `{}`. As it's a statement, you have
    to place a semicolon after the last brace. A class can be defined in a header
    file (as are many of the **C++ Standard Library** classes), but you have to take
    steps to ensure that such files are included only once in a source file. There
    are, however, some rules about specific items in a class that must be defined
    in a source file, which will be covered later.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个语句中定义了一个类，并且将在由大括号`{}`括起来的多个语句块中定义其成员。由于这是一个语句，所以必须在最后一个大括号后面加上分号。一个类可以在头文件中定义（就像许多**C++标准库**类一样），但是你必须采取措施确保这样的文件只在源文件中包含一次。然而，关于类中必须在源文件中定义的特定项目有一些规则，这将在后面介绍。
- en: If you peruse the C++ Standard Library, you will see that classes contain member
    functions and, in an attempt to put all the code for a class into a single header
    file, this makes the code difficult to read and difficult to understand. This
    may be justifiable for a library file maintained by a legion of expert C++ programmers,
    but for your own projects readability should be a key design goal. For this reason,
    a C++ class can be declared in a C++ header file, including its member functions,
    and the actual implementation of the functions can be placed in a source file.
    This makes the header files easier to maintain and more reusable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览C++标准库，你会发现类包含成员函数，并且试图将类的所有代码放入单个头文件中，这使得代码难以阅读和理解。这可能是有道理的，对于由大量专业C++程序员维护的库文件，但对于你自己的项目来说，可读性应该是一个关键的设计目标。因此，C++类可以在C++头文件中声明，包括其成员函数，并且函数的实际实现可以放在源文件中。这使得头文件更容易维护和更可重用。
- en: Defining class behavior
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类的行为
- en: 'A class can define functions that can only be called through an instance of
    the class; such a function is often called a **method**. An object will have state;
    this is provided by the data members defined by the class and initialized when
    the object is created. The methods on an object define the behavior of the object,
    usually acting upon the state of the object. When you design a class, you should
    think of the methods in this way: they describe the object doing something.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义只能通过类的实例调用的函数；这样的函数通常被称为**方法**。一个对象将有状态；这是由类定义的数据成员提供的，并且在创建对象时初始化。对象上的方法定义了对象的行为，通常作用于对象的状态。当你设计一个类时，你应该这样考虑方法：它们描述了对象在做某事。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class has two data members, `x` and `y`, which represent the direction
    of a two-dimensional vector resolved in the Cartesian x and y directions. The
    `public` keyword means that any members defined after this specifier are accessible
    by code defined outside of the class. By default, all the members of a class are
    `private` unless you indicate otherwise. `private` means that the member can only
    be accessed by other members of the class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个数据成员，`x`和`y`，它们表示笛卡尔x和y方向上的二维向量的方向。`public`关键字意味着在此指定符号之后定义的任何成员都可以被类外定义的代码访问。默认情况下，类的所有成员都是`private`的，除非你另有说明。`private`意味着该成员只能被类的其他成员访问。
- en: 'This is the difference between a `struct` and a `class`: by default, members
    of a `struct` are `public` and by default, members of a `class` are `private`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`struct`和`class`之间的区别：默认情况下，`struct`的成员是`public`的，而默认情况下，`class`的成员是`private`的。
- en: 'This class has a method called `get_magnituide` that will return the length
    of the Cartesian vector. This function acts upon the two data members of the class
    and returns a value. This is a type of **accessor** method; it gives access to
    the state of the object. Such a method is typical on a `class`, but there is no
    requirement that methods return values. Like functions, a method can also take
    parameters. The `get_magnituide` method can be called like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个名为`get_magnituide`的方法，它将返回笛卡尔向量的长度。这个函数作用于类的两个数据成员并返回一个值。这是一种**访问器**方法；它允许访问对象的状态。这样的方法在`class`上很典型，但没有要求方法返回值。像函数一样，方法也可以接受参数。`get_magnituide`方法可以这样调用：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here a `cartesian_vector` object is created on the stack and list initializer
    syntax is used to initialize it to a value representing a vector of `(3,4)`. The
    length of this vector is 5, which is the value returned by calling `get_magnitude`
    on the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈上创建了一个`cartesian_vector`对象，并使用列表初始化语法将其初始化为表示向量`(3,4)`的值。这个向量的长度是5，这是通过调用对象的`get_magnitude`返回的值。
- en: Using the this pointer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用这个指针
- en: 'The methods in a class have a special calling convention, which in Visual C++
    is called `__thiscall`. The reason is that every method in a class has a hidden
    parameter called `this`, which is a pointer of the class type to the current instance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法有一种特殊的调用约定，在Visual C++中称为`__thiscall`。原因是类中的每个方法都有一个名为`this`的隐藏参数，它是指向当前实例的类类型的指针：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `get_magnitude` method returns the length of the `cartesian_vector`
    object. The members of the object are accessed through the `->` operator. As shown
    previously, the members of the class can be accessed without the `this` pointer,
    but it does make it explicit that the items are members of the `class`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get_magnitude`方法返回`cartesian_vector`对象的长度。通过`->`运算符访问对象的成员。如前所示，可以在不使用`this`指针的情况下访问类的成员，但这确实明确了这些项是类的成员。
- en: 'You could define a method on the `cartesian_vector` type that allows you to
    change its state:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cartesian_vector`类型上定义一个方法，允许你改变它的状态：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The parameters of the `reset` method have the same names as the data members
    of the class; however, since we use the `this` pointer the compiler knows that
    this is not ambiguous.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`方法的参数与类的数据成员具有相同的名称；然而，由于我们使用了`this`指针，编译器知道这不会产生歧义。'
- en: You can dereference the `this` pointer with the `*` operator to get access to
    the object. This is useful when a member function must return a reference to the
    current object (as some operators will, as we will see later) and you can do this
    by returning `*this`. A method in a class can also pass the `this` pointer to
    an external function, which means that it is passing the current object by reference
    through a typed pointer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`*`运算符对`this`指针进行解引用，以访问对象。当成员函数必须返回对当前对象的引用时（正如我们稍后将看到的一些运算符），这是很有用的，您可以通过返回`*this`来实现。类中的方法还可以将`this`指针传递给外部函数，这意味着它通过类型化指针通过引用传递当前对象。
- en: Using the scope resolution operator
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用作用域解析运算符
- en: 'You can define a method inline in the `class` statement, but you can also separate
    the declaration and implementation, so the method is declared in the `class` statement
    but it is defined elsewhere. When defining a method out of the `class` statement,
    you need to provide the method with the name of the type using the scope resolution
    operator. For example, using the previous `cartesian_vector` example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`语句中可以内联定义一个方法，但也可以分开声明和实现，因此方法在`class`语句中声明，但在其他地方定义。在`class`语句之外定义方法时，需要使用作用域解析运算符为该类型的方法提供名称。例如，使用之前的`cartesian_vector`示例：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method is defined outside the class definition; it is, however, still the
    class method, so it has a `this` pointer that can be used to access the object's
    members. Typically, the class will be declared in a header file with prototypes
    for the methods and the actual methods will be implemented in a separate source
    file. In this case, using the `this` pointer to access the class members (methods
    and data members) make it obvious, when you take a cursory look at a source file,
    that the functions are methods of a class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在类定义之外定义；但是，它仍然是类方法，因此具有`this`指针，可用于访问对象的成员。通常，类将在头文件中声明方法的原型，并且实际方法将在单独的源文件中实现。在这种情况下，使用`this`指针访问类成员（方法和数据成员）使得当您粗略查看源文件时，函数是类的方法是显而易见的。
- en: Defining class state
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类状态
- en: Your class can have built-in types as data members, or custom types. These data
    members can be declared in the class (and created when an instance of the class
    is constructed), or they can be pointers to objects created in the free store
    or references to objects created elsewhere. Bear in mind that if you have a pointer
    to an item created in the free store, you need to know whose responsibility it
    is to deallocate the memory that the pointer points to. If you have a reference
    (or pointer) to an object created on a stack frame somewhere, you need to make
    sure that the objects of your class do not live longer than that stack frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您的类可以具有内置类型作为数据成员，也可以具有自定义类型。这些数据成员可以在类中声明（并在构造类的实例时创建），也可以是指向在自由存储中创建的对象或引用在其他地方创建的对象的指针。请记住，如果您有一个指向在自由存储中创建的项目的指针，您需要知道谁负责释放指针指向的内存。如果您有一个引用（或指针）指向在某个堆栈帧上创建的对象，则需要确保您的类的对象的生存时间不会超过该堆栈帧。
- en: When you declare data members as `public` it means that external code can read
    and write to the data members.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将数据成员声明为`public`时，这意味着外部代码可以读取和写入数据成员。
- en: 'You can decide that you would prefer to only give read-only access, in which
    case you can make the members `private` and provide read access through accessors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以决定只提供只读访问权限，这种情况下，可以将成员设为`private`，并通过访问器提供读取访问权限：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you make the data members `private` it means that you cannot use the initializer
    list syntax to initialize an object, but we will address this later. You may decide
    to use an accessor to give write access to a data member and use this to check
    the value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将数据成员`private`时，这意味着您不能使用初始化程序列表语法来初始化对象，但我们稍后会解决这个问题。您可以决定使用访问器来给数据成员提供写入访问权限，并使用此来检查值。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is for a type where the range of values must be between (but not including)
    -`100` and `100`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种范围必须在（但不包括）-100和100之间的类型。
- en: Creating objects
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'You can create objects on the stack or in the free store. Using the previous
    example, this is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在堆栈或自由存储中创建对象。使用前面的示例，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is **direct initialization** of the object and assumes that the data members
    of `cartesian_vector` are `public`. The `vec` object is created on the stack and
    initialized with an initializer list. In the second line, an object is created
    in the free store and initialized with an initializer list. The object on the
    free store must be freed at some point and this is carried out by deleting the
    pointer. The `new` operator will allocate enough memory in the free store for
    the data members of the class and for any of the infrastructure the class needs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对象的**直接初始化**，假设`cartesian_vector`的数据成员是`public`。`vec`对象在堆栈上创建并使用初始化列表进行初始化。在第二行，对象在自由存储中创建并使用初始化列表进行初始化。自由存储中的对象必须在某个时候被释放，这是通过删除指针来完成的。`new`运算符将为类的数据成员和类所需的任何基础设施在自由存储中分配足够的内存。
- en: 'A new feature of C++11 is to allow direct initialization to provide default
    values in the class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的一个新特性是允许直接初始化以在类中提供默认值：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means that if you create an instance of `point` without any other initialization
    values, it will be initialized so that `x` and `y` are both zero. If the data
    member is a built-in array, then you can provide direct initialization with an
    initialization list in the class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您创建一个`point`实例而没有任何其他初始化值，它将被初始化，以便`x`和`y`都为零。如果数据成员是内置数组，则可以在类中使用初始化列表进行直接初始化：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The C++ Standard Library containers can be initialized with an initialize list,
    so, in this class for `tire_pressures`, instead of declaring the type to be `double[4]`
    we could use `vector<double>` or `array<double,4>`, and initialize it in the same
    way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库容器可以使用初始化列表进行初始化，因此，在这个`tire_pressures`类中，我们可以使用`vector<double>`或`array<double,4>`，并以相同的方式进行初始化，而不是声明类型为`double[4]`。
- en: Construction of objects
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的构造
- en: 'C++ allows you to define special methods to perform the initialization of the
    object. These are called **constructors**. In C++11, you will get three such functions
    generated for you by default, but you can provide your own versions if you wish.
    These three constructors, along with three other related functions, are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许你定义特殊的方法来执行对象的初始化。这些被称为**构造函数**。在C++11中，你将默认获得三个这样的函数，但如果你愿意，你可以提供自己的版本。这三个构造函数以及另外三个相关函数如下：
- en: '**Default constructor:** This is called to create an object with the *default*
    value.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数：这是用来创建一个具有*默认*值的对象。
- en: '**Copy constructor:** This is used to create a new object based on the value
    of an existing object.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数：这用于基于现有对象的值创建一个新对象。
- en: '**Move constructor:** This is used to create a new object using the data moved
    from an existing object.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数：这用于使用从现有对象移动的数据创建新对象。
- en: '**Destructor:** This is called to clean up the resources used by an object.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数：这是用来清理对象使用的资源。
- en: '**Copy assignment:** This copies the data from one existing object into another
    existing object.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制赋值：这将数据从一个现有对象复制到另一个现有对象。
- en: '**Move assignment:** This moves the data from one existing object into another
    existing object.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动赋值：这将数据从一个现有对象移动到另一个现有对象。
- en: The compiler-created versions of these functions will be implicitly `public`;
    however, you may decide to prevent copying or assigning by defining your own versions,
    and making them `private`, or you can delete them using the `=delete` syntax.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的编译器创建的版本将被隐式地设为`public`；然而，你可以决定通过定义自己的版本并将它们设为`private`，或者你可以使用`=delete`语法删除它们，从而阻止复制或赋值。
- en: You can also provide your own constructors that will take any parameters you
    decide you need to initialize a new object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供自己的构造函数，以便使用你决定需要初始化新对象的任何参数。
- en: A constructor is a member function that has the same name as the type, but does
    not return a value, so you cannot return a value if the construction fails, which
    potentially means that the caller will receive a partially constructed object.
    The only way to handle this situation is to throw an exception (explained in [Chapter
    7](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml), *Diagnostics and Debugging*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个与类型同名的成员函数，但它不返回值，所以如果构造失败，你不能返回值，这可能意味着调用者将收到一个部分构造的对象。处理这种情况的唯一方法是抛出异常（在[第7章](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml)中解释，*诊断和调试*）。
- en: Defining constructors
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义构造函数
- en: 'The default constructor is used when an object is created without a value and
    hence the object will have to be initialized with a default value. The `point`
    declared previously could be implemented like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象创建时没有值时，将使用默认构造函数，因此对象将必须用默认值初始化。之前声明的`point`可以这样实现：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This explicitly initializes the items to a value of zero. If you want to create
    an instance with the default values, you do not include parentheses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将明确地将项目初始化为零值。如果你想创建一个具有默认值的实例，你不需要包括括号。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is important to be aware of this syntax because it is easy to write the
    following by mistake:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意这个语法，因为很容易出错地写成以下形式：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will compile because the compiler will think you are providing a function
    prototype as a forward declaration. However, you''ll get an error when you attempt
    to use the symbol `p` as a variable. You can also call the default constructor
    using initialize list syntax with empty braces:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译，因为编译器会认为你提供了一个函数原型作为前向声明。然而，当你尝试使用符号`p`作为变量时，你会得到一个错误。你也可以使用空括号的初始化列表语法调用默认构造函数：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although it does not matter in this case, where the data members are built-in
    types, initializing data members in the body of the constructor like this involves
    a call to the assignment operator of the member type. A more efficient way is
    to use direct initialization with a **member list**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这种情况下并不重要，数据成员是内置类型，但在构造函数体中像这样初始化数据成员涉及到调用成员类型的赋值运算符。更有效的方法是使用**成员列表**进行直接初始化。
- en: 'The following is a constructor that takes two parameters, which illustrates
    a member list:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有两个参数的构造函数，用来说明成员列表：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The identifiers outside the parentheses are the names of class members, and
    the items inside the parentheses are expressions used to initialize that member
    (in this case, a constructor parameter). This example uses `x` and `y` for the
    parameter names. You don''t have to do this; this is only given here as an illustration
    that the compiler will distinguish between the parameters and data members. You
    can also use braced initializer syntax in the member list of a constructor:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 括号外的标识符是类成员的名称，括号内的项目是用来初始化该成员的表达式（在这种情况下是构造函数参数）。这个例子使用`x`和`y`作为参数名。你不必这样做；这里只是给出一个例子，说明编译器将区分参数和数据成员。你也可以在构造函数的成员列表中使用大括号初始化语法：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You call this constructor when you create an object like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像这样创建一个对象时，你调用这个构造函数：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also create an array of objects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个对象数组：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates four `point` objects, which can be accessed by indexing the `arr`
    array. Note that when you create an array of objects the *default* constructor
    is called on the items; there is no way to call any other constructor, and so
    you have to initialize each one separately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建四个`point`对象，可以通过对`arr`数组进行索引访问。请注意，当你创建一个对象数组时，会调用*默认*构造函数；没有办法调用任何其他构造函数，所以你必须分别初始化每一个。
- en: 'You can also provide default values for constructor parameters. In the following
    code, the `car` class has values for the four tires (the first two are the front
    tires) and for the spare tire. There is one constructor that has mandatory values
    that will be used for the front and back tires, and an optional value for the
    spare. If a value is not provided for the spare tire pressure, then a default
    value will be used:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为构造函数参数提供默认值。在下面的代码中，`car`类为四个轮胎（前两个是前轮胎）和备用轮胎设置了值。有一个构造函数具有用于前后轮胎的必需值，并为备用轮胎提供了一个可选值。如果没有为备用轮胎压力提供值，则将使用默认值：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This constructor can be called with either two values or three values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数可以用两个值或三个值来调用：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Delegating constructors
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托构造函数
- en: 'A constructor may call another constructor using the same member list syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以使用相同的成员列表语法调用另一个构造函数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the constructor that takes one value delegates to the constructor that
    takes three parameters (in this case using the default value for the spare).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，接受一个值的构造函数委托给接受三个参数的构造函数（在这种情况下使用备用值）。
- en: Copy constructor
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: 'A copy constructor is used when you pass an object by value (or return by value)
    or if you explicitly construct an object based on another object. The last two
    lines of the following both create a `point` object from another `point` object,
    and in both cases the copy constructor is called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按值传递对象（或按值返回）或者基于另一个对象显式构造对象时，将使用复制构造函数。以下两行都从另一个`point`对象创建了一个`point`对象，而且在这两种情况下都调用了复制构造函数：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last line looks like it involves the assignment operator, but it actually
    calls the copy constructor. The copy constructor could be implemented like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行看起来涉及赋值运算符，但实际上调用了复制构造函数。复制构造函数可以这样实现：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The initialization accesses the `private` data members on another object (`rhs`).
    This is acceptable because the constructor parameter is the same type as the object
    being created. The copy operation may not be as simple as this. For example, if
    the class contains a data member that is a pointer, you will most likely want
    to copy the data that the pointer points to, and this will involve creating a
    new memory buffer in the new object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化访问另一个对象（`rhs`）的`private`数据成员。这是可以接受的，因为构造函数参数与正在创建的对象的类型相同。复制操作可能并不像这样简单。例如，如果类包含一个指针数据成员，您很可能希望复制指针指向的数据，并且这将涉及在新对象中创建一个新的内存缓冲区。
- en: Converting between types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'You can also perform conversions. In math, you can define a vector that represents
    direction, so that the line drawn between two points is a vector. In our code
    we have already defined a `point` class and a `cartesian_vector` class. You could
    decide to have a constructor that creates a vector between the origin and a point,
    in which case you are converting a `point` object to a `cartesian_vector` object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行转换。在数学中，您可以定义一个表示方向的向量，以便两点之间的连线是一个向量。在我们的代码中，我们已经定义了一个`point`类和一个`cartesian_vector`类。您可以决定创建一个构造函数，该构造函数创建原点和一个点之间的向量，这样您就将一个`point`对象转换为一个`cartesian_vector`对象：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is a problem here, which we will address in a moment. The conversions
    can be called like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题，我们马上就会解决。可以这样调用转换：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Making friends
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交朋友
- en: 'The problem with the code above is that the `cartesian_vector` class accesses
    `private` members of the `point` class. Since we have written both classes, we
    are happy to bend the rules, and so we make the `cartesian_vector` class a `friend`
    of the `point` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码的问题在于`cartesian_vector`类访问了`point`类的`private`成员。由于我们已经编写了这两个类，我们很乐意打破规则，因此我们将`cartesian_vector`类声明为`point`类的`friend`：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the `cartesian_vector` class is declared after the `point` class, we have
    to provide a forward declaration that essentially tells the compiler that the
    name `cartesian_vector` is about to be used and it will be declared elsewhere.
    The important line starts with `friend`. This indicates that the code for the
    entire class, `cartesian_vector`, can have access to the private members (data
    and methods) of the `point` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cartesian_vector`类在`point`类之后声明，我们必须提供一个前向声明，告诉编译器名称`cartesian_vector`即将被使用，并且将在其他地方声明。重要的一行以`friend`开头。这表明整个`cartesian_vector`类的代码可以访问`point`类的私有成员（数据和方法）。
- en: 'You can also declare `friend` functions. For example, you could declare an
    operator such that a `point` object can be inserted into the `cout` object, so
    it can be printed to the console. You cannot change the `ostream` class, but you
    can define a global method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明`friend`函数。例如，您可以声明一个运算符，使得`point`对象可以插入到`cout`对象中，以便可以打印到控制台。您不能更改`ostream`类，但可以定义一个全局方法：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function accesses the `private` members of `point` so you have to make
    the function a `friend` of the `point` class with:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数访问`point`的`private`成员，因此您必须将该函数声明为`point`类的`friend`：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Such `friend` declarations have to be declared in the `point` class, but it
    is irrelevant whether it is put in the `public` or `private` section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`friend`声明必须在`point`类中声明，但放在`public`或`private`部分都无关紧要。
- en: Marking constructors as explicit
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将构造函数标记为显式
- en: 'In some cases, you do not want to allow the implicit conversion between one
    type that is passed as a parameter of the constructor of another type. To do this,
    you need to mark the constructor with the `explicit` specifier. This now means
    that the only way to call the constructor is using the parentheses syntax: *explicitly*
    calling the constructor. In the following code, you cannot implicitly convert
    a `double` to an object of `mytype`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您不希望允许将一个类型隐式转换为另一个类型的构造函数的参数。为此，您需要使用`explicit`说明符标记构造函数。这意味着现在唯一调用构造函数的方式是使用括号语法：*显式*调用构造函数。在下面的代码中，您不能将`double`隐式转换为`mytype`的对象：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now you have to *explicitly* call the constructor if you want to create an
    object with a `double` parameter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须*显式*调用构造函数，如果你想要用`double`参数创建一个对象：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Destructing objects
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的销毁
- en: When an object is destroyed, a special method called the destructor is called.
    This method has the name of the class prefixed with a `~` symbol and it does not
    return a value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被销毁时，会调用一个特殊的方法，称为析构函数。这个方法的名称是类的名称前缀加上一个`~`符号，它不返回值。
- en: If the object is an automatic variable, on the stack, then it will be destroyed
    when the variable goes out of scope. When an object is passed by value, a copy
    is made on the called function's stack and the object will be destroyed when the
    called function completes. Furthermore, it does not matter how the function completes,
    whether an explicit call to `return` or reaching the final brace, or if an exception
    is thrown; in all of these cases, the destructor is called. If there are multiple
    objects in a function, the destructors are called in the reverse order to the
    construction of the objects in the same scope. If you create an array of objects,
    then the default constructor is called for each object in the array on the statement
    that declares the array, and all the objects will be destroyed--and the destructor
    on each one is called, when the array goes out of scope.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是一个自动变量，位于堆栈上，那么当变量超出作用域时它将被销毁。当对象按值传递时，在被调用的函数的堆栈上会进行一次复制，当被调用的函数完成时对象将被销毁。此外，函数的完成方式并不重要，无论是显式调用`return`还是达到最终的大括号，或者抛出异常；在所有这些情况下，都会调用析构函数。如果在一个函数中有多个对象，析构函数的调用顺序与在相同作用域中对象的构造顺序相反。如果你创建一个对象数组，那么在声明数组时将为数组中的每个对象调用默认构造函数，并且当数组超出作用域时所有的对象都将被销毁--并且每个对象的析构函数都会被调用。
- en: 'Here are some examples, for a class `mytype`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，对于一个类`mytype`：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An interesting action occurs when you return an object. The following annotation
    is what you would expect:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你返回一个对象时，会发生一个有趣的动作。以下注释是你所期望的：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In fact, the process is more streamlined. In a debug build, the compiler will
    see that the temporary object created on the return of the `get_object` function
    is the object that will be used as the variable `tt`, and so there is no extra
    copy on the return value of the `get_object` function. The function actually looks
    like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个过程更加简化。在调试构建中，编译器会看到在`get_object`函数返回时创建的临时对象将作为变量`tt`使用的对象，因此在`get_object`函数的返回值上不会有额外的复制。函数实际上看起来是这样的：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, the compiler is able to optimize the code further. In a release build
    (with optimizations enabled), the temporary will not be created and the object
    `tt` in the calling function will be the actual object `t` created in `get_object`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器能够进一步优化代码。在发布构建中（启用了优化），临时对象将不会被创建，调用函数中的对象`tt`将是在`get_object`中创建的实际对象`t`。
- en: 'An object will be destroyed when you explicitly delete a pointer to an object
    allocated on the free store. In this case, the call to the destructor is deterministic:
    it is called when your code calls `delete`. Again, with the same class `mytype`,
    this is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显式删除在自由存储上分配的对象的指针时，对象将被销毁。在这种情况下，对析构函数的调用是确定的：当你的代码调用`delete`时会被调用。同样，对于相同的类`mytype`，这是如下的：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There will be times when you want to use the deterministic aspect of deleting
    an object (with the possible danger of forgetting to call `delete`) and there
    will be times when you prefer to have the reassurance that an object is to be
    destroyed at an appropriate time (with the potential that it may be much later
    in time).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会希望使用删除对象的确定性方面（可能会忘记调用`delete`的危险），有时你会更喜欢在适当的时间销毁对象的保证（可能会在以后的时间）。
- en: If a data member in a class is a custom type with a destructor, then when the
    containing object is destroyed the destructors on the contained objects are called
    too. Nonetheless, note that this is only if the *object* is a class member. If
    a class member is a pointer to an object in the free store, then you have to explicitly
    delete the pointer in the containing object's destructor. However, you need to
    know where the object the pointer points to is because if it is not in the free
    store, or if the object is used by other objects, calling `delete` will cause
    problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类的数据成员是一个带有析构函数的自定义类型，那么当包含对象被销毁时，也会调用包含对象上的析构函数。尽管如此，请注意这仅适用于*对象*是类成员的情况。如果一个类成员是指向自由存储中的对象的指针，那么你必须在包含对象的析构函数中显式删除指针。然而，你需要知道指针指向的对象在哪里，因为如果它不在自由存储中，或者对象被其他对象使用，调用`delete`会引起问题。
- en: Assigning objects
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配对象
- en: The assignment operator is called when an *already created* object is assigned
    to the value of another one. By default, you will get a copy assignment operator
    that will copy all the data members. This is not necessarily what you want, particularly
    if the object has a data member that is a pointer, in which case your intention
    is more likely to do a deep copy and copy the data pointed to rather than the
    value of the pointer (in the latter case, *two* objects will point to the same
    data).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符在将一个*已经创建*的对象分配给另一个值时被调用。默认情况下，你会得到一个复制赋值运算符，它将复制所有的数据成员。这不一定是你想要的，特别是如果对象有一个数据成员是指针的情况下，此时你更有可能想要进行深拷贝，复制指向的数据而不是指针的值（在后一种情况下，*两个*对象将指向相同的数据）。
- en: If you define a copy constructor, you will still get the default copy assignment
    operator; however, it makes sense that if you regard it important to write your
    own copy constructor, you should also provide a custom copy assignment operator.
    (Similarly, if you define a copy assignment operator, you will get the default
    copy constructor unless you define it.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个复制构造函数，你仍然会得到默认的复制赋值运算符；然而，如果你认为编写自己的复制构造函数很重要，那么你也应该提供一个自定义的复制赋值运算符。
    （同样，如果你定义了一个复制赋值运算符，你将得到默认的复制构造函数，除非你定义它。）
- en: 'The copy assignment operator is typically a `public` member of the class and
    it takes a `const` reference to the object that will be used to provide the values
    for the assignment. The semantics of the assignment operator are that you can
    chain them, so, for example, this code calls the assignment operator on two of
    the objects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值运算符通常是类的`public`成员，并且它接受一个用于提供赋值值的对象的`const`引用。赋值运算符的语义是可以链式调用的，所以，例如，这段代码调用了两个对象上的赋值运算符：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last two lines do the same thing, but clearly the first is more readable.
    To enable these semantics, the assignment operator must return a reference to
    the object that has been assigned. So, the class `buffer` will have the following
    method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行做了同样的事情，但显然第一行更易读。为了启用这些语义，赋值运算符必须返回一个被赋值的对象的引用。因此，类`buffer`将有以下方法：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although the copy constructor and copy assignment methods appear to do similar
    things, there is a key difference. A copy constructor creates a new object that
    did not exist before the call. The calling code is aware that if the construction
    fails, then an exception will be raised. With assignment, both objects already
    exist, so you are copying the value from one object to another. This should be
    treated as an atomic action and all the copy should be performed; it is not acceptable
    for the assignment to fail halfway through, resulting in an object that is a bit
    of both objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管复制构造函数和复制赋值方法看起来做了类似的事情，但有一个关键的区别。复制构造函数创建了一个之前不存在的新对象。调用代码知道如果构造失败，那么将会引发异常。而赋值操作中，两个对象已经存在，所以你是将一个对象的值复制到另一个对象。这应该被视为一个原子操作，并且所有的复制都应该被执行；赋值在中途失败，导致一个对象是两个对象的一部分，是不可接受的。
- en: Furthermore, in construction, an object only exists after the construction is
    successful, so a copy construction cannot happen on an object itself, but it is
    perfectly legal (if pointless) for code to assign an object to itself. The copy
    assignment needs to check for this situation and take appropriate action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在构造中，对象只有在构造成功后才存在，所以复制构造不能发生在对象本身上，但是对于代码将对象分配给自身是完全合法的（尽管毫无意义）。复制赋值需要检查这种情况并采取适当的行动。
- en: There are various strategies to do this, and a common one is called the copy-and-swap
    idiom because it uses the Standard Library `swap` function that is marked as `noexcept`,
    and will not throw an exception. The idiom involves creating a temporary copy
    of the object on the right-hand side of the assignment and then swapping its data
    members with the data members of the object on the left-hand side.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种策略可以做到这一点，一个常见的策略被称为复制和交换惯用法，因为它使用了标记为`noexcept`的标准库`swap`函数，并且不会抛出异常。这种惯用法涉及在赋值右侧的对象上创建一个临时副本，然后交换它的数据成员与左侧对象的数据成员。
- en: Move semantics
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动语义
- en: C++11 provides move semantics through a move constructor and a move assignment
    operator, which are called when a temporary object is used either to create another
    object or to be assigned to an existing object. In both cases, because the temporary
    object will not live beyond the statement, the contents of the temporary can be
    moved to the other object, leaving the temporary object in an invalid state. The
    compiler will create these functions for you through the default action of moving
    the data from the temporary to the newly created (or the assigned to) object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过移动构造函数和移动赋值运算符提供了移动语义，当临时对象被用来创建另一个对象或被赋值给现有对象时，这些函数将被调用。在这两种情况下，因为临时对象不会在语句之后存在，临时对象的内容可以被移动到另一个对象，使得临时对象处于无效状态。编译器将通过默认操作从临时对象中移动数据到新创建的（或被赋值的）对象中创建这些函数。
- en: You can write your own versions, and to indicate move semantics these have a
    parameter that is an rvalue reference (`&&`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的版本，并且为了指示移动语义，这些版本有一个rvalue引用（`&&`）作为参数。
- en: If you want the compiler to provide you with a default version of any of these
    methods, you can provide the prototype in the class declaration suffixed with
    `=default`. In most cases, this is self-documenting rather than being a requirement,
    but if you are writing a POD class you must use the default versions of these
    functions, otherwise `is_pod` will not return `true`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望编译器为你提供这些方法的默认版本，你可以在类声明中提供带有`=default`后缀的原型。在大多数情况下，这是自说明的，而不是一个要求，但如果你正在编写一个POD类，你必须使用这些函数的默认版本，否则`is_pod`将不会返回`true`。
- en: 'If you want to use only move and never to use copy (for example, a file handle
    class), then you can *delete* the copy functions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想使用移动而不使用复制（例如，文件句柄类），那么你可以*删除*复制函数：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This class has a pointer data member and allows move semantics, in which case
    the move constructor will be called with a reference to a temporary object. Since
    the object is temporary, it will not survive after the move constructor call.
    This means that the new object can *move* the state of the temporary object into
    itself:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个指针数据成员，并允许移动语义，这种情况下移动构造函数将被调用，参数是一个临时对象的引用。由于对象是临时的，它在移动构造函数调用之后不会存在。这意味着新对象可以*移动*临时对象的状态到自身：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The move constructor assigns the temporary object's pointer to `nullptr`, so
    that any destructor defined for the class does not attempt to delete the pointer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数将临时对象的指针赋值为`nullptr`，这样，为类定义的任何析构函数都不会尝试删除指针。
- en: Declaring static members
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明静态成员
- en: You can declare a member of a class--a data member or a method--`static`. This
    is similar in some ways to how you use the `static` keyword on automatic variables
    and functions declared at file scope, but there are some important, and different,
    properties to this keyword when used on a class member.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个类的成员——数据成员或方法——为`static`。这在某些方面类似于在自动变量和文件作用域声明的函数上使用`static`关键字，但是当在类成员上使用这个关键字时，有一些重要的不同之处。
- en: Defining static members
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义静态成员
- en: When you use `static` on a class member it means that the item is associated
    with the class and not with a specific instance. In the case, of data members,
    this means that there is one data item shared by all instances of the class. Likewise,
    a `static` method is not attached to an object, it is not `__thiscall` and has
    no `this` pointer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类成员上使用`static`时，表示该项与类相关联，而不是与特定实例相关联。对于数据成员，这意味着所有类的实例共享一个数据项。同样，静态方法不附加到对象，它不是`__thiscall`，也没有`this`指针。
- en: A `static` method is part of the namespace of a class, so it can create objects
    for the class and have access to their `private` members. A `static` method has
    the `__cdecl` calling convention by default, but you can declare it as `__stdcall`
    if you wish. This means that, you can write a method within the class that can
    be used to initialize C-like pointers, which are used by many libraries. Note
    that the `static` function cannot call nonstatic methods on the class because
    a nonstatic method will need a `this` pointer, but a nonstatic method can call
    a `static` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法是类的命名空间的一部分，因此它可以为类创建对象并访问它们的`private`成员。静态方法默认具有`__cdecl`调用约定，但如果需要，可以声明为`__stdcall`。这意味着，可以编写一个在类中用于初始化许多库使用的C样式指针的方法。请注意，静态函数不能调用类的非静态方法，因为非静态方法需要`this`指针，但非静态方法可以调用静态方法。
- en: A nonstatic method is called through an object, either using the dot operator
    (for a class instance) or the `->` operator for an object pointer. A `static`
    method does not need an associated object, but it can be called through one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态方法通过对象调用，可以使用点运算符（对于类实例）或`->`运算符（对于对象指针）。静态方法不需要关联对象，但可以通过对象调用。
- en: 'This gives two ways to call a `static` method, through an object or through
    the `class` name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了两种调用静态方法的方式，通过对象或通过`class`名称：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the class defines a `static` method called `f` and a nonstatic method
    called `g`. The nonstatic method `g` can call the `static` method, but the `static`
    method `f` cannot call the nonstatic method. Since the `static` method `f` is
    `public`, code outside the `class` can call it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类定义了一个名为`f`的静态方法和一个名为`g`的非静态方法。非静态方法`g`可以调用静态方法，但静态方法`f`不能调用非静态方法。由于静态方法`f`是`public`的，类外部的代码可以调用它。
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although the `static` function can be called through an object, you do not have
    to create any objects at all to call it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过对象调用静态函数，但您不必创建任何对象来调用它。
- en: 'Static data members need a bit more work because when you use `static` it indicates
    that the data member is not part of an object, and usually data members are allocated
    when an object is created. You have to define `static` data members outside of
    the class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据成员需要更多的工作，因为当使用`static`时，表示数据成员不是对象的一部分，通常在创建对象时分配数据成员。必须在类外定义`static`数据成员：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The data member is defined outside of the class at file scope. It is named using
    the `class` name, but note that it also has to be defined using the type. In this
    case the data member is initialized with a value; if you do not do this, then
    on the first use of the variable it will have the default value of the type (in
    this case, zero). If you choose to declare the class in a header file (which is
    common), the definition of the `static` data members must be in a source file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员在类外部的文件作用域中定义。它使用`class`名称命名，但请注意，它也必须使用类型进行定义。在这种情况下，数据成员使用一个值进行初始化；如果不这样做，那么在首次使用变量时，它将具有类型的默认值（在这种情况下为零）。如果选择在头文件中声明类（这是常见的做法），则`static`数据成员的定义必须在源文件中。
- en: You can also declare a variable in a method that is `static`. In this case,
    the value is maintained across method calls, in all objects, so it has the same
    effect as a `static class` member, but you do not have the issue of defining the
    variable outside of the class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在方法中声明一个`static`变量。在这种情况下，该值在所有对象的方法调用之间保持不变，因此它具有与`static class`成员相同的效果，但不需要在类外部定义变量的问题。
- en: Using static and global objects
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态和全局对象
- en: A `static` variable in a global function will be created at some point before
    the function is first called. Similarly, a `static` object that is a member of
    a class will be initialized at some point before it is first accessed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数中的静态变量将在该函数首次调用之前的某个时刻创建。同样，作为类成员的静态对象将在首次访问之前的某个时刻初始化。
- en: Static and global objects are constructed before the `main` function is called,
    and destroyed after the `main` function finishes. The order of this initialization
    has some issues. The C++ standard says that the initialization of `static` and
    global objects defined in a source file will occur before any function or object
    defined in that source file is used, and if there are several global objects in
    a source file, they will be initialized in the order that they are *defined*.
    The issue is if you have several source files with `static` objects in each. There
    is no guarantee on the order in which these objects will be initialized. It becomes
    a problem if one `static` object depends on another `static` object because you
    cannot guarantee that the dependent object will be created after the object it
    depends upon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和全局对象在调用`main`函数之前构造，并在`main`函数结束后销毁。这种初始化的顺序存在一些问题。C++标准规定，源文件中定义的静态和全局对象的初始化将在使用该源文件中的任何函数或对象之前发生，如果一个源文件中有多个全局对象，则它们将按照它们被*定义*的顺序进行初始化。问题在于如果有几个源文件中都有静态对象。在这种情况下，无法保证这些对象的初始化顺序。如果一个静态对象依赖于另一个静态对象，那么就会出现问题，因为无法保证依赖对象在所依赖的对象之后创建。
- en: Named constructors
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名构造函数
- en: 'This is one application for `public static` methods. The idea is that since
    the `static` method is a member of the `class` it means that it has access to
    the `private` members of an instance of the `class`, so such a method can create
    an object, perform some additional initialization, and then return the object
    to the caller. This is a **factory method**. The `point` class used so far has
    been constructed using Cartesian points, but we could also create a point based
    on polar co-ordinates, where the `(x, y)` Cartesian co-ordinates can be calculated
    as:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`public static`方法的一个应用。其思想是，由于`static`方法是`class`的成员，这意味着它可以访问`class`实例的`private`成员，因此这样的方法可以创建一个对象，执行一些额外的初始化，然后将对象返回给调用者。这是一个**工厂方法**。到目前为止使用的`point`类是使用笛卡尔坐标构建的，但我们也可以基于极坐标创建一个点，其中`(x,
    y)`的笛卡尔坐标可以计算为：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here `r` is the length of the vector to the point and `theta` is the angle
    of this vector counter-clockwise to the x axis. The `point` class already has
    a constructor that takes two `double` values, so we cannot use this to pass polar
    co-ordinates; instead, we can use a `static` method as a *named constructor*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`r`是到点的向量长度，`theta`是该向量逆时针到x轴的角度。`point`类已经有一个接受两个`double`值的构造函数，因此我们不能使用它来传递极坐标；相反，我们可以使用一个`static`方法作为*命名构造函数*：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The method can be called like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样调用该方法：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The object `p11` is the `point` with the Cartesian co-ordinates of (1,1). In
    this example the `polar` method calls a `public` constructor, but it has access
    to private members, so the same method could be written (less efficiently) as:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`p11`是具有笛卡尔坐标(1,1)的`point`。在这个例子中，`polar`方法调用了一个`public`构造函数，但它可以访问私有成员，所以同样的方法也可以写成（效率较低）：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Nested classes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类
- en: 'You can define a class within a class. If the nested class is declared as `public`,
    then you can create objects in the container class and return them to external
    code. Typically, however, you will want to declare a class that is used by the
    class and should be `private`. The following declares a `public` nested class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在类内定义一个类。如果嵌套类声明为`public`，那么您可以在容器类中创建对象并将它们返回给外部代码。然而，通常情况下，您会希望声明一个被类使用并且应该是`private`的类。以下声明了一个`public`的嵌套类：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how the name of the nested class is prefixed with the name of the containing
    class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意嵌套类的名称是以包含类的名称作为前缀的。
- en: Accessing const objects
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问const对象
- en: 'You have seen many examples so far of using `const`, and perhaps the most frequent
    is when it is applied to a reference as a function parameter to indicate to the
    compiler that the function only has read-only access to the object. Such a `const`
    reference is used so that objects are passed by reference to avoid the overhead
    of the copying that would occur if the object were passed by value. Methods on
    a `class` can access the object data members and, potentially, can change them,
    so if you pass an object through a `const` reference the compiler will only allow
    the reference to call methods that do not change the object. The `point` class
    defined earlier had two accessors to access the data in the class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了许多使用`const`的例子，也许最常见的是将其应用于引用作为函数参数，以指示编译器函数只对对象具有只读访问权限。这样的`const`引用用于通过引用传递对象，以避免通过值传递对象时会发生的复制开销。`class`上的方法可以访问对象数据成员，并且可能会改变它们，因此如果通过`const`引用传递对象，编译器将只允许引用调用不改变对象的方法。之前定义的`point`类有两个访问器来访问类中的数据：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you define a function that takes a `const` reference to this and you attempt
    to call these accessors, you will get an error from the compiler:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义一个函数，该函数接受对此的`const`引用，并尝试调用这些访问器，您将会收到来自编译器的错误：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The error from the compiler is a bit obscure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的错误有点晦涩：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This message is the compiler complaining that the object is `const`, it is
    immutable, and it does not know whether these methods will preserve the state
    of the object. The solution is simple--add the `const` keyword to methods that
    do not change the object state, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息是编译器抱怨对象是`const`，它是不可变的，并且它不知道这些方法是否会保持对象的状态。解决方法很简单--对不改变对象状态的方法添加`const`关键字，就像这样：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This effectively means that the `this` pointer is `const`. The `const` keyword
    is part of the function prototype, so the method can be overloaded on this. You
    can have one method that is called when it is called on a `const` object and another
    called on a non-const object. This enables you to implement a copy-on-write pattern
    where, for example, a `const` method would return read-only access to the data
    and the non-const method would return a *copy* of the data that is writeable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着`this`指针是`const`。`const`关键字是函数原型的一部分，因此该方法可以在此上进行重载。您可以有一个方法，当它在`const`对象上调用时被调用，另一个方法在非`const`对象上被调用。这使您能够实现写时复制模式，例如，`const`方法将返回对数据的只读访问，而非`const`方法将返回可写的数据的*副本*。
- en: Of course, a method marked with `const` must not alter the data members, not
    even temporarily. So, such a method can only call `const` methods. There may be
    rare cases when a data member is designed to be changed through a `const` object;
    in this case the declaration of the member is marked with the `mutable` keyword.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，标记为`const`的方法不能改变数据成员，甚至是暂时的。因此，这样的方法只能调用`const`方法。也许有一些罕见的情况，数据成员被设计为可以通过`const`对象进行更改；在这种情况下，成员的声明会标记为`mutable`关键字。
- en: Using objects with pointers
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针与对象
- en: Objects can be created on the free store and accessed through a typed pointer.
    This gives more flexibility because it is efficient to pass pointers to functions,
    and you can explicitly determine the lifetime of the object because an object
    is created with the call to `new` and destroyed by the call to `delete`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以在自由存储器上创建，并通过类型化指针进行访问。这样做更加灵活，因为将指针传递给函数是高效的，并且您可以明确确定对象的生命周期，因为对象是通过`new`调用创建的，并且通过`delete`调用销毁的。
- en: Getting pointers to object members
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对象成员的指针
- en: 'If you need to get access to the address of a class data member through an
    instance (assuming the data member is `public`), you simply use the `&` operator:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要通过实例访问类数据成员的地址（假设数据成员是`public`），你只需使用`&`运算符：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case `struct` is used to declare `point` so that the members are `public`
    by default. The second line uses an initialization list to construct a `point`
    object with two values, and then the final line gets a pointer to one of the data
    members. Of course, the pointer cannot be used after the object has been destroyed.
    Data members are allocated in memory (in this case on the stack), so the address
    operator merely gets a pointer to that memory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`struct`用于声明`point`，以便成员默认为`public`。第二行使用初始化列表构造了一个具有两个值的`point`对象，然后最后一行获取了一个数据成员的指针。当然，在对象被销毁后，指针不能再使用。数据成员被分配在内存中（在这种情况下是在堆栈上），因此地址运算符只是获取指向该内存的指针。
- en: 'Function pointers are a different case. There will only be one copy of the
    method in memory, regardless of how many instances of the `class` are created,
    but because methods are called using the `__thiscall` calling convention (with
    a hidden `this` parameter) you have to have a function pointer that can be initialized
    with a pointer to an object to provide the `this` pointer. Consider this `class`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针是一个不同的情况。无论创建了多少个`class`的实例，内存中只会有一个方法的副本，但是因为方法使用`__thiscall`调用约定（带有隐藏的`this`参数），所以你必须有一个函数指针，它可以用对象的指针初始化，以提供`this`指针。考虑这个`class`：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can define a function pointer to the `get_magnitude` method like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义一个指向`get_magnitude`方法的函数指针：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first line declares a function pointer. This is similar to the C function
    pointer declarations except that there is an inclusion of the `class` name in
    the pointer type. This is needed so that the compiler knows that it has to provide
    a `this` pointer in any call through this pointer. The second line obtains a pointer
    to the method. Notice that no object is involved. You are not getting a function
    pointer to a method on an object; you are getting a pointer to a method on a `class`
    that must be called through an object. To call the method through this pointer,
    you need to use the pointer to the member operator `.*` on an object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了一个函数指针。这类似于C函数指针声明，只是在指针类型中包含了`class`名称。这是必要的，这样编译器就知道在通过这个指针调用时必须提供一个`this`指针。第二行获取了一个指向该方法的指针。注意没有涉及到任何对象。你不是获取一个对象上的方法的函数指针；你是获取一个必须通过对象调用的`class`上的方法的指针。要通过这个指针调用方法，你需要在对象上使用成员指针运算符`.*`：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first line creates an object and the second line calls the method. The
    pointer to the member operator says that the function pointer on the *right* is
    called with the object on the *left*. The address of the object on the left is
    used for the `this` pointer when the method is called. As this is a method, we
    need to provide a parameter list, which in this case is empty (if you have parameters,
    they would be in the pair of parentheses on the right of this statement). If you
    have an object pointer, then the syntax is similar, but you use the `->*` pointer
    to the member operator:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个对象，第二行调用了该方法。成员指针运算符表示右侧的函数指针将与左侧的对象一起调用。在调用方法时，左侧的对象的地址将用作`this`指针。由于这是一个方法，我们需要提供一个参数列表，在这种情况下是空的（如果你有参数，它们将在该语句右侧的括号中）。如果你有一个对象指针，那么语法是类似的，但是你使用`->*`成员指针运算符：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Operator overloading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'One of behaviors of a type is the operations you can apply to it. C++ allows
    you to overload the C++ operators as part of a class so that it''s clear that
    the operator is acting upon the type. This means that for a unary operator the
    member method should have no parameters and for a binary operator you need only
    one parameter, since the current object will be on the left of the operator, and
    hence the method parameter is the item on the right. The following table summarizes
    how to implement unary and binary operators, and four exceptions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的行为之一是可以应用于它的操作。C++允许你在类的一部分中重载C++运算符，以便清楚地表明运算符是作用于该类型的。这意味着对于一元运算符，成员方法不应该有参数，而对于二元运算符，你只需要一个参数，因为当前对象将位于运算符的左侧，因此方法参数是右侧的项目。以下表总结了如何实现一元和二元运算符，以及四个例外情况：
- en: '| **Expression** | **Name** | **Member method** | **Non-member function** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '**表达式** | **名称** | **成员方法** | **非成员函数** |'
- en: '| +a/-a | Prefix unary | operator() | operator(a) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| +a/-a | 前缀一元 | operator() | operator(a) |'
- en: '| a, b | Binary | operator(b) | operator(a,b) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| a, b | 二元 | operator(b) | operator(a,b) |'
- en: '| a+/a- | Postfix unary | operator(0) | operator(a,0) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| a+/a- | 后缀一元 | operator(0) | operator(a,0) |'
- en: '| a=b | Assignment | operator=(b) |  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| a=b | 赋值 | operator=(b) |  |'
- en: '| a(b) | Function call | operator()(b) |  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| a(b) | 函数调用 | operator()(b) |  |'
- en: '| a[b] | Indexing | operator[](b) |  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| a[b] | 索引 | operator[](b) |  |'
- en: '| a-> | Pointer access | operator->() |  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| a-> | 指针访问 | operator->() |  |'
- en: Here the ■ symbol is used to indicate any of the acceptable unary or binary
    operators except for the four operators mentioned in the table.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的■符号用于表示除表中提到的四个运算符之外的任何可接受的一元或二元运算符。
- en: There are no strict rules over what an operator should return, but it helps
    if an operator on a custom type behaves like operators on a built-in type. There
    also has to be some consistency. If you implement the `+` operator to add two
    objects together, then the same plus action should be used for the `+=` operator.
    Also, you could argue that the plus action will also determine what the minus
    action should be like, and hence the `-` and `-=` operators. Similarly, if you
    want to define the `<` operator, then you should define `<=. >`, `>=`, `==`, and
    `!=` too.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运算符应该返回什么并没有严格的规定，但是如果自定义类型的运算符的行为类似于内置类型的运算符，那么会有所帮助。还必须有一些一致性。如果你实现了`+`运算符来将两个对象相加，那么`+=`运算符应该使用相同的加法操作。同样，你可以说加法操作也将决定减法操作应该是什么样的，因此`-`和`-=`运算符。同样，如果你想定义`<`运算符，那么你应该也定义`<=`、`>`、`>=`、`==`和`!=`。
- en: The Standard Library's algorithms (for example, `sort`) will only expect the
    `<` operator to be defined on a custom type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的算法（例如`sort`）只会期望在自定义类型上定义`<`操作符。
- en: 'The table shows that you can implement almost all the operators as either a
    member of the custom type class or as a global function (with the exception of
    the four listed that have to be member methods). In general, it is best to implement
    the operator as part of the class because it maintains encapsulation: the member
    function has access to the non-public members of the class.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表格显示，你可以将几乎所有的操作符实现为自定义类型类的成员或全局函数（除了那四个必须是成员方法的）。一般来说，最好将操作符作为类的一部分来实现，因为它保持了封装性：成员函数可以访问类的非公共成员。
- en: 'An example of a unary operator is the unary negative operator. This usually
    does not alter an object but returns a new object that is the *negative* of the
    object. For our `point class`, this means making both co-ordinates negative, which
    is equivalent to a mirror of the Cartesian point in a line *y = -x*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符的一个例子是一元负号操作符。这通常不会改变一个对象，而是返回一个新的对象，这个对象是原对象的*负值*。对于我们的`point class`来说，这意味着将两个坐标都变成负数，这相当于在直线*y=-x*上对笛卡尔点进行镜像：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The operator is declared as `const` because it''s clear the operator does not
    change the object and hence it''s safe to be called on a `const` object. The operator
    can be called like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符声明为`const`，因为明显这个操作符不会改变对象，因此在`const`对象上调用是安全的。操作符可以这样调用：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To understand why we have implemented the operator like this, review what the
    unary operator would do when applied to a built-in type. The second statement
    here, `int i, j=0; i = -j;`, will only alter `i` and will not alter `j`, so the
    member `operator-` should not affect the value of the object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么我们要像这样实现操作符，回顾一下当应用于内置类型时一元操作符会做什么。这里的第二个语句，`int i, j=0; i = -j;`，只会改变`i`，不会改变`j`，所以成员`operator-`不应该影响对象的值。
- en: 'The binary negative operator has a different meaning. First, it has two operands,
    and, second, in this example, the result is a different type to the operands because
    the result is a vector that indicates a direction by taking one point away from
    another. Assuming that the `cartesian_vector` is already defined with a constructor
    that has two parameters, then we can write:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 二元负号操作符有不同的含义。首先，它有两个操作数，其次，在这个例子中，结果是一个不同类型的操作数，因为结果是一个向量，通过将一个点从另一个点中取出来来表示一个方向。假设`cartesian_vector`已经定义了一个有两个参数的构造函数，那么我们可以这样写：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The increment and decrement operators have a special syntax because they are
    unary operators that can be prefixed or postfixed, and they alter the object they
    are applied to. The major difference between the two operators is that the postfixed
    operator returns the value of the object *before* the increment/decrement action,
    so a temporary has to be created. For this reason, the prefix operator almost
    always has better performance than the postfix operator. In a class definition,
    to distinguish between the two, the prefix operator has no parameters and the
    postfix operator has a dummy parameter (in the preceding table, 0 is given). For
    a class `mytype`, this is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量操作符有特殊的语法，因为它们是可以前置或后置的一元操作符，并且它们会改变被应用的对象。两个操作符之间的主要区别在于后置操作符返回增量/减量操作之前的对象的值，因此需要创建一个临时对象。因此，前置操作符几乎总是比后置操作符性能更好。在类定义中，为了区分这两者，前置操作符没有参数，后置操作符有一个虚拟参数（在前面的表中，给出了0）。对于一个类`mytype`，这是这样的：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The actual increment code is implemented by the prefix operator, and this logic
    is used by the postfix operator through an explicit call to the method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的增量代码是由前置操作符实现的，并且后置操作符通过显式调用该方法来使用这个逻辑。
- en: Defining function classes
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数类
- en: 'A functor is a class that implements the `()` operator. This means that you
    can call an object using the same syntax as a function. Consider this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是一个实现了`()`操作符的类。这意味着你可以使用与调用函数相同的语法来调用一个对象。考虑这个：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This code can be called like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以这样调用：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code shows that the functor object not only provides some behavior (in
    this case, performing an action on the parameter) but it also can have a state.
    The preceding two lines are called through the `operator()` method on an object:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表明，函数对象不仅提供了一些行为（在这种情况下，在参数上执行一个动作），而且它也可以有一个状态。前面两行是通过对象上的`operator()`方法调用的。
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Look at the syntax. The functor object is called as if it is a function declared
    like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 看语法。函数对象被调用就好像它是这样声明的一个函数：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Imagine that you want to pass a pointer to a function--perhaps you are want
    the function''s behavior to be altered by external code. To be able to use either
    a functor or a method pointer, you need to overload your function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要传递一个指向函数的指针--也许你希望函数的行为可以被外部代码改变。为了能够使用函数对象或者方法指针，你需要重载你的函数：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first takes a reference to a functor object. The second has a C-type function
    pointer (to which you can pass a pointer to `multiply_by_3`) and is quite unreadable.
    In both cases the `fn` parameter is called in the same way in the implementation
    code, but you need to declare two functions because they are different types.
    Now, consider the magic of function templates:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个接受一个函数对象的引用。第二个有一个C类型的函数指针（你可以传递一个指向`multiply_by_3`的指针），并且相当难以阅读。在这两种情况下，`fn`参数在实现代码中以相同的方式被调用，但你需要声明两个函数，因为它们是不同的类型。现在，考虑函数模板的魔力：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is generic code; the `Fn` type can be a C function pointer or a functor
    `class`, and the compiler will generate the appropriate code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用代码；`Fn`类型可以是C函数指针或者函数对象`class`，编译器会生成适当的代码。
- en: This code can be called by either passing a function pointer to a global function,
    which will have the `__cdecl` calling convention, or a functor object where the
    `operator()` operator will be called, which has a `__thiscall` calling convention.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过传递一个函数指针到一个全局函数，该函数将具有`__cdecl`调用约定，或者一个函数对象，其中将调用`operator()`运算符，该运算符具有`__thiscall`调用约定。
- en: This is a mere implementation detail, but it does mean that you can write a
    generic function that can take either a C-like function pointer or a functor object
    as a parameter. The C++ Standard Library uses this magic, which means that the
    algorithms it provides can be called either with a *global function* or a *functor*,
    or a *lambda expression*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个实现细节，但这意味着你可以编写一个通用函数，可以接受C风格的函数指针或函数对象作为参数。C++标准库使用了这个魔法，这意味着它提供的算法可以被调用，要么使用*全局函数*，要么使用*函数对象*，要么使用*lambda表达式*。
- en: The Standard Library algorithms use three type of functional classes, generators,
    and unary and binary functions; that is, functions with zero, one or two parameters.
    In addition, the Standard Library calls a function object (unary or binary) that
    returns a `bool` **predicate**. The documentation will tell you if a predicate,
    unary, or binary function is needed. Older versions of the Standard Library needed
    to know the types of the return value and parameters (if any) of the function
    object to work, and, for this reason, functor classes had to be based upon the
    standard classes, `unary_function` and `binary_function`. In C++11, this requirement
    has been removed, so there is no requirement to use these classes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库算法使用三种类型的函数类、生成器和一元和二元函数；也就是说，具有零、一个或两个参数的函数。此外，标准库调用一个返回`bool`的函数对象（一元或二元）**谓词**。文档将告诉你是否需要谓词、一元或二元函数。旧版本的标准库需要知道函数对象的返回值和参数（如果有的话）的类型，因此，函数对象类必须基于标准类`unary_function`和`binary_function`。在C++11中，这个要求已经被移除，因此没有必要使用这些类。
- en: 'In some cases, you will want to use a binary functor when a unary functor is
    required. For example, the Standard Library defines the `greater` class that,
    when used as a function object, takes two parameters and a `bool` to determine
    whether the first parameter is greater than the second one, using the `operator>`
    defined by the type of both parameters. This will be used for functions that need
    a binary functor, and hence the function will compare two values; for example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当需要一个一元函数时，你可能会想要使用一个二元函数。例如，标准库定义了`greater`类，当作为函数对象使用时，它接受两个参数和一个`bool`来确定第一个参数是否大于第二个参数，使用两个参数的类型定义的`operator>`。这将用于需要二元函数的函数，因此函数将比较两个值；例如：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This takes two collections and compares corresponding items using the functor
    passed as the last parameter. It can be called like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个集合，并使用作为最后一个参数传递的函数对象比较相应的项目。可以这样调用它：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `greater` functor class is defined in the `<functional>` header and compares
    two numbers using the `operator>` defined for the type. What if you wanted to
    compare the items in a container with a fixed value; that is, when the `operator()(double,
    double)` method on the functor is called, one parameter always has a fixed value?
    One option is to define a stateful functor class (as shown previously) so that
    the fixed value is a member of the functor object. Another way to do this is to
    fill another `vector` with the fixed value and continue to compare two `vector`s
    (this can get quite expensive for large `vector`s).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`greater`函数对象类在`<functional>`头文件中定义，使用定义为该类型的`operator>`比较两个数字。如果你想要比较容器中的项目和一个固定值；也就是说，当函数对象的`operator()(double,
    double)`方法被调用时，一个参数总是有一个固定的值？一种选择是定义一个有状态的函数对象类（如前面所示），使得固定值成为函数对象的成员。另一种方法是用固定值填充另一个`vector`，并继续比较两个`vector`（对于大的`vector`来说，这可能会变得非常昂贵）。'
- en: 'Another way is to reuse the functor class, but to *bind* a value to one of
    its parameters. A version of the `compare_vals` function can be written like this,
    to take just one `vector`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是重用函数对象类，但将一个值*绑定*到它的一个参数上。可以像这样编写`compare_vals`函数的一个版本，只接受一个`vector`：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The code is written to call the functor parameter on just one value because
    it is assumed that the functor object contains the other value to compare. This
    is carried out by binding the functor class to the parameter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被编写为在一个值上调用函数对象参数，因为假设函数对象包含另一个要比较的值。这是通过将函数对象类绑定到参数来实现的：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `bind` function is variadic. The first parameter is the functor object and
    it is followed by the parameters that will be passed to the `operator()` method
    of the functor. The `compare_vals` function is passed a **binder** object that
    binds the functor to values. In the `compare_vals` function, the call to the functor
    in `compare(d[i])` is actually a call to the `operator()` method of the binder
    object, and this method forwards the parameter `d[i]` and the bound value to the
    `operator()` method of the functor.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数是可变参数的。第一个参数是函数对象，后面是将传递给函数对象的`operator()`方法的参数。`compare_vals`函数接收一个**binder**对象，将函数对象绑定到值上。在`compare_vals`函数中，对函数对象的调用`compare(d[i])`实际上是对绑定对象的`operator()`方法的调用，这个方法将参数`d[i]`和绑定的值转发给函数对象的`operator()`方法。'
- en: In the call to `bind`, if an actual value is provided (here, `2.0`), then that
    value is passed to the functor at that position in the call to the functor (here,
    `2,0` is passed to the second parameter). If a symbol preceded by an underscore
    is used, then it is a **placeholder**. There are 20 such symbols (`_1` to `_20`)
    defined in the `std::placeholders` namespace. The placeholder means "use the value
    passed in this position to the binder object `operator()` method call to the functor
    call `operator()` method indicated by the placeholder." Thus, the placeholder
    in this call means "pass the first parameter from invoking the binder and pass
    it to the first parameter of the `greater` functor `operator()`."
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`bind`时，如果提供了实际值（这里是`2.0`），那么该值将传递给函数对象在调用函数对象时的位置（这里是`2,0`传递给第二个参数）。如果使用下划线前缀的符号，则它是一个**占位符**。在`std::placeholders`命名空间中定义了20个这样的符号（`_1`到`_20`）。占位符的意思是“使用在这个位置传递给绑定器对象`operator()`方法调用的值来传递给函数对象调用`operator()`方法中由占位符指示的位置”。因此，在这个调用中，占位符的意思是“将从调用绑定器中传递的第一个参数传递给`greater`函数对象`operator()`的第一个参数”。
- en: 'The previous code compares each item in the `vector` with `2.0` and will keep
    a count of those that are greater than `2.0`. You could invoke it this way:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比较`vector`中的每个项目与`2.0`，并将大于`2.0`的项目计数。你可以这样调用它：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The parameter list is swapped, and this means that `2.0` is compared with each
    item in the `vector` and the function will keep a count of how many times `2.0`
    is greater than the item.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表被交换，这意味着`2.0`与`vector`中的每个项目进行比较，并且函数将计数`2.0`大于项目的次数。
- en: The `bind` function, and placeholders, are new to C++11\. In prior versions
    you could use the `bind1st` and `bind2nd` functions to bind a value to either
    the first or second parameter of the functor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数和占位符是C++11中的新功能。在之前的版本中，你可以使用`bind1st`和`bind2nd`函数来将一个值绑定到函数对象的第一个或第二个参数上。'
- en: Defining conversion operators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义转换运算符
- en: 'We have already seen that a constructor can be used to convert from another
    type to your custom type if your custom type has a constructor that takes the
    type you are converting. You can also perform the conversion in the other direction:
    converting the object into another type. To do this, you provide an operator without
    a return type with the name of the type to convert to. In this case, you need
    a space between the `operator` keyword and the name:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果你的自定义类型有一个接受你要转换的类型的构造函数，那么构造函数可以用来将另一种类型转换为你的自定义类型。你也可以进行另一种方向的转换：将对象转换为另一种类型。为此，你提供一个没有返回类型的操作符，其名称为要转换为的类型。在这种情况下，你需要在`operator`关键字和名称之间加一个空格。
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code can convert an `int` or a `string` to `mytype`; in the latter case,
    only through an explicit mention of the constructor.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以将`int`或`string`转换为`mytype`；在后一种情况下，只能通过显式提及构造函数来实现。
- en: 'The last line allows you to convert an object back to an `int`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行允许你将对象转换回`int`：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can make such conversion operators `explicit` so that they will be called
    only when an explicit cast is used. In many cases, you will want to leave off
    this keyword because implicit conversions are useful when you want to wrap a resource
    in a class and use the destructor to do automatic resource management for you.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这样的转换运算符声明为`explicit`，这样它们只会在使用显式转换时被调用。在许多情况下，你会希望省略这个关键字，因为当你想要将资源封装在类中并使用析构函数来自动管理资源时，隐式转换是有用的。
- en: Another example of using a conversion operator is returning values from a stateful
    functor. The idea here is that the `operator()` will perform some action and the
    result is maintained by the functor. The issue is how do you obtain this state
    of the functor, especially when they are often created as temporary objects? A
    conversion operator can provide this functionality.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换运算符的另一个例子是从有状态的函数对象中返回值。这里的想法是`operator()`将执行某些操作，并且结果由函数对象维护。问题是，如何获取函数对象的状态，特别是当它们经常作为临时对象创建时？转换运算符可以提供这种功能。
- en: 'For example, when you calculate an average, you do it in two stages: the first
    stage is to accumulate the values and then the second stage is to calculate the
    average by dividing it by the number of items. The following functor class does
    this with the division performed as part of the conversion to a `double`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你计算平均值时，你需要分两个阶段：第一阶段是累积值，第二阶段是通过将其除以项目数来计算平均值。以下的函数对象类通过在转换为`double`的过程中执行除法来实现这一点：
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This can be called like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这样调用它：
- en: '[PRE73]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `for_each` function calls the functor for every item in the `vector`, and
    the `operator()` simply sums the items passed to it and maintains a count. The
    interesting part is that after the `for_each` function has iterated over all of
    the items in the `vector` it returns the functor, and so there is an implicit
    conversion to a `double`, which calls the conversion operator that calculates
    the average.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`函数对`vector`中的每个项目调用函数对象，`operator()`简单地对传递给它的项目求和并保持计数。有趣的是，在`for_each`函数迭代完`vector`中的所有项目后，它会返回函数对象，因此会有一个隐式转换为`double`，调用转换运算符来计算平均值。'
- en: Managing resources
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理资源
- en: 'We have already seen one sort of resource that requires careful management:
    memory. You allocate memory with `new`, and when you have finished with the memory
    you must deallocate the memory with `delete`. A failure to deallocate the memory
    will cause a memory leak. Memory is, perhaps, the most fundamental of system resources,
    but most operating systems have many others: file handles, handles to graphic
    objects, synchronization objects, threads, and processes. Sometimes possession
    of such a resource is exclusive and will prevent other code from accessing the
    resource accessed through the resource. Thus, it is important that such resources
    are freed at some point, and, usually, that they are freed in a timely manner.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到一种需要仔细管理的资源：内存。您使用`new`分配内存，当您使用完内存后，必须使用`delete`释放内存。未能释放内存将导致内存泄漏。内存可能是最基本的系统资源，但大多数操作系统还有许多其他资源：文件句柄、图形对象句柄、同步对象、线程和进程。有时，对这种资源的拥有是独占的，并且会阻止其他代码访问通过该资源访问的资源。因此，重要的是在某个时刻释放这些资源，并且通常及时释放这些资源。
- en: Classes help here with a mechanism called **Resource Acquisition Is Initialization**
    (RAII) invented by Bjarne Stroustrup, the author of C++. Put simply, the resource
    is allocated in the constructor of an object and freed in the destructor, so it
    means that the lifetime of the resource is the lifetime of the object. Typically,
    such wrapper objects are allocated on the stack, and this means that you are guaranteed
    that the resource will be freed when the object goes out of scope *regardless
    of how this happens*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 类在这里有所帮助，使用了Bjarne Stroustrup发明的一种称为**资源获取即初始化**（RAII）的机制，他是C++的作者。简单地说，资源在对象的构造函数中分配，并在析构函数中释放，这意味着资源的生命周期与对象的生命周期相同。通常，这种包装对象是在堆栈上分配的，这意味着无论发生什么情况，当对象超出范围时，资源都将被释放。
- en: So, if objects are declared in the code block for a looping statement (`while`,
    `for`), then at the end of each loop the destructor for each will be called (in
    reverse order of creation) and the object will be created again when the loop
    is repeated. This occurs whether the loop is repeated because the end of the code
    block has been reached or if the loop is repeated through a call to `continue`.
    Another way to leave a code block is through a call to `break`, a `goto`, or if
    the code calls `return` to leave the function. If the code raises an exception
    (see [Chapter 7](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml), *Diagnostics and Debugging*),
    the destructor will be called as the object goes out of scope, so if the code
    is guarded by a `try` block, the destructor of objects declared in the block will
    be called before the `catch` clause is called. If there is no guard block, then
    the destructor will be called before the function stack is destroyed and the exception
    propagated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果对象在循环语句（`while`、`for`）的代码块中声明，那么在每次循环结束时，将调用每个对象的析构函数（按创建顺序的相反顺序），并且当循环重复时，对象将再次创建。无论循环是因为已经到达代码块的末尾而重复，还是通过调用`continue`而重复。离开代码块的另一种方法是通过调用`break`、`goto`，或者如果代码调用`return`来离开函数。如果代码引发异常（参见[第7章](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml)，*诊断和调试*），则在对象超出范围时将调用析构函数，因此如果代码受`try`块保护，则将在调用`catch`子句之前调用块中声明的对象的析构函数。如果没有保护块，则在函数堆栈被销毁并传播异常之前将调用析构函数。
- en: Writing wrapper classes
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写包装类
- en: There are several issues that you must address when writing a class to wrap
    a resource. The constructor will be used, either to obtain the resource using
    some library function (usually accessed through some kind of opaque handle) or
    will take the resource as a parameter. This resource is stored as a data member
    so other methods on the class can use it. The resource will be released in the
    destructor using whatever function your library provides to do this. This is the
    bare minimum. In addition, you have to think how the object will be used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写包装资源的类时，您必须解决几个问题。构造函数将被用于获取资源，要么使用某种库函数（通常通过某种不透明句柄访问）获取资源，要么将资源作为参数传递。这个资源将作为数据成员存储，以便类上的其他方法可以使用它。析构函数将使用库提供的函数释放资源。这是最低限度。此外，您还需要考虑对象将如何使用。
- en: Often such wrapper classes are most convenient if you can use instances as if
    they are the resource handle. This means that you maintain the same style of programming
    to access the resource, but you just don't have to worry too much about releasing
    the resource.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您可以将实例用作资源句柄，这样的包装类会更加方便。这意味着您可以保持相同的编程风格来访问资源，但您不必太担心释放资源。
- en: You should think about whether you want to be able convert between your wrapper
    class and the resource handle. If you do allow this, it means that you may have
    to think about cloning the resource, so that you do not have two copies of the
    handle--one that is managed by the class and the other copy that could be released
    by external code. You also need to think about whether you want to allow the object
    to be copied or assigned, and if so, then you will need to appropriately implement
    the copy constructor, a move constructor, and the copy and move assignment operators.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑是否希望能够在包装类和资源句柄之间进行转换。如果允许这样做，这意味着您可能需要考虑克隆资源，以便您不会有两个句柄的副本--一个由类管理，另一个副本可能会被外部代码释放。您还需要考虑是否允许对象被复制或分配，如果允许，那么您将需要适当地实现复制构造函数、移动构造函数以及复制和移动赋值运算符。
- en: Using smart pointers
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针
- en: The C++ Standard Library provides several classes to wrap resources accessed
    through pointers. To prevent memory leaks, you have to ensure that memory allocated
    on the free store is freed at some point. The idea of a smart pointer is that
    you treat an instance as if it is the pointer, so you use the `*` operator to
    dereference to get access to the object it points to or use the `->` operator
    to access a member of the wrapped object. The smart pointer class will manage
    the lifetime of the pointer it wraps and will release the resource appropriately.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了几个类来包装通过指针访问的资源。为了防止内存泄漏，您必须确保在某个时候释放在自由存储器上分配的内存。智能指针的想法是您将实例视为指针，因此您使用`*`运算符进行解引用以访问它指向的对象，或者使用`->`运算符访问包装对象的成员。智能指针类将管理其包装的指针的生命周期，并将适当释放资源。
- en: 'The Standard Library has three smart pointer classes: `unique_ptr`, `shared_ptr`,
    and `weak_ptr`. Each handles how the resource is released in a different way,
    and how or whether you can copy a pointer.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有三个智能指针类：`unique_ptr`，`shared_ptr`和`weak_ptr`。每个类以不同的方式处理资源的释放，以及如何或是否可以复制指针。
- en: Managing exclusive ownership
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理独占所有权
- en: The `unique_ptr` class is constructed with a pointer to the object it will maintain.
    This class provides the operator `*` to give access to the object, dereferencing
    the wrapped pointer. It also provides the `->` operator, so that if the pointer
    is for a class, you can access the members through the wrapped pointer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`类是使用指向将要维护的对象的指针构造的。该类提供了`*`运算符来访问对象，对包装指针进行解引用。它还提供了`->`运算符，因此如果指针是用于类的，您可以通过包装指针访问成员。'
- en: 'The following allocates an object on the free store and manually maintains
    its lifetime:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在自由存储器上分配一个对象并手动维护其生命周期：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this case, you get a pointer to the memory on the free store allocated for
    an `int`. To access the memory--either to write to it or read from it--you dereference
    the pointer with the `*` operator. When you are finished with the pointer, you
    must call `delete` to deallocate the memory and return it to the free store. Now
    consider the same code, but with a smart pointer:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您获得了一个指向为`int`分配的自由存储器上的内存的指针。要访问内存--无论是写入还是读取--您都必须使用`*`运算符对指针进行解引用。当您完成指针时，必须调用`delete`来释放内存并将其返回给自由存储器。现在考虑相同的代码，但使用智能指针：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The two main differences are that the smart pointer object is constructed explicitly
    by calling the constructor that takes a pointer of the type that is used as the
    template parameter. This pattern reinforces the idea that the resource should
    only be managed by the smart pointer.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要区别是智能指针对象是通过调用以模板参数使用的类型的指针的构造函数显式构造的。这种模式强化了资源应该只由智能指针管理的想法。
- en: The second change is that the memory is deallocated by calling the `release`
    method on the smart pointer object to take ownership of the wrapped pointer, so
    that we can delete the pointer explicitly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是通过在智能指针对象上调用`release`方法来释放内存，以获取包装指针的所有权，这样我们就可以显式删除指针。
- en: Think of the `release` method releasing the pointer from the ownership of the
    smart pointer. After this call, the smart pointer no longer wraps the resource.
    The `unique_ptr` class also has a method `get` that will give access to the wrapped
    pointer, but the smart pointer object will still retain ownership; *do not delete
    the pointer obtained this way*!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将`release`方法释放指针从智能指针的所有权中释放。在此调用之后，智能指针不再包装资源。`unique_ptr`类还有一个`get`方法，将允许访问包装的指针，但智能指针对象仍将保留所有权；*不要通过这种方式删除获得的指针*！
- en: 'Note that a `unique_ptr` object wraps a pointer, and just the pointer. This
    means that the object is the same size in memory as the pointer it wraps. So far,
    the smart pointer has added very little, so let''s look at another way to deallocate
    the resource:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`unique_ptr`对象包装一个指针，只是指针。这意味着对象在内存中的大小与它包装的指针相同。到目前为止，智能指针增加了很少，所以让我们看看另一种释放资源的方法：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is *deterministic* releasing of the resource, and means that the resource
    is released just when you want it to happen, which is similar to the situation
    with the pointer. The code here is not releasing the resource itself; it is allowing
    the smart pointer to do it, using a **deleter**. The default deleter for `unique_ptr`
    is a functor class called `default_delete`, which calls the `delete` operator
    on the wrapped pointer.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*确定性*释放资源，这意味着资源在您希望发生时释放，这与指针的情况类似。这里的代码并不释放资源本身；它允许智能指针使用**删除器**来释放资源。`unique_ptr`的默认删除器是一个名为`default_delete`的函数类，它在包装指针上调用`delete`运算符。
- en: 'If you intend to use deterministic destruction, `reset` is the preferred method.
    You can provide your own deleter by passing the type of a custom functor class
    as the second parameter to the `unique_ptr` template:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用确定性销毁，`reset`是首选方法。您可以通过将自定义函数类的类型作为`unique_ptr`模板的第二个参数来提供自己的删除器：
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In your code, you will specify that you want the custom deleter, like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您将指定您想要自定义删除器，就像这样：
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You may need to carry out an additional clean up before deleting the pointer,
    or the pointer could be a obtained by a mechanism other than `new`, so you can
    use a custom deleter to ensure that the appropriate releasing function is called.
    Note that the deleter is part of the smart pointer class, so if you have two different
    smart pointers using two different deleter this way, the smart pointer types are
    different even if they wrap the same type of resource.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除指针之前，您可能需要执行额外的清理，或者指针可能是通过除`new`之外的机制获得的，因此您可以使用自定义删除器来确保调用适当的释放函数。请注意，删除器是智能指针类的一部分，因此如果您有两个使用两种不同删除器的不同智能指针，智能指针类型是不同的，即使它们包装相同类型的资源。
- en: When you use a custom deleter, the size of a `unique_ptr` object may be larger
    than the pointer wrapped. If the deleter is a functor object, each smart pointer
    object will need memory for this, but if you use a lambda expression, no more
    extra space will be required.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用自定义删除器时，`unique_ptr`对象的大小可能大于包装的指针。如果删除器是一个函数对象，每个智能指针对象将需要为此分配内存，但如果使用lambda表达式，则不需要更多的额外空间。
- en: 'Of course, you are most likely to allow the smart pointer to manage the resource
    lifetime for you, and to do this you simply allow the smart pointer object to
    go out of scope:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您最有可能允许智能指针为您管理资源的生命周期，为此，您只需允许智能指针对象超出范围：
- en: '[PRE79]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Since the pointer created is a single object, it means that you can call the
    `new` operator on an appropriate constructor to pass in initialization parameters.
    The constructor of `unique_ptr` is passed a pointer to an already constructed
    object, and the class manages the lifetime of the object after that. Although
    a `unique_ptr` object can be created directly by calling its constructor, you
    cannot call the copy constructor, so you cannot use initialization syntax during
    construction. Instead, the Standard Library provides a function called `make_unique`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建的指针是单个对象，这意味着您可以调用适当构造函数上的`new`运算符来传递初始化参数。`unique_ptr`的构造函数传递指向已构造对象的指针，然后类管理对象的生命周期。虽然可以直接通过调用其构造函数创建`unique_ptr`对象，但不能调用复制构造函数，因此在构造期间不能使用初始化语法。相反，标准库提供了一个名为`make_unique`的函数。
- en: 'This has several overloads, and for this reason it is the preferred way to
    create smart pointers based on this class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 它有几个重载，因此这是基于这个类创建智能指针的首选方式：
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This code will call the default constructor on the wrapped type (`int`), but
    you can provide parameters that will be passed to the appropriate constructor
    of the type. For example, for a `struct` that has a constructor with two parameters,
    the following may be used:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在包装类型（`int`）上调用默认构造函数，但您可以提供要传递给类型的适当构造函数的参数。例如，对于具有两个参数的构造函数的`struct`，可以使用以下方法：
- en: '[PRE81]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `make_unique` function calls the constructor that assigns the members with
    non-default values. The `->` operator returns a pointer and the compiler will
    access the object members through this pointer.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`函数调用分配具有非默认值的成员的构造函数。`->`运算符返回一个指针，编译器将通过这个指针访问对象成员。'
- en: There is also a specialization of `unique_ptr` and `make_unique` for arrays.
    The default deleter for this version of `unique_ptr` will call `delete[]` on the
    pointer, and thus it will delete every object in the array (and call each object's
    destructor). The class implements an indexer operator (`[]`) so you can access
    each item in the array. However, note that there are no range checks, so, like
    a built-in array variable, you can access beyond the end of the array. There are
    no dereferencing operators (`*` or `->`), so a `unique_ptr` object based on an
    array can only be accessed with array syntax.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个专门用于数组的`unique_ptr`和`make_unique`的特化。此版本的`unique_ptr`的默认删除器将在指针上调用`delete[]`，因此它将删除数组中的每个对象（并调用每个对象的析构函数）。该类实现了一个索引器运算符（`[]`），因此您可以访问数组中的每个项目。但是，请注意，没有范围检查，因此，就像内置数组变量一样，您可以访问数组的末尾之外。没有解引用运算符（`*`或`->`），因此基于数组的`unique_ptr`对象只能使用数组语法访问。
- en: 'The `make_unique` function has an overload that allows you to pass the size
    of the array to create, but you have to initialize each object individually:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`函数有一个重载，允许您传递要创建的数组的大小，但您必须逐个初始化每个对象：'
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This creates an array with four `point` objects initially set to the default
    value, and the following lines initialize the second point to a value of `(10.0,
    -10.0)`. It is almost always better to use `vector` or `array` than `unique_ptr`
    to manage arrays of objects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含四个`point`对象的数组，最初设置为默认值，接下来的行将第二个点初始化为`(10.0，-10.0)`的值。几乎总是比使用`unique_ptr`来管理对象数组更好使用`vector`或`array`。
- en: Earlier versions of the C++ Standard Library had a smart pointer class called
    `auto_ptr`. This was a first attempt, and worked in most cases, but also had some
    limitations; for example, `auto_ptr` objects could not be stored in Standard Library
    containers. C++11 introduces rvalue references and other language features such
    as move semantics, and, through these, `unique_ptr` objects can be stored in containers.
    The `auto_ptr` class is still available through the `<new>` header, but only so
    that older code can still compile.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的C++标准库有一个名为`auto_ptr`的智能指针类。这是第一次尝试，在大多数情况下都有效，但也有一些限制；例如，`auto_ptr`对象不能存储在标准库容器中。C++11引入了右值引用和其他语言特性，如移动语义，通过这些特性，`unique_ptr`对象可以存储在容器中。`auto_ptr`类仍然通过`<new>`头文件可用，但只是为了让旧代码仍然可以编译。
- en: The important point about the `unique_ptr` class is that it ensures that there
    is a single copy of the pointer. This is important because the class destructor
    will release the resource, so if you *could* copy a `unique_ptr` object it would
    mean more than one destructor will attempt to release the resource. Objects of
    `unique_ptr` have *exclusive ownership*; an instance always owns what it points
    to.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`unique_ptr`类的重要一点是它确保指针只有一个副本。这很重要，因为类析构函数将释放资源，所以如果您*可以*复制`unique_ptr`对象，这意味着将有多个析构函数尝试释放资源。`unique_ptr`对象具有*独占所有权*；实例始终拥有其指向的内容。
- en: You cannot copy assign `unique_ptr` smart pointers (the copy assignment operator
    and copy constructor are deleted), but you can *move* them by transferring ownership
    of the resource from the source pointer to the destination pointer. So, a function
    can return a `unique_ptr` because the ownership is transferred through move semantics
    to the variable being assigned to the value of the function. If the smart pointer
    is put into a container, there is another move.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能复制分配`unique_ptr`智能指针（复制分配运算符和复制构造函数已删除），但可以通过转移所有权从源指针到目标指针来*移动*它们。因此，函数可以返回`unique_ptr`，因为通过移动语义将所有权转移到分配给函数值的变量。如果智能指针放入容器中，则会进行另一个移动。
- en: Sharing ownership
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享所有权
- en: 'There are occasions when you will need to share a pointer: you may create several
    objects and pass a pointer to a single object to each of them so they can call
    this object. Ordinarily, when an object has a pointer to another object, that
    pointer represents a resource that should be destroyed during the destruction
    of the containing object. If a pointer is shared, it means that when one of the
    objects deletes the pointer, the pointers in all of the other objects will be
    invalid (this is called a **dangling pointer** because it no longer points to
    an object). You need a mechanism where several objects can hold a pointer that
    will remain valid until *all* the objects using that pointer have indicated they
    will no longer need to use it.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要共享指针：您可能创建多个对象并将指针传递给每个对象的单个对象，以便它们可以调用此对象。通常，当一个对象持有指向另一个对象的指针时，该指针表示应在包含对象的销毁期间销毁的资源。如果指针是共享的，这意味着当其中一个对象删除指针时，所有其他对象中的指针将无效（这称为**悬空指针**，因为它不再指向对象）。您需要一种机制，其中多个对象可以持有指针，直到*所有*使用该指针的对象都表示它们将不再需要使用它为止，该指针将保持有效。
- en: C++11 provides this facility with the `shared_ptr` class. This class maintains
    a **reference count** on the resource, and each copy of the `shared_ptr` for that
    resource will increment the reference count. When one instance of `shared_ptr`
    for that resource is destroyed, it will decrement the reference count. The reference
    count is shared, so it means that a non-zero value signifies that at least one
    `shared_ptr` exists accessing the resource. When the last `shared_ptr` object
    decrements the reference count to zero, it is safe to release the resource.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过`shared_ptr`类提供了这种功能。该类在资源上维护**引用计数**，并且对于该资源的每个`shared_ptr`副本都会增加引用计数。当销毁该资源的一个`shared_ptr`实例时，它将减少引用计数。引用计数是共享的，因此它意味着非零值表示至少存在一个访问该资源的`shared_ptr`。当最后一个`shared_ptr`对象将引用计数减少到零时，可以安全释放资源。
- en: This means that the reference count must be managed in an atomic way to handle
    multithreaded code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着必须以原子方式管理引用计数以处理多线程代码。
- en: Since the reference count is shared, it means that each `shared_ptr` object
    holds a pointer to a shared buffer called the **control block**, and this means
    it holds the raw pointer and a pointer to the control block, and so each `shared_ptr`
    object will hold more data than a `unique_ptr`. The control block is used for
    more than just the reference count.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用计数是共享的，这意味着每个`shared_ptr`对象都持有指向称为**控制块**的共享缓冲区的指针，这意味着它持有原始指针和指向控制块的指针，因此每个`shared_ptr`对象将持有比`unique_ptr`更多的数据。控制块用于不仅仅是引用计数。
- en: A `shared_ptr` object can be created to use a custom deleter (passed as a constructor
    parameter), and the deleter is stored in the control block. This is important
    because it means that the custom deleter is not part of the type of the smart
    pointer, so several `shared_ptr` objects wrapping the same resource type but using
    different deleters are still the same type and can be put in a container for that
    type.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`对象可以创建以使用自定义删除器（作为构造函数参数传递），并且删除器存储在控制块中。这很重要，因为这意味着自定义删除器不是智能指针类型的一部分，因此封装相同资源类型但使用不同删除器的多个`shared_ptr`对象仍然是相同类型，并且可以放入该类型的容器中。'
- en: You can create a `shared_ptr` object from another `shared_ptr` object, and this
    will initialize the new object with the raw pointer and the pointer to the control
    block, *and* increment the reference count.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从另一个`shared_ptr`对象创建一个`shared_ptr`对象，并且这将使用原始指针和指向控制块的指针初始化新对象，并且增加引用计数。
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, the first shared pointer is created using a raw pointer. This is not the
    recommended way to use `shared_ptr`. The second shared pointer is created using
    the first smart pointer, so now there are two shared pointers to the same resource
    (`p` is assigned to `nullptr` to prevent its further use). After this, either
    `sp1` or `sp2` can be used to access the *same* resource. At the end of this code,
    one shared pointer is reset to `nullptr`; this means that `sp1` no longer has
    a reference count on the resource, and you cannot use it to access the resource.
    However, you can still use `sp2` to access the resource until it goes out of scope,
    or you call `reset`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个共享指针是使用原始指针创建的。这不是使用`shared_ptr`的推荐方式。第二个共享指针是使用第一个智能指针创建的，因此现在有两个共享指针指向相同的资源（`p`被分配为`nullptr`以防止其进一步使用）。在此之后，`sp1`或`sp2`可以用于访问*相同*资源。在此代码结束时，一个共享指针被重置为`nullptr`；这意味着`sp1`不再具有对资源的引用计数，并且您无法使用它来访问资源。但是，您仍然可以使用`sp2`来访问资源，直到它超出范围，或者您调用`reset`。
- en: 'In this code, the smart pointers were created from a separate raw pointer.
    Since the shared pointers now have taken over the lifetime management of the resource
    it is important to no longer use the raw pointer, and in this case it is assigned
    to `nullptr`. It is better to avoid the use of raw pointers, and the Standard
    Library enables this with a function called `make_shared`, which can be used like
    this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，智能指针是从单独的原始指针创建的。由于共享指针现在接管了资源的生命周期管理，因此重要的是不再使用原始指针，在这种情况下将其分配为`nullptr`。最好避免使用原始指针，标准库通过一个名为`make_shared`的函数实现了这一点，可以像这样使用：
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The function will create the specified object using a call to `new`, and since
    it takes a variable number of parameters, you can use it to call any constructor
    on the wrapped class.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将使用对`new`的调用创建指定的对象，并且由于它接受可变数量的参数，您可以使用它来调用包装类上的任何构造函数。
- en: You can create a `shared_ptr` object from a `unique_ptr` object, which means
    that the pointer is *moved* to the new object and the reference counting control
    block created. Since the resource will now be shared, it means that there is no
    longer exclusive ownership on the resource, so the pointer in the `unique_ptr`
    object will be made a `nullptr`. This means that you can have a factory function
    that returns a pointer to an object wrapped in a `unique_ptr` object, and the
    calling code can determine if it will use a `unique_ptr` object to get exclusive
    access to the resource or a `shared_ptr` object to share it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`unique_ptr`对象创建一个`shared_ptr`对象，这意味着指针被*移动*到新对象，并且创建了引用计数控制块。由于资源现在将被共享，这意味着不再对资源拥有独占权，因此`unique_ptr`对象中的指针将被设置为`nullptr`。这意味着您可以有一个工厂函数，返回一个包装在`unique_ptr`对象中的对象指针，并且调用代码可以确定是否使用`unique_ptr`对象来独占访问资源，还是使用`shared_ptr`对象来共享资源。
- en: There is little point in using `shared_ptr` for arrays of objects; there are
    much better ways to store collections of objects (`vector` or `array`). In any
    case, there is an indexing operator (`[]`) and the default deleter calls `delete`,
    not `delete[]`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象数组使用`shared_ptr`没有太大意义；有更好的方法来存储对象的集合（`vector`或`array`）。无论如何，有一个索引运算符（`[]`），默认删除器调用`delete`，而不是`delete[]`。
- en: Handling dangling pointers
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理悬空指针
- en: 'Earlier in this book we made the point that, when you delete a resource, you
    should set the pointer to `nullptr` and you should check a pointer before using
    it to see if it is `nullptr`. This is so that you do not call a pointer to memory
    for an object that has been deleted: a dangling pointer.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，我们指出，当您删除资源时，应将指针设置为`nullptr`，并且在使用指针之前应检查指针是否为`nullptr`。这样可以避免调用已被删除的对象的内存指针：悬空指针。
- en: There are situations when a dangling pointer can occur by design. For example,
    a *parent* object may create *child* objects that have a **back pointer** to the
    parent so that the child has access to the parent. (An example of this is a window
    that creates child controls; it is often useful for the child controls to have
    access to the parent window.) The problem with using a shared pointer in this
    situation is that the parent will have a reference count on each child control
    and each child control has a reference count on the parent, and this creates a
    circular dependency.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有时悬空指针可能是有意设计的。例如，*父*对象可能创建具有**反向指针**到父对象的*子*对象，以便子对象可以访问父对象。（一个例子是窗口创建子控件；子控件通常可以访问父窗口是很有用的。）在这种情况下使用共享指针的问题在于父对象将对每个子控件有一个引用计数，而每个子控件对父对象也有一个引用计数，这会创建一个循环依赖。
- en: Another example is if you have a container of observer objects with the intention
    of being able to inform each of these observer objects when an event occurs by
    calling a method on each one. Maintaining this list can be complicated, particularly
    if an observer object can be deleted, and hence you have to provide a means to
    remove the object from the container (where there will be a `shared_ptr` reference
    count) before you can completely delete the object. It becomes easier if your
    code can simply add a pointer to the object to the container in a way that does
    not maintain a reference count, but allows you to check when the pointer is used
    if the pointer is dangling or points to an existing object.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果您有一个观察者对象的容器，并且希望能够在事件发生时通过调用每个观察者对象的方法来通知每个观察者对象。维护此列表可能会很复杂，特别是如果观察者对象可以被删除，因此您必须提供一种从容器中删除对象的方法（其中将存在`shared_ptr`引用计数），然后才能完全删除对象。如果您的代码可以简单地以一种不维护引用计数但允许您在使用指针时检查指针是否悬空或指向现有对象的方式将对象指针添加到容器中，那将变得更容易。
- en: Such a pointer is called a **weak pointer** and the C++11 Standard Library provides
    a class called `weak_ptr`. You cannot use a `weak_ptr` object directly and there
    is no dereference operator.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的指针被称为**弱指针**，C++11标准库提供了一个名为`weak_ptr`的类。您不能直接使用`weak_ptr`对象，也没有解引用运算符。
- en: Instead, you create a `weak_ptr` object from a `shared_ptr` object and, when
    you want to access the resource, you create a `shared_ptr` object from the `weak_ptr`
    object. This means that a `weak_ptr` object has the same raw pointer, and access
    to the same control block as the `shared_ptr` object, but it does not take part
    in reference counting.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以从`shared_ptr`对象创建一个`weak_ptr`对象，当您想要访问资源时，您可以从`weak_ptr`对象创建一个`shared_ptr`对象。这意味着`weak_ptr`对象具有相同的原始指针，并且访问相同的控制块作为`shared_ptr`对象，但它不参与引用计数。
- en: 'Once created, the `weak_ptr` object will enable you to test whether the wrapper
    pointer is to an existing resource or to a resource that has been destroyed. There
    are two ways to do this: either call the member function `expired` or attempt
    to create a `shared_ptr` from the `weak_ptr`. If you are maintaining a collection
    of `weak_ptr` objects, you may decide to periodically iterate through the collection,
    call `expired` on each one, and if the method returns `true`, remove that object
    from the collection. Since the `weak_ptr` object has access to the control block
    created by the original `shared_ptr` object, it can test to see if the reference
    count is zero.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，`weak_ptr`对象将使您能够测试包装指针是指向现有资源还是已被销毁的资源。有两种方法可以做到这一点：要么调用成员函数`expired`，要么尝试从`weak_ptr`创建一个`shared_ptr`。如果您正在维护一组`weak_ptr`对象，您可能决定定期遍历该集合，对每个对象调用`expired`，如果该方法返回`true`，则从集合中删除该对象。由于`weak_ptr`对象可以访问原始`shared_ptr`对象创建的控制块，它可以测试引用计数是否为零。
- en: 'The second way to test to see if a `weak_ptr` object is dangling is to create
    a `shared_ptr` object from it. There are two options. You can create the `shared_ptr`
    object by passing the weak pointer to its constructor and if the pointer has expired,
    the constructor will throw a `bad_weak_ptr` exception. The other way is to call
    the `lock` method on the weak pointer and if the weak pointer has expired, then
    the `shared_ptr` object will be assigned to `nullptr` and you can test for this.
    These three ways are shown here:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`weak_ptr`对象是否悬空的第二种方法是从中创建一个`shared_ptr`对象。有两种选择。您可以通过将弱指针传递给其构造函数来创建`shared_ptr`对象，如果指针已过期，则构造函数将抛出`bad_weak_ptr`异常。另一种方法是在弱指针上调用`lock`方法，如果弱指针已过期，则`shared_ptr`对象将被分配为`nullptr`，您可以对此进行测试。这三种方法在这里显示：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Since a weak pointer does not alter the reference count on a resource it means
    that you can use it for a back pointer to break the cyclic dependency (although,
    often it makes sense to use a raw pointer instead because a child object cannot
    exist without its parent object).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于弱指针不会改变资源的引用计数，这意味着您可以使用它作为回指针来打破循环依赖（尽管通常更合理的做法是使用原始指针，因为子对象不能没有父对象而存在）。
- en: Templates
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Classes can be templated, which means that you can write generic code and the
    compiler will generate a class with the types that your code uses. The parameters
    can be types, constant integer values, or variadic versions (zero or more parameters,
    as provided by the code using the class). For example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以被模板化，这意味着您可以编写通用代码，编译器将生成一个使用您的代码类型的类。参数可以是类型、常量整数值，或者可变版本（零个或多个参数，由使用类的代码提供）。例如：
- en: '[PRE86]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here is a very simple array class that defines the basic iterator functions
    and the indexing operator, so that you can call it like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的数组类，它定义了基本的迭代器函数和索引运算符，这样您就可以这样调用它：
- en: '[PRE87]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you choose to define a function out of the `class` declaration, then you
    need to give the template and its parameters as part of the `class` name:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择在`class`声明之外定义一个函数，则需要将模板及其参数作为`class`名称的一部分给出：
- en: '[PRE88]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can also have default values for template parameters:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为模板参数设置默认值：
- en: '[PRE89]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If you think you should have a specific implementation for a template parameter,
    then you can provide the code for that version as a specialization of the template:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为应该为模板参数提供特定的实现，那么您可以将该版本的代码作为模板的特化提供：
- en: '[PRE90]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Note that, with a specialization, you do not get any code from the fully templated
    class; you have to implement all the methods you want to provide, and, as illustrated
    here, methods that are relevant to the specialization but not available on the
    fully templated class. This example is a **partial specialization**, meaning that
    it is specialized on just one parameter (`T`, the type of the data). This class
    will be used for declared variables of the type `simple_array<n, char>`, where
    `n` is an integer. You are free to have a fully specialized template, which, in
    this case, will be a specialization for a fixed size and a specified type:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过特化，您不会从完全模板化的类中获得任何代码；您必须实现您想要提供的所有方法，并且，如本例所示，还要实现与特化相关但在完全模板化类上不可用的方法。这个例子是**部分特化**，意味着它只是针对一个参数（`T`，数据类型）进行了特化。这个类将用于声明为类型`simple_array<n,
    char>`的变量，其中`n`是一个整数。您可以自由地拥有一个完全特化的模板，在这种情况下，它将是一个特定大小和指定类型的特化：
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: It is probably not useful in this case, but the idea is that there will be special
    code for variables that need 256 chars.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下可能没有用，但是想法是对需要256个字符的变量进行特殊代码处理。
- en: Using classes
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类
- en: The **Resource Acquisition Is Initialization** technique is useful for managing
    resources provided by other libraries, such as the C Runtime Library or the Windows
    SDK. It simplifies your code because you do not have to think about where a resource
    handle will go out of scope and provide clean-up code at every point. If the clean-up
    code is complicated, it is typical in C code to see it put at the end of a function
    and every exit point in the function will have a `goto` jump to that code. This
    results in messy code. In this example, we will wrap the C files functions with
    a class, so that the lifetime of the file handle is maintained automatically.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**技术对于管理由其他库提供的资源非常有用，例如C运行时库或Windows SDK。它简化了您的代码，因为您不必考虑资源句柄何时超出范围，并在每个点提供清理代码。如果清理代码很复杂，在C代码中通常会看到它放在函数的末尾，并且函数中的每个退出点都会有一个`goto`跳转到该代码。这会导致混乱的代码。在这个例子中，我们将用一个类来包装C文件函数，以便文件句柄的生命周期可以自动维护。'
- en: The C runtime `_findfirst` and `_findnext` functions allow you to search for
    a file or directory that matches a pattern (including wildcard symbols). The `_findfirst`
    function returns an `intptr_t`, which is relevant to just that search and this
    is passed to the `_findnext` function to get subsequent values. This `intptr_t`
    is an opaque pointer to resources that the C Runtime maintains for the search,
    and so when you are finished with the search you must call `_findclose` to clean
    up any resources associated with it. To prevent memory leaks, it is important
    to call `_findclose`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时的`_findfirst`和`_findnext`函数允许您搜索与模式匹配的文件或目录（包括通配符符号）。`_findfirst`函数返回一个`intptr_t`，这与该搜索相关，并且将其传递给`_findnext`函数以获取后续值。这个`intptr_t`是C运行时为搜索维护的资源的不透明指针，因此当您完成搜索时，必须调用`_findclose`来清理与之关联的任何资源。为了防止内存泄漏，调用`_findclose`非常重要。
- en: 'Under the `Beginning_C++` folder, create a folder called `Chapter_06`. In Visual
    C++, create a new C++ source file, save it to the `Chapter_06` folder, and call
    it `search.cpp`. The application will use the Standard Library console and strings,
    and it will use the C Runtime file functions, so add these lines to the top of
    the file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Beginning_C++`文件夹下，创建一个名为`Chapter_06`的文件夹。在Visual C++中，创建一个新的C++源文件，保存到`Chapter_06`文件夹中，并将其命名为`search.cpp`。该应用程序将使用标准库控制台和字符串，并将使用C运行时文件函数，因此在文件顶部添加以下行：
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The application will be called with a file search pattern and it will use the
    C functions to search for files, so you will need a `main` function that has parameters.
    Add the following to the bottom of the file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用C函数搜索文件，并且将使用带有参数的`main`函数。将以下内容添加到文件底部：
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first thing is to create a wrapper class for the search handle that will
    manage this resource. Above the usage function, add a class called `search_handle`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要创建一个搜索句柄的包装类，以管理此资源。在使用函数上方，添加一个名为`search_handle`的类：
- en: '[PRE94]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This class has a separate function to release the handle. This is so that a
    user of this class can release the wrapper resource as soon as possible. If the
    object is used in code that could throw an exception, the `close` method won't
    be called directly, but the destructor will be called instead. The wrapper object
    can be created with a `intptr_t` value. If this value is -1, then the handle is
    invalid, so the close method will only call `_findclose` if the handle does not
    have this value.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个单独的函数来释放句柄。这样，这个类的用户可以尽快释放包装资源。如果对象用于可能引发异常的代码中，`close`方法不会直接被调用，而是会调用析构函数。包装对象可以使用`intptr_t`值创建。如果这个值是-1，那么句柄是无效的，所以`close`方法只会在句柄没有这个值时调用`_findclose`。
- en: 'We want objects of this class to have exclusive ownership of the handle, so
    delete the copy constructor and copy assignment by putting the following in the
    public part of the class:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个类的对象拥有句柄的独占权，因此通过将以下内容放入类的公共部分来删除复制构造函数和复制赋值：
- en: '[PRE95]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If an object is moved, then any handle in the existing object must be released,
    so add the following after the lines you just added:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象被移动，那么现有对象中的任何句柄都必须被释放，因此在刚刚添加的行之后添加以下内容：
- en: '[PRE96]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The wrapper class will be allocated by a call to `_findfirst` and will be passed
    to a call to `_findnext`, so the wrapper class needs two operators: one to convert
    to an `intptr_t`, so objects of this class can be used wherever an `intptr_t`
    is needed, and the other so that object can be used when a `bool` is needed. Add
    these to the `public` part of the class:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类将通过调用`_findfirst`分配，并将传递给调用`_findnext`，因此包装类需要两个运算符：一个用于转换为`intptr_t`，以便可以在需要`intptr_t`的任何地方使用此类的对象，另一个用于在需要`bool`时使用对象。将这些添加到类的`public`部分：
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The conversion to `bool` allows you to write code like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`bool`允许您编写如下代码：
- en: '[PRE98]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you have a conversion operator that returns a pointer, then the compiler
    will call this in preference to the conversion to `bool`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个返回指针的转换运算符，那么编译器将优先调用这个而不是转换为`bool`。
- en: You should be able to compile this code (remember to use the `/EHsc` switch)
    to confirm that there are no typos.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够编译此代码（记得使用`/EHsc`开关）以确认没有拼写错误。
- en: 'Next, write a wrapper class to perform the search. Below the `search_handle`
    class, add a `file_search` class:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个包装类来执行搜索。在`search_handle`类下面，添加一个`file_search`类：
- en: '[PRE99]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This class is created with the search criteria, and we have the option of passing
    a C or C++ string. The class has a `search_handle` data member, and, since the
    default destructor will call the destructor of member objects, we do not need
    to provide a destructor ourselves. However, we will add a `close` method so that
    a user can explicitly release resources. Furthermore, so that users of the class
    can determine the search path, we need an accessor. At the bottom of the class,
    add the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是根据搜索条件创建的，我们可以选择传递C或C++字符串。该类有一个`search_handle`数据成员，并且，由于默认析构函数将调用成员对象的析构函数，因此我们不需要自己提供析构函数。但是，我们将添加一个`close`方法，以便用户可以显式释放资源。此外，为了让类的用户确定搜索路径，我们需要一个访问器。在类的底部，添加以下内容：
- en: '[PRE100]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We do not want instances of the `file_search` object to be copied because that
    would mean two copies of the search handle. You could delete the copy constructor
    and assignment operator, but there is no need. Try this: in the `main` function,
    add this test code (it does not matter where):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望复制`file_search`对象的实例，因为那意味着搜索句柄的两个副本。您可以删除复制构造函数和赋值运算符，但没有必要。尝试这样做：在`main`函数中，添加此测试代码（位置无关紧要）：
- en: '[PRE101]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Compile the code. You''ll get an error and an explanation:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码。您将收到一个错误和一个解释：
- en: '[PRE102]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Without a copy constructor, the compiler will generate one (this is the second
    line). The first line is a bit odd because it is saying that you are trying to
    call a deleted method that the compiler has generated! In fact, the error is saying
    that the generated copy constructor is attempting to copy the `handle` data member
    and the `search_handle` copy constructor that has been deleted. Thus you are protected
    against copying `file_search` objects without adding any other code. Delete the
    test lines you just added.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 没有复制构造函数，编译器会生成一个（这是第二行）。第一行有点奇怪，因为它说你正在尝试调用编译器生成的已删除的方法！实际上，错误是说生成的复制构造函数正在尝试复制`handle`数据成员和已删除的`search_handle`复制构造函数。因此，您受到保护，防止复制`file_search`对象而无需添加任何其他代码。删除您刚添加的测试行。
- en: Next add the following lines to the bottom of the `main` function. This will
    create a `file_search` object and print out information to the console.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main`函数的底部添加以下行。这将创建一个`file_search`对象并将信息打印到控制台。
- en: '[PRE103]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then you need to add code to perform the search. The pattern used here will
    be a method that has an out parameter and returns a `bool`. If a call to the method
    succeeds, then the file found will be returned in the out parameter and the method
    will return `true`. If the call fails, then the out parameter is left untouched
    and the method returns `false`. In the `public` section of the `file_search` class,
    add this function:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要添加代码来执行搜索。这里使用的模式将是一个具有输出参数并返回`bool`的方法。如果方法调用成功，则找到的文件将在输出参数中返回，并且该方法将返回`true`。如果调用失败，则输出参数保持不变，并且该方法返回`false`。在`file_search`类的`public`部分中，添加此函数：
- en: '[PRE104]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If this is the first call to this method, then `handle` will be invalid and
    so `_findfirst` is called. This will fill a `_finddata_t` structure with the results
    of the search and return an `intptr_t` value. The `search_handle` object data
    member is assigned to this value returned from this function, and if `_findfirst`
    returns `-1`, the method returns `false`. If the call is successful, then the
    out parameter (a reference to a `string`) is initialized using a C string pointer
    in the `_finddata_t` structure.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是对该方法的第一次调用，则`handle`将无效，因此将调用`_findfirst`。这将使用搜索结果填充`_finddata_t`结构并返回一个`intptr_t`值。`search_handle`对象的数据成员被赋予从此函数返回的值，如果`_findfirst`返回`-1`，则该方法返回`false`。如果调用成功，则输出参数（指向`string`的引用）将使用`_finddata_t`结构中的C字符串指针进行初始化。
- en: If there are more files that match the pattern, then you can call the `next`
    function repeatedly, and on these subsequent calls the `_findnext` function is
    called to get the next file. In this case the `search_handle` object is passed
    to the function and there is an implicit conversion to `intptr_t` through the
    class's conversion operator. If the `_findnext` function returns `-1`, it means
    there are no more files in the search.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多与模式匹配的文件，那么可以重复调用`next`函数，在这些后续调用中，将调用`_findnext`函数以获取下一个文件。在这种情况下，`search_handle`对象被传递给函数，并通过类的转换运算符隐式转换为`intptr_t`。如果`_findnext`函数返回`-1`，则意味着搜索中没有更多文件。
- en: 'At the bottom of the `main` function, add the following lines to perform the
    search:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的底部，添加以下行来执行搜索：
- en: '[PRE105]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now you can compile the code and run it with a search criterion. Bear in mind
    that this is constrained by the facilities of the `_findfirst`/`_findnext` functions,
    so the searches you can do will be quite simple. Try running this at the command
    line with a parameter to search for the subfolders in the `Beginning_C++` folder:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译代码并使用搜索条件运行它。请记住，这受到`_findfirst`/`_findnext`函数的限制，因此您可以进行的搜索将非常简单。尝试在命令行中运行此命令，并使用参数搜索`Beginning_C++`文件夹中的子文件夹。
- en: '[PRE106]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This will give a list of the subfolders starting with `Ch`. Since there is no
    reason for `search_handle` to be a separate class, move the entire class to the
    `private` section of the `search_handle`, above the declaration of the `handle`
    data member. Compile and run the code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以`Ch`开头的子文件夹列表。由于没有理由让`search_handle`成为一个单独的类，将整个类移到`search_handle`的`private`部分，在`handle`数据成员的声明之上。编译并运行代码。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With classes, C++ provides a powerful and flexible mechanism to encapsulate
    data and methods to provide behavior that acts on the data. You can template this
    code so that you can write generic code and get the compiler to generate code
    for the types that you require. In the example, you have seen how classes are
    the basis of object orientation. A class encapsulates data, so that the caller
    only needs to know about the expected behavior (in this example, getting the next
    result in a search), without needing to know the details of how the class does
    this.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类，C++提供了一个强大而灵活的机制来封装数据和方法，以提供对数据进行操作的行为。您可以将此代码模板化，以便编写通用代码并让编译器为您需要的类型生成代码。在本例中，您已经看到类是面向对象的基础。类封装数据，使得调用者只需要了解预期的行为（在本例中是获取搜索中的下一个结果），而无需了解类如何实现这一点的细节。
