- en: An In-Depth Look at Dynamic Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解动态分配
- en: In this chapter, you will learn how to work with dynamic memory allocation.
    This chapter is important because not all variables can be defined globally or
    on the stack (that is, from within a function), as global memory should be avoided
    where possible and stack memory is usually far more limited than heap memory (the
    memory that's used for dynamic memory allocations). The use of heap memory, however,
    has lead to numerous bugs over the years with respect to leaking and dangling
    pointers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何处理动态内存分配。本章很重要，因为并非所有变量都可以在全局范围内或堆栈上（即在函数内部）定义，全局内存应尽可能避免使用，而堆栈内存通常比堆内存（用于动态内存分配的内存）有限得多。然而，使用堆内存已经多年导致了许多关于泄漏和悬空指针的错误。
- en: This chapter will teach you not only how this dynamic memory allocation works
    but also how to allocate memory from the heap correctly in a C++ Core Guideline
    compliant manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不仅将教你动态内存分配的工作原理，还将教你如何在符合C++核心指南的情况下正确地从堆中分配内存。
- en: Beginning with why we use smart pointers as well as the difference between them,
    conversions, and other references, we will conclude this chapter with a brief
    explanation of how the heap works under Linux and why dynamic memory allocation
    is so slow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从为什么我们使用智能指针以及它们之间的区别，转换和其他引用开始，我们将在本章中简要解释Linux下堆的工作原理以及为什么动态内存分配如此缓慢。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Comparing std::shared_ptr and std::unique_ptr
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较std::shared_ptr和std::unique_ptr
- en: Converting from a unique_ptr into a shared_ptr
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从unique_ptr转换为shared_ptr
- en: Working with circular references
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理循环引用
- en: Typecasting with smart pointers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能指针进行类型转换
- en: The heap under a microscope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大堆内存
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install Valgrind using the following
    command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有对运行Ubuntu 18.04的计算机的管理访问权限，并具有功能正常的互联网连接。在运行这些示例之前，您必须使用以下命令安装Valgrind：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是在Ubuntu 18.04之外的任何操作系统上安装的，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10)找到。
- en: Comparing std::shared_ptr and std::unique_ptr
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较std::shared_ptr和std::unique_ptr
- en: In this recipe, we will learn about why the C++ Core Guidelines discourage the
    use of manually calling new and delete and why, instead, they recommend the use
    of `std::unique_ptr` and `std::shared_ptr`. We will also learn about the differences
    between a `std::unique_ptr` and a `std::shared_ptr` and why a `std::shared_ptr`
    should only be used in certain scenarios (that is, why `std::unique_ptr` is likely
    to be the smart pointer type that you should be using in most scenarios). This
    recipe is important as it will teach you how to properly allocate dynamic (heap)
    memory in modern C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习为什么C++核心指南不鼓励手动调用new和delete，而是建议使用`std::unique_ptr`和`std::shared_ptr`。我们还将了解`std::unique_ptr`和`std::shared_ptr`之间的区别，以及为什么`std::shared_ptr`应该只在某些情况下使用（也就是说，为什么`std::unique_ptr`很可能是您在大多数情况下应该使用的智能指针类型）。这个示例很重要，因为它将教会你如何在现代C++中正确分配动态（堆）内存。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete this recipe:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令下载源代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In C++, there are three different ways to declare a variable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，有三种不同的声明变量的方式：
- en: '**Global variables**: These are variables that are globally accessible. On
    Linux, these usually exist in the `.data`, `.rodata`, or `.bss` sections of your
    executable.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量**：这些是全局可访问的变量。在Linux上，这些变量通常存在于可执行文件的`.data`、`.rodata`或`.bss`部分。'
- en: '**Stack variables**: These are variables that you define inside functions and
    reside in your application''s stack memory, which is managed by the compiler.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆变量**：这些是你在函数内定义的变量，驻留在应用程序的堆栈内存中，由编译器管理。'
- en: '**Heap variables**: These are variables that are created using `malloc()`/`free()`
    or `new()`/`delete()` and use heap memory that is managed by a dynamic memory
    management algorithm (for example, `dlmalloc`, `jemalloc`, `tcmalloc`, and so
    on).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆变量**：这些是使用`malloc()`/`free()`或`new()`/`delete()`创建的变量，并使用由动态内存管理算法（例如`dlmalloc`、`jemalloc`、`tcmalloc`等）管理的堆内存。'
- en: 'In this chapter, we will focus on the latter, that is, heap style memory allocation.
    You might already know that, in C++, memory is allocated using `new()` and `delete()`,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于堆式内存分配。你可能已经知道，在 C++ 中，内存是使用 `new()` 和 `delete()` 分配的，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see, an integer pointer (that is, a pointer that points to an integer)
    is allocated and then set to `42`. We use `new()` in C++ and not `malloc()` for
    the following reasons:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一个整数指针（也就是指向整数的指针）被分配，然后设置为 `42`。我们在 C++ 中使用 `new()` 而不是 `malloc()`
    有以下原因：
- en: '`malloc()` returns `void *` and not the type that we care about. This can lead
    to allocation mismatch bugs (that is, you intend to allocate a car, and instead
    you allocate an orange). In other words, `malloc()` does not provide type safety.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc()` 返回 `void *` 而不是我们关心的类型。这可能导致分配不匹配的 bug（也就是说，你想分配一辆车，但实际上分配了一个橙子）。换句话说，`malloc()`
    不提供类型安全性。'
- en: '`malloc()` requires a size parameter. In order to allocate memory, we are required
    to know how many bytes to allocate for the type that we care about. This can lead
    to allocation size mismatch bugs (that is, you intend to allocate enough bytes
    for a car, but instead you only allocate enough bytes for an orange).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc()` 需要一个大小参数。为了分配内存，我们需要知道为我们关心的类型分配多少字节。这可能导致分配大小不匹配的 bug（也就是说，你想为一辆车分配足够的字节，但实际上只为一个橙子分配了足够的字节）。'
- en: '`malloc()` returns `NULL` on error, requiring `NULL` checks on every allocation.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc()` 在错误时返回 `NULL`，需要在每次分配时进行 `NULL` 检查。'
- en: 'The `new()` operator addresses all of these issues:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()` 运算符解决了所有这些问题：'
- en: '`new()` returns `T*`. As shown in the preceding example, this even allows for
    the use of `auto`, preventing redundancy, as C++''s type system has enough information
    to properly allocate and track the desired type.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()` 返回 `T*`。正如前面的例子所示，这甚至允许使用 `auto`，避免了冗余，因为 C++ 的类型系统有足够的信息来正确分配和跟踪所需的类型。'
- en: '`new()` doesn''t take a size argument. Instead, you tell it what type you want
    to allocate, which already has the size information about the type implicitly.
    Once again, by simply stating what you want to allocate, you get what you want
    to allocate, including the proper pointer and size.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()` 不需要大小参数。相反，你告诉它你想要分配的类型，这个类型已经隐含地包含了关于类型的大小信息。再一次，通过简单地声明你想要分配的内容，你就得到了你想要分配的内容，包括适当的指针和大小。'
- en: '`new()` throws an exception if the allocation fails. This prevents the need
    for `NULL` checks. If the next line of code executes, you are guaranteed that
    the allocation succeeds (assuming you do not have exceptions disabled).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()` 如果分配失败会抛出异常。这避免了需要进行 `NULL` 检查。如果下一行代码执行，你可以确保分配成功（假设你没有禁用异常）。'
- en: There is, however, still one issue with the `new()` operator; `new()` doesn't
    track ownership. Like `malloc()`, the `new()` operator returns a pointer, and
    this pointer can be passed around from function to function with no concept of
    who actually owns the pointer, which means it should delete the pointer when it
    is no longer needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`new()` 运算符仍然存在一个问题；`new()` 不跟踪所有权。和 `malloc()` 一样，`new()` 运算符返回一个指针，这个指针可以在函数之间传递，而没有实际拥有指针的概念，这意味着当不再需要指针时应该删除指针。
- en: 'This concept of ownership is a key component of the C++ Core Guidelines (in
    addition to memory spans) that attempts to address common bugs in C++ that result
    in instability, reliability, and security bugs. Let''s take a look at an example
    of this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权的概念是 C++ 核心指南的关键组成部分（除了内存跨度），旨在解决 C++ 中常见的导致不稳定、可靠性和安全性错误的 bug。让我们来看一个例子：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we allocate an integer pointer and then delete the
    pointer twice. In the previous example, we never actually delete the integer pointer
    prior to exiting the program. Now, consider the following code block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们分配了一个整数指针，然后两次删除了指针。在之前的例子中，我们实际上从未在退出程序之前删除整数指针。现在，考虑以下代码块：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we allocate an integer pointer, delete it, and then
    use it. Although these examples seem simple and obvious to avoid, in large, complex
    projects, these types of bugs occur often enough that the C++ community has developed
    static and dynamic analysis tools to identify these type of bugs automatically
    for us (although they are not perfect), as well as the C++ Core Guidelines themselves,
    in an attempt to prevent these types of bugs in the first place.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们分配了一个整数指针，删除了它，然后使用了它。尽管这些例子看起来简单明了，可以避免，但在大型复杂项目中，这些类型的 bug 经常发生，因此
    C++ 社区已经开发了静态和动态分析工具来自动识别这些类型的 bug（尽管它们并不完美），以及 C++ 核心指南本身，试图在第一时间防止这些类型的 bug。
- en: 'In C++11, the standards committee introduced `std::unique_ptr` to address this
    ownership issue with `new()` and `delete()`. Here is how it works:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中，标准委员会引入了 `std::unique_ptr` 来解决 `new()` 和 `delete()` 的所有权问题。它的工作原理如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we allocate an integer pointer using the `std::make_unique()`
    function. This function creates a `std::unique_ptr` and gives it a pointer that's
    allocated using `new()`. Here, the resulting pointer (for the most part) looks
    and behaves like a regular pointer, with the exception that the pointer is deleted
    automatically when `std::unique_ptr` loses scope. That is to say, `std::unique_ptr`
    owns the pointer that was allocated using `std::make_unique()` and is responsible
    for the lifetime of the pointer itself. In this example, we don't need to run
    `delete()` manually as `delete()` is run for us when the `main()` function is
    complete (as that is when `std::unique_ptr` loses scope).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用 `std::make_unique()` 函数分配了一个整数指针。这个函数创建了一个 `std::unique_ptr` 并给它分配了一个使用
    `new()` 分配的指针。在这里，结果指针（大部分情况下）看起来和行为像一个常规指针，唯一的例外是当 `std::unique_ptr` 失去作用域时，指针会自动被删除。也就是说，`std::unique_ptr`
    拥有使用 `std::make_unique()` 分配的指针，并负责指针本身的生命周期。在这个例子中，我们不需要手动运行 `delete()`，因为当 `main()`
    函数完成时（也就是 `std::unique_ptr` 失去作用域时），`delete()` 会自动运行。
- en: 'Using this simple trick of managing ownership, all of the bugs shown in the
    preceding code can be avoided (for the most part, which we will get to later).
    Although the following code is not C++ Core Guideline compliant (as the subscript
    operator is discouraged), you can also allocate arrays using `std::unique_ptr`,
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管理所有权的这种简单技巧，可以避免前面代码中显示的大部分错误（我们稍后会讨论）。尽管以下代码不符合C++核心指南（因为下标运算符不被鼓励），但您也可以使用`std::unique_ptr`来分配数组，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As shown in the preceding code, we allocate a C-style array of size `100` and
    then set the first element in the array. In general, the only pointer type that
    you will ever need is `std::unique_ptr`. There are, however, some issues that
    can still arise:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们分配了一个大小为`100`的C风格数组，然后设置了数组中的第一个元素。一般来说，您唯一需要的指针类型是`std::unique_ptr`。然而，仍然可能出现一些问题：
- en: Not tracking the lifetime of a pointer properly, for example, allocating `std::unique_ptr`
    in a function and returning the resulting pointer. Once the function returns, `std::unique_ptr`
    loses scope and thus deletes the pointer you just returned. `std::unique_ptr`
    *does not* implement automatic garbage collection. You are still required to understand
    the lifetime of the pointer and how that affects your code.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未正确跟踪指针的生命周期，例如，在函数中分配`std::unique_ptr`并返回生成的指针。一旦函数返回，`std::unique_ptr`失去作用域，因此删除了刚刚返回的指针。`std::unique_ptr`
    *不* 实现自动垃圾回收。您仍然需要了解指针的生命周期以及它对代码的影响。
- en: It is still possible to leak memory (although far more difficult) by never providing `std::unique_ptr`
    with an opportunity to lose scope; for example, adding `std::unique_ptr` to a
    global list or allocating `std::unique_ptr` in a class that you manually allocate
    with `new()` and then leak. Once again, `std::unique_ptr` *does not* implement
    automatic garbage collection and you are still required to ensure `std::unique_ptr`
    loses scope when needed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管更加困难，但仍然有可能泄漏内存，因为从未给`std::unique_ptr`提供失去作用域的机会；例如，将`std::unique_ptr`添加到全局列表中，或者在使用`new()`手动分配的类中分配`std::unique_ptr`，然后泄漏。再次强调，`std::unique_ptr`
    *不* 实现自动垃圾回收，您仍然需要确保在需要时`std::unique_ptr`失去作用域。
- en: '`std::unique_ptr` is also not capable of supporting shared ownership. Although
    this is an issue, this type of scenario rarely occurs. In most scenarios, `std::unique_ptr`
    is all that you need to ensure proper ownership.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`也无法支持共享所有权。尽管这是一个问题，但这种类型的情况很少发生。在大多数情况下，`std::unique_ptr`就足以确保适当的所有权。'
- en: One question that is raised often is, *once the pointer is allocated, how do
    we safely pass this pointer to other functions?* The answer is, you use the `get()`
    function and pass the pointer as a regular, C-style pointer. `std::unique_ptr`
    defines ownership, not `NULL` pointer safety. `NULL` pointer safety is provided
    by the Guideline Support Library with the `gsl::not_null` wrapper and `expects()`
    macros.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经常提出的一个问题是，*一旦分配了指针，我们如何安全地将该指针传递给其他函数？* 答案是，您使用`get()`函数并将指针作为常规的C风格指针传递。`std::unique_ptr`定义所有权，而不是`NULL`指针安全。`NULL`指针安全由指南支持库提供，其中包括`gsl::not_null`包装器和`expects()`宏。
- en: 'How these are used depends on your pointer philosophy:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用这些取决于您的指针哲学：
- en: Some believe any function that takes a pointer as an argument should be checked
    for a `NULL` pointer. The advantage of this approach is a `NULL` pointer can be
    identified quickly and safely handled, while the disadvantage is the extra branch
    logic you are introducing to your code, which reduces performance and readability.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人认为，任何接受指针作为参数的函数都应该检查`NULL`指针。这种方法的优点是可以快速识别和安全处理`NULL`指针，而缺点是您引入了额外的分支逻辑，这会降低代码的性能和可读性。
- en: Some believe *public* functions that take a pointer as an argument should be
    checked for a `NULL` pointer. The advantage of this approach is an improvement
    in performance as not all functions need `NULL` pointer checks. The disadvantage
    of this approach is that the public interfaces still have extra branch logic.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人认为接受指针作为参数的*公共*函数应该检查`NULL`指针。这种方法的优点是，性能得到了改善，因为并非所有函数都需要`NULL`指针检查。这种方法的缺点是，公共接口仍然具有额外的分支逻辑。
- en: Some believe a function should simply document its expectations (called a contract).
    The benefit to this approach is that the `assert()` and `expects()` macros can
    be used to check for `NULL` pointers in debug mode to enforce this contract, while
    in release mode, there are no performance penalties. The disadvantage of this
    approach is that, in release mode, all bets are off.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人认为函数应该简单地记录其期望（称为合同）。这种方法的好处是，`assert()`和`expects()`宏可以在调试模式下用于检查`NULL`指针以强制执行此合同，而在发布模式下，不会有性能损失。这种方法的缺点是，在发布模式下，所有的赌注都关闭。
- en: Which approach you take will largely depend on the type of application you are
    writing. If you are writing the next Crush game, you will likely care more about
    the latter approach as it performs the best. If you are writing an application
    that will automatically pilot an aircraft, we all hope you are using the first
    approach.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您采取的方法很大程度上取决于您正在编写的应用程序类型。如果您正在编写下一个Crush游戏，您可能更关心后一种方法，因为它的性能最佳。如果您正在编写一个将自动驾驶飞机的应用程序，我们都希望您使用第一种方法。
- en: 'To demonstrate how to pass a pointer using `std::unique_ptr`, let''s look at
    the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`std::unique_ptr`传递指针，让我们看一下以下示例：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Suppose you have a super critical function that is executed as a thread, taking
    an integer pointer as an argument, and adding the provided integer to a global
    counter. The preceding implementation of this thread is an *all bets off*, cross
    your fingers, and hope for the best approach. This function can be implemented
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个作为线程执行的超级关键函数，该函数以整数指针作为参数，并将提供的整数添加到全局计数器中。该线程的前面实现是*所有的赌注都关闭*，交叉双手，然后希望最好的方法。可以实现此函数如下：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding function calls `std::terminate()` (not a very fault-tolerant
    approach) if the provided pointer is a `NULL` pointer. As we can see, this approach
    is hard to read as there is a lot of extra logic here. We could implement this
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数调用`std::terminate()`（不是一个非常容错的方法），如果提供的指针是`NULL`指针。正如我们所看到的，这种方法很难阅读，因为这里有很多额外的逻辑。我们可以按照以下方式实现这一点：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This does the same thing as a `NULL` pointer check (depending on how you define
    `gsl::not_null` to work, as this could also throw an exception). You could also
    implement this as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`NULL`指针检查做的事情相同（取决于您如何定义`gsl::not_null`的工作方式，因为这也可能会抛出异常）。您也可以按照以下方式实现这一点：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous example always checks for `NULL` pointers while the preceding approach
    uses the contract approach, allowing the check to be removed in release modes.
    You could also use `assert()` as well (if you are not using the GSL... which jokingly,
    of course, should never be the case).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例总是检查`NULL`指针，而前面的方法使用了合同方法，允许在发布模式中删除检查。您也可以使用`assert()`（如果您没有使用GSL...当然，这绝对不应该是这种情况）。
- en: 'It should also be noted that the C++ standards committee is working to add
    `expects()` logic as a core component of the language through the use of C++ contracts,
    a feature that was sadly removed from C++20, but will hopefully be added in future
    versions of the standard, as we might be able to write the preceding function
    as follows (and tell the compiler which approach we wish to use instead of having
    to manually write it):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，C++标准委员会正在通过使用C++合同将`expects()`逻辑作为语言的核心组件添加到语言中，这是一个遗憾的特性，它在C++20中被删除了，但希望它会在未来的标准版本中添加，因为我们可能能够按照以下方式编写前面的函数（并告诉编译器我们希望使用哪种方法，而不必手动编写）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can use this function as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式使用这个函数：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the preceding code example, we can observe the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码示例中，我们可以观察到以下内容：
- en: We allocate an integer pointer from the heap using `std::make_unique()`, which
    returns `std::unique_ptr()`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`std::make_unique()`从堆中分配一个整数指针，它返回`std::unique_ptr()`。
- en: We create an array of threads and execute each thread, passing the newly allocated
    pointer to each one.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个线程数组，并执行每个线程，将新分配的指针传递给每个线程。
- en: Finally, we wait for all of the threads to finish and output the resulting count.
    Since `std::unique_ptr` is scoped to the `main()` function, we must ensure that
    the threads finish prior to returning from the `main()` function.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们等待所有线程完成并输出结果计数。由于`std::unique_ptr`的作用域限于`main()`函数，我们必须确保线程在`main()`函数返回之前完成。
- en: 'The preceding example results in the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例导致以下输出：
- en: '![](img/174f4cca-9a24-4400-8cc9-193f3b2d646b.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/174f4cca-9a24-4400-8cc9-193f3b2d646b.png)'
- en: 'As we mentioned previously, the preceding example defines `std::unique_ptr`
    as scoped to the `main()` function, which means we must ensure the threads are
    done before the `main()` function returns. This type of scenario is not always
    the case. Let''s look at the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面提到的，前面的示例将`std::unique_ptr`定义为`main()`函数的作用域，这意味着我们必须确保线程在`main()`函数返回之前完成。这种情况并非总是如此。让我们看下面的例子：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we create a function that adds to a count when given an integer pointer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个函数，当给定一个整数指针时，它会增加一个计数：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the preceding code, the `main()` function is also identical to
    our previous example, with the exception that `std::unique_ptr` is created in
    its own scope, which is released before the threads are required to complete.
    This results in the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`main()`函数与我们之前的示例相同，唯一的区别是`std::unique_ptr`是在自己的作用域中创建的，并在需要完成线程之前释放。这导致以下输出：
- en: '![](img/cf6bd321-786d-4be2-9694-3287c2c6229f.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf6bd321-786d-4be2-9694-3287c2c6229f.png)'
- en: As shown in the preceding screenshot, the resulting output is garbage as the
    threads attempted to read from memory that has been deleted (that is, the threads
    were given a dangling pointer).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，由于线程试图从已删除的内存中读取（即，线程被给予了悬空指针），结果输出是垃圾。
- en: Although this is a simple example, this type of scenario can occur in more complex
    scenarios and the root of the issue is shared ownership. In this example, each
    thread owns the pointer. In other words, no one thread attempts to take sole ownership
    of the pointer (including the main thread that allocates and executes the other
    threads). Although this type of issue usually occurs in multithreaded applications
    that have this no master thread design, this can also occur in asynchronous logic
    where the pointer is allocated and then passed to multiple, asynchronous jobs
    whose lifetime and point of execution are unknown.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的例子，但在更复杂的情况下，这种情况可能会发生，问题的根源是共享所有权。在这个例子中，每个线程都拥有指针。换句话说，没有一个线程试图独占指针（包括分配和执行其他线程的主线程）。尽管这种问题通常发生在具有无主线程设计的多线程应用程序中，但这也可能发生在异步逻辑中，其中指针被分配然后传递给多个异步作业，其生命周期和执行点是未知的。
- en: To handle these specific types of issues, C++ provides `std::shared_ptr`. This
    is a wrapper around a managed object. Each time `std::shared_ptr` is copied, the
    managed object increases an internal counter, which is used to track how many
    owners the pointer (which the managed object stores) has. Each time `std::shared_ptr`
    loses scope, the managed object decreases the internal counter and deletes the
    pointer once this count reaches `0`. Using this approach, `std::shared_ptr` is
    capable of supporting a one-to-many ownership model, which can handle the scenarios
    we defined previously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些特定类型的问题，C++提供了`std::shared_ptr`。这是一个受控对象的包装器。每次复制`std::shared_ptr`时，受控对象会增加一个内部计数器，用于跟踪指针（受控对象存储的）的所有者数量。每次`std::shared_ptr`失去作用域时，受控对象会减少内部计数器，并在此计数达到`0`时删除指针。使用这种方法，`std::shared_ptr`能够支持一对多的所有权模型，可以处理我们之前定义的情况。
- en: 'Let''s look at the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As shown in the preceding code, we have the same thread function that increments
    a counter, but the difference is that it takes `std::shared_ptr` instead of a
    regular integer pointer. Now, we can implement our preceding example as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们有相同的线程函数来增加一个计数器，但不同之处在于它接受`std::shared_ptr`而不是常规整数指针。现在，我们可以按照前面的示例实现如下：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As shown in the preceding code, the pointer is created in its own scope, which
    is removed before the threads are required to complete. Unlike the previous example,
    however, this code results in the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，指针在自己的作用域中创建，然后在需要完成线程之前被移除。然而，与之前的示例不同，这段代码的结果如下：
- en: '![](img/510ee43e-1a06-46ff-8411-882af9ebb984.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/510ee43e-1a06-46ff-8411-882af9ebb984.png)'
- en: The reason the preceding code executes properly is the pointer's ownership is
    shared between all of the threads and the pointer itself is not deleted (even
    though the scope is lost) until all of the threads complete.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以能够正确执行，是因为指针的所有权在所有线程之间共享，并且指针本身在所有线程完成之前不会被删除（即使作用域丢失）。
- en: 'One final note: it might be tempting to use `std::shared_ptr` for all pointer
    types when `std::unique_ptr` should be used instead as it has nice typecasting
    APIs and, in theory, ensures that a function has a valid pointer. The reality
    is, regardless of the use of `std::shared_ptr` or `std::unique_ptr`, a function
    must perform its `NULL` checks as defined by your application''s needs as `std::shared_ptr`
    can still be created as a `NULL` pointer.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点说明：当`std::unique_ptr`应该被使用时，可能会诱人使用`std::shared_ptr`来代替，因为它具有良好的类型转换API，并且理论上可以确保函数具有有效的指针。现实情况是，无论使用`std::shared_ptr`还是`std::unique_ptr`，函数都必须根据应用程序的需求执行其`NULL`检查，因为`std::shared_ptr`仍然可以被创建为`NULL`指针。
- en: '`std::shared_ptr` also has added overhead, as it must store the deleter that
    it needs internally. It also requires an additional heap allocation for the managed
    object. Both `std::shared_ptr` and `std::unique_ptr` define pointer ownership.
    They do not provide automatic garbage collection (that is, they do not automatically
    handle pointer lifetime), nor do they guarantee a pointer is not `NULL`. `std::shared_ptr`
    should only be used when more than one thing must own the lifetime of a pointer
    to ensure the proper execution of your application; otherwise, use `std::unique_ptr`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`也有额外的开销，因为它必须在内部存储所需的删除器。它还需要为受管理对象进行额外的堆分配。`std::shared_ptr`和`std::unique_ptr`都定义了指针所有权。它们不提供自动垃圾回收（即它们不自动处理指针的生命周期），也不能保证指针不是`NULL`。`std::shared_ptr`应该只在多个东西必须拥有指针的生命周期以确保应用程序的正确执行时使用；否则，请使用`std::unique_ptr`。'
- en: Converting from a std::unique_ptr into a std::shared_ptr
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`std::unique_ptr`转换为`std::shared_ptr`
- en: In this recipe, we will learn how to convert from a `std::unique_ptr` into a
    `std::shared_ptr`. This recipe is important as it is often convenient to define
    an API as accepting `std::unique_ptr` when the API itself really needs `std::shared_ptr`
    for internal use. A good example of this is when creating a GUI API. You might
    pass a widget to the API to store and own, without knowing if, later on down the
    road, the implementation of your GUI might need to add threads, in which case `std::shared_pointer`
    might be a better option. This recipe will provide you with the skills to convert
    a `std::unique_ptr` into a `std::shared_ptr` if needed, without having to modify
    the API itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何将`std::unique_ptr`转换为`std::shared_ptr`。这个配方很重要，因为通常在定义API时，接受`std::unique_ptr`是很方便的，而API本身实际上需要`std::shared_ptr`来进行内部使用。一个很好的例子是创建GUI
    API。您可能会将一个小部件传递给API来存储和拥有，而不知道以后在GUI的实现中可能需要添加线程，这种情况下`std::shared_pointer`可能是一个更好的选择。这个配方将为您提供将`std::unique_ptr`转换为`std::shared_ptr`的技能，如果需要的话，而不必修改API本身。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Follow these steps to complete this recipe:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个配方：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端中运行以下命令来下载源代码：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To compile the source code, run the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本配方中的每个示例：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本配方中所教授的课程的关系。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: '`std::shared_ptr` is used to manage a pointer when more than one thing must
    own the pointer for the application to execute properly. Suppose, however, that
    you provide an API that must accept an integer pointer, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`用于管理指针，当多个东西必须拥有指针才能正确执行应用程序时。然而，假设您提供了一个必须接受整数指针的API，如下所示：'
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding API suggests that whoever calls this function owns the integer
    pointer. That is, whoever calls this function is required to allocate the integer
    pointer, as well as delete it once the function is complete. If, however, we intend
    for the preceding API to own the pointer, we really should write this API as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的API表明，调用这个函数的人拥有整数指针。也就是说，调用这个函数的人需要分配整数指针，并在函数完成后删除它。然而，如果我们打算让前面的API拥有指针，我们真的应该将这个API写成如下形式：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This API says, *please allocate me an integer pointer, but I own it once it''s
    passed and will ensure it is deleted when needed.* Now, suppose this function
    will use this pointer in a one-to-many ownership scenario. What do you do? You
    could write your API as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API说，*请为我分配一个整数指针，但一旦传递给我，我就拥有它，并将在需要时确保它被删除。*现在，假设这个函数将在一个一对多的所有权场景中使用这个指针。你会怎么做？你可以将你的API写成下面这样：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This would, however, prevent your API from optimizing the one-to-many relationship
    in the future (that is, if you were able to remove this relationship in the future,
    you would still be stuck with `std::shared_ptr`, even though it is suboptimal
    without having to modify the API's function signature).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将阻止您的API在将来优化一对多的关系（也就是说，如果将来能够移除这种关系，您仍将被困在`std::shared_ptr`中，即使在不修改API函数签名的情况下，它也是次优的）。
- en: 'To solve this, the C++ APIs provide the ability to convert a `std::unique_ptr` into
    a `std::shared_ptr`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++ API提供了将`std::unique_ptr`转换为`std::shared_ptr`的能力，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Suppose we have an internal function that, for now, takes an integer pointer
    as a `std::shared_ptr`, uses its value to increment `count`, and executes it as
    a thread. Then, we provide a public API for it to use this internal function,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个内部函数，暂时以`std::shared_ptr`的整数指针作为参数，使用它的值来增加`count`，并将其作为线程执行。然后，我们为其提供一个公共API来使用这个内部函数，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As shown in the preceding code, our API claims ownership of a previously allocated
    integer pointer. Then, it creates a series of threads, executing each one and
    waiting for each thread to finish. The problem is that our internal function requires
    a `std::shared_ptr` (for example, maybe this internal function is used somewhere
    else in the code where there is a one-to-many ownership scenario that we cannot
    remove at the moment).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们的API声明拥有先前分配的整数指针。然后，它创建一系列线程，执行每一个并等待每个线程完成。问题在于我们的内部函数需要一个`std::shared_ptr`（例如，也许这个内部函数在代码的其他地方被使用，那里有一个一对多的所有权场景，我们目前无法移除）。
- en: To prevent the need to define our public API with `std::shared_ptr`, we can
    convert `std::unique_ptr` into `std::shared_ptr` by moving `std::unique_ptr` into
    a new `std::shared_ptr` and then calling our threads from there.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要用`std::shared_ptr`定义我们的公共API，我们可以通过将`std::unique_ptr`移动到一个新的`std::shared_ptr`中，然后从那里调用我们的线程来将`std::unique_ptr`转换为`std::shared_ptr`。
- en: '`std::move()` is required, as the only way to pass ownership of `std::unique_ptr`
    is through the use of `std::move()` (as only one `std::unique_ptr` can own the
    pointer at any given time).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::move()`是必需的，因为传递`std::unique_ptr`所有权的唯一方法是通过使用`std::move()`（因为在任何给定时间只有一个`std::unique_ptr`可以拥有指针）。'
- en: 'Now, we can execute this public API as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行这个公共API，如下所示：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/3662afb6-a730-4b83-a259-0d9182ad87de.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3662afb6-a730-4b83-a259-0d9182ad87de.png)'
- en: In the future, we might be able to remove the need for `std::shared_ptr` and
    pass `std::unique_ptr` to our internal function using the `get()` function, and,
    when that time comes, we won't have to modify the public API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们可能能够消除对`std::shared_ptr`的需求，并使用`get()`函数将`std::unique_ptr`传递给我们的内部函数，当那个时候，我们就不必修改公共API了。
- en: Working with circular references
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理循环引用
- en: In this recipe, we will learn how to work with circular references. A circular
    reference occurs when we're using more than one `std::shared_ptr`, where each
    `std::shared_ptr` owns a reference to the other. This recipe is important as this
    type of circular reference can occur when we're working with circularly dependent
    objects (although this should be avoided whenever possible). If it does occur,
    the shared nature of `std::shared_ptr` results in a memory leak. This recipe will
    provide you with the skills to avoid said memory leak using `std::weak_ptr`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何处理循环引用。循环引用发生在我们使用多个`std::shared_ptr`时，每个`std::shared_ptr`都拥有对另一个的引用。这个示例很重要，因为在处理循环依赖对象时可能会出现这种循环引用（尽管在可能的情况下应该避免）。如果发生了，`std::shared_ptr`的共享特性会导致内存泄漏。这个示例将教会你如何使用`std::weak_ptr`来避免这种内存泄漏。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To work with circular references, perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理循环引用，请执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code for this
    recipe:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令下载本示例的源代码：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To compile the source code, run the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例教授的课程的关系。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Although they should be avoided, circular references are likely to occur as
    your projects grow more and more complex and in size. If shared smart pointers
    are leveraged when these circular references occur, a hard to find memory leak
    can occur. To understand how this is possible, let''s look at the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应该避免，但随着项目变得越来越复杂和庞大，循环引用很可能会发生。当这些循环引用发生时，如果使用共享智能指针，可能会导致难以发现的内存泄漏。为了理解这是如何可能的，让我们看下面的例子：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding code, we start with two class prototypes. Circular
    references almost always start in this fashion as one class depends on another
    and vice versa, requiring the use of a class prototype.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们从两个类原型开始。循环引用几乎总是以这种方式开始，因为一个类依赖于另一个类，反之亦然，需要使用类原型。
- en: 'Let''s define a `car` as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`car`如下：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As shown in the preceding code, this is a simple class that stores a shared
    pointer to an `engine` and friends a function named `build_car()`. Now, we can
    define an `engine` as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，这是一个简单的类，它存储了一个指向`engine`的shared pointer，并且是`build_car()`函数的友元。现在，我们可以定义一个`engine`如下：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As shown in the preceding code, an `engine` is similar to a `car` with the difference
    that the engine stores a shared pointer to a car. Both, however, friend a `build_car()`
    function. Both also create default constructed shared pointers, meaning their
    shared pointers are `NULL` pointers at the time of construction.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`engine`类似于`car`，不同之处在于engine存储了一个指向car的shared pointer。两者都是`build_car()`函数的友元。它们都创建默认构造的shared
    pointers，这意味着它们的shared pointers在构造时是`NULL`指针。
- en: 'The `build_car()` function is used to complete the construction of each object,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_car()`函数用于完成每个对象的构建，如下所示：'
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown in the preceding code, we create each object and then set the car''s
    engine and vice versa. Since both the car and the engine are scoped to the `build_car()`
    function, we expect that these pointers will be deleted once the `build_car()`
    function returns. Now, we can execute this `build_car()` function as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们创建每个对象，然后设置car的engine，反之亦然。由于car和engine都限定在`build_car()`函数中，我们期望一旦`build_car()`函数返回，这些指针将被删除。现在，我们可以执行`build_car()`函数如下：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This seems like a simple program, but it has a hard to find memory leak. To
    demonstrate this, let''s run this application in `valgrind`, which is a dynamic
    memory analysis tool that''s capable of detecting memory leaks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个简单的程序，但却很难找到内存泄漏。为了证明这一点，让我们在`valgrind`中运行此应用程序，`valgrind`是一种动态内存分析工具，能够检测内存泄漏：
- en: '![](img/d039e626-58e3-4399-88f3-bb7b58a9d235.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d039e626-58e3-4399-88f3-bb7b58a9d235.png)'
- en: As shown in the preceding screenshot, `valgrind` says that memory was leaked.
    If we run `valgrind` with `--leak-check=full`, it will tell us that the memory
    leaks are with the car and engine shared pointers. The reason this memory leak
    occurs is that the car holds a shared reference to an engine. This same engine
    holds a shared reference to the car itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的截图显示，`valgrind`表示有内存泄漏。如果我们使用`--leak-check=full`运行`valgrind`，它会告诉我们内存泄漏出现在car和engine的shared
    pointers中。这种内存泄漏发生的原因是car持有对engine的shared reference。同样的engine也持有对car本身的shared
    reference。
- en: 'For example, consider the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in the preceding code, we have added a call to `use_count()`, which
    outputs the number of owners `std::shared_ptr` contains. If this is executed,
    we''ll see the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们添加了对`use_count()`的调用，它输出`std::shared_ptr`包含的所有者数量。如果执行此操作，将会看到以下输出：
- en: '![](img/0fe8e3a7-4ec9-46f6-9e6f-14f91b815586.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fe8e3a7-4ec9-46f6-9e6f-14f91b815586.png)'
- en: 'The reason we can see two owners is because the `build_car()` function holds
    a reference to a car and an engine here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到两个所有者是因为`build_car()`函数在这里持有对car和engine的引用：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The car holds a second reference to an engine because of this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，car持有对engine的第二个引用：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is also the same for the engine and the car. When the `build_car()` function
    completes, the following loses scope first:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于engine和car也是一样的。当`build_car()`函数完成时，以下内容首先失去了作用域：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The engine, however, is not deleted because the car still holds a reference
    to the engine. Then, the car loses scope:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，engine不会被删除，因为car仍然持有对engine的引用。然后，car失去了作用域：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, the car is not deleted because the engine (which hasn't been deleted
    yet) also holds a reference to the car. This results in `build_car()` returning
    with neither the car nor the engine being deleted because both still hold a reference
    to each other, with no means of telling either object to remove their references.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，car没有被删除，因为engine（尚未被删除）也持有对car的引用。这导致`build_car()`返回时，car和engine都没有被删除，因为它们仍然相互持有引用，没有办法告诉任何一个对象删除它们的引用。
- en: 'This type of circular memory leak, although easy to identify in our example,
    can be extremely difficult to identify in complex code, which is one of many reasons
    why shared pointers and circular dependencies should be avoided (usually a better
    design can remove the need for both). If this cannot be avoided, `std::weak_ptr`
    can be used instead, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的示例中很容易识别出这种循环内存泄漏，但在复杂的代码中很难识别，这是共享指针和循环依赖应该避免的许多原因之一（通常更好的设计可以消除对两者的需求）。如果无法避免，可以使用`std::weak_ptr`，如下所示：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As shown in the preceding code, we still define our car as holding a shared
    reference to an engine. We do this as we assume a car has a longer lifetime (that
    is, in our model, you can have a car without an engine, but you cannot have an
    engine without a car). The engine, however, is defined as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们仍然定义我们的car持有对engine的shared reference。我们这样做是因为我们假设car的寿命更长（也就是说，在我们的模型中，你可以有一辆没有发动机的车，但你不能没有车的发动机）。然而，engine的定义如下：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As shown in the preceding code, the engine now stores a weak reference to the
    car. Our `build_car()` function is defined as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，engine现在存储了对car的弱引用。我们的`build_car()`函数定义如下：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As shown in the preceding code, the `build_car()` function doesn''t change.
    The difference now is that, when we execute this application using `valgrind`,
    we see the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`build_car()`函数没有改变。现在的区别在于，当我们使用`valgrind`执行此应用程序时，会看到以下输出：
- en: '![](img/0ac121f9-776c-48ff-a5e0-fdbe56d97fa4.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ac121f9-776c-48ff-a5e0-fdbe56d97fa4.png)'
- en: As shown in the preceding screenshot, there are no memory leaks, and the `use_count()`
    for the car is `1`, while the `use_count()` for the engine is still `2` compared
    to the previous example. In the engine class, we use `std::weak_ptr`, which has
    access to the managed object `std::shared_ptr` manages, but doesn't increase the
    managed object's internal count when created. This provides `std::weak_ptr` with
    the ability to query whether `std::shared_ptr` is valid without having to hold
    a strong reference to the pointer itself.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，没有内存泄漏，汽车的`use_count()`为`1`，而引擎的`use_count()`与之前的例子相比仍为`2`。在引擎类中，我们使用`std::weak_ptr`，它可以访问`std::shared_ptr`管理的托管对象，但在创建时不会增加托管对象的内部计数。这使得`std::weak_ptr`能够查询`std::shared_ptr`是否有效，而无需持有指针本身的强引用。
- en: The reason the memory leak is removed is that, when the engine loses scope,
    its use count is decreased from `2` to `1`. Once the car loses scope, which only
    has a use count of `1`, it gets deleted, which in turn decrements the engine's
    use count to `0`, which causes the engine to be deleted as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏被消除的原因是，当引擎失去作用域时，其使用计数从`2`减少到`1`。一旦汽车失去作用域，其使用计数仅为`1`，就会被删除，从而将引擎的使用计数减少到`0`，这将导致引擎也被删除。
- en: 'The reason we use `std::weak_ptr` instead of a C-style pointer in the engine
    is because `std::weak_ptr` provides us with the ability to query the managed object
    to see if the pointer is still valid. For example, suppose we need to check whether
    the car still exists, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在引擎中使用`std::weak_ptr`而不是C风格指针的原因是，`std::weak_ptr`使我们能够查询托管对象，以查看指针是否仍然有效。例如，假设我们需要检查汽车是否仍然存在，如下所示：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using the `expired()` function, we can test to see whether the car still exists
    before using it, which is something that isn''t possible with a C-style pointer.
    Now, we can write our `build_car()` function as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`expired()`函数，我们可以在使用汽车之前测试汽车是否仍然存在，这是使用C风格指针无法实现的。现在，我们可以编写我们的`build_car()`函数如下：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding example, we create an engine and then create a new scope that
    creates our car. Then, we create our circular reference and lose scope. This causes
    the car to be deleted as expected. The difference is that our engine isn''t deleted
    yet as we still hold a reference to it. Now, we can run our test function, which
    results in the following output when it''s run with `valgrind`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个引擎，然后创建了一个创建汽车的新作用域。然后，我们创建了我们的循环引用并失去了作用域。这导致汽车被删除，这是预期的。不同之处在于，我们的引擎尚未被删除，因为我们仍然持有对它的引用。现在，我们可以运行我们的测试函数，当使用`valgrind`运行时，会得到以下输出：
- en: '![](img/37efcbf4-6ee5-4fef-b31a-150aa6c7b76f.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37efcbf4-6ee5-4fef-b31a-150aa6c7b76f.png)'
- en: As shown in the preceding screenshot, there are no memory leaks. `std::weak_ptr`
    successfully removed the chicken and egg problem that was introduced by the circular
    reference. As a result, `std::shared_ptr` is able to function as expected, releasing
    memory in the right order. In general, circular references and dependencies should
    be avoided whenever possible, but, if they cannot be avoided, `std::weak_ptr`,
    as shown in this recipe, can be used to prevent memory leaks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，没有内存泄漏。`std::weak_ptr`成功消除了循环引用引入的鸡和蛋问题。因此，`std::shared_ptr`能够按预期释放内存。通常情况下，应尽量避免循环引用和依赖关系，但如果无法避免，可以使用`std::weak_ptr`（如本教程所示）来防止内存泄漏。
- en: Typecasting with smart pointers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针进行类型转换
- en: In this recipe, we will learn how to typecast using `std::unique_ptr` and `std::shared_ptr`.
    Typecasting allows you to convert one type into another. This recipe is important
    as it demonstrates the proper way of handling typecasting with `std::unique_ptr`
    and `std::shared_ptr` when attempting to convert the smart pointer's type (for
    example, when upcasting or downcasting with virtual inheritance).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用`std::unique_ptr`和`std::shared_ptr`进行类型转换。类型转换允许将一种类型转换为另一种类型。本教程很重要，因为它演示了在尝试转换智能指针类型（例如，在虚拟继承中进行向上转型或向下转型）时，使用`std::unique_ptr`和`std::shared_ptr`处理类型转换的正确方式。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To see how typecasting works, perform the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解类型转换的工作原理，请执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To compile the source code, run the following command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Typecasting with smart pointers is not as straightforward as you might expect.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用智能指针进行类型转换并不像你期望的那样简单。
- en: 'To explain this better, let''s look at a simple example of how to typecast
    from a base class to a subclass using `std::unique_ptr`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们看一个简单的例子，演示如何使用`std::unique_ptr`从基类转换为子类：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s see how this works:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: 'We start with a virtual base class, as shown in the preceding code, and then
    we subclass the base class as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个虚拟基类开始，如前面的代码所示，然后我们将基类子类化如下：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we create a `std::unique_ptr` in our `main()` function and pass the pointer
    to a `foo()` function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`main()`函数中创建一个`std::unique_ptr`，并将指针传递给一个`foo()`函数：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`std::unique_ptr` simply owns the lifetime of the pointer. Any use of the pointer
    requires the use of the `get()` function, which converts `std::unique_ptr` into
    a normal, C-style pointer from that point on. This is the intended use of `std::unique_ptr`,
    since it isn''t designed to ensure pointer safety and is designed to ensure who
    owns the pointer is well-defined, ultimately determining when the pointer should
    be deleted.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`只是简单地拥有指针的生命周期。对指针的任何使用都需要使用`get()`函数，从那时起将`std::unique_ptr`转换为普通的C风格指针。这是`std::unique_ptr`的预期用法，因为它不是设计为确保指针安全，而是设计为确保谁拥有指针是明确定义的，最终确定指针何时应该被删除。'
- en: 'Now, the `foo()` function can be defined as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`foo()`函数可以定义如下：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As shown in the preceding code, the `foo()` function can treat the pointer as
    a normal C-style pointer, using `dynamic_cast()` to downcast from the base pointer
    back to the original subclass.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`foo()`函数可以将指针视为普通的C风格指针，使用`dynamic_cast()`从基类指针向下转换回原始子类。
- en: This same style of typecasting, which is standard C++, does not work with `std::shared_ptr`.
    The reason why is because the code that needs a typecast version of `std::shared_ptr`
    might also need to hold a reference to the pointer (that is, a copy of `std::shared_ptr`
    to prevent deletion).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++的这种类型转换方式在`std::shared_ptr`中不起作用。原因是需要类型转换版本的`std::shared_ptr`的代码可能还需要保存指针的引用（即`std::shared_ptr`的副本以防止删除）。
- en: That is, it is not possible to go from `base *b` to `std::shared_ptr<subclass>`
    because `std::shared_ptr` doesn't hold a reference to the pointer; instead, it
    holds a reference to a managed object, which stores the reference to the actual
    pointer. Since `base *b` doesn't store a managed object, there is no way to create
    a `std::shared_ptr` from it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，从`base *b`到`std::shared_ptr<subclass>`是不可能的，因为`std::shared_ptr`不持有指针的引用；相反，它持有托管对象的引用，该对象存储对实际指针的引用。由于`base
    *b`不存储托管对象，因此无法从中创建`std::shared_ptr`。
- en: 'C++ does, however, provide `std::shared_ptr` versions of `static_cast()`, `reinterpret_cast()`,
    `const_cast()`, and `dynamic_cast()` to perform the typecasting of shared pointers,
    which preserves the managed object when typecasting. Let''s take a look at an
    example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++提供了`std::shared_ptr`版本的`static_cast()`、`reinterpret_cast()`、`const_cast()`和`dynamic_cast()`来执行共享指针的类型转换，这样在类型转换时可以保留托管对象。让我们看一个例子：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As shown in the preceding code, we start with the same base and subclass. The
    difference occurs in our `foo()` function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们从相同的基类和子类开始。不同之处在于我们的`foo()`函数：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Instead of taking `base *b`, it takes `std::shared_ptr<base>`. Now, we can use
    the `std::dynamic_pointer_cast()` function instead of `dynamic_cast()` to downcast
    `std::shared_ptr<base>` to a `std::shared_ptr<subclass>`. The `std::shared_ptr`
    typecast functions provide us with the ability to typecast while still maintaining
    access to a `std::shared_ptr` as needed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它不再使用`base *b`，而是使用`std::shared_ptr<base>`。现在，我们可以使用`std::dynamic_pointer_cast()`函数而不是`dynamic_cast()`来将`std::shared_ptr<base>`向下转换为`std::shared_ptr<subclass>`。`std::shared_ptr`类型转换函数为我们提供了在需要时进行类型转换并仍然保持对`std::shared_ptr`的访问权限的能力。
- en: 'The resulting `main()` function will look like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`main()`函数将如下所示：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This results in the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/8b7d0aa2-1117-4b34-a220-0b1bba6777d6.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b7d0aa2-1117-4b34-a220-0b1bba6777d6.png)'
- en: It should be noted that we don't need to explicitly upcast as this can be done
    automatically (similar to regular pointers). We are only required to downcast
    explicitly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们不需要显式上转型，因为这可以自动完成（类似于常规指针）。我们只需要显式下转型。
- en: The heap under a microscope
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放大堆
- en: In this recipe, we will learn how the heap works in Linux. We will take a deeper
    look into how Linux actually provides heap memory when you use `std::unique_ptr`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习Linux中堆的工作原理。我们将深入了解Linux在您使用`std::unique_ptr`时如何提供堆内存。
- en: Although this recipe is intended for those of you who have more advanced capabilities,
    it is important as it will teach you what your application does to allocate memory
    from the heap (that is, using `new()`/`delete()`), which, in turn, will show you
    why heap allocations should never be done from time critical code, since they
    are slow. This recipe will teach you the skills you'll need when heap allocations
    are safe to perform and when heap allocations should be avoided in your applications,
    even if some of the assembly code that we inspect is hard to follow.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本示例是为那些具有更高级能力的人准备的，但它很重要，因为它将教会您如何从堆中分配内存（即使用`new()`/`delete()`）的应用程序，从而向您展示为什么堆分配不应该从时间关键代码中执行，因为它们很慢。本示例将教会您在何时执行堆分配是安全的，以及何时应该避免在您的应用程序中执行堆分配，即使我们检查的一些汇编代码很难跟踪。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To try the code files for this chapter, go through the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本章的代码文件，请按照以下步骤进行：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To compile the source code, run the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个步骤地介绍每个示例，并解释每个示例程序的作用以及它与本示例教授的课程的关系。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To better understand the extent to which code has to execute so as to allocate
    a variable on the heap, we will start with the following simple example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码需要执行多少次以在堆上分配变量，我们将从以下简单示例开始：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As shown in the preceding example, we allocate an integer using `std::unique_ptr()`.
    We use `std::unique_ptr()` as our starting point, as this is how most C++ Core
    Guideline code will allocate memory on the heap.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们使用`std::unique_ptr()`分配了一个整数。我们使用`std::unique_ptr()`作为起点，因为这是大多数C++核心指南代码在堆上分配内存的方式。
- en: 'The `std::make_unique()` function allocates a `std::unique_ptr` using the following
    pseudo logic (this is a simplified example as this doesn''t show how custom deleters
    are handled):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_unique()`函数使用以下伪逻辑分配了一个`std::unique_ptr`（这是一个简化的例子，因为这并没有显示如何处理自定义删除器）：'
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As shown in the preceding code, the `std::make_unique()` function creates a
    `std::unique_ptr` and gives it a pointer that it allocates with the `new()` operator.
    Once `std::unique_ptr` loses scope, it will delete the pointer using `delete()`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`std::make_unique()`函数创建了一个`std::unique_ptr`，并为其分配了一个使用`new()`操作符的指针。一旦`std::unique_ptr`失去作用域，它将使用`delete()`删除指针。
- en: 'When the compiler sees the new operator, it replaces the code with a call to
    operator `new(unsigned long)`. To see this, let''s look at the following example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到`new`操作符时，它会用对`new(unsigned long)`的调用替换代码。为了看到这一点，让我们看下面的例子：
- en: '[PRE66]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding example, we allocate a simple pointer using `new()`. Now,
    we can look at the resulting compiled assembly, which can be seen in the following
    screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`new()`分配了一个简单指针。现在，我们可以查看生成的汇编代码，如下截图所示：
- en: '![](img/b091f70c-4180-4aa8-a75b-8d820a238fbb.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b091f70c-4180-4aa8-a75b-8d820a238fbb.png)'
- en: 'As shown in the following screenshot, a call is made to `_Znwm`, which is mangled
    C++ code for `operator new(unsigned long)`, which is easy to demangle:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，调用了`_Znwm`，这是C++代码的名称修饰，对应的是`operator new(unsigned long)`，很容易进行名称还原：
- en: '![](img/c027acee-fceb-4dbb-89c2-3bd138eecd8c.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c027acee-fceb-4dbb-89c2-3bd138eecd8c.png)'
- en: 'The `new()` operator itself looks like the following pseudocode (note that
    this doesn''t take into account the ability to disable exception support or provide
    support for a new handler):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()`操作符本身看起来像以下伪代码（请注意，这不考虑禁用异常支持或提供新处理程序的能力）：'
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we can look at the new operator to see `malloc()` being called:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看`new`操作符，看看`malloc()`是如何被调用的：
- en: '![](img/837ddc0c-aa39-4480-a9dd-618520a38d5f.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/837ddc0c-aa39-4480-a9dd-618520a38d5f.png)'
- en: As shown in the preceding screenshot, `malloc()` is called. If the resulting
    pointer is not `NULL`, the operator returns; otherwise, it enters its error state,
    which involves calling a new handler and eventually throwing `std::bad_alloc()`
    (at least by default).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，调用了`malloc()`。如果结果指针不是`NULL`，则操作符返回；否则，它进入错误状态，这涉及调用新处理程序，最终抛出`std::bad_alloc()`（至少默认情况下）。
- en: The call to `malloc()` itself is far more complicated. When an application itself
    is started, the first thing it does is reserve heap space. The operating system
    gives every application a contiguous block of virtual memory to operate from,
    and the heap on Linux is the last block of memory in the application (that is,
    the memory that `new()` returns comes from the end of the application's memory
    space). Placing the heap here provides the operating system with a way to add
    additional memory to the application as it is needed (as the operating simply
    extends the end of the application's virtual memory).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`本身的调用要复杂得多。当应用程序启动时，它首先要做的是保留堆空间。操作系统为每个应用程序提供了一个连续的虚拟内存块，而在Linux上，堆是应用程序内存中的最后一个块（也就是说，`new()`返回的内存来自应用程序内存空间的末尾）。将堆放在这里为操作系统提供了一种在需要时向应用程序添加额外内存的方法（因为操作系统只是扩展应用程序的虚拟内存的末尾）。'
- en: The application itself uses the `sbrk()` function to ask the operating system
    for more memory when it runs out. When this function is called, the operating
    system allocates pages of memory from its internal page pool and maps this memory
    into the application by moving the end of the application's memory space. The
    map process itself is slow as the operating system not only has to allocate pages
    from the pool, which requires some sort of search and reservation logic, but it
    must also walk the application's page tables to add this additional memory to
    its virtual address space.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身使用`sbrk()`函数在内存不足时向操作系统请求更多内存。调用此函数时，操作系统会从内部页池中分配内存页，并通过移动应用程序的内存空间末尾将此内存映射到应用程序中。映射过程本身很慢，因为操作系统不仅需要从池中分配页，这需要某种搜索和保留逻辑，还必须遍历应用程序的页表，将此额外内存添加到其虚拟地址空间中。
- en: Once `sbrk()` has provided the application with additional memory, the `malloc()`
    engine takes over. As we mentioned previously, the operating system simply maps
    pages of memory into the application. Each page can be as small as 4k bytes to
    anywhere from 2 MB to even 1 GB, depending on the request. In our example, however,
    we allocated a simple integer, which is only `4` bytes in size. To convert pages
    into small objects without wasting memory, `malloc()` itself has an algorithm
    that breaks the memory provided by the operating system up into small blocks.
    This engine must also handle when these blocks of memory are freed so that they
    can be used again. This requires complex data structures to manage all of the
    application's memory, and each call to `malloc()`, `free()`, `new()`, and `delete()`
    has to exercise this logic.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`sbrk()`提供了额外内存，`malloc()`引擎接管。正如我们之前提到的，操作系统只是将内存页映射到应用程序中。每个页面的大小可以是4k字节，也可以是从2MB到1GB不等，具体取决于请求。然而，在我们的例子中，我们只分配了一个简单的整数，大小只有`4`字节。为了将页面转换为小对象而不浪费内存，`malloc()`本身有一个算法，将操作系统提供的内存分成小块。该引擎还必须处理这些内存块何时被释放，以便它们可以再次使用。这需要复杂的数据结构来管理应用程序的所有内存，并且每次调用`malloc()`、`free()`、`new()`和`delete()`都必须执行这种逻辑。
- en: A simple call to create a `std::unique_ptr` using `std::make_unique()` has to
    create `std::unique_ptr` with memory allocated from `new()`, which actually calls
    `malloc()`, which must search through a complex data structure to find a free
    block of memory that can eventually be returned, that is, assuming `malloc()`
    has free memory and doesn't have to ask the operating system for more memory using
    `sbrk()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::make_unique()`创建`std::unique_ptr`的简单调用必须使用`new()`分配内存来创建`std::unique_ptr`，而`new()`实际上调用`malloc()`，必须通过复杂的数据结构搜索可用的内存块，最终可以返回，也就是假设`malloc()`有空闲内存，并且不必使用`sbrk()`向操作系统请求更多内存。
- en: In other words, dynamic (that is, heap) memory is slow and should only be used
    when needed, and, ideally, not in time critical code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，动态（即堆）内存很慢，应该只在需要时使用，并且在时间关键的代码中最好不要使用。
