- en: Chapter 7.  Third-Party Libraries Without a Headache
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 无烦恼的第三方库
- en: In previous chapters, we have used our own libraries or the ones provided by
    Qt. In this chapter, we will learn how to integrate the third-party library OpenCV
    with a Qt project. This library will give you an impressive image processing toolbox.
    For each platform, you will learn to use a different specific compiler link configuration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了我们自己的库或 Qt 提供的库。在本章中，我们将学习如何将第三方库 OpenCV 集成到 Qt 项目中。这个库将为你提供一个令人印象深刻的图像处理工具箱。对于每个平台，你将学习使用不同的特定编译器链接配置。
- en: Qt Designer is a powerful WYSIWYG editor. This is why this chapter will also
    teach you to build a Qt Designer plugin that can be dragged and dropped from the
    **Widget Box** to the **Form Editor**, and then configured directly from Qt Creator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 是一个功能强大的 WYSIWYG 编辑器。这就是为什么本章还将教你如何构建一个可以从 **小部件框** 拖放到 **表单编辑器**
    的 Qt Designer 插件，并直接从 Qt Creator 进行配置。
- en: In the example project, the user can load a picture, select a filter from thumbnail
    previews, and save the result. This application will rely on OpenCV functions
    for image processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，用户可以加载一张图片，从缩略图预览中选择一个过滤器，并保存结果。这个应用程序将依赖于 OpenCV 函数进行图像处理。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Prepare a cross-platform project to host a third-party library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个跨平台项目以托管第三方库
- en: Link with a third party library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接第三方库
- en: Build a custom `QWidget` class using Qt Designer plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Designer 插件构建自定义 `QWidget` 类
- en: How the OpenCV API can work with Qt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV API 如何与 Qt 一起工作
- en: Create a Qt application that relies on a custom `QWidget` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个依赖于自定义 `QWidget` 类的 Qt 应用程序
- en: Creating your Qt Designer plugin
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的 Qt Designer 插件
- en: In [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop
    UI"), *Conquering the Desktop UI*, we created a custom Qt widget in Qt Designer
    using the promoting technique. It is now time to learn how to create a custom
    Qt widget by building a plugin for Qt Designer. Your widget will be available
    from the **Design mode** in the **Widget Box** alongside other regular Qt widgets.
    For this project example, we will create a `FilterWidget` class that processes
    an input image to apply a filter. The widget will also display the filter name
    and a dynamic thumbnail of the filtered picture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](part0040.xhtml#aid-164MG2 "第 4 章. 征服桌面 UI")，*征服桌面 UI* 中，我们使用提升技术，在
    Qt Designer 中创建了一个自定义 Qt 小部件。现在是时候学习如何通过为 Qt Designer 构建插件来创建自定义 Qt 小部件了。你的小部件将与其他常规
    Qt 小部件一起，在 **设计模式** 中的 **小部件框** 中可用。对于这个项目示例，我们将创建一个 `FilterWidget` 类，该类处理输入图像以应用过滤器。小部件还将显示过滤器名称和过滤后图片的动态缩略图。
- en: 'This project is composed of two sub-projects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由两个子项目组成：
- en: '`filter-plugin-designer`: This is a Qt Designer plugin containing `FilterWidget`
    class and the image processing code. This plugin is a dynamic library that will
    be used by the Qt Creator to offer our new `FilterWidget` in the **Form Editor**.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter-plugin-designer`: 这是一个包含 `FilterWidget` 类和图像处理代码的 Qt Designer 插件。这个插件是一个动态库，将被
    Qt Creator 使用，以便在 **表单编辑器** 中提供我们的新 `FilterWidget`。'
- en: '`image-filter`: This is a Qt Widget application using multiple `FilterWidget`.
    The user can open an image from their hard disk, select a filter (grayscale, blur,
    and so on), and save the filtered image.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image-filter`: 这是一个使用多个 `FilterWidget` 的 Qt 小部件应用程序。用户可以从他们的硬盘上打开一个图像，选择一个过滤器（灰度、模糊等），并保存过滤后的图像。'
- en: 'Our `filter-plugin-designer` will use the third-party library **OpenCV** (**Open
    Source Computer Vision**). It is a powerful, cross-platform open source library
    to manipulate images. Here is an overview schema:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `filter-plugin-designer` 将使用第三方库 **OpenCV**（**开源计算机视觉**）。这是一个强大的、跨平台的开源库，用于操作图像。以下是一个概述图：
- en: '![Creating your Qt Designer plugin](img/image00407.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的 Qt Designer 插件](img/image00407.jpeg)'
- en: You can see a plugin as a kind of module, which can be easily added to an existing
    software. A plugin must respect a specific interface to be automatically called
    by the application. In our case, the Qt Designer is the application that loads
    Qt plugins. So creating a plugin allows us to enhance the application without
    the need to modify the Qt Designer source code and recompile it. A plugin is a
    generally dynamic library (`.dll`/`.so`), so it will be loaded at runtime by the
    application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将插件视为一种模块，它可以轻松地添加到现有软件中。插件必须遵守特定的接口，才能被应用程序自动调用。在我们的案例中，Qt Designer是加载Qt插件的程序。因此，创建插件允许我们增强应用程序，而无需修改Qt
    Designer源代码并重新编译它。插件通常是一个动态库（`.dll`/`.so`），因此它将在运行时由应用程序加载。
- en: 'Now that you have a clear mind about the Qt Designer plugins, let''s build
    one! First, create a `Subdirs` project called `ch07-image-filter`. Then, you can
    add a subproject, `filter-plugin-designer`. You can use the **Empty qmake Project** template
    because we start this project from scratch. Here is the `filter-plugin-designer.pro`
    file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对Qt Designer插件有了清晰的认识，让我们来构建一个！首先，创建一个名为`ch07-image-filter`的`Subdirs`项目。然后，你可以添加一个子项目，`filter-plugin-designer`。你可以使用**空qmake项目**模板，因为我们从这个项目开始。以下是`filter-plugin-designer.pro`文件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note the `uiplugin` and `plugin` keywords for `QT` and `CONFIG`. They
    are required to create a Qt Designer plugin. We set the `TEMPLATE` keyword to `lib`
    because we are creating a dynamic library. The define, `FILTERPLUGINDESIGNER_LIBRARY`,
    will be used by the import/export mechanism of the library. We already covered
    this topic in [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your
    Project and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*.
    By default, our `TARGET` is `filter-plugin-designer`; the `$$qtLibraryTarget()`
    function will update it according to your platform. For example, the suffix "d"
    (standing for debug) will be appended on Windows. Finally, we append `target`
    to `INSTALLS`. Right now, this line does nothing, but we will describe a destination
    path for each platform soon; this way, executing the `make install` command will
    copy our target library file (`.dll`/`.so`) into the correct folder. To automatically
    perform this task on each compilation, you can add a new build step.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`uiplugin`和`plugin`关键字对于`QT`和`CONFIG`。它们是创建Qt Designer插件所必需的。我们将`TEMPLATE`关键字设置为`lib`，因为我们正在创建一个动态库。定义`FILTERPLUGINDESIGNER_LIBRARY`将被库的导入/导出机制使用。我们已经在[第3章](part0034.xhtml#aid-10DJ42
    "第3章。 划分你的项目和统治你的代码")中介绍了这个主题，*划分你的项目和统治你的代码*。默认情况下，我们的`TARGET`是`filter-plugin-designer`；`$$qtLibraryTarget()`函数将根据你的平台更新它。例如，Windows上会附加后缀“d”（代表调试）。最后，我们将`target`添加到`INSTALLS`中。目前，这一行没有任何作用，但我们将很快为每个平台指定一个目标路径；这样，执行`make
    install`命令将把我们的目标库文件（`.dll`/`.so`）复制到正确的文件夹。要自动在每个编译时执行此任务，你可以添加一个新的构建步骤。
- en: 'The deploy path is configured, but it will not be done automatically. Open
    the **Projects** tab and do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 部署路径已配置，但不会自动执行。打开**项目**选项卡，然后执行以下操作：
- en: Open the **Build Settings** | **Build Steps**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**构建设置** | **构建步骤**。
- en: Click on **Add Build Step** | **Make**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加构建步骤** | **Make**。
- en: In the **Make arguments** field, type `install`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建参数**字段中，输入`install`。
- en: 'You should get something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的结果：
- en: '![Creating your Qt Designer plugin](img/image00408.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的Qt Designer插件](img/image00408.jpeg)'
- en: Each time you build the project, the `make install` command will be called and
    it will deploy the library in Qt Creator.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建项目时，都会调用`make install`命令，并在Qt Creator中部署库。
- en: Configuring the project for Windows
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Windows项目
- en: 'Before preparing this project on Windows, let''s talk about the available choices
    when you develop a Qt application on a Windows host. The official Qt website provides
    multiple binary packages. We are mainly interested in the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上准备此项目之前，让我们谈谈在Windows主机上开发Qt应用程序时可供选择的内容。官方Qt网站提供了多个二进制包。我们主要关注以下内容：
- en: Qt for Windows 32-bit (MinGW)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 32位Qt（MinGW）
- en: Qt for Windows 32-bit (VS 2013)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 32位Qt（VS 2013）
- en: You may already be using one of these versions. The first one comes with a MinGW
    GCC compiler and the Qt framework. The second only provides the Qt framework and
    relies on the Microsoft Visual C++ compiler that will be installed with Visual
    Studio.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在使用这些版本中的某一个。第一个版本包含MinGW GCC编译器和Qt框架。第二个版本只提供Qt框架，并依赖于将随Visual Studio一起安装的Microsoft
    Visual C++编译器。
- en: Both versions are fine when you want to create a common Qt application for Windows.
    However, for this chapter, we want to link our `filter-plugin-designer` project
    with OpenCV libraries. Qt Designer must also be able to dynamically load `filter-plugin-designer`,
    so we must use a consistent compiler version at all stages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为Windows创建一个通用的Qt应用程序时，两个版本都很好。然而，对于本章，我们希望将我们的`filter-plugin-designer`项目与OpenCV库链接起来。Qt
    Designer还必须能够动态加载`filter-plugin-designer`，因此我们必须在所有阶段使用一致的编译器版本。
- en: Please note that Qt Creator on Windows is always based on MSVC, even in the
    MinGW binary package! So if you create a Qt Designer plugin using a MinGW compiler,
    your Qt Creator will not be able to load it. OpenCV for Windows provides only
    MSVC libraries, compile for MSVC11 (which is VS 2012), and MSVC12 (VS 2013).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Windows上的Qt Creator始终基于MSVC，即使在MinGW二进制包中也是如此！因此，如果你使用MinGW编译器创建Qt Designer插件，你的Qt
    Creator将无法加载它。Windows版本的OpenCV仅提供MSVC库，编译为MSVC11（即VS 2012）和MSVC12（VS 2013）。
- en: 'Here is a summary of the different solutions for building our project example
    in Windows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建我们的项目示例在Windows中的不同解决方案的总结：
- en: '![Configuring the project for Windows](img/image00409.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![为Windows配置项目](img/image00409.jpeg)'
- en: 'Keep in mind that for open-source software such as Qt Creator and OpenCV you
    can always try to compile them from a source with a different compiler. So, if
    you absolutely want to use a MinGW compiler, you must recompile OpenCV and Qt
    Creator from sources. Otherwise, we suggest that you use Qt for Windows 32-bit
    (VS 2013) as explained shortly. Here are the steps to prepare your development
    environment:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于像Qt Creator和OpenCV这样的开源软件，你总是可以尝试使用不同的编译器从源代码编译它们。因此，如果你绝对想使用MinGW编译器，你必须从源代码重新编译OpenCV和Qt
    Creator。否则，我们建议你使用稍后解释的Qt for Windows 32-bit (VS 2013)。以下是准备你的开发环境的步骤：
- en: Download and install Visual Studio Community Edition.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Visual Studio Community Edition。
- en: Download and install Qt for Windows 32-bit (VS 2013).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Qt for Windows 32-bit (VS 2013)。
- en: Download and extract OpenCV for Windows (for example: `C:\lib\opencv`).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压Windows版本的OpenCV（例如：`C:\lib\opencv`）。
- en: Create a new `OPENCV_HOME`: `C:\lib\opencv\build\x86\vc12` environment variable.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`OPENCV_HOME`环境变量：`C:\lib\opencv\build\x86\vc12`。
- en: Append to your system `Path`: `C:\lib\opencv\build\x86\vc12\bin` environment
    variable.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将系统环境变量`Path`追加为`C:\lib\opencv\build\x86\vc12\bin`。
- en: The `OPENCV_HOME` directory will be used in our `.pro` file. We also add an
    OpenCV libraries folder to the `Path` directory to easily resolve the dependencies
    at runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPENCV_HOME`目录将在我们的`.pro`文件中使用。我们还向`Path`目录添加了一个OpenCV库文件夹，以便在运行时轻松解决依赖关系。'
- en: 'You can now add the following snippet to the `filter-plugin-designer.pro` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将以下片段添加到`filter-plugin-designer.pro`文件中：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `target` path is set to the Qt Creator plugin folder. We also create a `target_lib`
    library to copy the `.lib` file generated by MSVC when we make a dynamic library
    (`.dll`). We add the OpenCV headers folder to the `INCLUDEPATH` to easily include
    them in our code. Finally, we update `LIBS` variable to link our plugin with the
    OpenCV modules (`core` and `imgproc`) from the OpenCV `lib` folder.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`路径设置为Qt Creator插件文件夹。我们还创建了一个`target_lib`库来复制由MSVC生成的`.lib`文件，当我们创建动态库（`.dll`）时。我们将OpenCV头文件文件夹添加到`INCLUDEPATH`，以便在代码中轻松包含它们。最后，我们更新`LIBS`变量，以便将我们的插件与OpenCV库（`core`和`imgproc`）链接起来，这些库来自OpenCV的`lib`文件夹。'
- en: Please note that the standalone Qt Designer application and the Qt Creator are
    different software. Both programs use a different plugin path. In our case, we
    only used the form editor from the Qt Creator, so we are targeting the Qt Creator
    plugin path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，独立的Qt Designer应用程序和Qt Creator是不同的软件。这两个程序使用不同的插件路径。在我们的案例中，我们只使用了Qt Creator中的表单编辑器，因此我们针对的是Qt
    Creator插件路径。
- en: Just as we appended `target` and `target_lib` to `INSTALLS`, both `.dll` and `.lib`
    files will be copied in the Qt Creator plugin path on a `make install` command.
    Qt Creator only requires the `.dll` file to load the plugin at runtime. The `.lib`
    file is only used to resolve the links with `filter-plugin-designer` when building
    our `image-filter` application. For simplicity, we are using the same directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将`target`和`target_lib`追加到`INSTALLS`一样，在`make install`命令中，`.dll`和`.lib`文件都将复制到Qt
    Creator插件路径。Qt Creator仅需要`.dll`文件在运行时加载插件。`.lib`文件仅用于在构建我们的`image-filter`应用程序时解决与`filter-plugin-designer`的链接。为了简单起见，我们使用相同的目录。
- en: Configuring the project for Linux
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Linux配置项目
- en: 'OpenCV binaries are certainly available in official software repositories.
    Depending on your distribution and your package manager, you can install it with
    commands such as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 二进制文件当然可以在官方软件仓库中找到。根据您的发行版和包管理器，您可以使用以下命令之一进行安装：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When OpenCV is installed on your Linux, you can add this snippet to the `filter-plugin-designer.pro`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OpenCV 在您的 Linux 上安装后，您可以将以下片段添加到 `filter-plugin-designer.pro` 文件中：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time we do not use the `LIBS` variable but `PKGCONFIG`, which relies on `pkg-config`.
    It is a helper tool that will insert the correct options into the compile command
    line. In our case, we will request `pkg-config` to link our project with OpenCV.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不使用 `LIBS` 变量，而是使用 `PKGCONFIG`，它依赖于 `pkg-config`。这是一个辅助工具，它将正确的选项插入到编译命令行中。在我们的情况下，我们将请求
    `pkg-config` 将我们的项目与 OpenCV 链接。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can list all the libs managed by `pkg-config` with the `pkg-config --list-all`
    command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pkg-config --list-all` 命令列出 `pkg-config` 管理的所有库。
- en: Configuring the project for Mac
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Mac 的项目
- en: The first step in making the project work on Mac OS is to install OpenCV. Fortunately,
    this is very easy using the `brew` command. If you develop on Mac OS and do not
    use it already, you should download it right now. In a nutshell, `brew` is an
    alternate package manager that gives you access to many packages (for developers
    and non-developers) that are not available on the Mac App Store.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS 上使项目工作的第一步是安装 OpenCV。幸运的是，使用 `brew` 命令非常简单。如果您在 Mac OS 上开发并且尚未使用它，您应该立即下载它。简而言之，`brew`
    是一个替代包管理器，它为您提供了访问许多包（针对开发人员和非开发者）的权限，这些包在 Mac App Store 上不可用。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download and install brew from [http://brew.sh/](http://brew.sh/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://brew.sh/](http://brew.sh/) 下载并安装 brew。
- en: 'In a terminal, simply type the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，只需输入以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will download, compile, and install OpenCV on your machine. At the time
    of writing, the latest OpenCV version available on brew was version 2.4.13\. Once
    this is done, open `filter-plugin-designer.pro` and add the following block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的机器上下载、编译和安装 OpenCV。在撰写本文时，brew 上可用的最新 OpenCV 版本是 2.4.13。完成此操作后，打开 `filter-plugin-designer.pro`
    并添加以下块：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We add OpenCV headers and link the path with `INCLUDEPATH` and `LIBS` variables.
    The `target` definition and `INSTALLS` are used to automatically deploy the output
    shared object to the Qt Creator application plugins directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加 OpenCV 头文件，并使用 `INCLUDEPATH` 和 `LIBS` 变量链接路径。`target` 定义和 `INSTALLS` 用于自动将输出共享对象部署到
    Qt Creator 应用程序插件目录。
- en: 'The last thing we have to do is to add an environment variable to let the Qt
    Creator know where it will find the library that will link it to the final application.
    In the **Projects** tab, go through the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的就是添加一个环境变量，让 Qt Creator 知道它将在哪里找到将链接到最终应用程序的库。在 **项目** 选项卡中，按照以下步骤操作：
- en: Open the **Details** window in **Build Environment**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **构建环境** 中打开 **详细信息** 窗口。
- en: Click on the **Add** Button.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 按钮。
- en: Type `DYLD_LIBRARY_PATH` in the `<VARIABLE>` field.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<VARIABLE>` 字段中输入 `DYLD_LIBRARY_PATH`。
- en: Type the path of the build directory in `<VALUE>` (you can copy and paste it
    from the section **General** | **Build directory**).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<VALUE>` 中输入构建目录的路径（您可以从 **通用** | **构建目录** 部分复制并粘贴）。
- en: Implementing your OpenCV filters
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现您的 OpenCV 过滤器
- en: 'Now that your development environment is ready, we can begin the fun part!
    We will implement three filters using OpenCV:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的开发环境已经准备好了，我们可以开始有趣的部分了！我们将使用 OpenCV 实现三个过滤器：
- en: '`FilterOriginal`: This filter does nothing and returns the same picture (lazy!)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilterOriginal`：这个过滤器什么都不做，返回相同的图片（懒惰！）'
- en: '`FilterGrayscale`: This filter converts a picture from color to grayscale'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilterGrayscale`：这个过滤器将图片从彩色转换为灰度'
- en: '`FilterBlur`: This filter smoothes the picture'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilterBlur`：这个过滤器使图片变得平滑'
- en: 'The parent class of all these filters is `Filter`. Here is this abstract class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些过滤器的父类是 `Filter`。以下是这个抽象类：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, `process()` is a pure abstract method. All filters will implement
    a specific behavior with this function. Let''s begin with the simple `FilterOriginal`
    class. Here is `FilterOriginal.h`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`process()` 是一个纯抽象方法。所有过滤器都将通过这个函数实现特定的行为。让我们从简单的 `FilterOriginal` 类开始。以下是
    `FilterOriginal.h`：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This class inherits `Filter` and we override the  `process()` function. The
    implementation is also really simple. Fill `FilterOriginal.cpp` with the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自 `Filter` 并重写了 `process()` 函数。实现也非常简单。在 `FilterOriginal.cpp` 中填写以下内容：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'No modification is performed; we return the same picture. Now that the filter
    structure is clear, we can create `FilterGrayscale`. The `.h`/`.cpp` files are
    close to `FilterOriginalFilter`, so let''s jump to the `process()` function of `FilterGrayscale.cpp`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有进行任何修改；我们返回相同的图片。现在过滤器结构已经清晰，我们可以创建`FilterGrayscale`。`.h`/`.cpp`文件接近`FilterOriginalFilter`，所以让我们跳转到`FilterGrayscale.cpp`的`process()`函数：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the Qt framework, we use the `QImage` class to manipulate pictures. In the
    OpenCV world, we use the `Mat` class, so the first step is to create a correct `Mat`
    object from the `QImage` source. OpenCV and Qt both handle many image formats.
    An image format describes the data bytes organization with information such as
    the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt框架中，我们使用`QImage`类来操作图片。在OpenCV世界中，我们使用`Mat`类，因此第一步是从`QImage`源创建一个正确的`Mat`对象。OpenCV和Qt都处理许多图像格式。图像格式描述了数据字节的组织，如下面的信息所示：
- en: '`Channel count`: A grayscale picture only needs one channel (white intensity),
    while a color picture requires three channels (red, green, and blue). You will
    even need four channels to handle the opacity (alpha) pixel information.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通道数`：灰度图片只需要一个通道（白色强度），而彩色图片需要三个通道（红色、绿色和蓝色）。处理不透明度（alpha）像素信息甚至需要四个通道。'
- en: '`Bit depth`: The number of bits used to store a pixel color.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位深度`：存储像素颜色的位数。'
- en: '`Channel order`: The most common orders are RGB and BGR. Alpha can be placed
    before or after the color information.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通道顺序`：最常见的顺序是RGB和BGR。Alpha可以放在颜色信息之前或之后。'
- en: 'For example, the OpenCV image format, `CV_8UC4`, means four channels of unsigned
    8-bit, which is the perfect fit for an alpha color picture. In our case, we are
    using a compatible Qt and OpenCV image format to convert our `QImage` in `Mat`.
    Here is a little summary:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenCV图像格式`CV_8UC4`表示四个无符号8位通道，这是alpha颜色图片的完美匹配。在我们的例子中，我们使用兼容的Qt和OpenCV图像格式将我们的`QImage`转换为`Mat`。以下是一个简短的总结：
- en: '![Implementing your OpenCV filters](img/image00410.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![实现你的OpenCV过滤器](img/image00410.jpeg)'
- en: 'Please note that some `QImage` class formats also depend on your platform endianness.
    The preceding table is for a little endian system. For OpenCV, the order is always
    the same: `BGRA`. It is not required in our project example, but you can swap
    blue and red channels as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些`QImage`类格式也取决于你的平台字节序。前面的表是为小端系统设计的。对于OpenCV，顺序始终相同：`BGRA`。在我们的项目示例中这不是必需的，但你可以按照以下方式交换蓝色和红色通道：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'OpenCV `Mat` and Qt `QImage` classes perform shallow construction/copy by default.
    This means that only metadata is really copied; the pixel data is shared. To create
    a deep copy of a picture, you must call the `copy()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的`Mat`和Qt的`QImage`类默认执行浅构造/复制。这意味着实际上只复制了元数据；像素数据是共享的。要创建图片的深拷贝，你必须调用`copy()`函数：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We created a `Mat` class called `tmp` from the `QImage` class. Note that `tmp`
    is not a deep copy of `image`; they share the same data pointer. Then, we can
    call the OpenCV function to convert the picture from color to grayscale using `cv::cvtColor()`.
    Finally, we create a `QImage` class from the grayscale `resultMat` element. In
    that case too, `resultMat` and `resultImage` share the same data pointer. Once
    we're done, we return a deep copy of `resultImage`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`QImage`类创建了一个名为`tmp`的`Mat`类。请注意，`tmp`不是`image`的深拷贝；它们共享相同的数据指针。然后，我们可以调用OpenCV函数使用`cv::cvtColor()`将图片从彩色转换为灰度。最后，我们从灰度`resultMat`元素创建一个`QImage`类。在这种情况下，`resultMat`和`resultImage`也共享相同的数据指针。完成操作后，我们返回`resultImage`的深拷贝。
- en: 'It is now time to implement the last filter. Here is the `process()` function
    of `FilterBlur.cpp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现最后一个过滤器了。以下是`FilterBlur.cpp`中的`process()`函数：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The conversion from `QImage` to `Mat` is the same. The processing differs because
    we use the `cv::GaussianBlur()` OpenCV function to smooth the picture. The `blur`
    is the kernel size used by the Gaussian blur. You can increase this value to get
    a softer picture, but only use an odd and positive number. Finally, we convert
    the `Mat` to `QImage` and return a deep copy to the caller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从`QImage`到`Mat`的转换是相同的。处理不同是因为我们使用`cv::GaussianBlur()`OpenCV函数来平滑图片。"blur"是高斯模糊使用的核大小。你可以增加这个值以获得更柔和的图片，但只能使用奇数和正数。最后，我们将`Mat`转换为`QImage`并返回给调用者的深拷贝。
- en: Designing the UI with FilterWidget
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FilterWidget设计UI
- en: 'Fine. Our filter classes are implemented, and we can now create our custom
    widget. This widget will take in input, a source, and a thumbnail picture. Then
    the thumbnail is immediately processed to display a preview of the filter. If
    the user clicks on the widget, it will process the source picture and trigger
    a signal with the filtered picture. Keep in mind that this widget will later be
    dragged and dropped in the **Form Editor** of Qt Creator. That''s why we will
    provide properties with getters and setters to select a filter from Qt Creator.
    Please create a new widget called `FilterWidget` using the **Qt Designer Form
    Class** template. The `FilterWidget.ui` is really simple:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们的过滤器类已经实现，现在我们可以创建我们的自定义小部件。这个小部件将接受输入、源图片和缩略图图片。然后缩略图立即处理以显示过滤器的预览。如果用户点击小部件，它将处理源图片并触发一个带有过滤后图片的信号。请注意，这个小部件稍后将被拖放到
    Qt Creator 的 **表单编辑器** 中。这就是为什么我们将提供带有获取器和设置器的属性来从 Qt Creator 中选择过滤器。请使用 **Qt
    Designer 表单类** 模板创建一个名为 `FilterWidget` 的新小部件。`FilterWidget.ui` 非常简单：
- en: '![Designing the UI with FilterWidget](img/image00411.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![使用 FilterWidget 设计 UI](img/image00411.jpeg)'
- en: 'The `titleLabel` is a `QLabel` on top of the `QWidget`. Below, `thumbnailLabel`
    will display the filtered picture thumbnail. Let''s switch to `FilterWidget.h`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`titleLabel` 是位于 `QWidget` 顶部的 `QLabel`。下面，`thumbnailLabel` 将显示过滤后的图片缩略图。让我们切换到
    `FilterWidget.h`：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The top part defines all the available filter types with the `enumFilterType`.
    We also use the Qtproperty system to expose the widget title and the current filter
    type to the **Property Editor** of Qt Creator. The syntax is like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分使用 `enumFilterType` 定义了所有可用的过滤器类型。我们还使用 Qtproperty 系统将小部件标题和当前过滤器类型暴露给 Qt
    Creator 的 **属性编辑器**。语法如下：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please note that exposing an enumeration requires it to be registered using
    the `Q_ENUM()` macro, so the **Property Editor** will display a combo box that
    allows you to choose the filter type from Qt Creator.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，暴露枚举需要使用 `Q_ENUM()` 宏进行注册，这样 **属性编辑器** 将显示一个组合框，允许您从 Qt Creator 中选择过滤器类型。
- en: The middle part lists all functions, slots, and signals. The most notable is
    the `process()` function that will use the current filter to modify the source
    picture. The `pictureProcessed()` signal will notify the application with the
    filtered picture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中间部分列出了所有函数、槽和信号。最值得注意的是 `process()` 函数，它将使用当前过滤器修改源图片。`pictureProcessed()`
    信号将通知应用程序带有过滤后图片的信号。
- en: The bottom part lists the picture and thumbnail `QImage` variables used in this
    class. In both cases, we handle both source and filtered pictures. The default
    source picture is an embedded picture in the plugin. This allows you to display
    a default preview when no thumbnail has been provided. The `mFilter` variable
    is a smart pointer to the current `Filter` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 底部部分列出了在这个类中使用的图片和缩略图 `QImage` 变量。在两种情况下，我们都处理了源图片和过滤后的图片。默认源图片是插件中嵌入的图片。这允许你在没有提供缩略图时显示默认预览。`mFilter`
    变量是当前 `Filter` 类的智能指针。
- en: 'Let''s switch to the implementation with `FilterWidget.cpp`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到 `FilterWidget.cpp` 的实现：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here are the constructor and the destructor. Please note that the default source
    picture loads an embedded picture of the gorgeous Lenna often used in image processing
    literature. The picture is in the resource file, `filter-plugin-designer.qrc`.
    The `mSourceThumbnail` function is initialized with a scaled picture of Lenna.
    The constructor calls the `setFilterType()`function to initialize an `Original`
    filter by default. Here is the core `process()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构造函数和析构函数。请注意，默认源图片加载了在图像处理文献中经常使用的美丽 Lenna 嵌入式图片。图片位于资源文件 `filter-plugin-designer.qrc`
    中。`mSourceThumbnail` 函数初始化为 Lenna 缩放后的图片。构造函数调用 `setFilterType()` 函数以默认初始化 `Original`
    过滤器。以下是核心的 `process()` 函数：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `process()` function is powerful, but really simple. We call `process()`
    of the current filter to update our filtered picture from the current source picture.
    Then we trigger the `pictureProcessed()` signal with the filtered picture. We
    can now add our `QImage` setters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()` 函数功能强大，但非常简单。我们调用当前过滤器的 `process()` 函数来更新从当前源图片中过滤后的图片。然后我们使用过滤后的图片触发
    `pictureProcessed()` 信号。现在我们可以添加我们的 `QImage` 设置器：'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `setSourcePicture()` function is a simple setter called by the application
    with a new source picture. The `updateThumbnail()` method will filter the new
    source thumbnail and display it. Let''s add the setters used by `Q_PROPERTY`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`setSourcePicture()` 函数是一个简单的设置器，由应用程序调用并传入新的源图片。`updateThumbnail()` 方法将过滤新的源缩略图并显示它。让我们添加由
    `Q_PROPERTY` 使用的设置器：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `setTitle()`function is a simple setter used to customize the widget title.
    Let's talk about the `setFilterType()` function. As you can see, this function
    does not just update the current filter type, `mFilterType`. Depending on the
    type, the corresponding filter will be created. Do you remember the smart pointer
    from [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your Project
    and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*? Here we
    are using a `unique_ptr` pointer for the `mFilter` variable, so we can use `make_unique`
    instead of a `new` raw. The `FilterWidget` class takes the ownership of the `Filter`
    class, and we do not need to worry about the memory management. Upon the `make_unique`
    instruction, the old owned pointer (if there is any) will be automatically deleted.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTitle()` 函数是一个简单的设置器，用于自定义小部件标题。让我们谈谈 `setFilterType()` 函数。如您所见，此函数不仅更新当前过滤器类型
    `mFilterType`，根据类型，还会创建相应的过滤器。你还记得第 3 章 [Dividing Your Project and Ruling Your
    Code](part0034.xhtml#aid-10DJ42 "第 3 章。 划分您的项目和统治您的代码") 中的智能指针吗？在这里，我们使用 `unique_ptr`
    指针为 `mFilter` 变量，因此我们可以使用 `make_unique` 而不是原始的 `new`。`FilterWidget` 类拥有 `Filter`
    类的所有权，我们不需要担心内存管理。在 `make_unique` 指令之后，旧的拥有指针（如果有）将被自动删除。'
- en: 'Finally, we call the `updateThumbnail()` function to display a filtered thumbnail
    corresponding to the selected filter type. Here are the getters and the mouse
    event handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `updateThumbnail()` 函数以显示与所选过滤器类型相对应的过滤缩略图。以下是获取器和鼠标事件处理程序：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `title()` and `filterType()` functions are getters used by the Qt Property
    System. We override the `mousePressEvent()` function to call our  `process()`
    function each time the user clicks on the widget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`title()` 和 `filterType()` 函数是 Qt 属性系统使用的获取器。我们重写 `mousePressEvent()` 函数，以便每次用户点击该小部件时都调用我们的
    `process()` 函数。'
- en: Exposing your plugin to Qt Designer
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的插件暴露给 Qt Designer
- en: The `FilterWidget` class is completed and ready to be used. We now have to register `FilterWidget`
    with the Qt Designer plugin system. This glue code is made using a child class
    of `QDesignerCustomWidgetInterface`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterWidget` 类已完成并准备好使用。我们现在必须将 `FilterWidget` 注册到 Qt Designer 插件系统中。这段粘合代码使用
    `QDesignerCustomWidgetInterface` 的子类制作。'
- en: 'Create a new C++ class named `FilterPluginDesigner` and update `FilterPluginDesigner.h`
    like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `FilterPluginDesigner` 的新 C++ 类，并按如下方式更新 `FilterPluginDesigner.h`：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `FilterPlugin` class inherits from two classes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterPlugin` 类从两个类继承：'
- en: The `QObject` class, to rely on the Qt parenting system
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObject` 类，以依赖 Qt 的父级系统'
- en: The `QDesignerCustomWidgetInterface` class to properly expose the `FilterWidget`
    information to the plugin system
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QDesignerCustomWidgetInterface` 类用于正确暴露 `FilterWidget` 信息给插件系统'
- en: 'The `QDesignerCustomWidgetInterface` class brings two new macros:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDesignerCustomWidgetInterface` 类引入了两个新的宏：'
- en: The `Q_PLUGIN_METADATA()` macro annotates the class to indicate a unique name
    for our filter to the meta-object system
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q_PLUGIN_METADATA()` 宏注释了该类，以向元对象系统指示我们过滤器的唯一名称'
- en: The `Q_INTERFACES()` macro tells the meta-object system which interface the
    current class has implemented
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q_INTERFACES()` 宏告诉元对象系统当前类实现了哪个接口'
- en: 'Qt Designer is now able to detect our plugin. We now have to provide information
    about the plugin itself. Update `FilterPluginDesigner.h`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 现在能够检测到我们的插件。我们现在必须提供有关插件本身的信息。更新 `FilterPluginDesigner.h`：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is much less overwhelming than it looks. The body of each one of these
    functions usually takes a single line. Here is the implementation of the most
    straightforward functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这比看起来要简单得多。每个函数的主体通常只有一行。以下是这些最直接函数的实现：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, there isn''t much to say about these functions. Most of them
    will simply return a `QString` value that will be displayed on the appropriate
    spot in the Qt Designer UI. We will focus only on the most interesting ones. Let''s
    start with `includeFile()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，关于这些函数没有太多可说的。大多数函数将简单地返回一个 `QString` 值，该值将在 Qt Designer UI 的适当位置显示。我们只关注最有趣的函数。让我们从
    `includeFile()` 开始：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function will be called by `uic` (**User Interface Compiler**) to generate
    the header corresponding to a `.ui` file. Continuing with `createWidget()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将由 `uic`（**用户界面编译器**）调用，以生成对应于 `.ui` 文件的头文件。继续使用 `createWidget()`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function makes the bridge between Qt Designer and `FilterWidget`. When
    you add the `FilterWidget` class in a `.ui` file, Qt Designer will call the `createWidget()`
    function to have an instance of the `FilterWidget` class and display its content.
    It also provides the `parent` element to which `FilterWidget` will be attached.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在 Qt Designer 和 `FilterWidget` 之间建立桥梁。当你在 `.ui` 文件中添加 `FilterWidget` 类时，Qt
    Designer 将调用 `createWidget()` 函数来创建 `FilterWidget` 类的一个实例并显示其内容。它还提供了 `parent`
    元素，`FilterWidget` 将附加到该元素上。
- en: 'Let''s finish with `initialize()`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `initialize()` 结束：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nothing much is done in this function. However, the `QDesignerFormEditorInterface*`
    parameter is worth some explanation. This pointer, provided by Qt Designer, gives
    access to a few of Qt Designer''s components via functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中并没有做太多事情。然而，`QDesignerFormEditorInterface*` 参数值得一些解释。这个指针由 Qt Designer
    提供，通过函数可以访问 Qt Designer 的几个组件：
- en: '`actionEditor()`: This function is the action editor (bottom panel of the designer)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionEditor()`: 这个函数是动作编辑器（设计器的底部面板）'
- en: '`formWindowManager()`: This function is the interface that enables you to create
    a new form window'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formWindowManager()`: 这个函数是允许你创建新表单窗口的接口'
- en: '`objectInspector()`: This function is the hierarchical representation of your
    layout (top right panel of the designer)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectInspector()`: 这个函数是您布局的层次表示（设计器的右上角面板）'
- en: '`propertyEditor()`: This function is the list of all the editable properties
    of the currently selected widget (bottom right panel of the designer)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyEditor()`: 这个函数是当前选中小部件的所有可编辑属性的列表（设计器的右下角面板）'
- en: '`topLevel()`: This function is the top-level widget of the designer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topLevel()`: 这个函数是设计器的顶级小部件'
- en: We covered each of these panels in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. 
    Get Your Qt Feet Wet"), *Get Your Qt Feet Wet*. If your widget plugin needs to
    intervene in any of these areas, this function is the entry point to customize
    the behavior of Qt Designer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](part0014.xhtml#aid-DB7S1 "第 1 章。初识 Qt") 中介绍了这些面板，*初识 Qt*。如果您的小部件插件需要干预这些区域中的任何一个，这个函数就是自定义
    Qt Designer 行为的入口点。
- en: Using your Qt Designer plugin
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的 Qt Designer 插件
- en: Our custom plugin is now finished. Because we added a custom `Build` command
    to automatically deploy the filter-widget library, it should be visible in Qt
    Designer. The deploy path we specified is inside the Qt Creator directory. Qt
    Creator integrates Qt Designer via a plugin that displays the UI inside Qt Creator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制插件现在已经完成。因为我们添加了一个定制的 `Build` 命令来自动部署 filter-widget 库，所以它应该在 Qt Designer
    中可见。我们指定的部署路径在 Qt Creator 目录内。Qt Creator 通过一个插件集成 Qt Designer，该插件在 Qt Creator
    内部显示 UI。
- en: When Qt Creator starts, it will try to load every library available in its specific
    paths. This means that you have to restart Qt Creator each time you modify the
    plugin (if you want to see the result of your modifications in the designer).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Qt Creator 启动时，它将尝试加载其特定路径下可用的每个库。这意味着每次你修改插件时（如果你想在设计器中看到修改的结果），你都必须重新启动
    Qt Creator。
- en: To see the plugin in action, we now have to create the application project of
    the chapter. Create a **Qt Widgets Application** sub-project in the `ch07-image-filter`
    project named `image-filter`. In the wizard, let it generate the form, `MainWindow.ui`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到插件的实际效果，我们现在必须创建本章的应用程序项目。在 `ch07-image-filter` 项目中创建一个名为 `image-filter`
    的 **Qt Widgets Application** 子项目。在向导中，让它生成表单，`MainWindow.ui`。
- en: 'To properly use the plugin, just link the `filter-plugin-designer` library
    in `image-filter.pro` like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确使用插件，只需在 `image-filter.pro` 中链接 `filter-plugin-designer` 库，如下所示：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To have access to the headers of `filter-plugin-designer`, we simply add it
    to the `INCLUDEPATH` directory. Finally, the linker is instructed to link to the
    library we deployed in Qt Creator. This ensures that the same library is used
    by Qt Designer and by our application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `filter-plugin-designer` 的头文件，我们只需将其添加到 `INCLUDEPATH` 目录。最后，链接器被指示链接到我们在
    Qt Creator 中部署的库。这确保了 Qt Designer 和我们的应用程序使用的是相同的库。
- en: 'Open the `MainWindow.ui` file and scroll to the bottom of the **Widget box**.
    Lo and behold, you should see this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.ui` 文件，并滚动到 `**Widget box**` 的底部。瞧，你应该能看到这个：
- en: '![Using your Qt Designer plugin](img/image00412.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用您的 Qt Designer 插件](img/image00412.jpeg)'
- en: 'The `FilterWidget` plugin appears under the Mastering Qt5 section. It even
    displays the famous Lenna as a preview icon. If you do not see the `FilterWidget`
    plugin, then restart Qt Creator and make sure that the plugin is properly loaded.
    To check this (in the **Design** tab), go to **Tools** | **Form Editor** | **About
    Qt Designer Plugins**. This is what it should display:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterWidget` 插件出现在 Mastering Qt5 部分。它甚至显示著名的 Lenna 作为预览图标。如果你看不到 `FilterWidget`
    插件，那么重新启动 Qt Creator 并确保插件已正确加载。为了检查这一点（在 **设计** 选项卡中），转到 **工具** | **表单编辑器** |
    **关于 Qt Designer 插件**。这是它应该显示的内容：'
- en: '![Using your Qt Designer plugin](img/image00413.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![使用你的 Qt Designer 插件](img/image00413.jpeg)'
- en: If the `FilterWidget` plugin does not appear in this list, you should check
    the Qt Creator plugin directory content (the path is stated in `image-filter.pro`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `FilterWidget` 插件没有出现在这个列表中，你应该检查 Qt Creator 插件目录的内容（路径在 `image-filter.pro`
    中声明）。
- en: Building the image-filter application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 image-filter 应用程序
- en: We can proceed to build the UI of the application. The idea is to open a picture
    from the filesystem and apply to it the various filters we developed in the `filter-designer-plugin`
    project. If you want to keep the result, you can save the resulting image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续构建应用程序的 UI。想法是从文件系统中打开一个图片，并应用我们在 `filter-designer-plugin` 项目中开发的各个过滤器。如果你想保留结果，你可以保存生成的图片。
- en: 'We will start by designing the UI. Modify `MainWindow.ui` to look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设计 UI。将 `MainWindow.ui` 修改如下：
- en: '![Building the image-filter application](img/image00414.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![构建 image-filter 应用程序](img/image00414.jpeg)'
- en: 'Here is the Object Inspector content to help you build this layout:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对象检查器内容，以帮助您构建此布局：
- en: '![Building the image-filter application](img/image00415.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![构建 image-filter 应用程序](img/image00415.jpeg)'
- en: 'There are three elements of this UI:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 UI 有三个元素：
- en: The `menuFile` element, which contains three possible actions: `actionOpenPicture`, `actionExit`,
    and `actionSaveAs`. You can see the details of these actions in the `Action Editor`
    window.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`menuFile` 元素，它包含三个可能的操作：`actionOpenPicture`、`actionExit` 和 `actionSaveAs`。您可以在
    `Action Editor` 窗口中查看这些操作的详细信息。'
- en: The `pictureLabel` element, which will display the loaded picture in the empty
    top part.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pictureLabel` 元素，它将在空顶部分显示加载的图片。'
- en: The `filtersLayout` element, which contains the three instances of our `FilterWidget`
    class in the bottom part.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtersLayout` 元素，它包含底部三个我们的 `FilterWidget` 类的实例。'
- en: As you add a `FilterWidget` class in `filtersLayout`, you can see that you can
    customize the `title` and the `filterType` in the **Property Editor** window.
    The preview will be automatically updated with the selected filter applied to
    our default picture. A dynamic preview like this is simply awesome, and you can
    foresee that your custom Qt Designer widgets can become quite powerful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `filtersLayout` 中添加 `FilterWidget` 类时，你可以看到你可以在 **属性编辑器** 窗口中自定义 `title`
    和 `filterType`。预览将自动更新为应用了所选过滤器的默认图片。这样的动态预览简直太棒了，你可以预见你的自定义 Qt Designer 小部件可以变得相当强大。
- en: 'Let''s implement the logic of our application. Update `MainWindow.h` like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现应用程序的逻辑。按照如下方式更新 `MainWindow.h`：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here are some elements that we have to explain:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们必须解释的元素：
- en: '`mSourcePicture`: This element is the loaded picture.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSourcePicture`：这个元素是加载的图片。'
- en: '`mSourceThumbnail`: This element is the generated thumbnail from `mSourcePicture`.
    To avoid wasting CPU cycles, `mSourcePicture` will be resized only once, and each
    of the `FilterWidget` instances will process this thumbnail rather than the full-resolution
    picture.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSourceThumbnail`：这个元素是从 `mSourcePicture` 生成的缩略图。为了避免浪费 CPU 循环，`mSourcePicture`
    只会调整大小一次，而每个 `FilterWidget` 实例将处理这个缩略图而不是全分辨率图片。'
- en: '`mCurrentPixmap`: This element is the currently displayed `QPixmap` in the `pictureLabel`
    widget.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCurrentPixmap`：这个元素是当前在 `pictureLabel` 小部件中显示的 `QPixmap`。'
- en: '`mCurrentFilter`: This element is the currently applied filter. Each time the
    user clicks on a different `FilterWidget`, this pointer will be updated.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCurrentFilter`：这个元素是当前应用的过滤器。每次用户点击不同的 `FilterWidget` 时，这个指针都会更新。'
- en: '`mFilters`: This element is a `QVector` of the `FilterWidget` class that we
    added to `MainWindow.ui`. It is only a helper, introduced to easily apply the
    same instructions to each `FilterWidget` class.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mFilters`：这个元素是我们添加到 `MainWindow.ui` 的 `FilterWidget` 类的 `QVector`。它只是一个辅助工具，引入了轻松应用相同指令到每个
    `FilterWidget` 类。'
- en: 'Now for the functions, we will limit ourselves to a broad overview. The details
    will be covered when we look at the implementation of each function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们概述一下函数，具体细节将在查看每个函数的实现时进行说明：
- en: '`loadPicture()`: This function triggers the whole pipeline. It will be called
    when the user clicks on `actionOpenPicture`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadPicture()`: 此函数触发整个管道。当用户点击 `actionOpenPicture` 时将调用此函数。'
- en: '`initFilters()`: This function is in charge of initializing `mFilters.`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initFilters()`: 此函数负责初始化 `mFilters`。'
- en: '`displayPicture()`: This function is the slot called by `mCurrentWidget::pictureProcessed()`
    to display the filtered picture.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayPicture()`: 此函数是 `mCurrentWidget::pictureProcessed()` 调用的插槽，用于显示过滤后的图片。'
- en: '`updatePicturePixmap()`: This function handles the display of `mCurrentPixmap`
    inside `pictureLabel`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePicturePixmap()`: 此函数处理在 `pictureLabel` 内显示 `mCurrentPixmap`。'
- en: 'Let''s look at the `MainWindow` class''s constructor implementation in `MainWindow.cpp`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `MainWindow` 类构造函数在 `MainWindow.cpp` 中的实现：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We connect the `actionOpenPicture::triggered()` signal to our yet-to-be-implemented `loadPicture()`
    function. The `actionExit` is straightforward; it is simply connected to the `QMainWindow::close()`
    slot. Finally, `initFilter()` is called. Let''s see its body:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `actionOpenPicture::triggered()` 信号连接到尚未实现的 `loadPicture()` 函数。`actionExit`
    操作很简单；它只是连接到 `QMainWindow::close()` 插槽。最后，调用 `initFilter()`。让我们看看它的主体：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each `FilterWidget` instance is added to `mFilters`. We then proceed to connect
    the `pictureProcessed()` signal to the `MainWindow::displayPicture` instruction
    and `mCurrentFilter` is initialized to the original filter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `FilterWidget` 实例都被添加到 `mFilters` 中。然后我们继续将 `pictureProcessed()` 信号连接到 `MainWindow::displayPicture`
    指令，并将 `mCurrentFilter` 初始化为原始过滤器。
- en: 'The class is now ready to load some pictures! This is the implementation of
    `loadPicture()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 类现在可以加载一些图片了！这是 `loadPicture()` 的实现：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The  `mSourcePicture` method is loaded using a `QFileDialog`, and `mSourceThumbnail`
    is generated from this input. Every `FilterWidget` class is updated with this
    new data and the `mCurrentFilter` element is triggered by calling its `process()`
    function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QFileDialog` 加载 `mSourcePicture` 方法，并从该输入生成 `mSourceThumbnail`。每个 `FilterWidget`
    类都使用这些新数据更新，并通过调用其 `process()` 函数触发 `mCurrentFilter` 元素。
- en: 'When `FilterWidget::process()` is finished, it emits the `pictureProcessed()`
    signal, which is connected to our `displayPicture()` slot. Let''s switch to this
    function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `FilterWidget::process()` 完成时，它会发出 `pictureProcessed()` 信号，该信号连接到我们的 `displayPicture()`
    插槽。让我们切换到这个函数：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Nothing very fancy here: `mCurrentPixmap` is updated from the given picture
    and the `updatePicturePixmap()` function is in charge of updating the `pictureLabel`
    element. Here is the implementation of `updatePicturePixmap()`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处：`mCurrentPixmap` 从给定的图片更新，而 `updatePicturePixmap()` 函数负责更新 `pictureLabel`
    元素。以下是 `updatePicturePixmap()` 的实现：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function simply creates a scaled version of `mCurrentPixmap` that fits
    inside `pictureLabel`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数简单地创建了一个缩放版本的 `mCurrentPixmap`，使其适合于 `pictureLabel` 内。
- en: The whole picture loading/filter processing is completed. If you run the application
    you should be able to load and modify your pictures. However, if you resize the
    window, you will see that the `pictureLabel` element does not scale very well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 整个图片加载/过滤处理已完成。如果您运行应用程序，您应该能够加载和修改您的图片。然而，如果您调整窗口大小，您会看到 `pictureLabel` 元素缩放得不是很好。
- en: 'To address this issue, we have to regenerate the scaled version of `mCurrentPixmap`
    each time the window is resized. Update `MainWindow` like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，每次窗口调整大小时，我们必须重新生成 `mCurrentPixmap` 的缩放版本。更新 `MainWindow` 如下：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the separation of `mCurrentPixmap` and the `pictureLabel` element's pixmap
    makes sense. Because we always generate the scaled version from the full-resolution `mCurrentPixmap`,
    we are sure that the resulting pixmap will look good.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将 `mCurrentPixmap` 和 `pictureLabel` 元素的 pixmap 分开是有意义的。因为我们总是从全分辨率的 `mCurrentPixmap`
    生成缩放版本，所以我们确信生成的 pixmap 会看起来很好。
- en: 'The image-filter application would not be complete without the ability to save
    your filtered picture. This will not take much effort. Here is the updated version
    of `MainWindow.h`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图像过滤器应用程序如果没有保存过滤后的图片的能力将是不完整的。这不会花费太多精力。以下是 `MainWindow.h` 的更新版本：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we simply added a `saveAsPicture()` function that will take the `mFilteredPicture`
    element and save it to a file. The implementation in `MainWindow.cpp` should not
    blow your mind:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地添加了一个 `saveAsPicture()` 函数，该函数将 `mFilteredPicture` 元素保存到文件中。`MainWindow.cpp`
    中的实现应该不会让您感到惊讶：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code snippet is long, but not very complex. The `actionSaveAs` function
    is enabled only when a picture is loaded. When the picture has been processed, `mFilteredPicture`
    is updated with the given picture. Because it is a reference, it costs absolutely
    nothing to store this filtered picture.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段虽然长，但并不复杂。`actionSaveAs` 函数仅在图片被加载时启用。当图片被处理完毕后，`mFilteredPicture` 会更新为给定的图片。因为它是一个引用，存储这个过滤后的图片几乎不花费任何代价。
- en: Finally, the `saveAsPicture()` function asks the user for a path and saves it
    using the `QImage` API, which tries to deduce the picture type based on the file
    extension.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`saveAsPicture()` 函数会询问用户路径，并使用 `QImage` API 保存图片，该 API 会尝试根据文件扩展名推断图片类型。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to integrate a third-party library with each
    desktop OS (Windows, Linux, and Mac). We chose the OpenCV library, which has been
    included in a custom Qt Designer plugin, and which can display a live preview
    of your image processing result in Qt Designer. We created an image filtering
    application that can open pictures, apply filters to them, and save the result
    on your machine.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将第三方库与每个桌面操作系统（Windows、Linux 和 Mac）集成。我们选择了 OpenCV 库，它已被包含在一个自定义的
    Qt Designer 插件中，并且可以在 Qt Designer 中显示你的图像处理结果的实时预览。我们创建了一个图像过滤应用程序，它可以打开图片，对它们应用过滤器，并将结果保存在你的机器上。
- en: We had a good look at how you can integrate third-party libraries and how to
    make a Qt Designer plugin. In the next chapter, we will push things forward by
    making the `image-filter` application ready to load filter plugins that could
    be implemented by third-party developers. To make things even cooler, we will
    cover the Qt animation framework to make the `image-filter` more spectacular.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仔细研究了如何集成第三方库以及如何创建一个 Qt Designer 插件。在下一章中，我们将通过使 `image-filter` 应用程序准备好加载由第三方开发者实现的过滤器插件来推进事情。为了使事情更加酷炫，我们将介绍
    Qt 动画框架，使 `image-filter` 更加引人注目。
