- en: 9\. Creating API Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 创建API服务
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In modern software development, most logic is served through distinct web services.
    This is essential to be able to both call and make new web services as a developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，大多数逻辑通过不同的Web服务提供。这对于作为开发人员能够调用和创建新的Web服务至关重要。
- en: In this chapter, you will be creating your own RESTful web service using the
    ASP.NET Core Web API template. You will learn not only how to do it but also some
    of the best practices for designing and building a Web API. You will also learn
    how to protect an API using Azure Active Directory (AAD), centralize error handling,
    troubleshoot errors, generate documentation, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用ASP.NET Core Web API模板创建自己的RESTful Web服务。您将学习如何做以及一些设计和构建Web API的最佳实践。您还将学习如何使用Azure
    Active Directory（AAD）保护API，集中处理错误，排除错误，生成文档等。
- en: By the end of this chapter, you will be able to create professional Web APIs
    that are secured with AAD, hosted on the cloud, scalable, and able to serve thousands
    of users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够创建受Azure Active Directory（AAD）保护、托管在云上、可扩展并能够为数千用户提供服务的专业Web API。
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: ASP.NET Core is a part of the .NET Core framework that is targeted at creating
    web apps. Using it, you can create both frontend (such as Razor or Blazor) and
    backend (such as Web API or gRPC) applications. However, in this chapter, you
    will be focusing on creating RESTful Web APIs. Creating a new web service for
    the first time might sound like a daunting task, but don't worry too much; for
    most scenarios, there is a template to get you started. In this chapter, you will
    create a few Web APIs using ASP.NET Core 6.0.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是.NET Core框架的一部分，旨在创建Web应用程序。使用它，您可以创建前端（如Razor或Blazor）和后端（如Web
    API或gRPC）应用程序。但是，在本章中，您将专注于创建RESTful Web API。首次创建新的Web服务可能听起来像是一项艰巨的任务，但不要太担心；对于大多数情况，都有一个模板可以帮助您入门。在本章中，您将使用ASP.NET
    Core 6.0创建一些Web API。
- en: ASP.NET Core Web API
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API
- en: In *Chapter 8*, *Creating and Using Web API Clients*, you learned how to call
    RESTful APIs. In this chapter, you will be making one. Web API is a template for
    creating RESTful Web APIs in .NET. It contains routing, Dependency Injection (DI),
    an example controller, logging, and other useful components to get you started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*中，*创建和使用Web API客户端*，您学习了如何调用RESTful API。在本章中，您将创建一个。Web API是用于在.NET中创建RESTful
    Web API的模板。它包含路由、依赖注入（DI）、示例控制器、日志记录和其他有用的组件，以帮助您入门。
- en: Creating a New Project
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'In order to create a new Web API, follow these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的Web API，请按照以下步骤操作：
- en: Create a new directory.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新目录。
- en: Name it after a project you want to create.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以您想要创建的项目命名它。
- en: Navigate to that directory using the `cd` command.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd`命令导航到该目录。
- en: 'Execute the following at the command line:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中执行以下操作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is all it takes to get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开始所需的全部。
- en: 'To see whether this is executing as expected, run the following and see your
    application come to life (*Figure 9.1*):'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看是否按预期执行，请运行以下命令并查看您的应用程序启动（*图9.1*）：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 9.1: Terminal window showing the port the application is hosted on'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：终端窗口显示应用程序托管的端口'
- en: '](img/B16835_09_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_01.jpg)'
- en: 'Figure 9.1: Terminal window showing the port the application is hosted on'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：终端窗口显示应用程序托管的端口
- en: In *Figure 9.1*, you will see port 7021 for the `https` version of the application.
    There may be multiple ports, especially if you are hosting both `HTTP` and `HTTPs`
    versions of an application. However, the key thing to remember is that you can
    the port where an application runs (for example, through the command line).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.1*中，您将看到应用程序`https`版本的端口7021。可能会有多个端口，特别是如果您同时托管`HTTP`和`HTTPs`版本的应用程序。但是，要记住的关键事情是您可以在哪个端口运行应用程序（例如，通过命令行）。
- en: A port is a channel through which you allow a certain application to be called
    by all other applications. It is a number that appears after a base URL and it
    allows a single application through. Those applications don't have to be outsiders;
    the same rules also apply to internal communication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是通过它允许其他所有应用程序调用某个特定应用程序的通道。它是一个出现在基本URL之后的数字，它允许一个单一的应用程序通过。这些应用程序不一定是外部应用程序；相同的规则也适用于内部通信。
- en: Localhost refers to an application hosted locally. Later in this chapter, you
    will configure the service to bind to whatever port you want.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本地主机指的是本地托管的应用程序。在本章后期，您将配置服务绑定到您想要的任何端口。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are 65,535 ports available on a single machine. Ports zero through 1023
    are called well-known ports because usually, the same parts of the system listen
    on them. Typically, if a single application is hosted on one machine, the port
    will be 80 for `http` and 443 for `https`. If you are hosting multiple applications,
    the ports will vary drastically (usually starting from port 1024).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单台计算机上有65,535个可用端口。端口0到1023被称为众所周知的端口，因为通常系统的相同部分会监听它们。通常情况下，如果一台计算机上托管了单个应用程序，端口将为`http`的80端口和`https`的443端口。如果托管多个应用程序，端口将会有很大的变化（通常从端口1024开始）。
- en: Web API Project Structure
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web API项目结构
- en: 'Every Web API is made of at least two classes—`Program` and one or more controllers
    (`WeatherForecastController` in this case):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web API至少由两个类组成—`Program`和一个或多个控制器（在本例中为`WeatherForecastController`）：
- en: 'Program: This is the **starting point** of an application. It serves as a low-level
    runner of an application and manages dependencies.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序：这是应用程序的**起点**。它作为应用程序的低级运行程序，并管理依赖关系。
- en: 'Controller: This is a `[Model]Controller`. In this example case, `WeatherForecastController`
    will be called using a `/weatherforecast` endpoint.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：这是一个`[Model]Controller`。在这个例子中，`WeatherForecastController`将使用`/weatherforecast`端点进行调用。
- en: '![Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：在VS Code中新创建的MyProject结构，并突出显示了关键部分'
- en: '](img/B16835_09_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_02.jpg)'
- en: 'Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：在VS Code中新创建的MyProject结构，并突出显示了关键部分
- en: An In-Depth Look at WeatherForecastController
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WeatherForecastController的深入了解
- en: 'The controller from the default template is preceded by two attributes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板中的控制器之前有两个属性：
- en: '`[ApiController]`: This attribute adds common, convenient (yet opinionated)
    Web API functionality.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ApiController]`：此属性添加了常见、方便（但是有主观意见）的Web API功能。'
- en: '`[Route("[controller]")]`: This attribute is used to provide a routing pattern
    of a given controller.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Route("[controller]")]`：此属性用于提供给定控制器的路由模式。'
- en: 'For example, in cases where these attributes are absent or the request is complex,
    you would need to validate an incoming HTTP request yourself without routing out
    of the box:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这些属性缺失或请求复杂的情况下，您需要自行验证传入的HTTP请求，而不是使用现成的路由：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This controller has `/WeatherForecast` as the route. The route is usually made
    of the word that precedes the word `Controller` unless specified otherwise. When
    developing APIs professionally, or when you have a client- and server-side application,
    it is recommended to preappend `/api` to the route, making it `[Route("api/[controller]")]`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该控制器的路由为`/WeatherForecast`。路由通常由单词`Controller`之前的单词组成，除非另有规定。在专业开发API或者在客户端和服务器端应用程序时，建议在路由前添加`/api`，使其成为`[Route("api/[controller]")]`。
- en: 'Next, you''ll learn about the controller class declaration. Common controller
    functions come from a derived `ControllerBase` class and a few components (usually
    a logger) and services. The only interesting bit here is that, instead of `Ilogger`,
    you use `ILogger<WeatherForecastController>`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将了解控制器类声明。常见的控制器函数来自派生的`ControllerBase`类和一些组件（通常是记录器）和服务。这里唯一有趣的部分是，您使用的不是`Ilogger`，而是`ILogger<WeatherForecastController>`：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reason behind using the generic part is solely for getting the context from
    the place where the log was called. Using a generic version of a logger, you use
    a fully qualified name of a class that is supplied as a generic argument. Calling
    `logger.Log` will prefix it with a context; in this case, it will be `Chapter09.Service.Controllers.WeatherForecastController[0]`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用部分的原因仅仅是为了从调用日志的地方获取上下文。使用记录器的通用版本，您使用作为通用参数提供的类的完全限定名称。调用`logger.Log`将在上下文前加上一个前缀；在这种情况下，它将是`Chapter09.Service.Controllers.WeatherForecastController[0]`。
- en: 'Lastly, look at the following controller method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，查看以下控制器方法：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `[HttpGet]` attribute binds the `Get` method with the root controller endpoint''s
    (`/WeatherForecast`) HTTP GET method. There is a version of that attribute for
    every HTTP method, and they are `HttpGet`, `HttpPost`, `HttpPatch`, `HttpPut`,
    and `HttpDelete`. To check whether the service works, run the application using
    the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpGet]`属性将`Get`方法与根控制器端点（`/WeatherForecast`）的HTTP GET方法绑定。每种HTTP方法都有一个版本的该属性，它们是`HttpGet`、`HttpPost`、`HttpPatch`、`HttpPut`和`HttpDelete`。要检查服务是否正常工作，请使用以下命令运行应用程序：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `-urls=https://localhost:7021/` argument is not a requirement. This
    argument simply makes sure that the port picked by .NET is the same as is indicated
    in this example during execution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-urls=https://localhost:7021/`参数不是必需的。该参数只是确保.NET选择的端口与执行期间在本示例中指示的端口相同。
- en: 'To see the output, navigate to `https://localhost:7021/weatherforecast/` in
    the browser. This will return a single default `WeatherForecast` upon calling
    HTTP GET:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输出，请在浏览器中导航到`https://localhost:7021/weatherforecast/`。这将在调用HTTP GET时返回一个默认的`WeatherForecast`：
- en: '`[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}]。`'
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When `https://localhost:7021/weatherforecast/` displays an error message (`localhost
    refused to connect`), it means that the application is likely running, but on
    a different port. So, always remember to specify a port as described in the *Creating
    a New Project* section (*Step 5*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当`https://localhost:7021/weatherforecast/`显示错误消息（`本地主机拒绝连接`）时，这意味着应用程序可能正在运行，但在不同的端口上。因此，请始终记住在*创建新项目*部分（*第5步*）中描述的指定端口。
- en: Responding with Different Status Codes
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同的状态码进行响应
- en: 'Find out what status codes can `public IEnumerable<WeatherForecast> Get()`
    respond with. Using the following steps, you can play around with it and inspect
    what happens in the browser:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 找出`public IEnumerable<WeatherForecast> Get()`可以响应的状态码。使用以下步骤，您可以尝试并检查浏览器中发生的情况：
- en: Navigate to `https://localhost:7021/weatherforecast/` in the browser.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`https://localhost:7021/weatherforecast/`。
- en: Click on `More tools`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“更多工具”。
- en: Select the `Developer tools` option. Alternatively, you can use the `F12` key
    to launch the developer tools.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“开发人员工具”选项。或者，您可以使用`F12`键启动开发人员工具。
- en: Next, click on the `Network` tab.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击“网络”选项卡。
- en: 'Click on the `Headers` tab. You will see that `https://localhost:7021/weatherforecast/`
    responds with `200` `Status Code`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“标头”选项卡。您会看到`https://localhost:7021/weatherforecast/`响应为`200`“状态码”：
- en: '![Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：开发工具网络选项卡-检查成功响应的响应标头'
- en: '](img/B16835_09_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_03.jpg)'
- en: 'Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：开发工具网络选项卡-检查成功响应的响应标头
- en: 'Create a new endpoint called `GetError` that throws an exception if a rare
    circumstance arises while a program is running:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GetError`的新端点，如果程序运行时出现罕见情况，则会引发异常：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, call `https://localhost:7021/weatherforecast/error`. It responds with
    a status code of `500`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用`https://localhost:7021/weatherforecast/error`。它响应状态码为`500`：
- en: '![Figure 9.4: Dev tools Network tab—inspecting a response with an exception'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4：开发工具网络选项卡-检查带有异常的响应'
- en: '](img/B16835_09_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_04.jpg)'
- en: 'Figure 9.4: Dev tools Network tab—inspecting a response with an exception'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：开发工具网络选项卡-检查带有异常的响应
- en: 'What should you do if you want a different status code to be returned? For
    that, the `BaseController` class contains utility methods for returning any kind
    of status code you require. For example, if you wanted to explicitly return an
    OK response, instead of returning a value right away, you could return `Ok(value)`.
    However, if you try changing the code, you will get the following error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要返回不同的状态代码，您应该怎么做？为此，`BaseController`类包含用于返回所需任何类型的状态代码的实用方法。例如，如果您想要明确返回一个OK响应，而不是立即返回一个值，您可以返回`Ok(value)`。但是，如果您尝试更改代码，您将收到以下错误：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This does not work because you do not return an HTTP status code from a controller;
    you either return some value or throw some error. To return any status code of
    your choice, you need to change the return type. For that reason, a controller
    should never have a return type of some value. It should always return the `IActionResult`
    type—a type that supports all status codes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为控制器不返回HTTP状态代码；您要么返回某个值，要么抛出某个错误。要返回您选择的任何状态代码，您需要更改返回类型。因此，控制器永远不应该有某个值的返回类型。它应该始终返回`IActionResult`类型
    - 一种支持所有状态代码的类型。
- en: 'Create one more method for getting the weather for any day of the week. If
    the day is not found (a value less than `1` or more than `7`), you will explicitly
    return `404 – not found`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何一周的天气添加一个方法。如果未找到该天（小于`1`或大于`7`的值），您将明确返回`404 - 未找到`：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, you added one new `{day}` at the end of the endpoint. This is a placeholder
    value, which comes from a matching function argument (in this case, `day`). Rerunning
    the service and navigating to `https://localhost:7021/weatherforecast/weekday/8`
    will result in a `404 – not found` status code because it is more than the max
    allowed day value, which is `7`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您在端点的末尾添加了一个新的`{day}`。这是一个占位符值，来自匹配函数参数（在本例中为`day`）。重新运行服务并导航到`https://localhost:7021/weatherforecast/weekday/8`将导致`404
    - 未找到`状态代码，因为它超过了允许的最大天数值，即`7`：
- en: '![Figure 9.5: The response to finding a weather forecast for a non-existent
    day of the week'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：查找不存在的一周天气预报的响应'
- en: '](img/B16835_09_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_05.jpg)'
- en: 'Figure 9.5: The response to finding a weather forecast for a non-existent day
    of the week'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：查找不存在的一周天气预报的响应
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SCudR](https://packt.link/SCudR).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/SCudR](https://packt.link/SCudR)找到此示例使用的代码。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本主题的理论部分。在接下来的部分中，您将通过练习将其付诸实践。
- en: 'Exercise 9.01: .NET Core Current Time Service'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：.NET Core当前时间服务
- en: 'Once you have managed to run a Web API once, adding new controllers should
    be trivial. Often, whether a service is running or not, it is checked using the
    most basic logic; whether it is returning OK or getting the current `DateTime`
    value. In this exercise, you will create a simple current time service returning
    the current time in ISO standard. Perform the following steps to do so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功运行了Web API一次，添加新的控制器应该是微不足道的。通常，无论服务是否正在运行，都会使用最基本的逻辑进行检查；它是返回OK还是获取当前的`DateTime`值。在这个练习中，您将创建一个简单的当前时间服务，返回ISO标准的当前时间。执行以下步骤来完成：
- en: 'Create a new controller called `TimeController` to get the local time and further
    add functions for testing purposes:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TimeController`的新控制器，以获取本地时间，并进一步添加用于测试目的的功能：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The controller shown here isn't just for testing; it acts as business logic
    too.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的控制器不仅用于测试；它也充当业务逻辑。
- en: 'Add an endpoint for HTTP GET called `GetCurrentTime` that points to the `time/current`
    route. You will use it to get the current time:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GetCurrentTime`的HTTP GET端点，指向`time/current`路由。您将用它来获取当前时间：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Return the current `DateTime` converted to a string in ISO format:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回当前的`DateTime`转换为ISO格式的字符串：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Navigate to `https://localhost:7021/time/current` and you should see the following
    response:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`https://localhost:7021/time/current`，您应该看到以下响应：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As mentioned in the *Web API Project Structure* section, you can use the endpoint
    to determine whether a service is running or not. If it is running, then you will
    get the `DateTime` value, which you saw in the preceding output. If it is not
    running, then you would get a response with a status code of `404 – not found`.
    If it is running but with problems, then you would get the `500` status code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Web API项目结构*部分所述，您可以使用端点来确定服务是否正在运行。如果正在运行，那么您将获得`DateTime`值，就像您在前面的输出中看到的那样。如果没有运行，那么您将获得一个带有`404
    - 未找到`状态代码的响应。如果正在运行但出现问题，那么您将获得`500`状态代码。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/OzaTd](https://packt.link/OzaTd).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/OzaTd](https://packt.link/OzaTd)找到此练习使用的代码。
- en: So far, all your focus was on a controller. It's time you shift your attention
    to another crucial part of a Web API—the `Program` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的重点都在控制器上。现在是时候将注意力转移到Web API的另一个关键部分 - `Program`类了。
- en: Bootstrapping a Web API
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导Web API
- en: The `Program` class wires up the whole API together. In layman's terms, you
    register the implementations for all the abstractions used by controllers and
    add all the necessary middleware.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类将整个API连接在一起。通俗地说，您为控制器注册了所有抽象的实现，并添加了所有必要的中间件。'
- en: Dependency Injection
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In *Chapter 2*, *Building Quality Object-Oriented Code*, you explored the concept
    of DI. In *Chapter 7*, *Creating Modern Web Applications with ASP.NET*, you had
    a look at an example of DI for logging services. In this chapter, you will get
    hands-on experience in DI and the Inversion of Control (IoC) container—a component
    used to wire up and resolve all the dependencies in a central place. In .NET Core
    and later, the default container is `Microsoft.Extensions.DependencyInjection`.
    You will learn more about that a bit later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第2章* *构建高质量的面向对象的代码* 中，您探讨了 DI 的概念。在 *第7章* *使用 ASP.NET 创建现代 Web 应用程序* 中，您看到了一个关于日志服务的
    DI 示例。在本章中，您将亲身体验 DI 和控制反转（IoC）容器 - 用于在一个中心位置连接和解析所有依赖关系的组件。在 .NET Core 及以后版本中，默认容器是
    `Microsoft.Extensions.DependencyInjection`。稍后您将更多地了解它。
- en: Program.cs and Minimal API
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Program.cs 和 Minimal API
- en: 'The simplest Web API in .NET 6 looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 中最简单的 Web API 如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a minimal API because it makes use of the top-level statements feature.
    Prior to .NET 6, you would have two methods within a `Startup` class (`Configure`
    and `ConfigureService`) and a `Program` class. Now you have a single file, `Program.cs`,
    and no classes or methods. You can still use the old way of starting an application.
    In fact, .NET 6 will generate similar classes under the hood. However, if you
    are making a new app in .NET 6, then using a minimal API should be preferred.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个最小的 API，因为它利用了顶级语句功能。在 .NET 6 之前，您会在 `Startup` 类（`Configure` 和 `ConfigureService`）和
    `Program` 类中有两个方法。现在，您只有一个文件 `Program.cs`，没有类或方法。您仍然可以使用旧的启动应用程序的方式。实际上，.NET 6
    将在幕后生成类似的类。但是，如果您在 .NET 6 中创建新应用程序，那么最好使用最小的 API。 '
- en: 'Break down the preceding code snippet. To start the application, you first
    need to build it. So, you will create a builder using the following line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 分解上述代码片段。要启动应用程序，首先需要构建它。因此，您将使用以下代码行创建一个构建器：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`builder.Services` specifies which services are to be injected. In this case,
    you registered the implementation of the controllers. So, here you have just one
    controller calling—that is, `WeatherForecastController`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder.Services` 指定要注入的服务。在这种情况下，您注册了控制器的实现。所以，这里只有一个控制器调用 - 即 `WeatherForecastController`：'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you use `builder.Build()`, you can access the `app` object and further
    configure the application by adding middleware. For example, to add controller
    routing, call the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `builder.Build()` 时，您可以访问 `app` 对象，并通过添加中间件进一步配置应用程序。例如，要添加控制器路由，请调用以下方法：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lastly, `builder.Environment.IsDevelopment()` checks whether the environment
    is developed. If it is developed, it calls `app.UseDeveloperExceptionPage();`,
    which adds detailed errors when something fails.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`builder.Environment.IsDevelopment()` 检查环境是否为开发环境。如果是开发环境，它将调用 `app.UseDeveloperExceptionPage();`，在发生错误时添加详细错误信息。
- en: Logging is not mentioned anywhere; yet you still use it. A common pattern is
    to group all the related injections under the same extension method for `IServiceCollection`.
    An example of an extension method for all the controller-related functionality,
    including logging, is the `AddControllers` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 日志没有在任何地方提及；但您仍在使用它。一个常见的模式是将所有相关的注入分组到同一个 `IServiceCollection` 的扩展方法下。包括日志记录在内的所有控制器相关功能的扩展方法的示例是
    `AddControllers` 方法。
- en: 'You already saw the logging messages sent through the console logger right
    after you ran the API. Under the hood, the `builder.Services.AddLogging` method
    is called. This method clears all the logging providers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了在运行 API 后通过控制台记录器发送的日志消息。在幕后，调用了 `builder.Services.AddLogging` 方法。该方法清除了所有记录提供程序：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you run the application now, you will not see anything appear in the console
    (*Figure 9.6*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行应用程序，您将看不到任何东西出现在控制台上（*图9.6*）：
- en: '![Figure 9.6: Running an application with no logs displayed'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6：运行应用程序时不显示任何日志'
- en: '](img/B16835_09_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_06.jpg)'
- en: 'Figure 9.6: Running an application with no logs displayed'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：运行应用程序时不显示任何日志
- en: 'However, if you modify `AddLogging` to include `Console` and `Debug` logging
    in the following way, you will see the logs as in *Figure 9.7*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果以以下方式修改 `AddLogging` 来包括 `Console` 和 `Debug` 日志，你将会看到日志，如 *图9.7* 所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, add an error logging functionality to the error endpoint of `WeatherForecastController`.
    This will throw an exception when a rare circumstance arises while a program is
    running:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将错误日志功能添加到 `WeatherForecastController` 的错误端点。当程序运行时出现罕见情况时，这将引发异常：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Restart the API with the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新启动 API：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, call `https://localhost:7021/weatherforecast/error` and this will show
    the logged message (compare *Figure 9.6* and *Figure 9.7*):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用 `https://localhost:7021/weatherforecast/error`，这将显示已记录的消息（比较 *图9.6* 和
    *图9.7*）：
- en: '![Figure 9.7: The error message, Whoops, displayed on the terminal'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：终端上显示的错误消息“Whoops”'
- en: '](img/B16835_09_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_07.jpg)'
- en: 'Figure 9.7: The error message, Whoops, displayed on the terminal'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：终端上显示的错误消息“Whoops”
- en: The Inner Workings of the AddLogging Method
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AddLogging` 方法的内部工作'
- en: 'How does the `AddLogging` method work? The decompiled code of the `AddLogging`
    method looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddLogging` 方法是如何工作的？`AddLogging` 方法的反编译代码如下：'
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is best practice not to initialize loggers by yourself. `ILoggerFactory`
    provides that functionality as a single place from which you may create loggers.
    While `ILoggerFactory` is an interface, `LoggerFactory` is an implementation of
    that interface. `AddSingleton` is a method that specifies that a single instance
    of `LoggerFactory` will be created and used whenever `ILoggerFactory` is referenced.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是不要自己初始化记录器。 `ILoggerFactory` 提供了这个功能，作为一个可以创建记录器的单一位置。虽然 `ILoggerFactory`
    是一个接口，`LoggerFactory` 是该接口的实现。`AddSingleton` 是一个方法，指定将创建和使用 `LoggerFactory` 的单个实例，每当引用
    `ILoggerFactory` 时。
- en: 'Now the question arises: why wasn''t `ILoggerFactory` used in a controller?
    `ILoggerFactory` is used under the hood when resolving an implementation of a
    controller. When exposing a controller dependency such as a `logger`, you no longer
    need to care about how it gets initialized. This is a great benefit because it
    makes the class holding a dependency both more simple and more flexible.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题出现了：为什么在控制器中没有使用 `ILoggerFactory`？当解析控制器的实现时，`ILoggerFactory` 在幕后使用。当公开控制器依赖项（如
    `logger`）时，您不再需要关心它是如何初始化的。这是一个很大的好处，因为它使持有依赖项的类更简单、更灵活。
- en: 'If you do want to use `ILoggerFactory` instead of `Ilogger`, you could have
    a constructor accepting the factory, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想使用 `ILoggerFactory` 而不是 `Ilogger`，您可以有一个接受工厂的构造函数，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can then use it to create a `logger`, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用它创建一个 `logger`，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This latter `logger` functions the same as the former.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的 `logger` 与前者的功能相同。
- en: This section dealt with the `AddSingleton` method for managing service dependencies
    in a central place. Proceed to the next section to solve dependency complexities
    with DI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涉及 `AddSingleton` 方法，用于在一个中心位置管理服务依赖项。继续下一节，解决依赖关系复杂性与 DI。
- en: The Lifetime of an Injected Component
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入组件的生命周期
- en: The `AddSingleton` method is useful because complex applications have hundreds,
    if not thousands, of dependencies often shared across different components. It
    would be quite a challenge to manage the initialization of each. DI solves that
    problem by providing a central place for managing dependencies and their lifetimes.
    Before proceeding further, you'll need to learn more about DI lifetimes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton` 方法非常有用，因为复杂的应用程序通常有数百甚至数千个依赖项，这些依赖项经常在不同的组件之间共享。要管理每个初始化将是一个相当大的挑战。DI
    通过提供一个管理依赖项及其生命周期的中心位置来解决这个问题。在继续之前，您需要了解更多关于 DI 生命周期的知识。'
- en: 'There are three injected object lifetimes in .NET:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中有三种注入的对象生命周期：
- en: 'Singleton: Object initialized once per application lifetime'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Singleton：应用程序生命周期内每次初始化一次的对象
- en: 'Scoped: Object initialized once per request'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scoped：对象每个请求初始化一次
- en: 'Transient: Object initialized every time it is referenced'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Transient：每次引用时初始化的对象
- en: To better illustrate DI and different service lifetimes, the next section will
    refactor the existing `WeatherForecastController` code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明 DI 和不同的服务生命周期，下一节将重构现有的 `WeatherForecastController` 代码。
- en: DI Examples within a Service
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务中的 DI 示例
- en: A service is a holder for logic at the highest level. By itself, a controller
    should not do any business logic and just delegate a request to some other object
    that is able to handle it. Apply this principle and refactor the `GetWeekday`
    method using DI.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是逻辑的最高级别的持有者。控制器本身不应执行任何业务逻辑，只需将请求委托给能够处理它的其他对象。应用这一原则，并使用 DI 重构 `GetWeekday`
    方法。
- en: 'First, create an interface for the service to which you will move all the logic.
    This is done to create an abstraction for which you will later provide an implementation.
    An abstraction is needed because you want to move out as much logic as possible
    from the controller into other components:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为您将要移动所有逻辑的服务创建一个接口。这样做是为了创建一个抽象，以便稍后提供实现。需要抽象是因为您希望尽可能多地将逻辑从控制器移出到其他组件中：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you move a portion away from a controller, you would like to handle error
    scenarios as well. In this case, if a provided day is not between `1` and `7`,
    you will return a `404 – not found` error. However, at the service level, there
    is no concept of HTTP status codes. Therefore, instead of returning an HTTP message,
    you will be throwing an exception. For the exception to be handled properly, you
    will create a custom exception called `NoSuchWeekdayException`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一部分移出控制器时，您还希望处理错误场景。在这种情况下，如果提供的日期不在 `1` 和 `7` 之间，您将返回 `404 - 未找到` 错误。但是，在服务级别上，没有
    HTTP 状态代码的概念。因此，您将抛出一个异常，而不是返回一个 HTTP 消息。为了正确处理异常，您将创建一个名为 `NoSuchWeekdayException`
    的自定义异常：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, create a class that implements the service. You will move your code here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个实现服务的类。您将把代码移到这里：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only difference here as compared to the previous code is that, instead of
    returning `NotFound`, you have used `throw new NoSuchWeekdayException`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码相比，唯一的区别是，您使用了 `throw new NoSuchWeekdayException`，而不是返回 `NotFound`。
- en: 'Now, inject the service into a controller:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将服务注入到控制器中：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The cleaned-up controller method, in the *Responding with Different Status
    Codes* section, with minimum business logic, now looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用不同状态代码响应* 部分中，经过清理的控制器方法，现在看起来是这样的，业务逻辑最少：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It might still seem like the same code; however, the key point here is that
    the controller no longer does any business logic. It simply maps results from
    the service back to an HTTP response.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来仍然是相同的代码；但是，这里的关键点是控制器不再执行任何业务逻辑。它只是将服务的结果映射回 HTTP 响应。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the *Error Handling* section, you will return to this and further remove
    code from the controller, making it as light as possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *错误处理* 部分，您将返回到这里，并进一步从控制器中删除代码，使其尽可能轻量化。
- en: 'If you run this code, you would get the following exception when calling any
    of the controller''s endpoints:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，在调用控制器的任何端点时，将会收到以下异常：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This exception shows that there is no way that `WeatherForecastController`
    can figure out the implementation for `IWeatherForecastService`. So, you need
    to specify which implementation fits the needed abstraction. For example, this
    is done inside the `Program` class as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此异常显示 `WeatherForecastController` 无法找出 `IWeatherForecastService` 的实现方式。因此，您需要指定哪个实现适合所需的抽象。例如，这是在
    `Program` 类内部完成的，如下所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `AddSingleton` method reads this as for the `IWeatherForecastService`, `WeatherForecastService`
    **implementation**. In the following paragraphs, you will learn how exactly it
    works.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton` 方法读取此处的 `IWeatherForecastService`，`WeatherForecastService` **实现**。在接下来的段营中，您将学习它的确切工作原理。'
- en: Now that you have a service to be injected, you can explore what effect each
    injection has on service calls when calling the following controller method. For
    that point, you will slightly modify `WeatherForecastService` and `WeatherForecastController`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个要注入的服务，您可以探索每次注入对服务调用的影响。在调用以下控制器方法时，您将略微修改`WeatherForecastService`和`WeatherForecastController`。
- en: 'Within `WeatherForecastService`, do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeatherForecastService`中，执行以下操作：
- en: 'Inject a `logger`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入一个`logger`：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the service is initialized, log a random `Guid` that changes the constructor
    to look like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务初始化时，记录一个随机的`Guid`，将构造函数修改为如下所示：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Within `WeatherForecastController`, do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeatherForecastController`中，执行以下操作：
- en: 'Inject the second instance of `WeatherForecastService`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入`WeatherForecastService`的第二个实例：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Call both instances when getting a weekday:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取工作日时同时调用两个实例：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `GetWeekday` method is called twice because it will help illustrate DI lifetimes
    better. Now it is time to explore different DI lifetimes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWeekday`方法被调用两次，因为它将有助于更好地说明DI的生命周期。现在是时候探索不同的DI生命周期了。'
- en: Singleton
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: 'Register the service as a singleton in `Program.cs` in the following way:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中将服务注册为单例的方式如下：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用应用程序后，您将看到在运行代码时生成的以下日志：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you call the application again, you will see the same GUID logged:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次调用应用程序，您将看到相同的GUID被记录：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This proves that the service was initialized only once.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明服务只初始化了一次。
- en: Scoped
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'Register the service as scoped in `Program.cs` in the following way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中将服务注册为作用域的方式如下：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 调用应用程序后，您将看到在运行代码时生成的以下日志：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On calling `WeatherForecastService` again, you will see the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用`WeatherForecastService`时，您将看到以下内容：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a different GUID that has been logged. This proves that the service
    was initialized once per request, but a new instance was initialized on a new
    request.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不同的GUID被记录。这证明服务在每个请求中只初始化一次，但在新请求中会初始化一个新实例。
- en: Transient
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瞬态
- en: 'Register the service as transient in `Program.cs` in the following way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中将服务注册为瞬态的方式如下：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After calling the application, you should see the following in the logs generated
    while running the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调用应用程序后，您将看到在运行代码时生成的以下日志：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That there are two different GUIDs logged proves that both services were initialized
    using different instances. It is possible to use DI and IoC outside of the Web
    API. DI through IoC is just another library with a few extras given by the Web
    API template.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记录了两个不同的GUID证明了两个服务是使用不同的实例初始化的。可以在Web API之外使用DI和IoC。通过IoC进行DI只是另一个库，Web API模板提供了一些额外的功能。
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to use IoC outside of ASP.NET Core, install the following NuGet
    (or other IoC container): `Microsoft.Extensions.DependencyInjection`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在ASP.NET Core之外使用IoC，请安装以下NuGet（或其他IoC容器）：`Microsoft.Extensions.DependencyInjection`。
- en: TryAdd
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TryAdd
- en: So far, you have wired implementations to their abstractions using an `Add[Lifetime]`
    function. However, that is not the best practice in most cases. Usually, you'll
    want a single implementation to be wired for a single abstraction. However, if
    you repeatedly call `Add[Lifetime]`, for example, the `AddSingleton` function,
    you will create a collection of implementing instances (duplicates) underneath.
    This is rarely the intention and therefore you should protect yourself against
    that.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用`Add[Lifetime]`函数将实现与其抽象连接起来。然而，在大多数情况下，这并不是最佳实践。通常，您希望一个单一的实现与一个单一的抽象连接起来。但是，如果您重复调用`Add[Lifetime]`，例如`AddSingleton`函数，您将在其下创建一组实现实例（重复项）。这很少是意图，因此您应该保护自己免受这种情况的影响。
- en: The cleanest way to wire dependencies is through the `TryAdd[Lifetime]` method.
    In the case of a duplicate dependency, it will simply not add a duplicate. To
    illustrate the difference between the two versions of DIs, compare the injected
    service counts using different methods. Here, you will inject two identical services
    as a singleton.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`TryAdd[Lifetime]`方法，最干净的方式来连接依赖关系。在重复依赖的情况下，它将简单地不添加重复。为了说明两个版本的DI之间的区别，比较使用不同方法注入服务的数量。在这里，您将作为单例注入两个相同的服务。
- en: 'Here you are using the `Add[Lifetime]` service as a singleton:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在使用`Add[Lifetime]`服务作为单例：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The command will display the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将显示以下输出：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here you are using the `TryAdd[Lifetime]` service as a singleton:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在使用`TryAdd[Lifetime]`服务作为单例：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The command will display the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将显示以下输出：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Observe that `Add[Lifetime]` added a duplicate in the output, while `TryAdd[Lifetime]`
    did not. Since you don't want duplicate dependencies, it's recommended that you
    use the `TryAdd[Lifetime]` version.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Add[Lifetime]`在输出中添加了重复项，而`TryAdd[Lifetime]`没有。由于您不希望有重复的依赖关系，建议您使用`TryAdd[Lifetime]`版本。
- en: 'You can do an injection for a concrete class as well. Calling `builder.Services.AddSingleton<WeatherForecastService,
    WeatherForecastService>();` is a valid C# code; however, it does not make much
    sense. DI is used to inject an implementation into an abstraction. This will not
    work when bootstrapping the service because the following error will be displayed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为具体类进行注入。调用`builder.Services.AddSingleton<WeatherForecastService, WeatherForecastService>();`是有效的C#代码；但是，这并没有太多意义。DI用于将实现注入到抽象中。当引导服务时，这将无法工作，因为将显示以下错误：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The error occurs because there is still an abstraction-implementation binding
    to be provided. It would only work if a concrete implementation, rather than an
    abstraction, were exposed in the constructor of the controller. In practice, this
    scenario is rarely used.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为仍然需要提供抽象-实现绑定。只有在控制器的构造函数中公开具体实现而不是抽象时才能工作。在实践中，这种情况很少被使用。
- en: You have learned that the cleanest way of wiring dependencies is through the
    `TryAdd[Lifetime]` method. You will now create a service that accepts primitive
    arguments (`int` and `string`) and see how it manages its non-primitive dependencies
    in an IoC container.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了通过`TryAdd[Lifetime]`方法将依赖项连接起来的最干净的方法。现在，您将创建一个接受原始参数（`int`和`string`）的服务，并查看它如何在IoC容器中管理其非原始依赖项。
- en: Manual Injection Using an IoC Container
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动使用IoC容器进行注入
- en: There are scenarios in which you will need to create an instance of a service
    before injecting it. An example use case could be a service with primitive arguments
    in a constructor, in other words, a weather forecast service for a specific city
    with a configured interval for forecast refreshes. So, here, you cannot inject
    a string or an integer, but you can create a service with an integer and a string
    and inject that instead.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要在注入之前创建服务的实例。一个示例用例可能是构造函数中带有原始参数的服务，换句话说，是为特定城市配置了天气预报刷新间隔的天气预报服务。因此，在这种情况下，您无法注入一个字符串或整数，但可以创建一个带有整数和字符串的服务并注入该服务。
- en: 'Modify `WeatherForecastService` with the said features:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`WeatherForecastService`以具有上述功能：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Return to the `Program` class and try to inject a service for `New York` with
    a refresh interval of `5` (hours):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`Program`类，并尝试为`纽约`注入一个刷新间隔为`5`（小时）的服务：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In order to inject the service, as always, you use a version of the `builder.Services.Add[Lifetime]`
    method. However, on top of that, you provided an argument—a delegate specifying
    how a service should be created. The service provider can be accessed by calling
    the `BuildServices` method on `IServiceCollection`. This delegate takes `IServiceProvider`
    as input and uses it to build a new service.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入服务，您始终使用`builder.Services.Add[Lifetime]`方法的一个版本。但是，除此之外，您还提供了一个参数-指定服务应如何创建的委托。可以通过在`IServiceCollection`上调用`BuildServices`方法来访问服务提供程序。此委托以`IServiceProvider`作为输入，并使用它来构建一个新服务。
- en: In this case, you did not use it and thus named the argument after the discard
    operator (`_`). The remaining contents of the function are just a simple return
    with the values from the previous paragraph (for brevity, you will not add any
    extra logic to use the new values). If you had a more complex service, for example,
    a service that requires another service, you could call the `.GetService<ServiceType>`
    method from `IServiceProvider`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您没有使用它，因此将参数命名为丢弃运算符(`_`)。函数的其余内容只是简单地返回前一段的值（为简洁起见，您不会添加任何额外的逻辑来使用新值）。如果您有一个更复杂的服务，例如需要另一个服务的服务，您可以从`IServiceProvider`调用`.GetService<ServiceType>`方法。
- en: '`Build` and `Create` are two common method names. However, they should not
    be used interchangeably. Use `Build` when building a single dedicated object,
    while `Create` is used when the intention is to produce many objects of diverse
    types.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build`和`Create`是两个常见的方法名称。但是，它们不应该互换使用。当构建单个专用对象时使用`Build`，而当意图是生成多个不同类型的对象时使用`Create`。'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fBFRQ](https://packt.link/fBFRQ).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/fBFRQ](https://packt.link/fBFRQ)找到此示例使用的代码。
- en: 'Exercise 9.02: Displaying Current Time in a Country API Time Zone'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：在国家API时区中显示当前时间
- en: In this exercise, you are tasked with creating a Web API that provides the date
    and time at different time zones of UTC. Through a URL, you will pass a number
    between `-12` and `+12` and return the time in that time zone.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您的任务是创建一个Web API，该API提供UTC不同时区的日期和时间。通过URL，您将传递一个介于`-12`和`+12`之间的数字，并返回该时区的时间。
- en: 'Perform the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create an interface called `ICurrentTimeProvider` with a method called `DateTime
    GetTime(string timezone)`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ICurrentTimeProvider`的接口，其中包含一个名为`DateTime GetTime(string timezone)`的方法：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a class called `CurrentTimeUtcProvider` implementing `ICurrentTimeProvider`
    to implement the logic required for the application:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CurrentTimeUtcProvider`的类，实现`ICurrentTimeProvider`接口，以实现应用程序所需的逻辑：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the method of converting the current `DateTime` to `Utc` and then
    offsetting that based on the time zone passed:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将当前`DateTime`转换为`Utc`，然后根据传递的时区进行偏移的方法：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a `CurrentTimeProviderController` controller to make sure it accepts
    `ICurrentTimeProvider` in the constructor:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`CurrentTimeProviderController`控制器，以确保它在构造函数中接受`ICurrentTimeProvider`：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create an `HttpGet` endpoint called `IActionResult Get(string timezoneId)`,
    which calls the current time provider and returns the current time:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IActionResult Get(string timezoneId)`的`HttpGet`端点，该端点调用当前时间提供程序并返回当前时间：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Please note that `{timezoneId}` is not specified in the `HttpGet` attribute.
    This is because the pattern is used for REST parts on an endpoint; however, in
    this scenario, it is passed as an argument of a query string. If a string contains
    whitespaces or other special characters, it should be encoded before being passed.
    You can URL-encode a string using this tool: [https://meyerweb.com/eric/tools/dencoder/](https://meyerweb.com/eric/tools/dencoder/).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`{timezoneId}`没有在`HttpGet`属性中指定。这是因为该模式用于端点上的REST部分；但是，在这种情况下，它作为查询字符串的参数传递。如果字符串包含空格或其他特殊字符，则应在传递之前对其进行编码。您可以使用此工具对字符串进行URL编码：[https://meyerweb.com/eric/tools/dencoder/](https://meyerweb.com/eric/tools/dencoder/)。
- en: 'In the `Program` class, inject the service:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类中注入服务：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, you injected the service as a singleton because it is stateless.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将服务作为单例注入，因为它是无状态的。
- en: 'Call the `https://localhost:7021/CurrentTime?timezone=[yourtimezone]` endpoint
    with a `timezoneid` value of your choice. For example, you can call the following
    endpoint: `https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time`.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的`timezoneid`值调用`https://localhost:7021/CurrentTime?timezone=[yourtimezone]`端点。例如，您可以调用以下端点：`https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time`。
- en: 'You will get the response showing the date and time at that time zone:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得显示该时区的日期和时间的响应：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/iqGJL](https://packt.link/iqGJL).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/iqGJL](https://packt.link/iqGJL)找到用于此练习的代码。
- en: OpenAPI and Swagger
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI和Swagger
- en: 'OpenAPI is a **REST API** description format. It is a specification of an API
    with the endpoints it has, the authentication methods it supports, the arguments
    it accepts, and the example requests and responses it informs. The REST API works
    with both JSON and XML formats; however, JSON is chosen frequently. Swagger is
    a collection of tools and libraries implementing the OpenAPI standard. Swagger
    generates two things:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是一种**REST API**描述格式。它是一个API的规范，包括它具有的端点、支持的身份验证方法、它接受的参数以及它通知的示例请求和响应。REST
    API可以使用JSON和XML格式；但是，通常选择JSON。Swagger是实现OpenAPI标准的一组工具和库。Swagger生成两个东西：
- en: A web page to make calls to your API
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于调用API的网页
- en: Generate client code
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成客户端代码
- en: 'In .NET, there are two libraries for working with Swagger:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，有两个用于使用Swagger的库：
- en: '`NSwag`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSwag`'
- en: '`Swashbuckle`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swashbuckle`'
- en: Using Swagger Swashbuckle
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Swagger Swashbuckle
- en: 'In this section, you will use `Swashbuckle` to demonstrate one of many ways
    to test APIs and generate API documentation. So, install the `Swashbuckle.AspNetCore`
    package by running the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用`Swashbuckle`来演示测试API和生成API文档的一种方法。因此，通过运行以下命令安装`Swashbuckle.AspNetCore`包：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Just before the `builder.Build()` call, add the following line of code in `Program.cs`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中的`builder.Build()`调用之前，添加以下代码行：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This injects the Swagger services needed to generate the Swagger schema and
    the documentation test page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注入生成Swagger模式和文档测试页面所需的Swagger服务。
- en: 'After `builder.Build()` in `Program.cs`, add the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中的`builder.Build()`之后，添加以下内容：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first line supports reaching the OpenAPI Swagger specification and the second
    one allows accessing the specification on a user-friendly web page.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行支持访问OpenAPI Swagger规范，第二行允许在用户友好的网页上访问规范。
- en: 'Now, run the program as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按以下方式运行程序：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When you navigate to `https://localhost:7021/swagger/`, you will see the following
    screen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到`https://localhost:7021/swagger/`时，您将看到以下屏幕：
- en: '![Figure 9.8: A user-friendly Swagger endpoint'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：用户友好的Swagger端点'
- en: '](img/B16835_09_08.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_08.jpg)'
- en: 'Figure 9.8: A user-friendly Swagger endpoint'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：用户友好的Swagger端点
- en: Clicking on any of the endpoints will allow you to send an HTTP request to them.
    This page can be configured to include common information about the project, such
    as the contact information, licenses it is under, description, terms of services,
    and more.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 单击任何端点都将允许您向其发送HTTP请求。此页面可以配置为包含有关项目的常见信息，例如联系信息、许可证、描述、服务条款等。
- en: The benefits of Swagger do not end here. If you had comments, you could include
    them on this page as well. You could also include all the possible response types
    that the endpoint produces. You can even include example requests and set them
    as defaults when calling an API.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger的好处并不止于此。如果您有注释，您也可以在此页面上包含它们。您还可以包含端点产生的所有可能的响应类型。甚至可以包含示例请求并在调用API时将它们设置为默认值。
- en: 'Create a new endpoint to save a weather forecast and then another one to retrieve
    it. Document both the methods one by one. So, first, update the `IWeatherForecastService`
    interface to include the two new methods, `GetWeekday` and `GetWeatherForecast`,
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的端点来保存天气预报，然后创建另一个端点来检索它。逐个记录这两种方法。因此，首先更新`IWeatherForecastService`接口以包括两个新方法`GetWeekday`和`GetWeatherForecast`，如下所示：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, add implementations of those methods to `WeatherForecastService`. To
    save the weather forecast, you will need storage, and the simplest storage would
    be `IMemoryCache`. Here, you will need a new field for `IMemoryCache`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`WeatherForecastService`中添加这些方法的实现。为了保存天气预报，您将需要存储，最简单的存储将是`IMemoryCache`。在这里，您将需要一个新的`IMemoryCache`字段：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, update the constructor to inject `IMemoryCache`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新构造函数以注入`IMemoryCache`：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, create the `SaveWeatherForecast` method to save a weather forecast:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建`SaveWeatherForecast`方法来保存天气预报：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a `GetWeatherForecast` method to get a weather forecast:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`GetWeatherForecast`方法来获取天气预报：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, go back to `WeatherForecastController` and create an endpoint for each
    method so that you can test it using the HTTP requests:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`WeatherForecastController`，为每个方法创建一个端点，以便您可以使用HTTP请求进行测试：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Please note that when creating a new weather forecast, you return a `CreatedAtAction`
    result. This returns an HTTP status code of `201` with a URI used to get the created
    resource. It was specified that, in order to get the created forecast later, you
    can use `GetWeatherForecast`. The anonymous `new { date = weatherForecast.Date.ToShortDateString()}`
    object specifies the arguments needed to call that action. You passed `Date.ToShortDateString()`
    and not just a date because a full `DateTime` contains more than what you need.
    Here, you need only a date; therefore, you explicitly cut what you don't need.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当创建新的天气预报时，您将返回`CreatedAtAction`结果。这将返回HTTP状态代码`201`和用于获取创建的资源的URI。指定了，为了以后获取创建的预报，您可以使用`GetWeatherForecast`。匿名的`new
    { date = weatherForecast.Date.ToShortDateString()}`对象指定了调用该操作所需的参数。您传递了`Date.ToShortDateString()`而不仅仅是一个日期，因为完整的`DateTime`包含了比您需要的更多内容。在这里，您只需要一个日期；因此，您明确地去掉了您不需要的部分。
- en: 'Document each method by describing what it does and what status codes it can
    return. You will then add this information above each endpoint:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述每个方法的功能和它可能返回的状态代码来记录每个方法。然后，在每个端点上方添加这些信息：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You have now added XML docs to the two endpoints. Using `ProducesResponseType`,
    you specified what status codes the endpoints could return. If you refresh the
    Swagger page, you will see the `SaveWeatherForecast` endpoint in Swagger:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为这两个端点添加了XML文档。使用`ProducesResponseType`，您指定了端点可能返回的状态代码。如果刷新Swagger页面，您将在Swagger中看到`SaveWeatherForecast`端点：
- en: '![Figure 9.9: SaveWeatherForecast endpoint in Swagger'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：Swagger中的SaveWeatherForecast端点'
- en: '](img/B16835_09_09.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_09.jpg)'
- en: 'Figure 9.9: SaveWeatherForecast endpoint in Swagger'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：在Swagger中保存WeatherForecast端点
- en: 'If you refresh the Swagger page, you will see the `GetWeatherForecast` endpoint
    in Swagger:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新Swagger页面，您将在Swagger中看到“GetWeatherForecast”端点：
- en: '![Figure 9.10: GetWeatherForecast endpoint in Swagger'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：Swagger中的GetWeatherForecast端点'
- en: '](img/B16835_09_10.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_10.jpg)'
- en: 'Figure 9.10: GetWeatherForecast endpoint in Swagger'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：Swagger中的GetWeatherForecast端点
- en: 'You can see the status code addition, but where did the comments go? By default,
    Swagger does not pick XML docs. You need to specify what it has to do by configuring
    your project file. To do so, add the following piece of code inside `<Project>`
    below the property group of a target framework:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到状态码的添加，但注释去哪了？默认情况下，Swagger不会选择XML文档。您需要通过配置项目文件来指定它的操作。为此，请在目标框架的属性组下方的`<Project>`内添加以下代码片段：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Figure 9.11: Swagger configuration to include XML docs'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：包括XML文档的Swagger配置'
- en: '](img/B16835_09_11.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_11.jpg)'
- en: 'Figure 9.11: Swagger configuration to include XML docs'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：包括XML文档的Swagger配置
- en: 'Lastly, go to the `Program.cs` file and replace `service.AddSwaggerGen()` with this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转到“Program.cs”文件，并用以下内容替换“service.AddSwaggerGen()”：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is the last piece of code needed to include XML comments in the Swagger
    docs. Now, refresh the page and you should see the comments included:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含XML注释的Swagger文档所需的最后一段代码。现在，刷新页面，您应该看到包含的注释：
- en: '![Figure 9.12: WeatherForecast Swagger docs with XML docs included'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12：包括XML文档的WeatherForecast Swagger文档'
- en: '](img/B16835_09_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_12.jpg)'
- en: 'Figure 9.12: WeatherForecast Swagger docs with XML docs included'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：包括XML文档的WeatherForecast Swagger文档
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到此示例使用的代码[https://packt.link/iQK5X](https://packt.link/iQK5X)。
- en: There is a lot more that you can do with Swagger; you can include an example
    request and response and give default values to parameters. You can even create
    your own API specification standards and decorate a project namespace to apply
    the same conventions to every controller and their endpoints, but that is beyond
    the scope of this book.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger还有很多其他功能；您可以包括示例请求和响应，并为参数提供默认值。您甚至可以创建自己的API规范标准，并装饰项目命名空间以将相同的约定应用于每个控制器及其端点，但这超出了本书的范围。
- en: 'The last thing to mention is the ability to generate a client out of the Swagger
    docs. To do so, follow these steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是能够从Swagger文档中生成客户端的能力。要这样做，请按照以下步骤操作：
- en: In order to download the `swagger.json` OpenAPI documentation artifact, navigate
    to `https://localhost:7021/swagger/v1/swagger.json`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了下载“swagger.json” OpenAPI文档文件，导航到“https://localhost:7021/swagger/v1/swagger.json”。
- en: Right-click anywhere on the page and select the `Save as` option.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面任意位置右键单击，然后选择“另存为”选项。
- en: Then, press the `Enter` key.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按“Enter”键。
- en: Next, you will use this JSON to generate client code. So, register and log in
    to [https://app.swaggerhub.com/home](https://app.swaggerhub.com/home) (you can
    use your GitHub account).
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将使用此JSON生成客户端代码。因此，请注册并登录到[https://app.swaggerhub.com/home](https://app.swaggerhub.com/home)（您可以使用GitHub帐户）。
- en: 'In the new window, click the `Create New` button (`1`):'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，单击“创建新”按钮（`1`）：
- en: '![Figure 9.13: SwaggerHub and the Import API window'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13：SwaggerHub和导入API窗口'
- en: '](img/B16835_09_13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_13.jpg)'
- en: 'Figure 9.13: SwaggerHub and the Import API window'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：SwaggerHub和导入API窗口
- en: Select the `Import and document API` option.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“导入和记录API”选项。
- en: Select the Swagger file you have just downloaded by clicking the `Browse` button (`2`).
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击“浏览”按钮（`2`）选择刚下载的Swagger文件。
- en: 'Then, hit the `UPLOAD FILE` button:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“UPLOAD FILE”按钮：
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you select the file, the `IMPORT` button (`3` in *Figure 9.13*) changes
    to the `UPLOAD FILE` button (`3` in *Figure 9.14*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择文件时，“导入”按钮（*图9.13*中的`3`）会更改为“上传文件”按钮（*图9.14*中的`3`）。
- en: '![Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14：SwaggerHub IMPORT按钮更改为UPLOAD FILE按钮'
- en: '](img/B16835_09_14.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_14.jpg)'
- en: 'Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：SwaggerHub IMPORT按钮更改为UPLOAD FILE按钮
- en: On the next screen, leave the name of the service and the version with default values.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，保留服务的名称和默认值的版本。
- en: 'Next, click the `IMPORT DEFINITION` button:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，单击“导入定义”按钮：
- en: '![Figure 9.15: SwaggerHub import Swagger service definition'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：SwaggerHub导入Swagger服务定义'
- en: '](img/B16835_09_15.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_15.jpg)'
- en: 'Figure 9.15: SwaggerHub import Swagger service definition'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：SwaggerHub导入Swagger服务定义
- en: Now that the `Swagger.json` API scheme is imported, you can use it to generate
    a strongly typed C# client code to call the API. So, click the `Export` option
    (`1`).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入了“Swagger.json”API方案，您可以使用它来生成强类型的C#客户端代码来调用API。因此，单击“导出”选项（`1`）。
- en: Then, click the `Client SDK` option (`2`).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，单击“Client SDK”选项（`2`）。
- en: 'Select the `csharp` option (`3`):![Figure 9.16: Exporting a new client in the
    C# client from SwaggerHub'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“csharp”选项（`3`）：![图9.16：从SwaggerHub导出新的C#客户端
- en: '](img/B16835_09_16.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_16.jpg)'
- en: 'Figure 9.16: Exporting a new client in the C# client from SwaggerHub'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：从SwaggerHub导出新的C#客户端
- en: A `csharp-client-generated.zip` file will be downloaded.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载一个“csharp-client-generated.zip”文件。
- en: Extract the `csharp-client-generated.zip` file.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取“csharp-client-generated.zip”文件。
- en: 'Navigate the extracted folder and open the `IO.Swagger.sln` file. You should
    see the following:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到提取的文件夹并打开“IO.Swagger.sln”文件。您应该会看到以下内容：
- en: '![Figure 9.17: Files generated for the client using SwaggerHub'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17：使用SwaggerHub为客户端生成的文件'
- en: '](img/B16835_09_17.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_17.jpg)'
- en: 'Figure 9.17: Files generated for the client using SwaggerHub'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：使用SwaggerHub为客户端生成的文件
- en: The generated client code not only has a strongly typed HTTP client but also
    includes tests. It also has a `README.md` file on how to call the client and many
    more common development scenarios.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的客户端代码不仅具有强类型的HTTP客户端，还包括测试。它还有一个关于如何调用客户端和许多常见开发场景的“README.md”文件。
- en: 'Now, the question that arises is whether you should use Swagger when you already
    have Postman. While Postman is one of the most popular tools used for testing
    different kinds of Web APIs, Swagger is so much more than just a client to test
    whether the API works. Primarily, Swagger is a tool for documenting the API. From
    a conventional code, it allows you to generate all that you might need to:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，出现的问题是，当您已经有了Postman时，是否应该使用Swagger。虽然Postman是用于测试不同类型的Web API的最流行工具之一，但Swagger不仅仅是一个用于测试API是否有效的客户端。主要是Swagger是一个用于记录API的工具。从传统代码中，它允许您生成所有可能需要的内容：
- en: Test page
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试页面
- en: Test the client code
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试客户端代码
- en: Test the documentation page
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文档页面
- en: Till now, you have learned that Swagger is a collection of tools and libraries
    implementing OpenAPI standards that are helpful for testing and documenting your
    APIs. You can now proceed to grasp error handling.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解到Swagger是实现OpenAPI标准的一组工具和库，对于测试和记录API非常有帮助。现在，您可以继续了解错误处理。
- en: Error Handling
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'You have already learned that the code within a controller should be as minimalistic
    as possible due to it being the highest level in code (direct call). Specific
    error handling should not be included in the controller code because it adds complexity
    to already-complex code. Fortunately, there is a way to map exceptions to HTTP
    status codes and set up all of them in one place—that is, via the `Hellang.Middleware.ProblemDetails`
    package. To do so, first install the package by running this command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到，控制器内的代码应尽可能简约，因为它是代码中的最高级别（直接调用）。特定的错误处理不应包含在控制器代码中，因为它会给已经复杂的代码增加复杂性。幸运的是，有一种方法可以将异常映射到HTTP状态代码并在一个地方设置它们，即通过`Hellang.Middleware.ProblemDetails`包。要这样做，首先通过运行以下命令安装该包：
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Map `NoSuchWeekdayException` to HTTP status code `404`. In the `Program.cs`
    file, before `builder.Build()`, add the following code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将`NoSuchWeekdayException`映射到HTTP状态代码`404`。在`Program.cs`文件中，在`builder.Build()`之前，添加以下代码：
- en: '[PRE71]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This not only converts an exception to the right status code but also uses `ProblemDetails`—a
    standard response model based on RFC 7807—to provide faults in an HTTP response.
    Also, this excludes exception details in the error message.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅将异常转换为正确的状态代码，还使用`ProblemDetails`——基于RFC 7807的标准响应模型——提供HTTP响应中的故障。此外，这还在错误消息中排除了异常详细信息。
- en: When developing a service locally, knowing what went wrong is invaluable. However,
    exposing the stack trace and other information needed to determine the error can
    expose exploits of your Web API. Thus, it's better to hide it when moving toward
    the release stage. By default, the `Hellang` library already excludes the exception
    details in upper environments, so it is better that you don't include that line.
    For demo purposes and a simplified response message, it was included here.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发服务时，了解出了什么问题是非常宝贵的。然而，暴露堆栈跟踪和其他确定错误所需的信息可能会暴露您的Web API的漏洞。因此，在向发布阶段迈进时最好隐藏它。默认情况下，`Hellang`库已经在高级环境中排除了异常详细信息，因此最好不要包含该行。出于演示目的和简化的响应消息，这里包含了它。
- en: 'Before you build a demo, you also need to turn off the default developer exceptions
    page because it overrides the exceptions in `ProblemDetails`. Simply remove the
    following block of code from the `Configure` method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建演示之前，您还需要关闭默认的开发人员异常页面，因为它会覆盖`ProblemDetails`中的异常。只需从`Configure`方法中删除以下代码块：
- en: '[PRE72]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since you already have a central place for handling `NoSuchWeekdayException`,
    you can simplify the controller method for getting `WeatherForecast` for a given date:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经有一个处理`NoSuchWeekdayException`的中央位置，您可以简化控制器方法，以获取给定日期的`WeatherForecast`：
- en: '[PRE73]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When calling the endpoint with an invalid day value (for example, `9`), you
    get the following response:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无效的日期值（例如`9`）调用端点时，您将获得以下响应：
- en: '[PRE74]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This centralized error handling approach allows the controllers to be rid of
    all the `try-catch` blocks.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集中的错误处理方法允许控制器摆脱所有的`try-catch`块。
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/CntW6](https://packt.link/CntW6).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/CntW6](https://packt.link/CntW6)找到此示例使用的代码。
- en: You can now map exceptions to HTTP status codes and set them all up in one place.
    This next section will take a look at another addition to an API, which is request validation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将异常映射到HTTP状态代码，并在一个地方设置它们。接下来的部分将介绍API的另一个补充，即请求验证。
- en: Request Validation
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求验证
- en: Another useful addition to an API is request validation. By default, ASP.NET
    Core has a request validator based on the required attributes. However, there
    might be complex scenarios where a combination of properties results in an invalid
    request or a custom error message for which validation is required.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: API的另一个有用的补充是请求验证。默认情况下，ASP.NET Core具有基于必需属性的请求验证器。但是，在可能导致无效请求的属性组合或需要自定义错误消息的复杂场景中，可能需要验证。
- en: '.NET has a great NuGet package for that: `FluentValidation.AspNetCore`. Perform
    the following steps to learn how to carry out request validation. Before you continue,
    install the package by running the following command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有一个很棒的NuGet包：`FluentValidation.AspNetCore`。执行以下步骤来学习如何进行请求验证。在继续之前，通过运行以下命令安装该包：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This package allows registering custom validators per model. It makes use of
    existing ASP.NET Core middleware, so all you must do is inject a new validator.
    Create a validator for `WeatherForecast`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 该包允许为每个模型注册自定义验证器。它利用现有的ASP.NET Core中间件，因此您所需做的就是注入一个新的验证器。为`WeatherForecast`创建一个验证器。
- en: 'A validator should inherit the `AbstractValidator` class. This is not obligatory,
    but it is highly recommended because it implements the common methods for functionality
    and has a default implementation for generic validation:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器应该继承`AbstractValidator`类。这不是强制性的，但强烈建议，因为它实现了功能的常见方法，并且对于通用验证有默认实现：
- en: '[PRE76]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Through a generic argument, you specified that this is a validator for `WeatherForecast`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通用参数，您指定了这是`WeatherForecast`的验证器。
- en: 'Next is the validation itself. This is done in a constructor of a validator:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是验证本身。这是在验证器的构造函数中完成的：
- en: '[PRE77]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`FluentValidation` is a .NET library and is all about fluent API, with self-explanatory
    methods. Here, you require a weather forecast date to be no more than one month
    in the future. The next validation is to have the temperature between `-100 C`
    and `100 C`.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`FluentValidation`是一个.NET库，完全是关于流畅API，具有自解释的方法。在这里，您需要将天气预报日期限制在未来一个月内。下一个验证是将温度限制在`-100
    C`和`100 C`之间。'
- en: 'If you ping your API through Swagger, the following request gets displayed:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过Swagger对API进行ping测试，则会显示以下请求：
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The response will be displayed as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将显示如下：
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You don't have to use `FluentValidation`, especially if your API is simple and
    does not have complex rules. But in an enterprise setting, it is highly recommended
    that you do use it because the level of detail you can add to your validation
    is unlimited.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必使用`FluentValidation`，特别是如果您的API很简单，没有复杂的规则。但在企业环境中，强烈建议您使用它，因为您可以为验证添加的细节级别是无限的。
- en: You learned about `FluentValidation` and the scenarios where it is useful. The
    next section will touch upon the two options for reading configuration in ASP.NET.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解了`FluentValidation`及其有用的场景。下一节将涉及ASP.NET中读取配置的两种选项。
- en: Note
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/uOGOe](https://packt.link/uOGOe).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/uOGOe](https://packt.link/uOGOe)找到此示例中使用的代码。
- en: Configuration
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'In ASP.NET Core Web API, you have two options for reading configuration:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core Web API中，您有两种读取配置的选项：
- en: '`IConfiguration`: This is a global configuration container. Even though it
    allows access to all the configuration properties, injecting it directly into
    other components is inefficient. This is because it is weakly typed and has a
    risk of you trying to get a non-existing configuration property.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfiguration`：这是一个全局配置容器。尽管它允许访问所有配置属性，但直接将其注入到其他组件中是低效的。这是因为它是弱类型的，并且存在尝试获取不存在的配置属性的风险。'
- en: '`IOptions`: This is strongly typed and convenient because the configuration
    is fragmented into just the pieces that a component needs.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptions`：这是强类型的，方便的，因为配置被分成了组件需要的部分。'
- en: You can choose either of the two options. It is best practice to use `IOptions`
    in ASP.NET Core, as the configuration examples will be based on it. Whichever
    option you choose, you need to store the configuration in the `appsettings.json`
    file.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择两种选项中的任何一种。在ASP.NET Core中最佳实践是使用`IOptions`，因为配置示例将基于它。无论您选择哪个选项，都需要将配置存储在`appsettings.json`文件中。
- en: 'Move the hardcoded configuration from a constructor (weather forecast city
    and refresh interval) and move it into a configuration section in the `appsettings.json`
    file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 将硬编码的配置（天气预报城市和刷新间隔）从构造函数中移动，并将其移到`appsettings.json`文件中的配置部分中：
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a model representing this configuration section:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示此配置部分的模型：
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You no longer have to inject the two primitive values into the component. Instead,
    you will inject `IOptions<WeatherForecastConfig>`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您不再需要将两个原始值注入到组件中。相反，您将注入`IOptions<WeatherForecastConfig>`：
- en: '[PRE82]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Before the JSON section is useable, you need to bind to it. This can be done
    by finding the section through `IConfiguration` (via the `builder.Configuration`
    property):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON部分可用之前，您需要将其绑定。这可以通过通过`IConfiguration`（通过`builder.Configuration`属性）找到该部分来完成：
- en: '[PRE83]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this case, `WeatherForecastConfig` has a matching section in the configuration
    file. Therefore, `nameof` was used. So, `nameof` should be preferred when using
    the alternative `string` type. That way, if the name of a type changes, the configuration
    will change consistently (or else the code won't compile).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`WeatherForecastConfig`在配置文件中有一个匹配的部分。因此，使用了`nameof`。因此，当使用替代的`string`类型时，应优先使用`nameof`。这样，如果类型的名称更改，配置将保持一致（否则代码将无法编译）。
- en: Remember the `BuildWeatherForecastService` method you used previously? The beauty
    of it all is that the method can be removed altogether because the service can
    be created without the need for custom initialization. If you compile and run
    the code, you will get the same response.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前使用的`BuildWeatherForecastService`方法吗？所有这一切的美妙之处在于，该方法可以完全删除，因为服务可以在不需要自定义初始化的情况下创建。如果编译并运行代码，您将获得相同的响应。
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/xoB0K](https://packt.link/xoB0K).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/xoB0K](https://packt.link/xoB0K)找到此示例中使用的代码。
- en: 'ASP.NET Core Web API is just a collection of libraries on top of the .NET Core
    framework. You can use `appsettings.json` in other types of applications as well.
    It is better to use individual libraries regardless of the project type you choose.
    In order to use the configuration through JSON, all you need to do is to install
    the following NuGet packages:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API只是.NET Core框架之上的一组库。您也可以在其他类型的应用程序中使用`appsettings.json`。无论您选择的项目类型如何，最好使用单独的库。要通过JSON使用配置，您只需要安装以下NuGet包：
- en: '`Microsoft.Extensions.Configuration`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration`'
- en: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
- en: '`Microsoft.Extensions.Configuration.FileExtensions`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.FileExtensions`'
- en: '`Microsoft.Extensions.Configuration.Json`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.Json`'
- en: '`Microsoft.Extensions.Options`'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Options`'
- en: In this section, you learned how to use `IConfiguration` and `IOptions`. Your
    API is now ready, and it already includes many standard components of a typical
    Web API. The next section will detail how you can handle this complexity in code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用`IConfiguration`和`IOptions`。您的API现在已经准备就绪，并且已经包含了典型Web API的许多标准组件。下一节将详细介绍如何在代码中处理这种复杂性。
- en: Development Environments and Configuration
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发环境和配置
- en: Applications often need to have two environments—production and development.
    You want the application development environment to have premade settings, more
    detailed error messages (if possible), more detailed logging, and lastly, debugging
    enabled. All of that is not needed for a production environment and you would
    want to keep it clean.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常需要两个环境——生产和开发。您希望应用程序开发环境具有预制设置，更详细的错误消息（如果可能的话），更详细的日志记录，最后，启用调试。所有这些对于生产环境都是不需要的，您希望保持它干净。
- en: Other than the build configuration, you manage environments through different
    configuration files. The `appsettings.json` file is a base configuration file
    and is used across all environments. This configuration file should contain the
    configuration you would like for production.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建配置之外，您还可以通过不同的配置文件管理环境。`appsettings.json`文件是一个基本配置文件，适用于所有环境。该配置文件应包含您希望用于生产的配置。
- en: The `Appsettings.development.json` file is a configuration file that will be
    applied when you build your application in debug mode. Here, `appsettings.json`
    will still be used with the development settings overriding the matching sections.
    A common example is described here.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appsettings.development.json`文件是一个配置文件，在调试模式下构建应用程序时将应用该文件。在这里，`appsettings.json`仍将与开发设置一起使用，覆盖匹配部分。这里描述了一个常见的例子。'
- en: 'Say `appsettings.json` has the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 说`appsettings.json`有以下内容：
- en: '[PRE84]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And `appsettings.development.json` has the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 而`appsettings.development.json`有以下内容：
- en: '[PRE85]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, the settings used will be the merged file with override matching sections,
    as shown here:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用的设置将是合并文件，覆盖匹配部分，如下所示：
- en: '[PRE86]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the next section, you will learn how to manage DI more cleanly.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何更清晰地管理DI。
- en: Bootstrapping
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导
- en: Complexity needs to be handled and the complexity referred to here is the `Program`
    class. You'll need to break it out into smaller pieces and form a Bootstrapping
    directory specifying the components the service is made of.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理的复杂性，这里指的是`Program`类。您需要将其拆分成更小的部分，并形成一个引导目录，指定服务所包含的组件。
- en: When breaking down code within `Program.cs`, it is recommended to use a fluent
    API pattern. This is a pattern where you can chain multiple function calls from
    a single root object. In this case, you will create several extension methods
    for the `IServiceCollection` type and chain all the module injections one by one.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中分解代码时，建议使用流畅的API模式。这是一种模式，您可以从单个根对象链式调用多个函数调用。在这种情况下，您将为`IServiceCollection`类型创建几个扩展方法，并依次链式注入所有模块。
- en: 'To reduce the complexity of the `Program` class, move the DI of different logical
    sections into different files. Each step that follows will do just that. So, split
    the controller and API baseline setup to a new file named `ControllersConfigurationSetup.cs`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少`Program`类的复杂性，将不同逻辑部分的DI移动到不同的文件中。接下来的每一步都将做到这一点。因此，将控制器和API基线设置拆分到一个名为`ControllersConfigurationSetup.cs`的新文件中：
- en: '[PRE87]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, move the code for logging to a new file named `LoggingSetup.cs`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将日志记录的代码移动到一个名为`LoggingSetup.cs`的新文件中：
- en: '[PRE88]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, move the request validation logic to a new file named `RequestValidatorsSetup.cs`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将请求验证逻辑移动到一个名为`RequestValidatorsSetup.cs`的新文件中：
- en: '[PRE89]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Move the Swagger setup logic to a new file named `SwaggerSetup.cs`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将Swagger设置逻辑移动到一个名为`SwaggerSetup.cs`的新文件中：
- en: '[PRE90]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Move the injection of the `WeatherForecast`-related classes'' code to a new
    file named `WeatherServiceSetup.cs`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将`WeatherForecast`相关类的注入代码移动到一个名为`WeatherServiceSetup.cs`的新文件中：
- en: '[PRE91]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Finally, move the exception mapping of HTTP status codes to a new file named
    `ExceptionMappingSetup.cs`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将HTTP状态代码的异常映射移动到一个名为`ExceptionMappingSetup.cs`的新文件中：
- en: '[PRE92]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now move all the new classes under `/Bootstrap` folder:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有新类移动到`/Bootstrap`文件夹下：
- en: '![Figure 9.18: Bootstrap folder with the fragmented services injection'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18：Bootstrap文件夹与分段服务注入'
- en: '](img/B16835_09_18.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_18.jpg)'
- en: 'Figure 9.18: Bootstrap folder with the fragmented services injection'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：Bootstrap文件夹与分段服务注入
- en: '*Figure 9.18* displays the `Bootstrap` folder. This project structure itself
    demonstrates what the API is made up of. So, DI becomes as simple as the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.18*显示了`Bootstrap`文件夹。这个项目结构本身展示了API的组成。因此，DI变得像下面这样简单：'
- en: '[PRE93]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In some cases, you may want to pass the configuration or environment from a
    builder to other bootstrap methods or app methods multiple times. If you find
    yourself repeatedly calling `builder.X`, then consider storing each property in
    a local variable, as shown here:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望将配置或环境从构建器传递到其他引导方法或应用程序方法多次。如果您发现自己反复调用`builder.X`，那么请考虑将每个属性存储在一个本地变量中，如下所示：
- en: '[PRE94]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With this, you will no longer repeatedly access the builder and will instead
    be able to use the needed builder properties directly. This is especially useful
    if you migrate from .NET Core to .NET 6\. `Environment` and `Configuration` used
    to be properties of a `Program` class, while `Services` would be injected into
    the `ConfigureServices` method. In .NET 6, `Services` is accessed through a `builder`
    object. However, with this approach, you can still use those properties or arguments
    as they were.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您将不再重复访问构建器，而是能够直接使用所需的构建器属性。如果您从.NET Core迁移到.NET 6，这将特别有用。`Environment`和`Configuration`曾经是`Program`类的属性，而`Services`将被注入到`ConfigureServices`方法中。在.NET
    6中，`Services`通过`builder`对象访问。但是，通过这种方法，您仍然可以像以前一样使用这些属性或参数。
- en: From now on, when referring to services, environments, or configurations, you
    will assume that you are accessing them from `builder.Services`, `builder.Environment`,
    and `builder.Configuration`, accordingly.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当涉及到服务、环境或配置时，您将假定正在从`builder.Services`、`builder.Environment`和`builder.Configuration`中访问它们。
- en: Note
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/iQK5X](https://packt.link/iQK5X)找到此示例中使用的代码。
- en: Calling Another API
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用另一个API
- en: A working product is usually made of many APIs communicating with each other.
    To communicate effectively, one web service often needs to call another service.
    For example, a hospital may have a website (frontend) that calls a Web API (backend).
    This Web API orchestrates things by making calls to a booking Web API, a billing
    Web API, and a staff Web API. A staff Web API may make calls to an inventory API,
    holidays API, etc.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的产品通常由许多相互通信的API组成。为了有效地进行通信，一个Web服务通常需要调用另一个服务。例如，医院可能有一个调用Web API（后端）的网站（前端）。这个Web
    API通过调用预订Web API、结算Web API和员工Web API来协调事务。员工Web API可能会调用库存API、假期API等。
- en: RapidAPI
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RapidAPI
- en: As discussed in *Chapter 8*, *Creating and Using Web API Clients*, there are
    various ways of making HTTP calls to other services (though HTTP is not the only
    way to call another service). This time, you will try to get weather forecasts
    from an existing API and format it in your way. For doing so, you will use the
    RapidAPI Weather API, which can be found at [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第8章*中所讨论的，*创建和使用Web API客户端*，有各种方法可以调用其他服务（尽管HTTP不是调用另一个服务的唯一方式）。这一次，您将尝试从现有API获取天气预报并以您的方式格式化它。为此，您将使用RapidAPI天气API，该API可以在[https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)找到。
- en: Note
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: RapidAPI is a platform that supports many APIs. The site [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)
    is just one example. Many of the APIs present there are free; however, be aware
    that an API that is free today might become paid tomorrow. If that happens by
    the time you read this chapter, go through the examples, and explore the *Weather
    APIs* section at [https://rapidapi.com/category/Weather](https://rapidapi.com/category/Weather).
    You should be able to find similar alternatives there.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: RapidAPI是一个支持许多API的平台。该网站[https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)只是一个例子。那里提供的许多API是免费的；但是，请注意，今天免费的API可能明天就变成付费的。如果在您阅读本章时发生了这种情况，请查看示例，并在[https://rapidapi.com/category/Weather](https://rapidapi.com/category/Weather)的*Weather
    APIs*部分探索类似的替代方案。
- en: 'This API requires a GitHub account for use. Perform the following steps to
    use the RapidAPI Weather API:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 该API需要使用GitHub账户。执行以下步骤来使用RapidAPI天气API：
- en: Log in to the website [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/).
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)网站。
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can navigate to [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)
    only if you are logged in. So, signup at [https://rapidapi.com/](https://rapidapi.com/)
    and create an account. This is required if you need an API key. Next login and
    select `Weather` category and choose `Open Weather` link.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在登录后才能转到[https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)。因此，请在[https://rapidapi.com/](https://rapidapi.com/)注册并创建一个账户。如果您需要API密钥，则需要这样做。接下来登录并选择`Weather`类别，然后选择`Open
    Weather`链接。
- en: 'After you log in to the website, you will see the following window:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到网站后，您将看到以下窗口：
- en: '![Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on
    rapidapi.com'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19：在rapidapi.com上未订阅的Visual Crossing Weather API测试页面'
- en: '](img/B16835_09_19.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_19.jpg)'
- en: 'Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：在rapidapi.com上未订阅的Visual Crossing Weather API测试页面
- en: Click the `Subscribe to Test` button to get access (for free) to making calls
    to the Web API. A new window will open.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“订阅测试”按钮以免费访问Web API。将打开一个新窗口。
- en: 'Select the `Basic` option, which will allow you to make 500 calls a month to
    that API. For educational purposes, the basic plan should be enough:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Basic`选项，这将允许您每月对该API进行500次调用。出于教育目的，基本计划应该足够了：
- en: '![Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：突出显示了免费基本计划的RapidAPI订阅费用'
- en: '](img/B16835_09_20.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_20.jpg)'
- en: 'Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：突出显示了免费基本计划的RapidAPI订阅费用
- en: You will be redirected to the test page with the `Test Endpoint` button available
    (instead of the `Subscribe to Test` button).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到测试页面，其中将提供“测试端点”按钮（而不是“订阅测试”按钮）。
- en: Now, configure the request. The first configuration asks you to enter the intervals
    for getting the weather forecast. You want an hourly forecast, so enter `1` hour
    beside `aggregateHours` (`1`).
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置请求。第一个配置要求您输入获取天气预报的间隔。您想要每小时的预报，所以在“aggregateHours”旁边输入“1”小时（`1`）。
- en: Next up is the `location` address (`2`).
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`location`地址（`2`）。
- en: In *Figure 9.21*, you can observe that the city, state, and country are specified.
    These fields ask you to enter your address. However, typing your city name would
    also work.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.21*中，您可以观察到指定了城市、州和国家。这些字段要求您输入您的地址。但是，输入您的城市名称也可以起作用。
- en: 'Choose the default `contentType` option as `csv` for this API (`3`):'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此API的默认`contentType`选项为`csv`（`3`）：
- en: '![Figure 9.21: GET weather forecast data request configuration'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21：获取天气预报数据请求配置'
- en: '](img/B16835_09_21.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_21.jpg)'
- en: 'Figure 9.21: GET weather forecast data request configuration'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：获取天气预报数据请求配置
- en: This API is interesting because it allows you to return data in different formats—JSON,
    XML, and CSV. It is still a Web API and not so RESTful because the data response
    type is natively CSV. If you choose JSON, it will look unnatural and significantly
    more difficult to work with.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API很有趣，因为它允许以不同的格式返回数据—JSON、XML和CSV。它仍然是一个Web API，而不是RESTful，因为数据响应类型本质上是CSV。如果选择JSON，它看起来会很不自然，并且更难处理。
- en: On the next screen, click `Code Snippets` (`1`) and then `(C#) HttpClient` (`2`)
    to see the example client code generated for you.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，点击“代码片段”（`1`），然后点击“（C#）HttpClient”（`2`）以查看为您生成的示例客户端代码。
- en: Next, click `Test Endpoint` (`3`) to send a request.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击“测试端点”（`3`）发送请求。
- en: 'Click the `Results` tab (`4`) to view the response (in *Figure 9.22*, other
    endpoints are collapsed):'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“结果”选项卡（`4`）以查看响应（在*图9.22*中，其他端点已折叠）：
- en: '![Figure 9.22: rapidapi.com with test request page and example code'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22：rapidapi.com上的测试请求页面和示例代码'
- en: in C# for making the request
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发出请求的C#示例代码
- en: '](img/B16835_09_22.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_22.jpg)'
- en: 'Figure 9.22: rapidapi.com with test request page and example code in C# for
    making the request'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：rapidapi.com上的测试请求页面和用于发出请求的C#示例代码
- en: This window provides a nice API. It is also a great way to learn how to make
    calls to it by giving multiple examples of creating clients using a variety of
    languages and technologies.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 该窗口提供了一个不错的API。这也是学习如何通过提供使用各种语言和技术创建客户端的多个示例来调用它的好方法。
- en: As always, you will not initialize this client directly in a client but inject
    the client somehow. In *Chapter 8*, *Creating and Using Web API Clients*, it was
    mentioned that to have a static `HttpClient` over one constantly disposed is an
    efficient practice. However, for a Web API, there is an even better alternative—`HttpClientFactory`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您不会直接在客户端中初始化此客户端，而是以某种方式注入客户端。在*第8章*，*创建和使用Web API客户端*中提到，拥有一个静态的`HttpClient`而不是一个不断处置的`HttpClient`是一种有效的做法。但是，对于Web
    API来说，有一个更好的选择—`HttpClientFactory`。
- en: 'Before you do all that, you need to prepare a few things. First, update the
    `appsettings.json` file with the inclusion of the base URL of an API:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在做所有这些之前，您需要准备一些东西。首先，更新`appsettings.json`文件，包括API的基本URL：
- en: '[PRE95]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, you will need to create another class for fetching the weather details
    from the said API. For that purpose, you will need an API key. You can find it
    in the example code snippet on the API website:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要为从所述API获取天气详情创建另一个类。为此，您将需要一个API密钥。您可以在API网站的示例代码片段中找到它：
- en: '![Figure 9.23: RapidAPI API key in the example code snippet'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23：示例代码片段中的RapidAPI API密钥'
- en: '](img/B16835_09_23.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_23.jpg)'
- en: 'Figure 9.23: RapidAPI API key in the example code snippet'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：示例代码片段中的RapidAPI API密钥
- en: Save the API key as an environment variable because it is a secret and storing
    secrets in code is bad practice. So, name it as `x-rapidapi-key`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API密钥保存为环境变量，因为它是一个秘密，将秘密存储在代码中是不好的做法。因此，将其命名为`x-rapidapi-key`。
- en: 'Lastly, the returned weather forecast might be quite different from yours.
    You can see the example response by clicking the `Test Endpoint` button:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回的天气预报可能与您的天气预报有很大不同。您可以通过点击“测试端点”按钮来查看示例响应：
- en: '![Figure 9.24: RapidAPI example response from GET current weather data endpoint'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24：从GET当前天气数据端点获取的RapidAPI示例响应'
- en: '](img/B16835_09_24.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_24.jpg)'
- en: 'Figure 9.24: RapidAPI example response from GET current weather data endpoint'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：从GET当前天气数据端点获取的RapidAPI示例响应
- en: Copy the results received after clicking the `Test Endpoint` button.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制点击“测试端点”按钮后收到的结果。
- en: Paste the results in [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv).
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果粘贴到[https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)。
- en: Give the class name as `WeatherForecast` and leave the rest of the settings
    as the defaults.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名命名为`WeatherForecast`，并将其余设置保留为默认设置。
- en: 'Finally, press the `GENERATE` button:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按下“生成”按钮：
- en: '![Figure 9.25: Response content pasted to'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25：响应内容粘贴到'
- en: https://toolslick.com/generation/code/class-from-csv
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: https://toolslick.com/generation/code/class-from-csv
- en: '](img/B16835_09_25.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_25.jpg)'
- en: 'Figure 9.25: Response content pasted to [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：响应内容粘贴到[https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)
- en: 'This will create two classes, `WeatherForecast` and `WeatherForecastClassMap`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个类，`WeatherForecast`和`WeatherForecastClassMap`：
- en: '![Figure 9.26: Generated data model and mapping classes (simplified for brevity)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.26：生成的数据模型和映射类（简化以节省篇幅）'
- en: '](img/B16835_09_26.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_26.jpg)'
- en: 'Figure 9.26: Generated data model and mapping classes (simplified for brevity)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：生成的数据模型和映射类（简化以节省篇幅）
- en: '`WeatherForecast` represents the object to which the data from this API will
    be loaded.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecast`表示将从该API获取的数据加载到的对象。'
- en: Create a file called `WeatherForecast.cs` under the `Dtos` folder (DTO will
    be described in detail in the *DTO and Mapping Using AutoMapper* section) and
    paste the class there.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dtos`文件夹下创建一个名为`WeatherForecast.cs`的文件（DTO将在*使用AutoMapper进行DTO和映射*部分详细描述），并将类粘贴在那里。
- en: 'Remove the bits that do not have a connection to an already-existing `WeatherForecast`
    model. The cleaned-up model will look as follows:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除与已存在的`WeatherForecast`模型无关的部分。清理后的模型将如下所示：
- en: '[PRE96]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You should know that `WeatherForecastClassMap` is a special class. It is used
    by the `CsvHelper` library, which is used for parsing CSV files. You could parse
    CSV files yourself; however, `CsvHelper` makes it a lot easier to parse.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，`WeatherForecastClassMap`是一个特殊的类。它被`CsvHelper`库使用，该库用于解析CSV文件。您可以自己解析CSV文件；但是，`CsvHelper`使解析变得更加容易。
- en: 'To use `CsvHelper`, install its NuGet package:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`CsvHelper`，请安装其NuGet包：
- en: '[PRE97]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`WeatherForecastCsv` represents a mapping from a CSV to a C# object.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecastCsv`表示从CSV到C#对象的映射。'
- en: Now, create a file called `WeatherForecastClassMap.cs` under the `ClassMaps`
    folder and paste the class there.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`ClassMaps`文件夹下创建一个名为`WeatherForecastClassMap.cs`的文件，并将类粘贴在那里。
- en: 'Keep only the mappings that match the `WeatherForecast` class that was edited
    in *Step 17*:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅保留与*步骤17*中编辑的`WeatherForecast`类匹配的映射：
- en: '[PRE98]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/dV6wX](https://packt.link/dV6wX)
    and [https://packt.link/mGJMW](https://packt.link/mGJMW).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/dV6wX](https://packt.link/dV6wX)和[https://packt.link/mGJMW](https://packt.link/mGJMW)找到此示例使用的代码。
- en: In the previous section, you learned how to get weather forecasts from an existing
    API and format them your way using the RapidAPI Weather API. Now it is time to
    proceed to the service client and use the models created, along with the settings,
    parse the API response, and return the current time weather.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学会了如何从现有API获取天气预报，并使用RapidAPI天气API按照自己的方式格式化它们。现在是时候继续进行服务客户端，并使用创建的模型以及设置，解析API响应，并返回当前时间的天气。
- en: Service Client
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务客户端
- en: 'Now you have all the ingredients that are needed to create the provider class.
    You learned in *Chapter 8*, *Creating and Using Web API Clients*, that when communicating
    with another API, it''s best to create a separate component for it. So, here you
    will start from an interface abstraction, `IWeatherForecastProvider`:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经拥有创建提供程序类所需的所有要素。您在*第8章*中学到，当与另一个API通信时，最好为其创建一个单独的组件。因此，在这里，您将从一个接口抽象`IWeatherForecastProvider`开始：
- en: '[PRE99]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, create an implementation of that interface—that is, a class taking `HttpClient`
    for DI:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建该接口的实现-即，使用`HttpClient`进行DI的类：
- en: '[PRE100]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To implement an interface, start with writing a method definition for getting
    the current weather:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个接口，首先编写一个用于获取当前天气的方法定义：
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, create a request to call HTTP GET with a relative URI for getting a forecast
    of the CSV type at a given location:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个请求，使用相对URI调用HTTP GET来获取给定位置的CSV类型的预测：
- en: '[PRE102]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, send a request and verify that it was a success:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发送一个请求并验证它是否成功：
- en: '[PRE103]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If the status code is not in the range of `200-300`, the `response.EnsureSuccessStatusCode();`
    throws an exception. Set up a CSV reader to prepare for deserializing weather
    forecasts:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码不在`200-300`范围内，则`response.EnsureSuccessStatusCode();`会引发异常。设置CSV读取器以准备反序列化天气预报：
- en: '[PRE104]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You are adding a `using` statement to `StringReader` and `CsvReader` because
    both implement the `IDisposable` interface for disposing unmanaged resources.
    This happens when you use the `using` statement within a function after it returns.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在向`StringReader`和`CsvReader`添加`using`语句，因为两者都实现了`IDisposable`接口，用于处理非托管资源。当您在函数中使用`using`语句在返回后发生时。
- en: 'Lastly, deserialize the forecasts:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反序列化预测：
- en: '[PRE105]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This way, you request the API to return forecasts starting from today and stopping
    a few days in the future with 1-hour intervals. The first returned forecast is
    the forecast of the current hour—that is, the forecast that you need:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您请求API从今天开始返回预测，并在未来的几天内以1小时的间隔停止。第一个返回的预测是当前小时的预测-也就是您需要的预测：
- en: '[PRE106]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, you will use `Newtonsoft.Json` for deserialization. Install the following
    package to do so:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将使用`Newtonsoft.Json`进行反序列化。安装以下软件包以执行此操作：
- en: '[PRE107]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Update the `AddControllersConfiguration` method by appending the following
    line on the services object:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在services对象上附加以下行来更新`AddControllersConfiguration`方法：
- en: '[PRE108]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This line replaces the default serializer with `Newtonsoft.Json`. Now, `Newtonsoft.Json`
    doesn't have to be used; however, it is a much more popular and complete library
    for serialization compared to the default one.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 此行用`Newtonsoft.Json`替换了默认序列化程序。现在，不一定要使用`Newtonsoft.Json`；但是，与默认序列化程序相比，它是一个更受欢迎和完整的序列化库。
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/jmSwi](https://packt.link/jmSwi).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/jmSwi](https://packt.link/jmSwi)找到此示例使用的代码。
- en: Till now, you have learned how to create a service client and make basic HTTP
    calls using it. It's effective for grasping the basics; however, the classes the
    API uses should be coupled with the classes of the APIs it consumes. In the next
    section, you will learn how to decouple the API from third-party API models using
    a DTO and mapping via `AutoMapper`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何创建服务客户端并使用它进行基本的HTTP调用。这对于掌握基础知识是有效的；但是，API使用的类应该与其消耗的API的类耦合。在下一节中，您将学习如何使用DTO和通过`AutoMapper`进行映射来解耦第三方API模型。
- en: DTO and Mapping Using AutoMapper
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AutoMapper进行DTO和映射
- en: The weather forecast model from RapidAPI is a Date Transfer Object (DTO)—a model
    used just for transferring data and convenient serialization. RapidAPI may change
    its data model and, if that happens, the DTO will change as well. If you are just
    presenting the data you had received and don't need to perform any logical operations
    on it, then any change may be alright.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: RapidAPI的天气预报模型是一个数据传输对象（DTO）- 一个仅用于传输数据和方便序列化的模型。RapidAPI可能会更改其数据模型，如果发生这种情况，DTO也将发生变化。如果您只是呈现您收到的数据并且不需要对其执行任何逻辑操作，那么任何更改都可能是可以的。
- en: However, you will usually apply business logic to a data model. You already
    know that references to a data model are scattered across multiple classes. With
    every change to a DTO, a class may have to change as well. For example, the DTO
    property that was called `weather` has now changed to `weathers`. Another example
    is of a property that was previously called `description` will now be called a
    `message`. So, renaming a DTO property like this will require you to make changes
    everywhere they are referenced. The bigger the project, the worse of an issue
    this becomes.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您通常会对数据模型应用业务逻辑。您已经知道数据模型的引用分散在多个类中。对DTO的每次更改，类可能也必须更改。例如，以前称为`weather`的DTO属性现在已更改为`weathers`。另一个例子是以前称为`description`的属性现在将被称为`message`。因此，像这样重命名DTO属性将需要您在引用它们的所有地方进行更改。项目越大，这个问题就会变得越糟糕。
- en: The advice of the SOLID principles is to avoid such changes (refer to *Chapter
    2*, *Building Quality Object-Oriented Code*). One of the ways to achieve this
    is by having two kinds of models—one for domain and the other for outside calls.
    This will require a mapping between foreign objects (coming from outside APIs)
    into your own.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则建议避免这样的更改（参见*第2章*，*构建高质量面向对象的代码*）。实现这一点的一种方法是拥有两种类型的模型——一种用于领域，另一种用于外部调用。这将需要在外部对象（来自外部API）和您自己之间进行映射。
- en: Mapping can be done either manually or by using some popular libraries. One
    of the most popular mapping libraries is AutoMapper. It allows you to map from
    one object to another using property names. You can also make your own mappings.
    Now, you will use this library to configure a mapping between a weather forecast
    DTO and a weather forecast model.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 映射可以手动完成，也可以使用一些流行的库。最流行的映射库之一是AutoMapper。它允许您使用属性名称将一个对象映射到另一个对象。您还可以创建自己的映射。现在，您将使用此库来配置天气预报DTO和天气预报模型之间的映射。
- en: 'So, first install NuGet:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装NuGet：
- en: '[PRE109]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This library allows you to inject `AutoMapper` into `ServiceCollection`. Here,
    `AutoMapper` uses the `Profile` class to define a mapping.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 此库允许您将`AutoMapper`注入到`ServiceCollection`中。在这里，`AutoMapper`使用`Profile`类来定义映射。
- en: 'A new mapping should inherit the `Profile` class. So, inside the constructor
    of the new profile, use a `CreateMap` method to provide a mapping:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 新映射应继承`Profile`类。因此，在新配置文件的构造函数中，使用`CreateMap`方法提供映射：
- en: '[PRE110]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, in order to map every property from the `CreateMap` method, call the
    `ForMember` method and specify how to do a mapping:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了从`CreateMap`方法映射每个属性，调用`ForMember`方法并指定如何进行映射：
- en: '[PRE111]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here, the value of `TemperatureC` comes from `main.temp` inside the DTO.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`TemperatureC`值来自DTO中的`main.temp`。
- en: 'For the other property, you will concatenate all the weather descriptions into
    one string and call that a summary (`BuildDescription`):'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他属性，您将所有天气描述连接成一个字符串，并称之为摘要（`BuildDescription`）：
- en: '[PRE112]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, use the lambda method, `ForMember`, when building a weather forecast summary
    mapping:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构建天气预报摘要映射时，使用lambda方法`ForMember`：
- en: '[PRE113]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Create a `MapperSetup` class and inject `AutoMapper` from the `AddModelMappings`
    method to provide different mapping profiles:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`MapperSetup`类，并从`AddModelMappings`方法中注入`AutoMapper`，以提供不同的映射配置文件：
- en: '[PRE114]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Append `.AddModelMappings()` to the `services` object calls. With this, you
    can call `mapper.Map<Model.WeatherForecast>(dtoForecast);`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`对象调用中添加`.AddModelMappings()`。通过这样做，您可以调用`mapper.Map<Model.WeatherForecast>(dtoForecast);`。
- en: Note
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fEfdw](https://packt.link/fEfdw)
    and [https://packt.link/wDqK6](https://packt.link/wDqK6).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/fEfdw](https://packt.link/fEfdw)和[https://packt.link/wDqK6](https://packt.link/wDqK6)找到此示例的代码。
- en: The `AutoMapper` mapping library allows you to map from one object to another
    by default mapping matching property names. The next section will detail how you
    can use DI to reuse `HttpClient`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapper`映射库允许您通过默认映射匹配属性名称从一个对象映射到另一个对象。下一节将详细介绍如何使用DI来重用`HttpClient`。'
- en: HttpClient DI
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpClient DI
- en: 'Continuing with DI, you now want to get into the habit of using the fragmented
    `ConfigureServices` approach. So, first, create a class called `HttpClientsSetup`
    and then create a method for adding the configured `HttpClients`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用DI，现在您希望养成使用分段的`ConfigureServices`方法的习惯。因此，首先创建一个名为`HttpClientsSetup`的类，然后创建一个用于添加配置的`HttpClients`的方法：
- en: '[PRE115]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Next, for the injection itself, use the `AddHttpClient` method:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于注入本身，请使用`AddHttpClient`方法：
- en: '[PRE116]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In the preceding section, it was mentioned that the keys should be hidden and
    stored in environment variables. To set a default start URI of every call, set
    `BaseAddress` (`WeatherForecastProviderUrl` used in *Step 10* of the *RapidAPI*
    section).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中提到，应该隐藏密钥并将其存储在环境变量中。要设置每次调用的默认起始URI，请设置`BaseAddress`（在*RapidAPI*部分的*步骤10*中使用的`WeatherForecastProviderUrl`）。
- en: 'To append the API key on every request, get the API key that you stored in
    environment variables and assign it to default headers as `x-rapidapi-key`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每个请求中附加API密钥，请获取存储在环境变量中的API密钥，并将其分配给默认标头，如`x-rapidapi-key`：
- en: '[PRE117]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To finish the injection-builder pattern, you need to return the `services`
    object, as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成注入构建器模式，您需要返回`services`对象，如下所示：
- en: '[PRE118]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, go back to `services` in `Program` and append the following:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Program`中的`services`并追加以下内容：
- en: '[PRE119]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To integrate the client you have just set up, go to `WeatherForecastService`,
    and inject the `mapper` and `provider` components:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成刚刚设置的客户端，请转到`WeatherForecastService`，并注入`mapper`和`provider`组件：
- en: '[PRE120]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Change the `GetWeatherForecast` method to either get the cached forecast of
    this hour or fetch a new one from the API:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`GetWeatherForecast`方法，以获取此小时的缓存预测或从API获取新的预测：
- en: '[PRE121]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This method, just like the preceding one, first tries to get a value from the
    cache. If the value exists, then the method returns a value. However, if the value
    does not exist, the method calls the API for the preconfigured city, maps the
    DTO forecast to the model forecast, and saves it in the cache.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法，就像前面的方法一样，首先尝试从缓存中获取值。如果值存在，则方法返回一个值。但是，如果值不存在，方法将调用预配置的城市的API，将DTO预测映射到模型预测，并将其保存在缓存中。
- en: 'If you send an HTTP GET request to `https://localhost:7021/WeatherForecast/`,
    you should see the following response:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`https://localhost:7021/WeatherForecast/`发送HTTP GET请求，您应该看到以下响应：
- en: '[PRE122]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Calling the same endpoint results in the same response. However, the response
    times are significantly faster due to the cache being used rather than repeating
    a call to the forecast API.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 调用相同的端点会导致相同的响应。然而，由于使用了缓存而不是重复调用预测API，响应时间显着更快。
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/GMFmm](https://packt.link/GMFmm).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/GMFmm](https://packt.link/GMFmm)找到此示例的代码。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本主题的理论部分。在接下来的部分中，您将通过练习将其付诸实践。
- en: 'Exercise 9.03: Performing File Operations by Calling Azure Blob Storage'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03：通过调用Azure Blob存储执行文件操作
- en: 'A common task with a Web API is to perform a variety of operations on files,
    such as download, upload, or delete. In this exercise, you will reuse a portion
    of `FilesClient` from *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented
    Code*, to serve as a baseline client for calling Azure Blob storage and call its
    methods via REST endpoints to do the following operations on a file:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: Web API的一个常见任务是对文件执行各种操作，如下载、上传或删除。在这个练习中，您将重用*第8章*的*Activity 8.04*中的`FilesClient`的一部分，*构建高质量的面向对象的代码*，作为调用Azure
    Blob存储的基线客户端，并通过REST端点调用其方法来执行以下操作：
- en: Download a file.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件。
- en: Get a shareable link with expiration time.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个带有过期时间的可共享链接。
- en: Upload a file.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传一个文件。
- en: Delete a file.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件。
- en: 'Perform the following steps to do so:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现：
- en: 'Extract an interface for `FilesClient` and call it `IFilesService`:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FilesClient`提取一个接口，并将其命名为`IFilesService`：
- en: '[PRE123]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The new interface is simplified as you will work on a single container. However,
    as per the requirements, you have added a few new methods: `Delete`, `Upload`,
    `Download`, and `GetDownloadLink`. The `Download` method is for downloading a
    file in its raw form—that is, bytes.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 新接口简化了，因为你将在一个单一的容器上工作。但是，根据要求，你已经添加了一些新方法：`Delete`、`Upload`、`Download`和`GetDownloadLink`。`Download`方法用于以原始形式下载文件，即字节。
- en: Create a new class called `Exercises/Exercise03/FilesService.cs`.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exercises/Exercise03/FilesService.cs`的新类。
- en: Copy the following parts of [https://packt.link/XC9qG](https://packt.link/XC9qG%20)
    there.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制[https://packt.link/XC9qG](https://packt.link/XC9qG%20)的以下部分。
- en: Rename `Client` to `Service`.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Client`重命名为`Service`。
- en: 'Also change the `Exercise04` reference (used in *Chapter 8*, *Building Quality
    Object-Oriented Code*) to `Exercise03` (a new one to be used for this chapter):'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将`Exercise04`的引用（在*第8章*，*构建高质量的面向对象的代码*中使用）更改为`Exercise03`（在本章中要使用的新引用）：
- en: '[PRE124]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The constructor initializes `blobServiceClient` to get `blobClient`, which
    allows you to do operations in the *Exercice03* directory in the Azure Blob Storage
    Account. If the folder doesn''t exist, `blobServiceClient` will create it for
    you:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化`blobServiceClient`以获取`blobClient`，它允许您在Azure Blob存储帐户的*Exercice03*目录中执行操作。如果文件夹不存在，`blobServiceClient`将为您创建它：
- en: '[PRE126]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the preceding step to work, you will need an Azure Storage Account. So,
    refer to *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented Code*.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述步骤生效，您需要一个Azure存储帐户。因此，请参考*第8章*的*Activity 8.04*，*构建高质量的面向对象的代码*。
- en: 'Create the `ValidateFileExists` method to validate whether a file exists in
    the storage, else throw an exception (a small helper method that did not exist before):'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ValidateFileExists`方法来验证存储中是否存在文件，否则抛出异常（一个之前不存在的小帮助方法）：
- en: '[PRE127]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, create the `Delete` method to delete a file:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`Delete`方法来删除文件：
- en: '[PRE128]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, you will first get a client for the file and then check whether the file
    exists. If not, then you will throw a `FileNotFoundException` exception. If the
    file exists, then you will delete the file.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你首先会得到一个文件的客户端，然后检查文件是否存在。如果不存在，那么你将抛出一个`FileNotFoundException`异常。如果文件存在，那么你将删除文件。
- en: 'Create the `UploadFile` method to upload a file:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`UploadFile`方法来上传文件：
- en: '[PRE129]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Once again, you first get a client that allows you to perform operations on
    a file. Then, feed the content and headers to it to upload.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，首先获取一个允许您对文件执行操作的客户端。然后，将内容和标头提供给它以上传。
- en: 'Create the `Download` method to download a file in bytes:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Download`方法以字节形式下载文件：
- en: '[PRE130]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This method creates a memory stream and downloads the file to it. Please note
    that this is not going to work on large files.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法创建一个内存流并将文件下载到其中。请注意，这不适用于大文件。
- en: Note
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more on how to process large files, please refer
    to [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解如何处理大文件的更多信息，请参考[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming)。
- en: There is a way to present raw downloaded bytes as an image or JSON, rather than
    as generic downloadable content. With an HTTP request or response, you can send
    a header specifying the way the content should be interpreted. This header is
    called Content-Type. Each application will process this differently. In the context
    of Swagger, `image/png` will be displayed as an image, while `application/json`
    will be shown as JSON.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以将原始下载的字节呈现为图像或JSON，而不是通用可下载内容。通过HTTP请求或响应，您可以发送一个指定内容应该如何被解释的标头。这个标头叫做Content-Type。每个应用程序都会以不同的方式处理这个标头。在Swagger的上下文中，`image/png`将显示为图像，而`application/json`将显示为JSON。
- en: 'Create a `GetUri` method to get a URI of `blobClient`:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GetUri`方法来获取`blobClient`的URI：
- en: '[PRE131]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Getting a URI requires the use of `BlobSasBuilder`, through which you can generate
    a shareable URL to a blob. Through the builder, specify the kind of resource you
    are trying to share (`"b"` stands for blob) and the expiry time. You need to set
    the permissions (to read) and pass the `sasBuilder` builder to the `blobClient`
    client to generate `sasUri`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 获取URI需要使用`BlobSasBuilder`，通过它可以生成一个可共享的blob URL。通过构建器，指定您要共享的资源类型（“b”代表blob）和过期时间。您需要设置权限（读取）并将`sasBuilder`构建器传递给`blobClient`客户端以生成`sasUri`。
- en: 'Now, use a filename to create a file download link:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用文件名创建一个文件下载链接：
- en: '[PRE132]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Inside the `ExceptionMappingSetup` class and the `AddExceptionMappings` method,
    add the following mapping:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ExceptionMappingSetup`类和`AddExceptionMappings`方法中，添加以下映射：
- en: '[PRE133]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create an extension method to inject a module of `FileUploadService`:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展方法来注入`FileUploadService`模块：
- en: '[PRE134]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: An extension method is a simplified way of showing a new method to an existing interface.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是向现有接口展示新方法的简化方式。
- en: 'Append it to `services` in `Program.cs` to use the `FileUploadService` module:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其附加到`Program.cs`中的`services`中，以使用`FileUploadService`模块：
- en: '[PRE135]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, create a controller for files:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为文件创建一个控制器：
- en: '[PRE136]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Controller creation is standard on MVC architecture, and this allows users to
    access `FileService` through HTTP requests.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的创建在MVC架构上是标准的，这允许用户通过HTTP请求访问`FileService`。
- en: 'Then, inject `IFilesService` to provide an interface through which file-related
    functionality could be accessed:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，注入`IFilesService`以提供一个接口，通过该接口可以访问与文件相关的功能：
- en: '[PRE137]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, create an endpoint to delete a file:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个端点来删除文件：
- en: '[PRE138]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Create an endpoint to download a file:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点来下载文件：
- en: '[PRE139]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Create an endpoint for getting a shareable file download link:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点来获取可共享的文件下载链接：
- en: '[PRE140]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create an endpoint for uploading a file:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点来上传文件：
- en: '[PRE141]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`IFormFile` is a common way of passing small files to a controller. However,
    from `IFormFile`, you need file contents as a stream. You can get this using the
    `OpenReadStream` method. Swagger allows you to use the File Explorer window to
    choose the file you want to upload.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFormFile`是将小文件传递给控制器的常用方式。但是，从`IFormFile`中，您需要文件内容作为流。您可以使用`OpenReadStream`方法来获取这个。Swagger允许您使用文件资源管理器窗口选择要上传的文件。'
- en: Now you run the API.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行API。
- en: 'Your Swagger documentation will have a new section with the controller methods.
    Here are the responses of each:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Swagger文档将有一个新的部分，其中包含控制器方法的响应。以下是每个的响应：
- en: 'Upload file request:'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件请求：
- en: '![Figure 9.27: Upload file request in Swagger'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.27：Swagger中的上传文件请求'
- en: '](img/B16835_09_27.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_27.jpg)'
- en: 'Figure 9.27: Upload file request in Swagger'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27：Swagger中的上传文件请求
- en: 'Upload file response:'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件响应：
- en: '![Figure 9.28: Upload file response in Swagger'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28：Swagger中的上传文件响应'
- en: '](img/B16835_09_28.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_28.jpg)'
- en: 'Figure 9.28: Upload file response in Swagger'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28：Swagger中的上传文件响应
- en: 'Get download link request:'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接请求：
- en: '![Figure 9.29: Get download link request in Swagger'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.29：在Swagger中获取下载链接请求'
- en: '](img/B16835_09_29.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_29.jpg)'
- en: 'Figure 9.29: Get download link request in Swagger'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：在Swagger中获取下载链接请求
- en: 'Get download link response:'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接响应：
- en: '![Figure 9.30: Get download link response in Swagger'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.30：Swagger中的获取下载链接响应'
- en: '](img/B16835_09_30.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_30.jpg)'
- en: 'Figure 9.30: Get download link response in Swagger'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：Swagger中的获取下载链接响应
- en: 'Download file request:'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件请求：
- en: '![Figure 9.31: Download file request in Swagger'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.31：Swagger中的下载文件请求'
- en: '](img/B16835_09_31.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_31.jpg)'
- en: 'Figure 9.31: Download file request in Swagger'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：Swagger中的下载文件请求
- en: 'Download file response:'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件响应：
- en: '![Figure 9.32: Download file response in Swagger'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.32：Swagger中的下载文件响应'
- en: '](img/B16835_09_32.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_32.jpg)'
- en: 'Figure 9.32: Download file response in Swagger'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：Swagger中的下载文件响应
- en: 'Delete file request:'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件请求：
- en: '![Figure 9.33: Delete file request in Swagger'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33：Swagger中的删除文件请求'
- en: '](img/B16835_09_33.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_33.jpg)'
- en: 'Figure 9.33: Delete file request in Swagger'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33：Swagger中的删除文件请求
- en: 'Delete file response:'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件响应：
- en: '![Figure 9.34: Delete file response in Swagger'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.34：Swagger中的删除文件响应'
- en: '](img/B16835_09_34.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_34.jpg)'
- en: 'Figure 9.34: Delete file response in Swagger'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34：Swagger中的删除文件响应
- en: This exercise illustrated the remaining aspects of what you can do with a Web
    API.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了Web API的其余方面。
- en: Note
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cTa4a](https://packt.link/cTa4a).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cTa4a](https://packt.link/cTa4a)找到用于此练习的代码。
- en: The volume of functionality you can serve through the web is immense. However,
    this comes with its own big problem. How do you ensure that your API is consumed
    only by the intended identities? In the next section, you will explore how to
    secure a Web API.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过网络提供的功能量是巨大的。然而，这也带来了自己的大问题。您如何确保您的API只被预期的身份消耗？在下一节中，您将探讨如何保护Web API。
- en: Securing a Web API
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护Web API
- en: Every now and then, you'll hear about a major security breach on the news. In
    this section, you will learn how to protect a public API using AAD.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 时不时地，您会在新闻中听到重大的安全漏洞。在本节中，您将学习如何使用AAD保护公共API。
- en: Azure Active Directory
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Active Directory
- en: Azure Active Directory (AAD) is Microsoft's cloud identity and access management
    service that is used to sign in to well-known applications, such as Visual Studio,
    Office 365, and Azure, and to internal resources. AAD uses OpenID to provide user
    identity through a JavaScript Web Token.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Active Directory（AAD）是微软的云身份和访问管理服务，用于登录知名应用程序，如Visual Studio、Office 365和Azure，以及内部资源。AAD使用OpenID通过JavaScript
    Web Token提供用户身份。
- en: JWT
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT
- en: A JavaScript Web Token (JWT) is a collection of personal data encoded and sent
    over as a mechanism of authentication. A single field encoded in a JWT is called
    a claim.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript Web Token（JWT）是编码和发送个人数据的集合，作为身份验证机制。在JWT中编码的单个字段称为声明。
- en: OpenID Connect
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: OpenID Connect (OIDC) is the protocol used for getting the ID token, which provides
    user identity or an access token. It's a layer on top of OAuth 2 to get an identity.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect（OIDC）是用于获取ID令牌的协议，它提供用户身份或访问令牌。它是在OAuth 2之上的一层，用于获取身份。
- en: OAuth serves as a means of getting an access token on behalf of some user. With
    OIDC, you get an identity; this has a role and access comes from that role. When
    a user wants to log in to a website, OpenID might require them to input their
    credentials. This might sound exactly the same as OAuth; however, don't mix the
    two. OpenID is all about acquiring and verifying the user's identity and granting
    access coming with a role. OAuth, on the other hand, gives access to a user to
    do a limited set of functionalities.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth作为一种手段，代表某个用户获取访问令牌。使用OIDC，您获得一个身份；这个身份有一个角色，访问权限来自于这个角色。当用户想要登录网站时，OpenID可能要求他们输入他们的凭据。这听起来可能与OAuth完全相同；然而，不要混淆这两者。OpenID主要是获取和验证用户的身份，并授予与角色相关的访问权限。另一方面，OAuth为用户提供对有限功能集的访问权限。
- en: 'A real-life analogy would be as follows:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实生活的类比如下：
- en: 'OpenID: You come to an airport and present your passport (which is issued by
    the government) confirming your role (passenger) and identity that way. You are
    **granted** a **passenger** role and allowed to board an airplane.'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID：您来到机场，出示由政府签发的护照（证实您的角色（乘客）和身份）。您被授予乘客角色，并被允许登机。
- en: 'OAuth: You come to an airport and the staff asks you to take part in an emotional
    state tracking event. With your **consent**, the staff (**others**) at the airport
    can now track more of your personal data.'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth：您来到机场，工作人员要求您参加情绪状态跟踪活动。在您的同意下，机场的工作人员（他人）现在可以跟踪更多您的个人数据。
- en: 'The following is a summary:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是摘要：
- en: OpenID provides authentication and **verifies who you are**.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID提供身份验证并验证您的身份。
- en: OAuth is authorization that allows others to do **things on your behalf**.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth是授权，允许他人代表您执行操作。
- en: Application Registration
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序注册
- en: 'The first step in securing a Web API using Azure is to create an application
    registration in AAD. Perform the following steps to do so:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure保护Web API的第一步是在AAD中创建应用程序注册。执行以下步骤：
- en: 'Navigate to `Azure Active Directory` by typing `active dir` in the search bar:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索栏中键入“active dir”导航到“Azure活动目录”：
- en: '![Figure 9.35: Azure Active Directory being searched in portal.azure'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.35：在portal.azure中搜索Azure活动目录'
- en: '](img/B16835_09_35.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_35.jpg)'
- en: 'Figure 9.35: Azure Active Directory being searched in portal.azure'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35：在portal.azure中搜索Azure活动目录
- en: In the new window, click the `App registrations` option (`1`).
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，点击“应用注册”选项（`1`）。
- en: 'Then, click the `New registration` button (`2`):'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“新注册”按钮（`2`）：
- en: '![Figure 9.36: Azure app registration'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.36：Azure应用注册'
- en: '](img/B16835_09_36.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_36.jpg)'
- en: 'Figure 9.36: Azure app registration'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36：Azure应用注册
- en: In the new window, enter `Chapter09WebApi` as the name.
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，输入`Chapter09WebApi`作为名称。
- en: 'Keep the other settings as the default and click the `Register` button:'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他设置为默认值，然后点击“注册”按钮：
- en: '![Figure 9.37: The new app registration named Chapter09WebApi'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.37：名为Chapter09WebApi的新应用注册'
- en: '](img/B16835_09_37.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_37.jpg)'
- en: 'Figure 9.37: The new app registration named Chapter09WebApi'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：名为Chapter09WebApi的新应用注册
- en: To access an API, you need at least one scope or role. In this example, you
    will create a scope called `access_as_user`.
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问API，您至少需要一个范围或角色。在本例中，您将创建一个名为`access_as_user`的范围。
- en: Scopes in general can be used to control which part of an API is accessible
    to you. For the scope to be available for all users, you will need to select `Admins
    and users`.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，范围可用于控制对API的哪一部分是可访问的。为了使范围对所有用户可用，您需要选择“管理员和用户”。
- en: 'In this trivial example, given the token is valid, you will allow access to
    everything. So, select the `Access all as a user` option. The exact values of
    the other fields do not matter:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，假设令牌有效，您将允许访问所有内容。因此，选择“作为用户访问所有内容”选项。其他字段的确切值并不重要：
- en: '![Figure 9.38: The access_as_user scope available for all users'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.38：`access_as_user`范围对所有用户可用'
- en: '](img/B16835_09_38.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_38.jpg)'
- en: 'Figure 9.38: The access_as_user scope available for all users'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38：`access_as_user`范围对所有用户可用
- en: The first step in securing a Web API using Azure was to create an application
    registration in AAD. The next topic will cover how you can implement security
    within a Web API in .NET.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure保护Web API的第一步是在AAD中创建应用程序注册。下一个主题将介绍如何在.NET中实现Web API的安全性。
- en: Implementing Web API Security
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Web API安全性
- en: 'This section will focus on the details of how, programmatically, you can get
    the token and work with it. So, first, install NuGet, which does JWT validation
    using the Microsoft identity platform:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍如何以编程方式获取令牌并处理它的详细信息。因此，首先安装使用Microsoft身份平台进行JWT验证的NuGet：
- en: '[PRE142]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the Bootstrap folder, create the `SecuritySetup` class:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bootstrap文件夹中，创建`SecuritySetup`类：
- en: '[PRE143]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then, in `Program.cs`, append this to `services`:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Program.cs`中，将此附加到`services`：
- en: '[PRE144]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The injected services are needed by the authorization middleware. So, add the
    following on an `app` to add authorization middleware:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 授权中间件需要注入的服务。因此，添加以下内容到`app`以添加授权中间件：
- en: '[PRE145]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This will be triggered on all endpoints decorated with the `[Authorize]` attribute.
    Make sure the preceding two lines are placed before `app.MapControllers();` or
    else the middleware will not be wired with your controllers.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在所有带有`[Authorize]`属性的端点上触发。确保前两行放置在`app.MapControllers();`之前，否则中间件将无法与您的控制器连接。
- en: 'Within `appsettings.json`, add the following configuration to link to your
    `AzureAd` security configuration:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在`appsettings.json`中，添加以下配置以链接到您的`AzureAd`安全配置：
- en: '[PRE146]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Lastly, add the `Authorize` attribute above each controller for any kind of
    security you choose:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每个控制器上方添加`Authorize`属性，以选择任何类型的安全性：
- en: '[PRE147]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The `Authorize` attribute is essential for any type of security implementation.
    This attribute will perform the generic token validation, while `[RequiredScope("access_as_user")]`
    will check whether the `access_as_user` scope was included or not. What you now
    have is a secured API. If you try calling the `WeatherForecast` endpoints, you
    will get a `401 – Unauthorised` error.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorize`属性对于任何类型的安全性实现都是必不可少的。该属性将执行通用令牌验证，而`[RequiredScope("access_as_user")]`将检查`access_as_user`范围是否已包含。现在您拥有了一个安全的API。如果尝试调用`WeatherForecast`端点，将收到`401
    - 未经授权`错误。'
- en: Note
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ruj9o](https://packt.link/ruj9o).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ruj9o](https://packt.link/ruj9o)找到此示例使用的代码。
- en: In the next section, you will learn how to generate a token through the token
    generator app and use it to securely access your API.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何通过令牌生成器应用程序生成令牌，并使用它安全地访问您的API。
- en: Token Generator App
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令牌生成器应用程序
- en: 'To call the API, you need to generate a token by creating a console application.
    Before you do that, however, you need to configure one more thing in your app
    registration. Your console application is considered a desktop app. So, when signing
    in, you need a redirect URI. This URI, returned with the code, is used to get
    the access token. To achieve this, perform the following steps:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用API，您需要通过创建一个控制台应用程序来生成一个令牌。但是，在这之前，您需要在应用程序注册中配置另一件事。您的控制台应用程序被视为桌面应用程序。因此，在登录时，您需要一个重定向URI。返回的此URI与代码一起用于获取访问令牌。为此，请执行以下步骤：
- en: From the left pane in AAD, select the `Authentication` option (`1`) to view
    all configurations with outside applications.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从AAD的左窗格中，选择`身份验证`选项（`1`）以查看所有与外部应用程序的配置。
- en: 'Next, click the `Add a platform` button (`2`) to configure a new application
    (token generator):'
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击“添加平台”按钮（`2`）配置一个新应用程序（令牌生成器）：
- en: '![Figure 9.39: Authentication window with options to configure a new application'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.39：带有配置新应用程序选项的身份验证窗口'
- en: '](img/B16835_09_39.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_39.jpg)'
- en: 'Figure 9.39: Authentication window with options to configure a new application'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39：带有配置新应用程序选项的身份验证窗口
- en: 'In the `Configure platforms` section, select the `Mobile and desktop applications`
    button (`3`) to register a console application token generator:'
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“配置平台”部分，选择“移动和桌面应用程序”按钮（`3`）注册控制台应用程序令牌生成器：
- en: '![Figure 9.40: Selecting the Mobile and desktop applications platform for authentication'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.40：选择移动和桌面应用程序平台进行身份验证'
- en: '](img/B16835_09_40.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_40.jpg)'
- en: 'Figure 9.40: Selecting the Mobile and desktop applications platform for authentication'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40：选择移动和桌面应用程序平台进行身份验证
- en: A new window will open on the screen.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上会打开一个新窗口。
- en: Type your `Custom redirect URIs` that specify where you will return after the
    successful login to AAD when requesting the token. In this case, it doesn't matter
    so much. So, type any URL.
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的“自定义重定向URI”，指定成功登录到AAD后请求令牌时将返回的位置。在这种情况下，这并不那么重要。所以，输入任何URL。
- en: 'Then, click the `Configure` button (`4`):'
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“配置”按钮（`4`）：
- en: '![Figure 9.41: Configuring the redirect URI'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.41：配置重定向URI'
- en: '](img/B16835_09_41.jpg)'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_41.jpg)'
- en: 'Figure 9.41: Configuring the redirect URI'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.41：配置重定向URI
- en: 'That completes the configuration of AAD. Now that you have all the infrastructure
    for security, build a console application to generate an access token from AAD:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了AAD的配置。现在您已经拥有了安全的所有基础设施，可以构建一个控制台应用程序来从AAD生成访问令牌：
- en: First, create a new project called `Chapter09.TokenGenerator`. It will allow
    you to generate authorization tokens needed to call your API.
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Chapter09.TokenGenerator`的新项目。它将允许您生成调用API所需的授权令牌。
- en: Then, make it a console app on .NET Core to keep it simple and display a generated
    token.
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其设置为.NET Core上的控制台应用程序，以保持简单并显示生成的令牌。
- en: 'Add `Microsoft.Identity.Client` by running the following command:'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令添加`Microsoft.Identity.Client`：
- en: '[PRE148]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This will allow you to request a token later.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您以后请求令牌。
- en: 'Next, in `Program.cs`, create a method to initialize an AAD application client.
    This will be used to prompt browser login, as if you were to log in to the Azure portal:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Program.cs`中创建一个方法来初始化AAD应用程序客户端。这将用于提示浏览器登录，就好像您要登录到Azure门户一样：
- en: '[PRE149]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The values used in the preceding code will differ, depending upon the AAD subscription.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中使用的值将根据AAD订阅而异。
- en: As you can see, the application uses the `clientId` and `tenantId` configured
    in AAD.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，应用程序使用了在AAD中配置的`clientId`和`tenantId`。
- en: 'Create another method to use the application that requires a user login on
    Azure to get an auth token:'
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个方法来使用需要在Azure上进行用户登录以获取身份验证令牌的应用程序：
- en: '[PRE150]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, define the scopes you need:'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义您需要的范围：
- en: '[PRE151]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Replace `api://{clientId}/{scope}` with your own application ID URI if you are
    not using a default value.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 用您自己的应用程序ID URI替换`api://{clientId}/{scope}`，如果您没有使用默认值。
- en: 'Then, attempt to get a cached token:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试获取缓存的令牌：
- en: '[PRE152]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The cached token retrieval is required if the login was done earlier. If you
    haven''t signed in before to get a token, you will need to log in to Azure AD:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前已经登录，则需要缓存令牌检索。如果您以前没有登录以获取令牌，您将需要登录到Azure AD：
- en: '[PRE153]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Return the access token as the result of a logged-in user so that you can use
    it later to access your APIs:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将访问令牌作为已登录用户的结果返回，以便以后可以使用它来访问您的API：
- en: '[PRE154]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now, call the two methods and print the result (using the minimal API):'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用这两个方法并打印结果（使用最小API）：
- en: '[PRE155]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Finally, when you run the token app, it will ask you to sign in:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当您运行令牌应用程序时，它会要求您登录：
- en: '![Figure 9.42: Sign-in request from Azure'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.42：来自Azure的登录请求'
- en: '](img/B16835_09_42.jpg)'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_42.jpg)'
- en: 'Figure 9.42: Sign-in request from Azure'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.42：来自Azure的登录请求
- en: 'A successful sign-in redirects you to a configured redirect URI with the following message:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的登录将重定向您到配置的重定向URI，并显示以下消息：
- en: '[PRE156]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'You will see that the token will be returned in the console window:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到令牌将在控制台窗口中返回：
- en: '![Figure 9.43: Generated token from the app registration in the console app'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.43：来自控制台应用程序中应用程序注册的生成令牌'
- en: '](img/B16835_09_43.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_43.jpg)'
- en: 'Figure 9.43: Generated token from the app registration in the console app'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.43：来自控制台应用程序中应用程序注册的生成令牌
- en: 'Now, you can inspect the token using the [https://jwt.io/](https://jwt.io/)
    website. The following screen is displayed, showing two parts: `Encoded` and `Decoded`.
    The `Decoded` part is divided into the following sections:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用[https://jwt.io/](https://jwt.io/)网站检查令牌。显示以下屏幕，显示两个部分：`Encoded`和`Decoded`。`Decoded`部分分为以下几个部分：
- en: '`HEADER`: This contains a type of token and the algorithm used to encrypt the token.'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEADER`：这包含了令牌的类型和用于加密令牌的算法。'
- en: '`PAYLOAD`: The claims encoded within the token contain information, such as
    who requested the token and what access has been granted:'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PAYLOAD`：令牌中编码的声明包含信息，例如谁请求了令牌以及授予了什么访问权限：'
- en: '![Figure 9.44: Encoded and decoded JWT version on the jwt.io website'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.44：jwt.io网站上编码和解码的JWT版本'
- en: using your app registration
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的应用注册
- en: '](img/B16835_09_44.jpg)'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_44.jpg)'
- en: 'Figure 9.44: Encoded and decoded JWT version on the jwt.io website using your
    app registration'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.44：在jwt.io网站上使用您的应用注册的编码和解码JWT版本
- en: In this section, you learned how to secure an unsecured API. Security is not
    limited to just an authorization token. As a professional developer, you must
    be aware of the most common vulnerabilities in APIs. A list of the top 10 most
    common security issues is updated every four years based on the trends in the
    industry. This list is called the Open Web Application Security Project (OWASP)
    and can be reached at [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何保护一个不安全的API。安全性不仅限于授权令牌。作为专业开发人员，您必须了解API中最常见的漏洞。根据行业趋势，每四年更新一次的前10个最常见的安全问题列表。此列表称为开放网络应用安全项目（OWASP），网址为[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)。
- en: In the next section, you will apply the changes needed for Swagger to work with
    the authorization token.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将应用Swagger与授权令牌一起工作所需的更改。
- en: Configuring Swagger Auth
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Swagger Auth
- en: 'To pass an authorization header through Swagger, you will need to add some
    configuration. Follow these steps to do so:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Swagger传递授权标头，您需要添加一些配置。按照以下步骤进行操作：
- en: 'In order to render an authorization button, add the following block of code
    inside the `SwaggerSetup` class, the `AddSwagger` method, and the `services.AddSwaggerGen(cfg
    =>` section:'
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了呈现授权按钮，请在`SwaggerSetup`类、`AddSwagger`方法和`services.AddSwaggerGen(cfg =>`部分内添加以下代码块：
- en: '[PRE157]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In order to forward the value of a bearer token with an authorization header,
    add the following code snippet:'
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过授权标头转发令牌的值，请添加以下代码片段：
- en: '[PRE158]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'When you navigate to [https://localhost:7021/index.html](https://localhost:7021/index.html),
    you will see that it now contains the `Authorize` button:'
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您导航到[https://localhost:7021/index.html](https://localhost:7021/index.html)时，您会看到它现在包含`授权`按钮：
- en: '![Figure 9.45: Swagger docs with Authorize button'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.45：Swagger文档带有授权按钮'
- en: '](img/B16835_09_45.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_45.jpg)'
- en: 'Figure 9.45: Swagger docs with Authorize button'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.45：Swagger文档带有授权按钮
- en: 'Click the `Authorize` button to allow you to input the bearer token:'
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`授权`按钮以允许您输入令牌：
- en: '![Figure 9.46: Bearer token input after clicking the Authorize button'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.46：单击授权按钮后的令牌输入'
- en: '](img/B16835_09_46.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_46.jpg)'
- en: 'Figure 9.46: Bearer token input after clicking the Authorize button'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.46：单击授权按钮后的令牌输入
- en: 'Now, send a request:'
  id: totrans-824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，发送一个请求：
- en: '![Figure 9.47: Swagger-generated request with a status of 200 generated in
    response'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.47：Swagger生成的响应中生成的状态为200的请求'
- en: '](img/B16835_09_47.jpg)'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_47.jpg)'
- en: 'Figure 9.47: Swagger-generated request with a status of 200 generated in response'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.47：Swagger生成的响应中生成的状态为200的请求
- en: You will see that the authorization header is added, and the `ok` response (HTTP
    status code `200`) is returned.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到授权标头已添加，并返回`ok`响应（HTTP状态码`200`）。
- en: In this section, you added some configuration to pass an authorization header
    through Swagger.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您添加了一些配置以通过Swagger传递授权标头。
- en: Note
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/hMc2t](https://packt.link/hMc2t).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/hMc2t](https://packt.link/hMc2t)找到此示例使用的代码。
- en: If you make a mistake and your token validation fails, you will get either a
    `401 – unauthorized` or `403 – forbidden` status code returned (often without
    any details). Fixing this error might be a headache. However, it is not too difficult
    to get more information on what went wrong. The next section provides more details.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您犯了一个错误，您的令牌验证失败，您将收到一个`401-未经授权`或`403-禁止`状态代码返回（通常没有任何详细信息）。修复此错误可能会让人头痛。但是，获取有关出了什么问题的更多信息并不太困难。下一节提供了更多细节。
- en: Troubleshooting Token Validation Errors
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除令牌验证错误
- en: To simulate this scenario, try invalidating the client-id in `appsettings.json`
    by changing any single symbol (for example, the last letter to `b`). Run the request
    and see how the response is displayed as `401`, with nothing else appearing in
    the logs.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种情况，请尝试通过更改`appsettings.json`中的客户端ID的任何单个符号（例如，将最后一个字母更改为`b`）来使其无效。运行请求，看看响应显示为`401`，日志中没有其他内容。
- en: 'All the validations and incoming and outcoming requests can be tracked through
    a pipeline. All you must do is change the default minimum logged level from `info`
    to `Trace`. You can do this by replacing the `appsettings.development.json` file
    contents with the following:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 所有验证和传入和传出的请求都可以通过管道进行跟踪。您所需做的就是将默认的最低记录级别从`info`更改为`Trace`。您可以通过用以下内容替换`appsettings.development.json`文件内容来实现这一点：
- en: '[PRE159]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Do not mix `appsettings.development.json` with `appsettings.json`. The former
    is used for configuration as a whole and the latter overrides the configuration
    but only in certain environments—development (local) in this case.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆`appsettings.development.json`和`appsettings.json`。前者用于整体配置，后者仅在某些环境（本地开发）中覆盖配置。
- en: 'If you run the same request again, you will now see a verbose log in the console:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行相同的请求，您现在将在控制台中看到详细的日志：
- en: '[PRE160]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Inspecting it deeper reveals the error as the following:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 深入检查后，发现错误如下：
- en: '`Audience validation failed; Audiences: ''api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb''.
    Did not match validationParameters`'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`受众验证失败；受众：''api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb''。未匹配验证参数`'
- en: 'This error indicates a mismatched audience configured in the JWT:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指示JWT中配置的受众不匹配：
- en: '![Figure 9.48: Token validation error with the error highlighted'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.48：令牌验证错误，错误已突出显示'
- en: '](img/B16835_09_48.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_48.jpg)'
- en: 'Figure 9.48: Token validation error with the error highlighted'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48：令牌验证错误，错误已突出显示
- en: Now it is time for you to learn about the SOA architecture where components
    of a system are hosted as separate services.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习SOA架构了，其中系统的组件作为单独的服务托管。
- en: Service-Oriented Architecture
  id: totrans-847
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: 'Software architecture has come a long way—evolving from monolithic to Service-Oriented
    Architecture (SOA). SOA is an architecture where major layers of applications
    are hosted as separate services. For example, there would be one or more Web APIs
    for data access, one or more Web APIs for business logic, and one or more client
    applications consuming it all. The flow would be like this: the client app calls
    the business Web API, which calls another business Web API or a data access Web
    API.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构已经走过了很长的路——从单片到面向服务的架构（SOA）。SOA是一种架构，应用程序的主要层被托管为独立的服务。例如，可能会有一个或多个用于数据访问的Web
    API，一个或多个用于业务逻辑的Web API，以及一个或多个客户端应用程序来消费它们。流程将是这样的：客户端应用程序调用业务Web API，该业务Web
    API调用另一个业务Web API或数据访问Web API。
- en: However, modern software architecture goes one step further to bring a more
    evolved architecture, called microservice architecture.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代软件架构更进一步，引入了一种更进化的架构，称为微服务架构。
- en: Microservice Architecture
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservice architecture is SOA with a single-responsibility principle applied.
    This means that, instead of service-as-a-layer, you now have hosted self-contained
    modules that have a single responsibility. A self-contained service has both data
    access and business logic layers. Instead of many services per layer, in this
    approach, you have many services per module.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是应用了单一责任原则的SOA。这意味着，现在你有托管的自包含模块，每个模块都有一个单一的责任，而不是作为一个层的服务。自包含服务既有数据访问层，也有业务逻辑层。在这种方法中，你不是每层有多个服务，而是每个模块有多个服务。
- en: The purpose of those self-contained modules is to allow multiple teams to work
    on different parts of the same system simultaneously without ever stepping on
    each other's toes. On top of that, parts in a system can be scaled and hosted
    independently and there is no single point of failure. Also, each team is free
    to use whatever technology stack they are most familiar with, as all the communication
    happens through HTTP calls.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自包含模块的目的是允许多个团队同时在同一系统的不同部分上工作，而不会互相干扰。此外，系统中的部分可以独立扩展和托管，并且没有单一故障点。此外，每个团队都可以自由使用他们最熟悉的技术栈，因为所有通信都是通过HTTP调用进行的。
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put all that you have learned into practice with an activity.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了这个主题的理论部分。在接下来的部分中，您将把所学到的知识付诸实践。
- en: 'Activity 9.01: Implementing the File Upload Service Using Microservice Architecture'
  id: totrans-854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：使用微服务架构实现文件上传服务
- en: A microservice should be self-contained and do just one thing. In this activity,
    you will sum up the steps needed for extracting a piece of code into a microservice
    that manages how you work with files through the web (delete, upload, and download).
    This should serve as an overall effective checklist of what needs to be done when
    creating a new microservice.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是自包含的，只做一件事。在这个活动中，您将总结提取代码到一个微服务中所需的步骤，该微服务通过网络管理文件的工作（删除、上传和下载）。这应该作为创建新微服务时需要完成的有效清单。
- en: 'Perform the following steps to do this:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new project. In this case, it will be a `.NET Core Web API` project
    on the .NET 6.0 framework.
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目。在这种情况下，它将是.NET 6.0框架上的`.NET Core Web API`项目。
- en: Name it `Chapter09.Activity.9.01`.
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Chapter09.Activity.9.01`。
- en: 'Now, add the commonly used NuGet packages:'
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加常用的NuGet包：
- en: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
- en: '`FluentValidation.AspNetCore`'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FluentValidation.AspNetCore`'
- en: '`Hellang.Middleware.ProblemDetails`'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hellang.Middleware.ProblemDetails`'
- en: '`Microsoft.AspNetCore.Mvc.NewtonsoftJson`'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.NewtonsoftJson`'
- en: '`Microsoft.Identity.Web`'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Identity.Web`'
- en: '`Swashbuckle.AspNetCore`'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swashbuckle.AspNetCore`'
- en: Next, include the Azure Blobs Client package as `Azure.Storage.Blobs`.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将Azure Blobs Client包含为`Azure.Storage.Blobs`。
- en: Create one or more controllers for communication with the Web API. In this case,
    you will move `FileController` to the `Controllers` folder.
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为与Web API通信创建一个或多个控制器。在这种情况下，您将`FileController`移动到`Controllers`文件夹。
- en: In order to create one or more services for business logic, move `FilesService`
    to the `Services` folder and `FileServiceSetup` to the `Bootstrap` folder.
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了为业务逻辑创建一个或多个服务，将`FilesService`移动到`Services`文件夹，将`FileServiceSetup`移动到`Bootstrap`文件夹。
- en: Then document API using XML docs and Swagger.
  id: totrans-869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用XML文档和Swagger文档API。
- en: Update the `csproj` file to include XML docs.
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`csproj`文件以包括XML文档。
- en: Copy `SwaggerSetup` to the `Bootstrap` folder.
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SwaggerSetup`复制到`Bootstrap`文件夹。
- en: Configure `Controllers`. In this scenario, it will be a plain one-line `services.AddControllers()`
    under the `ControllersConfigurationSetup` class and the `AddControllersConfiguration`
    method.
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`Controllers`。在这种情况下，它将是`ControllersConfigurationSetup`类下的一个简单的一行`services.AddControllers()`，以及`AddControllersConfiguration`方法。
- en: Configure the problem details error mappings. In this case, there are no exceptions
    that you will explicitly handle. So, you will keep it as a one-liner within the
    `ExceptionMappingSetup` class and the `AddExceptionMappings` and `services.AddProblemDetails()`
    methods.
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置问题详细错误映射。在这种情况下，没有异常需要显式处理。因此，您将在`ExceptionMappingSetup`类和`AddExceptionMappings`以及`services.AddProblemDetails()`方法中将其保留为一行。
- en: Secure the API.
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护API。
- en: Create AAD app registration for the new service. Refer to the *Application Registration*
    subsection in the *Securing the Web API* section.
  id: totrans-875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新服务创建AAD应用程序注册。参考*Securing the Web API*部分中的*Application Registration*子部分。
- en: Update the configuration of the new service based on the Azure AD app registration
    client, `tenant`, and `app` IDs.
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Azure AD应用程序注册客户端、`tenant`和`app` ID更新新服务的配置。
- en: Inject the needed services and configure the API pipeline.
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入所需的服务并配置API管道。
- en: Copy the `Program` class.
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`Program`类。
- en: Since the `ConfigureServices` method contains extra services, you don't need
    to remove them. Leave the `Configure` method as is.
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`ConfigureServices`方法包含额外的服务，您不需要删除它们。保持`Configure`方法不变。
- en: Run the service through Swagger and upload a test file. Don't forget to generate
    a bearer token first using the token generator app from the updated values learned
    earlier.
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Swagger运行服务并上传一个测试文件。不要忘记首先使用之前学到的更新值从令牌生成器应用程序生成一个令牌。
- en: 'After that, try to get a test file that you just uploaded. You should see the
    status code `200`:'
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，尝试获取刚上传的测试文件。您应该看到状态码`200`：
- en: 'Get download link request:'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接请求：
- en: '![Figure 9.49: Get download link request in Swagger'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.49：在Swagger中获取下载链接请求'
- en: '](img/B16835_09_49.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_49.jpg)'
- en: 'Figure 9.49: Get download link request in Swagger'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.49：在Swagger中获取下载链接请求
- en: 'Get download link response:'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取下载链接响应：
- en: '![Figure 9.50: Get download link response in Swagger'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.50：在Swagger中获取下载链接响应'
- en: '](img/B16835_09_50.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_50.jpg)'
- en: 'Figure 9.50: Get download link response in Swagger'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.50：在Swagger中获取下载链接响应
- en: Note
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: All the services that have been created so far require considerations such as
    hosting, scaling, and availability. In the following section, you will learn about
    serverless and Azure Functions.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有已创建的服务都需要考虑托管、扩展和可用性等因素。在接下来的部分，您将了解无服务器和Azure Functions。
- en: Azure Functions
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions
- en: 'In the preceding section, you learned that microservice architecture is a self-contained
    service with both data access and business logic layers. With this approach, you
    have many services per module. However, working with microservices, especially
    at the start, might seem like a hassle. It might raise doubts such as the following:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您了解到微服务架构是一个具有数据访问和业务逻辑层的独立服务。通过这种方法，每个模块有许多服务。然而，尤其是在开始阶段，使用微服务可能会显得很麻烦。它可能会引发以下疑问：
- en: What does not big enough mean?
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不够大是什么意思？
- en: Should you host on different servers or on the same machine?
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该在不同的服务器上托管还是在同一台机器上托管？
- en: Is another cloud hosting model better?
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个云托管模型更好吗？
- en: These questions might be overwhelming. So, a simple way of calling your code
    through HTTP is by using Azure Functions. Azure Functions is a serverless solution
    that allows you to call your functions on the cloud. Serverless does not mean
    that there is no server; you just do not need to manage it by yourself. In this
    section, you will try to port `CurrentTimeController` from *Exercise 9.02* to
    an Azure Function.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能会让人不知所措。因此，通过HTTP调用代码的简单方法是使用Azure Functions。Azure Functions是一种无服务器解决方案，允许您在云上调用函数。无服务器并不意味着没有服务器；您只是不需要自己管理它。在本节中，您将尝试将*练习9.02*中的`CurrentTimeController`移植到Azure
    Function中。
- en: Note
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before proceeding with the steps, install Azure Functions Core Tools first
    using the instructions here: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools).
    Azure Functions Core Tools also requires the Azure CLI to be installed (if you
    want to publish an Azure Functions application and not on a server). Follow the
    instructions here: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli).'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，首先按照这里的说明安装Azure Functions Core Tools。Azure Functions Core Tools还需要安装Azure
    CLI（如果您想要发布Azure Functions应用程序而不是在服务器上）。请按照这里的说明操作：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli)。
- en: 'Perform the following steps to do so:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In VS Code, click the `Extenstions` icon (`1`).
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中，点击“扩展”图标（`1`）。
- en: Then search for `azure function` in the search text box (`2`).
  id: totrans-903
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在搜索文本框（`2`）中搜索“azure function”。
- en: 'Then, install the `Azure Functions` extension (`3`):'
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，安装`Azure Functions`扩展（`3`）：
- en: '![Figure 9.51: Searching for the Azure Functions extension in VS Code'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.51：在VS Code中搜索Azure Functions扩展'
- en: '](img/B16835_09_51.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_51.jpg)'
- en: 'Figure 9.51: Searching for the Azure Functions extension in VS Code'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.51：在VS Code中搜索Azure Functions扩展
- en: A new Azure tab will appear on the left.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧将出现一个新的Azure选项卡。
- en: Click the new Azure tab.
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新的Azure选项卡。
- en: On the new page, click the `Add` button (`1`).
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新页面上，点击“添加”按钮（`1`）。
- en: 'Select the `Create Function…` option (`2`):'
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建函数…”选项（`2`）：
- en: '![Figure 9.52: The new Azure Functions extension in VS Code'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.52：在VS Code中的新Azure Functions扩展与“创建函数…”按钮'
- en: with the Create Function… button
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 与“创建函数…”按钮
- en: '](img/B16835_09_52.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_52.jpg)'
- en: 'Figure 9.52: The new Azure Functions extension in VS Code with the Create Function…
    button'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.52：在VS Code中的新Azure Functions扩展与“创建函数…”按钮
- en: In the Create Function window, select `HTTP trigger`.
  id: totrans-916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建函数”窗口中，选择“HTTP触发器”。
- en: Enter the name `GetCurrentTime.Get`.
  id: totrans-917
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称`GetCurrentTime.Get`。
- en: Name the project where it is held `Pact.AzFunction`.
  id: totrans-918
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`Pact.AzFunction`。
- en: On the last screen, select `anonymous`.
  id: totrans-919
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个屏幕上，选择“匿名”。
- en: At this point, there is no need to go into too much detail about this configuration.
    The key point to be considered here is that the function will be reachable publicly,
    through HTTP requests. A new project created through these steps will include
    the new Azure Function.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，没有必要过多地讨论这个配置。这里需要考虑的关键点是，该函数将通过HTTP请求公开访问。通过这些步骤创建的新项目将包括新的Azure Function。
- en: Now, navigate to the root of the new project folder to run the project.
  id: totrans-921
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到新项目文件夹的根目录运行项目。
- en: 'Next, press `F5` or click the `Start debugging to update this list…` message:'
  id: totrans-922
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按下`F5`或点击“开始调试以更新此列表…”消息：
- en: '![Figure 9.53: Azure Extension window with the to-be-built project'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.53：Azure扩展窗口与待构建项目'
- en: '](img/B16835_09_53.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_53.jpg)'
- en: 'Figure 9.53: Azure Extension window with the to-be-built project'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.53：待构建项目的Azure扩展窗口
- en: 'You will notice that upon a successful build, the message changes to the function name:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在成功构建后，消息会更改为函数名称：
- en: '![Figure 9.54: Azure Extension window with post-build project'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.54：构建后项目的Azure扩展窗口'
- en: '](img/B16835_09_54.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_54.jpg)'
- en: 'Figure 9.54: Azure Extension window with post-build project'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.54：构建后项目的Azure扩展窗口
- en: 'The terminal output window, displayed at the bottom of VS Code, shows the following
    details:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code底部显示的终端输出窗口中，显示了以下细节：
- en: '![Figure 9.55: The terminal output after a successful build'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.55：成功构建后的终端输出'
- en: '](img/B16835_09_55.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_09_55.jpg)'
- en: 'Figure 9.55: The terminal output after a successful build'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.55：成功构建后的终端输出
- en: 'Next, in VS Code Explorer, open `GetCurrentTime.cs`:'
  id: totrans-934
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在VS Code资源管理器中打开`GetCurrentTime.cs`：
- en: 'Note that in *Exercise 9.01*, you worked with the `GetCurrentTime` code. You will
    reuse the same code here:'
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在*练习9.01*中，您使用了`GetCurrentTime`代码。您将在这里重用相同的代码：
- en: '[PRE161]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The template names are generated based on your configuration from before. An
    Azure Function is bound to an HTTP endpoint through the `[Function("GetCurrentTime")]`
    attribute.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 模板名称是根据之前的配置生成的。Azure Function通过`[Function("GetCurrentTime")]`属性绑定到HTTP端点。
- en: Before you proceed, you might have noticed that, even though the function for
    getting the current time consumed a variable for `timezoneid`, there is no such
    variable here (yet). Unlike the previous REST APIs you created to pass parameters
    to an Azure Function, here you pass it through either a request body or query
    variables. The only problem here is that you will have to parse it yourself, as
    there are no bindings through attributes just like with the controller methods.
    The argument you need is just a simple string that can be passed as a query argument.
    This line parses the URI from the request and gets a `timezoneId` variable from
    the query string.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能已经注意到，即使用于获取当前时间的函数使用了`timezoneid`变量，但这里（还）没有这样的变量。与之前创建用于将参数传递给Azure
    Function的REST API不同，在这里，您通过请求正文或查询变量传递它。唯一的问题是您将不得不自己解析它，因为没有像控制器方法那样通过属性进行绑定。您需要的参数只是一个简单的字符串，可以作为查询参数传递。此行从请求中解析URI并从查询字符串中获取`timezoneId`变量。
- en: 'Use the `timezoneId` variable to get the current time in a specific zone:'
  id: totrans-939
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`timezoneId`变量获取特定时区的当前时间：
- en: '[PRE162]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Next up is the business logic. So, use the `timezoneId` variable to get the
    current time in a specified time zone:'
  id: totrans-941
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是业务逻辑。因此，使用`timezoneId`变量获取指定时区的当前时间：
- en: '[PRE163]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Finally, serialize the results in `HTTP 200 Ok` as the `text/plain` content type:'
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将结果序列化为`HTTP 200 Ok`，内容类型为`text/plain`：
- en: '[PRE164]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Run this code and navigate to `http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time`.
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码，并导航至`http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time`。
- en: 'You will get the current time of that time zone, as follows:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得该时区的当前时间，如下所示：
- en: '[PRE165]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: You have now grasped the workings of Azure Functions—a serverless solution to
    call your functions on the cloud.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经掌握了Azure Functions的工作原理——在云上调用函数的无服务器解决方案。
- en: It has been a long path through this book, but with the conclusion of this final
    activity, you have mastered all the concepts and skills required to create your
    own modern C# applications.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书的长篇历程，随着最终活动的结束，您已经掌握了创建自己的现代C#应用程序所需的所有概念和技能。
- en: Summary
  id: totrans-950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to build your own REST Web API using the ASP.NET
    Core Web API template. You learned how to tackle the ever-growing complexity of
    configuration using bootstrap classes. You were introduced to the OpenAPI standard
    and Swagger, a tool used for calling an API to see whether it has successfully
    rendered the documentation. You also delved into mapping exceptions to specific
    HTTP status codes, along with how to map DTOs to domain objects and vice versa.
    In the second half of the chapter, you practiced securing the Web API using AAD,
    learned the concept of microservices, and created one yourself—both through a
    new dedicated Web API and through an Azure Function.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用ASP.NET Core Web API模板构建自己的REST Web API。您学会了如何使用引导类来解决配置日益复杂的问题。您还了解了OpenAPI标准和Swagger，这是一个用于调用API以查看其是否成功呈现文档的工具。您还深入研究了将异常映射到特定HTTP状态代码的方法，以及如何将DTO映射到域对象，反之亦然。在本章的下半部分，您练习了使用AAD保护Web
    API，学习了微服务的概念，并通过新的专用Web API和Azure Function创建了一个微服务。
- en: Knowing how to create and consume Web APIs is important because that's what
    most of the software development is all about. You either consume or create Web
    APIs at some point. Even if you don't have to create one yourself, grasping the
    ins and outs of it will help you as a professional developer.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建和使用Web API很重要，因为这是大多数软件开发的关键。您在某个时候要么使用要么创建Web API。即使您不必自己创建一个，了解其内部工作将有助于您作为专业开发人员。
- en: This brings a close to *The C# Workshop*. Throughout this book, you have learned
    the basics of programming in C#, starting with simple programs that used arithmetic
    and logical operators, followed by the increasingly complex concepts of clean
    coding, delegates and lambdas, multithreading, client and server Web APIs, and
    Razor Pages applications.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了*The C# Workshop*。在本书中，您学会了使用C#进行编程的基础知识，从使用算术和逻辑运算符的简单程序开始，然后是越来越复杂的概念，如清晰的编码、委托和Lambda、多线程、客户端和服务器Web
    API以及Razor Pages应用程序。
- en: 'This concludes the print copy of this book, but it is not the end of your journey.
    Visit the GitHub repository at [https://packt.link/sezEm](https://packt.link/sezEm)
    for bonus chapters—*Chapter 10*, *Automated Testing*, and *Chapter 11*, *Production-Ready
    C#: From Development to Deployment*—covering such topics as different forms of
    testing before you take an in-depth look at unit testing using Nunit (the most
    popular third-party testing library for C#), getting acquainted with Git and using
    GitHub to keep a remote backup of your code, enabling Continuous Deployment (CD)
    and deployment from your code to the cloud, studying the cloud using Microsoft
    Azure, in addition to learning how to use GitHub Actions to perform CI and CD
    to push application changes live in production.'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本书的印刷版，但这并不是您旅程的终点。访问GitHub存储库[https://packt.link/sezEm](https://packt.link/sezEm)获取额外章节——*第10章*，*自动化测试*，和*第11章*，*生产就绪的C#：从开发到部署*——涵盖了在深入研究使用Nunit进行单元测试之前进行不同形式的测试，Nunit是C#最流行的第三方测试库，熟悉Git并使用GitHub保留代码的远程备份，启用持续部署（CD）并从代码部署到云端，学习使用Microsoft
    Azure的云，以及学习如何使用GitHub Actions执行CI和CD以将应用程序更改推送到生产环境。
- en: '![Rayon](img/Jason_Hales.png)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
  zh: '![雷氧](img/Jason_Hales.png)'
- en: '**Jason Hales**'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jason Hales**'
- en: '![Rayon](img/Almantas_Karpavicius.png)'
  id: totrans-957
  prefs: []
  type: TYPE_IMG
  zh: '![雷氧](img/Almantas_Karpavicius.png)'
- en: '**Almantas Karpavicius**'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '**Almantas Karpavicius**'
- en: '![Rayon](img/Mateus_Viegas.png)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![雷氧](img/Mateus_Viegas.png)'
- en: '**Mateus Viegas**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mateus Viegas**'
- en: Hey!
  id: totrans-961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嘿！
- en: We are Jason Hales, Almantas Karpavicius, and Mateus Viegas the authors of this
    book. We really hope you enjoyed reading our book and found it useful for learning
    C#.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是Jason Hales，Almantas Karpavicius和Mateus Viegas，是本书的作者。我们真诚地希望您喜欢阅读我们的书，并发现它对学习C#很有帮助。
- en: It would really help us (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on *The C# Workshop*.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在亚马逊上留下评论，分享您对*The C# Workshop*的想法，这将对我们（以及其他潜在读者！）非常有帮助。
- en: Go to the link [https://packt.link/r/1800566492](https://packt.link/r/1800566492).
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 访问链接[https://packt.link/r/1800566492](https://packt.link/r/1800566492)。
- en: OR
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: Scan the QR code to leave your review.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描QR码留下您的评论。
- en: '![Barcode](img/qrcode.jpg)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![条形码](img/qrcode.jpg)'
- en: Your review will help us to understand what's worked well in this book and what
    could be improved upon for future editions, so it really is appreciated.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论将帮助我们了解本书的优点和未来版本可以改进的地方，因此我们真的很感激。
- en: Best wishes,
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 祝一切顺利，
- en: Jason Hales, Almantas Karpavicius, and Mateus Viegas
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: Jason Hales，Almantas Karpavicius和Mateus Viegas
- en: '![Packt Logo](img/Packt_Logo-1.png)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![Packt标志](img/Packt_Logo-1.png)'
