- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Handling Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to write more robust and extensible
    code. We will begin this endeavor by exploring exception handling in C++. Adding
    language-prescribed methods in our code to handle errors will allow us to achieve
    less buggy and more reliable programs. By using the formal exception handling
    mechanisms *built into the language*, we can achieve a uniform handling of errors,
    which leads to more easily maintainable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们的探索之旅，旨在扩展你的C++编程知识库，使其超越面向对象的概念，目标是使你能够编写更健壮和可扩展的代码。我们将从探索C++中的异常处理开始这一努力。在我们的代码中添加语言规定的错误处理方法将使我们能够编写更少错误和更可靠的程序。通过使用语言内建的正式异常处理机制，我们可以实现错误的统一处理，这导致代码更容易维护。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding exception handling basics – `try`, `throw`, and `catch`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异常处理基础知识 – `try`，`throw`和`catch`
- en: Exploring exception handling mechanics – trying code that may raise exceptions,
    raising (throwing), catching, and handling exceptions using several variations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异常处理机制 – 尝试可能引发异常的代码，抛出（抛出），捕获，并使用多种变体处理异常
- en: Utilizing exception hierarchies with standard exception objects or by creating
    customized exception classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用标准异常对象或创建自定义异常类来利用异常层次结构
- en: By the end of this chapter, you will understand how to utilize exception handling
    in C++. You will see how to identify an error to raise an exception, transfer
    control of the program to a designated area by throwing an exception, and then
    handle the error by catching the exception and hopefully repairing the problem
    at hand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在C++中利用异常处理。你将看到如何识别错误以引发异常，通过抛出异常将程序控制权转移到指定区域，然后通过捕获异常来处理错误，并希望修复当前的问题。
- en: You will also learn how to utilize standard exceptions from the C++ Standard
    Library, as well as create customized exception objects. A hierarchy of exception
    classes can be designed to add robust error detection and handling capabilities.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何利用C++标准库中的标准异常，以及创建自定义异常对象。可以设计一个异常类层次结构，以添加强大的错误检测和处理能力。
- en: Let’s increase our understanding of C++ by expanding our programming repertoire
    by exploring the built-in language mechanisms of exception handling.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索C++内建的异常处理机制来扩展我们对C++的理解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter11`
    in a file named `Chp11-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11)。每个完整的程序示例都可以在GitHub的相应章节标题（子目录）下找到，对应章节的文件名，后面跟着一个连字符，然后是当前章节的示例编号。例如，本章节的第一个完整程序可以在上述GitHub目录下的`Chapter11`子目录中找到，文件名为`Chp11-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3QZi638](https://bit.ly/3QZi638).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的CiA视频可以在以下链接查看：[https://bit.ly/3QZi638](https://bit.ly/3QZi638)。
- en: Understanding exception handling
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异常处理
- en: Error conditions may occur within an application that would prevent a program
    from continuing correctly. Such error conditions may include data values that
    exceed application limits, necessary input files or databases have become unavailable,
    heap memory has become exhausted, or any other imaginable issue. C++ exceptions
    provide a uniform, language-supported manner for handling program anomalies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中可能会发生错误条件，这会阻止程序正确继续。这些错误条件可能包括超出应用程序限制的数据值，必要的输入文件或数据库变得不可用，堆内存耗尽，或任何其他可想象的问题。C++异常提供了一种统一、语言支持的程序异常处理方式。
- en: Prior to the introduction of language supported exception handling mechanisms,
    each programmer would handle errors in their own manner, and sometimes not at
    all. Program errors and exceptions that are not handled imply that somewhere further
    in the application, an unexpected result will occur and the application will most
    often terminate abnormally. These potential outcomes are certainly undesirable!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入语言支持的异常处理机制之前，每个程序员都会以自己的方式处理错误，有时甚至不处理。未处理的程序错误和异常意味着在应用程序的某个地方，将发生意外的结果，并且应用程序通常会异常终止。这些潜在的结果当然是不希望的！
- en: C++ **exception handling** provides a language supported mechanism to detect
    and correct program anomalies so that an application can remain running, rather
    than ending abruptly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++的**异常处理**提供了一种语言支持的机制来检测和纠正程序异常，以便应用程序可以继续运行，而不是突然终止。
- en: Let’s take a look at the mechanics, starting with the language supported keywords
    `try`, `throw`, and `catch`, which comprise exception handling in C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看机制，从语言支持的`try`、`throw`和`catch`关键字开始，这些构成了C++中的异常处理。 '
- en: Utilizing exception handling with try, throw, and catch
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用try、throw和catch进行异常处理
- en: '**Exception handling** detects a program anomaly, as defined by the programmer
    or by a class library, and passes control to another portion of the application
    where the specific problem may be handled. Only as a last resort will it be necessary
    to exit an application.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常处理**检测程序异常，由程序员或类库定义，并将控制权传递到应用程序的另一部分，在那里可以处理特定的问题。只有在最后不得已的情况下，才需要退出应用程序。'
- en: 'Let’s begin by taking a look at the keywords that support exception handling.
    The keywords are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看支持异常处理的关键字开始。关键字如下：
- en: '`try`: Allows programmers to *try* a portion of code that might cause an exception.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`：允许程序员尝试可能引发异常的代码部分。'
- en: '`throw`: Once an error is found, `throw` raises the exception. This will cause
    a jump to the catch block below the associated try block; `throw` will allow an
    argument to be returned to the associated catch block. The argument thrown may
    be of any standard or user defined type.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`：一旦发现错误，`throw`会引发异常。这将导致跳转到关联的try块下面的catch块；`throw`将允许将参数返回到关联的catch块。抛出的参数可以是任何标准或用户定义的类型。'
- en: '`catch`: Designates a block of code designed to seek exceptions that have been
    thrown, to attempt to correct the situation. Each catch block in the same scope
    will handle an exception of a different type.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`：指定一个代码块，用于寻找已抛出的异常，并尝试纠正情况。同一作用域中的每个catch块将处理不同类型的异常。'
- en: When utilizing exception handling, it is useful to review the idea of backtracking.
    When a sequence of functions is called, we build up, on the stack, state information
    applicable to each successive function call (parameters, local variables, and
    return value space), as well as the return address for each function. When an
    exception is thrown, we may need to unwind the stack to the point of origination
    where this sequence of function calls (or try blocks) began, resetting the stack
    pointer as well. This process is known as **backtracking** and allows a program
    to return to an earlier sequence in the code. Backtracking applies not only to
    function calls but to nested blocks including nested try blocks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异常处理时，回顾回溯的概念是有用的。当一系列函数被调用时，我们会在栈上建立适用于每个后续函数调用的状态信息（参数、局部变量和返回值空间），以及每个函数的返回地址。当抛出异常时，我们可能需要将栈回溯到函数调用序列（或try块）开始的点，同时重置栈指针。这个过程被称为**回溯**，允许程序返回到代码中的早期序列。回溯不仅适用于函数调用，还适用于嵌套块，包括嵌套的try块。
- en: 'Here is a simple example to illustrate basic exception handling syntax and
    usage. Though portions of the code are not shown to save space, the complete example
    can be found in our GitHub as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，用于说明基本的异常处理语法和用法。尽管为了节省空间没有显示代码的部分，但完整的例子可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code fragment, we can see the keywords `try`, `throw`, and `catch`
    in action. First, let’s notice the `Student::Validate()` member function. Imagine,
    in this virtual method, we verify that a `Student` meets admission standards.
    If so, the function ends normally. If not, an exception is thrown. In this example,
    a simple `string` is thrown encapsulating the message `"Does not meet prerequisites"`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到 `try`、`throw` 和 `catch` 关键字在起作用。首先，让我们注意到 `Student::Validate()`
    成员函数。想象一下，在这个虚函数中，我们验证一个 `Student` 是否符合入学标准。如果是这样，函数将正常结束。如果不是，将抛出一个异常。在这个例子中，抛出了一个简单的
    `string`，封装了消息 `"Does not meet prerequisites"`。
- en: In our `main()` function, we first instantiate a `Student`, namely `s1`. Then,
    we nest our call to `s1.Validate()` within a try block. We are literally saying
    that we’d like to *try* this block of code. Should `Student::Validate()` work
    as expected, error-free, our program completes the try block, skips the catch
    block(s) below the try block, and merely continues with the code below any catch
    blocks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们首先实例化一个 `Student`，即 `s1`。然后，我们将对 `s1.Validate()` 的调用嵌套在一个
    try 块中。我们实际上是在说我们想要 *尝试* 这段代码。如果 `Student::Validate()` 如预期那样工作，没有错误，我们的程序将完成 try
    块，跳过 try 块下面的捕获块，并继续执行任何捕获块下面的代码。
- en: However, should `Student::Validate()` throw an exception, we will skip any remaining
    code in our try block and seek an exception matching the type of `const string
    &` in a subsequently defined catch block. Here, in the matching catch block, our
    goal is to correct the error if at all possible. If we are successful, our program
    will continue with the code below the catcher. If not, our job is to end the program
    gracefully.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `Student::Validate()` 抛出异常，我们将跳过 try 块中剩余的任何代码，并寻找一个随后定义的匹配的捕获块中与 `const
    string &` 类型匹配的异常。在这里，在匹配的捕获块中，我们的目标是尽可能纠正错误。如果我们成功，我们的程序将继续执行捕获器下面的代码。如果我们不成功，我们的任务是优雅地结束程序。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let us summarize the overall flow of exception handling with the following
    logistics:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用以下逻辑总结异常处理的总体流程：
- en: When a program completes a try block without encountering any thrown exceptions,
    the code sequence continues with the statement following the catch block. Multiple
    catch blocks (with different argument types) may follow a try block.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序完成 try 块而没有遇到任何抛出的异常时，代码序列将继续执行 catch 块后面的语句。多个具有不同参数类型的 catch 块可以跟在 try
    块后面。
- en: When an exception is thrown, the program must backtrack and return to the try
    block containing the originating function call. The program may have to backtrack
    past multiple functions. When backtracking occurs, the objects encountered on
    the stack will be popped off, and hence destructed.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当抛出异常时，程序必须回溯并返回到包含原始函数调用的 try 块。程序可能需要回溯多个函数。当回溯发生时，堆栈上遇到的对象将被弹出，因此将被销毁。
- en: Once a program (with an exception raised) backtracks to the function where the
    try block was executed, the program will continue with the catch block (following
    the try block) whose signature matches the type of the exception that was thrown.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦程序（抛出异常）回溯到执行 try 块的函数，程序将继续执行与抛出的异常类型匹配的签名匹配的 catch 块（跟随 try 块）。
- en: Type conversion (with the exception of upcasting objects related through public
    inheritance) will not be done to match potential catch blocks. However, a catch
    block with ellipses (`…`) may be used as the most general type of catch block
    and can catch any type of exception.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换（除了通过公共继承相关联的对象的上转型）不会执行以匹配潜在的捕获块。然而，可以捕获任何类型的异常的省略号（`…`）捕获块可以用作最通用的捕获块。
- en: If a matching catch block does not exist, the program will call `terminate()`
    from the C++ Standard Library. Note that `terminate()` will call `abort()`; however,
    the programmer may instead register another function for `terminate()` to call
    via the `set_terminate()` function.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在匹配的捕获块，程序将调用 C++ 标准库中的 `terminate()`。请注意，`terminate()` 将调用 `abort()`；然而，程序员可以通过
    `set_terminate()` 函数注册另一个函数来代替 `terminate()`。
- en: 'Now, let’s see how to register a function with `set_terminate()`. Though we
    only show key portions of the code here, the complete program can be found in
    our GitHub:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `set_terminate()` 注册一个函数。尽管我们在这里只展示了代码的关键部分，但完整的程序可以在我们的 GitHub
    上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code fragment, we define our own `AppSpecificTerminate()` function.
    This is the function we wish to have the `terminate()` function call rather than
    its default behavior of calling `abort()`. Perhaps we use `AppSpecificTerminate()`
    to end our application a bit more gracefully, saving key data structures or database
    values. Of course, we would also then `exit()` (or `abort()`) ourselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们定义了自己的`AppSpecificTerminate()`函数。这是我们希望`terminate()`函数调用的函数，而不是其默认行为调用`abort()`。也许我们会使用`AppSpecificTerminate()`来更优雅地结束我们的应用程序，保存关键数据结构或数据库值。当然，我们也会自己`exit()`（或`abort()`）。
- en: In `main()`, we merely call `set_terminate(AppSpecificTerminate)` to register
    our terminate function with `set_terminate()`. Now, when `abort()` would otherwise
    be called, our function will be called instead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们只是调用`set_terminate(AppSpecificTerminate)`来将我们的终止函数注册到`set_terminate()`。现在，当`abort()`会被调用时，我们的函数将被调用。
- en: It is interesting to note that `set_terminate()` returns a function pointer
    to the previously installed `terminate_handler` (which upon its first call will
    be a pointer to `abort()`). Should we choose to save this value, we can use it
    to reinstate previously registered terminate handlers. Notice that we have not
    opted to save this function pointer in this example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`set_terminate()`返回一个指向之前安装的`terminate_handler`的函数指针（在其第一次调用时将是一个指向`abort()`的指针）。如果我们选择保存这个值，我们可以使用它来恢复之前注册的终止处理器。请注意，我们没有选择在这个例子中保存这个函数指针。
- en: 'Here is what the output would look like for an uncaught exception using the
    aforementioned code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用上述代码未捕获异常的输出示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that functions such as `terminate()`, `abort()`, and `set_terminate()`
    are from the Standard Library. Though we may precede their names with the library
    name using the scope resolution operator, such as `std::terminate()`, this is
    not necessary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`terminate()`、`abort()`和`set_terminate()`等函数来自标准库。尽管我们可以使用作用域解析运算符在它们的名字前加上库名，例如`std::terminate()`，但这不是必要的。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Exception handling is not meant to take the place of simple programmer error
    checking; exception handling has greater overhead. Exception handling should be
    reserved to handle more severe programmatic errors in a uniform manner and in
    a common location.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理并不是要取代简单的程序员错误检查；异常处理有更大的开销。异常处理应该保留用于以统一的方式和在共同的位置处理更严重的程序错误。
- en: Now that we have seen the basic mechanics for exception handling, let’s take
    a look at slightly more complex exception handling examples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了异常处理的基本机制，让我们看看稍微复杂一些的异常处理示例。
- en: Exploring exception handling mechanics with typical variations
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索具有典型变化的异常处理机制
- en: Exception handling can be more sophisticated and flexible than the basic mechanics
    previously illustrated. Let’s take a look at various combinations and variations
    of exception handling basics, as each may be applicable to different programming
    situations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可以比之前展示的基本机制更复杂和灵活。让我们看看异常处理基本原理的各种组合和变化，因为每种可能适用于不同的编程场景。
- en: Passing exceptions to outer handlers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将异常传递给外部处理器
- en: Caught exceptions may be passed up to outer handlers for processing. Alternatively,
    exceptions may be partially handled and then thrown to outer scopes for further
    handling.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的异常可以被传递给外部处理器进行处理。或者，异常可以被部分处理，然后抛出到外部作用域进行进一步处理。
- en: 'Let’s build on our previous example to demonstrate this principle. The full
    program can be seen in the following GitHub directory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于之前的例子来演示这个原则。完整的程序可以在以下GitHub目录中查看：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, let’s assume that we have our usual header files
    included and the usual class definition for `Student` defined. We will now augment
    the `Student` class by adding the `Student::Validate()` method (virtual, so that
    it may be overridden) and the `Student::TakePrerequisites()` method (not virtual,
    descendants should use it as-is).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，让我们假设我们已经包含了我们常用的头文件，并定义了`Student`类的常用类定义。现在我们将通过添加`Student::Validate()`方法（虚拟的，以便它可以被重写）和`Student::TakePrerequisites()`方法（非虚拟的，后代应该直接使用它）来增强`Student`类。
- en: Notice that our `Student::Validate()` method throws an exception, which is merely
    a string literal containing a message indicating the issue at hand. We can imagine
    the complete implementation of the `Student::TakePrerequisites()` method verifies
    that the `Student` has met the appropriate prerequisites, and returns a boolean
    value of `true` or `false` accordingly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的`Student::Validate()`方法抛出了一个异常，它只是一个包含指示当前问题的消息的字符串字面量。我们可以想象`Student::TakePrerequisites()`方法的完整实现验证`Student`是否满足适当的先决条件，并相应地返回`true`或`false`布尔值。
- en: In our `main()` function, we now notice a set of nested try blocks. The purpose
    here is to illustrate an inner try block that may call a method, such as `s1.Validate()`,
    which may raise an exception. Notice that the same level handler as the inner
    try block catches this exception. Ideally, an exception is handled at the level
    equal to the try block from which it originates, so let’s assume that the catcher
    in this scope tries to do so. For example, our innermost catch block presumably
    tries to correct the error and tests whether the correction has been made using
    a call to `s1.TakePrerequisites()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们现在注意到一组嵌套的`try`块。这里的目的是说明一个可能调用方法（例如`s1.Validate()`）的内部`try`块，该方法可能会抛出异常。请注意，与内部`try`块相同级别的处理程序捕获了这个异常。理想情况下，异常应该在与它起源的`try`块相同的级别上得到处理，所以让我们假设在这个作用域中的捕获器试图这样做。例如，我们的最内层捕获块可能试图纠正错误，并通过调用`s1.TakePrerequisites()`来测试是否已进行了纠正。
- en: But perhaps this catcher is only able to process the exception partially. Perhaps
    there is the knowledge that an outer level handler knows how to do the remaining
    corrections. In such cases, it is acceptable to re-throw this exception to an
    outer (nested) level. Our simple `throw;` statement in the innermost catch block
    does just this. Notice that there is a catcher at the outer level. Should the
    thrown exception match, type-wise, this outer level will now have the opportunity
    to further handle the exception and hopefully correct the problem so that the
    application can continue. Only if this outer catch block is unable to correct
    the error should the application be exited. In our example, each catcher prints
    out the string representing the error message; therefore, this message occurs
    twice in the output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许这个捕获器只能部分处理异常。也许存在这样的知识，即外层处理程序知道如何进行剩余的修正。在这种情况下，将这个异常重新抛出到外层（嵌套）级别是可以接受的。我们最内层的捕获块中的简单`throw;`语句正是这样做的。请注意，外层确实有一个捕获器。如果抛出的异常在类型上匹配，那么现在外层级别将有机会进一步处理异常，并希望纠正问题，以便应用程序可以继续运行。只有当外层捕获块无法纠正错误时，应用程序才应该退出。在我们的例子中，每个捕获器都会打印出表示错误信息的字符串；因此，这个消息在输出中出现了两次。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how to use nested try and catch blocks, let us move forward
    to see how a variety of thrown types and a variety of catch blocks can be used
    together.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用嵌套的`try`和`catch`块，让我们继续前进，看看如何将各种抛出类型和多种捕获块结合起来使用。
- en: Adding an assortment of handlers
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一系列处理器
- en: Sometimes, a variety of exceptions may be raised from an inner scope, creating
    the necessity to craft handlers for a variety of data types. Exception handlers
    (that is, catch blocks) can receive an exception of any data type. We can minimize
    the number of catchers we introduce by utilizing catch blocks with base class
    types; we know that derived class objects (related through public inheritance)
    can always be upcast to their base class type. We can also use the ellipses (`…`)
    in a catch block to allow us to catch anything not previously specified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从内部作用域可能会抛出各种异常，这就需要为各种数据类型创建处理器。异常处理器（即捕获块）可以接收任何数据类型的异常。我们可以通过使用基类类型的捕获块来最小化我们引入的捕获器的数量；我们知道派生类对象（通过公共继承相关）总是可以被向上转换为它们的基类类型。我们还可以在捕获块中使用省略号（`…`）来允许我们捕获之前未指定的任何内容。
- en: 'Let’s build on our initial example to illustrate assorted handlers in action.
    Though abbreviated, our full program example can be found in our GitHub as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于最初的示例来构建一个示例，以展示各种处理器的实际应用。虽然程序示例被简化了，但完整的程序示例可以在我们的 GitHub 上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the aforementioned segment of code, we first examine the `Student::Graduate()`
    member function. Here, we can imagine that this method runs through many graduation
    requirements, and as such, can potentially raise a variety of different types
    of exceptions. For example, should the `Student` instance have too low of a `gpa`,
    a float is thrown as the exception, indicating the student’s poor `gpa`. Should
    the `Student` have too few credits, an integer is thrown, indicating how many
    credits the `Student` still needs to earn their degree.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码段中，我们首先检查 `Student::Graduate()` 成员函数。在这里，我们可以想象这个方法会运行许多毕业要求，因此可能会抛出各种不同类型的异常。例如，如果
    `Student` 实例的 `gpa` 太低，会抛出一个浮点数作为异常，表示学生的 `gpa` 很差。如果 `Student` 的学分太少，会抛出一个整数，表示学生还需要获得多少学分才能获得学位。
- en: Perhaps the most interesting potential error that `Student::Graduate()` might
    raise would be if a required `Course` is missing from a student’s graduation requirements.
    In this scenario, `Student::Graduate()` would instantiate a new `Course` object,
    filling it with the `Course` name and number via construction. This anonymous
    object would then be thrown from `Student::Graduate()`, much as an anonymous `string`
    object may be alternatively thrown in this method. The handler may then catch
    the `Course` (or `string`) object by reference.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student::Graduate()` 可能引发的最有趣的潜在错误是，如果学生的毕业要求中缺少一个必需的 `Course`。在这种情况下，`Student::Graduate()`
    会实例化一个新的 `Course` 对象，通过构造函数填充 `Course` 名称和编号。这个匿名对象随后会从 `Student::Graduate()`
    中抛出，就像在这个方法中可以交替抛出的匿名 `string` 对象一样。然后处理器可以通过引用捕获 `Course`（或 `string`）对象。'
- en: In the `main()` function, we merely wrap the call to `Student::Graduate()` within
    a try block, as this statement may raise an exception. A sequence of catchers
    follows the try block – one `catch` statement per type of object that may be thrown.
    The last catch block in this sequence uses ellipses (`…`), indicating that this
    catcher will handle any other type of exception thrown by `Student::Graduate()`
    that has not been caught by the other catchers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们仅仅将 `Student::Graduate()` 的调用封装在一个 try 块中，因为这个语句可能会抛出异常。在 try
    块之后跟随一系列的捕获器 – 每个捕获器对应可能抛出的对象类型。在这个序列中的最后一个捕获块使用了省略号（`…`），表示这个捕获器将处理 `Student::Graduate()`
    抛出的任何其他类型的异常，这些异常没有被其他捕获器捕获。
- en: The catch block that is actually engaged is the one in which a `Course` is caught
    using `const Course &err`. With the `const` qualifier, we may not modify the `Course`
    in the handler, so we may only apply `const` member functions to this object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际参与捕获的捕获块是使用 `const Course &err` 捕获 `Course` 的那个。由于有 `const` 关键字，我们在处理程序中不能修改
    `Course`，因此我们只能对此对象应用 `const` 成员函数。
- en: Note that though each earlier catcher shown merely prints out an error and then
    exits, ideally, a catcher would try to correct the error so that the application
    would not need to terminate, allowing code below the catch blocks to continue
    onward.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管每个早期的捕获器只是打印出错误然后退出，理想情况下，捕获器会尝试纠正错误，这样应用程序就不需要终止，允许 catch 块下面的代码继续执行。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have seen a variety of thrown types and a variety of catch blocks,
    let us move forward to understand what we should group together within a single
    try block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了各种抛出类型和捕获块，让我们继续了解我们应该在单个 try 块中一起组合哪些内容。
- en: Grouping together dependent items within a try block
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 try 块中将相关项分组
- en: It is important to remember that when a line of code in a try block encounters
    an exception, the remainder of the try block is ignored. Instead, the program
    continues with a matching catcher (or calls `terminate()` if no suitable catcher
    exists). Then, if the error is repaired, the code beyond the catcher commences.
    Note that we never return to complete the remainder of the initial try block.
    The implication of this behavior is that you should only group together elements
    within a try block that go together. That is, if one item causes an exception,
    it is no longer important to complete the other item in that grouping.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当`try`块中的一行代码遇到异常时，`try`块剩余的部分将被忽略。相反，程序将继续执行匹配的catcher（如果不存在合适的catcher，则调用`terminate()`）。然后，如果错误被修复，catcher之后的代码开始执行。请注意，我们永远不会返回以完成初始`try`块的剩余部分。这种行为的意义是，你应该只将属于`try`块中的相关元素组合在一起。也就是说，如果一个项引发了异常，那么完成该分组中的其他项就不再重要了。
- en: 'Keep in mind that the goal of a catcher is to correct an error if at all possible.
    This means that the program may continue forward after the applicable catch block.
    You may ask: Is it now acceptable that an item was skipped in the associated try
    block? Should the answer be no, then rewrite your code. For example, you may want
    to add a loop around the `try`-`catch` grouping such that if an error is corrected
    by a catcher, the whole enterprise is retried starting with the initial try block.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，catcher的目标是在可能的情况下纠正错误。这意味着程序可以在适当的catch块之后继续执行。你可能会问：现在跳过关联的`try`块中的某个项是否可以接受？如果答案是否定的，那么请重写你的代码。例如，你可能会想要在`try`-`catch`分组周围添加一个循环，这样如果catcher纠正了错误，整个尝试将从最初的`try`块重新开始。
- en: Alternatively, make smaller, successive `try`-`catch` groupings. That is, *try*
    only one important task in its own try block (followed by applicable catchers).
    Then *try* the next task in its own try block with its associated catchers and
    so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，创建更小的连续`try`-`catch`分组。也就是说，仅在它自己的`try`块中（后面跟着相应的catcher）尝试一个重要的任务。然后，在它自己的`try`块中尝试下一个任务，并带有其关联的catcher，依此类推。
- en: Next, let’s take a look at a way to include in a function’s prototype the type
    of exceptions it may throw.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在函数原型中包含可能抛出的异常类型。
- en: Examining exception specifications in function prototypes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查函数原型中的异常规范
- en: We can optionally specify the types of exceptions a C++ function may throw by
    extending the signature of that function to include the object types of what may
    be thrown. However, because a function may throw more than one type of exception
    (or none at all), checking which type is actually thrown must be done at runtime.
    For this reason, these augmented specifiers in the function prototype are also
    known as `noexcept` specifier, which we’ll see shortly. Uses of dynamic exceptions
    also occur in existing code bases and libraries, so let’s briefly examine its
    usage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展函数的签名来指定C++函数可能抛出的异常类型，包括可能抛出的对象类型。然而，由于一个函数可能抛出多种类型的异常（或者根本不抛出），检查实际抛出的类型必须在运行时完成。因此，这些增强的指定符在函数原型中也被称为`noexcept`指定符，我们将在稍后看到。动态异常的使用也存在于现有的代码库和库中，所以让我们简要地考察其用法。
- en: 'Let’s see an example using exception types in the extended signature of a function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看在函数的扩展签名中使用异常类型：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned code fragment, we see two member functions of `Student`.
    `Student::Graduate()` includes the `throw` keyword after its parameter list and
    then, as part of this method’s extended signature, includes the types of objects
    that may be thrown from this function. Notice that the `Student::Enroll()` method
    merely has an empty list following `throw()` in its extended signature. This means
    that `Student::Enroll()` might throw any type of exception.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们可以看到`Student`类的两个成员函数。`Student::Graduate()`函数在其参数列表之后包含了`throw`关键字，并在其扩展签名中包含了可能从这个函数抛出的对象类型。请注意，`Student::Enroll()`方法在其扩展签名中仅在`throw()`之后有一个空列表。这意味着`Student::Enroll()`可能会抛出任何类型的异常。
- en: In both cases, by adding the `throw()` keyword with optional data types to the
    signature, we are providing a means to announce to the user of this function what
    types of objects might be thrown. We are then asking programmers to include any
    calls to this method within a try block followed by appropriate catchers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，通过在签名中添加带有可选数据类型的`throw()`关键字，我们为用户提供了宣布可能抛出的对象类型的方式。然后我们要求程序员在适当的位置包含对这种方法的方法调用，并在其后添加相应的catcher。
- en: We will see that though the idea of an extended signature seems very helpful,
    it has unfavorable issues in practice. For this reason, dynamic exception specifications
    have been *deprecated*. Because you may still see these specifications used in
    existing code, including Standard Library prototypes (such as with exceptions),
    this deprecated feature is still supported by compilers, and you will need to
    understand their usage.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，尽管扩展签名的想法看起来非常有帮助，但在实践中却存在不利的因素。因此，动态异常规范已被**弃用**。由于你可能会在现有的代码中看到这些规范的使用，包括标准库原型（例如异常处理），因此编译器仍然支持这个弃用的特性，你需要了解它们的用法。
- en: Though dynamic exceptions (extended function signatures as previously described)
    have been deprecated, a specifier with a similar purpose has been added to the
    language, the `noexcept` keyword.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动态异常（如之前所述的扩展函数签名）已被弃用，但为了达到类似的目的，语言中已添加了一个指定符，即`noexcept`关键字。
- en: 'This specifier can be added after the extended signature as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指定符可以按照以下方式添加到扩展签名之后：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nonetheless, let’s investigate why unfavorable issues exist relating to dynamic
    exceptions by looking at what happens when our application throws exceptions that
    are not part of a function’s extended signature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们通过查看当我们的应用程序抛出不属于函数扩展签名的异常时会发生什么来调查与动态异常相关的不利问题。
- en: Dealing with unexpected types of dynamic exceptions
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理意外的动态异常类型
- en: Should an exception be thrown of a type other than that specified in the extended
    function prototype, `unexpected()`, from the C++ Standard Library, will be called.
    You can register your own function with `unexpected()`, much as we registered
    our own function with `set_terminate()` earlier in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出的异常类型与扩展函数原型中指定的类型不同，C++标准库中的`unexpected()`将被调用。你可以使用`unexpected()`注册你自己的函数，就像我们在本章前面注册`set_terminate()`时做的那样。
- en: You can allow your `AppSpecificUnexpected()` function to rethrow an exception
    of the type that the originating function should have thrown; however, if that
    does not occur, `terminate()` will then be called. Furthermore, if no possible
    matching catcher exists to handle what is correctly thrown from the originating
    function (or rethrown by `AppSpecificUnexpected()`), then `terminate()` will be
    called.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让你的`AppSpecificUnexpected()`函数重新抛出原始函数应该抛出的异常类型；然而，如果这种情况没有发生，`terminate()`将被调用。此外，如果不存在可能的匹配catcher来处理从原始函数正确抛出（或由`AppSpecificUnexpected()`重新抛出）的内容，那么`terminate()`将被调用。
- en: 'Let’s see how to use `set_unexpected()` with our own function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`set_unexpected()`与我们的函数结合使用：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Registering our own function with `set_unexpected()` is very simple, as illustrated
    in the aforementioned code fragment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码片段所示，使用`set_unexpected()`将我们自己的函数注册起来非常简单。
- en: Historically, one motivating reason for employing exception specification in
    a function’s extended signature was to provide a documentative effect. That is,
    you could see which exceptions a function might possibly throw simply by examining
    its signature. You could then plan to enclose that function call within a try
    block and provide appropriate catchers to handle any potential situation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，在函数的扩展签名中使用异常规范的一个激励因素是为了提供文档效果。也就是说，你可以通过检查函数的签名来看到函数可能会抛出的异常。然后你可以计划在函数调用周围放置try块，并提供适当的catcher来处理任何潜在的情况。
- en: Nonetheless, regarding dynamic exceptions, it is useful to note that compilers
    do not check that the types of exceptions *actually* thrown in a function body
    match the types specified in the function’s extended signature. It is up to the
    programmer to ensure that they are in sync. Therefore, this deprecated feature
    can be error-prone and, overall, less useful than its original intention.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于动态异常，值得注意的是，编译器不会检查函数体中实际抛出的异常类型是否与函数扩展签名中指定的类型匹配。确保它们同步是程序员的职责。因此，这个弃用的特性可能会引起错误，并且总体上不如其原始意图有用。
- en: Though well intended, dynamic exceptions are currently unused, except in large
    quantities of library code such as the Standard C++ Library. Since you will inevitably
    utilize these libraries, it is important to understand these anachronisms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管初衷良好，但动态异常目前除了在大量的库代码（如标准C++库）中之外，并未被使用。由于你不可避免地会使用这些库，因此了解这些过时的特性很重要。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Dynamic exception specifications (that is, the ability to specify exception
    types in a method’s extended signature) have been *deprecated* in C++. This is
    because compilers are not able to validate their use, which must then be delayed
    until runtime. Their use, though still supported (many libraries have such specifications),
    is now deprecated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 动态异常指定（即在方法扩展签名中指定异常类型的能力）在C++中已被*弃用*。这是因为编译器无法验证其使用，这必须延迟到运行时。尽管它们的使用仍然得到支持（许多库有这样的指定），但现在已被弃用。
- en: Now that we have seen an assortment of exception handling detection, raising,
    catching, and (hopefully) correction schemes, let’s take a look at how we might
    create a hierarchy of exception classes to add sophistication to our error handling
    abilities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了各种异常处理检测、抛出、捕获以及（希望）纠正方案，让我们来看看如何创建一个异常类层次结构，以增强我们的错误处理能力。
- en: Utilizing exception hierarchies
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用异常层次结构
- en: Creating a class to encapsulate the details relating to a program error seems
    like a useful endeavor. In fact, the C++ Standard Library has created one such
    generic class, `exception`, to provide the basis for building an entire hierarchy
    of useful exception classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个封装与程序错误相关的详细信息的类似乎是一项有用的任务。实际上，C++标准库已经创建了一个这样的通用类，即`exception`，为构建整个有用的异常类层次结构提供基础。
- en: Let’s take a look at the `exception` class with its Standard Library descendants,
    and then how we may extend `exception` with our own classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`exception`类及其标准库派生类，然后探讨如何通过我们自己的类扩展`exception`。
- en: Using standard exception objects
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准异常对象
- en: 'The `<exception>` header. The `exception` class includes virtual functions
    with the following signatures: `virtual const char *what() const noexcept` and
    `virtual const char *what() const throw()`. These signatures indicate that derived
    classes should redefine `what()` to return a `const char *` with a description
    of the error at hand. The `const` keyword after `what()` indicates that these
    are `const` member functions; they will not change any members of the derived
    class. The `noexcept` usage in the first prototype indicates that `what()` is
    non-throwing. The `throw()` in the extended signature of the second prototype
    indicates that this function may throw any type. The usage of `throw()` in the
    second signature is a deprecated anachronism and should not be used in new code.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<exception>`头文件。`exception`类包含以下签名的虚拟函数：`virtual const char *what() const
    noexcept`和`virtual const char *what() const throw()`。这些签名表明派生类应该重新定义`what()`以返回一个描述当前错误的`const
    char *`。`what()`后面的`const`关键字表明这些是`const`成员函数；它们不会改变派生类的任何成员。第一个原型中`noexcept`的使用表明`what()`是非抛出的。第二个原型扩展签名中的`throw()`表明此函数可能抛出任何类型。第二个签名中`throw()`的使用是一个过时的做法，不应在新代码中使用。'
- en: The `std::exception` class is the base class of a variety of predefined C++
    exception classes, including `bad_alloc`, `bad_cast`, `bad_exception`, `bad_function_call`,
    `bad_typeid`, `bad_weak_ptr`, `logic_error`, `runtime_error`, and nested class
    `ios_base::failure`. Many of these derived classes have descendants themselves,
    adding additional standard exceptions to the predefined hierarchy of exceptions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::exception`类是多种预定义的C++异常类的基类，包括`bad_alloc`、`bad_cast`、`bad_exception`、`bad_function_call`、`bad_typeid`、`bad_weak_ptr`、`logic_error`、`runtime_error`以及嵌套类`ios_base::failure`。其中许多派生类本身也有派生，为预定义的异常层次结构添加了额外的标准异常。'
- en: Should a function throw any of the aforementioned exceptions, these exceptions
    may be caught by either catching the base class type, `exception`, or by catching
    an individual derived class type. Depending on what course of action your handler
    will take, you can decide whether you wish to catch one such exception as its
    generalized base class type or as its specific type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数抛出上述任何异常，这些异常可以通过捕获基类类型`exception`或捕获单个派生类类型来捕获。根据您的处理程序将采取的行动，您可以决定是否希望将其作为其泛化基类类型或其特定类型捕获。
- en: Just as the Standard Library has set up a hierarchy of classes based on the
    `exception` class, so may you. Let’s next take a look at how we might do just
    this!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标准库已经基于`exception`类建立了一个类层次结构一样，您也可以这样做。接下来，让我们看看我们如何做到这一点！
- en: Creating customized exception classes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义异常类
- en: As a programmer, you may decide that it is advantageous to establish your own
    specialized exception types. Each type can pack useful information into an object
    detailing just what went wrong with the application. Additionally, you may be
    able to pack clues into the object (which will be thrown) as to how to correct
    the error at hand. Simply derive your class from the Standard Library `exception`
    class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你可能会决定建立自己的专用异常类型是有益的。每种类型都可以将有关应用程序中发生什么错误的有用信息打包到对象中。此外，你还可以将有关如何纠正当前错误的线索打包到（将被抛出的）对象中。只需从标准库
    `exception` 类派生你的类即可。
- en: 'Let’s take a look at how easily this may be done by examining the critical
    portions of our next example, which can be found as a full program in our GitHub:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查下一个示例的关键部分来看看这有多容易做到，该示例作为一个完整的程序可以在我们的 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp)'
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s take a few minutes to examine the previous segment of code. Foremost,
    notice that we define our own exception class, `StudentException`. It is a derived
    class from the C++ Standard Library `exception` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间检查之前的代码段。首先，请注意我们定义了自己的异常类，`StudentException`。它是从 C++ 标准库 `exception`
    类派生的。
- en: The `StudentException` class contains data members to hold an error code as
    well as alphanumeric details describing the error condition using data members
    `errCode` and `details`, respectively. We have two simple access functions, `StudentException::GetCode()`
    and `StudentException::GetDetails()`, to easily retrieve these values. As these
    methods do not modify the object, they are `const` member functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`StudentException` 类包含数据成员来存储错误代码以及使用数据成员 `errCode` 和 `details` 分别描述错误条件的字母数字细节。我们有两个简单的访问函数，`StudentException::GetCode()`
    和 `StudentException::GetDetails()`，以便轻松检索这些值。由于这些方法不修改对象，它们是 `const` 成员函数。'
- en: We notice that the `StudentException` constructor initializes the two data members
    – one through the member initialization list and one in the body of the constructor.
    We also override the `virtual const char *what() const noexcept` method (as introduced
    by the `exception` class) in our `StudentException` class to return the string
    of characters `"Student Exception"`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，`StudentException` 构造函数初始化了两个数据成员——一个通过成员初始化列表，一个在构造函数体中。我们还重写了 `StudentException`
    类中的 `virtual const char *what() const noexcept` 方法（由 `exception` 类引入），以返回字符串 `"Student
    Exception"`。
- en: Next, let’s examine our `Student::Graduate()` method. This method may throw
    a `StudentException`. If an exception must be thrown, we instantiate one, constructing
    it with diagnostic data, and then `throw` the `StudentException` from this function.
    Note that the object thrown has no local identifier in this method – there’s no
    need, as any such local variable name would soon be popped off the stack after
    the throw occurred.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查我们的 `Student::Graduate()` 方法。此方法可能会抛出 `StudentException` 异常。如果必须抛出异常，我们将实例化一个异常，使用诊断数据构造它，然后从该函数中
    `throw` `StudentException` 异常。请注意，在此方法中抛出的对象没有局部标识符——因为没有必要，因为任何这样的局部变量名在抛出后很快就会从栈上弹出。
- en: In our `main()` function, we wrap our call to `s1.Graduate()` within a try block,
    and it is followed by a catch block that accepts a reference (`&`) to a `StudentException`,
    which we treat as `const`. Here, we first call our overridden `what()` method
    and then print out the diagnostic details from within the exception, `e`. Ideally,
    we would use this information to try to correct the error at hand and only exit
    the application if truly necessary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们将对 `s1.Graduate()` 的调用包裹在一个 try 块中，后面跟着一个 catch 块，该块接受一个对
    `StudentException` 的引用（`&`），我们将其视为 `const`。在这里，我们首先调用我们重写的 `what()` 方法，然后从异常 `e`
    中打印出诊断细节。理想情况下，我们会使用这些信息来尝试纠正当前错误，只有在真正必要时才退出应用程序。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Though the most usual way to create a customized exception class is to derive
    a class from the Standard `exception` class, you may also wish to utilize a different
    technique, that of an embedded exception class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从标准 `exception` 类派生一个类来创建自定义异常类是最常见的方式，但你可能也希望利用不同的技术，即嵌入异常类技术。
- en: Creating a nested exception class
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建嵌套异常类
- en: As an alternative implementation, exception handling may be embedded into a
    class by adding a nested class definition in the public access region for a particular
    outer class. The inner class will represent the customized exception class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代实现，异常处理可以通过在特定外部类的公共访问区域添加嵌套类定义来嵌入到类中。内部类将代表定制的异常类。
- en: Objects of nested, user defined types may be created and thrown to catchers
    anticipating such types. These nested classes are built into the public access
    region of the outer class, making them easily available for derived class usage
    and specialization. In general, exception classes built into an outer class must
    be public so that the instances of nested types thrown can be caught and handled
    outside the scope of the outer class (that is, in the scope where the primary,
    outer instance exists).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建嵌套的用户定义类型对象并将其抛出，以便捕获器可以捕获这些类型。这些嵌套类被构建在外部类的公共访问区域，使得它们对于派生类的使用和特殊化很容易访问。一般来说，嵌入到外部类中的异常类必须是公共的，这样抛出的嵌套类型实例才能在外部类的范围之外（即主要的外部实例存在的范围）被捕获和处理。
- en: 'Let’s take a look at this alternate implementation of an exception class by
    examining key segments of code, which can be found as a full program in our GitHub:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查代码的关键部分来查看这个异常类的替代实现，完整的程序可以在我们的 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp)'
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code fragments, we expanded our `Student` class to include a
    private, nested class called `StudentException`. Though the class shown is overly
    simplified, the nested class ideally should define a means to catalog the error
    in question as well as collect any useful diagnostic information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们将 `Student` 类扩展，包括一个名为 `StudentException` 的私有嵌套类。尽管显示的类过于简化，但嵌套类理想情况下应该定义一种方法来记录所讨论的错误，以及收集任何有用的诊断信息。
- en: In our `main()` function, we instantiate a `Student`, namely `s1`. In a try
    block, we then call `s1.Graduate();`. Our `Student::Graduate()` method presumably
    checks that the `Student` has met graduation requirements, and if not, throws
    an exception of the nested class type, `Student::StudentException` (which will
    be instantiated as needed).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们实例化了一个 `Student` 对象，即 `s1`。然后在 try 块中调用 `s1.Graduate();`。我们的
    `Student::Graduate()` 方法可能检查 `Student` 是否满足毕业要求，如果没有，则抛出嵌套类类型的异常，即 `Student::StudentException`（根据需要实例化）。
- en: Notice that our corresponding catch block utilizes scope resolution to specify
    the inner class type for `err`, the referenced object (that is, `const Student::StudentException
    &err`). Though we ideally would like to correct the program error within the handler,
    if we cannot, we simply print a message and `exit()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的相应 catch 块使用作用域解析来指定 `err`（引用的对象，即 `const Student::StudentException &err`）的内部类类型。尽管我们理想情况下希望在处理程序中纠正程序错误，如果我们不能这样做，我们只需打印一条消息并调用
    `exit()`。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Understanding how to create our own exception class (both as a nested class
    or derived from `std::exception`) is useful. We may additionally wish to create
    a hierarchy of application-specific exceptions. Let’s move ahead to see how to
    do so.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何创建我们自己的异常类（无论是作为嵌套类还是从 `std::exception` 派生）是有用的。我们可能还希望创建一个特定应用级别的异常层次结构。让我们继续前进，看看如何做到这一点。
- en: Creating hierarchies of user defined exception types
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户定义异常类型的层次结构
- en: An application may wish to define a series of classes that support exception
    handling to raise specific errors, and hopefully, also provide a means to collect
    diagnostics for an error so that the error may be addressed in an appropriate
    segment of the code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能希望定义一系列支持异常处理的类，以引发特定的错误，并希望提供一种收集错误诊断信息的方法，以便在代码的适当部分处理错误。
- en: You may wish to create a subhierarchy, derived from the C++ Standard Library
    `exception`, of your own exception classes. Be sure to use public inheritance.
    When utilizing these classes, you will instantiate an object of your desired exception
    type (filling it with valuable diagnostic information), and then throw that object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望创建一个从 C++ 标准库 `exception` 派生的子层次结构，以包含你自己的异常类。务必使用公有继承。当使用这些类时，你将实例化一个你想要的异常类型的对象（填充有有价值的诊断信息），然后抛出该对象。
- en: Also, if you create a hierarchy of exception types, your catchers can catch
    specific derived class types or more general base class types. The option is yours,
    depending on how you will plan to handle the exception. Keep in mind, however,
    that if you have a catcher for both the base and derived class types, place the
    derived class types first – otherwise your thrown object will first match to the
    base class type catcher without realizing that a more appropriate derived class
    match is available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你创建了一个异常类型的层次结构，你的捕获器可以捕获特定的派生类类型或更一般的基类类型。选择权在你，取决于你将如何计划处理异常。然而，请记住，如果你同时有一个基类和派生类类型的捕获器，请将派生类类型放在前面——否则，你的抛出对象将首先匹配到基类类型的捕获器，而不会意识到有一个更合适的派生类匹配可用。
- en: We have now seen both the hierarchy of C++ Standard Library exception classes,
    as well as how to create and utilize your own exception classes. Let’s now briefly
    recap the exception features we’ve learned in this chapter, before moving forward
    to our next chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了 C++ 标准库异常类的层次结构，以及如何创建和使用你自己的异常类。现在，在我们继续前进到下一章之前，让我们简要回顾一下本章学到的异常特性。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have begun expanding our C++ programming repertoire beyond
    OOP language features to include features that will enable us to write more robust
    programs. User code can inevitably be error-prone by nature; using language supported
    exception handling can help us achieve less buggy and more reliable code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始扩展我们的 C++ 编程库，不仅包括面向对象语言特性，还包括将使我们能够编写更健壮程序的特性。用户代码不可避免地具有错误倾向；使用语言支持的异常处理可以帮助我们实现更少错误和更可靠的代码。
- en: We have seen how to utilize the core exception handling features with `try`,
    `throw`, and `catch`. We’ve seen a variety of uses of these keywords – throwing
    exceptions to outer handlers, using an assortment of handlers featuring various
    types, and selectively grouping program elements together within a single try
    block, for example. We have seen how to register our own functions with `set_terminate()`
    and `set_unexpected()`. We have seen how to utilize the existing C++ Standard
    Library `exception` hierarchy. We have additionally explored defining our own
    exception classes to extend this hierarchy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `try`、`throw` 和 `catch` 核心异常处理特性。我们已经看到了这些关键字的各种用法——向外部处理程序抛出异常，使用各种类型的处理程序，例如，在单个
    try 块内选择性地将程序元素分组在一起。我们已经看到了如何使用 `set_terminate()` 和 `set_unexpected()` 注册我们自己的函数。我们已经看到了如何利用现有的
    C++ 标准库 `exception` 层次结构。我们还探讨了定义我们自己的异常类以扩展这个层次结构。
- en: We have added key features to our C++ skills by exploring exception handling
    mechanisms. We are now ready to move forward to [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526),
    *Friends and Operator Overloading*, so that we can continue expanding our C++
    programming repertoire with useful language features that will make us better
    programmers. Let’s move forward!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索异常处理机制，我们已经增加了我们的 C++ 技能的关键特性。我们现在准备向前推进到 [*第 12 章*](B19087_12.xhtml#_idTextAnchor526)，*友元和运算符重载*，这样我们就可以继续使用有用的语言特性来扩展我们的
    C++ 编程库，使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Add exception handling to your previous `Student` / `University` exercise from
    [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association, Aggregation,
    and Composition*, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将异常处理添加到你的上一章 [*第 10 章*](B19087_10.xhtml#_idTextAnchor454)，*实现关联、聚合和组合* 的 `Student`
    / `University` 练习中，如下所示：
- en: Should a `Student` try to enroll in more than the `MAX` defined number of allowable
    courses per `Student`, throw a `TooFullSchedule` exception. This class may be
    derived from the Standard Library `exception` class.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个 `Student` 尝试注册超过 `MAX` 定义的数量允许的课程，则抛出 `TooFullSchedule` 异常。这个类可能从标准库 `exception`
    类派生。
- en: Should a `Student` try to enroll in a `Course` that is already full, have the
    `Course::AddStudent(Student *)` method throw a `CourseFull` exception. This class
    may be derived from the Standard Library `exception` class.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个`Student`试图报名一个已经满员的`Course`，`Course::AddStudent(Student *)`方法应该抛出一个`CourseFull`异常。这个类可以继承自标准库的`exception`类。
- en: There are many other areas in the `Student` / `University` application that
    could utilize exception handling. Decide which areas should employ simple error
    checking and which are worthy of exception handling.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student` / `University`应用程序中还有许多其他区域可以利用异常处理。决定哪些区域应该使用简单的错误检查，哪些值得使用异常处理。
