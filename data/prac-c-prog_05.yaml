- en: Deep Dive into Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨指针
- en: Pointers have been the popular choice among programmers when it comes to using
    memory in an optimized way. Pointers have made it possible to access the content of
    any variable, array, or data type. You can use pointers for low-level access to
    any content and improve the overall performance of an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员需要以优化方式使用内存时，指针一直是他们的首选。指针使得访问任何变量、数组或数据类型的内容成为可能。你可以使用指针进行对任何内容的低级访问，并提高应用程序的整体性能。
- en: 'In this chapter, we will look at the following recipes on pointers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下关于指针的食谱：
- en: Reversing a string using pointers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针反转字符串
- en: Finding the largest value in an array using pointers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针在数组中找到最大值
- en: Sorting a singly linked list
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对单链表进行排序
- en: Finding the transpose of a matrix using pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针找到矩阵的转置
- en: Accessing a structure using a pointer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针访问结构
- en: Before we start with the recipes, I would like to discuss a few things related
    to how pointers work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始食谱之前，我想讨论一些与指针工作方式相关的事情。
- en: What is a pointer?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是指针？
- en: A pointer is a variable that contains the memory address of another variable,
    array, or string. When a pointer contains the address of something, it is said
    to be pointing at that thing. When a pointer points at something, it receives
    the right to access the content of that memory address. The question now is—why
    do we need pointers at all?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是一个包含另一个变量、数组或字符串内存地址的变量。当指针包含某个东西的地址时，它被称为指向那个东西。当指针指向某个东西时，它获得访问那个内存地址内容的权利。现在的问题是——我们为什么需要指针呢？
- en: 'We need them because they do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要它们是因为它们执行以下操作：
- en: Facilitate the dynamic allocation of memory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进内存的动态分配
- en: Provide an alternative way to access a data type (apart from variable names,
    you can access the content of a variable through pointers)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种访问数据类型的方法（除了变量名外，你还可以通过指针访问变量的内容）
- en: Make it possible to return more than one value from a function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得函数能够返回多个值
- en: 'For example, consider an `i` integer variable:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 **i** 整数变量：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you define an integer variable, two bytes will be allocated to it in memory.
    This set of two bytes can be accessed by a memory address. The value assigned
    to the variable is stored inside that memory location, as shown in the following
    diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个整数变量时，内存中会为其分配两个字节。这组两个字节可以通过一个内存地址访问。变量分配的值存储在那个内存位置中，如下所示图：
- en: '![](img/d9130228-08da-4a7a-9dd8-a8ff88f5874c.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9130228-08da-4a7a-9dd8-a8ff88f5874c.png)'
- en: Figure 5.1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1
- en: In the preceding diagram, **1000** represents the memory address of the **i** variable.
    Though, in reality, memory address is quite big and is in hex format, for the
    sake of simplicity, I am taking a small integer number, **1000**. The value of **10** is
    stored inside the memory address, **1000**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**1000** 代表 **i** 变量的内存地址。尽管在现实中，内存地址非常大，并且是十六进制格式，但为了简单起见，我使用了一个小的整数数字，**1000**。**10**
    的值存储在 **1000** 的内存地址中，如下所示图：
- en: 'Now, a `j` integer pointer can be defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以定义一个如下所示的 **j** 整数指针：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `j` integer pointer can point to the `i` integer through the following
    statement:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下语句，这个 **j** 整数指针可以指向 **i** 整数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `&` (ampersand) symbol represents the address, and the address of **i**
    will be assigned to the **j** pointer, as shown in the following diagram. The
    **2000** address is assumed to be the address of the **j** pointer and the address
    of the **i** pointer, that is, **1000**, is stored inside the memory location
    assigned to the **j** pointer, as shown in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`（与号）符号代表地址，**i** 的地址将被分配给 **j** 指针，如下所示图所示。假设 **2000** 地址是 **j** 指针的地址，而
    **i** 指针的地址，即 **1000**，存储在分配给 **j** 指针的内存位置中，如下所示图：'
- en: '![](img/10a0c270-1f8a-4c2e-b044-abcea432cbbb.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10a0c270-1f8a-4c2e-b044-abcea432cbbb.png)'
- en: Figure 5.2
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2
- en: 'The address of the `i` integer can be displayed by the following statements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下语句显示 **i** 整数的地址：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To display the contents of `i`, we can use the following statements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 `i` 的内容，我们可以使用以下语句：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the case of pointers, `&` (ampersand) represents the memory address and `*`
    (asterisk) represents content in the memory address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在指针的情况下，`&`（与号）代表内存地址，`*`（星号）代表内存地址中的内容。
- en: 'We can also define a pointer to an integer pointer by means of the following
    statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过以下语句定义一个指向整数指针的指针：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This pointer to a `k` integer pointer can point to a `j` integer pointer using
    the following statement:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指向`k`整型指针的指针可以使用以下语句指向`j`整型指针：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Through the previous statement, the address of the **j** pointer will be assigned
    to the pointer to a **k** integer pointer, as shown in the following diagram.
    The value of **3000** is assumed to be the memory address of **k**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的语句，将`j`指针的地址分配给指向`k`整型指针的指针，如下面的图所示。假设**3000**是`k`的内存地址：
- en: '![](img/36c9c97a-f526-47e9-a815-d8618006a8dc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36c9c97a-f526-47e9-a815-d8618006a8dc.png)'
- en: Figure 5.3
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3
- en: 'Now, when you display the value of `k`, it will display the address of `j`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你显示`k`的值时，它将显示`j`的地址：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To display the address of `i` through `k`, we need to use `*k`, because `*k`
    means that it will display the contents of the memory address pointed at by `k`.
    Now, `k` is pointing at `j` and the content in `j` is the address of `i`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示`i`到`k`的地址，我们需要使用`*k`，因为`*k`表示它将显示由`k`指向的内存地址的内容。现在，`k`指向`j`，而`j`中的内容是`i`的地址：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, to display the value of `i` through `k`, `**k` has to be used as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要显示`i`到`k`的值，必须使用`**k`如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using pointers enables us to access content precisely from desired memory locations.
    But allocating memory through pointers and not releasing it when the job is done
    may lead to a problem called **memory leak**. A memory leak is a sort of resource
    leak. A memory leak can allow unauthorized access of the memory content to hackers
    and may also block some content from being accessed even though it is present.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针使我们能够精确地从所需的内存位置访问内容。但是，通过指针分配内存而不在任务完成后释放它可能会导致称为**内存泄漏**的问题。内存泄漏是一种资源泄漏。内存泄漏可能允许黑客未经授权访问内存内容，也可能阻止某些内容被访问，即使它们存在。
- en: Now, let's begin with the first recipe of this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从这个章节的第一个菜谱开始。
- en: Reversing a string using pointers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针反转字符串
- en: In this recipe, we will learn to reverse a string using pointers. The best part
    is that we will not reverse the string and copy it onto another string, but we
    will reverse the original string itself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用指针反转一个字符串。最好的部分是，我们不会将字符串反转并复制到另一个字符串中，而是直接反转原始字符串本身。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Enter a string to assign to the `str` string variable as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个字符串并将其分配给`str`字符串变量，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set a pointer to point at the string, as demonstrated in the following code. The
    pointer will point at the memory address of the string''s first character:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个指针指向字符串，如下面的代码所示。指针将指向字符串的第一个字符的内存地址：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Find the length of the string by initializing an `n` variable to `1`. Set a
    `while` loop to execute when the pointer reaches the null character of the string
    as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过初始化一个`n`变量为`1`来找到字符串的长度。设置一个`while`循环，当指针到达字符串的空字符时执行，如下所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the `while` loop, the following actions will be performed:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环内部，将执行以下操作：
- en: The pointer is moved one character forward.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针向前移动一个字符。
- en: 'The value of the `n` variable is incremented by 1:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`n`的值增加1：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The pointer will be at the null character, so move the pointer one step back
    to make it point at the last character of the string as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指针将位于空字符，因此将指针向后移动一步，使其指向字符串的最后一个字符，如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set another pointer to point at the beginning of the string as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置另一个指针指向字符串的开头，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Exchange the characters equal to half the length of the string. To do that,
    set a `while` loop to execute for `n/2` times, as demonstrated in the following
    code snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换等于字符串长度一半的字符。为此，设置一个`while`循环执行`n/2`次，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the `while` loop, the first exchange operations take place; that is,
    the characters pointed at by our pointers are exchanged:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环内部，首先进行交换操作；即，我们的指针指向的字符被交换：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the character exchange, set the second pointer to move forward to point
    at its next character, that is, at the second character of the string, and move
    the first pointer backward to make it point at the second to last character as
    follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字符交换后，将第二个指针向前移动以指向其下一个字符，即字符串的第二个字符，并将第一个指针向后移动使其指向倒数第二个字符，如下所示：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Repeat this procedure for n/2 times, where `n` is the length of the string.
    When the `while` loop is finished, we will have the reverse form of the original
    string displayed on the screen:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程n/2次，其中n是字符串的长度。当`while`循环结束时，我们将在屏幕上显示原始字符串的反转形式：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `reversestring.c` program for reversing a string using pointers is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针反转字符串的`reversestring.c`程序如下：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's go behind the scenes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We will be prompted to enter a string that will be assigned to the `str` variable.
    A string is nothing but a character array. Assuming we enter the name `manish`,
    each character of the name will be assigned to a location in the array one by
    one (see *Figure 5.4*). We can see that the first character of the string, the
    letter **m**, is assigned to the **str[0]** location, followed by the second string
    character being assigned to the **str[1]** location, and so on. The null character,
    as usual, is at the end of the string, as shown in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被提示输入一个字符串，该字符串将被分配给`str`变量。字符串不过是一个字符数组。假设我们输入的名字是`manish`，名字中的每个字符将依次分配到数组的某个位置（参见*图5.4*）。我们可以看到，字符串的第一个字符，字母**m**，被分配到**str[0]**位置，接着第二个字符串字符被分配到**str[1]**位置，以此类推。空字符，像往常一样，位于字符串的末尾，如下面的图所示：
- en: '![](img/61e85e86-d659-4198-a0c8-86bf524627ee.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61e85e86-d659-4198-a0c8-86bf524627ee.png)'
- en: Figure 5.4
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4
- en: 'To reverse the string, we will seek the help of two pointers: one will be set
    to point at the first character of the string, and the other at the final character
    of the string. So, the first **ptr1** pointer is set to point at the first character
    of the string as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转字符串，我们将寻求两个指针的帮助：一个将被设置为指向字符串的第一个字符，另一个将被设置为指向字符串的最后一个字符。因此，第一个**ptr1**指针被设置为如下指向字符串的第一个字符：
- en: '![](img/47cd78c0-f0a4-48b2-9347-c1efa5717f2d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47cd78c0-f0a4-48b2-9347-c1efa5717f2d.png)'
- en: Figure 5.5
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5
- en: The exchanging of the characters has to be executed equal to half the length
    of the string; therefore, the next step will be to find the length of the string.
    After finding the string's length, the **ptr1** pointer will be set to move to
    the final character of the string.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字符的交换必须执行到字符串长度的一半；因此，下一步将是找到字符串的长度。在找到字符串的长度后，**ptr1**指针将被设置为移动到字符串的最后一个字符。
- en: 'In addition, another **ptr2** pointer is set to point at **m**, the first character
    of the string, as shown in the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，另一个**ptr2**指针被设置为指向字符串的第一个字符**m**，如下面的图所示：
- en: '![](img/69b96dcf-84c1-4c7c-82db-b53faf5f63db.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69b96dcf-84c1-4c7c-82db-b53faf5f63db.png)'
- en: Figure 5.6
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6
- en: 'The next step is to interchange the first and last characters of the string
    that are being pointed at by the **ptr1** and **ptr2 **pointers (see *Figure 5.7
    (a)*). After interchanging the characters pointed at by the **ptr1** and **ptr2** pointers,
    the string will appear as shown in *Figure 5.7 (b)*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将**ptr1**和**ptr2**指针所指的字符串的第一个和最后一个字符进行交换（参见*图5.7 (a)*）。在交换**ptr1**和**ptr2**指针所指的字符后，字符串将如图*图5.7
    (b)*所示：
- en: '![](img/f75f598f-d818-44c9-bec9-481e1cd9186b.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f75f598f-d818-44c9-bec9-481e1cd9186b.png)'
- en: Figure 5.7
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7
- en: After interchanging the first and last characters, we will interchange the second
    and the second to last characters of the string. To do so, the **ptr2** pointer will
    be moved forward and set to point at the next character in line, and the **ptr1** pointer will
    be moved backward and set to point at the second to last character.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换第一个和最后一个字符之后，我们将交换字符串的第二和倒数第二个字符。为此，**ptr2**指针将被向前移动并设置为指向下一个字符，而**ptr1**指针将被向后移动并设置为指向倒数第二个字符。
- en: 'You can see in the following *Figure** 5.8 (a)* that the **ptr2** and **ptr1** pointers
    are set to point at the **a** and **s** characters. Once this is done, another
    interchanging of the characters pointed at by **ptr2** and **ptr1** will take
    place. The string will appear as follows (*Figure 5.8 (b)*) after the interchanging
    of the **a** and **s** characters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的*图**5.8 (a)*中看到，**ptr2**和**ptr1**指针被设置为指向**a**和**s**字符。一旦这样做，**ptr2**和**ptr1**指针所指的字符将再次进行交换。交换**a**和**s**字符后，字符串将如下所示（*图5.8
    (b)*)：
- en: '![](img/f75d3c37-10ed-4028-9609-b92adfc3a1a0.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f75d3c37-10ed-4028-9609-b92adfc3a1a0.png)'
- en: Figure 5.8
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8
- en: 'The only task now left in reversing the string is to interchange the third
    and the third to last character. So, we will repeat the relocation process of
    the **ptr2** and **ptr1** pointers. Upon interchanging the **n** and **i** characters
    of the string, the original **str** string will have been reversed, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的唯一任务是交换字符串中的第三个和倒数第三个字符。因此，我们将重复**ptr2**和**ptr1**指针的重新定位过程。在交换字符串中的**n**和**i**字符后，原始的**str**字符串将被反转，如下所示：
- en: '![](img/7f3ab20e-a6c4-4e0d-ac48-697c08add75f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f3ab20e-a6c4-4e0d-ac48-697c08add75f.png)'
- en: Figure 5.9
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9
- en: After applying the preceding steps, if we print the **str** string, it will
    appear in reverse.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用上述步骤之后，如果我们打印`**str**`字符串，它将以相反的顺序出现。
- en: 'Let''s use GCC to compile the `reversestring.c` program as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`reversestring.c`程序，如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you get no errors or warnings, that means the `reversestring.c` program
    has been compiled into an executable file, called `reversestring.exe`. Let''s
    run this executable file as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`reversestring.c`程序已被编译成可执行文件，称为`reversestring.exe`。让我们按照以下方式运行此可执行文件：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Voilà! We've successfully reversed a string using pointers. Now, let's move
    on to the next recipe!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用指针反转了一个字符串。现在，让我们继续下一个菜谱！
- en: Finding the largest value in an array using pointers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针在数组中查找最大值
- en: In this recipe, all the elements of the array will be scanned using pointers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，将使用指针扫描数组的所有元素。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Define a macro by the name `max` with a size of `100` as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式定义一个名为`max`的宏，大小为`100`：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define a `p` integer array of a `max` size, as demonstrated in the following
    code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`p`整数数组，大小为`max`，如下所示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Specify the number of elements in the array as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定数组中元素的数量如下：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enter the elements for the array as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下所示输入数组的元素：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define two `mx` and `ptr` pointers to point at the first element of the array
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个`mx`和`ptr`指针，如下所示，以指向数组的第一个元素：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `mx` pointer will always point at the maximum value of the array, whereas
    the `ptr` pointer will be used for comparing the remainder of the values of the
    array. If the value pointed to by the `mx` pointer is smaller than the value pointed
    at by the `ptr` pointer, the `mx` pointer is set to point at the value pointed
    at by `ptr`. The `ptr` pointer will then move to point at the next array element
    as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mx`指针将始终指向数组的最大值，而`ptr`指针将用于比较数组剩余的值。如果`mx`指针指向的值小于`ptr`指针指向的值，则`mx`指针设置为指向`ptr`指针指向的值。然后，`ptr`指针将移动到指向下一个数组元素，如下所示：'
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the value pointed at by the `mx` pointer is larger than the value pointed
    to by the `ptr` pointer, the `mx` pointer is undisturbed and is left to keep pointing
    at the same value and the `ptr` pointer is moved further to point at the next
    array element for the following comparison:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`mx`指针指向的值大于`ptr`指针指向的值，则`mx`指针保持不变，并继续指向相同的值，而`ptr`指针将移动到指向下一个数组元素，以便进行以下比较：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This procedure is repeated until all the elements of the array (pointed to
    by the `ptr` pointer) are compared with the element pointed to by the `mx` pointer.
    Finally, the `mx` pointer will be left pointing at the maximum value in the array.
    To display the maximum value of the array, simply display the array element pointed
    to by the `mx` pointer as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此过程会重复进行，直到数组（由`ptr`指针指向）的所有元素都与由`mx`指针指向的元素进行比较。最后，`mx`指针将指向数组中的最大值。要显示数组的最大值，只需显示由`mx`指针指向的数组元素，如下所示：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `largestinarray.c` program for finding out the largest value in an array
    using pointers is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针查找数组中最大值的`largestinarray.c`程序如下：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's go behind the scenes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Define an array of a certain size and enter a few elements in it. These will
    be the values among which we want to find the largest value. After entering a few
    elements, the array might appear as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个特定大小的数组，并在其中输入一些元素。这些将是我们要找到最大值的值。输入一些元素后，数组可能如下所示：
- en: '![](img/841a0981-f48d-4771-a3d5-f09dba340ca7.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/841a0981-f48d-4771-a3d5-f09dba340ca7.png)'
- en: Figure 5.10
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10
- en: 'We will use two pointers for finding the largest value in the array. Let''s
    name the two pointers **mx** and **ptr**, where the **mx** pointer will be used
    to point at the maximum value of the array, and the **ptr** pointer will be used
    for comparing the rest of the array elements with the value pointed at by the **mx** pointer.
    Initially, both the pointers are set to point at the first element of the array,
    **p[0]**, as shown in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个指针来查找数组中的最大值。让我们将这两个指针命名为**mx**和**ptr**，其中**mx**指针将用于指向数组的最大值，而**ptr**指针将用于将数组的其余元素与**mx**指针指向的值进行比较。最初，两个指针都设置为指向数组的第一个元素**p[0]**，如下面的图所示：
- en: '![](img/9bd62825-6633-4870-8291-f6af94b0c192.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bd62825-6633-4870-8291-f6af94b0c192.png)'
- en: Figure 5.11
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11
- en: 'The **ptr** pointer is then moved to point at the next element of the array,
    **p[1]**. Then, the values pointed at by the **mx** and **ptr** pointers are compared.
    This process continues until all the elements of the array have been compared
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**ptr**指针被移动到指向数组的下一个元素，**p[1]**。然后，**mx**和**ptr**指针指向的值将被比较。这个过程会一直持续到数组中的所有元素都被比较，如下所示：
- en: '![](img/9bdd59f4-8345-42fb-a6d5-e1582e8a92b8.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bdd59f4-8345-42fb-a6d5-e1582e8a92b8.png)'
- en: Figure 5.12
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12
- en: 'Recall that we want the **mx** pointer to keep pointing at the larger value.
    Since 15 is greater than 3 (see *Figure 5.13*), the position of the **mx** pointer
    will be left undisturbed, and the **ptr** pointer will be moved to point at the
    next element, **p[2]**, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们希望**mx**指针保持指向较大的值。由于15大于3（见*图5.13*），**mx**指针的位置将保持不变，而**ptr**指针将移动到指向下一个元素，**p[2]**，如下所示：
- en: '![](img/7576f1a0-b230-4794-9e53-025875808ebe.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7576f1a0-b230-4794-9e53-025875808ebe.png)'
- en: Figure 5.13
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13
- en: 'Again, the values pointed at by the **mx** and **ptr** pointers, which are
    the values 15 and 70 respectively, will be compared. Now, the value pointed at
    by the **mx** pointer is smaller than the value pointed at by the **ptr** pointer.
    So, the **mx** pointer will be set to point at the same array element as **ptr** as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，**mx**和**ptr**指针指向的值，分别是15和70，将被比较。现在，**mx**指针指向的值小于**ptr**指针指向的值。因此，**mx**指针将被设置为指向与**ptr**相同的数组元素，如下所示：
- en: '![](img/59a65912-e6db-4fc2-b200-d22ca70bfa25.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59a65912-e6db-4fc2-b200-d22ca70bfa25.png)'
- en: Figure 5.14
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14
- en: 'The comparison of the array elements will continue. The idea is to keep the
    **mx** pointer pointing at the largest element in the array, as shown in the following
    diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素的比较将继续。想法是保持**mx**指针指向数组中的最大元素，如下面的图所示：
- en: '![](img/d8332507-2659-4cdd-b578-643371e0cfb3.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8332507-2659-4cdd-b578-643371e0cfb3.png)'
- en: Figure 5.15
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15
- en: As shown in *Figure 5.15*, **70** is greater than **20**, so the **mx** pointer
    will remain at **p[2]**, and the **ptr** pointer will move to the next element,
    **p[4]**. Now, the **ptr** pointer is pointing at the last array element. So,
    the program will terminate, displaying the last value pointed at by the **mx** pointer,
    which also happens to be the largest value in the array.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.15*所示，**70**大于**20**，因此**mx**指针将保持在**p[2]**，而**ptr**指针将移动到下一个元素，**p[4]**。现在，**ptr**指针指向数组的最后一个元素。因此，程序将终止，显示**mx**指针指向的最后一个值，这恰好是数组中的最大值。
- en: 'Let''s use GCC to compile the `largestinarray.c` program as the following statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`largestinarray.c`程序，如下所示：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you get no errors or warnings, that means that the `largestinarray.c` program
    has been compiled into an executable file, `largestinarray.exe`. Let''s now run
    this executable file as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`largestinarray.c`程序已经被编译成一个可执行文件，`largestinarray.exe`。现在，让我们按照以下方式运行这个可执行文件：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Voilà! We've successfully found the largest value in an array using pointers.
    Now, let's move on to the next recipe!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用指针在数组中找到了最大值。现在，让我们继续下一个菜谱！
- en: Sorting a singly linked list
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表的排序
- en: In this recipe, we will learn how to create a singly linked list comprising
    integer elements, and then we will learn how to sort this linked list in ascending
    order.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个由整数元素组成的单链表，然后我们将学习如何按升序排序这个链表。
- en: 'A singly linked list consists of several nodes that are connected through pointers.
    A node of a singly linked list might appear as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表由几个通过指针连接的节点组成。单链表中的一个节点可能如下所示：
- en: '![](img/6bb63c26-d9b2-4f5a-8289-dc0d361a448c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bb63c26-d9b2-4f5a-8289-dc0d361a448c.png)'
- en: Figure 5.16
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16
- en: 'As you can see, a node of a singly linked list is a structure composed of two
    parts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，单链表的一个节点是由两个部分组成的结构：
- en: '**Data: **This can be one or more variables (also called members) of integer,
    float, string, or any data type. To keep the program simple, we will take **data**
    as a single variable of the integer type.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这可以是一个或多个变量（也称为成员），可以是整数、浮点数、字符串或任何数据类型。为了使程序简单，我们将**data**作为一个整型变量。'
- en: '**Pointer**: This will point to the structure of the type node. Let''s call
    this pointer **next** in this program, though it can be under any name.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针**：这个指针将指向类型节点的结构。在这个程序中，我们可以将其称为**next**指针，尽管它可以有任何一个名字。'
- en: We will use bubble sort for sorting the linked list. Bubble sort is a sequential
    sorting technique that sorts by comparing adjacent elements. It compares the first
    element with the second element, the second element with the third element, and
    so on. The elements are interchanged if they are not in the preferred order. For
    example, if you are sorting elements into ascending order and the first element
    is larger than the second element, their values will be interchanged. Similarly,
    if the second element is larger than the third element, their values will be interchanged
    too.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用冒泡排序来对链表进行排序。冒泡排序是一种顺序排序技术，通过比较相邻元素进行排序。它将第一个元素与第二个元素进行比较，第二个元素与第三个元素进行比较，依此类推。如果元素不是按预期顺序排列，则交换它们的值。例如，如果你正在按升序排序元素，并且第一个元素大于第二个元素，它们的值将被交换。同样，如果第二个元素大于第三个元素，它们的值也将被交换。
- en: This way, you will find that, by the end of the first iteration, the largest
    value will *bubble* down towards the end of the list. After the second iteration,
    the second largest value will be *bubbled* down to the end of the list. In all,
    n-1 iterations will be required to sort the n elements using bubble sort algorithm.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你会发现，在第一次迭代的结束时，最大的值会*冒泡*到列表的末尾。在第二次迭代后，第二大的值将被*冒泡*到列表的末尾。总的来说，使用冒泡排序算法对n个元素进行排序需要n-1次迭代。
- en: Let's understand the steps in creating and sorting a singly linked list.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解创建和排序单链表的步骤。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define a node comprising two members—`data` and `next`. The data member is
    for storing integer values and the next member is a pointer to link the nodes
    as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的节点—`data`和`next`。`data`成员用于存储整数值，而`next`成员是一个指针，用于将节点链接如下：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Specify the number of elements in the linked list. The value entered will be
    assigned to the `n` variable as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定链表中的元素数量。输入的值将被分配给`n`变量，如下所示：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Execute a `for` loop for `n` number of times. Within the `for` loop, a node
    is created by the name `newNode`. When asked, enter an integer value to be assigned
    to the data member of `newNode` as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个`for`循环，循环`n`次。在`for`循环内部，创建一个名为`newNode`的节点。当被要求时，输入一个整数值分配给`newNode`的数据成员，如下所示：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Two pointers, `startList` and `temp1`, are set to point at the first node.
    The `startList` pointer will keep pointing at the first node of the linked list.
    The `temp1` pointer will be used to link the nodes as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置两个指针，`startList`和`temp1`，以指向第一个节点。`startList`指针将始终指向链表的第一个节点。`temp1`指针将用于链接节点，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To connect the newly created nodes, the following two tasks are performed:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了连接新创建的节点，执行以下两个任务：
- en: The next member of `temp1` is set to point at the newly created node.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`temp1`的下一个成员设置为指向新创建的节点。
- en: 'The `temp1` pointer is shifted to point at the newly created node as follows:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp1`指针被移动以指向新创建的节点，如下所示：'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the `for` loop gets over, we will have a singly linked list with its first
    node pointed at by `startList`, and the next pointer of the last node pointing
    at NULL. This linked list is ready to undergo the sorting procedure. Set a `for`
    loop to execute from `0` until `n-2` that is equal to n-1 iterations as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`for`循环结束时，我们将有一个单链表，其第一个节点由`startList`指向，最后一个节点的下一个指针指向NULL。这个链表已经准备好进行排序过程。设置一个`for`循环，从`0`执行到`n-2`，即n-1次迭代，如下所示：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Within the `for` loop, to compare values, use two pointers, `temp1` and `temp2`.
    Initially, `temp1` and `temp2` will be set to point at the first two nodes of
    the linked list, as shown in the following code snippet:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环内部，为了比较值，使用两个指针，`temp1`和`temp2`。最初，`temp1`和`temp2`将被设置为指向链表的前两个节点，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compare the nodes pointed at by `temp1` and `temp2` in the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中比较`temp1`和`temp2`所指向的节点：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After comparing the first two nodes, the `temp1` and `temp2` pointers will
    be set to point at the second and third nodes, and so on:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较前两个节点后，`temp1`和`temp2`指针将被设置为指向第二个和第三个节点，依此类推：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The linked list has to be arranged in ascending order, so the data member of
    `temp1` must be smaller than the data member of `temp2`. In case the data member
    of `temp1` is larger than the data member of `temp2`, the interchanging of the
    values of the data members will be done with the help of a temporary variable, `k`,
    as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链表必须按升序排列，因此`temp1`的数据成员必须小于`temp2`的数据成员。如果`temp1`的数据成员大于`temp2`的数据成员，则使用临时变量`k`交换数据成员的值，如下所示：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After n-1 performing iterations of comparing and interchanging consecutive
    values, if the first value in the pair is larger than the second, all the nodes
    in the linked list will be arranged in ascending order. To traverse the linked
    list and to display the values in ascending order, a temporary `t` pointer is
    set to point at the node pointed at by `startList`, that is, at the first node
    of the linked list, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过n-1次迭代比较和交换连续值后，如果一对中的第一个值大于第二个值，则链表中的所有节点将按升序排列。为了遍历链表并按升序显示值，设置一个临时的`t`指针指向由`startList`指向的节点，即链表的第一节点，如下所示：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A `while` loop is executed until the `t` pointer reaches `NULL`. Recall that
    the next pointer of the last node is set to NULL, so the `while` loop will execute
    until all the nodes of the linked list are traversed as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`while`循环执行，直到`t`指针达到`NULL`。回想一下，最后一个节点的下一个指针被设置为NULL，因此`while`循环将执行，直到遍历链表中的所有节点，如下所示：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the `while` loop, the following two tasks will be performed:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，将执行以下两个任务：
- en: The data member of the node pointed to by the `t` pointer is displayed.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针`t`所指向的节点数据成员被显示。
- en: 'The `t` pointer is moved further to point at its next node:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`t`指针进一步移动以指向其下一个节点：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `sortlinkedlist.c` program for creating a singly linked list, followed
    by sorting it in ascending order, is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单链表并按升序排序的`sortlinkedlist.c`程序如下：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, let's go behind the scenes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program is performed in two parts—the first part is the creation of a singly
    linked list, and the second part is the sorting of the linked list.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序分为两部分——第一部分是创建单链表，第二部分是排序链表。
- en: Let's start with the first part.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一部分开始。
- en: Creating a singly linked list
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单链表
- en: 'We will start by creating a new node by the name of **newNode**. When prompted,
    we will enter the value for its data member and then set the next **newNode** pointer
    to **NULL** ( as shown in *Figure 5.17*). This next pointer will be used for connecting
    with other nodes (as we will see shortly):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为**newNode**的新节点。当提示输入时，我们将输入其数据成员的值，然后设置下一个**newNode**指针为**NULL**（如图5.17所示）。这个下一个指针将用于与其他节点连接（正如我们很快将看到的）：
- en: '![](img/c6fefb79-a7fc-4202-bd5c-4f50fae32999.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6fefb79-a7fc-4202-bd5c-4f50fae32999.png)'
- en: Figure 5.17
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17
- en: 'After the first node is created, we will make the following two pointers point
    at it as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建第一个节点后，我们将按照以下方式使两个指针指向它：
- en: '**startList**: To traverse the singly linked list, we will need a pointer that
    points at the first node of the list. So, we will define a pointer called **startList** and
    set it to point at the first node of the list.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**startList**：为了遍历单链表，我们需要一个指向列表第一个节点的指针。因此，我们将定义一个名为**startList**的指针，并将其设置为指向列表的第一个节点。'
- en: '**temp1**: In order to connect with the next node, we will need one more pointer.
    We will call this pointer **temp1**, and set it to point at the **newNode** (see
    *Figure 5.18*):'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**temp1**：为了与下一个节点连接，我们还需要一个额外的指针。我们将把这个指针称为**temp1**，并将其设置为指向**newNode**（见*图5.18*）：'
- en: '![](img/28ba6f85-0923-41c9-ac7e-597ecd6db4a8.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28ba6f85-0923-41c9-ac7e-597ecd6db4a8.png)'
- en: Figure 5.18
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18
- en: We will now create another node for the linked list and call that **newNode** as
    well. The pointer can point to only one structure at a time. So, the moment we
    create a new node, the **newNode** pointer that was pointing at the first node
    will now point at the recently created node. We will be prompted to enter a value
    for the data member of the new node, and its next pointer will be set to **NULL**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为链表创建另一个节点，并将其命名为 **newNode**。指针一次只能指向一个结构。因此，当我们创建一个新节点时，之前指向第一个节点的 **newNode**
    指针现在将指向最近创建的节点。我们将被提示输入新节点数据成员的值，其下一个指针将被设置为 **NULL**。
- en: 'You can see in the following diagram that the two pointers, **startList** and
    **temp1**, are pointing at the first node and the **newNode** pointer is pointing
    at the newly created node. As stated earlier, **startList** will be used for traversing
    the linked list and **temp1** will be used for connecting with the newly created
    node as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的图中看到，两个指针 **startList** 和 **temp1** 指向第一个节点，而 **newNode** 指针指向新创建的节点。如前所述，**startList**
    将用于遍历链表，而 **temp1** 将用于连接新创建的节点，如下所示：
- en: '![](img/83719c68-2a28-4dbd-8da1-74d16d91746b.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83719c68-2a28-4dbd-8da1-74d16d91746b.png)'
- en: Figure 5.19
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19
- en: 'To connect the first node with **newNode**, the next pointer of **temp1** will
    be set to point at **newNode** (see *Figure 5.20 (a)*). After connecting with
    **newNode**, the **temp**`1` pointer will be moved further and set to point at
    **newNode** (see *Figure 5.20 (b)*) so that it can be used again for connecting
    with any new nodes that may be added to the linked list in future:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要将第一个节点与 **newNode** 连接，**temp1** 的下一个指针将被设置为指向 **newNode**（参见 *图 5.20（a）*）。连接
    **newNode** 后，**temp**`1` 指针将被进一步移动并设置为指向 **newNode**（参见 *图 5.20（b）*），以便它可以再次用于连接未来可能添加到链表中的任何新节点：
- en: '![](img/6194255a-490c-45cd-b8b8-10d15a2d39da.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6194255a-490c-45cd-b8b8-10d15a2d39da.png)'
- en: Figure 5.20
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20
- en: 'Steps three and four will be repeated for the rest of the nodes of the linked
    list. Finally, the singly linked list will be ready and will look something like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤三和四将重复应用于链表中的其余节点。最后，单链表将准备就绪，看起来可能如下所示：
- en: '![](img/b818dbea-1623-44d6-821b-10db3cc3adaf.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b818dbea-1623-44d6-821b-10db3cc3adaf.png)'
- en: Figure 5.21
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21
- en: Now that we have created the singly linked list, the next step is to sort the
    linked list in ascending order.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了单链表，下一步是将链表按升序排序。
- en: Sorting the singly linked list
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对单链表进行排序
- en: We will use the bubble sort algorithm for sorting the linked list. In the bubble
    sort technique, the first value is compared with the second value, the second
    is compared with the third value, and so on. If we want to sort our list in ascending
    order, then we will need to keep the smaller values toward the top when comparing
    the values.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用冒泡排序算法对链表进行排序。在冒泡排序技术中，第一个值与第二个值进行比较，第二个值与第三个值进行比较，依此类推。如果我们想按升序排序我们的列表，那么在比较值时，我们需要将较小的值保持在顶部。
- en: Therefore, while comparing the first and second values, if the first value is
    larger than the second value, then their places will be interchanged. If the first
    value is smaller than the second value, then no interchanging will happen, and
    the second and third values will be picked up for comparison.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在比较第一个和第二个值时，如果第一个值大于第二个值，则它们的顺序将被交换。如果第一个值小于第二个值，则不会发生交换，并将继续比较第二个和第三个值。
- en: There will be n-1 iterations of such comparisons, meaning if there are five
    values, then there will be four iterations of such comparisons; and after every
    iteration, the last value will be left out—that is, it will not be compared as
    it reaches its destination. The destination here means the location where the
    value must be kept when arranged in ascending order.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有 n-1 次这样的比较迭代，这意味着如果有五个值，那么将有四次这样的比较迭代；并且每次迭代后，最后一个值将被排除在外——也就是说，当它达到目的地时不会进行比较。这里的“目的地”是指当按升序排列时必须保持值的那个位置。
- en: The first iteration
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一次迭代
- en: 'To sort the linked list, we will employ the services of two pointers—**temp1**
    and **temp2**. The **temp1** pointer is set to point at the first node, and **temp2**
    is set to point at the next node as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对链表进行排序，我们将使用两个指针——**temp1** 和 **temp2**。**temp1** 指针被设置为指向第一个节点，而 **temp2**
    被设置为指向下一个节点，如下所示：
- en: '![](img/f10332d7-69c3-41f9-b727-a641ef0c5c97.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f10332d7-69c3-41f9-b727-a641ef0c5c97.png)'
- en: Figure 5.22
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22
- en: 'We will be sorting the linked list in ascending order, so we will keep the
    smaller values toward the beginning of the list. The data members of **temp1**
    and **temp2** will be compared. Because `temp1->data` is greater than `temp2->data`,
    that is, the data member of **temp1** is larger than the data member of **temp2**,
    their places will be interchanged (see the following diagram). After interchanging
    the data members of the nodes pointed at by **temp1** and **temp2**, the linked
    list will appear as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按升序对链表进行排序，因此我们将较小的值保持在列表的起始位置。**temp1** 和 **temp2** 的数据成员将被比较。因为 `temp1->data`
    大于 `temp2->data`，即 **temp1** 的数据成员大于 **temp2** 的数据成员，它们的顺序将被交换（见以下图表）。在交换 **temp1**
    和 **temp2** 指向的节点数据成员之后，链表将呈现如下：
- en: '![](img/cbe93673-7a70-4a7f-bed6-24062769e670.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe93673-7a70-4a7f-bed6-24062769e670.png)'
- en: Figure 5.23
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23
- en: After this, the two pointers will shift further, that is, the **temp1** pointer
    will be set to point at **temp2**, and the **temp2** pointer will be set to point
    at its next node. We can see in *Figure 5.24 (a)* that the **temp1** and **temp2** pointers
    are pointing at the nodes with the values 3 and 7, respectively. We can also see
    that `temp1->data` is less than `temp2->data`, that is, 3 < 7\. Since the data
    member of **temp1** is already smaller than the data member of **temp2**, no interchanging
    of values will take place and the two pointers will simply move one step further
    (see *Figure 5.24 (b)*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两个指针将进一步移动，即 **temp1** 指针将被设置为指向 **temp2**，而 **temp2** 指针将被设置为指向其下一个节点。我们可以在
    *图 5.24 (a)* 中看到 **temp1** 和 **temp2** 指针分别指向值为 3 和 7 的节点。我们还可以看到 `temp1->data`
    小于 `temp2->data`，即 3 < 7。由于 **temp1** 的数据成员已经小于 **temp2** 的数据成员，因此不会发生值交换，两个指针将简单地再向前移动一步（见
    *图 5.24 (b)*）。
- en: 'Now, because 7 > 4, their places will be interchanged. The values of data members
    pointed at by **temp1** and **temp2** will interchange as follows (*Figure 5.24
    (c)*):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为 7 > 4，它们的顺序将被交换。**temp1** 和 **temp2** 指向的数据成员的值将按以下方式交换（*图 5.24 (c)*）：
- en: '![](img/1d67b2cc-9615-42e7-9bb2-4c2c8e84fe04.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d67b2cc-9615-42e7-9bb2-4c2c8e84fe04.png)'
- en: Figure 5.24
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24
- en: 'After that, the **temp1** and **temp2** pointer will be shifted one step further,
    that is, **temp1** will point at **temp2**, and **temp2** will move onto its next
    node. We can see in the following *Figure 5.25 (a)* that **temp1** and **temp2**
    are pointing at the nodes with the values 7 and 2, respectively. Again, the data
    members of **temp1** and **temp2** will be compared. Because `temp1->data` is
    greater than `temp2->data`, their places will be interchanged. *Figure 5.25 (b)*
    shows the linked list after interchanging values of the data members:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，**temp1** 和 **temp2** 指针将再向前移动一步，即 **temp1** 将指向 **temp2**，而 **temp2** 将移动到其下一个节点。我们可以在下面的
    *图 5.25 (a)* 中看到 **temp1** 和 **temp2** 分别指向值为 7 和 2 的节点。再次，**temp1** 和 **temp2**
    的数据成员将被比较。因为 `temp1->data` 大于 `temp2->data`，它们的顺序将被交换。*图 5.25 (b)* 显示了交换数据成员值后的链表：
- en: '![](img/b7b96e4d-13a4-4cb5-82f4-cbe8f89e350c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7b96e4d-13a4-4cb5-82f4-cbe8f89e350c.png)'
- en: Figure 5.25
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25
- en: This was the first iteration, and you can notice that after this iteration,
    the largest value, 7, has been set to our desired location—at the end of the linked
    list. This also means that in the second iteration, we will not have to compare
    the last node. Similarly, after the second iteration, the second highest value
    will reach or is set to its actual location. The second highest value in the linked
    list is 4, so after the second iteration, the four node will just reach the seven node.
    How? Let's look at the second iteration of bubble sort.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次迭代，你可以注意到在这次迭代之后，最大的值 7 已经被设置到我们期望的位置——链表的末尾。这也意味着在第二次迭代中，我们不需要比较最后一个节点。同样，在第二次迭代之后，第二大的值将达到或被设置到其实际位置。链表中的第二大的值是
    4，因此，在第二次迭代之后，四个节点将刚好到达七个节点。如何做到？让我们看看冒泡排序的第二次迭代。
- en: The second iteration
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二次迭代
- en: 'We will begin the comparison by comparing first two nodes, so the **temp1**
    and **temp2** pointers will be set to point at the first and second nodes of the
    linked list, respectively (see *Figure 5.26 (a)*). The data members of **temp1**
    and **temp2** will be compared. As is clear, `temp1->data` is less than `temp2->data`
    (that is, 1 < 7), so their places will not be interchanged. Thereafter, the **temp1**
    and **temp2** pointers will shift one step further. We can see in *Figure 5.26
    (b)* that the **temp1** and **temp2** pointers are set to point at nodes of the
    values 3 and 4, respectively:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从比较前两个节点开始，因此 `**temp1**` 和 `**temp2**` 指针将被设置为分别指向链表的第一个和第二个节点（参见 *图 5.26
    (a)*）。将比较 `**temp1**` 和 `**temp2**` 的数据成员。如清晰可见，`temp1->data` 小于 `temp2->data`（即
    1 < 7），因此它们的位置不会互换。之后，`**temp1**` 和 `**temp2**` 指针将再向前移动一步。我们可以在 *图 5.26 (b)*
    中看到，`**temp1**` 和 `**temp2**` 指针被设置为分别指向值为 3 和 4 的节点：
- en: '![](img/2b4d1fc7-996d-4888-b1d9-d38db3fd1c58.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b4d1fc7-996d-4888-b1d9-d38db3fd1c58.png)'
- en: Figure 5.26
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26
- en: 'Once again, the data members of the **temp1** and **temp2** pointers will be
    compared. Because `temp1->data` is less than `temp2->data`, that is, 3 < 4 , their
    places will again not be interchanged and the **temp1** and **temp2** pointers
    will, again, shift one step further. That is, the **temp1** pointer will be set
    to point at **temp2**, and **temp2** will be set to point at its next node. You
    can see in *Figure 5.27 (a)* that the **temp1** and **temp2** pointers are set
    to point at nodes with the values 4 and 2, respectively. Because 4 > 2, their
    places will be interchanged. After interchanging the place of these values, the
    linked list will appear as follows in *Figure 5.27 (b)*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将比较 `**temp1**` 和 `**temp2**` 指针的数据成员。因为 `temp1->data` 小于 `temp2->data`，即
    3 < 4，它们的位置再次不会互换，`**temp1**` 和 `**temp2**` 指针将再次向前移动一步。也就是说，`**temp1**` 指针将被设置为指向
    `**temp2**`，而 `**temp2**` 将被设置为指向它的下一个节点。您可以在 *图 5.27 (a)* 中看到，**temp1** 和 **temp2**
    指针被设置为分别指向值为 4 和 2 的节点。因为 4 > 2，它们的位置将互换。在交换这些值的位置后，链表在 *图 5.27 (b)* 中将如下所示：
- en: '![](img/67940b4c-b33d-4d1d-ad28-5aedbec9e5a6.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67940b4c-b33d-4d1d-ad28-5aedbec9e5a6.png)'
- en: Figure 5.27
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27
- en: This is the end of the second iteration, and we can see that the second largest
    value, four, is set to our desired location as per ascending order. So, with every
    iteration, one value is being set at the required location. Accordingly, the next
    iteration will require one comparison less.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二次迭代的结束，我们可以看到第二大值，四，按照升序被设置到我们期望的位置。因此，在每次迭代中，一个值将被设置到所需的位置。相应地，下一次迭代将需要少一次比较。
- en: The third and fourth iterations
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三次和第四次迭代
- en: 'In the third iteration, we will only need to do the following comparisons:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次迭代中，我们只需要进行以下比较：
- en: Compare the first and second nodes
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较第一个和第二个节点
- en: Compare the second and third nodes
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较第二个和第三个节点
- en: After the third iteration, the third largest value, that is, three, will be
    set at our desired location, that is, just before node four.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次迭代后，第三大的值，即三，将被设置在我们期望的位置，即在节点四之前。
- en: 'In the fourth, and final, iteration, only the first and second nodes will be
    compared. The linked list will be sorted in ascending order as follows after the
    fourth iteration:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四次，也是最后一次迭代中，只有第一个和第二个节点将被比较。经过第四次迭代后，链表将按升序排序如下：
- en: '![](img/2df04458-77ea-4add-b196-3e4d7c65744a.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2df04458-77ea-4add-b196-3e4d7c65744a.png)'
- en: Figure 5.28
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28
- en: 'Let''s use GCC to compile the `sortlinkedlist.c` program as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 来编译 `sortlinkedlist.c` 程序，如下所示：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you get no errors or warnings, that means that the `sortlinkedlist.c` program
    has been compiled into an executable file, `sortlinkedlist.exe`. Let''s run this
    executable file as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着 `sortlinkedlist.c` 程序已经被编译成一个可执行文件，`sortlinkedlist.exe`。让我们按照以下步骤运行这个可执行文件：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Voilà! We've successfully created and sorted a singly linked list. Now, let's
    move on to the next recipe!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建并排序了一个单链表。现在，让我们继续下一个菜谱！
- en: Finding the transpose of a matrix using pointers
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针寻找矩阵的转置
- en: The best part of this recipe is that we will not only display the transpose
    of the matrix using pointers, but we will also create the matrix itself using
    pointers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱最好的部分是，我们不仅将使用指针显示矩阵的转置，而且我们还将使用指针创建矩阵本身。
- en: 'The transpose of a matrix is a new matrix that has rows equal to the number
    of columns of the original matrix and columns equal to the number of rows. The
    following diagram shows you a matrix of order **2 x 3** and its transpose, of
    order **3 x 2**:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的转置是一个新矩阵，其行数等于原始矩阵的列数，列数等于原始矩阵的行数。以下图表显示了**2 x 3**阶矩阵及其**3 x 2**阶转置：
- en: '![](img/1b86958e-4345-4caf-afa4-6322548bb6b6.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b86958e-4345-4caf-afa4-6322548bb6b6.png)'
- en: Figure 5.29
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29
- en: Basically, we can say that, upon converting the rows into columns and columns
    into rows of a matrix, you get its transpose.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以这样说，当将矩阵的行转换为列，列转换为行时，你得到的就是它的转置。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Define a matrix of 10 rows and 10 columns as follows (you can have a bigger
    matrix if you wish):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个10行10列的矩阵如下（如果你愿意，可以有一个更大的矩阵）：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enter the size of the rows and columns as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下输入行和列的大小：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Allocate memory locations equal to `r *c` quantity for keeping the matrix elements
    as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为保持矩阵元素，分配等于`r * c`数量的内存位置如下：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Enter elements of the matrix that will be assigned sequentially to each allocated
    memory as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下顺序将矩阵的元素输入到每个分配的内存中：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In order to access this matrix via a pointer, set a `ptr` pointer to point
    at the first memory location of the allocated memory block, as shown in *Figure
    5.30*. The moment that the `ptr` pointer is set to point at the first memory location,
    it will automatically get the address of the first memory location, so `1000`
    will be assigned to the `ptr` pointer:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过指针访问此矩阵，将`ptr`指针设置为指向分配的内存块的第一个内存位置，如*图5.30*所示。当`ptr`指针设置为指向第一个内存位置时，它将自动获取第一个内存位置的地址，因此`1000`将被分配给`ptr`指针：
- en: '![](img/f045b048-81c4-4327-9878-5f97b78f4b1e.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f045b048-81c4-4327-9878-5f97b78f4b1e.png)'
- en: Figure 5.30
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30
- en: 'To access these memory locations and display their content, use the `*(ptr
    +i*c + j)` formula within the nested loop, as shown in this code snippet:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问这些内存位置并显示其内容，请在嵌套循环中使用`*(ptr +i*c + j)`公式，如以下代码片段所示：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The value of the `r` row is assumed to be two, and that of column `c` is assumed
    to be three. With values of `i=0` and `j=0`, the formula will compute as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设行的值`r`为二，列的值`c`为三。当`i=0`和`j=0`时，公式将计算如下：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It will display the content of the memory address, `1000`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示内存地址`1000`的内容。
- en: 'When the value of `i=0` and `j=1`, the formula will compute as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当`i=0`和`j=1`时，公式将计算如下：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will first get `*(1000+1)`, because the `ptr` pointer is an integer pointer,
    and it will jump two bytes every time we add the value `1` to it at every memory
    location, from which we will get `*(1002)`, and it will display the content of
    the memory location `1002`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`*(1000+1)`，因为`ptr`指针是一个整数指针，每次我们在每个内存位置将值`1`加到它上面时，它将自动跳过两个字节，从而得到`*(1002)`，并显示内存位置`1002`的内容。
- en: 'Similarly, the value of `i=0` and `j=2` will lead to `*(1004)`; that is, the
    content of the memory location `1004` will be displayed. Using this formula, the
    value of `i=1` and `j=0` will lead to `*(1006)`; the value of `i=1` and `j=1`
    will lead to `*(1008)`; and the value of `i=1` and `j=2` will lead to `*(1010)`.
    So, when the aforementioned formula is applied within the nested loops, the original
    matrix will be displayed as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`i=0`和`j=2`的值将导致`*(1004)`；即显示内存位置`1004`的内容。使用此公式，`i=1`和`j=0`将导致`*(1006)`；`i=1`和`j=1`将导致`*(1008)`；`i=1`和`j=2`将导致`*(1010)`。因此，当在嵌套循环中应用上述公式时，原始矩阵将显示如下：
- en: '![](img/53b5cc56-2dfd-4f3c-bd7e-d7f196fbdf4c.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53b5cc56-2dfd-4f3c-bd7e-d7f196fbdf4c.png)'
- en: Figure 5.31
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31
- en: 'To display the transpose of a matrix, apply the following formula within the
    nested loops:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示矩阵的转置，请在嵌套循环中应用以下公式：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Again, assuming the values of row (r=2) and column (c=3), the following content
    of memory locations will be displayed:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设行的值（r=2）和列的值（c=3），以下内存位置的内容将被显示：
- en: '| **i** | **j** | **Memory address** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **i** | **j** | **内存地址** |'
- en: '| 0 | 0 | `1000` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | `1000` |'
- en: '| 0 | 1 | `1006` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | `1006` |'
- en: '| 1 | 0 | `1002` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | `1002` |'
- en: '| 1 | 1 | `1008` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | `1008` |'
- en: '| 2 | 0 | `1004` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | `1004` |'
- en: '| 2 | 1 | `1010` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | `1010` |'
- en: 'So, upon applying the preceding formula, the content of the following memory
    address will be displayed as the following in *Figure 5.32*. And the content of
    these memory addresses will comprise the transpose of the matrix:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用上述公式后，以下内存地址的内容将显示为*图 5.32*中的以下内容。这些内存地址的内容将构成矩阵的转置：
- en: '![](img/ddf71880-231d-4871-ac78-bf90da445a7c.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddf71880-231d-4871-ac78-bf90da445a7c.png)'
- en: Figure 5.32
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32
- en: Let's see how this formula is applied in a program.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个公式如何在程序中应用。
- en: 'The `transposemat.c` program for displaying the transpose of a matrix using
    pointers is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针显示矩阵转置的`transposemat.c`程序如下：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, let's go behind the scenes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Whenever an array is defined, the memory allocated to it internally is a sequential
    memory. Now let''s define a matrix of size 2 x 3, as shown in the following diagram.
    In that case, the matrix will be assigned six consecutive memory locations of
    two bytes each (see *Figure 5.33*). Why two bytes each? This is because an integer
    takes two bytes. This also means that if we define a matrix of the float type
    that takes four bytes, each allocated memory location would consist of four bytes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每当定义一个数组时，它内部分配的内存是顺序内存。现在让我们定义一个 2 x 3 大小的矩阵，如图所示。在这种情况下，矩阵将被分配六个连续的内存位置，每个位置两个字节（参见*图
    5.33*）。为什么是每个位置两个字节？这是因为一个整数占用两个字节。这也意味着如果我们定义一个浮点类型的矩阵，它占用四个字节，每个分配的内存位置将包含四个字节：
- en: '![](img/32003bda-355e-4f2e-a3fb-17af54bad1d8.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32003bda-355e-4f2e-a3fb-17af54bad1d8.png)'
- en: Figure 5.33
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33
- en: In reality, the memory address is long and is in hex format; but for simplicity,
    we will take the memory addresses of integer type and take easy-to-remember numbers,
    such as **1000**, as memory addresses. After memory address **1000**, the next
    memory address is **1002** (because an integer takes two bytes).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内存地址很长，并且是十六进制格式；但为了简单起见，我们将使用整数类型的内存地址，并使用易于记忆的数字，如**1000**，作为内存地址。在内存地址**1000**之后，下一个内存地址是**1002**（因为一个整数占用两个字节）。
- en: 'Now, to display the original matrix elements in row-major form using a pointer,
    we will need to display the elements of memory locations, **1000**, **1002**,
    **1004**, and so on:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用指针以行主序形式显示原始矩阵元素，我们需要显示内存位置的元素，**1000**、**1002**、**1004**以及如此等等：
- en: '![](img/337d6407-f33e-47fb-abde-5b3d33e2d2c8.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/337d6407-f33e-47fb-abde-5b3d33e2d2c8.png)'
- en: Figure 5.34
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34
- en: 'Similarly, in order to display the transpose of the matrix using a pointer,
    we will need to display the elements of memory locations; **1000**, **1006**,
    **1002**, **1008**, **1004**, and **1010**:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了使用指针显示矩阵的转置，我们需要显示内存位置的元素；**1000**、**1006**、**1002**、**1008**、**1004**和**1010**：
- en: '![](img/18e0a836-62ad-44c0-9862-e33ce8e7cf3f.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18e0a836-62ad-44c0-9862-e33ce8e7cf3f.png)'
- en: Figure 5.35
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35
- en: 'Let''s use GCC to compile the `transposemat.c` program as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译`transposemat.c`程序，如下所示：
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you get no errors or warnings, that means that the `transposemat.c` program
    has been compiled into an executable file, `transposemat.exe`. Let''s run this
    executable file with the following code snippet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`transposemat.c`程序已经被编译成可执行文件，`transposemat.exe`。让我们用以下代码片段运行这个可执行文件：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Voilà! We've successfully found the transpose of a matrix using pointers. Now,
    let's move on to the next recipe!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用指针找到了矩阵的转置。现在，让我们继续下一个菜谱！
- en: Accessing a structure using a pointer
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针访问结构
- en: 'In this recipe, we will make a structure that stores the information of an
    order placed by a specific customer. A structure is a user-defined data type that
    can store several members of different data types within it. The structure will
    have members for storing the order number, email address, and password of the
    customer:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个结构来存储特定客户下单的信息。结构是一种用户定义的数据类型，可以在其中存储不同数据类型的多个成员。该结构将包含用于存储订单号、电子邮件地址和密码的成员：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding structure is named `cart`, and comprises three members – `orderno` of
    the `int` type for storing the order number of the order placed by the customer,
    and `emailaddress` and `password` of the string type for storing the email address
    and password of the customer, respectively. Let's begin!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构被命名为`cart`，包含三个成员——用于存储客户下单顺序号的`int`类型成员`orderno`，以及用于存储客户电子邮件地址和密码的字符串类型成员`emailaddress`和`password`。让我们开始吧！
- en: How to do it…
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define a `cart` structure by the name `mycart`. Also, define two pointers to
    structure of the `cart` structure, `ptrcart` and `ptrcust`, as shown in the following
    code snippet:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`mycart`的`cart`结构。同时，定义两个指向`cart`结构的指针`ptrcart`和`ptrcust`，如下面的代码片段所示：
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Enter the order number, email address, and password of the customer, and these
    values will be accepted using the `mycart` structure variable. As mentioned previously,
    the dot operator (`.`) will be used for accessing the structure members, `orderno`,
    `emailaddress`, and `password`, through a structure variable as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入客户的订单号、电子邮件地址和密码，这些值将通过`mycart`结构变量接受。如前所述，点运算符（`.`）将用于通过结构变量访问结构成员`orderno`、`emailaddress`和`password`，如下所示：
- en: '[PRE63]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Set the pointer to the `ptrcart` structure to point at the `mycart` structure
    using the `ptrcart=&mycart` statement. Consequently, the pointer to the `ptrcart` structure
    will be able to access the members of the `mycart` structure by using the arrow
    (`->`) operator. By using `ptrcart->orderno`, `ptrcart->emailaddress`, and `ptrcart->password`,
    the values assigned to the `orderno`, `emailaddress`, and `password` structure
    members are accessed and displayed:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ptrcart=&mycart`语句将`ptrcart`结构指针设置为指向`mycart`结构。因此，`ptrcart`结构指针将能够通过使用箭头（`->`）运算符访问`mycart`结构的成员。通过使用`ptrcart->orderno`、`ptrcart->emailaddress`和`ptrcart->password`，可以访问分配给`orderno`、`emailaddress`和`password`结构成员的值并显示它们：
- en: '[PRE64]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will also modify the email address and password of the customer by asking
    them to enter a new email address and password and accept the new details via
    the pointer to the `ptrcart` structure as follows. Because `ptrcart` is pointing
    to the `mycart` structure, the new email address and password will overwrite the
    existing values that were assigned to the structure members of `mycart`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将通过让客户输入新的电子邮件地址和密码并接受通过指向`ptrcart`结构的新的详细信息来修改客户的电子邮件地址和密码。因为`ptrcart`指向`mycart`结构，新的电子邮件地址和密码将覆盖分配给`mycart`结构成员的现有值：
- en: '[PRE65]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, define a pointer to the `*ptrcust` structure. Using the following `malloc`
    function, allocate memory for it. The `sizeof` function will find out the number
    of bytes consumed by each of the structure members and return the total number
    of bytes consumed by the structure as a whole:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个指向`*ptrcust`结构的指针。使用以下`malloc`函数为其分配内存。`sizeof`函数将找出每个结构成员消耗的字节数，并返回整个结构消耗的总字节数：
- en: '[PRE66]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Enter the order number, email address, and password of the customer, and all
    the values will be assigned to the respective structure members using a pointer
    to a structure as follows. Obviously, the arrow operator (`->`) will be used for
    accessing the structure members through a pointer to a structure:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入客户的订单号、电子邮件地址和密码，所有这些值将通过指向结构的指针分配给相应的结构成员，如下所示。显然，将使用箭头运算符（`->`）通过指向结构的指针访问结构成员：
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The values entered by the user are then displayed through the pointer to the `ptrcust` structure
    again as follows:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过以下方式再次通过指向`ptrcust`结构的指针显示用户输入的值：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following `pointertostruct.c` program explains how to access a structure
    by using a pointer:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`pointertostruct.c`程序解释了如何使用指针访问结构：
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, let's go behind the scenes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you define a variable of the type structure, that variable can access
    members of the structure in the following format:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个结构类型的变量时，该变量可以以下格式访问结构成员：
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can see a period (`.`) between the structure variable and the structure
    member. This period (`.`) is also known as a dot operator, or member access operator.
    The following example will make it clearer:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在结构变量和结构成员之间看到一个点（`.`）。这个点（`.`）也被称为点运算符，或成员访问运算符。以下示例将使其更清晰：
- en: '[PRE71]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the preceding code, you can see that `mycart` is defined as a structure variable
    of the `cart` structure. Now, the `mycart` structure variable can access the `orderno`
    member by making the member access operator (`.`).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到`mycart`被定义为`cart`结构的结构变量。现在，`mycart`结构变量可以通过使用成员访问运算符（`.`）访问`orderno`成员。
- en: You can also define a pointer to a structure. The following statement defines
    `ptrcart` as a pointer to the `cart` structure.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以定义一个指向结构的指针。以下语句将`ptrcart`定义为指向`cart`结构的指针。
- en: '[PRE72]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When the pointer to a structure points to a structure variable, it can access
    the structure members of the structure variable. In the following statement, the
    pointer to the `ptrcart` structure points at the address of the `mycart` structure
    variable:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构体指针指向一个结构体变量时，它可以访问该结构体变量的结构体成员。在以下语句中，指向 `ptrcart` 结构体的指针指向 `mycart` 结构体变量的地址：
- en: '[PRE73]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, `ptrcart` can access the structure members, but instead of the dot operator
    (`.`), the arrow operator (`->`) will be used. The following statement accesses
    the `orderno` member of the structure using the pointer to a structure:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ptrcart` 可以访问结构体成员，但将使用箭头操作符 (`->`) 而不是点操作符 (`.`)。以下语句使用指向结构体的指针访问结构体的 `orderno`
    成员：
- en: '[PRE74]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you don’t want a pointer to a structure to point at the structure variable,
    then memory needs to be allocated for a pointer to a structure to access structure
    members. The following statement defines a pointer to a structure by allocating
    memory for it:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让结构体指针指向结构体变量，那么需要为指向结构体的指针分配内存以访问结构体成员。以下语句通过为它分配内存来定义一个指向结构体的指针：
- en: '[PRE75]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding code allocates memory equal to the size of a `cart` structure,
    typecasts that memory to be used by a pointer to a `cart` structure, and assigns
    that allocated memory to `ptrcust`. In other words, `ptrcust` is defined as a
    pointer to a structure, and it does not need to point to any structure variable,
    but can directly access the structure members.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为 `cart` 结构体分配了与结构体大小相等的内存，将该内存类型转换为指向 `cart` 结构体的指针，并将分配的内存赋值给 `ptrcust`。换句话说，`ptrcust`
    被定义为指向结构体的指针，它不需要指向任何结构体变量，但可以直接访问结构体成员。
- en: 'Let''s use GCC to compile the `pointertostruct.c` program as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `pointertostruct.c` 程序，如下所示：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you get no errors or warnings, that means that the `pointertostruct.c` program
    has been compiled into an executable file, `pointertostruct.exe`. Let''s run this
    executable file as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着 `pointertostruct.c` 程序已经被编译成一个可执行文件，名为 `pointertostruct.exe`。让我们按照以下方式运行这个可执行文件：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Voilà! We've successfully accessed a structure using a pointer.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用指针访问了一个结构体。
