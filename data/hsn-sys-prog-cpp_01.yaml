- en: Getting Started with System Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始系统编程
- en: In this chapter, we will discuss what system programming is (that is, the act
    of making system calls to the operating system to perform an action on your behalf),
    and go into the pros and cons of both system programming, and system programming
    with C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论系统编程是什么（即，向操作系统发出系统调用以代表您执行操作），并深入探讨系统编程和使用C++进行系统编程的利弊。
- en: 'In this chapter, we will review the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾以下内容：
- en: System calls, including what they are, how to execute them, and the potential
    security risks associated with them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用，包括它们是什么，如何执行它们以及与它们相关的潜在安全风险
- en: The benefits of using C++ when system programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统编程时使用C++的好处
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow the examples in this chapter, the reader must have:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循本章的示例，读者必须具备：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: Understanding system calls
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解系统调用
- en: An operating system is a piece of software designed to execute one or more applications
    simultaneously, while also providing the resources needed for those applications
    to execute. To accomplish this, the operating system must be capable of dividing
    hardware resources between all the applications executing on the system at the
    same time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是一种旨在同时执行一个或多个应用程序的软件，同时还提供这些应用程序执行所需的资源。为了实现这一点，操作系统必须能够在同一时间将硬件资源分配给系统上执行的所有应用程序。
- en: For example, most **personal computers** (**PCs**) have a single hard disk that
    stores all the files being used by the owner of the PC. On modern PCs, it's likely
    the user will want to execute several applications at once—for example, a web
    browser and an office suite.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数个人电脑（PC）都有一个存储所有文件的硬盘，这些文件是PC所有者正在使用的。在现代PC上，用户可能希望同时执行几个应用程序，例如网络浏览器和办公套件。
- en: Both of these applications will need exclusive access to the hard disk at various
    times while executing. In the case of the web browser, this might be to cache
    websites to disk, while in the case of the office suite, this might be to store
    documents.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个应用程序都需要在执行时不同的时间独占访问硬盘。对于网络浏览器，这可能是将网站缓存到磁盘中，而对于办公套件，这可能是存储文档。
- en: It's the operating system's responsibility to manage the applications and their
    access to the hard disk, to ensure that both the web browser and the office suite
    are able to execute properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统有责任管理应用程序及其对硬盘的访问，以确保网络浏览器和办公套件都能正常执行。
- en: To accomplish this, operating systems provide an **application programming interface** (**API**)
    that applications can leverage to accomplish their tasks. Accessing the hard disk
    is an example of one of these tasks. The `read()` and `write()` functions are
    examples of APIs provided by POSIX-compliant operating systems for reading from
    and writing data to file descriptors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，操作系统提供了应用程序编程接口（API），应用程序可以利用这些接口来完成其任务。访问硬盘就是其中一个任务的例子。`read()`和`write()`函数是POSIX兼容操作系统提供的API的例子，用于从文件描述符读取和写入数据。
- en: Under the hood, these APIs make calls to the operating system using an **application
    binary interface** (**ABI**) called a **system call**. The act of making system
    calls to accomplish tasks provided by the operating system is called **system
    programming**, which is the main focus of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这些API使用称为系统调用的应用程序二进制接口（ABI）向操作系统发出调用。执行系统调用以完成操作系统提供的任务的行为称为系统编程，这是本书的主要重点。
- en: The anatomy of a system call
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用的解剖学
- en: For the purposes of this section, we will focus our examples on the Intel x86
    architecture, although these examples apply to most other CPU architectures.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注英特尔x86架构的示例，尽管这些示例适用于大多数其他CPU架构。
- en: The original x86 architecture leveraged interrupts to provide system call ABIs.
    The APIs provided by the operating system would program specific registers on
    the CPU, and make a call to the operating system using an interrupt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的x86架构利用中断提供系统调用ABI。操作系统提供的API将在CPU上编程特定寄存器，并使用中断调用操作系统。
- en: 'For example, using BIOS, an application could read data from a hard disk using
    `int 0x13` with the following register layout:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用BIOS，应用程序可以使用`int 0x13`从硬盘中读取数据，其寄存器布局如下：
- en: '`AH = 2`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AH = 2`'
- en: '`AL`: Sectors to read'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AL`：要读取的扇区'
- en: '`CH`: Cylinder'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CH`：柱面'
- en: '`CL`: Sector'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CL`：扇区'
- en: '`DH`: Head'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DH`：磁头'
- en: '`DL`: Drive'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DL`：驱动器'
- en: '`ES:BX`: Buffer address'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ES:BX`：缓冲区地址'
- en: The application author would use the `read()` API command to read this data,
    while under the hood, `read()` would perform the system call using the preceding
    ABI. When `int 0x13` executed, the application would be paused by the hardware,
    and the operating system (in this case, BIOS) would execute on behalf of the application
    to read data from the disk and return the result in the buffer provided by the
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序作者将使用`read()`API命令来读取这些数据，而在底层，`read()`将使用前面的ABI执行系统调用。当`int 0x13`执行时，应用程序将被硬件暂停，操作系统（在本例中为BIOS）将代表应用程序执行从磁盘中读取数据，并将结果返回到应用程序提供的缓冲区中。
- en: Once complete, BIOS would execute `iret` (interrupt return) to return to the
    application, which would then have the data read from disk waiting in its buffer
    to be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，BIOS将执行`iret`（中断返回）以返回到应用程序，然后应用程序将从磁盘中读取的数据等待在其缓冲区中以供使用。
- en: With this approach, the application doesn't need to know how to physically interface
    with the hard disk on that specific computer in order to read data; a task that
    is meant to be handled by the operating system and its device drivers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，应用程序不需要知道如何在特定计算机上与硬盘进行物理接口，以便读取数据；这是操作系统及其设备驱动程序应该处理的任务。
- en: The application doesn't have to worry about other applications that may be executing
    either. It can simply leverage the provided API (or ABI, depending on the operating
    system), and the rest of the gory details are handled by the operating system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序也不必担心可能正在执行的其他应用程序。它只需利用提供的API（或ABI，取决于操作系统），其余繁琐的细节由操作系统处理。
- en: In other words, system calls provide a clean delineation between applications,
    to help the user accomplish specific tasks, and to help the operating system whose
    job it is to manage these applications and the hardware resources they require.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，系统调用提供了应用程序之间的清晰界限，以帮助用户完成特定任务，并帮助操作系统管理这些应用程序和它们所需的硬件资源。
- en: Interrupts are, however, slow. The hardware makes no assumptions about how the
    operating system is written, or how the applications the operating system is executing
    are written or organized. For this reason, interrupts must save the CPU state
    before the interrupt handler is executed, and restore this state when the `iret`
    command is executed, leading to poor performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，中断是缓慢的。硬件不会对操作系统的编写方式或操作系统正在执行的应用程序的编写或组织方式做任何假设。因此，中断必须在执行中断处理程序之前保存CPU状态，并在执行`iret`命令时恢复此状态，导致性能不佳。
- en: As will be shown, applications make a lot of system calls when attempting to
    perform their job, and this poor performance became a bottleneck on x86 architectures
    (as well as other CPU architectures).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将要展示的那样，应用程序在尝试执行其任务时会进行大量的系统调用，这种性能不佳成为x86架构（以及其他CPU架构）的瓶颈。
- en: To solve this issue, modern versions of Intel x86 CPU provided *fast system
    call* instructions. These instructions were designed specifically to address the
    performance bottleneck of interrupt-driven system calls. However, they require
    coordination between the CPU, the operating system, and the applications executing
    on that operating system to reduce overhead.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，现代版本的Intel x86 CPU提供了*快速系统调用*指令。这些指令专门设计用于解决基于中断的系统调用的性能瓶颈。然而，它们需要CPU、操作系统和在该操作系统上执行的应用程序之间的协调，以减少开销。
- en: Specifically, the operating system must structure the memory layout of itself
    and the applications it's running in a specific way, dictated by the CPU. By predefining
    the memory layout of the operating system and its associated applications, the
    CPU no longer needs to save and restore as much CPU state when performing a system
    call, reducing overhead. How this is accomplished is different depending on whether
    you're executing on an Intel or AMD x86 CPU.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，操作系统必须以CPU指定的特定方式构造自身和正在运行的应用程序的内存布局。通过预定义操作系统及其相关应用程序的内存布局，CPU在执行系统调用时不再需要保存和恢复太多CPU状态，从而减少开销。如何实现这一点取决于您是在Intel还是AMD
    x86 CPU上执行。
- en: The most important thing to understand with respect to how a system call is
    performed is that a system call is not cheap. Even with fast system call support,
    a system call has to perform a lot of work. In the case of reading data from a
    hard disk via the `read()` API, the CPU register state must be set up and a system
    call instruction must be executed. CPU control is handed off to the operating
    system to read data from the disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统调用的执行方式最重要的一点是，系统调用并不廉价。即使有快速系统调用支持，系统调用也必须执行大量的工作。在通过`read()`API从硬盘读取数据的情况下，必须设置CPU寄存器状态并执行系统调用指令。CPU控制权被移交给操作系统，以从硬盘中读取数据。
- en: Since more than one application might be executing, and attempting to read data
    from the disk at the same time, the operating system might have to pause the application
    so that it can service another.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有多个应用程序正在执行，并且尝试同时从硬盘中读取数据，因此操作系统可能必须暂停应用程序，以便为另一个应用程序提供服务。
- en: Once the operating system is ready to service the application, it must first
    figure out what data the application is attempting to read, which ultimately determines
    which physical device it needs to work with. In our example, this is a hard disk,
    but on a POSIX-compliant system it could be any type of block device.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作系统准备好为应用程序提供服务，它必须首先弄清楚应用程序试图读取的数据，这最终决定了它需要与哪个物理设备进行交互。在我们的例子中，这是一个硬盘，但在符合POSIX标准的系统中，它可以是任何类型的块设备。
- en: Next, the operating system must leverage one of its device drivers to read data
    from this disk. This takes time, as the operating system has to physically program
    the hard disk to ask for data from a specific location, over a hardware bus that
    almost certainly is not executing at the same speed as the CPU itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，操作系统必须利用其设备驱动程序之一从这个硬盘中读取数据。这需要时间，因为操作系统必须在硬盘上物理编程，要求从特定位置请求数据，通过一个几乎肯定不以与CPU本身相同的速度执行的硬件总线。
- en: Once the hard disk finally provides the operating system with the requested
    data, the operating system can provide this information back to the application
    and return control, restoring the CPU state to the application. All of this insanity
    is obscured by a single call to `read()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦硬盘最终向操作系统提供所请求的数据，操作系统可以将这些信息提供给应用程序，并返回控制权，将CPU状态恢复给应用程序。所有这些繁琐的工作都被一个`read()`调用所隐藏。
- en: For this reason, system calls should be executed sparingly, and only when absolutely
    needed, to prevent the poor performance of the resulting application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系统调用应该谨慎执行，只在绝对需要时执行，以防止导致应用程序性能不佳。
- en: It should be noted that this type of optimization requires a deep understanding
    of the APIs the application leverages, as higher-level APIs make their own system
    calls on the API's behalf. For example, allocating memory, as will be discussed
    later, is another type of system call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种优化类型需要对应用程序利用的API有深入的了解，因为更高级的API会代表API自己进行系统调用。例如，分配内存，稍后将讨论，也是另一种系统调用。
- en: For example, look at the difference between using an `std::array{}` or a `std::vector{}`
    command. `std::vector{}` supports resizing of the array being managed under the
    hood, which requires memory allocation. This can not only lead to memory fragmentation
    (a topic that will be discussed later on in this book), but also poor performance,
    as the memory allocation might have to ask the operating system for more system
    RAM.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看使用`std::array{}`或`std::vector{}`命令之间的区别。`std::vector{}`支持在底层管理的数组大小调整，这需要内存分配。这不仅可能导致内存碎片化（这本书后面将讨论的一个主题），还可能导致性能不佳，因为内存分配可能需要向操作系统请求更多的系统RAM。
- en: Learning about different types of system calls
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同类型的系统调用
- en: Almost every application that executes on a POSIX-compliant operating system
    must make a couple of system calls. Here, we outline some of the system call types
    that will be explored in this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在符合POSIX标准的操作系统上执行的每个应用程序都必须进行一些系统调用。在这里，我们概述了本书中将探讨的一些系统调用类型。
- en: Console input/output
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台输入/输出
- en: If you have ever executed a command-line application, you willbe familiar with
    the concept of console-based input/output. This is especially true with respect
    to POSIX-compliant operating systems. When outputting to the console, you can
    either output to `stdout` (typically used for normal output) or `stderr` (typically
    used for outputting error messages).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经执行过命令行应用程序，您将会熟悉基于控制台的输入/输出的概念。这在符合POSIX标准的操作系统中尤其如此。在向控制台输出时，您可以将输出发送到`stdout`（通常用于正常输出）或`stderr`（通常用于输出错误消息）。
- en: Outputting to `stdout` and `stderr` is accomplished by an application performing
    a system that asks the operating system to deliver a character buffer to these
    output devices. (It should be noted that, in this book, we typically state that
    we are *outputting to* `stdout`, not *printing to the console*.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序执行系统调用来输出到`stdout`和`stderr`。 （值得注意的是，在本书中，我们通常说我们*输出到*`stdout`，而不是*打印到控制台*。）
- en: 'The reason for this is that, on POSIX-compliant systems, your application doesn''t
    actually know where it is sending the text to. The application leverages an API
    to output to `stdout`. This can be accomplished by:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在符合POSIX标准的系统上，您的应用程序实际上并不知道将文本发送到哪里。应用程序利用API输出到`stdout`。这可以通过以下方式实现：
- en: Writing to a dedicated file handle (that is, `stdout`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入专用文件句柄（即`stdout`）
- en: Using C APIs such as `printf`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C API，如`printf`
- en: Using C++ APIs such as `std::cout`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++ API，如`std::cout`
- en: Forking an application that outputs to `stdout` for you (for example, by using
    `echo`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您输出到`stdout`的应用程序分叉（例如，使用`echo`）
- en: Most of these examples, when all is said and done, make a system call to the
    operating system to transfer a character buffer to a device that manages `stdout`
    or `stderr`. In some cases, this causes the operating system to relay the resulting
    character buffer to the parent process (likely your shell), which will ultimately
    make another system call to display the character buffer on the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些示例在说到底都会向操作系统发出系统调用，将字符缓冲区传输到管理`stdout`或`stderr`的设备。在某些情况下，这会导致操作系统将生成的字符缓冲区传递给父进程（可能是您的shell），最终父进程会再次进行系统调用，将字符缓冲区显示在屏幕上。
- en: However your operating system decides to handle this, a device driver exists
    in the operating system that manages the physical monitor used to display text,
    and the simple APIs the application calls to output text (for example, `printf`
    and `std::cout`) eventually provide this device driver with the requested character
    buffer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的操作系统如何处理，操作系统中存在一个设备驱动程序，用于管理用于显示文本的物理监视器，应用程序调用的简单API（例如`printf`和`std::cout`）最终会向该设备驱动程序提供所请求的字符缓冲区。
- en: Although, on most systems, the text being output to `stdout` is usually provided
    to your shell and eventually displayed on the screen, this doesn't have to be
    the case. Since the application is making a system call to output the character
    buffer, the operating system is free to forward this data to a serial device,
    log file, as input to another application, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数系统上，输出到`stdout`的文本通常会提供给您的shell，并最终显示在屏幕上，但这并非一定如此。由于应用程序正在进行系统调用以输出字符缓冲区，因此操作系统可以自由地将这些数据转发到串行设备、日志文件、作为另一个应用程序的输入等。
- en: This flexibility is one of the reasons POSIX-compliant operating systems are
    so powerful, and why learning how to properly make system calls is so important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性是符合POSIX标准的操作系统如此强大的原因之一，也是学习如何正确进行系统调用如此重要的原因。
- en: Memory allocation
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: Memory is another resource that an application must request using a system call.
    Most applications are given global and stack memory resources when the application
    is first executed, along with a small heap of memory that the application can
    use when calls to functions such as `malloc()` and `free()` are made.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是应用程序必须使用系统调用请求的另一种资源。当应用程序首次执行时，大多数应用程序会获得全局和堆栈内存资源，以及应用程序在调用诸如`malloc()`和`free()`等函数时可以使用的一小块堆内存。
- en: If the application only uses the memory that it is initially given in this heap,
    no extra memory needs to be requested by the application. If, however, heap memory
    runs out, the application's `malloc()` or `free()` engine will have to ask the
    operating system (via a system call) for more memory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序只使用最初在堆中给定的内存，那么应用程序不需要请求额外的内存。然而，如果堆内存用尽，应用程序的`malloc()`或`free()`引擎将不得不向操作系统（通过系统调用）请求更多内存。
- en: To do this, the operating system will extend the end of the application by adding
    more physical memory to the application. The `malloc()` or `free()` engine is
    then able to make use of this additional memory, until more is needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，操作系统将通过向应用程序添加更多的物理内存来扩展应用程序的末端。然后，`malloc()`或`free()`引擎能够利用这些额外的内存，直到需要更多内存。
- en: On systems with limited RAM, when a request for additional memory is made, the
    operating system has to take memory from other applications that aren't currently
    executing. It does this by swapping these applications to disk, an operation that
    is expensive to perform.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存有限的系统上，当请求额外的内存时，操作系统必须从当前未执行的其他应用程序中获取内存。它通过将这些应用程序交换到磁盘上来实现这一点，这是一种昂贵的操作。
- en: For this reason, on resource-constrained systems, calls to `malloc()` or `free()`
    should not be made in time-critical code, as the time it takes to execute these
    functions can vary greatly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在资源受限的系统上，不应该在时间关键的代码中调用`malloc()`或`free()`，因为执行这些函数所需的时间可能会有很大的变化。
- en: We will go into further detail on memory management in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中更详细地介绍内存管理，*全面了解内存管理*。
- en: File input/output
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: Reading and writing to a file is another common use case for most applications
    that requires making system calls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 读写文件是大多数应用程序的另一个常见用例，需要进行系统调用。
- en: It should be noted that on POSIX-compliant systems, reading and writing to a
    file descriptor doesn't always mean reading and writing to a file on a storage
    device. Instead, the system calls you make write to *character* or *block* devices.
    This could be a storage device, but could also be a console device, or even a
    virtual device such as `/dev/random`, which provides random data when read.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在符合POSIX的系统上，读取和写入文件描述符并不总是意味着读取和写入存储设备上的文件。相反，您所做的系统调用会写入*字符*或*块*设备。这可能是一个存储设备，但也可能是一个控制台设备，甚至是一个虚拟设备，比如`/dev/random`，在读取时提供随机数据。
- en: In [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning to Program
    File Input/Output*, we will provide more information about file input/output system
    programming.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中，*学习文件输入/输出编程*，我们将提供有关文件输入/输出系统编程的更多信息。
- en: Networking
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: Networking is another common use case that requires making system calls. On
    POSIX-compliant systems, we perform network-based system programming by working
    with POSIX sockets. Sockets provide an API for programming the **Network Interface
    Controller** (**NIC**), and support logic (for example, the TCP/IP stack) within
    the operating system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是另一个常见的用例，需要进行系统调用。在符合POSIX的系统上，我们通过使用POSIX套接字进行基于网络的系统编程。套接字提供了与操作系统中的**网络接口控制器**（**NIC**）和支持逻辑（例如TCP/IP协议栈）进行编程的API。
- en: Networking itself is an extremely complicated topic, deserving of its own book,
    but thankfully, the system calls needed to perform this type of programming are
    simple, with the majority of the gory details being handled by the operating system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 网络本身是一个非常复杂的主题，值得有一本专门的书来讨论，但幸运的是，执行这种类型的编程所需的系统调用是简单的，大部分繁琐的细节由操作系统处理。
- en: In [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming POSIX
    Sockets Using C++*, we will go into further detail on how to make these types
    of system calls using the socket API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml)中，*使用C++编程POSIX套接字*，我们将更详细地介绍如何使用套接字API进行这些类型的系统调用。
- en: Time
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Some readers might find it surprising to know that even performing simple tasks
    such as getting the current date and time require system calls to ask the operating
    system for this information. Even to this day, a dedicated chip (with a battery,
    in case of loss of power) is provided on the system to maintain the current date
    and time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会感到惊讶，甚至执行简单的任务，如获取当前日期和时间，都需要系统调用来向操作系统请求这些信息。直到今天，系统上都提供了一个专用芯片（带有电池，以防断电）来维护当前的日期和时间。
- en: If this information is needed, a system call must be made to request it. When
    this happens, the operating system will ask the device driver responsible for
    managing the chip what date and time it is currently storing, and then this information
    will be returned to the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要这些信息，必须进行系统调用来请求。当这种情况发生时，操作系统将询问负责管理芯片的设备驱动程序当前存储的日期和时间，然后将此信息返回给应用程序。
- en: It should be noted that not all time interfaces require system calls. For example,
    most high-resolution timers, which are designed to compare a high-resolution number
    before and after an operation has taken place, do not need the operating system
    to perform this action. This is because these high-resolution timers usually exist
    directly in the CPU, and their values can be extracted using a simple instruction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，并非所有时间接口都需要系统调用。例如，大多数高分辨率定时器，它们旨在在操作发生前后比较高分辨率数字，不需要操作系统执行此操作。这是因为这些高分辨率定时器通常直接存在于CPU中，并且它们的值可以使用简单的指令提取。
- en: The downside to these types of timers is that their values in and of themselves
    are usually meaningless (that is, the difference between the values returned is
    what provides meaning, not the values themselves). Essentially, these timers are
    usually nothing more than a counter that increments each time the CPU ticks (that
    is, executes an instruction).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的定时器的缺点是它们的值本身通常是没有意义的（也就是说，返回的值之间的差异才提供了意义，而不是值本身）。基本上，这些定时器通常只是一个计数器，每次CPU滴答（也就是执行一条指令）时递增。
- en: Since modern CPUs can dynamically change their frequency, the values these counters
    store depends on how long the CPU has executed since the previous power cycle,
    and at what frequency the CPU was set while it was executing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代CPU可以动态改变其频率，这些计数器存储的值取决于CPU自上次上电以来执行的时间长短，以及CPU在执行时设置的频率。
- en: There isn't even a guarantee that the value in one counter will be the same
    as the value read in another counter on another physical core, as each physical
    core is capable of changing its own frequency independently of other cores on
    multi-core CPUs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至不能保证一个计数器中的值与另一个物理核上的另一个计数器中读取的值相同，因为每个物理核都能够独立于多核CPU上的其他核改变自己的频率。
- en: The benefit of high-resolution timers is that they can be executed extremely
    quickly (as you are just executing an instruction that reads a counter in the
    CPU). The difference between two measured values can be used to carry out tasks
    such as measuring how long it takes to execute small functions—a task that usually
    doesn't work with standard timers, as they don't have enough granularity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 高分辨率定时器的好处是它们可以非常快地执行（因为您只是执行一个读取CPU中计数器的指令）。两个测量值之间的差异可以用来执行诸如测量执行小函数所需时间的任务，这通常无法使用标准定时器完成，因为它们没有足够的粒度。
- en: In [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml), *Time Interfaces
    in Unix*, we will go over these details and even provide an example of how to
    do this yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml)中，《Unix中的时间接口》，我们将详细介绍这些细节，甚至提供如何自己实现的示例。
- en: Threading and process creation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和进程创建
- en: Executing multiple tasks simultaneously can be accomplished by asking the operating
    system to create additional threads (or even new processes). This is a common
    task in system programming, and there are numerous system calls to get the job
    done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同时执行多个任务可以通过请求操作系统创建额外的线程（甚至新进程）来实现。这是系统编程中的常见任务，有许多系统调用可以完成这项工作。
- en: A process is a unit of execution that has a set of resources assigned to it
    (for example, memory, file descriptors, and so on.) Each application is made up
    of at least one process, but they can contain more than one (for example, a shell
    is an application that is specifically designed to run several child processes).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是一个执行单元，为其分配了一组资源（例如内存、文件描述符等）。每个应用程序至少由一个进程组成，但它们可以包含多个进程（例如，shell是一个专门设计用于运行多个子进程的应用程序）。
- en: Each process is scheduled by the operating system to execute for a limited amount
    of time before the next process is given access to the CPU, and this cycle continues
    as needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程由操作系统安排执行一定的时间，然后下一个进程获得CPU的访问权限，这个循环根据需要继续进行。
- en: Threads are like processes, but they share the same resources as other threads
    of the same process. Threads provide an application with an opportunity to create
    tasks that are capable of executing in parallel, without the need for inter-process
    communication methods. In [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),
    *Learning to Program POSIX and C++ Threads*, we will learn how to program threads
    using both POSIX and C++ APIs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 线程类似于进程，但它们与同一进程的其他线程共享相同的资源。线程为应用程序提供了一个机会，可以创建能够并行执行的任务，而无需使用进程间通信方法。在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中，《学习使用POSIX和C++线程编程》，我们将学习如何使用POSIX和C++
    API编程线程。
- en: System call security risks
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用安全风险
- en: System calls are not without their security risks. Even on modern hardware,
    and using CPU architectures other than Intel, executing more than one process
    within an operating system with full isolation between processes is nearly impossible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用并非没有安全风险。即使在现代硬件上，使用英特尔以外的CPU架构，在操作系统中执行多个进程并实现进程之间的完全隔离几乎是不可能的。
- en: Although modern hardware and modern operating systems work hard to provide the
    best possible isolation and security, it should always be assumed that other,
    malicious processes executing alongside yours may be able to spy on what you're
    doing, including sensitive tasks such as decrypting user data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代硬件和现代操作系统都在努力提供最佳的隔离和安全性，但应始终假定与您同时执行的其他恶意进程可能能够窥探您的操作，包括解密用户数据等敏感任务。
- en: This is another topic that deserves its own book, but here, we will briefly
    discuss two different, recent security vulnerabilities that affect system programming.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个值得一本专门书籍的主题，但在这里，我们将简要讨论影响系统编程的两种不同的最近的安全漏洞。
- en: SYSRET
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SYSRET
- en: The *fast system call* interface provided by Intel and AMD was not without its
    issues. As stated previously, for fast system calls to work, the hardware, operating
    system, and applications must coordinate. This is to ensure that ABI information
    is handled properly, to allow the operating system to execute a system call without
    the need for the hardware to save the entire CPU state before execution begins.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔和AMD提供的*快速系统调用*接口并非没有问题。如前所述，为了使快速系统调用正常工作，硬件、操作系统和应用程序必须协调。这是为了确保ABI信息得到正确处理，以允许操作系统在执行系统调用之前无需硬件保存整个CPU状态。
- en: The same applies when the system call is complete, and control must be handed
    back to the application. To accomplish this, the operating system must load the
    application's stack, and then execute the `SYSRET` instruction, which returns
    control to the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统调用完成并且必须将控制权交还给应用程序时也是如此。为了实现这一点，操作系统必须加载应用程序的堆栈，然后执行`SYSRET`指令，将控制权返回给应用程序。
- en: The problem with this approach is that a **non-maskable interrupt** (**NMI**)
    could fire between the operating system loading the application's stack and the
    execution of `SYSRET`. The result of this race condition is that an NMI (which
    is code that executes with root privileges) would be executed using the application's
    stack and not the kernel's stack, resulting in a possible security vulnerability
    or corruption.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于**不可屏蔽中断**（NMI）可能会在操作系统加载应用程序的堆栈和执行`SYSRET`之间触发。这种竞争条件的结果是，NMI（以根权限执行的代码）将使用应用程序的堆栈而不是内核的堆栈执行，从而可能导致安全漏洞或损坏。
- en: Thankfully, there are ways for modern operating systems to prevent this type
    of attack, which most operating systems, such as Linux, can and do leverage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，现代操作系统有办法防止这种类型的攻击，大多数操作系统，如Linux，都可以并且确实利用这些方法。
- en: Meltdown and Spectre
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meltdown和Spectre
- en: The Meltdown and Spectre attacks are a modern examples of just how complicated
    system calls are to implement. To support the fast execution of system calls,
    the kernel's memory is mapped into each application using a memory layout technical
    called the 3:1 split, which refers to the three-to-one ratio of application memory
    to kernel memory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 熔断和幽灵攻击是系统调用实现的复杂性的现代例子。为了支持系统调用的快速执行，内核的内存被映射到每个应用程序中，使用一种称为3:1分割的内存布局技术，指的是应用程序内存与内核内存的三比一的比例。
- en: To prevent an application from reading/writing kernel memory, which may or may
    not contain highly-sensitive information such as encryption keys and passwords,
    modern CPU architectures provide a mechanism to lock down the kernel portion of
    this memory, such that only the kernel is capable of seeing it all. The application
    is only able to see its deprivileged portion of that memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止应用程序读取/写入内核内存，这些内核内存可能包含高度敏感的信息，如加密密钥和密码，现代CPU架构提供了一种机制来锁定内核内存的部分，以便只有内核能够看到所有内容。应用程序只能看到其部分特权内存。
- en: 'To improve the performance of these modern CPUs, most architectures, including
    Intel, AMD, and ARM, incorporate a technology called **speculative execution**.
    For example, look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这些现代CPU的性能，包括英特尔、AMD和ARM在内的大多数架构都采用了一种称为**推测执行**的技术。例如，看下面的代码：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The CPU doesn't know whether `x` is true or false until it executes this instruction.
    If the CPU assumes that `x` is true, it can enhance performance by saving some
    CPU cycles. If `x` does, in fact, end up being true, the CPU saves cycles, whereas
    if `x` is actually false, the penalty is usually worth the risk, especially if
    the CPU can make an educated guess as to the likelihood of `x` being true instead
    of false (for example, if the CPU executed this statement in the past and `x`
    was true).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CPU在执行这条指令之前不知道`x`是真还是假。如果CPU假设`x`是真，它可以通过节省一些CPU周期来提高性能。如果`x`实际上是真的，CPU就能节省周期，而如果`x`实际上是假的，惩罚通常是值得冒的风险，特别是如果CPU能够对`x`是真还是假进行合理猜测（例如，如果CPU在过去执行过这个语句并且`x`是真的）。
- en: This type of optimization is called *speculative execution*. The CPU is executing
    code, even though it's possible the code may later turn out to be invalid and
    need to be undone.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化称为*推测执行*。CPU正在执行代码，即使可能以后代码可能被证明是无效的并需要撤销。
- en: Speculative execution attacks such as Meltdown and Spectre exploit this process
    to bypass the memory protections that protect the system call interface between
    an application and its kernel. This is done by convincing the CPU to speculatively
    execute an instruction that would typically cause a security violation (for example,
    attempting to read a password from kernel memory).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像熔断和幽灵这样的推测执行攻击利用这一过程，绕过保护系统调用接口的内存保护，这个接口位于应用程序和其内核之间。这是通过说服CPU进行推测执行一个通常会导致安全违规的指令（例如，尝试从内核内存中读取密码）来完成的。
- en: If the CPU speculatively executes this type of instruction, there will be a
    gap between the CPU loading the password into the CPU's cache, and the CPU figuring
    out that a security violation has occurred. If the CPU is interrupted during this
    gap (using what is called a transient instruction), the password will be left
    in the CPU's cache, even though the instruction never actually completed its execution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CPU推测执行这种类型的指令，CPU将在CPU加载密码到CPU缓存和CPU发现发生安全违规之间存在一个间隙。如果CPU在这个间隙期间被中断（使用所谓的瞬态指令），密码将留在CPU缓存中，即使指令实际上并没有完成执行。
- en: To recover the password from the cache, attackers leverage additional attacks
    on the CPU called **side-channel attacks**, which are specifically designed to
    read the contents of a CPU's cache without performing a direct memory operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从缓存中恢复密码，攻击者利用了对CPU的额外攻击，称为**侧信道攻击**，这些攻击专门设计用来读取CPU缓存的内容，而不执行直接的内存操作。
- en: The end result is that an attacker is capable of setting up an elaborate set
    of conditions that will eventually allow them to recover sensitive information
    stored in the kernel, using nothing more than an unprivileged application (which
    could be a website you happened to click on while looking for cat videos).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，攻击者能够设置一系列复杂的条件，最终允许他们使用一个非特权应用程序（可能是你在寻找猫视频时点击的网站）恢复存储在内核中的敏感信息。
- en: If this seems complicated, that's because it is. These types of attacks are
    extremely sophisticated. The goal of these examples is to provide a brief overview
    of why system calls are not without their issues. Depending on the CPU and operating
    system you're executing on, you might have to take special care when handling
    sensitive information while system programming.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很复杂，那是因为它确实很复杂。这些类型的攻击非常复杂。这些例子的目标是提供关于系统调用并非没有问题的简要概述。根据你所执行的CPU和操作系统，你在处理敏感信息时可能需要特别小心。
- en: Benefits of using C++ when system programming
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在系统编程时使用C++的好处
- en: Although the focus of this book is on system programming and not C++, and we
    do provide a lot of examples in C, there are several benefits to system programming
    in C++ compared to standard C.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的重点是系统编程而不是C++，我们确实提供了很多C++的例子，但与标准C相比，C++在系统编程中有几个好处。
- en: Note that this section assumes some general knowledge of C++. A more complete
    explanation of the C++ standard will be provided in [Chapter 2](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml),
    *Learning the C, C++17, and POSIX Standards*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节假定读者对C++有一些基本知识。有关C++标准的更完整解释将在[第2章](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml)中提供，*学习C、C++17和POSIX标准*。
- en: Type safety in C++
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的类型安全
- en: Standard C is not a type-safe language. Type safety refers to protections put
    in place to prevent one type from being confused with another type. Some languages,
    such as ADA, are extremely type-safe, providing so many protections that the language,
    at times, can be frustrating to work with.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C不是一种类型安全的语言。类型安全是指为防止一种类型与另一种类型混淆而采取的保护措施。一些语言，如ADA，非常类型安全，提供了许多保护措施，以至于有时使用该语言可能会令人沮丧。
- en: Conversely, languages such as C are so type-unsafe that hard-to-find type errors
    occur frequently, and often lead to instability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，像C这样的语言是如此不安全，以至于很难找到类型错误，而且经常导致不稳定性。
- en: C++ provides a compromise between the two approaches, encouraging reasonable
    type safety by default, while providing mechanisms to circumvent this when needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++在这两种方法之间提供了一个折衷方案，鼓励默认情况下合理的类型安全性，同时在需要时提供规避这一点的机制。
- en: 'For example, consider the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Allocating an integer on the heap in C requires the use of `malloc()`, which
    returns `void *`. There are several issues with this code that are addressed in
    C++:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中在堆上分配整数需要使用`malloc()`，它返回`void *`。这段代码存在几个问题，在C++中得到了解决：
- en: C automatically converts the `void *` type to `int *`, meaning that an implicit
    type conversion has occurred even though there is no connection between the type
    the user stated and the type returned. The user could easily allocate `short`
    (which is not the same thing as `int`, a topic we will discuss in [Chapter 3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml),
    *System Types for C and C++*). The type conversion would still be applied, meaning
    that the compiler would not have the proper context to detect that the allocation
    was not large enough for the type the user was attempting to allocate.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C自动将`void *`类型转换为`int *`，这意味着即使用户声明的类型与返回的类型之间没有连接，隐式类型转换仍然发生了。用户可以轻松地分配`short`（这与`int`不同，这是我们将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论的一个主题，*C和C++的系统类型*）。类型转换仍然会被应用，这意味着编译器无法正确地检测到分配的空间对于用户尝试分配的类型来说不够大。
- en: The size of the allocation must be stated by the programmer. Unlike C++, C has
    no understanding of the type that is being allocated. Thus, it is unaware of the
    size of the type, and so the programmer must explicitly state this. The problem
    with this approach is that hard-to-find allocation bugs can be introduced. Often,
    the type that is provided to `sizeof()` is incorrect (for example, the programmer
    might provide a pointer instead of the type itself, or the programmer might change
    the code later on, but forget to change the value being provided to `sizeof()`).
    As stated previously, there is no connection between what `malloc()` allocates
    and returns, and the type the user attempts to allocate, providing an opportunity
    to introduce a hard-to-find logic error.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员必须声明分配的大小。与C++不同，C不了解正在分配的类型。因此，它不知道类型的大小，因此程序员必须明确声明这一点。这种方法的问题在于可能引入难以发现的分配错误。通常，提供给`sizeof()`的类型是不正确的（例如，程序员可能提供指针而不是类型本身，或者程序员可能稍后更改代码，但忘记更改提供给`sizeof()`的值）。如前所述，`malloc()`分配和返回的内容与用户尝试分配的类型之间没有关联，这提供了引入难以发现的逻辑错误的机会。
- en: The type must be explicitly stated twice. `malloc()` returns `void *`, but C
    implicitly converts to whatever pointer type the user states—which means a type
    has been declared twice (in this case, `void *` and `int *`). In C++, the use
    of `auto` means that the type is only declared once (in this case, `int` states
    the type is an `int *`), and `auto` will take on whatever type is returned. The
    use of `auto` and the removal of implicit type conversions means whatever type
    is declared in the allocation is what the `p` variable will take on. If the code
    after this allocation expects a different type to the one `p` takes on, the compiler
    will know about it at compile time in C++, while a bug like this would likely
    not be caught in C until runtime, when the program crashes (we hope this code
    is not controlling an airplane!).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须明确声明两次。`malloc()`返回`void *`，但C隐式转换为用户声明的任何指针类型，这意味着类型已经声明了两次（在这种情况下，`void
    *`和`int *`）。在C++中，使用`auto`意味着类型只声明一次（在这种情况下，`int`表示类型是`int *`），并且`auto`将采用返回的任何类型。使用`auto`和去除隐式类型转换意味着分配中声明的任何类型都是`p`变量将采用的类型。如果在此分配后的代码期望`p`采用不同的类型，编译器将在C++中在编译时知道这一点，而在C中，这样的错误可能直到运行时才会被捕获，当程序崩溃时（我们希望这段代码不控制飞机！）。
- en: In addition to the preceding example of the dangers of implicit type casting,
    C++ also provides **run-time type information** (**RTTI**). This information has
    many uses, but the most important use case involves the `dynamic_cast<>` operator,
    which performs runtime type checking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隐式类型转换的危险示例之外，C++还提供了**运行时类型信息**（**RTTI**）。这些信息有许多用途，但最重要的用例涉及`dynamic_cast<>`运算符，它执行运行时类型检查。
- en: 'Specifically, converting from one type to another can be checked during runtime,
    to ensure a type error doesn''t occur. This is often seen when performing the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，可以在运行时检查从一种类型转换为另一种类型，以确保不会发生类型错误。这在执行以下操作时经常看到：
- en: '**Polymorphic type conversions**: In C, polymorphism is possible, but it must
    be done manually, a pattern that is seen often in kernel programming. C, however,
    doesn''t have the ability to determine whether a pointer was allocated for a base
    type or not, resulting in the potential for a type error. Conversely, C++ is capable
    of determining at runtime whether a provided pointer is being cast to the proper
    type, including when using polymorphism.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态类型转换**：在C中，多态是可能的，但必须手动完成，这是内核编程中经常见到的模式。然而，C无法确定指针是否为基本类型分配，从而导致可能出现类型错误的可能性。相反，C++能够在运行时确定提供的指针是否被转换为正确的类型，包括在使用多态性时。'
- en: '**Exception support**: When catching an exception, C++ uses RTTI (essentially
    `dynamic_cast<>`), to ensure that the exception being thrown is caught by the
    proper handler.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常支持**：在捕获异常时，C++ 使用 RTTI（本质上是 `dynamic_cast<>`）来确保被抛出的异常被适当的处理程序捕获。'
- en: Objects of C++
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 对象
- en: 'Although C++ supports object-oriented programming with built-in constructs,
    object-oriented programming is a design pattern that is often used in C as well,
    and in POSIX in general. Take the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 C++ 支持使用内置构造进行面向对象编程，但面向对象编程也经常在 C 中以及 POSIX 中使用。看下面的例子：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have a struct that stores a `point{}`, which contains `x`
    and `y` positions. We then offer a function that is capable of translating this
    `point{}` in both the `x` and `y` positions, using a given value (that is, a diagonal
    translation).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个存储 `point{}` 的结构体，其中包含 `x` 和 `y` 位置。然后我们提供一个函数，能够使用给定的值（即对角线平移）来翻译这个
    `point{}` 的 `x` 和 `y` 位置。
- en: 'There are a couple of notes with respect to this example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个例子，有几点需要注意：
- en: Often, people will claim to dislike object-oriented programming, but then you
    see this sort of thing in their code, which is, in fact, an object-oriented design.
    The use of class isn't the only way to create an object-oriented design. The difference
    with C++ is that the language provides additional constructs for cleanly and safely
    working with objects, while with C this same functionality must be done by hand—a
    process that is prone to error.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们经常声称不喜欢面向对象的编程，但是在他们的代码中却会看到这种情况，实际上这是一种面向对象的设计。使用类并不是创建面向对象设计的唯一方式。C++ 的不同之处在于语言提供了额外的构造来清晰、安全地处理对象，而在
    C 中，这个功能必须手动完成，这个过程容易出错。
- en: The `translate()` function is only related to the `point{}` object because it
    takes a `point{}` as a parameter. As a result, the compiler has no contextual
    information to understand how to manipulate a `point{}` struct, without `translate()` being
    given a pointer to it as a parameter. This means that every single public-facing
    function that wishes to manipulate a `point{}` struct must take a pointer to it
    as its first parameter, and verify that the pointer is valid. Not only is this
    a clunky interface, it's slow.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate()` 函数只与 `point{}` 对象相关，因为它将 `point{}` 作为参数。因此，编译器没有上下文信息来理解如何操作
    `point{}` 结构，没有给 `translate()` 提供指针作为参数。这意味着每个公共函数都必须以指针作为第一个参数来操作 `point{}` 结构，并验证指针是否有效。这不仅是一个笨拙的接口，而且速度慢。'
- en: 'In C++, the preceding example can be written as the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，前面的例子可以写成如下形式：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, a struct is still used. The only difference between a class and
    a struct in C++ is that all variables and functions are public by default with
    a struct, while they are private by default with a class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，仍然使用了一个 `struct`。C++ 中类和结构体的唯一区别是，结构体中的所有变量和函数默认都是公共的，而类中默认是私有的。
- en: The difference is that the `translate()` function is a member of `point{}`,
    which means it has access to the contents of its structure, and so no pointers
    are needed to perform the translation. As a result, this code is safer, more deterministic,
    and easier to reason about, as there is never the fear of a null dereference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于 `translate()` 函数是 `point{}` 的成员，这意味着它可以访问其结构的内容，因此不需要指针来执行翻译。因此，这段代码更安全、更确定，并且更容易理解，因为永远不会出现空指针解引用的情况。
- en: 'Finally, objects in C++ provide construction and destruction routines that
    help prevent objects from not being properly initialized or properly deconstructed.
    Take the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++ 中的对象提供了构造和销毁例程，有助于防止对象未被正确初始化或正确销毁。看下面的例子：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we create a custom file object that holds a file descriptor,
    often seen and used when system programming with POSIX APIs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个自定义文件对象，它保存了一个文件描述符，在使用 POSIX API 进行系统编程时经常看到和使用。
- en: In C, the programmer would have to remember to manually set the file descriptor
    to `0` on initialization, and close the file descriptor when it is no longer in
    scope. In C++, using the preceding example, both of these operations would be
    done for you any time you use `myfile`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，程序员需要记住在初始化时手动将文件描述符设置为 `0`，并在不再使用时关闭文件描述符。在 C++ 中，使用前面的例子，每次使用 `myfile`
    时都会为您执行这两个操作。
- en: This is an example of the use of **Resource Acquisition Is Initialization**
    (**RAII**), a topic that will be discussed in more detail in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml), *C++,
    RAII, and the GSL Refresher*, as this pattern is used a lot by C++. We will leverage
    this technique when system programming to avoid a lot of common POSIX-style pitfalls.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用**资源获取即初始化**（**RAII**）的例子，这个主题将在 [第 4 章](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml)
    中详细讨论，*C++，RAII 和 GSL 刷新*，因为这种模式在 C++ 中经常被使用。在系统编程时，我们将利用这种技术来避免许多常见的 POSIX 风格陷阱。
- en: Templates used in C++
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中使用的模板
- en: Template programming is often an undervalued, misunderstood addition to C++
    that is not given enough credit. Most programmers need to look no further than
    attempting to create a generic linked list to understand why.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模板编程经常被低估和误解，它是 C++ 中一个没有得到足够赞扬的补充。大多数程序员只需要尝试创建一个通用链表就能理解为什么。
- en: C++ templates provides you with the ability to define your code without having
    to define type information ahead of time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 模板使您能够在不提前定义类型信息的情况下定义代码。
- en: 'One way to create a linked list in C is to use pointers and dynamic memory
    allocation, as seen in this simple example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中创建链表的一种方式是使用指针和动态内存分配，就像在这个简单的例子中看到的那样：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we store data in the linked list using `void *`.
    An example of how to use this is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `void *` 存储链表中的数据。使用方法如下：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are a few issues with this approach:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一些问题：
- en: This type of linked list is clearly not type-safe. The use of the data and the
    data's allocation are completely unrelated, requiring the programmer using this
    linked list to manage all of this without error.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型的链表显然不是类型安全的。数据的使用和数据的分配完全无关，需要使用这个链表的程序员在没有错误的情况下管理所有这些。
- en: A dynamic memory allocation is needed for both the nodes and the data. As was
    discussed earlier, memory allocations are slow as they require system calls.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点和数据都需要动态内存分配。正如前面讨论的，内存分配很慢，因为它们需要系统调用。
- en: In general, this code is hard to read and clunky.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总的来说，这段代码很难阅读，而且笨拙。
- en: Another way to create a generic linked list is to use macros. There are several
    implementations of these types of linked lists (and other data structures) floating
    around on the internet, which provide a generic implementation of a linked list
    without the need for dynamically allocating data. These macros provide the user
    with a way to define the data type the linked list will manage at compile time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通用链表的另一种方法是使用宏。在互联网上有几种这些类型的链表（和其他数据结构）的实现，它们提供了一个通用的链表实现，无需动态分配数据。这些宏为用户提供了一种在编译时定义链表将管理的数据类型的方法。
- en: The problem with these approaches, other than reliability, is these implementations
    use macros to implement template programming in a way that is far less elegant.
    In other words, the solution to adding generic data structures to C is to use
    C's macro language to manually implement template programming. The programmer
    would be better off just using C++ templates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可靠性之外，这些实现使用宏来实现模板编程的方式远不如优雅。换句话说，向C添加通用数据结构的解决方案是使用C的宏语言手动实现模板编程。程序员最好只使用C++模板。
- en: 'In C++, a data structure like a linked list can be created without having to
    declare the type the linked list is managing until it is declared, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以创建像链表这样的数据结构，而无需在声明之前声明链表管理的类型，如下所示：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, not only are we able to create a linked list without
    macros or dynamic allocations (and all the problems that come with the use of
    `void *` pointers), but we are also able to encapsulate the functionality, providing
    a cleaner implementation and user API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们不仅能够创建一个不需要宏或动态分配（以及使用`void *`指针带来的所有问题）的链表，而且还能够封装功能，提供更清晰的实现和用户API。
- en: One complaint that is often made about template programming is the amount of
    code it generates. Most code bloat from templates typically originates as a programming
    error. For example, a programmer might not realize that integers and unsigned
    integers are not the same types, resulting in code bloat when templates are used
    (as a definition for each type is created).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模板编程经常提出的一个抱怨是它生成的代码量。模板的大部分代码膨胀通常源于编程错误。例如，程序员可能没有意识到整数和无符号整数不是相同的类型，导致在使用模板时出现代码膨胀（因为为每种类型创建了一个定义）。
- en: Even aside from that issue, the use of macros would produce the same code bloat.
    There is no free lunch. If you want to avoid the use of dynamic allocation and
    type casting while still providing generic algorithms, you have to create an instance
    of your algorithm for each type you plan to use. If reliability is your goal,
    allowing the compiler to generate the code needed to ensure your program executes
    properly outweighs the disadvantages.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不考虑这个问题，使用宏也会产生相同的代码膨胀。没有免费的午餐。如果你想避免使用动态分配和类型转换，同时仍然提供通用算法，你必须为你计划使用的每种类型创建你的算法的实例。如果可靠性是你的目标，允许编译器生成确保程序正确执行所需的代码，将会超过这些缺点。
- en: Functional programming associated with C++
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与C++相关的函数式编程
- en: Functional programming is another addition to C++ that provides the user with
    compiler assistance, in the form of lambda functions. Currently, this must be
    carried out by hand in C.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是C++的另一个补充，它以lambda函数的形式为用户提供编译器的帮助。目前，这在C中必须手动完成。
- en: 'In C, a functional programming construct can be achieved using a callback.
    For example, consider the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，可以使用回调来实现函数式编程构造。例如，考虑以下代码：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code example, we create a `guard` function that locks a mutex,
    calls a function that operates on a value, and then unlocks the mutex on exit.
    We then create two functions, one that increments a value given to it, and one
    that decrements a value given to it. Finally, we create a function that instantiates
    a count, and then increments the count and decrements the count using the guard
    function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我们创建了一个`guard`函数，它锁定互斥锁，调用一个操作值的函数，然后在退出时解锁互斥锁。然后，我们创建了两个函数，一个增加给定的值，一个减少给定的值。最后，我们创建一个函数，实例化一个计数，然后使用`guard`函数递增计数和递减计数。
- en: 'There are a couple of issues with this code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在一些问题：
- en: The first issue is the need for pointer logic to ensure we can manipulate the
    variable we wish to operate on. We are also required to manually pass this pointer
    around to keep track of it. This makes the APIs clunky, as we have a lot of extra
    code that we have to write manually for such a simple example.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是需要指针逻辑来确保我们可以操作所需操作的变量。我们还需要手动传递这个指针来跟踪它。这使得API笨拙，因为我们必须为这样一个简单的例子手动编写大量额外的代码。
- en: The function signature of the helper functions is static. The guard function
    is a simple one. It locks a mutex, calls a function, and then unlocks it. The
    problem is that, since the parameters of the function must be known while writing
    the code instead of at compile time, we cannot reuse this function for other tasks.
    We will need to hand-write the same function for each function signature type
    we plan to support.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助函数的函数签名是静态的。`guard`函数是一个简单的函数。它锁定互斥锁，调用一个函数，然后解锁它。问题在于，由于在编写代码时必须知道函数的参数，而不是在编译时，我们无法将此函数重用于其他任务。我们需要手动为计划支持的每种函数签名类型编写相同的函数。
- en: 'The same example can be written using C++ as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下C++编写相同的示例：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the same functionality is provided, but without the
    need for pointers. In addition, the guard function is generic and can be used
    for more than one case. This is accomplished by leveraging both template programming
    and functional programming.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，提供了相同的功能，但不需要指针。此外，守卫函数是通用的，可以用于多种情况。这是通过利用模板编程和函数式编程实现的。
- en: The lambda provides the callback, but the parameters of the callback are encoded
    into the lambda's function signature, which is absorbed by the use of a template
    function. The compiler is capable of generating a version of the guard function
    for use that takes the parameters (in this case, a reference to the `count` variable)
    and storing it in the code itself, removing the need for users to do this by hand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda提供了回调，但是回调的参数被编码到lambda的函数签名中，这由模板函数的使用吸收。编译器能够生成一个用于接受参数（在本例中是对`count`变量的引用）并将其存储在代码本身中以供使用的守卫函数的版本，从而消除了用户手动执行此操作的需要。
- en: The preceding example will be used a lot in this book, especially when creating
    benchmarking examples, as this pattern gives you the ability to wrap functionality
    in code designed to time the execution of your callback.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，前面的例子将被大量使用，特别是在创建基准测试示例时，因为这种模式使您能够将功能包装在旨在计时回调执行的代码中。
- en: Error handling mechanism in C++
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的错误处理机制
- en: 'Error handling is another issue with C. The problem, at least until set jump
    exceptions were added, was that the only ways to get an error code from a function
    were as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是C的另一个问题。问题是，至少在添加了set jump异常之前，从函数获取错误代码的唯一方法是：
- en: Constrain the output of a function, so that certain output values from the function
    could be considered an error
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制函数的输出，以便将函数的某些输出值视为错误
- en: Get the function to return a structure, and then manually parse that structure
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取函数返回一个结构，然后手动解析该结构
- en: 'For example, consider the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding example provides a simple mechanism for outputting an error from
    a function without having to constrain the output of the function (for example,
    by assuming that `-1` is always an error).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子提供了一个简单的机制，用于从函数输出错误，而无需限制函数的输出（例如，假设`-1`始终是一个错误）。
- en: 'In C++, this can be implemented using the following C++17 logic:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以使用以下C++17逻辑来实现：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we were able to remove the need for a dedicated structure
    by leveraging `std::pair{}`, and we were able to remove the need to work with `std::pair{}`
    by leveraging an `initializer_list{}` and C++17-structured bindings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够通过利用`std::pair{}`来消除对专用结构的需求，并且通过利用`initializer_list{}`和C++17结构化绑定来消除对`std::pair{}`的需求。
- en: There is, however, an even easier method for handling errors without the need
    for checking the output of every function you execute, and that is to use exceptions.
    C provides exceptions through the set jump API, while C++ provides C++ exception
    support. Both of these will be discussed at length in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种更简单的处理错误的方法，而无需检查您执行的每个函数的输出，那就是使用异常。C通过set jump API提供异常，而C++提供C++异常支持。这两者将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中详细讨论，即*使用异常处理错误*。
- en: APIs and C++ containers in C++
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API和C++容器在C++中
- en: As well as the language primitives that C++ provides, it also comes with a **Standard
    Template Library** (**STL**) and associated APIs that greatly aid system programming.
    A good portion of this book will focus on these APIs, and how they support system
    programming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C++提供的语言原语外，它还带有**标准模板库**（STL）及相关API，这些API极大地帮助系统编程。本书的很大一部分将专注于这些API以及它们如何支持系统编程。
- en: It should be noted that the focus of this book is system programming and not
    C++, and for this reason, we do not cover C++ containers in any detail, but instead
    assume the reader has some general knowledge of what they are and how they work.
    With that said, C++ containers support system programming by preventing the user
    from having to re-write them manually.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，本书的重点是系统编程而不是C++，因此我们不会详细介绍C++容器，而是假设读者对它们是什么以及它们如何工作有一些基本知识。话虽如此，C++容器通过防止用户手动重写它们来支持系统编程。
- en: We teach students how to write their own data structures, not so that when they
    need a data structure they know how to write one, but instead so that, when they
    need one, they know which data structure to use and why. C++ already provides
    most, if not all, of the data structures you might need when system programming.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们教导学生如何编写自己的数据结构，不是为了当他们需要数据结构时知道如何编写一个，而是为了当他们需要一个时，知道使用哪种数据结构以及为什么。C++已经提供了大部分，如果不是全部，您在系统编程时可能需要的数据结构。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned what system programming is. We covered the general
    anatomy of a system call, different types of system calls, and some recent security
    issues with system calls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是系统编程。我们涵盖了系统调用的一般解剖，不同类型的系统调用以及一些最近与系统调用相关的安全问题。
- en: In addition, we covered the advantages of system programming with C++ instead
    of strictly using standard C. In the next chapter, we will cover the C, C++, and
    POSIX standards in detail and how they relate to system programming.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们讨论了使用C++进行系统编程的优势，而不仅仅是严格使用标准C。在下一章中，我们将详细介绍C、C++和POSIX标准以及它们与系统编程的关系。
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is system programming?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是系统编程？
- en: Prior to *fast system calls*, how were system calls executed?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*快速系统调用*之前，系统调用是如何执行的？
- en: What key change was made to support *fast system calls*?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持*快速系统调用*所做的关键更改是什么？
- en: Does allocating memory always result in a system call?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存是否总是导致系统调用？
- en: What type of execution do the Meltdown and Spectre attacks exploit?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Meltdown和Spectre攻击利用了什么类型的执行？
- en: What is type safety?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型安全？
- en: Provide at least one benefit to template programming in C++?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中模板编程至少提供一个好处是什么？
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
