- en: Networking and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和安全
- en: Network programming is becoming more and more popular. Most computers are connected
    to the internet, and more and more applications now rely on that. From simple
    program updates that might require an internet connection to applications that
    rely on a stable internet connection, network programming is becoming a necessary
    part of application development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程变得越来越受欢迎。大多数计算机都连接到互联网，越来越多的应用程序现在依赖于它。从可能需要互联网连接的简单程序更新到依赖稳定互联网连接的应用程序，网络编程已经成为应用程序开发的必要部分。
- en: The C++ language did not have support for networking until recent standard updates.
    Networking support has been postponed later standards, most probably until C++23\.
    However, we can prepare for that release beforehand by tackling a network application.
    We will also discuss the standard extension for networking and see what will it look
    like to have networking supported in the language. This chapter will concentrate
    on the main principles of networking and the protocols driving communication between
    devices. Designing a network application is a great addition to your skillset
    as a programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近的标准更新，C++语言才开始支持网络。网络支持已经推迟到了后续的标准，很可能要等到C++23。然而，我们可以通过处理网络应用程序来为发布做好准备。我们还将讨论网络的标准扩展，并看看语言中支持网络会是什么样子。本章将集中讨论网络的主要原则和驱动设备之间通信的协议。设计网络应用程序是作为程序员技能的重要补充。
- en: One of the major problems developers face regularly is the security of applications.
    Whether it's related to the input data being processed or coding with proven patterns
    and practices, the security of the application must be the number-one priority.
    It's especially important for network applications. In this chapter, we will also
    delve into techniques and best practices for secure programming in C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常面临的一个主要问题是应用程序的安全性。无论是与正在处理的输入数据相关还是使用经过验证的模式和实践进行编码，应用程序的安全性必须是首要任务。对于网络应用程序来说尤为重要。在本章中，我们还将深入探讨C++中安全编程的技术和最佳实践。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to computer networks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机网络简介
- en: Sockets and socket programming in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的套接字和套接字编程
- en: Designing a network application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计网络应用程序
- en: Understanding security issues in C++ programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解C++程序中的安全问题
- en: Leveraging secure programming techniques in project development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用安全编程技术进行项目开发
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler, along with the `-std=c++2a` option, will be used to compile
    the examples in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，将使用g++编译器以`-std=c++2a`选项进行编译。
- en: You can find the source files for this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章的源文件。
- en: Discovering network programming in C++
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中发现网络编程
- en: Two computers interact together using networks. Computers connect to the internet
    using a special hardware component called a **network adapter** or a **network
    interface controller**. The operating system installed on the computer provides
    drivers to work with the network adapter; that is, to support network communications
    the computer must have a network adapter installed with an OS that supports the
    networking stack. By stack, we mean the layers of modifications that the piece
    of data goes through when traveling from one computer to another. For example,
    opening a website on a browser renders data that's been gathered through the network.
    That data is received as a sequence of zeros and ones and then transformed into
    a form that's more intelligible to the web browser. Layering is essential in networking.
    Network communication as we know it today consists of several layers conforming
    to the OSI model we'll discuss here. The network interface controller is a hardware
    component that supports the physical and data link layers of the **Open System
    Interconnection** (**OSI**) model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 两台计算机通过网络进行交互。计算机使用特殊的硬件组件称为**网络适配器**或**网络接口控制器**连接到互联网。安装在计算机上的操作系统提供驱动程序以与网络适配器一起工作；也就是说，为了支持网络通信，计算机必须安装有支持网络堆栈的操作系统。通过堆栈，我们指的是数据在从一台计算机传输到另一台计算机时经历的一系列修改层。例如，在浏览器上打开网站会呈现通过网络收集的数据。该数据以一系列零和一接收，然后转换为对Web浏览器更易理解的形式。分层在网络中是至关重要的。如今的网络通信由符合我们将在此讨论的OSI模型的几个层组成。网络接口控制器是支持**开放系统互连**（**OSI**）模型的物理和数据链路层的硬件组件。
- en: 'The OSI model aims to standardize communication functions between a wide range
    of devices. Devices differ in structure and organization. This relates to both
    hardware and software. For example, a smartphone using an Intel CPU running an
    Android OS is different from a MacBook computer running a macOS Catalina. The
    difference is not the names and companies behind the aforementioned products,
    but the structure and organization of hardware and software. To eliminate the
    differences in network communication, a set of standardized protocols and intercommunication
    functions is proposed as the OSI model. The layers that we mentioned earlier are
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型旨在标准化各种设备之间的通信功能。设备在结构和组织上有所不同。这涉及硬件和软件。例如，使用英特尔CPU运行Android OS的智能手机与运行macOS
    Catalina的MacBook电脑是不同的。不同之处不在于上述产品背后的名称和公司，而在于硬件和软件的结构和组织。为了消除网络通信中的差异，OSI模型提出了一套标准化的协议和互联功能。我们之前提到的层如下：
- en: Application layer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: Presentation layer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层
- en: Session layer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话层
- en: Transport layer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层
- en: Network layer
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层
- en: Data-link layer
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据链路层
- en: Physical layer
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层
- en: 'A more simplified model includes the following four layers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更简化的模型包括以下四个层：
- en: '**Application**: This processes the details of the particular application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：处理特定应用程序的详细信息。'
- en: '**Transport**: This provides data transmission between two hosts.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输**：这提供了两个主机之间的数据传输。'
- en: '**Network**:This handles the transferal of packets around the network.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：这处理网络中数据包的传输。'
- en: '**Link**: This includes the device driver in the operating system, along with
    the network adapter inside the computer.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链路**：这包括操作系统中的设备驱动程序，以及计算机内的网络适配器。'
- en: The link (or data-link) layer includes the device driver in the operating system,
    along with the network adapter in the computer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 链路（或数据链路）层包括操作系统中的设备驱动程序，以及计算机中的网络适配器。
- en: To understand these layers, let's suppose you are using a desktop application
    for messaging such as *Skype* or *Telegram*. When you type in a message and hit
    the send button, the message goes through the network to its destination. In this
    scenario, let's suppose you are sending a text message to your friend who has
    the same application installed on their computer. This might seem simple from
    a high-level perspective, but the process is sophisticated and even the simplest
    message undergoes a lot of transformations before reaching its destination. First
    of all, when you hit the send button, the text message gets converted into binary
    form. The network adapter operates with binaries. Its basic function is to send
    and receive binary data through the medium. Besides the actual data that's sent
    over the network, the network adapter should know the destination address of the
    data. The destination address is one of many properties that's appended to user
    data. By user data, we mean the text that you typed and sent to your friend. The
    destination address is the unique address of your friend's computer. The typed
    text is packaged with the destination address and other information that's necessary
    for it to be sent to its target. Your friend's computer (including the network
    adapter, OS, and the messaging application) receives and unpackages the data.
    The text contained in that package is then rendered on the screen by the messaging
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些层，让我们假设您正在使用桌面应用程序进行消息传递，比如*Skype*或*Telegram*。当您输入一条消息并点击发送按钮时，消息会通过网络传输到其目的地。在这种情况下，假设您正在向安装了相同应用程序的朋友发送文本消息。从高层次的角度来看，这可能看起来很简单，但这个过程是复杂的，即使是最简单的消息在到达目的地之前也经历了许多转换。首先，当您点击发送按钮时，文本消息会被转换为二进制形式。网络适配器使用二进制。它的基本功能是通过介质发送和接收二进制数据。除了实际发送到网络上的数据之外，网络适配器还应该知道数据的目的地地址。目的地地址是附加到用户数据的许多属性之一。通过用户数据，我们指的是您输入并发送给朋友的文本。目的地地址是您朋友计算机的唯一地址。输入的文本与目的地地址和其他必要信息一起打包，以便发送到目标位置。您朋友的计算机（包括网络适配器、操作系统和消息应用程序）接收并解包数据。然后消息应用程序会在屏幕上显示该数据包中的文本。
- en: 'Almost every OSI layer mentioned at the beginning of this chapter adds its
    specific header to the data that''s sent over the network. The following diagram
    depicts how the data from the application layer gets stacked with headers before
    it''s moved to its destination:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在本章开头提到的每个OSI层都会向通过网络发送的数据添加其特定的标头。以下图表描述了应用层数据在移动到目的地之前如何叠加标头：
- en: '![](img/a757ca62-f6cd-41ca-a522-d59b4bb81220.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a757ca62-f6cd-41ca-a522-d59b4bb81220.png)'
- en: OSI model
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型
- en: Take a look at the first line (the **Application Layer**) in the preceding diagram.
    The **Data** is the text that you've typed into the messaging application in order
    to send it to your friend. In each layer, all the way down to the **Physical Layer**,
    the data is packaged with headers specific to each layer of the OSI model. The
    computer on the other side receives and retrieves the packaged data. In each layer,
    it removes the header specific to that layer and moves the rest of the package
    up to the next layer. Finally, the data reaches your friend's messaging application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面图表中的第一行（**应用层**）。**数据**是您在消息应用程序中输入的文本，以便将其发送给您的朋友。在每一层，一直到**物理层**，数据都会被打包，并附加有OSI模型每一层特定的标头。另一边的计算机接收并检索打包的数据。在每一层，它会移除该层特定的标头，并将其余的数据包移动到下一层。最终，数据到达您朋友的消息应用程序。
- en: As programmers, we are mostly concerned with writing applications that are able
    to send and receive data over a network without delving into the details of the
    layers. However, we need a minimal understanding of how layers augment data on
    higher levels with headers. Let's learn how a network application works in practice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们主要关注编写能够在网络上发送和接收数据的应用程序，而不深入了解各层的细节。然而，我们需要对如何在更高层次上使用标头增强数据有一定的了解。让我们学习一下网络应用程序在实践中是如何工作的。
- en: Network applications under the hood
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序的内部工作
- en: 'A network application installed on a device communicates with other applications
    installed on other devices through the network. In this chapter, we''ll discuss
    applications working together through the internet. A high-level overview of this
    communication can be seen in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在设备上的网络应用程序通过网络与其他设备上安装的应用程序进行通信。在本章中，我们将讨论通过互联网一起工作的应用程序。可以在以下图表中看到这种通信的高层概述：
- en: '![](img/3e256446-4904-4374-be81-67b37eae5d24.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e256446-4904-4374-be81-67b37eae5d24.png)'
- en: At the lowest level of communication is the physical layer, which transmits
    bits of data through the medium. A medium, in this case, is the network cable
    (consider Wi-Fi communication too). The user application abstracts from the lower
    levels of network communication. Everything a programmer needs is provided by
    the operating system. The operating system implements the low-level details of
    the network communication, such as the **Transmission Control Protocol**/**Internet
    Protocol **(**TCP**/**IP**) suite.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信的最低层是物理层，它通过介质传输数据位。在这种情况下，介质是网络电缆（也考虑Wi-Fi通信）。用户应用程序抽象了网络通信的较低层。程序员所需的一切都由操作系统提供。操作系统实现了网络通信的低级细节，比如**传输控制协议**/**互联网协议**（**TCP**/**IP**）套件。
- en: Whenever an application needs to access the network, whether it's a local area
    network or the internet, it requests the operating system to provide an access
    point. The OS manages to provide a gateway to the network by utilizing a network
    adapter and specific software that speaks to the hardware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序需要访问网络，无论是局域网还是互联网，它都会请求操作系统提供一个访问点。操作系统通过利用网络适配器和特定软件与硬件通信来管理提供网络的网关。
- en: 'A more detailed illustration of this looks as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这更详细的说明如下：
- en: '![](img/000a23f6-9ba9-4102-8fe3-88292e377065.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/000a23f6-9ba9-4102-8fe3-88292e377065.png)'
- en: 'The operating system provides an API to work with its networking subsystem.
    The main abstraction that programmers should care about is the socket. We can
    treat a socket as a file that sends its contents through the network adapter.
    Sockets are the access points that connect two computers via the network, as depicted
    in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供了一个用于处理其网络子系统的API。程序员应该关心的主要抽象是套接字。我们可以将套接字视为通过网络适配器发送其内容的文件。套接字是连接两台计算机的访问点，如下图所示：
- en: '![](img/26dbd171-672b-494d-b565-81f297597189.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26dbd171-672b-494d-b565-81f297597189.png)'
- en: From the programmer's perspective, the socket is a structure that allows us
    to implement data through the network in applications. The socket is a connection
    point that either sends or receives data; that is, an application receives data
    via sockets too. The operating system provides a socket for the application upon
    request. An application can have more than one socket. Client applications in
    the client-server architecture usually operate with a single socket. Now, let's
    delve into socket programming in detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，套接字是一个允许我们在应用程序中通过网络实现数据传输的结构。套接字是一个连接点，可以发送或接收数据；也就是说，应用程序也可以通过套接字接收数据。操作系统在请求时为应用程序提供套接字。一个应用程序可以拥有多个套接字。客户端应用程序在客户端-服务器架构中通常使用单个套接字。现在，让我们详细了解套接字编程。
- en: Programming network applications using sockets
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字编程网络应用
- en: As we mentioned previously, a socket is an abstraction over network communication.
    We treat them as regular files – everything written to a socket is sent via the
    network to its destination by the operating system. Everything that is received
    via the network is written into the socket – again, by the operating system. This
    way, the OS provides two-way communication for network applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，套接字是对网络通信的抽象。我们将它们视为常规文件 - 所有写入套接字的内容都由操作系统通过网络发送到目的地。通过网络接收到的所有内容都会被操作系统写入套接字。这样，操作系统为网络应用程序提供了双向通信。
- en: 'Let''s suppose that we run two different applications working with the network.
    For example, we open a web browser to surf the web and use a messaging application
    (such as Skype) to chat with friends. The web browser represents a client application
    in a client-server network architecture. The server, in this case, is the computer
    that responds with the requested data. For example, we type an address into the
    address bar of the web browser and see the resulting web page on the screen. Whenever
    we visit a website, the web browser requests a socket from the operating system.
    In terms of coding, the web browser creates a socket using the API provided by
    the OS. We can describe the socket with a more specific prefix: a client socket.
    For the server to process client requests, the computer running the web server
    must listen for incoming connections; that is, the server application creates
    a server socket intended to listen to connections.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行两个不同的与网络相关的应用程序。例如，我们打开一个网页浏览器来浏览网页，并使用一个消息应用（如Skype）与朋友聊天。网页浏览器代表了客户端-服务器网络架构中的客户端应用程序。在这种情况下，服务器是响应所请求数据的计算机。例如，我们在网页浏览器的地址栏中输入一个地址，然后在屏幕上看到生成的网页。每当我们访问一个网站时，网页浏览器都会从操作系统请求一个套接字。在编码方面，网页浏览器使用操作系统提供的API创建一个套接字。我们可以用更具体的前缀来描述套接字：客户端套接字。为了让服务器处理客户端请求，运行Web服务器的计算机必须监听传入的连接；也就是说，服务器应用程序创建一个用于监听连接的服务器套接字。
- en: 'Whenever a connection is established between the client and server, data communication
    can proceed. The following diagram depicts a web browser request to **facebook.com**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端和服务器之间建立连接时，数据通信就可以进行。下图描述了网页浏览器对**facebook.com**的请求：
- en: '![](img/025167ab-52c6-40b9-a864-ee63f96cdb67.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025167ab-52c6-40b9-a864-ee63f96cdb67.png)'
- en: Pay attention to the group of numbers in the preceding diagram. This is called
    an **Internet Protocol** (**IP**) **address**. The IP address is the location
    that we need in order to transfer data to the device. There are billions of devices
    connected to the internet. To make a unique distinction between them, each device
    exposes a unique numeric value representing its address. A connection is established
    using the IP protocol, which is why we call it an IP address. An IP address consists
    of four groups of 1-byte length numbers. Its dotted-decimal representation is
    in the form X.X.X.X, where X is the 1-byte number. The values at each position
    range from 0 to 255. More specifically, it's a version 4 IP address. Modern systems
    use a version 6 address, which is a combination of numbers and letters, providing
    a wider range of available address values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前图中的数字组。这被称为**Internet Protocol**（**IP**）**地址**。IP地址是我们需要的位置，以便将数据传输到设备。有数十亿台设备连接到互联网。为了对它们进行唯一区分，每个设备都会暴露一个代表其地址的唯一数字值。使用IP协议建立连接，这就是为什么我们称其为IP地址。IP地址由四组1字节长度的数字组成。它的点分十进制表示形式为X.X.X.X，其中X是1字节数字。每个位置的值范围从0到255。更具体地说，这是一个版本4的IP地址。现代系统使用版本6地址，这是数字和字母的组合，提供了更广泛的可用地址值范围。
- en: When creating a socket, we assign the IP address of the local computer to it;
    that is, we're binding the socket to the address. When using the socket to send
    data to another device in the network, we should set its destination address.
    The destination address is held by another socket on that device. To create a
    connection between two devices, we use two sockets. A reasonable question might
    arise— What if there are several applications running on the device? What if we
    run several applications, each of which has created a socket for itself? Which
    one should receive the incoming data?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建套接字时，我们将本地计算机的IP地址分配给它；也就是说，我们将套接字绑定到该地址。当使用套接字向网络中的另一设备发送数据时，我们应该设置其目标地址。目标地址由该设备上的另一个套接字持有。为了在两个设备之间创建连接，我们使用两个套接字。可能会出现一个合理的问题——如果设备上运行了多个应用程序怎么办？如果我们运行了多个应用程序，每个应用程序都为自己创建了一个套接字怎么办？哪一个应该接收传入的数据？
- en: To answer these questions, take a good look at the preceding diagram. You should
    see a number after the colon at the end of the IP address. That's called the **port
    number**. The port number is a 2-byte length number that's assigned to the socket
    by the operating system. Because of the 2-byte length limit, the OS cannot assign
    more than 65,536 unique port numbers to sockets; that is, you cannot have more
    than 65,536 simultaneous running processes or threads communicating via the network
    (however, there are ways to reuse sockets). Apart from that, there are port numbers
    that are reserved for specific applications. These ports are called well-known
    ports and range from 0 to 1023\. They are reserved for privileged services. For
    example, the HTTP server's port number is 80\. That doesn't mean it can't use
    other ports.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这些问题，请仔细查看前面的图表。您应该在IP地址末尾的冒号后看到一个数字。这被称为**端口号**。端口号是一个2字节长度的数字，由操作系统分配给套接字。由于2字节长度限制，操作系统无法为套接字分配超过65,536个唯一的端口号；也就是说，您不能有超过65,536个同时运行的进程或线程通过网络进行通信（但是有方法可以重用套接字）。除此之外，还有一些端口号专门为特定应用程序保留。这些端口称为众所周知的端口，范围从0到1023。它们保留用于特权服务。例如，HTTP服务器的端口号是80。这并不意味着它不能使用其他端口。
- en: Let's learn how to create a socket in C++. We will design a wrapper class that
    encapsulates **Portable Operating System Interface** (**POSIX**) sockets, also
    known as **Berkeley** or **BSD** sockets. It has a standard set of functions for
    socket programming. The C++ extension for network programming will be a tremendous
    addition to the language. The working draft contains information on the networking
    interface. We will discuss this later in this chapter. Before that, let's try
    to create our own networking wrappers for existing and low-level libraries. When
    we use POSIX sockets, we depend on the operating system's API. The OS provides
    an API that represents the functions and objects that are used to create sockets,
    send and receive data, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在C++中创建套接字。我们将设计一个封装**便携操作系统接口**（**POSIX**）套接字的包装类，也称为**伯克利**或**BSD**套接字。它具有用于套接字编程的标准函数集。网络编程的C++扩展将是语言的巨大补充。工作草案包含有关网络接口的信息。我们将在本章后面讨论这一点。在那之前，让我们尝试为现有和低级库创建我们自己的网络包装器。当我们使用POSIX套接字时，我们依赖于操作系统的API。操作系统提供了一个API，表示用于创建套接字、发送和接收数据等的函数和对象。
- en: 'POSIX represents a socket as a file descriptor. We use it almost as if it were
    a regular file. File descriptors follow the UNIX philosophy of providing a common
    interface to data input/output. The following code creates a socket using the
    `socket()` function (defined in the `<sys/socket.h>` header):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX将套接字表示为文件描述符。我们几乎可以像处理常规文件一样使用它。文件描述符遵循UNIX哲学，提供了一个通用的数据输入/输出接口。以下代码使用`socket()`函数（在`<sys/socket.h>`头文件中定义）创建套接字：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The declaration of the `socket()` function is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket()`函数的声明如下：'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, `AF_INET`, `SOCK_STREAM`, and `IPPROTO_TCP` are numeric values. The domain
    parameter specifies the protocol family of the socket. We use `AF_INET` to specify
    the IPv4 protocol. For IPv6, we use `AF_INET6`. The second parameter specifies
    the type of the socket, that is, whether it's a stream-oriented or datagram socket.
    For each specific type, the last parameter should be specified accordingly. In
    the preceding example, we specified `SOCK_STREAM` with `IPPROTO_TCP`. The **Transmission
    Control Protocol** (**TCP**) represents a reliable stream-oriented protocol. This
    is why we set the type parameter to `SOCK_STREAM`. Before we implement a simple
    socket application, let's find out more about network protocols.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`AF_INET`、`SOCK_STREAM`和`IPPROTO_TCP`都是数值。域参数指定套接字的协议族。我们使用`AF_INET`来指定IPv4协议。对于IPv6，我们使用`AF_INET6`。第二个参数指定套接字的类型，即它是面向流的还是数据报的套接字。对于每种特定类型，最后一个参数应相应地指定。在前面的示例中，我们使用`IPPROTO_TCP`指定了`SOCK_STREAM`。**传输控制协议**（**TCP**）代表可靠的面向流的协议。这就是为什么我们将类型参数设置为`SOCK_STREAM`的原因。在实现简单的套接字应用程序之前，让我们更多地了解网络协议。
- en: Network protocols
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络协议
- en: A network protocol is a collection of rules and data formats that define intercommunication
    between applications. For example, a web browser and a web server communicate
    via **Hyper-Text Transfer Protocol** (**HTTP**). HTTP is more like a set of rules than
    a transport protocol. Transport protocols are at the base of every network communication.
    An example of a transport protocol would be TCP. When we mentioned the TCP/IP
    suite, we meant the implementation of TCP over IP. We can consider the **Internet
    Protocol** (**IP**) as the heart of internet communications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议是一组规则和数据格式，用于定义应用程序之间的互联。例如，Web浏览器和Web服务器通过**超文本传输协议**（**HTTP**）进行通信。HTTP更像是一组规则，而不是传输协议。传输协议是每个网络通信的基础。传输协议的一个例子是TCP。当我们提到TCP/IP套件时，我们指的是TCP在IP上的实现。我们可以将**互联网协议**（**IP**）视为互联网通信的核心。
- en: 'It provides host-to-host routing and addressing. Everything that we send or
    receive via the internet is packaged as an *IP packet*. The following is what
    the IPv4 packet looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供主机到主机的路由和寻址。我们通过互联网发送或接收的所有内容都被打包成*IP数据包*。以下是IPv4数据包的外观：
- en: '![](img/947b4431-3e7b-4324-a92c-42a6140bcb04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/947b4431-3e7b-4324-a92c-42a6140bcb04.png)'
- en: The IP header weighs 20 bytes. It combines necessary flags and options for delivering
    a packet from the source address to the destination address. In the domain of
    the IP protocol, we usually call a packet a datagram. Each layer has its specific
    terms for packets. More careful specialists talk about encapsulating TCP segments
    into IP datagrams. It's totally fine to call them packets*.*
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: IP头部重量为20字节。它结合了从源地址到目的地址传递数据包所需的标志和选项。在IP协议领域，我们通常称数据包为数据报。每个层都有其特定的数据包术语。更加细心的专家会谈论将TCP段封装到IP数据报中。将它们称为数据包是完全可以的*.*
- en: Each protocol at the higher level appends meta-information to the data that's
    sent and received via the network; for example, TCP data is encapsulated in an
    IP datagram. Besides this meta-information, the protocol also defines the underlying
    rules and operations that should be performed to complete a data transfer between
    two and more devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个更高级别的协议都会向通过网络发送和接收的数据附加元信息；例如，TCP数据封装在IP数据报中。除了这些元信息，协议还定义了应该执行的底层规则和操作，以完成两个或多个设备之间的数据传输。
- en: You can find more detailed information in specific documents called **Request
    for Comments **(**RFCs**). For example, RFC 791 describes the Internet Protocol,
    while RFC 793 describes the Transmission Control Protocol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在称为**请求评论**（**RFCs**）的特定文档中找到更详细的信息。例如，RFC 791描述了互联网协议，而RFC 793描述了传输控制协议。
- en: Many popular applications – file transfer, email, web, and others – use TCP
    as their main transport protocol. For example, the HTTP protocol defines the format
    of the messages that are transferred from the client to the server and vice versa.
    The actual transfer happens using a transport protocol – in this case, TCP. However,
    the HTTP standard doesn't limit TCP to being the only transport protocol.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的应用程序 - 文件传输、电子邮件、网络等 - 使用TCP作为它们的主要传输协议。例如，HTTP协议定义了从客户端到服务器和反之亦然传输的消息格式。实际的传输是使用传输协议进行的
    - 在这种情况下是TCP。但是，HTTP标准并不限制TCP成为唯一的传输协议。
- en: 'The following diagram illustrates the TCP header being appended to the data
    before passing it to the lower level:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了在将数据传递到较低级别之前，TCP头被附加到数据中：
- en: '![](img/84ddead5-264a-4848-8552-5bc1e8c1986f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84ddead5-264a-4848-8552-5bc1e8c1986f.png)'
- en: Pay attention to the source port number and destination port number. Those are
    the unique identifiers that differentiate between running processes in operating
    systems. Also, take a look at the sequence and acknowledgment numbers. They are
    TCP-specific and used for transmission reliability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意源端口号和目标端口号。这些是在操作系统中区分运行进程的唯一标识符。还要看一下序列号和确认号。它们是TCP特有的，用于传输可靠性。
- en: 'In practice, TCP is used due to its following features:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，TCP由于以下特点而被使用：
- en: Retransmission of lost data
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢失数据的重传
- en: In-order delivery
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序传递
- en: Data integrity
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性
- en: Congestion control and avoidance
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥塞控制和避免
- en: '**IP**(short for Internet Protocol) is not reliable. It doesn''t care for lost
    packets, which is why TCP handles the retransmission of lost packets. It marks
    each packet with a unique identifier that should be acknowledged by the other
    side of the transmission. If the sender does not receive an **acknowledgment code** (**ACK**)
    for a packet, the protocol will resend the packet (a limited number of times).
    It is also crucial to receive packets in the proper order. TCP reorders received
    packets to represent correctly ordered information. That''s why, when listening
    to music online, we don''t listen to the end of the song at its beginning.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP**（即互联网协议）是不可靠的。它不关心丢失的数据包，这就是为什么TCP处理丢失数据包的重传。它使用唯一标识符标记每个数据包，应该由传输的另一端确认。如果发送方没有收到数据包的**确认码**（**ACK**），协议将重新发送数据包（有限次数）。正确接收数据包也非常重要。TCP重新排序接收到的数据包以正确表示排序信息。这就是为什么在线听音乐时，我们不会在歌曲的开头听到结尾。'
- en: Retransmission of packets might lead to another problem known as **network congestion**.
    This happens when a node doesn't manage to send packets fast enough. Packets get
    stuck for a while and unnecessary retransmission increases their number. Various
    implementations of TCP employ algorithms for congestion avoidance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的重传可能会导致另一个问题，即**网络拥塞**。当节点无法快速发送数据包时，就会发生这种情况。数据包会被卡住一段时间，不必要的重传会增加它们的数量。TCP的各种实现采用了拥塞避免算法。
- en: It maintains a congestion window – a factor that determines the amount of data
    that can be sent out. Using the slow-start mechanism, TCP slowly increases the
    congestion window after initializing the connection. Though the protocol is described
    in the corresponding **Request for Comments** (**RFC**), there are plenty of mechanisms
    that are implemented differently in operating systems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它维护一个拥塞窗口 - 一个确定可以发送的数据量的因素。使用慢启动机制，TCP在初始化连接后缓慢增加拥塞窗口。尽管该协议在相应的**请求评论**（**RFC**）中有描述，但在操作系统中实现的机制有很多不同。
- en: On the other side of the fence is the **User Datagram Protocol** (**UDP**).
    The main difference between these two is that TCP is reliable. This means that,
    in the case of lost network packets, it resends the same packet until it reaches
    its designated destination. Because of its reliability, data transmissions via
    TCP are considered to take longer than using UDP. UDP doesn't guarantee we can
    deliver packets properly and without losses. Instead, developers should take care
    of resending, checking, and verifying the data transmission. Applications that
    require fast communication tend to rely on UDP. For example, a video call application
    or an online game uses UDP because of its speed. Even if a couple of packets get
    lost during the transmission, it won't affect the user experience. It's better
    to have small glitches while playing a game or talking to a friend in a video
    chat than to wait seconds for the next frame of the game or video.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一边是**用户数据报协议**（**UDP**）。这两者之间的主要区别是TCP是可靠的。这意味着在丢失网络数据包的情况下，它会重新发送相同的数据包，直到它到达指定的目的地。由于其可靠性，通过TCP进行的数据传输被认为比使用UDP需要更长的时间。UDP不能保证我们可以正确地传递数据包而且没有丢失。相反，开发人员应该负责重新发送、检查和验证数据传输。需要快速通信的应用程序倾向于依赖UDP。例如，视频通话应用程序或在线游戏使用UDP因为它的速度。即使在传输过程中丢失了几个数据包，也不会影响用户体验。在玩游戏或进行视频聊天时，最好出现小故障，而不是等待下一帧游戏或视频。
- en: 'One of the main reasons why TCP is slower than UDP is the bigger number of
    steps in the connection initiation procedure for TCP. The following diagram shows
    the process of connection establishment in TCP, also known as the three-way handshake:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TCP比UDP慢的主要原因之一是TCP连接初始化过程中步骤较多。下图显示了TCP连接建立的过程，也称为三次握手：
- en: '![](img/297eb191-d103-4058-b238-d114d4404673.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/297eb191-d103-4058-b238-d114d4404673.png)'
- en: The client picks a random number when sending a `SYN` packet to the server.
    The server increments that random number by one, picks another random number,
    and replies with a `SYN-ACK` packet. The client increments both numbers received
    from the server by one and completes the handshake by sending the last `ACK` to
    the server. After the three-way handshake is successfully completed, the client
    and server can transfer packets to each other. This connection establishment process
    applies to every TCP connection. Details of the handshake are hidden from the
    developers of network applications. We create the socket and start listening to
    incoming connections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在向服务器发送`SYN`数据包时选择一个随机数。服务器将该随机数加一，选择另一个随机数，并回复一个`SYN-ACK`数据包。客户端将从服务器接收的两个数字都加一，并通过向服务器发送最后一个`ACK`完成握手。成功完成三次握手后，客户端和服务器可以相互传输数据包。这种连接建立过程适用于每个TCP连接。握手的细节对网络应用程序的开发者是隐藏的。我们创建套接字并开始监听传入的连接。
- en: 'Notice the difference between the two types of endpoint. One of them is the
    client. When implementing a network application, we should make a clear distinction
    between the client and the server because they have different implementations.
    This relates to the type of sockets as well. When creating a server socket, we
    are making it listen to incoming connections, while the client doesn''t listen
    – it makes requests. The following diagram depicts certain functions and their
    invocation sequence for the client and server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两种端点之间的区别。其中之一是客户端。在实现网络应用程序时，我们应该明确区分客户端和服务器，因为它们有不同的实现。这也与套接字的类型有关。创建服务器套接字时，我们使其监听传入的连接，而客户端不监听
    - 它发出请求。下图描述了客户端和服务器的某些函数及其调用顺序：
- en: '![](img/abc95252-99b1-40e7-8518-218dab92e194.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abc95252-99b1-40e7-8518-218dab92e194.png)'
- en: When creating a socket in code, we specify the protocol and the type of the socket.
    When we want a reliable connection between two endpoints, we choose TCP. The interesting
    thing is that we can use a transport protocol such as TCP to build our own protocol.
    Let's say we define a special document format to send and receive in order to
    treat the communication valid. For example, each document should start with the
    word PACKT. HTTP works the same way. It uses TCP for transport and defines a communication
    format over it. In the case of UDP, we should also design and implement a reliability
    strategy for communication. The preceding diagram shows how TCP establishes a
    connection between two endpoints. The client sends a `SYN` request to the server.
    The server answers with the `SYN-ACK` response, letting the client know that it's
    fine to continue the handshake. Finally, the client answers with an `ACK` to the
    server stating the connection is officially established. They can communicate
    as long as they want.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中创建套接字时，我们指定协议和套接字的类型。当我们需要两个端点之间的可靠连接时，我们选择TCP。有趣的是，我们可以使用TCP等传输协议来构建自己的协议。假设我们定义了一种特殊的文档格式来发送和接收以使通信有效。例如，每个文档应该以单词PACKT开头。HTTP也是这样工作的。它使用TCP进行传输，并定义了其上的通信格式。在UDP的情况下，我们还应该为通信设计和实现可靠性策略。前面的图表显示了TCP如何在两个端点之间建立连接。客户端向服务器发送`SYN`请求。服务器用`SYN-ACK`响应回答，让客户端知道可以继续握手。最后，客户端向服务器发送`ACK`，表示连接已正式建立。他们可以随意进行通信。
- en: '**Synchronize** (**SYN**) and ACK are protocol-defined terms that have become
    common in network programming.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步**（**SYN**）和**确认**（ACK）是协议定义的术语，在网络编程中变得常见。'
- en: UDP doesn't work this way. It sends data to the destination without worrying
    about an established connection. If you use UDP but need some reliability, you
    should implement it by yourself; for example, by checking whether a portion of
    data reached the destination. To check it, you can wait for the destination to
    answer with a custom-defined `ACK` packet. Most reliability-oriented implementations
    might repeat already existing protocols, such as TCP. However, there are many
    scenarios where you don't need them; for example, you don't need congestion avoidance
    because you don't need to send the same packet twice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UDP不是这样工作的。它将数据发送到目的地，而不必担心是否建立了连接。如果您使用UDP但需要一些可靠性，您应该自己来实现；例如，通过检查一部分数据是否到达了目的地。为了检查它，您可以等待目的地用自定义定义的`ACK`数据包进行回复。大多数可靠性导向的实现可能会重复已经存在的协议，如TCP。然而，有许多情况下您不需要它们；例如，您不需要拥塞避免，因为您不需要发送相同的数据包两次。
- en: We designed a strategy game in the previous chapter. Suppose the game is online
    and you are playing with a real opponent instead of an automated enemy player.
    Each frame of the game is rendered based on the data that's received across the
    network. If we put some effort into making the data transfer reliable, increasing
    the data integrity, and making sure none of the packets are lost, the user experience
    may be hurt because of the desynchronization of players. This scenario is good
    for using UDP. We can implement data transfer without a retransmission strategy
    so that we squeeze the speed of the game. Of course, using UDP doesn't force us
    to avoid reliability. In the same scenario, we might need to make sure the packet
    is received successfully by the player. For example, when the player surrenders,
    we should make sure the opponent receives the message. So, we can have conditional
    reliability based on packet priority of. UDP provides flexibility and speed in
    network applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设计了一个策略游戏。假设游戏是在线的，你正在与一个真正的对手而不是一个自动化的敌对玩家进行游戏。游戏的每一帧都是基于通过网络接收的数据进行渲染的。如果我们在使数据传输可靠、增加数据完整性以及确保没有任何数据包丢失方面付出了一些努力，可能会因为玩家的不同步而影响用户体验。这种情况适合使用UDP。我们可以实现数据传输而不需要重传策略，以便提高游戏的速度。当然，使用UDP并不强迫我们避免可靠性。在同样的情况下，我们可能需要确保数据包被玩家成功接收。例如，当玩家投降时，我们应该确保对手收到消息。因此，我们可以根据数据包的优先级进行有条件的可靠性。UDP在网络应用程序中提供了灵活性和速度。
- en: Let's take a look at an implementation of a TCP server application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个TCP服务器应用程序的实现。
- en: Designing a network application
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计网络应用程序
- en: The approach of designing an application with a small subsystem that requires
    a network connection is different compared to a fully network-related application.
    An example of the latter might be a client-server application for file storage
    and synchronization (such as Dropbox). It consists of a server and clients, where
    the client is installed as a desktop or mobile application that can also be used
    as a file explorer. Each update to the files in the system controlled by Dropbox
    will be instantly synchronized with the server. This way, you will always have
    your files in the cloud and can access them anywhere with an internet connection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个需要网络连接的小子系统来设计应用程序的方法与完全与网络相关的应用程序不同。后者的一个例子可能是用于文件存储和同步的客户端-服务器应用程序（如Dropbox）。它由服务器和客户端组成，其中客户端安装为桌面或移动应用程序，也可以用作文件资源管理器。由Dropbox控制的系统中文件的每次更新都将立即与服务器同步。这样，您将始终在云中拥有您的文件，并可以在任何地方通过互联网连接访问它们。
- en: 'We will be designing a similar simplified server application for file storage
    and manipulation. The following are the main tasks of the server:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个类似的简化的服务器应用程序，用于文件存储和操作。服务器的主要任务如下：
- en: Receive files from client applications
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端应用程序接收文件
- en: Store files at specified locations
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定的位置存储文件
- en: Send files to clients upon request
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据请求向客户端发送文件
- en: 'Referring to [Chapter 10](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml), *Designing
    World-Ready Applications*, we can move forward to the following top-level design
    of the application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第10章](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml)，*设计面向世界的应用程序*，我们可以继续进行以下应用程序的顶层设计：
- en: '![](img/45a77bf5-8c18-40ec-9537-129401650f37.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45a77bf5-8c18-40ec-9537-129401650f37.png)'
- en: Each of the rectangles in the preceding diagram represents a class or a collection
    of classes concerned with specific tasks. For example, the **Storage Manager**
    handles everything related to storing and retrieving files. Whether it uses classes
    such as a file, location, database, and so on does not concern us that much at
    this point.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中的每个矩形代表一个类或一组类，涉及特定的任务。例如，**存储管理器**处理与存储和检索文件相关的所有事务。在这一点上，它使用文件、位置、数据库等类并不那么关心。
- en: The **Client Manager** is a class or a group of classes that represent handling
    everything related to authenticating or authorizing clients (by client, we mean
    a client application), keeping steady connections with clients, receiving files
    from clients, sending files to clients, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端管理器**是一个类或一组类，用于处理与客户端（指客户端应用程序）相关的所有事务，包括认证或授权客户端，与客户端保持稳定的连接，从客户端接收文件，向客户端发送文件等。'
- en: We specifically emphasized **Networking** as an entity of interest in this chapter.
    Everything that relates to a network connection, along with data transfers from
    and to clients, is handled via **Networking**. Now, let's see what functionality
    we can use to design the Networking class (we will call it Network Manager for
    convenience).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们特别强调了**网络**作为一个感兴趣的实体。所有与网络连接相关的事情，以及与客户端的数据传输，都是通过**网络**来处理的。现在，让我们看看我们可以使用什么功能来设计网络类（我们将称之为网络管理器以方便起见）。
- en: Using POSIX sockets
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POSIX套接字
- en: As we mentioned previously, functions such as `socket()`, `bind()`, and `accept()`
    are library functions that are supported by default in most Unix systems. Previously,
    we included the `<sys/socket.h>` file. Besides that, we will need several other
    header files. Let's implement the classic TCP server example and wrap it in the
    Networking module for our file transfer application server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，诸如`socket()`、`bind()`和`accept()`之类的函数在大多数Unix系统中默认支持。之前，我们包含了`<sys/socket.h>`文件。除此之外，我们还需要几个其他头文件。让我们实现经典的TCP服务器示例，并将其封装在Networking模块中，用于我们的文件传输应用服务器。
- en: 'As we mentioned previously, server-side development differs from client-side
    development in terms of the type of socket and its behavior. Although both sides
    operate with sockets, the server-side socket is continuously listening for incoming
    connections, while the client-side socket initiates a connection with the server.
    For the server socket to wait for connections, we create a socket and bind it
    to the server IP address and a port number that clients will try to connect to.
    The following C code represents the creation and binding of a TCP server socket:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，服务器端开发在套接字的类型和行为方面与客户端开发不同。虽然两边都使用套接字，但服务器端套接字不断监听传入的连接，而客户端套接字则与服务器建立连接。为了使服务器套接字等待连接，我们创建一个套接字并将其绑定到服务器IP地址和客户端将尝试连接的端口号。以下C代码表示了TCP服务器套接字的创建和绑定：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first call creates a socket. The third parameter is set to 0, meaning that
    the default protocol will be selected based on the type of the socket. The type
    is passed as the second parameter, `SOCK_STREAM`, which makes the protocol value
    equal to `IPPROTO_TCP` by default. The `bind()` function binds the socket with
    the specified IP address and port number. We specified them in the `sockaddr_in`
    structure, which combines network address-related details in it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用创建了一个套接字。第三个参数设置为0，这意味着将根据套接字的类型选择默认协议。类型作为第二个参数传递，`SOCK_STREAM`，这将使协议值默认等于`IPPROTO_TCP`。`bind()`函数将套接字绑定到指定的IP地址和端口号。我们在`sockaddr_in`结构中指定了它们，该结构将网络地址相关的细节组合在一起。
- en: Although we skipped this in the preceding code, you should consider checking
    the calls to `socket()` and `bind()` functions (and other functions in POSIX sockets)
    against errors. Almost all of them return `-1` in the event of an error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的代码中跳过了这一点，但你应该考虑检查对`socket()`和`bind()`函数（以及POSIX套接字中的其他函数）的调用是否出现错误。几乎所有这些函数在出现错误时都会返回`-1`。
- en: 'Also, note the `htons()` function. It takes care of converting its arguments
    into network byte order. The problem is hidden in the way computers are designed.
    Some machines (Intel microprocessors, for example) use **little-endian** byte
    ordering, while others use **big-endian** ordering. **Little-endian** ordering
    places the least significant byte first. **Big-endian** ordering places the most
    significant byte first. The following diagram shows the difference between the
    two:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意`htons()`函数。它负责将其参数转换为网络字节顺序。问题隐藏在计算机设计的方式中。一些机器（例如Intel微处理器）使用**小端**字节顺序，而其他一些使用**大端**顺序。**小端**顺序将最不重要的字节放在最前面。**大端**顺序将最重要的字节放在最前面。以下图表显示了两者之间的区别：
- en: '![](img/16478fe6-bab4-4ef2-9d55-9473870f4425.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16478fe6-bab4-4ef2-9d55-9473870f4425.png)'
- en: The network byte order is a convention independent of specific machine architectures.
    The `htons()` function converts the provided port number from host byte order
    (**little-** or **big-endian**) into network byte order (independent from the
    machine).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网络字节顺序是与特定机器架构无关的约定。`htons()`函数将提供的端口号从主机字节顺序（**小端**或**大端**）转换为网络字节顺序（与机器无关）。
- en: 'That''s it – the socket is ready. Now, we should specify that it is ready for
    incoming connections. To specify that, we use the `listen()` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——套接字已经准备好了。现在，我们应该指定它准备好接收传入的连接。为了指定这一点，我们使用`listen()`函数：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As its name suggests, it listens for incoming connections. The second argument
    that's passed to the `listen()` function specifies the number of connections that
    the server will queue before discarding new incoming requests. In the preceding
    code, we specified `5` as the maximum number. In a high-load environment, we would
    increase this number. The maximum number is specified by the `SOMAXCONN` constant
    defined in the `<sys/socket.h>` header.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它用于监听传入的连接。传递给`listen()`函数的第二个参数指定了服务器在丢弃新的传入请求之前将排队的连接数。在前面的代码中，我们指定了`5`作为最大数。在高负载环境中，我们会增加这个数字。最大数由`<sys/socket.h>`头文件中定义的`SOMAXCONN`常量指定。
- en: 'The choice of backlog number (the second parameter of the `listen()` function)
    is based on factors such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: backlog数（`listen()`函数的第二个参数）的选择基于以下因素：
- en: If the rate of the connection requests is high for a short period of time, the
    backlog number should have a larger value.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连接请求的速率在短时间内很高，那么backlog数应该有一个较大的值。
- en: The duration of the server handles an incoming connection. The shorter the time,
    the smaller the backlog value will be.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器处理传入连接的持续时间。时间越短，backlog值就越小。
- en: 'When a connection initiation is happening, we can either to drop it or accept
    it and continue processing the connection. That''s why we use the `accept()` function
    in the following snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接初始化发生时，我们可以选择放弃它或接受它并继续处理连接。这就是为什么我们在下面的代码段中使用`accept()`函数：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two things to consider in the preceding code are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中需要考虑的两件事如下：
- en: First, the accepted socket connection information is written into the client's `sockaddr_in`
    structure. We can gather everything necessary about the client from that struct.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，接受的套接字连接信息被写入客户端的`sockaddr_in`结构中。我们可以从该结构中收集关于客户端的所有必要信息。
- en: Next, pay attention to the return value of the `accept()` function. It's a new
    socket that's created to handle requests from that particular client. The next
    call to the `accept()` function will return another value that will represent
    another client with a separate connection. We should handle this properly because
    the `accept()` call is blocking; that is, it waits for new connection requests.
    We will modify the preceding code so that it accepts multiple connections being
    handled in separate threads.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，要注意`accept()`函数的返回值。它是一个新的套接字，用于处理来自特定客户端的请求。下一次调用`accept()`函数将返回另一个值，代表另一个具有独立连接的客户端。我们应该正确处理这一点，因为`accept()`调用是阻塞的；也就是说，它等待新的连接请求。我们将修改前面的代码，以便在单独的线程中处理多个连接。
- en: 'The last line with the comment in the preceding code states that `new_socket`
    can be used to receive or send data to the client. Let''s see how we can achieve
    this and then start designing our `Networking` class. To read the data that''s
    received by the socket, we need to use the `recv()` function, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中带有注释的最后一行说明`new_socket`可以用于接收或发送数据给客户端。让我们看看如何实现这一点，然后开始设计我们的`Networking`类。要读取套接字接收的数据，我们需要使用`recv()`函数，如下所示：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `recv()` function takes a `char*` buffer to write data into it. It stops
    writing at `sizeof(buffer)`. The last parameter of the function is the additional
    flag we can set for reading. You should consider calling the function several
    times to read bigger than the `BUFFER_MAX_SIZE` data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv()`函数接受一个`char*`缓冲区来写入数据。它在`sizeof(buffer)`处停止写入。函数的最后一个参数是我们可以设置用于读取的附加标志。您应该考虑多次调用该函数以读取大于`BUFFER_MAX_SIZE`的数据。'
- en: 'Finally, to send data over the socket, we call the `send()` function, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要通过套接字发送数据，我们调用`send()`函数，如下所示：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, we've covered almost all the functions that are required to implement
    a server application. Now, let's wrap them in a C++ class and incorporate multithreading
    so that we can process client requests concurrently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们几乎涵盖了实现服务器应用程序所需的所有函数。现在，让我们将它们封装在一个C++类中，并加入多线程，以便我们可以并发处理客户端请求。
- en: Implementing a POSIX socket wrapper class
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个POSIX套接字包装类
- en: 'Let''s design and implement a class that will serve as the starting point for
    network-based applications. The main interface of the class looks as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计和实现一个类，它将作为基于网络的应用程序的起点。该类的主要接口如下所示：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's natural for the `Networking` class to be a singleton because we want a
    single instance to listen for incoming connections. It's also important to have
    multiple objects, each of which represents a separate connection with a client.
    Let's gradually make the class design better. Earlier, we saw that each new client
    socket is created after the server socket listens to and then accepts a connection
    request.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Networking`类作为单例是很自然的，因为我们希望有一个单一的实例来监听传入的连接。同时，拥有多个对象，每个对象代表与客户端的单独连接，也是很重要的。让我们逐渐改进类的设计。之前，我们看到在服务器套接字监听并接受连接请求之后，将创建每个新的客户端套接字。'
- en: 'After that, we can send or receive data through that new client socket. The
    server operates similarly to what can be seen in the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们可以通过新的客户端套接字发送或接收数据。服务器的操作方式与下图中所示的类似：
- en: '![](img/1d1c32ac-afd0-44be-a927-e1e391ec20c8.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d1c32ac-afd0-44be-a927-e1e391ec20c8.png)'
- en: 'That is, after accepting each incoming connection, we will have one separate
    socket for a connection. We store them in the `clients_` vector in the `Networking`
    class. Therefore, we can write the main logic of creating a server socket, listening,
    and accepting new connections in a single function that can work concurrently
    if required. The `start_server()` function serves as the starting point for the
    server to listen for incoming connections. The following code block illustrates
    this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在接受每个传入的连接之后，我们将有一个单独的套接字用于连接。我们将它们存储在`Networking`类的`clients_`向量中。因此，我们可以在一个函数中编写创建服务器套接字、监听和接受新连接的主要逻辑，如果需要的话，可以并发工作。`start_server()`函数作为服务器监听传入连接的起点。以下代码块说明了这一点：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we've stopped at a point where we should accept incoming connections (see
    the comment in the preceding code snippet). We have two choices here (actually,
    there are more than two choices, but we will only discuss two of them). We can
    either place the call to `accept()` directly into the `start_server()` function
    or we can implement a separate function that the `Networking` class user will
    call whenever applicable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们停在了应该接受传入连接的地方（请参阅前面的代码片段中的注释）。我们在这里有两种选择（实际上，不止两种选择，但我们只讨论其中的两种）。我们可以直接将`accept()`调用放入`start_server()`函数中，或者我们可以实现一个单独的函数，`Networking`类用户在适当时将调用它。
- en: It's not a bad practice to have specific exception classes for each error case
    that we have in the project. The preceding code might be rewritten when considering
    custom exceptions. You can do that as a homework project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目中的每个错误情况拥有特定的异常类并不是一个坏的做法。在考虑自定义异常时，前面的代码可能会被重写。您可以将其作为一个作业项目来完成。
- en: 'One of the choices has the `accept()` function in the `start_server()` function,
    which pushes each new connection into the `clients_` vector, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个选择在`start_server()`函数中有`accept()`函数，它将每个新连接推送到`clients_`向量中，如下所示：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Yes, we used an infinite loop. This may sound awful, but as long as the server
    is running, it must accept new connections. However, we all know that the infinite
    loop blocks the execution of code; that is, it won''t ever leave the `start_server()`
    function. We introduced our network application as a project that has at least
    three components: the Client Manager, the Storage Manager, and the one we are
    designing right now – the `Networking` class.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们使用了一个无限循环。这听起来可能很糟糕，但只要服务器在运行，它就必须接受新的连接。然而，我们都知道无限循环会阻塞代码的执行；也就是说，它永远不会离开`start_server()`函数。我们将我们的网络应用程序介绍为一个至少有三个组件的项目：客户端管理器、存储管理器，以及我们正在设计的`Networking`类。
- en: The execution of one component must not affect the others in a bad way; that
    is, we can use threads to make some components run in the background. The `start_server()`
    function running in the context of a thread is a nice solution, although we should
    now care about the synchronization issues we covered in [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml)*,
    Concurrency and Multithreading*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件的执行不应以不好的方式影响其他组件；也就是说，我们可以使用线程使一些组件在后台运行。在线程的上下文中运行的`start_server()`函数是一个不错的解决方案，尽管我们现在应该关心我们在[第8章](fc8fb840-e179-4725-9e44-403b63be460d.xhtml)中讨论的同步问题，即并发和多线程。
- en: Also, pay attention to the incompleteness of the preceding loop. After accepting
    a connection, it pushes the client data into the `clients_` vector. We should
    consider using another structure for that as we also need to store the socket
    descriptor, along with the client. We can use `std::undordered_map` to map the
    socket descriptor to the client connection information, but a simple `std::pair`
    or `std::tuple` would be fine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意前面循环的不完整性。在接受连接后，它将客户端数据推送到`clients_`向量中。我们应该考虑使用另一个结构，因为我们还需要存储套接字描述符，以及客户端。我们可以使用`std::undordered_map`将套接字描述符映射到客户端连接信息，但简单的`std::pair`或`std::tuple`也可以。
- en: 'However, let''s go even further and create a custom object representing the
    client connection, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们更进一步，创建一个表示客户端连接的自定义对象，如下所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will modify the `Networking` class so that it stores a vector of `Client`
    objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`Networking`类，使其存储`Client`对象的向量：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can change the design approach and make the `Client` object responsible
    for sending and receiving data:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以改变设计方法，使`Client`对象负责发送和接收数据：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even better, we can attach an `std::thread` object to the `Client` class so
    that each object handles data transfer in a separate thread. However, you should
    be careful not to starve the system. The number of incoming connections can increase
    drastically and the server application will become stuck. We will discuss this
    scenario in the next section when we discuss security issues. It's suggested you
    leverage thread pools that will both help us reuse threads and keep control over
    the number of threads running in the program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以将`std::thread`对象附加到`Client`类，这样每个对象都可以在单独的线程中处理数据传输。然而，你应该小心不要使系统陷入饥饿状态。传入连接的数量可能会急剧增加，服务器应用程序将会变得卡住。在下一节中，当我们讨论安全问题时，我们将讨论这种情况。建议您利用线程池，这将帮助我们重用线程并控制程序中运行的线程数量。
- en: The final design of the class depends on the type of data that we receive and
    send to the client. There are at least two different approaches. One of them is
    connecting to the client, receiving the necessary data, and shutting down the
    connection. The second approach is implementing a protocol by which the client
    and server will communicate. Although it sounds complex, the protocol might be
    simple.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类的最终设计取决于我们接收和发送给客户端的数据类型。至少有两种不同的方法。其中一种是连接到客户端，接收必要的数据，然后关闭连接。第二种方法是实现客户端和服务器之间通信的协议。虽然听起来复杂，但协议可能很简单。
- en: It's also extensible and makes the application more robust because you can support
    more features as the project evolves. We will get back to designing the protocol
    for authenticating client requests in the next section, when we discuss how to
    secure the network server application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是可扩展的，使应用程序更加健壮，因为您可以在项目发展过程中支持更多功能。在下一节中，当我们讨论如何保护网络服务器应用程序时，我们将回到设计用于验证客户端请求的协议。
- en: Securing the C++ code
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护C++代码
- en: 'Compared to many languages, C++ is a little harder to master in terms of secure
    coding. There are plenty of guidelines that provide advice regarding how to and
    how not to avoid security risks in C++ programs. One of the most popular issues
    that we discussed in [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building
    C++ Applications*, is using preprocessor macros. The example we used had the following
    macro:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言相比，C++在安全编码方面稍微难以掌握。有许多指南提供了关于如何避免C++程序中的安全风险的建议。我们在[第1章](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml)中讨论的最受欢迎的问题之一是使用预处理器宏。我们使用的例子有以下宏：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Improper use of this macro leads to logic errors that are hard to spot. In
    the following code, the programmer expects to get `16` printed to the screen:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确使用这个宏会导致难以发现的逻辑错误。在下面的代码中，程序员期望在屏幕上打印`16`：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is `7`. The issue here is with the missing parentheses around the
    `arg` parameter; that is, the preceding macro should be rewritten as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`7`。这里的问题在于`arg`参数周围缺少括号；也就是说，前面的宏应该重写如下：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Although this example is popular, we strongly suggest avoiding macros as much
    as possible. C++ provides plenty of constructs that can be processed at compile
    time, such as `constexpr`, `consteval`, and `constinit` – even if statements have
    a `constexpr` alternative. Use them if you need compile-time processing in your
    code. And, of course, there are modules, a long-awaited addition to the language.
    You should prefer using modules everywhere you used an `#include` with ubiquitous
    include guards:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很受欢迎，我们强烈建议尽量避免使用宏。C++提供了许多可以在编译时处理的构造，比如`constexpr`、`consteval`和`constinit`
    - 即使语句也有`constexpr`的替代方案。如果您需要在代码中进行编译时处理，请使用它们。当然，还有模块，这是语言中期待已久的补充。您应该更喜欢使用模块，而不是使用`#include`和无处不在的包含保护：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's not only more secure, but also more efficient because modules are processed
    once (we can consider them as precompiled headers).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅更安全，而且更高效，因为模块只处理一次（我们可以将它们视为预编译头）。
- en: 'Although we don''t want you to become paranoid about for security issues, you
    should be careful almost everywhere. You will avoid most of these issues by learning
    the language''s quirks and oddities. Also, a good practice would be to use the
    newest features that replace or fix the disadvantages of previous versions. For
    example, consider the following `create_array()` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不希望您对安全问题变得偏执，但您几乎应该在任何地方小心。通过学习语言的怪癖和奇特之处，您将避免大部分这些问题。此外，一个好的做法是使用替换或修复以前版本的缺点的最新功能。例如，考虑以下`create_array()`函数：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The caller of the `create_array()` function is left with a pointer to the non-existing
    array because `arr` has an automatic storage duration. We can replace the preceding
    code with a better alternative if required:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_array()` 函数的调用者因为`arr`具有自动存储期而留下了指向不存在数组的指针。如果需要，我们可以用更好的替代方案来替换前面的代码：'
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Strings are treated as character arrays and are the reason behind many buffer
    overflow issues. One of the most popular issues is writing data into a string
    buffer while ignoring its size. The `std::string` class is a safer alternative
    to C strings in that regard. However, when supporting legacy code, you should
    be careful when using functions such as `strcpy()`, as shown in the following
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串被视为字符数组，是许多缓冲区溢出问题的原因。其中最常见的问题之一是在忽略其大小的情况下向字符串缓冲区写入数据。在这方面，`std::string`类是C字符串的一个更安全的替代方案。然而，在支持旧代码时，您在使用`strcpy()`等函数时应该小心，就像以下示例中所示：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Given that, legally, `small_buffer` should have a null-terminator at the end
    of it, it will only cope with the first three characters of the `long_text` string.
    However, the following happens after calling `strcpy()`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于法律上，`small_buffer`应该在末尾有一个空终结符，它只能处理`long_text`字符串的前三个字符。然而，在调用`strcpy()`后发生了以下情况：
- en: '![](img/2e5109ce-bee4-4c01-b755-126f953aacc8.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e5109ce-bee4-4c01-b755-126f953aacc8.png)'
- en: You should be even more careful when implementing network applications. Most
    data coming from client connections should be handled properly, and buffer overflows
    are not rare. Let's learn how to make network applications more secure.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现网络应用程序时，您应该更加小心。大部分来自客户端连接的数据应该得到适当处理，缓冲区溢出并不罕见。让我们学习如何使网络应用程序更加安全。
- en: Securing network applications
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护网络应用程序
- en: In the previous section of this book, we designed a network application that
    receives client data using socket connections. Besides the fact that most viruses
    that penetrate the system are from the outside world, network applications have
    this natural tendency to open up the computer to various threats on the internet.
    First of all, whenever you are running a network application, an open port exists
    in the system. Someone who knows the exact port that your application is listening
    on can intrude by faking protocol data. We will mostly discuss the server-side
    of network applications here; however, some of the topics here apply to client
    applications as well.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一节中，我们设计了一个使用套接字连接接收客户端数据的网络应用程序。除了大部分渗入系统的病毒来自外部世界这一事实之外，网络应用程序有这种自然倾向，即向互联网上的各种威胁打开计算机。首先，每当您运行一个网络应用程序时，系统中就存在一个开放的端口。知道您的应用程序正在监听的确切端口的人可以通过伪造协议数据侵入。我们将主要讨论网络应用程序的服务器端；然而，这里的一些主题也适用于客户端应用程序。
- en: 'One of the first things you should do is incorporate client authorization and
    authentication. These are two terms that are easy to confuse. Be careful not to
    use them interchangeably; they are different:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该做的第一件事之一是加入客户端授权和认证。这两个术语很容易混淆。小心不要将它们互换使用；它们是不同的：
- en: '**Authentication** is the process of validating client access. It means that
    not every incoming connection request is served right away. Before transferring
    data to and from the client, the server application must be sure that the client
    is a known client. In almost the same way we access a social network platform
    by typing in our email and password, the authentication of a client defines whether
    the client has the right to access the system at all.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**是验证客户端访问的过程。这意味着并非每个传入的连接请求都会立即得到服务。在与客户端传输数据之前，服务器应用程序必须确保客户端是已知的客户端。几乎与我们通过输入电子邮件和密码访问社交网络平台的方式相同，客户端的认证定义了客户端是否有权访问系统。'
- en: '**Authorization**, on the other hand, defines what exactly the client can do
    in the system. It''s a set of permissions that are provided to specific clients.
    For instance, the client application we discussed in the previous section is able
    to upload files to the system. Sooner or later, you might want to incorporate
    paid subscriptions and provide paying clients with a wider range of features;
    for example, by allowing them to create folders to organize their files. So, when
    a client requests a folder''s creation, we might want to authorize the request
    to discover if the client has the right to do so.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**，另一方面，定义了客户端在系统中可以做什么。这是一组权限，提供给特定的客户端。例如，我们在前一节讨论的客户端应用程序能够上传文件到系统中。迟早，您可能希望加入付费订阅，并为付费客户提供更广泛的功能；例如，允许他们创建文件夹来组织他们的文件。因此，当客户端请求创建文件夹时，我们可能希望授权请求以发现客户端是否有权这样做。'
- en: When the client application initiates a connection with the server, all the
    server gets is the connection details (IP address, port number). To let the server
    know who is behind the client application (the actual user), the client application
    sends over the user's credentials. Usually, this process involves sending the
    user a unique identifier (such as a username or email address) with the password
    to access the system. The server then checks these credentials against its database
    and verifies whether it should grant access to the client. This form of communication
    between the client and the server might be a simple text transfer or a formatted
    object transfer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端应用程序与服务器建立连接时，服务器获得的只是连接详细信息（IP地址，端口号）。为了让服务器知道客户端应用程序背后的是谁（实际用户），客户端应用程序发送用户的凭据。通常，这个过程涉及向用户发送一个唯一标识符（如用户名或电子邮件地址）和密码以访问系统。然后，服务器会检查这些凭据与其数据库，并验证是否应该允许客户端访问。客户端和服务器之间的这种通信形式可能是简单的文本传输或格式化对象传输。
- en: 'For example, the protocol that''s defined by the server might require the client
    to send a **JavaScript Object Notation** (**JSON**) document in the following
    form:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务器定义的协议可能要求客户端以以下形式发送**JavaScript对象表示**（**JSON**）文档：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The response from the server allows the client to proceed further or update
    its UI to let the user know the result of the operation. There are several cases
    that you might have encountered while using any web or network application when
    signing in. For example, a wrongly typed password might lead to an `Invalid username
    or password` error being returned by the server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应允许客户端进一步进行，或者更新其用户界面以让用户知道操作的结果。在使用任何网络应用程序或网络应用程序时，您可能遇到了几种情况。例如，错误输入的密码可能导致服务器返回“无效的用户名或密码”错误。
- en: Besides this first necessary step, it is wise to validate every piece of data
    coming from the client application. A buffer overflow might be avoided quite easily
    if the email field is checked for its size. For example, the client application,
    when intentionally trying to break the system, might send a JSON object that has
    a very large value for its fields. That check is on the server's shoulders. Preventing
    security flaws starts with data validation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这一必要的第一步之外，验证来自客户端应用程序的每一条数据都是明智的。如果检查电子邮件字段的大小，就可以很容易地避免缓冲区溢出。例如，当客户端应用程序故意试图破坏系统时，可能会发送一个JSON对象，其中的字段具有非常大的值。这个检查是服务器的责任。预防安全漏洞始于数据验证。
- en: Another form of security attack is making too many requests per second from
    a single or multiple clients. For example, a client application making hundreds
    of authentication requests in 1 second causes the server to intensively process
    those requests and waste its resources trying to serve them all. It would be better
    to check the rate of client requests, for example, limiting them to a single request
    per second.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种安全攻击形式是从单个或多个客户端每秒发出过多的请求。例如，一个客户端应用程序在1秒内发出数百个身份验证请求，导致服务器密集处理这些请求，并浪费资源试图为它们提供服务。最好检查客户端请求的速率，例如，将其限制为每秒一个请求。
- en: These forms of attack (intentional or unintentional) are referred to as **Denial
    of Service** (**DOS**) attacks. The more advanced version of a DOS attack takes
    the form of making a huge number of requests to the server from multiple clients.
    This form is called a **Distributed DOS** (**DDOS**) attack. A simple approach
    might be to blacklist IP addresses that are trying to crash the system by making
    multiple requests per second. As a programmer of network applications, you should
    consider all the issues described here and many others outside the scope of this
    book when developing your applications.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式的攻击（有意或无意的）被称为**拒绝服务**（**DOS**）攻击。DOS攻击的更高级版本采取了从多个客户端向服务器发出大量请求的形式。这种形式被称为**分布式DOS**（**DDOS**）攻击。一个简单的方法可能是黑名单IP地址，这些IP地址试图通过每秒发出多个请求来使系统崩溃。作为网络应用程序的程序员，在开发应用程序时，您应该考虑本书范围之外的所有这些问题以及其他许多问题。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced designing network applications in C++. With effect
    from its first version, C++ has lacked built-in support for networking. The C++23
    standard plans to finally introduce it in the language.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在C++中设计网络应用程序。从其第一个版本开始，C++一直缺乏对网络的内置支持。C++23标准计划最终在语言中引入对网络的支持。
- en: We started off by introducing the basics of networking. Understanding networking
    completely takes a lot of time, but there are several foundational concepts that
    every programmer must know before implementing an application in any way related
    to the network. Those foundational concepts include layering in the OSI model
    and different kinds of transport protocol, such as TCP and UDP. Having an understanding
    of the differences between TCP and UDP is necessary for any programmer. As we
    learned, TCP makes reliable connections between sockets, and sockets are the next
    thing that a programmer encounters when developing network applications. Those
    are the connection points of two instances of applications. Whenever we need to
    send or receive data through a network, we should define a socket and work with
    it almost as we would work with a regular file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了网络的基础知识。完全理解网络需要很长时间，但在实现与网络有关的任何应用程序之前，每个程序员都必须了解一些基本概念。这些基本概念包括OSI模型中的分层和不同类型的传输协议，如TCP和UDP。了解TCP和UDP之间的区别对于任何程序员都是必要的。正如我们所学到的，TCP在套接字之间建立可靠的连接，而套接字是开发网络应用程序时程序员遇到的下一个东西。这些是两个应用程序实例的连接点。每当我们需要通过网络发送或接收数据时，我们应该定义一个套接字，并且几乎可以像处理常规文件一样处理它。
- en: All the abstractions and concepts that we use in application development are
    handled by the OS and, in the end, by the network adapter. This is a device that's
    capable of sending data through a network medium. Receiving data from the medium
    doesn't guarantee safety. The network adapter receives anything coming from the
    medium. To make sure we are handling incoming data correctly, we should also take
    care of application security. The last section of this chapter was about writing
    secure code and validating the input to make sure no harm will be done to the
    program. Securing your program is a good step in making sure your programs are
    of high quality. One of the best approaches to developing programs is testing
    them thoroughly. You may recall that, in [Chapter 10](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml), *Designing
    World-Ready Applications*, we discussed software development steps and explained
    that one of the most important steps explained testing the program once the coding
    phase is complete. After testing it, you will most probably discover a lot of
    bugs. Some of these bugs are hard to reproduce and fix, and that's where debugging
    comes to the rescue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序开发中使用的所有抽象和概念都由操作系统处理，并最终由网络适配器处理。这是一种能够通过网络介质发送数据的设备。从介质接收数据并不能保证安全。网络适配器接收来自介质的任何东西。为了确保我们正确处理传入数据，我们还应该注意应用程序安全性。本章的最后一节是关于编写安全代码和验证输入，以确保程序不会受到伤害。保护程序是确保程序质量的良好步骤。开发程序的最佳方法之一是彻底测试它们。您可能还记得，在[第10章](069ab9af-21a4-4b8c-bc3f-f7bc0d9e4712.xhtml)中，*设计面向世界的应用程序*，我们讨论了软件开发步骤，并解释了一旦编码阶段完成，测试程序是最重要的步骤之一。测试后，您很可能会发现许多错误。其中一些错误很难重现和修复，这就是调试发挥作用的地方。
- en: The next chapter is all about testing and debugging your programs the right
    way.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于以正确的方式测试和调试您的程序。
- en: Questions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: List all seven layers of the OSI model.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出OSI模型的所有七层。
- en: What's the point of port numbers?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口号的意义是什么？
- en: Why should you use sockets in network applications?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该在网络应用程序中使用套接字？
- en: Describe the sequence of operations you should perform at the server-side to
    receive data using a TCP socket.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述在服务器端使用TCP套接字接收数据时应执行的操作顺序。
- en: What are the differences between TCP and UDP?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP之间有什么区别？
- en: Why shouldn't you use macro definitions in your code?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不应该在代码中使用宏定义？
- en: How would you differentiate between different client applications when implementing
    a server application?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现服务器应用程序时，如何区分不同的客户端应用程序？
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*TCP/IP Illustrated, Volume 1: The Protocol**s*, by R. Stevens: [https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/](https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R. Stevens的《TCP/IP Illustrated，Volume 1: The Protocols》：[https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/](https://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0321336313/)'
- en: '*Networking Fundamentals*, by Gordon Davies:[ https://www.packtpub.com/cloud-networking/networking-fundamentals](https://www.packtpub.com/cloud-networking/networking-fundamentals)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gordon Davies的《网络基础知识》：[https://www.packtpub.com/cloud-networking/networking-fundamentals](https://www.packtpub.com/cloud-networking/networking-fundamentals)'
