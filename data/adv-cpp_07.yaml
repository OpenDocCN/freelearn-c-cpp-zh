- en: 6\. Streams and I/O
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 流和I/O
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Write and read data to/from files or the console using the Standard I/O Library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准I/O库向文件或控制台写入和读取数据
- en: Format and parse data using the in-memory I/O interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存I/O接口格式化和解析数据
- en: Extend standard I/O streams for user-defined types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展用户定义类型的标准I/O流
- en: Develop applications that use the I/O Standard Library from multiple threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发使用多个线程的I/O标准库的应用程序
- en: In this chapter, we'll develop flexible and maintainable applications using
    the I/O Standard Library, work with streams, learn how the I/O library can be
    used in multithreaded applications, and finally learn to format and parse data
    using the Standard Library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用I/O标准库开发灵活且易于维护的应用程序，处理流，学习I/O库如何在多线程应用程序中使用，并最终学会使用标准库格式化和解析数据。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered one of the most challenging topics – concurrency
    in C++. We looked at the main multithreaded concepts and differentiated between
    synchronous, asynchronous, and threaded execution in C++. We learned the key points
    about synchronization, data hazards, and race conditions. Finally, we looked at
    working with threads in modern C++. In this chapter, we will go deeper and learn
    how to handle I/O in multithreaded applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了C++中最具挑战性的主题之一 - 并发性。我们研究了主要的多线程概念，并区分了C++中的同步、异步和线程执行。我们学习了关于同步、数据危害和竞争条件的关键要点。最后，我们研究了在现代C++中使用线程。在本章中，我们将深入学习如何处理多线程应用中的I/O。
- en: This chapter is dedicated to `streams` and `I/O` in C++. I/O is the general
    concept of input and output operations. The main purpose of this part of the Standard
    Library is to provide a clear interface regarding the input and output of data.
    But this is not the only goal. There are a lot of situations where I/O can help
    us in our applications. It's hard to imagine any application that doesn't write
    errors or exceptional situations into the log file with the purpose of sending
    it to the development team for analysis. In GUI applications, we always need to
    format the displayed information or parse the user input. In complex and large
    applications, we usually need to log internal data structures, and so on. In all
    these cases, we employ the I/O portion of the `Standard Library`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于C++中的`流`和`I/O`。I/O是输入和输出操作的一般概念。标准库的这一部分的主要目的是提供关于数据输入和输出的清晰接口。但这并不是唯一的目标。有很多情况下，I/O可以帮助我们的应用程序。很难想象任何一个应用程序不会将错误或异常情况写入日志文件，以便将其发送给开发团队进行分析。在GUI应用程序中，我们总是需要格式化显示的信息或解析用户输入。在复杂和大型应用程序中，我们通常需要记录内部数据结构等。在所有这些情况下，我们使用`标准库`的I/O部分。
- en: We will start our chapter with a brief introduction to the Input/Output portion
    of the Standard Library. We will learn about the I/O and explore their main concepts
    and terms. Then, we will consider which types are supported by default and how
    we can extend streams to user-defined types. Next, we will study the structure
    of the I/O library and check the headers and classes available for our use. Finally,
    we will investigate how to work with streams, read and write to a file, create
    multithreaded applications with input and output operations, and format and parse
    text data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对标准库的输入/输出部分进行简要介绍开始本章。我们将学习有关I/O的概念并探索其主要概念和术语。然后，我们将考虑默认支持哪些类型以及如何将流扩展到用户定义的类型。接下来，我们将研究I/O库的结构，并检查可供我们使用的头文件和类。最后，我们将调查如何处理流，读写文件，创建具有输入和输出操作的多线程应用程序，并格式化和解析文本数据。
- en: This chapter will be concluded with a challenging and exciting activity in which
    we will improve our `Art Gallery Simulator` project from the previous chapter
    and create a robust, clear, multithreaded, and easy to use `Logger`. We will develop
    a class with a clear interface that can be accessed from any place in the project.
    Next, we will adapt it to work with several threads. Finally, we will integrate
    our robust logger into the Art Gallery Simulator project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以一个具有挑战性和令人兴奋的活动结束，我们将改进上一章的`艺术画廊模拟器`项目，并创建一个健壮、清晰、多线程且易于使用的`日志记录器`。我们将开发一个具有清晰接口的类，可以从项目中的任何地方访问。接下来，我们将使其适应多个线程的工作。最后，我们将把我们的健壮的日志记录器整合到艺术画廊模拟器项目中。
- en: Let's start by looking at the I/O part of the C++ Standard Library and learn
    what opportunities are open to us with this set of tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看C++标准库的I/O部分开始，了解这组工具为我们提供了哪些机会。
- en: Reviewing the I/O Portion of the Standard Library
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查标准库的I/O部分
- en: 'In computer science, I/O is the term that implies the communication between
    programs, devices, computers, and so on. In C++, we employ standard input and
    standard output terms to describe the I/O process. Standard input means the streams
    of data that are transferred into the program. To get this data, the program should
    perform the read operation. Standard output means the streams of data that are
    transferred from a program to an external device, such as a file, display, socket,
    printer, and so on. To output this data, the program should perform the write
    operation. Standard input and output streams are inherited from the main process
    and are common for all child threads. Take a look at the following diagram to
    get a better understanding of the considered terms:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，I/O是指程序、设备、计算机等之间的通信。在C++中，我们使用标准输入和标准输出术语来描述I/O过程。标准输入意味着传输到程序中的数据流。要获取这些数据，程序应执行读取操作。标准输出意味着从程序传输到外部设备（如文件、显示器、套接字、打印机等）的数据流。要输出这些数据，程序应执行写操作。标准输入和输出流是从主进程继承的，并且对所有子线程都是通用的。看一下下面的图表，以更好地理解所考虑的术语：
- en: '![](img/C14583_06_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_01.jpg)'
- en: 'Figure 6.1: I/O communication between devices'
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：设备之间的I/O通信
- en: In the C++ Standard Library, most of the I/O classes are generalized class templates.
    All of them are logically divided into two categories – abstractions and implementations.
    We are already familiar with the abstraction classes and know that we can use
    them for different purposes without recompiling the code. The same is true for
    the I/O library. Here, we have six abstract classes that are the basis of the
    I/O operations in C++. We will not deep dive into these interfaces. Usually, we
    use more high-level classes for our operations and appeal to them only if we need
    to implement our own derived class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++标准库中，大多数I/O类都是通用的类模板。它们在逻辑上分为两类——抽象和实现。我们已经熟悉了抽象类，并且知道我们可以在不重新编译代码的情况下用它们来实现不同的目的。I/O库也是如此。在这里，我们有六个抽象类，它们是C++中I/O操作的基础。我们不会深入研究这些接口。通常，我们使用更高级的类来进行操作，只有在需要实现自己的派生类时才会使用它们。
- en: 'The **ios_base** abstract class is responsible for managing stream status flags,
    formatting flags, callbacks, and private storage. The **basic_streambuf** abstract
    class provides an interface for buffering input or output operations and provides
    access to the source of input, such as a file, socket, or sink of output, such
    as a string or vector. The **basic_ios** abstract class implements facilities
    for work with derived classes from the **basic_streambuf** interface. The **basic_ostream**,
    **basic_istream**, and **basic_iostream** abstract classes are wrappers for derived
    classes from the **basic_streambuf** interface and provide a high-level input/output
    interface, respectively. Let''s briefly consider them and their relationships,
    which are shown in the following class diagram. You can see that all of them,
    except for **ios_base**, are template classes. Under the name of each class, you
    can find the file name where this class is defined:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**ios_base**抽象类负责管理流状态标志、格式化标志、回调和私有存储。**basic_streambuf**抽象类提供了缓冲输入或输出操作的接口，并提供了对输入源的访问，例如文件、套接字，或输出的接收端，例如字符串或向量。**basic_ios**抽象类实现了与**basic_streambuf**接口派生类的工作设施。**basic_ostream**、**basic_istream**和**basic_iostream**抽象类是**basic_streambuf**接口派生类的包装器，并分别提供了高级的输入/输出接口。让我们简要地考虑它们及其关系，这些关系显示在下面的类图中。您可以看到，除了**ios_base**之外，它们都是模板类。在每个类的名称下面，您可以找到定义该类的文件名：'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: In the UML notation, we use the `<<interface>>` keyword to show that class is
    an abstract class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML符号中，我们使用`<<interface>>`关键字来显示类是一个抽象类。
- en: '![Figure 6.2: Class diagram of I/O abstract interfaces'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：I/O抽象接口的类图'
- en: '](img/C14583_06_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_06_02.jpg)'
- en: 'Figure 6.2: Class diagram of I/O abstract interfaces'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：I/O抽象接口的类图
- en: 'Implementation classes are logically divided into the following categories:
    **File I/O**, **String I/O**, **Synchronized I/O**, **I/O manipulators**, and
    predefined standard stream objects. All of them are derived from the aforementioned
    abstract classes. Let''s consider each of them in detail in the upcoming sections.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类别在逻辑上分为以下几类：**文件I/O**，**字符串I/O**，**同步I/O**，**I/O操纵器**和预定义的标准流对象。所有这些类都是从上述抽象类派生而来的。让我们在接下来的部分详细考虑每一个。
- en: Predefined Standard Stream Objects
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义的标准流对象
- en: 'We will start our acquaintance with the I/O Standard Library with the already
    familiar `std::cout` class from the `<iostream>` header file. We use it for outputting
    the data to the Terminal. You may also be aware about the `std::cin` class for
    reading user input – but not everyone knows that `std::cout` and `std::cin` are
    predefined standard stream objects that are used for formatting input and output
    to the Terminal. The <iostream> header file also contains `std::cerr` and `std::clog`
    stream objects, which are used for logging errors. As usual, there are also their
    analogs for wide characters with a prefix of "`w`": `wcout`, `wcin`, `wcerr`,
    and `wclog`. All of these objects are automatically created and initialized at
    system startup. Although it is safe to use these objects from multiple threads,
    the output can be mixed. Let''s revise how to use them. Since they are only overloaded
    for built-in types, we should write our own overrides for user-defined types.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从已经熟悉的`<iostream>`头文件中的`std::cout`类开始认识I/O标准库。我们用它来将数据输出到终端。您可能也知道`std::cin`类用于读取用户输入——但并不是每个人都知道`std::cout`和`std::cin`是预定义的标准流对象，用于格式化输入和输出到终端。`<iostream>`头文件还包含`std::cerr`和`std::clog`流对象，用于记录错误。通常情况下，它们也有带有前缀“`w`”的宽字符的类似物：`wcout`，`wcin`，`wcerr`和`wclog`。所有这些对象都会在系统启动时自动创建和初始化。虽然从多个线程中使用这些对象是安全的，但输出可能会混合。让我们回顾一下如何使用它们。由于它们只对内置类型进行了重载，我们应该为用户定义的类型编写自己的重载。
- en: 'The `std::cout` stream object is often used with the `std::endl` manipulator.
    It inserts a newline character in the output sequence and flushes it. Here is
    an example of using them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cout`流对象经常与`std::endl`操纵器一起使用。它在输出序列中插入换行符并刷新它。这里有一个使用它们的例子：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Originally, the `std::cin` object reads all input character sequence, symbol
    by symbol. But it has overloads for built-in types and can read values such as
    `numbers`, `strings`, `characters`, and so on. There is a little trick in reading
    strings; `std::cin` reads the string until the next whitespace or newline symbol.
    So, if you need it to read a string, you have to do it in a loop, read it word
    by word, or use the `std::getline()` function, which takes the `std::cin` object
    as the first parameter and the destination string as the second.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`std::cin`对象逐个读取所有输入字符序列。但它对于内置类型有重载，并且可以读取诸如`数字`、`字符串`、`字符`等值。在读取字符串时有一个小技巧；`std::cin`会读取字符串直到下一个空格或换行符。因此，如果您需要读取一个字符串，您必须在循环中逐个单词地读取它，或者使用`std::getline()`函数，该函数将`std::cin`对象作为第一个参数，目标字符串作为第二个参数。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The right shift operator, `>>`, of the `std::cin` stream object reads only one
    word from a line. Use `std::getline(std::cin, str)` to read the whole line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cin`流对象的右移操作符`>>`只从一行中读取一个单词。使用`std::getline(std::cin, str)`来读取整行。'
- en: 'Here is an example of using `std::cin` with different types:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`std::cin`与不同类型的示例：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, here, we read the name using the `std::getline()` function because
    the user can input two or three words. We also read the age and then read the
    sex using the right shift operator, `>>`, because we need to read only a single
    word. We then print the read data to ensure that everything went well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这里，我们使用`std::getline()`函数读取名称，因为用户可以输入两个或三个单词。我们还读取年龄，然后使用右移操作符`>>`读取性别，因为我们只需要读取一个单词。然后打印读取的数据，以确保一切顺利。
- en: The **std::cerr** and **std::clog** stream objects differ in only one way –
    **std::cerr** immediately flushes the output sequence, while **std::clog** buffers
    it and flushes only when the buffer is full. When it comes to usage, they are
    very similar to **std::cout**. The only difference is that the messages from **std::cerr**
    and **std::clog** (in most of the IDEs) are red in color.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::cerr**和**std::clog**流对象在一个方面有所不同-**std::cerr**立即刷新输出序列，而**std::clog**对其进行缓冲，并且仅在缓冲区满时刷新。在使用时，它们与**std::cout**非常相似。唯一的区别是**std::cerr**和**std::clog**的消息（在大多数IDE中）是红色的。'
- en: 'In the following screenshot, you can see the output from these stream objects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到这些流对象的输出：
- en: '![](img/C14583_06_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_03.jpg)'
- en: 'Figure 6.3: The output from the std::cerr and std::clog stream objects'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：来自std::cerr和std::clog流对象的输出
- en: Now, let's perform an exercise to consolidate everything we've learned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一项练习，巩固我们所学的一切。
- en: 'Exercise 1: Overriding the Left Shift Operator, <<, for User-Defined Types'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：重载左移操作符<<，用于用户定义的类型
- en: 'In this exercise, we will write a very useful portion of code that you can
    use anywhere to output user-defined types. First of all, we will create a class
    with the name `Track` that represents a musical track. It will have the following
    private members: `name`, `singer`, `length`, and `date`. Then, we will override
    the left shift operator, `<<`, for this class. Next, we will create an instance
    of this class and output it using the `std::cout` stream object.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个非常有用的代码部分，您可以在任何地方使用它来输出用户定义的类型。首先，我们将创建一个名为`Track`的类，表示音乐曲目。它将具有以下私有成员：`name`，`singer`，`length`和`date`。然后，我们将重载这个类的左移操作符`<<`。接下来，我们将创建这个类的一个实例，并使用`std::cout`流对象输出它。
- en: 'Perform the following steps to execute this exercise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来执行此练习：
- en: 'Include the required headers: `<iostream>` for output to a console and `<string>`
    for string support:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件：`<iostream>` 用于在控制台输出和 `<string>` 用于字符串支持：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare the `Track` class and add the private section variables for keeping
    information about the `track`, that is, `m_Name`, `m_Singer`, `m_Date`, and `m_LengthInSeconds`.
    In the public section, add a constructor with parameters that initialize all the
    private variables. Also, add the `public` section getters for all class members:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Track`类，并添加私有部分变量以保存有关`track`的信息，即`m_Name`，`m_Singer`，`m_Date`和`m_LengthInSeconds`。在公共部分，添加一个带参数的构造函数，初始化所有私有变量。还要为所有类成员添加`public`部分的getter：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now comes the most difficult part of the exercise: writing the overload function
    for the `Track` type. This is a `template` function that has two type parameters:
    `charT` and `Traits`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是练习中最困难的部分：为`Track`类型编写重载函数。这是一个具有两个类型参数`charT`和`Traits`的`template`函数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We made this function inline to let the compiler know that we want it to perform
    optimization on this function. The return type of this function is a reference
    to a `std::basic_ostream<charT, Traits>` class. The name of this function is operator
    `<<`. This function takes two parameters: the first is the reference to the `std::basic_ostream<charT,
    Traits>` class and the second is a copy of the `Track` variable. The full function
    declaration is as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将此函数设置为内联函数，以便让编译器知道我们希望它对此函数进行优化。此函数的返回类型是对`std::basic_ostream<charT, Traits>`类的引用。此函数的名称是`operator
    <<`。此函数接受两个参数：第一个是对`std::basic_ostream<charT, Traits>`类的引用，第二个是`Track`变量的副本。完整的函数声明如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, add the function definition. Use the `os` variable, just like we use the
    `std::cout` object, and format the output as you wish. Then, return the `os` variable
    from the function. The complete code of the overloaded operator, `<<`, is as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加函数定义。使用`os`变量，就像我们使用`std::cout`对象一样，并根据需要格式化输出。然后，从函数返回`os`变量。重载操作符`<<`的完整代码如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, enter the `main` function and create and initialize the instance of the
    `Track` type with the name `track_001`. Finally, use `std::cout` to print the
    `track_001` value:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入`main`函数，并创建并初始化`Track`类型的实例`track_001`。最后，使用`std::cout`打印`track_001`的值：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compile and execute the application. Run it. You will get the following output:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并执行应用程序。运行它。您将获得以下输出：
- en: '![](img/C14583_06_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_04.jpg)'
- en: 'Figure 6.4: The result of executing Exercise 1'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：执行练习1的结果
- en: Great job. Here, we considered using predefined standard stream objects and
    learned how to write our own overloaded shift operators for user-defined types.
    Let's move on and examine reading and writing to a file with the C++ Standard
    IO Library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。在这里，我们考虑了使用预定义的标准流对象，并学习了如何为用户定义的类型编写我们自己的重载移位操作符。让我们继续并研究使用C++标准IO库读写文件的部分。
- en: File I/O Implementation Classes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件I/O实现类
- en: File streams manage input and output to files. They provide an interface that
    implements the `basic_ifstream` for input operations, `basic_ofstream` for output
    operations, `basic_fstream` for both input and output operations, and `basic_filebuf`
    for the implementation of a raw file device. All of them are defined in the `<fstream>`
    header file. The Standard Library also provides typedefs for char and `wchar_t`
    types, that is, `ifstream`, `fstream`, and `ofstream`, and the same names with
    a "`w`" prefix for wide characters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件流管理对文件的输入和输出。它们提供了一个接口，实现了输入操作的`basic_ifstream`，输出操作的`basic_ofstream`，同时输入和输出操作的`basic_fstream`，以及用于实现原始文件设备的`basic_filebuf`。它们都在`<fstream>`头文件中定义。标准库还提供了char和`wchar_t`类型的typedefs，即`ifstream`，`fstream`和`ofstream`，以及带有“w”前缀的相同名称，用于宽字符。
- en: 'We can create a file stream in two ways. The first way is to do this in one
    line, that is, to open a file and connect a stream to a file by just passing the
    filename to a constructor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式创建文件流。第一种方式是在一行中执行此操作，即通过将文件名传递给构造函数来打开文件并将流连接到文件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another way is creating an object and then calling the `open()` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个对象，然后调用`open()`函数：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'IO streams have bool variables: a **goodbit**, an **eofbit**, a **failbit**,
    and a **badbit**. They are used to check the state of the stream after each operation
    and indicate which error happened on the stream.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: IO流具有bool变量：**goodbit**，**eofbit**，**failbit**和**badbit**。它们用于在每次操作后检查流的状态，并指示流上发生了哪种错误。
- en: 'After the object''s creation, we can check the stream status by checking the
    `failbit` or checking the stream associated with the open file. To check a `failbit`,
    call the `fail()` function on the `file` stream:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象创建后，我们可以通过检查`failbit`或检查与打开文件相关联的流来检查流状态。要检查`failbit`，请在`file`流上调用`fail()`函数：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To check whether the stream is associated with the open file, call the `is_open()`
    function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查流是否与打开的文件相关联，请调用`is_open()`函数：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Input, output, and bidirectional file streams can also be opened in different
    modes by using flags. They are declared in the `ios_base` namespace. Besides the
    `ios_base::in` and `ios_base::out` flags, we also have the `ios_base::ate`, `ios_base::app`,
    `ios_base::trunc`, and `ios_base::binary` flags. The `ios_base::trunc` flag removes
    the content of the file. The `ios_base::app` flag always writes the output to
    the end of the file. Even if you decide to change the position in the file, you
    cannot do this. The `ios_base::ate` flag sets the position of the file descriptor
    to the end of the file but allows you to modify the position later. Finally, the
    `ios_base::binary` flag suppresses any formatting of the data so that it's read
    or wrote in "raw" format. Let's consider all the possible combinations of open
    modes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输入、输出和双向文件流也可以使用标志以不同模式打开。它们声明在`ios_base`命名空间中。除了`ios_base::in`和`ios_base::out`标志之外，我们还有`ios_base::ate`，`ios_base::app`，`ios_base::trunc`和`ios_base::binary`标志。`ios_base::trunc`标志会删除文件的内容。`ios_base::app`标志总是将输出写入文件的末尾。即使您决定更改文件中的位置，也无法这样做。`ios_base::ate`标志将文件描述符的位置设置为文件末尾，但允许您稍后修改位置。最后，`ios_base::binary`标志抑制数据的任何格式化，以便以“原始”格式读取或写入。让我们考虑所有可能的打开模式组合。
- en: By default, `std::ofstream` is opened in `ios_base::out` mode, `std::ifstream`
    is opened in `ios_base::in` mode, and `std::fstream` is opened in `ios_base::in|ios_base::out`
    mode. The `ios_base::out|ios_base::trunc` mode creates the file if it doesn't
    exist or removes all the content from the existing file. The `ios_base::out|ios_base::app`
    mode creates the file if it doesn't exist or opens the existing file and allows
    you to write only at the end of the file. Both of the aforementioned modes can
    be combined with the `ios_base::in` flag, so the file will be opened in read and
    write mode simultaneously.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`std::ofstream`以`ios_base::out`模式打开，`std::ifstream`以`ios_base::in`模式打开，`std::fstream`以`ios_base::in|ios_base::out`模式打开。`ios_base::out|ios_base::trunc`模式会在文件不存在时创建文件，或者删除现有文件的所有内容。`ios_base::out|ios_base::app`模式会在文件不存在时创建文件，或者打开现有文件，并允许您仅在文件末尾写入。上述两种模式都可以与`ios_base::in`标志结合使用，因此文件将同时以读取和写入模式打开。
- en: 'Here is an example of how to open the file using the aforementioned modes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上述模式打开文件的示例：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行以下操作：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we''ve opened the file stream in the required mode, we can start reading
    or writing to a file. The file streams allow us to change our position in the
    file. Let''s consider how we can do this. To get the current file''s position,
    we can call the `tellp()` function in `ios_base::out` mode and the `tellg()` function
    in `ios_base::in` mode. It can be used later so that we can return to this position
    if needed. We can also find the exact position in a file by using the `seekp()`
    function in `ios_base::out` mode and the `seekg()` function in `ios_base::in`
    mode. It takes two parameters: the number of characters to shift and from which
    file position it should count. There are allowed three types of positions to `seek:
    std::ios_base::beg`, that is, the beginning of file, `std::ios_base::end`, that
    is, the end of file, and `std::ios_base::cur`, that is, the current position.
    Here is an example of calling the `seekp()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们以所需模式打开文件流之后，我们可以开始读取或写入文件。文件流允许我们更改文件中的位置。让我们考虑如何做到这一点。要获取当前文件的位置，我们可以在`ios_base::out`模式中调用`tellp()`函数，在`ios_base::in`模式中调用`tellg()`函数。稍后可以使用它，以便在需要时返回到此位置。我们还可以使用`seekp()`函数在`ios_base::out`模式中和`seekg()`函数在`ios_base::in`模式中找到文件中的确切位置。它接受两个参数：要移动的字符数以及应从哪个文件位置计数。允许三种位置类型`seek:
    std::ios_base::beg`，即文件的开头，`std::ios_base::end`，即文件的末尾，以及`std::ios_base::cur`，即当前位置。以下是调用`seekp()`函数的示例：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we ask to set the current file's position at the fifth character
    from the end of the file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们要求将当前文件的位置设置为文件末尾的第五个字符。
- en: 'To write to the file, we can use the overloaded left shift operator, `<<`,
    for general formatted output, the `put()` function to write a single character,
    or the `write()` function to write a block of characters. Using the left shift
    operator is the most convenient way to write data to file as you can pass any
    built-in type as an argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，我们可以使用重载的左移操作符`<<`进行一般格式化输出，使用`put()`函数写入单个字符，或使用`write()`函数写入一块字符。使用左移操作符是将数据写入文件的最方便的方法，因为可以将任何内置类型作为参数传递：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `put()` and `write()` functions can only be used with character values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`put()`和`write()`函数只能用于字符值。'
- en: 'To read from a file, we can use the overloaded right shift operator, `>>`,
    or use a set of functions for reading characters, such as `read()`, `get()`, and
    `getline()`. The right shift operator is overloaded for all built-in types and
    we can use it like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取，我们可以使用重载的右移操作符`>>`，或使用一组用于读取字符的函数，如`read()`，`get()`和`getline()`。右移操作符已经为所有内置类型进行了重载，我们可以像这样使用它：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, the file stream is closed when the execution leaves the scope of visibility,
    so we don't need to perform any additional actions to close the file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当执行离开可见范围时，文件流将被关闭，因此我们不需要执行任何额外的操作来关闭文件。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Be attentive while reading data from a file. The right shift operator, `>>`,
    only reads a string until a whitespace or newline character. To read the full
    string, you could use a loop or read each word in a separate variable, like we
    did in *Exercise 1*, *Overriding the Left Shift Operator ,<<, for User-Defined
    Types*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在从文件中读取数据时要注意。右移操作符`>>`只会读取字符串直到空格或换行符为止。要读取完整的字符串，可以使用循环或将每个单词读入单独的变量，就像我们在*练习1*中所做的那样，*重载左移操作符<<，用于用户定义的类型*。
- en: Now, let's practice reading and writing data to a file using the C++ IO Standard
    Library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们练习使用C++ IO标准库将数据读取和写入文件。
- en: 'Exercise 2: Reading and Writing User-Defined Data Types to a File'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：将用户定义的数据类型读写到文件
- en: 'In this exercise, we''ll write a piece of code for a book shop. We need to
    store information about book prices in a file and then read that information from
    a file when needed. To implement this, we will create a class that represents
    a book with a name, author, year of publishing, and a price. Next, we will create
    an instance of this class and write it to a file. Later, we will read the information
    about the book from the file into the instance of the book class. Perform the
    following steps to complete this exercise:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为书店编写一段代码。我们需要将有关书籍价格的信息存储在文件中，然后在需要时从文件中读取该信息。为了实现这一点，我们将创建一个代表具有名称、作者、出版年份和价格的书的类。接下来，我们将创建该类的实例并将其写入文件。稍后，我们将从文件中读取有关书籍的信息到书籍类的实例中。执行以下步骤来完成这个练习：
- en: 'Include the required headers: `<iostream>` for output to a console, `<string>`
    for string support, and `<fstream>` for I/O file library support:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件：`<iostream>`用于输出到控制台，`<string>`用于字符串支持，`<fstream>`用于I/O文件库支持：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `Book` class, which represents the book in a book shop. In the
    private section, define four variables with self-explanatory names: `m_Name`,
    `m_Author`, `m_Year`, and `m_Price`. In the public section, define a constructor
    with parameters, which initializes all class members. Also, in the `public` section,
    define getters for all the class members:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Book`类，它代表书店中的书。在私有部分，使用不言自明的名称定义四个变量：`m_Name`，`m_Author`，`m_Year`和`m_Price`。在公共部分，定义带参数的构造函数，初始化所有类成员。此外，在`public`部分，为所有类成员定义getter：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enter the `main` function and declare the `pricesFile` variable, which holds
    the filename:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数并声明`pricesFile`变量，该变量保存文件名：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, create an instance of the `book` class and initialize it with `book name`,
    `author name`, `year`, and `price`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`book`类的实例，并用`book name`，`author name`，`year`和`price`进行初始化：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write this class instance to a file. Create an instance of the `std::ofstream`
    class. Open our file with the `pricesFile` variable name. Check if the stream
    is successfully opened and print an error message if not:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此类实例写入文件。创建`std::ofstream`类的实例。使用`pricesFile`变量名打开我们的文件。检查流是否成功打开，如果没有，则打印错误消息：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, write all the information about the `book_001` book to a file using getters
    with spaces between each item and a newline symbol at the end:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，使用getter将有关`book_001`书籍的所有信息写入文件，每个项目之间用空格分隔，并在末尾加上换行符:'
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile and execute the application. Now, go to the project folder and find
    where the '**prices.txt**' file is located. In the following screenshot, you can
    see the location of the created file in the project directory:![](img/C14583_06_05.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并执行应用程序。现在，转到项目文件夹，并找到'**prices.txt**'文件的位置。在下面的屏幕截图中，您可以看到在项目目录中创建的文件的位置:![](img/C14583_06_05.jpg)
- en: 'Figure 6.5: Location of the created file'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：创建文件的位置
- en: Open it in **Notepad**. In the following screenshot, you can see what the output
    to the file looks like:![](img/C14583_06_06.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**记事本**中打开它。在下面的屏幕截图中，您可以看到文件的输出是什么样子的:![](img/C14583_06_06.jpg)
- en: 'Figure 6.6: The result of the output of the user-defined type to the file'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：将用户定义的类型输出到文件的结果
- en: 'Now, let''s read this data to the variable. Create an instance of the `std::ifstream`
    class. Open the file called `pricesFile`. Check if the stream has been successfully
    opened and print an error message if not:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这些数据读取到变量中。创建`std::ifstream`类的实例。打开名为`pricesFile`的文件。检查流是否成功打开，如果没有，则打印错误消息：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the local variables that will be used for the input from a file, namely
    `name`, `authorName`, `authorSurname`, `year`, and `price`. Their names are self-explanatory:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将用于从文件输入的本地变量，即`name`，`authorName`，`authorSurname`，`year`和`price`。它们的名称不言自明：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, read the data from the file into variables in the order they are in the
    file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照文件中的顺序将数据读入变量中：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a `Book` instance called `book_002` and initialize it with those read
    values:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`book_002`的`Book`实例，并用这些读取的值进行初始化：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To check whether the read operation successfully executed, print the `book_002`
    variable to the console:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查读取操作是否成功执行，请将`book_002`变量打印到控制台：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile and execute the application again. In the console, you will see the
    following output:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译和执行应用程序。在控制台中，您将看到以下输出：
- en: '![](img/C14583_06_07.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_07.jpg)'
- en: 'Figure 6.7: The result of executing Exercise 2'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：执行练习2的结果
- en: As you can see, we wrote and read custom formatted data from a file without
    any difficulties. We created our own custom type, wrote it to the file using the
    `std::ofstream` class, and checked that everything was wrote successfully. Then,
    we read those data from a file to our custom variable using the `std::ifstream`
    class, output it to the console, and ensured that everything was read correctly.
    By doing this, we learned how to read and write data to a file using the I/O Standard
    Library. Now, let's move on and learn about the in-memory portion of the I/O library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们从文件中写入和读取了自定义格式的数据，没有任何困难。我们创建了自己的自定义类型，使用`std::ofstream`类将其写入文件，并检查一切是否都写入成功。然后，我们使用`std::ifstream`类从文件中读取这些数据到我们的自定义变量，将其输出到控制台，并确保一切都被正确读取。通过这样做，我们学会了如何使用I/O标准库向文件读写数据。现在，让我们继续学习I/O库的内存部分。
- en: String I/O Implementation
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串I/O实现
- en: 'The I/O Standard Library allows input and output – not only to devices such
    as files but also to memory, in particular, to the `std::string` objects. In this
    case, the string can be a source for input operations as well as a sink for output
    operations. In the `<sstream>` header file, stream classes are declared that manage
    input and output to strings. They, like the file streams, also provides an interface
    that implements RAII – the string opens for reading or writing upon the stream''s
    creation and closes on its destruction. They are represented in the Standard Library
    by the following classes: `basic_stringbuf`, which implements a raw string interface,
    `basic_istringstream` for input operations, `basic_ostringstream` for output operations,
    and `basic_stringstream` for both input and output operations. The Standard Library
    also provides typedefs for `char` and `wchar_t` types: `istringstream`, `ostringstream`,
    and `stringstream` and the same names with the "w" prefix for wide characters.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: I/O标准库允许输入和输出 - 不仅可以输出到文件等设备，还可以输出到内存，特别是`std::string`对象。在这种情况下，字符串可以作为输入操作的源，也可以作为输出操作的接收器。在`<sstream>`头文件中，声明了管理输入和输出到字符串的流类。它们，就像文件流一样，还提供了一个实现RAII的接口
    - 字符串在流创建时打开以供读取或写入，并在销毁时关闭。它们在标准库中由以下类表示：`basic_stringbuf`，它实现了原始字符串接口，`basic_istringstream`用于输入操作，`basic_ostringstream`用于输出操作，`basic_stringstream`用于输入和输出操作。标准库还为`char`和`wchar_t`类型提供了typedefs：`istringstream`，`ostringstream`和`stringstream`以及带有宽字符的相同名称的前缀为"w"的名称。
- en: 'To create an object of the `std::istringstream` class, we should pass the initializer
    string as a constructor parameter or set it later using the `str()` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`std::istringstream`类的对象，我们应该将初始化字符串作为构造函数参数传递或者稍后使用`str()`函数设置它：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, we can do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样做：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, to read values from the stream, use the right shift operator, `>>`, which
    is overloaded for all built-in types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要从流中读取值，请使用重定向运算符`>>`，它对所有内置类型进行了重载：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To create an object of the `std::ostringstream` class, we just declare a variable
    of its type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`std::ostringstream`类的对象，我们只需声明其类型的变量：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, to write data to the string, use the left shift operator, `<<`, which
    is overloaded for all built-in types:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要将数据写入字符串，请使用重定向运算符`<<`，它对所有内置类型进行了重载：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To get the resulting string, use the `str()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取结果字符串，请使用`str()`函数：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `std::stringstream` object works bidirectional, so it has both a default
    constructor and a constructor that takes the string. We can create the default
    `std::stringstream` object by declaring the variable of this type and then use
    it for reading and writing:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stringstream`对象是双向的，因此它既有默认构造函数，也有接受字符串的构造函数。我们可以通过声明这种类型的变量来创建默认的`std::stringstream`对象，然后用它进行读写：'
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, we can create `std::stringstream` using the constructor with a string
    parameter. Then, we can use it for reading and writing as usual:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用带有字符串参数的构造函数创建`std::stringstream`。然后，我们可以像往常一样使用它进行读写：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we can create a default `std::stringstream` object and initialize
    it by setting a string using the `str()` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个默认的`std::stringstream`对象，并通过使用`str()`函数设置一个字符串来初始化它：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we can use the ss object for reading and writing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用ss对象进行读写：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also apply open modes for these kinds of streams. Their functionality
    is similar to that of file streams but with a little difference. `ios_base::binary`
    is irrelevant in the case of working with string streams and `ios_base::trunc`
    is ignored. Thus, we can open any of the string streams in four modes: `ios_base::app`,
    `ios_base::ate`, and `ios_base::in/ios_base::out`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为这些类型的流应用打开模式。它们的功能类似于文件流，但有一点不同。在使用字符串流时，`ios_base::binary`是无关紧要的，`ios_base::trunc`会被忽略。因此，我们可以以四种模式打开任何字符串流：`ios_base::app`，`ios_base::ate`，`ios_base::in/ios_base::out`。
- en: Now, let's practice reading and writing data to a string using the C++ IO Standard
    Library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们练习使用C++ IO标准库向字符串读写数据。
- en: 'Exercise 3: Creating a Function for Replacement Words in a String'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：创建一个替换字符串中单词的函数
- en: 'In this exercise, we will implement a function that parses the given string
    and replaces the given word by other words. To complete this exercise, we create
    a callable class that takes three parameters: the original string, the word to
    be replaced, and the word that will be used for replacing. As a result, the new
    string should be returned. Perform the following steps to complete this exercise:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个函数，该函数解析给定的字符串，并用其他单词替换给定的单词。要完成这个练习，我们创建一个可调用类，它接受三个参数：原始字符串，要替换的单词和将用于替换的单词。结果应该返回新的字符串。执行以下步骤来完成这个练习：
- en: 'Include the required headers: `<iostream>` for the output to a Terminal and
    `<sstream>` for I/O string support:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件：`<iostream>`用于输出到终端，`<sstream>`用于I/O字符串支持：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the callable class with the name `Replacer`. It has only one function
    – an overloaded parentheses operator, (), that returns a string and takes three
    parameters: the original string, the word to be replaced, and the word to be used
    for replacing. The function declaration looks as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为`Replacer`的可调用类。它只有一个函数 - 重载的括号运算符，即()，它返回一个字符串，并接受三个参数：原始字符串、要替换的单词和用于替换的单词。函数声明如下：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, create the `istringstream` object, that is, `iss`, and set the `originalString`
    variable as the source of input:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`istringstream`对象，即`iss`，并将`originalString`变量设置为输入源：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the `ostringstream` object, that is, `oss`, that will hold the converted
    string:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ostringstream`对象，即`oss`，它将保存转换后的字符串：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, in the loop, while there is possible input, perform a read of the word
    to the word variable. Check if this word is equal to the `wordToBeReplaced` variable.
    If so, replace it with the `wordReplaceBy` variable and write to the `oss` stream.
    If they are unequal, write the original word to the `oss` stream. After each word,
    add a whitespace character since the `iss` stream truncates them. Finally, return
    the result. The complete class is as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在循环中，当可能有输入时，执行对单词变量的读取。检查这个单词是否等于`wordToBeReplaced`变量。如果是，用`wordReplaceBy`变量替换它，并写入`oss`流。如果它们不相等，将原始单词写入`oss`流。在每个单词后，添加一个空格字符，因为`iss`流会截断它们。最后，返回结果。完整的类如下：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Enter the `main` function. Create an instance of the `Replacer` class with
    a name of worker. Define the `foodList` variable and initialize it by the string
    that contains a list of food; some items should be repeated. Define the `changedList`
    string variable and initialize it by the return value of the `worker()` function.
    Use `std::cout` to display the result in the Terminal:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数。创建一个名为worker的`Replacer`类的实例。定义`foodList`变量，并将其初始化为包含食物列表的字符串；一些项目应该重复。定义`changedList`字符串变量，并将其初始化为`worker()`函数的返回值。使用`std::cout`在终端上显示结果：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compile, build, and run the exercise. As a result, you will get the following
    output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译、构建并运行练习。结果将如下所示：
- en: '![Figure 6.8: The result of executing Exercise 3](img/C14583_06_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：执行练习3的结果](img/C14583_06_08.jpg)'
- en: 'Figure 6.8: The result of executing Exercise 3'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：执行练习3的结果
- en: Well done! Here, we learned how to use string streams for formatting input and
    output. We created an application that easily replaces words in a sentence, strengthened
    our knowledge, and now we are ready to learn about I/O manipulators so that we
    can improve our skills regarding working with threads.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在这里，我们学会了如何使用字符串流来格式化输入和输出。我们创建了一个可以轻松替换句子中单词的应用程序，加强了我们的知识，现在我们准备学习I/O操作符，以便我们可以提高我们处理线程的技能。
- en: I/O Manipulators
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O操作符
- en: So far, we've learned about simple input and output using streams, but they
    are not sufficient in many cases. For more complex I/O data formatting, the Standard
    Library has a big set of I/O manipulators. They are functions that have been developed
    to work with shift operators, both left (<<) and right (>>), to control how streams
    behave. I/O manipulators are divided into two types – those that are invoked without
    arguments and those that needs arguments. Some of them work both for input and
    output. Let's briefly consider their meaning and usage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用流进行简单的输入和输出，但在许多情况下这是不够的。对于更复杂的I/O数据格式化，标准库有一个大量的I/O操作符。它们是为了与移位操作符（<<和>>）一起工作而开发的函数，用于控制流的行为。I/O操作符分为两种类型
    - 一种是无需参数调用的，另一种是需要参数的。其中一些既适用于输入又适用于输出。让我们简要地考虑它们的含义和用法。
- en: I/O Manipulators for Changing the Numeric Base of the Stream
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于更改流的数字基数的I/O操作符
- en: 'In the `<ios>` header, there are declared functions for changing the numeric
    base of the stream: `std::dec`, `std::hex`, and `std::oct`. They are invoked without
    arguments and set the numeric base of the stream to decimal, hexadecimal, and
    octal, respectively. In the `<iomanip>` header, the `std::setbase` function is
    declared, which is invoked with the following arguments: 8, 10, and 16\. They
    are interchangeable and work for both input and output operations.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ios>`头文件中，声明了用于更改流的数字基数的函数：`std::dec`、`std::hex`和`std::oct`。它们是无需参数调用的，并将流的数字基数分别设置为十进制、十六进制和八进制。在`<iomanip>`头文件中，声明了`std::setbase`函数，它是用以下参数调用的：8、10和16。它们是可互换的，并且适用于输入和输出操作。
- en: In the `<ios>` header, there is also the `std::showbase` and `std::noshowbase`
    functions, which control displaying the numeric base of the stream. They only
    affect hexadecimal and octal integer output, except the zero value, and monetary
    input and output operations. Let's complete an exercise and learn how to use them
    in practice.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ios>`头文件中，还有`std::showbase`和`std::noshowbase`函数，它们控制显示流的数字基数。它们只影响十六进制和八进制的整数输出，除了零值和货币输入和输出操作。让我们完成一个练习，学习如何在实践中使用它们。
- en: 'Exercise 4: Displaying Entered Numbers in Different Numeric Bases'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：以不同的数字基数显示输入的数字
- en: 'In this exercise, we will develop an application that, in the infinite loop,
    asks the user to enter an integer in one of the following numeric bases: decimal,
    hexadecimal, or octal. After reading the input, it displays this integer in other
    numeric representations. To perform this exercise, complete the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将开发一个应用程序，在无限循环中，要求用户以十进制、十六进制或八进制中的一种输入一个整数。读取输入后，将以其他数字表示形式显示这个整数。要完成这个练习，完成以下步骤：
- en: 'Include the `<iostream>` header for streaming support. Declare the enumeration
    called `BASE` and define three values: `DECIMAL`, `OCTAL`, and `HEXADECIMAL`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`<iostream>`头文件以支持流。声明名为`BASE`的枚举并定义三个值：`DECIMAL`、`OCTAL`和`HEXADECIMAL`：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a function called `displayInBases` that takes two parameters – integer
    and base. Next, define the switch statement, which tests the received numeric
    base and displays the given integer in the other two numeric representations:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`displayInBases`的函数，它接受两个参数 - 整数和基数。接下来，定义switch语句，测试接收到的数字基数，并以其他两种数字表示显示给定的整数：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Enter the `main` function and define the integer variable that will be used
    for reading user input:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数并定义将用于读取用户输入的整数变量：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create an infinite while loop. Inside the loop, ask the user to enter a decimal
    value. Read the input as a decimal integer. Pass it to the `displayInBases` function.
    Next, ask the user to enter a hexadecimal value. Read the input as a hexadecimal
    integer. Pass it to the `displayInBases` function. Finally, ask the user to enter
    an octal value. Read the input as an octal integer. Pass it to the `displayInBases`
    function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个无限循环。在循环内部，要求用户输入一个十进制值。将输入读取为十进制整数。将其传递给`displayInBases`函数。接下来，要求用户输入一个十六进制值。将输入读取为十六进制整数。将其传递给`displayInBases`函数。最后，要求用户输入一个八进制值。将输入读取为八进制整数。将其传递给`displayInBases`函数：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Build and run the application. Follow the output and enter, for example, 12
    in different numeric representations. The output should be as follows:![Figure
    6.9: The result of executing Exercise 4, part 1](img/C14583_06_09.jpg)'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。跟随输出并输入，例如，在不同的数字表示中输入12。输出应该如下所示：![图6.9：执行练习4，第1部分的结果](img/C14583_06_09.jpg)
- en: 'Figure 6.9: The result of executing Exercise 4, part 1'
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：执行练习4，第1部分的结果
- en: 'Now, let''s change `std::dec`, `std::oct`, and `std::hex` in the `std::setbase()`
    function to check whether the output will be the same. First, add the `<iomanip>`
    header for `std::setbase()` support. Next, in the main function in the loop, replace
    `std::dec` with `std::setbase(10)`, `std::hex` with `std::setbase(16)`, and `std::oct`
    with `std::setbase(8)`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`std::dec`、`std::oct`和`std::hex`在`std::setbase()`函数中更改，以检查输出是否相同。首先，添加`<iomanip>`头文件以支持`std::setbase()`。接下来，在主函数中的循环中，将`std::dec`替换为`std::setbase(10)`，将`std::hex`替换为`std::setbase(16)`，将`std::oct`替换为`std::setbase(8)`：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, build and run the application. Follow the output and enter the same
    integer (12) in different numeric representations. The output should be as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行应用程序。跟随输出并在不同的数字表示中输入相同的整数（12）。输出应该如下所示：
- en: '![Figure 6.10: The result of executing Exercise 4, part 2](img/C14583_06_10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：执行练习4，第2部分的结果](img/C14583_06_10.jpg)'
- en: 'Figure 6.10: The result of executing Exercise 4, part 2'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：执行练习4，第2部分的结果
- en: Now, compare the results. As you can see, the output is identical. By doing
    this, we made sure that these functions are interchangeable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，比较一下结果。如您所见，输出是相同的。通过这样做，我们确保这些函数是可以互换的。
- en: I/O Manipulators for Floating-Point Formatting
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点格式的I/O操作符
- en: 'In the `<ios>` header, there are declared functions for changing floating-point
    digit formatting: `std::fixed`, `std::scientific`, `std::hexfloat`, and `std::defaultfloat`.
    They are invoked without arguments and set `floatfield` to fixed, scientific,
    fixed and scientific, and default values, respectively. There is also the `std::
    showpoint` and `std::noshowpoint` functions, which control displaying floating-point
    digits. They only affect the output. The `std::noshowpoint` function only affects
    floating-point digits without the fractional part.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ios>`头文件中，声明了用于更改浮点数位格式的函数：`std::fixed`、`std::scientific`、`std::hexfloat`和`std::defaultfloat`。它们在没有参数的情况下被调用，并将`floatfield`分别设置为固定、科学、固定和科学以及默认值。还有`std::showpoint`和`std::noshowpoint`函数，用于控制显示浮点数位。它们只影响输出。`std::noshowpoint`函数只影响没有小数部分的浮点数位。
- en: 'In the `<iomanip>` header, there is a declared `std:: setprecision` function
    that is invoked with a number that represents precision. When the digits to the
    right of the point are dropped, the result is rounded off. If the number is too
    big to be represented in the normal way, the precision specification is ignored,
    and the number is displayed in a more convenient way. You only need to set precision
    once and change it only when you need another precision. When you choose a data
    type to store a floating-point variable, you should notice some tricks. In C++,
    there are three data types that can represent floating-point values: float, double,
    and long double.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<iomanip>`头文件中，声明了一个`std::setprecision`函数，它以表示精度的数字调用。当小数点右侧的数字被舍弃时，结果会四舍五入。如果数字太大而无法以正常方式表示，则会忽略精度规范，并以更方便的方式显示数字。您只需要设置一次精度，并且只在需要另一种精度时更改它。当您选择用于存储浮点变量的数据类型时，您应该注意一些技巧。在C++中，有三种数据类型可以表示浮点值：float、double和long
    double。
- en: 'The float is usually 4 bytes, double is 8 bytes, and long double is 8, 12,
    or 16 bytes. So, the precision of each of those is limited. The float type can
    accommodate a maximum of 6-9 significant digits, the double type can accommodate
    a maximum of 15-18 significant digits, and the long double type can accommodate
    a maximum of 33-36 significant digits. Take a look at the following table if you
    wish to compare the difference between them:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数通常是4个字节，双精度是8个字节，长双精度是8、12或16个字节。因此，每种类型的精度都是有限的。浮点类型最多可以容纳6-9个有效数字，双精度类型最多可以容纳15-18个有效数字，长双精度类型最多可以容纳33-36个有效数字。如果您希望比较它们之间的差异，请查看以下表格：
- en: '![Figure 6.11: Comparison table of the floating-point types](img/C14583_06_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：浮点类型的比较表](img/C14583_06_11.jpg)'
- en: 'Figure 6.11: Comparison table of the floating-point types'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：浮点类型的比较表
- en: Note
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When you need precision for more than six significant digits, favor double,
    otherwise you will get unexpected results.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要超过六个有效数字的精度时，请优先选择double，否则您将得到意外的结果。
- en: Let's complete an exercise and learn how to use them in practice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成一个练习，学习如何在实践中使用它们。
- en: 'Exercise 5: Displaying Entered Floating-Point Numbers with Different Formatting'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：以不同格式显示输入的浮点数
- en: 'In this exercise, we will write an application that, in the infinite loop,
    asks the user to enter a floating-point number. After reading the input, it displays
    this number with different formatting types. To perform this exercise, complete
    the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个应用程序，在无限循环中要求用户输入一个浮点数。在读取输入后，它以不同的格式类型显示这个数字。要完成这个练习，完成以下步骤：
- en: 'Include the `<iostream>` header for streaming support and `<iomanip>` for `std::setprecision`
    support:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`<iostream>`头文件以支持流和`<iomanip>`以支持`std::setprecision`：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, declare a template `formattingPrint` function that has a template parameter
    called `FloatingPoint` and takes a parameter variable of this type. Next, store
    the previous precision in an auto variable by calling the `precision()` function
    in the `std::cout` object. Then, display the given number in different formats
    in the Terminal: with the point, without a point, and in the fixed, scientific,
    hexfloat, and defaultfloat formats. Next, in the for loop, from 0 to 22, display
    the given number with precision and the size of the loop counter. After the loop
    exits, set the precision back using the value we stored earlier:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个模板`formattingPrint`函数，它有一个名为`FloatingPoint`的模板参数，并接受一个此类型的参数变量。接下来，通过调用`std::cout`对象中的`precision()`函数，将先前的精度存储在一个auto变量中。然后，在终端中以不同的格式显示给定的数字：带小数点，不带小数点，以及固定、科学、十六进制浮点和默认浮点格式。接下来，在for循环中，从0到22，显示给定的数字的精度和循环计数器的大小。循环退出后，使用我们之前存储的值重新设置精度：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enter the `main` function. Declare a `float` variable called `floatNum`, a
    double variable called `doubleNum`, and a long double variable called `longDoubleNum`.
    Then, in the infinite while loop, ask the user to input a floating-point number,
    read the input to `longDoubleNum`, and pass it to the `formattingPrint` function.
    Next, initialize `doubleNum` by using the `longDoubleNum` value and pass it to
    the `formattingPrint` function. Next, initialize `floatNum` by using the `longDoubleNum`
    value and pass it to the `formattingPrint` function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`main`函数。声明一个名为`floatNum`的`float`变量，一个名为`doubleNum`的双精度变量，以及一个名为`longDoubleNum`的长双精度变量。然后，在无限循环中，要求用户输入一个浮点数，读取输入到`longDoubleNum`，并将其传递给`formattingPrint`函数。接下来，通过使用`longDoubleNum`的值初始化`doubleNum`并将其传递给`formattingPrint`函数。接下来，通过使用`longDoubleNum`的值初始化`floatNum`并将其传递给`formattingPrint`函数：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Build and run the application. Follow the output and enter the floating-point
    value with `22` significant digits, for example, `0.2222222222222222222222`. We
    will get a long output. Now, we need to split it for analysis. Here is a screenshot
    of part of the long double value''s output:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。跟踪输出并输入具有`22`个有效数字的浮点值，例如`0.2222222222222222222222`。我们将得到一个很长的输出。现在，我们需要将其拆分进行分析。这是长双精度值输出的一部分的屏幕截图：
- en: '![Figure 6.12: The result of executing Exercise 5, part 1](img/C14583_06_12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：执行练习5，第1部分的结果](img/C14583_06_12.jpg)'
- en: 'Figure 6.12: The result of executing Exercise 5, part 1'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：执行练习5，第1部分的结果
- en: 'We can see that, with the default, the fixed and `defaultfloat` formations
    only output six significant digits. With scientific formatting, the output of
    the value looks as expected. When we call `setprecision(0)` or `setprecision(1)`,
    we expect that no one digit will be outputted after the point. But with numbers
    less than 1 setprecision, this will leave one digit after the point. By doing
    this, we will see the correct output until 21 precision. This means that on our
    system, the maximum precision for a long double is 20 significant digits. Now,
    let''s analyze the output for the double value:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，默认情况下，固定和`defaultfloat`格式只输出六个有效数字。使用科学格式化时，值的输出看起来如预期。当我们调用`setprecision(0)`或`setprecision(1)`时，我们期望小数点后不输出任何数字。但对于小于1的数字，setprecision会在小数点后留下一个数字。通过这样做，我们将看到正确的输出直到21精度。这意味着在我们的系统上，长双精度的最大精度是20个有效数字。现在，让我们分析双精度值的输出：
- en: '![Figure 6.13: The result of executing Exercise 5, part 2](img/C14583_06_13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：执行练习5，第2部分的结果](img/C14583_06_13.jpg)'
- en: 'Figure 6.13: The result of executing Exercise 5, part 2'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：执行练习5，第2部分的结果
- en: 'Here, we can see the same results for formatting, but different for precision.
    The inaccurate output starts from precision 17\. This means that, on our system,
    the maximum precision for double is 16 significant digits. Now, let''s analyze
    the output for float value:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到相同的格式化结果，但精度不同。不准确的输出从精度17开始。这意味着，在我们的系统上，双精度的最大精度是16个有效数字。现在，让我们分析浮点值的输出：
- en: '![Figure 6.14: The result of executing Exercise 5, part 3](img/C14583_06_14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：执行练习5，第3部分的结果](img/C14583_06_14.jpg)'
- en: 'Figure 6.14: The result of executing Exercise 5, part 3'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：执行练习5，第3部分的结果
- en: Here, we can see the same results for formatting, but different ones for precision.
    The inaccurate output starts from precision 8\. This means that, on our system,
    the maximum precision for the float is 8 significant digits. The results on different
    systems should be different. An analysis of them will help you choose the correct
    data type for your applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到相同的格式化结果，但精度不同。不准确的输出从精度8开始。这意味着，在我们的系统上，浮点的最大精度是8个有效数字。不同系统上的结果可能不同。对它们的分析将帮助您选择正确的数据类型用于您的应用程序。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Never use the float data type for representing money or exchange rates; you
    may get the wrong result.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用浮点数据类型来表示货币或汇率；你可能会得到错误的结果。
- en: I/O Manipulators for Boolean Formatting
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔格式化的I/O操作符
- en: 'In the `<ios>` header, there are declared functions for changing boolean formatting:
    `std::boolalpha` and `std::noboolalpha`. They are invoked without arguments and
    allow us to display boolean values in textual or digital ways, respectively. They
    are used for both input and output operations. Let''s consider an example of using
    these I/O manipulators for output operations. We will display the Boolean both
    as text and as a digit:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ios>`头文件中，声明了用于更改布尔格式的函数：`std::boolalpha`和`std::noboolalpha`。它们在没有参数的情况下被调用，并允许我们分别以文本或数字方式显示布尔值。它们用于输入和输出操作。让我们考虑一个使用这些I/O操作符进行输出操作的例子。我们将布尔值显示为文本和数字：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After compiling and running this example, you will get the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此示例后，您将得到以下输出：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the default formatting of bool variables is performed with
    the `std::noboolalpha` flag. To use these functions in input operations, we need
    to have a source string that contains true/false words or 0/1 symbols. The `std::boolalpha`
    and `std::noboolalpha` function calls in the input operation are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，布尔变量的默认格式是使用`std::noboolalpha`标志执行的。要在输入操作中使用这些函数，我们需要有一个包含true/false单词或0/1符号的源字符串。输入操作中的`std::boolalpha`和`std::noboolalpha`函数调用如下：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you then output these variables, you will see that they were initialized
    correctly by reading boolean values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输出这些变量，您会看到它们通过读取布尔值正确初始化。
- en: I/O Manipulators for Field Width and Fill Control
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于字段宽度和填充控制的I/O操作符
- en: 'In the Standard Library, there are also functions for manipulating by the width
    of the outputted field, which characters should be used in the case when the width
    is more than the output data, and in which place these filling characters should
    be inserted. These functions will be useful when you want to align your output
    to the left or right position or when you want to replace spaces with some other
    symbols. For example, let''s say you need to print prices in two columns. If you
    use standard formatting, you will get the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，还有一些函数用于通过输出字段的宽度进行操作，当宽度大于输出数据时应该使用哪些字符，以及这些填充字符应该插入在哪个位置。当您想要将输出对齐到左侧或右侧位置，或者当您想要用其他符号替换空格时，这些函数将非常有用。例如，假设您需要在两列中打印价格。如果您使用标准格式，您将得到以下输出：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This doesn''t look very good and it''s hard to read. If we apply the formatting,
    the output will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太好，很难阅读。如果我们应用格式，输出将如下所示：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This looks better. Again, you may want to check which characters are being
    used to fill in empty spaces and which are actually spaces that you inserted between
    digits. Let''s set the filling character to "*", for example. You will get the
    following output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更好。再次，您可能想要检查用于填充空格的字符以及实际插入在数字之间的空格。例如，让我们将填充字符设置为“*”。您将得到以下输出：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, you can see that the blank space is filled with stars. Now that we''ve
    considered where it can be useful to format width and fill with output, let''s
    consider how we can do that with I/O manipulators. The `std::setw` and `std::setfill`
    functions are declared in the `<iomanip>` header. `std::setw` takes an integer
    value as a parameter and sets the width of the stream to exact n characters. There
    are a few cases where the width will be set to 0\. They are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到空格被星号填充了。既然我们已经考虑了在哪里可以使用格式化宽度和填充输出，那么让我们考虑如何使用I/O操作符进行这样的操作。`std::setw`和`std::setfill`函数声明在`<iomanip>`头文件中。`std::setw`以整数值作为参数，并将流的宽度设置为精确的n个字符。有几种情况下，宽度将被设置为0。它们如下：
- en: When the shift operator is called with `std::string` or `char`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用移位操作符与`std::string`或`char`时
- en: When the `std::put_money()` function is called
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`std::put_money()`函数时
- en: When the `std::quoted()` function is called
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`std::quoted()`函数时
- en: 'In the `<ios>` header, there are declared functions for changing the place
    where filling characters should be inserted: `std::internal`, `std::left`, and
    `std::right`. They are only used for output operations and only affect integer,
    floating-point, and monetary values.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ios>`头文件中，声明了用于更改填充字符应该插入的位置的函数：`std::internal`、`std::left`和`std::right`。它们仅用于输出操作，仅影响整数、浮点和货币值。
- en: 'Now, let''s consider an example of using all of them together. Let''s output
    positive, negative, floating-point, and hexadecimal values with a width of 10
    and replace the filling character with "`#`":'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个同时使用它们的例子。让我们输出正数、负数、浮点数和十六进制值，宽度为10，并用“#”替换填充字符：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After building and running this example, you will get the following output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行此示例后，您将得到以下输出：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: I/O Manipulators for Other Numeric Formatting
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数字格式的I/O操作符
- en: 'If you need to output a positive numeric value with a "+" sign, you can use
    another I/O manipulator from the `<ios>` header – the `std::showpos` function.
    The opposite of meaning manipulator also exists – the `std::noshowpos` function.
    They both have an effect on the output. Their use is very easy. Let''s consider
    the following example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要输出带有“+”符号的正数值，您可以使用`<ios>`头文件中的另一个I/O操作符——`std::showpos`函数。相反的意义操作符也存在——`std::noshowpos`函数。它们都会影响输出。它们的使用非常简单。让我们考虑以下例子：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we made the output with default formatting, then with the `std::showpos`
    flag, and finally with the `std::noshowpos` flag. If you build and run this small
    example, you will see that, by default, the `std::noshowpos` flag is set. Look
    at the result of execution:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用默认格式输出，然后使用`std::showpos`标志，最后使用`std::noshowpos`标志。如果您构建并运行这个小例子，您会看到，默认情况下，`std::noshowpos`标志被设置。看一下执行结果：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You will also want to output uppercase characters for floating-point or hexadecimal
    digits so that you can use functions from the `<ios>` header: `std::uppercase`
    and `std::nouppercase`. They only work on the output. Let''s consider a small
    example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您还希望为浮点或十六进制数字输出大写字符，以便您可以使用`<ios>`头文件中的函数：`std::uppercase`和`std::nouppercase`。它们仅适用于输出。让我们考虑一个小例子：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, we output floating-point and hexadecimal digits with and without the
    `std::uppercase` flag. By default, the `std::nouppercase` flag is set. Look at
    the result of execution:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们输出浮点数和十六进制数字，有时使用`std::uppercase`标志，有时不使用。默认情况下，`std::nouppercase`标志被设置。看一下执行的结果：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I/O Manipulators for Whitespace Processing
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于处理空白的I/O操纵器
- en: 'In the Standard Library, there are functions for processing whitespaces. The
    `std::ws` function from the `<istream>` header only works with input streams and
    discards leading whitespaces. The `std::skipws` and `std::noskipws` functions
    from the `<ios>` header are used to control reading and writing leading whitespaces.
    They work for both input and output streams. When the `std::skipws` flag is set,
    the stream ignores whitespaces in front of the input of the character sequence.
    By default, the `std::skipws` flag is set. Let''s consider an example of using
    these I/O manipulators. First, we will read the input with default formatting
    and output what we have read. Next, we will clear our strings and read data with
    the `std::noskipws` flag:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，有用于处理空白的函数。`<istream>`头文件中的`std::ws`函数只适用于输入流，并丢弃前导空白。`<ios>`头文件中的`std::skipws`和`std::noskipws`函数用于控制读取和写入前导空白。它们适用于输入和输出流。当设置了`std::skipws`标志时，流会忽略字符序列前面的空白。默认情况下，`std::skipws`标志被设置。让我们考虑一下使用这些I/O操纵器的例子。首先，我们将用默认格式读取输入并输出我们所读取的内容。接下来，我们将清除我们的字符串，并使用`std::noskipws`标志读取数据：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After building and running this example, we will get the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行这个例子后，我们将得到以下输出：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see from the preceding output, if we set the `std::noskipws` flag,
    we will read whitespaces as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，如果我们设置了`std::noskipws`标志，我们将读取空白字符。
- en: 'In the `<iomanip>` header, an unusual manipulator for this header has been
    declared: `std::quoted`. When this function is applied to the input, it wraps
    a given string in quotes with escaping characters. If the input string already
    contains escaped quotes, it reads them as well. In order to understand this, let''s
    consider a small example. We will initialize a source string with some text without
    quotes and another string will initialize with text with escaped quotes. Next,
    we will read them by using `std::ostringstream` without a flag is set and provide
    the output via `std::cout`. Take a look at the following example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<iomanip>`头文件中，声明了一个不寻常的操纵器：`std::quoted`。当这个函数应用于输入时，它会用转义字符将给定的字符串包装在引号中。如果输入字符串已经包含转义引号，它也会读取它们。为了理解这一点，让我们考虑一个小例子。我们将用一些没有引号的文本初始化一个源字符串，另一个字符串将用带有转义引号的文本初始化。接下来，我们将使用`std::ostringstream`读取它们，没有设置标志，并通过`std::cout`提供输出。看一下下面的例子：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As a result, we will get the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s do the same output but with `std::quoted` call:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`std::quoted`调用做同样的输出：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we will have a different result:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将得到不同的结果：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Did you notice that the first string is wrapped by quotes and that the substring
    "right here" from the second string is stored with escape characters?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到第一个字符串被引号包裹，第二个字符串中的子字符串"right here"带有转义字符了吗？
- en: 'Now, you know how to wrap any string in the quotes. You can even write your
    own wrapper to decrease the number of lines when you use `std::quoted()`. For
    example, we moved the work with the stream to a separate function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何将任何字符串包装在引号中了。你甚至可以编写自己的包装器来减少使用`std::quoted()`时的行数。例如，我们将流的工作移到一个单独的函数中：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we do the following when we need we call our wrapper:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们需要时，我们调用我们的包装器：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, it looks much better. The first topic has come to an end, so let's revise
    what we have just learned. In practice, we learned about the usage of predefined
    stream objects, I/O operations with files with inner memory, I/O formatting, and
    the I/O of user-defined types. Now that we have a complete understanding of how
    to work with the I/O library in C++, we will consider what to do when the standard
    stream is not enough.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了。第一个主题已经结束，让我们复习一下我们刚刚学到的东西。在实践中，我们学习了预定义流对象的使用，内存中的文件I/O操作，I/O格式化，以及用户定义类型的I/O。现在我们完全了解了如何在C++中使用I/O库，我们将考虑当标准流不够用时该怎么办。
- en: Making Additional Streams
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建额外的流
- en: When the provided interface of streams is not enough for resolving your task,
    you may want to create an additional stream that will reuse one of the existing
    interfaces. You may need to output or provide input from a specific external device,
    or you may need to add the Id of the thread that invoked the I/O operation. There
    are a few ways to do that. You may create a new class that will aggregate one
    of the existing streams as a private member. It will implement all the needed
    functions, such as shift operators, through already existing stream functions.
    Another way to do this is to inherit one of the existing classes and override
    all the virtual functions in a way you need them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当流的提供的接口不足以解决你的任务时，你可能需要创建一个额外的流，它将重用现有接口之一。你可能需要从特定的外部设备输出或提供输入，或者你可能需要添加调用I/O操作的线程的Id。有几种方法可以做到这一点。你可以创建一个新的类，将现有流作为私有成员聚合起来。它将通过已经存在的流函数实现所有需要的函数，比如移位操作符。另一种方法是继承现有类，并以你需要的方式重写所有虚拟函数。
- en: First of all, you have to choose the appropriate class to be used. Your choice
    should depend on which modification you want to add. Choose `std::basic_istream`,
    `std::basic_ostream`, and `std::basic_iostream` if you need to modify input or
    output operations. Choose `std::ios_base` if you want to modify the state information,
    control information, private storage, and so on. Choose `std::basic_ios` if you
    want to modify something related to the stream buffer. After you choose the correct
    base class, inherit one of the aforementioned classes to create an additional
    stream.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须选择要使用的适当类。您的选择应取决于您想要添加哪种修改。如果您需要修改输入或输出操作，请选择`std::basic_istream`，`std::basic_ostream`和`std::basic_iostream`。如果您想要修改状态信息、控制信息、私有存储等，请选择`std::ios_base`。如果您想要修改与流缓冲区相关的内容，请选择`std::basic_ios`。在选择正确的基类之后，继承上述类之一以创建额外的流。
- en: There's one more thing you have to know – how to initialize correctly standard
    streams. In terms of the initialization of a file or string stream and basic stream
    classes, there are some big differences. Let's review them. To initialize the
    object of class that is derived from the file stream class, you need to pass the
    file name. To initialize the object of the class that is derived from the string
    stream class, you need to call the default constructor. Both of them have their
    own stream buffers, so they don't need additional manipulation on initialization.
    To initialize the object of the class that is derived from the basic stream class,
    you need to pass a pointer to a stream buffer. You can create a variable of the
    buffer or you may use the buffer of the predefined stream objects, such as `std::cout`
    or `std::cerr`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事情你必须知道 - 如何正确初始化标准流。在初始化文件或字符串流和基本流类方面，有一些重大区别。让我们来回顾一下。要初始化从文件流类派生的类的对象，您需要传递文件名。要初始化从字符串流类派生的类的对象，您需要调用默认构造函数。它们两者都有自己的流缓冲区，因此在初始化时不需要额外的操作。要初始化从基本流类派生的类的对象，您需要传递一个指向流缓冲区的指针。您可以创建一个缓冲区的变量，或者您可以使用预定义流对象的缓冲区，如`std::cout`或`std::cerr`。
- en: Let's review these two methods of creating additional streams in detail.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细回顾一下创建额外流的这两种方法。
- en: How to Make an Additional Stream – Composition
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何创建一个额外的流 - 组合
- en: Composition means that you declare some of the standard stream objects in the
    private section of your class as a class member. When you choose an appropriate
    standard stream class, go to its header and notice which constructor it has. Then,
    you need to correctly initialize this member in the constructor of your class.
    To use your class as a stream object, you need to implement basic functions such
    as the shift operator, `str()`, and so on. As you may remember, every stream class
    has overloaded shift operators for built-in types. They also have overloaded shift
    operators for predefined functions such as `std::endl`. You need to be able to
    use your class as a real stream object. Instead of declaring all 18 overloaded
    shift operators, we just need to create one template. Also, to allow for the use
    of predefined manipulators, we must declare a shift operator that takes a pointer
    to a function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 组合意味着在类的私有部分声明一些标准流对象作为类成员。当您选择适当的标准流类时，请转到其头文件并注意它有哪些构造函数。然后，您需要在类的构造函数中正确初始化这个成员。要将您的类用作流对象，您需要实现基本函数，如移位运算符、`str()`等。您可能还记得，每个流类都有针对内置类型的重载移位运算符。它们还有针对预定义函数的重载移位运算符，如`std::endl`。您需要能够将您的类用作真正的流对象。我们只需要创建一个模板，而不是声明所有18个重载的移位运算符。此外，为了允许使用预定义的操纵器，我们必须声明一个接受函数指针的移位运算符。
- en: This doesn't look very hard, so let's try to implement such a "wrapper" for
    the `std::ostream` object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不是很难，所以让我们尝试实现一个“包装器”来包装`std::ostream`对象。
- en: 'Exercise 6: Composing the Standard Stream Object in the User-Defined Class'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：在用户定义的类中组合标准流对象
- en: 'In this exercise, we will create own stream object that wraps the `std::ostream`
    object and adds additional features. We will create a class called `extendedOstream`
    that will output data to the Terminal and insert the following data in front of
    each piece of output: date and time and thread ID. To complete this exercise,
    perform the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个自己的流对象，包装`std::ostream`对象并添加额外的功能。我们将创建一个名为`extendedOstream`的类，它将向终端输出数据，并在每个输出的数据前插入以下数据：日期和时间以及线程ID。要完成这个练习，执行以下步骤：
- en: 'Include the required headers: `<iostream>` for `std::endl` support, `<sstream>`
    for `std::ostream` support, `<thread>` for `std::this_thread::get_id()` support,
    `<chrono>` for `std::chrono::system_clock::now()`, and `<ctime>` for converting
    timestamps into readable representations:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件：`<iostream>`用于`std::endl`支持，`<sstream>`用于`std::ostream`支持，`<thread>`用于`std::this_thread::get_id()`支持，`<chrono>`用于`std::chrono::system_clock::now()`，和`<ctime>`用于将时间戳转换为可读表示：
- en: Note
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, declare the `extendedOstream` class. Declare the `std::ostream` variable
    called `m_oss` and the bool variable called `writeAdditionalInfo`. This bool variable
    will be used to indicate whether extended data should be printed or not:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`extendedOstream`类。声明名为`m_oss`的`std::ostream`变量和名为`writeAdditionalInfo`的bool变量。这个bool变量将用于指示是否应该打印扩展数据：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, in the public section, define a default constructor and initialize `m_oss`
    with `std::cout` to redirect output to the Terminal. Initialize `writeAdditionalInfo`
    with `true`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在公共部分，定义一个默认构造函数，并用`std::cout`初始化`m_oss`以将输出重定向到终端。用`true`初始化`writeAdditionalInfo`：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Define a template overloaded left shift operator, `<<`, that returns a reference
    to `extendedOstream` and takes a template parameter called value. Then, if `writeAdditionalInfo`
    is `true`, output the time, thread ID, and the given value, and then set `writeAdditionalInfo`
    to `false`. If `writeAdditionalInfo` is `false`, output only the given value.
    This function will be used for the output of all built-in types:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个模板重载的左移操作符`<<`，它返回对`extendedOstream`的引用，并带有名为value的模板参数。然后，如果`writeAdditionalInfo`为`true`，输出时间、线程ID和给定的值，然后将`writeAdditionalInfo`设置为`false`。如果`writeAdditionalInfo`为`false`，只输出给定的值。这个函数将用于所有内置类型的输出：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define another overloaded left shift operator that takes a pointer to the function
    as a parameter and returns the reference to `std::ostream`. In the function body,
    set `writeAdditionalInfo` to `true`, call the given function, and pass `m_oss`
    as an argument. This overloaded operator will be used for predefined functions
    such as `std::endl`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个重载的左移操作符，它以函数指针作为参数并返回对`std::ostream`的引用。在函数体中，将`writeAdditionalInfo`设置为`true`，调用给定的函数，并将`m_oss`作为参数传递。这个重载的操作符将用于预定义函数，如`std::endl`：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the private section, define the `fTime` function, which returns std::string.
    It gets a system time. Format it into a readable representation and return it:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在私有部分，定义`fTime`函数，返回std::string。它获取系统时间。将其格式化为可读表示，并返回它：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the private section, define the `threadId()` function, which returns a string.
    Get the `id` of the current thread, format it, and return it:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在私有部分，定义`threadId()`函数，返回一个字符串。获取当前线程的`id`，格式化它，并返回它：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Enter the `main` function. To test how our stream object works, create an object
    of the `extendedOstream` type called `oss`. Output different data, for example,
    integer, float, hexadecimal, and bool:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数。为了测试我们的流对象如何工作，创建一个名为`oss`的`extendedOstream`类型的对象。输出不同的数据，例如整数、浮点数、十六进制和布尔值：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, create a thread, initialize it with a lambda function, and put the same
    output inside the lambda. Don''t forget to join the thread:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个线程，用lambda函数初始化它，并在lambda内部放置相同的输出。不要忘记加入线程：
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, build and run the application. You will get the following output:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行应用程序。你将得到以下输出：
- en: '![](img/C14583_06_15.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_15.jpg)'
- en: 'Figure 6.15: The result of executing Exercise 6'
  id: totrans-300
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：执行练习6的结果
- en: 'Consider each line of the output. You can see the next format of the output:
    "[date and time][thread ID]output data". Ensure that the thread ID differs from
    thread to thread. Then, the data was output in the expected format. So, as you
    can see, it''s not too hard to implement your own I/O stream object using the
    composition of the standard stream.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑输出的每一行。你可以看到输出的下一个格式："[日期和时间][线程ID]输出数据"。确保线程ID在不同的线程之间不同。然后，数据以预期的格式输出。所以，正如你所看到的，使用标准流的组合实现自己的I/O流对象并不太难。
- en: How to Make an Additional Stream – Inheritance
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何创建一个附加流 - 继承
- en: Inheritance means that you create your own stream class and inherit it from
    one of the standard stream objects that has a virtual destructor. Your class must
    be a template class and have template parameters, just like in the parent class.
    To use all your inherited functions with the object of your class, the inheritance
    should be public. In the constructor, you should initialize the parent class,
    depending on the class type – with the file name, with the stream buffer, or by
    default. Next, you should override those basic functions that you would change
    according to your requirements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 继承意味着你创建自己的流类，并从具有虚拟析构函数的标准流对象中继承它。你的类必须是一个模板类，并且具有模板参数，就像父类一样。要使用你的所有继承函数与你的类的对象，继承应该是公共的。在构造函数中，你应该根据类的类型初始化父类
    - 使用文件名、流缓冲区或默认值。接下来，你应该重写那些基本函数，根据你的要求进行更改。
- en: The most common case where we need to inherit standard stream classes is when
    we want to implement I/O operations for a new device, such as a socket or printer.
    All of the defined standard stream classes are responsible for formatting input
    and output and have overloads for strings, files, and the Terminal. Only the `std::basic_streambuf`
    class is responsible for work with devices, so we need to inherit this class,
    write our own implementation, and set it as a stream buffer for standard classes.
    The core functionality of `streambuf` classes is to transport characters. It can
    use buffers to store characters between flushing or can flush immediately after
    each call. These concepts are called buffered and unbuffered characters transport.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要继承标准流类的最常见情况是当我们想要为新设备（如套接字或打印机）实现I/O操作时。所有定义的标准流类都负责格式化输入和输出，并且对字符串、文件和终端进行了重载。只有`std::basic_streambuf`类负责与设备一起工作，因此我们需要继承这个类，编写我们自己的实现，并将其设置为标准类的流缓冲区。`streambuf`类的核心功能是传输字符。它可以使用缓冲区在刷新之间存储字符，也可以在每次调用后立即刷新。这些概念称为缓冲和非缓冲字符传输。
- en: 'The buffered characters transport for output operations works as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出操作的缓冲字符传输工作如下：
- en: Characters are buffered into the internal buffer by the `sputc()` function call.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`sputc()`函数调用将字符缓冲到内部缓冲区。
- en: When the buffer is full, `sputc()` invokes the protected virtual member, that
    is, `overflow()`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当缓冲区满时，`sputc()`调用受保护的虚拟成员`overflow()`。
- en: The `overflow()` function transfers all buffer content to the external device.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`overflow()`函数将所有缓冲区内容传输到外部设备。'
- en: When the `pubsync()` function is called, it calls the protected virtual member
    known as `sync()`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pubsync()`函数时，它会调用受保护的虚拟成员`sync()`。
- en: The `sync()` function transfers all buffer content to the external device.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync()`函数将所有缓冲区内容传输到外部设备。'
- en: 'The unbuffered characters transport for output operations works slightly differently:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 输出操作的非缓冲字符传输工作略有不同：
- en: Characters are passed to the `sputc()` function.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符传递给`sputc()`函数。
- en: The `sputc()` function immediately calls the protected virtual member known
    as `overflow()`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sputc()`函数立即调用被称为`overflow()`的受保护虚拟成员。'
- en: The `overflow()` function transfers all buffer content to the external device.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`overflow()`函数将所有缓冲区内容传输到外部设备。'
- en: So, for buffered and unbuffered characters transport for output operations,
    we should override the `overflow()` and sync() functions, which do the actual
    work.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于输出操作的缓冲和非缓冲字符传输，我们应该重写`overflow()`和`sync()`函数，这些函数执行实际工作。
- en: 'The buffered characters transport for input operations works as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 用于输入操作的缓冲字符传输工作如下：
- en: The `sgetc()` function reads the character from the internal buffer.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sgetc()`函数从内部缓冲区读取字符。'
- en: The `sgetc()` function invokes the `sungetc()` function, which makes the consumed
    character available again.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sgetc()`函数调用`sungetc()`函数，使已消耗的字符再次可用。'
- en: If the internal buffer is empty, the `sgetc()` function invokes the `underflow()`
    function.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内部缓冲区为空，`sgetc()`函数会调用`underflow()`函数。
- en: The `underflow()` function reads characters from the external device to the
    internal buffer.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`underflow()`函数从外部设备读取字符到内部缓冲区。'
- en: 'The `sgetc()` and `underflow()` functions always return the same character.
    To read different characters each time, we have another pair of functions: `sbumpc()`
    and `uflow()`. The algorithm of reading characters with them is the same:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`sgetc()`和`underflow()`函数总是返回相同的字符。为了每次读取不同的字符，我们有另一对函数：`sbumpc()`和`uflow()`。使用它们读取字符的算法是相同的：'
- en: The `sbumpc()` function reads the character from the internal buffer.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sbumpc()`函数从内部缓冲区读取字符。'
- en: The `sbumpc()` function invokes the `sputbackc()` function, which makes the
    next character available for input.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sbumpc()`函数调用`sputbackc()`函数，使下一个字符可用于输入。'
- en: If the internal buffer is empty, the `sbumpc()` function invokes the `uflow()`
    function.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内部缓冲区为空，`sbumpc()`函数会调用`uflow()`函数。
- en: The `uflow()` function reads characters from the external device to the internal
    buffer.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uflow()`函数从外部设备读取字符到内部缓冲区。'
- en: 'The unbuffered characters transport for input operations works as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 用于输入操作的非缓冲字符传输工作如下：
- en: The `sgetc()` function invokes a protected virtual member known as `underflow()`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sgetc()`函数调用一个被称为`underflow()`的受保护虚拟成员。'
- en: The `underflow()` function reads characters from the external device to the
    internal buffer.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`underflow()`函数从外部设备读取字符到内部缓冲区。'
- en: The `sbumpc()` function invokes a protected virtual member known as `uflow()`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sbumpc()`函数调用一个被称为`uflow()`的受保护虚拟成员。'
- en: The `uflow()` function reads characters from the external device to the internal
    buffer.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uflow()`函数从外部设备读取字符到内部缓冲区。'
- en: In the case of any errors, the protected virtual member known as `pbackfail()`
    is invoked, which handles error situations. So, as you can see, to override the
    `std::basic_streambuf` class, we need to override the virtual members that work
    with external devices. For the input `streambuf`, we should override the `underflow()`,
    `uflow()`, and `pbackfail()` members. For the output `streambuf`, we should override
    the `overflow()` and `sync()` members.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生任何错误的情况下，会调用被称为`pbackfail()`的受保护虚拟成员，该成员处理错误情况。因此，可以看到，要重写`std::basic_streambuf`类，我们需要重写与外部设备一起工作的虚拟成员。对于输入`streambuf`，我们应该重写`underflow()`、`uflow()`和`pbackfail()`成员。对于输出`streambuf`，我们应该重写`overflow()`和`sync()`成员。
- en: Let's consider all of these steps in more detail.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑所有这些步骤。
- en: 'Exercise 7: Inheriting the Standard Stream Object'
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：继承标准流对象
- en: 'In this exercise, we will create a class called `extended_streambuf` that inherits
    from `std::basic_streambuf`. We will use a buffer of the `std::cout` stream object
    and override the overflow() function so that we can write data to an external
    device (`stdout`). Next, we will write an `extended_ostream` class that inherits
    from the `std::basic_ostream` class and set a stream buffer to `extended_streambuf`.
    Finally, we will make minor changes to our wrapper class and use `extended_ostream`
    as a private stream member. To complete this exercise, perform the following steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个名为`extended_streambuf`的类，它继承自`std::basic_streambuf`。我们将使用`std::cout`流对象的缓冲区，并重写`overflow()`函数，以便我们可以将数据写入外部设备（`stdout`）。接下来，我们将编写一个名为`extended_ostream`的类，它继承自`std::basic_ostream`类，并将流缓冲区设置为`extended_streambuf`。最后，我们将对我们的包装类进行微小的更改，并将`extended_ostream`用作私有流成员。要完成此练习，请执行以下步骤：
- en: 'Include the required headers: `<iostream>` for `std::endl` support, `<sstream>`
    for `std::ostream` and `std::basic_streambuf` support, `<thread>` for `std::this_thread::get_id()`
    support, `<chrono>` for `std::chrono::system_clock::now()`, and `<ctime>` for
    converting timestamps into a readable state.'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件：`<iostream>`用于支持`std::endl`，`<sstream>`用于支持`std::ostream`和`std::basic_streambuf`，`<thread>`用于支持`std::this_thread::get_id()`，`<chrono>`用于支持`std::chrono::system_clock::now()`，`<ctime>`用于将时间戳转换为可读状态。
- en: 'Create a template class called `extended_streambuf` that inherits from the
    `std::basic_streambuf` class. Override a public member called `overflow()` that
    writes a character to the output stream and returns the EOF or the written character:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`extended_streambuf`的模板类，它继承自`std::basic_streambuf`类。重写一个名为`overflow()`的公共成员，该成员将字符写入输出流并返回EOF或已写入的字符：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, create a template class called `extended_ostream` that is derived from
    the `std::basic_ostream` class. In the private section, define a member of the
    `extended_streambuf` class, namely buffer. Initialize the `std::basic_ostream`
    parent class with a buffer member. Next, in the constructor body, invoke the `init()`
    function from the parent class with buffer as an argument. Also, overload the
    `rdbuf()` function, which returns a pointer to the buffer variable:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`extended_ostream`的模板类，它是从`std::basic_ostream`类派生而来的。在私有部分，定义一个`extended_streambuf`类的成员，即缓冲区。用缓冲区成员初始化`std::basic_ostream`父类。然后，在构造函数体中，使用缓冲区作为参数调用父类的`init()`函数。还要重载`rdbuf()`函数，该函数返回指向缓冲区变量的指针：
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Rename an `extendedOstream` class to the logger to avoid misunderstandings
    with similar names. Leave the existing interface as is but replace the `std::ostream&`
    member with our own stream, that is, `object - extended_ostream`. The complete
    class looks as follows:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`extendedOstream`类重命名为logger，以避免与类似名称的误解。保持现有接口不变，但用我们自己的流替换`std::ostream&`成员，即`object
    - extended_ostream`。完整的类如下所示：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Enter the `main` function and change the `extendedOstream` object to the `logger`
    object. Leave the rest of the code as is. Now, build and run the exercise. You
    will see the output that was given in the previous exercise but in this case,
    we used our own stream buffer, our own stream object, and a wrapper class that
    adds additional information to the output. Look at the result of the execution
    that''s shown in the following screenshot and compare it with the previous result.
    Make sure they are similar. If they are, that means we did a good job and our
    inherited classes work as expected:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数并将`extendedOstream`对象更改为`logger`对象。将其余代码保持不变。现在，构建并运行练习。您将看到在上一个练习中给出的输出，但在这种情况下，我们使用了自己的流缓冲区，自己的流对象和一个包装类，为输出添加了额外的信息。查看下面截图中显示的执行结果，并将其与先前的结果进行比较。确保它们是相似的。如果是这样，那就意味着我们做得很好，我们的继承类按预期工作：
- en: '![Figure 6.16: The result of executing Exercise 7](img/C14583_06_16.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16：执行练习7的结果](img/C14583_06_16.jpg)'
- en: 'Figure 6.16: The result of executing Exercise 7'
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：执行练习7的结果
- en: In this topic, we have done a lot and learned how to create additional streams
    in different ways. We considered all the appropriate classes for inheritance and
    which class is better to use for different needs. We also learned how to inherit
    from basic streambuf classes to implement work with external devices. Now, we
    will learn how to use I/O streams in an asynchronous way.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们做了很多工作，学会了如何以不同的方式创建额外的流。我们考虑了所有适当的继承类，以及哪个类更适合不同的需求。我们还学会了如何从基本streambuf类继承，以实现与外部设备的工作。现在，我们将学习如何以异步方式使用I/O流。
- en: Leveraging Asynchronous I/O
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用异步I/O
- en: There are a lot of cases where I/O operations can take a lot of time, for example,
    creating a backup file, searching a huge database, reading large files, and so
    on. You can use threads to execute I/O operations without blocking the application's
    execution. But for some applications, it's not a suitable way to handle long I/O,
    for example, when there can are thousands of I/O operations per second. In those
    cases, C++ developers use asynchronous I/O. It saves thread resources and ensure
    that the thread of the execution cannot be blocked. Let's consider what synchronous
    and asynchronous I/O is.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况下，I/O操作可能需要很长时间，例如创建备份文件，搜索大型数据库，读取大文件等。您可以使用线程执行I/O操作，而不阻塞应用程序的执行。但对于一些应用程序来说，处理长时间I/O的方式并不适合，例如当每秒可能有数千次I/O操作时。在这些情况下，C++开发人员使用异步I/O。它可以节省线程资源，并确保执行线程不会被阻塞。让我们来看看同步和异步I/O是什么。
- en: As you may recall from Chapter 5, The Philosophers' Dinner – Threads and Concurrency,
    synchronous operation means that some thread invokes the operation and waits for
    it to complete. It may be a single-threaded or multi-threaded application. The
    main point is that the thread is waiting for the I/O operation to complete.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得第5章《哲学家的晚餐-线程和并发》，同步操作意味着某个线程调用操作并等待其完成。它可以是单线程或多线程应用程序。关键是线程正在等待I/O操作完成。
- en: The asynchronous execution takes place when an operation does not block the
    execution of the working thread. The thread that performs the asynchronous I/O
    operation sends an asynchronous request and continues with another task. When
    the operation has finished, the initial thread will be notified about the finish
    and it can handle the results as necessary.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 异步执行发生在操作不阻塞工作线程的情况下。执行异步I/O操作的线程发送异步请求并继续执行另一个任务。当操作完成时，初始线程将收到完成通知，并可以根据需要处理结果。
- en: From this, it looks like asynchronous I/O is much better than synchronous, but
    it depends on the situation. If you need to perform lots of fast I/O operations,
    it would be more suitable to follow the synchronous way due to the overhead of
    processing kernel I/O requests and signals. Thus, you need to consider all possible
    scenarios while developing an architecture for your application.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度看，异步I/O似乎比同步更好，但这取决于情况。如果需要执行大量快速的I/O操作，由于处理内核I/O请求和信号的开销，更适合遵循同步方式。因此，在开发应用程序架构时，需要考虑所有可能的情况。
- en: The Standard Library doesn't support asynchronous I/O operations. So, to leverage
    asynchronous I/O, we need to consider alternative libraries or write our own implementations.
    First, let's consider platform-dependent implementations. Then, we will look at
    cross-platform libraries.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库不支持异步I/O操作。因此，为了利用异步I/O，我们需要考虑替代库或编写自己的实现。首先，让我们考虑依赖于平台的实现。然后，我们将看看跨平台库。
- en: Asynchronous I/O on Windows Platforms
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows平台上的异步I/O
- en: 'Windows supports I/O operations for a variety of devices: files, directories,
    drives, ports, pipes, sockets, terminals, and so on. In general, we use the same
    interface for I/O for all of these devices, but some settings differ from device
    to device. Let''s consider an I/O operation on a file in Windows.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Windows支持各种设备的I/O操作：文件、目录、驱动器、端口、管道、套接字、终端等。一般来说，我们对所有这些设备使用相同的I/O接口，但某些设置因设备而异。让我们考虑在Windows上对文件进行I/O操作。
- en: So, in Windows, we need to open a device and get a Handler for it. Different
    devices open in different ways. To open a file, directory, drive, or port, we
    use the `CreateFile` function from the `<Windows.h>` header. To open a pipe, we
    use the `CreateNamedPipe` function. To open a socket, we use the socket() and
    accept() functions. To open a terminal, we use the `CreateConsoleScreenBuffer`
    and `GetStdHandle` functions. All of them return a device handler that is used
    in all the functions for work with that device.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Windows中，我们需要打开设备并获取其处理程序。不同的设备以不同的方式打开。要打开文件、目录、驱动器或端口，我们使用`<Windows.h>`头文件中的`CreateFile`函数。要打开管道，我们使用`CreateNamedPipe`函数。要打开套接字，我们使用socket()和accept()函数。要打开终端，我们使用`CreateConsoleScreenBuffer`和`GetStdHandle`函数。它们都返回一个设备处理程序，该处理程序用于所有与该设备的操作。
- en: 'The `CreateFile` function takes seven parameters that manage the work with
    the opened device. The function declaration looks as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFile`函数接受七个参数，用于管理打开设备的操作。函数声明如下所示：'
- en: '[PRE84]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The first parameter is `pszName` – the path to the file. The second parameter
    calls `dwDesiredAccess` and manages access to the device. It can take one of the
    following values:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`pszName` - 文件的路径。第二个参数调用`dwDesiredAccess`并管理对设备的访问。它可以取以下值之一：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The third parameter, `dwShareMode`, manages how the OS should handle all the
    new `CreateFile` invocations when the file is already open. It can take one of
    the following values:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数`dwShareMode`管理操作系统在文件已经打开时如何处理所有新的`CreateFile`调用。它可以取以下值之一：
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The fourth parameter, `psa`, is usually set to `NULL`. The fifth parameter,
    `dwCreationDisposition`, manages whether the file be opened or created. It can
    take one of the following values:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个参数`psa`通常设置为`NULL`。第五个参数`dwCreationDisposition`管理文件是打开还是创建。它可以取以下值之一：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The sixth parameter, `dwFlagsAndAttributes`, manages the cache or work with
    the file. It can take one of the following values for managing caching:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个参数`dwFlagsAndAttributes`管理缓存或文件的操作。它可以取以下值之一来管理缓存：
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It can take one of the following values for managing work with files:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以取以下值之一来管理文件的操作：
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It can take one of the following values for file attributes:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以取以下值之一来管理文件属性：
- en: '[PRE90]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The last parameter, `hFileTemplate`, takes a handler to the open file or `NULL`
    as parameters. If the file handler is passed, the `CreateFile` function ignores
    all the attributes and flags and the use the attributes and flags of the open
    file.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`hFileTemplate`接受打开文件的句柄或`NULL`作为参数。如果传递了文件句柄，`CreateFile`函数将忽略所有属性和标志，并使用打开文件的属性和标志。
- en: 'That''s all regarding `CreateFile` parameters. If it cannot open a device,
    it returns `INVALID_HANDLE_VALUE`. The following example demonstrates how to open
    a file for reading:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于`CreateFile`参数的全部内容。如果无法打开设备，它将返回`INVALID_HANDLE_VALUE`。以下示例演示了如何打开文件进行读取：
- en: '[PRE91]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, to perform an input operation, we use the `ReadFile` function. It takes
    the file descriptor as the first parameter, the source buffer as the second parameter,
    the maximum number of bytes to read as the third parameter, the number of reading
    bytes as the fourth parameter, and the `NULL` value for synchronous execution
    or the pointer to a valid and unique OVERLAPPED structure as the last parameter.
    If the operation succeeds, the `ReadFile` returns true, or false otherwise. The
    following example demonstrates how to input from the previously opened file for
    reading:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要执行输入操作，我们使用`ReadFile`函数。它将文件描述符作为第一个参数，源缓冲区作为第二个参数，要读取的最大字节数作为第三个参数，读取字节数作为第四个参数，`NULL`值作为同步执行或者指向有效且唯一的OVERLAPPED结构的指针作为最后一个参数。如果操作成功，`ReadFile`返回true，否则返回false。以下示例演示了如何从先前打开的文件进行读取输入：
- en: '[PRE92]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To perform the output operation, we use the `WriteFile` function. It has the
    same declaration as `ReadFile`, but the third parameter sets the number of bytes
    to write and the fifth parameter is a number of written bytes. The following example
    demonstrates how to output to a previously opened file for writing:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行输出操作，我们使用`WriteFile`函数。它与`ReadFile`具有相同的声明，但第三个参数设置要写入的字节数，第五个参数是写入的字节数。以下示例演示了如何向先前打开的文件进行写入输出：
- en: '[PRE93]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To write cached data to a device, use the `FlushFileBuffer` function. It takes
    a single parameter – the file descriptor. Let''s move to the asynchronous I/O.
    To let the OS know that you plan to work with the device asynchronously, you need
    to open it with the `FILE_FLAG_OVERLAPPED` flag. Now, opening the file for writing
    or reading looks as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓存数据写入设备，使用`FlushFileBuffer`函数。它只有一个参数 - 文件描述符。让我们转向异步I/O。要让操作系统知道您计划异步地使用设备，需要使用`FILE_FLAG_OVERLAPPED`标志打开它。现在，打开文件进行写入或读取如下所示：
- en: '[PRE94]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We use the same operations to perform reading or writing to files, that is,
    `ReadFile` and `WriteFile`, with the only difference that the number of reads
    or wrote bytes are set to NULL and we must pass a valid and unique `OVERLAPPED`
    object. Let''s consider what the structure of the OVERLAPPED object is:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的操作来执行对文件的读取或写入，即`ReadFile`和`WriteFile`，唯一的区别是读取或写入的字节数设置为NULL，我们必须传递一个有效且唯一的`OVERLAPPED`对象。让我们考虑一下`OVERLAPPED`对象的结构是什么：
- en: '[PRE95]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The Internal member is set to `STATUS_PENDING`, which means that the operation
    hasn't started yet. The number of read or wrote bytes will be written into the
    `InternalHigh` member. `Offset` and `OffsetHigh` are ignored in asynchronous operations.
    The `hEvent` member is used for receiving events about the completion of the asynchronous
    operation.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 内部成员设置为`STATUS_PENDING`，这意味着操作尚未开始。读取或写入的字节数将写入`InternalHigh`成员。在异步操作中，`Offset`和`OffsetHigh`将被忽略。`hEvent`成员用于接收有关异步操作完成的事件。
- en: Note
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the I/O operations is not guaranteed, so you cannot rely on this.
    If you plan to write to a file at one place, and read from a file at another place,
    you cannot rely on the order.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: I/O操作的顺序不能保证，因此您不能依赖于此。如果您计划在一个地方写入文件，并在另一个地方从文件中读取，您不能依赖于顺序。
- en: There is one unusual thing in working with `ReadFile` and `WriteFile` in asynchronous
    mode. They return a non-zero value if the I/O request was performed synchronously.
    If they return `FALSE`, you need to invoke the `GetLastError` function to check
    why `FALSE` was returned. If the error code is `ERROR_IO_PENDING`, this means
    that the I/O request was successfully handled, is in a pending state, and will
    be performed later.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步模式下使用`ReadFile`和`WriteFile`时有一个不寻常的地方。如果它们以同步方式执行I/O请求，则返回一个非零值。如果它们返回`FALSE`，你需要调用`GetLastError`函数来检查为什么返回了`FALSE`。如果错误代码是`ERROR_IO_PENDING`，这意味着I/O请求已成功处理，处于挂起状态，并将在以后执行。
- en: The last thing that you should remember is that you can't move or remove the
    `OVERLAPPED` object or buffer with data until the I/O operation finishes. For
    each I/O operation, you should create a new OVERLAPPED object.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住的最后一件事是，在I/O操作完成之前，不能移动或删除`OVERLAPPED`对象或数据缓冲区。对于每个I/O操作，你应该创建一个新的OVERLAPPED对象。
- en: 'Finally, let''s consider the ways in which the system notifies us about completing
    the I/O operation. There are a few such mechanisms: releasing the device, releasing
    the event, producing an alert, and using I/O ports.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑系统通知我们完成I/O操作的方式。有几种这样的机制：释放设备、释放事件、产生警报和使用I/O端口。
- en: '`WriteFile` and `ReadFile` functions set a device to the "occupied" state.
    When the I/O operation is finished, the driver sets a device to the "free" state.
    We can check if the finished I/O operation is invoking the `WaitForSingleObject`
    or `WaitForMultipleObject` functions. The following example demonstrates this
    approach:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteFile`和`ReadFile`函数将设备设置为“占用”状态。当I/O操作完成时，驱动程序将设备设置为“空闲”状态。我们可以通过调用`WaitForSingleObject`或`WaitForMultipleObject`函数来检查完成的I/O操作。以下示例演示了这种方法：'
- en: '[PRE96]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is the easiest way to check if the I/O operation has finished. But this
    approach makes the calling thread wait on the `WaitForSingleObject` call, so it
    becomes a synchronous call. Moreover, you can initiate a few I/O operations for
    this device, but you cannot be sure that the thread will wake up on the needed
    release of the device.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检查I/O操作是否已完成的最简单方法。但这种方法使调用线程在`WaitForSingleObject`调用上等待，因此它变成了一个同步调用。此外，你可以为该设备启动几个I/O操作，但不能确定线程是否会在需要释放设备时唤醒。
- en: '`CreateEvent` function and set it to the `OVERLAPPED` object. Then, when the
    I/O operation has finished, the system releases this event by calling the `SetEvent`
    function. Next, when the calling thread needs to get the result of an executing
    I/O operation, you invoke `WaitForSingleObject` and pass the descriptors for this
    event. The following example demonstrates this approach:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CreateEvent`函数并将其设置为`OVERLAPPED`对象。然后，当I/O操作完成时，系统通过调用`SetEvent`函数释放此事件。接下来，当调用线程需要获取正在执行的I/O操作的结果时，你调用`WaitForSingleObject`并传递此事件的描述符。以下示例演示了这种方法：
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It's a pretty easy approach if you wish to notify the calling thread about the
    end of the I/O operation. But this is not the ideal way to do this because when
    there are a lot of these operations, you need to create an event object for each
    of them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望通知调用线程I/O操作的结束，这是一个相当简单的方法。但这并不是最理想的做法，因为当有很多这样的操作时，你需要为每个操作创建一个事件对象。
- en: '`ReadFileEx` and `WriteFileEx` to the input/output. They are similar to the
    standard `ReadFile` and `WriteFile`, but we don''t pass the variable that stores
    the number of read or wrote characters and we pass an address of the callback
    function. This callback function is called a completion routine and has the following
    declaration:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFileEx`和`WriteFileEx`用于输入/输出。它们类似于标准的`ReadFile`和`WriteFile`，但我们不传递存储读取或写入字符数的变量，而是传递回调函数的地址。这个回调函数被称为完成例程，并且具有以下声明：'
- en: '[PRE98]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`ReadFileEx` and `WriteFileEx` pass the address of the callback function to
    the device driver. When the operation has finished on the device, the driver adds
    the address of the callback function to the APC queue and the pointer to the OVERLAPPED
    structure. Then, the OS invokes this function and passes the number of read or
    wrote bytes, error code, and pointer to the OVERLAPPED structure.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFileEx`和`WriteFileEx`将回调函数的地址传递给设备驱动程序。当设备上的操作完成时，驱动程序将回调函数的地址添加到APC队列和OVERLAPPED结构的指针。然后，操作系统调用此函数并传递读取或写入的字节数、错误代码和OVERLAPPED结构的指针。'
- en: The main cons of this approach are writing callback functions and using a lot
    of global variables because callback functions have a small amount of information
    in the context. Another reason not to use this approach is that only the calling
    thread can receive the notification regarding completion.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是编写回调函数和使用大量全局变量，因为回调函数在上下文中包含少量信息。不使用这种方法的另一个原因是只有调用线程才能接收有关完成的通知。
- en: 'Now that we''ve gone over the bad, let''s look at the best approach for handling
    I/O results – I/O ports. The I/O completion ports are developed to be used with
    thread pools. To create such a port, we use `CreateIoCompletionPort`. The declaration
    of this function looks as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了不好的地方，让我们看看处理I/O结果的最佳方法 - I/O端口。I/O完成端口是为与线程池一起使用而开发的。要创建这样一个端口，我们使用`CreateIoCompletionPort`。该函数的声明如下：
- en: '[PRE99]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This function creates an I/O completion port and associates the device with
    this port. To complete this action, we need to call it twice. To create the new
    completion port, we invoke the `CreateIoCompletionPort` function and pass `INVALID_HANDLE_VALUE`
    as the first parameter, NULL as a second parameter, 0 as a third parameter, and
    pass the number of the threads for this port. Passing 0 as the fourth parameter
    will set the number of threads equal to the number of processors.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个I/O完成端口并将设备与此端口关联。要完成此操作，我们需要调用两次。要创建新的完成端口，我们调用`CreateIoCompletionPort`函数，并将`INVALID_HANDLE_VALUE`作为第一个参数传递，NULL作为第二个参数，0作为第三个参数，并传递此端口的线程数。将0作为第四个参数将使线程数等于处理器的数量。
- en: Note
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the I/O completion port, it is recommended to use the number of threads
    that is equal to the number of processors, multiplied twice.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于I/O完成端口，建议使用线程数等于处理器数量的两倍。
- en: 'Next, we need to associate this port with the input/output device. So, we invoke
    the `CreateIoCompletionPort` function for the second time and pass a descriptor
    of the device, a descriptor of the created completion port, the constant that
    will indicate reading or writing to the device, and 0 as the number of threads.
    Then, when we need to get the result of completion, we call `GetQueuedCompletionStatus`
    from our port descriptor. If the operation completes, the function returns a result
    immediately. If it doesn''t, then the thread waits to complete. The following
    example demonstrates this approach:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此端口与输入/输出设备关联起来。因此，我们第二次调用`CreateIoCompletionPort`函数，并传递设备的描述符、创建的完成端口的描述符、将指示对设备进行读取或写入的常量，以及0作为线程数。然后，当我们需要获取完成的结果时，我们从我们的端口描述符调用`GetQueuedCompletionStatus`。如果操作完成，函数会立即返回结果。如果没有完成，线程就会等待完成。以下示例演示了这种方法：
- en: '[PRE100]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Asynchronous I/O on Linux Platforms
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux平台上的异步I/O
- en: The asynchronous I/O on Linux supports input and output to different devices
    such as sockets, pipes, and TTYs, except files. Yes, this is pretty strange, but
    Linux developers decided that I/O operations with files are fast enough.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的异步I/O支持对不同设备进行输入和输出，如套接字、管道和TTY，但不包括文件。是的，这很奇怪，但Linux开发人员决定文件的I/O操作已经足够快了。
- en: 'To open an I/O device, we use the open() function. It has the following declaration:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开I/O设备，我们使用open()函数。它的声明如下：
- en: '[PRE101]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The first parameter is a filename, while the second parameter is a bitmask that
    controls how the file should be opened. If the system cannot open the device,
    open() returns a value of -1\. In the case of success, it returns a device descriptor.
    The possible flags for open mode are `O_RDONLY`, `O_WRONLY`, and `O_RDWR`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是文件名，而第二个参数是一个控制文件应如何打开的位掩码。如果系统无法打开设备，open()返回值为-1。在成功的情况下，它返回一个设备描述符。open模式的可能标志是`O_RDONLY`、`O_WRONLY`和`O_RDWR`。
- en: To perform input/output operations, we use the `POSIX` interface called `aio`.
    They have a defined set of functions such as `aio_read`, `aio_write`, `aio_fsync`,
    and so on. They are used to initiate the asynchronous operations. To get the result
    of execution, we can use signal notification or the instantiation of a thread.
    Alternatively, we can choose not to be notified at all. All of them are declared
    in the `<aio.h>` header.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行输入/输出操作，我们使用名为`aio`的`POSIX`接口。它们有一组定义好的函数，如`aio_read`、`aio_write`、`aio_fsync`等。它们用于启动异步操作。要获取执行结果，我们可以使用信号通知或实例化线程。或者，我们可以选择不被通知。所有这些都在`<aio.h>`头文件中声明。
- en: 'Almost all of these take the `aiocb` structure (asynchronous IO control block)
    as a parameter. It controls the IO operations. The declaration of this structure
    looks as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些都以`aiocb`结构（异步IO控制块）作为参数。它控制IO操作。该结构的声明如下：
- en: '[PRE102]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `aio_fildes` member is a descriptor to the opened device, while the `aio_offset`
    member is an offset in the device where read or write operations should be done.
    The `aio_buf` member is a pointer to the buffer to read or write from. The `aio_nbytes`
    member is the size of the buffer. The `aio_reqprio` member is the priority of
    the execution of this IO operation. The `aio_sigevent` member is a structure that
    points out how the calling thread should be notified about the finish. The `aio_lio_opcode`
    member is a type of I/O operation. The following example demonstrates how to initialize
    the `aiocb` structure:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`aio_fildes`成员是打开设备的描述符，而`aio_offset`成员是在进行读取或写入操作的设备中的偏移量。`aio_buf`成员是指向要读取或写入的缓冲区的指针。`aio_nbytes`成员是缓冲区的大小。`aio_reqprio`成员是此IO操作执行的优先级。`aio_sigevent`成员是一个指出调用线程应如何被通知完成的结构。`aio_lio_opcode`成员是I/O操作的类型。以下示例演示了如何初始化`aiocb`结构：'
- en: '[PRE103]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, we created a buffer for reading file content, namely `fileContent`. Then,
    we created an `aiocb` structure called `aiocbObj`. Next, we opened a file for
    reading and checked if this operation was successful. Then, we set the pointer
    to a buffer and a buffer size. The buffer size tells the driver how many bytes
    should be read or wrote. Next, we pointed out that we will read from the beginning
    of the file by setting the offset to 0\. Then, we set the notification type in
    `SIGEV_SIGNAL`, which means we would like to get a signal notification about the
    finish operation. Then, we set the signal number, which should trigger the notification
    about the finish. In our case, it's `SIGUSR1` – the user-defined signal. Next,
    we set the pointer to the `aiocb` structure to the signal handler.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为读取文件内容创建了一个缓冲区，即`fileContent`。然后，我们创建了一个名为`aiocbObj`的`aiocb`结构。接下来，我们打开了一个文件进行读取，并检查了这个操作是否成功。然后，我们设置了指向缓冲区和缓冲区大小的指针。缓冲区大小告诉驱动程序应该读取或写入多少字节。接下来，我们指出我们将从文件的开头读取，将偏移量设置为0。然后，我们设置了`SIGEV_SIGNAL`中的通知类型，这意味着我们希望得到有关完成操作的信号通知。然后，我们设置了应触发完成通知的信号号码。在我们的情况下，它是`SIGUSR1`
    - 用户定义的信号。接下来，我们将`aiocb`结构的指针设置为信号处理程序。
- en: After the creation and correct initialization of an `aiocb` structure, we can
    perform input or output operations. Let's complete an exercise to understand how
    to use async I/O on Linux platforms.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和正确初始化`aiocb`结构之后，我们可以执行输入或输出操作。让我们完成一个练习，以了解如何在Linux平台上使用异步I/O。
- en: 'Exercise 8: Asynchronously Reading from a File in Linux'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：在Linux上异步读取文件
- en: 'In this exercise, we will develop an application that reads data from a file
    in an asynchronous way and outputs the read data to the console. When the read
    operation is performed, the driver notifies the application using the triggering
    signal. To do this exercise, perform the following steps:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将开发一个应用程序，以异步方式从文件中读取数据，并将读取的数据输出到控制台。当执行读取操作时，驱动程序使用触发信号通知应用程序。要完成这个练习，执行以下步骤：
- en: 'Include all the required headers: `<aio.h>` for asynchronous reading and writing
    support, `<signal.h>` for signal support, `<fcntl.h>` for operations with files,
    `<unistd.h>` for symbolic constants support, `<iostream>` for output to the Terminal,
    `<chrono>` for time options, and `<thread>` for threading support:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所有必需的头文件：`<aio.h>`用于异步读写支持，`<signal.h>`用于信号支持，`<fcntl.h>`用于文件操作，`<unistd.h>`用于符号常量支持，`<iostream>`用于输出到终端，`<chrono>`用于时间选项，`<thread>`用于线程支持：
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create a bool variable called `isDone` that will indicate when the operation
    has been completed:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`isDone`的bool变量，用于指示操作何时已完成：
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Define the function that will be our signal handler, that is, `aioSigHandler`.
    It will be called when the async operation is done. Signal handlers should have
    the following signature:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将作为我们的信号处理程序的函数，即`aioSigHandler`。当异步操作完成时将调用它。信号处理程序应具有以下签名：
- en: '[PRE106]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The first parameter is a signal number, the second parameter is a structure
    that contains information about why the signal was generated, and the last parameter
    is additional information. It can be cast to a pointer of the `ucontext_t` structure
    so that we can receive the thread context that was interrupted by this signal.
    In `aioSigHandler`, check whether the signal regarding the async I/O operation
    is constant using `SI_ASYNCIO`. If so, output a message. Next, set `isDone` to
    `true`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是信号编号，第二个参数是一个包含有关信号生成原因的信息的结构，最后一个参数是附加信息。它可以转换为`ucontext_t`结构的指针，以便我们可以接收到被该信号中断的线程上下文。在`aioSigHandler`中，检查异步I/O操作相关的信号是否是常量，使用`SI_ASYNCIO`。如果是，输出一条消息。接下来，将`isDone`设置为`true`：
- en: '[PRE107]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Define another helping function called `initSigAct`. It will initialize the
    `sigaction` structure. This structure defines which signal will be sent on the
    I/O operation''s finish and which handler should be called. Here, we chose `SIGUSR1`
    – a user-defined signal. In `sa_flags`, set that we want this signal to be delivered
    on action restart or information received:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个辅助函数，名为`initSigAct`。它将初始化`sigaction`结构。该结构定义了在I/O操作完成时将发送哪个信号以及应调用哪个处理程序。在这里，我们选择了`SIGUSR1`
    - 一个用户定义的信号。在`sa_flags`中，设置我们希望在操作重新启动或接收到信息时传递此信号：
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Define the helping function called `fillAiocb`, which fills in the `aiocb`
    structure with the given parameters. It will take the reference to the aiocb structure,
    the file descriptor, the pointer to a buffer, and the buffer''s size as parameters.
    Set `sigev_signo` in `SIGUSR1`, which we initialized previously:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义名为`fillAiocb`的辅助函数，它将使用给定的参数填充`aiocb`结构。它将以aiocb结构的引用、文件描述符、缓冲区指针和缓冲区大小作为参数。在`sigev_signo`中设置`SIGUSR1`，这是我们之前初始化的：
- en: '[PRE109]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Enter the `main` function. Define the variable called `buf_size`, which holds
    the buffer size. Create a buffer of that size:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main`函数。定义名为`buf_size`的变量，其中包含缓冲区大小。创建一个该大小的缓冲区：
- en: '[PRE110]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create a variable called `fileName` that holds a file called "`Test.txt`".
    Then, open this file with read-only access:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fileName`的变量，其中包含一个名为"`Test.txt`"的文件。然后，以只读方式打开此文件：
- en: '[PRE111]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create a `sigaction` structure and initialize it using the `initSigAct` function:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sigaction`结构并使用`initSigAct`函数进行初始化：
- en: '[PRE112]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Create an `aiocb` structure and initialize it using the `fillAiocb` function:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`aiocb`结构并使用`fillAiocb`函数进行初始化：
- en: '[PRE113]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Perform a `read` operation using the `aio_read` function:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`aio_read`函数执行`read`操作：
- en: '[PRE114]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, in the loop, evaluate the `isDone` variable. If it is false, make the
    thread sleep for `3ms`. By doing this, we will wait for the I/O operation to finish:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在循环中，评估`isDone`变量。如果它为false，则使线程休眠`3ms`。通过这样做，我们将等待I/O操作完成：
- en: '[PRE115]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Before running this exercise, create a `Test.txt` file in the project directory
    and write different symbols. For example, our file contains the following data:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行此练习之前，在项目目录中创建一个`Test.txt`文件，并写入不同的符号。例如，我们的文件包含以下数据：
- en: '[PRE116]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, there's alphabetical characters, numerical characters, special symbols,
    spaces, tabulation characters, and newline characters.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有字母字符、数字字符、特殊符号、空格、制表符和换行符。
- en: 'Now, build and run this exercise in your IDE. Your output will be similar to
    the following:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的IDE中构建并运行此练习。您的输出将类似于以下内容：
- en: '![](img/C14583_06_17.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_17.jpg)'
- en: 'Figure 6.17: The result of executing Exercise 8'
  id: totrans-446
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：执行练习8的结果
- en: You can see that the file was successfully opened for reading and that we successfully
    set the `SIGUSR1` signal and handler for it. Then, we received signal number 30,
    that is, the `SI_ASYNCIO` signal. Finally, we can output what we have read and
    compare it with the file content. By doing this, we can ensure that all the data
    was read correctly.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到文件已成功打开进行读取，并且我们成功设置了`SIGUSR1`信号和其处理程序。然后，我们收到信号编号30，即`SI_ASYNCIO`信号。最后，我们可以输出我们已读取的内容并将其与文件内容进行比较。通过这样做，我们可以确保所有数据都已正确读取。
- en: That's all for async I/O in Linux systems.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Linux系统中的异步I/O的全部内容。
- en: Note
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about asynchronous IO in Linux by going to Linux''s
    man pages: http://man7.org/linux/man-pages/man7/aio.7.html.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问Linux的man页面了解有关Linux中异步IO的更多信息：http://man7.org/linux/man-pages/man7/aio.7.html。
- en: Now, let's learn about what we can use for cross-platform applications.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下我们可以用于跨平台应用的内容。
- en: Asynchronous Cross-Platform I/O Libraries
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步跨平台I/O库
- en: 'We''ve already considered the platform-specific decision for asynchronous I/O.
    Now, to write a cross-platform application, you can use these platform-specific
    approaches and use them with preprocessor directives; for example:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了特定于平台的异步I/O的决定。现在，要编写一个跨平台应用程序，您可以使用这些特定于平台的方法，并将它们与预处理器指令一起使用；例如：
- en: '[PRE117]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In both the headers, you can declare the same interface for platform-specific
    implementations. You can also implement your own AIO library, which will use some
    state machines or queue in the separate thread. Also, you can use some of the
    free libraries that implement the necessary features. The most popular library
    is `Boost.Asio`. It provides a lot of interfaces for asynchronous work, such as
    the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个头文件中，您可以为特定于平台的实现声明相同的接口。您还可以实现自己的AIO库，该库将在单独的线程中使用一些状态机或队列。此外，您可以使用一些实现所需功能的免费库。最流行的库是`Boost.Asio`。它提供了许多用于异步工作的接口，例如以下内容：
- en: Concurrency without threads
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需线程的并发
- en: Threads
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Buffers
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区
- en: Streams
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Coroutines
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: TCP, UDP, and ICMP
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP、UDP和ICMP
- en: Sockets
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: SSL
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL
- en: Timers
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Serial ports
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串口
- en: 'Let''s briefly consider its interface for I/O operations. We can use the interface
    of the `Asio` library for synchronous and asynchronous operations. All of the
    I/O operations start from the `io_service` class, which provides core I/O functionality.
    It is declared in the `<boost/asio/io_service.hpp>` header file. The synchronous
    I/O invokes the `run()` function of the `io_service` object for a single operation
    that blocks the calling thread until the job is done. The asynchronous I/O uses
    the `run()`, `run_one()`, `poll()`, and `poll_one()` functions. The `run()` function
    runs the event loop to process request handlers. The `run_one()` function does
    the same, but the event loop should process only one handler. The `poll()` function
    runs the event loop to execute all the ready handlers. `poll_one()` does the same
    but only for one handler. The following example demonstrates the usage of all
    these functions:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地考虑一下它的I/O操作接口。我们可以使用`Asio`库的接口进行同步和异步操作。所有I/O操作都始于`io_service`类，该类提供核心I/O功能。它在`<boost/asio/io_service.hpp>`头文件中声明。同步I/O调用`io_service`对象的`run()`函数进行单个操作，该操作会阻塞调用线程，直到工作完成。异步I/O使用`run()`、`run_one()`、`poll()`和`poll_one()`函数。`run()`函数运行事件循环以处理请求处理程序。`run_one()`函数执行相同的操作，但事件循环只处理一个处理程序。`poll()`函数运行事件循环以执行所有准备好的处理程序。`poll_one()`执行相同的操作，但只针对一个处理程序。以下示例演示了所有这些函数的用法：
- en: '[PRE118]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'It''s possible to run the event handler before the actual I/O operations are
    called. Use the working class with the `io_service` class to implement this feature
    in your code. The work class guarantees that the run function will not return
    until you''ve decided that there will not be any future I/O operations. For example,
    you can make the working class a member of another class and remove it from the
    destructor. So, during the lifetime of your class, `io_service` will be running:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际进行I/O操作之前，可以运行事件处理程序。使用`io_service`类的工作类在代码中实现此功能。工作类保证`run`函数在您决定不会有任何未来的I/O操作之前不会返回。例如，您可以将工作类作为另一个类的成员，并在析构函数中将其移除。因此，在您的类的生命周期内，`io_service`将一直运行：
- en: '[PRE119]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, to perform any I/O operations, we need the exact the I/O device, for
    example, file, socket, and so on. There are many classes that implement work with
    different I/O devices, for example, `boost::asio::ip::tcp::socket` from the `<boost/asio/ip/tcp.hpp>`
    header. Next, to read and write to the socket, we make use of `boost::asio::async_read`
    and `boost::asio::async_write`. They take a socket, `boost::asio::buffer`, and
    the callback function as parameters. When the async operation is performed, the
    callback function is invoked. We can pass a lambda function as a callback function
    or bind an existing function using the boost::bind function. `boost::bind` creates
    a callable object. The following example demonstrates how to write to a socket
    using `Boost::Asio`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要执行任何I/O操作，我们需要确切的I/O设备，例如文件、套接字等。有许多类实现了与不同I/O设备的工作，例如`<boost/asio/ip/tcp.hpp>`头文件中的`boost::asio::ip::tcp::socket`。接下来，要读取和写入套接字，我们使用`boost::asio::async_read`和`boost::asio::async_write`。它们将套接字、`boost::asio::buffer`和回调函数作为参数。执行异步操作时，将调用回调函数。我们可以将lambda函数作为回调函数传递，也可以使用boost::bind函数绑定现有函数。`boost::bind`创建一个可调用对象。以下示例演示了如何使用`Boost::Asio`写入套接字：
- en: '[PRE120]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here, we used lambda functions as callbacks for async I/O operations.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用lambda函数作为异步I/O操作的回调函数。
- en: Note
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `Boost.Asio` is well-documented at https://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html.
    There are lots of examples with different IO devices and different approaches.
    You can refer to this documentation if you decide to use `Boost.Asio` in your
    projects.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio`在https://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html上有很好的文档。有许多不同IO设备和不同方法的示例。如果您决定在项目中使用`Boost.Asio`，可以参考此文档。'
- en: Here, we've considered different ways we can implement asynchronous I/O operations.
    Depending on your requirements, environment, and allowed utilities, you can choose
    the appropriate way to implement asynchronous I/O in your applications. Remember
    that if you choose to perform many fast I/O operations, it's better to do them
    in a synchronous way as it doesn't take up a lot of system resources. Now that
    we know how to leverage asynchronous I/O, let's learn how to use I/O in multithreaded
    applications.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们考虑了实现异步I/O操作的不同方式。根据您的要求、环境和允许的实用程序，您可以选择适当的方式在应用程序中实现异步I/O。请记住，如果选择执行许多快速I/O操作，最好以同步方式执行，因为它不会占用大量系统资源。现在我们知道如何利用异步I/O，让我们学习如何在多线程应用程序中使用I/O。
- en: Interaction of Threads and I/O
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程和I/O的交互
- en: The I/O Standard Library is not thread-safe. In the documentation of the Standard
    Library, we can find an explanation that states that the concurrent access to
    the stream or stream buffer can lead to a data race and, as a result, an undefined
    behavior. To avoid this, we should synchronize access to the streams and buffers
    using the techniques that we learned about in *Chapter 5*, *The Philosophers'
    Dinner – Threads and Concurrency*.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: I/O标准库不是线程安全的。在标准库的文档中，我们可以找到一个解释，说明并发访问流或流缓冲区可能导致数据竞争，从而导致未定义的行为。为了避免这种情况，我们应该使用我们在*第5章*，*哲学家的晚餐-线程和并发性*中学到的技术来同步对流和缓冲区的访问。
- en: 'Let''s talk a little bit about the `std::cin` and `std::cout` objects. Each
    call to them is thread-safe, but let''s consider the following example:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈`std::cin`和`std::cout`对象。对它们的每次调用都是线程安全的，但让我们考虑以下例子：
- en: '[PRE121]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In this line, we see that `std::cout` is called once, but each call to the
    shift operator is actually a different call to the `std::cout` object. So, we
    can rewrite this line as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们看到`std::cout`只被调用一次，但每次对移位运算符的调用实际上是对`std::cout`对象的不同调用。因此，我们可以将这一行重写如下：
- en: '[PRE122]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This code does exactly the same as the previous single line, that is, if you
    call this single line from the different threads, your output will be mixed and
    unclear. You can modify it to make it really thread-safe like so:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与前面的单行代码完全相同，也就是说，如果您从不同的线程调用这个单行代码，您的输出将混合在一起，不清晰。您可以修改它以使其真正线程安全，如下所示：
- en: '[PRE123]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: So, if you output to the Terminal using the second method, your output will
    be clear and thread-safe. This behavior can vary, depending on the compiler or
    std library version. You also have to know that `std::cout` and `std::cin` are
    synchronized among them. This means that invoking `std::cout` always flushes the
    `std::cin` stream and the invocation of `std::cin` always flushes the `std::cout`
    stream.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您使用第二种方法向终端输出，您的输出将清晰且线程安全。这种行为可能会有所不同，具体取决于编译器或std库版本。您还必须知道`std::cout`和`std::cin`在它们之间是同步的。这意味着调用`std::cout`总是刷新`std::cin`流，调用`std::cin`总是刷新`std::cout`流。
- en: The best approach is to wrap all I/O operations in a guard class that will control
    access to the stream using mutexes. If you need to output to the Terminal from
    multiple threads using `std::cout`, you can implement a very simple class that
    does nothing but lock the mutex and invoke `std::cout`. Let's complete an exercise
    and create such class.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是将所有I/O操作封装在一个保护类中，该类将使用互斥锁控制对流的访问。如果您需要从多个线程使用`std::cout`输出到终端，您可以实现一个非常简单的类，它除了锁定互斥锁并调用`std::cout`之外什么也不做。让我们完成一个练习并创建这样的类。
- en: 'Exercise 9: Developing a Thread-Safe Wrapper for std::cout'
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：为std::cout开发一个线程安全的包装器
- en: 'In this exercise, we will develop a simple `std::cout` wrapper that produces
    a thread-safe output. We will write a small test function to check how it works.
    Let''s start and perform the following steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将开发一个简单的`std::cout`包装器，用于生成线程安全的输出。我们将编写一个小的测试函数来检查它的工作原理。让我们开始并执行以下步骤：
- en: 'Include all the required headers:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所有必需的头文件：
- en: '[PRE124]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now, let's think about our wrapper. We can create a variable of this class somewhere
    and pass it to each created thread. However, this is a bad decision because in
    complex applications, this will take a lot of effort. We can also do this as a
    singleton so that we have access to it from everywhere. Next, we have to think
    about the content of our class. Actually, we can use the classes that we created
    in *Exercise 7*, *Inheriting the Standard Stream Object*. In that exercise, we
    overloaded `std::basic_streambuf` and `std::basic_ostream` and set `std::cout`
    as the output device. We can add a mutex to the overloaded function and use it
    as is. Note that we don't need any additional logic – just the output data using
    `std::cout`. To do this, we can create a simpler class. If we did not set the
    output device, applying the left shift operator will not take effect and will
    store the data to be outputted in the internal buffer. Great! Now, we need to
    think about how to get this buffer to output using `std::cout`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下我们的包装器。我们可以在某个地方创建这个类的变量，并将其传递给每个创建的线程。然而，这是一个不好的决定，因为在复杂的应用程序中，这将需要大量的工作。我们也可以将其作为单例来做，这样我们就可以从任何地方访问它。接下来，我们必须考虑我们的类的内容。实际上，我们可以使用我们在*练习7*中创建的类，*继承标准流对象*。在那个练习中，我们重载了`std::basic_streambuf`和`std::basic_ostream`，并将`std::cout`设置为输出设备。我们可以在重载函数中添加一个互斥锁并直接使用它。请注意，我们不需要任何额外的逻辑-只需使用`std::cout`输出数据。为此，我们可以创建一个更简单的类。如果我们没有设置输出设备，应用左移运算符将不会生效，并且将存储要输出的数据到内部缓冲区。太好了！现在，我们需要考虑如何将这个缓冲区输出到`std::cout`。
- en: 'Implement a function such as `write()` that will lock a mutex and output to
    `std::cout` from the internal buffer. The usage of this function will look as
    follows:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个诸如`write()`的函数，它将锁定互斥锁并从内部缓冲区输出到`std::cout`。使用这个函数的方式将如下所示：
- en: '[PRE125]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We have one function that will always be called automatically, and we can put
    the code of the write function into it. It''s a destructor. In this case, we combine
    the creation and destruction into a single line. The usage of such an object will
    look as follows:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个函数将始终自动调用，并且我们可以将写函数的代码放入其中。这是一个析构函数。在这种情况下，我们将创建和销毁合并为一行。这样一个对象的使用将如下所示：
- en: '[PRE126]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, let''s define our `mtcout` (multithreaded cout) class. It has a public
    default constructor. In the private section, it has a static mutex variable. As
    you may recall, the static variable is shared among all the instances of the class.
    In the destructor, we lock the mutex and output using cout. Add a prefix to the
    output – the ID of the current thread and a space character:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的`mtcout`（多线程cout）类。它有一个公共默认构造函数。在私有部分，它有一个静态互斥变量。正如你可能记得的那样，静态变量在类的所有实例之间是共享的。在析构函数中，我们锁定互斥锁并使用cout输出。在输出中添加一个前缀-当前线程的ID和一个空格字符：
- en: '[PRE127]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, declare the `mutex` variable outside the class. We are doing this because
    we must declare a static variable in any source file:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在类外声明`mutex`变量。我们这样做是因为我们必须在任何源文件中声明一个静态变量：
- en: '[PRE128]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Enter the main function. Create a lambda called `func`. It will test our `mtcout`
    class. It takes string as a parameter and outputs this string in the loop from
    `0` to `1000` using `mtcout`. Add the same output using `std::cout` and comment
    it out. Compare the output in both cases:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入主函数。创建一个名为`func`的lambda。它将测试我们的`mtcout`类。它以字符串作为参数，并在循环中使用`mtcout`从`0`到`1000`输出这个字符串。使用`std::cout`添加相同的输出并将其注释掉。比较两种情况下的输出：
- en: '[PRE129]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create four threads and pass a lambda function as a parameter. Pass different
    strings to each thread. Finally, join all four threads:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个线程并将lambda函数作为参数传递。将不同的字符串传递给每个线程。最后，加入所有四个线程：
- en: '[PRE130]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Build and run the exercise for the first time. You will get the following output:![Figure
    6.18: The result of executing Exercise 9, part 1](img/C14583_06_18.jpg)'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次构建和运行练习。您将获得以下输出：![图6.18：执行练习9，第1部分的结果](img/C14583_06_18.jpg)
- en: 'Figure 6.18: The result of executing Exercise 9, part 1'
  id: totrans-504
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：执行练习9，第1部分的结果
- en: Here, we can see that each of threads outputs its own message. This message
    has not been interrupted and the output looks clear.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每个线程都输出自己的消息。这条消息没有被中断，输出看起来很清晰。
- en: Now, uncomment the output with `std::cout` in the lambda and comment out the
    output using `mtcout`.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，取消lambda中使用`std::cout`的输出，并注释掉使用`mtcout`的输出。
- en: 'Again, build and run the application. Now, you will get a "dirty", mixed output,
    like the following:![Figure 6.19: The result of executing Exercise 9, part 2](img/C14583_06_19.jpg)'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建和运行应用程序。现在，您将获得一个"脏"的、混合的输出，如下所示：![图6.19：执行练习9，第2部分的结果](img/C14583_06_19.jpg)
- en: 'Figure 6.19: The result of executing Exercise 9, part 2'
  id: totrans-508
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：执行练习9，第2部分的结果
- en: 'You can see this mixed output because we don''t output a single string; instead,
    we invoke `std::cout` four times:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这种混合输出，因为我们没有输出单个字符串；相反，我们调用`std::cout`四次：
- en: '[PRE131]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Sure, we can format the string before outputting it, but it is more convenient
    to use the mtcout class and not have to worry about formatting. You can create
    similar wrappers for any stream so that you can perform I/O operations safely.
    You can change the output and add any additional information, such as the ID of
    the current thread, time, or whatever you need. Employ the things we learned about
    in *Chapter 5*, *The Philosophers' Dinner – Threads and Concurrency*, to synchronize
    the I/O operations, extend streams and make the output more useful for your needs.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在输出之前格式化字符串，但使用mtcout类更方便，不必担心格式。您可以为任何流创建类似的包装器，以便安全地执行I/O操作。您可以更改输出并添加任何其他信息，例如当前线程的ID、时间或您需要的任何其他信息。利用我们在*第5章*中学到的关于同步I/O操作、扩展流并使输出对您的需求更有用的东西。
- en: Using Macros
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用宏
- en: 'In the activity for this chapter, we will use macro definitions to simplify
    and beautify our code, so let''s do a refresher on how to use them. Macro definitions
    are preprocessor directives. The syntax of the macro definition is as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的活动中，我们将使用宏定义来简化和美化我们的代码，所以让我们回顾一下如何使用它们。宏定义是预处理器指令。宏定义的语法如下：
- en: '[PRE132]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Here, [name] is any meaningful name and[expression] is any small function or
    value.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，[name]是任何有意义的名称，[expression]是任何小函数或值。
- en: 'When the preprocessor faces the macro name, it replaces it with the expression.
    For example, let''s say you have the following macro:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当预处理器面对宏名称时，它将其替换为表达式。例如，假设您有以下宏：
- en: '[PRE133]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Then, you use it in a few places in your code:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码中的几个地方使用它：
- en: '[PRE134]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'When the preprocessor finishes its work, the code will be as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当预处理器完成其工作时，代码将如下所示：
- en: '[PRE135]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The preprocessor does the same work for functions. For example, let''s say
    you have a macro for getting the maximum number:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器对函数执行相同的工作。例如，假设您有一个用于获取最大数的宏：
- en: '[PRE136]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Then, you use it in a few places in your code:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码中的几个地方使用它：
- en: '[PRE137]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'When the preprocessor finishes its work, the code will be as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当预处理器完成其工作时，代码将如下所示：
- en: '[PRE138]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'As an expression, you can use any valid expression, such as a function call,
    inline function, value, and so on. If you need to write the expression in more
    than one line, use the back-slash operator, "\". For example, the max definition
    we can write in two lines is as follows:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 作为表达式，您可以使用任何有效的表达式，比如函数调用、内联函数、值等。如果您需要在多行中编写表达式，请使用反斜杠运算符"\"。例如，我们可以将max定义写成两行，如下所示：
- en: '[PRE139]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The macro definitions came from the C language. It's better to use const variables
    or inline functions instead. However, there are still cases when it's more convenient
    to use macro definitions, for example, in loggers when you wish to define different
    logging levels.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义来自C语言。最好使用const变量或内联函数。然而，仍然有一些情况下使用宏定义更方便，例如在记录器中定义不同的记录级别时。
- en: Now. we know everything we need to complete the activity. So, let's sum up what
    we have learned in this chapter and let's improve the project that we wrote in
    *Chapter 5*, *The Philosophers' Dinner – Threads and Concurrency*. We'll be developing
    a thread-safe logger and integrating it into our project.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在。我们知道完成这个活动所需的一切。所以，让我们总结一下我们在本章学到的东西，并改进我们在*第5章*中编写的项目，*哲学家的晚餐-线程和并发性*。我们将开发一个线程安全的记录器，并将其集成到我们的项目中。
- en: 'Activity 1: The Logging System for The Art Gallery Simulator'
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：艺术画廊模拟器的日志系统
- en: 'In this activity, we are going to develop a logger that will output formatted
    logs to the Terminal. We will output logs in the following format:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将开发一个记录器，它将以格式化的形式输出日志到终端。我们将以以下格式输出日志：
- en: '[PRE140]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: We will implement macro definitions for different logging levels that will be
    used instead of straightforward calls. This logger will be thread-safe, and we
    will invoke it from different threads simultaneously. Finally, we will integrate
    it into the project – The Art Gallery Simulator. We will run the simulation and
    observe pretty-printed logs. We will create an additional stream, use streams
    with concurrency, and format the output. We will implement almost everything that
    we have learned about in this chapter. We will also employ a synchronization technique
    from the previous chapter.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为不同的日志级别实现宏定义，这些宏定义将用于替代直接调用。这个记录器将是线程安全的，并且我们将同时从不同线程调用它。最后，我们将把它集成到项目中——美术馆模拟器中。我们将运行模拟并观察漂亮打印的日志。我们将创建一个额外的流，使用并发流，并格式化输出。我们将几乎实现本章中学到的所有内容。我们还将使用上一章的同步技术。
- en: Thus, before attempting this activity, ensure that you have completed all the
    previous exercises in this chapter.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在尝试此活动之前，请确保您已完成本章中的所有先前练习。
- en: 'Before we implement this application, let''s describe our classes. We have
    the following newly created classes:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此应用程序之前，让我们描述一下我们的类。我们有以下新创建的类：
- en: '![Figure 6.20: Descriptions of the classes that should be implemented](img/C14583_06_20.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20：应该实现的类的描述](img/C14583_06_20.jpg)'
- en: 'Figure 6.20: Descriptions of the classes that should be implemented'
  id: totrans-540
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：应该实现的类的描述
- en: 'We also have the following classes already implemented in The Art Gallery Simulator
    project:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在美术馆模拟器项目中已经实现了以下类：
- en: '![](img/C14583_06_21.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_06_21.jpg)'
- en: 'Figure 6.21: The table of already implemented classes in The Art Gallery Simulator
    project'
  id: totrans-543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.21：美术馆模拟器项目中已实现的类的表格
- en: 'Let''s add our new classes to the class diagram before we start the implementation.
    All of the described classes with relationships are composed in the following
    diagram:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，让我们将新的类添加到类图中。所有描述的类及其关系都组成了以下图表：
- en: '![Figure 6.22: The class diagram](img/C14583_06_22.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22：类图](img/C14583_06_22.jpg)'
- en: 'Figure 6.22: The class diagram'
  id: totrans-546
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.22：类图
- en: 'To receive the output in the desired format, the `LoggerUtils` class should
    have the following `static` functions:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以期望的格式接收输出，`LoggerUtils`类应该具有以下`static`函数：
- en: '![Figure 6.23: Descriptions of the LoggerUtils member functions](img/C14583_06_23.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![图6.23：LoggerUtils成员函数的描述](img/C14583_06_23.jpg)'
- en: 'Figure 6.23: Descriptions of the LoggerUtils member functions'
  id: totrans-549
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.23：LoggerUtils成员函数的描述
- en: 'Follow these steps to complete this activity:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Define and implement the `LoggerUtils` class, which provides an interface for
    output formatting. It contains static variables that format given data into the
    required representation.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现`LoggerUtils`类，提供输出格式化的接口。它包含将给定数据格式化为所需表示形式的静态变量。
- en: 'Define and implement the `StreamLogger` class, which provides a thread-safe
    interface for output to the Terminal. It should format the output like so:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现`StreamLogger`类，为终端提供线程安全的输出接口。它应该格式化输出如下：
- en: '[PRE141]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In a separate header file, declare the macro definitions for different logging
    levels that return a temporary object of the `StreamLogger` class.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的头文件中，声明不同日志级别的宏定义，返回`StreamLogger`类的临时对象。
- en: Integrate the implemented logger into the classes from the Art Gallery simulator.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现的记录器集成到美术馆模拟器的类中。
- en: Replace all invocations of `std::cout` with the appropriate macro definition
    calls.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用适当的宏定义调用替换所有`std::cout`的调用。
- en: 'After implementing the aforementioned steps, you should get some output on
    the Terminal regarding the logs from all the implemented classes. Take a look
    and ensure that the logs are outputted in the desired format. The expected output
    should as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施了上述步骤之后，您应该在终端上获得有关所有实现类的日志的输出。查看并确保日志以期望的格式输出。预期输出应该如下：
- en: '![Figure 6.24: The result of the application''s execution](img/C14583_06_24.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24：应用程序执行的结果](img/C14583_06_24.jpg)'
- en: 'Figure 6.24: The result of the application''s execution'
  id: totrans-559
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.24：应用程序执行的结果
- en: Note
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 696.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第696页找到。
- en: Summary
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about I/O operations in C++. We considered the I/O
    Standard Library, which provides an interface for synchronous I/O operations.
    Also, we considered platform-dependent native tools for asynchronous I/O, and
    the `Boost.Asio` library for cross-platform asynchronous I/O operations. We also
    learned how to use I/O streams in multithreaded applications.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C++中的I/O操作。我们考虑了I/O标准库，它提供了同步I/O操作的接口。此外，我们考虑了与平台相关的异步I/O的本机工具，以及`Boost.Asio`库用于跨平台异步I/O操作。我们还学习了如何在多线程应用程序中使用I/O流。
- en: We started by looking at the basic features that the Standard Library provides
    for I/O operations. We learned about predefined stream objects such as `std::cin`
    and `std::cout`. In practice, we learned how to work with standard streams and
    override shift operators for easy read and write custom data types.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看了标准库为I/O操作提供的基本功能。我们了解了预定义的流对象，如`std::cin`和`std::cout`。在实践中，我们学习了如何使用标准流并重写移位运算符以便轻松读取和写入自定义数据类型。
- en: Next, we practiced how to create additional streams. We inherited from the basic
    stream class, implemented our own stream buffer class, and practiced their usage
    in the exercises. We learned about the most appropriate stream classes for inheritance
    and considered their pros and cons.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们练习了如何创建额外的流。我们继承了基本流类，实现了自己的流缓冲区类，并练习了它们在练习中的使用。我们了解了最适合继承的流类，并考虑了它们的优缺点。
- en: Then, we considered the approaches of asynchronous I/O operations on different
    operating systems. We briefly considered using the cross-platform I/O library
    known as `Boost.Asio`, which provides an interface for both synchronous and asynchronous
    operations.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考虑了不同操作系统上异步I/O操作的方法。我们简要考虑了使用跨平台I/O库Boost.Asio，该库提供了同步和异步操作的接口。
- en: Finally, we learned about how to perform I/O operations in multithreaded applications.
    We put all of these new skills into practice by building a multithreaded logger.
    We created a logger abstraction and employed it in the Art Gallery simulator.
    As a result, we created an easy, clear, and robust logging system that allows
    us to easily debug the application using logs. In all, we employed everything
    we learned about in this chapter.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何在多线程应用程序中执行I/O操作。我们将所有这些新技能付诸实践，通过构建一个多线程日志记录器。我们创建了一个日志记录抽象，并在艺术画廊模拟器中使用它。结果，我们创建了一个简单、清晰、健壮的日志记录系统，可以通过日志轻松调试应用程序。总之，我们在本章中运用了我们学到的一切。
- en: 'In the next chapter, we''re going to be taking a closer look at testing and
    debugging applications. We will start by learning about assertions and safety
    netting. Then, we will practice writing unit tests and mocks for interfaces. After,
    we will practice debugging applications in the IDE: we will use breakpoints, watchpoints,
    and data visualization. Finally, we will write an activity that will master our
    skills of testing code.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地学习应用程序的测试和调试。我们将首先学习断言和安全网。然后，我们将练习编写接口的单元测试和模拟。之后，我们将在IDE中练习调试应用程序：我们将使用断点、观察点和数据可视化。最后，我们将编写一个活动，来掌握我们的代码测试技能。
