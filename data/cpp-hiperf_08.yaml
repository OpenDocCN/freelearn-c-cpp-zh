- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Compile-Time Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时编程
- en: C++ has the ability to evaluate expressions at compile time, meaning that values
    are already calculated when the program executes. Even though metaprogramming
    has been possible since C++98, it was initially very complicated due to its complex
    template-based syntax. With the introduction of `constexpr`, `if constexpr`, and
    recently, C++ *concepts*, metaprogramming has become much more similar to writing
    regular code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++具有在编译时评估表达式的能力，这意味着值在程序执行时已经计算出来。尽管自C++98以来就一直可以进行元编程，但由于其复杂的基于模板的语法，最初非常复杂。随着`constexpr`、`if
    constexpr`的引入，以及最近的C++ *概念*，元编程变得更类似于编写常规代码。
- en: This chapter will give you a brief introduction to compile-time expression evaluations
    in C++ and how they can be used for optimization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍C++中的编译时表达式求值以及它们如何用于优化。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Metaprogramming using C++ templates and how to write abbreviated function templates
    in C++20
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++模板进行元编程以及如何在C++20中编写缩写函数模板
- en: Inspecting and manipulating types at compile time using type traits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时使用类型特征检查和操作类型
- en: Constant expressions that are evaluated by the compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器评估的常量表达式
- en: C++20 concepts and how to use them to add constraints to our template parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20概念以及如何使用它们为我们的模板参数添加约束
- en: Some real-world examples of metaprogramming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程的一些真实例子
- en: We will begin with an introduction to template metaprogramming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍模板元编程开始。
- en: Introduction to template metaprogramming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模板元编程
- en: 'When writing regular C++ code, it is eventually transformed into machine code.
    **Metaprogramming**, on the other hand, allows us to write code that transforms
    itself into regular C++ code. In a more general sense, metaprogramming is a technique
    where we write code that transforms or generates some other code. By using metaprogramming,
    we can avoid duplicating code that only differs slightly based on the data types
    we use, or we can minimize runtime costs by precomputing values that can be known
    before the final program executes. There is nothing that stops us from generating
    C++ code by using other languages. We could, for example, do metaprogramming by
    using preprocessor macros extensively or writing a Python script that generates
    or modifies C++ files for us:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写常规C++代码时，最终会将其转换为机器代码。另一方面，**元编程**允许我们编写能够将自身转换为常规C++代码的代码。更一般地说，元编程是一种技术，我们编写能够转换或生成其他代码的代码。通过使用元编程，我们可以避免重复使用仅基于我们使用的数据类型略有不同的代码，或者通过预先计算在最终程序执行之前就可以知道的值来最小化运行时成本。没有什么能阻止我们使用其他语言生成C++代码。例如，我们可以通过广泛使用预处理器宏或编写一个生成或修改C++文件的Python脚本来进行元编程：
- en: '![](img/B15619_08_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_08_01.png)'
- en: 'Figure 8.1: A metaprogram generates regular C++ code that will later be compiled
    into machine code'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：一个元程序生成将被编译成机器代码的常规C++代码
- en: Even though we could use any language to produce regular code, with C++, we
    have the privilege of writing metaprograms within the language itself using **templates**
    and **constant expressions**. The C++ compiler can execute our metaprogram and
    generate regular C++ code that the compiler will further transform into machine
    code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用任何语言来生成常规代码，但是使用C++，我们有特权在语言本身内部使用**模板**和**常量表达式**编写元程序。C++编译器可以执行我们的元程序，并生成编译器将进一步转换为机器代码的常规C++代码。
- en: 'There are many advantages to doing metaprogramming directly within C++ using
    templates and constant expressions rather than using some other technique:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中直接使用模板和常量表达式进行元编程，而不是使用其他技术，有许多优势：
- en: We don't have to parse the C++ code (the compiler does that for us).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必解析C++代码（编译器会为我们做这个工作）。
- en: There is excellent support for analyzing and manipulating C++ types when using
    C++ template metaprogramming.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用C++模板元编程时，对分析和操作C++类型有很好的支持。
- en: The code of the metaprogram and the regular non-generic code is mixed in the
    C++ source. Sometimes, this can make it hard to understand what parts are executed
    at runtime and compile time, respectively. However, in general, this is a very
    important aspect of making C++ metaprogramming effective to use.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元程序的代码和常规非通用代码混合在C++源代码中。有时，这可能使人难以理解哪些部分分别在运行时和编译时执行。然而，总的来说，这是使C++元编程有效使用的一个非常重要的方面。
- en: 'In its simplest and most common form, template metaprogramming in C++ is used
    to generate functions, values, and classes that accept different types. A template
    is said to be **instantiated** when the compiler uses that template to generate
    a class or a function. Constant expressions are **evaluated** by the compiler
    to generate constant values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单和最常见的形式中，C++中的模板元编程用于生成接受不同类型的函数、值和类。当编译器使用模板生成类或函数时，称模板被**实例化**。编译器通过**评估**常量表达式来生成常量值：
- en: '![](img/B15619_08_02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_08_02.png)'
- en: 'Figure 8.2: Compile-time programming in C++. The metaprogram that will generate
    regular C++ code is written in C++ itself.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：C++中的编译时编程。将生成常规C++代码的元程序是用C++本身编写的。
- en: 'This is a somewhat simplified view; there is nothing that says that the C++
    compiler is required to perform the transformations in this way. However, it''s
    useful to think about C++ metaprogramming being carried out in these two distinct
    phases:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简化的观点；没有什么规定C++编译器必须以这种方式执行转换。然而，将C++元编程视为在这两个不同阶段进行的是很有用的：
- en: An initial phase, where templates and constant expressions produce regular C++
    code of functions, classes, and constant values. This phase is usually called
    **constant evaluation**.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始阶段，模板和常量表达式生成函数、类和常量值的常规C++代码。这个阶段通常被称为**常量评估**。
- en: A second phase, where the compiler eventually compiles the regular C++ code
    into machine code.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二阶段，编译器最终将常规C++代码编译成机器代码。
- en: Later in this chapter, I will refer to C++ code generated from metaprogramming
    as *regular C++ code*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我将把从元编程生成的C++代码称为*常规C++代码*。
- en: When using metaprogramming, it is important to remember that its main use case
    is to make great libraries and, thereby, hide complex constructs/optimizations
    from the user code. Please note that however complex the interior of the code
    for the metaprogram may be, it's important to hide it behind a good interface
    so that the user codebase is easy to read and use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用元编程时，重要的是要记住它的主要用例是制作出色的库，并因此隐藏用户代码中的复杂构造/优化。请注意，无论代码的内部多么复杂，都很重要将其隐藏在良好的接口后面，以便用户代码库易于阅读和使用。
- en: Let's move on and create our first templates for generating function and classes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的第一个用于生成函数和类的模板。
- en: Creating templates
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模板
- en: Let's take a look at a simple `pow()` function and a `Rectangle` class. By using
    a **type template parameter**, the `pow()` function and the `Rectangle` class
    can be used with any integer or floating-point type. Without templates, we would
    have to create a separate function/class for every base type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的`pow()`函数和一个`Rectangle`类。通过使用**类型模板参数**，`pow()`函数和`Rectangle`类可以与任何整数或浮点类型一起使用。没有模板，我们将不得不为每种基本类型创建一个单独的函数/类。
- en: Writing metaprogramming code can be very complex; something that can make it
    easier is to imagine how the expected regular C++ code is intended to be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编写元编程代码可能非常复杂；使其变得更容易的一点是想象预期的常规C++代码的意图。
- en: 'Here is an example of a simple function template:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单函数模板的示例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this function will generate a function whose return type is dependent
    on the template parameter type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数将生成一个返回类型取决于模板参数类型的函数：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The explicit template argument types (`float` and `int` in this case) can (preferably)
    be omitted, and instead the compiler can figure this out on its own. This mechanism
    is called **template argument deduction** because the compiler *deduces* the template
    arguments. The following example will result in the same template instantiation
    as the one shown previously:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模板参数类型（在这种情况下为`float`和`int`）可以（最好）省略，而编译器可以自行解决这个问题。这种机制称为**模板参数推断**，因为编译器*推断*模板参数。以下示例将导致与先前显示的相同的模板实例化：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Correspondingly, a simple class template can be defined as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，可以定义一个简单的类模板如下：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a class template is utilized, we can explicitly specify the types that
    the template should generate the code for, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类模板时，我们可以明确指定模板应为其生成代码的类型，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But it''s also possible to benefit from **class template argument deduction**
    (**CTAD**), and have the compiler deduce the argument type for us. The following
    code will instantiate a `Rectangle<int>`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但也可以从**类模板参数推断**（**CTAD**）中受益，并让编译器为我们推断参数类型。以下代码将实例化一个`Rectangle<int>`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A function template can then accept a `Rectangle` object where the rectangle
    dimensions are defined using an arbitrary type `T`, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数模板可以接受一个`Rectangle`对象，其中矩形的尺寸是使用任意类型`T`定义的，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Type template parameters are the most common template parameters. Next, you
    will see how to use numeric parameters instead of type parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类型模板参数是最常见的模板参数。接下来，您将看到如何使用数值参数而不是类型参数。
- en: Using integers as template parameters
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用整数作为模板参数
- en: 'Beyond general types, a template can also be of other types, such as integral
    types and floating-point types. In the following example, we will use an `int`
    in the template, which means that the compiler will generate a new function for
    every unique integer passed as a template argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一般类型，模板还可以是其他类型，例如整数类型和浮点类型。在下面的示例中，我们将在模板中使用`int`，这意味着编译器将为每个唯一的整数传递的模板参数生成一个新函数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code will oblige the compiler to instantiate two distinct functions:
    one squares the value and one cubes the value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将强制编译器实例化两个不同的函数：一个平方值，一个立方值：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the difference between the template parameter `N` and the function parameter
    `v`. For every value of `N`, the compiler generates a new function. However, `v`
    is passed as a regular parameter and, as such, does not result in a new function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意模板参数`N`和函数参数`v`之间的差异。对于每个`N`的值，编译器都会生成一个新函数。但是，`v`作为常规参数传递，因此不会导致生成新函数。
- en: Providing specializations of a template
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供模板的特化
- en: 'By default, the compiler will generate regular C++ code whenever we use a template
    with new parameters. But it''s also possible to provide a custom implementation
    for certain values of the template parameters. Say, for example, that we want
    to provide the regular C++ code of our `const_pow_n()` function when it''s used
    with integers and the value of `N` is `2`. We could write a **template specialization**
    for this case, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每当我们使用新参数的模板时，编译器将生成常规的C++代码。但也可以为模板参数的某些值提供自定义实现。例如，假设我们希望在使用整数并且`N`的值为`2`时，提供我们的`const_pow_n()`函数的常规C++代码。我们可以为这种情况编写一个**模板特化**，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For function templates, we need to fix *all* template parameters when writing
    a specialization. For example, it's not possible to only specify the value of
    `N` and let the type argument `T` be unspecified. However, for class templates,
    it is possible to specify only a subset of the template parameters. This is called
    **partial template specialization**. The compiler will choose the most specific
    template first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数模板，当编写特化时，我们需要固定*所有*模板参数。例如，不可能只指定`N`的值，而让类型参数`T`未指定。但是，对于类模板，可以只指定模板参数的子集。这称为**部分模板特化**。编译器将首先选择最具体的模板。
- en: The reason we cannot apply partial template specialization to functions is that
    functions can be overloaded (and classes cannot). If we were allowed to mix overloads
    and partial specialization, it would be very hard to comprehend.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能对函数应用部分模板特化的原因是函数可以重载（而类不能）。如果允许混合重载和部分特化，那将很难理解。
- en: How the compiler handles a template function
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器如何处理模板函数
- en: 'When the compiler handles a template function, it constructs a regular function
    with the template parameters expanded. The following code will make the compiler
    generate regular functions since it utilizes templates:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器处理模板函数时，它会构造一个展开了模板参数的常规函数。以下代码将使编译器生成常规函数，因为它使用了模板：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Thus, when compiled, as distinguished from regular functions, the compiler
    will generate new functions for every unique set of *template parameters*. This
    means that it is the equivalent of manually creating four different functions
    that look something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当编译时，与常规函数不同，编译器将为每组唯一的*模板参数*生成新函数。这意味着它相当于手动创建了四个不同的函数，看起来像这样：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is important for understanding how metaprogramming works. The template
    code generates non-templated C++ code, which is then executed as regular code.
    If the generated C++ code does not compile, the error will be caught at compile
    time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于理解元编程的工作原理非常重要。模板代码生成非模板化的C++代码，然后作为常规代码执行。如果生成的C++代码无法编译，错误将在编译时被捕获。
- en: Abbreviated function templates
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩写函数模板
- en: 'C++20 introduced a new abbreviated syntax for writing function templates by
    adopting the same style used by generic lambdas. By using `auto` for function
    parameter types, we are actually creating a function template rather than a regular
    function. Recall our initial `pow_n()` template, which was declared like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++20引入了一种新的缩写语法，用于编写函数模板，采用了通用lambda使用的相同风格。通过使用`auto`作为函数参数类型，我们实际上创建的是一个函数模板，而不是一个常规函数。回想一下我们最初的`pow_n()`模板，它是这样声明的：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the abbreviated function template syntax, we can instead declare it by
    using `auto`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩写的函数模板语法，我们可以使用`auto`来声明它：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The difference between these two versions is that the abbreviated version doesn''t
    have an explicit placeholder for the type of the variable `v`. And since we were
    using the placeholder `T` in our implementation, this code will unfortunately
    fail to compile:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本之间的区别在于缩写版本没有变量`v`的显式占位符。由于我们在实现中使用了占位符`T`，这段代码将不幸地无法编译：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To fix this, we can use the `decltype` specifier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用`decltype`指定符。
- en: Receiving the type of a variable with decltype
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用decltype接收变量的类型
- en: The `decltype` specifier is used to retrieve the type of a variable and is used
    when an explicit type name is not available.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype`指定符用于检索变量的类型，并且在没有显式类型名称可用时使用。'
- en: Sometimes, we need an explicit placeholder for a type but none are available,
    only the variable name is. This happened to us in our implementation of the `pow_n()`
    function previously, when using the abbreviated function template syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个显式的类型占位符，但没有可用的，只有变量名。这在我们之前实现`pow_n()`函数时发生过，当使用缩写的函数模板语法时。
- en: 'Let''s look at an example of using `decltype` by fixing our implementation
    of `pow_n()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修复`pow_n()`的实现来看一个使用`decltype`的例子：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Although this code compiles and works, we are a bit lucky since the type of
    `v` is actually a `const` reference and not the type we want for the variable
    `product`. We can get around this by using the left-to-right declaration style.
    But trying to rewrite the line where the product is defined to something that
    would appear to be identical reveals a problem:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码编译并工作，但我们有点幸运，因为`v`的类型实际上是一个`const`引用，而不是我们想要的变量`product`的类型。我们可以通过使用从左到右的声明样式来解决这个问题。但是，试图将定义产品的行重写为看起来相同的东西会揭示一个问题：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are getting a compilation error since `product` is a `const` reference
    and may not be assigned to a new value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到了一个编译错误，因为`product`是一个`const`引用，可能无法分配新值。
- en: 'What we really want is to get rid of the `const` reference from the type of
    `v` when defining the variable `product`. We could use a handy template called
    `std::remove_cvref` for this purpose. Our definition of `product` would then look
    like this instead:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是从变量`v`的类型中去掉`const`引用，当定义变量`product`时。我们可以使用一个方便的模板`std::remove_cvref`来实现这个目的。我们的`product`的定义将如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Phew! In this particular case, it would probably have been easier to stick with
    our initial `template <typename T>` syntax. But now, you have learned how to use
    `std::remove_cvref` together with `decltype`, which is a common pattern when writing
    generic C++ code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！在这种特殊情况下，也许最好还是坚持最初的`template <typename T>`语法。但现在，您已经学会了在编写通用C++代码时如何使用`std::remove_cvref`和`decltype`，这是一个常见的模式。
- en: 'Before C++20, it was common to see `decltype` in the body of generic lambdas.
    However, it is now possible to avoid the rather inconvenient `decltype` by adding
    explicit template parameters to generic lambdas:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前，在通用lambda的主体中经常看到`decltype`。然而，现在可以通过向通用lambda添加显式模板参数来避免相当不方便的`decltype`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the definition of the lambda, we are writing `<class T>` in order to get
    an identifier for the type of the argument that can be used inside the body of
    the function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda的定义中，我们写`<class T>`以获取一个可以在函数体内使用的参数类型的标识符。
- en: It might take some time to get accustomed to using `decltype` and utilities
    for manipulating types. Maybe `std::remove_cvref` looks a bit mysterious at first.
    It's a template from the `<type_traits>` header, which we will look further into
    in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 也许需要一些时间来习惯使用`decltype`和操纵类型的工具。也许`std::remove_cvref`一开始看起来有点神秘。它是`<type_traits>`头文件中的一个模板，我们将在下一节中进一步了解它。
- en: Type traits
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型特征
- en: When doing template metaprogramming, you may often find yourself in situations
    where you need information about the types you are dealing with at compile time.
    When writing regular (non-generic) C++ code, we work with concrete types that
    we have complete knowledge about, but this is not the case when writing a template;
    the concrete types are not determined until a template is being instantiated by
    the compiler. Type traits let us extract information about the types our templates
    are dealing with in order to generate efficient and correct C++ code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行模板元编程时，您可能经常会发现自己处于需要在编译时获取有关您正在处理的类型的信息的情况。在编写常规（非泛型）C++代码时，我们使用完全了解的具体类型，但在编写模板时情况并非如此；具体类型直到编译器实例化模板时才确定。类型特征允许我们提取有关我们模板处理的类型的信息，以生成高效和正确的C++代码。
- en: In order to extract information about template types, the standard library provides
    a type traits library, which is available in the `<type_traits>` header. All type
    traits are evaluated at compile time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取有关模板类型的信息，标准库提供了一个类型特征库，该库在`<type_traits>`头文件中可用。所有类型特征都在编译时评估。
- en: Type trait categories
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型特征类别
- en: 'There are two categories of type traits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有两类类型特征：
- en: Type traits that return information about a type as a boolean or an integer
    value.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回关于类型信息的类型特征，作为布尔值或整数值。
- en: Type traits that return a new type. These type traits are also called metafunctions.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回新类型的类型特征。这些类型特征也被称为元函数。
- en: The first category returns `true` or `false`, depending on the input, and ends
    with `_v` (short for value).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类返回`true`或`false`，取决于输入，并以`_v`结尾（代表值）。
- en: The `_v` postfix was added in C++17\. If your library implementation does not
    provide `_v` postfixes for type traits, then you can use the older version, `std::is_floating_point<float>::value`.
    In other words, remove the `_v` extension and add `::value` at the end.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`_v`后缀是在C++17中添加的。如果您的库实现不提供类型特征的`_v`后缀，则可以使用旧版本`std::is_floating_point<float>::value`。换句话说，删除`_v`扩展并在末尾添加`::value`。'
- en: 'Here are some examples of compile-time type checking using type traits for
    fundamental types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用类型特征对基本类型进行编译时类型检查的一些示例：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Type traits can also be used on user-defined types:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特征也可以用于用户定义的类型：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second category of type traits returns a new type and ends with `_t` (short
    for type). These type trait transformations (or metafunctions) come in handy when
    dealing with pointers and references:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特征的第二类返回一个新类型，并以`_t`结尾（代表类型）。当处理指针和引用时，这些类型特征转换（或元函数）非常方便：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The type trait `std::remove_cvref` that we used earlier is also part of this
    category. It removes the reference part (if any) and the `const` and `volatile`
    qualifiers from a type. `std::remove_cvref` was introduced in C++20\. Before that,
    it was conventional to use `std::decay` for this task.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的类型特征`std::remove_cvref`也属于这个类别。它从类型中移除引用部分（如果有）以及`const`和`volatile`限定符。`std::remove_cvref`是在C++20中引入的。在那之前，通常使用`std::decay`来执行此任务。
- en: Using type traits
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型特征
- en: 'As already mentioned, all type traits are evaluated at compile time. For example,
    this function, which returns `1` if the value is greater than or equal to zero
    and `-1` otherwise, can immediately return `1` for unsigned integers, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有类型特征都在编译时评估。例如，以下函数如果值大于或等于零则返回`1`，否则返回`-1`，对于无符号整数可以立即返回`1`，如下所示：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since type traits are evaluated at compile time, the compiler will generate
    the code shown in the following table when invoked with an unsigned and signed
    integer, respectively:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型特征在编译时评估，因此当使用无符号整数和有符号整数调用时，编译器将生成下表中显示的代码：
- en: '| Used with an unsigned integer... | ...generated function: |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 与无符号整数一起使用... | ...生成的函数： |'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Used with a signed integer... | ...generated function: |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 与有符号整数一起使用... | ...生成的函数： |'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Table 8.1: Based on the type we pass to sign_func() (in the left column), different
    functions is generated by the compiler (in the right column).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：基于我们传递给`sign_func()`的类型（在左列），编译器生成不同的函数（在右列）。
- en: Next, let's talk about constant expressions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈常量表达式。
- en: Programming with constant expressions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量表达式进行编程
- en: 'An expression prefixed with the `constexpr` keyword tells the compiler that
    the expression should be evaluated at compile time:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`constexpr`关键字前缀的表达式告诉编译器应在编译时评估该表达式：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `constexpr` keyword can also be used with functions. In that case, it tells
    the compiler that a certain function is intended to be evaluated at compile time
    if all the conditions allowing for compile-time evaluation are fulfilled. Otherwise,
    it will execute at runtime, like a regular function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`关键字也可以与函数一起使用。在这种情况下，它告诉编译器某个函数打算在编译时评估，如果满足所有允许进行编译时评估的条件，则会在运行时执行，就像常规函数一样。'
- en: 'A `constexpr` function has a few restrictions; it is not allowed to do the
    following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数有一些限制；不允许执行以下操作：'
- en: Handle local static variables
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理本地静态变量
- en: Handle `thread_local` variables
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`thread_local`变量
- en: Call any function, which, in itself, is not a `constexpr` function
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用任何函数，本身不是`constexpr`函数
- en: With the `constexpr` keyword, writing a compile-time evaluated function is as
    easy as writing a regular function since its parameters are regular parameters
    instead of template parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`constexpr`关键字，编写编译时评估的函数与编写常规函数一样容易，因为它的参数是常规参数而不是模板参数。
- en: 'Consider the following `constexpr` function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`constexpr`函数：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s call the function like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样调用函数：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the result of `sum()` is used in a constant expression and all its parameters
    can be determined at compile time, the compiler will generate the following regular
    C++ code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sum()`的结果用于常量表达式，并且其所有参数都可以在编译时确定，因此编译器将生成以下常规的C++代码：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is then compiled into machine code, as usual. In other words, the compiler
    evaluates a `constexpr` function and generates regular C++ code where the result
    is calculated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像往常一样将其编译成机器代码。换句话说，编译器评估`constexpr`函数并生成常规的C++代码，其中计算结果。
- en: 'If we called `sum()` instead and stored the result in a variable that is *not*
    marked with `constexpr`, the compiler *might* (most likely) evaluate `sum()` at
    compile time:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`sum()`并将结果存储在未标记为`constexpr`的变量中，编译器可能（很可能）在编译时评估`sum()`：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In summary, if a `constexpr` function is invoked from a constant expression
    and all its arguments are constant expressions, it is guaranteed to be evaluated
    at compile time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果从常量表达式调用`constexpr`函数，并且其所有参数都是常量表达式，那么它保证在编译时评估。
- en: Constexpr functions in a runtime context
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时上下文中的Constexpr函数
- en: In the previous example, the summed values (`3`, `4`, `5`) were known to the
    compiler at compile time, but how do `constexpr` functions handle variables whose
    values are not known until runtime? As mentioned in the previous section, `constexpr`
    is an indicator to the compiler that a function, under certain conditions, can
    be evaluated at compile time. If variables with values are unknown until the runtime
    is invoked, they will be evaluated just like regular functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，编译器在编译时已知的值（`3`、`4`、`5`）是已知的，但是`constexpr`函数如何处理直到运行时才知道值的变量？如前一节所述，`constexpr`是编译器的指示，表明在某些条件下，函数可以在编译时评估。如果直到运行时调用时才知道值的变量，它们将像常规函数一样被评估。
- en: 'In the following example, the values of `x`, `y`, and `z` are provided from
    the user at runtime, and therefore, it would be impossible for the compiler to
    calculate the sum at compile time:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`x`、`y`和`z`的值是在运行时由用户提供的，因此编译器无法在编译时计算总和：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we didn't intend to use `sum()` during runtime at all, we could prohibit
    such usage by making it an immediate function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根本不打算在运行时使用`sum()`，我们可以通过将其设置为立即函数来禁止这种用法。
- en: Declaring immediate functions using consteval
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`consteval`声明立即函数
- en: 'A `constexpr` function can be called at runtime or compile time. If we want
    to limit the uses of a function so that it''s only invoked at compile time, we
    can do that by using the keyword `consteval` instead of `constexpr`. Let''s assume
    that we want to prohibit all uses of `sum()` at runtime. With C++20, we can do
    that with the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数可以在运行时或编译时调用。如果我们想限制函数的使用，使其只在编译时调用，我们可以使用关键字`consteval`而不是`constexpr`。假设我们想禁止在运行时使用`sum()`。使用C++20，我们可以通过以下代码实现：'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A function that is declared using `consteval` is called an **immediate function**
    and can only produce constants. If we want to call `sum()`, we need to call it
    from within a constant expression, or the compilation will fail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`consteval`声明的函数称为**立即函数**，只能生成常量。如果我们想调用`sum()`，我们需要在常量表达式中调用它，否则编译将失败：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The compiler will also complain if we try to use `sum()` with parameters that
    are not known at compile time:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在编译时使用参数不明确的`sum()`，编译器也会报错：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's discuss the `if` `constexpr` statement next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论`if` `constexpr`语句。
- en: The if constexpr statement
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if constexpr语句
- en: 'The `if constexpr` statement allows template functions to evaluate different
    scopes in the same function at compile time (also called compile-time polymorphism).
    Take a look at the following example, where a function template called `speak()`
    tries to differentiate member functions, depending on the type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`if constexpr`语句允许模板函数在同一函数中在编译时评估不同的作用域（也称为编译时多态）。看看下面的例子，其中一个名为`speak()`的函数模板尝试根据类型区分成员函数：'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s say we compile the following lines:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编译以下行：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The compiler will then generate a `speak()` function, similar to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器将生成一个类似于这样的`speak()`函数：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the compiler will keep the call to the member function, `quack()`,
    which will then fail to compile since `Bear` does not contain a `quack()` member
    function. This happens even though the `quack()` member function will never be
    executed due to the `else if (false)` statement.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器将保留对成员函数`quack()`的调用，然后由于`Bear`不包含`quack()`成员函数而无法编译。这甚至会发生在`quack()`成员函数由于`else
    if (false)`语句而永远不会被执行的情况下。
- en: In order to make the `speak()` function compile, regardless of the type, we
    need to inform the compiler that we'd like to completely ignore the scope if the
    `if` statement is `false`. Conveniently, this is exactly what `if constexpr` does.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`speak()`函数无论类型如何都能编译，我们需要告诉编译器，如果`if`语句为`false`，我们希望完全忽略作用域。方便的是，这正是`if
    constexpr`所做的。
- en: 'Here is how we can write the `speak()` function with the ability to handle
    both `Bear` and `Duck`, even though they do not share a common interface:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何编写`speak()`函数，以便处理`Bear`和`Duck`，即使它们没有共同的接口：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When `speak()` is invoked with `Animal == Bear`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Animal == Bear`调用`speak()`时，如下所示：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'the compiler generates the following function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成以下函数：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When `speak()` is invoked with `Animal == Duck`,as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Animal == Duck`调用`speak()`时，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'the compiler generates the following function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成以下函数：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If `speak()` is invoked with any other primitive type, such as `Animal == int`,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用任何其他原始类型调用`speak()`，例如`Animal == int`，如下所示：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'the compiler generates an empty function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成一个空函数：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Unlike a regular `if` statement, the compiler is now able to generate multiple
    different functions: one using `Bear`, another one using `Duck`, and a last one
    if the type is neither `Bear` nor `Duck`. If we want to make this third case a
    compilation error, we can do that by adding an `else` case with a `static_assert`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的`if`语句不同，编译器现在能够生成多个不同的函数：一个使用`Bear`，另一个使用`Duck`，如果类型既不是`Bear`也不是`Duck`，则生成最后一个。如果我们想让这第三种情况成为编译错误，我们可以通过添加一个带有`static_assert`的`else`语句来实现：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We will talk more about the usefulness of `static_assert` later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更多地讨论`static_assert`的用处。
- en: As mentioned earlier, the way `constexpr` is being used here can be referred
    to as compile-time polymorphism. So, how does it relate to runtime polymorphism?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这里使用`constexpr`的方式可以称为编译时多态。那么，它与运行时多态有什么关系呢？
- en: Comparison with runtime polymorphism
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与运行时多态的比较
- en: 'As a side note, if we were to implement the previous example with traditional
    runtime polymorphism, using inheritance and virtual functions to achieve the same
    functionality, the implementation would look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果我们使用传统的运行时多态来实现前面的例子，使用继承和虚函数来实现相同的功能，实现将如下所示：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The objects have to be accessed using pointers or references, and the type
    is inferred at *runtime*, which results in a performance loss compared with the
    compile-time version, where everything is available when the application executes.
    The following image shows the difference between the two types of polymorphism
    in C++:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须使用指针或引用进行访问，并且类型在*运行时*推断，这导致性能损失与编译时版本相比，其中应用程序执行时一切都是可用的。下面的图像显示了C++中两种多态类型之间的区别：
- en: '![](img/B15619_08_03.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_08_03.png)'
- en: 'Figure 8.3: Runtime polymorphism is supported by virtual functions whereas
    compile time polymorphism is supported by function/operator overloading and if
    constexpr.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：运行时多态由虚函数支持，而编译时多态由函数/操作符重载和if constexpr支持。
- en: Now, we will continue to see how we can use `if constexpr` for something more
    useful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续看看如何使用`if constexpr`来做一些更有用的事情。
- en: Example of the generic modulus function using if constexpr
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用if constexpr的通用模数函数示例
- en: This example will show you how to use `if constexpr` to distinguish between
    operators and global functions. In C++, the `%` operator is used to get the modulus
    of integers, while `std::fmod()` is used for floating-point types. Say we'd like
    to generalize our codebase and create a generic modulus function called `generic_mod()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将向您展示如何使用`if constexpr`来区分运算符和全局函数。在C++中，`%`运算符用于获取整数的模，而`std::fmod()`用于浮点类型。假设我们想要将我们的代码库泛化，并创建一个名为`generic_mod()`的通用模数函数。
- en: 'If we were to implement `generic_mod()` with a regular `if` statement, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用常规的`if`语句来实现`generic_mod()`，如下所示：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'it would fail if invoked with `T == float` as the compiler would generate the
    following function, which would fail to compile:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以`T == float`调用它，它将失败，因为编译器将生成以下函数，这将无法编译通过：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even though the application cannot reach it, the compiler will generate the
    line `return v % n;`, which isn't compliant with `float`. The compiler doesn't
    care that the application cannot reach it—since it cannot generate an assembly
    for it, it will fail to compile.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用程序无法到达它，编译器将生成`return v % n;`这一行，这与`float`不兼容。编译器不在乎应用程序是否能到达它——因为它无法为其生成汇编代码，所以它将无法编译通过。
- en: 'As in the previous example, we will change the `if` statement to an `if constexpr`
    statement:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们将`if`语句更改为`if constexpr`语句：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, when the function is invoked with a floating-point type, it will generate
    the following function, where the `v % n` operation is eradicated:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用浮点类型调用函数时，它将生成以下函数，其中`v % n`操作被消除：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The runtime `assert()` tells us that we cannot call this function if the second
    argument is 0.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时的`assert()`告诉我们，如果第二个参数为0，我们不能调用这个函数。
- en: Checking programming errors at compile time
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在编译时检查编程错误
- en: Assert statements are a simple but very powerful tool for validating invariants
    and contracts between callers and callees in a codebase, (see *Chapter 2*, *Essential
    C++ Techniques*.) It's possible to check programming errors while executing the
    program using `assert()`. But we should always strive to detect errors as early
    as possible, and if we have a constant expression, we can catch programming errors
    when compiling the program using `static_assert()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Assert语句是验证代码库中调用者和被调用者之间不变性和契约的简单但非常强大的工具（见*第2章*，*Essential C++ Techniques*）。使用`assert()`可以在执行程序时检查编程错误。但我们应该始终努力尽早检测错误，如果有常量表达式，我们可以使用`static_assert()`在编译程序时捕获编程错误。
- en: Using assert to trigger errors at runtime
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用assert在运行时触发错误
- en: 'Review the templated version of `pow_n()`. Let''s say we want to prevent it
    from being called with negative exponents (the `n` value). To prevent this in
    the runtime version, where `n` is a regular argument, we can add a runtime assertion:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`pow_n()`的模板版本。假设我们想要阻止它使用负指数（`n`值）进行调用。在运行时版本中，其中`n`是一个常规参数，我们可以添加一个运行时断言来阻止这种情况：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the function is called with a negative value for `n`, the program will break
    and inform us where we should start looking for the bug. This is good, but it
    would be even better if we could track this error at compile time rather than
    runtime.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数被调用时`n`的值为负数，程序将中断并告知我们应该从哪里开始寻找错误。这很好，但如果我们能在编译时而不是运行时跟踪这个错误会更好。
- en: Using static_assert to trigger errors at compile time
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`static_assert`在编译时触发错误
- en: 'If we do the same to the template version, we can utilize `static_assert()`.
    The `static_assert()` declaration, unlike a regular assert, will refuse to compile
    if the condition isn''t fulfilled. So, it''s better to break the build than have
    a program break at runtime. In the following example, if the template parameter
    `N` is a negative number, `static_assert()` will prevent the function from compiling:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对模板版本做同样的事情，我们可以利用`static_assert()`。与常规的assert不同，`static_assert()`声明如果条件不满足将拒绝编译。因此，最好是在编译时中断构建，而不是在运行时中断程序。在下面的例子中，如果模板参数`N`是一个负数，`static_assert()`将阻止函数编译：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In other words, with regular variables, the compiler is only aware of the type
    and has no idea what it contains. With compile-time values, the compiler knows
    both the type and the value. This allows the compiler to calculate other compile-time
    values.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对于常规变量，编译器只知道类型，不知道它包含什么。对于编译时值，编译器既知道类型又知道值。这使得编译器能够计算其他编译时值。
- en: Instead of using an `int` and assert that it's non-negative, we could (should)
    have used an `unsigned int` instead. We are only using a signed `int` in this
    example to demonstrate the use of `assert()` and `static_assert()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以（应该）使用无符号整数而不是使用`int`并断言它是非负的。在这个例子中，我们只是使用有符号的`int`来演示`assert()`和`static_assert()`的使用。
- en: Using compile-time asserts is one way to check constraints at compile time.
    It is a simple but very useful tool. The support for compile-time programming
    has seen some very exciting progress over the last few years in C++. Now, we will
    move on to one of the biggest features from C++20 that takes constraints checking
    to a new level.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时断言是一种在编译时检查约束的方法。这是一个简单但非常有用的工具。在过去几年中，C++的编译时编程支持取得了一些非常令人兴奋的进展。现在，我们将继续介绍C++20中的一个最重要的特性，将约束检查提升到一个新的水平。
- en: Constraints and concepts
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束和概念
- en: 'So far, we have covered quite a few important techniques for writing C++ metaprograms.
    You have seen how templates can generate concrete classes and functions for us
    with excellent support from the type traits library. Furthermore, you have seen
    how the use of `constexpr`, `consteval`, and `if constexpr` can help us move computations
    from runtime to compile time. In that way, we can detect programming errors at
    compile time and write programs with lower runtime costs. This is great, but there
    is still plenty of room for improvement when it comes to writing and consuming
    generic code in C++. Some of the issues that we haven''t addressed yet include:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了写C++元编程的一些重要技术。您已经看到模板如何利用类型特征库为我们生成具体的类和函数。此外，您已经看到了`constexpr`、`consteval`和`if
    constexpr`的使用可以帮助我们将计算从运行时移动到编译时。通过这种方式，我们可以在编译时检测编程错误，并编写具有较低运行时成本的程序。这很棒，但在编写和使用C++中的通用代码方面仍有很大的改进空间。我们尚未解决的一些问题包括：
- en: Interfaces are too generic. When using a template with some arbitrary type,
    it's hard to know what the requirements of that type are. This makes the templates
    hard to use if we only inspect the template interface. Instead, we have to rely
    on documentation or dig deep into the implementation of a template.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口太通用。当使用具有任意类型的模板时，很难知道该类型的要求是什么。如果我们只检查模板接口，这使得模板难以使用。相反，我们必须依赖文档或深入到模板的实现中。
- en: Type errors are caught late by the compiler. The compiler will eventually check
    the types when compiling the regular C++ code, but the error messages are usually
    hard to interpret. Instead, we would like type errors to be caught in the instantiation
    phase.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型错误由编译器晚期捕获。编译器最终会在编译常规C++代码时检查类型，但错误消息通常很难解释。相反，我们希望在实例化阶段捕获类型错误。
- en: Unconstrained template parameters make metaprogramming hard. The code we have
    written so far in this chapter has used unconstrained template parameters, with
    the exception of a few static asserts. This is manageable for small examples,
    but it would be much easier to write and reason about our metaprograms if we could
    have access to more meaningful types, in the same way the type system helps us
    write correct non-generic C++ code.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无约束的模板参数使元编程变得困难。到目前为止，在本章中我们编写的代码都使用了无约束的模板参数，除了一些静态断言。这对于小例子来说是可以管理的，但如果我们能够像类型系统帮助我们编写正确的非通用C++代码一样，获得更有意义的类型，那么编写和推理我们的元编程将会更容易。
- en: Conditional code generation (compile-time polymorphism) can be performed using
    `if constexpr`, but it quickly becomes hard to read and write at a larger scale.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if constexpr`可以进行条件代码生成（编译时多态），但在较大规模上很快变得难以阅读和编写。
- en: 'As you will see in this section, C++ concepts address these issues in an elegant
    and effective way by introducing two new keywords: `concept` and `requires`. Before
    exploring constraints and concepts, we will spend some time considering the shortcomings
    of template metaprogramming without concepts. Then, we will use constraints and
    concepts to strengthen our code.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在本节中看到的，C++概念以一种优雅而有效的方式解决了这些问题，引入了两个新关键字：`concept`和`requires`。在探讨约束和概念之前，我们将花一些时间考虑没有概念的模板元编程的缺点。然后，我们将使用约束和概念来加强我们的代码。
- en: An unconstrained version of a Point2D template
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Point2D模板的无约束版本
- en: 'Suppose we are writing a program that deals with a two-dimensional coordinate
    system. We have a class template that represents a point with `x` and `y` coordinates,
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个处理二维坐标系的程序。我们有一个类模板，表示具有`x`和`y`坐标的点，如下所示：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s assume that we need to find the Euclidean distance between two points,
    **p1** and **p2**, as illustrated here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要找到两点**p1**和**p2**之间的欧几里德距离，如下所示：
- en: '![](img/B15619_08_04.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_08_04.png)'
- en: 'Figure 8.4: Finding the Euclidean between p1 and p2'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：找到p1和p2之间的欧几里得距离
- en: 'To compute the distance, we implement a free function that takes two points
    and uses the Pythagorean theorem (the actual math is of less importance here):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算距离，我们实现了一个接受两个点并使用勾股定理的自由函数（这里实际的数学并不重要）：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A small test program verifies that we can instantiate the `Point2D` template
    with integers and compute the distance between the two points:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的测试程序验证了我们可以用整数实例化`Point2D`模板，并计算两点之间的距离：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This code compiles and runs fine and outputs `5` to the console.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译和运行都很好，并在控制台输出`5`。
- en: Generic interfaces and bad error messages
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用接口和糟糕的错误消息
- en: 'Before moving on, let''s take a short detour and reflect for a while on the
    function template `dist()`. Let''s imagine that we didn''t have easy access to
    the implementation of `dist()` and only could read the interface:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们稍微偏离一下，对函数模板`dist()`进行一段时间的反思。假设我们无法轻松访问`dist()`的实现，只能读取接口：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What can we say about the return type and the types of `p1` and `p2`? Practically
    nothing—because `p1` and `p2` are completely *unconstrained*, the interface of
    `dist()` does not reveal anything for us. This doesn't mean that we can pass anything
    to `dist()`, though, because in the end, the generated regular C++ code has to
    compile.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说返回类型和`p1`和`p2`的类型有什么？实际上几乎没有——因为`p1`和`p2`完全*未受约束*，`dist()`的接口对我们来说没有透露任何信息。这并不意味着我们可以将任何东西传递给`dist()`，因为最终生成的常规C++代码必须编译。
- en: 'For example, if we try to instantiate our `dist()` template with two integers
    instead of `Point2D` objects like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试用两个整数而不是`Point2D`对象来实例化我们的`dist()`模板，就像这样：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'the compiler will gladly generate a regular C++ function, similar to this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将很乐意生成一个常规的C++函数，类似于这样：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The error will be caught later on when the regular C++ code is checked by the
    compiler. Clang generates the following error message when trying to instantiate
    `dist()` with two integers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器检查常规的C++代码时，错误将在稍后被捕获。当尝试用两个整数实例化`dist()`时，Clang生成以下错误消息：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This error message refers to the *implementation* of `dist()`, something that
    the caller of the function `dist()` shouldn't need to know about. This is a trivial
    example, but trying to interpret error messages caused by providing wrong types
    to templates from sophisticated template libraries can be a real challenge.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息是指`dist()`的*实现*，这是调用函数`dist()`的调用者不需要知道的东西。这是一个微不足道的例子，但是尝试解释由于向复杂的模板库提供错误类型而引起的错误消息可能是一个真正的挑战。
- en: 'Even worse, if we are really unlucky, we get through the entire compilation
    by providing types that don''t make sense at all. In this case, we are instantiating
    a `Point2D` with `const char*`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果我们真的很不幸，通过提供根本没有意义的类型来完成整个编译。在这种情况下，我们正在用`const char*`实例化`Point2D`：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It compiles and runs, but the output is probably not what we would expect.
    We want to catch these sorts of errors earlier on in the process, something we
    can achieve by using constraints and concepts as shown in the image below:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它编译并运行，但输出可能不是我们所期望的。我们希望在过程的早期阶段捕获这些类型的错误，这是我们可以通过使用约束和概念来实现的，如下图所示：
- en: '![](img/B15619_08_05.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_08_05.png)'
- en: 'Figure 8.5: Type errors can be caught at instantiation phase using constraints
    and concepts'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：使用约束和概念可以在实例化阶段捕获类型错误
- en: Later on, you will see how this code can be made more expressive so that it
    is easier to use correctly and harder to misuse. We will do this by adding concepts
    and constraints to our code. But first, I will provide a quick overview of how
    to define and use concepts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，您将看到如何使此代码更具表现力，以便更容易正确使用并更难滥用。我们将通过向我们的代码添加概念和约束来实现这一点。但首先，我将快速概述如何定义和使用概念。
- en: A syntactic overview of constraints and concepts
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束和概念的语法概述
- en: This section is a short introduction to constraints and concepts. We will not
    cover them completely in this book but I will provide you with enough material
    to be productive.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是对约束和概念的简要介绍。我们不会在本书中完全覆盖它们，但我会为您提供足够的材料来提高生产力。
- en: Defining new concepts
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义新概念
- en: 'Defining new concepts is straightforward with some help from the type traits
    that you are already familiar with. The following example defines the concept
    `FloatingPoint` using the keyword `concept`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您已经熟悉的类型特征，可以轻松地定义新概念。以下示例使用关键字`concept`定义了概念`FloatingPoint`：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The right-hand side of the assignment expression is where we can specify the
    constraints of the type `T`. It''s also possible to combine multiple constraints
    using `||` (logical OR) and `&&` (logical AND). The following example uses `||`
    to combine floats and integrals into a `Number` concept:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式的右侧是我们可以指定类型`T`的约束的地方。还可以使用`||`（逻辑或）和`&&`（逻辑与）来组合多个约束。以下示例使用`||`将浮点数和整数组合成`Number`概念：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You will note that, it's possible to build concepts using already defined concepts
    on the right-hand side as well. The standard library contains a `<concepts>` header,
    which defines many useful concepts, such as `std::floating_point` (which we should
    use rather than defining our own).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到，还可以使用右侧已定义的概念构建概念。标准库包含一个`<concepts>`头文件，其中定义了许多有用的概念，例如`std::floating_point`（我们应该使用它而不是定义自己的）。
- en: 'Furthermore, we can use the `requires` keyword to add a set of statements that
    should be added to our concept definition. For example, this is the definition
    of the concept `std::range` from the Ranges library:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`requires`关键字来添加一组语句，这些语句应该添加到我们的概念定义中。例如，这是来自Ranges库的概念`std::range`的定义：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In short, this concept states that a range is something that we can pass to
    `std::ranges::begin()` and `std::ranges::end()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个概念说明了范围是我们可以传递给`std::ranges::begin()`和`std::ranges::end()`的东西。
- en: It's possible to write more sophisticated `requires` clauses than this, and
    you will see more on that later on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写比这更复杂的`requires`子句，稍后您将看到更多内容。
- en: Constraining types with concepts
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用概念约束类型
- en: 'We can add constraints to template parameter types by using the `requires`
    keyword. The following template can only be instantiated with the parameters of
    integral types by using the concept `std::integral`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`requires`关键字向模板参数类型添加约束。以下模板只能使用`std::integral`概念实例化整数类型的参数：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can use the same technique when defining class templates:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类模板时也可以使用相同的技术：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'An alternative syntax allows us to write this in a more compact way by replacing
    the `typename` directly with the concept:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种语法允许我们以更紧凑的方式编写，通过直接用概念替换`typename`：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This form can also be used with class templates:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式也可以用于类模板：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we want to use the abbreviated function template form when defining a function
    template, we can add the concept in front of the `auto` keyword:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在定义函数模板时使用缩写的函数模板形式，我们可以在`auto`关键字前面添加概念：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The return type can also be constrained by using concepts:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型也可以通过使用概念来约束：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see, there are many ways to specify the same thing. The abbreviated
    form combined with concepts has really made it easy to both read and write constrained
    function templates. Another powerful feature of C++ concepts is the ability to
    overload functions in a clear and expressive way.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有许多方法可以指定相同的事情。缩写形式与概念的结合确实使有限函数模板的阅读和编写变得非常容易。C++概念的另一个强大特性是以清晰和表达性的方式重载函数。
- en: Function overloading
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'Recall the `generic_mod()` function we implemented earlier using `if constexpr`.
    It looked something like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前使用`if constexpr`实现的`generic_mod()`函数。它看起来像这样：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'By using concepts, we can overload a function template similar to how we would
    have done if we''d written a regular C++ function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用概念，我们可以重载一个函数模板，类似于我们如果编写了一个常规的C++函数：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With your new knowledge of constraints and concepts, it's time to go back to
    our example with the `Point2D` template and see how it can be improved.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有了你对约束和概念的新知识，现在是时候回到我们的`Point2D`模板的例子，看看它如何改进。
- en: A constrained version of the Point2D template
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Point2D模板的约束版本
- en: Now that you know how to define and use concepts, let's put them to use by writing
    a better version of our templates, `Point2D` and `dist()`. Remember that what
    we're aiming for is a more expressive interface and to have errors caused by irrelevant
    parameter types appear at template instantiation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何定义和使用概念了，让我们通过编写一个更好的模板`Point2D`和`dist()`来使用它们。记住，我们的目标是一个更具表现力的接口，并且使由无关参数类型引起的错误在模板实例化时出现。
- en: 'We will begin by creating a concept for arithmetic types:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个算术类型的概念：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we will create a concept called `Point` that defines that a point should
    have the member functions `x()` and `y()` return the same type, and that this
    type should support arithmetic operations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`Point`的概念，它定义了一个点应该具有成员函数`x()`和`y()`返回相同类型，并且这个类型应该支持算术操作：
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This concept can now make the interface of `dist()` much better with explicit
    constraints:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念现在可以通过显式约束使`dist()`的接口更好：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is starting to look really promising, so let''s just add a constraint
    to our return type as well. Although `Point2D` might be instantiated with an integral
    type, we know that the distance can be a floating-point number. The concept `std::floating_point`
    from the standard library is well suited for this. Here is the final version of
    `dist()`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来真的很有希望，所以让我们也对我们的返回类型添加一个约束。虽然`Point2D`可能被实例化为整数类型，但我们知道距离可以是浮点数。标准库中的概念`std::floating_point`非常适合这个。这是`dist()`的最终版本：
- en: '[PRE76]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Our interface is now more descriptive, and when we try to instantiate it with
    wrong parameter types, we will get errors during the instantiation phase rather
    than the final compilation phase.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接口现在更加描述性，当我们尝试用错误的参数类型实例化它时，我们将在实例化阶段而不是最终编译阶段获得错误。
- en: 'We should now do the same to our `Point2D` template to avoid someone accidentally
    instantiating it with types that it wasn''t intended to handle. For example, we
    would like to prevent someone from instantiating a `Point2D` class with `const
    char*`, like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该对我们的`Point2D`模板做同样的事情，以避免有人意外地用它实例化它不打算处理的类型。例如，我们希望阻止有人用`const char*`实例化`Point2D`类，就像这样：
- en: '[PRE77]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We have already created the `Arithmetic` concept, which we can use here to
    put constraints in the template parameter of `Point2D`. Here is how we do this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`Arithmetic`概念，我们可以在这里使用它来在`Point2D`的模板参数中放置约束。这是我们如何做到的：
- en: '[PRE78]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The only thing we needed to change was to specify that the type `T` should support
    the operations specified by the concept `Arithmetic`. Trying to instantiate a
    template using `const char*` will now generate a direct error message while the
    compiler tries to instantiate a `Point2D<const char*>` class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要改变的是指定类型`T`应该支持概念`Arithmetic`指定的操作。尝试使用`const char*`实例化模板现在将生成一个直接的错误消息，而编译器尝试实例化`Point2D<const
    char*>`类。
- en: Adding constraints to your code
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向你的代码添加约束
- en: The usefulness of concepts reaches far beyond template metaprogramming. It's
    a fundamental feature of C++20 that changes how we write and reason about code
    using concepts other than concrete types or completely unconstrained variables
    declared with `auto`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 概念的实用性远远超出了模板元编程。这是C++20的一个基本特性，改变了我们使用概念而不是具体类型或完全无约束的变量声明`auto`来编写和推理代码的方式。
- en: A concept is very similar to a type (such as `int`, `float`, or `Plot2D<int>`).
    Both types and concepts specify a set of supported operations on an object. By
    inspecting a type or a concept, we can determine how certain objects can be constructed,
    moved, compared, and accessed by member functions and so on. A big difference,
    though, is that a concept does not say anything about how an object is stored
    in memory, whereas a type provides this information in addition to its set of
    supported operations. For example, we can use the `sizeof` operator on a type
    but not on a concept.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 概念非常类似于类型（如`int`、`float`或`Plot2D<int>`）。类型和概念都指定了对象上支持的一组操作。通过检查类型或概念，我们可以确定某些对象如何构造、移动、比较和通过成员函数访问等。然而，一个重大的区别是，概念并不说任何关于对象如何存储在内存中，而类型除了其支持的操作集之外还提供了这些信息。例如，我们可以在类型上使用`sizeof`运算符，但不能在概念上使用。
- en: 'With concepts and `auto`, we can declare variables without the need for spelling
    out the exact type, but still express the intent with our code very clearly. Have
    a look at the following code snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过概念和`auto`，我们可以声明变量而无需明确指出确切的类型，但仍然非常清楚地表达我们的意图。看一下以下代码片段：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Most of the time, when we stumble upon code like this, we are interested in
    knowing what operations we can perform on `v` rather than knowing the exact type.
    Adding a concept in front of `auto` makes the difference:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当我们遇到这样的代码时，我们更感兴趣的是我们可以在`v`上执行哪些操作，而不是知道确切的类型。在`auto`前面添加一个概念会产生不同的效果：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It''s possible to use concepts in almost all contexts where we can use the
    keyword `auto`: local variables, return values, function arguments, and so forth.
    Using concepts in our code makes it easier to read. At the time of writing this
    book (mid 2020), there is currently no additional support for concepts in the
    established C++ IDEs. However, it is just a matter of time before code completion,
    as well as other useful editor features based on concepts, will be available and
    make C++ coding both more fun and safer.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以在几乎所有可以使用关键字 `auto` 的上下文中使用概念：局部变量、返回值、函数参数等等。在我们的代码中使用概念使得阅读更加容易。在撰写本书时（2020
    年中），已经建立的 C++ IDE 中目前还没有对概念的额外支持。然而，代码补全以及其他基于概念的有用编辑器功能很快就会可用，使得 C++ 编码更加有趣和安全。
- en: Concepts in the standard library
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的概念
- en: C++20 also included a new `<concepts>` header with predefined concepts. You
    have already seen some of them in action. Many concepts are based on the traits
    from the type traits library. However, there are a few fundamental concepts that
    have not been expressed with traits previously. Among the most important ones
    are the comparison concepts such as `std::equality_comparable` and `std::totally_ordered`,
    as well as the object concepts such as `std::movable`, `std::copyable`, `std::regular`,
    and `std::semiregular`. We will not spend any more time on the concepts from the
    standard library but remember to keep them in mind before starting to define your
    own. Defining concepts on the correct level of generality is not trivial and it's
    usually wise to define new concepts based on the already existing ones.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 还包括一个新的 `<concepts>` 头文件，其中包含预定义的概念。您已经看到其中一些概念的作用。许多概念都是基于类型特性库中的特性。然而，有一些基本概念以前没有用特性表达。其中最重要的是比较概念，如
    `std::equality_comparable` 和 `std::totally_ordered`，以及对象概念，如 `std::movable`、`std::copyable`、`std::regular`
    和 `std::semiregular`。我们不会在标准库的概念上花费更多时间，但在开始定义自己的概念之前，请记住将它们牢记在心。在正确的泛化级别上定义概念并不是件容易的事，通常明智的做法是基于已经存在的概念定义新的概念。
- en: Let's end this chapter by having a look at some real-world examples of metaprogramming
    in C++.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 C++ 中一些实际的元编程示例来结束本章。
- en: Real-world examples of metaprogramming
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程的实际例子
- en: Advanced metaprogramming can appear to be very academic, so in order to demonstrate
    its usefulness, let's look at some examples that not only demonstrate the syntax
    of metaprogramming, but how it can be used in practice.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 高级元编程可能看起来非常学术化，因此为了展示其有用性，让我们看一些不仅演示元编程语法的例子，还演示它如何在实践中使用。
- en: 'Example 1: creating a generic safe cast function'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1：创建一个通用的安全转换函数
- en: 'When casting between data types in C++, there is a multitude of different ways
    things can go wrong:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中进行数据类型转换时，有多种不同的方式会出错：
- en: You might lose a value if casting to an integer type of a lower bit length.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将值转换为比特长度较低的整数类型，可能会丢失一个值。
- en: You might lose a value if casting a negative value to an unsigned integer.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将负值转换为无符号整数，可能会丢失一个值。
- en: If casting from a pointer to any other integer than `uintptr_t`, the correct
    address might become incorrect. This is because C++ only guarantees that `uintptr_t`
    is the only integer type that can withhold an address.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从指针转换为任何其他整数而不是 `uintptr_t`，正确的地址可能会变得不正确。这是因为 C++ 仅保证 `uintptr_t` 是唯一可以保存地址的整数类型。
- en: If casting from `double` to `float`, the result might be `int` if the `double`
    value is too large for `float` to withhold.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从 `double` 转换为 `float`，结果可能是 `int`，如果 `double` 值太大，`float` 无法容纳。
- en: If casting between pointers with a `static_cast()`, we might get undefined behavior
    if the types aren't sharing a common base class.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `static_cast()` 在指针之间进行转换，如果类型没有共同的基类，可能会得到未定义的行为。
- en: In order to make our code more robust, we can create a generic checked cast
    function that verifies our casts in debug mode and performs our casts as fast
    as possible if in release mode.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更加健壮，我们可以创建一个通用的检查转换函数，在调试模式下验证我们的转换，并在发布模式下尽可能快地执行我们的转换。
- en: Depending on the types that are being cast, different checks are performed.
    If we try to cast between types that are not verified, it won't compile.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 根据被转换的类型，会执行不同的检查。如果我们尝试在未经验证的类型之间进行转换，它将无法编译。
- en: 'These are the cases `safe_cast()` is intended to handle:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `safe_cast()` 旨在处理的情况：
- en: '**Same type**: Obviously, if we''re casting the same type, we just return the
    input value.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同类型：显然，如果我们转换相同类型，我们只需返回输入值。
- en: '**Pointer to pointer**: If casting between pointers, `safe_cast()` performs
    a dynamic cast in debug mode to verify it is castable.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针到指针：如果在指针之间进行转换，`safe_cast()` 在调试模式下执行动态转换以验证是否可转换。
- en: '**Double to floating point**: `safe_cast()` accepts precision loss when casting
    from `double` to `float` with one exception – if casting from a `double` to a
    `float`, there is a chance the double is too large for the float to handle the
    result.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双精度浮点数到浮点数：`safe_cast()` 在从 `double` 转换为 `float` 时接受精度损失，但有一个例外 - 如果从 `double`
    转换为 `float`，则有可能 `double` 太大，使得 `float` 无法处理结果。
- en: '**Arithmetic to arithmetic**: If casting between arithmetic types, the value
    is cast back to its original type to verify no precision has been lost.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术到算术：如果在算术类型之间进行转换，值将被转换回其原始类型以验证是否丢失精度。
- en: '**Pointer to non-pointer**: If casting from a pointer to a non-pointer type,
    `safe_cast()` verifies that the destination type is an `uintptr_t` or `intptr_t`,
    the only integer types that are guaranteed to hold an address.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针到非指针：如果从指针转换为非指针类型，`safe_cast()` 验证目标类型是否为 `uintptr_t` 或 `intptr_t`，这是唯一保证能够保存地址的整数类型。
- en: In any other case, the `safe_cast()` function fails to compile.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他情况下，`safe_cast()` 函数将无法编译。
- en: 'Let''s see how we can implement this. We start by fetching information about
    our cast operation in `constexpr` booleans. The reason they are `constexpr` booleans
    and not `const` booleans is that we will utilize them later in `if constexpr`
    expressions, which require `constexpr` conditions:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点。我们首先获取有关我们的转换操作的`constexpr`布尔值的信息。它们是`constexpr`布尔值而不是`const`布尔值的原因是，我们将在稍后的`if
    constexpr`表达式中使用它们，这些表达式需要`constexpr`条件：
- en: '[PRE81]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, now that we have all the necessary information about the cast as `constexpr`
    booleans, we assert at compile time that we can perform the cast. As mentioned
    previously, a `static_assert()` will fail to compile if the condition is not satisfied
    (unlike a regular assert, which verifies conditions at runtime).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经获得了关于转换的所有必要信息，作为`constexpr`布尔值，我们在编译时断言我们可以执行转换。如前所述，如果条件不满足，`static_assert()`将无法编译通过（与常规assert不同，后者在运行时验证条件）。
- en: Note the usage of `static_assert()` and `make_false<T>` at the end of the `if`/`else`
    chain. We cannot just type `static_assert(false)` as that would prevent `safe_cast()`
    from compiling at all; instead, we utilize the template function `make_false<T>()`
    to delay the generation until required.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在`if`/`else`链的末尾使用了`static_assert()`和`make_false<T>`。我们不能只输入`static_assert(false)`，因为那样会完全阻止`safe_cast()`的编译；相反，我们利用模板函数`make_false<T>()`来推迟生成，直到需要时。
- en: 'When the actual `static_cast()` is performed, we cast back to the original
    type and verify that the result is equal to the uncasted argument using a regular
    runtime `assert()` This way, we can make sure the `static_cast()` has not lost
    any data:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行实际的`static_cast()`时，我们将回到原始类型并验证结果是否等于未转换的参数，使用常规的运行时`assert()`。这样，我们可以确保`static_cast()`没有丢失任何数据：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Note how we use the `if constexpr` in order for the function to conditionally
    compile. If we use a regular `if` statement, the function will fail to compile:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用`if constexpr`来使函数有条件地编译。如果我们使用普通的`if`语句，函数将无法编译通过。
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is because the compiler will try to compile the following line and `dynamic_cast`
    only accepts pointers:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器将尝试编译以下行，而`dynamic_cast`只接受指针：
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'However, thanks to the `if constexpr` and `safe_cast<int>(42.0f)` constructs,
    the following function compiles properly:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`if constexpr`和`safe_cast<int>(42.0f)`的构造，以下函数可以正确编译：
- en: '[PRE85]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can see, except for the `is_number_to_number` clause, everything in-between
    the `if constexpr` statements has been completely eradicated, allowing the function
    to compile.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了`is_number_to_number`子句之外，在`if constexpr`语句之间的所有内容都已经被完全消除，从而使函数能够编译。
- en: 'Example 2: hash strings at compile time'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2：在编译时对字符串进行哈希处理
- en: 'Let''s say we have a resource system consisting of an unordered map of strings
    that identifies bitmaps. If a bitmap is already loaded, the system returns the
    loaded bitmap; otherwise, it loads the bitmap and returns it:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个资源系统，其中包含一个无序映射的字符串，用于标识位图。如果位图已经加载，系统将返回已加载的位图；否则，它将加载位图并返回：
- en: '[PRE86]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The bitmap cache is then utilized wherever a bitmap resource is needed:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在需要位图资源的地方使用位图缓存：
- en: If it's not loaded yet, the `get_bitmap_resource()` function will load and return
    it
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未加载，`get_bitmap_resource()`函数将加载并返回它
- en: If it's already been loaded somewhere else, the `get_bitmap_resource()` will
    simply return the loaded function
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经在其他地方加载过，`get_bitmap_resource()`将简单地返回已加载的函数。
- en: 'So, independent of which of these draw functions is executed first, the second
    one will not have to load the bitmap from disk:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论哪个绘制函数先执行，第二个函数都不必从磁盘加载位图：
- en: '[PRE87]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Since we are using an unordered map, we need to compute a hash value whenever
    we check for a bitmap resource. You will now see how we can optimize the runtime
    code by moving computations to compile time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了无序映射，每当我们检查位图资源时都需要计算哈希值。现在您将看到我们如何通过将计算移动到编译时来优化运行时代码。
- en: The advantages of the compile-time hash sum calculation
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译时哈希值计算的优势
- en: The problem that we will try to solve is that every time the line `get_bitmap_resource("my_bitmap.png")`
    is executed, the application will compute the hash sum of the string `"my_bitmap.png"`
    at runtime. What we would like to do is perform this calculation at compile time
    so that when the application executes, the hash sum has already been calculated.
    In other words, just as you have learned to use metaprogramming to generate functions
    and classes at compile time, we will now have it generate the hash sum at compile
    time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试解决的问题是，每次执行`get_bitmap_resource("my_bitmap.png")`这一行时，应用程序都会在运行时计算字符串`"my_bitmap.png"`的哈希值。我们希望在编译时执行这个计算，这样当应用程序执行时，哈希值已经被计算出来。换句话说，就像你们学习使用元编程在编译时生成函数和类一样，我们现在要让它在编译时生成哈希值。
- en: 'You might have already come to the conclusion that this is a so-called *micro-optimization*:
    calculating the hash sum of a small string won''t affect the application''s performance
    at all as it is such a tiny operation. That is probably completely true; this
    is just an example of how to move a calculation from runtime to compile time,
    and there might be other instances where this can make a significant performance
    impact.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经得出结论，这是所谓的*微优化*：计算一个小字符串的哈希值不会对应用程序的性能产生任何影响，因为这是一个非常小的操作。这可能完全正确；这只是一个将计算从运行时移动到编译时的示例，可能还有其他情况下这可能会产生显著的性能影响。
- en: As a side note, when writing software for weak hardware, string hashing is a
    pure luxury, but hashing strings at compile time gives us this luxury on any platform
    since everything is computed at compile time.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，当为弱硬件编写软件时，字符串哈希是一种纯粹的奢侈，但在编译时对字符串进行哈希处理可以让我们在任何平台上都享受到这种奢侈，因为一切都是在编译时计算的。
- en: Implementing and verifying a compile-time hash function
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现和验证编译时哈希函数
- en: 'In order to enable the compiler to calculate the hash sum at compile time,
    we rewrite `hash_function()` so that it takes a raw null-terminated `char` string
    as a parameter of an advanced class like `std::string`, which cannot be evaluated
    at compile time. Now, we can mark `hash_function()` as `constexpr`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编译器能够在编译时计算哈希和，我们重写`hash_function()`，使其以一个高级类（如`std::string`）的原始空终止`char`字符串作为参数，这在编译时无法计算。现在，我们可以将`hash_function()`标记为`constexpr`：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, let''s invoke this with a raw literal string known at compile time:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用在编译时已知的原始字面字符串调用它：
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The compiler will generate the following piece of code, which is the sum of
    the ASCII values corresponding to `a`, `b`, and `c` (`97`, `98`, and `99`):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将生成以下代码片段，这是与`a`，`b`和`c`对应的ASCII值的总和（`97`，`98`和`99`）：
- en: '[PRE90]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Just accumulating the individual values is a very bad hash function; do not
    do this in a real-world application. It's only here because it's easy to grasp.
    A better hash function would be to combine all the individual characters with
    `boost::hash_combine()`, as explained in *Chapter 4*, *Data Structures*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 只是累积单个值是一个非常糟糕的哈希函数；在实际应用中不要这样做。这里只是因为它容易理解。一个更好的哈希函数是将所有单个字符与`boost::hash_combine()`结合起来，如*第4章*，*数据结构*中所解释的那样。
- en: '`hash_function()` will only evaluate at compile time if the compiler knows
    the string at compile time; if not, the compiler will execute `constexpr` at runtime,
    just like any other expression.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash_function()`只有在编译器在编译时知道字符串时才会在编译时计算；如果不知道，编译器将像任何其他表达式一样在运行时执行`constexpr`。'
- en: Now that we have the hash function in place, it's time to create a string class
    that uses it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了哈希函数，现在是时候创建一个使用它的字符串类了。
- en: Constructing a PrehashedString class
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造一个PrehashedString类
- en: 'We are now ready to implement a class for pre-hashed strings that will use
    the hash function we created. This class consists of the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现一个用于预哈希字符串的类，它将使用我们创建的哈希函数。这个类包括以下内容：
- en: A constructor that takes a raw string as a parameter and calculates the hash
    at construction.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以原始字符串作为参数并在构造时计算哈希的构造函数。
- en: Comparison operators.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符。
- en: A `get_hash()` member function, which returns the hash.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`get_hash()`成员函数，返回哈希值。
- en: An overload of `std::hash()`, which simply returns the hash value. This overload
    is used by `std::unordered_map`, `std::unordered_set`, or any other class from
    the standard library that uses hash values. To put it simply, this makes the container
    aware that a hash function exists for the `PrehashedString`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::hash()`的重载，简单地返回哈希值。这个重载被`std::unordered_map`，`std::unordered_set`或标准库中使用哈希值的任何其他类使用。简单地说，这使得容器意识到`PrehashedString`存在一个哈希函数。'
- en: 'Here is a basic implementation of a `PrehashedString` class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`PrehashedString`类的基本实现：
- en: '[PRE91]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Note the template trick in the constructor. This forces the `PrehashedString`
    to only accept compile-time string literals. The reason for this is that the `PrehashedString`
    class does not own the `const char* ptr` and therefore we may only use it with
    string literals created at compile time:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意构造函数中的模板技巧。这迫使`PrehashedString`只接受编译时字符串字面值。这样做的原因是`PrehashedString`类不拥有`const
    char* ptr`，因此我们只能在编译时使用它创建的字符串字面值：
- en: '[PRE92]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: So, now that we have everything in place, let's see how the compiler handles
    `PrehashedString`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，既然我们已经准备就绪，让我们看看编译器如何处理`PrehashedString`。
- en: Evaluating PrehashedString
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估PrehashedString
- en: 'Here is a simple test function that returns the hash value for the string `"abc"`
    (used for simplicity):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的测试函数，返回字符串`"abc"`的哈希值（为了简单起见）：
- en: '[PRE93]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Since our hash function simply sums the values, and the letters in `"abc"`
    have ASCII values of *a* = 97, *b* = 98, and *c* = 99, the assembler (generated
    by Clang) should output the sum 97 + 98 + 99 = 294 somewhere. Inspecting the assembler,
    we can see that the `test_prehashed_string()` function compiles to exactly one
    `return` statement, which returns `294`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的哈希函数只是对值求和，而`"abc"`中的字母具有ASCII值*a* = 97，*b* = 98，*c* = 99，由Clang生成的汇编代码应该输出和为97
    + 98 + 99 = 294。检查汇编代码，我们可以看到`test_prehashed_string()`函数编译成了一个`return`语句，返回`294`：
- en: '[PRE94]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This means that the whole `test_prehashed_string()` function has been executed
    at compile time; when the application executes, the hash sum has already been
    calculated!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着整个`test_prehashed_string()`函数已经在编译时执行；当应用程序执行时，哈希和已经被计算！
- en: Evaluating get_bitmap_resource() with PrehashedString
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PrehashedString评估get_bitmap_resource()
- en: 'Let''s return to our original `get_bitmap_resource()` function, the `std::string`,
    which was originally used and exchanged for a `PrehashedString`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初的`get_bitmap_resource()`函数，最初使用的`std::string`已经被替换为`PrehashedString`：
- en: '[PRE95]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We also need a function to test with:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个测试函数：
- en: '[PRE96]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What we would like to know is whether this function precalculated the hash sum.
    Since `get_bitmap_resource()` does quite a lot (constructing a static `std::unordered_map`,
    inspecting the map, and so on), the resulting assembly is about 500 lines. Nevertheless,
    if our magic hash sum is found in the assembler, this means that we have succeeded.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道的是这个函数是否预先计算了哈希和。由于`get_bitmap_resource()`做了很多事情（构造静态`std::unordered_map`，检查映射等），生成的汇编代码大约有500行。尽管如此，如果我们的魔术哈希和在汇编代码中找到，这意味着我们成功了。
- en: 'When inspecting the assembler generated by Clang, we will find a line that
    corresponds to our hash sum, `294`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查由Clang生成的汇编代码时，我们将找到一行对应于我们的哈希和，`294`：
- en: '[PRE97]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: To confirm this, we will change the string from `"abc"` to `"aaa"`, which should
    change this line in the assembler to 97 * 3 = 291, but everything else should
    be exactly the same.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这一点，我们将字符串从`"abc"`改为`"aaa"`，这应该将汇编代码中的这一行改为97 * 3 = 291，但其他一切应该完全相同。
- en: We're doing this to make sure this wasn't just some other magic number that
    popped up, totally unrelated to the hash sum.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了确保这不只是一些其他与哈希和毫不相关的魔术数字。
- en: 'Inspecting the resulting assembler, we will find the desired result:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的汇编代码，我们将找到期望的结果：
- en: '[PRE98]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Everything, except this line, is the same, so we can safely assume that the
    hash is calculated at compile time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这一行之外，其他都是相同的，因此我们可以安全地假设哈希是在编译时计算的。
- en: The examples we have looked at demonstrate that we can use compile-time programming
    for very different things. Adding safety checks that can be verified at compile
    time allows us to find bugs without running the program and searching for errors
    with coverage tests. And moving expensive runtime operations to compile time makes
    our final program faster.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的示例表明，我们可以将编译时编程用于非常不同的事情。添加可以在编译时验证的安全检查，使我们能够在不运行程序并通过覆盖测试搜索错误的情况下找到错误。并且将昂贵的运行时操作转移到编译时可以使我们的最终程序更快。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to use metaprogramming to generate functions
    and values at compile time instead of runtime. You also discovered how to do this
    in a modern C++ way by using templates, the `constexpr`, `static_assert()`, and
    `if constexpr`, type traits, and concepts. Moreover, with constant string hashing,
    you saw how to use compile-time evaluation in a practical context.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用元编程来在编译时而不是运行时生成函数和值。您还发现了如何以现代C++的方式使用模板、`constexpr`、`static_assert()`和`if
    constexpr`、类型特征和概念来实现这一点。此外，通过常量字符串哈希，您看到了如何在实际环境中使用编译时评估。
- en: In the next chapter, you will learn how to further expand your C++ toolbox so
    that you can create libraries by constructing hidden proxy objects.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何进一步扩展您的C++工具箱，以便您可以通过构建隐藏的代理对象来创建库。
