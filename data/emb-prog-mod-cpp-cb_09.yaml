- en: Peripherals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外围设备
- en: Communication with peripheral devices is an essential part of any embedded application.
    Applications need to check the availability and status and send data to and receive
    data from a variety of devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与外围设备的通信是任何嵌入式应用的重要部分。应用程序需要检查可用性和状态，并向各种设备发送数据和接收数据。
- en: 'Each target platform is different and many ways of connecting peripheral devices
    to the computing unit exist. There are, however, several hardware and software
    interfaces that have become industry standard for communication with peripheral
    devices. In this chapter, we will learn how to work with peripheral devices connected
    directly to processor pins or over serial interfaces. This chapter covers the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目标平台都不同，连接外围设备到计算单元的方式有很多种。然而，有几种硬件和软件接口已经成为与外围设备通信的行业标准。在本章中，我们将学习如何处理直接连接到处理器引脚或串行接口的外围设备。本章涵盖以下主题：
- en: Controlling devices connected via GPIO
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GPIO控制连接的设备
- en: Exploring pulse-width modulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索脉宽调制
- en: Using ioctl to access a real-time clock in Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ioctl访问Linux中的实时时钟
- en: Using libgpiod to control GPIO pins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用libgpiod控制GPIO引脚
- en: Controlling I2C peripheral devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制I2C外围设备
- en: The recipes in this chapter involve interaction with real hardware and are intended
    to be run on a real Raspberry Pi board.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的配方涉及与真实硬件的交互，并打算在真实的树莓派板上运行。
- en: Controlling devices connected via GPIO
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过GPIO控制连接的设备
- en: '**General Purpose Input-Output** (GPIO) is the simplest way of connecting peripheral
    devices to the CPU. Every processor usually has some number of pins reserved for
    general purposes. These pins can be electrically connected directly to the pins
    of a peripheral device. An embedded application can control the device by changing
    the signal level of the pins configured for output or by reading the signal level
    of the input pins.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用输入输出**（GPIO）是将外围设备连接到CPU的最简单方式。每个处理器通常都有一些用于通用目的的引脚。这些引脚可以直接与外围设备的引脚电连接。嵌入式应用可以通过改变配置为输出的引脚的信号电平或读取输入引脚的信号电平来控制设备。'
- en: The interpretation of the signal levels does not follow any protocol and is
    determined by the peripheral device. Developers need to consult the device datasheet
    to be able to program the communication properly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 信号电平的解释不遵循任何协议，而是由外围设备确定。开发人员需要查阅设备数据表以便正确地编程通信。
- en: This type of communication is usually done on the kernel side using a dedicated
    device driver. This is, however, not always a requirement. In this recipe, we
    will learn how to use the GPIO interface on a Raspberry Pi board from a user-space
    application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的通信通常是在内核端使用专用设备驱动程序完成的。然而，这并不总是必需的。在这个配方中，我们将学习如何从用户空间应用程序中使用树莓派板上的GPIO接口。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to create a simple application that controls a **Light Emitting
    Diode** (LED) connected to a general-purpose pin on a Raspberry Pi board:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，控制连接到树莓派板上的通用引脚的**发光二极管**（LED）：
- en: In your `~/test` working directory, create a subdirectory called `gpio`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`~/test`工作目录中，创建一个名为`gpio`的子目录。
- en: Use your favorite text editor to create a `gpio.cpp` file in the `gpio` subdirectory.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器在`gpio`子目录中创建一个`gpio.cpp`文件。
- en: 'Put the following code snippet into the file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段放入文件中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[WiringPI示例](http://wiringpi.com/examples/blink/)部分的说明，将LED连接到树莓派板上。
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry Pi documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个SSH连接到你的树莓派板。按照[Raspberry Pi文档](https://www.raspberrypi.org/documentation/remote-access/ssh/)部分的说明进行操作。
- en: Copy the contents of the `gpio` folder to the Raspberry Pi board over SSH.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH将`gpio`文件夹的内容复制到树莓派板上。
- en: 'Log in to the board over SSH, then build and run the application:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH登录到板上，然后构建和运行应用程序：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your application should run and you should be able to observe the LED blinking.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该运行，你应该能够观察到LED在闪烁。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Raspberry Pi boards have 40 pins (26 in the first models) that can be programmed
    using a **Memory-Mapped Input-Output** (**MMIO**) mechanism. MMIO allows developers
    to query or set the state of pins by reading or writing specific addresses in
    the physical memory of the system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派板有40个引脚（第一代有26个）可以使用**内存映射输入输出**（MMIO）机制进行编程。MMIO允许开发人员通过读取或写入系统物理内存中的特定地址来查询或设置引脚的状态。
- en: In the *Using specialized memory* recipe in [Chapter 6](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml),
    *Memory Management*, we learned how to access MMIO registers. In this recipe,
    we are going to offload the MMIO address's manipulations to the specialized library,
    `wiringPi`. It hides all the complexities of memory mapping and finding proper
    offsets under the hood, exposing a clean API instead.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml)的*使用专用内存*配方中，*内存管理*，我们学习了如何访问MMIO寄存器。在这个配方中，我们将把MMIO地址的操作交给专门的库`wiringPi`。它隐藏了内存映射和查找适当偏移量的所有复杂性，而是暴露了一个清晰的API。
- en: 'This library is pre-installed on Raspberry Pi boards, so to simplify the build
    process, we are going to build the code directly on the board instead of using
    cross-compilation. Unlike other recipes, our build rules do not mention a cross
    compiler—we are going to use the native ARM compiler on the board. We only add
    a dependency to the `wiringPi` library:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库已经预装在树莓派板上，所以为了简化构建过程，我们将直接在板上构建代码，而不是使用交叉编译。与其他教程不同，我们的构建规则没有提到交叉编译器 - 我们将使用板上的本机ARM编译器。我们只添加了对`wiringPi`库的依赖：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code of this example is a modification of the `wiringPi` example for blinking
    an LED. Firstly, we initialize the `wiringPi` library:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码是对`wiringPi`用于LED闪烁的示例的修改。首先，我们初始化`wiringPi`库：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we enter the endless loop. On each iteration, we set the pin to the `HIGH`
    state:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入无限循环。在每次迭代中，我们将引脚设置为`HIGH`状态：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the `500 ms` delay, we set the same pit to the `LOW` state and add another
    delay:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在500毫秒的延迟之后，我们将相同的引脚设置为`LOW`状态并添加另一个延迟：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We configured our program to use pin `0`, which corresponds to `GPIO.0` or
    pin `17` of the `BCM2835` chip of Raspberry Pi:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置程序使用引脚`0`，对应于树莓派的`BCM2835`芯片的`GPIO.0`或引脚`17`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If an LED is connected to this pin, it will blink, turning on for 0.5 seconds
    and then off for another 0.5 seconds. By tweaking the delays in the loop, you
    can change the blinking pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LED连接到这个引脚，它将会闪烁，打开0.5秒，然后关闭0.5秒。通过调整循环中的延迟，您可以改变闪烁模式。
- en: Since the program enters an endless loop, we can terminate it at any time by
    pressing *Ctrl* + *C* in the SSH console; otherwise, it will run forever.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序进入无限循环，我们可以通过在SSH控制台中按下*Ctrl* + *C*来随时终止它；否则，它将永远运行。
- en: 'When we run the application, we only see the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们只会看到以下输出：
- en: '![](img/9f3a257e-977a-4e63-97e3-c39452e84ce4.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f3a257e-977a-4e63-97e3-c39452e84ce4.png)'
- en: 'We log when we turn the LED `on` or `off`, but to check that the program actually
    works, we need to look at the LED connected to the pin. If we follow the wiring
    instructions, we can see how it works. While the program is running, the LED on
    the boards blinks synchronously with the program output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录LED打开或关闭的时间，但要检查程序是否真正工作，我们需要查看连接到引脚的LED。如果我们按照接线说明，就可以看到它是如何工作的。当程序运行时，板上的LED会与程序输出同步闪烁：
- en: '![](img/72b7b80d-860c-48ec-ba6c-bb4aaee983d5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72b7b80d-860c-48ec-ba6c-bb4aaee983d5.png)'
- en: We are able to control simple devices connected directly to the CPU pins without
    writing complicated device drivers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够控制直接连接到CPU引脚的简单设备，而无需编写复杂的设备驱动程序。
- en: Exploring pulse-width modulation
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索脉宽调制
- en: 'Digital pins can only be in one of two states: either `HIGH` or `LOW`. An LED
    connected to a digital pin can also only be in one of two states: `on` or `off`,
    correspondingly. But is there a way to control the brightness of this LED? Yes,
    we can use a method called **Pulse-width Modulation **(**PWM**).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数字引脚只能处于两种状态之一：`HIGH`或`LOW`。连接到数字引脚的LED也只能处于两种状态之一：`on`或`off`。但是有没有办法控制LED的亮度？是的，我们可以使用一种称为**脉宽调制**（**PWM**）的方法。
- en: The idea behind PWM is simple. We limit the amount of power delivered by the
    electrical signal by turning it on or off periodically. This makes the signal
    pulse with some frequency and the amount of power is proportional to the width
    of the pulse—the time when the signal was `HIGH`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PWM背后的想法很简单。我们通过周期性地打开或关闭电信号来限制电信号传递的功率。这使得信号以一定频率脉冲，并且功率与脉冲宽度成正比 - 即信号处于`HIGH`状态的时间。
- en: For example, if we turn a pin to `HIGH` for 10 microseconds and then `LOW` for
    another 90 microseconds in a loop, a device connected to that pin receives 10%
    of the power that would be delivered if the pin were always `HIGH`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将引脚设置为`HIGH` 10微秒，然后在循环中再设置为`LOW` 90微秒，连接到该引脚的设备将接收到原本的10%的电源。
- en: In this recipe, we will learn how to use PWM to control the brightness of an
    LED connected to a digital GPIO pin on the Raspberry Pi board.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用PWM来控制连接到树莓派板数字GPIO引脚的LED的亮度。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'We are going to create a simple application that gradually changes the brightness
    of an LED connected to a general-purpose pin on a Raspberry Pi board:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，逐渐改变连接到树莓派板上的通用引脚的LED的亮度：
- en: In your `~/test` working directory, create a subdirectory called `pwm`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`pwm`的子目录。
- en: Use your favorite text editor to create a `pwm.cpp` file in the `pwm` subdirectory.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`pwm`子目录中创建一个名为`pwm.cpp`的文件。
- en: 'Let''s put in the required `include` functions and define a function called `Blink`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加所需的`include`函数并定义一个名为`Blink`的函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is followed by a `main` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个`main`函数：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/.).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/)中的*WiringPI示例*部分的说明，将LED连接到树莓派板上。
- en: Set up an SSH connection to your Raspberry Pi board. Follow instructions from
    the *Raspberry PI documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立SSH连接到您的树莓派板。请按照[https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/)中的*Raspberry
    PI文档*部分的说明进行操作。
- en: Copy the contents of the `pwm` folder to the Raspberry Pi board over SSH.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH将`pwm`文件夹的内容复制到树莓派板上。
- en: 'Log in to the board over SSH, then build and run the application:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH登录到板上，然后构建和运行应用程序：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your application should now run and you can observe the LED blinking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在应该运行，您可以观察LED的闪烁。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe reuses the code to blink an LED and the schematics from the preceding
    recipe. We moved this code from the `main` function to a new function, `Blink`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方重用了从前一个配方中闪烁LED的代码和原理图。我们将这段代码从`main`函数移动到一个新函数`Blink`中。
- en: 'The `Blink` function accepts two parameters—`duration` and `percent_on`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blink`函数接受两个参数——`duration`和`percent_on`：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`duration` determines the total width of the pulse in microseconds. `percent_on`
    defines a ratio of the time when the signal is `HIGH` to the total duration of
    the pulse.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration`确定脉冲的总宽度（以微秒为单位）。`percent_on`定义了信号为`HIGH`时的时间与脉冲总持续时间的比例。'
- en: 'The implementation is straightforward. When `Blink` is invoked, it turns the
    pin to `HIGH` and waits for the amount of time proportional to `percent_on`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单。当调用`Blink`时，它将引脚设置为`HIGH`并等待与`percent_on`成比例的时间：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, it turns the pin to `LOW` and waits for the remaining time:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它将引脚设置为`LOW`并等待剩余时间：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Blink` is the main building block for implementing PWM. We can control the
    brightness by changing `percent_on` from `0` to `100`, and if we pick `duration`
    short enough, we will not see any flickering.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blink`是实现PWM的主要构建块。我们可以通过将`percent_on`从`0`变化到`100`来控制亮度，如果我们选择足够短的`duration`，我们将看不到任何闪烁。'
- en: A duration that is equal to or shorter than the refresh rate of a TV or monitor
    is good enough. For 60 Hz, the duration is 16.6 milliseconds. We use 10 milliseconds
    for simplicity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 电视或监视器的刷新率相等或短于持续时间是足够好的。对于60赫兹，持续时间为16.6毫秒。我们使用10毫秒以简化。
- en: 'Next, we wrap everything up in another endless loop, but now it has another
    parameter, `count`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所有内容包装在另一个无限循环中，但现在它有另一个参数`count`：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is updated with each iteration and bounces between `0` and `100`. The `delta` variable
    defines the direction of change—either a decrease or increase—as well as the amount
    of change, which is always `1` in our case:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它在每次迭代中更新，并在`0`和`100`之间反弹。`delta`变量定义了变化的方向——减少或增加——以及变化的量，在我们的情况下始终为`1`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the count reaches `101` or `0`, the direction changes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当计数达到`101`或`0`时，方向会改变：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On each iteration, we invoke `Blink`, passing `10ms` as a pulse and `count`
    as a ratio that defines the amount of time when LED is on, hence its brightness
    (as shown in the following image):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们调用`Blink`，传递`10ms`作为脉冲和`count`作为定义LED开启时间的比例，因此它的亮度（如下图所示）：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/98a8f41e-0940-43fa-82fe-09b2c45f7fb0.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98a8f41e-0940-43fa-82fe-09b2c45f7fb0.png)'
- en: Due to the high frequency of updates, we cannot tell when the LED turns from
    on to off.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更新频率高，我们无法确定LED何时从开启到关闭。
- en: When we wire everything up and run the program, we can see that the LED gets
    brighter or dimmer smoothly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有东西连接起来并运行程序时，我们可以看到LED逐渐变亮或变暗。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: PWM is widely used in embedded systems for a variety of purposes. It is a common
    mechanism for servo control and voltage regulation. Use the *Pulse-width modulation*
    Wikipedia page, available at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation),
    as a starting point to learn more about this technique.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: PWM广泛用于嵌入式系统，用于各种目的。这是伺服控制和电压调节的常见机制。使用*脉宽调制*维基百科页面，网址为[https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation)，作为了解更多关于这种技术的起点。
- en: Using ioctl to access a real-time clock in Linux
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ioctl访问Linux中的实时时钟
- en: In our preceding recipes, we used MMIO to access peripheral devices from user-space
    Linux applications. This interface, however, is not the recommended way of communication
    between user-space applications and device drivers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方中，我们使用MMIO从用户空间Linux应用程序访问外围设备。然而，这种接口不是用户空间应用程序和设备驱动程序之间通信的推荐方式。
- en: In Unix-like operating systems such as Linux, most of the peripheral devices
    can be accessed in the same way as regular files using so-called device files.
    When an application opens a device file, it can read from it, fetching data from
    the corresponding device, or write to it, sending data to the device.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix操作系统（如Linux）中，大多数外围设备可以以与常规文件相同的方式访问，使用所谓的设备文件。当应用程序打开设备文件时，它可以从中读取，从相应设备获取数据，或者向其写入，向设备发送数据。
- en: In many cases, device drivers cannot work with unstructured data streams. They
    expect data exchange organized in the form of requests and responses, where each
    request and response has a specific and fixed format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，设备驱动程序无法处理非结构化的数据流。它们期望以请求和响应的形式组织的数据交换，其中每个请求和响应都有特定和固定的格式。
- en: This kind of communication is covered by the `ioctl` system call. It accepts
    a device-dependant request code as its parameter. It may also contain other parameters
    that encode the request data or provide storage for the output data. These parameters
    are specific to a particular device and request code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信由`ioctl`系统调用来处理。它接受一个设备相关的请求代码作为参数。它还可能包含其他参数，用于编码请求数据或提供输出数据的存储。这些参数特定于特定设备和请求代码。
- en: In this recipe, we will learn how to use `ioctl` in user-space applications
    for data exchange with device drivers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在用户空间应用程序中使用`ioctl`与设备驱动程序进行数据交换。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that reads the current time from the **Real-Time
    Clock** (**RTC**) connected to the Raspberry Pi board:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，从连接到树莓派板的**实时时钟**（**RTC**）中读取当前时间：
- en: In your `~/test` working directory, create a subdirectory called `rtc`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`rtc`的子目录。
- en: Use your favorite text editor to create a `rtc.cpp` file in the `rtc` subdirectory.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`rtc`子目录中创建一个名为`rtc.cpp`的文件。
- en: 'Let''s put the required `include` functions into the `rtc.cpp` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把所需的`include`函数放到`rtc.cpp`文件中：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we define a class called `Rtc` that encapsulates the communication to
    the real-clock device:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个名为`Rtc`的类，它封装了对真实时钟设备的通信：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the class is defined, we put a simple usage example into the `main` function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦类被定义，我们将一个简单的使用示例放入`main`函数中：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Build your application and copy the resulting `rtc` binary to our Raspberry
    Pi emulator.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的应用程序并将生成的`rtc`二进制文件复制到我们的树莓派模拟器中。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We are implementing an application that talks directly to the hardware RTC connected
    to the system. There is a difference between the system clock and the RTC. The
    system clock is active and maintained only when the system is running. When the
    system is powered off or goes into sleep mode, the system clock becomes invalid.
    The RTC is active even when the system is off. It maintains the actual time that
    is used to configure the system clock when the system is up. Moreover, it can
    be programmed to wake up the system at a specific time when in sleep mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实现一个直接与连接到系统的硬件RTC通信的应用程序。系统时钟和RTC之间存在差异。系统时钟仅在系统运行时处于活动状态并维护。当系统关闭电源或进入睡眠模式时，系统时钟变得无效。即使系统关闭，RTC也处于活动状态。它维护用于在系统启动时配置系统时钟的实际时间。此外，它可以被编程为在睡眠模式下的特定时间唤醒系统。
- en: 'We encapsulate all communication with the RTC driver into a class called `Rtc`.
    All data exchange with the driver goes through the `/dev/rtc` special device file. In
    the `Rtc` class constructor, we open the device file and store the resulting file
    descriptor in the `fd` instance variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有与RTC驱动程序的通信封装到一个名为`Rtc`的类中。与驱动程序的所有数据交换都通过`/dev/rtc`特殊设备文件进行。在`Rtc`类构造函数中，我们打开设备文件并将结果文件描述符存储在`fd`实例变量中：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, a destructor is used to close the file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，析构函数用于关闭文件：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since the device is closed in the destructor as soon as the `Rtc` instance
    is destroyed, we can use the **Resource Acquisition is Initialization **(RAII)
    idiom to throw exceptions when something goes wrong without leaking the file descriptors:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备在析构函数中关闭，一旦`Rtc`实例被销毁，我们可以使用**资源获取即初始化**（RAII）习惯用法在出现问题时抛出异常而不泄漏文件描述符：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our class defines only one member function—`GetTime`. It is a wrapper on top
    of the `RTC_RD_TIME` `ioctl` call. This call expects a `rtc_time` structure to
    return the current time. It is almost identical to the `tm` structure that we
    are going to use to convert the time returned by the RTC driver into a POSIX timestamp
    format, so we place both of them into the same memory location as a `union` data
    type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类只定义了一个成员函数—`GetTime`。它是在`RTC_RD_TIME` `ioctl`调用之上的一个包装器。此调用期望返回一个`rtc_time`结构以返回当前时间。它几乎与我们将要用来将RTC驱动程序返回的时间转换为POSIX时间戳格式的`tm`结构相同，因此我们将它们都放入相同的内存位置作为`union`数据类型：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This way, we avoid copying identical fields from one structure to another.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们避免了从一个结构复制相同字段到另一个结构。
- en: 'Once the data structure is ready, we invoke the `ioctl` call, passing the `RTC_RD_TIME`
    constant as a request ID and a pointer to our structure as an address to store
    data to:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构准备就绪后，我们调用`ioctl`调用，将`RTC_RD_TIME`常量作为请求ID传递，并将指向我们结构的指针作为存储数据的地址传递：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once successful, `ioctl` returns `0`. In this case, we convert the resulting
    data structure into the `time_t` POSIX timestamp format using the `mktime` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，`ioctl`返回`0`。在这种情况下，我们使用`mktime`函数将结果数据结构转换为`time_t` POSIX时间戳格式：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `main` function, we create an instance of the `Rtc` class and then invoke
    the `GetTime` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们创建了`Rtc`类的一个实例，然后调用`GetTime`方法：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the POSIX timestamp represents the number of seconds since January 1,
    1970, we convert it into a human-friendly representation using the `ctime` function
    and output the result to the console:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自从POSIX时间戳表示自1970年1月1日以来的秒数，我们使用`ctime`函数将其转换为人类友好的表示，并将结果输出到控制台：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we run our application, we can see the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，我们可以看到以下输出：
- en: '![](img/b7640217-c2f3-4c53-b5b8-c7901c07760f.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7640217-c2f3-4c53-b5b8-c7901c07760f.png)'
- en: We were able to read the current time directly from the hardware clock using
    `ioctl`. The `ioctl` API is widely used in Linux embedded applications to communicate
    with devices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够直接从硬件时钟使用`ioctl`读取当前时间。`ioctl` API在Linux嵌入式应用中被广泛使用，用于与设备通信。
- en: There's more
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: In our simple example, we learned how to use only one `ioctl` request. RTC devices
    support many other requests that can be used to set the alarm, update the time,
    and control RTC interrupts. More details can be found in the *RTC ioctl documentation* section
    available at [https://linux.die.net/man/4/rtc](https://linux.die.net/man/4/rtc).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，我们学习了如何只使用一个`ioctl`请求。RTC设备支持许多其他请求，可用于设置闹钟，更新时间和控制RTC中断。更多细节可以在[https://linux.die.net/man/4/rtc](https://linux.die.net/man/4/rtc)的*RTC
    ioctl文档*部分找到。
- en: Using libgpiod to control GPIO pins
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用libgpiod控制GPIO引脚
- en: In the preceding recipe, we learned how to access the RTC using the `ioctl`
    API. Can we use it to control GPIO pins as well? The answer is yes. Recently,
    a generic GPIO driver was added to Linux, along with a user-space library, `libgpiod`,
    to simplify access to devices connected to GPIO by adding a convenience layer
    on top of the generic `ioctl` API. This interface allows embedded developers to
    manage their devices on any Linux-based platform without writing device drivers.
    Additionally, it provides bindings for C++ out of the box.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的教程中，我们学习了如何使用`ioctl` API访问RTC。我们可以使用它来控制GPIO引脚吗？答案是肯定的。最近，Linux添加了一个通用GPIO驱动程序，以及一个用户空间库`libgpiod`，通过在通用`ioctl`
    API之上添加一个便利层来简化对连接到GPIO的设备的访问。此接口允许嵌入式开发人员在任何基于Linux的平台上管理其设备，而无需编写设备驱动程序。此外，它提供了C++的绑定。
- en: As a result, the `wiringPi` library has been deprecated, despite still being
    widely used because of its easy-to-use interface.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，尽管仍然被广泛使用，但`wiringPi`库已被弃用，因为其易于使用的接口。
- en: In this recipe, we will learn how to use the `libgpiod` C++ bindings. We are
    going to use the same LED blinking example to see the differences and similarities
    in the `wiringPi` and `libgpiod` approaches.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用`libgpiod` C++绑定。我们将使用相同的LED闪烁示例来查看`wiringPi`和`libgpiod`方法的差异和相似之处。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that blinks an LED connected to the Raspberry
    Pi board using a new `libgpiod` API:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，使用新的`libgpiod` API来闪烁连接到树莓派板的LED。
- en: In your `~/test` working directory, create a subdirectory called `gpiod`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`gpiod`的子目录。
- en: Use your favorite text editor to create a `gpiod.cpp` file in the `gpiod` subdirectory.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`gpiod`子目录中创建一个`gpiod.cpp`文件。
- en: 'Put the code for the application into the `rtc.cpp` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的代码放入`rtc.cpp`文件中：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[Raspberry PI documentation](http://wiringpi.com/examples/blink/)中的*WiringPI示例*部分的说明，将LED连接到您的树莓派板。
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry PI documentation *section at [https://www.raspberrypi.org/documentation/remote-access/](https://www.raspberrypi.org/documentation/remote-access/).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个SSH连接到您的树莓派板。请按照[Raspberry PI documentation](https://www.raspberrypi.org/documentation/remote-access/)中的说明进行操作。
- en: Copy the contents of the `gpio` folder to the Raspberry Pi board over SSH.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH将`gpio`文件夹的内容复制到树莓派板上。
- en: 'Install the `libgpiod-dev` package:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`libgpiod-dev`软件包：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Log in to the board over SSH, then build and run the application:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH登录到板上，然后构建和运行应用程序：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Your application should run and you can observe the LED blinking.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应该运行，您可以观察LED闪烁。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our application uses a new, recommended way of accessing GPIO devices in Linux.
    Since it was added only recently, it requires the latest version of the Raspbian
    distributive, `buster`, to be installed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用了Linux中访问GPIO设备的新的推荐方式。由于它是最近才添加的，因此需要安装最新版本的Raspbian发行版`buster`。
- en: The `gpiod` library itself provides high-level wrappers to communicate with
    GPIO kernel modules using the `ioctl` API. This interface is designed for C languages
    and on top of it, there is an additional layer for C++ bindings. This layer lives
    in the `libgpiocxx` library, which is part of the `libgpiod2` package along with
    the `libgpiod` library for C.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiod`库本身提供了用于使用`ioctl` API与GPIO内核模块通信的高级包装。该接口设计用于C语言，其上还有一个用于C++绑定的附加层。这一层位于`libgpiocxx`库中，它是`libgpiod2`软件包的一部分，与C的`libgpiod`库一起提供。'
- en: The library uses exceptions to report errors, so the code is simple and not
    cluttered with checks of return codes. Also, we do not need to bother with releasing
    the capture's resources; it is done automatically via C++ RAII mechanisms.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该库使用异常来报告错误，因此代码简单且不会被返回代码检查所淹没。此外，我们不需要担心释放捕获的资源；它会通过C++ RAII机制自动完成。
- en: 'When the application starts, it creates an instance of the class chip, which
    works as an entry point for GPIO communication. Its constructor accepts the name
    of the device to work with:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动时，它创建了一个chip类的实例，该类作为GPIO通信的入口点。它的构造函数接受要使用的设备的名称：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we create an instance of the line, which represents a particular GPIO
    pin:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个line的实例，它代表一个特定的GPIO引脚：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that unlike the `wiringPi` implementation, we pass a `17` pin number because
    `libgpiod` uses native Broadcom SOC Channel (**BCM**) pin numbering:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`wiringPi`实现不同，我们传递了`17`引脚号，因为`libgpiod`使用本机Broadcom SOC通道（**BCM**）引脚编号：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the line instance is created, we need to configure the desired access
    mode. We construct an instance of the `line_request` structure, passing the name
    of a consumer (`"test"`) and a constant indicating that the pin is configured
    for output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建line实例后，我们需要配置所需的访问模式。我们构造一个`line_request`结构的实例，传递一个消费者的名称（`"test"`）和一个指示引脚配置为输出的常量：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that, we can change the pin state using the `set_value` method. As in
    the `wiringPi` example, we set the pin to `1` or `HIGH` for `500ms`, then back
    to `0` or `LOW` for another `500ms` in a loop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`set_value`方法更改引脚状态。与`wiringPi`示例一样，我们将引脚设置为`1`或`HIGH`，持续`500ms`，然后再设置为`0`或`LOW`，再持续`500ms`，循环进行：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output of this program is identical to the output of the program from the *Controlling
    devices connected via GPIO* recipe. The code may look more complex, but the new
    API is more generic and can work on any Linux board, not just Raspberry Pi.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出与*通过GPIO连接的设备进行控制*配方的输出相同。代码可能看起来更复杂，但新的API更通用，可以在任何Linux板上工作，而不仅仅是树莓派。
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: More information about `libgpiod` and the GPIO interface, in general, can be
    found at [https://github.com/brgl/libgpiod](https://github.com/brgl/libgpiod).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`libgpiod`和GPIO接口的更多信息，可以在[https://github.com/brgl/libgpiod](https://github.com/brgl/libgpiod)找到。
- en: Controlling I2C peripheral devices
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制I2C外设设备
- en: Connecting devices over GPIO has one downside. A processor has a limited and
    relatively small number of pins available for GPIO. When you need to work with
    numerous devices or devices that provide complex functionality, you can run out
    of pins easily.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GPIO连接设备有一个缺点。处理器可用于GPIO的引脚数量有限且相对较小。当您需要处理大量设备或提供复杂功能的设备时，很容易用完引脚。
- en: A solution is using one of the standard serial buses to connect peripheral devices.
    One of them is **Inter-Integrated Circuit** (**I2C**). This is widely used to
    connect various low-speed devices because of its simplicity and because a device
    can be connected with only two wires on the host controller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用标准串行总线之一连接外围设备。其中之一是**Inter-Integrated Circuit**（**I2C**）。由于其简单性和设备可以仅用两根导线连接到主控制器，因此这被广泛用于连接各种低速设备。
- en: The bus is well supported both on hardware and software levels. By using I2C
    peripherals, developers can control them from user-space applications without
    writing complex device drivers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 总线在硬件和软件层面都得到了很好的支持。通过使用I2C外设，开发人员可以在用户空间应用程序中控制它们，而无需编写复杂的设备驱动程序。
- en: In this recipe, we will learn how to work with an I2C device on a Raspberry
    Pi board. We will use a popular and inexpensive LCD display. It has 16 pins, which
    makes it difficult to connect to the Raspberry board directly. However, with an
    I2C backpack, it only needs four wires to connect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何在树莓派板上使用I2C设备。我们将使用一款流行且便宜的LCD显示器。它有16个引脚，这使得它直接连接到树莓派板变得困难。然而，通过I2C背包，它只需要四根线来连接。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We will create an application that displays text on a 1602 LCD display attached
    to our Raspberry Pi board:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，该应用程序在连接到我们的树莓派板的1602 LCD显示器上显示文本：
- en: In your `~/test` working directory, create a subdirectory called `i2c`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`~/test`工作目录中，创建一个名为`i2c`的子目录。
- en: Use your favorite text editor to create an `i2c.cpp` file in the `i2c` subdirectory.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器在`i2c`子目录中创建一个`i2c.cpp`文件。
- en: 'Put the following `include` directives and constants'' definitions into the `i2c.cpp` file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`include`指令和常量定义放入`i2c.cpp`文件中：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we define a new class, `Lcd`, which encapsulates the display control logic.
    We start with the data fields and the `public` methods:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个新的类`Lcd`，它封装了显示控制逻辑。我们从数据字段和`public`方法开始：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'They are followed by the `private` methods. Low-level helper methods go first:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`private`方法。低级辅助方法首先出现：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the helper functions are defined, we add higher-level methods:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦辅助函数被定义，我们添加更高级的方法：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `main` function that uses the `Lcd` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加使用`Lcd`类的`main`函数：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Connect the pins on the `i2c` backpack of your 1602LCD display to the pins
    on your Raspberry Pi board according to this table:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这个表格，将你的1602LCD显示器的`i2c`背包上的引脚连接到树莓派板上的引脚：
- en: '| **Raspberry Pi pin name** | **Physical pin number** | **1602 I2C pin** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派引脚名称** | **物理引脚号** | **1602 I2C引脚** |'
- en: '| GND  | 6 | GND |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| GND | 6 | GND |'
- en: '| +5v | 2 | VSS |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| +5v | 2 | VSS |'
- en: '| SDA.1 | 3 | SDA |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| SDA.1 | 3 | SDA |'
- en: '| SCL.1 | 5 | SCL |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| SCL.1 | 5 | SCL |'
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry PI documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立SSH连接到你的树莓派板。按照[Raspberry PI documentation](https://www.raspberrypi.org/documentation/remote-access/ssh/)部分的说明进行操作。
- en: 'Log in to the Raspberry board and run the `raspi-config` tool to enable `i2c`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到树莓派板并运行`raspi-config`工具以启用`i2c`：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the menu, select Interfacing Options | I2C | Yes.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中，选择Interfacing Options | I2C | Yes。
- en: Reboot the board to activate the new settings.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动板以激活新设置。
- en: Copy the contents of the `i2c` folder to the Raspberry Pi board over SSH.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH将`i2c`文件夹的内容复制到树莓派板上。
- en: 'Log in to the board over SSH, then build and run the application:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH登录到板上，然后构建和运行应用程序：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Your application should run and you can observe the LED blinking.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该运行，你可以观察到LED在闪烁。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, our peripheral device—an LCD screen—is connected to the board
    over the I2C bus. It is a form of a serial interface, so the connection only requires
    four physical wires. An LCD screen, however, can do much more than a simple LED.
    This means that the communication protocol used to control it is also more complex.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们的外围设备——LCD屏幕——通过I2C总线连接到板上。这是一种串行接口，所以连接只需要四根物理线。然而，LCD屏幕可以做的远不止简单的LED。这意味着用于控制它的通信协议也更复杂。
- en: We will use only a fraction of the functionality provided by the 1602 LCD screen.
    The communication logic is loosely based on the `LiquidCrystal_I2C` library for
    Arduino, adapted for Raspberry Pi.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用1602 LCD屏幕提供的功能的一小部分。通信逻辑松散地基于Arduino的`LiquidCrystal_I2C`库，适用于树莓派。
- en: 'We define an `Lcd` class that hides all the complexities of I2C communication
    and the specifics of the 1602 control protocol in its private methods. Besides
    a constructor and a destructor, it exposes only two public methods: `Clear` and
    `Display`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`Lcd`类，它隐藏了I2C通信的所有复杂性和1602控制协议的私有方法。除了构造函数和析构函数之外，它只公开了两个公共方法：`Clear`和`Display`。
- en: 'In Linux, we communicate to I2C devices via device files. To start working
    with a device, we need to open a device file corresponding to an I2C controller
    using the regular open call:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，我们通过设备文件与I2C设备通信。要开始使用设备，我们需要使用常规的打开调用打开与I2C控制器对应的设备文件：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There may be multiple devices attached to the same bus. We need to select the
    device we what to communicate to. We do this with an `ioctl` call:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有多个设备连接到同一总线。我们需要选择要通信的设备。我们使用`ioctl`调用来实现这一点：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: At this point, the I2C communication is configured and we can issue I2C commands
    by writing data to the open file descriptor. The commands, however, are specific
    for each peripheral device. So, after generic I2C initialization, we need to proceed
    with the LCD initialization.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，I2C通信已配置，我们可以通过向打开的文件描述符写入数据来发出I2C命令。然而，这些命令对于每个外围设备都是特定的。因此，在通用I2C初始化之后，我们需要继续进行LCD初始化。
- en: We put all the LCD-specific initialization into the `Init` private function. It
    configures the operation modes, the number of rows, and the size of the displayed
    characters. To do this, we define the helper methods, data types, and constants.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有LCD特定的初始化放入`Init`私有函数中。它配置操作模式、行数和显示字符的大小。为此，我们定义了辅助方法、数据类型和常量。
- en: 'The basic helper function is `SendToI2C`. It is a simple method that writes
    a byte of data into the file descriptor configured for I2C communication and throws
    an exception in the case of an error:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的辅助函数是`SendToI2C`。它是一个简单的方法，将数据字节写入配置为I2C通信的文件描述符，并在出现错误时抛出异常。
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On top of `SendToI2C`, we define another helper method, `SendToLcd`. It sends
    a sequence of bytes to I2C, forming a command that the LCD controller can interpret.
    This involves setting different flags and taking care of delays required between
    chunks of data:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SendToI2C`之外，我们还定义了另一个辅助方法`SendToLcd`。它向I2C发送一系列字节，形成LCD控制器可以解释的命令。这涉及设置不同的标志并处理数据块之间需要的延迟：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The LCD is working in 4-bit mode, which means that each byte sent to the display
    requires two commands. We define the `Write` method to do it for us:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: LCD以4位模式工作，这意味着发送到显示器的每个字节都需要两个命令。我们定义`Write`方法来为我们执行这些操作：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we define all possible commands supported by the device and put them
    into the `Function` enum class. A `Call` helper function can be used to invoke
    the functions in a type-safe way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义设备支持的所有可能命令，并将它们放入`Function`枚举类中。`Call`辅助函数可以用于以类型安全的方式调用函数：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we use these helper functions to define public methods to clear the
    screen and display a string.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用这些辅助函数来定义清除屏幕和显示字符串的公共方法。
- en: Since all the complexity of the communication protocol is encapsulated in the
    `Lcd` class, our `main` function is relatively simple.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通信协议的所有复杂性都封装在`Lcd`类中，我们的`main`函数相对简单。
- en: 'It creates an instance of the class, passing in a device filename and a device
    address that we are going to use. By default, a 1620 LCD with an I2C backpack
    has a `0x27` address:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个类的实例，传入我们将要使用的设备文件名和设备地址。默认情况下，带有I2C背包的1620 LCD的地址是`0x27`：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The constructor of the `Lcd` class performs all initialization and as soon
    as the instance is created, we can invoke the `Display` function. Instead of hardcoding
    the string to display, we use data passed by a user through the command-line parameters.
    The first parameter is displayed in the first row. If the second parameter is
    provided, it is also displayed in the second row of the display:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lcd`类的构造函数执行所有初始化，一旦实例被创建，我们就可以调用`Display`函数。我们不是硬编码要显示的字符串，而是使用用户通过命令行参数传递的数据。第一个参数显示在第一行。如果提供了第二个参数，它也会显示在显示器的第二行：'
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Our program is ready and we can copy it over to the Raspberry Pi board and build
    it there. But before running it, we need to wire the display to the board and
    enable I2C support.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序已经准备好了，我们可以将其复制到树莓派板上并在那里构建。但在运行之前，我们需要将显示器连接到板上并启用I2C支持。
- en: 'We use the `raspi-config` tool to enable I2C. We need to do it only once, but
    a reboot is required unless I2C has not been previously enabled:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`raspi-config`工具来启用I2C。我们只需要做一次，但除非之前未启用I2C，否则需要重新启动：
- en: '![](img/6ea36835-ced3-40ef-a8c8-70b0c08c2f71.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ea36835-ced3-40ef-a8c8-70b0c08c2f71.png)'
- en: 'Finally, we can run our application. It will display the following output on
    the LCD display:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行我们的应用程序。它将在LCD显示器上显示以下输出：
- en: '![](img/91251e94-ad99-47c6-b5c3-e5866ca97b1e.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91251e94-ad99-47c6-b5c3-e5866ca97b1e.jpg)'
- en: Now, we know how to control devices connected via an I2C bus from Linux user-space
    programs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何从Linux用户空间程序控制通过I2C总线连接的设备。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: More information about working with I2C devices can be found at the *Interfacing
    with I2C devices *page, available at [https://elinux.org/Interfacing_with_I2C_Devices](https://elinux.org/Interfacing_with_I2C_Devices.).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用I2C设备的更多信息，请访问[https://elinux.org/Interfacing_with_I2C_Devices](https://elinux.org/Interfacing_with_I2C_Devices.)上的*与I2C设备接口*页面。
