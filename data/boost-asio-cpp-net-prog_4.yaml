- en: Chapter 4. Getting Started with Boost.Asio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 使用Boost.Asio入门
- en: We already know about the Boost C++ library in general. Now it is time to find
    out more about Boost.Asio, the library that we use to develop network applications.
    Boost.Asio is a collection of libraries that are used to process data asynchronously
    because Asio itself stands for **Asynchronous I/O** (**input and output**). Asynchronous
    means that a particular task in a program will operate without blocking other
    tasks and Boost.Asio will notify the program when it has finished carrying out
    that task. In other words, the task is executed concurrently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对Boost C++库有了一般了解。现在是时候更多地了解Boost.Asio了，这是我们用来开发网络应用程序的库。Boost.Asio是一组库，用于异步处理数据，因为Asio本身代表**异步I/O**（**输入和输出**）。异步意味着程序中的特定任务将在不阻塞其他任务的情况下运行，并且Boost.Asio将在完成该任务时通知程序。换句话说，任务是同时执行的。
- en: 'In this chapter, we are going to discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Distinguishing between concurrent and nonconcurrent programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分并发和非并发编程
- en: Understanding the I/O service, the brain and the heart of Boost.Asio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解I/O服务，Boost.Asio的大脑和心脏
- en: Binding a function dynamically to a function pointer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数动态绑定到函数指针
- en: Synchronizing access to any global data or shared data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问任何全局数据或共享数据
- en: Getting closer to the Boost.Asio library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近Boost.Asio库
- en: Imagine we are developing an audio downloader application and we want the user
    to be able to navigate to all the menus in the application, even when the downloading
    process is in progress. If we do not use asynchronous programming, the application
    will be blocked by the downloading process and the user will have to wait until
    the downloading of the file is complete. But thanks to asynchronous programming,
    the user does not need to wait until the download process is complete to continue
    using the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个音频下载应用程序，并且希望用户能够在下载过程中导航到应用程序的所有菜单。如果我们不使用异步编程，应用程序将被下载过程阻塞，用户必须等到文件下载完成才能继续使用。但由于异步编程，用户不需要等到下载过程完成才能继续使用应用程序。
- en: In other words, a synchronous process is like queuing in a theater ticketing
    line. We will be served only if we reach the ticket counter and before that, we
    have to wait for all the processes of the previous costumers who are in front
    of us in the line to be completed. In contrast, we can imagine that the asynchronous
    process is like dinning in a restaurant where the waiter does not have to wait
    for the order of a customer to be prepared by the cook. Instead of blocking the
    time and waiting for the cook, the waiter can go and take orders from other customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，同步过程就像在剧院售票处排队。只有当我们到达售票处之后，我们才会被服务，而在此之前，我们必须等待前面排队的其他顾客的所有流程完成。相比之下，我们可以想象异步过程就像在餐厅用餐，其中服务员不必等待顾客的订单被厨师准备。服务员可以在不阻塞时间并等待厨师的情况下去接受其他顾客的订单。
- en: The `Boost` libraries also have the `Boost.Thread` library that is used to execute
    tasks concurrently, but the `Boost.Thread` library is used to access internal
    resources, such as the CPU core resource, while the `Boost.Asio` library is used
    to access external resources, such as network connections, because the data is
    sent and received by a network card.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost`库还有`Boost.Thread`库，用于同时执行任务，但`Boost.Thread`库用于访问内部资源，如CPU核心资源，而`Boost.Asio`库用于访问外部资源，如网络连接，因为数据是通过网络卡发送和接收的。'
- en: 'Let''s distinguish between concurrent and nonconcurrent programming. Take a
    look at the following code for this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们区分并发和非并发编程。看一下以下代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is a nonconcurrent program. Save the code as `nonconcurrent.cpp`
    and then compile it using the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个非并发程序。将代码保存为`nonconcurrent.cpp`，然后使用以下命令进行编译：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running `nonconcurrent.cpp`, an output like this will be displayed in
    front of you:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`nonconcurrent.cpp`后，将显示如下输出：
- en: '![Getting closer to the Boost.Asio library](img/00021.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![接近Boost.Asio库](img/00021.jpeg)'
- en: 'We want to run two functions: `Print1()` and `Print2()`. In nonconcurrent programming,
    the application runs the `Print1()` function first and afterwards, completes all
    the instructions in the function. The program continues to invoke the `Print2()`
    function until the instruction is run completely.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要运行两个函数：`Print1()`和`Print2()`。在非并发编程中，应用程序首先运行`Print1()`函数，然后完成函数中的所有指令。程序继续调用`Print2()`函数，直到指令完全运行。
- en: 'Now, let''s compare nonconcurrent programming with concurrent programming.
    For this, take a look at the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将非并发编程与并发编程进行比较。为此，请看以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the preceding code as `concurrent.cpp` and compile it using the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码保存为`concurrent.cpp`，并使用以下命令进行编译：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the program to get the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序以获得以下输出：
- en: '![Getting closer to the Boost.Asio library](img/00022.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![接近Boost.Asio库](img/00022.jpeg)'
- en: We can see from the preceding output that the `Print1()` and `Print2()` functions
    are run concurrently. The `Print2()` function does not need to wait for the `Print1()`
    function to finish executing all the instructions that are to be invoked. This
    is why we call this concurrent programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上面的输出中看到，`Print1()`和`Print2()`函数是同时运行的。`Print2()`函数不需要等待`Print1()`函数执行完所有要调用的指令。这就是为什么我们称之为并发编程。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not forget to copy the associated dynamic library file if you include a library
    in your code. For instance, if you include `boost_system-mgw49-mt-1_58` using
    the `–l` option, you have to copy the `libboost_system-mgw49-mt-1_58.dll` file
    and paste it into the same directory as the output-executable file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码中包含库，请不要忘记复制相关的动态库文件。例如，如果使用`-l`选项包含`boost_system-mgw49-mt-1_58`，则必须复制`libboost_system-mgw49-mt-1_58.dll`文件并将其粘贴到与输出可执行文件相同的目录中。
- en: Examining the I/O service in the Boost.Asio library
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Boost.Asio库中的I/O服务
- en: The core object of the `Boost::Asio` namespace is `io_service`. The **I/O service**
    is a channel that is used to access operating system resources and establish communication
    between our program and the operating system that performs I/O requests. There
    is also an **I/O object** that has the role of submitting I/O requests. For instance,
    the `tcp::socket` object will provide a socket programming request from our program
    to the operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost::Asio`命名空间的核心对象是`io_service`。**I/O service**是一个通道，用于访问操作系统资源，并在我们的程序和执行I/O请求的操作系统之间建立通信。还有一个**I/O对象**，其作用是提交I/O请求。例如，`tcp::socket`对象将从我们的程序向操作系统提供套接字编程请求。'
- en: Using and blocking the run() function
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用和阻塞run()函数
- en: One of the most frequently used functions in the I/O service object is the `run()`
    function. It is used to run the `io_service` object's event processing loop. It
    will block the next statement program until all the work in the `io_service` object
    is completed and there are no more handlers to be dispatched. If we stop the `io_service`
    object, it will no longer block the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在I/O服务对象中最常用的函数之一是`run()`函数。它用于运行`io_service`对象的事件处理循环。它将阻塞程序的下一个语句，直到`io_service`对象中的所有工作都完成，并且没有更多的处理程序需要分派。如果我们停止`io_service`对象，它将不再阻塞程序。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In programming, `event` is an action or occurrence detected by a program, which
    will be handled by the program using the `event handler` object. The `io_service`
    object has one or more instances where events are handled, which is `event processing
    loop`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，`event`是程序检测到的一个动作或事件，将由程序使用`event handler`对象处理。`io_service`对象有一个或多个实例，用于处理事件的`event
    processing loop`。
- en: 'Now, let''s take a look at the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码片段：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We save the preceding code as `unblocked.cpp` and then run the following command
    to compile it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将上述代码保存为`unblocked.cpp`，然后运行以下命令进行编译：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the program, the following output gets displayed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，将显示以下输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, why do we still obtain the line of text in the console even though
    previously we knew that the `run()` function blocks the next function after it
    is invoked? This is because we have not given any work to the `io_service` object.
    Since there is no work for `io_service` to do, the `io_service` object should
    not block the program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么即使我们之前知道`run()`函数在被调用后会阻塞下一个函数，我们仍然在控制台中获取到文本行呢？这是因为我们没有给`io_service`对象任何工作。由于`io_service`没有工作要做，`io_service`对象不应该阻塞程序。
- en: 'Now, let''s give the `io_service` object some work to do. The program for this
    will look like as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给`io_service`对象一些工作要做。这个程序将如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Give the preceding code the name `blocked.cpp` and then compile it by typing
    the following command in our console window:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 给上述代码命名为`blocked.cpp`，然后在控制台窗口中输入以下命令进行编译：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run the program by typing `blocked` in our console, we will not see the
    line of text anymore since we have added the following code line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在控制台中输入`blocked`来运行程序，由于我们添加了以下代码行，我们将不再看到文本行：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `work` class is responsible for telling the `io_service` object when the
    work starts and when it has finished. It will make sure that the `run()` function
    in the `io_service` object will not exit during the time the work is underway.
    Also, it will make sure that the `run()` function does exit when there is no unfinished
    work remaining. In our preceding code, the `work` class informs the `io_service`
    object that it has work to do, but we do not define what the work is. Therefore,
    the program will be blocked infinitely and it will not show the output. The reason
    it has been blocked is because the `run()` function is invoked even though we
    can still terminate the program by pressing *Ctrl* + *C*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`work`类负责告诉`io_service`对象工作何时开始和何时结束。它将确保`io_service`对象中的`run()`函数在工作进行时不会退出。此外，它还将确保`run()`函数在没有未完成的工作时退出。在我们的上述代码中，`work`类通知`io_service`对象它有工作要做，但我们没有定义工作是什么。因此，程序将被无限阻塞，不会显示输出。它被阻塞的原因是因为即使我们仍然可以通过按*Ctrl*
    + *C*来终止程序，`run()`函数仍然被调用。'
- en: Using the non-blocking poll() function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非阻塞的poll()函数
- en: Now, we will leave the `run()` function for a while and try to use the `poll()`
    function. The `poll()` function is used to run ready handlers until there are
    no more ready handlers remaining or until the `io_service` object has been stopped.
    However, in contrast with the `run()` function, the `poll()` function will not
    block the program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将暂时离开`run()`函数，尝试使用`poll()`函数。`poll()`函数用于运行就绪处理程序，直到没有更多的就绪处理程序，或者直到`io_service`对象已停止。然而，与`run()`函数相反，`poll()`函数不会阻塞程序。
- en: 'Let''s type the following code that uses the `poll()` function and save it
    as `poll.cpp`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入以下使用`poll()`函数的代码，并将其保存为`poll.cpp`：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, compile `poll.cpp` by using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令编译`poll.cpp`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because there is no work that the `io_service` object has to do, the program
    should display the five lines of text as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`io_service`对象没有工作要做，所以程序应该显示以下五行文本：
- en: '![Using the non-blocking poll() function](img/00023.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用非阻塞的poll()函数](img/00023.jpeg)'
- en: 'However, what if we give work to the `io_service` object when we use the `poll()`
    function? To find out the answer, let''s type the following code and save it as
    `pollwork.cpp`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在使用`poll()`函数时给`io_service`对象分配工作会怎样呢？为了找出答案，让我们输入以下代码并将其保存为`pollwork.cpp`：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To compile `pollwork.cpp`, use the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译`pollwork.cpp`，使用以下命令：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The difference between the `poll.cpp` file and the `pollwork.cpp` file is only
    the following line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll.cpp`文件和`pollwork.cpp`文件之间的区别只有以下一行：'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, if we run `pollwork.exe`, we will obtain the same output as that of
    `poll.exe`. This is because, as we know from before, the `poll()` function will
    not block the program while there is more work to do. It will execute the current
    work and then return the value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行`pollwork.exe`，我们将获得与`poll.exe`相同的输出。这是因为，正如我们之前所知道的，`poll()`函数在有更多工作要做时不会阻塞程序。它将执行当前工作，然后返回值。
- en: Removing the work object
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除work对象
- en: We can also unblock the program by removing the `work` object from the `io_service`
    object, but we have to use a pointer to the `work` object in order to remove the
    `work` object itself. We are going to use the `shared_ptr` pointer, a smart pointer
    provided by the `Boost` libraries.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过从`io_service`对象中移除`work`对象来解除程序的阻塞，但是我们必须使用指向`work`对象的指针来移除`work`对象本身。我们将使用`Boost`库提供的智能指针`shared_ptr`指针。
- en: 'Let''s use the modified code of `blocked.cpp`. The code for this will be as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用修改后的`blocked.cpp`代码。代码如下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the preceding code as `removework.cpp` and compile it using the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码保存为`removework.cpp`，并使用以下命令进行编译：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run `removework.cpp`, compared to `blocked.cpp`, which will block the
    program infinitely, the following line of text will be displayed to us:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`removework.cpp`时，与`blocked.cpp`相比，它将无限期地阻塞程序，将显示以下文本：
- en: '![Removing the work object](img/00024.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![移除work对象](img/00024.jpeg)'
- en: Now, let's dissect the code. As we can see in the preceding code, we used the
    `shared_ptr` pointer to instantiate the `work` object. With this smart pointer
    provided by Boost, we no longer need to manually delete memory allocation in order
    to store the pointer since it guarantees that the object pointed to will be deleted
    when the last pointer is destroyed or reset. Do not forget to include `shared_ptr.hpp`
    inside the `boost` directory as the `shared_ptr` pointer is defined in the header
    file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解析代码。如前所述，我们在上面的代码中使用了`shared_ptr`指针来实例化`work`对象。有了Boost提供的这个智能指针，我们不再需要手动删除内存分配以存储指针，因为它保证了指向的对象在最后一个指针被销毁或重置时将被删除。不要忘记在`boost`目录中包含`shared_ptr.hpp`，因为`shared_ptr`指针是在头文件中定义的。
- en: We also add the `reset()` function to reset the `io_service` object when it
    prepares for a subsequent `run()` function invocation. The `reset()` function
    has to be invoked before any invocation of the `run()` or `poll()` functions.
    It will also tell the `shared_ptr` pointer to automatically destroy the pointer
    we created. More information about the `share_ptr` pointer can be found at [www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm](http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`reset()`函数来重置`io_service`对象，以便准备进行后续的`run()`函数调用。在任何`run()`或`poll()`函数调用之前必须调用`reset()`函数。它还会告诉`shared_ptr`指针自动销毁我们创建的指针。有关`shared_ptr`指针的更多信息，请访问[www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm](http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm)。
- en: The preceding program explains that we have successfully removed the `work`
    object from the `io_service` object. We can use this functionality if we intend
    to finish all the pending work even though it hasn't actually been finished yet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序解释了我们已成功从`io_service`对象中移除了`work`对象。即使尚未完成所有挂起的工作，我们也可以使用这个功能。
- en: Dealing with many threads
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个线程
- en: 'We have only dealt with one thread for one `io_service` object so far. If we
    want to deal with more threads in a single `io_service` object, the following
    code will explain how to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了一个`io_service`对象的一个线程。如果我们想在单个`io_service`对象中处理更多的线程，以下代码将解释如何做到这一点：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Give the preceding code the name `mutithreads.cpp` and then compile it using
    the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 给上述代码命名为`mutithreads.cpp`，然后使用以下命令进行编译：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We include the `thread.hpp` header file so that we can use the `thread` object
    defined inside the header file. The thread itself is a piece sequence of instructions
    that can be run independently, so we can run multiple threads at once.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`thread.hpp`头文件，以便我们可以使用头文件中定义的`thread`对象。线程本身是一系列可以独立运行的指令，因此我们可以同时运行多个线程。
- en: 'Now, run `mutithreads.exe` in our console. I obtained the following output
    by running it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的控制台中运行`mutithreads.exe`。我通过运行它获得了以下输出：
- en: '![Dealing with many threads](img/00025.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![处理多个线程](img/00025.jpeg)'
- en: 'You might obtain a different output because all the threads that are set up
    as a pool of threads are equivalent to each other. The `io_service` object may
    choose any one of them randomly and invoke its handler, so we cannot guarantee
    whether or not the `io_service` object will choose a thread sequentially:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会得到不同的输出，因为作为线程池设置的所有线程彼此等效。`io_service`对象可能会随机选择其中任何一个并调用其处理程序，因此我们无法保证`io_service`对象是否会按顺序选择线程：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the preceding code snippet, we can create five threads to display lines
    of text as you can see in the previous screenshot. The five lines of text will
    be enough for this example to view the order of nonconcurrent flow:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的代码片段，我们可以创建五个线程来显示文本行，就像在之前的屏幕截图中所看到的那样。这五行文本足以用于此示例以查看非并发流的顺序：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In every thread that is created, the program will invoke the `run()` function
    to run the work of the `io_service` object. Calling the `run()` function once
    is insufficient because all nonworkers will be invoked after the `run()` object
    finishes all its work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的每个线程中，程序将调用`run()`函数来运行`io_service`对象的工作。只调用一次`run()`函数是不够的，因为所有非工作线程将在`run()`对象完成所有工作后被调用。
- en: 'After creating five threads, the program runs the work of the `io_service`
    object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了五个线程后，程序运行了`io_service`对象的工作：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After all the work is run, the program waits for you to press the *Enter* key
    from the keyboard using the preceding code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有工作运行之后，程序会等待您使用上面的代码片段从键盘上按*Enter*键。
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So after we press the *Enter* key, the program will finish its remaining code
    and we will obtain the rest of the output as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们按下*Enter*键后，程序将完成其余的代码，我们将得到以下其余的输出：
- en: '![Dealing with many threads](img/00026.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![处理多线程](img/00026.jpeg)'
- en: Understanding the Boost.Bind library
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Boost.Bind库
- en: We have been able to use the `io_service` object and initialize the `work` object.
    What we should know after this is how to give some work to the `io_service` object.
    But before we progress to giving work to the `io_service` service, we need to
    understand the `boost::bind` library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够使用`io_service`对象并初始化`work`对象。在继续向`io_service`服务提供工作之前，我们需要了解`boost::bind`库。
- en: The `Boost.Bind` library is used to ease the invocation of a function pointer.
    It converts the syntax from something that is abstruse and confusing to something
    that is easy to understand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Bind`库用于简化函数指针的调用。它将语法从晦涩和令人困惑的东西转换为易于理解的东西。'
- en: Wrapping a function invocation
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装函数调用
- en: 'Let''s look at the following code in order to understand how to wrap a function
    invocation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码，以了解如何包装函数调用：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save the preceding code as `uncalledbind.cpp` and then compile it using the
    following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码保存为`uncalledbind.cpp`，然后使用以下命令进行编译：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will not get any line of text as output since we just created a function
    invocation but haven''t actually called it. We have to add it to the `()` operator
    to call the function as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会得到任何文本行作为输出，因为我们只是创建了一个函数调用，但实际上并没有调用它。我们必须将其添加到`()`运算符中来调用函数，如下所示：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Name the preceding code `calledbind.cpp` and run the following command to compile
    it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码命名为`calledbind.cpp`并运行以下命令进行编译：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will get the line of text as the output if we run the program, and
    of course, we will see the `bind()` function as an output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行程序，现在将会得到一行文本作为输出，当然，我们将看到`bind()`函数作为输出：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following command to compile the preceding `argumentbind.cpp` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以编译上述`argumentbind.cpp`文件：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We successfully call the function with the argument using `boost::bind` because
    of which we obtain the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地使用`boost::bind`调用了带有参数的函数，因此我们得到了以下输出：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You need to remember that if the function has more than one argument, we have
    to match the function signature exactly. The following code will explain this
    in more detail:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，如果函数有多个参数，我们必须完全匹配函数签名。以下代码将更详细地解释这一点：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compile the `signaturebind.cpp` code by using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译`signaturebind.cpp`代码：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The signature of an identity function are `std::string`, `int`, and `float`.
    So, we have to fill the `bind` parameter with `std::string`, `int`, and `float`,
    respectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 身份函数的签名是`std::string`、`int`和`float`。因此，我们必须分别用`std::string`、`int`和`float`填充`bind`参数。
- en: 'Because we have matched the function signature exactly, we will obtain an output
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们完全匹配了函数签名，我们将得到以下输出：
- en: '![Wrapping a function invocation](img/00027.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![包装函数调用](img/00027.jpeg)'
- en: 'We have already been able to call the `global()` function in `boost::bind`.
    Now, let''s continue to call the function inside a class in `boost::bind`. The
    code for this looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够在`boost::bind`中调用`global()`函数。现在，让我们继续在`boost::bind`中调用类中的函数。这方面的代码如下所示：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Compile the preceding `classbind.cpp` code by using following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译上述`classbind.cpp`代码：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output for this will be exactly the same as the `signaturebind.cpp` code
    since the content of the function is exactly the same as well:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与`signaturebind.cpp`代码的输出完全相同，因为函数的内容也完全相同：
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Working with the Boost.Bind library
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Bind库
- en: So far, we have been able to use `boost::bind` for the global and class functions.
    However, when we use the `io_service` object with `boost::bind`, we will get a
    **non-copyable** error because the `io_service` object cannot be copied.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够使用`boost::bind`来调用全局和类函数。然而，当我们使用`io_service`对象与`boost::bind`时，我们会得到一个**不可复制**的错误，因为`io_service`对象无法被复制。
- en: 'Now, let''s take a look at `multithreads.cpp` again. We will modify the code
    to explain the use of `boost::bind` for the `io_service` object and we will still
    need the help of the `shared_ptr` pointer. Let''s take a look at the following
    code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看一下`multithreads.cpp`。我们将修改代码以解释`boost::bind`用于`io_service`对象，并且我们仍然需要`shared_ptr`指针的帮助。让我们看一下以下代码片段：
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We name the preceding code `ioservicebind.cpp` and compile it using the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将上述代码命名为`ioservicebind.cpp`并使用以下命令进行编译：
- en: '[PRE43]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we run `ioservicebind.exe`, we obtain the same output as `multithreads.exe`,
    but of course, the program will randomize the order of all threads:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`ioservicebind.exe`时，我们会得到与`multithreads.exe`相同的输出，但当然，程序会随机排列所有线程的顺序：
- en: '[PRE44]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We instantiate the `io_service` object in the `shared_ptr` pointer to make
    it **copyable** so that we can bind it to the worker `thread()` function that
    we use as a thread handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`shared_ptr`指针中实例化`io_service`对象，以使其**可复制**，以便我们可以将其绑定到作为线程处理程序使用的`worker
    thread()`函数：
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we look at the `create_thread()` function, we see the different arguments
    that it gets in the `ioservicebind.cpp` and `multithreads.cpp` files. We can pass
    a pointer to the `void()` function that takes no arguments as the argument to
    the `create_thread()` function, as we can see in the `multithreads.cpp` file.
    We can also pass a binding function as an argument to the `create_thread()` function,
    as we can see in the `ioservicebind.cpp` file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`create_thread()`函数，在`ioservicebind.cpp`和`multithreads.cpp`文件中看到它得到的不同参数。我们可以将指向不带参数的`void()`函数的指针作为`create_thread()`函数的参数传递，就像我们在`multithreads.cpp`文件中看到的那样。我们还可以将绑定函数作为`create_thread()`函数的参数传递，就像我们在`ioservicebind.cpp`文件中看到的那样。
- en: Synchronizing data access with the Boost.Mutex library
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Mutex库同步数据访问
- en: Have you ever got the following output when you ran the `multithreads.exe` or
    `ioservicebind.exe` executable files?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`multithreads.exe`或`ioservicebind.exe`可执行文件时，您是否曾经得到以下输出？
- en: '![Synchronizing data access with the Boost.Mutex library](img/00028.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用Boost.Mutex库同步数据访问](img/00028.jpeg)'
- en: 'We can see in the preceding screenshot that there is a formatting issue here.
    Because the `std::cout` object is a global object, writing to it from different
    threads at once can cause output formatting issues. To solve this issue, we can
    use a `mutex` object that can be found in the `boost::mutex` object provided by
    the `thread` library. Mutex is used to synchronize access to any global data or
    shared data. To understand more about Mutex, take a look at the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上面的截图中看到这里存在格式问题。因为`std::cout`对象是一个全局对象，同时从不同的线程写入它可能会导致输出格式问题。为了解决这个问题，我们可以使用`mutex`对象，它可以在`thread`库提供的`boost::mutex`对象中找到。Mutex用于同步对任何全局数据或共享数据的访问。要了解更多关于Mutex的信息，请看以下代码：
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Save the preceding code as `mutexbind.cpp` and then compile it using the following
    command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码保存为`mutexbind.cpp`，然后使用以下命令编译它：
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, run the `mutexbind.cpp` file and we will not face the formatting issue
    anymore:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`mutexbind.cpp`文件，我们将不再面临格式问题：
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We instantiate the new `mutex` object, `global_stream_lock`. With this object,
    we can call the `lock()` and `unlock()` functions. The `lock()` function will
    block other threads that access the same function to wait for the current thread
    to be finished. The other threads can access the same function if only the current
    thread has called the `unlock()` function. One thing to remember is that we should
    not call the `lock()` function recursively because if the `lock()` function is
    not unlocked by the `unlock()` function, then thread deadlock will occur and it
    will freeze the application. So, we have to be careful when using the `lock()`
    and `unlock()` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化了新的`mutex`对象`global_stream_lock`。有了这个对象，我们可以调用`lock()`和`unlock()`函数。`lock()`函数将阻塞其他访问相同函数的线程，等待当前线程完成。只有当前线程调用了`unlock()`函数，其他线程才能访问相同的函数。需要记住的一件事是，我们不应该递归调用`lock()`函数，因为如果`lock()`函数没有被`unlock()`函数解锁，那么线程死锁将发生，并且会冻结应用程序。因此，在使用`lock()`和`unlock()`函数时，我们必须小心。
- en: Giving some work to the I/O service
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给I/O服务一些工作
- en: 'Now, it is time for us to give some work to the `io_service` object. Knowing
    more about `boost::bind` and `boost::mutex` will help us to give the `io_service`
    object work to do. There are two member functions in the `io_service` object:
    the `post()` and `dispatch()` functions, which we will frequently use to do this.
    The `post()` function is used to request the `io_service` object to run the `io_service`
    object''s work after we queue up all the work, so it does not allow us to run
    the work immediately. While the `dispatch()` function is also used to make a request
    to the `io_service` object to run the `io_service` object''s work, but it will
    execute the work right away without queuing it up.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给`io_service`对象一些工作了。了解更多关于`boost::bind`和`boost::mutex`将帮助我们给`io_service`对象一些工作。`io_service`对象中有两个成员函数：`post()`和`dispatch()`函数，我们经常会使用它们来做这件事。`post()`函数用于请求`io_service`对象在我们排队所有工作后运行`io_service`对象的工作，因此不允许我们立即运行工作。而`dispatch()`函数也用于请求`io_service`对象运行`io_service`对象的工作，但它会立即执行工作而不是排队。
- en: Using the post() function
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用post()函数
- en: 'Let''s examine the `post()` function by creating the following code. We will
    use the `mutexbind.cpp` file as our base code, since we will just modify the source
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建以下代码来检查`post()`函数。我们将使用`mutexbind.cpp`文件作为我们的基础代码，因为我们只会修改源代码：
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Name the preceding code as `post.cpp` and compile it using the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码命名为`post.cpp`，并使用以下命令编译它：
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before we run the program, let''s examine the code to understand its behavior:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，让我们检查代码以了解其行为：
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We add the `fac()` function to calculate the *n* factorial recursively. There
    is a time delay to slow down the process in order to see the work of our worker
    threads:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`fac()`函数来递归计算*n*的阶乘。为了看到我们的工作线程的工作，有一个时间延迟来减慢进程：
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `main` block, we post three function objects on the `io_service` object,
    using the `post()` function. We do this just after we initialize the five worker
    threads. However, because we call the `run()` function of the `io_service` object
    inside each thread, the work of the `io_service` object will run. This means that
    the `post()` function will do its job.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`块中，我们使用`post()`函数在`io_service`对象上发布了三个函数对象。我们在初始化五个工作线程后立即这样做。然而，因为我们在每个线程内调用了`io_service`对象的`run()`函数，所以`io_service`对象的工作将运行。这意味着`post()`函数将起作用。
- en: 'Now, let''s run `post.cpp` and take a look at what has happened here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`post.cpp`并看看这里发生了什么：
- en: '![Using the post() function](img/00029.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用post()函数](img/00029.jpeg)'
- en: As we can see in the output of the preceding screenshot, the program runs the
    thread from the pool of threads, and after it finishes one thread, it calls the
    `post()` function from the `io_service` object until all three `post()` functions
    and all five threads have been called. Then, it calculates the factorial for each
    three *n* number. After it gets the `worker.reset()` function, it is notified
    that the work has been finished, and then it joins all the threads via the `threads.join_all()`
    function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图输出中所看到的，程序从线程池中运行线程，并在完成一个线程后，调用`io_service`对象的`post()`函数，直到所有三个`post()`函数和所有五个线程都被调用。然后，它计算每个三个*n*数字的阶乘。在得到`worker.reset()`函数后，它被通知工作已经完成，然后通过`threads.join_all()`函数加入所有线程。
- en: Using the dispatch() function
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`dispatch()`函数
- en: 'Now, let''s examine the `dispatch()` function to give the `io_service` function
    some work. We will still use the `mutexbind.cpp` file as our base code and we
    will modify it a little so that it becomes like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查`dispatch()`函数，给`io_service`函数一些工作。我们仍然会使用`mutexbind.cpp`文件作为我们的基础代码，并稍微修改它，使其变成这样：
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Give the preceding code the name `dispatch.cpp` and compile it using the following
    command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给上述代码命名为`dispatch.cpp`，并使用以下命令进行编译：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s run the program to get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序以获得以下输出：
- en: '![Using the dispatch() function](img/00030.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用dispatch()函数](img/00030.jpeg)'
- en: 'Different than the `post.cpp` file, in the `dispatch.cpp` file, we just create
    one worker thread. Also, we add two functions, `dispatch(),` and `post()` to understand
    the difference between both functions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与`post.cpp`文件不同，在`dispatch.cpp`文件中，我们只创建一个工作线程。此外，我们添加了两个函数`dispatch()`和`post()`来理解两个函数之间的区别：
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are two functions that we can use to get the `io_service` object working
    for us: the `run()` and `poll()` member functions. The `run()` function blocks
    the program because it has to wait for the work that we assign to it, while the
    `poll()` function does not block the program. When we need to give some work to
    the `io_service` object, we simply use the `poll()` or `run()` functions, depending
    on what we need, and then we call the `post()`or `dispatch()` functions as needed.
    The `post()` function is used to command the `io_service` object in order to run
    the given handler, but without permitting the handler is called by the `io_service`
    object from inside this function. While the `dispatch()` function is used to call
    the handler in the thread in which the `run()`or `poll()` functions are currently
    being invoked. The fundamental difference between the `dispatch()` and the `post()`
    functions is that the `dispatch()` function completes the work right away whenever
    it can, while the `post()` function always queues the work.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数可以让我们使用`io_service`对象工作：`run()`和`poll()`成员函数。`run()`函数会阻塞程序，因为它必须等待我们分配给它的工作，而`poll()`函数不会阻塞程序。当我们需要给`io_service`对象一些工作时，我们只需使用`poll()`或`run()`函数，取决于我们的需求，然后根据需要调用`post()`或`dispatch()`函数。`post()`函数用于命令`io_service`对象运行给定的处理程序，但不允许处理程序在此函数内部被`io_service`对象调用。而`dispatch()`函数用于在调用`run()`或`poll()`函数的线程中调用处理程序。`dispatch()`和`post()`函数之间的根本区别在于，`dispatch()`函数会立即完成工作，而`post()`函数总是将工作排队。
- en: We found out about the `io_service` object, how to run it, and how to give it
    some work. Now, let's move to the next chapter to find out more about the `Boost.Asio`
    library, and we will be one step closer to creating our network programming.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了`io_service`对象，如何运行它，以及如何给它一些工作。现在，让我们转到下一章，了解更多关于`Boost.Asio`库的内容，我们将离创建网络编程更近一步。
