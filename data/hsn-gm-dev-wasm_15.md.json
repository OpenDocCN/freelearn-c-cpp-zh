["```cpp\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL_opengl.h>\n#include <GLES2/gl2.h>\n#include <stdlib.h>\n#include <emscripten.h>\n```", "```cpp\n#define CANVAS_WIDTH 800\n#define CANVAS_HEIGHT 600\n#define FLOAT32_BYTE_SIZE 4\n#define STRIDE FLOAT32_BYTE_SIZE*4\n```", "```cpp\nconst GLchar* vertex_shader_code[] = {\n    \"precision mediump float; \\n\"\n    \"attribute vec4 a_position; \\n\"\n    \"attribute vec2 a_texcoord; \\n\"\n\n    \"uniform vec4 u_translate; \\n\"\n\n    \"varying vec2 v_texcoord; \\n\"\n\n    \"void main() { \\n\"\n        \"gl_Position = u_translate + a_position; \\n\"\n        \"v_texcoord = a_texcoord; \\n\"\n    \"} \\n\"\n};\n```", "```cpp\nconst GLchar* fragment_shader_code[] = {\n    \"precision mediump float; \\n\"\n    \"varying vec2 v_texcoord; \\n\"\n\n    \"uniform sampler2D u_texture; \\n\"\n\n    \"void main() { \\n\"\n        \"gl_FragColor = texture2D(u_texture, v_texcoord); \\n\"\n    \"} \\n\"\n };\n```", "```cpp\nGLuint program = 0;\nGLuint texture;\n\nGLint a_texcoord_location = -1;\nGLint a_position_location = -1;\n\nGLint u_texture_location = -1;\nGLint u_translate_location = -1;\n\nGLuint vertex_texture_buffer;\n```", "```cpp\nfloat vertex_texture_data[] = {\n    // x,   y,        u,   v\n    0.167,  0.213,    1.0, 1.0,\n   -0.167,  0.213,    0.0, 1.0,\n    0.167, -0.213,    1.0, 0.0,\n   -0.167, -0.213,    0.0, 0.0,\n   -0.167,  0.213,    0.0, 1.0,\n    0.167, -0.213,    1.0, 0.0\n};\n```", "```cpp\nSDL_Window *window;\nSDL_Renderer *renderer;\nSDL_Texture* sprite_texture;\nSDL_Surface* sprite_surface;\n```", "```cpp\nint sprite_width;\nint sprite_height;\n```", "```cpp\nfloat ship_x = 0.0;\nfloat ship_y = 0.0;\n```", "```cpp\nvoid game_loop();\n```", "```cpp\nint main() {\n SDL_Init( SDL_INIT_VIDEO );\n SDL_CreateWindowAndRenderer( CANVAS_WIDTH, CANVAS_HEIGHT, 0, &window, &renderer );\n    SDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\n    SDL_RenderClear( renderer );\n    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource( vertex_shader,1,vertex_shader_code,0);\n    glCompileShader(vertex_shader);\n    GLint compile_success = 0;\n    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &compile_success);\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile vertex shader\\n\");\n        glDeleteShader(vertex_shader);\n        return 0;\n    }\n    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource( fragment_shader,1,fragment_shader_code,0);\n    glCompileShader(fragment_shader);\n    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS,&compile_success);\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile fragment shader\\n\");\n        glDeleteShader(fragment_shader);\n        return 0;\n    }\n    program = glCreateProgram();\n    glAttachShader( program,vertex_shader);\n    glAttachShader( program,fragment_shader);\n    glLinkProgram(program);\n    GLint link_success = 0;\n    glGetProgramiv(program, GL_LINK_STATUS, &link_success);\n    if (link_success == GL_FALSE)\n    {\n        printf(\"failed to link program\\n\");\n        glDeleteProgram(program);\n        return 0;\n    }\n    glUseProgram(program);\n    u_texture_location = glGetUniformLocation(program, \"u_texture\");\n    u_translate_location = glGetUniformLocation(program,\"u_translate\");\n    a_position_location = glGetAttribLocation(program, \"a_position\");\n    a_texcoord_location = glGetAttribLocation(program, \"a_texcoord\");\n    glGenBuffers(1, &vertex_texture_buffer);\n    glBindBuffer( GL_ARRAY_BUFFER, vertex_texture_buffer );\n    glBufferData(GL_ARRAY_BUFFER, \n    sizeof(vertex_texture_data),vertex_texture_data, GL_STATIC_DRAW);\n    sprite_surface = IMG_Load( \"/sprites/spaceship.png\" );\n    if( !sprite_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n    sprite_texture = SDL_CreateTextureFromSurface( renderer, \n    sprite_surface );\n    if( !sprite_texture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n    SDL_QueryTexture( sprite_texture,NULL, NULL,&sprite_width, &sprite_height );\n    glTexImage2D( GL_TEXTURE_2D,0,GL_RGBA,sprite_width,sprite_height,\n                  0,GL_RGBA,GL_UNSIGNED_BYTE,sprite_surface );\n    SDL_FreeSurface( sprite_surface );\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_BLEND);\n    glEnableVertexAttribArray(a_position_location);\n    glEnableVertexAttribArray(a_texcoord_location);\n    glVertexAttribPointer(a_position_location,2,GL_FLOAT,GL_FALSE,4 * \n    sizeof(float),(void*)0 );\n    glVertexAttribPointer(a_texcoord_location,2,GL_FLOAT,GL_FALSE,\n                          4 * sizeof(float),(void*)(2 * sizeof(float)));\n    emscripten_set_main_loop(game_loop, 0, 0);\n}\n```", "```cpp\nSDL_Init( SDL_INIT_VIDEO );\nSDL_CreateWindowAndRenderer( CANVAS_WIDTH, CANVAS_HEIGHT, 0, &window, &renderer );\nSDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\nSDL_RenderClear( renderer );\n```", "```cpp\nGLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);\nglShaderSource( vertex_shader,\n                1,\n                vertex_shader_code,\n                0);\n\nglCompileShader(vertex_shader);\n\nGLint compile_success = 0;1\nglGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &compile_success);\nif(compile_success == GL_FALSE)\n{\n    printf(\"failed to compile vertex shader\\n\");\n    glDeleteShader(vertex_shader);\n    return 0;\n}\n```", "```cpp\nGLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);\nglShaderSource( fragment_shader,\n                1,\n                fragment_shader_code,\n                0);\n\nglCompileShader(fragment_shader);\nglGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &compile_success);\n\nif(compile_success == GL_FALSE)\n{\n    printf(\"failed to compile fragment shader\\n\");\n    glDeleteShader(fragment_shader);\n    return 0;\n}\n```", "```cpp\nprogram = glCreateProgram();\nglAttachShader( program,\n                vertex_shader);\n\nglAttachShader( program,\n                fragment_shader);\n\nglLinkProgram(program);\n\nGLint link_success = 0;\n\nglGetProgramiv(program, GL_LINK_STATUS, &link_success);\n\nif (link_success == GL_FALSE)\n{\n    printf(\"failed to link program\\n\");\n    glDeleteProgram(program);\n    return 0;\n}\nglUseProgram(program);\n```", "```cpp\nu_texture_location = glGetUniformLocation(program, \"u_texture\");\nu_translate_location = glGetUniformLocation(program, \"u_translate\");\n\na_position_location = glGetAttribLocation(program, \"a_position\");\na_texcoord_location = glGetAttribLocation(program, \"a_texcoord\");\n```", "```cpp\nglGenBuffers(1, &vertex_texture_buffer);\nglBindBuffer( GL_ARRAY_BUFFER, vertex_texture_buffer );\n```", "```cpp\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertex_texture_data),\n                vertex_texture_data, GL_STATIC_DRAW);\n```", "```cpp\nsprite_surface = IMG_Load( \"/sprites/spaceship.png\" );\n\nif( !sprite_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nsprite_texture = SDL_CreateTextureFromSurface( renderer, sprite_surface );\n\nif( !sprite_texture ) {\n    printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nSDL_QueryTexture( sprite_texture,\n                    NULL, NULL,\n                    &sprite_width, &sprite_height );\n\nglTexImage2D( GL_TEXTURE_2D,\n                0,\n                GL_RGBA,\n                sprite_width,\n                sprite_height,\n                0,\n                GL_RGBA,\n                GL_UNSIGNED_BYTE,\n                sprite_surface );\n\nSDL_FreeSurface( sprite_surface );\n```", "```cpp\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\nglEnable(GL_BLEND);\n```", "```cpp\nglEnableVertexAttribArray(a_position_location);\nglEnableVertexAttribArray(a_texcoord_location);\n\nglVertexAttribPointer(\n        a_position_location,     // set up the a_position attribute\n        2,                       // how many attributes in the position\n        GL_FLOAT,                // data type of float\n        GL_FALSE,                // the data is not normalized\n        4 * sizeof(float),       // stride (how many array items until \n                                 //the next position)\n        (void*)0                 // starting point for attribute\n);\n\nglVertexAttribPointer(\n        a_texcoord_location,         // set up the a_texcoord attribute\n        2,                           // how many attributes in the \n                                     //texture coordinates\n        GL_FLOAT,                    // data type of float\n        GL_FALSE,                    // the data is not normalized\n        4 * sizeof(float),           // stride (how many array items \n                                     //until the next position)\n        (void*)(2 * sizeof(float))   // starting point for attribute\n);\n```", "```cpp\nemscripten_set_main_loop(game_loop, 0, 0);\n```", "```cpp\nvoid game_loop() {\n    glClearColor( 0, 0, 0, 1 );\n    glClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );\n\n    ship_x += 0.002;\n    ship_y += 0.001;\n\n    if( ship_x >= 1.16 ) {\n        ship_x = -1.16;\n    }\n\n    if( ship_y >= 1.21 ) {\n        ship_y = -1.21;\n    }\n\n    glUniform4f(u_translate_location,\n                ship_x, ship_y, 0, 0 );\n\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n}\n```", "```cpp\nglClearColor( 0, 0, 0, 1 );\nglClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );\n```", "```cpp\nship_x += 0.002;\nship_y += 0.001;\n\nif( ship_x >= 1.16 ) {\n    ship_x = -1.16;\n}\n\nif( ship_y >= 1.21 ) {\n    ship_y = -1.21;\n}\n\nglUniform4f(u_translate_location,\n            ship_x, ship_y, 0, 0 );\n```", "```cpp\nglDrawArrays(GL_TRIANGLES, 0, 6);\n```", "```cpp\nemcc webgl-redux.c -o redux.html --preload-file sprites -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"]\n```", "```cpp\n#define TWOPI 6.2831853 // 2\u03c0\n```", "```cpp\nconst GLchar* fragment_shader_code[] = {\n    \"precision mediump float; \\n\"\n    \"varying vec2 v_texcoord; \\n\"\n\n    \"uniform float u_time; \\n\"\n    \"uniform sampler2D u_texture; \\n\"\n    \"uniform sampler2D u_glow; \\n\"\n\n    \"void main() { \\n\"\n        \"float cycle = (sin(u_time) + 1.0) / 2.0; \\n\"\n        \"vec4 tex = texture2D(u_texture, v_texcoord); \\n\"\n        \"vec4 glow = texture2D(u_glow, v_texcoord); \\n\"\n        \"glow.rgb *= glow.aaa; \\n\"\n        \"glow *= cycle; \\n\"\n        \"gl_FragColor = tex + glow; \\n\"\n    \"} \\n\"\n};\n```", "```cpp\nGLuint program = 0;\nGLuint texture;\nGLuint glow_tex;\n\nGLint a_texcoord_location = -1;\nGLint a_position_location = -1;\nGLint u_texture_location = -1;\nGLint u_glow_location = -1;\nGLint u_time_location = -1;\n\nGLint u_translate_location = -1;\nGLuint vertex_texture_buffer;\n```", "```cpp\nfloat time_cycle = 0;\nfloat delta_time = 0.0;\nint diff_time = 0;\n\nUint32 last_time;\nUint32 last_frame_time;\nUint32 current_time;\n```", "```cpp\nSDL_Surface* glow_surface;\n```", "```cpp\nint main() {\n    last_frame_time = last_time = SDL_GetTicks();\n\n    SDL_Init( SDL_INIT_VIDEO );\n\n    SDL_CreateWindowAndRenderer( CANVAS_WIDTH, CANVAS_HEIGHT, 0, \n    &window, &renderer );\n\n    SDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\n    SDL_RenderClear( renderer );\n\n    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);\n\n    glShaderSource( vertex_shader,\n                    1,\n                    vertex_shader_code,\n                    0);\n\n    glCompileShader(vertex_shader);\n\n    GLint compile_success = 0;\n    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &compile_success);\n\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile vertex shader\\n\");\n        glDeleteShader(vertex_shader);\n        return 0;\n    }\n\n    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);\n\n    glShaderSource( fragment_shader,\n                    1,\n                    fragment_shader_code,\n                    0);\n\n    glCompileShader(fragment_shader);\n    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, \n    &compile_success);\n\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile fragment shader\\n\");\n        glDeleteShader(fragment_shader);\n        return 0;\n    }\n\n    program = glCreateProgram();\n    glAttachShader( program,\n                    vertex_shader);\n\n    glAttachShader( program,\n                    fragment_shader);\n\n    glLinkProgram(program);\n\n    GLint link_success = 0;\n\n    glGetProgramiv(program, GL_LINK_STATUS, &link_success);\n\n    if (link_success == GL_FALSE)\n    {\n        printf(\"failed to link program\\n\");\n        glDeleteProgram(program);\n        return 0;\n    }\n\n    glUseProgram(program);\n\n    u_glow_location = glGetUniformLocation(program, \"u_glow\");\n    u_time_location = glGetUniformLocation(program, \"u_time\");\n\n    u_texture_location = glGetUniformLocation(program, \"u_texture\");\n    u_translate_location = glGetUniformLocation(program, \n    \"u_translate\");\n\n    a_position_location = glGetAttribLocation(program, \"a_position\");\n    a_texcoord_location = glGetAttribLocation(program, \"a_texcoord\");\n\n    glGenBuffers(1, &vertex_texture_buffer);\n\nglBindBuffer( GL_ARRAY_BUFFER, vertex_texture_buffer );\n glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_texture_data),\n vertex_texture_data, GL_STATIC_DRAW);\n\nsprite_surface = IMG_Load( \"/sprites/spaceship.png\" );\n\n    if( !sprite_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n\n    sprite_texture = SDL_CreateTextureFromSurface( renderer, \n    sprite_surface );\n\n    if( !sprite_texture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n\n    SDL_QueryTexture( sprite_texture,\n                        NULL, NULL,\n                        &sprite_width, &sprite_height );\n\n    glTexImage2D( GL_TEXTURE_2D,\n                    0,\n                    GL_RGBA,\n                    sprite_width,\n                    sprite_height,\n                    0,\n                    GL_RGBA,\n                    GL_UNSIGNED_BYTE,\n                    sprite_surface );\n\n    SDL_FreeSurface( sprite_surface );\n\n    glGenTextures( 1,\n                    &glow_tex);\n\n    glActiveTexture(GL_TEXTURE1);\n    glEnable(GL_TEXTURE_2D);\n    glBindTexture(GL_TEXTURE_2D, glow_tex);\n\n    glow_surface = IMG_Load( \"/sprites/glow.png\" );\n\n    if( !glow_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n\n    glTexImage2D( GL_TEXTURE_2D,\n                    0,\n                    GL_RGBA,\n                    sprite_width,\n                    sprite_height,\n                    0,\n                    GL_RGBA,\n                    GL_UNSIGNED_BYTE,\n                    glow_surface );\n\n    glGenerateMipmap(GL_TEXTURE_2D);\n\n    SDL_FreeSurface( glow_surface );\n\n    glUniform1i(u_texture_location, 0);\n    glUniform1i(u_glow_location, 1);\n\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_BLEND);\n\n    glEnableVertexAttribArray(a_position_location);\n    glEnableVertexAttribArray(a_texcoord_location);\n\n    glVertexAttribPointer(\n        a_position_location,     // set up the a_position attribute\n        2,                       // how many attributes in the position\n        GL_FLOAT,                // data type of float\n        GL_FALSE,                // the data is not normalized\n        4 * sizeof(float),       // stride (how many array items until \n                                 //the next position)\n        (void*)0                 // starting point for attribute\n    );\n\n    glVertexAttribPointer(\n        a_texcoord_location,       // set up the a_texcoord attribute\n        2,                         // how many attributes in the \n                                   //texture coordinates\n        GL_FLOAT,                  // data type of float\n        GL_FALSE,                  // the data is not normalized\n        4 * sizeof(float),         // stride (how many array items \n                                   //until the next position)\n        (void*)(2 * sizeof(float)) // starting point for attribute\n    );\n\n    emscripten_set_main_loop(game_loop, 0, 0);\n}\n```", "```cpp\nlast_frame_time = last_time = SDL_GetTicks();\n```", "```cpp\nu_glow_location = glGetUniformLocation(program, \"u_glow\");\nu_time_location = glGetUniformLocation(program, \"u_time\");\n```", "```cpp\nglGenTextures( 1,\n                &glow_tex);\n\nglActiveTexture(GL_TEXTURE1);\nglEnable(GL_TEXTURE_2D);\nglBindTexture(GL_TEXTURE_2D, glow_tex);\n\nglow_surface = IMG_Load( \"/sprites/glow.png\" );\n\nif( !glow_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nglTexImage2D( GL_TEXTURE_2D,\n                0,\n                GL_RGBA,\n                sprite_width,\n                sprite_height,\n                0,\n                GL_RGBA,\n                GL_UNSIGNED_BYTE,\n                glow_surface );\n\nSDL_FreeSurface( glow_surface );\n\nglGenerateMipmap(GL_TEXTURE_2D);\n\nglUniform1i(u_texture_location, 0);\nglUniform1i(u_glow_location, 1);\n```", "```cpp\ncurrent_time = SDL_GetTicks();\n\ndiff_time = current_time - last_time;\n\ndelta_time = diff_time / 1000.0;\nlast_time = current_time;\n\ntime_cycle += delta_time * 4;\n\nif( time_cycle >= TWOPI ) {\n    time_cycle -= TWOPI;\n}\n\nglUniform1f( u_time_location, time_cycle );\n```", "```cpp\ntime_cycle += delta_time * 4;\n```", "```cpp\nif( time_cycle >= TWOPI ) {\n    time_cycle -= TWOPI;\n}\n```", "```cpp\nglUniform1f( u_time_location, time_cycle );\n```", "```cpp\nemcc glow.c -o glow.html --preload-file sprites -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"]\n```", "```cpp\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL_opengl.h>\n\n#include <GLES3/gl3.h>\n#include <stdlib.h>\n#include <emscripten.h>\n\n#define CANVAS_WIDTH 800\n#define CANVAS_HEIGHT 600\n#define FLOAT32_BYTE_SIZE 4\n#define STRIDE FLOAT32_BYTE_SIZE*4\n```", "```cpp\nconst GLchar* vertex_shader_code[] = {\n    \"precision mediump float; \\n\"\n    \"attribute vec4 a_position; \\n\"\n    \"attribute vec2 a_texcoord; \\n\"\n    \"varying vec2 v_texcoord; \\n\"\n\n    \"void main() { \\n\"\n        \"gl_Position = a_position; \\n\"\n        \"v_texcoord = a_texcoord; \\n\"\n    \"} \\n\"\n};\n```", "```cpp\nconst GLchar* fragment_shader_code[] = {\n    \"precision mediump float; \\n\"\n\n    \"varying vec2 v_texcoord; \\n\"\n\n    \"uniform sampler2D u_texture; \\n\"\n    \"uniform sampler2D u_normal; \\n\"\n    \"uniform vec3 u_light_pos; \\n\"\n\n    \"const float ambient = 0.6; \\n\"\n    \"const float specular = 32.0; \\n\"\n    \"const vec3 view_pos = vec3(400, 300,-100); \\n\"\n    \"const vec4 light_color = vec4( 0.6, 0.6, 0.6, 0.0); \\n\"\n\n    \"void main() { \\n\"\n        \"vec4 tex = texture2D(u_texture, v_texcoord); \\n\"\n\n        \"vec4 ambient_frag = tex * ambient; \\n\"\n        \"ambient_frag.rgb *= light_color.rgb; \\n\"\n\n        \"vec3 norm = vec3(texture2D(u_normal, v_texcoord)); \\n\"\n        \"norm.xyz *= 2.0; \\n\"\n        \"norm.xyz -= 1.0; \\n\"\n\n        \"vec3 light_dir = normalize(gl_FragCoord.xyz - u_light_pos); \\n\"\n\n        \"vec3 view_dir = normalize(view_pos - gl_FragCoord.xyz); \\n\"\n        \"vec3 reflect_dir = reflect(light_dir, norm); \\n\"\n\n        \"float reflect_dot = max( dot(view_dir, reflect_dir), 0.0 ); \\n\"\n        \"float spec = pow(reflect_dot, specular); \\n\"\n        \"vec4 specular_frag = spec * light_color; \\n\"\n\n        \"float diffuse = max(dot(norm, light_dir), 0.0); \\n\"\n        \"vec4 diffuse_frag = vec4( diffuse*light_color.r, \n         diffuse*light_color.g, \"\n                                    \"diffuse*light_color.b,  0.0);    \\n\"\n        \"gl_FragColor = ambient_frag + diffuse_frag + specular_frag; \\n\"\n    \"} \\n\"\n};\n```", "```cpp\n\"uniform sampler2D u_texture; \\n\"\n\"uniform sampler2D u_normal; \\n\"\n```", "```cpp\n\"uniform vec3 u_light_pos; \\n\"\n```", "```cpp\n\"const float ambient = 0.6; \\n\"\n\"const float specular = 0.8; \\n\"\n\"const vec3 view_pos = vec3(400, 300,-100); \\n\"\n\"const vec4 light_color = vec4( 0.6, 0.6, 0.6, 0.0); \\n\"\n```", "```cpp\n\"vec4 tex = texture2D(u_texture, v_texcoord); \\n\"\n\"vec4 ambient_frag = tex * ambient; \\n\"\n\n\"ambient_frag.rgb *= light_color.rgb; \\n\"\n```", "```cpp\n\"vec3 norm = vec3(texture2D(u_normal, v_texcoord)); \\n\"\n\"norm.xyz *= 2.0; \\n\"\n\"norm.xyz -= 1.0; \\n\"\n```", "```cpp\n\"vec3 light_dir = normalize(gl_FragCoord.xyz - u_light_pos); \\n\"\n```", "```cpp\n\"vec3 view_dir = normalize(view_pos - gl_FragCoord.xyz); \\n\"\n```", "```cpp\n\"vec3 reflect_dir = reflect(light_dir, norm); \\n\"\n```", "```cpp\n\"float reflect_dot = max( dot(view_dir, reflect_dir), 0.0 ); \\n\"\n\"float spec = pow(reflect_dot, specular); \\n\"\n\"vec4 specular_frag = spec * light_color; \\n\"\n```", "```cpp\n\"float diffuse = max(dot(norm, light_dir), 0.0); \\n\"\n\"vec4 diffuse_frag = vec4(diffuse*light_color.r, diffuse*light_color.g, diffuse*light_color.b, 0.0); \\n\"\n```", "```cpp\n\"gl_FragColor = ambient_frag + diffuse_frag + specular_frag; \\n\"\n```", "```cpp\nGLuint program = 0;\nGLint sdl_program = 0;\nGLuint circle_tex, normal_tex, light_tex;\nGLuint normal_map;\n\nGLint a_texcoord_location = -1;\nGLint a_position_location = -1;\nGLint u_texture_location = -1;\nGLint u_normal_location = -1;\nGLint u_light_pos_location = -1;\n\nGLint u_translate_location = -1;\nGLuint vertex_texture_buffer;\n\nfloat vertex_texture_data[] = {\n    // x,    y,         u,   v\n     0.167,  0.213,     1.0, 1.0,\n    -0.167,  0.213,     0.0, 1.0,\n     0.167, -0.213,     1.0, 0.0,\n    -0.167, -0.213,     0.0, 0.0,\n    -0.167,  0.213,     0.0, 1.0,\n     0.167, -0.213,     1.0, 0.0\n};\n```", "```cpp\nSDL_Window *window;\nSDL_Renderer *renderer;\n\nSDL_Texture* light_texture;\n\nSDL_Surface* surface;\n\nint light_width;\nint light_height;\n\nint light_x = 600;\nint light_y = 200;\nint light_z = -300;\n```", "```cpp\nvoid game_loop();\nvoid input();\nvoid draw_light_icon();\n```", "```cpp\nint main() {\n    SDL_Init( SDL_INIT_VIDEO );\n    SDL_CreateWindowAndRenderer( CANVAS_WIDTH, CANVAS_HEIGHT, 0, \n    &window, &renderer );\n    SDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\n    SDL_RenderClear( renderer );\n\n    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);\n\n    glShaderSource( vertex_shader,\n                    1,\n                    vertex_shader_code,\n                    0);\n\n    glCompileShader(vertex_shader);\n\n    GLint compile_success = 0;\n    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &compile_success);\n\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile vertex shader\\n\");\n        glDeleteShader(vertex_shader);\n        return 0;\n    }\n\n    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);\n\n    glShaderSource( fragment_shader,\n                    1,\n                    fragment_shader_code,\n                    0);\n\n    glCompileShader(fragment_shader);\n    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, \n    &compile_success);\n\n    if(compile_success == GL_FALSE)\n    {\n        printf(\"failed to compile fragment shader\\n\");\n\n        GLint maxLength = 0;\n        glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &maxLength);\n\n        GLchar* errorLog = malloc(maxLength);\n        glGetShaderInfoLog(fragment_shader, maxLength, &maxLength, \n        &errorLog[0]);\n        printf(\"error: %s\\n\", errorLog);\n\n        glDeleteShader(fragment_shader);\n        return 0;\n    }\n\n    program = glCreateProgram();\n    glAttachShader( program,\n                    vertex_shader);\n\n    glAttachShader( program,\n                    fragment_shader);\n\n    glLinkProgram(program);\n\n    GLint link_success = 0;\n\n    glGetProgramiv(program, GL_LINK_STATUS, &link_success);\n\n    if (link_success == GL_FALSE)\n    {\n        printf(\"failed to link program\\n\");\n        glDeleteProgram(program);\n        return 0;\n    }\n\n    glDeleteShader(vertex_shader);\n    glDeleteShader(fragment_shader);\n    glUseProgram(program);\n```", "```cpp\nu_texture_location = glGetUniformLocation(program, \"u_texture\");\nu_normal_location = glGetUniformLocation(program, \"u_normal\");\nu_light_pos_location = glGetUniformLocation(program, \"u_light_pos\");\nu_translate_location = glGetUniformLocation(program, \"u_translate\");\n```", "```cpp\na_position_location = glGetAttribLocation(program, \"a_position\");\na_texcoord_location = glGetAttribLocation(program, \"a_texcoord\");\n```", "```cpp\nglGenBuffers(1, &vertex_texture_buffer);\n\nglBindBuffer( GL_ARRAY_BUFFER, vertex_texture_buffer );\nglBufferData( GL_ARRAY_BUFFER, sizeof(vertex_texture_data),\n              vertex_texture_data, GL_STATIC_DRAW);\n```", "```cpp\nglGenTextures( 1,\n                &circle_tex);\n\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, circle_tex);\n\nsurface = IMG_Load( \"/sprites/circle.png\" );\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nglTexImage2D( GL_TEXTURE_2D,\n                0,\n                GL_RGBA,\n                128, // sprite width\n                128, // sprite height\n                0,\n                GL_RGBA,\n                GL_UNSIGNED_BYTE,\n                surface );\n\nglUniform1i(u_texture_location, 1);\nglGenerateMipmap(GL_TEXTURE_2D);\n\nSDL_FreeSurface( surface );\n\nglGenTextures( 1,\n                &normal_tex);\n\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, normal_tex);\n\nsurface = IMG_Load( \"/sprites/ball-normal.png\" );\n\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nglTexImage2D( GL_TEXTURE_2D,\n                0,\n                GL_RGBA,\n                128, // sprite width\n                128, // sprite height\n                0,\n                GL_RGBA,\n                GL_UNSIGNED_BYTE,\n                surface );\n\nglUniform1i(u_normal_location, 1);\nglGenerateMipmap(GL_TEXTURE_2D);\n\nSDL_FreeSurface( surface );\n\nsurface = IMG_Load( \"/sprites/light.png\" );\n\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nlight_texture = SDL_CreateTextureFromSurface( renderer, surface );\n\nif( !light_texture ) {\n    printf(\"failed to create light texture: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nSDL_QueryTexture( light_texture,\n                    NULL, NULL,\n                    &light_width, &light_height );\n\nSDL_FreeSurface( surface );\n```", "```cpp\nglGenTextures( 1,\n                &circle_tex);\n\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, circle_tex);\n```", "```cpp\nsurface = IMG_Load( \"/sprites/circle.png\" );\n\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n```", "```cpp\nglTexImage2D( GL_TEXTURE_2D,\n                0,\n                GL_RGBA,\n                128, // sprite width\n                128, // sprite height\n                0,\n                GL_RGBA,\n                GL_UNSIGNED_BYTE,\n                surface );\n```", "```cpp\nglUniform1i(u_texture_location, 1);\nglGenerateMipmap(GL_TEXTURE_2D);\n\nSDL_FreeSurface( surface );\n```", "```cpp\nglGenTextures( 1,\n                &normal_tex);\n\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, normal_tex);\nsurface = IMG_Load( \"/sprites/ball-normal.png\" );\n\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nglTexImage2D( GL_TEXTURE_2D,\n    0,\n    GL_RGBA,\n    128, // sprite width\n    128, // sprite height\n    0,\n    GL_RGBA,\n    GL_UNSIGNED_BYTE,\n    surface );\n\nglUniform1i(u_normal_location, 1);\nglGenerateMipmap(GL_TEXTURE_2D);\n\nSDL_FreeSurface( surface );\n```", "```cpp\nsurface = IMG_Load( \"/sprites/light.png\" );\n\nif( !surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nlight_texture = SDL_CreateTextureFromSurface( renderer, surface );\n\nif( !light_texture ) {\n    printf(\"failed to create light texture: %s\\n\", IMG_GetError() );\n    return 0;\n}\n\nSDL_QueryTexture( light_texture,\n                    NULL, NULL,\n                    &light_width, &light_height );\n\nSDL_FreeSurface( surface );\n```", "```cpp\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\nglEnable(GL_BLEND);\n```", "```cpp\nemscripten_set_main_loop(game_loop, 0, 0);\n```", "```cpp\nvoid game_loop() {\n    input();\n\n    glGetIntegerv(GL_CURRENT_PROGRAM,&sdl_program);\n    glUseProgram(program);\n\n    glClearColor( 0, 0, 0, 1 );\n    glClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );\n\n    glBindBuffer(GL_ARRAY_BUFFER, vertex_texture_buffer);\n    glVertexAttribPointer(\n        a_position_location,       // set up the a_position attribute\n        2,                         // how many attributes in the \n                                   //position\n        GL_FLOAT,                  // data type of float\n        GL_FALSE,                  // the data is not normalized\n        4 * sizeof(float),         // stride (how many array items \n                                   //until the next position)\n        (void*)0                   // starting point for attribute\n     );\n\n    glEnableVertexAttribArray(a_texcoord_location);\n    glBindBuffer(GL_ARRAY_BUFFER, vertex_texture_buffer);\n    glVertexAttribPointer(\n        a_texcoord_location,     // set up the a_texcoord attribute\n        2,                       // how many attributes in the texture \n                                 //coordinates\n        GL_FLOAT,                // data type of float\n        GL_FALSE,                // the data is not normalized\n        4 * sizeof(float),       // stride (how many array items until \n                                 //the next position)\n        (void*)(2 * sizeof(float)) // starting point for attribute\n    );\n\n    glUniform3f( u_light_pos_location,\n                (float)(light_x), (float)(600-light_y), (float)(light_z) );\n\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n\n    glUseProgram(sdl_program);\n    draw_light_icon();\n}\n\n```", "```cpp\nglGetIntegerv(GL_CURRENT_PROGRAM,&sdl_program);\nglUseProgram(program);\n```", "```cpp\nglClearColor( 0, 0, 0, 1 );\nglClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );\n```", "```cpp\nglBindBuffer(GL_ARRAY_BUFFER, vertex_texture_buffer);\nglVertexAttribPointer(\n            a_position_location,   // set up the a_position attribute\n            2,                     // how many attributes in the \n                                   //position\n            GL_FLOAT,              // data type of float\n            GL_FALSE,              // the data is not normalized\n            4 * sizeof(float),     // stride (how many array items \n                                   //until the next position)\n            (void*)0               // starting point for attribute\n);\n\nglEnableVertexAttribArray(a_texcoord_location);\nglBindBuffer(GL_ARRAY_BUFFER, vertex_texture_buffer);\nglVertexAttribPointer(\n    a_texcoord_location,          // set up the a_texcoord attribute\n    2,                            // how many attributes in the texture \n                                  //coordinates\n    GL_FLOAT,                     // data type of float\n    GL_FALSE,                     // the data is not normalized\n    4 * sizeof(float),            // stride (how many array items until \n                                  //the next position)\n    (void*)(2 * sizeof(float))    // starting point for attribute\n);\n```", "```cpp\nglDrawArrays(GL_TRIANGLES, 0, 6);\n```", "```cpp\nglUseProgram(sdl_program);\ndraw_light_icon();\n```", "```cpp\nvoid input() {\n    SDL_Event event;\n    static int mouse_down = 0;\n\n    if(SDL_PollEvent( &event ) )\n    {\n        if(event.type == SDL_MOUSEWHEEL )\n        {\n            if( event.wheel.y > 0 ) {\n                light_z+= 100;\n            }\n            else {\n                light_z-=100;\n            }\n\n            if( light_z > 10000 ) {\n                light_z = 10000;\n            }\n            else if( light_z < -10000 ) {\n                light_z = -10000;\n            }\n        }\n        else if(event.type == SDL_MOUSEMOTION )\n        {\n            if( mouse_down == 1 ) {\n                SDL_GetMouseState( &light_x, &light_y );\n            }\n        }\n        else if(event.type == SDL_MOUSEBUTTONDOWN )\n        {\n            if(event.button.button == SDL_BUTTON_LEFT)\n            {\n                SDL_GetMouseState( &light_x, &light_y );\n                mouse_down = 1;\n            }\n        }\n        else if(event.type == SDL_MOUSEBUTTONUP )\n        {\n            if(event.button.button == SDL_BUTTON_LEFT)\n            {\n                mouse_down = 0;\n            }\n        }\n    }\n}\n```", "```cpp\nvoid draw_light_icon() {\n    SDL_Rect dest;\n    dest.x = light_x - light_width / 2 - 32;\n    dest.y = light_y - light_height / 2;\n    dest.w = light_width;\n    dest.h = light_height;\n\n    SDL_RenderCopy( renderer, light_texture, NULL, &dest );\n}\n```", "```cpp\nemcc lighting.c -o lighting.html --preload-file sprites -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"]\n```"]