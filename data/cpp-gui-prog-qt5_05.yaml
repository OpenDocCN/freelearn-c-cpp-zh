- en: Item Views and Dialogs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目视图和对话框
- en: In the previous chapter, we learned how to display data using different types
    of chart. Charts are one of many ways to present information to the users on screen.
    It is very important for your application to present vital information to the
    users so that they know exactly what's happening to the application—whether data
    has been saved successfully, or the application is waiting for the user's input,
    or warning/error messages that the users should be aware of, and so on—it's all
    very important to ensure your application's user-friendliness and usability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用不同类型的图表显示数据。图表是向用户在屏幕上呈现信息的许多方式之一。对于您的应用程序来说，向用户呈现重要信息非常重要，这样他们就可以准确地了解应用程序的情况——无论数据是否已成功保存，或者应用程序正在等待用户的输入，或者用户应该注意的警告/错误消息等等——这些都非常重要，以确保您的应用程序的用户友好性和可用性。
- en: 'In this chapter, we will cover the following topics :'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with item view widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目视图部件
- en: Working with dialog boxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对话框
- en: Working with file selection dialogs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件选择对话框
- en: Image scaling and cropping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像缩放和裁剪
- en: Qt provides us with many types of widget and dialog that we can easily use to
    display important information to the users. Let's check out what these widgets
    are!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了许多类型的部件和对话框，我们可以轻松使用它们来向用户显示重要信息。让我们看看这些部件是什么！
- en: Working with item view widgets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用项目视图部件
- en: Other than displaying data using different types of chart, we can also display
    this data using different types of item view. An item view widget presents data
    by rendering it visually, usually along the vertical axis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用不同类型的图表显示数据外，我们还可以使用不同类型的项目视图来显示这些数据。项目视图部件通过在垂直轴上呈现数据来将数据可视化呈现。
- en: A two-dimensional item view, often known as a **table view**, displays data
    in both vertical and horizontal directions. That allows it to display huge volumes
    of data within a compact space, and enables the users to search for an item very
    quickly and easily.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 二维项目视图，通常称为**表视图**，在垂直和水平方向上显示数据。这使它能够在紧凑的空间内显示大量数据，并使用户能够快速轻松地搜索项目。
- en: 'There are two ways to display data in an item view. The most common method
    is to use the **model-view architecture**, which uses three different components,
    model, view, and delegate, to retrieve data from a data source and display it
    in the item view. These components all make use of the **signal-slot architecture**
    provided by Qt to communicate with each other:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目视图中显示数据有两种方法。最常见的方法是使用**模型-视图架构**，它使用三个不同的组件，模型、视图和委托，从数据源检索数据并在项目视图中显示它。这些组件都利用Qt提供的**信号-槽架构**来相互通信：
- en: Signals from the model inform the view about changes to the data held by the
    data source
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的信号通知视图有关数据源保存的数据的更改
- en: Signals from the view provide information about the user's interaction with
    the items being displayed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图的信号提供有关用户与正在显示的项目的交互的信息
- en: Signals from the delegate are used during editing to tell the model and view
    about the state of the editor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托的信号在编辑期间用于告诉模型和视图有关编辑器状态的信息
- en: The other method is the manual way, in which the programmer must tell Qt which
    data goes into which column and row. This method is much simpler than the model-view,
    but much slower when compared to its performance. However, for small amounts of
    data, the performance issue can be negligible, making this a good approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是手动方式，程序员必须告诉Qt哪些数据放在哪一列和行。与模型-视图相比，这种方法要简单得多，但在性能上要慢得多。然而，对于少量数据，性能问题可以忽略不计，这是一个很好的方法。
- en: 'If you open up Qt Designer, you will see the two different categories for Item
    View Widgets, namely Item Views (Model-Based) and Item Widgets (Item-Based):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开Qt Designer，您将看到两种不同的项目视图部件类别，即项目视图（基于模型）和项目部件（基于项目）：
- en: '![](img/6f63f909-cc29-4299-baf3-b34e7655cf7d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f63f909-cc29-4299-baf3-b34e7655cf7d.png)'
- en: Even though they might look the same, in actual fact the widgets within the
    two categories work very differently. In this chapter, we will learn how to use
    the latter category, as it is more straightforward and easy to understand, and
    able to serve as prerequisite knowledge for the former category.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们看起来可能相同，但实际上这两个类别中的部件工作方式非常不同。在本章中，我们将学习如何使用后一类别，因为它更直观、易于理解，并且可以作为前一类别的先决知识。
- en: 'Under the Item Widgets (Item-Based) category are three different widgets called
    List Widget, Tree Widget, and Table Widget. Each of these item widgets displays
    data in a different way. Pick the one that suits your needs:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目部件（基于项目）类别下有三种不同的部件，称为列表部件、树部件和表部件。每个项目部件以不同的方式显示数据。选择适合您需求的部件：
- en: '![](img/a50b4415-472d-4c74-b1e1-f735f0a5bd21.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a50b4415-472d-4c74-b1e1-f735f0a5bd21.png)'
- en: As you can see from the preceding diagram, the **List Widget** displays its
    items in a one-dimensional list, while the **Table Widget** displays its item
    in a two-dimensional table. Even though the **Tree Widget** works almost similar
    to the **List Widget**, its items are displayed in a hierarchical structure, in
    which each item can have multiple children items under it, recursively. One good
    example of this is the filesystem in our operating system, which displays the
    directory structure using the tree widget.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的图表中所看到的，**列表部件**以一维列表显示其项目，而**表部件**以二维表格显示其项目。尽管**树部件**几乎与**列表部件**类似，但其项目以分层结构显示，其中每个项目下可以递归地有多个子项目。一个很好的例子是我们操作系统中的文件系统，它使用树部件显示目录结构。
- en: To illustrate the differences, let's create a new Qt Widgets application project
    and try it out ourselves.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些区别，让我们创建一个新的Qt Widgets应用程序项目，并自己试一试。
- en: Creating our Qt Widgets application
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Qt Widgets应用程序
- en: 'Once you have created the project, open up `mainwindow.ui` and drag the three
    different item widgets to your main window. After that, select the main window
    and click the Layout Vertically button located at the top:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，打开`mainwindow.ui`并将三种不同的项目小部件拖到主窗口中。之后，选择主窗口并点击位于顶部的垂直布局按钮：
- en: '![](img/e0e15392-5def-4f64-accd-075c8e6d2778.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0e15392-5def-4f64-accd-075c8e6d2778.png)'
- en: 'Then, double-click on the List Widget and a new window will pop out. Here,
    you can add a few dummy items to the List Widget by clicking the + icon, or remove
    them by selecting an item from the list and clicking the - icon. Click the OK
    button to apply the final result to the widget:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，双击列表小部件，将弹出一个新窗口。在这里，您可以通过单击+图标向列表小部件添加一些虚拟项目，或者通过选择列表中的项目并单击-图标来删除它们。单击“确定”按钮将最终结果应用于小部件：
- en: '![](img/4a126e2c-2059-4faf-a325-fafa3b81ce9d.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a126e2c-2059-4faf-a325-fafa3b81ce9d.png)'
- en: 'You can do the same to the Tree Widget. It''s almost the same as the List Widget,
    except that you can add sub-items to an item, recursively. You can also add columns
    to the Tree Widget and name the columns:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对树形小部件执行相同的操作。它几乎与列表小部件相同，只是您可以向项目添加子项目，递归地。您还可以向树形小部件添加列并命名这些列：
- en: '![](img/486ef112-0666-4f94-a753-eac1472c352e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/486ef112-0666-4f94-a753-eac1472c352e.png)'
- en: 'Finally, double-click on the Table Widget to open the Edit Table Widget window.
    Unlike the other two item views, the Table Widget is a two-dimensional item view,
    which means you can add columns and rows to it just like a spreadsheet. Each column
    and row can be labeled with the desired name by setting it in the Columns or Rows
    tab:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，双击表格小部件以打开编辑表格小部件窗口。与其他两个项目视图不同，表格小部件是一个二维项目视图，这意味着您可以像电子表格一样向其添加列和行。可以通过在“列”或“行”选项卡中设置所需的名称来为每列和行加标签：
- en: '![](img/c3e07ba3-fb5c-4017-90db-caf9edae65e1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3e07ba3-fb5c-4017-90db-caf9edae65e1.png)'
- en: It's really easy to understand how a widget works by using the Qt Designer.
    Just drag and drop the widget into the window and play around with its settings,
    then build and run the project to see the result for yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Qt Designer，了解小部件的工作原理非常容易。只需将小部件拖放到窗口中并调整其设置，然后构建并运行项目以查看结果。
- en: 'In this case, we have demonstrated the differences between the three item views
    widgets without writing a single line of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经演示了三种不同的项目视图小部件之间的区别，而不需要编写一行代码：
- en: '![](img/cb94f990-0b6d-435e-8bea-c09205c56bf3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb94f990-0b6d-435e-8bea-c09205c56bf3.png)'
- en: Making our List Widget functional
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的列表小部件功能化
- en: Writing code, however, is still required in order for the widgets to be fully
    functional in your application. Let's learn how to add items to our item view
    widgets using C++ code!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使小部件在应用程序中完全可用，仍然需要编写代码。让我们学习如何使用C++代码向我们的项目视图小部件添加项目！
- en: 'First, open up `mainwindow.cpp` and write the following code to the class constructor,
    right after `ui->setupui(this)`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`mainwindow.cpp`并在`ui->setupui(this)`之后的类构造函数中编写以下代码：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As simple as that, you have successfully added an item to the List Widget!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单，您已成功向列表小部件添加了一个项目！
- en: '![](img/2f54393e-6a48-42c9-90c3-0d36ae463ad2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f54393e-6a48-42c9-90c3-0d36ae463ad2.png)'
- en: 'There is another way to add an item to the List Widget. But before that, we
    must add the following headers to `mainwindow.h`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法可以向列表小部件添加项目。但在此之前，我们必须向`mainwindow.h`添加以下头文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `QDebug` header is for us to print out debug message, and the `QListWidgetItem`
    header is for us to declare List Widget `Item` objects. Next, open up `mainwindow.cpp`
    and add the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDebug`头文件用于打印调试消息，`QListWidgetItem`头文件用于声明列表小部件的项目对象。接下来，打开`mainwindow.cpp`并添加以下代码：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code does the same as the previous one-line code. Except, this
    time, I've added an extra data to the item. The `setData()` function takes in
    two input variables—the first variable is the data-role of item, which indicates
    how it should be treated by Qt. If you put a value that matches the `Qt::ItemDataRole`
    enumerator, the data will affect the display, decoration, tooltip, and so on,
    and that may change its appearance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与前一个一行代码相同。不同的是，这次我向项目添加了额外的数据。`setData()`函数接受两个输入变量——第一个变量是项目的数据角色，指示Qt应如何处理它。如果放入与`Qt::ItemDataRole`枚举器匹配的值，数据将影响显示、装饰、工具提示等，这可能会改变其外观。
- en: 'In my case, I just simply set a number that doesn''t match any of the enumerators
    in `Qt::ItemDataRole` so that I can store it as a hidden data for later use. To
    retrieve the data, you can simply call `data()` and insert the number that matches
    the one you''ve just set:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我只是简单地设置了一个与`Qt::ItemDataRole`中的任何枚举器都不匹配的数字，以便我可以将其存储为以后使用的隐藏数据。要检索数据，您只需调用`data()`并插入与您刚刚设置的数字匹配的数字：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build and run the project; you should be able to see that the new item is now
    being added to the List Widget:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行项目；您应该能够看到新项目现在已添加到列表小部件中：
- en: '![](img/bf13b2e0-4637-4f30-a7c4-2c79b541baad.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf13b2e0-4637-4f30-a7c4-2c79b541baad.png)'
- en: For more information about `Qt::ItemDataRole` enumerators, please check out
    the following link: [http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum](http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Qt::ItemDataRole`枚举器的更多信息，请查看以下链接：[http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum](http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum)
- en: As mentioned earlier, hidden data can be attached to a list item for later use.
    For example, you could use the list widget to display a list of products ready
    to be purchased by the user. Each of these items can be attached with its product
    ID so that when the user selects the item and places it on the cart, your system
    can automatically identify which product has been added to the cart by identifying
    the product ID stored as the data role.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，可以将隐藏数据附加到列表项目以供以后使用。例如，您可以使用列表小部件显示准备由用户购买的产品列表。每个项目都可以附加其产品ID，以便当用户选择该项目并将其放入购物车时，您的系统可以自动识别已添加到购物车的产品ID作为数据角色存储。 '
- en: In the preceding example, I stored custom data, `1000`, in my list item and
    set its data role as `100`, which does not match any of the `Qt::ItemDataRole`
    enumerators. This way, the data won't be shown to the users, and thus it can only
    be retrieved through C++ code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我在我的列表项中存储了自定义数据`1000`，并将其数据角色设置为`100`，这与任何`Qt::ItemDataRole`枚举器都不匹配。这样，数据就不会显示给用户，因此只能通过C++代码检索。
- en: Adding functionality to the Tree Widget
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向树部件添加功能
- en: 'Next, let''s move on to the Tree Widget. It is actually not that different
    from the List Widget. Let''s take a look at the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转到树部件。实际上，它与列表部件并没有太大的不同。让我们看一下以下代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's pretty much the same as the List Widget, except we have to set the column
    ID in the `setText()` function. This is because the Tree Widget is somewhere between
    a List Widget and a Table Widget—it can have more than one column but can't have
    any rows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它与列表部件几乎相同，只是我们必须在`setText()`函数中设置列ID。这是因为树部件介于列表部件和表部件之间——它可以有多个列，但不能有任何行。
- en: 'The most obvious distinction between a Tree Widget and other view widgets is
    that all its items can contain children items, recursively. Let''s look at the
    following code to see how we can add a child item to an existing item in the Tree
    Widget:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 树部件与其他视图部件最明显的区别是，所有的项都可以递归地包含子项。让我们看一下以下代码，看看我们如何向树部件中的现有项添加子项：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s really that simple! The final result looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！最终结果看起来像这样：
- en: '![](img/3580d596-4c97-4c34-9699-f54ddf816393.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3580d596-4c97-4c34-9699-f54ddf816393.png)'
- en: Finally, our Table Widget
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后，我们的表部件
- en: Next, let's do the same for the Table Widget. Technically, the items already
    exist and are reserved in the Table Widget when the columns and rows are being
    created. What we need to do is to create a new item and replace it with the (currently
    empty) item located at a specific column and row, which is why the function name
    is called `setItem()`, instead of `addItem()` used by the List Widget.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对表部件做同样的操作。从技术上讲，当列和行被创建时，表部件中的项已经存在并被保留。我们需要做的是创建一个新项，并用特定列和行的（当前为空的）项替换它，这就是为什么函数名叫做`setItem()`，而不是列表部件使用的`addItem()`。
- en: 'Let''s take a look at the code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see from the code, I have added two sections of data to two different
    locations, which translates into the following result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我在两个不同的位置添加了两个数据部分，这将转化为以下结果：
- en: '![](img/05cecb5e-908c-4668-8afa-dde23dae413d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05cecb5e-908c-4668-8afa-dde23dae413d.png)'
- en: 'That''s it! It''s all that simple and easy to display data using item views
    in Qt. If you are looking for more examples related to item views, please visit
    the following link: [http://doc.qt.io/qt-5/examples-itemviews.html](http://doc.qt.io/qt-5/examples-itemviews.html)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！使用Qt中的项视图来显示数据是如此简单和容易。如果你正在寻找与项视图相关的更多示例，请访问以下链接：[http://doc.qt.io/qt-5/examples-itemviews.html](http://doc.qt.io/qt-5/examples-itemviews.html)
- en: Working with dialog boxes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对话框
- en: One very important aspect of creating a user-friendly application is the ability
    to display vital information regarding the status of the application when a certain
    event (intended or unintended) occurs. To display such information, we need an
    external window that can be dismissed by the user once he/she has acknowledged
    the information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户友好的应用程序的一个非常重要的方面是，在发生某个事件（有意或无意）时，能够显示关于应用程序状态的重要信息。为了显示这样的信息，我们需要一个外部窗口，用户可以在确认信息后将其关闭。
- en: 'Qt comes with this functionality, and it''s all residing in the `QMessageBox`
    class. There are several types of message box you can use in Qt; the most basic
    one uses just a single line of code, like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Qt具有这个功能，它全部驻留在`QMessageBox`类中。在Qt中，你可以使用几种类型的消息框；最基本的一种只需要一行代码，就像这样：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are three parameters you need to provide for this function. The first
    one is the parent of the message box, which we have set as the main window. The
    second parameter is for the window title, and the third parameter is for the message
    we want to deliver to the user. The preceding code will produce the following
    result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，你需要提供三个参数。第一个是消息框的父窗口，我们已经将其设置为主窗口。第二个参数是窗口标题，第三个参数是我们想要传递给用户的消息。上述代码将产生以下结果：
- en: '![](img/2b92e3f2-4363-46db-aa12-afc721e665e8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b92e3f2-4363-46db-aa12-afc721e665e8.png)'
- en: 'The appearance shown here is running on a Windows system. The appearance may
    look different on different operating systems (Linux, macOS, and so forth). As
    you can see, the dialog box even comes with an icon located before the text. There
    are a few types of icon you can use, such as information, warning, and critical.
    The following code shows you the code for calling all the different message boxes
    with icons:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的外观是在Windows系统上运行的。在不同的操作系统（Linux、macOS等）上，外观可能会有所不同。正如你所看到的，对话框甚至带有文本之前的图标。你可以使用几种类型的图标，比如信息、警告和严重。以下代码向你展示了调用带有图标的不同消息框的代码：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code produces the following results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下结果：
- en: '![](img/84024277-2f97-4651-b89e-b3a4e9528f8a.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84024277-2f97-4651-b89e-b3a4e9528f8a.png)'
- en: 'If you don''t need any icons, just call the `QMessageBox::about()` function
    instead. You can also set the buttons you want by picking from a list of standard
    buttons provided by Qt, for example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要任何图标，只需调用`QMessageBox::about()`函数。你还可以通过从Qt提供的标准按钮列表中选择来设置你想要的按钮，例如：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will produce the following result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果：
- en: '![](img/e95537ee-6b14-4da6-9e38-af1eaaf6fda3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e95537ee-6b14-4da6-9e38-af1eaaf6fda3.png)'
- en: 'Since these are the built-in functions provided by Qt to create message boxes
    with ease, it doesn''t give developers the freedom to fully customize a message
    box. However, Qt does allow you to create your message boxes manually using another
    method, which is much more customizable than the built-in method. It takes a couple
    more lines of code, but is still pretty simple to write:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是Qt提供的内置函数，用于轻松创建消息框，它不会给开发人员完全自定义消息框的自由。但是，Qt允许您使用另一种方法手动创建消息框，这种方法比内置方法更可定制。这需要更多的代码行，但编写起来仍然相当简单：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will produce the following result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果：
- en: '![](img/f79a9076-7112-4fa4-bed4-5bc3b9bc5628.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79a9076-7112-4fa4-bed4-5bc3b9bc5628.png)'
- en: '*It looks just the same*, you''re telling me. What about adding our own icon
    and customized buttons? No problem with that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: “看起来完全一样”，你告诉我。那么添加我们自己的图标和自定义按钮呢？这没有问题：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code produces the following result:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下结果：
- en: '![](img/04e2e8f6-5139-4bfb-aced-564cedaf5d2d.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04e2e8f6-5139-4bfb-aced-564cedaf5d2d.png)'
- en: 'In the preceding code example, I have loaded the question icon that comes with
    Qt, but you can also load your own icon from the resource file if you intended
    to do so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我已经加载了Qt提供的问题图标，但如果您打算这样做，您也可以从资源文件中加载自己的图标：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Build and run the project now, and you should be able to see this fantastic
    message box:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行项目，您应该能够看到这个奇妙的消息框：
- en: '![](img/ce170a25-75c4-448e-ab26-b82691eda029.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce170a25-75c4-448e-ab26-b82691eda029.png)'
- en: Once you have understood how to create your own message boxes, let's proceed
    to learn about the event system that comes with the message box.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了如何创建自己的消息框，让我们继续学习消息框附带的事件系统。
- en: When a user is presented with a message box with multiple different choices,
    he/she would expect a different reaction from the application when pressing a
    different button.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户被呈现具有多个不同选择的消息框时，他/她会期望在按下不同按钮时应用程序有不同的反应。
- en: For example, when a message box pops up and asks the user whether they wish
    to quit the program or not, the button Yes should make the program terminate,
    while the No button will do nothing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当消息框弹出并询问用户是否希望退出程序时，按钮“是”应该使程序终止，而“否”按钮将不起作用。
- en: 'Qt''s `QMessageBox` class provides us with a simple solution for checking the
    button event. When the message box is being created, Qt will wait for the user
    to pick their choice; then, it will return the button that gets triggered. By
    checking which button is being clicked, the developer can then proceed to trigger
    the relevant event. Let''s take a look at the example code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的`QMessageBox`类为我们提供了一个简单的解决方案来检查按钮事件。当消息框被创建时，Qt将等待用户选择他们的选择；然后，它将返回被触发的按钮。通过检查哪个按钮被点击，开发人员可以继续触发相关事件。让我们看一下示例代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will produce the following result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果：
- en: '![](img/4ec73206-502c-4051-aa2a-ba175f839f16.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ec73206-502c-4051-aa2a-ba175f839f16.png)'
- en: 'If you prefer the manual way to create your message box, the code for checking
    the button event is slightly longer:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢手动创建消息框，检查按钮事件的代码会稍微长一些：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though the code is slightly longer, the basic concept is pretty much the
    same—the clicked button will always be able to be retrieved by the developer for
    triggering the appropriate action. This time, however, instead of checking the
    enumerator, Qt directly checks the button pointer instead, since the preceding
    code does not use the built-in standard buttons from the `QMessageBox` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码稍微长一些，但基本概念基本相同——被点击的按钮始终可以被开发人员检索以触发适当的操作。然而，这次，Qt直接检查按钮指针，而不是检查枚举器，因为前面的代码没有使用`QMessageBox`类的内置标准按钮。
- en: 'Build the project, and you should be able to get the following result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目，您应该能够获得以下结果：
- en: '![](img/9c49eca5-6076-4609-9e1c-e3f2e7a1a762.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c49eca5-6076-4609-9e1c-e3f2e7a1a762.png)'
- en: 'For more information regarding the dialog boxes, please visit the API documents
    located at the following link: [http://doc.qt.io/qt-5/qdialog.html](http://doc.qt.io/qt-5/qdialog.html)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关对话框的更多信息，请访问以下链接的API文档：[http://doc.qt.io/qt-5/qdialog.html](http://doc.qt.io/qt-5/qdialog.html)
- en: Creating File Selection Dialogs
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件选择对话框
- en: Since we have covered the topic about message boxes, let's also learn about
    the other type of dialog—the File Selection Dialog. The File Selection Dialog
    is also very useful, especially if your application frequently deals with files.
    It is extremely unpleasant to ask users to key in the absolute path of the file
    they wanted to open, so the File Selection Dialog is very handy in this kind of
    situation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了消息框的主题，让我们也了解一下另一种类型的对话框——文件选择对话框。文件选择对话框也非常有用，特别是如果您的应用程序经常处理文件。要求用户输入他们想要打开的文件的绝对路径是非常不愉快的，因此文件选择对话框在这种情况下非常方便。
- en: Qt provides us with a built-in File Selection Dialog that looks exactly the
    same as the one we see in our operating system, and therefore, it won't feel unfamiliar
    to the users. The File Selection Dialog essentially only does one thing—it lets
    the user pick the file(s) or folder they want and return the path(s) of the selected
    file(s) or folder; that's all. In fact, it is not in charge of opening the file
    and reading its content.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了一个内置的文件选择对话框，看起来与我们在操作系统中看到的一样，因此，对用户来说并不陌生。文件选择对话框本质上只做一件事——让用户选择他们想要的文件或文件夹，并返回所选文件或文件夹的路径；就这些。实际上，它不负责打开文件和读取其内容。
- en: 'Let''s look at how we can trigger the File Selection Dialog. First, open up
    `mainwindow.h` and add in the following header files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何触发文件选择对话框。首先，打开`mainwindow.h`并添加以下头文件：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, open up `mainwindow.cpp` and insert the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`mainwindow.cpp`并插入以下代码：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It''s that simple! Build and run the project now, and you should get this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！现在构建并运行项目，您应该会得到这个：
- en: '![](img/cb0d3f1e-1e61-4d02-b280-9a4935ead609.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb0d3f1e-1e61-4d02-b280-9a4935ead609.png)'
- en: If the user has selected a file and pressed Open, the `fileName` variable will
    be filled with the absolute path of the selected file. If the user clicked the
    Cancel button, the `fileName` variable will be an empty string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择了文件并按下打开，`fileName` 变量将填充为所选文件的绝对路径。如果用户单击取消按钮，`fileName` 变量将为空字符串。
- en: 'The File Selection Dialog also contains several options that can be set during
    the initialization step. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件选择对话框在初始化步骤中还包含几个可以设置的选项。例如：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are three things that we have set in the preceding code they are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了三件事，它们如下：
- en: The window title of the File Selection Dialog
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件选择对话框的窗口标题
- en: The default path that the users see when the dialog is being created
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框创建时用户看到的默认路径
- en: File type filters
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型过滤
- en: The file type filter is very handy when you only allow the users to select a
    specific type of file (for example, only JPEG image files) and hide the rest.
    Besides `getOpenFileName()`, you can also use `getSaveFileName()`, which will
    allow the user to specify a filename that does not already exist.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型过滤在您只允许用户选择特定类型的文件时非常方便（例如，仅允许 JPEG 图像文件），并隐藏其他文件。除了 `getOpenFileName()`，您还可以使用
    `getSaveFileName()`，它将允许用户指定尚不存在的文件名。
- en: 'For more information regarding the File Selection Dialog, please visit the
    API documents located at the following link: [http://doc.qt.io/qt-5/qfiledialog.html](http://doc.qt.io/qt-5/qfiledialog.html)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文件选择对话框的更多信息，请访问以下链接的 API 文档：[http://doc.qt.io/qt-5/qfiledialog.html](http://doc.qt.io/qt-5/qfiledialog.html)
- en: Image scaling and cropping
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像缩放和裁剪
- en: Since we learned about the File Selection Dialog in the previous section, I'd
    thought we should learn something fun this time!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一节中学习了文件选择对话框，我想这次我们应该学习一些有趣的东西！
- en: 'First off, let''s create a new Qt Widgets Application. Then, open up `mainwindow.ui`
    and create the following user interface:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的 Qt Widgets 应用程序。然后，打开 `mainwindow.ui` 并创建以下用户界面：
- en: '![](img/867c3332-9f87-40c0-933b-05190c15dd8e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/867c3332-9f87-40c0-933b-05190c15dd8e.png)'
- en: 'Let''s dissect this user interface into three parts:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个用户界面分解成三个部分：
- en: 'Top—Image preview:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部—图像预览：
- en: First, add a Horizontal Layout to the window.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在窗口中添加一个水平布局。
- en: Then, add a Label widget into the Horizontal Layout we just added, then set
    the text property to `empty`. Set both the label's minimumSize and maximumSize
    properties to 150x150\. Finally, set the frameShape property under the QFrame
    category to Box.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将一个标签小部件添加到我们刚刚添加的水平布局中，然后将文本属性设置为 `empty`。将标签的 minimumSize 和 maximumSize
    属性都设置为 150x150。最后，在 QFrame 类别下设置 frameShape 属性为 Box。
- en: Add two Horizontal Spacers to the sides of the label to make it centered.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签的两侧添加两个水平间隔器，使其居中。
- en: 'Middle—Sliders for adjustments:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中部—用于调整的滑块：
- en: Add a Form Layout to the window, below the Horizontal Layout we just added previously
    in step 1.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口中添加一个表单布局，放在我们在步骤 1 中刚刚添加的水平布局下方。
- en: Add three Labels to the Form Layout, and set their text property to `Scale:`,
    `Horizontal:`, and `Vertical:` respectively.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三个标签添加到表单布局中，并将它们的文本属性分别设置为 `比例：`、`水平：` 和 `垂直：`。
- en: Add three Horizontal Sliders to the Form Layout. Set the minimum property to
    `1` and maximum to `100`. Then, set the pageStep property to `1`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三个水平滑块添加到表单布局中。将最小属性设置为 `1`，最大属性设置为 `100`。然后，将 pageStep 属性设置为 `1`。
- en: Set the value property of the scale slider to `100`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将比例滑块的值属性设置为 `100`。
- en: 'Bottom—Browse button and Save button:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部—浏览按钮和保存按钮：
- en: Add a Horizontal Layout to the window, below the Form Layout we previously added
    during step 2.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口中添加一个水平布局，放在我们在步骤 2 中添加的表单布局下方。
- en: Add two Push Buttons to the Horizontal Layout and set their text property to
    `Browse` and `Save` respectively.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个按钮添加到水平布局中，并将它们的文本属性分别设置为 `浏览` 和 `保存`。
- en: Lastly, delete the Menu Bar, Tool Bar, and Status Bar from the central widget.
  id: totrans-142
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从中央小部件中删除菜单栏、工具栏和状态栏。
- en: 'Now that we have created the user interface, let''s dive into the coding! First,
    open up `mainwindow.h` and add in the following headers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户界面，让我们开始编码吧！首先，打开 `mainwindow.h` 并添加以下头文件：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, add the following variables to `mainwindow.h`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下变量添加到 `mainwindow.h`：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, go back to `mainwindow.ui` and right-click on the Browse button, followed
    by selecting Go to slot. Then, a window will pop up and ask you to select a signal.
    Pick the `clicked()` signal located at the top of the list, and then press the
    OK button:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，返回到 `mainwindow.ui`，右键单击浏览按钮，然后选择转到槽。然后，一个窗口将弹出并要求您选择一个信号。选择位于列表顶部的 `clicked()`
    信号，然后按下 OK 按钮：
- en: '![](img/e63f85a0-57c5-4097-a3aa-ddba2adc9e17.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e63f85a0-57c5-4097-a3aa-ddba2adc9e17.png)'
- en: 'A new `slot` function will be automatically added to your source file. Now,
    add the following code to open up the File Selection Dialog when the Browse button
    is clicked. The dialog only lists JPEG images and hides the other files:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的源文件中将自动添加一个新的 `slot` 函数。现在，添加以下代码以在单击浏览按钮时打开文件选择对话框。对话框仅列出 JPEG 图像并隐藏其他文件：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the code checks whether any image has been selected by the user.
    If it has its checks again and see whether the image resolution is at least 150
    x 150\. If no problem is found, we will save the image's pixel map to a pointer
    called `pix`, then save the image size to the `imageSize` variable, and the initial
    drawing size to the `drawSize` variable. Finally, we set the `canDraw` variable
    to `true`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码检查用户是否选择了任何图像。如果选择了图像，它会再次检查图像分辨率是否至少为 150 x 150。如果没有问题，我们将保存图像的像素映射到名为
    `pix` 的指针中，然后将图像大小保存到 `imageSize` 变量中，并将初始绘图大小保存到 `drawSize` 变量中。最后，我们将 `canDraw`
    变量设置为 `true`。
- en: 'After that, open up `mainwindow.h` again and declare these two functions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，再次打开 `mainwindow.h` 并声明以下两个函数：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first function, `paintEvent()`, is a virtual function that automatically
    gets called whenever Qt needs to refresh the user interface, such as when the
    main window is being resized. We''ll override this function and draw the newly
    loaded image onto the image preview widget. In this case, we''ll call the `paintImage()`
    function within the `paintEvent()` virtual function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`paintEvent()`是一个虚函数，每当Qt需要刷新用户界面时（例如当主窗口被调整大小时），它就会自动调用。我们将重写这个函数，并将新加载的图像绘制到图像预览部件上。在这种情况下，我们将在`paintEvent()`虚函数中调用`paintImage()`函数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, we''ll write the `paintImage()` function in `mainwindow.cpp`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将在`mainwindow.cpp`中编写`paintImage()`函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function does two things—if we don't set the `fileName` variable, it will
    proceed to draw the image on top of the image preview widget, otherwise, it will
    crop the image based on the dimension of the image preview widget and save it
    to the disk following the `fileName` variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有两个作用——如果我们不设置`fileName`变量，它将继续在图像预览部件上绘制图像，否则，它将根据图像预览部件的尺寸裁剪图像，并根据`fileName`变量将其保存到磁盘上。
- en: 'We''ll call this function again when the save button is being clicked. This
    time, we''ll set the `fileName` variable as the desired directory path and filename,
    so that the `QPainter` class can save the image correctly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击保存按钮时，我们将再次调用此函数。这次，我们将设置`fileName`变量为所需的目录路径和文件名，以便`QPainter`类可以正确保存图像：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lastly, right-click on each of the three sliders and select Go to slot. Then,
    select `valueChanged(int)` and click OK.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，右键单击三个滑块中的每一个，然后选择“转到槽”。然后，选择`valueChanged(int)`并单击“确定”。
- en: '![](img/b605edff-3b8d-4ce0-9661-b08ae23bbb5d.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b605edff-3b8d-4ce0-9661-b08ae23bbb5d.png)'
- en: 'After that, we''ll write the code for the `slot` functions resulting from the
    previous step:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将编写从上一步骤中得到的`slot`函数的代码：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The scale slider is basically for users to resize the image to their desired
    scale within the image preview widget. The left slider is for the users to move
    the image horizontally, while the top slider is used by the users to move the
    image vertically. By combining these three different sliders, users can adjust
    and crop the image to their liking before proceeding to upload the image to the
    server, or use it for other purposes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 比例滑块基本上是供用户在图像预览部件内调整所需比例的。左侧滑块是供用户水平移动图像的，而顶部滑块是供用户垂直移动图像的。通过组合这三个不同的滑块，用户可以在将图像上传到服务器之前，或者用于其他目的之前，调整和裁剪图像以满足他们的喜好。
- en: 'If you build and run the project now, you should be able to get this result:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在构建并运行项目，您应该能够获得以下结果：
- en: '![](img/2b7d67e4-2cc1-434a-87b7-8e09130c019a.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b7d67e4-2cc1-434a-87b7-8e09130c019a.png)'
- en: You can click on the Browse button to select a JPG image file to load. After
    that, the image should appear on the preview area. You can then move the sliders
    around for adjusting the cropping size. Once you're satisfied with the result,
    click the Save button to save your image in the current directory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击“浏览”按钮选择要加载的JPG图像文件。之后，图像应该会出现在预览区域。然后，您可以移动滑块来调整裁剪大小。一旦您对结果满意，点击“保存”按钮将图像保存在当前目录中。
- en: 'Do check out the sample code that comes together with this book if you want
    to learn more about it in detail. You can find the source code at the following
    GitHub page: [https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5](https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想详细了解，请查看本书附带的示例代码。您可以在以下GitHub页面找到源代码：[https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5](https://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5)
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '**Input and Output (I/O)** are the essence of modern computer software. Qt
    allows us to display our data in many different ways that are both intuitive and
    engaging to the end users. Other than that, the event system that comes with Qt
    makes our life as a programmer a lot easier, as it tends to automatically capture
    the user inputs through the powerful signal-and-slot mechanism and in-response
    triggering custom-defined behaviors. Without Qt, we would have a hard time trying
    to figure out how to reinvent the proverbial wheel, and might eventually end up
    creating a less user-friendly product.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入和输出（I/O）**是现代计算机软件的本质。Qt允许我们以许多直观和引人入胜的方式显示我们的数据给最终用户。除此之外，Qt提供的事件系统使得作为程序员的我们的生活变得更加轻松，因为它倾向于通过强大的信号和槽机制自动捕获用户输入，并触发自定义行为。没有Qt，我们将很难想出如何重新发明这个老生常谈的轮子，并最终可能会创建一个不太用户友好的产品。'
- en: In this chapter, we have learned how to make use of the fantastic features that
    are provided by Qt—view widgets, dialog boxes, and file selection dialogs used
    to display important information to the users. Furthermore, we also went through
    a fun little project that taught us how to scale and crop an image using Qt widgets
    for user inputs. In the next chapter, we will go for something more advanced (and
    fun too), which is creating our very own web browser using Qt!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用Qt提供的出色功能——视图部件、对话框和文件选择对话框，用于向用户显示重要信息。此外，我们还通过一个有趣的小项目学习了如何使用Qt部件对用户输入进行缩放和裁剪图像。在下一章中，我们将尝试更高级（也更有趣）的内容，即使用Qt创建我们自己的网络浏览器！
