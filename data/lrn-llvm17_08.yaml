- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Advanced IR Generation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级IR生成
- en: With IR generation introduced in the previous chapters, you can already implement
    most of the functionality required in a compiler. In this chapter, we will look
    at some advanced topics that often arise in real-world compilers. For example,
    many modern languages make use of exception handling, so we’ll look at how to
    translate this into LLVM IR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中介绍了IR生成后，你就可以实现编译器所需的大部分功能。在本章中，我们将探讨一些在现实世界编译器中经常出现的高级主题。例如，许多现代语言都使用了异常处理，因此我们将探讨如何将其转换为LLVM
    IR。
- en: To support the LLVM optimizer so that it can produce better code in certain
    situations, we must add additional type metadata to the IR code. Moreover, attaching
    debug metadata enables the compiler’s user to take advantage of source-level debug
    tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持LLVM优化器，以便它在某些情况下产生更好的代码，我们必须向IR代码中添加额外的类型元数据。此外，附加调试元数据使编译器的用户能够利用源级调试工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '*Throwing and catching exceptions*: Here, you will learn how to implement exception
    handling in your compiler'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抛出和捕获异常*：在这里，你将学习如何在你的编译器中实现异常处理'
- en: '*Generating metadata for type-based alias analysis*: Here, you will attach
    additional metadata to LLVM IR, which helps LLVM to better optimize the code'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为基于类型的别名分析生成元数据*：在这里，你将为LLVM IR附加额外的元数据，这有助于LLVM更好地优化代码'
- en: '*Adding debug metadata*: Here, you will implement the support classes needed
    to add debug information to the generated IR code'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加调试元数据*：在这里，你将实现添加到生成的IR代码中的调试信息所需的支持类'
- en: By the end of this chapter, you will have learned about exception handling,
    as well as metadata for type-based alias analysis and debug information.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解异常处理，以及基于类型的别名分析和调试信息的元数据。
- en: Throwing and catching exceptions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出和捕获异常
- en: 'Exception handling in LLVM IR is closely tied to platform support. Here, we
    will look at the most common type of exception handling using `libunwind`. Its
    full potential is used by C++, so we will look at an example in C++ first, where
    the `bar()` function can throw an `int` or `double` value:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR中的异常处理与平台支持紧密相关。在这里，我们将探讨使用`libunwind`的最常见的异常处理类型。C++使用了它的全部潜力，因此我们将首先查看一个C++的例子，其中`bar()`函数可以抛出`int`或`double`值：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `foo()` function calls `bar()`, but only handles a thrown `int`. It also
    declares that it only throws `int` values:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()`函数调用`bar()`，但只处理抛出的`int`。它还声明它只抛出`int`值：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Throwing an exception requires two calls into the runtime library; this can
    be seen in the `bar()` function. First, memory for the exception is allocated
    with a call to `__cxa_allocate_exception()`. This function takes the number of
    bytes to allocate as a parameter. The exception payload (the `int` or `double`
    value in this example) is copied to the allocated memory. The exception is then
    raised with a call to `__cxa_throw()`. This function takes three arguments: the
    pointer to the allocated exception, type information about the payload, and a
    pointer to a destructor, in case the exception payload has one. The `__cxa_throw()`
    function initiates the stack unwinding process and never returns. In LLVM IR,
    this is done for the `int` value, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常需要调用运行时库两次；这可以在`bar()`函数中看到。首先，通过调用`__cxa_allocate_exception()`为异常分配内存。这个函数接受要分配的字节数作为参数。异常负载（在这个例子中的`int`或`double`值）被复制到分配的内存中。然后，通过调用`__cxa_throw()`来引发异常。这个函数接受三个参数：分配的异常的指针、负载的类型信息以及指向析构函数的指针，以防异常负载有一个。`__cxa_throw()`函数启动堆栈回溯过程，并且永远不会返回。在LLVM
    IR中，这是对`int`值进行的，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`_ZTIi` is the type information describing an `int` type. For a double type,
    it would be `_ZTId`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ZTIi`是描述`int`类型的类型信息。对于`double`类型，它将是`_ZTId`。'
- en: 'So far, nothing LLVM-specific is done. This changes in the `foo()` function
    because the call to `bar()` can raise an exception. If it is an `int` type exception,
    then the control flow must be transferred to the IR code of the catch clause.
    To accomplish this, the `invoke` instruction must be used instead of the `call`
    instruction:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有进行任何特定于LLVM的操作。这在前面的`foo()`函数中发生了变化，因为对`bar()`的调用可能会抛出异常。如果它是一个`int`类型的异常，那么控制流必须转移到捕获子句的IR代码。为了完成这个任务，必须使用`invoke`指令而不是`call`指令：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference between both instructions is that `invoke` has two labels associated.
    The first label is where execution continues in case the called function ends
    normally, usually with a `ret` instruction. In the example code, this label is
    called `%next`. If an exception occurs, then execution continues at a so-called
    *landing pad*, with a label of `%lpad`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令之间的区别在于`invoke`有两个标签相关联。第一个标签是在被调用函数正常结束（通常使用`ret`指令）时继续执行的地方。在示例代码中，这个标签被称为`%next`。如果发生异常，则执行继续在所谓的*着陆点*，标签为`%lpad`。
- en: 'The landing pad is a basic block that must begin with a `landingpad` instruction.
    The `landingpad` instruction gives LLVM information about the handled exception
    types. For example, a possible landing pad could look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 着陆点是一个必须以`landingpad`指令开始的代码块。`landingpad`指令向LLVM提供有关处理异常类型的信息。例如，一个可能的着陆点可能看起来像这样：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are three possible types of action here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能有三种操作类型：
- en: '`cleanup`: This denotes that code to clean up the current state is present.
    Usually, this is used to call destructors of local objects. If this marker is
    present, then the landing pad is always called during stack unwinding.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanup`：这表示存在清理当前状态的代码。通常，这用于调用局部对象的析构函数。如果存在此标记，则在栈回溯期间始终调用着陆点。'
- en: '`catch`: This is a list of type-value pairs and denotes the exception types
    that can be handled. The landing pad is called if the thrown exception type is
    found in this list. In the case of the `foo()` function, the value is the pointer
    to the C++ runtime type information for the `int` type, similar to the parameter
    of the `__cxa_throw()` function.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`：这是一个类型-值对的列表，表示可以处理的异常类型。如果抛出的异常类型在此列表中，则调用着陆点。在`foo()`函数的情况下，值是C++运行时类型信息指针，类似于`__cxa_throw()`函数的参数。'
- en: '`filter`: This specifies an array of exception types. The landing pad is called
    if the exception type of the current exception is not found in the array. This
    is used to implement the `throw()` specification. For the `foo()` function, the
    array has only one member – the type information for the `int` type.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：这指定了一个异常类型数组。如果当前异常的类型不在数组中，则调用着陆点。这用于实现`throw()`规范。对于`foo()`函数，数组只有一个成员——`int`类型的类型信息。'
- en: 'The result type of the `landingpad` instruction is the `{ ptr, i32 }` structure.
    The first element is a pointer to the thrown exception, while the second is a
    type selector. Let’s extract both from the structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`landingpad`指令的结果类型是`{ ptr, i32 }`结构。第一个元素是指向抛出异常的指针，而第二个是类型选择器。让我们从结构中提取这两个值：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *type selector* is a number that helps us identify the cause of *why the
    landing pad is called*. It is a positive value if the current exception type matches
    one of the exception types given in the `catch` part of the `landingpad` instruction.
    If the current exception type does not match any of the values given in the `filter`
    part, then the value is negative. It is `0` if the cleanup code should be called.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型选择器*是一个帮助我们识别*为什么着陆点被调用*的原因的数字。如果当前异常类型与`landingpad`指令的`catch`部分中给出的异常类型之一匹配，则该值是正数。如果当前异常类型与`filter`部分中给出的任何值都不匹配，则该值为负数。如果应该调用清理代码，则该值为`0`。'
- en: 'The type selector is an offset into a type information table, constructed from
    the values given in the `catch` and `filter` parts of the `landingpad` instruction.
    During optimization, multiple landing pads can be combined into one, which means
    that the structure of this table is not known at the IR level. To retrieve the
    type selector for a given type, we need to call the intrinsic `@llvm.eh.typeid.for`
    function. We need this to check if the type selector value corresponds to the
    type information for `int` so that we can execute the code in the `catch (int
    e) {}` block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型选择器是一个类型信息表的偏移量，该表由`landingpad`指令的`catch`和`filter`部分给出的值构建而成。在优化过程中，多个着陆点可以合并为一个，这意味着该表的结构在IR级别上是未知的。为了检索给定类型的类型选择器，我们需要调用内建的`@llvm.eh.typeid.for`函数。我们需要这个函数来检查类型选择器值是否对应于`int`类型的类型信息，以便我们可以在`catch
    (int e) {}`块中执行代码：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The handling of an exception is framed by calls to `__cxa_begin_catch()` and
    `__cxa_end_catch()`. The `__cxa_begin_catch()` function needs one argument – the
    current exception – which is one of the values returned by the `landingpad` instruction.
    It returns a pointer to the exception payload – an `int` value in our case.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是通过调用 `__cxa_begin_catch()` 和 `__cxa_end_catch()` 来框架化的。`__cxa_begin_catch()`
    函数需要一个参数——当前异常，它是 `landingpad` 指令返回的值之一。它返回异常负载的指针——在我们的例子中是一个 `int` 值。
- en: 'The `__cxa_end_catch()` function marks the end of exception handling and deallocates
    the memory allocated with `__cxa_allocate_exception()`. Please note that the runtime
    behavior is much more complicated if another exception is thrown inside the `catch`
    block. The exception is handled as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`__cxa_end_catch()` 函数标记了异常处理的结束，并释放了使用 `__cxa_allocate_exception()` 分配的内存。请注意，如果在
    `catch` 块内部抛出另一个异常，运行时行为会变得更加复杂。异常处理如下：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the type of the current exception does not match the list in the `throws()`
    declaration, the unexpected exception handler is called. First, we need to check
    the type selector again:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前异常的类型与 `throws()` 声明中的列表不匹配，则调用未预期的异常处理器。首先，我们需要再次检查类型选择器：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the value of the type selector is lower than `0`, then we call the handler:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型选择器的值小于 `0`，则调用处理器：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the handler is not expected to come back.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，处理器不应该返回。
- en: 'No cleanup work is needed in this case, so all the cleanup code does is resume
    the execution of the stack unwinder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下不需要进行清理工作，因此所有清理代码所做的只是恢复堆栈回溯器的执行：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One piece is still missing: `libunwind` drives the stack unwinding process,
    but it is not tied to a single language. Language-dependent handling is done in
    the personality function. For C++ on Linux, the personality function is called
    `__gxx_personality_v0()`. Depending on the platform or compiler, this name can
    vary. Each function that needs to take part in stack unwinding has a personality
    function attached. This personality function analyzes if the function catches
    an exception, has a non-matching filter list, or needs a cleanup call. It gives
    this information back to the unwinder, which acts accordingly. In LLVM IR, the
    pointer to the personality function is given as a part of the function definition:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还缺少一部分：`libunwind` 驱动堆栈回溯过程，但它并不绑定到单一的语言。语言相关的处理在个性函数中完成。对于 Linux 上的 C++，个性函数被调用为
    `__gxx_personality_v0()`。根据平台或编译器，这个名称可能会有所不同。每个需要参与堆栈回溯的函数都有一个个性函数附加。这个个性函数分析函数是否捕获了异常，是否有不匹配的过滤器列表，或者是否需要清理调用。它将此信息返回给回溯器，回溯器据此采取行动。在
    LLVM IR 中，个性函数的指针作为函数定义的一部分给出：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this, the exception handling facility is complete.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，异常处理功能就完成了。
- en: 'To use exception handling in the compiler for your programming language, the
    simplest strategy is to piggyback on the existing C++ runtime functions. This
    also has the advantage that your exceptions are interoperable with C++. The disadvantage
    is that you tie some of the C++ runtime into the runtime of your language, most
    notably memory management. If you want to avoid this, then you need to create
    your own equivalents of the `_cxa_` functions. Still, you will want to use `libunwind`,
    which provides the stack unwinding mechanism:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器中为您的编程语言使用异常处理的最简单策略是利用现有的 C++ 运行时函数。这也具有优势，即您的异常可以与 C++ 兼容。缺点是您将一些 C++
    运行时绑定到您语言的运行时中，最显著的是内存管理。如果您想避免这种情况，那么您需要创建自己的 `_cxa_` 函数等效物。尽管如此，您仍然会想使用 `libunwind`，它提供了堆栈回溯机制：
- en: 'Let’s look at how to create this IR. We created the `calc` expression compiler
    in [*Chapter 2*](B19561_02.xhtml#_idTextAnchor037), *The Structure of a Compiler*.
    Now, we will extend the code generator of the expression compiler to raise and
    handle an exception in case a division by zero is performed. The generated IR
    will check if the divisor of a division is `0`. If true, then an exception will
    be raised. We will also add a landing pad to the function, which catches the exception
    and prints `Divide by zero!` to the console and ends the calculation. Using exception
    handling is not necessary in this simple case, but it allows us to concentrate
    on the code generation process. We must add all the code to the `CodeGen.cpp`
    file. We begin by adding the required new fields and some helper methods. First
    of all, we need to store the LLVM declaration of the `__cxa_allocate_exception()`
    and `__cxa_throw()` functions, which consist of the function type and the function
    itself. A `GlobalVariable` instance is needed to hold the type information. We
    also need references to the basic blocks holding the landing pad and a basic block
    containing just an `unreachable` instruction:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何创建这个 IR。我们在 [*第 2 章*](B19561_02.xhtml#_idTextAnchor037) 中创建了 `calc` 表达式编译器，*编译器的结构*。现在，我们将扩展表达式编译器的代码生成器，以便在执行除以零操作时抛出和处理异常。生成的
    IR 将检查除法的除数是否为 `0`。如果是，则抛出异常。我们还将向函数中添加一个 landing pad，它捕获异常并将 `Divide by zero!`
    打印到控制台并结束计算。在这个简单的情况下，使用异常处理不是必需的，但它允许我们专注于代码生成过程。我们必须将所有代码添加到 `CodeGen.cpp` 文件中。我们首先添加所需的新字段和一些辅助方法。首先，我们需要存储
    `__cxa_allocate_exception()` 和 `__cxa_throw()` 函数的 LLVM 声明，这些声明包括函数类型和函数本身。需要一个
    `GlobalVariable` 实例来存储类型信息。我们还需要引用包含 landing pad 的基本块和一个只包含 `unreachable` 指令的基本块：
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also add a new helper function to create the IR for comparing two values.
    The `createICmpEq()` function takes the `Left` and `Right` values to compare as
    parameters. It creates a compare instruction testing for equality of the values,
    and a branch instruction to two basic blocks, for the equal and inequal cases.
    The two basic blocks are returned via references in the `TrueDest` and `FalseDest`
    parameters. Furthermore, a label for the new basic blocks can be given in the
    `TrueLabel` and `FalseLabel` parameters. The code is as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个新的辅助函数来创建比较两个值的 IR。`createICmpEq()` 函数接受要比较的 `Left` 和 `Right` 值作为参数。它创建一个比较指令来测试值的相等性，并为相等和不相等的情况创建一个分支指令到两个基本块。这两个基本块通过
    `TrueDest` 和 `FalseDest` 参数返回。此外，可以在 `TrueLabel` 和 `FalseLabel` 参数中给出新基本块的标签。代码如下：
- en: '[PRE13]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use the functions from the runtime, we need to create several function declarations.
    In LLVM, a function type gives the signature, and the function itself must be
    constructed. We use the `createFunc()` method to create both objects. The functions
    need references to the `FunctionType` and `Function` pointers, the name of the
    newly declared function, and the result type. The parameter type list is optional,
    and the flag to indicate a variable parameter list is set to `false`, indicating
    that there is no variable part in the parameter list:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用运行时函数，我们需要创建几个函数声明。在 LLVM 中，函数类型给出签名，而函数本身必须构造。我们使用 `createFunc()` 方法创建这两个对象。函数需要
    `FunctionType` 和 `Function` 指针的引用，新声明的函数的名称，以及结果类型。参数类型列表是可选的，表示变量参数列表的标志设置为 `false`，表示参数列表中没有变量部分：
- en: '[PRE14]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these preparations done, we can generate the IR to raise an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些准备工作后，我们可以生成 IR 来抛出异常。
- en: Raising an exception
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'To generate the IR code to raise an exception, we will add the `addThrow()`
    method. This new method needs to initialize the new fields and then generate the
    IR to raise an exception via the `__cxa_throw()` function. The payload of the
    raised exception is of the `int` type and can be set to an arbitrary value. Here
    is what we need to code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成抛出异常的 IR 代码，我们将添加 `addThrow()` 方法。这个新方法需要初始化新的字段，然后通过 `__cxa_throw()` 函数生成抛出异常的
    IR。抛出的异常的有效负载是 `int` 类型，可以设置为任意值。以下是我们需要编写的代码：
- en: 'The new `addThrow()` method begins by checking if the `TypeInfo` field has
    been initialized. If it has not been initialized, then a global external constant
    of an `i8` pointer type called `_ZTIi` is created. This represents the C++ metadata
    describing the C++ `int` type:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `addThrow()` 方法首先检查 `TypeInfo` 字段是否已初始化。如果没有初始化，则创建一个名为 `_ZTIi` 的 `i8` 指针类型的全局外部常量。这代表了描述
    C++ `int` 类型的 C++ 元数据：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The initialization continues with creating the IR declaration for the `__cxa_allocate_exception()`
    and `__cxa_throw()` functions using our helper `createFunc()` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化继续通过使用我们的辅助`createFunc()`方法创建`__cxa_allocate_exception()`和`__cxa_throw()`函数的IR声明：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A function that uses exception handling needs a personality function, which
    helps with stack unwinding. We add the IR code to declare the `__gxx_personality_v0()`
    personality function from the C++ library and set it as the personality routine
    of the current function. The current function is not stored as a field, but we
    can use the `Builder` instance to query the current basic block, which has the
    function stored as a `Parent` field:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用异常处理的函数需要一个个人函数，它有助于栈回溯。我们添加IR代码来声明来自C++库的`__gxx_personality_v0()`个人函数，并将其设置为当前函数的个人例程。当前函数不是作为字段存储的，但我们可以使用`Builder`实例来查询当前基本块，该基本块将函数存储为`Parent`字段：
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we must create and populate the basic block for the landing pad. First,
    we need to save the pointer to the current basic block. Then, we must create a
    new basic block, set it in the builder so that it can be used as the basic block
    to insert instructions, and call the `addLandingPad()` method. This method generates
    the IR code for handling an exception and is described in the next section, *Catching
    an exception*. This code populates the basic block for the landing pad:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建并填充着陆地基本块。首先，我们需要保存当前基本块的指针。然后，我们必须创建一个新的基本块，将其设置在构建器中以便可以使用它来插入指令，并调用`addLandingPad()`方法。这个方法生成处理异常的IR代码，并在下一节*捕获异常*中描述。这段代码填充了着陆地基本块：
- en: '[PRE18]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The initialization part is completed by creating the basic block holding an
    `unreachable` instruction. Again, we create the basic block and set it as an insertion
    point at the builder. Then, we can add the `unreachable` instruction to it. Lastly,
    we can set the insertion point of the builder back to the saved `SaveBB` instance
    so that the following IR is added to the right basic block:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建包含`unreachable`指令的基本块来完成初始化部分。再次，我们创建基本块并将其设置为构建器的插入点。然后，我们可以向其中添加`unreachable`指令。最后，我们可以将构建器的插入点设置回保存的`SaveBB`实例，以便以下IR添加到正确的基本块：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To raise an exception, we need to allocate memory for the exception and the
    payload via a call to the `__cxa_allocate_exception()` function. Our payload is
    of the C++ `int` type, which usually has a size of 4 bytes. We create a constant
    unsigned value for the size and call the function with it as a parameter. The
    function type and the function declaration are already initialized, so we only
    need to create the `call` instruction:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要抛出异常，我们需要通过调用`__cxa_allocate_exception()`函数为异常和有效负载分配内存。我们的有效负载是C++的`int`类型，通常大小为4字节。我们创建一个常量无符号值作为大小，并用它作为参数调用该函数。函数类型和函数声明已经初始化，所以我们只需要创建`call`指令：
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we store the `PayloadVal` value in the allocated memory. To do so, we
    need to create an LLVM IR constant with a call to the `ConstantInt::get()` function.
    The pointer to the allocated memory is of an `i8` pointer type; to store a value
    of the `i32` type, we need to create a `bitcast` instruction to cast the type:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`PayloadVal`值存储在分配的内存中。为此，我们需要创建一个调用`ConstantInt::get()`函数的LLVM IR常量。分配的内存的指针是`i8`指针类型；为了存储`i32`类型的值，我们需要创建一个`bitcast`指令来转换类型：
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we must raise the exception with a call to the `__cxa_throw()` function.
    As this function raises an exception, which is also handled in the same function,
    we need to use the `invoke` instruction instead of the `call` instruction. Unlike
    the `call` instruction, the `invoke` instruction ends a basic block because it
    has two successor basic blocks. Here, these are the `UnreachableBB` and `LPadBB`
    basic blocks. If the function raises no exception, the control flow is transferred
    to the `UnreachableBB` basic blocks. Due to the design of the `__cxa_throw()`
    function, this will never happen because the control flow is transferred to the
    `LPadBB` basic block to handle the exception. This finishes the implementation
    of the `addThrow()` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须通过调用`__cxa_throw()`函数来抛出异常。由于这个函数会抛出异常，而这个异常也在同一个函数中处理，因此我们需要使用`invoke`指令而不是`call`指令。与`call`指令不同，`invoke`指令会结束一个基本块，因为它有两个后续的基本块。在这里，这些是`UnreachableBB`和`LPadBB`基本块。如果函数没有抛出异常，控制流将转移到`UnreachableBB`基本块。由于`__cxa_throw()`函数的设计，这种情况永远不会发生，因为控制流会转移到`LPadBB`基本块来处理异常。这完成了`addThrow()`方法的实现：
- en: '[PRE22]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we’ll add the code to generate the IR to handle the exception.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加生成处理异常的IR的代码。
- en: Catching an exception
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'To generate the IR code to catch an exception, we must add the `addLandingPad()`
    method. The generated IR extracts the type information from the exception. If
    it matches the C++ `int` type, then the exception is handled by printing `Divide
    by zero!` to the console and returning from the function. If the type does not
    match, we simply execute the `resume` instruction, which transfers control back
    to the runtime. As there are no other functions in the call hierarchy to handle
    this exception, the runtime will terminate the application. The following steps
    describe the code that is needed to generate the IR for catching an exception:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成捕获异常的IR代码，我们必须添加`addLandingPad()`方法。生成的IR从异常中提取类型信息。如果它与C++的`int`类型匹配，则异常通过将`Divide
    by zero!`打印到控制台并从函数返回来处理。如果类型不匹配，我们只需执行`resume`指令，将控制权转回运行时。由于调用堆栈中没有其他函数来处理这个异常，运行时将终止应用程序。以下步骤描述了生成捕获异常所需的代码：
- en: 'In the generated IR, we need to call the `__cxa_begin_catch()` and `__cxa_end_catch()`
    functions from the C++ runtime library. To print the error message, we will generate
    a call to the `puts()` function from the C runtime library. Furthermore, to get
    the type information from the exception, we must generate a call to the `llvm.eh.typeid.for`
    intrinsic. We also need the `FunctionType` and `Function` instances for all of
    them; we will take advantage of our `createFunc()` method to create them:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的IR中，我们需要从C++运行时库中调用`__cxa_begin_catch()`和`__cxa_end_catch()`函数。为了打印错误消息，我们将生成对C运行时库中的`puts()`函数的调用。此外，为了从异常中获取类型信息，我们必须生成对`llvm.eh.typeid.for`内建函数的调用。我们还需要所有这些的`FunctionType`和`Function`实例；我们将利用我们的`createFunc()`方法来创建它们：
- en: '[PRE23]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `landingpad` instruction is the first instruction we generate. The result
    type is a structure containing fields of an `i8` pointer and an `i32` type. This
    structure is generated with a call to the `StructType::get()` function. Moreover,
    since we need to handle an exception of a C++ `int` type, we need to also add
    this as a clause to the `landingpad` instruction, which must be a constant of
    an `i8` pointer type. This means that generating a `bitcast` instruction is required
    to convert the `TypeInfo` value into this type. After, we must store the value
    that’s returned from the instruction for later use in the `Exc` variable:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`landingpad`指令是我们生成的第一个指令。结果类型是一个包含`i8`指针和`i32`类型字段的结构。我们通过调用`StructType::get()`函数生成此结构。此外，由于我们需要处理C++
    `int`类型的异常，我们还需要将其添加为`landingpad`指令的一个子句，该指令必须是一个`i8`指针类型的常量。这意味着需要生成一个`bitcast`指令来将`TypeInfo`值转换为该类型。之后，我们必须将指令返回的值存储在`Exc`变量中，以供以后使用：'
- en: '[PRE24]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we extract the type selector from the returned value. With a call to
    the `llvm.eh.typeid.for` intrinsic, we retrieve the type ID for the `TypeInfo`
    field, representing the C++ `int` type. With this IR, we have generated the two
    values we need to compare to decide if we can handle the exception:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从返回值中提取类型选择器。通过调用`llvm.eh.typeid.for`内建函数，我们检索代表C++ `int`类型的`TypeInfo`字段的类型ID。有了这个IR，我们已经生成了我们需要比较的两个值，以决定我们是否可以处理这个异常：
- en: '[PRE25]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To generate the IR for the comparison, we must call our `createICmpEq()` function.
    This function also generates two basic blocks, which we store in the `TrueDest`
    and `FalseDest` variables:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成比较的IR，我们必须调用我们的`createICmpEq()`函数。此函数还生成两个基本块，我们将它们存储在`TrueDest`和`FalseDest`变量中：
- en: '[PRE26]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the two values do not match, the control flow continues at the `FalseDest`
    basic block. This basic block only contains a `resume` instruction, to give control
    back to the C++ runtime:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个值不匹配，控制流将继续在`FalseDest`基本块中。此基本块仅包含一个`resume`指令，以将控制权交还给C++运行时：
- en: '[PRE27]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the two values are equal, the control flow continues at the `TrueDest` basic
    block. First, we generate the IR code to extract the pointer to the exception
    from the return value of the `landingpad` instruction, stored in the `Exc` variable.
    Then, we generate a call to the `__cxa_begin_catch ()` function, passing the pointer
    to the exception as a parameter. This indicates the beginning of handling the
    exception for the runtime:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个值相等，控制流将继续在`TrueDest`基本块中。首先，我们生成IR代码以从`landingpad`指令的返回值中提取指向异常的指针，该返回值存储在`Exc`变量中。然后，我们生成对`__cxa_begin_catch
    ()`函数的调用，并将指向异常的指针作为参数传递。这表示运行时开始处理异常：
- en: '[PRE28]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The exception is then handled by calling the `puts()` function to print a message
    to the console. For this, we generate a pointer to the string with a call to the
    `CreateGlobalStringPtr()` function, and then pass this pointer as a parameter
    in the generated call to the `puts()` function:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过调用`puts()`函数来处理异常，打印一条消息到控制台。为此，我们通过调用`CreateGlobalStringPtr()`函数生成一个指向字符串的指针，然后将此指针作为参数传递给生成的`puts()`函数调用：
- en: '[PRE29]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we’ve handled the exception, we must generate a call to the `__cxa_end_catch()`
    function to inform the runtime about it. Finally, we return from the function
    with a `ret` instruction:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经处理了异常，我们必须生成对`__cxa_end_catch()`函数的调用，以通知运行时。最后，我们使用`ret`指令从函数返回：
- en: '[PRE30]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the `addThrow()` and `addLandingPad()` functions, we can generate the IR
    to raise an exception and handle an exception. However, we still need to add the
    IR to check if the divisor is `0`. We’ll cover this in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addThrow()`和`addLandingPad()`函数，我们可以生成IR来抛出异常和处理异常。然而，我们仍然需要添加IR来检查除数是否为`0`。我们将在下一节中介绍这一点。
- en: Integrating the exception handling code into the application
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将异常处理代码集成到应用程序中
- en: 'The IR for the division is generated inside the `visit(BinaryOp &)` method.
    Instead of just generating a `sdiv` instruction, we must generate an IR to compare
    the divisor with `0`. If the divisor is 0, then the control flow continues in
    a basic block, raising the exception. Otherwise, the control flow continues in
    a basic block with the `sdiv` instruction. With the help of the `createICmpEq()`
    and `addThrow()` functions, we can code this very easily:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除法的IR是在`visit(BinaryOp &)`方法中生成的。我们不仅需要生成一个`sdiv`指令，还必须生成一个IR来比较除数与`0`。如果除数为0，则控制流在基本块中继续，抛出异常。否则，控制流在带有`sdiv`指令的基本块中继续。借助`createICmpEq()`和`addThrow()`函数，我们可以非常容易地实现这一点：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The code generation part is now complete. To build the application, we must
    change into the build directory and run the `ninja` tool:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成部分现在已完成。要构建应用程序，我们必须切换到构建目录并运行`ninja`工具：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the build has finished, you can check the generated IR with the `with
    a:` `3/a` expression:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，你可以使用`with a:` `3/a`表达式来检查生成的IR：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will see the additional IR needed to raise and catch the exception.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到抛出和捕获异常所需的额外IR。
- en: 'The generated IR now depends on the C++ runtime. The easiest way to link against
    the required libraries is to use the `clang++` compiler. Rename the `rtcalc.c`
    file with the runtime functions for the expression calculator to `rtcalc.cpp`,
    and add `extern "C"` in front of each function inside the file. Then, use the
    `llc` tool to turn the generated IR into an object file, and the `clang++` compiler
    to create an executable:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的IR现在依赖于C++运行时。链接所需库的最简单方法是使用`clang++`编译器。将表达式计算器的运行时函数的`rtcalc.c`文件重命名为`rtcalc.cpp`，并在文件中的每个函数前添加`extern
    "C"`。然后，使用`llc`工具将生成的IR转换为对象文件，并使用`clang++`编译器创建可执行文件：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can run the generated application with different values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用不同的值运行生成的应用程序：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the second run, the input is `0`, and this raises the exception. It works
    as expected!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次运行中，输入是`0`，这会抛出异常。它按预期工作！
- en: In this section, we learned how to raise and catch exceptions. The code to generate
    the IR can be used as a blueprint for other compilers. Of course, the type information
    that’s used and the number of catch clauses depends on the input to the compiler,
    but the IR we need to generate still follows the pattern presented in this section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何抛出和捕获异常。生成IR的代码可以用作其他编译器的蓝图。当然，使用的类型信息和捕获子句的数量取决于编译器的输入，但我们需要生成的IR仍然遵循本节中展示的模式。
- en: Adding metadata is another way to provide further information to LLVM. In the
    next section, we’ll add type metadata to support the LLVM optimizer in certain
    situations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 添加元数据是向LLVM提供更多信息的另一种方式。在下一节中，我们将添加类型元数据以支持LLVM优化器在特定情况下的工作。
- en: Generating metadata for type-based alias analysis
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为基于类型的别名分析生成元数据
- en: Two pointers may point to the same memory cell, at which point they alias each
    other. Memory is not typed in the LLVM model, which makes it difficult for the
    optimizer to decide if two pointers alias each other or not. If the compiler can
    prove that two pointers do not alias each other, then more optimizations are possible.
    In the next section, we will have a closer look at the problem and investigate
    how adding additional metadata will help before we implement this approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个指针可能指向同一个内存单元，此时它们相互别名。在 LLVM 模型中，内存没有类型，这使得优化器难以决定两个指针是否相互别名。如果编译器可以证明两个指针不会相互别名，那么可以执行更多的优化。在下一节中，我们将更详细地研究这个问题，并在实现此方法之前探讨添加额外元数据如何有所帮助。
- en: Understanding the need for additional metadata
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解额外元数据的需求
- en: 'To demonstrate the problem, let’s look at the following function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示问题，让我们看看以下函数：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The optimizer cannot decide if the pointers, `p` and `q`, point to the same
    memory cell or not. During optimization, an important analysis can be performed
    called `p` and `q` point to the same memory cell, then they are aliases. Moreover,
    if the optimizer can prove that both pointers never alias each other, this enables
    additional optimization opportunities. For example, in the `doSomething()` function,
    the stores can be reordered without altering the result in this case.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器无法决定指针 `p` 和 `q` 是否指向同一个内存单元。在优化过程中，可以进行一个重要的分析，称为 `p` 和 `q` 指向同一个内存单元，那么它们是别名。此外，如果优化器可以证明这两个指针永远不会相互别名，这将使额外的优化机会成为可能。例如，在
    `doSomething()` 函数中，存储操作可以被重新排序，而不会改变结果。
- en: In addition, it depends on the definition of the source language if a variable
    of one type can be an alias of another variable of a different type. Please note
    that languages may also contain expressions that break the type-based alias assumption
    – for example, type casts between unrelated types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个类型的变量是否可以是另一个不同类型变量的别名，这取决于源语言的定义。请注意，语言也可能包含破坏基于类型的别名假设的表达式——例如，不同类型之间的类型转换。
- en: 'The solution chosen by the LLVM developers is to add metadata to the `load`
    and `store` instructions. The added metadata serves two purposes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 开发者选择的解决方案是在 `load` 和 `store` 指令中添加元数据。添加的元数据有两个目的：
- en: First, it defines the type hierarchy based on which type may alias another type
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它基于哪种类型可以别名另一种类型来定义类型层次结构
- en: Second, it describes the memory access in a `load` or `store` instruction
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它描述了 `load` 或 `store` 指令中的内存访问
- en: 'Let’s have a look at the type hierarchy in C. Each type of hierarchy starts
    with a root node, either **named** or **anonymous**. LLVM assumes that root nodes
    with the same name describe the same type of hierarchy. You can use different
    type hierarchies in the same LLVM modules, and LLVM makes the safe assumption
    that these types may alias. Beneath the root node, there are the nodes for scalar
    types. Nodes for aggregate types are not attached to the root node, but they refer
    to scalar types and other aggregate types. Clang defines the hierarchy for C as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 C 中的类型层次结构。每个类型层次结构都以一个根节点开始，无论是**命名**的还是**匿名**的。LLVM 假设具有相同名称的根节点描述了相同类型的层次结构。你可以在同一个
    LLVM 模块中使用不同的类型层次结构，LLVM 假设这些类型可能存在别名。在根节点之下，有标量类型的节点。聚合类型的节点不直接连接到根节点，但它们引用标量类型和其他聚合类型。Clang
    将 C 的层次结构定义为如下：
- en: The root node is called `Simple` `C/C++ TBAA`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点被称为 `Simple C/C++ TBAA`。
- en: Beneath the root node is the node for the `char` types. This is a special type
    in C because all pointers can be converted into a pointer to `char`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根节点之下是 `char` 类型的节点。这在 C 中是一个特殊类型，因为所有指针都可以转换为指向 `char` 的指针。
- en: Beneath the `char` node are the nodes for the other scalar types and a type
    for all pointers, called `any pointer`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `char` 节点之下是其他标量类型的节点以及所有指针的类型，称为 `any pointer`。
- en: In addition to this, aggregate types are defined as a sequence of member types
    and offsets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，聚合类型被定义为成员类型和偏移量的序列。
- en: 'These metadata definitions are used in access tags attached to the `load` and
    `store` instructions. An access tag is made up of three parts: a base type, an
    access type, and an offset. Depending on the base type, there are two possible
    ways the access tag describes memory access:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元数据定义用于附加到 `load` 和 `store` 指令的访问标签上。一个访问标签由三部分组成：一个基类型、一个访问类型和一个偏移量。根据基类型的不同，访问标签描述内存访问的方式有两种可能：
- en: If the base type is an aggregate type, then the access tag describes the memory
    access of a `struct` member with the necessary access type and is located at the
    given offset.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基类型是聚合类型，则访问标签描述了具有必要访问类型的 `struct` 成员的内存访问，并位于给定的偏移量处。
- en: If the base type is a scalar type, then the access type must be the same as
    the base type and the offset must be `0`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基类型是标量类型，则访问类型必须与基类型相同，偏移量必须为 `0`。
- en: 'With these definitions, we can now define a relation on the access tags, which
    is used to evaluate if two pointers may alias each other or not. Let’s take a
    closer look at the options for the immediate parent of a `(base type,` `offset)`
    tuple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，我们现在可以在访问标签上定义一个关系，该关系用于评估两个指针是否可能相互别名。让我们更仔细地看看 `(base type, offset)`
    元组的直接父节点的选项：
- en: If the base type is a scalar type and the offset is 0, then the immediate parent
    is `(parent type, 0)`, with the parent type being the type of the parent node,
    as defined in the type hierarchy. If the offset is not 0, then the immediate parent
    is undefined.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基类型是标量类型且偏移量为 0，则直接父节点是 `(父类型，0)`，其中父类型是父节点在类型层次结构中定义的类型。如果偏移量不为 0，则直接父节点未定义。
- en: If the base type is an aggregate type, then the immediate parent of the `(base
    type, offset)` tuple is the `(new type, new offset)` tuple, with the new type
    being the type of the member at offset. The new offset is the offset of the new
    type, adjusted to its new start.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基类型是聚合类型，则 `(base type, offset)` 元组的直接父节点是 `(new type, new offset)` 元组，其中新类型是偏移量处的成员的类型。新偏移量是新类型的偏移量，调整到其新的起始位置。
- en: The transitive closure of this relation is the parent relation. Two memory accesses,
    (base type 1, access type 1, offset 1) and (base type 2, access type 2, offset
    2), may alias one another if (base type 1, offset 1) and (base type 2, offset
    2) or vice versa are related in the parent relation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关系的传递闭包是父关系。两个内存访问，(基类型 1，访问类型 1，偏移量 1) 和 (基类型 2，访问类型 2，偏移量 2)，如果 (基类型 1，偏移量
    1) 和 (基类型 2，偏移量 2) 或反之在父关系中相关联，则它们可能相互别名。
- en: 'Let’s illustrate this with an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When using the memory access tag definition for scalar types, the access tag
    for the `i` parameter is (`int`, `int`, 0), while for the `c` parameter, it is
    (`char`, `char`, 0). In the type hierarchy, the parent of the node for the `int`
    type is the `char` node. Therefore, the immediate parent of (`int`, 0) is (`char`,
    0) and both pointers can alias. The same is true for the `x` and `c` parameters.
    However, the `x` and `i` parameters are not related, so they do not alias each
    other. The access for the `y` member of `struct Point` is (`Point`, `float`, 4),
    with 4 being the offset of the `y` member in the struct. The immediate parent
    of (`Point`, 4) is (`float`, 0), so the access to `p->y` and `x` may alias, and
    with the same reasoning also with the `c` parameter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用标量类型的内存访问标签定义时，`i` 参数的访问标签是 (`int`，`int`，0)，而 `c` 参数的访问标签是 (`char`，`char`，0)。在类型层次结构中，`int`
    类型节点的父节点是 `char` 节点。因此，(`int`，0) 的直接父节点是 (`char`，0)，并且两个指针可以别名。对于 `x` 和 `c` 参数也是如此。然而，`x`
    和 `i` 参数不相关，因此它们不会相互别名。`struct Point` 的 `y` 成员的访问是 (`Point`，`float`，4)，其中 4 是
    `y` 成员在结构体中的偏移量。(`Point`，4) 的直接父节点是 (`float`，0)，因此对 `p->y` 和 `x` 的访问可能别名，同样地，根据相同的推理，也与
    `c` 参数相关。
- en: Creating TBAA metadata in LLVM
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 LLVM 中创建 TBAA 元数据
- en: To create the metadata, we must use the `llvm::MDBuilder` class, which is declared
    in the `llvm/IR/MDBuilder.h` header file. The data itself is stored in instances
    of the `llvm::MDNode` and `llvm::MDString` classes. Using the builder class shields
    us from the internal details of the construction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建元数据，我们必须使用 `llvm::MDBuilder` 类，该类在 `llvm/IR/MDBuilder.h` 头文件中声明。数据本身存储在 `llvm::MDNode`
    和 `llvm::MDString` 类的实例中。使用构建器类可以保护我们免受构建内部细节的影响。
- en: A root node is created with a call to the `createTBAARoot()` method, which expects
    the name of the type hierarchy as a parameter and returns the root node. An anonymous,
    unique root node can be created with the `createAnonymousTBAARoot()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `createTBAARoot()` 方法创建一个根节点，该方法期望类型层次结构的名称作为参数并返回根节点。可以使用 `createAnonymousTBAARoot()`
    方法创建一个匿名、唯一的根节点。
- en: A scalar type is added to the hierarchy with the `createTBAAScalarTypeNode()`
    method, which takes the name of the type and the parent node as a parameter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `createTBAAScalarTypeNode()` 方法将标量类型添加到层次结构中，该方法接受类型名称和父节点作为参数。
- en: On the other hand, adding a type node for an aggregate type is slightly more
    complex. The `createTBAAStructTypeNode()` method takes the name of the type and
    a list of the fields as parameters. Specifically, the fields are given as a `std::pair<llvm::MDNode*,
    uint64_t>` instance, where the first element indicates the type of the member
    and the second element represents the offset in `struct`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为聚合类型添加类型节点稍微复杂一些。`createTBAAStructTypeNode()`方法接受类型名称和字段列表作为参数。具体来说，字段以`std::pair<llvm::MDNode*,
    uint64_t>`实例给出，其中第一个元素表示成员的类型，第二个元素表示在`struct`中的偏移量。
- en: An access tag is created with the `createTBAAStructTagNode()` method, which
    takes the base type, the access type, and the offset as parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createTBAAStructTagNode()`方法创建一个访问标签，该方法接受基类型、访问类型和偏移量作为参数。
- en: Lastly, the metadata must be attached to a `load` or `store` instruction. The
    `llvm::Instruction` class contains a method called `setMetadata()`, which is used
    to add various type-based alias analysis metadata. The first parameter must be
    of the `llvm::LLVMContext::MD_tbaa` type and the second must be the access tag.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，元数据必须附加到`load`或`store`指令。`llvm::Instruction`类包含一个名为`setMetadata()`的方法，用于添加基于类型的各种别名分析元数据。第一个参数必须是`llvm::LLVMContext::MD_tbaa`类型，第二个参数必须是访问标签。
- en: Equipped with this knowledge, we must add metadata for `tinylang`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们必须为`tinylang`添加元数据。
- en: Adding TBAA metadata to tinylang
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加TBAA元数据到tinylang
- en: To support TBAA, we must add a new `CGTBAA` class. This class is responsible
    for generating the metadata nodes. Furthermore, we make the `CGTBAA` class a member
    of the `CGModule` class, calling it `TBAA`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持TBAA，我们必须添加一个新的`CGTBAA`类。这个类负责生成元数据节点。此外，我们将`CGTBAA`类作为`CGModule`类的成员，命名为`TBAA`。
- en: 'Every load and store instruction must be annotated. A new function is created
    for this purpose in the `CGModule` class called `decorateInst()`. This function
    tries to create the tag access information. If this is successful, the metadata
    is attached to the respective load or store instruction. Moreover, this design
    also allows us to turn off the metadata generation process in case we do not need
    it, such as in builds with optimizations turned off:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载和存储指令都必须进行注释。在`CGModule`类中为此目的创建了一个新函数，称为`decorateInst()`。此函数尝试创建标签访问信息。如果成功，则将元数据附加到相应的加载或存储指令。此外，这种设计还允许我们在不需要时关闭元数据生成过程，例如在关闭优化的构建中：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We put the declaration of the new `CGTBAA` class in the `include/tinylang/CodeGen/CGTBAA.h`
    header file and the definition in the `lib/CodeGen/CGTBAA.cpp` file. Aside from
    the AST definitions, the header file needs to include the files for defining the
    metadata nodes and builder:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新`CGTBAA`类的声明放在`include/tinylang/CodeGen/CGTBAA.h`头文件中，定义放在`lib/CodeGen/CGTBAA.cpp`文件中。除了AST定义外，头文件还需要包含定义元数据节点和构建器的文件：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `CGTBAA` class needs to store some data members. So, let’s see how to do
    this step by step:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGTBAA`类需要存储一些数据成员。那么，让我们一步一步地看看如何做这个步骤：'
- en: 'First of all, we need to cache the root of the type hierarchy:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要缓存类型层次结构的根：
- en: '[PRE40]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To construct the metadata nodes, we need an instance of the `MDBuilder` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建元数据节点，我们需要`MDBuilder`类的一个实例：
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Lastly, we must store the metadata that’s been generated for a type for reuse:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须存储为类型生成的元数据以供重用：
- en: '[PRE42]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we’ve defined the variables that are required for the construction,
    we must add the methods that are required to create the metadata:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了构建所需变量，我们必须添加创建元数据所需的方法：
- en: 'The constructor initializes the data members:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化数据成员：
- en: '[PRE43]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We must lazily instantiate the root of the type hierarchy, which we name `Simple`
    `tinylang TBAA`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须延迟实例化类型层次结构的根，我们将其命名为`Simple` `tinylang TBAA`：
- en: '[PRE44]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For a scalar type, we must create a metadata node with the help of the `MDBuilder`
    class based on the name of the type. The new metadata node is stored in the cache:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于标量类型，我们必须使用基于类型的名称通过`MDBuilder`类创建一个元数据节点。新的元数据节点存储在缓存中：
- en: '[PRE45]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The method to create the metadata for a record is more complicated as we have
    to enumerate all the fields of the record. Similar to scalar types, the new metadata
    node is stored in the cache:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建记录元数据的方法更为复杂，因为我们必须枚举记录的所有字段。类似于标量类型，新的元数据节点存储在缓存中：
- en: '[PRE46]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To return the metadata for a `tinylang` type, we need to create the type hierarchy.
    Due to the type system of `tinylang` being very restricted, we can use a simple
    approach. Each scalar type is mapped to a unique type attached to the root node,
    and we map all pointers to a single type. Structured types then refer to these
    nodes. If we cannot map a type, then we return `nullptr`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了返回 `tinylang` 类型的元数据，我们需要创建类型层次结构。由于 `tinylang` 的类型系统非常受限，我们可以使用简单的方法。每个标量类型映射到一个与根节点附加的唯一类型，我们将所有指针映射到单个类型。结构化类型然后引用这些节点。如果我们无法映射类型，则返回
    `nullptr`：
- en: '[PRE47]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The general method to get the metadata is `getAccessTagInfo()`. To get the
    TBAA access tag information, a call to the `getTypeInfo()` function must be added.
    This function expects `TypeDeclaration` as its parameter, which is retrieved from
    the instructions we want to produce metadata for:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取元数据的一般方法是 `getAccessTagInfo()`。要获取 TBAA 访问标签信息，必须添加对 `getTypeInfo()` 函数的调用。该函数期望
    `TypeDeclaration` 作为其参数，该参数是从我们想要为生成元数据的指令中检索到的：
- en: '[PRE48]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, to enable the generation of TBAA metadata, we simply need to attach
    the metadata to all of the load and store instructions that we generate within
    `tinylang`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了启用 TBAA 元数据的生成，我们只需将元数据附加到我们在 `tinylang` 中生成的所有加载和存储指令上。
- en: 'For example, in `CGProcedure::writeVariable()`, a store to a global variable
    uses a store instruction:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `CGProcedure::writeVariable()` 中，对一个全局变量的存储使用了一个存储指令：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To decorate this particular instruction, we need to replace this line with
    the following lines, where `decorateInst()` adds the TBAA metadata to this store
    instruction:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了装饰这个特定的指令，我们需要将这一行替换为以下行，其中 `decorateInst()` 将 TBAA 元数据添加到这个存储指令中：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With these changes in place, we have finished generating the TBAA metadata.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，我们已经完成了 TBAA 元数据的生成。
- en: 'We can now compile a sample `tinylang` file into an LLVM intermediate representation
    to see our newly implemented TBAA metadata. For instance, consider the following
    file, `Person.mod`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将一个示例 `tinylang` 文件编译成 LLVM 中间表示，以查看我们新实现的 TBAA 元数据。例如，考虑以下文件，`Person.mod`：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `tinylang` compiler that is built in the build directory of this chapter
    can be used to generate the intermediate representation for this file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章构建目录中构建的 `tinylang` 编译器可以用来为该文件生成中间表示：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the newly generated `Person.ll` file, we can see that the store instruction
    is decorated with the TBAA metadata that we have generated within this chapter,
    where the metadata reflects the fields of the record type that was originally
    declared:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在新生成的 `Person.ll` 文件中，我们可以看到存储指令被装饰了我们本章内生成的 TBAA 元数据，其中元数据反映了最初声明的记录类型的字段：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have learned how to generate TBAA metadata, we will explore a very
    similar topic in the next section: generating debug metadata.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何生成 TBAA 元数据，我们将在下一节中探索一个非常类似的主题：生成调试元数据。
- en: Adding debug metadata
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加调试元数据
- en: To allow source-level debugging, we have to add debug information. Support for
    debug information in LLVM uses debug metadata to describe the types of the source
    language and other static information, and intrinsics to track variable values.
    The LLVM core libraries generate debug information in the *DWARF format on Unix
    systems* and in *PDB format for Windows*. We’ll look at the general structure
    in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许源级调试，我们必须添加调试信息。LLVM 对调试信息支持使用调试元数据来描述源语言类型和其他静态信息，以及内联函数来跟踪变量值。LLVM 核心库在
    Unix 系统上使用 *DWARF 格式* 生成调试信息，在 Windows 上使用 *PDB 格式*。我们将在下一节中查看一般结构。
- en: Understanding the general structure of debug metadata
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解调试元数据的一般结构
- en: To describe the general structure, LLVM uses metadata similar to the metadata
    for type-based analysis. The static structure describes the file, the compilation
    unit, functions and lexical blocks, and the used data types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述一般结构，LLVM 使用与基于类型的分析元数据相似的元数据。静态结构描述了文件、编译单元、函数和词法块，以及使用的数据类型。
- en: 'The main class we use is `llvm::DIBuilder`, and we need to use the `llvm/IR/DIBuilder`
    header file to get the class declaration. This builder class provides an easy-to-use
    interface to create the debug metadata. Later, the metadata is either added to
    LLVM objects such as global variables, or is used in calls to debug intrinsics.
    Here’s some important metadata that the builder class can create:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要使用的是 `llvm::DIBuilder` 类，我们需要使用 `llvm/IR/DIBuilder` 头文件来获取类声明。这个构建器类提供了一个易于使用的接口来创建调试元数据。稍后，这些元数据要么被添加到
    LLVM 对象（如全局变量）中，要么用于调用调试内嵌函数。以下是构建器类可以创建的一些重要元数据：
- en: '`llvm::DIFile`: This describes a file using the filename and the absolute path
    of the directory containing the file. You use the `createFile()` method to create
    it. A file can contain the main compilation unit or it could contain imported
    declarations.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::DIFile`：它使用文件名和包含该文件的目录的绝对路径来描述一个文件。您可以使用 `createFile()` 方法来创建它。一个文件可以包含主编译单元，也可以包含导入的声明。'
- en: '`llvm::DICompileUnit`: This is used to describe the current compilation unit.
    Among other things, you specify the source language, a compiler-specific producer
    string, whether optimizations are enabled or not, and, of course, `DIFile`, in
    which the compilation unit resides. You create it with a call to `createCompileUnit()`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::DICompileUnit`：它用于描述当前的编译单元。在众多其他信息中，您指定源语言、编译器特定的生产者字符串、是否启用优化，以及当然，`DIFile`，其中包含编译单元。您可以通过调用
    `createCompileUnit()` 来创建它。'
- en: '`llvm::DISubprogram`: This describes a function. The most important information
    here is the scope (usually `DICompileUnit` or `DISubprogram` for a nested function),
    the name of the function, the mangled name of the function, and the function type.
    It is created with a call to `createFunction()`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::DISubprogram`：它描述一个函数。这里最重要的信息是作用域（通常是嵌套函数的 `DICompileUnit` 或 `DISubprogram`），函数的名称、函数的混淆名称和函数类型。它通过调用
    `createFunction()` 来创建。'
- en: '`llvm::DILexicalBlock`: This describes a lexical block and models the block
    scoping found in many high-level languages. You can create this with a call to
    `createLexicalBlock()`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::DILexicalBlock`：它描述一个词法块，并模拟了许多高级语言中发现的块作用域。您可以通过调用 `createLexicalBlock()`
    来创建它。'
- en: 'LLVM makes no assumptions about the language your compiler translates. As a
    consequence, it has no information about the data types of the language. To support
    source-level debugging, especially displaying variable values in a debugger, type
    information must be added too. Here are some important constructs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 对你的编译器所翻译的语言没有任何假设。因此，它没有关于该语言数据类型的信息。为了支持源级调试，特别是显示调试器中的变量值，还必须添加类型信息。以下是一些重要的结构：
- en: The `createBasicType()` function, which returns a pointer to the `llvm::DIBasicType`
    class, creates the metadata to describe a basic type such as `INTEGER` in `tinylang`
    or `int` in C++. Besides the name of the type, the required parameters are the
    size in bits and the encoding – for example, if it is a signed or unsigned type.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createBasicType()` 函数，它返回指向 `llvm::DIBasicType` 类的指针，用于创建描述基本类型（如 `tinylang`
    中的 `INTEGER` 或 C++ 中的 `int`）的元数据。除了类型的名称外，所需的参数还包括位大小和编码——例如，如果是有符号或无符号类型。'
- en: There are several ways to construct the metadata for composite data types, as
    represented by the `llvm::DIComposite` class. You can use the `createArrayType()`,
    `createStructType()`, `createUnionType()`, and `createVectorType()` functions
    to instantiate the metadata for array, struct, union, and vector data types, respectively.
    These functions require the parameter you expect, such as the base type and the
    number of subscriptions for an array type or a list of the field members of a
    struct type.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造复合数据类型的元数据有几种方法，如 `llvm::DIComposite` 类所示。您可以使用 `createArrayType()`、`createStructType()`、`createUnionType()`
    和 `createVectorType()` 函数分别实例化数组、结构体、联合和向量数据类型的元数据。这些函数需要您预期的参数，例如数组类型的基类型和订阅数，或结构体类型的字段成员列表。
- en: There are also methods to support enumerations, templates, classes, and so on.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样存在支持枚举、模板、类等方法。
- en: 'The list of functions shows you that you have to add every detail of the source
    language to the debug information. Let’s assume your instance of the `llvm::DIBuilder`
    class is called `DBuilder`. Let’s also assume that you have some `tinylang` source
    in a file called `File.mod` in the `/home/llvmuser` folder. Inside this file is
    the `Func():INTEGER` function at *line 5*, which contains a local `VAR i:INTEGER`
    declaration at *line 7*. Let’s create the metadata for this, beginning with the
    information for the file. You need to specify the filename and the absolute path
    of the folder in which the file resides:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数列表显示你必须将源语言的每一个细节都添加到调试信息中。假设你的`llvm::DIBuilder`类实例称为`DBuilder`。假设你有一些`tinylang`源代码位于`/home/llvmuser`文件夹中的`File.mod`文件中。在这个文件中，第5行有一个`Func():INTEGER`函数，其中包含在第7行的局部`VAR
    i:INTEGER`声明。让我们为这个创建元数据，从文件的信息开始。你需要指定文件名和文件所在文件夹的绝对路径：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The file is a module in `tinylang`, which makes it the compilation unit for
    LLVM. This carries a lot of information:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件是`tinylang`中的一个模块，这使得它成为LLVM的编译单元。这包含了很多信息：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Furthermore, the debugger needs to know the source language. The DWARF standard
    defines an enumeration with all the common values. One disadvantage of this is
    that you cannot simply add a new source language. To do that, you have to create
    a request at the DWARF committee. Be aware that the debugger and other debug tools
    also need support for a new language – just adding a new member to the enumeration
    is not enough.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，调试器需要知道源语言。DWARF标准定义了一个包含所有常见值的枚举。其缺点之一是你不能简单地添加一个新的源语言。为此，你必须向DWARF委员会提出请求。请注意，调试器和其他调试工具也需要对新语言的支持——仅仅添加枚举的新成员是不够的。
- en: In many cases, it is sufficient to choose a language that is close to your source
    language. In the case of `tinylang`, this is Modula-2, and we use `DW_LANG_Modula2`
    as the language identifier. A compilation unit resides in a file, which is identified
    by the `DbgFile` variable we created previously. Additionally, the debug information
    can carry information about the producer, which can be the name of the compiler
    and version information. Here, we just pass the `tinylang` string. If you do not
    want to add this information, then you can simply use an empty string as a parameter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，选择一种接近你的源语言的语言就足够了。对于`tinylang`来说，这是Modula-2，我们使用`DW_LANG_Modula2`作为语言标识符。编译单元位于一个文件中，该文件由我们之前创建的`DbgFile`变量标识。此外，调试信息可以携带有关生产者的信息，这可以是编译器的名称和版本信息。在这里，我们只是传递了`tinylang`字符串。如果你不想添加这些信息，那么你可以简单地使用一个空字符串作为参数。
- en: The next set of information includes the `IsOptimized` flag, which should indicate
    if the compiler has turned optimization on or not. Usually, this flag is derived
    from the `–O` command-line switch. You can pass additional parameter settings
    to the debugger with the `CUFlags` parameter. This is not used here, and we pass
    an empty string. We also do not use Objective-C, so we pass `0` as the Objective-C
    runtime version.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个信息集包括`IsOptimized`标志，该标志应指示编译器是否已开启优化。通常，此标志是从`–O`命令行开关派生出来的。你可以通过`CUFlags`参数将额外的参数设置传递给调试器。这里我们不使用它，所以我们传递一个空字符串。我们也不使用Objective-C，所以我们传递`0`作为Objective-C运行时版本。
- en: Normally, debug information is embedded in the object file we are creating.
    If we want to write the debug information into a separate file, then the `SplitName`
    parameter must contain the name of this file. Otherwise, simply passing an empty
    string is sufficient. Finally, you can define the level of debug information that
    should be emitted. The default is full debug information, as indicated by the
    use of the `FullDebug` enum value, but you can also choose the `LineTablesOnly`
    value if you want to emit only line numbers, or the `NoDebug` value for no debug
    information at all. For the latter, it is better to not create debug information
    in the first place.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调试信息嵌入在我们创建的对象文件中。如果我们想将调试信息写入一个单独的文件，那么`SplitName`参数必须包含该文件的名称。否则，简单地传递一个空字符串就足够了。最后，你可以定义应该输出的调试信息的级别。默认情况下是完整的调试信息，如使用`FullDebug`枚举值所示，但你也可以选择`LineTablesOnly`值以仅输出行号，或者选择`NoDebug`值以完全不输出调试信息。对于后者，最好从一开始就不创建调试信息。
- en: 'Our minimalistic source only uses the `INTEGER` data type, which is a signed
    32-bit value. Creating the metadata for this type is straightforward:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最简源代码只使用了`INTEGER`数据类型，这是一个有符号的32位值。为这个类型创建元数据是直接的：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To create the debug metadata for the function, we have to create a type for
    the signature first, and then the metadata for the function itself. This is similar
    to the creation of IR for a function. The signature of the function is an array
    with all the types of parameters in source order and the return type of the function
    as the first element at index `0`. Usually, this array is constructed dynamically.
    In our case, we can also construct the metadata statically. This is useful for
    internal functions, such as for module initializing. Typically, the parameters
    of these functions are always known, and the compiler writer can hard-code them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数创建调试元数据，我们首先必须为签名创建一个类型，然后是函数本身的元数据。这与为函数创建IR的过程类似。函数的签名是一个数组，包含源顺序中所有参数的类型以及函数的返回类型作为索引`0`的第一个元素。通常，这个数组是动态构建的。在我们的例子中，我们也可以静态构建元数据。这对于内部函数很有用，例如用于模块初始化。通常，这些函数的参数总是已知的，编译器编写者可以将它们硬编码：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our function has the `INTEGER` return type and no further parameters, so the
    `DbgSigTy` array only contains the pointer to the metadata for this type. This
    static array is turned into a type array, which is then used to create the type
    for the function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个函数具有`INTEGER`返回类型，没有其他参数，因此`DbgSigTy`数组只包含此类型的元数据指针。这个静态数组被转换成一个类型数组，然后用于创建函数的类型。
- en: 'The function itself requires more data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身需要更多的数据：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A function belongs to a compilation unit, which in our case is stored in the
    `DbgCU` variable. We need to specify the name of the function in the source file,
    which is `Func`, and the mangled name is stored in the object file. This information
    helps the debugger locate the machine code of the function. The mangled name,
    based on the rules of `tinylang`, is `_t4File4Func`. We also have to specify the
    file that contains the function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数属于一个编译单元，在我们的例子中，它存储在`DbgCU`变量中。我们需要在源文件中指定函数的名称，它是`Func`，而混淆后的名称存储在目标文件中。这些信息有助于调试器定位函数的机器代码。根据`tinylang`的规则，混淆后的名称是`_t4File4Func`。我们还需要指定包含该函数的文件。
- en: 'This may sound surprising at first, but think of the include mechanism in C
    and C++: a function can be stored in a different file, which is then included
    with `#include` in the main compilation unit. Here, this is not the case and we
    use the same file as the one the compilation unit uses. Next, the line number
    of the function and the function type are passed. The line number of the function
    may not be the line number where the lexical scope of the function begins. In
    this case, you can specify a different `ScopeLine`. A function also has protection,
    which we specify here with the `FlagPrivate` value to indicate a private function.
    Other possible values for function protection are `FlagPublic` and `FlagProtected`,
    for public and protected functions, respectively.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始听起来令人惊讶，但想想C和C++中的包含机制：一个函数可以存储在不同的文件中，然后在主编译单元中使用`#include`包含它。在这里，情况并非如此，我们使用与编译单元相同的文件。接下来，传递函数的行号和函数类型。函数的行号可能不是函数词法作用域开始的行号。在这种情况下，你可以指定不同的`ScopeLine`。函数还有保护级别，我们使用`FlagPrivate`值来指定私有函数。函数保护的其它可能值是`FlagPublic`和`FlagProtected`，分别表示公共和受保护的函数。
- en: Besides the protection level, other flags can be specified here. For example,
    `FlagVirtual` indicates a virtual function and `FlagNoReturn` indicates that the
    function does not return to the caller. You can find the complete list of possible
    values in the LLVM include file – that is, `llvm/include/llvm/IR/DebugInfoFlags.def`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保护级别之外，还可以在此处指定其他标志。例如，`FlagVirtual`表示虚函数，而`FlagNoReturn`表示该函数不会返回给调用者。你可以在LLVM包含文件中找到可能的完整值列表——即`llvm/include/llvm/IR/DebugInfoFlags.def`。
- en: Lastly, flags specific to a function can be specified. The most commonly used
    flag is the `SPFlagLocalToUnit` value, which indicates that the function is local
    to this compilation unit. The `MainSubprogram` value is also used often, indicating
    that this function is the main function of the application. The LLVM include file
    mentioned previously also lists all possible values related to flags specific
    to functions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以指定特定于函数的标志。最常用的标志是`SPFlagLocalToUnit`值，它表示该函数是此编译单元的局部函数。`MainSubprogram`值也经常使用，表示该函数是应用程序的主函数。前面提到的LLVM包含文件还列出了所有与特定于函数的标志相关的可能值。
- en: So far, we have only created the metadata referring to static data. Variables
    are dynamic, so we’ll explore how to attach the static metadata to the IR code
    for accessing variables in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了指向静态数据的元数据。变量是动态的，所以我们将探讨如何在下一节中将静态元数据附加到IR代码以访问变量。
- en: Tracking variables and their values
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪变量及其值
- en: To be useful, the type metadata described in the previous section needs to be
    associated with variables of the source program. For a global variable, this is
    pretty easy. The `createGlobalVariableExpression()` function of the `llvm::DIBuilder`
    class creates the metadata to describe a global variable. This includes the name
    of the variable in the source, the mangled name, the source file, and so on. A
    global variable in LLVM IR is represented by an instance of the `GlobalVariable`
    class. This class has a method called `addDebugInfo()`, which associates the metadata
    node returned from `createGlobalVariableExpression()` with the global variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了变得有用，上一节中描述的类型元数据需要与源程序中的变量相关联。对于全局变量，这很简单。`llvm::DIBuilder`类的`createGlobalVariableExpression()`函数创建描述全局变量的元数据。这包括源变量名、混淆名、源文件等。在LLVM
    IR中，全局变量由`GlobalVariable`类的实例表示。这个类有一个名为`addDebugInfo()`的方法，它将`createGlobalVariableExpression()`返回的元数据节点与全局变量关联。
- en: For local variables, we need to take another approach. LLVM IR does not know
    of a class representing a local variable as it only knows about values. The solution
    the LLVM community has developed is to insert calls to intrinsic functions into
    the IR code of a function. An `llvm.dbg.declare` and `llvm.dbg.value`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部变量，我们需要采取另一种方法。LLVM IR不知道表示局部变量的类，因为它只知道值。LLVM社区开发的解决方案是在函数的IR代码中插入内建函数的调用。一个`llvm.dbg.declare`和一个`llvm.dbg.value`。
- en: The `llvm.dbg.declare` intrinsic provides information and is generated once
    by the frontend to declare a local variable. Essentially, this intrinsic describes
    the address of a local variable. During optimization, passes can replace this
    intrinsic with (possibly multiple) calls to `llvm.dbg.value` to preserve the debug
    information and to track the local source variables. After optimization, multiple
    calls to `llvm.dbg.declare` may be present as it is used to describe the program
    points where the local variables live within memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm.dbg.declare`内建函数提供信息，并且由前端生成一次，用于声明局部变量。本质上，这个内建函数描述了局部变量的地址。在优化过程中，传递可以替换这个内建函数为（可能多个）对`llvm.dbg.value`的调用，以保留调试信息并跟踪局部源变量。优化后，可能存在多个`llvm.dbg.declare`调用，因为它用于描述局部变量在内存中存在的程序点。'
- en: On the other hand, the `llvm.dbg.value` intrinsic is called whenever a local
    variable is set to a new value. This intrinsic describes the value of a local
    variable, not its address.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，每当局部变量被设置为新的值时，都会调用`llvm.dbg.value`内建函数。这个内建函数描述了局部变量的值，而不是其地址。
- en: How does all of this work? The LLVM IR representation and the programmatic creation
    via the `llvm::DIBuilder` class differ a bit, so we will look at both.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是如何工作的？LLVM IR表示和通过`llvm::DIBuilder`类的程序性创建略有不同，所以我们将查看两者。
- en: 'Continuing with our example from the previous section, we’ll allocate local
    storage for the `I` variable inside the `Func` function with the `alloca` instruction:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们上一节中的例子，我们将在`Func`函数内部使用`alloca`指令为`I`变量分配局部存储：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After that, we must add a call to the `llvm.dbg.declare` intrinsic:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们必须添加对`llvm.dbg.declare`内建函数的调用：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first parameter is the address to the local variable. The second parameter
    is the metadata describing the local variable, which is created by a call to either
    `createAutoVariable()` for a local variable or `createParameterVariable()` for
    a parameter of the `llvm::DIBuilder` class. Finally, the third parameter describes
    an address expression, which will be explained later.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是局部变量的地址。第二个参数是描述局部变量的元数据，它通过调用`createAutoVariable()`为局部变量或`createParameterVariable()`为`llvm::DIBuilder`类的参数创建。最后，第三个参数描述了一个地址表达式，稍后将会解释。
- en: 'Let’s implement the IR creation. You can allocate the storage for the local
    `@i` variable with a call to the `CreateAlloca()` method of the `llvm::IRBuilder<>`
    class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现IR的创建。你可以通过调用`llvm::IRBuilder<>`类的`CreateAlloca()`方法为局部`@i`变量分配存储：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `LLVMCtx` variable is the used context class, and `Builder` is the used
    instance of the `llvm::IRBuilder<>` class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`LLVMCtx`变量是使用的上下文类，`Builder`是`llvm::IRBuilder<>`类的使用实例。'
- en: 'A local variable also needs to be described by metadata:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量也需要由元数据来描述：
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using the values from the previous section, we can specify that the variable
    is part of the `DbgFunc` function, is called `i`, is defined in the `DbgFile`
    file at *line 7*, and is of the `DbgIntTy` type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中的值，我们可以指定变量是`DbgFunc`函数的一部分，被命名为`i`，在`DbgFile`文件的第*7*行定义，并且是`DbgIntTy`类型。
- en: 'Finally, we associate the debug metadata with the address of the variable using
    the `llvm.dbg.declare` intrinsic. Using `llvm::DIBuilder` shields you from all
    of the details of adding a call:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`llvm.dbg.declare`内省将调试元数据与变量的地址关联起来。使用`llvm::DIBuilder`可以让你免于添加调用的所有细节：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Again, we have to specify a source location for the variable. An instance of
    `llvm::DILocation` is a container that holds the line and column of a location
    associated with a scope. Furthermore, the `insertDeclare()` method adds the call
    to the intrinsic function of the LLVM IR. In terms of this function’s parameters,
    it requires the address of the variable, stored in `Val`, and the debug metadata
    for the variable, stored in `DbgValVar`. We also pass an empty address expression
    and the debug location we created previously. As with normal instructions, we
    need to specify into which basic block the call is inserted. If we specify a basic
    block, then the call is inserted at the end. Alternatively, we can specify an
    instruction, and the call is inserted before that instruction. We also have the
    pointer to the `alloca` instruction, which is the last instruction that we inserted
    into the underlying basic block. Therefore, we can use this basic block, and the
    call gets appended after the `alloca` instruction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们必须为变量指定一个源位置。`llvm::DILocation`的一个实例是一个容器，它包含与作用域关联的位置的行和列。此外，`insertDeclare()`方法将调用添加到LLVM
    IR的内省函数中。就这个函数的参数而言，它需要存储在`Val`中的变量的地址和存储在`DbgValVar`中的变量的调试元数据。我们还将传递一个空地址表达式和之前创建的调试位置。与正常指令一样，我们需要指定调用插入到哪个基本块中。如果我们指定一个基本块，那么调用将被插入到块的末尾。或者，我们可以指定一个指令，调用将被插入到该指令之前。我们还有`alloca`指令的指针，这是我们最后插入到基本块中的指令。因此，我们可以使用这个基本块，并且调用将在`alloca`指令之后附加。
- en: If the value of a local variable changes, then a call to `llvm.dbg.value` must
    be added to the IR to set the new value of a local variable. The `insertValue()`
    method of the `llvm::DIBuilder` class can be used to achieve this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果局部变量的值发生了变化，那么必须在IR中添加对`llvm.dbg.value`的调用以设置局部变量的新值。可以使用`llvm::DIBuilder`类的`insertValue()`方法来实现这一点。
- en: When we implemented the IR generation for functions, we used an advanced algorithm
    that mainly used values and avoided allocating storage for local variables. In
    terms of adding debug information, this only means that we use `llvm.dbg.value`
    much more often than you see it in clang-generated IR.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现函数的IR生成时，我们使用了一个高级算法，该算法主要使用值并避免为局部变量分配存储空间。在添加调试信息方面，这意味着我们比在clang生成的IR中更频繁地使用`llvm.dbg.value`。
- en: What can we do if the variable does not have dedicated storage space but is
    part of a larger, aggregate type? One of the situations where this can arise is
    with the use of nested functions. To implement access to the stack frame of the
    caller, you must collect all used variables in a structure and pass a pointer
    to this record to the called function. Inside the called function, you can refer
    to the variables of the caller as if they are local to the function. What is different
    is that these variables are now part of an aggregate.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量没有专门的存储空间，而是属于一个更大的聚合类型，我们该怎么办？这种情况可能出现在嵌套函数的使用中。为了实现对调用者栈帧的访问，你必须在一个结构中收集所有使用的变量，并将指向这个记录的指针传递给被调用函数。在被调用函数内部，你可以像引用局部变量一样引用调用者的变量。不同之处在于，这些变量现在成为了聚合的一部分。
- en: In the call to `llvm.dbg.declare`, you use an empty expression if the debug
    metadata describes the whole memory the first parameter is pointing to. However,
    if it only describes a part of the memory, then you need to add an expression
    indicating which part of the memory the metadata applies to.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`llvm.dbg.declare`的调用中，如果你使用调试元数据描述了第一个参数指向的整个内存，则使用一个空表达式。然而，如果它只描述内存的一部分，那么你需要添加一个表达式来指示元数据适用于内存的哪一部分。
- en: 'In the case of the nested frame, you need to calculate the offset in the frame.
    You need access to a `DataLayout` instance, which you can get from the LLVM module
    into which you are creating the IR code. If the `llvm::Module` instance is named
    `Mod`, and the variable holding the nested frame structure is named `Frame` and
    is of the `llvm::StructType` type, you can access the third member of the frame
    in the following manner. This access gives you the offset of the member:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套帧的情况下，你需要计算帧中的偏移量。你需要访问一个 `DataLayout` 实例，你可以从创建 IR 代码的 LLVM 模块中获取它。如果 `llvm::Module`
    实例命名为 `Mod`，并且持有嵌套帧结构的变量命名为 `Frame` 且为 `llvm::StructType` 类型，你可以以下方式访问帧的第三个成员。这种访问给你成员的偏移量：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Moreover, the expression is created from a sequence of operations. To access
    the third member of the frame, the debugger needs to add the offset to the base
    pointer. As an example, you need to create an array and this information like
    so:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，表达式是由一系列操作创建的。要访问帧的第三个成员，调试器需要将偏移量添加到基指针。例如，你需要创建一个数组以及类似的信息：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'From this array, you can create the expression that you must then pass to `llvm.dbg.declare`
    instead of the empty expression:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个数组中，你可以创建必须传递给 `llvm.dbg.declare` 的表达式，而不是空表达式：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It is important to note that you are not limited to this offset operation. DWARF
    knows many different operators, and you can create fairly complex expressions.
    You can find the complete list of operators in the LLVM include file, called `llvm/include/llvm/BinaryFormat/Dwarf.def`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你不仅限于这种偏移操作。DWARF 知道许多不同的运算符，你可以创建相当复杂的表达式。你可以在 LLVM 的包含文件中找到运算符的完整列表，该文件名为
    `llvm/include/llvm/BinaryFormat/Dwarf.def`。
- en: At this point, you can create debug information for variables. To enable the
    debugger to follow the control flow in the source, you also need to provide line
    number information. This is the topic of the next section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以为变量创建调试信息。为了使调试器能够跟踪源代码中的控制流，你还需要提供行号信息。这是下一节的主题。
- en: Adding line numbers
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加行号
- en: A debugger allows a programmer to step through an application line by line.
    For this, the debugger needs to know which machine instructions belong to which
    line in the source. LLVM allows adding a source location to each instruction.
    In the previous section, we created location information of the `llvm::DILocation`
    type. A debug location provides more information than just the line, column, and
    scope. If needed, the scope into which this line is inlined can be specified.
    It is also possible to indicate that this debug location belongs to implicit code
    – that is, code that the frontend has generated but is not in the source.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器允许程序员逐行执行应用程序。为此，调试器需要知道哪些机器指令属于源代码中的哪一行。LLVM 允许将源位置添加到每个指令。在上一个章节中，我们创建了
    `llvm::DILocation` 类型的位置信息。调试位置提供的信息比仅行、列和作用域更多。如果需要，可以指定此行内联的作用域。还可能指示此调试位置属于隐式代码——即前端生成的但不在源代码中的代码。
- en: Before this information can be attached to an instruction, we must wrap the
    debug location in a `llvm::DebugLoc` object. To do so, you must simply pass the
    location information obtained from the `llvm::DILocation` class to the `llvm::DebugLoc`
    constructor. With this wrapping, LLVM can track the location information. While
    the location in the source does not change, the generated machine code for a source-level
    statement or expression can be dropped during optimization. This encapsulation
    helps deal with these possible changes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此信息可以附加到指令之前，我们必须将调试位置包装在 `llvm::DebugLoc` 对象中。为此，你必须简单地将从 `llvm::DILocation`
    类获得的定位信息传递给 `llvm::DebugLoc` 构造函数。通过这种包装，LLVM 可以跟踪位置信息。虽然源代码中的位置没有改变，但在优化过程中，源级语句或表达式的生成机器代码可能会被丢弃。这种封装有助于处理这些可能的变化。
- en: Adding line number information mostly boils down to retrieving the line number
    information from the AST and adding it to the generated instructions. The `llvm::Instruction`
    class has the `setDebugLoc()` method, which attaches the location information
    to the instruction.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 添加行号信息主要归结为从抽象语法树（AST）中检索行号信息并将其添加到生成的指令中。`llvm::Instruction` 类具有 `setDebugLoc()`
    方法，该方法将位置信息附加到指令上。
- en: In the next section, we’ll learn how to generate debug information and add it
    to our `tinylang` compiler.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何生成调试信息并将其添加到我们的 `tinylang` 编译器中。
- en: Adding debug support to tinylang
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 tinylang 添加调试支持
- en: We encapsulate the generation of debug metadata in the new `CGDebugInfo` class.
    Additionally, we place the declaration in the `tinylang/CodeGen/CGDebugInfo.h`
    header file and the definition in the `tinylang/CodeGen/CGDebugInfo.cpp` file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调试元数据的生成封装在新的`CGDebugInfo`类中。此外，我们将声明放在`tinylang/CodeGen/CGDebugInfo.h`头文件中，定义放在`tinylang/CodeGen/CGDebugInfo.cpp`文件中。
- en: The `CGDebugInfo` class has five important members. We need a reference to the
    code generator for the module, `CGM`, because we need to convert types from AST
    representation into LLVM types. Of course, we also need an instance of the `llvm::DIBuilder`
    class called `Dbuilder`, as we did in the previous sections. A pointer to the
    instance of the compile unit is also needed; we store it in the `CU` member.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGDebugInfo`类有五个重要的成员。我们需要模块的代码生成器的引用，即`CGM`，因为我们需要将AST表示的类型转换为LLVM类型。当然，我们还需要一个名为`Dbuilder`的`llvm::DIBuilder`类的实例，就像我们在前面的章节中所做的那样。还需要一个指向编译单元实例的指针；我们将其存储在`CU`成员中。'
- en: 'To avoid having to create the debug metadata for types again, we must also
    add a map to cache this information. The member is called `TypeCache`. Finally,
    we need a way to manage the scope information, for which we must create a stack
    based on the `llvm::SmallVector<>` class called `ScopeStack`. Thus, we have the
    following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免再次为类型创建调试元数据，我们还必须添加一个映射来缓存这些信息。该成员称为`TypeCache`。最后，我们需要一种管理范围信息的方法，为此我们必须基于`llvm::SmallVector<>`类创建一个名为`ScopeStack`的栈。因此，我们有以下内容：
- en: '[PRE67]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following methods of the `CGDebugInfo` class make use of these members:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGDebugInfo`类的以下方法使用了这些成员：'
- en: 'First, we need to create the compile unit, which we do in the constructor.
    We also create the file containing the compile unit here. Later, we can refer
    to the file through the `CU` member. The code for the constructor is as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建编译单元，这在我们构造函数中完成。我们在这里也创建了包含编译单元的文件。稍后，我们可以通过`CU`成员来引用该文件。构造函数的代码如下：
- en: '[PRE68]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Often, we need to provide a line number. The line number can be derived from
    the source manager location, which is available in most AST nodes. The source
    manager can convert this into a line number:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们需要提供一个行号。行号可以从源管理器的位置推导出来，这在大多数AST节点中都是可用的。源管理器可以将此转换为行号：
- en: '[PRE69]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The information about a scope is held on a stack. We need methods to open and
    close a scope and retrieve the current scope. The compilation unit is the global
    scope, which we add automatically:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围的信息存储在栈上。我们需要方法来打开和关闭范围以及检索当前范围。编译单元是全局范围，我们自动添加：
- en: '[PRE70]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we must create a method for each category of type we need to transform.
    The `getPervasiveType()` method creates the debug metadata for basic types. Note
    the use of the encoding parameter, which declares the `INTEGER` type as a signed
    type and the `BOOLEAN` type encoded as a Boolean:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须为每个需要转换的类型类别创建一个方法。`getPervasiveType()`方法为基本类型创建调试元数据。注意使用编码参数，将`INTEGER`类型声明为有符号类型，将`BOOLEAN`类型编码为布尔值：
- en: '[PRE71]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the type name is simply renamed, then we must map this to a type definition.
    Here, we need to make use of the scope and line number information:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类型名称只是重命名，那么我们必须将其映射到类型定义。在这里，我们需要使用范围和行号信息：
- en: '[PRE72]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Creating the debug information for an array requires specifying the size and
    the alignment. We can retrieve this data from the `DataLayout` class. We also
    need to specify the index range of the array:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数组的调试信息需要指定大小和对齐。我们可以从`DataLayout`类中检索这些数据。我们还需要指定数组的索引范围：
- en: '[PRE73]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using all these single methods, we can create a central method to create the
    metadata for a type. This metadata is also responsible for caching the data:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有这些单个方法，我们可以创建一个中心方法来创建类型的元数据。这个元数据也负责缓存数据：
- en: '[PRE74]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We also need to add a method to emit metadata for global variables:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一个方法来生成全局变量的元数据：
- en: '[PRE75]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To emit the debug information for procedures, we need to create the metadata
    for the procedure type. For this, we need a list of the types of the parameter,
    with the return type being the first entry. If the procedure has no return type,
    then we must use an unspecified type; this is called `void`, similar to how it
    is in C. If a parameter is a reference, then we need to add the reference type;
    otherwise, we must add the type to the list:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成过程的调试信息，我们需要为过程类型创建元数据。为此，我们需要一个参数类型的列表，其中返回类型是第一个条目。如果过程没有返回类型，那么我们必须使用未指定的类型；这被称为`void`，类似于C语言中的用法。如果一个参数是引用类型，那么我们需要添加引用类型；否则，我们必须将类型添加到列表中：
- en: '[PRE76]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For the procedure itself, we can now create the debug information using the
    procedure type we created in the previous step. A procedure also opens a new scope,
    so we must push the procedure onto the scope stack. We must also associate the
    LLVM function object with the new debug information:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实际的过程本身，我们现在可以使用在上一步骤中创建的过程类型来创建调试信息。过程也打开了一个新的作用域，因此我们必须将过程推入作用域栈。我们还必须将
    LLVM 函数对象与新的调试信息关联起来：
- en: '[PRE77]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When the end of a procedure is reached, we must inform the builder to finish
    constructing the debug information for this procedure. We also need to remove
    the procedure from the scope stack:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当达到过程的末尾时，我们必须通知构建器完成此过程的调试信息构建。我们还需要从作用域栈中移除过程：
- en: '[PRE78]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Lastly, when we’ve finished adding the debug information, we need to implement
    the `finalize()` method on the builder. The generated debug information is then
    validated. This is an important step during development as it helps you find wrongly
    generated metadata:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们完成添加调试信息后，我们需要在构建器上实现 `finalize()` 方法。生成的调试信息随后被验证。这是开发过程中的一个重要步骤，因为它有助于你找到错误生成的元数据：
- en: '[PRE79]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Debug information should only be generated if the user requested it. This means
    that we will need a new command-line switch for this. We will add this to the
    file of the `CGModule` class, and we will also use it inside this class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调试信息只有在用户请求时才应生成。这意味着我们需要一个新的命令行开关来实现这一点。我们将将其添加到 `CGModule` 类的文件中，并且我们还将在这个类内部使用它：
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `-g` option can be used with the `tinylang` compiler to generate debug metadata.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项可以与 `tinylang` 编译器一起使用来生成调试元数据。'
- en: 'Furthermore, the `CGModule` class holds an instance of the `std::unique_ptr<CGDebugInfo>`
    class. The pointer is initialized in the constructor for setting the command-line
    switch:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CGModule` 类持有 `std::unique_ptr<CGDebugInfo>` 类的一个实例。该指针在构造函数中初始化，用于设置命令行开关：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the getter method defined in `CGModule.h`, we simply return the pointer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CGModule.h` 中定义的获取方法中，我们简单地返回指针：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The common pattern to generate the debug metadata is to retrieve the pointer
    and check if it is valid. For example, after creating a global variable, we can
    add the debug information like so:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 生成调试元数据的常见模式是检索指针并检查其是否有效。例如，在创建全局变量后，我们可以这样添加调试信息：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To add line number information, we need a conversion method called `getDebugLoc()`
    in the `CGDebugInfo` class, which turns the location information from the AST
    into the debug metadata:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加行号信息，我们需要在 `CGDebugInfo` 类中实现一个名为 `getDebugLoc()` 的转换方法，它将 AST 中的位置信息转换为调试元数据：
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Additionally, a utility function in the `CGModule` class can be called to add
    the line number information to an instruction:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CGModule` 类中的一个实用函数可以被调用来向指令添加行号信息：
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this way, you can add the debug information for your compiler.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你可以为你的编译器添加调试信息。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how throwing and catching exceptions work in LLVM
    and the IR you can generate to exploit this feature. To enhance the scope of IR,
    you learned how you can attach various metadata to instructions. Metadata for
    type-based alias analysis provides additional information to the LLVM optimizer
    and helps with certain optimizations to produce better machine code. Users always
    appreciate the possibility of using a source-level debugger, and by adding debug
    information to the IR code, you can implement this important feature of a compiler.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在 LLVM 和 IR 中抛出和捕获异常的工作原理，以及你可以生成以利用此功能的功能。为了扩展 IR 的范围，你学习了如何将各种元数据附加到指令上。基于类型的别名分析元数据为
    LLVM 优化器提供了额外的信息，并有助于某些优化以生成更好的机器代码。用户总是欣赏使用源级调试器的可能性，通过向 IR 代码添加调试信息，你可以实现编译器的重要功能。
- en: Optimizing the IR code is the core task of LLVM. In the next chapter, we will
    learn how the pass manager works and how we can influence the optimization pipeline
    the pass manager governs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 优化 IR 代码是 LLVM 的核心任务。在下一章中，我们将学习如何工作以及我们如何可以影响由它管理的优化管道。
