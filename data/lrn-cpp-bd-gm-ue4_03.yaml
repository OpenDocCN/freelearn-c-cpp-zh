- en: If, Else, and Switch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: If，Else和Switch
- en: In the previous chapter, we discussed the importance of memory and how it can
    be used to store data inside a computer. We spoke about how memory is reserved
    for your program using variables, and how we can include different types of information
    in our variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了内存的重要性以及如何将数据存储在计算机内部。我们谈到了如何使用变量为程序保留内存，并且我们可以在变量中包含不同类型的信息。
- en: 'In this chapter, we will talk about how to control the flow of our program
    and how we can change what code gets executed by branching the code using control
    flow statements. Here, we''ll discuss the different types of control flow, as
    follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何控制程序的流程以及如何通过控制流语句分支代码。在这里，我们将讨论不同类型的控制流，如下所示：
- en: '`If` statements'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`If`语句'
- en: How to check whether things are equal using the `==` operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`==`运算符检查事物是否相等
- en: '`else` statements'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`语句'
- en: How to test for inequalities (that is, how to check whether one number is greater
    or smaller than another using the `>`, `>=`, `<`, `<=`, and `!=` operators)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试不等式（即，如何使用`>`,`>=`,`<`,`<=`和`!=`运算符检查一个数字是否大于或小于另一个数字）
- en: Using logical operators (such as not (`!`), and (`&&`), or (`||`))
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑运算符（如非（`!`），和（`&&`），或（`||`））
- en: 'Branching in more than two ways:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支超过两种方式：
- en: The `else if` statement
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else if`语句'
- en: The `switch` statement
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: Our first example project with Unreal Engine
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个虚幻引擎示例项目
- en: Branching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支
- en: 'The computer code we wrote in [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory,* went in one direction: straight down. Sometimes, we might
    want to be able to skip parts of the code. We might want the code to be able to
    branch in more than one direction. Schematically, we can represent this in the
    following manner:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml)中编写的计算机代码只有一个方向：向下。有时，我们可能希望能够跳过代码的某些部分。我们可能希望代码能够分支到多个方向。从图表上看，我们可以这样表示：
- en: '![](img/c1178346-f65b-44e1-84a2-c7030d6be946.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1178346-f65b-44e1-84a2-c7030d6be946.png)'
- en: In other words, we want the option to not run certain lines of code under certain
    conditions. The preceding diagram is called a flowchart. According to this flowchart,
    if, and only if, we are hungry then we will go prepare a sandwich, eat it, and
    then go and rest on the couch. If we are not hungry, then there is no need to
    make a sandwich, so we will simply rest on the couch.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望在特定条件下有选择地不运行某些代码行。上面的图表称为流程图。根据这个流程图，只有当我们饿了，我们才会准备三明治，吃完后就去休息。如果我们不饿，那么就不需要做三明治，我们会直接休息。
- en: We'll only use flowcharts in this book sometimes, but in UE4, you can even use
    flowcharts to program your game (using something called blueprints).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们有时会使用流程图，但在UE4中，您甚至可以使用流程图来编写游戏（使用称为蓝图的东西）。
- en: This book is about C++ code, so we will always transform our flowcharts into
    actual C++ code in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于C++代码的，因此在本书中，我们将始终将我们的流程图转换为实际的C++代码。
- en: Controlling the flow of your program
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制程序的流程
- en: Ultimately, what we want is the code to branch in one way under certain conditions.
    Code commands that change which line of code gets executed next are called control
    flow statements. The most basic control flow statement is the `if` statement.
    To be able to code `if` statements, we first need a way to check the value of
    a variable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望代码在特定条件下以一种方式分支。更改下一行执行的代码的代码命令称为控制流语句。最基本的控制流语句是`if`语句。为了能够编写`if`语句，我们首先需要一种检查变量值的方法。
- en: So, to start, let's introduce the `==` symbol, which is used to check the value
    of a variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们介绍`==`符号，用于检查变量的值。
- en: The == operator
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ==运算符
- en: 'In order to check whether two things are equal in C++, we need to use not one
    but two equal signs (`==`) one after the other, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在C++中检查两个事物是否相等，我们需要使用两个等号（`==`）而不是一个，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the preceding code, you will notice that the output is the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，您会注意到输出如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In C++, `1` means true and `0` means false. If you want the words `true` or
    `false` to appear instead of `1` and `0`, you can use the `boolalpha` stream manipulator
    in the `cout` line of code, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`1`表示`true`，`0`表示`false`。如果您希望在`1`和`0`之外显示`true`或`false`，可以在`cout`代码行中使用`boolalpha`流操纵器，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `==` operator is a type of comparison operator. The reason why C++ uses
    `==` to check for equality and not just `=` is that we already used up the `=`
    symbol for the assignment operator! (see the *More on variables* section in [Chapter
    2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml), *Variables and Memory*). If we
    use a single `=` sign, C++ will assume that we want to overwrite `x` with `y`,
    not compare them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符是一种比较运算符。C++使用`==`来检查相等性的原因是，我们已经使用了`=`符号作为赋值运算符！（请参阅[第2章](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml)中的*关于变量的更多信息*部分）。如果使用单个`=`符号，C++将假定我们要用`y`覆盖`x`，而不是比较它们。'
- en: Coding if statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写if语句
- en: 'Now that we have the double equals sign under our belt, let''s code the flowchart.
    The code for the preceding flowchart diagram is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们掌握了双等号，让我们编写流程图。上述流程图的代码如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the first time we are using a `bool` variable! A `bool` variable either
    holds the value `true` or the value `false`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次使用`bool`变量！`bool`变量可以保存值`true`或值`false`。
- en: First, we start with a `bool` variable called `isHungry` and just set it to
    `true`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个名为`isHungry`的`bool`变量开始，然后将其设置为`true`。
- en: 'Then, we use an `if` statement, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`if`语句，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `if` statement acts like a guard on the block of code below it (remember
    that a block of code is a group of code encased within `{` and `}`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句就像是守卫下面的代码块（记住，代码块是在`{`和`}`中的一组代码）：'
- en: '![](img/31a956f9-de7e-4848-b059-20dade64db0d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31a956f9-de7e-4848-b059-20dade64db0d.png)'
- en: You can only read the code between `{` and `}` if `isHungry==true`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`isHungry==true`时，您才能阅读`{`和`}`之间的代码。
- en: You can only get at the code inside the curly braces when `isHungry == true`.
    Otherwise, you will be denied access and forced to skip over that entire block
    of code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`isHungry==true`时，您才能访问大括号内的代码。否则，您将被拒绝访问并被迫跳过整个代码块。
- en: 'Basically, anything that can be evaluated as a boolean can go inside `if (boolean)`.
    So, we can achieve the same effect by simply writing the following line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，任何可以作为布尔值进行评估的东西都可以放在`if（boolean）`中。因此，我们可以通过简单地编写以下代码行来实现相同的效果：
- en: '`if( isHungry ) // only go here if isHungry is true` This can be used as an
    alternative for the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`if（isHungry）//只有在isHungry为true时才会到这里`这可以用作以下内容的替代：'
- en: '`if( isHungry == true )`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`if（isHungry==true）`'
- en: 'The reason people might use the `if( isHungry )` form is to avoid the possibility
    of making mistakes. Writing `if( isHungry = true )` by accident will set `isHungry`
    to true every time the `if` statement is hit! To avoid this possibility, we can
    just write `if( isHungry )` instead. Alternatively, some (wise) people use what
    are called Yoda conditions to check an `if` statement: `if( true == isHungry )`.
    The reason we write the `if` statement in this way is that, if we accidentally
    write `if( true = isHungry )`, this will generate a compiler error, catching the
    mistake.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能使用`if（isHungry）`形式的原因是为了避免出错的可能性。意外写成`if（isHungry = true）`会使`isHungry`在每次命中`if`语句时都设置为true！为了避免这种可能性，我们可以只写`if（isHungry）`。或者，一些（明智的）人使用所谓的Yoda条件来检查`if`语句：`if（true
    == isHungry）`。我们以这种方式编写`if`语句的原因是，如果我们意外地写成`if（true = isHungry）`，这将生成编译器错误，捕捉错误。
- en: 'Try running this code segment to see what I mean:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行此代码段以查看我的意思：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following lines show the output of the preceding lines of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了前面代码的输出：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The line of code that has `(x = y)` overwrites the previous value of `x` (which
    was 4) with the value of `y` (which is 5). Although we were trying to check whether
    `x` equals `y`, what happened in the previous statement was that `x` was assigned
    the value of `y`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`(x = y)`的代码行会覆盖`x`的先前值（为4）并用`y`的值（为5）进行赋值。尽管我们试图检查`x`是否等于`y`，但在先前的语句中发生的是`x`被赋予了`y`的值。
- en: Coding else statements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写else语句
- en: The `else` statement is used to have our code do something in the case that
    the `if` portion of the code does not run.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句用于在`if`部分的代码未运行时执行我们的代码。'
- en: 'For example, say we have something else that we''d like to do in case we are
    not hungry, as shown in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们还有其他事情要做，以防我们不饿，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are a few important things that you need to remember about the `else`
    keyword, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件重要的事情您需要记住关于`else`关键字，如下所示：
- en: An `else` statement must always immediately follow after an `if` statement.
    You can't have any extra lines of code between the end of the `if` block and the
    corresponding `else` block.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`语句必须紧随`if`语句之后。在`if`块结束和相应的`else`块之间不能有任何额外的代码行。'
- en: 'A program can never execute both the `if` and the corresponding `else` block.
    It''s always one or the other:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序永远不会同时执行`if`和相应的`else`块。它总是一个或另一个：
- en: '![](img/3676e502-fcb4-404c-b163-9fc5bb354f97.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3676e502-fcb4-404c-b163-9fc5bb354f97.png)'
- en: The else statement is the way you will go if `isHungry` is not equal to true.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `isHungry` 不等于true，则`else`语句是您将要执行的方式。
- en: You can think of the `if`/`else` statements as a guard diverting people to either
    the left or the right. Each person will either go toward the food (when `isHungry==true`),
    or they will go away from the food (when `isHungry==false`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`if`/`else`语句视为将人们引导到左侧或右侧的守卫。每个人都会朝着食物走（当`isHungry==true`时），或者他们会远离食物（当`isHungry==false`时）。
- en: Testing for inequalities using other comparison operators (>, >=, <, <=, and
    !=)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他比较运算符（>，>=，<，<=和!=）进行不等式测试
- en: 'Other logical comparisons can be easily done in C++. The `>` and `<` symbols
    mean just what they do in math. They are the greater than (`>`) and less than
    (`<`) symbols. `>=` has the same meaning as the `≥` symbol in math. `<=` is the
    C++ code for `≤`. Since there isn''t a `≤` symbol on the keyboard, we have to
    write it using two characters in C++. `!=` is how we say *"not equal to"* in C++.
    So, for example, say we have the following lines of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C++中可以很容易地进行其他逻辑比较。 `>` 和 `<` 符号的意思与数学中一样。它们分别表示大于（`>`）和小于（`<`）。`>=` 在数学中与 `≥`
    符号具有相同的含义。`<=` 是C++中 `≤` 的代码。由于键盘上没有 `≤` 符号，我们必须在C++中使用两个字符来编写它。`!=` 是C++中表示“不等于”的方式。因此，例如，假设我们有以下代码行：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can ask the computer whether `x > y` or `x < y`, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以询问计算机是否 `x > y` 或 `x < y`，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need the brackets around the comparisons of `x` and `y` because of something
    known as operator precedence. If we don't have the brackets, C++ will get confused
    between the `<<` and `<` operators. It's weird and you will better understand
    this later, but you need C++ to evaluate the `(x < y)` comparison before you output
    the result (<<). There is an excellent table available for reference at [http://en.cppreference.com/w/cpp/language/operator_precedence](http://en.cppreference.com/w/cpp/language/operator_precedence).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在比较`x`和`y`时加上括号，因为有一个称为运算符优先级的东西。如果没有括号，C++将在`<<`和`<`运算符之间感到困惑。这很奇怪，您稍后会更好地理解这一点，但您需要C++在输出结果（<<）之前评估`(x
    < y)`比较。有一个很好的可供参考的表格，网址为[http://en.cppreference.com/w/cpp/language/operator_precedence](http://en.cppreference.com/w/cpp/language/operator_precedence)。
- en: Using logical operators
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑运算符
- en: 'Logical operators allow you to do more complex checks, rather than checking
    for a simple equality or inequality. Say, for example, the condition to gain entry
    into a special room requires the player to have both the red and green keycards.
    We want to check whether two conditions hold true at the same time. To do this
    type of complex logic statement check there are three additional constructs that
    we need to learn: the not (`!`), and (`&&`), and or (`||`) operators.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符允许您进行更复杂的检查，而不仅仅是检查简单的相等或不相等。例如，要获得进入特殊房间的条件需要玩家同时拥有红色和绿色钥匙卡。我们想要检查两个条件是否同时成立。为了进行这种复杂的逻辑语句检查，我们需要学习三个额外的构造：非(`!`)、和(`&&`)和或(`||`)运算符。
- en: The not (!) operator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非(!)运算符
- en: 'The `!` operator is handy to reverse the value of a `boolean` variable. Take
    the example of the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符很方便，可以颠倒`boolean`变量的值。以以下代码为例：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `if` statement here checks whether or not you are wearing socks. Then, you
    are issued a command to get some socks on. The `!` operator reverses the value
    of whatever is in the `boolean` variable to be the opposite value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`if`语句检查您是否穿袜子。然后，您会收到一个命令来穿上一些袜子。`!`运算符将`boolean`变量中的值取反。
- en: 'We use something called a truth table to show all the possible results of using
    the `!` operator on a `boolean` variable, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个称为真值表的东西来显示在`boolean`变量上使用`!`运算符的所有可能结果，如下所示：
- en: '| `wearingSocks` | `!wearingSocks` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `wearingSocks` | `!wearingSocks` |'
- en: '| `true` | `false` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `false` |'
- en: '| `false` | `true` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `false` | `true` |'
- en: So, when `wearingSocks` has the value `true`, `!wearingSocks` has the value
    `false` and vice versa.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`wearingSocks`的值为`true`时，`!wearingSocks`的值为`false`，反之亦然。
- en: Exercises
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What do you think will be the value of `!!wearingSocks` when the value of `wearingSocks`
    is `true`?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`wearingSocks`的值为`true`时，您认为`!!wearingSocks`的值将是多少？
- en: What is the value of `isVisible` after the following code is run?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行以下代码后，`isVisible`的值是多少？
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Solutions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: If `wearingSocks` is `true`, then `!wearingSocks` is `false`. Therefore, `!!wearingSocks`
    becomes `true` again. It's like saying "I am not not hungry." Not not is a double
    negative, so this sentence means that I am actually hungry.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`wearingSocks`是`true`，那么`!wearingSocks`就是`false`。因此，`!!wearingSocks`再次变为`true`。这就像在说“我不饿”。双重否定，所以这句话意味着我实际上是饿了。
- en: The answer to the second question is `false`. The value of `hidden` was `true`,
    so `!hidden` is `false`. The `false` value then gets saved into the `isVisible`
    variable. But the value of `hidden` itself remains `true`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个问题的答案是`false`。`hidden`的值是`true`，所以`!hidden`是`false`。然后`false`的值被保存到`isVisible`变量中。但`hidden`本身的值仍然是`true`。
- en: The `!` operator is sometimes colloquially known as a bang. The preceding bang-bang
    operation (`!!`) is a double negative and a double logical inversion. If you bang-bang
    a `bool` variable, there is no net change to the variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符有时在口语中被称为感叹号。前面的双重感叹号操作(`!!`)是双重否定和双重逻辑反转。如果您对`bool`变量进行双重否定，那么变量不会有任何变化。'
- en: Of course, you can use these on an `int` and in that case, if the `int` is set
    to zero, `! int` will be `true`, and if it is greater than zero, `! int` will
    be `false`. Therefore, if you bang-bang that `int` variable, and the `int` value
    is greater than zero, it is reduced to a simple `true`. If the `int` value is
    0 already, it is reduced to a simple `false`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在`int`上使用这些，如果`int`设置为零，`! int`将是`true`，如果大于零，`! int`将是`false`。因此，如果您对该`int`变量进行双重否定，且`int`值大于零，则它将简化为`true`。如果`int`值已经是0，则它将简化为`false`。
- en: The and (&&) operator
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和(&&)运算符
- en: 'Say we only want to run a section of the code if two conditions are `true`.
    For example, we are only dressed if we are wearing both socks and clothes. You
    can use the following code to check this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想在两个条件都为`true`时运行代码的一部分。例如，只有在我们穿袜子和衣服时才算穿好衣服。您可以使用以下代码来检查：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The or (||) operator
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或(||)运算符
- en: We sometimes want to run a section of the code if either one of the variables
    is `true`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在变量中的任一个为`true`时运行代码的一部分。
- en: 'So, for example, say the player wins a certain bonus if they find either a
    special star in the level or the time that they take to complete the level is
    less than 60 seconds. In this case, you can use the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设玩家在关卡中找到特殊星星或完成关卡所需的时间少于60秒时，可以获得特定的奖励。在这种情况下，您可以使用以下代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may notice that I added parentheses around `levelCompleteTime < maxTimeForBonus`.
    While precedence rules may let you add longer statements without them, I've found
    it can be better to just add them if you have any doubt. It's better safe than
    sorry (and may be a little clearer to someone else looking at it later).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我在`levelCompleteTime < maxTimeForBonus`周围添加了括号。尽管优先级规则可能让您在没有它们的情况下添加更长的语句，但我发现如果有任何疑问，最好还是添加它们。小心总比后悔好（对于稍后查看的其他人来说可能更清晰）。
- en: Exercise
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: By now, you should have noticed that the best way to get better at programming
    is by doing it. You have to practice programming a lot to get significantly better
    at it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经注意到提高编程能力的最佳方法是通过实践。您必须经常练习编程才能显著提高。
- en: Create two integer variables, called `x` and `y`, and read them in from the
    user. Write an `if`/`else` statement pair that prints the name of the bigger-valued
    variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个整数变量，称为`x`和`y`，并从用户那里读取它们。编写一个`if`/`else`语句对，打印出值较大的变量的名称。
- en: Solution
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution to the preceding exercise is shown in the following block of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个练习的解决方案如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't type a letter when `cin` expects a number. If that happens, `cin` can
    fail and give a bad value to your variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cin`期望一个数字时不要输入字母。如果发生这种情况，`cin`可能会失败，并给您的变量一个错误的值。
- en: Branching code in more than two ways
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以两种以上的方式分支代码
- en: 'In the previous sections, we were only able to make the code branch in one
    of the two ways. In pseudocode, we had the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，我们只能使代码在两种方式中的一种分支。在伪代码中，我们有以下代码：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pseudocode is *fake code*. Writing pseudocode is a great way to brainstorm and
    plan out your code, especially if you are not quite used to C++.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码是*假代码*。编写伪代码是一种很好的头脑风暴和计划代码的方法，特别是如果你还不太习惯C++的话。
- en: This code is a little bit like a metaphorical fork in the road, with only one
    of two directions to choose from.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点像是在一个象征性的岔路口，只有两个方向可选。
- en: 'Sometimes, we might want to branch the code in more than just two directions.
    We might want the code to branch in three ways, or even more. For example, say
    the direction in which the code goes depends on what item the player is currently
    holding. The player can be holding one of three different items: a coin, key,
    or sand dollar. And C++ allows that! In fact, in C++, you can branch in any number
    of directions that you wish.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望代码分支不仅仅有两个方向。我们可能希望代码以三种方式或更多方式分支。例如，假设代码的走向取决于玩家当前持有的物品。玩家可以持有三种不同的物品：硬币、钥匙或沙元。C++允许这样做！事实上，在C++中，你可以按照任意你希望的方向进行分支。
- en: The else if statement
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`else if`语句'
- en: 'The `else if` statement is a way to code in more than just two possible branch
    directions. In the following code example, the code will go in one of the three
    different ways, depending on whether the player is holding the `Coin`, `Key`,
    or `Sanddollar` object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if`语句是一种编写超过两个可能分支方向的方法。在下面的代码示例中，代码将根据玩家持有的`Coin`、`Key`或`Sanddollar`对象的不同方式进行运行：'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the preceding code only goes in one of the three separate ways! In
    an `if`, `else`, and `else if` series of checks, we will only ever go into one
    of the blocks of code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码只会按三种不同的方式之一进行！在`if`、`else`和`else if`系列检查中，我们只会进入一个代码块。
- en: '![](img/ee886ad0-ece1-421b-a109-35e91255f97f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee886ad0-ece1-421b-a109-35e91255f97f.png)'
- en: Exercise
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use a C++ program to answer the questions that follow the code. Be sure to
    try these exercises in order to gain fluency with these equality operators:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++程序回答代码后面的问题。一定要尝试这些练习，以便熟练掌握这些相等运算符：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write some new lines of code at the spot that says (`// *** Write new...`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在标有(`// *** Write new...`)的位置写一些新的代码行：
- en: Check whether `x` and `y` are equal. If they are equal, print `x and y are equal`.
    Otherwise, print `x and y are not equal`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`x`和`y`是否相等。如果它们相等，打印`x and y are equal`。否则，打印`x and y are not equal`。
- en: 'An exercise on inequalities: check whether `x` is greater than `y`. If it is,
    print `x is greater than y`. Otherwise, print `y is greater than x`.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个关于不等式的练习：检查`x`是否大于`y`。如果是，打印`x is greater than y`。否则，打印`y is greater than
    x`。
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To evaluate equality, insert the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估相等性，请插入以下代码：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To check which value is greater, insert the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查哪个值更大，请插入以下代码：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The switch statement
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: The `switch` statement allows your code to branch in multiple ways. What the
    `switch` statement will do is look at the value of a variable, and depending on
    its value, the code will go in a different direction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句允许你的代码以多种方式分支。`switch`语句将查看变量的值，并根据其值，代码将走向不同的方向。'
- en: 'We''ll also see the `enum` construct here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会在这里看到`enum`构造：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Switches are like coin sorters. When you drop a 25-cent coin into a coin sorter,
    it finds its way into the 25-cent coin pile. Similarly, a `switch` statement will
    simply allow the code to jump down to the appropriate section. The example of
    sorting coins is shown in the following diagram:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`就像硬币分类器。当你把25美分硬币放入硬币分类器时，它会自动进入25美分硬币堆。同样，`switch`语句将允许代码跳转到适当的部分。硬币分类的示例显示在下图中：'
- en: '![](img/d32684e2-0719-4159-af5b-c8cf73d1773d.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d32684e2-0719-4159-af5b-c8cf73d1773d.png)'
- en: 'The code inside the `switch` statement will continue to run (line by line)
    until the `break;` statement is hit. The `break` statement jumps you out of the
    `switch` statement. If you leave out the `break;` statements, it will continue
    to run the code inside the next case statement and won''t stop until it either
    hits a `break;` or the end of the `switch`. If you want to experiment, try taking
    out all the `break;` statements and see what happens! Take a look at the following
    diagram to understand how the `switch` works:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句内的代码将继续运行（逐行），直到遇到`break;`语句。`break`语句会跳出`switch`语句。如果省略`break;`语句，它将继续运行下一个case语句内的代码，并且直到遇到`break;`或者`switch`结束才会停止。如果你想尝试，可以尝试去掉所有的`break;`语句，看看会发生什么！看一下下面的图表，了解`switch`的工作原理：'
- en: '![](img/313c6aed-604d-4a6d-a39f-ab1684cd5561.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/313c6aed-604d-4a6d-a39f-ab1684cd5561.png)'
- en: First, the `Food` variable is inspected. What value does it have? In this case,
    it has `Fish` inside it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先检查`Food`变量。它有什么值？在这种情况下，它里面有`Fish`。
- en: The `switch` command jumps down to the correct case label. (If there is no matching
    case label, `switch` will just be skipped).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`命令跳转到正确的case标签。（如果没有匹配的case标签，`switch`将被跳过）。'
- en: The `cout` statement is run, and `Here fishy fishy fishy` appears on the console.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cout`语句被执行，控制台上出现`Here fishy fishy fishy`。'
- en: After inspecting the variable and printing the user response, the `break` statement
    is hit. This makes us stop running lines of code in the `switch` and exit the
    `switch`. The next line of code that is run is just what would otherwise have
    been the next line of code in the program if the `switch` had not been there at
    all (after the closing curly brace of the `switch` statement). It is the `return
    0` that exits the program.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查变量并打印用户响应后，`break`语句被执行。这使我们停止运行`switch`中的代码行，并退出`switch`。接下来要运行的代码行就是如果`switch`根本不存在的话，否则将是程序中的下一行代码（在`switch`语句的结束大括号之后）。是`return
    0`退出程序。
- en: The switch statement versus the if statement
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`语句与`if`语句'
- en: Switches are like the `if` / `else if` / `else` chains from earlier. However,
    switches can generate code faster than `if` / `else if` / `else if` / `else` chains.
    Intuitively, switches only jump to the appropriate section of the code to execute.
    An `if` / `else if` / `else` chain might involve more complicated comparisons
    (including logical comparisons), which might take more CPU time. The main reason
    you will use `if` statements is if you are trying to check something that's more
    complicated than just comparing something in a specific set of values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开关类似于之前的`if` / `else if` / `else`链。但是，开关可以比`if` / `else if` / `else if` / `else`链更快地生成代码。直观地说，开关只会跳转到适当的代码部分以执行。`if`
    / `else if` / `else`链可能涉及更复杂的比较（包括逻辑比较），这可能需要更多的CPU时间。您将使用`if`语句的主要原因是，如果您要检查的内容比仅比较特定值集合中的内容更复杂。
- en: 'An instance of an `enum` is really an `int`. To verify this, print the following
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`的一个实例实际上是一个`int`。要验证这一点，请打印以下代码：'
- en: '`cout << "Fish=" << Fish <<'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`cout << "Fish=" << Fish <<'
- en: '" Bread=" << Bread <<'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '" Bread=" << Bread <<'
- en: '" Apple=" << Apple <<`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '" Apple=" << Apple <<`'
- en: '` "Orange=" << Orange << endl;`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '` "Orange=" << Orange << endl;`'
- en: You will see the integer values of the `enum`—just so you know.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`enum`的整数值-只是让您知道。
- en: 'Sometimes, programmers want to group multiple values under the same switch
    `case` label. Say we have an `enum` object as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员希望在相同的开关`case`标签下分组多个值。假设我们有一个如下所示的`enum`对象：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A programmer wants to group all the greens together, so they write a `switch`
    statement as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员希望将所有绿色物品分组在一起，因此他们编写了一个如下所示的`switch`语句：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, `Zucchini` falls through and executes the same code as `Broccoli`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Zucchini`会掉下来并执行与`Broccoli`相同的代码。
- en: The non-green vegetables are in the `default` case label. To prevent a fall-through,
    you have to remember to insert an explicit `break` statement after each `case`
    label.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 非绿色蔬菜位于`default` case标签中。为了防止穿透，您必须记住在每个`case`标签后插入显式的`break`语句。
- en: 'We can write another version of the same switch that does not let Zucchini
    fall through, by the explicit use of the `break` keyword in the switch:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写另一个版本的相同开关，它不会让Zucchini掉下来，而是在开关中明确使用`break`关键字：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that it is good programming practice to `break` the `default` case as well,
    even though it is the last case listed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使它是最后一个列出的情况，`break` `default` case也是良好的编程实践。
- en: Exercise
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Complete the following program, which has an `enum` object with a series of
    mounts to choose from. Write a `switch` statement that prints the following messages
    for the mount selected:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下程序，其中有一个`enum`对象，其中有一系列可供选择的坐骑。编写一个`switch`语句，为所选的坐骑打印以下消息：
- en: '| `Horse` | The steed is valiant and mighty. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `Horse` | 这匹骏马是勇敢而强大的。 |'
- en: '| `Mare` | This mare is white and beautiful. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `Mare` | 这匹母马是白色和美丽的。 |'
- en: '| `Mule` | You are given a mule to ride. You resent that. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Mule` | 你被给了一匹骡子骑。你对此感到愤慨。 |'
- en: '| `Sheep` | Baa! The sheep can barely support your weight. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `Sheep` | 咩！这只羊几乎无法支撑您的重量。 |'
- en: '| `Chocobo` | Chocobo! |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Chocobo` | Chocobo! | '
- en: Remember, an `enum` object is really an `int` statement. The first entry in
    an `enum` object is by default `0`, but you can give the `enum` object any starting
    value you wish using the `=` operator. Subsequent values in the `enum` object
    are `ints` arranged in order.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`enum`对象实际上是一个`int`语句。`enum`对象中的第一个条目默认为`0`，但您可以使用`=`运算符为`enum`对象指定任何起始值。`enum`对象中的后续值是按顺序排列的`ints`。
- en: Solution
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution to the preceding exercise is shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个练习的解决方案显示在以下代码中：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Bit-shifted enums
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位移的枚举
- en: 'A common thing to do in an `enum` object is to assign a bit-shifted value to
    each entry:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enum`对象中常见的做法是为每个条目分配一个位移值：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The bit-shifted values should be able to combine the window properties. This
    is how the assignment will look:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 位移值应该能够组合窗口属性。分配将如下所示：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Checking which `WindowProperties` have been set involves a check using `bitwise
    AND`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 检查已设置哪些`WindowProperties`涉及使用`按位AND`进行检查：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Bit-shifting is a technique that is slightly beyond the scope of this book,
    but I've included this tip just so you know about it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 位移是一种略微超出本书范围的技术，但我包含了这个提示，只是让您知道它。
- en: Our first example with Unreal Engine
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在虚幻引擎中的第一个示例
- en: We need to get started with Unreal Engine.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始使用虚幻引擎。
- en: 'A word of warning: when you open your first Unreal project, you will find that
    the code looks very complicated. Don''t get discouraged. Simply focus on the highlighted
    parts. Throughout your career as a programmer, you will often have to deal with
    very large code bases containing sections that you do not understand. However,
    focusing on the parts that you do understand will make this section productive.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：当您打开第一个虚幻项目时，您会发现代码看起来非常复杂。不要灰心。只需专注于突出显示的部分。在您作为程序员的职业生涯中，您经常需要处理包含您不理解的部分的非常庞大的代码库。然而，专注于您理解的部分将使本节变得富有成效。
- en: First, you need to download the launcher to install the engine. Go to [https://www.unrealengine.com/en-US/what-is-unreal-engine-4](https://www.unrealengine.com/en-US/what-is-unreal-engine-4)
    and when you click Get Started Now or Download, you will have to create a free
    account before you can download the launcher.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要下载启动器以安装引擎。转到[https://www.unrealengine.com/en-US/what-is-unreal-engine-4](https://www.unrealengine.com/en-US/what-is-unreal-engine-4)，当您单击立即开始或下载时，您必须在下载启动器之前创建一个免费帐户。
- en: 'Once you have downloaded the launcher, open the Epic Games Launcher app. Select
    Launch Unreal Engine 4.20.X (there will probably be a new version by the time
    you read this), as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下载启动器后，打开Epic Games Launcher应用程序。选择启动虚幻引擎4.20.X（到您阅读此内容时可能会有新版本），如下截图所示：
- en: '![](img/04daefd6-113d-4bca-b666-9978e61e8f50.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04daefd6-113d-4bca-b666-9978e61e8f50.png)'
- en: If you don't have the engine installed, you need to go to the Unreal Engine
    tab and download an engine (~7 GB).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装引擎，您需要转到虚幻引擎选项卡并下载一个引擎（~7 GB）。
- en: 'Once the engine is launched (which might take a few seconds), you will be in
    the Unreal Project Browser screen, as shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引擎启动（可能需要几秒钟），你将进入虚幻项目浏览器屏幕，就像下面的截图中所示的那样：
- en: '![](img/2f95b850-6c0b-4430-8406-180d2d8c046c.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f95b850-6c0b-4430-8406-180d2d8c046c.png)'
- en: Now, select the New Project tab in the UE4 project browser. Choose the C++ tab
    and select the Puzzle project. This is one of the simpler projects that doesn't
    have too much code, so it's good to start with. We'll move on to the 3D projects
    later.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在UE4项目浏览器中选择“新项目”标签页。选择C++标签页并选择Puzzle项目。这是一个比较简单的项目，代码不是太多，所以很适合入门。我们稍后会转到3D项目。
- en: 'Here are a few things to make a note of in this screen:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上有几件事情要注意：
- en: Be sure you're in the New Project tab.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你在“新项目”标签页中。
- en: When you click on Puzzle, make sure that it is the one in the C++ tab, not the Blueprint
    tab.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你点击Puzzle时，确保它是C++标签页上的一个，而不是蓝图标签页上的一个。
- en: Enter a name for your project, `Puzzle`, in the Name box (this is important
    for the example code I will give you to work on later).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“名称”框中输入项目名称“Puzzle”（这对我稍后给你的示例代码很重要）。
- en: If you want to change the storage folder (such as to a different drive), click
    the ... button next to the folder so that the browse window appears. Then, find
    the directory where you want to store your project.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想更改存储文件夹（比如更改到另一个驱动器），点击文件夹旁边的...按钮，这样浏览窗口就会出现。然后，找到你想要存储项目的目录。
- en: After you've done all this, select Create Project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，选择创建项目。
- en: 'Note: if it tells you it can''t create the project because you do not have
    the Windows 8.1 SDK installed, you can download it from [https://developer.microsoft.com/en-us/windows/downloads/sdk-archive](https://developer.microsoft.com/en-us/windows/downloads/sdk-archive).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果它告诉你无法创建项目，因为你没有安装Windows 8.1 SDK，你可以从[https://developer.microsoft.com/en-us/windows/downloads/sdk-archive](https://developer.microsoft.com/en-us/windows/downloads/sdk-archive)下载它。
- en: 'Visual Studio 2017 will open with the code of your project, as well as the
    Unreal Editor, as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017将打开你的项目代码，以及虚幻编辑器，就像下面的截图中所示的那样：
- en: '![](img/a1f96d5d-3788-4084-af56-7b2642074bb6.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1f96d5d-3788-4084-af56-7b2642074bb6.png)'
- en: Looks complicated? Oh boy, it sure is! We'll explore some of the functionality
    in the toolbars at the side later. For now, just select Play, as shown in the
    preceding screenshot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来复杂吗？哦，天哪，它确实复杂！我们稍后会探索一些工具栏中的功能。现在，只需选择播放，就像前面的截图中所示的那样。
- en: 'This launches the game. This is how it should look:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动游戏。它应该是这个样子的：
- en: '![](img/a8243275-3064-4ce4-a989-5047adb97709.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8243275-3064-4ce4-a989-5047adb97709.png)'
- en: Now, try clicking on the blocks. As soon as you click on a block, it turns orange,
    and this increases your score. You can end your play session by clicking Stop
    or hitting *Esc* on your keyboard.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试点击方块。一旦你点击一个方块，它就会变成橙色，这会增加你的分数。你可以通过点击“停止”或在键盘上按*Esc*来结束你的游戏会话。
- en: What we're going to do is find the section that does this and change the behavior
    a little.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是找到这个部分并稍微改变一下行为。
- en: Find and open the `PuzzleBlock.cpp` file. Look for PuzzleBlock under C++ Classes
    | Puzzle and double-click it to open it in your IDE.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 找到并打开`PuzzleBlock.cpp`文件。在C++类|拼图下找到PuzzleBlock，双击它以在IDE中打开它。
- en: In Visual Studio, the list of files in the project is located inside the Solution
    Explorer. If your Solution Explorer is hidden, simply click on View/Solution Explorer
    from the menu at the top.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，项目中的文件列表位于“解决方案资源管理器”中。如果你的“解决方案资源管理器”被隐藏了，只需点击顶部菜单中的“查看/解决方案资源管理器”。
- en: 'Inside this file, scroll down to the bottom, where you''ll find a section that
    begins with the following words:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，向下滚动到底部，你会找到一个以以下单词开头的部分：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`APuzzleBlock` is the class name (we''ll get into classes later), and `BlockClicked`
    is the function name. Whenever a puzzle block gets clicked on, the section of
    code from the starting `{` to the ending `}` is run. Hopefully, exactly how this
    happens will make more sense later.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`APuzzleBlock`是类名（我们稍后会介绍类），`BlockClicked`是函数名。每当一个拼图块被点击时，从起始`{`到结束`}`的代码部分就会运行。希望这发生的方式稍后会更有意义。'
- en: It's kind of like an `if` statement in a way. If a puzzle piece is clicked on,
    then this group of the code is run for that puzzle piece.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上有点像`if`语句。如果点击了一个拼图块，那么这组代码就会为该拼图块运行。
- en: We're going to walk through the steps to make the blocks flip colors when they
    are clicked on (so, a second click will change the color of the block from orange
    back to blue).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍如何使方块在被点击时翻转颜色（因此，第二次点击将把方块的颜色从橙色改回蓝色）。
- en: 'Perform the following steps with the utmost care:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以最大的小心进行以下步骤：
- en: 'Open the `PuzzleBlock.h` file. After the line which has this code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PuzzleBlock.h`文件。在包含以下代码的行之后：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, open the `PuzzleBlock.cpp` file. Look for the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`PuzzleBlock.cpp`文件。查找以下代码：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `PuzzleBlock.cpp`, replace the contents of the void `APuzzleBlock::BlockClicked`
    section of code with the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PuzzleBlock.cpp`中，用以下代码替换void `APuzzleBlock::BlockClicked`代码部分的内容：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Only replace inside the `void APuzzleBlock::BlockClicked(UPrimitiveComponent*
    ClickedComp, FKey ButtonClicked)`statement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 只替换`void APuzzleBlock::BlockClicked(UPrimitiveComponent* ClickedComp, FKey ButtonClicked)`语句内部。
- en: Do not replace the line that starts with `void APuzzleBlock::BlockClicked`.
    You might get an error (if you haven't named your project `Puzzle`). If so, you
    can start over by creating a new project with the correct name.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不要替换以`void APuzzleBlock::BlockClicked`开头的那一行。你可能会出现错误（如果你没有将项目命名为“Puzzle”）。如果是这样，你可以通过使用正确的名称创建一个新项目来重新开始。
- en: 'Press Play to see your changes in action! So, let''s analyze this. This is
    the first line of code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放按钮，看看你的更改生效了！所以，让我们分析一下。这是第一行代码：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This line of code simply flips the value of `bIsActive`. The `bIsActive` variable
    is a `bool` variable (it is created in `APuzzleBlock.h`), which keeps track of
    whether or not the block is active and should be displayed in orange. It's like
    flipping a switch. If `bIsActive` is `true`, `!bIsActive` will be `false`. So,
    whenever this line of code is hit (which happens with a click on any block), the
    `bIsActive` value is reversed (from `true` to `false` or from `false` to `true`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码只是翻转了`bIsActive`的值。`bIsActive`变量是一个`bool`变量（它在`APuzzleBlock.h`中创建），用于跟踪方块是否处于活动状态并且应该显示为橙色。这就像翻转开关一样。如果`bIsActive`为`true`，`!bIsActive`将为`false`。因此，每当这行代码被执行（通过点击任何方块时会发生），`bIsActive`的值就会被反转（从`true`到`false`或从`false`到`true`）。
- en: 'Let''s consider the next block of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑下一段代码：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are simply changing the block color. If `bIsActive` is `true`, then the block
    becomes orange. Otherwise, the block turns blue.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是改变了方块的颜色。如果`bIsActive`为`true`，那么方块就会变成橙色。否则，方块就会变成蓝色。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to branch the code. Branching makes it possible
    for the code to go in a different direction instead of going straight down.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何分支代码。分支使代码可以朝不同的方向发展，而不是一直向下执行。
- en: In the next chapter, we will move on to a different kind of control flow statement
    that will allow you to go back and repeat a line of code a certain number of times.
    The sections of code that repeat will be called loops.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论一种不同类型的控制流语句，它将允许您返回并重复执行一行代码一定次数。重复执行的代码部分将被称为循环。
