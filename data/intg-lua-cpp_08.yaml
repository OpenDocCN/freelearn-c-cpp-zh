- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Abstracting a C++ Type Exporter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象C++类型导出器
- en: In the previous chapter, we learned how to export a C++ class to Lua as a user-defined
    type. An instance of the class is exported to Lua to serve as the prototype for
    the type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何将C++类导出到Lua作为用户定义的类型。类的实例被导出到Lua作为类型的原型。
- en: The exercise from the previous chapter required you to create a factory class
    for the type. However, with that requirement, each type needs its own factory
    class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的练习要求你为类型创建一个工厂类。然而，由于这个要求，每种类型都需要自己的工厂类。
- en: In this chapter, we will learn how to implement a general C++ type exporter
    so that you can use it as the factory class for any C++ type, without redoing
    the work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实现一个通用的C++类型导出器，这样你就可以将其用作任何C++类型的工厂类，而无需重复工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reviewing the factory implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾工厂实现
- en: Designing a type exporter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计类型导出器
- en: Stubbing the type exporter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟类型导出器
- en: Defining `LuaModuleDef`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`LuaModuleDef`
- en: Re-implementing `luaNew`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新实现`luaNew`
- en: Are you flexible enough?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否足够灵活？
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处访问本章的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08)。
- en: Reviewing the factory implementation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾工厂实现
- en: We will review the exercise from the previous chapter. The solution this book
    has adopted requires progressive and minimal changes. It also leads naturally
    to the feature covered in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾上一章的练习。本书采用的解决方案需要渐进和最小化更改。它也自然地引出了本章介绍的功能。
- en: If you have not implemented your own solution and are willing to stop here for
    a moment, this is another chance to give it a shot. Many technologies are simple
    in explanation but hard to grasp. The best way to understand them is to review
    and practice them, hands-on, again and again until you get an "aha" moment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有实现自己的解决方案并且愿意停下来思考一下，这是一个尝试的机会。许多技术在解释上很简单，但很难掌握。理解它们的最佳方式是通过反复回顾和实践，直到你获得“啊哈”的顿悟。
- en: Now, we will review a solution. The focus is on the changes and key concepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回顾一个解决方案。重点是变化和关键概念。
- en: Defining the factory
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义工厂
- en: To make a factory, we only need to change `Destinations.h` and `Destinations.cc`.
    In your preferred IDE, you can open the `end` project for *Chapter 7* and the
    `begin` project for this chapter to check the differences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个工厂，我们只需要更改`Destinations.h`和`Destinations.cc`。在你的首选IDE中，你可以打开*第7章*的`end`项目以及本章的`begin`项目来检查差异。
- en: 'Let us first look at the header file for the factory class declaration. You
    can find the following declarations in `Destinations.h` in the `begin` project
    for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看工厂类声明的头文件。你可以在本章`begin`项目的`Destinations.h`中找到以下声明：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The change from the previous chapter is that we are creating a factory class
    named `DestinationsFactory`, which implements the `LuaModule` interface. In fact,
    we are moving the `LuaModule` implementation from `Destinations` to `DestinationsFactory`
    so that the `Destinations` type does not know anything about Lua. This is one
    of the benefits of a factory class. The system can be better layered.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的变化是，我们创建了一个名为`DestinationsFactory`的工厂类，它实现了`LuaModule`接口。实际上，我们将`LuaModule`实现从`Destinations`移动到`DestinationsFactory`，这样`Destinations`类型就不知道任何关于Lua的事情。这是工厂类的一个好处。系统可以更好地分层。
- en: Did you know?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: If you use Linux or Mac, you can also use the `diff` `Chapter07/end/Destinations.h
    Chapter08/begin/Destinations.h`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux或Mac，你也可以使用`diff` `Chapter07/end/Destinations.h Chapter08/begin/Destinations.h`。
- en: Next, we will review the factory implementation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾工厂实现。
- en: Implementing the factory
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现工厂
- en: 'The factory only has two member functions, which are implemented as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂只有两个成员函数，其实现如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, instead of `REGS`, `luaRegs` returns `FACTORY_REGS`, which is defined
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`luaRegs`不再返回`REGS`，而是返回`FACTORY_REGS`，它被定义为如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means, now, we only export a single function, `luaNew`, to Lua.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，现在，我们只导出一个函数，`luaNew`，到Lua。
- en: As explained in *Chapter 6*, the Lua library expects the last entry to be `{NULL,
    NULL}` to mark the end of the array. This is a typical technique for C-based libraries
    because they usually get a pointer to an item as the input for an array and need
    to figure out where the array ends.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第6章*所述，Lua库期望数组的最后一个条目是`{NULL, NULL}`，以标记数组的结束。这是基于C的库的典型技术，因为它们通常将一个指向数组项的指针作为数组的输入，并需要确定数组在哪里结束。
- en: 'Also, delete `luaNew` from `REGS` so that it looks like the following list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从`REGS`中删除`luaNew`，使其看起来像以下列表：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Previously, `REGS` served two purposes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`REGS`有两个用途：
- en: The `__index` metatable for new instances created from Lua. This is done in
    `luaNew` with `luaL_setfuncs(L,` `REGS.data(), 0)`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Lua创建的新实例的`__index`元表。这是在`luaNew`中通过`luaL_setfuncs(L, REGS.data(), 0)`来完成的。
- en: The registered Lua module, which is a plain Lua table. This is done with a call
    to `LuaExecutor::registerModule`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册的Lua模块，这是一个普通的Lua表。这是通过调用`LuaExecutor::registerModule`来完成的。
- en: Now, `REGS` only serves the first purpose and gives the second responsibility
    to `FACTORY_REGS`. This is yet another structural improvement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`REGS`只服务于第一个目的，并将第二个责任交给了`FACTORY_REGS`。这是另一个结构改进。
- en: These are all the changes we need to create a factory. You can read the complete
    source code that you get from GitHub. However, there is not much code change,
    right? We were just moving things around, and we now have a different object-creation
    mechanism.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们创建工厂所需的所有更改。您可以从GitHub获取完整的源代码。然而，代码更改并不多，对吧？我们只是移动了一些东西，现在我们有一个不同的对象创建机制。
- en: Now, based on this factory concept, we are ready to move on to the main focus
    of this chapter. From now on, you can use the `begin` project as the basis for
    development. Let us start to design a general C++ type exporter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于这个工厂概念，我们准备继续本章的主要焦点。从现在开始，您可以使用`begin`项目作为开发的基础。让我们开始设计一个通用的C++类型导出器。
- en: Designing a type exporter
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计类型导出器
- en: First, let us define our scope. We want to generalize the factory we have just
    made and make it work with any C++ class – that is, the C++ class still needs
    to implement and provide the `lua_CFunction` wrappers in some way. It is possible
    to automate the creation of those wrappers, but that would require implementing
    a heavy C++ template library, which is not strictly related to Lua and is out
    of the scope of this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的范围。我们希望使刚刚创建的工厂通用化，并使其能够与任何C++类一起工作——也就是说，C++类仍然需要以某种方式实现和提供`lua_CFunction`包装器。自动创建这些包装器是可能的，但这将需要实现一个重量级的C++模板库，这与Lua没有直接关系，并且超出了本书的范围。
- en: With the scope defined, let us make some high-level designs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了范围之后，让我们做一些高级设计。
- en: Choosing a design pattern
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择设计模式
- en: When we talk about making something *general* in C++, usually it means we need
    to use templates. To work with our Lua executor, we need to export `LuaModule`.
    So, we need to implement the exporter as a template class that can provide `LuaModule`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论在C++中使某物*通用*时，通常意味着我们需要使用模板。为了与我们的Lua执行器一起工作，我们需要导出`LuaModule`。因此，我们需要将导出器实现为一个模板类，它可以提供`LuaModule`。
- en: How can we provide `LuaModule`? We can make the exporter inherit from the `LuaModule`
    interface, or make one of its member functions return `LuaModule`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何提供`LuaModule`？我们可以使导出器继承自`LuaModule`接口，或者使其其中一个成员函数返回`LuaModule`。
- en: 'One of the popular design patterns for the latter option is the **Builder**
    pattern. This can be demonstrated with the following pseudo-code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 后者选项中流行的设计模式之一是**建造者**模式。这可以通过以下伪代码来演示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A builder usually has many functions to customize different properties for the
    thing it creates, alongside a `build` function to create the final object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者通常有许多函数来定制它所创建的事物的不同属性，同时还有一个`build`函数来创建最终对象。
- en: 'Since our goal is to help with object creation alone, like in the factory exercise,
    and not to customize the object, the *Builder* pattern is overkill. We will choose
    the vanilla C++ inheritance. The exporter type can be defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标仅仅是帮助进行对象创建，就像在工厂练习中一样，而不是定制对象，因此*建造者*模式是多余的。我们将选择纯C++继承。导出器类型可以定义如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a template class. It will export C++ type `T` as `LuaModule`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模板类。它将导出C++类型`T`为`LuaModule`。
- en: Now, let us stub the exporter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们模拟导出器。
- en: Stubbing the exporter
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟导出器
- en: We have two major considerations for the design of the exporter. First, it is
    `LuaModule`, so it needs to implement its pure virtual functions. Second, we want
    it to resemble what we implemented in the factory exercise, which means we have
    a pretty good idea of what to return in the `luaRegs` virtual function implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出器的设计中，我们有两个主要的考虑因素。首先，它是 `LuaModule`，因此需要实现它的纯虚函数。其次，我们希望它类似于我们在工厂练习中实现的内容，这意味着我们对
    `luaRegs` 虚拟函数实现中要返回的内容有一个相当好的想法。
- en: 'Let us get started. Add a new file named `LuaModuleExporter.hpp` and define
    the `LuaModuleExporter` class, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始。添加一个名为 `LuaModuleExporter.hpp` 的新文件，并定义 `LuaModuleExporter` 类，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This makes the exporter a final class and prevents it from being copy-constructed.
    Because the purpose of the exporter is to provide `LuaModule` and we do not have
    logic for it to get passed around by value, adding some restrictions can prevent
    bugs in the future. We achieve this by assigning the `delete` keyword to the copy
    constructor. We also want to control the object creation, so we make the constructor
    private. This has another effect – you cannot use `new operator` to create instances
    of the class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得导出器成为一个最终类，并防止它被复制构造。因为导出器的目的是提供 `LuaModule`，我们没有逻辑让它通过值传递，所以添加一些限制可以防止未来的错误。我们通过将
    `delete` 关键字赋给复制构造函数来实现这一点。我们还想控制对象创建，所以我们使构造函数私有。这还有一个副作用——你不能使用 `new` 操作符来创建类的实例。
- en: 'Now, add the implementation for `LuaModule` as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式为 `LuaModule` 添加实现：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is straightforward. On the Lua module level, we only want to export one
    function to create concrete objects. So, we will only register `luaNew`. The name
    of the module needs to be passed in. We will find a way when we implement the
    details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。在 Lua 模块级别，我们只想导出一个函数来创建具体对象。因此，我们只会注册 `luaNew`。模块的名称需要传递进来。我们将在实现细节时找到一种方法。
- en: Thus, we have a stub for our exporter. This is a system-level design contract.
    Now, let us write the test code to see how it should be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为导出器创建了一个占位符。这是一个系统级的设计合约。现在，让我们编写测试代码来查看它应该如何使用。
- en: Preparing the C++ test code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 C++ 测试代码
- en: 'In `main.cpp`, write the `main` function as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中编写 `main` 函数如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared with the previous chapter, the only difference is how `LuaModule` is
    created. Now, it is created with `LuaModuleExporter<Destinations>::make()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章相比，唯一的区别是 `LuaModule` 的创建方式。现在，它是通过 `LuaModuleExporter<Destinations>::make()`
    创建的。
- en: At this point, the project should compile. When you run it, it should not crash
    on the C++ side; although, at this stage, it will not be able to do anything meaningful,
    and you should see an error message from Lua.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，项目应该可以编译。当你运行它时，它不应该在 C++ 端崩溃；尽管如此，在这个阶段，它将无法执行任何有意义的操作，你应该会看到 Lua 的错误信息。
- en: Now, we will see what Lua code we need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到我们需要什么 Lua 代码。
- en: Preparing the Lua test script
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Lua 测试脚本
- en: 'Write `script.lua` exactly as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `script.lua` 编写如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We used this code snippet in the previous chapter. This will help to validate
    whether we will get the same result later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中使用了这个代码片段。这将帮助我们验证我们是否会在本章后面得到相同的结果。
- en: Next, let us start to make the exporter work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始使导出器工作。
- en: Defining LuaModuleDef
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 LuaModuleDef
- en: 'First, we need to provide the name of the module and then the `__index` metatable.
    Finally, we need to provide a name for the metatable. Recall that in `Destinations.cc`,
    the name of the metatable is hardcoded as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要提供模块的名称，然后是 `__index` 元表。最后，我们需要提供一个元表的名称。回想一下，在 `Destinations.cc` 中，元表的名称硬编码如下：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, this needs to be passed to the exporter. Let us define a structure for
    the aforementioned three pieces of information. In `LuaModule.h`, add the following
    declaration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这需要传递给导出器。让我们定义一个结构来表示上述三块信息。在 `LuaModule.h` 中添加以下声明：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This defines `moduleName` and `moduleRegs`. The metatable name is based on the
    module name, with `".Metatable"` appended to it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了 `moduleName` 和 `moduleRegs`。元表名称基于模块名称，并在其后附加 `".Metatable"`。
- en: Note that this structure is also templated. This indicates that a definition
    is for a certain C++ type. We will use the template later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个结构也是模板化的。这表明定义是为某种 C++ 类型。我们将在本章后面使用模板。
- en: Now, we can pass this structure to the exporter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个结构传递给导出器。
- en: Using LuaModuleDef
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LuaModuleDef
- en: 'In `LuaModuleExporter.hpp`, accept an instance of `LuaModuleDef` during exporter
    creation. Rewrite the related code as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LuaModuleExporter.hpp`中，在导出器创建期间接受`LuaModuleDef`实例。重写相关代码如下：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The changes are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如下：
- en: We added a private member variable, `luaModuleDef`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个私有成员变量`luaModuleDef`
- en: We added an argument of type `LuaModuleDef` to `make` and the private constructor
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向`make`和私有构造函数添加了一个类型为`LuaModuleDef`的参数
- en: We changed `luaName` to return `luaModuleDef.moduleName`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`luaName`改为返回`luaModuleDef.moduleName`
- en: We deleted the private member variable, `name`, introduced during stubbing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们删除了在模拟过程中引入的私有成员变量`name`
- en: Now, we can define `LuaModuleDef` for the `Destinations` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`Destinations`类定义`LuaModuleDef`。
- en: 'In `Destinations.h`, delete the declaration for `DestinationsFactory` and add
    the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Destinations.h`中，删除`DestinationsFactory`的声明并添加以下代码：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `Destinations.cpp`, delete all implementations for `DestinationsFactory`
    and add the following code after the anonymous namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Destinations.cpp`中，删除`DestinationsFactory`的所有实现，并在匿名命名空间之后添加以下代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in `main.cpp`, change the module creation code to the following statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main.cpp`中，将模块创建代码更改为以下语句：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This pumps `LuaModuleDef` for the `Destinations` class into the exporter. Make
    sure that the project can compile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`Destinations`类的`LuaModuleDef`泵送到导出器中。确保项目可以编译。
- en: Now, we will fill in the rest of the missing pieces to make the exporter really
    work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将填补其余缺失的部分，使导出器真正工作。
- en: Re-implementing luaNew
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新实现`luaNew`
- en: Because we will store `LuaModuleDef` in `LuaModuleExporter`, to access it, we
    need to find the instance of `LuaModuleExporter`. Let us first implement a helper
    function for this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在`LuaModuleExporter`中存储`LuaModuleDef`，为了访问它，我们需要找到`LuaModuleExporter`的实例。让我们首先实现一个辅助函数来完成这个任务。
- en: 'Since the exporter is also `LuaModule`, it already has an upvalue mechanism,
    implemented in *Chapter 6*. `LuaModule::pushLuaUpvalues` will push the pointer
    to the `LuaModule` instance as an upvalue. To retrieve it, we can add the following
    function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导出器也是`LuaModule`，它已经具有第6章中实现的值机制。`LuaModule::pushLuaUpvalues`会将`LuaModule`实例的指针作为值推入。要检索它，我们可以添加以下函数：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the same as the `getObj` function in *Chapter 6*, but now, it is a static
    member function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这与第6章中的`getObj`函数相同，但现在它是一个静态成员函数。
- en: 'With a way to access the exporter instance from the static member functions,
    we can write `LuaModuleExporter::luaNew` as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一种从静态成员函数访问导出器实例的方式，我们可以将`LuaModuleExporter::luaNew`编写如下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is actually copied from `Destinations.cc`. The changes, besides using `T`
    `typename` instead of the hardcoded class name, are highlighted in the preceding
    code. You can see that they are all about pumping `LuaModuleDef`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是从`Destinations.cc`中复制的。除了使用`T` `typename`代替硬编码的类名之外，更改已在前面的代码中突出显示。你可以看到它们都是关于泵送`LuaModuleDef`。
- en: If you have forgotten how `luaNew` works, you can check the previous chapter,
    where there are figures to show how the Lua stack changes as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了`luaNew`是如何工作的，你可以查看上一章，其中有一些图表显示了Lua堆栈如何变化。
- en: 'Finally, let us implement the stub for `LuaModuleExporter::luaDelete` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现`LuaModuleExporter::luaDelete`的存根如下：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`luaDelete` is registered as the `__gc` metamethod in `luaNew`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaDelete`在`luaNew`中注册为`__gc`元方法。'
- en: Do you remember?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得吗？
- en: As explained in the previous chapter, we set `luaDelete` as the finalizer for
    the user data created in `luaNew`. During the Lua garbage collection process,
    the finalizer will be called, with an argument as the user data reference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们将`luaDelete`设置为`luaNew`中创建的用户数据的终结器。在Lua垃圾回收过程中，终结器将被调用，参数为用户数据引用。
- en: You can also delete `REGS`, `FACTORY_REGS`, `luaNew`, and `luaDelete` in `Destinations.cc`.
    They are not used anymore.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`Destinations.cc`中删除`REGS`、`FACTORY_REGS`、`luaNew`和`luaDelete`。它们不再使用。
- en: 'Now, we can test the exporter. Execute the project. If you have done everything
    correctly, you should see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试导出器。执行项目。如果你一切都做对了，你应该会看到以下输出：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have not really changed the test code from the previous chapter, except for
    how the `Destinations` class gets exported to Lua.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有真正改变上一章中的测试代码，除了`Destinations`类如何导出到Lua的方式。
- en: If you have encountered any errors, do not feel discouraged. This is the most
    complex chapter in this book, and we need to implement code correctly in multiple
    files to make it work. Trace back your steps and fix the error. You can do it!
    Also, in GitHub, there are multiple checkpoint projects for this chapter, which
    you can refer to. As previously mentioned, we will not automate the generation
    of the `lua_CFunction` wrappers. Generalization also needs a limit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了任何错误，不要气馁。这是这本书中最复杂的一章，我们需要在多个文件中正确实现代码才能使其工作。回顾你的步骤并修复错误。你可以做到！此外，在 GitHub
    上，有多个针对本章的检查点项目，你可以参考。如前所述，我们不会自动生成 `lua_CFunction` 包装器。泛化也需要有界限。
- en: But, let us check how general our implementation is.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们检查我们的实现有多通用。
- en: Are you flexible enough?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你足够灵活吗？
- en: 'To answer this question, let us rewrite `script.lua` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，让我们将 `script.lua` 修改如下：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, the new requirement is that, in the Lua code, when creating the `Destinations`
    objects, we can provide an initial list of unvisited places.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，新的要求是在 Lua 代码中，当创建 `Destinations` 对象时，我们可以提供一个未访问地点的初始列表。
- en: This means that we need to support parameterized object creation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要支持参数化对象创建。
- en: Can our exporter support this? This should be a common use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导出器支持这个功能吗？这应该是一个常见的用例。
- en: Now is a good time to ponder over life, get a cup of coffee, or whatever. We
    are almost near the end of *Part 3* of this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是思考人生、喝杯咖啡或做任何其他事情的好时机。我们几乎接近这本书的第三部分结束。
- en: 'If you recall, our object creation code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们的对象创建代码如下：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a seasoned C++ programmer, you may think that, because `std::make_unique<T>`
    can forward its arguments to the constructor of `T`, there must be a way to make
    `LuaModuleExporter<T>::make` do the same. Right, but the magic of `std::make_unique<T>`
    is at C++ compile time. So, how would you handle that when the arguments are passed
    in Lua code after the C++ code has been compiled?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名经验丰富的 C++ 程序员，你可能认为，因为 `std::make_unique<T>` 可以将其参数传递给 `T` 的构造函数，所以一定有办法让
    `LuaModuleExporter<T>::make` 做同样的事情。没错，但 `std::make_unique<T>` 的魔力在于 C++ 编译时。那么，当参数在
    C++ 代码编译后通过 Lua 代码传递时，你将如何处理呢？
- en: Worry not. Let us explore the **factory method** design pattern. A factory method
    is a contract defined as a method or an interface to create and return an object.
    However, how the object is created is not important and not part of the contract.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心。让我们来探索**工厂方法**设计模式。工厂方法是一个定义为一个方法或接口的合约，用于创建并返回一个对象。然而，对象的创建方式并不重要，也不属于合约的一部分。
- en: 'To see how it works, let us implement one for `LuaModuleDef`. Add another member
    variable, named `createInstance`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到它是如何工作的，让我们为 `LuaModuleDef` 实现一个。添加另一个成员变量，命名为 `createInstance`，如下所示：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a bit of advanced C++ usage. Therefore, it is important that you take
    the following into account:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一点高级的 C++ 使用。因此，重要的是你要考虑以下几点：
- en: '`createInstance` is declared as a member variable but not as a member function.
    This is because you can simply assign the member variable a different value during
    object construction to achieve a different behavior, but with a member function,
    you need to create a subclass to override the behavior. *We should prefer composition
    over inheritance whenever* *we can.*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createInstance` 被声明为一个成员变量，而不是一个成员函数。这是因为你可以在对象构造期间简单地给成员变量赋一个不同的值以实现不同的行为，但如果你使用成员函数，你需要创建一个子类来覆盖行为。*我们应该在可能的情况下优先选择组合而不是继承*。'
- en: '`createInstance` is of type `std::function`. With this type, you can use the
    variable as if it were a function. If you are more familiar with Lua in this regard,
    you’ll understand that a named Lua function is also a variable. Here, we want
    to achieve the same effect. `T *(lua_State *)` is the type of the function. It
    means that the function expects one argument of type `lua_State*` and will return
    a pointer to type `T`. You can check the C++ reference manual to learn more about
    `std::function`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createInstance` 的类型是 `std::function`。使用这种类型，你可以像使用函数一样使用这个变量。如果你在这方面更熟悉 Lua，你会明白一个命名的
    Lua 函数也是一个变量。在这里，我们想要达到相同的效果。`T *(lua_State *)` 是函数的类型。这意味着该函数期望一个类型为 `lua_State*`
    的参数，并将返回一个类型为 `T` 的指针。你可以查看 C++ 参考手册来了解更多关于 `std::function` 的信息。'
- en: Then, we provide a default implementation as a C++ lambda. This lambda simply
    creates an instance in the heap without any constructor parameter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们提供一个默认的实现，作为一个 C++ lambda 表达式。这个 lambda 表达式简单地创建一个堆中的实例，没有任何构造函数参数。
- en: 'To use this factory method, change `LuaModuleExporter::luaNew`, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个工厂方法，按照以下方式更改 `LuaModuleExporter::luaNew`：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have changed from new `T()` to `luaModuleDef.createInstance(L)`, and it still
    does the same thing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从 `new T()` 更改为 `luaModuleDef.createInstance(L)`，它仍然做同样的事情。
- en: However, note that we no longer create the object in `LuaModuleExporter`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们不再在 `LuaModuleExporter` 中创建对象。
- en: Finally, to answer the question, yes, we are flexible enough.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了回答这个问题，是的，我们足够灵活。
- en: On modern C++
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于现代 C++
- en: In 1998, C++ was standardized for the first time as C++98\. It saw little change
    until 2011, with C++11\. Since then, C++ has quickly adopted modern programming
    techniques in language specification. Lambdas and `std::function` are just two
    of the many examples. If you know some other languages (for example, Java), you
    can make some analogies (lamdba and functional interface), although the syntaxes
    are different. I implemented `LuaModuleDef` this way instead of using a more traditional
    method to show you some examples of modern C++ features. This is the future, and
    I encourage you to explore modern C++ in more detail. People working with Java,
    Kotlin, and Swift use such techniques by default. You can play an important role
    here by adopting these new techniques and helping C++ to catch up.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1998 年，C++ 首次标准化为 C++98。直到 2011 年的 C++11，它变化很小。从那时起，C++ 快速采用了语言规范中的现代编程技术。Lambda
    和 `std::function` 只是众多例子中的两个。如果你了解其他语言（例如 Java），你可以做一些类比（lambda 和函数式接口），尽管语法不同。我以这种方式实现了
    `LuaModuleDef`，而不是使用更传统的方法，以展示一些现代 C++ 特性的例子。这是未来，我鼓励你更深入地探索现代 C++。使用 Java、Kotlin
    和 Swift 的人默认使用这些技术。通过采用这些新技术并帮助 C++ 赶上，你可以在这里扮演重要的角色。
- en: 'In `Destinations.cc`, change the `LuaModuleDef` instance as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Destinations.cc` 中，按照以下方式更改 `LuaModuleDef` 实例：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This initializes the `createInstance` field with the provided lambda, rather
    than the default lambda. The new lambda does similar things to the `luaWish` wrapper.
    The beauty of this is that you have full control over this lambda. You can create
    another constructor for the `Destinations` class and simply invoke the new constructor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用提供的 lambda 初始化 `createInstance` 字段，而不是默认的 lambda。新的 lambda 与 `luaWish` 包装器做类似的事情。这个优点在于你可以完全控制这个
    lambda。你可以为 `Destinations` 类创建另一个构造函数，并简单地调用新的构造函数。
- en: 'We can test the project with the new Lua script. You should see the following
    output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用新的 Lua 脚本测试项目。你应该能看到以下输出：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, `Shanghai` and `Tokyo` have been added to the unvisited list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`上海` 和 `东京` 已经被添加到未访问列表中。
- en: Even further design improvement
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步的设计改进
- en: We are creating objects in `LuaModuleDef` but destroying them in `LuaModuleExporter`,
    and our use case does not involve transferring object ownership. For a better
    design, the same class should destroy the objects it creates, which we will implement
    in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `LuaModuleDef` 中创建对象，但在 `LuaModuleExporter` 中销毁它们，并且我们的用例不涉及对象所有权的转移。为了更好的设计，应该由创建对象的同一类销毁它们，这将在下一章中实现。
- en: This time, for real, we have finished.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，真的是完成了。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a general C++ module exporter, mainly for the
    object creation part. This ensures that you can implement complex object creation
    logic once and reuse it with many C++ classes. Also, this chapter marks the end
    of *Part 3*, *How to Call C++* *from Lua*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们实现了一个通用的 C++ 模块导出器，主要用于对象创建部分。这确保了你只需实现一次复杂对象创建逻辑，就可以与许多 C++ 类一起重用。此外，这一章标志着
    *第 3 部分*，*从 Lua 调用 C++* 的结束。
- en: In the following chapter, we will recap the different communication mechanisms
    between Lua and C++ and explore them further.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾 Lua 和 C++ 之间的不同通信机制，并进一步探讨它们。
- en: Exercise
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: This is an open exercise. You can write a new C++ class, or find one from your
    work in the past, and then export it to Lua with `LuaModuleExporter`. Try to provide
    an interesting `createInstance` implementation as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放练习。你可以编写一个新的 C++ 类，或者找到你过去工作中的某个类，然后使用 `LuaModuleExporter` 将其导出到 Lua。尝试提供一个有趣的
    `createInstance` 实现以及。
- en: Part 4 – Advanced Topics
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 部分 – 高级主题
- en: By this point of the book, you will have learned all the common mechanisms to
    integrate Lua with C++.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你将已经学会了所有将 Lua 与 C++ 集成的常见机制。
- en: In this part, you will recap what you have learned, which will also serve as
    a source for quick reference. You will also learn how to implement a standalone
    C++ module that can be loaded by Lua, as a dynamic loadable library. Then, you
    will learn some advanced memory management techniques and how to implement multithreading
    with Lua.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将回顾你所学的知识，这也可以作为快速参考的来源。你还将学习如何实现一个可以被Lua加载的独立C++模块，作为一个可动态加载的库。然后，你将学习一些高级内存管理技术以及如何使用Lua实现多线程。
- en: 'This part comprises the following chapters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '*Chapter 9*, *Recapping Lua-C++ Communication Mechanisms*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章*，*回顾Lua-C++通信机制*'
- en: '*Chapter 10*, *Managing Resources*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10章*，*管理资源*'
- en: '*Chapter 11*, *Multithreading with Lua*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*使用Lua进行多线程*'
