- en: Chapter 2. The First Brush with Boost's Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Boost实用程序的初次接触
- en: 'Over the course of this book, we will focus on a number of Boost libraries
    that deal with different subsystems, such as filesystems, threads, network I/O,
    and a variety of containers, among others. In each chapter, we will delve into
    the details of a few such libraries. This chapter is different, in the sense that
    we will pick up a set of useful and varied tricks that will help you in almost
    all programming situations. To that end we have the following topics lined up
    for us:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们将专注于处理不同子系统的多个Boost库，例如文件系统、线程、网络I/O和各种容器等。在每一章中，我们将深入探讨一些这样的库的细节。这一章不同之处在于，我们将挑选一些有用和多样化的技巧，这些技巧几乎可以帮助您解决所有编程情况。为此，我们为我们列出了以下主题：
- en: Simple data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单数据结构
- en: Working with heterogeneous values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异构值
- en: Handling command-line arguments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: Other utilities and compile-time checks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他实用程序和编译时检查
- en: This is the kitchen-sink chapter that you can keep coming back to and scour
    for an interesting technique that would seem to apply to a problem at hand.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个厨房水槽章节，您可以不断回来查找一个在手头问题上似乎适用的有趣技术。
- en: Simple data structures
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单数据结构
- en: 'In this section, we will look at two different libraries that will help you
    create simple data structures of immediate usefulness: Boost.Optional and Boost.Tuple.
    Boost.Optional can be used to represent optional values; objects that may or may
    not be there. Boost.Tuple is used to create ordered sets of heterogeneous values.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两个不同的库，它们将帮助您创建立即有用的简单数据结构：Boost.Optional和Boost.Tuple。Boost.Optional可用于表示可选值；可能存在也可能不存在的对象。Boost.Tuple用于创建异构值的有序集合。
- en: Boost.Optional
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Optional
- en: 'Let us consider that you need to maintain about musicians in a data store.
    Among other things, you can look up the latest album released by an artiste. You
    have written a simple API in C++ for doing this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设您需要在数据存储中维护有关音乐家的信息。除其他事项外，您可以查找艺术家发布的最新专辑。您已经用C++编写了一个简单的API来实现这一点：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For simplicity we will ignore the possibility that two or more artistes could
    share the same name. Here is a simple implementation of this function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将忽略两个或更多艺术家可能共享相同名称的可能性。以下是这个函数的一个简单实现：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We store the names of artistes and their latest albums in a map called `latest_albums`.
    The `find_latest_album_of` function takes the name of an artiste and uses the
    `find` member function of `std::map` to look up the latest album. If it does not
    find an entry, it returns an empty string. Now, it is possible that some artistes
    have not released an album yet. Returning an empty string seems legit for such
    cases until you realize that musicians have their unique whims and sometimes,
    they release an album without a name. So, how do you distinguish between the cases
    where the musician is yet to release an album, versus where the musician's latest
    album was untitled? In one case, there is no value to return while in the other
    case, it is an empty string.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个名为`latest_albums`的映射中存储了艺术家的名字和他们的最新专辑。`find_latest_album_of`函数接受一个艺术家的名字，并使用`std::map`的`find`成员函数来查找最新专辑。如果找不到条目，它会返回一个空字符串。现在，有些艺术家可能还没有发布专辑。对于这种情况返回一个空字符串似乎是合理的，直到你意识到音乐家有他们独特的怪癖，有时会发布没有名字的专辑。那么，你如何区分音乐家尚未发布专辑的情况和音乐家最新专辑没有标题的情况？在一种情况下，没有值可返回，而在另一种情况下，它是一个空字符串。
- en: 'The `boost::optional<T>` template can be used to represent an optional value;
    one that may or may not be present. In this case, it is tailor-made for our problem.
    To represent a `std::string` value that may or may not be present, you use `boost::optional<std::string>`.
    We can rewrite the `find_latest_album_of` function using `boost::optional`, as
    shown in the following code listing:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::optional<T>`模板可用于表示可选值；可能存在也可能不存在的值。在这种情况下，它是为我们的问题量身定制的。要表示可能存在也可能不存在的`std::string`值，您可以使用`boost::optional<std::string>`。我们可以使用`boost::optional`重写`find_latest_album_of`函数，如下面的代码列表所示：'
- en: '**Listing 2.1: Using Boost.Optional**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2.1：使用Boost.Optional**'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We simply return the value found (line 14), which is automatically wrapped in
    a `boost::optional` container. If there is no value to return, we return a special
    object, `boost::none` (line 16). This causes an empty `boost::optional` object
    to be returned. The code using `boost::optional` does exactly what we need; it
    checks whether a key is present in the container and returns the value or indicates
    that it is absent without any ambiguity (that is, empty versus untitled).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地返回找到的值（第14行），它会自动包装在`boost::optional`容器中。如果没有值可返回，我们返回一个特殊对象`boost::none`（第16行）。这会导致返回一个空的`boost::optional`对象。使用`boost::optional`的代码正是我们需要的；它检查容器中是否存在一个键，并返回值，或指示它不存在，而没有任何歧义（即空与无标题）。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A default-initialized instance of `boost::optional` is always empty. If the
    value stored in `boost::optional` is movable (see [Appendix](apa.html "Appendix A. C++11
    Language Features Emulation"), *C++11 Language Features Emulation*), the wrapper
    `optional` object is also movable. If the stored value is copyable, the wrapper
    `optional` object is also copyable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::optional`的默认初始化实例始终为空。如果存储在`boost::optional`中的值是可移动的（参见[附录](apa.html
    "附录 A. C++11语言特性模拟")，*C++11语言特性模拟*），包装器`optional`对象也是可移动的。如果存储的值是可复制的，包装器`optional`对象也是可复制的。'
- en: 'We can generalize the lookup function in listing 2.1 to any container with
    a map-like or dictionary interface as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表2.1中的查找函数泛化到任何具有类似映射或字典接口的容器中，如下所示：
- en: '**Listing 2.2: Generic lookup using optional**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2.2：使用可选项进行通用查找**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have converted `lookup` to a function template that
    can be called on any `map`, `multimap`, their unordered variants, or any other
    nonstandard container, exposing a similar interface. It is parameterized on the
    container type `C`. The container type `C` must have nested type definitions:
    `key_type` and `mapped_type` corresponding to the types of keys and values the
    map stores; a constraint satisfied by `std:map` and other associative containers
    from the Standard Library.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已将`lookup`转换为函数模板，可以在任何`map`、`multimap`、它们的无序变体或任何其他非标准容器上调用，暴露类似的接口。它是基于容器类型`C`进行参数化的。容器类型`C`必须具有嵌套类型定义：`key_type`和`mapped_type`，对应于地图存储的键和值的类型；这是标准库中`std:map`和其他关联容器满足的约束。
- en: The use of the `typename` keyword (lines 4, 5, 7) may need some explanation.
    If we omit the `typename` keyword from these lines, the compiler will fail to
    identify `C::mapped_type`, `C::key_type`, and `C::const_iterator` as names of
    types. Because `mapped_type`, `key_type`, and `const_iterator` are names that
    are dependent on the type template parameter `C`, the compiler needs to be told
    that they identify types. We use the `typename` keyword to do this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`typename`关键字的使用（第4、5、7行）可能需要一些解释。如果我们从这些行中省略`typename`关键字，编译器将无法识别`C::mapped_type`、`C::key_type`和`C::const_iterator`作为类型的名称。因为`mapped_type`、`key_type`和`const_iterator`是依赖于类型模板参数`C`的名称，所以需要告诉编译器它们标识类型。我们使用`typename`关键字来做到这一点。'
- en: Accessing values stored in boost::optional
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问存储在boost::optional中的值
- en: 'You can check whether an `optional` object contains a value or is empty, and
    extract the value stored in a non-empty `optional` object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查`optional`对象是否包含值或为空，并提取非空`optional`对象中存储的值：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the code that calls `find_latest_album_of`, to test whether the returned
    value is empty, we invoke the object in a Boolean context (line 4). If it evaluates
    to `true`, it means that `album` is not empty. If it has a value, we can obtain
    a reference to the contained value using the overloaded `operator*` (line 10).
    We can access members of the underlying object using an overloaded `operator->`
    ; in this case we call the empty member function of `std::string` (line 7). We
    could also use get member function of a nonempty `boost::optional` object instead
    of the overloaded `operator*` to access the value stored. Dereferencing an empty
    optional value by calling the `operator*`, `get`, or `operator->` causes a runtime
    error, which is why we first check whether the `optional` object is empty before
    trying to dereference it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`find_latest_album_of`的代码中，为了测试返回的值是否为空，我们在布尔上下文中调用对象（第4行）。如果评估为`true`，这意味着`album`不为空。如果它有一个值，我们可以使用重载的`operator*`（第10行）获得对包含值的引用。我们可以使用重载的`operator->`访问底层对象的成员；在这种情况下，我们调用`std::string`的空成员函数（第7行）。我们还可以使用非空`boost::optional`对象的`get`成员函数来访问存储的值，而不是使用重载的`operator*`。通过调用`operator*`、`get`或`operator->`对空的可选值进行解引用会导致运行时错误，这就是为什么我们首先检查`optional`对象是否为空，然后再尝试对其进行解引用。
- en: get_value_or
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: get_value_or
- en: 'Using `optional`, we indicate that there may or may not be a value present
    for albums. But we would sometimes need to use APIs that should have taken optional
    values but do not. In such cases, we may want to return empty values with some
    default value. Imagine residents of Paris being asked about their favorite city
    and for those who do not name one, Paris being used as the default favorite:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`optional`，我们指示专辑可能有也可能没有值。但有时我们需要使用应该接受可选值但没有的API。在这种情况下，我们可能希望返回带有一些默认值的空值。想象一下，问巴黎居民他们最喜欢的城市，对于那些没有回答的人，巴黎将被用作默认最爱：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the imaginary `getFavoriteCity` function returns an empty value, we want
    `Paris` to be passed to the `printFavoriteCity` function. We do this using the
    `get_value_or` member function (line 14).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想象中的`getFavoriteCity`函数返回一个空值，我们希望将`Paris`传递给`printFavoriteCity`函数。我们使用`get_value_or`成员函数来实现这一点（第14行）。
- en: Boost.Optional versus pointers
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Boost.Optional与指针
- en: If we did not use `optional`, what would the functions `find_last_album_of`
    or `lookup` return in order to indicate that there was no value found? They would
    either need to return a pointer to a dynamically-allocated object or `nullptr`
    if there was no value found. Besides using dynamic memory, it requires that the
    caller function manage the lifetime of the dynamically-allocated object that is
    returned. This condition can be mitigated using smart pointers ([Chapter 3](ch03.html
    "Chapter 3. Memory Management and Exception Safety"), *Memory Management and Exception
    Safety*), but it does not eliminate free store allocations that are costly. The
    `boost::optional` class eliminates free store allocations and stores the encapsulated
    object in its layout. In addition, it stores a Boolean flag to keep track of whether
    it is initialized or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用`optional`，那么`find_last_album_of`或`lookup`函数会返回什么来指示没有找到值？它们要么需要返回指向动态分配对象的指针，要么在没有找到值时返回`nullptr`。除了使用动态内存，这还要求调用函数管理返回的动态分配对象的生命周期。这种情况可以通过智能指针（[第3章](ch03.html
    "第3章。内存管理和异常安全性")，“内存管理和异常安全性”）来缓解，但它并不能消除昂贵的自由存储分配。`boost::optional`类消除了自由存储分配，并将封装的对象存储在其布局中。此外，它存储一个布尔标志来跟踪它是否被初始化。
- en: Boost.Tuple
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Tuple
- en: 'Boost Tuples are a cool way to group disparate types of data together into
    ordered tuples and pass them around. Structures do the same thing but a couple
    of things set tuples apart:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Tuples是一种将不同类型的数据组合成有序元组并传递它们的很酷的方法。结构也可以做同样的事情，但元组有一些特殊之处：
- en: You can write generic code to manipulate tuples of all kinds, for example, to
    print all their members and comparing two tuples for similarity in structure and
    types.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写通用代码来操作各种元组，例如打印它们的所有成员并比较两个元组的结构和类型是否相似。
- en: Each new structure or class defines a new type in your software. Types should
    represent interfaces and behaviors. Representing every ad hoc clumping of data
    with a type results in proliferation of types that have no meaning in the problem
    space or its abstraction.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个新的结构或类在您的软件中定义了一个新的类型。类型应该表示接口和行为。用类型表示数据的每个临时聚集会导致类型的泛滥，这些类型在问题空间或其抽象中没有意义。
- en: A Boost Tuple is an incredibly useful library that helps you conveniently create
    schemas for moving related data around together, such as exchanging data between
    functions. Boost Tuples are a generalization of `std::pair`, which is used to
    create 2-element tuples.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Tuple是一个非常有用的库，它可以帮助您方便地创建用于一起移动相关数据的模式，例如在函数之间交换数据。Boost Tuples是`std::pair`的泛化，用于创建2元组。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using a C++ compiler with good C++11 support, you should use the
    `std::tuple` facility from the Standard Library—one of the Boost libraries that
    made it to the C++11 standard. The header to be included is `<tuple>`. Most of
    what we discuss here is applicable to `std::tuple`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用支持良好的C++11的C++编译器，应该使用标准库中的`std::tuple`工具，这是C++11标准中包含的Boost库之一。需要包含的头文件是`<tuple>`。我们在这里讨论的大部分内容都适用于`std::tuple`。
- en: Creating tuples
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建元组
- en: 'Let us look at an example. Given a series of stock prices at different points
    in time, we want to find out the best two points in time to buy and sell the stock
    to maximize the profit. We can assume that there is no option to short-sell, that
    is, you must buy before you sell. For simplicity, the input can be assumed to
    be a vector of doubles. In this vector, we are interested in the pair of indices
    that represent the best time to buy and sell the stock to maximize profit:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。给定不同时间点的股票价格系列，我们想要找出买入和卖出股票以最大化利润的最佳两个时间点。我们可以假设没有卖空的选项，也就是说，必须先买入再卖出。为简单起见，可以假定输入是一个双精度浮点数的向量。在这个向量中，我们对表示最佳买入和卖出股票的索引对感兴趣，以最大化利润：
- en: '**Listing 2.3: Using tuples**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.3：使用元组**'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function `getBestTransactDays` returns a tuple of two unsigned integers
    (`size_t`) and a double (line 4) that represent the two indices at which buying
    and selling the stock would maximize profit, and the maximum profit possible.
    The return type of the function is `boost::tuple<size_t, size_t, double>`. The
    header `boost/tuple/tuple.hpp` provides the necessary functions and types for
    working with tuples (line 1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getBestTransactDays`返回一个包含两个无符号整数（`size_t`）和一个双精度浮点数（第4行）的元组，表示买入和卖出股票的最大利润的两个索引，以及可能的最大利润。函数的返回类型是`boost::tuple<size_t,
    size_t, double>`。头文件`boost/tuple/tuple.hpp`提供了处理元组所需的函数和类型（第1行）。
- en: The function `getBestTransactDays` implements a simple linear algorithm that
    runs through the vector, keeping track of the lowest stock price seen so far.
    If the current element has a lesser value than the lowest stock price so far,
    then this is set as the new lowest, and its index is noted (lines 12-14). The
    function also keeps track of the maximum gain, that is, the maximum difference
    in prices noted so far. If we encounter an element whose difference from the lowest
    price is higher than the maximum gain, then we note this difference as the new
    maximum gain (line 15), and also note the days of transaction required to achieve
    this gain (lines 16-18).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getBestTransactDays`实现了一个简单的线性算法，通过遍历向量，跟踪到目前为止看到的最低股价。如果当前元素的值小于目前为止的最低股价，则将其设置为新的最低价，并记录其索引（第12-14行）。该函数还跟踪最大收益，即到目前为止记录的价格差的最大值。如果我们遇到一个与最低价的差值高于最大收益的元素，则将此差值记录为新的最大收益（第15行），并记录实现此收益所需的交易日（第16-18行）。
- en: 'We create the tuple using `boost::make_tuple` (line 22), which is a convenience
    function for creating tuples from its elements without explicit template instantiations.
    You could have also created and returned a tuple like this in place of line 22:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`boost::make_tuple`（第22行）创建元组，这是一个方便的函数，用于从其元素创建元组，而无需显式模板实例化。您也可以在第22行的位置创建并返回一个元组，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `boost::make_tuple` is more compact and, being a function template,
    resolves the types of its arguments automatically to create the tuple of correct
    types. This is a frequently seen pattern where you use a factory function template
    to instantiate a class template, thus automating type detection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`boost::make_tuple`更加紧凑，并且作为一个函数模板，它会自动解析其参数的类型，以创建正确类型的元组。这是一个经常见到的模式，您可以使用工厂函数模板来实例化类模板，从而自动检测类型。
- en: Accessing tuple elements
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问元组元素
- en: 'There are several ways in which we can access the elements in a tuple. Look
    at the following example of calling the `getBestTransactDays` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以访问元组中的元素。看一下调用`getBestTransactDays`函数的以下示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also unpack the elements in the tuple into individual variables using
    `boost::tie`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`boost::tie`将元组中的元素解包到单独的变量中：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding line of code will assign the first element of the tuple to `buyDay`,
    the second to `sellDay`, and the third to `profit`. If we are interested in only
    a subset of the elements in the tuple, we can ignore the others using `boost::tuples::ignore`.
    Here is the same example, but we have ignored `sellDay` this time using `boost::tuples::ignore`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将把元组的第一个元素分配给`buyDay`，第二个元素分配给`sellDay`，第三个元素分配给`profit`。如果我们只对元组中的部分元素感兴趣，可以使用`boost::tuples::ignore`忽略其他元素。以下是相同的示例，但这次我们使用`boost::tuples::ignore`忽略了`sellDay`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Comparing tuples
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较元组
- en: 'Tuples of the same length can be compared to relational operators, such as
    `==`, `<`, `>`, `<=`, and `>=`. In any such comparison, the corresponding elements
    at each position are compared. The types of elements at the corresponding positions
    need not be identical; they just need to be comparable using the relational operator
    in question:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相同长度的元组可以使用关系运算符进行比较，例如`==`，`<`，`>`，`<=`和`>=`。在任何这样的比较中，将比较每个位置上的对应元素。对应位置上的元素的类型不需要完全相同；它们只需要能够使用相关的关系运算符进行比较即可：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the actual types in tuples `t1` and `t2` are different, but both have
    the same length, and the elements at corresponding positions are comparable with
    each other. In general, comparison stops at the first pair of elements that determines
    the outcome of the comparison. In this example, all three elements are compared
    because the first two elements compare equal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元组`t1`和`t2`中的实际类型不同，但两者长度相同，并且相应位置的元素可以相互比较。通常，比较会在决定比较结果的第一对元素处停止。在这个例子中，所有三个元素都被比较，因为前两个元素相等。
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code is used to define relational operators for structs with
    very little code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于定义具有非常少代码的结构的关系运算符：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing generic code using tuples
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元组编写通用代码
- en: 'We will now write a generic function to find the number of elements in a tuple:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个通用函数来查找元组中元素的数量：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function simply uses the `boost::tuples::length<T>` metafunction to compute
    the number of elements in the tuple. This computation takes place at compile time.
    A **metafunction** is just a class template that has an accessible static member
    or a nested type computed at compile time from its template arguments (see [Chapter
    7](ch07.html "Chapter 7. Higher Order and Compile-time Programming"), *Higher
    Order and Compile-time Programming*, for a more rigorous definition). In this
    case, the `boost::tuples::length<T>` metafunction has a public static member called
    `value`, which is computed as the number of elements in the tuple `T`. If you
    use tuples from the Standard Library, you should use `std::tuple_size<T>` instead
    of `boost::tuples::length<T>`. This is just a small illustration of generic programming
    using metafunctions and type computation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地使用`boost::tuples::length<T>`元函数来计算元组中元素的数量。这个计算是在编译时进行的。**元函数**只是一个类模板，它具有从其模板参数在编译时计算出的可访问的静态成员或嵌套类型（参见[第7章](ch07.html
    "第7章。高阶和编译时编程")，“高阶和编译时编程”，有一个更严格的定义）。在这种情况下，`boost::tuples::length<T>`元函数有一个名为`value`的公共静态成员，它被计算为元组`T`中的元素数量。如果您使用标准库中的元组，应该使用`std::tuple_size<T>`而不是`boost::tuples::length<T>`。这只是一个使用元函数和类型计算的通用编程的小例子。
- en: Working with heterogeneous values
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异构值
- en: The need to have a value that can hold different types of data at different
    times during the lifetime of a program is not new. C++ supports the `union` construct
    of C, which essentially allows you to have a single type that can, at different
    times, assume values of different underlying POD types. **POD** or **Plain Old
    Data** types, roughly speaking, are types that do not require any special initialization,
    destruction, and copying steps and whose semantic equivalents may be created by
    copying their memory layouts byte for byte.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的生命周期中需要一个可以在不同时间点容纳不同类型数据的值并不是什么新鲜事。C++支持C的`union`构造，它本质上允许您拥有一个单一类型，可以在不同时间点假定不同底层POD类型的值。**POD**或**Plain
    Old Data**类型，粗略地说，是不需要任何特殊初始化、销毁和复制步骤的类型，其语义等效物可以通过逐字复制其内存布局来创建。
- en: These restrictions mean that most C++ classes, including a majority of those
    from the Standard Library, can never be part of a union. Starting with C++11,
    these restrictions on a union have been relaxed somewhat, and you can now store
    objects of types with nontrivial construction, destruction, and copy semantics
    (that is, non-POD types) in a union. However, the life cycle management of such
    objects stored in a union is not automatic and can be a pain in the neck, hence
    it is best avoided.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制意味着大多数C++类，包括大多数标准库中的类，永远不能成为联合的一部分。从C++11开始，对联合的这些限制有所放宽，现在可以在联合中存储具有非平凡构造、销毁和复制语义（即非POD类型）的对象。但是，存储在联合中的这些对象的生命周期管理不是自动的，可能会很麻烦，因此最好避免。
- en: Two libraries from Boost, Variant, and Any, provide useful variant types that
    provide the same functionality as unions without many of the restrictions. Using
    Variants and Any, storing heterogeneous data in the Standard Library containers
    becomes remarkably easy and error-free. These libraries represent discriminated
    union types. Values of a range of types can be stored in discriminated unions,
    and the type information is stored along with the value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Boost的两个库，Variant和Any，提供了有用的变体类型，提供了与联合相同的功能，但没有许多限制。使用Variants和Any，在标准库容器中存储异构数据变得非常容易和无误。这些库代表了可辨别的联合类型。各种类型的值可以存储在可辨别的联合中，并且类型信息与值一起存储。
- en: In addition to storing data of heterogeneous types, we frequently need to convert
    between different representations of the same data, for example, text to numeric
    and vice versa. Boost Conversion provides, among other things, a way to seamlessly
    convert between types using a uniform syntax. We look at Any, Variant, and Conversion
    libraries in the following sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储异构类型的数据，我们经常需要在不同表示之间进行转换，例如，文本到数字的转换以及反之。Boost Conversion提供了一种无缝转换类型的方法，其中包括使用统一的语法进行类型转换。我们将在以下部分中查看Any、Variant和Conversion库。
- en: Boost.Variant
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Variant
- en: Boost Variant avoids all that is wrong with C++ unions and provides a union-like
    construct defined over a fixed set of arbitrary types, not just POD types. We
    can define a variant datatype using the Boost Variant header-only library by instantiating
    the `boost::variant` template with a list of types. The list of types identifies
    the different types of values that the variant object can assume at different
    points in time. The different types in the list can be varied and unrelated, conforming
    to only one binding condition—that each of the types be copyable or at least movable.
    You may even create variants that contain other variants.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Variant避免了C++联合的所有问题，并提供了一个类似联合的构造，定义在一组任意类型上，而不仅仅是POD类型。我们可以使用Boost Variant头文件库定义一个变体数据类型，通过使用`boost::variant`模板实例化一个类型列表。类型列表标识了变体对象在不同时间点可以假定的不同类型的值。列表中的不同类型可以是多样的和不相关的，只需满足一个绑定条件——即每个类型都是可复制的或至少可移动的。甚至可以创建包含其他变体的变体。
- en: 'In our first example, we create a variant of an integer, a `std::string`, and
    two user-defined types `Foo` and `Bar`. With this, we illustrate the constraints
    on creating variant types and on operations that can be performed on such variant
    values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们创建了一个整数、一个`std::string`和两个用户定义类型`Foo`和`Bar`的变体。通过这个例子，我们说明了创建变体类型的约束以及可以对这种变体值执行的操作：
- en: '**Listing 2.4: Creating and using variants**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.4节：创建和使用变体
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create two bare bones types: `Foo` (line 4) and `Bar` (line 10); we can
    initialize both implicitly from `int`. We define a variant called `value` (line
    18) over three types, `Foo`, `int`, and `std::string`. A second variant, `value2`
    (line 20) is defined over `std::string`, `Foo`, and `Bar`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个基本类型：`Foo`（第4行）和`Bar`（第10行）；我们可以从`int`隐式初始化两者。我们定义了一个名为`value`的变体（第18行），它包含三种类型，`Foo`、`int`和`std::string`。第二个变体，`value2`（第20行），定义为`std::string`、`Foo`和`Bar`。
- en: By default, each variant instance is value-initialized to an object of its first
    type. Thus, `value` is default-constructed to a `Foo` instance—the first type
    in the list of type parameters to the variant. Similarly, `value2` is default-constructed
    to `std::string`—the first type in its list of type parameters. If the first type
    is a POD type, it is zero-initialized. Thus, the first type must be default constructible
    for the variant to be default constructible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个变体实例都被值初始化为其第一个类型的对象。因此，`value`被默认构造为`Foo`实例——在变体的类型参数列表中的第一个类型。同样，`value2`被默认构造为`std::string`——在其类型参数列表中的第一个类型。如果第一个类型是POD类型，它将被零初始化。因此，第一个类型必须是默认可构造的，变体才能是默认可构造的。
- en: We assign an integer to `value` (line 22). This sets it to be an `int` and not
    `Foo`, which an integer is implicitly convertible to. We confirm this using the
    `boost::get<T>` function template on the address of `value` with `T=int` (line
    23), and we confirm that it is not null (line 24).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个整数赋给`value`（第22行）。这将使它成为`int`而不是`Foo`，因为整数可以隐式转换为`Foo`。我们使用`boost::get<T>`函数模板在`value`的地址上使用`T=int`（第23行）进行确认，并确认它不是空指针（第24行）。
- en: We assign a `const char*` to `value` (line 25), which implicitly converts to
    `std::string` that gets stored in `value`, overwriting the integer value stored
    earlier. Next, we assign an object of `Foo` (line 26), which overwrites the earlier
    `std::string` value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`const char*`赋给`value`（第25行），它隐式转换为`std::string`，并存储在`value`中，覆盖了先前存储的整数值。接下来，我们分配了一个`Foo`对象（第26行），它覆盖了先前的`std::string`值。
- en: If we try to assign an integer to `value2` (line 28, commented), it will cause
    a compilation error. The variable `value2` being a variant defined over `std::string`,
    `Foo`, and `Bar`, an integer can implicitly be converted to either `Foo` or `Bar`
    and neither is a better choice—hence, it causes ambiguity and the compiler throws
    an error. In general, variant initialization and assignment should not result
    in an ambiguity over which type to instantiate within the variant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将整数分配给`value2`（第28行，已注释），它将导致编译错误。变量`value2`被定义为`std::string`、`Foo`和`Bar`的变体，整数可以隐式转换为`Foo`或`Bar`，但都不是更好的选择，因此会导致歧义，编译器会抛出错误。通常情况下，变体的初始化和赋值不应该导致对变体中要实例化的类型产生歧义。
- en: If we try to stream the contents of `value` to `std::cout` (line 29, commented),
    then again, we would encounter a compilation error. This would be because one
    of the types (`Foo`) supported by the variant is not *streamable*, which means
    it cannot be written to `ostreams` using the insertion operator (`<<`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将`value`的内容流式传输到`std::cout`（第29行，已注释），那么同样，我们将遇到编译错误。这是因为变体支持的类型之一（`Foo`）不可*流式传输*，这意味着它不能使用插入运算符（`<<`）写入到`ostreams`中。
- en: Accessing values in a variant
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问变体中的值
- en: 'We use the `boost::get<T>` function template to access the value of type `T`
    in a variant, where `T` is the concrete type of the value we want. This function,
    when called on a variant reference, returns a reference to the stored value or
    throws a `boost::bad_get` exception if the stored value is not of the type specified.
    When called on a pointer to a variant, it returns the address of the stored value
    or a null pointer if the stored value is not of the specified type. The latter
    behavior can be used to test whether a variant stores a particular type of value
    or not, the way it was used in listing 2.4 (line 23). This behavior of `get<>`
    closely mirrors that of `dynamic_cast`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`boost::get<T>`函数模板来访问变体中类型为`T`的值，其中`T`是我们想要的具体类型的值。当在变体引用上调用此函数时，如果存储的值不是指定类型，则返回对存储值的引用，或抛出`boost::bad_get`异常。当在指向变体的指针上调用时，如果存储的值不是指定类型，则返回存储值的地址，如果存储的值不是指定类型，则返回空指针。后者的行为可以用来测试变体是否存储了特定类型的值，就像在列表2.4（第23行）中使用的那样。`get<>`的这种行为与`dynamic_cast`的行为非常相似：
- en: '**Listing 2.5: Accessing values in a variant**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.5节：访问变体中的值
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we create a variant `v1` that can store a `std::string`
    or an `int` value (line 6). We set `v1` to the character string `"19937"` (line
    7). We use the `boost::get<int>` function to try and get an integer from `v1`
    (line 11) but, since `v1` stores a `string` at this point, this results in an
    exception being thrown. Next, we use the pointer overload of `boost::get<int>`
    that takes the address of the variant `v1`. This returns the pointer to the stored
    value if its type matches the one requested via `get` function's template parameter.
    If it does not, as in this case, a null pointer is returned (lines 16 and 17).
    Finally, we can get the zero-based index of the type of the value that is currently
    stored in the variant by calling the `which` member function. Since `v1` contains
    `std::string` and the declared type of `v1` is `boost::variant<std::string, int>`,
    therefore `v1.which()` should return the index of `std::string` in the variant's
    declaration—0 in this case (line 19).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个变体`v1`，可以存储`std::string`或`int`值（第6行）。我们将`v1`设置为字符串`"19937"`（第7行）。我们使用`boost::get<int>`函数尝试从`v1`中获取整数（第11行），但由于此时`v1`存储的是一个字符串，所以会抛出异常。接下来，我们使用`boost::get<int>`的指针重载，该重载获取变体`v1`的地址。如果其类型与通过`get`函数的模板参数请求的类型匹配，则返回存储值的指针。如果不匹配，就像在这种情况下一样，将返回空指针（第16和17行）。最后，我们可以通过调用`which`成员函数获取当前存储在变体中的值的类型的从零开始的索引。由于`v1`包含`std::string`，并且`v1`的声明类型是`boost::variant<std::string,
    int>`，因此`v1.which()`应该返回变体声明中`std::string`的索引——在这种情况下是0（第19行）。
- en: Compile-time visitation
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译时访问
- en: How the value stored in a variant is consumed usually depends on the type of
    the value. Checking a variant for each possible type using an if-else ladder can
    quickly aggravate the readability and maintainability of your code. Of course,
    we can find out the zero-based index of the type of the current value using the
    `which` member method of the variant, but it would be of little immediate use.
    Instead, we will look at a very elegant and versatile compile-time visitation
    mechanism provided by the Boost Variant library without which handling variants
    would be quite a drag.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 变体中存储的值如何被消耗通常取决于值的类型。使用if-else梯子检查变体的每种可能类型可能会迅速加剧代码的可读性和可维护性。当然，我们可以使用变体的`which`成员方法找出当前值的类型的从零开始的索引，但这对我们目前没有什么用。相反，我们将看一下Boost
    Variant库提供的非常优雅和多功能的编译时访问机制，没有这个机制，处理变体将会相当麻烦。
- en: The idea is to create a visitor class that contains an overloaded function call
    operator (`operator()`) to handle each type that may be stored in the variant.
    Using the function `boost::apply_visitor`, we can invoke the appropriate overload
    in the visitor class on a variant object, based on the type of value it contains.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一个访问者类，其中包含一个重载的函数调用运算符（`operator()`），用于处理可能存储在变体中的每种类型。使用函数`boost::apply_visitor`，我们可以根据它包含的值的类型在变体对象上调用访问者类中的适当重载。
- en: 'The visitor class should publicly inherit from the `boost::static_visitor<T>`
    template, where `T` is the return type of the overloaded function call operator.
    By default, `T` is `void`. Let us look at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者类应该公开继承`boost::static_visitor<T>`模板，其中`T`是重载的函数调用运算符的返回类型。默认情况下，`T`是`void`。让我们看一个例子：
- en: '**Listing 2.6: Compile-time visitation of variants**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.6：变体的编译时访问**'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We create a variant over the types `std::string`, `long`, and `double` called
    `v1` (line 14). We set it to a value of type `double` (line 15). Finally, we invoke
    a visitor of type `SimpleVariantVistor` on `v1` (line 17). The `SimpleVariantVisitor`
    inherits from `boost::apply_visitor<void>` (line 3) and contains overloads of
    `operator()` for `std::string` (line 5) and `long` (line 8) but not `double`.
    Each overload prints its argument to the standard output.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类型为`std::string`、`long`和`double`的变体称为`v1`（第14行）。我们将其设置为类型为`double`的值（第15行）。最后，我们在`v1`上调用类型为`SimpleVariantVistor`的访问者（第17行）。`SimpleVariantVisitor`继承自`boost::apply_visitor<void>`（第3行），并包含`std::string`（第5行）和`long`（第8行）的重载，但没有`double`的重载。每个重载都将其参数打印到标准输出。
- en: The resolution of overloads happens at compile time rather than at runtime.
    Thus, an overload must be available for every type of value that the variant may
    contain. A particular overload is invoked if its parameter type is the best match
    for the type of the value stored in the variant. Moreover, a single overload may
    handle multiple types if all the types are convertible to the type of the argument
    of the overload.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的解析发生在编译时而不是运行时。因此，每种值类型的重载必须可用。如果其参数类型是最适合变体中存储的值类型的类型，则会调用特定的重载。此外，如果所有类型都可以转换为重载的参数类型，则单个重载可以处理多种类型。
- en: Interestingly, in the preceding example, there is no overload available for
    `double`. However, narrowing conversions are allowed and the overload for `long`
    is invoked with potential narrowing. In this case, the overload for `long` handles
    both `long` and `double` types. On the other hand, if we had separate overloads
    available for `double` and `long` but none for `std::string`, we would have had
    a compilation error. This would happen because not even a narrowing conversion
    would be available from `std::string` to either `long` or `double`, and the overload
    resolution would fail. Being a compile-time mechanism, this is independent of
    the type of the actual value stored in a variant object at any time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在前面的例子中，没有`double`的重载可用。然而，允许缩小转换，并且使用`long`的重载进行潜在的缩小。在这种情况下，`long`的重载处理`long`和`double`类型。另一方面，如果我们有`double`和`long`的单独重载，但没有`std::string`的重载，我们将会遇到编译错误。这是因为从`std::string`到`long`或`double`甚至没有缩小转换可用，重载解析将失败。作为编译时机制，这与变体对象中实际存储的值的类型无关。
- en: Generic visitors
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用访问者
- en: 'You may create a member function template that handles a family of types. In
    cases where the code for handling different types does not significantly differ,
    it may make sense to have such member templates. Here is an example of a visitor
    which prints the contents of the variant:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个处理一系列类型的成员函数模板。在处理不同类型的代码没有显着差异的情况下，可能有意义使用这样的成员模板。以下是一个打印变体内容的访问者的示例：
- en: '**Listing 2.7: Generic compile-time visitation**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.7：通用的编译时访问**'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we define a variant over the types `std::string`, `double`,
    `long`, and `Foo`. The visitor class `PrintVisitor` contains a generic `operator()`.
    As long as all the types in the variant are *streamable*, this code will compile
    and print the value of the variant to the standard output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了一个类型为`std::string`、`double`、`long`和`Foo`的变体。访问者类`PrintVisitor`包含一个通用的`operator()`。只要变体中的所有类型都是*可流化的*，这段代码就会编译并将变体的值打印到标准输出。
- en: Applying visitors to variants in a container
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将访问者应用于容器中的变体
- en: 'Often, we have an STL container of variant objects, and we want to visit each
    object using our visitor. We can utilize the `std::for_each` STL algorithm and
    a single-argument overload of `boost::apply_visitor` for the purpose. The single-argument
    overload of `boost::apply_visitor` takes a visitor instance and returns a functor
    that applies the visitor to a passed element. The following example best illustrates
    the usage:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们有一个包含变体对象的STL容器，并且我们希望使用我们的访问者访问每个对象。我们可以利用`std::for_each` STL算法和`boost::apply_visitor`的单参数重载来实现这一目的。`boost::apply_visitor`的单参数重载接受一个访问者实例，并返回一个将访问者应用于传递的元素的函数对象。以下示例最好说明了用法：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Defining recursive variants
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义递归变体
- en: The last few years have seen a phenomenal growth in the popularity of one particular
    data interchange format—JavaScript Object Notation or JSON. It is a simple text-based
    format that is often less verbose XML. Originally used as object literals in JavaScript,
    the format is more readable than XML. It is also a relatively simple format that
    is easy to understand and parse. In this section, we will represent well-formed
    JSON content using `boost::variants` and see how variants can handle recursive
    definitions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年中，有一个特定的数据交换格式—JavaScript对象表示法或JSON—的流行度呈现了惊人的增长。它是一种简单的基于文本的格式，通常比XML更简洁。最初用作JavaScript中的对象文字，该格式比XML更易读。它也是一种相对简单的格式，易于理解和解析。在本节中，我们将使用`boost::variants`来表示格式良好的JSON内容，并看看变体如何处理递归定义。
- en: The JSON format
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON格式
- en: 'To start with, we will look at an example of people records in the JSON notation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一个人员记录的JSON表示的例子：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code is an example of a JSON object—it contains key-value pairs
    identifying the attributes of an unnamed object. The attribute names are quoted
    strings, such as `"Name"`, `"Age"`, `"PhoneNumbers"` (of which you can have more
    than one), and `"Address"`. Their values could be simple strings (`"Name"`) or
    numeric values (`"Age"`), or arrays of such values (`"PhoneNumbers"`) or other
    objects (`"Address"`). A single colon (`:`) separates keys from values. The key-value
    pairs are separated by commas. The list of key-value pairs in an object are enclosed
    in curly braces. This format allows arbitrary levels of nesting as seen in the
    case of the `"Address"` attribute whose value itself is an object. You can create
    more nested objects that are values of attributes of other nested objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个JSON对象的示例——它包含标识未命名对象属性的键值对。属性名称是带引号的字符串，例如`"Name"`、`"Age"`、`"PhoneNumbers"`（可以有多个）和`"Address"`。它们的值可以是简单字符串（`"Name"`）或数值（`"Age"`），或这些值的数组（`"PhoneNumbers"`）或其他对象（`"Address"`）。一个冒号（`:`）将键与值分开。键值对之间用逗号分隔。对象中的键值对列表用大括号括起来。这种格式允许任意级别的嵌套，如`"Address"`属性的值本身就是一个对象。您可以创建更多嵌套对象，这些对象是其他嵌套对象属性的值。
- en: 'You may combine many such records together in an array, which are enclosed
    in square brackets and separated by commas:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将许多这样的记录组合在一个数组中，这些记录被方括号括起来，并用逗号分隔：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A well-formed JSON text contains an object or an array of zero or more objects,
    numeric values, strings, Booleans, or null values. An object itself contains zero
    or more unique attributes each represented by a unique string. The value of each
    attribute can be a string, numeric value, Boolean value, null value, another object,
    or an array of such values. Thus, the basic tokens in JSON content are numeric
    values, strings, Booleans, and nulls. The aggregates are objects and arrays.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个格式良好的JSON文本包含一个对象或零个或多个对象、数值、字符串、布尔值或空值的数组。对象本身包含零个或多个由唯一字符串表示的唯一属性。每个属性的值可以是字符串、数值、布尔值、空值、另一个对象或这些值的数组。因此，JSON内容中的基本令牌是数值、字符串、布尔值和空值。聚合是对象和数组。
- en: Representing JSON content with recursive variants
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用递归变体表示JSON内容
- en: 'If we were to declare a variant to represent a basic token in a JSON, it would
    look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要声明一个变体来表示JSON中的基本令牌，它会是这样的：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The type `JSONNullType` is an empty type that may be used to represent a null
    element in JSON.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`JSONNullType`是一个空类型，可以用来表示JSON中的空元素。
- en: To extend this variant to represent more complex JSON content, we will try to
    represent a JSON object—a key-value pair as a type. The keys are always strings,
    but the values can be any of the types listed above or another nested object.
    So, the definition of a JSON object is essentially recursive, and this is why
    we need a recursive variant definition to model it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个变体以表示更复杂的JSON内容，我们将尝试表示一个JSON对象——一个键值对作为一种类型。键始终是字符串，但值可以是上面列出的任何类型或另一个嵌套对象。因此，JSON对象的定义本质上是递归的，这就是为什么我们需要递归变体定义来对其进行建模。
- en: 'To include the definition of a JSON object in the preceding variant type, we
    use a metafunction called `boost::make_recursive_variant`. It takes a list of
    types and defines the resultant recursive variant type as a nested type called
    `type`. So, here is how we write a recursive definition of the variant:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在前述变体类型中包含JSON对象的定义，我们使用一个名为`boost::make_recursive_variant`的元函数。它接受一个类型列表，并将生成的递归变体类型定义为一个名为`type`的嵌套类型。因此，这是我们如何编写变体的递归定义的方式：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `#define` statement on line 1 may be necessary for many compilers where
    the support for recursive variants, especially using `make_recursive_variant`,
    is limited.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行的`#define`语句可能对许多编译器是必要的，特别是对于支持递归变体的使用`make_recursive_variant`的限制。
- en: We define the recursive variant using the `boost::make_recursive_variant` metafunction
    (line 6). In the list of types, we add a new type `std::map` with keys of type
    `std::string` (line 11) and values of type `boost::recursive_variant_` (line 12).
    The special type `boost::recursive_variant_` is used to indicate that the outer
    variant type can occur as a value in the map itself. Thus, we have captured the
    recursive nature of a JSON object in the variant definition.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`boost::make_recursive_variant`元函数（第6行）定义递归变体。在类型列表中，我们添加了一个新类型`std::map`，其键的类型为`std::string`（第11行），值的类型为`boost::recursive_variant_`（第12行）。特殊类型`boost::recursive_variant_`用于指示外部变体类型可以作为映射中的值出现。因此，我们在变体定义中捕获了JSON对象的递归特性。
- en: 'This definition is still not complete. A well-formed JSON content may contain
    arrays of elements of all these different kinds. Such arrays may also be the values
    of an object''s attributes or be nested inside other arrays. If we choose to represent
    an array by a vector, then an extension of the preceding definition is easy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义还不完整。一个格式良好的JSON内容可能包含所有这些不同类型的元素的数组。这些数组也可以是对象属性的值，或者嵌套在其他数组中。如果我们选择用向量来表示一个数组，那么对前述定义的扩展就很容易了：
- en: '**Listing 2.8a: Recursive variant for JSON**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.8a：JSON的递归变体**'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We add one more type—`std::vector<boost::recursive_variant_>` (line 13)—which
    represents an array of `JSONValue` objects. By virtue of this one additional line,
    we now support several more possibilities:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个类型——`std::vector<boost::recursive_variant_>`（第13行），它表示了`JSONValue`对象的数组。凭借这一额外的行，我们现在支持了更多的可能性：
- en: A top-level array consisting of JSON objects, other JSON arrays, and the basic
    types of tokens
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层数组由JSON对象、其他JSON数组和基本类型的标记组成
- en: An array-valued attribute of an object
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的数组值属性
- en: An array-valued element in another JSON array
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个JSON数组中的数组值元素
- en: This is the complete definition of `JSONValue`. In addition, we create typedefs
    for the recursive aggregate types—JSON arrays and JSON objects (line 16 and 17).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`JSONValue`的完整定义。此外，我们为递归聚合类型——JSON数组和JSON对象创建了typedefs（第16行和第17行）。
- en: Visiting recursive variants
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问递归变体
- en: 'We shall now write a visitor to print JSON data stored in a variant in its
    standard notation. Visiting a recursive variant is not different from visiting
    a nonrecursive one. We still need to define overloads that can handle all types
    of values that the variant may store. In addition, in the overloads for the recursive
    aggregate types (in this case, `JSONArray` and `JSONObject`), we may need to recursively
    visit each of its elements:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个访问者，以标准表示法打印存储在变体中的JSON数据。访问递归变体与访问非递归变体没有区别。我们仍然需要定义能够处理变体可能存储的所有类型值的重载。此外，在递归聚合类型（在本例中为`JSONArray`和`JSONObject`）的重载中，我们可能需要递归访问其每个元素：
- en: '**Listing 2.8b: Visiting recursive variants**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.8b：访问递归变体**'
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The visitor `JSONPrintVisitor` inherits publicly from `boost::static_visitor<void>`
    and provides overloads of `operator()` for the different possible types of JSON
    values. There is an overload for `std::string` (line 6), which prints strings
    in double quotes (line 8) after escaping any embedded quotes and other characters
    that need escaping. For this, we assume the availability of a function called
    `escapeStr`. We have a second overload for the `JSONNullType` (line 11), which
    just prints the string `null` without quotes. Other types of values, such as `double`
    or `bool` are handled by the member template (line 17). For `bool` values, it
    prints the unquoted strings `true` and `false` using the `std::boolalpha` `ostream`
    manipulator (line 19).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者`JSONPrintVisitor`公开继承自`boost::static_visitor<void>`，并为JSON值的不同可能类型提供了`operator()`的重载。它有一个`std::string`的重载（第6行），它在转义任何嵌入引号和其他需要转义的字符后，用双引号打印字符串（第8行）。为此，我们假设有一个名为`escapeStr`的函数可用。我们还有一个`JSONNullType`（第11行）的重载，它只是打印不带引号的字符串`null`。其他类型的值，如`double`或`bool`，由成员模板处理（第17行）。对于`bool`值，它使用`std::boolalpha`
    `ostream`操作器（第19行）打印不带引号的字符串`true`和`false`。
- en: The main work is done by the two overloads for `JSONArray` (line 22) and `JSONObject`
    (line 34). The `JSONArray` overload prints the elements of the array enclosed
    in square brackets and separated by commas. It prints the first element of the
    vector of `JSONValues` (line 27) and then, applies the `std::for_each` generic
    algorithm on this vector, starting with its second element to print the subsequent
    elements separated by commas (line 28). For this purpose, it passes as the third
    argument to `std::for_each`, a pointer to the function `printArrElem`. The `printArrElem`
    (line 52) function prints each element by applying `JSONPrintVisitor` (line 54).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作由`JSONArray`（第22行）和`JSONObject`（第34行）的两个重载完成。`JSONArray`重载打印了用方括号括起来并用逗号分隔的数组元素。它打印了`JSONValues`向量的第一个元素（第27行），然后对这个向量应用`std::for_each`通用算法，从第二个元素开始打印后续元素并用逗号分隔（第28行）。为此，它将`printArrElem`函数的指针作为第三个参数传递给`std::for_each`。`printArrElem`（第52行）函数通过应用`JSONPrintVisitor`（第54行）打印每个元素。
- en: The `JSONObject` overload prints the elements of the map as a comma-separated
    list of key-value pairs. The first pair is printed as a quoted, escaped key (line
    40), then a colon (line 41) followed by a call to `boost::apply_visitor` (line
    42). Subsequent pairs are printed separated by commas from the preceding ones
    by iterating over the remaining elements of the map using the `std::for_each`
    and `printObjAttr` function pointers (line 45). The logic is analogous to that
    in the `JSONArray` overload. The `printObjAttr` function (line 57) prints each
    key-value pair passed to it, prefixing a comma (line 58), printing the escaped,
    quoted key (line 59), prints a colon (line 60), and invoking the visitor on the
    variant value (line 61).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONObject`重载将映射的元素打印为以逗号分隔的键值对列表。第一对被打印为带引号的转义键（第40行），然后是一个冒号（第41行），接着调用`boost::apply_visitor`（第42行）。后续的对通过使用`std::for_each`和`printObjAttr`函数指针（第45行）迭代映射的剩余元素，以逗号分隔前面的对来打印。这个逻辑类似于`JSONArray`的重载。`printObjAttr`函数（第57行）打印传递给它的每个键值对，前缀是一个逗号（第58行），打印转义的带引号的键（第59行），打印一个冒号（第60行），并在变体值上调用访问者（第61行）。'
- en: Boost.Any
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Any
- en: The Boost Any library takes a different route to store heterogeneous data than
    Boost Variant. Unlike Variant, Any allows you to store almost any type of data
    not limited to a fixed set and maintains the runtime type information of the stored
    data. Thus, it does not use templates at all and requires that **Runtime Type
    Identification** (**RTTI**) be enabled, while compiling the code using Boost Any
    (most modern compilers keep this enabled by default).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Any库采用了与Boost Variant不同的方法来存储异构数据。与Variant不同，Any允许您存储几乎任何类型的数据，而不限于固定集合，并且保留存储数据的运行时类型信息。因此，它根本不使用模板，并且要求在使用Boost
    Any编译代码时启用**运行时类型识别**（**RTTI**）（大多数现代编译器默认情况下保持启用）。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the Boost Any library to work correctly, you must not disable the generation
    of RTTI for your programs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Boost Any库正常工作，您不能禁用程序的RTTI生成。
- en: 'In the following example, we create instances of `boost::any` to store numeric
    data, character arrays, and non-POD type objects:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们创建了`boost::any`的实例来存储数字数据、字符数组和非POD类型对象：
- en: '**Listing 2.9: Using Boost Any**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.9：使用Boost Any**'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also use a nonthrowing version of `any_cast` by passing the address
    of an `any` object instead of a reference. This returns a null pointer, instead
    of throwing an exception if the stored type does not match the type it is cast
    to. The following snippet illustrates this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`any_cast`的非抛出版本，而不是传递引用的方式，而是传递`any`对象的地址。如果存储的类型与要转换的类型不匹配，这将返回一个空指针，而不是抛出异常。以下代码片段说明了这一点：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We pass the address of `any` objects to `any_cast` (lines 3, 5, 8, and 9),
    and it returns null unless the type parameter to `any_cast` matches the type of
    the value stored in the `any` object. Using the pointer overload of `any_cast`,
    we can write a generic predicate to check whether an `any` variable stores a value
    of a given type:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`any`对象的地址传递给`any_cast`（第3、5、8和9行），除非`any_cast`的类型参数与`any`对象中存储的值的类型匹配，否则它将返回空值。使用`any_cast`的指针重载，我们可以编写一个通用的谓词来检查`any`变量是否存储了给定类型的值：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how you would use it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您将如何使用它：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This behavior of `boost::any_cast` emulates how `dynamic_cast` works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::any_cast`的这种行为模拟了`dynamic_cast`的工作原理。'
- en: 'In listing 2.9, we used different instances of the type `boost::any` to store
    different types of values. But the same instance of `boost::any` can store different
    types of values at different times. The following snippet illustrates this using
    the `swap` member function of `any`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单2.9中，我们使用不同的`boost::any`类型的实例来存储不同类型的值。但是，同一个`boost::any`实例可以在不同的时间存储不同类型的值。以下代码片段使用`any`的`swap`成员函数说明了这一点：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We first assign a value of type `double` to `v1` (line 7), which was carrying
    a value of type `int` (line 1). Next, we swap the contents of `v1` with `v2` (line
    8), which was carrying a value of type `std::string` (line 2). We can now expect
    `v1` to contain a `std::string` value (line 9) and `v2` to contain a `double`
    value (line 10).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`double`类型的值赋给`v1`（第7行），而它原来是`int`类型的值（第1行）。接下来，我们交换`v1`的内容与`v2`（第8行），而`v2`原来是`std::string`类型的值（第2行）。现在我们可以期望`v1`包含一个`std::string`值（第9行），而`v2`包含一个`double`值（第10行）。
- en: 'Besides using the pointer overload of `any_cast`, we can also use the `type`
    member function of `any` to access the type of the stored value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`any_cast`的指针重载，我们还可以使用`any`的`type`成员函数来访问存储值的类型：
- en: '**Listing 2.10: Accessing type information in Any**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.10：在Any中访问类型信息**'
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The type member function of `any` returns an object of `std::type_info` (defined
    in the Standard Library header `<typeinfo>`). To check whether this type is the
    same as a given type, we compare it with the `type_info` object obtained by applying
    the `typeid` operator on the given type (in this case, it is `int`). Instead of
    directly comparing the two `type_info` objects, we compare their hash codes obtained
    using the `hash_code` member function of `type_info`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`的`type`成员函数返回一个`std::type_info`对象（在标准库头文件`<typeinfo>`中定义）。为了检查这个类型是否与给定的类型相同，我们将其与通过对给定类型应用`typeid`运算符获得的`type_info`对象进行比较（在本例中是`int`）。我们不直接比较这两个`type_info`对象，而是比较它们使用`type_info`的`hash_code`成员函数获得的哈希码。'
- en: Boost.Conversion
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Conversion
- en: If you have ever tried parsing a text input (from a file, standard input, network,
    and so on) and tried a semantic translation of the data in it, you would have
    possibly felt the need for an easy way to convert text to numeric values. The
    opposite problem is to write text output based on values of numeric and textual
    program variables. The `basic_istream` and `basic_ostream` classes provide facilities
    for reading and writing specific types of values. However, the programming model
    for such uses is not very intuitive or robust. The C++ Standard Library and its
    extensions offer various conversion functions with various degrees of control,
    flexibility, and a general lack of usability. For example, there exists a whole
    slew of functions that convert between numeric and character formats or the other
    way round (for example, `atoi`, `strtol`, `strtod`, `itoa`, `ecvt`, `fcvt`, and
    so on). If we were trying to write generic code for converting between types,
    we would not even have the option of using any of these functions, which only
    work for conversions between specific types. How can we define a generic conversion
    syntax that can be extended to arbitrary types?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾尝试解析文本输入（来自文件、标准输入、网络等）并尝试对其中的数据进行语义转换，您可能会感到需要一种将文本转换为数值的简便方法。相反的问题是根据数值和文本程序变量的值编写文本输出。`basic_istream`和`basic_ostream`类提供了读取和写入特定类型值的功能。然而，这些用法的编程模型并不直观或健壮。C++标准库及其扩展提供了各种转换函数，具有不同程度的控制、灵活性和普遍缺乏可用性。例如，存在一整套函数，用于在数值和字符格式之间进行转换，或者反过来（例如，`atoi`、`strtol`、`strtod`、`itoa`、`ecvt`、`fcvt`等）。如果我们尝试编写用于类型转换的通用代码，我们甚至无法使用这些函数中的任何一个，因为它们只适用于特定类型之间的转换。我们如何定义一个通用的转换语法，可以扩展到任意类型？
- en: The Boost `Conversion` library introduces a couple of function templates that
    provide a very intuitive and uniform conversion syntax, which can also be extended
    through user-defined specializations. We will look at the conversion templates
    one by one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Boost `Conversion`库引入了一对函数模板，提供了非常直观和统一的转换语法，也可以通过用户定义的特化进行扩展。我们将逐一查看转换模板。
- en: lexical_cast
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lexical_cast
- en: 'The `lexical_cast` function template can be used to convert a source type to
    a target type. Its syntax resembles the syntax of various C++ casts:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast`函数模板可用于将源类型转换为目标类型。其语法类似于各种C++转换的语法：'
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following example shows how we can use `lexical_cast` to convert a string
    to an integer:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了我们如何使用`lexical_cast`将字符串转换为整数：
- en: '**Listing 2.11: Using lexical_cast**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.11：使用lexical_cast**'
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We apply `lexical_cast` (line 4) to convert a value of type `std::string` to
    a value of `int`. The beauty of this approach is that it can provide a uniform
    syntax to all conversions and can be extended to new types. If the string does
    not contain a valid numeric string, then the `lexical_cast` invocation will throw
    an exception of type `bad_lexical_cast`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用`lexical_cast`（第4行）将`std::string`类型的值转换为`int`类型的值。这种方法的美妙之处在于它可以为所有转换提供统一的语法，并且可以扩展到新类型。如果字符串不包含有效的数字字符串，则`lexical_cast`调用将抛出`bad_lexical_cast`类型的异常。
- en: 'Overloads of the `lexical_cast` function template are provided to allow the
    conversion of a part of a character array:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了`lexical_cast`函数模板的重载，允许转换字符数组的一部分：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can use the preceding function in the following way:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式使用前述函数：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When converting objects of types that are streamable, `lexical_cast` streams
    the objects to an `ostream` object, such as an instance of `stringstream`, and
    reads it back as the target type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换可流式传输的类型的对象时，`lexical_cast`将对象流式传输到`ostream`对象，例如`stringstream`的实例，并将其作为目标类型读取回来。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A streamable object can be converted to a stream of characters and inserted
    into an `ostream` object, such as an instance of `stringstream`. In other words,
    a type `T`, such that `ostream& operator<<(ostream&, const T&)`, is defined is
    said to be streamable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可流式传输的对象可以转换为字符流，并插入到`ostream`对象中，例如`stringstream`的实例。换句话说，如果定义了类型`T`，使得`ostream&
    operator<<(ostream&, const T&)`，则称其为可流式传输。
- en: Setting up and tearing down stream objects for each such operation incurs some
    overhead. As a result, in some cases, the default version of `lexical_cast` may
    not give you the best possible performance. In such cases, you may specialize
    the `lexical_cast` template for the set of types involved, and use a fast library
    function or provide your own fast implementation. The `Conversion` library already
    takes care of optimizing `lexical_cast` for all common type pairs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个此类操作设置和拆卸流对象会产生一些开销。因此，在某些情况下，`lexical_cast`的默认版本可能无法提供最佳性能。在这种情况下，您可以为涉及的类型集合专门化`lexical_cast`模板，并使用快速库函数或提供自己的快速实现。`Conversion`库已经优化了所有常见类型对的`lexical_cast`。
- en: Besides the `lexical_cast` template, there are other templates available for
    conversion between different numeric types (`boost::numeric_cast`), downcasts
    and cross-casts in class hierarchies (`polymorphic_downcast`, `polymorphic_cast`).
    You can refer to the online documentation for more information on these features.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`lexical_cast`模板之外，还有其他模板可用于不同数值类型之间的转换（`boost::numeric_cast`）、类层次结构中的向下转换和交叉转换（`polymorphic_downcast`、`polymorphic_cast`）。您可以参考在线文档以获取有关这些功能的更多信息。
- en: Handling command-line arguments
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: Command-line arguments, like API parameters, are the remote control buttons
    that help you tune the behavior of commands to your advantage. A well-designed
    set of command-line options is behind much of the power of a command. In this
    section, we will see how the Boost.Program_Options library helps you add support
    for a rich and standardized set of command-line options to your own programs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数，就像API参数一样，是帮助您调整命令行行为的遥控按钮。一组精心设计的命令行选项在很大程度上支持命令的功能。在本节中，我们将看到Boost.Program_Options库如何帮助您为自己的程序添加对丰富和标准化的命令行选项的支持。
- en: Designing command-line options
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计命令行选项
- en: C provides the most primitive abstraction for the command line of your program.
    Using the two arguments passed to the main function—the number of arguments (`argc`)
    and the list of arguments (`argv`)—you can find out about each and every argument
    passed to the program and their relative ordering. The following program prints
    `argv[0]`, which is the path to the program itself with which the program was
    invoked. When run with a set of command-line arguments, the program also prints
    each argument on a separate line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C为程序的命令行提供了最原始的抽象。使用传递给主函数的两个参数-参数的数量（`argc`）和参数的列表（`argv`）-您可以了解到传递给程序的每个参数及其相对顺序。以下程序打印出`argv[0]`，这是程序本身的路径，用它调用程序。当使用一组命令行参数运行时，程序还会将每个参数分别打印在一行上。
- en: 'Most programs need to add more logic and validation to verify and interpret
    command-line arguments and hence, a more elaborate framework is needed to handle
    command-line arguments:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序需要添加更多的逻辑和验证来验证和解释命令行参数，因此需要一个更复杂的框架来处理命令行参数：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The diff command – a case study
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: diff命令-一个案例研究
- en: 'Programs usually document a set of command-line options and switches that modify
    their behavior. Let us take a look at the example of the `diff` command in Unix.
    The `diff` command is run like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常会记录一组修改其行为的命令行选项和开关。让我们来看看Unix中`diff`命令的例子。`diff`命令是这样运行的：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It prints the difference between the content of the two files. There are several
    ways in which you can choose to print the differences. For each different chunk
    found, you may choose to print a few additional lines surrounding the difference
    to get a better understanding of the context in which the differing part appears.
    These surrounding lines or "context" do not differ between the two files. To do
    this, you can use one of the following alternatives:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出两个文件内容之间的差异。有几种方式可以选择打印出差异。对于每个不同的块，您可以选择打印出几行额外的上下文，以更好地理解出现差异的上下文。这些周围的行或"上下文"在两个文件之间是相同的。为此，您可以使用以下的其中一种替代方案：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, you choose to print five additional lines of context. You can also choose
    the default of three by specifying:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您选择打印五行额外的上下文。您还可以通过指定默认值为三来选择默认值：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding examples, `-U` or `--unified` are examples of command-line
    options. The former is a short option consisting of a single leading hyphen and
    a single letter (`-U`). The latter is a long option with two leading hyphens and
    a multi-character option name (`--unified`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`-U`或`--unified`是命令行选项的例子。前者是一个由单个前导破折号和单个字母（`-U`）组成的短选项。后者是一个由两个前导破折号和多字符选项名称（`--unified`）组成的长选项。
- en: The number `5` is an option value; an argument to the option (`-U` or `--unified`)
    preceding it. The option value is separated from a preceding short option by space,
    but from a preceding long option by an equals sign (`=`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`5`是一个选项值；是前面的选项（`-U`或`--unified`）的参数。选项值与前面的短选项之间用空格分隔，但与前面的长选项之间用等号(`=`)分隔。
- en: If you are "diffing" two C or C++ source files, you can get more useful information
    using a command-line switch or flag `-p`. A switch is an option that does not
    take an option value as an argument. Using this switch, you can print the name
    of the C or C++ function in the context of which a particular difference is detected.
    There is no long option corresponding to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在"diffing"两个C或C++源文件，您可以使用命令行开关或标志`-p`来获取更有用的信息。开关是一个不带选项值的选项。使用此开关，您可以打印出在检测到特定差异的上下文中C或C++函数的名称。没有与之对应的长选项。
- en: 'The `diff` command is a very powerful tool with which you can find differences
    in the content of files in full directories. When diffing two directories, if
    a file exists in one but not the other, `diff` ignores this file by default. However,
    you may want to instead see the contents of the new file. To do this, you will
    use the `-N` or `--new-file` switch. If we want to now run our `diff` command
    on two directories of C++ source code to identify changes, we can do it in this
    way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`命令是一个非常强大的工具，可以在完整目录中查找文件内容的差异。当对比两个目录时，如果一个文件存在于一个目录中而另一个目录中不存在，`diff`默认会忽略此文件。但是，您可能希望查看新文件的内容。为此，您将使用`-N`或`--new-file`开关。如果我们现在想要在两个C++源代码目录上运行我们的`diff`命令来识别更改，我们可以这样做：'
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You don't have to be eagle-eyed to notice that we used an option called `-pN`.
    This is actually not a single option but two switches, (`-p`) and (`-N`), collapsed
    together.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必眼尖才能注意到我们使用了一个名为`-pN`的选项。这实际上不是一个单一的选项，而是两个开关（`-p`）和（`-N`）合并在一起。
- en: 'Certain patterns or conventions should be evident from this case-study:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个案例研究中应该能够看出某些模式或约定：
- en: Starting short options with single hyphens
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用单破折号开始短选项
- en: Starting long options with double hyphens
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用双破折号开始长选项
- en: Separating short options and option-values with space
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用空格分隔短选项和选项值
- en: Separating long options and option-value with equals
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用等号分隔长选项和选项值
- en: Collapsing short switches together
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并短开关
- en: These are *de facto* standardized conventions on highly POSIX-compliant systems,
    such as Linux. It is, however, by no means the only convention followed. Windows
    command lines often use a leading forward slash (`/`) in place of a hyphen. They
    often do not distinguish between short and long options, and sometimes use a colon
    (`:`) in place of an equals sign to separate an option and its option value. Java
    commands as well as commands in several older Unix systems use a single leading
    hyphen for both short and long options. Some of them use a space for separating
    an option and option-value irrespective of whether it is a short option or a long
    one. How can you take care of so many complex rules that vary from platform to
    platform while parsing your command line? This is where Boost Program Options
    library makes a big difference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是高度符合POSIX的系统（如Linux）上*事实上*标准化的约定。然而，并不是唯一遵循的约定。Windows命令行经常使用前斜杠(`/`)代替连字符。它们通常不区分短选项和长选项，并有时使用冒号(`:`)代替等号来分隔选项和其选项值。Java命令以及几个旧的Unix系统中的命令使用单个前导连字符来表示短选项和长选项。其中一些使用空格来分隔选项和选项值，无论是短选项还是长选项。在解析命令行时，如何处理从平台到平台变化的这么多复杂规则？这就是Boost程序选项库产生重大影响的地方。
- en: Using Boost.Program_Options
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Program_Options
- en: 'The Boost Program Options library provides you with a declarative way of parsing
    command lines. You can specify the set of options and switches and the type of
    option-values for each option that your program supports. You can also specify
    which set of conventions you want to support for your command line. You can then
    feed all of this information to the library functions that parse and validate
    the command line and extract all the command-line data into a dictionary-like
    structure from which you can access individual bits of data. We will now write
    some code to model the previously mentioned options for the `diff` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Boost程序选项库为您提供了一种声明性的解析命令行的方式。您可以指定程序支持的选项和开关集合以及每个选项支持的选项值类型。您还可以指定要为命令行支持的约定集合。然后，您可以将所有这些信息提供给库函数，该函数解析和验证命令行，并将所有命令行数据提取到类似字典的结构中，从中可以访问单个数据位。现在，我们将编写一些代码来模拟`diff`命令的先前提到的选项：
- en: '**Listing 2.12a: Using Boost Program Options**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.12a：使用Boost程序选项**'
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, we declare the structure of the command line
    using an `options_description` object. Successive options are declared using an
    overloaded function call `operator()` in the object returned by the `add_options`.
    You can cascade calls to this operator in the same way that you can print multiple
    values by cascading calls to the insertion operator (`<<`) on `std::cout`. This
    makes for a highly readable specification of the options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`options_description`对象声明了命令行的结构。连续的选项使用`add_options`返回的对象中的重载函数调用`operator()`来声明。您可以像在`std::cout`上级联调用插入运算符(`<<`)一样级联调用此运算符。这使得选项的规范非常易读。
- en: We declare the `--unified` or `-U` option specifying both the long and short
    options in a single string, separated by a comma (line 10). The second argument
    indicates that we expect a numeric argument, and the default value will be taken
    as `3` if the argument is not specified on the command line. The third field is
    the description of the option and will be used to generate a documentation string.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了`--unified`或`-U`选项，指定长选项和短选项在单个字符串中，用逗号分隔（第10行）。第二个参数表示我们期望一个数字参数，如果在命令行上未指定参数，则默认值将为`3`。第三个字段是选项的描述，将用于生成文档字符串。
- en: We declare the short options `-p` and `-N` (lines 13 and 15), but as they do
    not have corresponding long options, they are introduced with a comma followed
    by a short option (`",p"` and `",N"`). They also do not take an option value,
    so we just provide their description.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了短选项`-p`和`-N`（第13和15行），但由于它们没有相应的长选项，它们是以逗号开头，后跟短选项(`",p"`和`",N"`)。它们也不需要选项值，所以我们只提供它们的描述。
- en: 'So far so good. We will now complete the code example by parsing the command
    line and fetching the values. First, we will specify the styles to follow in Windows
    and Unix:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在我们将通过解析命令行并获取值来完成代码示例。首先，我们将指定在Windows和Unix中要遵循的风格：
- en: '**Listing 2.12b: Using Boost Program Options**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.12b：使用Boost程序选项**'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code highlights some important differences between Windows and
    Unix conventions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码突出了Windows和Unix约定之间的一些重要区别：
- en: A more or less standardized Unix style is available precanned and called, `unix_style`.
    However, we have to build the Windows style ourselves.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更或多或少标准化的Unix风格可预先准备好并称为`unix_style`。然而，我们必须自己构建Windows风格。
- en: The `short_allow_next` flag allows you to separate a short option and its option
    value with a space; this is used on both Windows and Unix.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short_allow_next`标志允许您用空格分隔短选项和其选项值；这在Windows和Unix上都可以使用。'
- en: The `allows_slash_for_short` and `allow_slash_for_long` flags allow the options
    to be preceded by forward slashes; a common practice on Windows.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allows_slash_for_short`和`allow_slash_for_long`标志允许选项以斜杠开头；这是Windows上的常见做法。'
- en: The `case_insensitive` flag is appropriate for Windows where the usual practice
    is to have case insensitive commands and options.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case_insensitive`标志适用于Windows，通常习惯于不区分大小写的命令和选项。'
- en: The `long_allow_next` flag on Windows allows long options and option values
    to be separated by a space instead of equals.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，`long_allow_next`标志允许长选项和选项值用空格而不是等号分隔。
- en: 'Now, let us see how we can parse a conforming command line using all of this
    information. To do this, we will declare an object of type `variables_map` to
    read all the data and then parse the command line:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用所有这些信息解析符合规范的命令行。为此，我们将声明一个`variables_map`类型的对象来读取所有数据，然后解析命令行：
- en: '**Listing 2.12c: Using Boost Program Options**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.12c：使用Boost程序选项**'
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We create a command-line parser using the `command_line_parser` function (line
    32). We call the `options` member function on the returned parser to specify the
    parsing rules encoded in `desc` (line 33). We chain further member function calls,
    to the `style` member function of the parser for specifying the expected style
    (line 34), and to the `run` member function to actually perform the parsing. The
    call to `run` returns a data structure containing the data parsed from the command-line.
    The call to `boost::program_options::store` stores the parsed data from this data
    structure inside the `variables_map` object `vm` (lines 31-35). Finally, we check
    whether the program was invoked without arguments or with the `help` option, and
    print the help string (line 39). Streaming the `option_description` instance `desc`
    to an `ostream` prints a help string, that is automatically generated based on
    the command-line rules encoded in `desc` (line 41). All this is encapsulated in
    a try-catch block to trap any command line parsing errors thrown by the call to
    `run` (line 35). In the event of such an error, the error details are printed
    (line 45) along with the usage details (line 46).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`command_line_parser`函数创建一个命令行解析器（第32行）。我们在返回的解析器上调用`options`成员函数来指定在`desc`中编码的解析规则（第33行）。我们链式调用更多的成员函数，将其传递给解析器的`style`成员函数以指定预期的样式（第34行），并调用`run`成员函数来执行实际的解析。调用`run`返回一个包含从命令行解析的数据的数据结构。调用`boost::program_options::store`将从这个数据结构中解析的数据存储在`variables_map`对象`vm`中（第31-35行）。最后，我们检查程序是否在没有参数或使用`help`选项的情况下调用，并打印帮助字符串（第39行）。将`option_description`实例`desc`流式传输到`ostream`会打印一个帮助字符串，该字符串是根据`desc`中编码的命令行规则自动生成的（第41行）。所有这些都封装在一个try-catch块中，以捕获由对`run`的调用抛出的任何命令行解析错误（第35行）。在出现这样的错误时，将打印错误详细信息（第45行），并打印使用详细信息（第46行）。
- en: If you notice, we call a function called `notify(…)` on line 37\. In more advanced
    uses, we may choose to use values that are read from the command line to set variables
    or object members, or perform other post-processing actions. Such actions can
    be specified for each option while declaring option descriptions, but these actions
    are only initiated by the call to `notify`. As a matter of consistency, do not
    drop the call to `notify`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，你会发现我们在第37行调用了一个名为`notify(…)`的函数。在更高级的用法中，我们可以选择使用从命令行读取的值来设置变量或对象成员，或执行其他后处理操作。这些操作可以在声明选项描述时为每个选项指定，但这些操作只能通过调用`notify`来启动。为了保持一致，不要删除对`notify`的调用。
- en: 'We can now extract the values passed via the command line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以提取通过命令行传递的值了：
- en: '**Listing 2.12d: Using Boost Program Options**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.12d：使用Boost程序选项**'
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Parsing positional parameters
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析位置参数
- en: 'If you were observant, you would have noticed that we did nothing to read the
    two file names; the two main operands of the `diff` command. We did this for simplicity,
    and we will fix this now. We run the `diff` command like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，你会注意到我们没有做任何事情来读取两个文件名；`diff`命令的两个主要操作数。我们之所以这样做是为了简单起见，现在我们将修复这个问题。我们这样运行`diff`命令：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `old_source_dir` and `new_source_dir` arguments are called positional parameters.
    They are not options or switches, nor are they arguments to any options. In order
    to handle them, we will have to use a couple of new tricks. First of all, we must
    tell the parser the number and type of these parameters that we expect. Second,
    we must tell the parser that these are positional parameters. Here is the code
    snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`old_source_dir`和`new_source_dir`参数被称为位置参数。它们既不是选项也不是开关，也不是任何选项的参数。为了处理它们，我们将不得不使用一些新技巧。首先，我们必须告诉解析器我们期望的这些参数的数量和类型。其次，我们必须告诉解析器这些是位置参数。以下是代码片段：'
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, we set up a second options description object called
    `posparams` to identify the positional parameters. We add options with names `"file1"`
    and `"file2"`, and indicate that these parameters are mandatory, using the `required()`
    member function of the `value` parameter (lines 4 and 5). We also specify two
    string variables `file1` and `file2` to store the positional parameters. All of
    this is added to the main options description object `desc` (line 6). For the
    parser to not look for actual options called `"--file1"` and `"--file2"`, we must
    tell the parser that these are positional parameters. This is done by defining
    a `positional_options_description` object (line 9) and adding the options that
    should be treated as positional options (lines 10 and 11). The second parameter
    in the call to `add(…)` specifies how many positional parameters should be considered
    for that option. Since we want one file name, each for options `file1` and `file2`,
    we specify `1` in both the calls. Positional parameters on the command line are
    interpreted according to the order in which they are added to the positional options
    description. Thus, in this case, the first positional parameter will be treated
    as `file1`, and the second parameter will be treated as `file2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了一个名为`posparams`的第二个选项描述对象，用于识别位置参数。我们使用`value`参数的`required()`成员函数（第4和5行）添加了名称为`"file1"`和`"file2"`的选项，并指示这些参数是必需的。我们还指定了两个字符串变量`file1`和`file2`来存储位置参数。所有这些都添加到主选项描述对象`desc`（第6行）。为了使解析器不寻找名为`"--file1"`和`"--file2"`的实际选项，我们必须告诉解析器这些是位置参数。这是通过定义一个`positional_options_description`对象（第9行）并添加应该被视为位置选项的选项（第10和11行）来完成的。在`add(…)`调用中的第二个参数指定了应该考虑该选项的位置参数的数量。由于我们想要一个文件名，分别用于选项`file1`和`file2`，所以我们在两次调用中都指定为`1`。命令行上的位置参数根据它们添加到位置选项描述的顺序进行解释。因此，在这种情况下，第一个位置参数将被视为`file1`，第二个参数将被视为`file2`。
- en: Multiple option values
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个选项值
- en: 'In some cases, a single option may take multiple option values. For example,
    during compilation, you will use the `-I` option multiple times to specify multiple
    directories. To parse such options and their option values, you can specify the
    target type as a vector, as shown in the following snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，单个选项可能需要多个选项值。例如，在编译期间，你将多次使用`-I`选项来指定多个目录。为了解析这样的选项及其选项值，你可以将目标类型指定为矢量，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will work on an invocation like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在这样的调用上起作用：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In some cases, however, you might want to specify multiple option values, but
    you specify the option itself only once. Let us say that you are running a command
    to discover assets (local storage, NICs, HBAs, and so on) connected to each of
    a set of servers. You can have a command like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能想要指定多个选项值，但只指定一次选项本身。假设你正在运行一个命令来发现连接到一组服务器的每个资产（本地存储、NIC、HBA等）的命令。你可以有这样一个命令：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, to model the `--server` option, you would need to use the `multitoken()`
    directive as shown here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了模拟`--server`选项，你需要像这样使用`multitoken()`指令：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can retrieve vector-valued parameters through the variable map like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过变量映射这样检索矢量值参数：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, you can use variable hooks at the time of option definition
    like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在选项定义时使用变量挂钩，就像这样：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Make sure that you don't forget to call `notify` after parsing the command line.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在解析命令行后不要忘记调用`notify`。
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Trying to support positional parameters and options with multi-tokens together
    in the same command can confuse the parser and should be generally avoided.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试支持在同一命令中同时使用多个令牌的位置参数和选项可能会使解析器混淆，通常应该避免。
- en: The Program Options library uses Boost Any for its implementation. For the Program
    Options library to work correctly, you must not disable the generation of RTTI
    for your programs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 程序选项库使用Boost Any进行实现。为了使程序选项库正常工作，你不能禁用程序的RTTI生成。
- en: Other utilities and compile-time checks
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他实用程序和编译时检查
- en: Boost includes a number of micro-libraries that provide small but useful functionalities.
    Most of them are not elaborate enough to be separate libraries. Instead, they
    are grouped under `Boost.Utility` and `Boost.Core`. We will look at two such libraries
    here.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Boost包括许多微型库，提供小而有用的功能。它们中的大多数都不够复杂，无法成为单独的库。相反，它们被分组在`Boost.Utility`和`Boost.Core`下。我们将在这里看两个这样的库。
- en: We will also look at some useful ways to detect errors as early as possible,
    at compile time, and glean information about the program's compilation environment
    and tool chains using different facilities from Boost.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一些有用的方法，尽早在编译时检测错误，并使用Boost的不同设施从程序的编译环境和工具链中获取信息。
- en: BOOST_CURRENT_FUNCTION
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BOOST_CURRENT_FUNCTION
- en: 'When writing debug logs, it is incredibly useful to be able to write function
    names and some qualifying information about functions from where logging is invoked.
    This information is (obviously) available to compilers during the compilation
    of sources. However, the way to print it is different for different compilers.
    Even for a given compiler, there may be more than one ways to do it. If you want
    to write portable code, this is one wart you have to take care to hide. The best
    tool for this is the macro `BOOST_CURRENT_FUNCTION`, formally a part of `Boost.Utility`,
    shown in action in the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写调试日志时，能够写入函数名称以及有关调用日志的函数的一些限定信息非常有用。这些信息（显然）在编译源代码时对编译器是可用的。然而，打印它的方式对不同的编译器是不同的。即使对于同一个编译器，可能有多种方法来做到这一点。如果你想编写可移植的代码，这是一个你必须注意隐藏的瑕疵。这方面最好的工具是宏`BOOST_CURRENT_FUNCTION`，正式是`Boost.Utility`的一部分，在下面的示例中展示了它的作用：
- en: '**Listing 2.13: Pretty printing current function name**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.13：漂亮打印当前函数名**'
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Depending on your compiler, the output you see would vary in format. GNU compilers
    tend to have a more readable output, while on Microsoft Visual Studio you will
    see some very elaborate output including details such as calling conventions.
    In particular, the output for template instantiations is much more elaborate on
    Visual Studio. Here is a sample output I see on my systems.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的编译器，你看到的输出格式会有所不同。GNU编译器倾向于有更可读的输出，而在Microsoft Visual Studio上，你会看到一些非常复杂的输出，包括调用约定等细节。特别是，在Visual
    Studio上，模板实例化的输出要复杂得多。这是我在我的系统上看到的一个示例输出。
- en: 'With GNU g++:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GNU g++：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With Visual Studio:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can immediately see some differences. GNU compilers call out static methods
    from nonstatic ones. On Visual Studio, you have to differentiate based on calling
    conventions (`__cdecl` for static member methods as well as global methods, `__thiscall`
    for instance methods). You might want to take a look at the `current_function.hpp`
    header file to figure out which macros are used behind the scenes. On GNU compilers,
    for example, it is `__PRETTY_FUNCTION__`, while on Visual Studio, it is `__FUNCSIG__`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到一些不同之处。GNU编译器从非静态方法中调用静态方法。在Visual Studio中，你必须根据调用约定进行区分（`__cdecl`用于静态成员方法以及全局方法，`__thiscall`用于实例方法）。你可能想看一下`current_function.hpp`头文件，以找出在幕后使用了哪些宏。例如，在GNU编译器中，是`__PRETTY_FUNCTION__`，而在Visual
    Studio中是`__FUNCSIG__`。
- en: Boost.Swap
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Swap
- en: 'The Boost Swap library is yet another useful micro library and is part of Boost
    Core:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Swap库是另一个有用的微型库，是Boost Core的一部分：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It wraps a well-known idiom around swapping objects. Let us first look at the
    problem itself to understand what is going on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它围绕交换对象的一个众所周知的习语。让我们首先看看问题本身，以了解发生了什么。
- en: 'There is one global `swap` function in the `std` namespace. In many cases,
    for a type defined in a particular namespace, a specialized `swap` overload may
    be provided in the same namespace. When writing generic code, this can pose some
    challenges. Imagine a generic function that calls `swap` on its arguments:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std`命名空间中有一个全局的`swap`函数。在许多情况下，对于在特定命名空间中定义的类型，可能会在相同的命名空间中提供一个专门的`swap`重载。在编写通用代码时，这可能会带来一些挑战。想象一个通用函数调用其参数的`swap`：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding snippet, we call `std::swap` on line 5 to perform the swapping.
    While this is well-formed, this may not do what is desired in some cases. Consider
    the following types and functions in the namespace `X`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们在第5行调用`std::swap`来执行交换。虽然这是良好形式的，但在某些情况下可能不会产生期望的结果。考虑命名空间`X`中的以下类型和函数：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Of course, `X::Foo` is a trivial type and `X::swap` is a no-op, but they can
    be replaced with a meaningful implementation and the points we make here would
    still hold.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`X::Foo`是一个平凡的类型，`X::swap`是一个无操作，但它们可以被一个有意义的实现替换，我们在这里所做的观点仍然成立。
- en: So, what happens if you call the function `process_values` on two arguments
    of type `X::Foo`?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你在两个类型为`X::Foo`的参数上调用函数`process_values`会发生什么？
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The call to `process_values` (line 2) will call `std::swap` on the passed instances
    of `X::Foo`, that is, `f1` and `f2`. Yet, we would likely have wanted `X::swap`
    be called on `f1` and `f2` because it is a more appropriate overload. There is
    a way to do this; you call `boost::swap` instead. Here is the rewrite of the `process_values`
    template snippet:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对`process_values`的调用（第2行）将在传递给`X::Foo`的实例上调用`std::swap`，即`f1`和`f2`。然而，我们可能希望在`f1`和`f2`上调用`X::swap`，因为这是一个更合适的重载。有一种方法可以做到这一点；你可以调用`boost::swap`。下面是`process_values`模板片段的重写：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you now run this code, you will see the `X::swap` overload printing its
    name to the console. To understand how `boost::swap` manages to call the appropriate
    overload, we need to understand how we could have solved this without `boost::swap`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这段代码，你会看到`X::swap`重载将其名称打印到控制台。要理解`boost::swap`是如何调用适当的重载的，我们需要了解如何在没有`boost::swap`的情况下解决这个问题：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If we did not have the `using` declaration (line 5), the call to `swap` (line
    6) would still have succeeded for a type `T` that was defined in a namespace,
    which had a `swap` overload defined for `T`—thanks to **Argument Dependent Lookup**
    (**ADL**)—`X::Foo`, accompanied by `X::swap`, is such a type. However, it would
    have failed for types defined in the global namespace (assuming you didn't define
    a generic `swap` in the global namespace). With the `using` declaration (line
    5), we create the fallback for the unqualified call to `swap` (line 6). When ADL
    succeeds in finding a namespace level `swap` overload, the call to `swap` gets
    resolved to this overload. When ADL fails to find such an overload, then `std::swap`
    is used, as dictated, by the `using` declaration. The problem is that this is
    a nonobvious trick, and you have to know it to use it. Not every engineer in your
    team will come equipped with all the name lookup rules in C++. In the meantime,
    he can always use `boost::swap`, which essentially wraps this piece of code in
    a function. You can now use just one version of `swap` and expect the most appropriate
    overload to be invoked each time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有`using`声明（第5行），对`swap`的调用（第6行）仍然会成功，对于一个在命名空间中定义的类型`T`，该命名空间中定义了`T`的`swap`重载——这要归功于**参数相关查找**（**ADL**）——`X::Foo`和`X::swap`就是这样的类型。然而，对于在全局命名空间中定义的类型，它会失败（假设你没有在全局命名空间中定义一个通用的`swap`）。有了`using`声明（第5行），我们为对`swap`的未限定调用创建了回退。当ADL成功找到命名空间级别的`swap`重载时，对`swap`的调用就会解析为这个重载。当ADL找不到这样的重载时，就会使用`std::swap`，如`using`声明所规定的那样。问题在于这是一个不明显的技巧，你必须知道才能使用它。你团队中的每个工程师都不一定都了解C++中的所有名称查找规则。与此同时，他总是可以使用`boost::swap`，它本质上是将这段代码包装在一个函数中。现在你可以只使用一个版本的`swap`，并期望每次调用时调用最合适的重载。
- en: Compile-time asserts
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时断言
- en: Compile-time asserts require certain conditions to hold true at some point in
    the code. Any violation of the condition causes the compilation to fail at the
    point. It is an effective way to find errors at compile time, which otherwise
    would cause serious grief at runtime. It may also help reduce the volume and verbosity
    of compiler error messages of the sort generated due to template instantiation
    failures.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时断言要求在代码的某个点上某些条件必须为真。任何条件的违反都会导致编译失败。这是一种在编译时发现错误的有效方法，否则这些错误可能会在运行时造成严重的困扰。它还可以帮助减少由于模板实例化失败而产生的编译器错误消息的数量和冗长程度。
- en: 'Runtime asserts are meant to corroborate the invariance of certain conditions
    that must hold true at some point in the code. Such a condition might be the result
    of the logic or algorithm used or could be based on some documented convention.
    For example, if you are writing a function to raise a number to some power, how
    do you handle the mathematically undefined case of both the number and the power
    being zero? You can use an assert to express this explicitly, as shown in the
    following snippet (line 6):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时断言旨在证实代码中某些必须为真的条件的不变性。这样的条件可能是逻辑或算法的结果，也可能基于某些已记录的约定。例如，如果你正在编写一个将一个数字提高到某个幂的函数，那么你如何处理数和幂都为零的数学上未定义的情况？你可以使用断言来明确表达这一点，如下面的代码片段所示（第6行）：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Any violation of such invariants indicates a bug or a flaw, which needs to be
    fixed, and causes a catastrophic failure of the program in debug builds. Boost
    provides a macro called `BOOST_STATIC_ASSERT` that takes an expression, which
    can be evaluated at compile time and triggers a compilation failure if this expression
    evaluates to false.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的不变性违反表明存在错误或缺陷，需要修复，并导致程序在调试构建中发生灾难性故障。Boost提供了一个名为`BOOST_STATIC_ASSERT`的宏，它接受一个可以在编译时求值的表达式，并在这个表达式求值为假时触发编译失败。
- en: 'For example, you may have designed a memory allocator class template that is
    meant to be used only with "small" objects. Of course, smallness is arbitrary,
    but you can design your allocator to be optimized for objects of size 16 bytes
    or smaller. If you want to enforce correct usage of your class, you should simply
    prevent its instantiation for any class of size greater than 16 bytes. Here is
    our first example of `BOOST_STATIC_ASSERT` that helps you enforce the small object
    semantics of your allocator:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能已经设计了一个内存分配器类模板，该模板仅用于“小”对象。当然，小是任意的，但您可以设计您的分配器以优化大小为16字节或更小的对象。如果您想强制正确使用您的类，您应该简单地阻止其对大于16字节的类的实例化。这是我们的第一个例子`BOOST_STATIC_ASSERT`，它可以帮助您强制执行分配器的小对象语义：
- en: '**Listing 2.16a: Using compile-time asserts**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.16a：使用编译时断言**'
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We define our dummy allocator template called `SmallObjectAllocator` (lines
    3 and 4) and call the `BOOST_STATIC_ASSERT` macro in the class scope (line 6).
    We pass an expression to the macro that must be possible to evaluate at compile
    time. Now, `sizeof` expressions are always evaluated by the compiler and 16 is
    an integer literal, so the expression `sizeof(T) <= 16` can be entirely evaluated
    at compile time and can be passed to `BOOST_STATIC_ASSERT`. If we now instantiate
    the `SmallObjectAllocator` with a type `Foo`, whose size is 32 bytes, we will
    get a compiler error due to the static assert on line 6\. Here is the code that
    can trigger the assertion:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`SmallObjectAllocator`的虚拟分配器模板（第3和第4行），并在类范围内调用`BOOST_STATIC_ASSERT`宏（第6行）。我们将一个必须在编译时可能求值的表达式传递给宏。现在，`sizeof`表达式总是由编译器求值的，而16是一个整数字面量，因此表达式`sizeof(T)
    <= 16`可以完全在编译时求值，并且可以传递给`BOOST_STATIC_ASSERT`。如果我们现在用类型`Foo`实例化`SmallObjectAllocator`，其大小为32字节，我们将由于第6行的静态断言而得到编译器错误。这是可以触发断言的代码：
- en: '**Listing 2.16b: Using compile-time asserts**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.16b：使用编译时断言**'
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We define a type `Foo` whose size is 32 bytes, which is larger than the maximum
    supported by `SmallObjectAllocator` (line 13). We instantiate the `SmallObjectAllocator`
    template with the types `int` (line 18) and `Foo` (line 19) . The compilation
    fails for `SmallObjectAllocator<Foo>`, and we get an error message.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类型`Foo`，其大小为32字节，大于`SmallObjectAllocator`支持的最大大小（第13行）。我们使用类型`int`（第18行）和`Foo`（第19行）实例化`SmallObjectAllocator`模板。`SmallObjectAllocator<Foo>`的编译失败，我们得到一个错误消息。
- en: Tip
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: C++11 supports compile-time asserts using the new `static_assert` keyword. If
    you are using a C++11 compiler, `BOOST_STATIC_ASSERT` internally uses `static_assert`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: C++11支持使用新的`static_assert`关键字进行编译时断言。如果您使用的是C++11编译器，`BOOST_STATIC_ASSERT`在内部使用`static_assert`。
- en: 'The actual error message naturally varies from compiler to compiler, especially
    on C++03 compilers. On C++11 compilers, because this internally uses the `static_assert`
    keyword, the error message tends to be more uniform and meaningful. However, on
    pre-C++11 compilers too, you get a fairly accurate idea of the offending line.
    On my system, using the GNU g++ compiler in C++03 mode, I get the following errors:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的错误消息自然会因编译器而异，特别是在C++03编译器上。在C++11编译器上，因为这在内部使用`static_assert`关键字，错误消息往往更加统一和有意义。然而，在C++11之前的编译器上，您也可以得到一个相当准确的错误行。在我的系统上，使用GNU
    g++编译器在C++03模式下，我得到了以下错误：
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last line of the compiler error refers to an incomplete type `boost::STATIC_ASSERTION_FAILURE<false>`,
    which comes from the innards of the `BOOST_STATIC_ASSERT` macro. It is clear that
    there was an error on line 6, and the static assertion failed. If I switch to
    C++11 mode, the error messages are a lot saner:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误的最后一行引用了一个不完整的类型`boost::STATIC_ASSERTION_FAILURE<false>`，它来自`BOOST_STATIC_ASSERT`宏的内部。很明显，第6行出现了错误，静态断言失败。如果我切换到C++11模式，错误消息会更加合理：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There is another variant of the static assert macro called `BOOST_STATIC_ASSERT`,
    which takes a message string as the second parameter. With C++11 compilers, it
    simply prints this message for the error message. Under pre-C++11 compilers, this
    message may or may not make it to the compiler error content. You use it this
    way:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种静态断言宏的变体称为`BOOST_STATIC_ASSERT`，它将消息字符串作为第二个参数。对于C++11编译器，它只是打印这个消息作为错误消息。在C++11之前的编译器下，这个消息可能会或可能不会出现在编译器错误内容中。您可以这样使用它：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Not all expressions can be evaluated at compile time. Mostly, expressions involving
    constant integers, sizes of types, and general type computations can be evaluated
    at compile time. The Boost TypeTraits library and the Boost **Metaprogramming
    Library** (**MPL**) offer several metafunctions using which many sophisticated
    conditions can be checked on types at compile time. We illustrate such use with
    a small example. We will see more examples of such use in later chapters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有表达式都可以在编译时求值。大多数情况下，涉及常量整数、类型大小和一般类型计算的表达式可以在编译时求值。Boost TypeTraits库和Boost
    **Metaprogramming Library** (**MPL**)提供了几个元函数，使用这些元函数可以在编译时对类型进行许多复杂的条件检查。我们用一个小例子来说明这种用法。我们将在后面的章节中看到更多这种用法的例子。
- en: 'We may use static assertions not only in class scope but also in function and
    namespace scope. Here is an example of a library of function templates that allow
    bitwise operations on different POD types. When instantiating these functions,
    we assert at compile time that the types passed are POD types:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以在类范围内使用静态断言，还可以在函数和命名空间范围内使用。这是一个函数模板库的示例，允许对不同的POD类型进行位操作。在实例化这些函数时，我们在编译时断言传递的类型是POD类型：
- en: '**Listing 2.17: Using compile-time asserts**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单2.17：使用编译时断言**'
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we define a function `bitwise_or` (lines 4 and 5) , which takes two objects,
    potentially of different types and sizes, and returns the bitwise-or of their
    content. Inside this function, we use the metafunction `boost::is_pod<T>` to assert
    that both the objects passed are of POD types (line 7). Also, because the return
    type of the function is `T`, the type of the left argument, we assert that the
    function must always be called with the larger argument first (line 9) so that
    there is no data loss.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个函数`bitwise_or`（第4和5行），它接受两个对象，可能是不同类型和大小的，并返回它们内容的按位或。在这个函数内部，我们使用了元函数`boost::is_pod<T>`来断言传递的两个对象都是POD类型（第7行）。此外，因为函数的返回类型是`T`，即左参数的类型，我们断言函数必须始终首先调用较大的参数（第9行），以便没有数据丢失。
- en: Diagnostics using preprocessor macros
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预处理宏进行诊断
- en: A number of times in my career as a software engineer, I have worked on products
    with a single code base that were built on five different flavors of Unix and
    on Windows, often in parallel. Often these build servers would be big iron servers
    with hundreds of gigs of attached storage that would be used by multiple products
    for the purpose of building. There would be myriad environments, tool chains,
    and configurations cohabiting on the same server. It must have taken ages to stabilize
    these systems to a point where everything built perfectly. One day, all hell broke
    loose when, overnight, without any significant check-ins having gone in, our software
    started acting weird. It took us almost a day to figure out that someone had tinkered
    with the environment variables, as a result of which we were linking using a different
    version of the compiler and linking with a different runtime from the one with
    which our third-party libraries were built. I don't need to tell you that this
    was not ideal for a build system even at the time that it existed. Unfortunately,
    you may still find such messed up environments that take a long time to set up
    and then get undone by a flippant change. What saved us that day after half a
    day's fruitless toil was the good sense of using preprocessor macros to dump information
    about the build system, including compiler names, versions, architecture, and
    their likes at program startup. We could soon glean enough information from this
    data dumped by the program, before it inevitably crashed and we spotted the compiler
    mismatch.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为软件工程师的职业生涯中，有很多次我曾经在建立在五种不同Unix和Windows上的单一代码库的产品上工作，通常是并行进行的。通常这些构建服务器会是大型服务器，附带数百吉字节的存储空间，用于多个产品进行构建。会有无数的环境、工具链和配置共存于同一服务器上。将这些系统稳定到一切都能完美构建的程度肯定花费了很长时间。有一天，地狱就在一夜之间降临了，尽管没有进行任何重大的提交，我们的软件开始表现得很奇怪。我们花了将近一天的时间才发现有人动了环境变量，结果我们使用了不同版本的编译器进行链接，并且使用了与我们的第三方库构建时不同的运行时进行链接。我不需要告诉你，即使在那个时候，这对于构建系统来说也不是理想的情况。不幸的是，你可能仍然会发现这样混乱的环境，需要很长时间来设置，然后被一个轻率的改变破坏。在半天的徒劳努力之后拯救我们的是明智地使用预处理宏在程序启动时倾倒有关构建系统的信息，包括编译器名称、版本、架构等。我们很快就能从程序倾倒的数据中获得足够的信息，在它不可避免地崩溃之前，我们就发现了编译器不匹配的问题。
- en: Such information is doubly useful for library writers who might be able to provide
    the most optimal implementation of a library on each compiler or platform by leveraging
    specific interfaces and doing conditional compilation of code based on preprocessor
    macro definitions. The bane of working with such macros is, however, the absolute
    disparity between different compilers, platforms, and environments on how they
    are named and what their function is. Boost provides a much more uniform set of
    preprocessor macros for gleaning information about the software build environment
    through its `Config` and `Predef` libraries. We will look at a handful of useful
    macros from these libraries.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的信息对于可能能够通过利用特定接口在每个编译器或平台上提供库的最优实现的库编写者来说是双重有用的，并且可以根据预处理宏定义进行条件编译。然而，使用这些宏的弊端在于不同编译器、平台和环境之间的绝对差异，包括它们的命名和功能是什么。Boost通过其`Config`和`Predef`库提供了一个更加统一的一组用于获取有关软件构建环境信息的预处理宏。我们将看一下这些库中一些有用的宏。
- en: 'The `Predef` library is a header-only library that provides all sorts of macros
    for getting useful information about the build environment at compile time. The
    information available can fall into different categories. Rather than providing
    a long list of options and explaining what they do—a job that the online documentation
    does adequately—we will look at the following code to illustrate how this information
    is accessed and used:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predef`库是一个仅包含头文件的库，提供了各种宏，用于在编译时获取有关构建环境的有用信息。可用的信息可以分为不同的类别。我们将看一下以下代码，以说明如何访问和使用这些信息，而不是提供一个选项的长列表并解释它们的作用——在线文档已经充分做到了这一点。'
- en: '**Listing 2.18a: Using diagnostic macros from Predef**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2.18a：使用Predef中的诊断宏
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding function uses the `BOOST_OS_*` macros from the `Predef` library
    to identify the OS on which the code is built. We have only shown macros for three
    different OSes. The online documentation provides a full list of macros for identifying
    different OSes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用了`Predef`库中的`BOOST_OS_*`宏来识别代码所构建的操作系统。我们只展示了三种不同操作系统的宏。在线文档提供了用于识别不同操作系统的完整列表的宏。
- en: '**Listing 2.18b: Using diagnostic macros from Predef**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2.18b：使用Predef中的诊断宏
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding function uses the `BOOST_ARCH_*` macros from the `Predef` library
    to identify the architecture of the platform on which the code is built. We have
    only shown macros for x86 and ARM architectures; the online documentation provides
    a complete list of macros for identifying different architectures.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用了`Predef`库中的`BOOST_ARCH_*`宏来识别代码所构建的平台的架构。我们只展示了x86和ARM架构的宏；在线文档提供了用于识别不同架构的完整列表的宏。
- en: '**Listing 2.18c: Using diagnostic macros from Predef**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2.18c：使用Predef中的诊断宏
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding function uses the `BOOST_COMP_*` macros from the `Predef` library
    to identify the compiler that was used to build the code. We have only shown macros
    for GNU and Microsoft Visual C++ compilers. The online documentation provides
    a complete list of macros for identifying different compilers. When defined, the
    `BOOST_COMP_*` macro for a particular compiler evaluates to its numeric version.
    For example, on Visual Studio 2010, `BOOST_COMP_MSVC` evaluates to `100030319`.
    This could be translated as version `10.0.30319`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用了`Predef`库中的`BOOST_COMP_*`宏来识别用于构建代码的编译器。我们只展示了GNU和Microsoft Visual C++编译器的宏。在线文档提供了用于识别不同编译器的完整宏列表。当定义了特定编译器的`BOOST_COMP_*`宏时，它会评估为其数值版本。例如，在Visual
    Studio 2010上，`BOOST_COMP_MSVC`评估为`100030319`。这可以被翻译为版本`10.0.30319`：
- en: '**Listing 2.18d: Using diagnostic macros from Predef**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 2.18d清单：使用Predef中的诊断宏
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we use the `BOOST_VERSION_NUMBER` macro to construct
    versions against which we compare the current version of the GNU or Microsoft
    Visual C++ compilers. If the GNU compiler version is less than 4.8.1 or the Microsoft
    Visual Studio C++ compiler version is less than 12.0, we print that the support
    for C++11 might be incomplete.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`BOOST_VERSION_NUMBER`宏来构建与当前版本的GNU或Microsoft Visual C++编译器进行比较的版本。如果GNU编译器版本小于4.8.1或Microsoft
    Visual Studio C++编译器版本小于12.0，我们会打印出对C++11的支持可能不完整。
- en: 'In the final example of this section, we use macros from `boost/config.hpp`
    to print compiler, platform, and runtime library names (lines 6, 7, and 8). We
    also use two macros defined in `boost/version.hpp` to print the version of Boost
    used, as a string (line 10) and as a numeric value (line 11):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一个示例中，我们使用`boost/config.hpp`中的宏来打印编译器、平台和运行时库的名称（第6、7和8行）。我们还使用`boost/version.hpp`中定义的两个宏来打印所使用的Boost版本，一个作为字符串（第10行），一个作为数值（第11行）：
- en: '**Listing 2.19: Using configuration information macros**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 2.19清单：使用配置信息宏
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Self-test questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all the options that apply:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: What are the advantages of using `boost::swap` over `std::swap`?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`boost::swap`而不是`std::swap`的优点是什么？
- en: a. There is no real advantage
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: a. 没有真正的优势
- en: b. `boost::swap` invokes swap overloads supplied with the passed type, if any
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: b. `boost::swap`会调用传递类型提供的交换重载
- en: c. `boost::swap` is faster than `std::swap`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::swap`比`std::swap`更快
- en: d. `boost::swap` does not throw exceptions
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::swap`不会抛出异常
- en: 'Can you apply a visitor to multiple variant arguments in a single call? (*Hint*:
    you may want to look up the online documentation)'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能在单个调用中将访问者应用于多个变体参数吗？（提示：您可能需要查阅在线文档）
- en: a. Yes. A visitor can only be applied to one or two variant arguments
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是的。访问者只能应用于一个或两个变体参数
- en: b. Yes. A visitor can be applied to one or more arguments
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: b. 是的。访问者可以应用于一个或多个参数
- en: c. No. The member operators take only one variant argument
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: c. 不。成员操作符只接受一个变体参数
- en: d. None of the above
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: Is the following a valid compile-time assert?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是否是有效的编译时断言？
- en: '`BOOST_STATIC_ASSERT(x == 0); // x is some variable`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSERT(x == 0); // x is some variable`'
- en: a. Yes, provided `x` is of an integral type
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是的，只要`x`是整数类型
- en: b. Yes, provided `x` is declared as a `const static` numeric variable
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: b. 是的，只要`x`声明为`const static`数值变量
- en: c. No, `x` is a variable, and its value cannot be known at compile time
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: c. 不，`x`是一个变量，其值在编译时无法知道
- en: d. Only expressions involving `sizeof` are valid in a `BOOST_STATIC_ASSERT`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: d. 只有涉及`sizeof`的表达式在`BOOST_STATIC_ASSERT`中是有效的
- en: What do we mean when we say that a type `X` is a POD type?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们说类型`X`是POD类型时，我们是什么意思？
- en: a. `X` does not have a user-defined constructor or destructor
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: a. `X`没有用户定义的构造函数或析构函数
- en: b. `X` can be copied by copying its memory layout bit-wise
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: b. 通过按位复制其内存布局可以复制`X`
- en: c. `X` does not have a user-defined copy constructor or copy assignment operator
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: c. `X`没有用户定义的复制构造函数或复制赋值运算符
- en: d. All of the above
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上所有
- en: What is the type and value stored in a default-constructed object of type `boost::variant<std::string,
    double>`?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型为`boost::variant<std::string, double>`的默认构造对象中存储的类型和值是什么？
- en: a. The type is `const char*` and value is `NULL`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: a. 类型是`const char*`，值是`NULL`
- en: b. The type is `double` and value is `0.0`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: b. 类型是`double`，值是`0.0`
- en: c. The type is `std::string` and value is the default constructed `std::string`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: c. 类型是`std::string`，值是默认构造的`std::string`
- en: d. The type is `boost::optional<double>` and value is empty
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: d. 类型是`boost::optional<double>`，值为空
- en: Check the reference on Boost.Optional in the online documentation for the latest
    Boost libraries. What happens if you call the `get` and `get_ptr` methods on an
    empty `optional` object?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Boost库在线文档中Boost.Optional的参考资料。如果在一个空的`optional`对象上调用`get`和`get_ptr`方法会发生什么？
- en: a. Both throw the `boost::empty_optional` exception
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: a. 两者都会抛出`boost::empty_optional`异常
- en: b. `get` throws an exception, while `get_ptr` returns a null pointer
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: b. `get`抛出异常，而`get_ptr`返回空指针
- en: c. `get` asserts, while `get_ptr` returns a null pointer
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: c. `get`会断言，而`get_ptr`会返回空指针
- en: d. Both `get` and `get_ptr` assert
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: d. `get`和`get_ptr`都会断言
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was a quick tour of several Boost libraries that help you do important
    programming chores, such as parsing command lines, creating type-safe variant
    types, handling empty values, and performing compile-time checks.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对几个Boost库的快速介绍，这些库帮助您完成重要的编程任务，如解析命令行、创建类型安全的变体类型、处理空值和执行编译时检查。
- en: Hopefully, you have appreciated the diversity of libraries in Boost and the
    expressive power they lend to your code. In the process, you would have also become
    more familiar with compiling code that uses the Boost libraries and linking to
    the appropriate libraries as needed.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经欣赏了Boost库中的多样性以及它们为您的代码提供的表达能力。在这个过程中，您也会更加熟悉使用Boost库编译代码并根据需要链接到适当的库。
- en: In the next chapter, we will look at how you can deterministically manage heap
    memory and other resources in exception-safe ways using various flavors of Boost's
    smart pointers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用各种Boost智能指针的变种以确定性地管理堆内存和其他资源，以及在异常安全的方式下。
- en: References
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Curiously Recurring Template Pattern: [https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的递归模板模式：[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern)
