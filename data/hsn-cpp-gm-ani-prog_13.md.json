["```cpp\n// Loop through all joints in the chain in reverse, \n// starting with the joint before the end effecor\nforeach joint in ikchain.reverse() {\n\u00a0\u00a0\u00a0\u00a0// Find a vector from current joint to end effector\n\u00a0\u00a0\u00a0\u00a0jointToEffector = effector.position - joint.position\n\u00a0\u00a0\u00a0\u00a0// Find a vector from the current joint to the goal\n\u00a0\u00a0\u00a0\u00a0jointToGoal = goal.position - joint.position\n\u00a0\u00a0\u00a0\u00a0// Rotate the joint so the joint to effector vector \n\u00a0\u00a0\u00a0\u00a0// matches the orientation of the joint to goal vector\n\u00a0\u00a0\u00a0\u00a0joint.rotation = fromToRotation(jointToEffector, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jointToGoal) * joint.rotation\n}\n```", "```cpp\n    class CCDSolver {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<Transform> mIKChain;\n    \u00a0\u00a0\u00a0\u00a0unsigned int mNumSteps;\n    \u00a0\u00a0\u00a0\u00a0float mThreshold;\n    public:\n    \u00a0\u00a0\u00a0\u00a0CCDSolver();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int newSize);\n    \u00a0\u00a0\u00a0\u00a0Transform& operator[](unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0Transform GetGlobalTransform(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetNumSteps();\n    \u00a0\u00a0\u00a0\u00a0void SetNumSteps(unsigned int numSteps);\n    \u00a0\u00a0\u00a0\u00a0float GetThreshold();\n    \u00a0\u00a0\u00a0\u00a0void SetThreshold(float value);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0bool Solve(const Transform& target);\n    };\n    ```", "```cpp\n    CCDSolver::CCDSolver() {\n    \u00a0\u00a0\u00a0\u00a0mNumSteps = 15;\n    \u00a0\u00a0\u00a0\u00a0mThreshold = 0.00001f;\n    }\n    ```", "```cpp\n    unsigned int CCDSolver::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mIKChain.size();\n    }\n    void CCDSolver::Resize(unsigned int newSize) {\n    \u00a0\u00a0\u00a0\u00a0mIKChain.resize(newSize);\n    }\n    Transform& CCDSolver::operator[](unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mIKChain[index];\n    }\n    ```", "```cpp\n    unsigned int CCDSolver::GetNumSteps() {\n    \u00a0\u00a0\u00a0\u00a0return mNumSteps;\n    }\n    void CCDSolver::SetNumSteps(unsigned int numSteps) {\n    \u00a0\u00a0\u00a0\u00a0mNumSteps = numSteps;\n    }\n    float CCDSolver::GetThreshold() {\n    \u00a0\u00a0\u00a0\u00a0return mThreshold;\n    }\n    void CCDSolver::SetThreshold(float value) {\n    \u00a0\u00a0\u00a0\u00a0mThreshold = value;\n    }\n    ```", "```cpp\n    Transform CCDSolver::GetGlobalTransform(unsigned int x) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = (unsigned int)mIKChain.size();\n    \u00a0\u00a0\u00a0\u00a0Transform world = mIKChain[x];\n    \u00a0\u00a0\u00a0\u00a0for (int i = (int) x - 1; i >= 0; --i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0world = combine(mIKChain[i], world);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return world;\n    }\n    ```", "```cpp\n    bool CCDSolver::Solve(const Transform& target) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (size == 0) { return false; }\n    \u00a0\u00a0\u00a0\u00a0unsigned int last = size - 1;\n    \u00a0\u00a0\u00a0\u00a0float thresholdSq = mThreshold * mThreshold;\n    \u00a0\u00a0\u00a0\u00a0vec3 goal = target.position;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < mNumSteps; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 effector = GetGlobalTransform(last).position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (lenSq(goal - effector) < thresholdSq) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = (int)size - 2; j >= 0; --j) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0effector=GetGlobalTransform(last).position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform world = GetGlobalTransform(j);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 position = world.position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat rotation = world.rotation;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 toEffector = effector - position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 toGoal = goal - position;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat effectorToGoal;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (lenSq(toGoal) > 0.00001f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0effectorToGoal = fromTo(toEffector, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0toGoal);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat worldRotated =rotation * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 effectorToGoal;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat localRotate = worldRotated * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 inverse(rotation);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mIKChain[j].rotation = localRotate * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mIKChain[j].rotation;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0effector=GetGlobalTransform(last).position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (lenSq(goal - effector) < thresholdSq) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0return false;\n    } // End CCDSolver::Solve function\n    ```", "```cpp\nvoid Iterate(const Transform& goal) {\n\u00a0\u00a0\u00a0\u00a0startPosition = chain[0]\n\u00a0\u00a0\u00a0\u00a0// Iterate backwards\n\u00a0\u00a0\u00a0\u00a0chain[size - 1] = goal.position;\n\u00a0\u00a0\u00a0\u00a0for (i = size - 2; i >= 0; --i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = chain[i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next = chain[i + 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0direction = normalize(current - next)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0offset = direction * length[i + 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0chain[i] = next + offset\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Iterate forwards\n\u00a0\u00a0\u00a0\u00a0chain[0] = startPosition\n\u00a0\u00a0\u00a0\u00a0for (i\u00a0\u00a0= 1; i < size; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = chain[i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prev = chain[i - 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0direction = normalize(current - prev)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0offset = direction * length[i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0chain[i] = prev + offset\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\n    class FABRIKSolver {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<Transform> mIKChain;\n    \u00a0\u00a0\u00a0\u00a0unsigned int mNumSteps;\n    \u00a0\u00a0\u00a0\u00a0float mThreshold;\n    \u00a0\u00a0\u00a0\u00a0std::vector<vec3> mWorldChain;\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> mLengths;\n    ```", "```cpp\n    protected:\n    \u00a0\u00a0\u00a0\u00a0void IKChainToWorld();\n    \u00a0\u00a0\u00a0\u00a0void IterateForward(const vec3& goal);\n    \u00a0\u00a0\u00a0\u00a0void IterateBackward(const vec3& base);\n    \u00a0\u00a0\u00a0\u00a0void WorldToIKChain();\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0FABRIKSolver();\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int newSize);\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetNumSteps();\n    \u00a0\u00a0\u00a0\u00a0void SetNumSteps(unsigned int numSteps);\n    \u00a0\u00a0\u00a0\u00a0float GetThreshold();\n    \u00a0\u00a0\u00a0\u00a0void SetThreshold(float value);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Transform GetLocalTransform(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0void SetLocalTransform(unsigned int index, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const Transform& t);\n    \u00a0\u00a0\u00a0\u00a0Transform GetGlobalTransform(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0bool Solve(const Transform& target);\n    };\n    ```", "```cpp\n    FABRIKSolver::FABRIKSolver() {\n    \u00a0\u00a0\u00a0\u00a0mNumSteps = 15;\n    \u00a0\u00a0\u00a0\u00a0mThreshold = 0.00001f;\n    }\n    ```", "```cpp\n    unsigned int FABRIKSolver::GetNumSteps() {\n    \u00a0\u00a0\u00a0\u00a0return mNumSteps;\n    }\n    void FABRIKSolver::SetNumSteps(unsigned int numSteps) {\n    \u00a0\u00a0\u00a0\u00a0mNumSteps = numSteps;\n    }\n    float FABRIKSolver::GetThreshold() {\n    \u00a0\u00a0\u00a0\u00a0return mThreshold;\n    }\n    void FABRIKSolver::SetThreshold(float value) {\n    \u00a0\u00a0\u00a0\u00a0mThreshold = value;\n    }\n    ```", "```cpp\n    unsigned int FABRIKSolver::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mIKChain.size();\n    }\n    void FABRIKSolver::Resize(unsigned int newSize) {\n    \u00a0\u00a0\u00a0\u00a0mIKChain.resize(newSize);\n    \u00a0\u00a0\u00a0\u00a0mWorldChain.resize(newSize);\n    \u00a0\u00a0\u00a0\u00a0mLengths.resize(newSize);\n    }\n    ```", "```cpp\n    Transform FABRIKSolver::GetLocalTransform(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mIKChain[index];\n    }\n    void FABRIKSolver::SetLocalTransform(unsigned int index,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const Transform& t) {\n    \u00a0\u00a0\u00a0\u00a0mIKChain[index] = t;\n    }\n    ```", "```cpp\n    Transform FABRIKSolver::GetGlobalTransform(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = (unsigned int)mIKChain.size();\n    \u00a0\u00a0\u00a0\u00a0Transform world = mIKChain[index];\n    \u00a0\u00a0\u00a0\u00a0for (int i = (int)index - 1; i >= 0; --i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0world = combine(mIKChain[i], world);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return world;\n    }\n    ```", "```cpp\n    void FABRIKSolver::IKChainToWorld() {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform world = GetGlobalTransform(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[i] = world.position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i >= 1) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 prev = mWorldChain[i - 1];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mLengths[i] = len(world.position - prev);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (size > 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mLengths[0] = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void FABRIKSolver::WorldToIKChain() {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (size == 0) { return; }\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size - 1; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform world = GetGlobalTransform(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform next = GetGlobalTransform(i + 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 position = world.position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat rotation = world.rotation;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 toNext = next.position - position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0toNext = inverse(rotation) * toNext;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 toDesired = mWorldChain[i + 1] - position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0toDesired = inverse(rotation) * toDesired;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat delta = fromTo(toNext, toDesired);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mIKChain[i].rotation = delta * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mIKChain[i].rotation;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void FABRIKSolver::IterateBackward(const vec3& goal) {\n    \u00a0\u00a0\u00a0\u00a0int size = (int)Size();\n    \u00a0\u00a0\u00a0\u00a0if (size > 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[size - 1] = goal;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for (int i = size - 2; i >= 0; --i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 direction = normalized(mWorldChain[i] - \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[i + 1]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 offset = direction * mLengths[i + 1];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[i] = mWorldChain[i + 1] + offset;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void FABRIKSolver::IterateForward(const vec3& base) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (size > 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[0] = base;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for (int i = 1; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 direction = normalized(mWorldChain[i] - \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[i - 1]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 offset = direction * mLengths[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mWorldChain[i] = mWorldChain[i - 1] + offset;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    bool FABRIKSolver::Solve(const Transform& target) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (size == 0) { return false; }\n    \u00a0\u00a0\u00a0\u00a0unsigned int last = size - 1;\n    \u00a0\u00a0\u00a0\u00a0float thresholdSq = mThreshold * mThreshold;\n\n    \u00a0\u00a0\u00a0\u00a0IKChainToWorld();\n    \u00a0\u00a0\u00a0\u00a0vec3 goal = target.position;\n    \u00a0\u00a0\u00a0\u00a0vec3 base = mWorldChain[0];\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < mNumSteps; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 effector = mWorldChain[last];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (lenSq(goal - effector) < thresholdSq) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WorldToIKChain();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IterateBackward(goal);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IterateForward(base);\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0WorldToIKChain();\n    \u00a0\u00a0\u00a0\u00a0vec3 effector = GetGlobalTransform(last).position;\n    \u00a0\u00a0\u00a0\u00a0if (lenSq(goal - effector) < thresholdSq) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    bool CCDSolver::Solve(const vec3& goal) {\n    \u00a0\u00a0\u00a0\u00a0// Local variables and size check\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < mNumSteps; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if we've reached the goal\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = (int)size - 2; j >= 0; --j) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // Iteration logic\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 // -> APPLY CONSTRAINTS HERE!\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0effector = GetGlobalTransform(last).position;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (lenSq(goal - effector) < thresholdSq) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Last goal check\n    }\n    ```", "```cpp\n    bool FABRIKSolver::Solve(const vec3& goal) {\n    \u00a0\u00a0\u00a0\u00a0// Local variables and size check\n    \u00a0\u00a0\u00a0\u00a0IKChainToWorld();\n    \u00a0\u00a0\u00a0\u00a0vec3 base = mWorldChain[0];\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < mNumSteps; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if we've reached the goal\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IterateBackward(goal);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IterateForward(base);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WorldToIKChain();//NEW, NEEDED FOR CONSTRAINTS\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// -> APPLY CONSTRAINTS HERE!\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IKChainToWorld();//NEW, NEEDED FOR CONSTRAINTS\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Last goal check\n    }\n    ```", "```cpp\nvoid ApplyBallSocketConstraint(int i, float limit) { \n\u00a0\u00a0\u00a0\u00a0quat parentRot = i == 0 ? mOffset.rotation : \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 GetWorldTransform(i - 1).rotation;\n\u00a0\u00a0\u00a0\u00a0quat thisRot = GetWorldTransform(i).rotation;\n\u00a0\u00a0\u00a0\u00a0vec3 parentDir = parentRot * vec3(0, 0, 1);\n\u00a0\u00a0\u00a0\u00a0vec3 thisDir = thisRot * vec3(0, 0, 1);\n\u00a0\u00a0\u00a0\u00a0float angle = ::angle(parentDir, thisDir);\n\u00a0\u00a0\u00a0\u00a0if (angle > limit * QUAT_DEG2RAD) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec3 correction = cross(parentDir, thisDir);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat worldSpaceRotation = parentRot * \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0angleAxis(limit * QUAT_DEG2RAD, correction);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mChain[i].rotation = worldSpaceRotation * \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 inverse(parentRot);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nvoid ApplyHingeSocketConstraint(int i, vec3 axis) { \n\u00a0\u00a0\u00a0\u00a0Transform joint = GetWorldTransform(i);\n\u00a0\u00a0\u00a0\u00a0Transform parent = GetWorldTransform(i - 1);\n\u00a0\u00a0\u00a0\u00a0vec3 currentHinge = joint.rotation * axis;\n\u00a0\u00a0\u00a0\u00a0vec3 desiredHinge = parent.rotation * axis;\n\u00a0\u00a0\u00a0\u00a0mChain[i].rotation = mChain[i].rotation * \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 fromToRotation(currentHinge, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0desiredHinge);\n}\n```"]