- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Concurrent System Programming with C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 进行并发系统编程
- en: In this chapter, we will look at what concurrency means and how it is different
    from parallelism. We will go through the fundamentals and the theory behind processes
    and threads. We will look at the changes in the C++ memory model, which enforce
    native concurrency support in the language. We will also familiarize ourselves
    with what a race condition is, how it can lead to a data race, and how to prevent
    data races. Next, we will get acquainted with the C++20 `std::jthread` primitive,
    which enables multithreading support. We will learn about the specifics of the
    `std::jthread` class and how we can stop already running `std::jthread` instances
    by using the `std::stop_source` primitive. Finally, we will learn how to synchronize
    the execution of concurrent code and how to report calculation results from executed
    tasks. We will learn how to use C++ synchronization primitives such as *barriers*
    and *latches* to synchronize the execution of concurrent tasks, and how to properly
    report the result of these tasks using *promises* and *futures*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨并发意味着什么，以及它与并行性的区别。我们将了解进程和线程的基本原理和理论。我们将探讨 C++ 内存模型的变化，这些变化强制语言支持原生并发。我们还将熟悉什么是竞态条件，它如何导致数据竞争，以及如何防止数据竞争。接下来，我们将熟悉
    C++20 的 `std::jthread` 原语，它使多线程支持成为可能。我们将了解 `std::jthread` 类的细节，以及如何使用 `std::stop_source`
    原语停止已运行的 `std::jthread` 实例。最后，我们将学习如何同步并发代码的执行，以及如何从执行的任务中报告计算结果。我们将学习如何使用 C++
    同步原语，如 *屏障* 和 *闩锁* 来同步并发任务的执行，以及如何使用 *承诺* 和 *未来* 正确报告这些任务的结果。
- en: 'To sum up, we will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主题：
- en: What is concurrency?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: Thread versus process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程与进程
- en: Concurrency with C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 进行并发
- en: Demystifying race conditions and data races
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭秘竞态条件和数据竞争
- en: Practical multithreading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践多线程
- en: Sharing data during parallel execution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行期间共享数据
- en: So, let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都在以下配置的环境中进行了测试：
- en: Linux Mint 21 Cinnamon Edition
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Mint 21 Cinnamon 版本
- en: GCC 12.2 with compiler flags – `-``std=c++20 -pthread`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 12.2 与编译器标志 – `-std=c++20 -pthread`
- en: A stable internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接
- en: Please make sure your environment is at least this recent. For all the examples,
    you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保您的环境至少是这个版本。对于所有示例，您还可以使用 [https://godbolt.org/](https://godbolt.org/)。
- en: All code examples in this chapter are available to download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%206](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%206).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例均可从 [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%206](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%206)
    下载。
- en: What is concurrency?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: Modern cars have become highly intricate machines that provide not only transportation
    but also various other functionalities. These functionalities include infotainment
    systems, which allow users to play music and videos, and heating and air conditioning
    systems, which regulate the temperature for passengers. Consider a scenario in
    which these features did not work simultaneously. In such a case, the driver would
    have to choose between driving the car, listening to music, or staying in a comfortable
    climate. This is not what we expect from a car, right? We expect all of these
    features to be available at the same time, enhancing our driving experience and
    providing a comfortable trip. To achieve this, these features must operate in
    parallel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代汽车已经成为高度复杂的机器，不仅提供交通功能，还提供各种其他功能。这些功能包括信息娱乐系统，允许用户播放音乐和视频，以及加热和空调系统，调节乘客的气温。考虑一个这样的场景，这些功能不能同时工作。在这种情况下，驾驶员必须在开车、听音乐或保持舒适气候之间做出选择。这并不是我们对汽车的期望，对吧？我们期望所有这些功能都能同时可用，增强我们的驾驶体验，提供舒适的旅程。为了实现这一点，这些功能必须并行运行。
- en: But do they really run in parallel, or do they just run concurrently? Is there
    any difference?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它们真的并行运行，还是只是并发运行？有什么区别吗？
- en: In computer systems, **concurrency** and **parallelism** are similar in certain
    ways, but they are not the same. Imagine you have some work to do, but this work
    can be done in separate smaller chunks. Concurrency refers to the situation where
    multiple chunks of the work begin, execute, and finish during overlapping time
    intervals, without a guaranteed specific order of execution. On the other hand,
    parallelism is an execution policy where these chunks execute simultaneously on
    hardware with multiple computing resources, such as a multi-core processor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统中，**并发**和**并行**在某些方面是相似的，但它们并不相同。想象一下，你有一些工作要做，但这些工作可以分成几个独立的小部分。并发指的是多个工作部分在重叠的时间间隔内开始、执行和完成，没有保证特定的执行顺序。另一方面，并行是一种执行策略，这些部分在具有多个计算资源的硬件上同时执行，例如多核处理器。
- en: Concurrency happens when multiple chunks of work, which we call **tasks**, are
    executed in an unspecified order for a certain period of time. The operating system
    could run some of the tasks and force the rest to wait. In concurrent execution,
    the task continuously strives for an execution slot because the operating system
    does not guarantee that it will execute all of them at once. Furthermore, it is
    highly possible that while a task is being executed, it is suddenly suspended,
    and another task starts executing. This is called **preemption**. It is clear
    that in concurrent task execution, the order of how the tasks will be executed
    is not guaranteed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个工作部分，我们称之为**任务**，在一定时间内以未指定的顺序执行时，就会发生并发。操作系统可能会运行一些任务，并强制其他任务等待。在并发执行中，任务持续争取执行槽位，因为操作系统不保证它们会一次性执行所有任务。此外，在任务执行过程中，它可能会突然被暂停，另一个任务开始执行。这被称为**抢占**。很明显，在并发任务执行中，任务的执行顺序是没有保证的。
- en: 'Let’s get back to our car example. In modern cars, the infotainment system
    is responsible for performing many activities simultaneously. For example, it
    can run the navigation part while allowing you to listen to music. This is possible
    because the system runs these tasks concurrently. It runs the tasks related to
    route calculation while processing the music content. If the hardware system has
    a single core, then these tasks should run concurrently:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的汽车例子。在现代汽车中，信息娱乐系统负责同时执行许多活动。例如，它可以在运行导航部分的同时让你听音乐。这是可能的，因为系统可以并发地运行这些任务。它在处理音乐内容的同时运行与路线计算相关的任务。如果硬件系统只有一个核心，那么这些任务应该并发运行：
- en: '![Figure 6.1 – Concurrent task execution](img/Figure_6.01_B20833.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 并发任务执行](img/Figure_6.01_B20833.jpg)'
- en: Figure 6.1 – Concurrent task execution
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 并发任务执行
- en: 'From the preceding figure, you can see that each task gets a non-deterministic
    execution time in an unpredictable order. In addition, there is no guarantee that
    your task will be finished before the next one is started. This is where the preemption
    happens. While your task is running, it is suddenly suspended, and another task
    is scheduled for execution. Keep in mind that task switching is not a cheap process.
    The system consumes the processor’s computation resource to perform this action
    – to make the context switch. The conclusion should be the following: we have
    to design our systems to respect these limitations.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你可以看到每个任务以不可预测的顺序获得非确定性的执行时间。此外，没有保证你的任务会在下一个任务开始之前完成。这就是抢占发生的地方。当你的任务正在运行时，它突然被暂停，另一个任务被安排执行。请记住，任务切换不是一个便宜的过程。系统消耗处理器的计算资源来执行这个动作——进行上下文切换。结论应该是这样的：我们必须设计我们的系统来尊重这些限制。
- en: On the other hand, parallelism is a form of concurrency that involves executing
    multiple operations simultaneously on *separate processing units*. For example,
    a computer with multiple CPUs can execute multiple tasks in parallel, which can
    lead to significant performance improvements. You don’t have to worry about the
    context switching and the preemption. It has its drawbacks, though, and we will
    discuss them thoroughly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，并行是一种并发形式，涉及在**独立的处理单元**上同时执行多个操作。例如，具有多个CPU的计算机可以并行执行多个任务，这可以导致性能的显著提升。你不必担心上下文切换和抢占。尽管如此，它也有其缺点，我们将详细讨论。
- en: '![Figure 6.2 – Parallel task execution](img/Figure_6.02_B20833.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 并行任务执行](img/Figure_6.02_B20833.jpg)'
- en: Figure 6.2 – Parallel task execution
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 并行任务执行
- en: Going back to our car example, if the CPU of the infotainment system is multi-core,
    then the tasks related to the navigation system could be executed on one core,
    and the tasks for the music processing on some of the other cores. Therefore,
    you don’t have to take any action to design your code to support preemption. Of
    course, this is only true if you are sure that your code will be executed in such
    an environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的汽车例子，如果信息娱乐系统的CPU是多核的，那么导航系统的相关任务可以在一个核心上执行，而音乐处理任务可以在其他一些核心上执行。因此，你不需要采取任何行动来设计你的代码以支持抢占。当然，这只有在你能确定你的代码将在这样的环境中执行时才成立。
- en: The fundamental connection between concurrency and parallelism lies in the fact
    that parallelism can be applied to concurrent computations without affecting the
    accuracy of the outcome, but the presence of concurrency alone does not guarantee
    parallelism.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并发与并行之间的基本联系在于，并行性可以应用于并发计算，而不会影响结果的准确性，但仅仅并发并不保证并行性。
- en: In summary, concurrency is an important concept in computing that allows multiple
    tasks to be executed simultaneously, even though that is not guaranteed. This
    could lead to improved performance and efficient resource utilization but at the
    cost of more complicated code respecting the pitfalls that concurrency brings.
    On the other hand, truly parallel execution of code is easier to handle from a
    software perspective but must be supported by the underlying system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，并发是计算中的一个重要概念，它允许同时执行多个任务，尽管这并不保证。这可能会导致性能提升和资源利用效率的提高，但代价是代码更加复杂，需要尊重并发带来的陷阱。另一方面，从软件角度来看，真正并行执行代码更容易处理，但必须由底层系统支持。
- en: In the next section, we will get familiar with the difference between execution
    threads and processes in Linux.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将熟悉Linux中执行线程和进程之间的区别。
- en: Threads versus processes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程与进程
- en: In Linux, a **process** is an instance of a program in execution. A process
    can have one or more threads of execution. A **thread** is a sequence of instructions
    that can proceed independently of other threads within the same process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，**进程**是正在执行程序的实例。一个进程可以有一个或多个执行线程。**线程**是可以在同一进程内独立于其他线程执行的指令序列。
- en: Each process has its own memory space, system resources, and execution context.
    Processes are isolated from each other and do not share memory by default. They
    can only communicate through files and **inter-process communication** (**IPC**)
    mechanisms, such as pipes, queues, sockets, shared memory, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有自己的内存空间、系统资源和执行上下文。进程之间是隔离的，默认情况下不共享内存。它们只能通过文件和**进程间通信**（**IPC**）机制，如管道、队列、套接字、共享内存等来通信。
- en: A thread, on the other hand, is a lightweight unit of execution within a process.
    The overhead of loading the instructions from non-volatile memory to RAM or even
    the cache is already paid for by the process creating the thread – the parent
    process. Each thread has its own stack and register values but shares the memory
    space and system resources of the parent process. Because threads share memory
    within the process, they can easily communicate with each other and synchronize
    their own execution. In general, this makes them more efficient than processes
    for concurrent execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程是进程内的轻量级执行单元。从非易失性内存中加载指令到RAM或甚至缓存的开销已经由创建线程的进程——父进程——承担。每个线程都有自己的堆栈和寄存器值，但共享父进程的内存空间和系统资源。因为线程在进程内共享内存，所以它们可以轻松地相互通信并同步自己的执行。一般来说，这使得它们在并发执行方面比进程更有效率。
- en: '![Figure 6.3 – IPC](img/Figure_6.03_B20833.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – IPC](img/Figure_6.03_B20833.jpg)'
- en: Figure 6.3 – IPC
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – IPC
- en: 'The main differences between processes and threads are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程之间的主要区别如下：
- en: '**Resource allocation**: Processes are independent entities that have their
    own memory space, system resources, and scheduling priority. On the other hand,
    threads share the same memory space and system resources as the process they belong
    to.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：进程是独立的实体，拥有自己的内存空间、系统资源和调度优先级。另一方面，线程与它们所属的进程共享相同的内存空间和系统资源。'
- en: '**Creation and destruction**: Processes are created and destroyed by the operating
    system, while threads are created and managed by the process that they belong
    to.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创造与销毁**：进程是由操作系统创建和销毁的，而线程是由它们所属的进程创建和管理的。'
- en: '**Context switching**: When a context switch occurs, the operating system switches
    the entire process context, including all its threads. In contrast, a thread context
    switch only requires switching the state of the current thread, which, in general,
    is faster and less resource-intensive.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文切换**：当发生上下文切换时，操作系统会切换整个进程上下文，包括其所有线程。相比之下，线程上下文切换只需要切换当前线程的状态，这在一般情况下更快，资源消耗也更少。'
- en: '**Communication and synchronization**: IPC mechanisms such as pipes, queues,
    sockets, and shared memory are used to enable communication between processes.
    Threads, on the other hand, can communicate directly by sharing memory within
    the same process. This also enables efficient synchronization between threads,
    as they can use locks and other synchronization primitives to coordinate their
    access to shared resources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信和同步**：使用管道、队列、套接字和共享内存等IPC机制来启用进程间的通信。另一方面，线程可以通过在同一个进程内共享内存来直接通信。这也使得线程之间的同步变得高效，因为它们可以使用锁和其他同步原语来协调对共享资源的访问。'
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Linux schedules tasks in the kernel, which are either threads or single-threaded
    processes. Each task is represented through a kernel thread; thus, the scheduler
    does not differentiate between a thread and a process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linux在内核中调度任务，这些任务要么是线程，要么是单线程进程。每个任务都通过内核线程来表示；因此，调度器不会区分线程和进程。
- en: Processes and threads have their analogy in real life. Let’s say you are working
    on a project with a group of people, and the project is divided into different
    tasks. Each task represents a unit of work that needs to be completed. You can
    think of the project as a process, and each task as a thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程在现实生活中有它们的类比。假设你正在与一组人合作完成一个项目，项目被划分为不同的任务。每个任务代表需要完成的工作单元。你可以将项目视为进程，每个任务视为线程。
- en: In this analogy, the process (project) is a collection of related tasks that
    need to be completed to achieve a common goal. Each task (thread) is a separate
    unit of work that can be assigned to a specific person to complete.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，进程（项目）是一系列需要完成以实现共同目标的关联任务集合。每个任务（线程）是一个独立的工作单元，可以被分配给特定的人来完成。
- en: When you assign a task to someone, you are creating a new thread within the
    project (process). The person who is assigned the task (thread) can work on it
    independently, without interfering with the work of others. They may also communicate
    with other team members (threads) to coordinate their work, just as threads within
    a process can communicate with each other. They also need to use the common project
    resource to finish their tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一项任务分配给某个人时，你就在项目中（进程）创建了一个新的线程。被分配任务（线程）的人可以独立地工作，而不会干扰到他人的工作。他们还可以与其他团队成员（线程）沟通，协调他们的工作，就像进程内的线程可以相互沟通一样。他们还需要使用共同的资源来完成他们的任务。
- en: In contrast, if you divide the project into different projects, you create multiple
    processes. Each process has its own resources, team members, and goals. It is
    harder to ensure that both processes share a resource needed for the project to
    finish.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你将项目划分为不同的项目，你将创建多个进程。每个进程都有自己的资源、团队成员和目标。确保这两个进程共享项目完成所需的资源变得更加困难。
- en: So, processes and threads in computing are like real-life projects and tasks,
    respectively. A process represents a collection of related tasks that need to
    be completed to achieve a common goal, while a thread is a separate unit of work
    that can be assigned to a specific person to complete.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算机中的进程和线程分别类似于现实生活中的项目和任务。进程代表需要完成以实现共同目标的关联任务集合，而线程是独立的工作单元，可以被分配给特定的人来完成。
- en: In Linux, processes are separate instances of a program with their own memory
    and resources, while threads are lightweight execution units within a process
    that share the same memory and resources. Threads can communicate more efficiently
    and are more suitable for tasks that require parallel execution, while processes
    provide better isolation and fault tolerance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，进程是具有自己内存和资源的程序实例，而线程是进程内的轻量级执行单元，它们共享相同的内存和资源。线程可以更有效地进行通信，更适合需要并行执行的任务，而进程提供了更好的隔离和容错能力。
- en: Having all this in mind, let’s see how to write concurrent code in C++.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们看看如何在C++中编写并发代码。
- en: Concurrency with C++
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的并发
- en: The C++ language has had built-in support for managing and executing concurrent
    threads since C++11\. But it doesn’t have any native support for managing concurrent
    processes. The C++ Standard Library provides various classes for thread management,
    synchronization and communication between threads, protection of shared data,
    atomic operations, and parallel algorithms. The **C++ memory model** is also designed
    with thread awareness in mind. This makes it a great choice for developing concurrent
    applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言自 C++11 起就内置了对管理并发线程的支持。但它没有为管理并发进程提供任何原生支持。C++ 标准库提供了各种用于线程管理、线程间同步和通信、保护共享数据、原子操作和并行算法的类。**C++
    内存模型**也是考虑到线程意识而设计的。这使得它成为开发并发应用程序的一个很好的选择。
- en: Multithreading with C++ is the ability to have multiple threads of execution
    running concurrently within a single program. This allows a program to take advantage
    of multiple CPU cores and perform tasks in parallel, leading to faster completion
    of tasks and improved overall performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 进行多线程是指在一个程序中同时运行多个执行线程的能力。这允许程序利用多个 CPU 核心，并行执行任务，从而加快任务完成速度并提高整体性能。
- en: The C++ Standard Library introduced the `std::thread` thread management class.
    Once it is instantiated, it is the responsibility of the user to take care of
    the thread’s objective. The users have to choose to either join the thread or
    detach it from its parent thread. If they don’t take care of it, the program terminates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库引入了 `std::thread` 线程管理类。一旦实例化，用户就有责任处理线程的目标。用户必须选择是连接线程还是将其从父线程中分离。如果他们不加以管理，程序将终止。
- en: With the release of C++20, a brand-new thread management class, `std::jthread`,
    was introduced. It makes it relatively easy to create and manage threads. To create
    a new thread, you can create an instance of the `std::jthread` class, passing
    the function or callable object that you want to run as a separate thread. A key
    advantage of `std::jthread` compared to `std::thread` is that you don’t have to
    explicitly worry about joining it. It will be done automatically during the `std::jthread`
    destruction. Later in the chapter, we will have a deeper look into `std::jthread`
    and how to use it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++20 的发布，引入了一个全新的线程管理类 `std::jthread`。它使得创建和管理线程相对容易。要创建一个新线程，你可以创建 `std::jthread`
    类的实例，传递你想要在单独线程中运行的函数或可调用对象。与 `std::thread` 相比，`std::jthread` 的一个关键优势是，你不必显式地担心将其连接。它将在
    `std::jthread` 销毁时自动完成。在本章的后面部分，我们将更深入地探讨 `std::jthread` 以及如何使用它。
- en: Bear in mind that multithreading will also make a program more complex, as it
    requires careful management of shared resources and synchronization of threads.
    If not properly managed, multithreading can lead to issues such as deadlocks and
    race conditions, which can cause a program to hang or produce unexpected results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，多线程也会使程序变得更加复杂，因为它需要仔细管理共享资源和线程同步。如果管理不当，多线程可能导致死锁和竞态条件等问题，这些问题可能导致程序挂起或产生意外的结果。
- en: Additionally, multithreading requires the developers to ensure that the code
    is thread-safe, which can be a challenging task. Not all tasks are suitable for
    multithreading; some tasks may actually run slower if attempted to be parallelized.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，多线程要求开发者确保代码是线程安全的，这可能是一项具有挑战性的任务。并非所有任务都适合多线程；有些任务如果尝试并行化，实际上可能会运行得更慢。
- en: Overall, multithreading with C++ can provide significant benefits in terms of
    performance and resource utilization, but it also requires careful consideration
    of the potential challenges and pitfalls.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，使用 C++ 进行多线程可以在性能和资源利用方面提供显著的好处，但它也要求仔细考虑潜在挑战和陷阱。
- en: Now, let’s get familiar with the most common pitfalls of writing concurrent
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们熟悉一下编写并发代码最常见的陷阱。
- en: Demystifying race conditions and data races
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘竞态条件和数据竞争
- en: 'In C++, multithreading support was first introduced with the C++11 version
    of the language. One of the key elements provided by the C++11 standard to facilitate
    multithreading is the memory model. The memory model tackles two problems: the
    layout of objects in memory and the concurrent access to these objects. In C++,
    all data is represented by objects, which are blocks of memory that have various
    properties such as type, size, alignment, lifetime, value, and an optional name.
    Each object remains in memory for a specific period of time and is stored in one
    or more memory locations, depending on whether it is a simple scalar object or
    a more complex type.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，多线程支持首次在C++11语言版本中引入。C++11标准提供的关键元素之一是内存模型，它有助于促进多线程。内存模型解决两个问题：对象在内存中的布局以及对这些对象的并发访问。在C++中，所有数据都由对象表示，这些对象是具有各种属性（如类型、大小、对齐、生命周期、值和可选名称）的内存块。每个对象在内存中保持一段时间，并存储在一个或多个内存位置中，这取决于它是一个简单的标量对象还是一个更复杂的数据类型。
- en: In the context of multithreaded programming in C++, it is crucial to consider
    how to tackle concurrent access by multiple threads to shared objects. If two
    or more threads try to access different memory locations, there is usually no
    problem. However, when threads attempt to write in the same memory location simultaneously,
    it can lead to data races, which can cause unexpected behaviors and errors in
    the program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++的多线程编程中，考虑如何处理多个线程对共享对象的并发访问至关重要。如果两个或更多线程尝试访问不同的内存位置，通常不会有问题。然而，当线程尝试同时写入同一内存位置时，可能会导致数据竞争，这可能导致程序中出现意外的行为和错误。
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Data races occur when multiple threads try to access data and at least one of
    them attempts to modify it, and no precautions are taken to synchronize the memory
    access. Data races can cause undefined behavior in your program and are a source
    of trouble.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据竞争发生在多个线程尝试访问数据，并且至少有一个线程尝试修改它，而没有采取预防措施来同步内存访问时。数据竞争可能导致程序中出现未定义的行为，并成为问题的来源。
- en: 'But how does your program come to a *data race*? This happens when there is
    a *race condition* that hasn’t been properly handled. Let’s have a look into the
    difference between data races and race conditions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但你的程序是如何出现数据竞争的？这发生在存在未妥善处理的竞态条件时。让我们来看看数据竞争和竞态条件的区别：
- en: '**Race condition**: A situation where the correctness of a code depends on
    specific timing or a strict sequence of operation'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：一种代码的正确性取决于特定时间或严格操作顺序的情况'
- en: '**Data race**: When two or more threads access one object and at least one
    of these threads modifies it'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据竞争**：当两个或更多线程访问一个对象，并且至少有一个线程修改它时'
- en: 'Based on these definitions, we can deduce that every data race that occurs
    in your program comes as a result of not correctly handling race conditions. But
    the opposite is not always true: not every race condition leads to a data race.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些定义，我们可以推断出，你程序中发生的每一个数据竞争都是由于没有正确处理竞态条件的结果。但反之并不总是成立：并非每个竞态条件都会导致数据竞争。
- en: There is no better way to understand race conditions and data races than by
    looking at an example. Let’s imagine a primitive banking system, really primitive,
    which we hope doesn’t exist anywhere.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看示例来理解竞态条件和数据竞争是最佳方式。让我们想象一个原始的银行系统，一个非常原始的系统，我们希望它不存在于任何地方。
- en: Bill and John have accounts in a bank. Bill has $100 in his account and John
    has $50\. Bill owes John a total of $30\. To pay off his debt, Bill decides to
    make two transfers to John’s account. The first is worth $10 and the second is
    $20\. So de facto, Bill will repay John. After both transfers are complete, Bill
    will have $70 left in his account, while John will have accumulated a total of
    $80.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比尔和约翰在一家银行有账户。比尔账户中有100美元，约翰账户中有50美元。比尔总共欠约翰30美元。为了还清债务，比尔决定向约翰的账户进行两次转账。第一次转账10美元，第二次转账20美元。所以实际上，比尔将偿还约翰。两次转账完成后，比尔账户中剩下70美元，而约翰账户累计达到80美元。
- en: 'Let’s define an `Account` structure that contains the name of the owner of
    the account together with their account balance at a certain moment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个包含账户所有者姓名和他们在某一时刻的账户余额的`Account`结构：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `Account` structure, we will also add the overloaded operator methods
    for `+=` and `-=`. These are responsible for depositing or withdrawing a specific
    amount of money to the corresponding account, respectively. Before and after each
    of the operations, the current balance of the account is printed. Here is the
    definition of these operators, which are part of the `Account` structure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Account` 结构中，我们还将添加 `+=` 和 `-=` 重载操作符方法。这些方法分别负责向相应的账户存入或提取特定金额的钱。在每个操作之前和之后，都会打印出账户的当前余额。以下是这些操作符的定义，它们是
    `Account` 结构的一部分：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking into the implementation of the operator functions shows that they first
    read the current balance of the account, then store it in a local object (marker
    `{1}`), and finally, using the value of the local object, they increment or decrement
    with the specified amount.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看操作符函数的实现过程可以看出，它们首先读取账户的当前余额，然后将其存储在一个局部对象中（标记为 `{1}`），最后，使用局部对象的值，根据指定的金额进行增加或减少。
- en: As simple as it gets!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到不能再简单了！
- en: The resulting value of the new balance of the account is written back into the
    `balance` member of the `Account` structure (marker `{2}`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 账户新余额的结果被写回到 `Account` 结构的 `balance` 成员中（标记为 `{2}`）。
- en: 'We also need to define a method that will be responsible for the actual money
    transfer:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个负责实际钱款转账的方法：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only thing it does is withdraw the desired amount from one account (marker
    `{1}`) and deposit it to the other account (marker `{2}`), which is exactly what
    we need to successfully transfer money between accounts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的唯一事情是从一个账户（标记为 `{1}`）中提取所需金额，并将其存入另一个账户（标记为 `{2}`），这正是我们成功在账户之间转账所需要做的。
- en: 'Now, let’s have a look at our `main` program method, which will execute our
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `main` 程序方法，它将执行我们的示例：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we need to create accounts for Bill and John and deposit $100 and $70
    into them, respectively (markers `{1}` and `{2}`). Then, we have to do the actual
    money transfers: one transfer for $10 and one for $20 (markers `{3}` and `{4}`).
    I know that this code may look unfamiliar to you but don’t worry, we will deep-dive
    into `std::jthread` shortly in this chapter.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为比尔和约翰创建账户，并分别存入 $100 和 $70（标记为 `{1}` 和 `{2}`）。然后，我们必须进行实际的钱款转账：一次转账
    $10，另一次转账 $20（标记为 `{3}` 和 `{4}`）。我知道这段代码可能对你来说看起来不熟悉，但别担心，我们将在本章中很快深入探讨 `std::jthread`。
- en: The only important detail you have to know so far is that we try to make both
    transfers *concurrently* with the help of the C++ multithreading library. At the
    end of the process, we set some time for both execution threads to finish the
    money transfers (marker `{5}`) and print the result (markers `{6}` and `{7}`).
    As we already discussed, after the transfers are finished, Bill should have $70
    in his account while John should have $80.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你必须知道的重要细节是，我们试图通过 C++ 多线程库的帮助，使两次转账 *并发* 进行。在过程结束时，我们为两个执行线程设置了一些时间来完成钱款转账（标记为
    `{5}`）并打印结果（标记为 `{6}` 和 `{7}`）。正如我们之前讨论的，转账完成后，比尔应该在他的账户中有 $70，而约翰应该有 $80。
- en: 'Let’s see the program output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序输出：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Wait, what? Bill has $80 while John has $60! How is that possible?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，比尔有 $80，而约翰有 $60！这是怎么可能的？
- en: 'It’s possible because we created a *race condition* that led to a *data race*!
    Let’s explain. Having a deeper look into the implementation of the `operator+=`
    method reveals the problem. By the way, the situation is absolutely the same with
    the other operator method as well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们创建了一个导致 *竞争条件* 的 *数据竞争*！让我们来解释一下。更深入地查看 `operator+=` 方法的实现，我们可以发现问题。顺便说一下，其他操作符方法的情况也是完全相同的：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At marker `{1}`, we cache the current balance of the account into a local object
    living on the stack.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记 `{1}` 处，我们将账户的当前余额缓存到一个位于栈上的局部对象中。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The C++ memory model guarantees that each thread has its own copy of all objects
    with automatic storage duration – the stack objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 内存模型保证每个线程都有其自己的所有具有自动存储期的对象的副本——栈对象。
- en: Next, we give the current execution thread some rest time of at least `1ms`
    (marker `{2}`). With this statement, we put our thread to sleep, allowing other
    threads (if any) to take processor time and start executing. Nothing to worry
    about so far, right? Once the thread is back on executing, it uses its cached
    value of the account’s balance and increments it with the new amount. Finally,
    it stores the newly calculated value back to the `balance` member of the `Account`
    structure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给当前执行线程至少`1ms`的休息时间（标记 `{2}`）。通过这个语句，我们将线程置于休眠状态，允许其他线程（如果有）获取处理器时间并开始执行。到目前为止，没有什么可担心的，对吧？一旦线程重新开始执行，它将使用账户余额的缓存值，并增加新的金额。最后，它将新计算出的值存储回`Account`结构的`balance`成员。
- en: 'Having a closer look into the output of the program, we observe the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察程序的输出，我们注意到以下内容：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first transfer starts executing. It is running as part of a thread with
    the `140278035490560` identifier. We see that before the withdrawal is finished,
    the second transfer is started too. Its identifier is `140278027097856`. The second
    transfer finishes the withdrawal first, leaving Bill’s bank account with a balance
    of $80\. Then, the first withdrawal is back in action. But what happens then?
    Instead of taking $10 more from Bill’s account, it actually returns $10! This
    happens because the first thread was suspended when it had already cached the
    initial account balance of $100\. A *race condition* was created. Meanwhile, the
    second transfer has changed the account balance, and now, when the first transfer
    is back to execution, it already works with outdated cached values. This results
    in blindly overriding the newer account balance with the outdated value. A *data*
    *race* happened.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次转账开始执行。它作为具有`140278035490560`标识符的线程的一部分运行。我们看到在第一次提款完成之前，第二次提款也开始执行。其标识符为`140278027097856`。第二次提款首先完成提款，使得比尔的银行账户余额变为80美元。然后，第一次提款重新开始。但接下来发生了什么？它并没有从比尔的账户中再取出10美元，而是实际上退还了10美元！这是因为第一个线程在已经缓存了初始账户余额100美元时被挂起。这创建了一个*竞态条件*。同时，第二次转账已经改变了账户余额，现在当第一个转账重新开始执行时，它已经使用过时的缓存值。这导致盲目地用过时的值覆盖了更新的账户余额。发生了*数据竞态*。
- en: How do we avoid them?
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何避免它们？
- en: Luckily, the C++ programming language provides various concurrency control mechanisms
    to address these challenges, such as atomic operations, locks, semaphores, condition
    variables, barriers, and others. These mechanisms help ensure that shared resources
    are accessed in a predictable and safe manner and that threads are coordinated
    effectively to avoid a data race. In the next sections, we will get deeper into
    some of these synchronization primitives.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++编程语言提供了各种并发控制机制来解决这些挑战，例如原子操作、锁、信号量、条件变量、屏障等。这些机制有助于确保共享资源以可预测和安全的方式被访问，并且线程能够有效地协调以避免数据竞态。在接下来的章节中，我们将深入了解一些这些同步原语。
- en: Practical multithreading
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的多线程
- en: In computer science, a thread of execution is a sequence of code instructions
    that can be managed independently by a scheduler of the operating system. On a
    Linux system, the thread is always part of a process. The C++ threads could be
    executed concurrently with each other via the multithreading capabilities provided
    by the standard. During execution, threads share common memory space, unlike processes,
    where each has its own. Specifically, the threads of a process share its executable
    code, the dynamically and globally allocated objects, which are not defined as
    `thread_local`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，一个执行线程是一系列可以被操作系统调度器独立管理的代码指令序列。在Linux系统中，线程始终是进程的一部分。C++线程可以通过标准提供的多线程能力相互并发执行。在执行过程中，线程共享公共内存空间，与每个进程都有自己的内存空间不同。具体来说，进程的线程共享其可执行代码、动态和全局分配的对象，这些对象没有被定义为`thread_local`。
- en: Hello C++ jthread
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello C++ jthread
- en: 'Every C++ program contains at least one thread, and this is the thread that
    runs the `int main()` method. Multithreaded programs have additional threads started
    at some point in the execution of the main thread. Let’s have a look at a simple
    C++ program that uses multiple threads to print to the standard output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C++程序都至少包含一个线程，这就是运行`int main()`方法的线程。多线程程序在主线程执行的某个点上启动额外的线程。让我们看看一个简单的C++程序，它使用多个线程将输出打印到标准输出：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the program starts, the `int main()` method is entered. Nothing surprising
    so far. At the beginning of the execution, we create a variable on the method
    stack, called `my_threads`. It is a type of `std::array`, which contains five
    elements in it. The `std::array` type represents a container from the Standard
    Library, encapsulating C-style, fixed-sized arrays. It has the advantages of a
    standard container, such as being aware of its own size, supporting assignment,
    random access iterators, and so on. As with any other array type in C++, we need
    to specify what kind of elements it contains. In our example, `my_threads` contains
    five `std::jthread` objects. The `std::jthread` class was introduced in the C++
    Standard Library with the C++20 standard release. It represents a single thread
    of execution, just like `std::thread`, which was introduced with the release of
    C++11\. Some advantages of `std::jthread` compared to `std::thread` are that it
    automatically rejoins on destruction and it can be canceled or stopped in some
    specific cases. It is defined in the `<thread>` header; therefore, we must include
    it in order to compile successfully.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，进入 `int main()` 方法。到目前为止没有什么令人惊讶的。在执行开始时，我们在方法栈上创建了一个变量，称为 `my_threads`。它是一种
    `std::array` 类型，其中包含五个元素。`std::array` 类型代表标准库中的一个容器，封装了 C 风格的固定大小数组。它具有标准容器的优点，例如知道自己的大小，支持赋值，随机访问迭代器等。与
    C++ 中的任何其他数组类型一样，我们需要指定它包含什么类型的元素。在我们的例子中，`my_threads` 包含五个 `std::jthread` 对象。`std::jthread`
    类是在 C++20 标准发布时引入到 C++ 标准库中的。它代表一个执行线程，就像 `std::thread`，它在 C++11 的发布中引入。与 `std::thread`
    相比，`std::jthread` 的一些优点是它在销毁时会自动重新连接，并且在某些特定情况下可以被取消或停止。它定义在 `<thread>` 头文件中；因此，我们必须包含它才能成功编译。
- en: Yes, you are asking the right question! If we already defined an array of `jthread`
    objects, what job do they really perform? The expectation is that every thread
    is associated with some job that needs to be done. But here, the simple answer
    is *nothing*. Our array contains five `jthread` objects, which don’t actually
    represent an execution thread. They are used more like placeholders because, when
    `std::array` is instantiated, it also creates the objects it contains using their
    default constructors if no other arguments are passed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你问的是正确的问题！如果我们已经定义了一个 `jthread` 对象的数组，它们实际上执行什么工作呢？预期是每个线程都与一些需要完成的工作相关联。但在这里，简单的答案是
    *没有*。我们的数组包含五个 `jthread` 对象，实际上并不代表一个执行线程。它们更像是一个占位符，因为当 `std::array` 被实例化时，如果没有传递其他参数，它也会使用它们的默认构造函数创建包含的对象。
- en: 'Let’s now define some workers that our threads can be associated with. The
    `std::jthread` class accepts, as a worker, any *callable* type. Such types provide
    a single operation that can be invoked. Widely known examples of such types are
    function objects and lambda expressions, which we already covered in detail in
    [*Chapter 4*](B20833_04.xhtml#_idTextAnchor060). In our example, we will use lambda
    expressions because they provide a way of creating anonymous function objects
    (functors) that can be utilized in-line or passed as an argument. The introduction
    of lambda expressions in C++11 simplifies the process of creating anonymous functors,
    making it more efficient and straightforward. The following code shows our worker
    method defined as a lambda expression:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一些线程可以与之关联的工作者。`std::jthread` 类接受任何 *可调用* 类型作为工作者。这类类型提供单个可调用的操作。这类类型的广泛例子包括函数对象和
    lambda 表达式，我们已经在 [*第 4 章*](B20833_04.xhtml#_idTextAnchor060) 中详细介绍了。在我们的例子中，我们将使用
    lambda 表达式，因为它们提供了一种创建匿名函数对象（functors）的方法，这些对象可以内联使用或作为参数传递。C++11 中 lambda 表达式的引入简化了创建匿名函数对象的过程，使其更加高效和直接。以下代码展示了我们定义的工作者方法作为一个
    lambda 表达式：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The defined lambda expression, `const auto worker{…};`, is pretty simple. It
    is instantiated on the function stack. It has no input parameters, and it doesn’t
    capture any state from outside. The only work it does is to print to the standard
    output the `jthread` object’s ID. Every thread in C++ provided by the standard
    concurrency support library has a unique identifier associated with it. The `std::this_thread::get_id()`
    method returns the ID of the specific thread in which it has been invoked. This
    means that if this lambda expression is passed to several different threads, it
    should print a different thread ID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的lambda表达式`const auto worker{…};`相当简单。它在函数栈上实例化。它没有输入参数，也不捕获任何外部状态。它所做的唯一工作是向标准输出打印`jthread`对象的ID。C++标准并发支持库提供的每个线程都有一个与之关联的唯一标识符。`std::this_thread::get_id()`方法返回被调用的特定线程的ID。这意味着如果这个lambda表达式被传递到几个不同的线程，它应该打印出不同的线程ID。
- en: Printing to `std::cout` by many concurrent threads could bring surprising results.
    The `std::cout` object is defined as a global, thread-safe object, which ensures
    that each character written to it is done so atomically. However, no guarantees
    are made about a sequence of characters such as strings, and it is likely that
    the output when multiple threads are concurrently writing strings to `std::cout`
    will be a mixture of these strings. Well, this is not what we really want here.
    We expect that each thread will be able to fully print its messages. Therefore,
    we need a synchronization mechanism, which ensures that writing a string to `std::cout`
    is fully atomic. Luckily, C++20 introduces a whole new family of class templates
    defined in the `<syncstream>` standard library header, which provides mechanisms
    to synchronize threads writing to one and the same stream. One of them is `std::osyncstream`.
    You can use it as a regular stream. Just create an instance of it by passing `std::cout`
    as a parameter. Then, with the help of its `std::basic_ostream& operator<<(...)`
    class method, you can insert data, just like a regular stream. It is guaranteed
    that all of the inserted data will be flushed atomically to the output once the
    `std::osyncstream` object goes out of scope and is destroyed. In our example,
    the `sync_cout` object will be destroyed when the lambda is about to finish its
    execution and leave its scope. This is exactly the behavior we want.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由许多并发线程向`std::cout`打印可能会产生意想不到的结果。`std::cout`对象被定义为全局的、线程安全的对象，这确保了写入它的每个字符都是原子性的。然而，对于字符串等字符序列没有提供任何保证，并且当多个线程同时向`std::cout`写入字符串时，输出很可能是这些字符串的混合。嗯，这并不是我们真正想要的。我们期望每个线程都能完全打印出它的消息。因此，我们需要一个同步机制，确保将字符串写入`std::cout`是完全原子的。幸运的是，C++20在`<syncstream>`标准库头文件中引入了一整套新的类模板，它提供了同步线程向同一个流写入的机制。其中之一是`std::osyncstream`。你可以像使用常规流一样使用它。只需通过传递`std::cout`作为参数来创建它的一个实例。然后，借助其`std::basic_ostream&
    operator<<(...)`类方法，你可以插入数据，就像常规流一样。保证一旦`std::osyncstream`对象超出作用域并被销毁，所有插入的数据都将被原子性地刷新到输出。在我们的例子中，`sync_cout`对象将在lambda即将完成其执行并离开作用域时被销毁。这正是我们想要的行为。
- en: 'Finally, we are ready to give some work to our threads to do. This means that
    we need to associate worker lambdas with the five threads we have in the `my_threads`
    array. But the `std::jthread` type supports adding a worker method only as part
    of its construction. That’s why we need to create other `jthread` objects and
    replace them with the placeholders in the `my_threads` array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备给我们的线程分配一些工作去做。这意味着我们需要将工作lambda函数与`my_threads`数组中的五个线程关联起来。但是`std::jthread`类型只支持在其构造过程中添加工作方法。这就是为什么我们需要创建其他的`jthread`对象，并用它们替换`my_threads`数组中的占位符：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Being a standard container, `std::array` natively supports range-based for loops.
    Therefore, we can easily iterate through all elements in `my_threads` and replace
    them with new `jthread` objects that already have associated workers with them.
    Firstly, we create new `jthread` objects with automatic storage duration and assign
    them a worker object. In our case, for every newly created thread, we assign one
    and the same worker object. This is possible because, in the current case, the
    `jthread` class makes a copy of the worker instance in the `jthread` objects and,
    therefore, each `jthread` object gets its own copy of the worker lambda. When
    constructing these objects, the process is carried out within the context of the
    caller. This means that any exceptions that occur during the evaluation and copying
    or movement of the arguments are thrown in the current `main` thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准容器，`std::array` 本地支持基于范围的 for 循环。因此，我们可以轻松地遍历 `my_threads` 中的所有元素，并用已经具有相关工作者的新
    `jthread` 对象替换它们。首先，我们创建具有自动存储期的新的 `jthread` 对象，并分配一个工作对象。在我们的情况下，对于每个新创建的线程，我们分配同一个工作对象。这是可能的，因为在当前情况下，`jthread`
    类在 `jthread` 对象中复制了工作实例，因此每个 `jthread` 对象都得到了工作 lambda 的副本。当构造这些对象时，该过程是在调用者的上下文中执行的。这意味着在评估、复制或移动参数期间发生的任何异常都将抛出在当前的
    `main` 线程中。
- en: An important detail is that the newly created `jthread` objects are not copied
    to the existing elements of the array, but they are moved. Therefore, the `std::jthread`
    class has implicitly deleted its copy constructor and assignment operator because
    it doesn’t make much sense to copy a thread to an already existing thread. In
    our case, the newly created `jthread` objects will be created in the storage of
    the existing array elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的细节是，新创建的 `jthread` 对象不会被复制到数组的现有元素中，而是被移动。因此，`std::jthread` 类隐式地删除了其复制构造函数和赋值运算符，因为将一个线程复制到已存在的线程中并没有太多意义。在我们的情况下，新创建的
    `jthread` 对象将在现有数组元素的存储中创建。
- en: When a `jthread` object is constructed, the associated thread starts immediately,
    although there may be some delays due to Linux scheduling specifics. The thread
    begins executing at the function specified as an argument to the constructor.
    In our example, this is the worker lambda associated with each thread. If the
    worker returns a result, it will be ignored, and if it ends by throwing an exception,
    the `std::terminate` function is executed. Therefore, we need to make sure that
    either our worker code doesn’t throw or we catch everything throwable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `jthread` 对象被构造时，相关的线程立即开始执行，尽管可能由于 Linux 调度特性而有一些延迟。线程从构造函数参数指定的函数开始执行。在我们的例子中，这是与每个线程关联的工作
    lambda。如果工作返回一个结果，它将被忽略，如果它通过抛出异常结束，则执行 `std::terminate` 函数。因此，我们需要确保我们的工作代码不抛出异常，或者我们捕获所有可抛出的异常。
- en: When a thread is started, it begins executing its dedicated worker. Each thread
    has its own function stack space, which guarantees that any local variable defined
    in the worker will have a separate instance per thread. Therefore, `const auto
    thread_id` in the worker is initialized with a different ID depending on the thread
    it is run by. We do not need to take any precautions to ensure that the data stored
    in `thread_id` is consistent. It is guaranteed by the Standard that data with
    automatic storage duration is not shared between the threads.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程启动时，它开始执行其专用的工作。每个线程都有自己的函数栈空间，这保证了在工作者中定义的任何局部变量在每个线程中都有一个单独的实例。因此，`const
    auto thread_id` 在工作者中被初始化为不同的 ID，这取决于它是由哪个线程运行的。我们不需要采取任何预防措施来确保存储在 `thread_id`
    中的数据的一致性。标准保证具有自动存储期的数据在线程之间不共享。
- en: 'Once all the `jthread` objects have been created, the `main` thread concurrently
    prints its ID along with the rest of the threads. There is no guaranteed order
    of execution for each thread, and it is possible for one thread to be interrupted
    by another. As a result, it is important to ensure that the code is written in
    a manner that can handle potential preemption and remains robust in all scenarios:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有 `jthread` 对象都创建完成，`main` 线程将并发地打印其 ID 以及其他线程的 ID。每个线程的执行顺序没有保证，一个线程可能被另一个线程中断。因此，确保代码能够处理潜在的抢占，并在所有情况下保持健壮性是很重要的：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All threads are now running concurrently with the `main` thread. We need to
    make sure that the `main` thread is also printing to the standard output in a
    thread-safe manner. We again use an instance of `std::osyncstream`, but this time,
    we don’t create a named variable – instead, we create a temporary one. This approach
    is favored due to its ease of use, similar to using the `std::cout` object. The
    standard guarantees that the output will be flushed at the end of each statement,
    as the temporary ones persist until the end of the statement and their destructor
    is invoked, resulting in the flushing of the output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程现在都与应用程序的主线程并发运行。我们需要确保主线程以线程安全的方式向标准输出打印。我们再次使用 `std::osyncstream` 的一个实例，但这次我们不创建一个命名变量——相反，我们创建一个临时变量。这种做法因其易用性而受到青睐，类似于使用
    `std::cout` 对象。标准保证在每个语句结束时刷新输出，因为临时变量会持续到语句结束，并且它们的析构函数会被调用，从而导致输出刷新。
- en: 'Here is a sample output from the program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序的一个示例输出：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `std::jthread` name refers to a *joining* thread. Unlike `std::thread`,
    `std::jthread` also has the ability to *automatically* join the thread that it
    has been started by. The behavior of `std::thread` can be confusing at times.
    If `std::thread` has not been joined or detached, and it is still considered *joinable*,
    the `std::terminate` function will be called upon its destruction. A thread is
    considered joinable if neither the `join()` nor the `detach()` method has been
    called. In our example, all the `jthread` objects automatically join during their
    destruction and do not result in the termination of the program.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::jthread` 名称指的是一个**连接**线程。与 `std::thread` 不同，`std::jthread` 还具有**自动**连接它所启动的线程的能力。`std::thread`
    的行为有时可能会令人困惑。如果 `std::thread` 没有被连接或分离，并且仍然被认为是**可连接的**，那么在其销毁时将会调用 `std::terminate`
    函数。一个线程被认为是可连接的，如果既没有调用 `join()` 方法，也没有调用 `detach()` 方法。在我们的例子中，所有的 `jthread`
    对象在销毁时会自动连接，并不会导致程序终止。'
- en: Canceling threads – is this really possible?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消线程——这真的可能吗？
- en: Before C++ 20 was released, this wasn’t quite possible. It was not guaranteed
    that `std::thread` was stoppable in the sense that there wasn’t a standard utility
    to halt the thread’s execution. Different mechanisms were used instead. Stopping
    `std::thread` required cooperation between the `main` and worker threads, typically
    using a flag or atomic variable or some kind of messaging system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 20 发布之前，这并不完全可能。不能保证 `std::thread` 是可停止的，因为没有一个标准的工具可以停止线程的执行。相反，使用了不同的机制。停止
    `std::thread` 需要主线程和工作线程之间的协作，通常使用标志或原子变量或某种消息系统。
- en: 'With the release of C++20, there is now a standardized utility for requesting
    `std::jthread` objects to stop their execution. The stop tokens come to help.
    Looking at the C++ standard reference page about the definition of `std::jthread`
    ([https://en.cppreference.com/w/cpp/thread/jthread](https://en.cppreference.com/w/cpp/thread/jthread)),
    we find the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++20 的发布，现在有一个标准化的工具可以请求 `std::jthread` 对象停止它们的执行。停止令牌出现了。查看关于 `std::jthread`
    定义的 C++ 标准参考页面（[https://en.cppreference.com/w/cpp/thread/jthread](https://en.cppreference.com/w/cpp/thread/jthread)），我们发现以下内容：
- en: “The class jthread represents a single thread of execution. It has the same
    general behavior as std::thread, except that jthread automatically rejoins on
    destruction, and can be canceled/stopped in certain situations.”
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: “`jthread` 类代表一个单独的执行线程。它具有与 `std::thread` 相同的一般行为，除了在销毁时会自动重新连接，并且在某些情况下可以被取消/停止。”
- en: We already saw that `jthread` objects automatically join on destruction, but
    what about canceling/stopping and what does “certain situations” mean? Let’s dig
    deeper into this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `jthread` 对象在销毁时会自动连接，但关于取消/停止以及“某些情况”是什么意思呢？让我们更深入地探讨这个问题。
- en: 'First of all, don’t expect that `std::jthread` exposes some magical mechanism,
    some red button that stops the running thread when it is pressed. It is always
    a matter of implementation, how exactly your worker function is implemented. If
    you want your thread to be cancelable, you have to make sure that you have implemented
    it in the right way in order to allow cancellation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不要期望 `std::jthread` 揭示某种神奇机制，某种按下时可以停止正在运行的线程的红色按钮。这始终是实现的问题，你的工作函数是如何实现的。如果你想使你的线程可取消，你必须确保你以正确的方式实现了它，以便允许取消：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Looking at the definition of our worker lambda function, we observe that it
    is now slightly reworked (marker `{1}`). It accepts two new parameters – `std::stop_token
    token` and `int num`. The stop token reflects the shared stop state that a `jthread`
    object has. If the worker method accepts many parameters, then the stop token
    must always be the first parameter passed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们之前的工作线程 lambda 函数的定义，我们可以看到它现在略有修改（标记 `{1}`）。它接受两个新的参数——`std::stop_token
    token` 和 `int num`。停止令牌反映了 `jthread` 对象共享的停止状态。如果工作方法接受许多参数，那么停止令牌必须始终是第一个传递的参数。
- en: It is imperative to ensure that the worker method is designed to be able to
    handle cancellation. This is what the stop token is used for. Our logic should
    be implemented in such a way that it regularly checks whether a stop request has
    been received. This is done with a call to the `stop_requested()` method of the
    `std::stop_token` object. Every specific implementation decides where and when
    these checks are to be done. If the code doesn’t respect the stop token state,
    then the thread can’t be canceled gracefully. So, it’s up to you to correctly
    design your code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保工作方法能够处理取消操作是至关重要的。这就是停止令牌的作用所在。我们的逻辑应该以这种方式实现，以便定期检查是否收到了停止请求。这是通过调用 `std::stop_token`
    对象的 `stop_requested()` 方法来完成的。每个具体的实现都决定在哪里以及何时进行这些检查。如果代码不尊重停止令牌的状态，那么线程就不能优雅地取消。因此，正确设计你的代码取决于你。
- en: Luckily, our worker lambda respects the state of the thread’s stop token. It
    continuously checks whether a stop is requested (marker `{2}`). If not, it prints
    the thread’s ID and goes to sleep for `200ms`. This loop continues until the parent
    thread decides to send stop requests to its worker threads (marker `{3}`). This
    is done by invoking the `request_stop()` method of the `std::jthread` object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的工作线程 lambda 尊重线程停止令牌的状态。它持续检查是否收到停止请求（标记 `{2}`）。如果没有，它将打印线程的 ID 并进入休眠状态
    `200ms`。这个循环会一直持续到父线程决定向其工作线程发送停止请求（标记 `{3}`）。这是通过调用 `std::jthread` 对象的 `request_stop()`
    方法来完成的。
- en: 'Here is the output of the program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we know how we can stop the execution of a specific `std::jthread`
    using `std::stop_token`, let’s see how we can stop the execution of multiple `std::jthread`
    objects using a single stop source.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何使用 `std::stop_token` 来停止特定 `std::jthread` 的执行，那么让我们看看如何使用单个停止源来停止多个
    `std::jthread` 对象的执行。
- en: std::stop_source
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::stop_source`'
- en: The `std::stop_source` class enables you to signal a cancellation request for
    `std::jthread`. When a stop request is issued through a `stop_source` object,
    it becomes visible to all other `stop_source` and `std::stop_token` objects associated
    with the same stop state. You just need to signal it, and any thread worker that
    consumes it will be notified.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stop_source` 类允许你为 `std::jthread` 发出取消请求。当通过 `stop_source` 对象发出停止请求时，它对所有与相同停止状态关联的其他
    `stop_source` 和 `std::stop_token` 对象都是可见的。你只需要发出信号，任何消费它的线程工作器都会收到通知。'
- en: By utilizing `std::stop_token` and `std::stop_source`, threads can signal or
    check for a request to stop their execution asynchronously. The request to stop
    is made through `std::stop_source`, which affects all related `std::stop_token`
    objects. These tokens can be passed to the worker functions and used to monitor
    stop requests. Both `std::stop_source` and `std::stop_token` share ownership of
    the stop state. The method of the `std::stop_source` class – `request_stop()`
    – and the methods in `std::stop_token` – `stop_requested()` and `stop_possible()`
    – are all atomic operations to ensure that no data race will occur.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `std::stop_token` 和 `std::stop_source`，线程可以异步地发出或检查停止执行请求。停止请求是通过 `std::stop_source`
    来发出的，它影响所有相关的 `std::stop_token` 对象。这些令牌可以被传递给工作函数并用于监控停止请求。`std::stop_source`
    和 `std::stop_token` 都共享停止状态的所有权。`std::stop_source` 类的方法 `request_stop()` 以及 `std::stop_token`
    中的方法 `stop_requested()` 和 `stop_possible()` 都是原子操作，以确保不会发生数据竞争。
- en: 'Let’s have a look at how our previous example could be reworked with the help
    of the stop tokens:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用停止令牌来重新设计我们之前的示例：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `main` method starts with the declaration of the `std::stop_source` source,
    which will be used by the `main` thread to signal all child worker threads and
    request them to stop. The worker lambda is slightly reworked in order to accept
    `std::stop_source sr` as an input. This is in fact the communication channel through
    which the worker is notified for a stop request. The `std::stop_source` object
    is copied in all workers associated with the started threads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法从声明 `std::stop_source` 源开始，它将被 `main` 线程用来向所有子工作者线程发出信号并请求它们停止。工作者
    lambda 被稍微修改，以便接受 `std::stop_source sr` 作为输入。这实际上是工作者被通知停止请求的通信通道。`std::stop_source`
    对象被复制到所有与已启动线程相关的工作者中。'
- en: Rather than iterating through all the threads and invoking on each of them a
    stop request, the only operation that we need to invoke is to directly call `request_stop()`
    on the source instance in the `main` thread (marker `{1}`). This will broadcast
    stop requests to all workers that consume it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是遍历所有线程并对每个线程调用停止请求，我们需要的唯一操作是在 `main` 线程的源实例上直接调用 `request_stop()`（标记 `{1}`）。这将向所有消费它的工作者广播停止请求。
- en: As the name suggests, the call to the `request_stop()` method on the stop source
    object is just a request rather than a blocking call. So, don’t expect your threads
    to stop immediately once the call is finished.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在停止源对象上调用 `request_stop()` 方法只是一个请求，而不是阻塞调用。因此，不要期望你的线程在调用完成后立即停止。
- en: 'Here is the sample output from the program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的示例输出：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are now familiar with two mechanisms for halting thread execution in C++.
    Now, it’s time to see how we can share data between multiple threads.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了在 C++ 中停止线程执行的两种机制。现在是时候看看我们如何能够在多个线程之间共享数据了。
- en: Sharing data during parallel execution
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行期间的数据共享
- en: '*Think in terms of tasks rather than* *threads* ([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp4-think-in-terms-of-tasks-rather-than-threads](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp4-think-in-terms-of-tasks-rather-than-threads)).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*以任务而非线程为思考方式* ([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp4-think-in-terms-of-tasks-rather-than-threads](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp4-think-in-terms-of-tasks-rather-than-threads))。'
- en: Referring back to the *C++ Core Guidelines*, they advise us that it is better
    to stick to tasks rather than threads. A thread is a technical implementation
    idea, a perspective on how the machine works. On the other hand, a task is a practical
    concept for work that you want to do, ideally alongside other tasks. In general,
    practical concepts are simpler to understand and provide better abstraction, and
    we prefer them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾到 *C++ 核心指南*，它们建议我们最好坚持使用任务而不是线程。线程是一种技术实现理念，是对机器工作方式的一种看法。另一方面，任务是你想要执行的工作的实用概念，理想情况下与其他任务并行。一般来说，实用概念更容易理解，并且提供更好的抽象，我们更倾向于使用它们。
- en: But what is a task in C++? Is it another standard library primitive or what?
    Let’s have a look!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 C++ 中，任务是什么？它是另一个标准库原语吗？还是其他什么？让我们看看！
- en: 'In C++, besides threads, tasks are also available to perform work asynchronously.
    A task consists of a worker and two associated components: a **promise** and a
    **future**. These components are connected through a shared state, which is a
    kind of data channel. The promise does the work and places the result in the shared
    state, while the future retrieves the result. Both the promise and the future
    can run in separate threads. One unique aspect of the future is that it can retrieve
    the result at a later time, making the calculation of the result by the promise
    independent from the retrieval of the result by the associated future.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，除了线程，还可以使用任务来异步执行工作。一个任务由一个工作器和两个相关组件组成：一个 **promise** 和一个 **future**。这些组件通过共享状态连接，这是一种数据通道。promise
    执行工作并将结果放入共享状态，而 future 获取结果。promise 和 future 都可以在单独的线程中运行。future 的一个独特之处在于它可以在稍后时间检索结果，使得
    promise 计算结果与相关 future 检索结果的操作独立。
- en: '![Figure 6.4 – Inter-thread communication](img/Figure_6.04_B20833.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 线程间通信](img/Figure_6.04_B20833.jpg)'
- en: Figure 6.4 – Inter-thread communication
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 线程间通信
- en: The `<future>` header, defined in the Standard Library, is necessary for utilizing
    tasks. It provides the capability to obtain the results of functions executed
    in separate threads, also referred to as `std::promise` class, these results are
    communicated through a shared state, where the asynchronous task can store its
    return value or an exception. This shared state can then be accessed using `std::future`
    to retrieve the return value or the stored exception.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中定义的`<future>`头文件对于利用任务来说是必要的。它提供了获取在单独线程中执行的功能的结果的能力，也称为`std::promise`类，这些结果通过共享状态进行通信，异步任务可以在其中存储其返回值或异常。然后可以使用`std::future`访问这个共享状态以检索返回值或存储的异常。
- en: 'Let’s have a look at a simple example where a thread reports a string as a
    result to its parent thread:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，其中线程将其结果作为字符串报告给父线程：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we already discussed, threads communicate with each other using a shared
    state. In the `int main()` method, we declare `std::promise<std::string> promise`,
    which is our de facto data source (marker `{1}`). The `std::promise` class is
    a template class that needs to be parameterized once it is instantiated. In our
    example, we want our worker thread, `std::thread th1`, to return a string as a
    result. Therefore, we instantiate `std::promise` with the `std::string` type.
    We also need a way for the `main` thread to be able to get the result that will
    be set by the worker thread. In order to do so, we need to get a `std::future`
    object from the promise we already instantiated. This is possible because the
    `std::promise` type has a method that returns its associated future – `std::future<...>
    get_future()`. In our example, we instantiate a future object, `future`, which
    is initialized by the `get_future()` method of the promise (marker `{2}`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，线程通过共享状态相互通信。在`int main()`方法中，我们声明`std::promise<std::string> promise`，这是我们事实上的数据源（标记
    `{1}`）。`std::promise`类是一个模板类，一旦实例化就需要进行参数化。在我们的例子中，我们希望工作线程`std::thread th1`返回一个字符串作为结果。因此，我们使用`std::string`类型实例化`std::promise`。我们还需要一种方式让`main`线程能够获取工作线程将要设置的结果。为了做到这一点，我们需要从已经实例化的承诺中获取一个`std::future`对象。这是可能的，因为`std::promise`类型有一个返回其相关未来的方法——`std::future<...>
    get_future()`。在我们的例子中，我们实例化了一个未来对象`future`，它通过承诺的`get_future()`方法初始化（标记 `{2}`）。
- en: Since we already have a promise and its associated future, we are now ready
    to move the promise as part of the worker thread. We are moving it in order to
    be sure that it won’t be used by the `main` thread anymore (marker `{3}`). Our
    worker thread is quite simple, and it just sleeps for `20ms` and sets the result
    in the promise (marker `{4}`). The `std::promise` type provides several ways to
    set a result. The result could be either a value of type by which the promise
    is parameterized or it could be an exception thrown during worker execution. The
    value is set by the `set_value()` and `set_value_at_thread_exit()`methods. The
    main difference between both methods is that `set_value()` immediately notifies
    the shared state that the value is ready, whereas `set_value_at_thread_exit()`
    does it when the thread execution is finished.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有一个承诺及其相关的未来，我们现在可以准备将承诺作为工作线程的一部分进行移动。我们这样做是为了确保它不会被`main`线程再使用（标记 `{3}`）。我们的工作线程相当简单，它只是休眠`20ms`并在承诺中设置结果（标记
    `{4}`）。`std::promise`类型提供了几种设置结果的方法。结果可以是承诺参数化的类型值，也可以是工作执行期间抛出的异常。值是通过`set_value()`和`set_value_at_thread_exit()`方法设置的。这两种方法之间的主要区别在于，`set_value()`立即通知共享状态值已准备好，而`set_value_at_thread_exit()`则在线程执行完成后这样做。
- en: Meanwhile, the `main` thread execution has been blocked waiting for the result
    of the worker thread. This is done on the call to the `future.get()` method. This
    is a blocking call on which the waiting thread is blocked until the shared state
    is notified that the result of the future is set. In our example, this happens
    after the completion of the worker thread because the shared state is only notified
    when the worker is finished (marker `{5}`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`main`线程的执行被阻塞，等待工作线程的结果。这是在调用`future.get()`方法时完成的。这是一个阻塞调用，等待线程在共享状态通知未来结果已设置之前被阻塞。在我们的例子中，这发生在工作线程完成后，因为只有当工作完成时共享状态才会被通知（标记
    `{5}`）。
- en: 'The expected output from the program is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的预期输出如下：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Barriers and latches
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍和锁
- en: New thread synchronization primitives were introduced with the C++20 standard.
    Barriers and latches are straightforward thread synchronization primitives that
    block threads to wait until a counter reaches zero. These primitives are offered
    by the standard library in the form of the `std::latch` and `std::barrier` classes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准引入了新的线程同步原语。屏障和 latch 是简单的线程同步原语，它们会阻塞线程，直到计数器达到零。这些原语以 `std::latch`
    和 `std::barrier` 类的形式由标准库提供。
- en: What distinguishes these two synchronization mechanisms? The key difference
    is that `std::latch` can only be used once, while `std::barrier` can be used multiple
    times by multiple threads.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种同步机制有什么区别？关键区别是 `std::latch` 只能使用一次，而 `std::barrier` 可以被多个线程多次使用。
- en: What advantages do barriers and latches offer over other synchronization primitives
    that the C++ standard provides, such as condition variables and locks? Barriers
    and latches are easier to use, more intuitive, and, in some circumstances, may
    provide better performance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障和 latch 相比 C++ 标准提供的其他同步原语（如条件变量和锁）有什么优势？屏障和 latch 更容易使用，更直观，在某些情况下可能提供更好的性能。
- en: 'Let’s have a look at the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have an array of two threads that are synchronized on a latch. This means
    that each thread starts its execution and does its work until it reaches the latch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个线程的数组，它们在 latch 上同步。这意味着每个线程开始执行并完成其工作，直到达到 latch。
- en: The `std::latch` class is a synchronization mechanism that utilizes a downward-counting
    counter to coordinate threads. The counter is set at initialization and passed
    as an argument to the constructor. The threads can then wait until the counter
    reaches zero. It is not possible to increase or reset the counter once it is initialized.
    Access to the member functions of `std::latch` from multiple threads concurrently
    is guaranteed to be thread-safe and free from data races.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::latch` 类是一种同步机制，它使用向下计数的计数器来协调线程。计数器在初始化时设置，并作为参数传递给构造函数。然后线程可以等待直到计数器达到零。一旦初始化，计数器就不能增加或重置。从多个线程并发访问
    `std::latch` 的成员函数保证是线程安全的，并且没有数据竞争。'
- en: 'In our example (marker `{1}`), we have initialized the latch with a value of
    `2` because we have two worker threads that need to be synchronized with the main
    one. Once the worker reaches the latch, it has three options:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子（标记 `{1}`）中，我们使用 `2` 的值初始化了 latch，因为我们有两个工作线程需要与主线程同步。一旦工作线程达到 latch，它有三个选择：
- en: Decrement it and continue (marker `{2}`). This is done using the member of the
    `std::latch` class – `void count_down(n = 1)`. This call is non-blocking and automatically
    decrements the latch’s internal counter value by `n`. It is undefined behavior
    if you try to decrement with a negative value or with a value greater than the
    value that the internal counter currently has. In our example, this is a worker
    thread with an ID of `0`, which, once it is ready, decrements the latch counter
    and finishes.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少它并继续（标记 `{2}`）。这是通过 `std::latch` 类的成员函数 – `void count_down(n = 1)` 来实现的。这个调用是非阻塞的，并自动将
    latch 的内部计数器值减去 `n`。如果尝试使用负值或大于内部计数器当前值的值来减少，则行为是未定义的。在我们的例子中，这是一个 ID 为 `0` 的工作线程，一旦它准备好，就会减少
    latch 计数器并完成。
- en: Decrement it and wait until the latch becomes zero (marker `{3}`). In order
    to do so, you have to use another method of the `std::latch` class – `void arrive_and_wait(n
    = 1)`. This method, once it is invoked, decrements the latch by `n` and blocks
    it until the latch’s internal counter hits `0`. In our example, this is a worker
    thread with an ID of `1`, which, once it is ready, starts waiting until the other
    worker is finished.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少它并等待直到 latch 变为零（标记 `{3}`）。为了做到这一点，你必须使用 `std::latch` 类的另一个方法 – `void arrive_and_wait(n
    = 1)`。这个方法一旦被调用，就会减少 latch 的值 `n` 并阻塞它，直到 latch 的内部计数器达到 `0`。在我们的例子中，这是一个 ID 为
    `1` 的工作线程，一旦它准备好，就会开始等待，直到另一个工作线程完成。
- en: Just block and wait until the internal counter of the latch becomes zero (marker
    `{4}`). This is possible because `std::latch` provides a method – `void wait()
    const`. This is a blocking call on which the invoking thread is blocked until
    the internal counter of the latch hits zero. In our example, the `main` thread
    blocks and starts waiting for the worker threads to finish their execution.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需阻塞并等待闩锁的内部计数器变为零（标记 `{4}`）。这是可能的，因为 `std::latch` 提供了一个方法——`void wait() const`。这是一个阻塞调用，调用线程会在闩锁的内部计数器达到零之前被阻塞。在我们的例子中，`main`
    线程会阻塞并开始等待工作线程完成它们的执行。
- en: 'The result of our program is that the `main` thread execution is suspended
    until the worker threads finish their jobs. The `std::latch` class provides a
    convenient way to synchronize the execution of several threads:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的结果是 `main` 线程的执行被挂起，直到工作线程完成它们的任务。`std::latch` 类提供了一个方便的方式来同步多个线程的执行：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another very similar synchronization primitive to `std::latch` is `std::barrier`.
    Barriers are thread synchronization primitives that permit a group of threads
    to wait until all of them reach a specific synchronization point. Unlike a latch,
    a barrier can be used multiple times. Once the threads have been released from
    the synchronization point, they can reuse the barrier. A synchronization point
    is a specific moment where a thread can pause its execution until a specific condition
    has been met. This makes barriers ideal for synchronizing repeated tasks or executing
    different phases from the same bigger task by many threads.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::latch` 非常相似的同步原语是 `std::barrier`。屏障是线程同步原语，允许一组线程等待直到它们都达到一个特定的同步点。与闩锁不同，屏障可以被多次使用。一旦线程从同步点释放，它们可以重用屏障。同步点是一个特定时刻，线程可以暂停其执行，直到满足特定条件。这使得屏障非常适合同步重复任务或由多个线程执行同一更大任务的不同阶段。
- en: In order to get a better understanding of what barriers are, let’s use an example.
    Imagine that you have a network of temperature sensors installed in your home.
    In each room, there is a sensor installed. Each sensor takes a temperature measurement
    at a specific time period and the result is buffered in its memory. When the sensor
    does 10 measurements, it sends them as a chunk to a server. This server is responsible
    for collecting all measurements from all sensors in your home and calculating
    temperature mean values – the mean temperature for each room and the mean temperature
    for your entire home.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解什么是屏障，让我们用一个例子来说明。想象一下，你在家里安装了一个温度传感器的网络。在每一个房间中，都安装了一个传感器。每个传感器在特定的时间段内进行温度测量，并将结果缓冲在其内存中。当传感器完成10次测量后，它会将它们作为一个数据块发送到服务器。这个服务器负责收集家中所有传感器的所有测量数据，并计算温度平均值——每个房间的平均温度和整个家的平均温度。
- en: Let’s discuss the algorithm now. In order to calculate the mean temperature
    of your entire home, we first need to process the temperature measurements done
    by the sensors that are sent to the server at some specific time period. This
    means that we need to process all the temperature samples received for a specific
    room to calculate the mean temperature for that room, and we need to do this for
    all the rooms in your home. Finally, with the calculated mean temperatures for
    each room, we can calculate the mean temperature for the entire home.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下算法。为了计算你整个家的平均温度，我们首先需要处理传感器在某个特定时间段发送到服务器的温度测量数据。这意味着我们需要处理接收到的特定房间的所有温度样本，以计算该房间的平均温度，并且我们需要为家中的所有房间都这样做。最后，有了每个房间的计算出的平均温度，我们可以计算整个家的平均温度。
- en: 'It sounds like we need to process a lot of data. It makes sense to try to parallelize
    the data processing wherever possible. Yes, you are right: not all of the data
    processing can be parallelized! There is a strict sequence of actions we need
    to respect. Firstly, we need to calculate the mean temperature in each room. There
    are no dependencies between the rooms, so we can execute these calculations in
    parallel. Once we have all the room temperatures calculated, we can continue to
    the calculation of the mean temperature of the entire home. This is exactly where
    `std::barrier` will come to the rescue.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来我们需要处理大量的数据。尽可能地在数据处理中尝试并行化是有意义的。是的，你说得对：并非所有的数据处理都可以并行化！我们需要遵守一系列严格的行为顺序。首先，我们需要计算每个房间的平均温度。房间之间没有依赖关系，因此我们可以并行执行这些计算。一旦我们计算出所有房间的温度，我们就可以继续计算整个家的平均温度。这正是
    `std::barrier` 会提供帮助的地方。
- en: 'The `std::barrier` synchronization primitive blocks the threads at a specific
    synchronization point (the barrier) until all of them arrive. Then, it allows
    a callback to be invoked and a specific action to be performed. In our example,
    we need to wait for all room calculations to be finished – to wait on the barrier.
    Then, a callback will be executed where we will calculate the mean temperature
    for the entire home:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::barrier` 同步原语在特定的同步点（屏障）阻塞线程，直到所有线程到达。然后，它允许调用回调并执行特定操作。在我们的例子中，我们需要等待所有房间计算完成——等待在屏障上。然后，将执行回调，我们将计算整个家庭的平均温度：'
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s start with the definition of our data container where we will store the
    temperature measurements done for each room, together with their calculated mean
    values by our worker threads. We will use a vector of rooms, `room_temperature`,
    in which we will store the room name, a vector of measurements, and the mean value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的数据容器开始，我们将在此容器中存储每个房间进行的温度测量，以及工作线程计算出的平均值。我们将使用一个房间温度向量 `room_temperature`，在其中我们将存储房间名称、测量值向量以及平均值。
- en: 'Now, we need to define the workers that will, in parallel, calculate the mean
    values for each room:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义将并行计算每个房间平均值的工人：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We create the same count of `jthread` instances as the count of the rooms. Each
    `jthread` instance is created and a worker lambda is assigned to it. As you can
    see, the worker lambda captures a `std::stop_source` object, which will be used
    to notify it that no other work is pending and the thread execution should be
    finished. The lambda also captures `std::barrier measurementBarrier`, which will
    be used to block each thread that is ready with its computation until all other
    threads are also ready (marker `{1}`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了与房间数量相同的 `jthread` 实例。每个 `jthread` 实例被创建，并分配了一个工作 lambda。正如你所看到的，工作 lambda
    捕获了一个 `std::stop_source` 对象，该对象将用于通知它没有其他工作待处理，线程执行应该完成。lambda 还捕获了 `std::barrier
    measurementBarrier`，它将被用于阻塞每个已经准备好其计算的线程，直到所有其他线程也准备好（标记 `{1}`）。
- en: 'The `std::barrier` instance needs to be initialized with the count of the synchronization
    points (marker `{2}`). This means that the barrier will be raised when the count
    of threads reaching the barrier is equal to the initialized value. In our example,
    we initialize the barrier with the count of the worker threads that will concurrently
    compute the mean temperatures for each room. An optional initialization parameter
    that the barrier accepts is a callback function (marker `{3}`). This function
    must not throw and, therefore, we mark it as `noexcept`. It will be invoked when
    all threads in a certain cycle arrive at the barrier and before the barrier is
    raised. Keep in mind that the standard doesn’t specify which thread this callback
    will be executed on. We will use this callback to do the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::barrier` 实例需要使用同步点的数量（标记 `{2}`）进行初始化。这意味着当达到屏障的线程数量等于初始化值时，屏障将被提升。在我们的例子中，我们使用将要并发计算每个房间平均温度的工作线程数量来初始化屏障。屏障可以接受一个可选的初始化参数，即回调函数（标记
    `{3}`）。此函数不得抛出异常，因此我们将其标记为 `noexcept`。它将在所有线程到达屏障并提升屏障之前被调用。请注意，标准并未指定哪个线程将执行此回调。我们将使用此回调来完成以下操作：'
- en: Iterate through all already computed mean temperatures for the rooms and compute
    the mean temperature of the entire home. This is the result we expect our program
    to deliver.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历所有已计算房间的平均温度，并计算整个家庭的平均温度。这是我们期望程序提供的结果。
- en: Feed the worker threads with new temperature data for the next computation cycle.
    In contrast to `std::latch`, `std::barrier` allows us to use the same barrier
    as many times as we need.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为工人线程提供下一次计算周期的新温度数据。与 `std::latch` 不同，`std::barrier` 允许我们根据需要多次使用同一个屏障。
- en: Check whether we have already calculated five times the mean temperature of
    the entire home and, if so, notify the workers that they need to gracefully stop
    and exit the program.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们是否已经计算了整个家庭平均温度的五次，如果是这样，则通知工人他们需要优雅地停止并退出程序。
- en: 'When a thread starts working and it is ready with its computation, it hits
    the barrier (marker `{4}`). This is possible because `std::barrier` exposes a
    method: `void arrive_and_wait()`. This call effectively decrements the internal
    counter of the barrier, which notifies it that the thread has arrived and blocks
    the thread until the counter hits zero and the barrier’s callback is triggered.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程开始工作并且它准备好进行计算时，它会遇到屏障（标记 `{4}`）。这是可能的，因为 `std::barrier` 提供了一个方法：`void
    arrive_and_wait()`。这个调用实际上减少了屏障的内部计数器，通知它线程已经到达，并阻塞线程，直到计数器达到零并且触发屏障的回调。
- en: 'In the following code, you can find the methods responsible for generating
    example temperature values and calculating the mean temperature value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你可以找到负责生成示例温度值和计算平均温度值的函数：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we have all the code pieces available, let’s see the `main` method implementation
    of our program:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有代码片段，让我们看看我们程序的 `main` 方法实现：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the input temperature data of our example, we use a random number generator,
    which produces data with normal distribution. As a result, we get the following
    output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们示例中的输入温度数据，我们使用随机数生成器，它产生具有正态分布的数据。因此，我们得到以下输出：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the preceding example, we have demonstrated how you can use synchronization
    primitives with `std::jthread` to provide inter-thread synchronization for your
    program.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们展示了如何使用同步原语与 `std::jthread` 提供程序中的线程间同步。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored several topics related to concurrency and parallelism
    in C++. We began by discussing the terminology and differences between concurrency
    and parallelism, including preemption. We then delved into how programs execute
    on single and multiple processing units, distinguishing between processes and
    execution threads and briefly exploring communication mechanisms such as pipes,
    sockets, and shared memory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与 C++ 中并发和并行相关的多个主题。我们首先讨论了术语和并发与并行之间的区别，包括抢占。然后，我们深入探讨了程序如何在单个和多个处理单元上执行，区分了进程和执行线程，并简要探讨了管道、套接字和共享内存等通信机制。
- en: In the context of C++, we examined how the language supports concurrency, specifically
    through the `std::thread` class and the new `std::jthread` primitive introduced
    in C++20\. We also discussed the risks associated with race conditions and data
    races, including an example of a money transfer operation. To avoid these issues,
    we examined mechanisms such as locks, atomic operations, and memory barriers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 的背景下，我们考察了语言如何支持并发，特别是通过 `std::thread` 类和 C++20 中引入的新 `std::jthread` 原语。我们还讨论了与竞争条件和数据竞争相关的风险，包括一个货币转账操作的示例。为了避免这些问题，我们考察了诸如锁、原子操作和内存屏障等机制。
- en: Moving on, we looked closely at the `std::jthread` class, exploring its functionality
    and proper usage. Additionally, we learned about a new synchronized stream wrapper
    delivered in C++20 for printing in concurrent environments. We also covered how
    to cancel running threads using `std::stop_token` and how to request a stop to
    several threads using `std::stop_source`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们仔细研究了 `std::jthread` 类，探讨了其功能和正确用法。此外，我们还了解了 C++20 中引入的新同步流包装器，用于并发环境中的打印。我们还介绍了如何使用
    `std::stop_token` 取消正在运行的线程，以及如何使用 `std::stop_source` 请求多个线程停止。
- en: We then shifted our focus to returning results from threads using `std::future`
    and `std::promise`. Additionally, we discussed the use of `std::latch` and `std::barrier`,
    using an example of a temperature station to demonstrate how the latter can be
    used to synchronize threads.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重点转向使用 `std::future` 和 `std::promise` 从线程返回结果。此外，我们还讨论了 `std::latch` 和
    `std::barrier` 的使用，通过温度站的示例演示了后者如何用于同步线程。
- en: Overall, we explored a range of topics related to concurrency and parallelism
    in C++, from basic terminology and concepts to more advanced techniques and mechanisms
    for avoiding data races and synchronizing threads. But please stay tuned because,
    in the next chapter, you will get familiar with some mechanisms for IPC that are
    widely used in software programming.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们探讨了与 C++ 中并发和并行相关的多个主题，从基本术语和概念到更高级的技术和机制，用于避免数据竞争和同步线程。但请保持关注，因为在下一章中，你将熟悉一些在软件编程中广泛使用的
    IPC 机制。
