- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Creating Better Test Confirmations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更好的测试确认
- en: This chapter introduces *Part 3*, where we extend the TDD library to support
    the growing needs of the logging library. *Part 1*, *Testing MVP*, of this book
    developed a basic unit test library, and *Part 2*, *Logging Library*, started
    to use the unit test library to build a logging library. Now we are following
    TDD, which encourages enhancing something once the basic tests are working.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*第三部分*，其中我们将TDD库扩展以支持日志库不断增长的需求。本书的*第一部分*，*测试MVP*，开发了一个基本的单元测试库，*第二部分*，*日志库*，开始使用单元测试库构建日志库。现在，我们正在遵循TDD，它鼓励在基本测试运行良好后进行增强。
- en: Well, we managed to get a basic unit test library working and proved its worth
    by building a logging library. In a way, the logging library is like systems tests
    for the unit test library. Now it’s time to enhance the unit test library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们成功使基本的单元测试库运行起来，并通过构建日志库证明了其价值。从某种意义上说，日志库就像是单元测试库的系统测试。现在，是时候增强单元测试库了。
- en: This chapter adds a completely new type of confirmation to the unit test library.
    First, we’ll look at the existing confirmations to understand how they can be
    improved and what the new solution will look like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向单元测试库添加了一种全新的确认类型。首先，我们将查看现有的确认，以了解它们如何改进以及新解决方案将是什么样子。
- en: The new confirmations will be more intuitive, more flexible, and extensible.
    And remember to pay attention not only to the code being developed in this chapter
    but also to the process. That’s because we’ll be using TDD throughout to write
    some tests, starting with a simple solution and then enhancing the tests to create
    an even better solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 新的确认将更加直观、灵活和可扩展。并且请记住，不仅要关注本章开发的代码，还要关注过程。这是因为我们将使用TDD来编写一些测试，从简单的解决方案开始，然后增强测试以创建更好的解决方案。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: The problem with the current confirmations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前确认存在的问题
- en: How to simplify string confirmations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何简化字符串确认
- en: Enhancing the unit test library to support Hamcrest-style confirmations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强单元测试库以支持Hamcrest风格的确认
- en: Adding more Hamcrest matcher types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多Hamcrest匹配器类型
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 20
    or later compiler and standard library. The code is based on and continues enhancing
    the testing library from *Part 1*, *Testing MVP*, of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用标准C++，它基于任何现代C++ 20或更高版本的编译器和标准库。代码基于并继续增强本书第一部分*测试MVP*中的测试库。
- en: 'You can find all the code for this chapter in the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到本章所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: The problem with the current confirmations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前确认存在的问题
- en: 'Before we begin making changes, we should have some idea of why. TDD is all
    about the customer experience. How can we design something that is easy and intuitive
    to use? Let’s start by taking a look at a couple of existing tests:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行更改之前，我们应该对为什么要这样做有一个想法。TDD完全是关于客户体验的。我们如何设计出易于使用且直观的东西？让我们先看看几个现有的测试：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These tests have served well and are easy, right? What we’re looking at here
    is not the tests themselves but the confirmations. This style of confirmation
    is called the *classic style*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试已经很好地服务了，而且很简单，对吧？我们在这里关注的不光是测试本身，而是确认。这种确认风格被称为*经典风格*。
- en: 'How would we speak or read aloud the first confirmation? It might go like this:
    “*Confirm the expected value of abc matches the value* *of result*.”'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何大声说出第一个确认？可能如下所示：“*确认abc的预期值与结果值匹配*。”
- en: 'That’s not too bad, but it’s a bit awkward. That’s not how a person would normally
    talk. Without looking at any code, a more natural way to say the same thing would
    be: “*Confirm that result* *equals abc*.”'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不错，但有点尴尬。这不是人们通常说话的方式。不查看任何代码，表达相同内容的一种更自然的方式是：“*确认结果等于abc*。”
- en: At first glance, maybe all we need to do is reverse the order of the parameters
    and put the actual value first followed by the expected value. But there’s a piece
    missing. How do we know that a confirmation is checking for equality? We know
    because that’s the only thing the existing `confirm` functions know how to check.
    Also, that means the `CONFIRM` macro only knows how to check for equality, too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，我们可能只需要颠倒参数的顺序，将实际值放在预期值之前。但这里缺少了一个部分。我们如何知道一个确认是在检查相等性呢？我们知道，因为现有的`confirm`函数只会检查这一项。这也意味着`CONFIRM`宏也只知道如何检查相等性。
- en: We have a better solution for bool values because we created special `CONFIRM_TRUE`
    and `CONFIRM_FALSE` macros that are easy to use and understand. And because the
    bool versions only take a single parameter, there’s no question of expected versus
    actual ordering.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔值，我们有一个更好的解决方案，因为我们创建了特殊的`CONFIRM_TRUE`和`CONFIRM_FALSE`宏，它们易于使用和理解。而且因为布尔版本只接受一个参数，所以不存在预期值与实际值顺序的问题。
- en: 'There’s a better solution that aligns with the more natural way we would speak
    about a confirmation. The better solution uses something called matchers and is
    referred to as the *Hamcrest style*. The name “Hamcrest” is just a reordering
    of the letters in the word “matchers.” Here is what a test would look like written
    in the Hamcrest style:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更好的解决方案，与更自然的确认方式相一致。这个更好的解决方案使用了一种称为匹配器的东西，被称为*Hamcrest风格*。名字“Hamcrest”只是将“matchers”这个词的字母顺序重新排列。以下是一个用Hamcrest风格编写的测试示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’re not really designing the Hamcrest style in this book. The style already
    exists and is common in other testing libraries. And the main reason the testing
    library in this book puts the expected value first followed by the actual value
    for the classical style is to follow the common practice of the classical style.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中并不是真正设计Hamcrest风格的。这种风格已经存在，并且在其他测试库中很常见。本书中测试库将预期值放在实际值之前，遵循经典风格的常见做法。
- en: Imagine you were to reinvent a better light switch. And I’ve been in buildings
    that have tried. The light switch might actually be better in some way. But if
    it doesn’t follow normal expectations, then people will get confused.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你要重新发明一个更好的灯开关。我曾在一些尝试过的建筑中待过。灯开关在某些方面可能实际上更好。但如果它不符合正常的预期，那么人们会感到困惑。
- en: The same is true of the classical confirmations we started with in this book.
    I could have designed the confirmations to put the actual value first and maybe
    that would be better. But it would be unexpected for anybody who is even a little
    familiar with the existing testing libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书开始时我们使用的经典确认也是如此。我本可以将确认设计成将实际值放在前面，也许那样会更好。但对于任何对现有测试库稍有了解的人来说，这将是出乎意料的。
- en: This brings up a great point to consider when creating designs using TDD. Sometimes,
    an inferior solution is better when that’s what the customer expects. Remember
    that whatever we design should be easy and intuitive to use. The goal is not to
    make the ultimate and most modern design but to make something that the user will
    be happy with.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这在创建TDD设计时提出了一个值得考虑的要点。有时，当客户期望的是次优解决方案时，次优解决方案反而更好。记住，我们设计的任何东西都应该易于使用且直观。目标不是创造终极和最现代的设计，而是创造用户会满意的东西。
- en: This is why Hamcrest matchers work. The design doesn’t just switch the order
    of the expected and actual values because switching the order by itself would
    only confuse users.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Hamcrest匹配器可以工作。设计并不是仅仅交换预期值和实际值的顺序，因为仅仅交换顺序本身只会让用户感到困惑。
- en: 'Hamcrest works well because something else was added: the matcher. Notice the
    `Equals(10)` part of the confirmation. `Equals` is a matcher that makes it clear
    what the confirmation is doing. The matcher, together with a more intuitive ordering,
    gives a solution enough benefits to overcome the natural reluctance people have
    with switching to a new way of doing things. The Hamcrest style is not just a
    better light switch. Hamcrest is different enough and provides enough value that
    it avoids the confusion of a slightly better but different solution.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Hamcrest工作得很好，因为还增加了一些其他东西：匹配器。注意确认中的`Equals(10)`部分。`Equals`是一个匹配器，它清楚地说明了确认正在做什么。匹配器与更直观的顺序结合，为解决方案提供了足够的优势，以克服人们转向新做事方式的自然抵触。Hamcrest风格不仅仅是一个更好的灯开关。Hamcrest足够不同，提供了足够的价值，避免了稍微好一些但不同的解决方案的困惑。
- en: Also, notice that the name of the macro has changed from `CONFIRM` to `CONFIRM_THAT`.
    The name change is another way to avoid confusion and lets users continue to use
    the older classical style or opt for the newer Hamcrest style.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，宏的名称已从 `CONFIRM` 更改为 `CONFIRM_THAT`。名称更改是避免混淆的另一种方式，并允许用户继续使用较老的经典风格或选择较新的
    Hamcrest 风格。
- en: Now that we have a place to specify something such as `Equals`, we can also
    use different matchers such as `GreaterThan` or `BeginsWith`. Imagine that you
    wanted to confirm that some text begins with some expected characters. How would
    you write a test like that using classical confirmations? You would have to check
    for the beginning text outside of the confirmation and then confirm the result
    of the check. With the Hamcrest style and an appropriate matcher, you can confirm
    the text with a single-line confirmation. And you get the benefit of a more readable
    confirmation that makes it clear what is being confirmed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个地方可以指定像 `Equals` 这样的东西，我们也可以使用不同的匹配器，比如 `GreaterThan` 或 `BeginsWith`。想象一下，如果你想要确认某些文本以某些预期的字符开始，你会如何编写这样的测试？你必须在确认之外检查开始文本，然后确认检查的结果。使用
    Hamcrest 风格和适当的匹配器，你可以用单行确认来确认文本。而且你得到了一个更易于阅读的确认，这清楚地表明了正在确认的内容。
- en: What if you can’t find a matcher that fits your needs? You can always write
    your own to do exactly what you need. So, Hamcrest is extensible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到符合您需求的匹配器，您总是可以编写自己的来做到您需要的精确程度。因此，Hamcrest 是可扩展的。
- en: Before diving into the new Hamcrest design, the next section will take a slight
    detour to explain an improvement to the existing classic `confirm` template function.
    This improvement will be used in the Hamcrest design, so understanding the improvement
    first will help later when we get to the Hamcrest code explanations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨新的 Hamcrest 设计之前，下一节将稍微偏离一下，解释对现有的经典 `confirm` 模板函数的改进。这个改进将在 Hamcrest
    设计中使用，因此首先理解这个改进将有助于我们稍后到达 Hamcrest 代码解释时。
- en: Simplifying string confirmations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化字符串确认
- en: While I was writing the code for this chapter, I ran into a problem confirming
    string data types that reminded me of how we added support for confirming strings
    in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045)*, Adding More Confirm Types*.
    The motivating factor from [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045) was
    to get the code to compile because we can’t pass `std::string` to a `std::to_string`
    function. I’ll briefly explain the problem again here.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写本章的代码时，我遇到了一个确认字符串数据类型的问题，这让我想起了我们在[*第五章*](B18567_05.xhtml#_idTextAnchor045)“添加更多确认类型”中添加对字符串确认支持的情况。第五章的动机因素是为了让代码能够编译，因为我们不能将
    `std::string` 传递给 `std::to_string` 函数。我将在下面简要地再次解释这个问题。
- en: I’m not sure of the exact reasons, but I think that the C++ standard library
    designers felt there was no need to provide an overload of `std::to_string` that
    accepts `std::string` because no conversion is needed. A string is already a string!
    Why convert something into what it already is?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定确切的原因，但我想 C++ 标准库的设计者认为没有必要提供接受 `std::string` 的 `std::to_string` 重载，因为没有必要的转换。字符串已经是字符串了！为什么要把某物转换成它已经是的东西呢？
- en: Maybe this decision was on purpose or maybe it was an oversight. But it sure
    would have helped to have a string conversion into a string for template functions
    that need to convert their generic types into strings. That’s because, without
    the overload, we have to take extra steps to avoid compile errors. What we need
    is a `to_string` function that can convert any type into a string even if the
    type is already a string. If we had this ability to always be able to convert
    types into strings, then a template wouldn’t need to be specialized for strings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可能这个决定是有意为之，也可能是一个疏忽。但确实，如果有一个将字符串转换为字符串的转换，对于需要将它们的泛型类型转换为字符串的模板函数来说，这会大有帮助。因为没有这个重载，我们不得不采取额外的步骤来避免编译错误。我们需要的是一个可以将任何类型转换为字符串的
    `to_string` 函数，即使类型已经是字符串。如果我们总是能够将类型转换为字符串，那么模板就不需要为字符串进行特殊化。
- en: 'In [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045), we introduced this template:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18567_05.xhtml#_idTextAnchor045)中，我们介绍了这个模板：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `confirm` function accepts two templatized parameters, called `expected`
    and `actual`, that are compared for equality. If they are not equal, then the
    function passes both parameters to an exception that gets thrown. The parameters
    need to be converted into strings, as needed, by the `ActualConfirmException`
    constructor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirm`函数接受两个模板参数，称为`expected`和`actual`，它们用于比较相等性。如果不相等，则函数将这两个参数传递给抛出的异常。参数需要根据需要通过`ActualConfirmException`构造函数转换为字符串。'
- en: This is where we run into a problem. If the `confirm` template function is called
    with strings, then it doesn’t compile because strings can’t be converted into
    strings by calling `std::to_string`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们遇到问题的所在。如果使用字符串调用`confirm`模板函数，那么它将无法编译，因为字符串不能通过调用`std::to_string`转换为字符串。
- en: 'The solution we went with in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045)
    was to overload the `confirm` function with a non-template version that directly
    accepted strings. We actually created two overloads, one for strings and one for
    string views. This solved the problem but left us with the following two additional
    overloads:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](B18567_05.xhtml#_idTextAnchor045)中我们采取的解决方案是使用直接接受字符串的非模板版本的`confirm`函数进行重载。我们实际上创建了两个重载，一个用于字符串，一个用于字符串视图。这解决了问题，但留下了以下两个额外的重载：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When calling `confirm` with strings, these overloads are used instead of the
    template. The version that accepts `std::string` types calls into the version
    that takes `std::string_view` types, which uses the `expected` and `actual` parameters
    directly without trying to call `std::to_string`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字符串调用`confirm`时，这些重载会代替模板使用。接受`std::string`类型的版本会调用接受`std::string_view`类型的版本，该版本直接使用`expected`和`actual`参数，而不尝试调用`std::to_string`。
- en: At the time, this wasn’t such a bad solution because we already had extra overloads
    of `confirm` for bools and the various floating point types. Two more overloads
    for strings was okay. Later, you’ll see how a small change will let us remove
    these two string overloads.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在当时，这并不是一个糟糕的解决方案，因为我们已经有了`confirm`函数的额外重载，用于bool类型和各种浮点类型。为字符串添加两个额外的重载是可以接受的。稍后，你将看到一个小小的改动将使我们能够移除这两个字符串重载。
- en: And now we come back to the problem of converting string data types with the
    new Hamcrest design we’ll be working on in this chapter. We will no longer need
    extra overloads of `confirm` even for bool or floating point types. As I was working
    on a new solution, I came back to the earlier solution from [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045)
    and decided to refactor the existing classic confirms so that both solutions would
    be similar.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到本章将要讨论的新Hamcrest设计中的字符串数据类型转换问题。即使对于bool或浮点类型，我们也不再需要额外的`confirm`重载。在我开发新解决方案的过程中，我回到了[第5章](B18567_05.xhtml#_idTextAnchor045)中较早的解决方案，并决定重构现有的经典确认，以便两种解决方案相似。
- en: We’ll get into the new design later in this chapter. But so that we don’t have
    to interrupt that explanation, I have decided to take the detour now and explain
    how to remove the need for the string and string view overloads of the classic
    `confirm` function. Going through the explanation now should also make it easier
    to understand the new Hamcrest design since you’ll already be familiar with this
    part of the solution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论新的设计。但为了避免打断这个解释，我决定现在先绕道解释如何移除经典`confirm`函数的字符串和字符串视图重载的需求。现在通过这个解释应该也会更容易理解新的Hamcrest设计，因为你已经熟悉了这个解决方案的这部分。
- en: Also, I’d like to add that TDD helps with this type of refactoring. Because
    we already have existing tests for the classic confirms, we can remove the string
    overloads of `confirm` and make sure that all the tests continue to pass. I’ve
    worked on projects before where only the new code would use the better solution
    and we would have to leave the existing code unchanged in order to avoid introducing
    bugs. Doing this just makes the code harder to maintain because now there would
    be two different solutions in the same project. Having good tests helps give you
    the confidence needed to change existing code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我想补充一点，TDD有助于这种重构。因为我们已经有了经典确认的现有测试，我们可以移除`confirm`的字符串重载，并确保所有测试继续通过。我之前在项目中工作过，只有新代码会使用更好的解决方案，我们必须保持现有代码不变，以避免引入错误。这样做只是让代码更难维护，因为现在同一个项目中会有两种不同的解决方案。良好的测试有助于给你所需的信心，以便更改现有代码。
- en: Okay, the core of the problem is that the C++ standard library does not include
    overloads of `to_string` that work with strings. And while it might be tempting
    to just add our own version of `to_string` to the `std` namespace, this is not
    allowed. It would probably work, and I’m sure that lots of people have done this.
    But it’s technically undefined behavior to add any function into the `std` namespace.
    There are very specific cases where we are allowed to add something into the `std`
    namespace, and unfortunately, this is not one of the allowed exceptions to the
    rules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，问题的核心是 C++ 标准库不包括与字符串一起工作的 `to_string` 重载。虽然添加我们自己的 `to_string` 版本到 `std`
    命名空间可能很有吸引力，但这是不允许的。它可能工作，我确信很多人已经这样做了。但是，将任何函数添加到 `std` 命名空间是技术上的未定义行为。有一些非常具体的情况，我们被允许将某些内容添加到
    `std` 命名空间，不幸的是，这并不是允许的例外之一。
- en: 'We will need our own version of `to_string`. We just can’t put our version
    in the `std` namespace. That’s a problem because when we call `to_string`, we
    currently specify the namespace by calling `std::to_string`. What we need to do
    is simply call `to_string` without any namespace and let the compiler look in
    either the `std` namespace to find the versions of `to_string` that work with
    numeric types, or look in our namespace to find our new version that works with
    strings. The new `to_string` function and the modified `confirm` template function
    look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要我们自己的 `to_string` 版本。我们只是不能将其放入 `std` 命名空间。这是一个问题，因为当我们调用 `to_string` 时，我们目前通过调用
    `std::to_string` 来指定命名空间。我们需要做的是简单地调用 `to_string` 而不带任何命名空间，让编译器在 `std` 命名空间中查找与数值类型一起工作的
    `to_string` 版本，或者在我们的命名空间中查找我们新的与字符串一起工作的版本。新的 `to_string` 函数和修改后的 `confirm` 模板函数看起来像这样：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can remove the two overloads of `confirm` that take string views and strings.
    Now, the `confirm` template function will work for strings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除接受字符串视图和字符串的 `confirm` 的两个重载。现在，`confirm` 模板函数将适用于字符串。
- en: With the new `to_string` function that accepts `std::string`, all it needs to
    do is return the same string. We don’t really need another `to_string` function
    that works with string views.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 新的接受 `std::string` 的 `to_string` 函数只需要返回相同的字符串。我们实际上不需要另一个与字符串视图一起工作的 `to_string`
    函数。
- en: 'The `confirm` template function is a little more complicated because it now
    needs two types, `ExpectedT` and `ActualT`. The two types are needed for those
    cases when we need to compare a string literal with a string, such as in the following
    test:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirm` 模板函数稍微复杂一些，因为它现在需要两种类型，`ExpectedT` 和 `ActualT`。这两种类型是用于那些我们需要比较字符串字面量和字符串的情况，例如以下测试中所示：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason this test used to compile when we had only a single `confirm` template
    parameter is that it wasn’t calling into the template. The compiler was converting
    the `"abc"` string literal into a string and calling the overload of `confirm`
    that accepted two strings. Or maybe it was converting both the string literal
    and the string into string views and calling the overload of `confirm` that accepted
    two string views. Either way, because we had separate overloads of `confirm`,
    the compiler was able to make it work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试之所以在只有一个 `confirm` 模板参数时能够编译，是因为它没有调用模板。编译器将 `"abc"` 字符串字面量转换为字符串，并调用接受两个字符串的重载的
    `confirm`。或者，它可能将字符串字面量和字符串都转换为字符串视图，并调用接受两个字符串视图的重载的 `confirm`。无论如何，因为我们有单独的
    `confirm` 重载，编译器能够使其工作。
- en: Now that we removed both `confirm` overloads that deal with strings, we have
    only the template, and we need to let it accept different types in order to compile.
    I know, we still have overloads for bool and the floating point types. I’m only
    talking about the string overloads that we can remove.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了处理字符串的 `confirm` 重载，我们只剩下模板，我们需要让它接受不同的类型以便编译。我知道，我们仍然有处理布尔型和浮点型的重载。我只是在谈论我们可以移除的字符串重载。
- en: In the new template, you can see that we call `to_string` without any namespace
    specification. The compiler is able to find the versions of `to_string` it needs
    because of the two using statements inside the template function. The first using
    statement tells the compiler that it should consider all the `to_string` overloads
    in the `std` namespace. And the second using statement tells the compiler to also
    consider any `to_string` functions it finds in the `MereTDD` namespace.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的模板中，你可以看到我们没有指定任何命名空间就调用了`to_string`。由于模板函数内部有两个using语句，编译器能够找到所需的`to_string`版本。第一个using语句告诉编译器应该考虑`std`命名空间中所有的`to_string`重载。第二个using语句告诉编译器还应考虑在`MereTDD`命名空间中找到的任何`to_string`函数。
- en: The compiler is now able to find a version of `to_string` that works with the
    numeric types when `confirm` is called with numeric types. And the compiler can
    find our new `to_string` function that works with strings when needed. We no longer
    need to limit the compiler to only look in the `std` namespace.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当`confirm`函数使用数值类型调用时，编译器现在能够找到一个与数值类型兼容的`to_string`版本。当需要时，编译器也可以找到我们新的与字符串兼容的`to_string`函数。我们不再需要限制编译器只查找`std`命名空间。
- en: Now we can go back to the new Hamcrest style design, which we will do in the
    next section. The Hamcrest design will, eventually, use a solution similar to
    what was just described here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到新的Hamcrest风格设计，我们将在下一节中完成。Hamcrest设计最终将使用与这里刚刚描述的类似解决方案。
- en: Enhancing the test library to support Hamcrest matchers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强测试库以支持Hamcrest匹配器
- en: Once you get a basic implementation working and passing the tests, TDD guides
    us to enhance the design by creating more tests and then getting the new tests
    to pass. That’s exactly what this chapter is all about. We’re enhancing the classic
    style confirmations to support the Hamcrest style.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本实现工作正常并通过测试，TDD（测试驱动开发）会引导我们通过创建更多测试并让新测试通过来增强设计。这正是本章的全部内容。我们正在增强经典风格的确认方式以支持Hamcrest风格。
- en: 'Let’s start by creating a new file, called `Hamcrest.cpp`, in the `tests` folder.
    Now, the overall project structure should look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新文件开始，这个文件叫做`Hamcrest.cpp`，位于`tests`文件夹中。现在，整个项目结构应该看起来像这样：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’ve been following all the code in this book so far, remember that we’re
    going back to the *MereTDD* project that we last worked on in [*Chapter 7*](B18567_07.xhtml#_idTextAnchor065),
    *Test Setup and Teardown*. This is not the *MereMemo* logging project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随这本书中的所有代码，记得我们正在回到我们在[*第7章*](B18567_07.xhtml#_idTextAnchor065)中最后工作的*MereTDD*项目，*测试设置和清理*。这不是*MereMemo*日志项目。
- en: 'The Hamcrest style test that we need to support goes inside `Hamcrest.cpp`
    so that the new file looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要支持的Hamcrest风格测试放在`Hamcrest.cpp`文件中，这样新的文件看起来就像这样：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We might as well start with the new `CONFIRM_THAT` macro, which goes at the
    end of `Test.h` right after the other `CONFIRM` macros, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不妨从新的`CONFIRM_THAT`宏开始，它位于`Test.h`文件的末尾，紧随其他`CONFIRM`宏之后，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `CONFIRM_THAT` macro is similar to the `CONFIRM` macro except that the `actual`
    parameter comes first, and instead of an `expected` parameter, we have a parameter
    called `matcher`. We’ll also call a new function called `confirm_that`. The new
    function helps make it simpler to keep the classic style `confirm` overloads separate
    from the Hamcrest-style `confirm_that` function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONFIRM_THAT`宏与`CONFIRM`宏类似，除了`actual`参数放在第一位，而不是`expected`参数，我们有一个名为`matcher`的参数。我们还将调用一个新的函数`confirm_that`。这个新函数有助于使保持经典风格的`confirm`重载与Hamcrest风格的`confirm_that`函数分开变得更加简单。'
- en: 'We don’t need all the overloads in the same way that we needed for `confirm`.
    The `confirm_that` function can be implemented with a single template function.
    Place this new template in `Test.h` right after the classic `confirm` template
    function. Both template functions should look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要像`confirm`那样所有的重载。`confirm_that`函数可以用一个单独的模板函数实现。将这个新的模板放在`Test.h`文件中，紧随经典的`confirm`模板函数之后。这两个模板函数应该看起来像这样：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’re only adding the `confirm_that` function. I decided to show both functions
    so that you can see the differences easier. Notice that now, the `ActualT` type
    is given first. The order doesn’t really matter, but I like to put the template
    parameters in a reasonable order. We no longer have an `ExpectedT` type; instead,
    we have a `MatcherT` type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只添加了`confirm_that`函数。我决定展示两个函数，这样你可以更容易地看到它们之间的差异。注意，现在，`ActualT`类型被放在了第一位。顺序实际上并不重要，但我喜欢将模板参数按照合理的顺序排列。我们不再有`ExpectedT`类型；相反，我们有一个`MatcherT`类型。
- en: The name of the new template function is different too, so there is no ambiguity
    due to the similar template parameters. The new template function is called `confirm_that`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 新的模板函数的名称也不同，因此由于相似的模板参数而导致的歧义不存在。新的模板函数被称为 `confirm_that`。
- en: While the classic `confirm` function compares the `actual` parameter directly
    with the `expected` parameter, the new `confirm_that` function calls into a `pass`
    method on the `matcher` to perform the check. We don’t really know what the `matcher`
    will be doing in the `pass` method because that is for the `matcher` to decide.
    And because any changes in the comparison from one type to another are wrapped
    up in the `matcher`, we don’t need to overload the `confirm_that` function like
    we had to do for the classic `confirm` function. We’ll still need a special code,
    but the differences will be handled by the `matcher` in this design.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当经典 `confirm` 函数直接比较 `actual` 参数和 `expected` 参数时，新的 `confirm_that` 函数会调用 `matcher`
    上的 `pass` 方法来执行检查。我们并不真正知道 `matcher` 在 `pass` 方法中会做什么，因为这取决于 `matcher`。而且，由于任何类型之间的比较变化都被封装在
    `matcher` 中，我们不需要像经典 `confirm` 函数那样重载 `confirm_that` 函数。我们仍然需要特殊的代码，但差异将由本设计中的
    `matcher` 处理。
- en: This is where I realized that there needs to be a different solution for converting
    the `matcher` and `actual` parameters into strings. It seems pointless to override
    `confirm_that` just to avoid calling `to_string` when the type of `ActualT` is
    a string. So, I stopped calling `std::to_string(actual)` and instead started calling
    `to_string(actual)`. In order for the compiler to find the necessary `to_string`
    functions, the using statements are needed. This is the explanation that the previous
    section describes for simplifying the string comparisons.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里我意识到，需要为将 `matcher` 和 `actual` 参数转换为字符串找到一个不同的解决方案。仅仅为了避免当 `ActualT` 的类型为字符串时调用
    `to_string`，而重写 `confirm_that` 看起来毫无意义。因此，我停止调用 `std::to_string(actual)`，而是开始调用
    `to_string(actual)`。为了让编译器找到必要的 `to_string` 函数，需要使用 `using` 语句。这正是前一小节中描述的简化字符串比较的解释。
- en: 'Now that we have the `confirm_that` template, we can focus on the `matcher`.
    We need to be able to call a `pass` method and convert a `matcher` into a string.
    Let’s create a base class for all the matchers to inherit from, so they will all
    have a common interface. Place this base class and `to_string` function right
    after the `confirm_that` function in `Test.h`, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `confirm_that` 模板，我们可以专注于 `matcher`。我们需要能够调用一个 `pass` 方法并将 `matcher`
    转换为字符串。让我们创建一个所有匹配器都可以继承的基类，这样它们都将有一个共同的接口。将这个基类和 `to_string` 函数放在 `Test.h` 中的
    `confirm_that` 函数之后，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `to_string` function will let us convert a matcher into a string by calling
    the virtual `to_string` method in the `Matcher` base class. Notice there is no
    `pass` method in the `Matcher` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_string` 函数将使我们通过调用 `Matcher` 基类中的虚拟 `to_string` 方法，将匹配器转换为字符串。注意在 `Matcher`
    类中并没有 `pass` 方法。'
- en: The `Matcher` class itself is a base class that doesn’t need to be copied or
    assigned. The only common interface the `Matcher` class defines is a `to_string`
    method that all matchers will implement to convert themselves into a string that
    can be sent to the test run summary report.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher` 类本身是一个基类，不需要被复制或赋值。`Matcher` 类定义的唯一公共接口是一个 `to_string` 方法，所有匹配器都将实现这个方法，将自身转换为可以发送到测试运行摘要报告的字符串。'
- en: What happened to the `pass` method? Well, the `pass` method needs to accept
    the actual type that will be used to determine whether the actual value matches
    the expected value. The expected value itself will be held in the derived matcher
    class. The actual value will be passed to the `pass` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass` 方法怎么了？嗯，`pass` 方法需要接受实际类型，该类型将用于确定实际值是否与预期值匹配。预期值本身将保存在派生匹配器类中。实际值将传递给
    `pass` 方法。'
- en: The types of values accepted for the actual and expected values will be fully
    under the control of the derived matcher class. Because the types can change from
    one usage of a matcher to another, we can’t define a `pass` method in the `Matcher`
    base class. This is okay because the `confirm_that` template doesn’t work with
    the `Matcher` base class. The `confirm_that` template will have knowledge of the
    real matcher-derived class and can call the `pass` method directly as a non-virtual
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值和预期值接受的类型将完全由派生匹配器类控制。因为类型可以从一个匹配器的使用改变到另一个使用，所以我们不能在`Matcher`基类中定义一个`pass`方法。这是可以接受的，因为`confirm_that`模板不与`Matcher`基类一起工作。`confirm_that`模板将了解实际的匹配器派生类，并且可以直接作为非虚方法调用`pass`方法。
- en: The `to_string` method is different because we want to call the virtual `Matcher::to_string`
    method from within the `to_string` helper function that accepts any `Matcher`
    reference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_string`方法不同，因为我们想在接受任何`Matcher`引用的`to_string`辅助函数内部调用虚拟的`Matcher::to_string`方法。'
- en: So, when converting a matcher into a string, we treat all matchers the same
    and go through the virtual `to_string` method. And when calling `pass`, we work
    directly with the real matcher class and call `pass` directly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当将匹配器转换为字符串时，我们对待所有匹配器都是一样的，并通过虚拟的`to_string`方法进行。而在调用`pass`时，我们直接与真实的匹配器类一起工作，并直接调用`pass`。
- en: 'Let’s see what a real matcher class will look like. The test we are implementing
    uses a matcher called `Equals`. We can create the derived `Equals` class right
    after the `Matcher` class and the `to_string` function, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个真实的匹配器类将是什么样子。我们正在实现的测试使用了一个名为`Equals`的匹配器。我们可以在`Matcher`类和`to_string`函数之后立即创建派生的`Equals`类，如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Equals` class is another template because it needs to hold the proper expected
    value type, and it needs to use the same type in the `pass` method for the `actual`
    parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals`类是另一个模板，因为它需要持有正确的预期值类型，并且它需要在`pass`方法中使用相同的类型作为`actual`参数。'
- en: Notice that the `to_string` override method uses the same solution to convert
    the `mExpected` data member into a string that we’ve been using. We call `to_string`
    and let the compiler find an appropriate match in either the `std` or `MereTDD`
    namespaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`to_string`重写方法使用了与我们将要使用相同的解决方案来将`mExpected`数据成员转换为字符串。我们调用`to_string`并让编译器在`std`或`MereTDD`命名空间中找到适当的匹配项。
- en: 'We need one more small change to get everything working. In our Hamcrest test,
    we use the `Equals` matcher without any namespace specification. We could refer
    to it as `MereTDD::Equals`. But the namespace specification distracts from the
    readability of the tests. Let’s add a `using namespace MereTDD` statement to the
    top of any test file that will use Hamcrest matchers so we can refer to them directly,
    like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一个小改动才能让一切正常工作。在我们的Hamcrest测试中，我们使用`Equals`匹配器而不指定任何命名空间。我们可以将其称为`MereTDD::Equals`。但命名空间指定会分散测试的可读性。让我们在将使用Hamcrest匹配器的任何测试文件顶部添加一个`using
    namespace MereTDD`语句，这样我们就可以直接引用它们，如下所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That’s everything needed to support our first Hamcrest matcher unit test –
    building and running show that all tests pass. What about an expected failure?
    First, let’s create a new test like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们支持第一个Hamcrest匹配器单元测试所需的一切——构建和运行测试以显示所有测试都通过。那么预期的失败会怎样呢？首先，让我们创建一个像这样的新测试：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This test is designed to fail because `10` will not equal `9`. We need to build
    and run once just to get the failure message from the summary report. Then, we
    can add a call to `setExpectedFailureReason` with the exactly formatted failure
    message. Remember that the failure message needs to match exactly, including all
    the spaces and punctuation. I know this can be tedious, but it should not be a
    test that you need to worry about unless you’re testing one of your own custom
    matchers to make sure the custom matcher is able to format a proper error message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试被设计为失败的，因为`10`不会等于`9`。我们需要构建和运行一次，只是为了从总结报告中获取失败信息。然后，我们可以添加一个调用`setExpectedFailureReason`的语句，并带有精确格式的失败信息。记住，失败信息需要完全匹配，包括所有的空格和标点符号。我知道这可能会很繁琐，但除非你正在测试自己的自定义匹配器以确保自定义匹配器能够格式化正确的错误信息，否则你不需要担心这个测试。
- en: 'After getting the exact error message, we can modify the test to turn it into
    an expected failure, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取确切的错误信息后，我们可以修改测试，将其转换为预期的失败，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Building and running again shows both Hamcrest tests results, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行会显示两个Hamcrest测试结果，如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a good start. We haven’t yet started talking about how to design custom
    matchers. Before we start custom matchers, what about other basic types? We only
    have a couple of Hamcrest tests that compare int values. The next section will
    explore other basic types and add more tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始。我们还没有开始讨论如何设计自定义匹配器。在我们开始自定义匹配器之前，其他基本类型怎么样？我们只有几个比较整数值的 Hamcrest 测试。下一节将探讨其他基本类型并添加更多测试。
- en: Adding more Hamcrest types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多 Hamcrest 类型
- en: There is a pattern to using TDD that you should be familiar with by now. We
    add a little bit of something, get it working, and then add more. We have the
    ability to confirm int values with a Hamcrest `Equals` matcher. Now it’s time
    to add more types. Some of these types might work without any extra work due to
    the template `confirm_that` function. Other types might need changes. We’ll find
    out what needs to be done by writing some tests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉使用 TDD 的模式。我们添加一点东西，使其工作，然后添加更多。我们有能力使用 Hamcrest 的 `Equals` 匹配器确认整数值。现在是时候添加更多类型了。其中一些类型可能不需要额外的工作就能工作，这要归功于模板
    `confirm_that` 函数。其他类型可能需要更改。我们将通过编写一些测试来找出需要做什么。
- en: 'The first test ensures that the other integer types work as expected. Add this
    test to `Hamcrest.cpp`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试确保其他整数类型按预期工作。将此测试添加到 `Hamcrest.cpp`：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, the test declares a couple of chars and uses the `Equals` matcher in
    a couple of different ways. The first is to test for equality with another char.
    The second uses a char literal value, `'A'`, for the comparison.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，测试声明了一些字符，并以几种不同的方式使用 `Equals` 匹配器。第一种是测试与另一个字符的相等性。第二种使用字符字面量值 `'A'` 进行比较。
- en: The second set of confirmations is based on short ints. We use the `Equals`
    matcher with another short int and then an int literal value of `10` for the comparison.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组确认基于短整数。我们使用 `Equals` 匹配器与另一个短整数以及整数字面量值 `10` 进行比较。
- en: The third set of confirmations is based on unsigned ints and, again, tries to
    use the `Equals` matcher with another variable of the same type and with a literal
    int.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组确认基于无符号整数，并且再次尝试使用 `Equals` 匹配器与相同类型的另一个变量以及字面量整数进行比较。
- en: The fourth set of confirmations makes sure that long long types are supported.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第四组确认确保了长长类型得到支持。
- en: We’re not creating helper functions designed to simulate other software being
    tested. You already know how to use confirmations in a real project based on the
    tests in the logging library. That’s why this test makes things simple and just
    focuses on making sure that the `CONFIRM_THAT` macro, which calls the `confirm_that`
    template function, works.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有创建旨在模拟其他正在测试的软件的辅助函数。你已经知道如何根据日志库中的测试在真实项目中使用确认。这就是为什么这个测试使事情简单，并且只专注于确保
    `CONFIRM_THAT` 宏（它调用 `confirm_that` 模板函数）能够正常工作。
- en: Building and running these tests show that all tests pass with no changes or
    enhancements needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行这些测试表明，所有测试都通过，无需任何更改或增强。
- en: 'What about bool types? Here is a test that goes into `Hamcrest.cpp` to test
    bool types:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于布尔类型呢？这里有一个测试，它进入 `Hamcrest.cpp` 以测试布尔类型：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test shows that the Hamcrest style works for bool types, too. When comparing
    one bool variable with another, the Hamcrest style is better than the classic
    style. However, when comparing a bool variable with an expected true or false
    literal, it’s actually more readable to use the classic style because we have
    simplified `CONFIRM_TRUE` and `CONFIRM_FALSE` macros.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，Hamcrest 风格也适用于布尔类型。当比较一个布尔变量与另一个布尔变量时，Hamcrest 风格比经典风格更好。然而，当比较布尔变量与预期的真或假字面量时，使用经典风格实际上更易于阅读，因为我们已经简化了
    `CONFIRM_TRUE` 和 `CONFIRM_FALSE` 宏。
- en: 'Now, let’s move on to strings with this test that goes into `Hamcrest.cpp`.
    Note that this test will fail to compile at first and that’s okay. The test looks
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过这个测试进入 `Hamcrest.cpp` 来处理字符串。请注意，这个测试最初将无法编译，这是可以接受的。测试看起来像这样：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are several confirms in this test, and that’s okay because they’re all
    related. The comments help to clarify what each confirmation is testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中有几个确认，这是可以接受的，因为它们都是相关的。注释有助于阐明每个确认正在测试的内容。
- en: 'We’re always looking for two things with a new test. The first is whether the
    test compiles at all. And the second is whether it passes. Right now, the test
    will fail to compile with an error similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新的测试中总是寻找两件事。第一是测试是否能够编译。第二是测试是否通过。目前，测试将无法编译并出现类似于以下错误的错误：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might get different line numbers, so I’ll explain what the error is referring
    to. The failure is in the `Equals` constructor, which looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到不同的行号，所以我将解释错误所指的是什么。失败发生在 `Equals` 构造函数中，如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And line 63 in `Hamcrest.cpp` is the following line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Hamcrest.cpp` 的第 63 行是以下这一行：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’re trying to construct an `Equals` matcher given the `"abc"` string literal,
    and this fails to compile. The reason is that the `T` type is an array that needs
    to be initialized in a different manner.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在尝试使用 `"abc"` 字符串字面量构造一个 `Equals` 匹配器，但这无法编译。原因是 `T` 类型是一个需要以不同方式初始化的数组。
- en: 'What we need is a special version of `Equals` that works with string literals.
    Since a string literal is an array of constant chars, the following template specialization
    will work. Place this new template in `Test.h` right after the existing `Equals`
    template:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种特殊的 `Equals` 版本，它可以与字符串字面量一起工作。由于字符串字面量是一个常量字符数组，以下模板特化将有效。将这个新模板放在
    `Test.h` 中，紧接在现有的 `Equals` 模板之后：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll need a couple of extra includes in `Test.h` for `cstring` and `type_traits`,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Test.h` 中添加一些额外的包含，用于 `cstring` 和 `type_traits`，如下所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The template specialization uses a new C++20 feature, called *requires*, which
    helps us to place constraints on template parameters. The `requires` keyword is
    actually part of a bigger enhancement in C++20, called *concepts*. Concepts are
    a huge enhancement to C++ and a full explanation would be beyond the scope of
    this book. We’re using concepts and the `requires` keyword to simplify the template
    specialization to only work with strings. The template itself takes a `T` type
    like before and a new numeric value, `N`, which will be the size of the string
    literal. The requires clause makes sure that `T` is a char. We need to remove
    the const qualifier from `T` because string literals are actually constant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模板特化使用了新的 C++20 功能，称为 *requires*，它帮助我们为模板参数添加约束。`requires` 关键字实际上是 C++20 中更大增强的一部分，称为
    *概念*。概念是 C++ 的巨大增强，完整的解释超出了本书的范围。我们使用概念和 `requires` 关键字来简化模板特化，使其仅与字符串一起工作。模板本身接受一个
    `T` 类型，就像之前一样，以及一个新的数值 `N`，它将是字符串字面量的大小。`requires` 子句确保 `T` 是一个字符。我们需要从 `T` 中移除
    const 限定符，因为字符串字面量实际上是常量。
- en: The `Equals` specialization then says it is an array of `T[N]`. The constructor
    takes a reference to an array of `N` chars, and instead of trying to directly
    initialize `mExpected` with the constructor’s `expected` parameter, it now calls
    `memcpy` to copy the chars from the literal into the `mExpected` array. The strange
    syntax of `char const (& expected)[N]` is how C++ specifies an array as a method
    parameter that does not get decayed into a simple pointer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `Equals` 特化声明它是一个 `T[N]` 的数组。构造函数接受一个 `N` 个字符的数组的引用，并且不再尝试直接使用构造函数的 `expected`
    参数初始化 `mExpected`，而是现在调用 `memcpy` 将字符从字面量复制到 `mExpected` 数组中。`char const (& expected)[N]`
    的奇怪语法是 C++ 指定不退化成简单指针的数组作为方法参数的方式。
- en: Now the `pass` method can take a string reference as its `actual` parameter
    type since we know that we are dealing with strings. Additionally, the `to_string`
    method can directly construct and return `std::string` from the `mExpected` char
    array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `pass` 方法可以接受一个字符串引用作为其 `actual` 参数类型，因为我们知道我们正在处理字符串。此外，`to_string` 方法可以直接从
    `mExpected` 字符数组构造并返回 `std::string`。
- en: 'One interesting, and maybe only theoretical, benefit of the `Equals` template
    specialization and the `pass` method is that we can now confirm that a string
    literal equals another string literal. I can’t think of any place where this would
    be useful but it works, so we might as well add it to the test like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals` 模板特化和 `pass` 方法的有趣之处，也许只是理论上的好处，是我们现在可以确认一个字符串字面量等于另一个字符串字面量。我想不出任何地方会有用，但它确实可以工作，所以我们不妨像这样将其添加到测试中：'
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What about char pointers? They’re not as common as char arrays for template
    parameters because char arrays come from working with string literals. A char
    pointer is slightly different. We should consider char pointers because while
    they are not as common in template parameters, a char pointer is probably more
    common overall than char arrays. Here is a test that demonstrates char pointers.
    Note that this test will not compile yet. Add this into `Hamcrest.cpp`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 字符指针怎么样？它们在模板参数中不如字符数组常见，因为字符数组来源于字符串字面量的工作。字符指针略有不同。我们应该考虑字符指针，因为虽然它们在模板参数中不常见，但字符指针可能比字符数组更常见。以下是一个演示字符指针的测试。请注意，这个测试目前还不能编译。将以下内容添加到
    `Hamcrest.cpp` 中：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can initialize a char pointer given a string literal just like how `std::string`
    is initialized. But while `std::string` copies the text into its own memory to
    manage, a char pointer just points to the first char in the string literal. I
    keep saying that we’re working with char pointers. But to be more specific, we’re
    working with constant char pointers. The code needs to use const, but I sometimes
    leave const out when speaking or writing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像初始化`std::string`一样，给字符指针初始化一个字符串字面量。但是，虽然`std::string`会将文本复制到自己的内存中以便管理，字符指针只是指向字符串字面量的第一个字符。我一直在说我们在处理字符指针。但为了更具体，我们正在处理常量字符指针。代码需要使用`const`，但我在说话或写作时有时会省略`const`。
- en: The new test for the string pointer confirms the need to take extra steps to
    make sure that `sp1` and `sp2` point to different memory addresses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 新的字符串指针测试确认了需要采取额外步骤以确保`sp1`和`sp2`指向不同的内存地址。
- en: String literals in C++ are consolidated so that duplicate literal values all
    point to the same memory address. Even though a literal such as `"abc"` might
    be used many times in the source code, there will only be one copy of the string
    literal in the final executable that gets built. The test must go through extra
    steps to make sure that `sp1` and `sp2` have different pointer values while maintaining
    the same text. Whenever `std::string` is initialized with a string literal, the
    text of the string literal gets copied into `std::string` to manage. The `std::string`
    might use dynamically allocated memory or local memory on the stack. A `std::string`
    will not just point to the memory address used in the initialization. If we simply
    initialized `sp2` the same way as `sp1`, then both pointers would point to the
    same memory address. But by initializing `sp2` to point to the string inside `s1`,
    then `sp2` points to a different memory address from `sp1`. Even though `sp1`
    and `sp2` point to different memory addresses, the value of the text chars at
    each address is the same.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的字符串字面量被合并，所以重复的字面量值都指向相同的内存地址。即使一个字面量如`"abc"`在源代码中可能被多次使用，最终的可执行文件中也只会有一个字符串字面量的副本。测试必须通过额外步骤来确保`sp1`和`sp2`具有不同的指针值，同时保持相同的文本。每当`std::string`用字符串字面量初始化时，字符串字面量的文本就会被复制到`std::string`中以便管理。`std::string`可能会使用动态分配的内存或栈上的局部内存。`std::string`不会仅仅指向初始化时使用的内存地址。如果我们简单地像`sp1`一样初始化`sp2`，那么两个指针都会指向相同的内存地址。但通过将`sp2`初始化为指向`s1`中的字符串，那么`sp2`就指向了与`sp1`不同的内存地址。尽管`sp1`和`sp2`指向不同的内存地址，但每个地址上文本字符的值是相同的。
- en: Okay, now that you understand what the test is doing, does it compile? No. The
    build fails while trying to call the `pass` method in the `confirm_that` template
    function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你明白了测试在做什么，它编译了吗？不。在尝试在`confirm_that`模板函数中调用`pass`方法时，构建失败了。
- en: 'The line in the test that causes the build failure is the last confirmation.
    The compiler is trying to convert the `s1` string into a constant char pointer.
    But this is misleading because even if we comment out the last confirmation so
    that the build succeeds, the test then fails at runtime, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 导致构建失败的测试中的那一行是最后的确认。编译器试图将`s1`字符串转换为常量字符指针。但这是有误导性的，因为即使我们注释掉最后的确认，构建成功，但测试在运行时仍然会失败，如下所示：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because you might get different line numbers, I’ll explain that line 75 is
    the first confirmation from the test:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可能得到不同的行号，我会解释第75行是测试中的第一个确认：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Look at the test failure message though. It says that `"abc"` is not equal to
    `"abc"`! What is going on?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看看测试失败的信息。它说`"abc"`不等于`"abc"`！这是怎么回事？
- en: Because we’re using the original `Equals` template class, it only knows that
    we are dealing with char pointers. When we call `pass`, it’s the pointer values
    that are being compared. And because we took extra steps to make sure that `sp1`
    and `sp2` have different pointer values, the test fails. And the test fails even
    though the text both pointers refer to is the same.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用的是原始的`Equals`模板类，它只知道我们正在处理字符指针。当我们调用`pass`时，被比较的是指针值。而且因为我们采取了额外步骤确保`sp1`和`sp2`具有不同的指针值，所以测试失败了。即使两个指针所引用的文本相同，测试也会失败。
- en: 'In order to support pointers, we’ll need another template specialization of
    `Equals`. But we can’t just specialize on any pointer type, in the same way we
    couldn’t specialize on any array type. We made sure that the array specialization
    only works for char arrays. So, we should also make sure that our pointer specialization
    only works with char pointers. Add this specialization right after the second
    `Equals` class in `Test.h`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持指针，我们需要对`Equals`进行另一个模板特殊化。但我们不能对任何指针类型进行特殊化，就像我们不能对任何数组类型进行特殊化一样。我们确保数组特殊化只适用于char数组。因此，我们也应该确保我们的指针特殊化只与char指针一起工作。在`Test.h`中的第二个`Equals`类之后添加这个特殊化：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this third version of the `Equals` class, we not only fix the build error
    but all the confirmations pass too! This template specializes `Equals` for `T
    *` and also requires that `T` be a char type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`Equals`类的第三个版本，我们不仅修复了构建错误，所有的确认都通过了！这个模板为`T *`专门化了`Equals`，并要求`T`是一个char类型。
- en: The constructor accepts a pointer to constant chars and initializes `mExpected`
    with the pointer. The `mExpected` data member is `std::string`, which knows how
    to initialize itself from a pointer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个指向常量字符的指针，并用该指针初始化`mExpected`。`mExpected`数据成员是`std::string`，它知道如何从指针初始化自己。
- en: The `pass` method also accepts `std::string`, which will let it compare against
    actual strings or char pointers. Additionally, the `to_string` method can return
    `mExpected` directly since it’s already a string.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`方法也接受`std::string`，这将允许它与实际的字符串或char指针进行比较。此外，`to_string`方法可以直接返回`mExpected`，因为它已经是一个字符串。'
- en: When we were adding more classical confirmations in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045),
    *Adding More Confirm Types*, we added special support for floating point types.
    We’ll need to add special support for confirming floating-point types in the Hamcrest
    style, too. The Hamcrest floating-point specializations will come in the next
    chapter along with learning how to write custom matchers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第五章*](B18567_05.xhtml#_idTextAnchor045)“添加更多确认类型”中添加更多经典确认时，我们添加了对浮点类型的特殊支持。我们还需要在Hamcrest风格中添加对确认浮点类型的特殊支持。Hamcrest的浮点特殊化将在下一章中介绍，包括如何编写自定义匹配器。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We used TDD throughout this chapter to add Hamcrest confirmations and even improve
    the existing code for classical confirmations. Without TDD, the existing code
    in a real project would likely not get approval from management to make changes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用了TDD来添加Hamcrest确认，甚至改进了现有的经典确认代码。没有TDD，真实项目中的现有代码可能不会得到管理层的批准进行更改。
- en: This chapter showed you the benefits of having unit tests that can help verify
    the quality of code after making changes. We were able to refactor the existing
    classical confirmations design for dealing with strings so that it matches the
    new design, which has a similar need. This lets both the classical and Hamcrest
    confirmations share a similar design instead of maintaining two different designs.
    All the changes were possible because the unit tests verified that everything
    continued to run as expected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了拥有单元测试的好处，这些测试可以帮助验证在做出更改后代码的质量。我们能够重构现有的经典确认设计，以处理字符串，使其与新设计相匹配，该设计有类似的需求。这使得经典和Hamcrest确认可以共享类似的设计，而不是维护两种不同的设计。所有这些更改都是可能的，因为单元测试验证了一切都按预期继续运行。
- en: The most important changes in this chapter added Hamcrest style confirmations,
    which are more intuitive and more flexible than the classic confirmations developed
    in [*Chapter 4*](B18567_04.xhtml#_idTextAnchor038), *Adding Tests to a Project*.
    Additionally, the new Hamcrest confirmations are extensible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的变化是添加了Hamcrest风格的确认，这些确认比在[*第四章*](B18567_04.xhtml#_idTextAnchor038)“向项目中添加测试”中开发的经典确认更直观、更灵活。此外，新的Hamcrest确认也是可扩展的。
- en: We added support for Hamcrest confirmations following a TDD approach, which
    let us start simply. The simplicity was critical because we soon got into more
    advanced template specializations and even a new C++20 feature, called *requires*,
    that lets us specify how the templates should be used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循TDD方法添加了对Hamcrest确认的支持，这让我们可以简单地开始。这种简单性是关键的，因为我们很快进入了更高级的模板特殊化，甚至是一个新的C++20特性，称为*requires*，它允许我们指定模板应该如何使用。
- en: TDD makes the process of designing software flow better – from simple ideas
    at the start of a project or the beginning of an enhancement to an enhanced solution
    like this chapter developed. Even though we have working Hamcrest confirmations,
    we’re not done yet. We’ll continue to enhance the confirmations in the next chapter
    by making sure we can confirm floating-point values and custom-type values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TDD使软件设计过程更加流畅——从项目开始或增强初期简单的想法，到像本章开发这样的增强解决方案。尽管我们已经有工作的Hamcrest确认，但我们还没有完成。我们将在下一章继续增强确认，确保我们可以确认浮点值和自定义类型值。
