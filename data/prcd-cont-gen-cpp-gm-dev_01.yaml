- en: Chapter 1. An Introduction to Procedural Generation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。程序生成简介
- en: When you load an image on a PC, a song on an iPod, or a book on a Kindle, you
    load it from storage. That image, song, and book already exists as a whole, and
    whenever you want to access it, you grab the whole previously created thing. In
    the case of music or a video, you can stream it in chunks, but it still already
    exists as a whole in storage. Let's compare this to buying a ready-made desk from
    a furniture store. You get the entire desk as one single thing and that's that;
    you have a desk.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在PC上加载一张图片、iPod上的一首歌曲，或者Kindle上的一本书时，你是从存储中加载它。那张图片、歌曲和书已经作为一个整体存在，每当你想要访问它时，你就会获取整个之前创建的东西。在音乐或视频的情况下，你可以分块流式传输，但它仍然作为一个整体存在于存储中。让我们将这与从家具店购买现成的桌子进行比较。你得到整个桌子作为一个单一的东西，就是这样；你有了一张桌子。
- en: Now, let's imagine that instead of buying a complete desk, you buy one that's
    flat-packed. Instead of getting a pre-built desk, you get all the pieces that
    you need to build one, and instructions on how to do so. When you get home, you
    can follow those instructions, and you will have a desk. If you feel so inclined,
    you can even deviate from the instructions and create a unique desk that is different
    from that of everyone else.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，你不是买一个成品桌子，而是买了一个平装的桌子。你得到的不是一个预制的桌子，而是你需要建造一个桌子的所有零件，以及如何做的说明。当你回家后，你可以按照这些说明来建造桌子。如果你愿意，你甚至可以偏离说明，创造出与其他人不同的独特桌子。
- en: Let's use this analogy in the context of game development by substituting the
    purchasing of a desk with the loading of a level. In the first case, we loaded
    the level as a whole, as it was pre-built. However, in the second example, we
    got all the pieces that we need to build a level and put them together ourselves
    in whatever order we choose.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游戏开发的背景下使用这个类比，将购买桌子替换为加载关卡。在第一种情况下，我们加载了整个关卡，因为它是预先构建好的。然而，在第二个例子中，我们得到了所有需要建造关卡的零件，并按照自己选择的顺序将它们组合在一起。
- en: This process of something being created via an algorithm or procedure, as opposed
    to already existing, is called **procedural generation.** The desk was created
    procedurally as you followed an algorithm to put its pieces together. The same
    goes for the game level. This can be extended to almost anything. For example,
    music, images, games, and text can all be procedurally generated.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过算法或程序创建某物的过程，而不是已经存在的东西，被称为**程序生成**。桌子是通过按照算法将其零件组合而成的。游戏关卡也是如此。这几乎可以扩展到任何东西。例如，音乐、图像、游戏和文本都可以通过程序生成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Procedural generation versus random generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序生成与随机生成
- en: Generating pseudorandom numbers in C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中生成伪随机数
- en: Seeds
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种子
- en: The benefits and drawbacks of procedural generation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序生成的利与弊
- en: A brief history of rogue-like games
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 罗格式游戏的简史
- en: How to implement procedural generation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现程序生成
- en: Procedural generation versus random generation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成与随机生成
- en: I'd like to make a distinction before we go any further. In this book, we're
    going to talk a lot about procedural generation and random generation. These terms
    are often used interchangeably, but they are not the same thing. Therefore, let's
    take a moment to define them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想先做一个区分。在这本书中，我们将大量讨论程序生成和随机生成。这些术语经常被互换使用，但它们并不是同一回事。因此，让我们花一点时间来定义它们。
- en: Procedural generation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序生成
- en: Procedural generation is the process of creating content using an algorithm.
    This in itself has no element of randomness. If the functions, expressions, algorithms,
    and inputs that are used to generate the content remain the same, then you'll
    always get the same results. This is due to the fact that computers are deterministic,
    which is something that we'll cover shortly. Procedural generation is not inherently
    random.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成是使用算法创建内容的过程。这本身没有随机元素。如果用于生成内容的函数、表达式、算法和输入保持不变，那么你总是会得到相同的结果。这是因为计算机是确定性的，这是我们很快会讨论的内容。程序生成本身并不具有随机性。
- en: Random generation
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机生成
- en: Randomness is induced when we give these algorithms different inputs or alter
    their expressions. This variance is what creates the variety of the output. When
    someone says something was procedurally generated, they usually mean procedurally
    generated utilizing randomness.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给这些算法不同的输入或改变它们的表达时，就会引入随机性。这种变化是导致输出多样性的原因。当有人说某物是程序生成时，他们通常是指利用随机性进行程序生成。
- en: Introducing randomness
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入随机性
- en: Computers are **deterministic** machines. This means that if you give them the
    same input, and perform the same operations, you'll get the same output every
    time. With respect to the desk example, everyone gets the same pieces, follows
    the same instructions, and so builds the same desk.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是**确定性**的机器。这意味着如果你给它们相同的输入，并执行相同的操作，每次都会得到相同的输出。就桌子的例子而言，每个人都得到相同的零件，遵循相同的说明，因此建造出相同的桌子。
- en: Again, using the context of games, if everyone gets the same assets and algorithms
    to put them together, we will all get the same game and experience. Sometimes,
    this is the goal. However, in our case, we want to create game systems that are
    unpredictable and dynamic. Therefore, we need to introduce an element of randomness
    to procedural generation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以游戏的背景来说，如果每个人都得到相同的资产和算法来组合它们，我们都会得到相同的游戏和体验。有时，这是目标。然而，在我们的情况下，我们希望创建不可预测和动态的游戏系统。因此，我们需要在程序生成中引入一定的随机元素。
- en: Pseudorandom number generation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪随机数生成
- en: Random number generation is simply the process of picking a number at random.
    This is pretty straightforward for us, but it is a much tougher task for a computer.
    In fact, it's impossible for a computer to generate a truly random number without
    special hardware. You'll understand why this is so in a moment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成只是随机选择一个数字的过程。对我们来说这很简单，但对计算机来说是一项更艰巨的任务。事实上，计算机要生成一个真正的随机数是不可能的，除非有特殊的硬件。你马上就会明白为什么会这样。
- en: The next best thing is pseudorandom number generation. The word *pseudo* literally
    means *not genuine*. Therefore, pseudorandom number generation can be thought
    of as a fake random number generation. The numbers appear to be random but are
    actually the result of complex equations and algorithms that could in fact be
    calculated in advance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最好的选择是伪随机数生成。单词*pseudo*的字面意思是*不真实*。因此，伪随机数生成可以被认为是假随机数生成。这些数字看起来是随机的，但实际上是复杂方程和算法的结果，事实上可以提前计算出来。
- en: Bear in mind that not all pseudorandom number generators are built equally.
    For applications such as trivial simulations and games, fairly linear algorithms
    can be used and are perfectly suitable. However, pseudorandom number generation
    is also used in applications such as **cryptography**, and will use much more
    complex algorithms so that the outcome cannot be determined via patterns created
    from earlier outputs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有的伪随机数生成器都是一样的。对于诸如普通模拟和游戏之类的应用程序，可以使用相当线性的算法，并且非常适用。然而，伪随机数生成也用于诸如**密码学**之类的应用程序，将使用更复杂的算法，以便无法通过先前输出创建的模式来确定结果。
- en: The pseudorandom number generators that we use as developers fall firmly into
    the first category and are perfectly suitable. Luckily for us, C++ offers a number
    of ways in which trivial pseudorandom numbers can be generated. Throughout the
    course of this book, we will use `std::rand()` and `std::srand()`, both of which
    standard C++ functions that are included in `<cstdlib>` library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为开发者使用的伪随机数生成器属于第一类，并且非常适用。幸运的是，C++提供了多种生成普通伪随机数的方法。在本书的过程中，我们将使用`std::rand()`和`std::srand()`，它们都是标准C++函数，包含在`<cstdlib>`库中。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Learning how to read and extract information from documentation is a skill that
    I feel is often overlooked. With a multitude of great forums at hand it's easy
    to go straight to Google for a solution to your problem, but first, always read
    the documentation. [http://www.cplusplus.com](http://www.cplusplus.com) is a great
    C++ reference, and SFML is fully documented at [http://www.sfml-dev.org/documentation/](http://www.sfml-dev.org/documentation/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何阅读和从文档中提取信息是一项我认为经常被忽视的技能。有了众多优秀的论坛，很容易直接去谷歌寻找解决方案，但首先，一定要阅读文档。[http://www.cplusplus.com](http://www.cplusplus.com)是一个很好的C++参考，SFML在[http://www.sfml-dev.org/documentation/](http://www.sfml-dev.org/documentation/)上有完整的文档。
- en: Why computers can't generate truly random numbers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么计算机不能生成真正的随机数
- en: We now know that computers can't generate random numbers, and that we generate
    pseudorandom numbers instead. Let's have a look at why this is so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道计算机不能生成随机数，而是生成伪随机数。让我们看看为什么会这样。
- en: The reason behind this is the same as the reason why two computers will reach
    the same output given the same input and operation; computers are deterministic.
    Everything that a computer produces is the result of an algorithm or equation.
    They are nothing more than highly sophisticated calculators. Therefore, you can't
    ask them to act unpredictably.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因与两台计算机在给定相同输入和操作的情况下会达到相同输出的原因相同；计算机是确定性的。计算机产生的一切都是算法或方程的结果。它们只不过是高度复杂的计算器。因此，你不能要求它们表现得不可预测。
- en: True random numbers can be generated, but you need to utilize systems outside
    the machine. For example, at [https://www.random.org/](https://www.random.org/)
    **you can** generate truly random numbers using atmospheric noise. There are other
    systems that are akin to this, but unless you are generating random numbers for
    something important such as security purposes, trivial pseudorandom number generation
    will suffice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的随机数可以生成，但你需要利用机器外部的系统。例如，在[https://www.random.org/](https://www.random.org/)
    **你可以**使用大气噪音生成真正的随机数。还有其他类似的系统，但除非你为安全目的生成随机数，否则普通伪随机数生成就足够了。
- en: Generating random numbers in C++
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中生成随机数
- en: Let's start coding by writing a small program to generate some pseudorandom
    numbers. To do this, we will use the `std::rand()` function. It generates a pseudorandom
    integer in the range between `0` to `RAND_MAX`. The `RAND_MAX` variable is a constant
    defined in `<cstdlib>`. Its value will vary depending on the library that you
    are using. On a standard library implementation, it's guaranteed to be at least
    32767.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个小程序来生成一些伪随机数来开始编码。为此，我们将使用`std::rand()`函数。它在`0`到`RAND_MAX`之间生成一个伪随机整数。`RAND_MAX`变量是在`<cstdlib>`中定义的常量。它的值将取决于你使用的库。在标准库实现中，它的值至少为32767。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're already familiar with this topic, feel free to skip ahead to the sub-chapter
    named Seeds.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉这个主题，可以直接跳到名为种子的子章节。
- en: 'You can download the code for this program from the Packt website at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    It will be present in the `Examples` folder, and the project name is `random_numbers`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Packt网站[http://www.packtpub.com/support](http://www.packtpub.com/support)下载这个程序的代码。它将出现在`Examples`文件夹中，项目名称是`random_numbers`：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Downloading the example code
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt Publishing图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: This is a very simple console application that makes a call to `std::rand()`
    every time we press the Enter key. This returns us the pseudorandom number, and
    we pass it to `std::cout` to display it. That's how easy it is!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的控制台应用程序，每次按Enter键时都会调用`std::rand()`。这会返回伪随机数，并将其传递给`std::cout`以显示它。就是这么简单！
- en: '![Generating random numbers in C++](img/B04920_01_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![在C++中生成随机数](img/B04920_01_01.jpg)'
- en: Generating random numbers within a range
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在范围内生成随机数
- en: The previous code generated numbers between `0` and `RAND_MAX`. That's great,
    but we'll usually want more control over this in order to generate numbers within
    a certain range. To do this, we are going to use the **modulo** **operator**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码生成了介于`0`和`RAND_MAX`之间的数字。这很好，但通常我们希望更多地控制这一点，以便在特定范围内生成数字。为此，我们将使用**模运算符**。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In C++, the modulo operator is the % symbol. This varies between languages,
    but is generally either *%* or *Mod*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，模运算符是%符号。这在不同的语言之间有所不同，但通常是*%*或*Mod*。
- en: The modulo operator returns the remainder of the division between two numbers.
    So, 9 mod 2 is 1, as 2 goes into 9 four times with 1 left over. We can use this
    to create a range for the pseudorandom number generation. Let's generate a number
    between 0 and 249.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 取模运算符返回两个数字之间的除法余数。因此，9 mod 2是1，因为2可以整除9四次，剩下1。我们可以利用这个来创建伪随机数生成的范围。让我们生成一个介于0和249之间的数字。
- en: 'To do this, we need to make the following change:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要进行以下更改：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the program a few times now, and you''ll see that all the results are limited
    to the range that we just defined. So now we can generate a number between 0 and
    n, but what if we don''t want our range to start from 0? To do this, we need to
    make one more change to the line that generates a number:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序几次，您会看到所有的结果都限制在我们刚刚定义的范围内。所以现在我们可以生成一个介于0和n之间的数字，但是如果我们不希望我们的范围从0开始怎么办？为此，我们需要对生成数字的行进行一次更改：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that the number we used in the mod calculation will generate a number
    between 0 and n-1, and the number we add afterwards will increase the range by
    that amount. So here, we generate a number between 0 and 200 and then increase
    the range by 50 to get a number between 50 and 250.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在模运算中使用的数字将生成一个介于0和n-1之间的数字，然后我们之后添加的数字将增加该数量的范围。因此，在这里，我们生成一个介于0和200之间的数字，然后增加50来获得一个介于50和250之间的数字。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're not fully comfortable with the math behind what we're doing here,
    head over to Khan Academy. It's a fantastic resource for learning and has lots
    of great mathematics-related material.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对我们在这里所做的事情背后的数学不太了解，请前往Khan Academy。这是一个学习的绝佳资源，有很多优秀的与数学相关的材料。
- en: Run the program and note the first five numbers that are generated. In my case,
    they are 91, 226, 153, 219, and 124\. Now, run it again. You'll notice that something
    strange happens; we received the exact same numbers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并注意生成的前五个数字。在我的情况下，它们是91、226、153、219和124。现在再次运行。您会注意到发生了一些奇怪的事情；我们收到了完全相同的数字。
- en: They were generated in a pseudorandom manner, right? Maybe it was just a fluke.
    Let's run it again and see what we get. You will get the same result again. To
    understand what's happening here, we need to take a look at **seeds**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是以伪随机的方式生成的，对吧？也许这只是一个偶然。让我们再次运行它，看看我们得到了什么。你会再次得到相同的结果。要理解这里发生了什么，我们需要看一下**种子**。
- en: Seeds
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子
- en: We just created a program to generate pseudorandom numbers, but every time we
    run it we get the same results. We know that these numbers are the results of
    complex equations and algorithms, so why are they the same? It's because each
    time we run the program, we're starting with the same seed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个生成伪随机数的程序，但每次运行它时，我们都会得到相同的结果。我们知道这些数字是复杂方程和算法的结果，那为什么它们是相同的呢？这是因为每次运行程序时，我们都从相同的种子开始。
- en: Defining seeds
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义种子
- en: A seed provides a starting point for an algorithm. So, in the previous example,
    yes we're using complex algorithms to generate numbers, but we're kicking off
    the algorithm at the same point each time. No matter how complex the algorithm
    is, if you start at the same point, and perform the same operations, you're going
    to get the same results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 种子为算法提供了一个起点。因此，在前面的例子中，是的，我们正在使用复杂的算法来生成数字，但我们每次都从相同的点开始算法。无论算法有多复杂，如果您从相同的点开始，并执行相同的操作，您将得到相同的结果。
- en: 'Imagine that we have three people, and each person is about to walk the same
    path by 5 steps. If they all start from the same square, they will end at the
    same square:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有三个人，每个人都要走5步相同的路径。如果他们都从同一个方块开始，他们最终会到达同一个方块：
- en: '![Defining seeds](img/B04920_01_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![定义种子](img/B04920_01_02.jpg)'
- en: 'Now, in the next diagram, we give these three people unique starting positions.
    Even though they are doing the same actions as before, and are on the same path,
    their results are different because they started from different locations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一个图表中，我们给这三个人不同的起始位置。即使他们做的动作与之前相同，并且在同一路径上，但由于他们从不同的位置开始，他们的结果是不同的：
- en: '![Defining seeds](img/B04920_01_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![定义种子](img/B04920_01_03.jpg)'
- en: In this analogy, the path is the algorithm, and the starting square is the seed.
    By changing the seed we can get different results from the same actions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，路径是算法，起始方块是种子。通过改变种子，我们可以从相同的动作中获得不同的结果。
- en: You will have most likely used seeds before and not even known it. Games that
    procedurally generate worlds, such as Minecraft and Lego Worlds, give you the
    option to set a seed manually before generating a world. If your friend generates
    a world that looks great, they can grab their seed and give it to you. When you
    input that seed yourself, you kick off the algorithm at the same place that your
    friends did and you end up with the same worlds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能以前使用过种子，甚至都不知道。像Minecraft和乐高世界这样的游戏，在生成世界之前，会给你设置一个种子的选项。如果你的朋友生成了一个看起来很棒的世界，他们可以获取他们的种子并给你。当你自己输入那个种子时，你就像你的朋友一样从同一个位置启动算法，最终得到相同的世界。
- en: Using seeds
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用种子
- en: Now that we know what seeds are, let's fix the previous example so that we don't
    keep generating the same numbers. To do this, we will use the `std::srand()` function.
    It's similar to `std::rand()`, but it takes an argument. This argument is used
    to set the seed for an algorithm. We'll add the call to `std::srand()` before
    we enter the while loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了种子是什么，让我们修复上一个例子，以便我们不再生成相同的数字。为此，我们将使用`std::srand()`函数。它类似于`std::rand()`，但它需要一个参数。这个参数用于设置算法的种子。我们将在进入while循环之前调用`std::srand()`。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You only need to set the seed once per run of the application. Once `std::srand()`
    has been called, all the subsequent calls to `std::rand()` will be based upon
    the updated initial seed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要在应用程序运行时设置一次种子。一旦调用了`std::srand()`，所有后续对`std::rand()`的调用都将基于更新后的初始种子。
- en: 'The updated code should look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码应该是这样的：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now when we run this code we get different results! I got 214, 60, 239, 71,
    and 233\. Don't worry if your numbers don't match mine exactly; they are both
    CPU- and vendor-specific. So, what will happen if we run the program again? We
    changed the seed. So we should get different numbers again, right?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行这段代码时，我们得到了不同的结果！我得到了214、60、239、71和233。如果你的数字和我的不完全匹配，不要担心；它们都是CPU和供应商特定的。那么如果我们再次运行程序会发生什么呢？我们改变了种子。所以我们应该再次得到不同的数字，对吗？
- en: Not quite. We called `std::srand()` and set a new seed, but each time we run
    the program we're setting the same seed again. We're kicking the algorithm off
    at the same position each time, so we're seeing the same results. What we really
    want to do is randomly generate a seed during runtime so that the algorithm always
    starts at a new position.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全正确。我们调用了`std::srand()`并设置了一个新的种子，但每次运行程序时，我们又设置了相同的种子。我们每次都从相同的位置启动算法，所以看到了相同的结果。我们真正想做的是在运行时随机生成一个种子，这样算法总是从一个新的位置开始。
- en: Generating random seeds during the runtime
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时生成随机种子
- en: There are many ways to achieve this, and your use case will determine which
    method is suitable. For us, as game developers, something relatively trivial such
    as the current system time will usually suffice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以实现这一点，您的用例将决定哪种方法适合。对于我们作为游戏开发者来说，通常一些相对琐碎的东西，比如当前系统时间，就足够了。
- en: This does mean that if you run the program at the exact same time you'll get
    the same results, but that's almost never going to be a problem for our use. C++
    provides us with a nice function to get the current time, `time()`, which is located
    in `<ctime>`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你在完全相同的时间运行程序，你会得到相同的结果，但这几乎永远不会成为我们的问题。C++为我们提供了一个很好的函数来获取当前时间，`time()`，它位于`<ctime>`中。
- en: 'Let''s update the program one last time and pass `time()` as a parameter in
    `std::srand()` so that we generate unique numbers with every run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后一次更新程序，并将`time()`作为参数传递给`std::srand()`，以便在每次运行时生成唯一的数字：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, every time we run the program, we get unique numbers! You may have noticed
    that if you run the program multiple times in succession, the first number is
    always very similar to the last run. That's because between the runs time doesn't
    change a lot. This means that the starting points are close to each other and
    the results reflect this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次运行程序，我们都会得到唯一的数字！你可能已经注意到，如果连续多次运行程序，第一个数字总是与上次运行非常相似。这是因为在运行之间时间变化不大。这意味着起始点彼此接近，结果也反映了这一点。
- en: Controlled randomness is the key to generating random numbers
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制随机性是生成随机数的关键
- en: The process of generating random numbers is a huge component in creating systems
    that procedurally generate game content. There are lots of ways in which random
    data is generated, such as noise maps and other external systems, but in this
    book, we'll stick to these simple C++ functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的过程是创建过程生成游戏内容的重要组成部分。有许多生成随机数据的方法，比如噪声地图和其他外部系统，但在本书中，我们将坚持使用这些简单的C++函数。
- en: We want systems that are predictable enough to give us control over them as
    developers, but they should be dynamic enough to create variations for the player.
    This balance can be hard to achieve, and sometimes games get it wrong. Later in
    this chapter, we'll look at some of the things that you have to watch out for
    when incorporating procedural generation into a game project to avoid this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望系统足够可预测，以便我们作为开发者控制它们，但它们也应该足够动态，以便为玩家创建变化。这种平衡很难实现，有时游戏会做错。在本章的后面，我们将看一些在将过程生成纳入游戏项目时需要注意的事项，以避免出现这种情况。
- en: The use of procedural generation in games
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用过程生成
- en: Now we know what procedural generation is, and that it's the element of randomness
    we add that lets us create dynamic systems, let's take a look at some examples
    of how it is used in games. There are countless ways in which it can be utilized;
    the following are just a few major implementations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了过程生成是什么，以及它是我们添加的随机元素，让我们能够创建动态系统，让我们来看一些游戏中如何使用它的例子。它可以被利用的方式有无数种，以下只是一些主要的实现方式。
- en: Saving space
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节省空间
- en: Necessity, as the saying goes, is the mother of invention. As developers of
    today we're spoiled with the hardware that we have at our disposal. Even the most
    baseline machines that you'll get today will have a hard drive of 500 GB in size
    and up as standard. This is quite a luxury considering that just a couple of decades
    ago that would be MB and not GB.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，需要是发明之母。作为今天的开发者，我们被我们可以使用的硬件宠坏了。即使是今天最基本的机器也会有一个500 GB大小的硬盘作为标准。考虑到仅仅几十年前，那将是MB而不是GB，这是相当奢侈的。
- en: Game distribution was also a very different game back then. Today, we either
    buy games on a physical disk, with Blu-ray disks offering a whopping 25 GB per
    layer, or download them off the Internet, where there are no size restrictions
    at all. Keeping this in mind, now consider the fact that the size of most **Nintendo
    Entertainment System** (**NES**) games was a mere 128 to 384 KB! These storage
    restrictions meant that game developers had to fit lots of content into a small
    space, and procedural generation was a great way to do this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏分发在当时也是一个非常不同的游戏。今天，我们要么在物理光盘上购买游戏，蓝光光盘每层提供了惊人的25 GB，要么从互联网上下载，那里根本没有大小限制。记住这一点，现在考虑一下大多数**任天堂娱乐系统**（**NES**）游戏的大小仅为128到384
    KB！这些存储限制意味着游戏开发人员必须将大量内容放入一个小空间，程序生成是一个很好的方法。
- en: Since building large levels and storing them wasn't possible in the past, games
    were designed to build their levels and resources algorithmically. You'd put all
    the resources needed on your storage media, and have the software assemble the
    level at the player's end.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过去无法构建大型关卡并存储它们，游戏被设计为通过算法构建它们的关卡和资源。你会把所有需要的资源放在存储介质上，然后让软件在玩家端组装关卡。
- en: Hopefully now, the earlier desk analogy makes more sense. It's just like how
    flat-packed furniture is easier to transport, and it can then be built at home.
    As hardware has developed, this has become less of a problem, but it was a great
    solution for early developers who had storage concerns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在早期的桌子类比更容易理解了。就像平装家具更容易运输，然后可以在家里组装一样。随着硬件的发展，这已经不再是一个问题，但对于早期有存储问题的开发者来说，这是一个很好的解决方案。
- en: Map generation
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图生成
- en: One of the most prominent uses of procedural generation in modern video games
    is the generation of game maps and terrain. The extent to which this can be used
    is vast, and ranges from generating simple 2D maps to full 3D worlds and terrain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代视频游戏中，程序生成最突出的用途之一是生成游戏地图和地形。它可以被广泛使用，从生成简单的2D地图到完整的3D世界和地形。
- en: When procedurally generating 3D terrain, noise maps, such as the ones generated
    by **Perlin noise**, are used to represent random distribution by producing an
    image with areas of both high and low concentration. This data, the variance in
    concentration and intensity, can then be used in many ways. When generating a
    terrain, it's commonly used to determine the height at any given position.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序生成3D地形时，诸如**Perlin噪声**生成的噪声图被用来表示通过产生具有高低浓度区域的图像来代表随机分布。这些数据，浓度和强度的变化，可以以许多方式使用。在生成地形时，它通常用于确定任意位置的高度。
- en: '![Map generation](img/B04920_01_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![地图生成](img/B04920_01_04.jpg)'
- en: The procedural generation of complex 3D terrain is beyond the scope of this
    book. However, we will generate 2D dungeons later in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的3D地形的程序生成超出了本书的范围。然而，我们将在本书的后面生成2D地牢。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you do want to explore 3D terrain generation, read up on terms such as "fractal
    terrain generation", "height maps", and "noise generation". These will put you
    on the correct path.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索3D地形生成，请阅读诸如“分形地形生成”、“高度图”和“噪声生成”之类的术语。这将让你走上正确的道路。
- en: Texture creation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理创建
- en: Another prominent example of procedural generation is the creation of textures.
    Similar to terrain generation, the procedural generation of textures uses noise
    to create variance. This can then be used to create varying textures. Different
    patterns and equations are also used to create a more controlled noise that forms
    recognizable patterns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的另一个突出例子是纹理的创建。与地形生成类似，纹理的程序生成使用噪声来创建变化。然后可以用来创建不同的纹理。不同的图案和方程也被用来创建更受控制的噪声，形成可识别的图案。
- en: 'Generating textures procedurally like this means that you can potentially have
    an unlimited number of possible textures without any overhead on storage. From
    a limited pool of initial resources, endless combinations can be generated, an
    example of which can be seen in the following image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样程序性地生成纹理意味着你可以在没有任何存储开销的情况下拥有无限数量的可能纹理。从有限的初始资源池中，可以生成无尽的组合，下面的图像就是一个例子：
- en: '![Texture creation](img/B04920_01_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![纹理创建](img/B04920_01_05.jpg)'
- en: Perlin noise is just one example of the many algorithms that are commonly used
    in procedural generation. The study of these algorithms is beyond the scope of
    this book, but if you want to further explore the use of procedural generation,
    it would be a good place to start.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声只是许多常用于程序生成的算法之一。研究这些算法超出了本书的范围，但如果你想进一步探索程序生成的用途，这将是一个很好的起点。
- en: Animation
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: Traditionally, game animations are created by animators, and then exported as
    an animation file that is ready for use in the game. This file will store the
    various movements that each part of a model will go through during animation.
    It then gets applied to the game character during runtime. The player's current
    state will determine which animation should be playing. For example, when you
    press *A* to jump, the player will change to a jumping state, and the jumping
    animation will be triggered. This system works great, but it is very rigid. Each
    step, jump, and roll is identical.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，游戏动画是由动画师创建的，然后导出为一个动画文件，可以直接在游戏中使用。这个文件将存储模型的每个部分在动画期间经历的各种动作。然后在运行时应用到游戏角色上。玩家当前的状态将决定应该播放哪种动画。例如，当你按下*A*键跳跃时，玩家将变为跳跃状态，并触发跳跃动画。这个系统运行良好，但非常死板。每一步、跳跃和翻滚都是相同的。
- en: However, procedural generation can be used to create real-time, dynamic animation.
    By taking the current position of the character's skeleton and calculating the
    multiple forces that are being imparted upon it, a new position can be calculated.
    The most prominent example of procedural animation is ragdoll physics.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序生成可以用来创建实时的、动态的动画。通过获取角色骨骼的当前位置，并计算施加在它上面的多个力，可以计算出一个新的位置。程序动画最突出的例子是布娃娃物理效果。
- en: Sound
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音
- en: Although less common than the previous examples, procedural generation is also
    used to create game sounds. This will commonly be in the form of manipulating
    existing sounds. For example, sound can be spatialized, meaning it appears to
    be coming from a specific position when heard by the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不如前面的例子常见，程序生成也被用来创建游戏音效。这通常是通过操纵现有的声音来实现的。例如，声音可以被空间化，意味着当用户听到时，它似乎是来自特定位置。
- en: At a stretch, short, one-shot sound effects may be synthesized, but due to the
    little benefit that it brings as compared to the amount of work needed to implement
    it, it's seldom used. It's simply much easier to load premade sounds.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，可以合成短暂的、一次性的音效，但由于它所带来的好处与实施它所需的工作量相比很少，它很少被使用。加载预制的声音会更容易得多。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sfxr is a small program that generates random sound effects from scratch. Its
    source is available. So, if sound synthesis interests you, it will serve as a
    good starting point. You can find the project at [https://github.com/grimfang4/sfxr](https://github.com/grimfang4/sfxr).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Sfxr是一个小程序，可以从头开始生成随机音效。它的源代码是可用的。因此，如果你对声音合成感兴趣，它将作为一个很好的起点。你可以在[https://github.com/grimfang4/sfxr](https://github.com/grimfang4/sfxr)找到这个项目。
- en: Benefits of procedural generation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成的好处
- en: We've looked at some of the key ways in which procedural generation is used
    in games. So now let's take a look at some of its most important benefits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看了一些程序生成在游戏中的关键用途。现在让我们来看看它的一些最重要的好处。
- en: Larger games can be created
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以创建更大的游戏
- en: 'If your game world is hand-built, it''s going to have size restrictions for
    a number of reasons. Every object needs to be placed manually, every texture/model
    needs to be handcrafted, and so on. All of this takes time and money. Even the
    largest handcrafted game''s world sizes, such as those seen in The *The Witcher
    3: Wild Hunt* and *Grand Theft Auto V*, pale in comparison to what procedurally
    generated worlds can achieve.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏世界是手工建造的，由于种种原因，它将有大小限制。每个物体都需要手动放置，每个纹理/模型都需要手工制作，等等。所有这些都需要时间和金钱。即使是最大的手工制作游戏世界的大小，比如《巫师3：狂猎》和《侠盗猎车手V》中所见的那样，也远远不及程序生成的世界可以实现的规模。
- en: If a game utilizes procedural generation correctly, then theoretically, there
    is no limit to the world size. For example, *No Man's Sky* is a science-fiction
    game set in an infinite, procedurally generated galaxy. When you start to get
    really big maps however, hardware becomes a limiting factor. Areas that have been
    generated need to be saved to the disk in order to revisit them, and this quickly
    adds up. For example, to generate the biggest world possible in Minecraft, you
    will need around 409 petabytes of storage for the level data!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个游戏正确地利用程序生成，理论上，世界的大小是没有限制的。例如，《无人之境》是一个设定在一个无限的、程序生成的银河系中的科幻游戏。然而，当你开始制作真正巨大的地图时，硬件成为了一个限制因素。生成的区域需要保存到磁盘中以便重新访问，这很快就会累积起来。例如，要在《我的世界》中生成最大的世界，你将需要大约409PB的存储空间来存储关卡数据！
- en: Procedural generation can be used to lower budgets
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序生成可以用来降低预算。
- en: Making games is expensive. Really expensive. In fact, most AAA games cost tens,
    if not hundreds, of millions of dollars to make. With budgets that are this high,
    any option to save money is welcome. Procedural generation can do just that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏是昂贵的。非常昂贵。事实上，大多数AAA游戏的制作成本高达数千万，甚至数亿美元。在这么高的预算下，任何节省金钱的选择都是受欢迎的。程序生成可以做到这一点。
- en: Let's say that we are working on a title that needs 100 brick textures. Traditionally,
    you'd have one of your artists create each brick. While they will have top quality,
    this will cost both time and money. Alternately, by utilizing procedural generation
    techniques, you can have an artist create a handful of resources and use them
    to generate however many resources you need to use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在制作一个需要100种砖块纹理的游戏。传统上，你需要让你的艺术家创建每一块砖。虽然它们会有最高质量，但这将耗费时间和金钱。另外，通过利用程序生成技术，你可以让一个艺术家创建一些资源，并使用它们来生成你需要使用的资源。
- en: This is just one example, and the same goes for modeling, design, and so on.
    There are pros and cons of using procedural generation in this way, but it's a
    valid option.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，建模、设计等也是如此。以这种方式使用程序生成有利有弊，但这是一个有效的选择。
- en: An increase in gameplay variety
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏玩法的多样性增加
- en: If your game world is handmade, the experience that players have is going to
    be fixed. Everyone will collect the same items, the terrain will be the same,
    and as a result, the overall experience will be the same. The defining feature
    of procedurally generated games is that experiences differ. There is a sense of
    unknown to the game, and every time you play, there will be something new waiting
    that you haven't encountered yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏世界是手工制作的，那么玩家的体验将是固定的。每个人都会收集相同的物品，地形都是一样的，因此整体体验也将是一样的。程序生成游戏的显著特点是体验不同。游戏中有一种未知的感觉，每次玩都会有一些新的东西等着你去发现。
- en: An increase in replayability
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加了可重复性
- en: Let's continue from the last point. If a game is linear, without any procedural
    generation, the challenge is gone after you've played the game once. You know
    the plot, you know where the enemies will be, and unless it has an amazing story
    or mechanics, there's not much reason why you'd want to play the game again.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一点继续。如果一个游戏是线性的，没有任何程序生成，那么在玩过一次游戏后挑战就消失了。你知道情节，你知道敌人会在哪里，除非它有一个惊人的故事或机制，否则你不会想再玩一次游戏。
- en: However, if your game utilizes procedural generation, then the challenge is
    fresh each time the game is run. The game is always evolving; the environments
    are always new. If you look at the games that have the greatest replayability,
    they tend to be the ones that give the player the greatest amount of control.
    Most of these games will utilize some form of procedural generation to do so.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的游戏利用程序生成，那么每次运行游戏时挑战都是新的。游戏总是在不断发展；环境总是新的。如果你看看那些具有最大重玩价值的游戏，它们往往是给玩家最大控制权的游戏。大多数这类游戏都会利用某种形式的程序生成来实现。
- en: The drawbacks of procedural generation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成的缺点
- en: As with anything, there are two sides to a story. Procedural generation brings
    a myriad of possibilities and enhancements to games, but there are considerations
    to be taken when implementing it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何事物一样，事情都有两面性。程序生成为游戏带来了无数可能性和增强，但在实施时也需要考虑一些因素。
- en: More taxing on the hardware
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对硬件的负担更重
- en: As we now know, procedural generation is the creation of content through running
    algorithms. These algorithms can be intense and require a lot of computing power.
    If you develop a game that makes heavy use of procedural generation, you need
    to ensure that a regular consumer PC or console is able to meet its demands.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知，程序生成是通过运行算法来创建内容。这些算法可能非常复杂，需要大量的计算能力。如果你开发的游戏大量使用程序生成，你需要确保普通消费者的PC或游戏机能够满足其需求。
- en: For example, if you choose to generate trees procedurally in an open world game,
    there's going to be a big load on the CPU and GPU whenever that area needs to
    be generated. Lesser PCs might not have the power to do so, and therefore, they
    may stutter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你选择在开放世界游戏中以程序方式生成树木，那么每当该区域需要生成时，CPU和GPU的负担都会很大。性能较差的电脑可能无法胜任，因此游戏可能会出现卡顿。
- en: Worlds can feel repetitive
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界可能会感到重复
- en: Another potential drawback is the fact that worlds can feel repetitive. If you
    allow your game system to generate incredibly large worlds, but use few and basic
    algorithms to do so, you'll inevitably have a lot of repetitive areas being generated.
    Patterns and repeating areas will be very easy to spot, and this will diminish
    from your game greatly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的缺点是世界可能会感到重复。如果你允许游戏系统生成非常大的世界，但使用了少量和基本的算法，那么必然会生成很多重复的区域。模式和重复的区域会很容易被发现，这将大大降低游戏的质量。
- en: You sacrifice quality control
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你牺牲了质量控制
- en: Computers may be faster at crunching numbers than us humans, but there's one
    thing that we're vastly superior at, and that's creativity. No matter how amazing
    the procedural algorithm is, you lose the human touch. The little changes and
    subtleties that a seasoned designer can bring to a project are sacrificed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可能比我们人类更快地进行数字计算，但有一件事我们绝对比计算机优秀，那就是创造力。无论程序算法有多么神奇，都无法取代人类的触感。经验丰富的设计师为项目带来的微小变化和细微差别都会因此而牺牲。
- en: It also means that you can't guarantee the same gameplay quality to all players.
    Some players may generate a really great map that facilitates gameplay, while
    others may generate a map that actively prohibits it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你无法保证所有玩家都能获得相同的游戏质量。有些玩家可能会生成一个非常棒的地图，有利于游戏进行，而其他人可能生成一个明显阻碍游戏进行的地图。
- en: You may generate an unplayable world
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你可能会生成一个无法玩的世界
- en: In extreme cases of the previous point, a level that is completely unplayable
    may be generated. The risk of this happening depends on how well your procedural
    content is generated, but it should always be considered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一点的极端情况下，可能会生成一个完全无法玩的关卡。这种风险取决于你的程序内容生成得有多好，但这一点应该始终被考虑。
- en: When generating a 3D terrain map, you may accidently generate a terrain that
    is too high for the player to climb, or blocks off an area that needs to be accessible.
    The same goes for a 2D map. Later in this book we'll be generating dungeon rooms
    randomly. So for example, we need to ensure that each room has a valid entrance
    and exit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成3D地形地图时，你可能会意外生成一个对玩家来说太高无法攀爬的地形，或者封锁了需要进入的区域。2D地图也是如此。在本书的后面，我们将随机生成地牢房间。例如，我们需要确保每个房间都有有效的入口和出口。
- en: It is hard to script set game events
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 很难编写固定的游戏事件
- en: Continuing with the previous point, procedural generation is uncertain. If the
    entire world around you is generated exclusively procedurally and randomly, then
    it makes it almost impossible to script fixed game events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的观点，程序生成是不确定的。如果你周围的整个世界都是纯粹通过程序和随机生成的，那么几乎不可能编写固定的游戏事件。
- en: Game events are pre-scripted events, and the nature of procedural generation
    is to create unscripted worlds. Getting the two to work together is a tough challenge.
    For this reason, games tend to use a mix of procedural generation and premade
    game development. With this, you get the fixed game events and moments that are
    needed to drive a narrative, and in between all of this, you create a unique and
    open world for the player to explore and interact with at their own whim.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏事件是预先编写的事件，而程序生成的本质是创建未经脚本的世界。让这两者共同工作是一个艰巨的挑战。因此，游戏往往会同时使用程序生成和预先制作的游戏开发。通过这样，你可以得到固定的游戏事件和时刻，这些是驱动叙事所需要的，而在所有这些之间，你可以为玩家创造一个独特和开放的世界，让他们自由地探索和互动。
- en: A brief history of rogue-like games
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rogue-like游戏的简要历史
- en: Since we're going to implement what we are learning in a rogue-like, let's just
    take a second to look at their history. It's always great to understand the origins
    of the things that you are doing!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将实现我们所学的内容在一个类似Rogue的游戏中，让我们花一点时间来看看它们的历史。了解你所做的事情的起源总是很好的！
- en: Rogue is a dungeon crawling game that was first developed by *Michael Toy* and
    *Glenn Wichman* and initially released in 1980\. Every level of the dungeon was
    randomly generated along with the positions of the object within. Rogue defined
    the dungeon crawling genre and was the inspiration for many titles that followed.
    This is why we call games of this type **roguelikes**, because they are literally
    like Rogue!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Rogue是一款地牢爬行游戏，最初由*Michael Toy*和*Glenn Wichman*开发，并于1980年首次发布。地牢的每个级别都是随机生成的，其中包括对象的位置。Rogue定义了地牢爬行类型，并成为许多后续游戏的灵感来源。这就是为什么我们称这种类型的游戏为**roguelikes**，因为它们确实像Rogue！
- en: Procedural generation has been a key element in roguelikes since their conception.
    This is why I chose the genre to introduce the topic. Together, we will recreate
    the iconic features that define the genre, and approach procedural generation
    with a very practical and hands-on approach.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自从诞生以来，程序生成一直是Roguelike游戏的关键元素。这就是为什么我选择这种类型的游戏来介绍这个主题。我们将一起重新创建定义这种类型游戏的标志性特征，并以非常实际和动手的方式来处理程序生成。
- en: How we'll implement procedural generation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将如何实现程序生成
- en: At the very start of the book I gave a brief overview of each chapter and what
    we will be covering in it. Now that we've covered what procedural generation is,
    let's take a look specifically at some of the ways in which we'll be implementing
    it as we work towards creating our own roguelike game. This list is not exhaustive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的开头，我简要概述了每一章和我们将在其中涵盖的内容。现在我们已经了解了程序生成是什么，让我们具体看看一些我们将实施它的方式，因为我们努力创建我们自己的Roguelike游戏。这个列表并不详尽。
- en: Populating environments
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充环境
- en: When we load the game for the first time our objects will be in fixed locations.
    We're going to start our efforts by fixing this, implementing what we've learned
    in this chapter about random number generation to spawn our objects at random
    locations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次加载游戏时，我们的对象将处于固定位置。我们将通过实现本章学到的关于随机数生成的知识来开始我们的努力，以在随机位置生成我们的对象。
- en: At the end of this chapter there are a few optional exercises that include generating
    numbers within a collection of different ranges. I suggest completing them if
    you're not comfortable with it already, as we'll be relying on it to achieve this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，有一些可选的练习，包括在不同范围的集合中生成数字。如果你还不熟悉，我建议完成它们，因为我们将依靠它来实现这一点。
- en: Creating unique game objects
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独特的游戏对象
- en: One of my personal favorite aspects of procedural generation is the creation
    of unique objects and items. Knowing that there is a wide variety of items in
    a game is awesome. Knowing that the items don't even exist yet, and that the possibilities
    are limitless, is even better!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的我个人最喜欢的一个方面是创建独特的对象和物品。知道游戏中有各种各样的物品是很棒的。知道这些物品甚至还不存在，而且可能性是无限的，更好！
- en: We'll start simply by initializing our object's member variables randomly, and
    move up to giving our objects unique sprites and properties. We'll also look at
    creating dynamic classes that can create highly unique objects from a single base
    class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单地随机初始化对象的成员变量开始，然后逐步提供我们对象独特的精灵和属性。我们还将研究创建动态类，可以从单个基类创建高度独特的对象。
- en: Creating unique art
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建独特的艺术
- en: Generating textures and materials from scratch using procedural generation is
    a very large subject. There are lots of ways by which this can be achieved. Traditionally,
    we use things such as Perlin noise as their basis function and then build upon
    it with patterns and colors. We're not going to go into this topic to this extent.
    Instead, we're going to use the built-in image processing features of **Simple
    and Fast Multimedia Library** (**SFML**) to create unique textures during the
    runtime.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序生成从头开始生成纹理和材料是一个非常庞大的主题。有很多方法可以实现这一点。传统上，我们使用像Perlin噪声这样的基础函数，然后用图案和颜色进行扩展。我们不会深入探讨这个话题。相反，我们将使用**Simple
    and Fast Multimedia Library** (**SFML**)的内置图像处理功能，在运行时创建独特的纹理。
- en: Starting with a simple approach, we'll change image properties such as size,
    color, and scale to create a variation in the existing assets. We'll then use
    render textures to combine multiple sprite components on the fly to create unique
    assets for our enemies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的方法开始，我们将改变图像属性，如大小、颜色和比例，以创建现有资产的变化。然后，我们将使用渲染纹理来动态组合多个精灵组件，以创建我们敌人的独特资产。
- en: Audio manipulation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频操作
- en: As with graphics, SFML offers a number of functions that allow us to modify
    sounds. Therefore, we'll use these to alter the pitch and volume of our sound
    effects to create variance. We'll then use advanced functions to create 3D spatialized
    sound, bringing depth to the scene through our audio.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形一样，SFML提供了许多函数，允许我们修改声音。因此，我们将使用这些来改变声音效果的音调和音量，以创建变化。然后，我们将使用高级函数来创建3D空间化声音，通过我们的音频为场景带来深度。
- en: Behavior and mechanics
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为和机械
- en: It's not just the static items and resources that can be generated procedurally.
    To add more variance to our gameplay, we'll use some procedural techniques to
    create dynamic gameplay mechanics. Specifically, we'll create a system that will
    generate a random goal for the player, and present them with a random reward should
    that goal be achieved.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅是静态物品和资源可以通过程序生成，为了增加游戏玩法的多样性，我们将使用一些程序技术来创建动态的游戏机制。具体来说，我们将创建一个系统，为玩家生成一个随机目标，并在达成目标时提供一个随机奖励。
- en: We'll also give our enemies some basic **Artificial Intelligence** (**AI**)
    in the form of **A Star** (**A***)pathfinding, allowing them to chase a player
    through the level.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将给我们的敌人一些基本的**人工智能**（**AI**），以**A星**（**A***）寻路的形式，让它们能够在关卡中追逐玩家。
- en: Dungeon generation
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地牢生成
- en: Towards the end of the book, once we're comfortable using **Random Number Generator**
    (**RNG**) with procedural systems, and with our game project, we are going to
    implement the defining feature of roguelikes; randomly generated dungeons.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后，一旦我们熟练掌握了使用**随机数生成器**（**RNG**）和程序系统，以及我们的游戏项目，我们将实现roguelike的定义特征；随机生成的地牢。
- en: I've mentioned a few times that procedural generation can be used to create
    theoretically never-ending game worlds. So, we're going to do just that. We'll
    implement a system where every room that we visit is generated randomly, and we'll
    give each floor a distinct feel using the graphics manipulation techniques we'll
    learn in later chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到程序生成可以用来创建理论上无尽的游戏世界。因此，我们将实现一个系统，我们访问的每个房间都是随机生成的，并且我们将使用我们在后面章节学到的图形操作技术为每个楼层赋予独特的感觉。
- en: Component-based design
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组件的设计
- en: Procedural generation is all about creating dynamic systems, objects, and data.
    Therefore, it makes sense that we want the most flexible game framework that we
    can have so that it incorporates this well. One of the ways to achieve this is
    through component-based design. Therefore, to end our work, we're going to take
    a quick look at it, breaking our project down into a more component-based approach.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成就是关于创建动态系统、对象和数据。因此，我们希望拥有最灵活的游戏框架，以便很好地整合这一点。实现这一点的方法之一是组件化设计。因此，最后，我们将快速地看一下它，将我们的项目分解为更多基于组件的方法。
- en: The complete game
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的游戏
- en: These are the major systems changes that we'll implement. There will be lots
    in-between, but these examples will cover the major mechanics and skills that
    we will be using. When we reach the end of the book, you will have a fully working
    roguelike with an endless dungeon that is randomly generated, randomly generated
    items that spawn in random locations, procedural textures throughout the dungeon
    levels, and random enemies, all implemented with a flexible component-based architecture.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要实现的主要系统变化。中间会有很多内容，但这些例子将涵盖我们将使用的主要机制和技能。当我们到达书的末尾时，你将拥有一个完全可用的roguelike游戏，其中包括一个无尽的随机生成地牢，随机生成的物品出现在随机位置，地牢层中的程序纹理，以及随机敌人，所有这些都是使用灵活的基于组件的架构实现的。
- en: You will not only learn the skills needed to implement procedural generation
    in your own games, but also see how they all work in the context of one-another.
    Isolated exercises are great, but nothing beats working on a real-world example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅会学习实现程序生成在你自己的游戏中所需的技能，还会看到它们如何在彼此的背景下运作。孤立的练习很好，但没有什么比在一个真实的例子上工作更好。
- en: Exercises
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To enable you to test your knowledge of this chapter's content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you access your strengths and weaknesses in
    the material covered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你测试本章内容的知识，这里有一些练习供你做。它们对本书的其余部分并不是必需的，但做这些练习将帮助你评估所学内容的优势和劣势。
- en: 'Using the `std::rand()` function with the modulo operator (%), for updating
    `random_numbers.cpp` to generate numbers that fall within the following ranges:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::rand()`函数和取模运算符（%），更新`random_numbers.cpp`以生成落在以下范围内的数字：
- en: 0 to 1000
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0到1000
- en: 150 to 600
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 150到600
- en: 198 to 246
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 198到246
- en: Come up with a new way of generating a random seed during the runtime. There
    are lots of ways to do this. So be creative! In my solution, the first numbers
    were always similar. Find out whether you can generate a random seed that mitigates
    that.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想出一种在运行时生成随机种子的新方法。有很多方法可以做到这一点。所以要有创意！在我的解决方案中，前几个数字总是相似的。看看你是否能生成一个减轻这一点的随机种子。
- en: Have a look at your game collection and find out whether you can identify where
    procedural generation has been used.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看你的游戏收藏，找出哪些地方使用了程序生成。
- en: Which of the following are examples of procedural generation?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是程序生成的例子？
- en: Loading a song
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载一首歌
- en: Ragdoll physics
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布娃娃物理
- en: Creating unique objects during the runtime
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建独特的对象
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that procedural generation is the creation of content
    by using algorithms. This concept can be applied to all digital media and is used
    in games to create dynamic systems and environments. Procedural generation brings
    larger games, variety, and dynamism; all at the cost of lesser control, and potentially
    lesser performance as it is taxing on hardware. Some examples of the most popular
    uses of procedural generation in modern gaming include terrain generation, texture
    creation, and procedural animation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到程序生成是通过使用算法来创建内容。这个概念可以应用于所有数字媒体，并且在游戏中用于创建动态系统和环境。程序生成带来了更大的游戏、多样性和动态性；但控制力较小，可能会影响性能，因为它对硬件要求较高。现代游戏中程序生成最流行的用途包括地形生成、纹理创建和程序动画。
- en: In the next chapter, we will take a look at the project that has been supplied
    with the book. As we learn to create procedural systems, we will be implementing
    them in a real game project, with the ultimate goal of creating a roguelike game,
    a genre that heavily utilizes procedural generation. We will review the game template,
    the SFML modules that we will be using, and get the project setup. Then, we will
    compile it on your system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下本书提供的项目。当我们学习创建程序化系统时，我们将在一个真实的游戏项目中实现它们，最终目标是创建一个使用程序生成的游戏，这是一个大量利用程序生成的类型。我们将回顾游戏模板，我们将使用的SFML模块，并设置项目。然后，我们将在您的系统上编译它。
- en: If you are familiar with C++ game development and have used SFML before, you
    may already be familiar with the concepts presented in the next chapter. If that's
    the case, feel free to skim through the chapter to get right into the programming
    in [Chapter 3](ch03.html "Chapter 3. Using RNG with C++ Data Types"), *Using RNG
    with C++ Data Types*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉C++游戏开发并且以前使用过SFML，您可能已经熟悉下一章中介绍的概念。如果是这种情况，请随意浏览本章，直接进入[第3章](ch03.html
    "第3章。使用C++数据类型的RNG")*使用C++数据类型的RNG*的编程。
