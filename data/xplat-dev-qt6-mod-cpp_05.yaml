- en: '*Chapter 4*: t Quick and QML'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：Qt Quick和QML'
- en: Qt consists of two different modules for developing a **graphical user interface**
    (**GUI**) application. The first approach is to use Qt Widgets and C++, which
    we learned about in the previous chapter. The second approach is to use Qt Quick
    Controls and the **Qt Modeling Language** (**QML**), which we will be covering
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt由两个不同的模块组成，用于开发**图形用户界面**（**GUI**）应用程序。第一种方法是使用Qt Widgets和C++，我们在上一章中学习过。第二种方法是使用Qt
    Quick Controls和**Qt建模语言**（**QML**），我们将在本章中介绍。
- en: In this chapter, you will learn how to use Qt Quick Controls and the QML scripting
    language. You will study how to use Qt Quick Layouts and positioners and make
    a responsive GUI application. You will learn to integrate your backend C++ code
    with frontend QML. You will learn the fundamentals of Qt Quick and QML, and how
    to develop touch-friendly and visual-oriented Qt applications. You will also learn
    about mouse and touch events and how to develop a touch-aware application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Qt Quick Controls和QML脚本语言。您将学习如何使用Qt Quick布局和定位器，并创建一个响应式GUI应用程序。您将学习如何将后端C++代码与前端QML集成。您将学习Qt
    Quick和QML的基础知识，以及如何开发触摸友好和视觉导向的Qt应用程序。您还将学习有关鼠标和触摸事件的知识，以及如何开发一个触摸感知的应用程序。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Getting started with QML and Qt Quick
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用QML和Qt Quick
- en: Understanding Qt Quick Controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qt Quick Controls
- en: Creating a simple Qt Quick application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的Qt Quick应用程序
- en: Designing a **user interface** (**UI**) with Qt Quick Designer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt Quick Designer设计**用户界面**（**UI**）
- en: Positioners and layouts in QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的定位器和布局
- en: Integrating QML with C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将QML与C++集成
- en: Integrating QML with **JavaScript** (**JS**)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将QML与**JavaScript**（**JS**）集成
- en: Handling mouse and touch events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理鼠标和触摸事件
- en: By the end of this chapter, you will understand the basics of QML, integration
    with C++, and how to create your own fluid UI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解QML的基础知识，与C++的集成，以及如何创建自己的流畅UI。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest desktop platforms such as Windows
    10, Ubuntu 20.04, or macOS 10.14.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台上安装Qt 6.0.0和Qt Creator 4.14.0的最低版本，如Windows 10，Ubuntu 20.04或macOS
    10.14。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter04)。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platforms in your machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的屏幕截图来自Windows平台。您将在您的机器上看到基于底层平台的类似屏幕。
- en: Getting started with QML and Qt Quick
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用QML和Qt Quick
- en: QML is a UI markup language. It is a declarative language that is part of the
    Qt framework. It enables the building of fluid and touch-friendly UIs and came
    into existence with the evolution of touchscreen mobile devices. It was created
    to be highly dynamic, where developers can easily create fluid UIs with minimal
    coding. The Qt QML module implements the QML architecture and provides a framework
    for developing applications. It defines and implements the language and infrastructure,
    and provides **application programming interfaces** (**APIs**) to integrate the
    QML language with JS and C++.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: QML是一种UI标记语言。它是Qt框架的一部分，是一种声明性语言。它使得构建流畅且触摸友好的UI成为可能，并随着触摸屏移动设备的发展而出现。它被创建为高度动态的，开发人员可以轻松地使用最少的编码创建流畅的UI。Qt
    QML模块实现了QML架构，并提供了一个开发应用程序的框架。它定义和实现了语言和基础设施，并提供了**应用程序编程接口**（**API**）来将QML语言与JS和C++集成。
- en: Qt Quick provides a library of types and functionality for QML. It comprises
    interactive types, visual types, animations, models, views, and graphics effects.
    It is used for mobile applications where touch input, fluid animations, and user
    experience are crucial. The Qt QML module provides the language and infrastructure
    for QML applications, whereas the Qt Quick module provides many visual elements,
    animation, and many more modules to develop touch-oriented and visually appealing
    applications. Instead of using Qt Widgets for UI design, you can use QML and Qt
    Quick Controls. Qt Quick supports several platforms, such as Windows, Linux, Mac,
    iOS, and Android. You can create a custom class in C++ and port it over to Qt
    Quick to extend its functionality. Furthermore, the language provides a smooth
    integration with C++ and JS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick为QML提供了一系列类型和功能的库。它包括交互类型、可视类型、动画、模型、视图和图形效果。它用于触摸输入、流畅动画和用户体验至关重要的移动应用程序。Qt
    QML模块为QML应用程序提供了语言和基础设施，而Qt Quick模块提供了许多可视元素、动画和许多其他模块，用于开发面向触摸和视觉吸引力的应用程序。您可以使用QML和Qt
    Quick Controls而不是Qt Widgets来设计UI。Qt Quick支持多个平台，如Windows、Linux、Mac、iOS和Android。您可以在C++中创建自定义类，并将其移植到Qt
    Quick以扩展其功能。此外，该语言与C++和JS的集成非常顺畅。
- en: Understanding the QML type system
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解QML类型系统
- en: 'Let''s get familiar with the **QML type system** and various QML types. The
    types in a QML file can originate from various sources. The different types used
    in a QML file are outlined here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉**QML类型系统**和各种QML类型。QML文件中的类型可以来自各种来源。在QML文件中使用的不同类型在这里概述：
- en: Basic types provided natively by QML such as `int`, `bool`, `real`, and `list`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML本身提供的基本类型，如`int`，`bool`，`real`和`list`
- en: JS types such as `var`, `Date`, and `Array`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS类型，如`var`，`Date`和`Array`
- en: QML object types such as `Item`, `Rectangle`, `Image`, and `Component`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML对象类型，如`Item`，`Rectangle`，`Image`和`Component`
- en: Types registered via C++ by QML modules such as `BackendLogic`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过QML模块由C++注册的类型，如`BackendLogic`
- en: Types provided as a QML file, such as `MyPushButton`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为QML文件提供的类型，例如`MyPushButton`
- en: A basic type can contain a simple value such as an `int` or a `bool` type. In
    addition to the native basic types, the Qt Quick module also provides additional
    basic types. The QML engine also supports JS objects and arrays. Any standard
    JS type can be created and stored using the generic `var` type. Please note that
    the `variant` type is obsolete and exists only to support older applications.
    A QML object type is a type from which a QML object can be created. Custom QML
    object types can be defined by creating a `.qml` file that defines the type. QML
    object types can have properties, methods, signals, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型可以包含诸如`int`或`bool`类型的简单值。除了本机基本类型外，Qt Quick模块还提供了其他基本类型。QML引擎还支持JS对象和数组。任何标准JS类型都可以使用通用的`var`类型创建和存储。请注意，`variant`类型已经过时，只存在于支持旧应用程序的情况下。QML对象类型是可以创建QML对象的类型。可以通过创建定义类型的`.qml`文件来定义自定义QML对象类型。QML对象类型可以具有属性、方法、信号等。
- en: 'To use the basic QML types inside your QML file, import the `QtQml` module
    with the following line of code: `import QtQml`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的QML文件中使用基本的QML类型，请使用以下代码行导入`QtQml`模块：`import QtQml`
- en: '`Item` is the base type for all visual elements in Qt Quick. All visual items
    in Qt Quick are inherited from `Item`, which is a transparent visual element that
    can be used as a container. Qt Quick provides `Rectangle` as a visual type to
    draw rectangles, and an `Image` type to display images. `Item` provides a common
    set of properties for the visual elements. We will explore the usage of these
    types throughout the book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`是Qt Quick中所有可视元素的基本类型。Qt Quick中的所有可视项都是从`Item`继承的，它是一个可以用作容器的透明可视元素。Qt
    Quick提供`Rectangle`作为绘制矩形的可视类型，并提供`Image`类型来显示图像。`Item`为可视元素提供了一组通用属性。我们将在整本书中探索这些类型的用法。'
- en: 'You can learn more about QML types at the following link:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解更多关于QML类型的信息：
- en: '[https://doc.qt.io/qt-6/qmltypes.html](https://doc.qt.io/qt-6/qmltypes.html)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qmltypes.html](https://doc.qt.io/qt-6/qmltypes.html)'
- en: In this section, we learned the basics of QML and Qt Quick. In the next section,
    we will discuss Qt Quick Controls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了QML和Qt Quick的基础知识。在下一节中，我们将讨论Qt Quick Controls。
- en: Understanding Qt Quick Controls
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Qt Quick Controls
- en: '**Qt Quick Controls** provides a set of UI elements that can be used to build
    a fluid UI using Qt Quick. To avoid ambiguity with **widgets**, we will use the
    term **controls** for UI elements. **Qt Quick Controls 1** was originally designed
    to support desktop platforms. With the evolution of mobile devices and embedded
    systems, the module required changes to meet performance expectations. Hence,
    **Qt Quick Controls 2** was born, and it further enhanced support for mobile platforms.
    Qt Quick Controls 1 has been deprecated since Qt 5.11 and has been removed from
    Qt 6.0\. Qt Quick Controls 2 is now simply known as Qt Quick Controls.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt Quick Controls**提供了一组UI元素，可用于使用Qt Quick构建流畅的UI。为了避免与**小部件**产生歧义，我们将使用术语**控件**来表示UI元素。**Qt
    Quick Controls 1**最初设计用于支持桌面平台。随着移动设备和嵌入式系统的发展，该模块需要进行更改以满足性能期望。因此，**Qt Quick
    Controls 2**诞生了，并进一步增强了对移动平台的支持。自Qt 5.11起，Qt Quick Controls 1已被弃用，并已从Qt 6.0中删除。Qt
    Quick Controls 2现在简称为Qt Quick Controls。'
- en: 'The QML types can be imported into your application using the following `import`
    statement in your `.qml` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在您的`.qml`文件中使用以下`import`语句导入QML类型：
- en: '`import QtQuick.Controls`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`import QtQuick.Controls`'
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In Qt 6, there are certain changes in the QML import and versioning system.
    The version numbers have been kept optional. If you import a module without specifying
    the version number, then the latest version of the module is imported automatically.
    If you import a module with only the major version number, then the module is
    imported with a specified major version and the latest minor version. Qt 6 introduced
    an `import <module> auto`. This ensures the imported module and importing module
    have the same version number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6中，QML导入和版本控制系统发生了一些变化。版本号现在是可选的。如果导入模块时没有指定版本号，则会自动导入模块的最新版本。如果只导入模块的主要版本号，则会导入指定主要版本和最新次要版本的模块。Qt
    6引入了`import <module> auto`。这确保了导入的模块和导入模块具有相同的版本号。
- en: 'Changes to Qt Quick Controls in Qt 6 can be found at the following link:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Qt 6中Qt Quick Controls的更改，请访问以下链接：
- en: '[https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html](https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html](https://doc.qt.io/qt-6/qtquickcontrols-changes-qt6.html)'
- en: 'Qt Quick Controls offers QML types for creating UIs. Example of Qt Quick Controls
    are given here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Controls提供了用于创建UI的QML类型。这里提供了Qt Quick Controls的示例：
- en: '`ApplicationWindow`: Styled top-level window with support for a header and
    footer'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationWindow`：带有标题和页脚支持的样式化顶层窗口'
- en: '`BusyIndicator`: Indicates background activity—for instance, while content
    is being loaded'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusyIndicator`：指示后台活动，例如内容正在加载时'
- en: '`Button`: Push button that can be clicked to perform a command or answer a
    question'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`：可单击以执行命令或回答问题的推按钮'
- en: '`CheckBox`: Check button that can be toggled on or off'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckBox`：可以切换打开或关闭的复选框'
- en: '`ComboBox`: Combined button and pop-up list for selecting options'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComboBox`：用于选择选项的组合按钮和弹出列表'
- en: '`Dial`: Circular dial that is rotated to set a value'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`拨号`：旋转以设置值的圆形拨号'
- en: '`Dialog`: Pop-up dialog with standard buttons and a title'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对话框`：带有标准按钮和标题的弹出对话框'
- en: '`Label`: Styled text label with inherited font'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`：带有继承字体的样式文本标签'
- en: '`Popup`: Base type of pop-up-like UI controls'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Popup`：类似弹出式UI控件的基本类型'
- en: '`ProgressBar`: Indicates the progress of an operation'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBar`：指示操作进度'
- en: '`RadioButton`: Exclusive radio button that can be toggled on or off'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RadioButton`：可以切换打开或关闭的互斥单选按钮'
- en: '`ScrollBar`: Vertical or horizontal interactive scroll bar'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动条：垂直或水平交互式滚动条
- en: '`ScrollView`: Scrollable view'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`：可滚动视图'
- en: '`Slider`: Used to select a value by sliding a handle along a track'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider`：用于通过沿轨道滑动手柄来选择值'
- en: '`SpinBox`: Allows the user to select from a set of preset values'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpinBox`：允许用户从一组预设值中进行选择'
- en: '`Switch`: Button that can be toggled on or off'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`：可以切换打开或关闭的按钮'
- en: '`TextArea`: Multiline text-input area'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextArea`：多行文本输入区域'
- en: '`TextField`: Single-line text input field'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField`：单行文本输入字段'
- en: '`ToolTip`: Provides tool tips for any control'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolTip`：为任何控件提供工具提示'
- en: '`Tumbler`: Spinnable wheel of items that can be selected'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tumbler`：可旋转的可选择项目的轮子'
- en: 'To configure the Qt Quick Controls module for building with qmake, add the
    following line to the project''s `.pro` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要为qmake构建配置Qt Quick Controls模块，请将以下行添加到项目的`.pro`文件中：
- en: '`QT += quickcontrols2`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT += quickcontrols2`'
- en: In this section, we learned about the different types of UI elements available
    with Qt Quick. In the next section, we will discuss the different styles provided
    by Qt Quick and how to apply them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Qt Quick提供的不同类型的UI元素。在下一节中，我们将讨论Qt Quick提供的不同样式以及如何应用它们。
- en: Styling Qt Quick Controls
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick Controls的样式
- en: 'Qt Quick Controls comes with a standard set of styles. They are listed here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Controls带有一套标准样式。它们在这里列出：
- en: '**Basic**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本
- en: '**Fusion**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**融合**'
- en: '**Imagine**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**想象**'
- en: '**Material**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材料**'
- en: '**Universal**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**'
- en: 'There are two ways to apply styles in Qt Quick Controls, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick Controls中有两种应用样式的方式，如下：
- en: Compile time
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时间
- en: Runtime
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时
- en: 'You can apply a compile-time style by importing the corresponding style module,
    as shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导入相应的样式模块来应用编译时样式，如下所示：
- en: '`import QtQuick.Controls.Universal`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`import QtQuick.Controls.Universal`'
- en: 'You can apply a runtime style by using one of the following approaches:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方法之一应用运行时样式：
- en: '![Figure 4.1 – Different ways to apply a style at runtime'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1-运行时应用样式的不同方法'
- en: '](img/Figure_4.1_B16231.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B16231.jpg)'
- en: Figure 4.1 – Different ways to apply a style at runtime
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1-运行时应用样式的不同方法
- en: In this section, we learned about the available styles in Qt Quick. In the next
    section, we will create our first Qt Quick GUI application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Qt Quick中提供的样式。在下一节中，我们将创建我们的第一个Qt Quick GUI应用程序。
- en: Creating a simple Qt Quick application
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的Qt Quick应用程序
- en: 'Let''s create our first Qt Quick application using Qt 6\. A Hello World program
    is a very simple program that displays `Hello World!`. The project uses minimal—and
    the most basic—code. For this project, we will use the **project skeleton** created
    by Qt Creator. So, let''s begin! Proceed as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Qt 6创建我们的第一个Qt Quick应用程序。Hello World程序是一个非常简单的程序，显示`Hello World!`。该项目使用最少的——和最基本的——代码。对于这个项目，我们将使用Qt
    Creator创建的**项目骨架**。所以，让我们开始吧！按照以下步骤进行：
- en: To create a new Qt Quick application, click on the **File menu** option on the
    menu bar or hit *Ctrl* + *N*. Alternatively, you can also click on the **New Project**
    button located on the welcome screen. Then, a window will pop up for you to choose
    a project template. Select **Qt Quick Application - Empty** and click the **Choose...**
    button, as shown in the following screenshot:![Figure 4.2 – New Qt Quick application
    wizard
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的Qt Quick应用程序，请单击菜单栏上的**文件菜单**选项或按下*Ctrl* + *N*。或者，您也可以单击欢迎屏幕上的**新建项目**按钮。然后，将弹出一个窗口供您选择项目模板。选择**Qt
    Quick Application - Empty**并单击**选择...**按钮，如下截图所示：![图4.2-新的Qt Quick应用程序向导
- en: '](img/Figure_4.2_B16231.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B16231.jpg)'
- en: Figure 4.2 – New Qt Quick application wizard
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2-新的Qt Quick应用程序向导
- en: In the next step, you will be asked to choose a project name and a project location.
    You can navigate to the desired project location by clicking the `SimpleQtQuickApp`.
    Then, click on the **Next** button to proceed to the next screen, as shown in
    the following screenshot:![Figure 4.3 – Project location selection screen
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您将被要求选择项目名称和项目位置。您可以通过单击`SimpleQtQuickApp`导航到所需的项目位置。然后，单击**下一步**按钮继续到下一个屏幕，如下截图所示：![图4.3-项目位置选择屏幕
- en: '](img/Figure_4.3_B16231.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B16231.jpg)'
- en: Figure 4.3 – Project location selection screen
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3-项目位置选择屏幕
- en: In the next step, you can select a kit from a set of kits to build and run your
    project. To build and run a project, at least one kit must be active and selectable.
    Select the default **Desktop Qt 6.0.0 MinGW 64-bit**kit. Click on the **Next**
    button to proceed to the next screen. This can be seen in the following screenshot:![Figure
    4.4 – Kit selection screen
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您可以从一组工具包中选择一个工具包来构建和运行您的项目。要构建和运行项目，至少必须激活并可选择一个工具包。选择默认的**Desktop Qt
    6.0.0 MinGW 64位**工具包。单击**下一步**按钮继续到下一个屏幕。可以在以下截图中看到：![图4.4-工具包选择屏幕
- en: '](img/Figure_4.4_B16231.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B16231.jpg)'
- en: Figure 4.4 – Kit selection screen
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4-工具包选择屏幕
- en: The next step is to add your Qt Quick project to the installed **version control
    system** (**VCS**). You may skip version control for this project. Click on the
    **Finish** button to create a project with the generated files, as shown in the
    following screenshot:![Figure 4.5 – Project management screen
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将您的Qt Quick项目添加到已安装的**版本控制系统**（**VCS**）中。您可以跳过此项目的版本控制。单击**完成**按钮以创建带有生成文件的项目，如下截图所示：![图4.5-项目管理屏幕
- en: '](img/Figure_4.5_B16231.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B16231.jpg)'
- en: Figure 4.5 – Project management screen
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5-项目管理屏幕
- en: Once a project has been created, Qt Creator will automatically open up a file
    from your project, called `main.qml`. You will see a type of script that is very
    different from your usual C/C++ projects, as shown in the following screenshot:![Figure
    4.6 – Code editor screen showing the main.qml file
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，Qt Creator将自动打开项目中的一个文件，名为`main.qml`。您将看到一种与您平常的C/C++项目非常不同的脚本类型，如下截图所示：![图4.6-显示main.qml文件的代码编辑器屏幕
- en: '](img/Figure_4.6_B16231.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.6_B16231.jpg)'
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the `QQuickView` class, which provides a window for displaying
    a Qt Quick UI. This approach is little old. `QQmlApplicationEngine` has a convenient
    central application functionality with QML, whereas `QQuickView` is normally controlled
    from C++. The following code snippet shows how to use `QQuickView` to load a `.qml`
    file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`QQuickView`类，它提供了一个用于显示Qt Quick UI的窗口。这种方法有点老了。`QQmlApplicationEngine`具有方便的QML中央应用功能，而`QQuickView`通常是从C++控制的。以下代码片段显示了如何使用`QQuickView`来加载`.qml`文件：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`QQuickView` doesn''t support using `Window` as a root item. If you want to
    create your root window from QML, then opt for `QQmlApplicationEngine`. While
    using `QQuickView`, you can directly use any Qt Quick element, as shown in the
    following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`QQuickView`不支持将`Window`作为根项。如果您想要从QML创建您的根窗口，那么选择`QQmlApplicationEngine`。在使用`QQuickView`时，您可以直接使用任何Qt
    Quick元素，如下面的代码片段所示：'
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, you can build and run the Qt Quick project by clicking on the green arrow
    button located at the bottom-left corner of the **integrated development environment**
    (**IDE**), as shown in the following screenshot:![Figure 4.7 – The build and run
    option in Qt Creator
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以通过点击位于**集成开发环境**（**IDE**）左下角的绿色箭头按钮来构建和运行Qt Quick项目，如下截图所示：![图4.7 – Qt
    Creator中的构建和运行选项
- en: '](img/Figure_4.7_B16231.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B16231.jpg)'
- en: Figure 4.7 – The build and run option in Qt Creator
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – Qt Creator中的构建和运行选项
- en: 'Now, hit the **Run** button to build and run the application. Soon, you will
    see a UI with **Hello World!**, as shown in the following screenshot:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**运行**按钮来构建和运行应用程序。很快，您将会看到一个带有**Hello World!**的UI，如下截图所示：
- en: '![Figure 4.8 – Output of the Hello World UI'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – Hello World UI的输出'
- en: '](img/Figure_4.8_B16231.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B16231.jpg)'
- en: Figure 4.8 – Output of the Hello World UI
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – Hello World UI的输出
- en: 'You can run the application from the command line on Windows, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Windows的命令行中运行应用程序，如下所示：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also run the application from the command line on Linux distributions,
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在Linux发行版的命令行中运行应用程序，如下所示：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In command-line mode, you may see a few error dialogs if the libraries are
    not found in the application path. You can copy the Qt libraries and plugin files
    to that binary folder to resolve the issue. To avoid these issues, we will stick
    to Qt Creator to build and run our sample programs. You can switch between different
    kits by going to the project interface and selecting a kit based on your preferences.
    Please remember that you need to run `qmake` after you make changes to your `.pro`
    file. If you are using the command line, then proceed with the following commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行模式下，如果在应用程序路径中找不到库文件，您可能会看到一些错误对话框。您可以将Qt库和插件文件复制到二进制文件夹中以解决这个问题。为了避免这些问题，我们将坚持使用Qt
    Creator来构建和运行我们的示例程序。您可以通过转到项目界面并根据您的偏好选择一个工具包来在不同的工具包之间切换。请记住，在对`.pro`文件进行更改后，您需要运行`qmake`。如果您正在使用命令行，则继续执行以下命令：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also create a Qt Quick 2 UI project with a QML entry point without
    using any C++ code. To use it, you need to have a QML runtime environment such
    as `qmlscene` set up. Qt Creator uses `.qmlproject` to handle QML-only projects:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个带有QML入口点的Qt Quick 2 UI项目，而不使用任何C++代码。要使用它，您需要设置一个QML运行时环境，比如`qmlscene`。Qt
    Creator使用`.qmlproject`来处理仅包含QML的项目：
- en: To create a Qt Quick 2 UI project, select **Qt Quick 2 UI Prototype** from the
    new project template screen, as shown in the following screenshot:![Figure 4.9
    – Qt Quick UI Prototype wizard
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Qt Quick 2 UI项目，从新项目模板屏幕中选择**Qt Quick 2 UI Prototype**，如下截图所示：![图4.9 – Qt
    Quick UI Prototype向导
- en: '](img/Figure_4.9_B16231.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16231.jpg)'
- en: Figure 4.9 – Qt Quick UI Prototype wizard
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – Qt Quick UI Prototype向导
- en: Continue clicking the `QtQuickUIPrototype.qmlproject` and `QtQuickUIPrototype.qml`
    Qt Creator-generated files.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续点击`QtQuickUIPrototype.qmlproject`和`QtQuickUIPrototype.qml`这两个由Qt Creator生成的文件。
- en: Let's modify the contents of `QtQuickUIPrototype.qml` to add a `Text` element
    and display `Hello World!`, as illustrated in the following screenshot:![Figure
    4.10 – Sample contents of Qt Quick UI Prototype project
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`QtQuickUIPrototype.qml`的内容，添加一个`Text`元素并显示`Hello World!`，如下截图所示：![图4.10
    – Qt Quick UI Prototype项目的示例内容
- en: '](img/Figure_4.10_B16231.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16231.jpg)'
- en: Figure 4.10 – Sample contents of Qt Quick UI Prototype project
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – Qt Quick UI Prototype项目的示例内容
- en: Now, hit the **Run** button to build and run the application. Soon, you will
    see a UI with **Hello World!**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**运行**按钮来构建和运行应用程序。很快，您将会看到一个带有**Hello World!**的UI。
- en: 'You can also run the application from the command line, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在命令行中运行应用程序，如下所示：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may have to mention `qmlscene` and the `qml` file path in the command line.
    Use this only if you are prototyping. You cannot create a full application with
    this. Consider using a Qt Quick application project instead for a full application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要在命令行中提到`qmlscene`和`qml`文件路径。只有在原型设计时才使用这个。您不能用这个来创建一个完整的应用程序。考虑使用Qt Quick应用程序项目来创建一个完整的应用程序。
- en: In this section, we learned how to create a simple GUI using the Qt Quick module.
    In the next section, we will learn how to design a custom UI using the Qt Quick
    Designer UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Qt Quick模块创建一个简单的GUI。在下一节中，我们将学习如何使用Qt Quick Designer UI设计自定义UI。
- en: Designing a UI with Qt Quick Designer
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Quick Designer设计UI
- en: 'In this section, you will learn how to use Qt Quick Designer to design your
    UI. Similar to the `.ui` file in Qt Widgets, you can also create a UI file in
    QML. The file has a `.ui.qml` file extension. There are two types of QML file:
    one with a `.qml` extension and another with a `.ui.qml` extension. The QML engine
    treats it as a standard `.qml` file, but it prohibits the logical implementation
    inside it. It creates a reusable UI definition for multiple `.qml` files. Through
    the separation of UI definition and logical implementation, it enhances the maintainability
    of QML code.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Qt Quick Designer设计您的UI。与Qt Widgets中的`.ui`文件类似，您也可以在QML中创建一个UI文件。该文件具有`.ui.qml`文件扩展名。有两种类型的QML文件：一种是`.qml`扩展名，另一种是`.ui.qml`扩展名。QML引擎将其视为标准的`.qml`文件，但禁止其中的逻辑实现。它为多个`.qml`文件创建了可重用的UI定义。通过分离UI定义和逻辑实现，增强了QML代码的可维护性。
- en: 'Let''s get familiar with Qt Quick Designer''s interface before we start learning
    how to design our own UI. The following screenshot shows different sections of
    Qt Quick Designer. We will gradually learn about these sections while designing
    our UI:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习如何设计自己的UI之前，让我们熟悉一下Qt Quick Designer的界面。以下截图显示了Qt Quick Designer的不同部分。在设计我们的UI时，我们将逐渐了解这些部分：
- en: '![Figure 4.11 – Sections of Qt Quick Designer''s UI'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 - Qt Quick Designer界面的各个部分'
- en: '](img/Figure_4.11_B16231.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16231.jpg)'
- en: Figure 4.11 – Sections of Qt Quick Designer's UI
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 - Qt Quick Designer界面的各个部分
- en: 'Qt Quick Designer''s UI consists of the following major sections:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Designer的界面包括以下主要部分：
- en: '**Navigator**: This lists the items in the current QML file as a tree structure.
    It''s similar to the **Object Operator** window in Qt Designer that we learned
    about in the last chapter.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航器**：将当前QML文件中的项目列为树结构。这类似于我们在上一章中学习的Qt Designer中的**对象操作器**窗口。'
- en: '**Control Library**: This window shows all the Qt Quick controls available
    in QML. You can drag and drop the controls to the canvas window to modify your
    UI.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控件库**：此窗口显示了QML中所有可用的Qt Quick控件。您可以将控件拖放到画布窗口中，以修改您的UI。'
- en: '**Resources**: This displays all the resources in a list that can then be used
    for the UI design.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：显示了可以用于UI设计的所有资源的列表。'
- en: '**Import Browser**: The **Import Browser** facilitates the importing of different
    QML modules into the current QML file, to add new functionality to your QML project.
    You can also create your own custom QML module and import in from here.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入浏览器**：**导入浏览器**便于将不同的QML模块导入到当前QML文件中，以为您的QML项目添加新功能。您还可以创建自己的自定义QML模块，并从这里导入。'
- en: '**Text Editor**: This has six tool buttons, each for a specific action, such
    as copy and paste.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本编辑器**：有六个工具按钮，每个按钮都用于特定操作，如复制和粘贴。'
- en: '**Property Editor**: This is similar to the property editor of Qt Designer.
    The **Properties** section in Qt Quick Designer displays the properties of the
    selected item. You can also change the properties of the items in the **Text Editor**.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性编辑器**：类似于Qt Designer中的属性编辑器。Qt Quick Designer中的**属性**部分显示了所选项目的属性。您还可以在**文本编辑器**中更改项目的属性。'
- en: '**Form Editor**: The **Form Editor** is a canvas where you design a UI for
    your Qt Quick application.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单编辑器**：**表单编辑器**是一个画布，您可以在其中为Qt Quick应用程序设计UI。'
- en: '**State Editor**: This window lists the different states in a QML project,
    and describes UI definitions and their behavior.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态编辑器**：此窗口列出了QML项目中的不同状态，并描述了它们的UI定义和行为。'
- en: '**Connection Editor**: This section is similar to the **Signal/Slot Editor**
    in Qt Designer. Here, you can define the signals and slots mechanism for your
    QML component.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接编辑器**：此部分类似于Qt Designer中的**信号/槽编辑器**。在这里，您可以为您的QML组件定义信号和槽机制。'
- en: 'You are now familiar with the Qt Quick Designer UI. Let''s create a Qt Quick
    UI file and explore the Qt Quick controls, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经熟悉了Qt Quick Designer UI。让我们创建一个Qt Quick UI文件，并探索Qt Quick控件，如下所示：
- en: To create a Qt Quick UI, select `ui.qml` file extension. By default, Qt Creator
    will open up Qt Quick Designer. You can switch to code-editing mode by clicking
    the **Edit** button on the left-side panel:![Figure 4.12 – QtQuick UI File wizard
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个Qt Quick UI，选择`ui.qml`文件扩展名。默认情况下，Qt Creator将打开Qt Quick Designer。您可以通过单击左侧面板上的**编辑**按钮切换到代码编辑模式：![图4.12
    - QtQuick UI文件向导
- en: '](img/Figure_4.12_B16231.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16231.jpg)'
- en: Figure 4.12 – QtQuick UI File wizard
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 - QtQuick UI文件向导
- en: Let's add a few QML elements to the `Item`, `Rectangle`, `Image`, `Text`, and
    so on. `Item` is a transparent UI element that can be used as a container:![Figure
    4.13 – Qt Quick Designer showing basic QML types
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`Item`、`Rectangle`、`Image`、`Text`等添加一些QML元素。`Item`是一个可以用作容器的透明UI元素：![图4.13
    - Qt Quick Designer显示基本的QML类型
- en: '](img/Figure_4.13_B16231.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16231.jpg)'
- en: Figure 4.13 – Qt Quick Designer showing basic QML types
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 - Qt Quick Designer显示基本的QML类型
- en: By default, the library contains only a few basic QML types. You can import
    Qt Quick modules to Qt Quick Designer through the QML `QtQuick.Controls` packages,
    as shown in the next screenshot:![Figure 4.14 – Qt Quick Designer showing the
    QML module import option
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，库只包含一些基本的QML类型。您可以通过QML `QtQuick.Controls`包将Qt Quick模块导入到Qt Quick Designer中，如下一张截图所示：![图4.14
    - Qt Quick Designer显示了QML模块导入选项
- en: '](img/Figure_4.14_B16231.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16231.jpg)'
- en: Figure 4.14 – Qt Quick Designer showing the QML module import option
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 - Qt Quick Designer显示了QML模块导入选项
- en: 'Once the module is imported, you can see a section with **Qt Quick - Controls
    2** in the library, as illustrated in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入模块，您就可以在库中看到一个带有**Qt Quick - Controls 2**的部分，如下一张截图所示：
- en: '![Figure 4.15 – Qt Quick Designer showing Qt Quick Controls'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15 - Qt Quick Designer显示Qt Quick控件'
- en: '](img/Figure_4.15_B16231.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16231.jpg)'
- en: Figure 4.15 – Qt Quick Designer showing Qt Quick Controls
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 - Qt Quick Designer显示Qt Quick控件
- en: In this section, we got familiar with Qt Quick Designer's interfaces. In the
    next section, you will learn about different positioners and layouts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们熟悉了Qt Quick Designer的界面。在下一节中，您将学习不同的定位器和布局。
- en: Positioners and layouts in QML
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的位置器和布局
- en: There are different ways to position items in QML. You can manually position
    a control by mentioning *x* and *y* coordinates or by using anchors, positioners,
    or layouts. Let's discuss how to position a control through the aforementioned
    methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中有不同的定位项目的方法。您可以通过提及*x*和*y*坐标或使用锚点、位置器或布局手动定位控件。让我们讨论如何通过上述方法定位控件。
- en: Manual positioning
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动定位
- en: A control can be positioned at specific *x* and *y* coordinates by setting their
    corresponding *x* and *y* properties. As per the visual coordinate system rules,
    this will position the controls relative to the top-left corner of their parent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置相应的*x*和*y*属性，可以将控件定位在特定的*x*和*y*坐标上。根据视觉坐标系统规则，这将使控件相对于其父级的左上角定位。
- en: 'The following code snippet shows how to place a `Rectangle` item at position
    (`50,50`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何将`Rectangle`项目放置在位置(`50,50`)处：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you run the preceding code, you will see a blue rectangle created at the
    (`50,50`) position. Change the `x` and `y` values and you will see how the position
    is changed relative to the top-left corner. Qt allows you to write multiple properties
    in a single line separated by a semicolon. You can write `x` and `y` positions
    in the same line, separated by a semicolon.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您将看到一个蓝色矩形被创建在(`50,50`)位置。更改`x`和`y`值，您将看到位置相对于左上角如何改变。Qt允许您在一行中用分号分隔写入多个属性。您可以在同一行中用分号分隔写入`x`和`y`位置。
- en: In this section, you learned how to position a visual item by specifying its
    coordinates. In the next section, we will discuss the use of anchors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何通过指定其坐标来定位可视项。在下一节中，我们将讨论锚点的使用。
- en: Positioning with anchors
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用锚点定位
- en: 'Qt Quick provides a way to anchor a control to another control. There are seven
    invisible anchor lines for each item: `left`, `right`, `top`, `bottom`, `baseline`,
    `horizontalCenter`, and `verticalCenter`. You can set margins or different margins
    for each side. If there are multiple anchors for a specific item, they can then
    be grouped.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick提供了一种将控件锚定到另一个控件的方法。每个项目有七条不可见的锚线：`left`、`right`、`top`、`bottom`、`baseline`、`horizontalCenter`和`verticalCenter`。您可以为每个边设置边距或不同的边距。如果特定项目有多个锚点，那么它们可以被分组。
- en: 'Let''s have a look at the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this example, you will see a red rectangle inside a blue rectangle
    with different margins in the output window, as shown next:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例，您将在输出窗口中看到一个红色矩形，它位于蓝色矩形内部，具有不同的边距，如下所示：
- en: '![Figure 4.16 – Anchor positioning a control inside a window'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16 - 锚定在窗口内部定位控件'
- en: '](img/Figure_4.16_B16231.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B16231.jpg)'
- en: Figure 4.16 – Anchor positioning a control inside a window
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 - 锚定在窗口内部定位控件
- en: In this section, you learned how to position a visual item by using anchors.
    In the next section, we will discuss the use of positioners.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用锚点定位可视项。在下一节中，我们将讨论位置器的使用。
- en: Positioners
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置器
- en: '**Positioners** are containers that manage the positions of visual elements
    in a declarative UI. Positioners behave in a similar way to layout managers in
    **Qt widgets**.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Positioners**是在声明性UI中管理可视元素位置的容器。Positioners的行为方式类似于**Qt widgets**中的布局管理器。'
- en: 'A standard set of positioners is provided in a basic set of Qt Quick elements.
    They are outlined as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一组标准的位置器在基本的Qt Quick元素集中提供。它们概述如下：
- en: '**Column** positions its children in a column.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Column**将其子项放置在列中。'
- en: '**Row** positions its children in a row.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Row**将其子项放置在一行中。'
- en: '**Grid** positions its children in a grid.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grid**将其子项放置在网格中。'
- en: '**Flow** positions its children like words on a page.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flow**将其子项放置在页面上的单词中。'
- en: 'Let''s have a look how to use them in Qt Quick Designer. First, create three
    **Rectangle** items with different colors and then position them inside a **Row**
    element, as illustrated in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Qt Quick Designer中使用它们。首先，创建三个具有不同颜色的**Rectangle**项目，然后将它们放置在一个**Row**元素内，如下截图所示：
- en: '![Figure 4.17 – Rectangles inside a Row positioner'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17 - 位置器内的矩形'
- en: '](img/Figure_4.17_B16231.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16231.jpg)'
- en: Figure 4.17 – Rectangles inside a Row positioner
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 - 位置器内的矩形
- en: 'You can also write code to position the controls inside a positioner. Qt Creator
    automatically generates code if you use Qt Quick Designer. The generated code
    can be viewed and modified through the **Text Editor** tab next to **Form Editor**.
    The code is shown in the following snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写代码来定位位置器内的控件。如果使用Qt Quick Designer，Qt Creator会自动生成代码。生成的代码可以通过**Form Editor**旁边的**Text
    Editor**选项卡查看和修改。代码如下所示：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this section, we learned about different positioners. In the next section,
    we will discuss the use of repeaters and models, along with positioners.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了不同的位置器。在下一节中，我们将讨论重复器和模型的使用，以及位置器。
- en: Repeater
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Repeater
- en: A **repeater** creates a number of visual elements using a provided model, as
    well as elements from a template to use with a positioner, and uses data from
    a model. A repeater is placed inside a positioner, and creates visual elements
    that follow the defined positioner arrangement. When there are many similar items,
    then a positioner with a repeater makes it easier to maintain when arranged in
    a regular layout.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Repeater**使用提供的模型创建多个可视元素，以及用于与位置器一起使用的模板元素，并使用模型中的数据。重复器放置在位置器内，并创建遵循定义的位置器排列的可视元素。当有许多类似的项目时，使用重复器的位置器在规则布局中排列时更容易维护。'
- en: 'Let''s create five rectangles positioned in a row using `Repeater`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Repeater`创建一个排列在一行中的五个矩形，如下所示：
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you run the preceding example, you will see five rectangles arranged in
    a row, as shown next:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述示例时，您将看到五个矩形排列在一行中，如下所示：
- en: '![Figure 4.18 – Rectangles inside a Row positioner'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18 - 位置器内的矩形'
- en: '](img/Figure_4.18_B16231.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B16231.jpg)'
- en: Figure 4.18 – Rectangles inside a Row positioner
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 - 位置器内的矩形
- en: In this section, we learned about the use of repeaters with positioners. In
    the next section, we will look into Qt Quick Layouts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了使用位置器和重复器。在下一节中，我们将深入了解Qt Quick布局。
- en: Qt Quick Layouts
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick布局
- en: Qt Quick Layouts are a set of QML types that can be used to arrange visual elements
    in a UI. Qt Quick Layouts can resize their children, hence they are used for resizable
    UIs. The basic difference between positioners and layouts is that layouts can
    resize their children on window resize.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick布局是一组QML类型，可用于在UI中排列可视元素。Qt Quick布局可以调整其子元素的大小，因此它们用于可调整大小的UI。位置器和布局之间的基本区别在于布局可以在窗口调整大小时调整其子元素。
- en: 'Qt Quick Layouts can be imported into your QML file by using the following
    `import` statement:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下`import`语句将Qt Quick布局导入到您的QML文件中：
- en: '`import QtQuick.Layouts`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`import QtQuick.Layouts`'
- en: 'There are five different type of layouts in QML, as outlined here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有五种不同类型的QML布局，如下所述：
- en: '`RowLayout`: This arranges elements in a row. It is similar to `GridLayout`
    but only has one row.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowLayout`：按行排列元素。它类似于`GridLayout`，但只有一行。'
- en: '`ColumnLayout`: This arranges elements in a column. It is similar to `GridLayout`
    but only has one column.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColumnLayout`：按列排列元素。它类似于`GridLayout`，但只有一列。'
- en: '`GridLayout`: This allows elements to be arranged dynamically in a grid.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridLayout`：允许在网格中动态排列元素。'
- en: '`Layout`: This provides attached properties for items pushed onto a `ColumnLayout`,
    `RowLayout`, or `GridLayout` layout type.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layout`：为推送到`ColumnLayout`、`RowLayout`或`GridLayout`布局类型的项目提供附加属性。'
- en: '`StackLayout`: This arranges elements in a stack-like manner where only one
    element is visible at a time.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackLayout`：以堆栈方式排列元素，一次只有一个元素可见。'
- en: 'Let''s look at the following `RowLayout` example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下`RowLayout`示例：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Please note that a `Row` type is a positioner, while a `RowLayout` type is a
    layout. When to use them depends mainly on your goal, as usual. Let's move on
    to the next section to see how to integrate QML with C++.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Row`类型是位置器，而`RowLayout`类型是布局。何时使用它们主要取决于您的目标，与往常一样。让我们继续下一节，看看如何将QML与C++集成。
- en: Integrating QML with C++
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将QML与C++集成
- en: QML applications often need to handle more advanced and performance-intensive
    tasks in C++. The most common and quickest way to do this is to expose the C++
    class to the QML runtime, provided the C++ implementation is derived from `QObject`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: QML应用程序通常需要在C++中处理更高级和性能密集型的任务。这样做的最常见和最快速的方法是将C++类暴露给QML运行时，前提是C++实现派生自`QObject`。
- en: QML can be easily integrated with C++ code. QML objects can be loaded and manipulated
    from C++. QML integration with Qt's meta-object system allows C++ functionality
    to be invoked from QML. This helps in building hybrid applications with a mixture
    of C++, QML, and JS. To expose C++ data or properties or methods to QML, it should
    be derived from a `QObject` class. This is possible because all QML object types
    are implemented using `QObject`-derived classes, allowing the QML engine to load
    and inspect objects through the Qt meta-object system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: QML可以很容易地与C++代码集成。可以从C++加载和操作QML对象。QML与Qt的元对象系统集成允许从QML调用C++功能。这有助于构建混合应用程序，其中混合了C++、QML和JS。要将C++数据、属性或方法暴露给QML，它应该派生自`QObject`类。这是可能的，因为所有QML对象类型都是使用`QObject`派生类实现的，允许QML引擎通过Qt元对象系统加载和检查对象。
- en: 'You can integrate QML with C++ in the following ways:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以以下方式将QML与C++集成：
- en: Embedding C++ objects into QML with context properties
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文属性将C++对象嵌入到QML中
- en: Registering the type with the QML engine
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向QML引擎注册类型
- en: Creating a QML extension plugin
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建QML扩展插件
- en: Let's discuss each approach one by one in the following sections.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下各节中逐一讨论每种方法。
- en: Important note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To quickly determine which integration method is appropriate for your project,
    have a look at the flowchart illustrated in the Qt documentation at the following
    link:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速确定哪种集成方法适合您的项目，请查看Qt文档中以下链接中的流程图：
- en: '[https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html](https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html](https://doc.qt.io/qt-6/qtqml-cppintegration-overview.html)'
- en: Embedding C++ objects into QML with context properties
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文属性将C++对象嵌入到QML中
- en: You can expose C++ objects into a QML environment by using context properties.
    Context properties are suitable for simple applications. They export your object
    as a global object. Contexts are exposed to the QML environment after being instantiated
    by the QML engine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上下文属性将C++对象暴露到QML环境中。上下文属性适用于简单的应用程序。它们将您的对象导出为全局对象。上下文在由QML引擎实例化后暴露给QML环境。
- en: 'Let''s have a look at the following example, where we have exported `radius`
    to the QML environment. You can also export C++ models in a similar way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例，在这个示例中，我们已将`radius`导出到QML环境。您也可以以类似的方式导出C++模型：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use the exported value directly in the QML file, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在QML文件中使用导出的值，如下所示：
- en: '[PRE13]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can also register your C++ class and instantiate it inside the QML environment.
    Let's learn how to achieve that in the next section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在QML环境中注册您的C++类并实例化它。让我们在下一节中学习如何实现这一点。
- en: Registering a C++ class with the QML engine
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用QML引擎注册C++类
- en: Registering QML types permits a developer to control the life cycle of a C++
    object from the QML environment. This can't be achieved with context properties
    and also doesn't populate the global namespace. Still, all types need to be registered
    first and by this, all libraries need to be linked on application start, which
    in most cases is not really a problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注册QML类型允许开发人员从QML环境中控制C++对象的生命周期。这不能通过上下文属性实现，也不会填充全局命名空间。不过，所有类型都需要首先注册，并且在应用程序启动时需要链接所有库，这在大多数情况下并不是真正的问题。
- en: 'The methods can be public slots or public methods flagged with `Q_INVOKABLE`.
    Now, let''s import the C++ class into the QML file. Have a look at the following
    C++ class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以是公共槽或使用`Q_INVOKABLE`标记的公共方法。现在，让我们将C++类导入到QML文件中。看一下以下C++类：
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You need to register the C++ class in the `main.cpp` file as a module using
    `qmlRegisterType()`, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在`main.cpp`文件中使用`qmlRegisterType()`将C++类注册为模块，如下所示：
- en: '[PRE15]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any `Qobject`-derived C++ class can be registered as a QML object type. Once
    a class is registered with the QML type system, the class can be used like any
    other QML type. Now, the C++ class is ready to be instantiated inside your `.qml`
    file. You have to import the module and create an object, as illustrated in the
    following code snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 任何派生自`Qobject`的C++类都可以注册为QML对象类型。一旦一个类被注册到QML类型系统中，该类就可以像任何其他QML类型一样使用。现在，C++类已准备好在您的`.qml`文件中实例化。您需要导入模块并创建一个对象，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you run the preceding program, you can see that the program is fetching
    data from the backend C++ class and displaying it in the UI.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述程序时，您会看到程序正在从后端C++类中获取数据并在UI中显示。
- en: 'You can also expose a C++ class as a QML singleton by using `qmlRegisterSingletonType()`.
    By using a QML singleton, you can prevent duplicate objects in the global namespace.
    Let''s skip this part as it requires an understanding of design patterns. Detailed
    documentation can be found at the following link:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`qmlRegisterSingletonType()`将C++类公开为QML单例。通过使用QML单例，您可以防止全局命名空间中的重复对象。让我们跳过这部分，因为它需要对设计模式有所了解。详细的文档可以在以下链接找到：
- en: '[https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType](https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType%20)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType](https://doc.qt.io/qt-6/qqmlengine.html#qmlRegisterSingletonType%20)'
- en: In Qt 6, you can achieve C++ integration by using a `QML_ELEMENT` macro. This
    macro declares the enclosing type as available in QML, using its class or namespace
    name as the QML element name. To use this macro in your C++ header file, you will
    have to include the `qml.h` header file as `#include <QtQml>`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6中，您可以通过使用`QML_ELEMENT`宏实现C++集成。该宏将声明封闭类型作为QML中可用，使用其类或命名空间名称作为QML元素名称。要在C++头文件中使用此宏，您将需要包含`qml.h`头文件，如`#include
    <QtQml>`。
- en: 'Let''s have a look at the following example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `.pro` file, you have to add the `qmltypes` option to the `CONFIG` variable
    and `QML_IMPORT_NAME` and `QML_IMPORT_MAJOR_VERSION` are to be mentioned, as illustrated
    in the following code snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.pro`文件中，您需要将`qmltypes`选项添加到`CONFIG`变量，并且需要提到`QML_IMPORT_NAME`和`QML_IMPORT_MAJOR_VERSION`，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your C++ class is now ready to be instantiated inside your `.qml` file. You
    have to import the module and create an object, as illustrated in the following
    code snippet:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您的C++类现在已准备好在您的`.qml`文件中实例化。您需要导入模块并创建一个对象，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, you learned how to export your C++ class into the QML environment
    and access its functions from QML. In this example, the data is retrieved only
    when the method is called. You can also get notified when the data is changed
    inside C++ by adding a `Q_PROPERTY()` macro with a `NOTIFY` signal. You need to
    know about the signals and slots mechanism before using it. So, we will skip this
    part and discuss it further in [*Chapter 6*](B16231_06_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Signals and Slots*. In the next section, we will discuss how to create a QML
    extension plugin.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何将您的C++类导出到QML环境中，并从QML访问其函数。在这个例子中，数据只有在调用方法时才被检索。您还可以通过添加带有`NOTIFY`信号的`Q_PROPERTY()`宏在C++内部更改数据时得到通知。在使用之前，您需要了解信号和槽机制。因此，我们将跳过这部分，并在[*第6章*](B16231_06_Final_ASB_ePub.xhtml#_idTextAnchor123)中进一步讨论*信号和槽*。在下一节中，我们将讨论如何创建一个QML扩展插件。
- en: Creating a QML extension plugin
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建QML扩展插件
- en: A QML extension plugin provides the most flexible way to integrate with C++.
    It allows you to register types in a plugin that is loaded when the first QML
    file calls the import identifier. You can use plugins across projects, which is
    very convenient when building complex projects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: QML扩展插件提供了与C++集成的最灵活的方式。它允许您在插件中注册类型，在第一个QML文件调用导入标识符时加载该插件。您可以在项目之间使用插件，这在构建复杂项目时非常方便。
- en: 'Qt Creator has a wizard to create a `QqmlExtensionPlugin` and should implement
    the `registerTypes()` function. A `Q_PLUGIN_METADATA` macro is required to identify
    the plugin as a QML extension plugin:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator有一个向导可以创建`QqmlExtensionPlugin`，并且应该实现`registerTypes()`函数。需要使用`Q_PLUGIN_METADATA`宏来标识插件为QML扩展插件：
- en: '![Figure 4.19 – Qt Quick 2 QML Extension Plugin wizard'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19 - Qt Quick 2 QML扩展插件向导'
- en: '](img/Figure_4.19_B16231.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B16231.jpg)'
- en: Figure 4.19 – Qt Quick 2 QML Extension Plugin wizard
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 - Qt Quick 2 QML扩展插件向导
- en: 'This section is an advanced Qt topic. You need to understand Qt in depth to
    create your own QML extension plugin. You can skip this section if you are a beginner,
    but you can learn more about the QML extension plugin in the Qt documentation
    at the following link:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是一个高级的Qt主题。您需要深入了解Qt才能创建自己的QML扩展插件。如果您是初学者，可以跳过本节，但您可以在以下链接的Qt文档中了解更多关于QML扩展插件的信息：
- en: '[https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html](https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html](https://doc.qt.io/qt-6/qtqml-modules-cppplugins.html)'
- en: Let's move on to the next section to discover how to invoke a QML method inside
    a C++ class.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节，了解如何在C++类中调用QML方法。
- en: Invoking QML methods inside a C++ class
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++类中调用QML方法
- en: All QML methods are exposed to the meta-object system and can be called from
    C++ using `QMetaObject::invokeMethod()`. You can specify types for the parameters
    and the return value after the colon character, as shown in the next code snippet.
    This can be useful when you want to connect a signal in C++ with a certain signature
    to a QML-defined method, for example. If you omit the types, the C++ signature
    will use `QVariant`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有QML方法都暴露给元对象系统，并可以使用`QMetaObject::invokeMethod()`从C++中调用。您可以在冒号字符后指定参数和返回值的类型，如下一个代码片段所示。当您想要将C++中的信号连接到QML定义的特定签名的方法时，这可能很有用。如果省略类型，则C++签名将使用`QVariant`。
- en: Let's look at an application that calls a QML method using `QMetaObject::invokeMethod()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个调用QML方法的应用程序，使用`QMetaObject::invokeMethod()`。
- en: 'In the QML file, let''s add a method called `qmlMethod()`, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML文件中，让我们添加一个名为`qmlMethod()`的方法，如下所示：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `main.cpp` file, call `QMetaObject::invokeMethod()` as per the following
    code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中，按照以下代码片段调用`QMetaObject::invokeMethod()`：
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Please note that the parameter and return type have to be specified. Both basic
    types and object types are allowed as type names. If the type is not mentioned
    in the QML type system, then you must declare `QVariant` as a type with `Q_RETURN_ARG()`
    and `Q_ARG()` when calling `QMetaObject::invokeMethod`. Alternatively, you can
    call `invokeMethod()` with only two parameters if you don''t need any return values,
    as shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须指定参数和返回类型。基本类型和对象类型都允许作为类型名称。如果类型在QML类型系统中未提及，则在调用`QMetaObject::invokeMethod`时，您必须使用`Q_RETURN_ARG()`和`Q_ARG()`声明`QVariant`作为类型。或者，如果您不需要任何返回值，可以只用两个参数调用`invokeMethod()`，如下所示：
- en: '`QMetaObject::invokeMethod(myObject, "qmlMethod");`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMetaObject::invokeMethod(myObject, "qmlMethod");`'
- en: In this section, you learned to receive data from a QML method. In the next
    section, you will learn how to access a QML object pointer inside C++.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了从QML方法中接收数据。在下一节中，您将学习如何在C++中访问QML对象指针。
- en: Exposing a QML object pointer to C++
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将QML对象指针暴露给C++
- en: Sometimes, you may want to modify the properties of a QML object through C++,
    such as modifying the text of a control, changing the visibility of a control,
    or changing a custom property. The QML engine permits you to register your QML
    objects to C++ types, which automatically exposes the QML object's properties.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望通过C++修改QML对象的属性，例如修改控件的文本、更改控件的可见性或更改自定义属性。QML引擎允许您将QML对象注册为C++类型，从而自动公开QML对象的属性。
- en: 'Let''s have a look at the following example, where we have exported a QML object
    to the C++ environment:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，我们将一个QML对象导出到C++环境中：
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the QML file, you need to create an instance of the `C++` class and call
    the `C++` method. As you can see in the following code snippet, the property is
    manipulated inside the `C++` class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML文件中，您需要创建`C++`类的实例并调用`C++`方法。如下面的代码片段所示，在`C++`类内部操作属性：
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Important note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The Qt QML module provides several macros for registering non-instantiable types.
    `QML_ANONYMOUS` registers a C++ type that is not instantiable and cannot be referred
    to from QML. `QML_INTERFACE` registers an existing Qt interface type. The type
    is not instantiable from QML, and you cannot declare QML properties with it. `QML_UNCREATABLE`
    registers a named C++ type that is not instantiable but should be identifiable
    as a type to the QML type system. `QML_SINGLETON` registers a singleton type that
    can be imported from QML.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Qt QML模块提供了几个用于注册不可实例化类型的宏。`QML_ANONYMOUS`注册一个不可实例化且无法从QML引用的C++类型。`QML_INTERFACE`注册一个现有的Qt接口类型。该类型无法从QML实例化，并且您不能使用它声明QML属性。`QML_UNCREATABLE`注册一个命名的不可实例化的C++类型，但应该作为QML类型系统中的类型可识别。`QML_SINGLETON`注册一个可以从QML导入的单例类型。
- en: Congratulations! You have learned how to integrate QML and C++. In the next
    section, we will discuss how to use JS with QML.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经学会了如何集成QML和C++。在下一节中，我们将讨论如何在QML中使用JS。
- en: Integrating QML with JS
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将QML与JS集成
- en: QML has a good integration with JS and uses **JavaScript Object Notation** (**JSON**)-**like
    syntaxes**, allowing expressions and methods to be defined as JS functions. It
    also permits developers to import JS files and use the existing functionality.
    The QML engine provides a JS environment that has some limitations compared to
    the JS environment provided by a web browser. The logic for a Qt Quick application
    can be defined in the JS. The JS code can be written inline inside the QML file,
    or in a separate JS file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: QML与JS有很好的集成，并使用类似**JavaScript对象表示**（**JSON**）的语法，允许定义表达式和方法作为JS函数。它还允许开发人员导入JS文件并使用现有功能。QML引擎提供了一个JS环境，与Web浏览器提供的JS环境相比有一些限制。Qt
    Quick应用程序的逻辑可以在JS中定义。JS代码可以内联编写在QML文件中，也可以编写在单独的JS文件中。
- en: 'Let''s look at how to use inline JS inside a QML document. The following example
    demonstrates the `btnClicked()` inline JS function. The method is called when
    the `Button` control is clicked:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在QML文档中使用内联JS。下面的示例演示了`btnClicked()`内联JS函数。当单击`Button`控件时，将调用该方法：
- en: '[PRE24]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example shows how to integrate JS code with QML. We have used
    the `btnClicked()` inline JS function. When you run the application, you will
    get a message saying **JS called!**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何将JS代码与QML集成。我们使用了`btnClicked()`内联JS函数。当您运行应用程序时，将收到一条消息，上面写着**JS called!**。
- en: 'If your logic is very long or has uses in multiple QML documents, then use
    a separate JS file. You can import a JS file as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的逻辑非常复杂或在多个QML文档中使用，则使用单独的JS文件。您可以按如下方式导入JS文件：
- en: '`import "<JavaScriptFile>" as <Identifier>`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "<JavaScriptFile>" as <Identifier>`'
- en: 'For example, you could run the following line of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以运行以下代码行：
- en: '`import "constants.js" as Constants`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "constants.js" as Constants`'
- en: In the previous example, we are importing `constants.js` into the QML environment.
    `Constants` is an identifier for our JS file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`constants.js`导入到QML环境中。`Constants`是我们JS文件的标识符。
- en: 'You can also create a shared JS library. You just have to include the following
    line of code at the beginning of the JS file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个共享的JS库。您只需在JS文件的开头包含以下代码行：
- en: '`.pragma library`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pragma library`'
- en: Important note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the script is a single expression, then writing it inline is recommended.
    If the script is a few lines long, then use a block. If the script is more than
    several lines long or is required by different objects, then create a function
    and call it as needed. For long scripts, create a JS file and import it inside
    the QML file. Avoid using `Qt.include()` as it is deprecated and will be removed
    from future versions of Qt.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本是单个表达式，则建议将其内联写入。如果脚本有几行长，则使用块。如果脚本超过几行长或被不同对象需要，则创建一个函数并根据需要调用它。对于长脚本，创建一个JS文件并在QML文件中导入它。避免使用`Qt.include()`，因为它已被弃用，并将在未来的Qt版本中删除。
- en: 'To learn more about importing JS in QML, read the following documentation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关在QML中导入JS的更多信息，请阅读以下文档：
- en: '[https://doc.qt.io/qt-6/qtqml-javascript-imports.html](https://doc.qt.io/qt-6/qtqml-javascript-imports.html)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtqml-javascript-imports.html](https://doc.qt.io/qt-6/qtqml-javascript-imports.html)'
- en: In this section, you learned how to integrate JS with QML. In the next section,
    we will discuss how to import a directory in QML.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何将JS与QML集成。在下一节中，我们将讨论如何在QML中导入目录。
- en: Importing a directory in QML
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在QML中导入目录
- en: You can import a local directory with QML files directly inside another QML
    file without adding in resources. You can use the directory's absolute or relative
    filesystem paths to do this, providing a convenient way for QML types to be arranged
    as reusable directories on the filesystem.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在另一个QML文件中导入包含QML文件的本地目录，而无需添加资源。您可以使用目录的绝对或相对文件系统路径来实现这一点，为QML类型提供了一种方便的方式，将其排列为可重用的目录在文件系统上。
- en: 'The common form of a directory import is shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 目录导入的常见形式如下所示：
- en: '`import "<DirectoryPath>" [as <Qualifier>]`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "<DirectoryPath>" [as <Qualifier>]`'
- en: 'For example, if your directory name is `customqmlelements`, then you can import
    it as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的目录名称是`customqmlelements`，那么您可以按如下方式导入它：
- en: '`import "../customqmlelements"`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "../customqmlelements"`'
- en: 'It is also possible to import the directory as a qualified local namespace,
    as shown in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将目录作为限定的本地命名空间导入，如下面的代码片段所示：
- en: '`import "../customqmlelements" as CustomQMLElements`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "../customqmlelements" as CustomQMLElements`'
- en: 'You can also import a file from the resource path, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按以下方式从资源路径导入文件：
- en: '`import "qrc:/qml/customqmlelements"`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "qrc:/qml/customqmlelements"`'
- en: 'You can also import a directory of QML files from a remote server. There are
    two different types of `qmldir` files: a QML directory listing file and a QML
    module definition file. Here, we are discussing the use of the `qmldir` QML directory
    listing file. The directory can be imported using the `qmldir` file can be accessed.
    To avoid malicious code, you have to be careful with the network files.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从远程服务器导入一个包含QML文件的目录。有两种不同类型的`qmldir`文件：QML目录列表文件和QML模块定义文件。在这里，我们讨论的是使用`qmldir`
    QML目录列表文件。可以使用`qmldir`文件导入目录。为了避免恶意代码，您必须小心处理网络文件。
- en: 'The following documentation provides further information about the `qmldir`
    QML directory listing file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文档提供了有关`qmldir` QML目录列表文件的更多信息：
- en: '[https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html](https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html](https://doc.qt.io/qt-6/qtqml-syntax-directoryimports.html)'
- en: 'You can learn more about the different types of `qmldir` files at the following
    link:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关不同类型的`qmldir`文件的更多信息：
- en: '[https://doc.qt.io/qt-6/qtqml-modules-qmldir.html](https://doc.qt.io/qt-6/qtqml-modules-qmldir.html)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qtqml-modules-qmldir.html](https://doc.qt.io/qt-6/qtqml-modules-qmldir.html)'
- en: In this section, you learned how to import a directory in QML. In the next section,
    we will discuss how to handle mouse and touch events in QML.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何在QML中导入目录。在下一节中，我们将讨论如何在QML中处理鼠标和触摸事件。
- en: Handling mouse and touch events
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理鼠标和触摸事件
- en: QML provides excellent support for mouse and touch events through input handlers
    that let QML applications handle mouse and touch events. QML types such as `MouseArea`,
    `MultiPointTouchArea`, and `TapHandler` are used to detect mouse and touch events.
    We will have a look at these QML types in the following section.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: QML通过输入处理程序提供了对鼠标和触摸事件的出色支持，这些处理程序让QML应用程序处理鼠标和触摸事件。QML类型，如`MouseArea`、`MultiPointTouchArea`和`TapHandler`用于检测鼠标和触摸事件。我们将在下一节中查看这些QML类型。
- en: MouseArea
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MouseArea
- en: '`MouseArea` is an invisible item that is used with a visible item such as `Item`
    or `Rectangle` in order to provide mouse and touch handling events for that item.
    `MouseArea` receives mouse events within the defined area of `Item`. You can define
    this area by anchoring `MouseArea` to its parent''s area using the `anchors.fill`
    property. If you set the visible property to `false`, then the mouse area becomes
    transparent to mouse events.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea`是一个不可见的项目，用于与可见项目（如`Item`或`Rectangle`）一起，以便为该项目提供鼠标和触摸处理事件。`MouseArea`在`Item`的定义区域内接收鼠标事件。您可以通过使用`anchors.fill`属性将`MouseArea`锚定到其父级区域来定义此区域。如果将visible属性设置为`false`，则鼠标区域对鼠标事件变得透明。'
- en: 'Let''s look at how to use `MouseArea` in the following example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下示例中使用`MouseArea`：
- en: '[PRE25]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, you can see that only the `rectangle` area received
    the mouse event. Other parts of window didn't get the mouse events. You can perform
    actions accordingly based on the mouse events. `MouseArea` also provides convenient
    signals that give us information about mouse events such as mouse hover, mouse
    press, press and hold, mouse exit, and mouse release events. Write the corresponding
    signal handlers and experiment with the `entered()`, `exited()`, `pressed()`,
    and `released()` signals. You can also detect which mouse button was pressed and
    execute a corresponding action.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您可以看到只有`rectangle`区域收到了鼠标事件。窗口的其他部分没有收到鼠标事件。您可以根据鼠标事件执行相应的操作。`MouseArea`还提供了方便的信号，可以提供有关鼠标事件的信息，如鼠标悬停、鼠标按下、按住、鼠标退出和鼠标释放事件。编写相应的信号处理程序，并尝试使用`entered()`、`exited()`、`pressed()`和`released()`信号。您还可以检测按下了哪个鼠标按钮，并执行相应的操作。
- en: MultiPointTouchArea
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MultiPointTouchArea
- en: The `MultiPointTouchArea` QML type enables handling of multiple touch points
    in a multi-touch screen. Just as with `MouseArea`, `MultiPointTouchArea` is an
    invisible item. You can track multiple touch points and process the gesture accordingly.
    When it is disabled, the touch area becomes transparent to both touch and mouse
    events. In a `MultiPointTouchArea` type, a mouse event is handled as a single
    touch point. You can set the `mouseEnabled` property to `false` to stop processing
    the mouse events.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiPointTouchArea` QML类型使多点触摸屏幕上的多个触摸点处理成为可能。与`MouseArea`一样，`MultiPointTouchArea`是一个不可见的项。您可以跟踪多个触摸点并相应地处理手势。当禁用时，触摸区域对触摸和鼠标事件都变得透明。在`MultiPointTouchArea`类型中，鼠标事件被处理为单个触摸点。您可以将`mouseEnabled`属性设置为`false`以停止处理鼠标事件。'
- en: 'Let''s look at the following example, where we have two rectangles that follow
    our touch points:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例，其中有两个矩形跟随我们的触摸点：
- en: '[PRE26]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a `MultiPointTouchArea` type, `TouchPoint` defines a touch point. It contains
    details about the touch point, such as the pressure, current position, and area.
    Now, run the application on your mobile device and verify it!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MultiPointTouchArea`类型中，`TouchPoint`定义了一个触摸点。它包含有关触摸点的详细信息，如压力、当前位置和区域。现在，在您的移动设备上运行应用程序并进行验证！
- en: In this section, you learned about the use of `MouseArea` and `MultiPointTouchArea`
    to handle mouse and touch events. Let's learn about `TapHandler` in the next section.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了使用`MouseArea`和`MultiPointTouchArea`来处理鼠标和触摸事件。让我们在下一节中了解`TapHandler`。
- en: TapHandler
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TapHandler
- en: '`TapHandler` is a handler for click events on a mouse and tap events on a touchscreen.
    You can use `TapHandler` to react to taps and touch gestures, and it allows you
    to handle events in multiple nested items simultaneously. Recognition of a valid
    tap gesture depends on `gesturePolicy`. The default value of `gesturePolicy` is
    `TapHandler.DragThreshold`, for which the event point must not move significantly.
    If `gesturePolicy` is set to `TapHandler.WithinBounds`, then `TapHandler` takes
    an exclusive grab on the press event, but releases the grab as soon as the event
    point leaves the boundary of the parent item. Similarly, if `gesturePolicy` is
    set to `TapHandler.ReleaseWithinBounds`, then `TapHandler` takes an exclusive
    grab on the press and retains it until release in order to detect this gesture.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`TapHandler`是鼠标点击事件和触摸屏上的轻拍事件的处理程序。您可以使用`TapHandler`来对轻拍和触摸手势做出反应，并允许您同时处理多个嵌套项中的事件。有效轻拍手势的识别取决于`gesturePolicy`。`gesturePolicy`的默认值是`TapHandler.DragThreshold`，其中事件点不得显着移动。如果将`gesturePolicy`设置为`TapHandler.WithinBounds`，则`TapHandler`独占按下事件，但一旦事件点离开父项的边界，就会释放独占。同样，如果将`gesturePolicy`设置为`TapHandler.ReleaseWithinBounds`，则`TapHandler`独占按下事件，并保持独占直到释放，以便检测此手势。'
- en: 'Let''s create a `TapHandler` type that recognizes different mouse button events
    and stylus taps, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`TapHandler`类型，以识别不同的鼠标按钮事件和触笔轻拍，如下所示：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can use `MouseArea`. Input handlers make the formation of complex touch
    interactions simpler, which is difficult to achieve with either `MouseArea` or
    `TouchArea`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`MouseArea`。输入处理程序使得形成复杂的触摸交互变得更简单，这是使用`MouseArea`或`TouchArea`难以实现的。
- en: Qt provides some ready-made controls to handle generic gestures such as pinch,
    flick, and swipe. `PinchArea` is a convenient QML type to handle simple pinch
    gestures. It is an invisible item that is used with another visible item. `Flickable`
    is another convenient QML type that provides a surface for a flick gesture. Explore
    the related documentation and examples to understand more about these QML elements.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一些现成的控件来处理通用手势，如捏合、轻扫和滑动。`PinchArea`是一个方便的QML类型，用于处理简单的捏合手势。它是一个不可见项，与另一个可见项一起使用。`Flickable`是另一个方便的QML类型，提供了一个用于轻扫手势的表面。探索相关文档和示例，以了解更多关于这些QML元素的信息。
- en: Let's look at `SwipeView` in the next section.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看`SwipeView`。
- en: SwipeView
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SwipeView
- en: A `SwipeView` to navigate pages by swiping sideways. It uses a swipe-based navigation
    model and provides a simplified way for horizontal-paged scrolling. You can add
    a page indicator at the bottom to display the current active page.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwipeView`用于通过侧向滑动导航页面。它使用基于滑动的导航模型，并提供了一种简化的水平分页滚动方式。您可以在底部添加页面指示器以显示当前活动页面。'
- en: 'Let''s look at a simple example, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，如下所示：
- en: '[PRE28]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we just have to add child items to `SwipeView`. You can set
    the `SwipeView` current index as the `PageIndicator` current index. `SwipeView`
    is one of the navigation models, which also include `StackView` and `Drawer`.
    You can explore these QML types to experience gestures on your mobile devices.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只需向`SwipeView`添加子项。您可以将`SwipeView`当前索引设置为`PageIndicator`当前索引。`SwipeView`是导航模型之一，还包括`StackView`和`Drawer`。您可以探索这些QML类型，以在移动设备上体验手势。
- en: In this section, you learned about the use of various QML types to handle mouse,
    touch, and gesture events. Next, we will summarize what we learned in this chapter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了使用各种QML类型来处理鼠标、触摸和手势事件。接下来，我们将总结本章学到的内容。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained the fundamentals of the Qt Quick module and how to create
    a custom UI. You learned to design and build GUIs with Qt Quick Designer and learned
    about Qt Quick Controls, and how to build a custom Qt Quick application. You also
    learned how to integrate QML with C++ and JS. You should now understand the similarities
    and differences between Qt Widgets and Qt Quick and be able to choose the most
    suitable framework for your project. In this chapter, we have learned about Qt
    Quick and how to create an application using QML. You also learned how to integrate
    QML with JS and learned about mouse and touch events.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了Qt Quick模块的基础知识以及如何创建自定义UI。您学会了如何使用Qt Quick Designer设计和构建GUI，并了解了Qt Quick
    Controls以及如何构建自定义Qt Quick应用程序。您还学会了如何将QML与C++和JS集成。现在您应该了解Qt Widgets和Qt Quick之间的相似之处和不同之处，并能够为您的项目选择最合适的框架。在本章中，我们学习了Qt
    Quick以及如何使用QML创建应用程序。您还学会了如何将QML与JS集成，并了解了鼠标和触摸事件。
- en: In the next chapter, we will discuss cross-platform development using Qt Creator.
    You will learn to configure and build applications on Windows, Linux, Android,
    and macOS **operating systems** (**OSes**). We are going to learn how to port
    our Qt application to different platforms without too many challenges. Let's go!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用Qt Creator进行跨平台开发。您将学习在Windows、Linux、Android和macOS操作系统（OSes）上配置和构建应用程序。我们将学习如何将我们的Qt应用程序移植到不同的平台，而不会遇到太多挑战。让我们开始吧！
