- en: 9\. Audio-Visual Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.音频-视觉元素
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will finish the dodgeball-based game that we have been working
    on in the past four chapters. We will conclude this chapter by adding sound effects,
    particle effects, and by creating another level, this time with an actual path
    the player must follow to finish it. By the end of this chapter, you will be able
    to add 2D and 3D sound effects, as well as particle effects, to your UE4 projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成我们在过去四章中一直在努力的基于躲避球的游戏。我们将通过添加音效、粒子效果，并创建另一个关卡来结束本章，这次关卡中玩家必须遵循实际路径才能完成。到本章结束时，您将能够向您的UE4项目添加2D和3D音效，以及粒子效果。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned about game UI and how to create and add
    a user interface (also known as a widget) to the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了游戏UI以及如何创建和添加用户界面（也称为小部件）到屏幕上。
- en: In this chapter, we will learn how to add audio and particle effects to our
    game. Both of these aspects will increase the quality of our game and produce
    a much more immersive experience for the player.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何向我们的游戏添加音频和粒子效果。这两个方面都将提高我们游戏的质量，并为玩家提供更加沉浸式的体验。
- en: Sound in video games can come in the form of either sound effects (also known
    as SFX) or music. Sound effects make the world around you more believable and
    alive, while the music helps set the tone for your game. Both these aspects are
    very important to your game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，声音可以以声音效果（也称为SFX）或音乐的形式出现。声音效果使您周围的世界更加真实和生动，而音乐则有助于为您的游戏设定基调。这两个方面对于您的游戏都非常重要。
- en: 'In competitive games such as *Counter-Strike* (*CS: GO*), sound is also extremely
    important because players need to hear the sounds around them, such as gunshots
    and footsteps, and which direction they came from, to gather as much information
    about their surroundings as possible.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在竞技游戏中，如《反恐精英：全球攻势》（CS:GO）中，声音也非常重要，因为玩家需要听到他们周围的声音，如枪声和脚步声，以及它们来自哪个方向，以尽可能多地了解他们周围的情况。
- en: 'Particle effects are important for the same reason that sound effects are important:
    they make your game world more believable and immersive.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果和音效之所以重要，是因为它们使您的游戏世界更加真实和沉浸。
- en: Let's start this chapter by learning how audio works in UE4.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习UE4中的音频工作来开始本章。
- en: Audio in UE4
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4中的音频
- en: 'One of the essential components of any game is sound. Sounds make your game
    more believable and immersive, which will provide a much better experience for
    your player. Video games usually have two types of sounds:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏的基本组成部分之一是声音。声音使您的游戏更加真实和沉浸，这将为您的玩家提供更好的体验。视频游戏通常有两种类型的声音：
- en: 2D sounds
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D声音
- en: 3D sounds
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D声音
- en: 2D sounds don't have any consideration for the listener's distance and direction,
    while 3D sounds can be higher or lower in volume and pan to the right or left,
    depending on the player's location. 2D sounds are usually used for music, while
    3D sounds are usually used for sound effects. The main sound file types are `.wav`
    and `.mp3`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2D声音不考虑听者的距离和方向，而3D声音可以根据玩家的位置在音量上升或下降，并在右侧或左侧移动。2D声音通常用于音乐，而3D声音通常用于音效。主要的声音文件类型是.wav和.mp3。
- en: 'Here are some of the assets and classes related to audio in UE4:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是UE4中与音频相关的一些资产和类：
- en: '`Sound Base`: Represents an asset that contains audio. This class is mainly
    used in C++ and Blueprint to reference an audio file that can be played.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “声音基础”：代表包含音频的资产。这个类主要用于C++和蓝图，用于引用可以播放的音频文件。
- en: '`Sound Wave`: Represents an audio file that has been imported into UE4\. Inherits
    from `Sound Base`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声波：代表已导入到UE4中的音频文件。继承自“声音基础”。
- en: '`Sound Cue`: An audio asset that can contain logic related to things such as
    attenuation (how the volume changes as the listener''s distance varies), looping,
    sound mixing, and other audio-related functionality. It inherits from `Sound Base`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “声音提示”：一个音频资产，可以包含与衰减（随着听者距离变化而音量如何变化）、循环、声音混合和其他与音频相关的功能相关的逻辑。它继承自“声音基础”。
- en: '`Sound Class`: An asset that allows you to separate your audio files into groups
    and manage some of their settings, such as volume and pitch. An example of this
    would be grouping all your sounds related to sound effects in the `SFX` `Sound
    Class`, all your character dialogue in the `Dialogue` `Sound Class`, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “声音类”：允许您将音频文件分组并管理其中一些设置，如音量和音调。一个例子是将所有与音效相关的声音分组到“SFX”声音类中，将所有角色对话分组到“对话”声音类中，等等。
- en: '`Sound Attenuation`: An asset that allows you to specify how a 3D sound will
    behave; for example, at which distance it will start to lower the volume, at which
    distance it will become inaudible (can''t be heard), if its volume will change
    linearly or exponentially as the distance increases, and so on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “声音衰减”：允许您指定3D声音的行为的资产；例如，它将从哪个距离开始降低音量，它将在哪个距离变得听不见（无法听到），如果音量会随着距离的增加而线性或指数变化等等。
- en: '`Audio Component`: An actor component that allows you to manage the playback
    of audio files and their properties. Useful for setting up continuous playback
    of sounds, such as background music.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频组件：允许您管理音频文件及其属性的演员组件。用于设置连续播放声音，如背景音乐。
- en: 'In UE4, we can import existing sounds the same way we would any other asset:
    either by dragging a file from the Windows File Explorer into the `Content Browser`
    or by clicking the `Import` button in the `Content Browser`. We''ll do this in
    the next exercise.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，我们可以像导入其他资产一样导入现有的声音：通过将文件从Windows文件资源管理器拖放到“内容浏览器”中，或者通过在“内容浏览器”中点击“导入”按钮。我们将在下一个练习中进行这个操作。
- en: 'Exercise 9.01: Importing an Audio File'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：导入音频文件
- en: In this exercise, you will import an existing sound file from your computer
    into UE4\. This audio file will be played when the dodgeball bounces off a surface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将从计算机中导入一个现有的声音文件到UE4中。当躲避球从表面弹起时，将播放此音频文件。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t have an audio file (either an `.mp3` or `.wav` file) available
    to complete this exercise, you can download the `.mp3` or `.wav` file available
    at this link: [https://www.freesoundeffects.com/free-track/bounce-1-468901/](https://www.freesoundeffects.com/free-track/bounce-1-468901/).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有音频文件（.mp3或.wav文件）可用来完成此练习，您可以在此链接下载.mp3或.wav文件：[https://www.freesoundeffects.com/free-track/bounce-1-468901/](https://www.freesoundeffects.com/free-track/bounce-1-468901/)。
- en: Save this file as `BOUNCE.wav`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为“BOUNCE.wav”。
- en: 'Once you have an audio file, follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有音频文件，请按照以下步骤操作：
- en: Open the editor.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: 'Go to the `Content` folder inside the `Content Browser` interface and create
    a new folder called `Audio`:![Figure 9.1: The Audio folder in the Content Browser'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“内容浏览器”界面内的“内容”文件夹，并创建一个名为“音频”的新文件夹：![图9.1：内容浏览器中的音频文件夹
- en: '](img/B16183_09_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_01.jpg)'
- en: 'Figure 9.1: The Audio folder in the Content Browser'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：内容浏览器中的音频文件夹
- en: Go to the `Audio` folder you just created.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您刚刚创建的“音频”文件夹。
- en: Import your audio file into this folder. You can do this by *dragging* the audio
    file from `Windows File Explorer` into `Content Browser`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的音频文件导入此文件夹。您可以通过*将*音频文件从“Windows文件资源管理器”拖放到“内容浏览器”中来执行此操作。
- en: 'After you''ve done this, a new asset should appear with the name of your audio
    file, which you can listen to when clicking on it:![Figure 9.2: The imported audio
    file'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，应该会出现一个名为您音频文件的新资产，您可以在单击它时听到它：![图9.2：导入的音频文件
- en: '](img/B16183_09_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_02.jpg)'
- en: 'Figure 9.2: The imported audio file'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：导入的音频文件
- en: 'Open this asset. You should see many properties available for editing. However,
    we''ll be focusing solely on some of the properties inside the `Sound` category:![Figure
    9.3: The Sound asset’s settings'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开此资产。您应该看到许多可供编辑的属性。但是，我们将仅专注于“声音”类别内的一些属性：![图9.3：声音资产的设置
- en: '](img/B16183_09_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_03.jpg)'
- en: 'Figure 9.3: The Sound asset''s settings'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：声音资产的设置
- en: 'The following properties are available in the `Sound` category:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性可在“声音”类别中使用：
- en: '`Looping`: Whether this sound will loop while being played.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “循环”：此声音在播放时是否循环。
- en: '`Volume`: The volume of this sound.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “音量”：此声音的音量。
- en: '`Pitch`: The pitch of this sound. The higher the pitch, the higher the frequency,
    and the higher in tone this sound will be.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “音调”：此声音的音调。音调越高，频率越高，音调越高。
- en: '`Class`: The `Sound Class` of this sound.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “类”：此声音的“声音类”。
- en: The only property we'll be changing is the `Class` property. We could use one
    of the existing `Sound` classes that comes with UE4, but let's create our own
    `Sound Class` for the dodgeball in order to create a new group of sounds for our
    game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改的唯一属性是“类”属性。我们可以使用UE4提供的现有“声音”类之一，但让我们为躲避球创建自己的“声音类”，以便为我们的游戏创建一组新的声音。
- en: Go to the `Audio` folder inside the `Content Browser` interface.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“内容浏览器”界面内的“音频”文件夹。
- en: '*Right-click*, go to the `Sounds` category (the penultimate category), then
    the `Classes` category, and select `Sound Class`. This will create a new `Sound
    Class` asset. Rename this asset `Dodgeball`.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*，转到“声音”类别（倒数第二个类别），然后转到“类别”类别，选择“声音类”。这将创建一个新的“声音类”资产。将此资产重命名为“躲避球”。'
- en: 'Open your imported sound asset and set its `Class` property to `Dodgeball`:![Figure
    9.4: Changing the Class property to the Dodgeball Sound Class'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您导入的声音资产，并将其“类”属性设置为“躲避球”：![图9.4：将类属性更改为躲避球声音类
- en: '](img/B16183_09_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_04.jpg)'
- en: 'Figure 9.4: Changing the Class property to the Dodgeball Sound Class'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：将类属性更改为躲避球声音类
- en: Now that this imported sound asset belongs to a specific class, you can group
    other sound effects related to the dodgeball in the same `Sound Class` and edit
    their properties through that `Sound Class`, which includes `Volume`, `Pitch`,
    and many others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个导入的声音资产属于特定的类，您可以将与躲避球相关的其他声音效果分组到同一个“声音类”中，并通过该“声音类”编辑它们的属性，包括“音量”、“音调”和许多其他属性。
- en: And with that, we can conclude our exercise. You have learned how to import
    sounds into your project and how to change their basic properties. Now, let's
    move on to the next exercise, where we'll be playing a sound whenever a dodgeball
    bounces off a surface in our game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以结束我们的练习了。您已经学会了如何将声音导入到您的项目中，以及如何更改它们的基本属性。现在，让我们继续进行下一个练习，在这个练习中，我们将在我们的游戏中每当躲避球从表面弹开时播放声音。
- en: 'Exercise 9.02: Playing a Sound When the Dodgeball Bounces off a Surface'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：当躲避球从表面弹开时播放声音
- en: In this exercise, we will add the necessary functionality to our `DodgeballProjectile`
    class so that a sound will play when the dodgeball bounces off a surface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们的“DodgeballProjectile”类添加必要的功能，以便当躲避球从表面弹开时播放声音。
- en: 'To do this, follow these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: Close the editor and open Visual Studio.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并打开Visual Studio。
- en: 'In the header file for the `DodgeballProjectile` class, add a protected `class
    USoundBase*` property called `BounceSound`. This property should be a `UPROPERTY`
    and have the `EditDefaultsOnly` tag so that it can be edited in the Blueprint:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“DodgeballProjectile”类的头文件中，添加一个受保护的“class USoundBase*”属性，名为“BounceSound”。此属性应该是一个“UPROPERTY”，并具有“EditDefaultsOnly”标记，以便可以在蓝图中进行编辑：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you''ve done this, go to the `DodgeballProjectile` class''s source file
    and add an include for the `GameplayStatics` object:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，转到“DodgeballProjectile”类的源文件，并添加一个包含“GameplayStatics”对象的包含：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, at the beginning of the class's implementation of the `OnHit` function,
    before the cast to the `DodgeballCharacter` class, check whether our `BounceSound`
    is a valid property (different than `nullptr`) and whether the magnitude of the
    `NormalImpulse` property is greater than `600` units (we can access the magnitude
    by calling its `Size` function).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类的“OnHit”函数的实现开始之前，在对“DodgeballCharacter”类的转换之前，检查我们的“BounceSound”是否是有效属性（与“nullptr”不同），以及“NormalImpulse”属性的大小是否大于“600”单位（我们可以通过调用其“Size”函数来访问大小）。
- en: 'As we saw in *Chapter 8*, *User Interfaces*, the `NormalImpulse` property indicates
    the direction and magnitude of the force that will change the dodgeball''s trajectory
    after it has been hit. The reason why we want to check if its magnitude is greater
    than a certain amount is that when the dodgeball starts losing momentum and bounces
    off of the floor several times per second, we don''t want to play `BounceSound`
    several times per second; otherwise, it will generate a lot of noise. So, we will
    check whether the impulse that the dodgeball is suffering is greater than that
    amount to make sure this doesn''t happen. If both these things are true, we''ll
    call the `GameplayStatics` object''s `PlaySoundAtLocation`. This function is responsible
    for playing 3D sounds. It receives five parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第8章*，*用户界面*中看到的，`NormalImpulse`属性表示在被击中后改变躲避球轨迹的方向和大小的力量。我们要检查它的大小是否大于一定数量的原因是，当躲避球开始失去动量并且每秒在地板上反弹多次时，我们不希望每秒播放`BounceSound`多次；否则，会产生很多噪音。因此，我们将检查躲避球所受的冲量是否大于该数量，以确保这种情况不会发生。如果这两个条件都成立，我们将调用`GameplayStatics`对象的`PlaySoundAtLocation`。这个函数负责播放3D声音。它接收五个参数：
- en: A world context object, which we'll pass as the `this` pointer.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个世界上下文对象，我们将作为`this`指针传递。
- en: A `SoundBase` property, which will be our `HitSound` property.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`SoundBase`属性，将是我们的`HitSound`属性。
- en: The origin of the sound, which we'll pass using the `GetActorLocation` function.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的来源，我们将使用`GetActorLocation`函数传递。
- en: '`VolumeMultiplier`, which we''ll pass with a value of `1`. This value indicates
    how much higher or lower the volume of this sound will be when it''s played. For
    instance, a value of `2` means it will have the volume twice as high.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolumeMultiplier`，我们将传递一个值为`1`。这个值表示播放此声音时音量会高低多少。例如，值为`2`表示音量会是原来的两倍。'
- en: '`PitchMultiplier`, which indicates how much higher or lower the pitch of this
    sound will be when it''s played. We''ll be passing this value by using the `FMath`
    object''s `RandRange` function, which receives two numbers as parameters and returns
    a random number between those two. To randomly generate a number between `0.7`
    and `1.3`, we''ll be calling this function with these values as parameters.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PitchMultiplier`，表示播放此声音时音调会高低多少。我们将使用`FMath`对象的`RandRange`函数传递这个值，该函数接收两个数字作为参数，并返回这两个数字之间的随机数。为了在`0.7`和`1.3`之间随机生成一个数字，我们将使用这些值作为参数调用这个函数。'
- en: 'Have a look at the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function responsible for playing 2D sounds is also available from the `GameplayStatics`
    object, and it's called `PlaySound2D`. This function will receive the same parameters
    as the `PlaySoundAtLocation` function, except for the third parameter, which is
    the origin of the sound.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 负责播放2D声音的函数也可以从`GameplayStatics`对象中获得，它被称为`PlaySound2D`。这个函数将接收与`PlaySoundAtLocation`函数相同的参数，除了第三个参数，即声音的来源。
- en: Compile these changes and then open Unreal Editor.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改，然后打开虚幻编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `BounceSound` property to the Sound asset you imported:![Figure 9.5:
    Setting the BounceSound property to our imported sound'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，转到其`Class Defaults`选项卡，并将`BounceSound`属性设置为你导入的声音资产：![图9.5：将BounceSound属性设置为我们导入的声音
- en: '](img/B16183_09_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_05.jpg)'
- en: 'Figure 9.5: Setting the BounceSound property to our imported sound'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：将BounceSound属性设置为我们导入的声音
- en: 'Play the level again and enter the enemy character''s line of sight. You should
    notice a sound playing with different pitch values every time the dodgeball thrown
    by the enemy character hits a wall or the floor (not the player character):![Figure
    9.6: The player character causing the enemy character to throw dodgeballs'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次玩这个关卡，进入敌人角色的视线。你应该注意到每当敌人角色投掷的躲避球击中墙壁或地板（而不是玩家角色）时，会播放不同音调的声音：![图9.6：玩家角色导致敌人角色投掷躲避球
- en: '](img/B16183_09_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_06.jpg)'
- en: 'Figure 9.6: The player character causing the enemy character to throw dodgeballs'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：玩家角色导致敌人角色投掷躲避球
- en: If this happens, congratulations – you've successfully played a sound using
    UE4! If you can't hear the sound playing, make sure that it is audible (it has
    a level of volume that you can hear).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做成功了，恭喜你——你已经成功使用UE4播放了声音！如果你听不到声音，确保它是可听到的（它有一个你可以听到的音量级别）。
- en: 'However, another thing you''ll probably notice is that the sound is always
    played at the same volume, regardless of the distance that the character is from
    the dodgeball that is bouncing: the sound isn''t playing in 3D but rather is being
    played in 2D. To play a sound in 3D using UE4, we''ll have to learn about Sound
    Attenuation assets.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会注意到的另一件事是，无论角色与反弹的躲避球的距离如何，声音总是以相同的音量播放：声音不是以3D方式播放，而是以2D方式播放。要在UE4中以3D方式播放声音，我们必须学习关于声音衰减资产的知识。
- en: Sound Attenuation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音衰减
- en: For a sound to be played in 3D inside UE4, you'll have to create a Sound Attenuation
    asset, as we mentioned in the first section of this chapter. A Sound Attenuation
    asset will let you specify how you want a specific sound to change volume as its
    distance from the listener increases. Have a look at the following example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UE4中以3D方式播放声音，你必须创建一个声音衰减资产，就像我们在本章的第一节中提到的那样。声音衰减资产将让你指定当声音与听者的距离增加时，你希望特定声音如何改变音量。看一下以下示例。
- en: 'Open Unreal Editor, go to the `Audio` folder inside the `Content Browser` interface,
    *right-click*, go to the `Sounds` category, and select `Sound Attenuation`. Name
    this new asset `BounceAttenuation`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开虚幻编辑器，转到`内容浏览器`界面内的`Audio`文件夹，*右键单击*，转到`声音`类别，并选择`声音衰减`。将这个新资产命名为`BounceAttenuation`：
- en: '![Figure 9.7: Creating the Sound Attenuation asset'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：创建声音衰减资产'
- en: '](img/B16183_09_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_07.jpg)'
- en: 'Figure 9.7: Creating the Sound Attenuation asset'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：创建声音衰减资产
- en: Open this `BounceAttenuation` asset.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个`BounceAttenuation`资产。
- en: 'Sound Attenuation assets have many settings; however, we''ll want to focus
    mainly on a couple of settings from the `Attenuation Distance` section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 声音衰减资产有许多设置；然而，我们主要关注`衰减距离`部分的一些设置：
- en: '`Inner Radius`: This `float` property allows us to specify at what distance
    the sound will start lowering in volume. If the sound is played at a distance
    less than this value, the volume won''t be affected. Set this property to `200`
    units.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内半径`：这个`float`属性允许我们指定声音开始降低音量的距离。如果声音在小于这个值的距离播放，音量不会受到影响。将此属性设置为`200`单位。'
- en: '`Falloff Distance`: This float property allows us to specify at what distance
    we want the sound to be inaudible. If the sound is played at a distance greater
    than this value, we won''t hear it. The volume of the sound will vary according
    to its distance to the listener and whether it''s closer to `Inner Radius` or
    `Falloff Distance`. Set this property to `1500` units:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`衰减距离`：这个浮点属性允许我们指定声音变得听不见的距离。如果声音在大于这个值的距离播放，我们将听不到它。声音的音量将根据其与听者的距离以及它是更接近`内半径`还是`衰减距离`而变化。将此属性设置为`1500`单位：'
- en: '![Figure 9.8: The Sound Attenuation asset settings'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：声音衰减资产设置'
- en: '](img/B16183_09_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_08.jpg)'
- en: 'Figure 9.8: The Sound Attenuation asset settings'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：声音衰减资产设置
- en: Think of this as two circles around the player, with the smaller circle being
    the Inner Circle (with a radius value of `Inner Radius`) and the bigger circle
    being the Falloff Circle (with a radius value of `Falloff Distance`). If a sound
    originates from inside the Inner Circle, it is played at full volume, while a
    sound that originates from outside the Falloff Circle is not played at all.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为玩家周围的两个圆，较小的圆是内圆（半径值为`内半径`），较大的圆是衰减圆（半径值为`衰减距离`）。如果声音起源于内圆内部，则以全音量播放，而起源于衰减圆外部的声音则不会播放。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on Sound Attenuation assets here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到有关声音衰减资产的更多信息：
- en: '[https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation](https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation](https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation)。'
- en: Now that you know about Sound Attenuation assets, let's move on to the next
    exercise, where we'll turn the sound that plays when the dodgeball bounces off
    the ground into a 3D sound.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了声音衰减资产，让我们继续下一个练习，我们将把躲避球弹起时播放的声音变成3D声音。
- en: 'Exercise 9.03: Turning the Bounce Sound into a 3D Sound'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03：将弹跳声音变成3D声音
- en: In this exercise, we'll be turning the sound that plays when a dodgeball bounces
    off the ground, which we added in the previous exercise, into a 3D sound. This
    means that when the dodgeball bounces off a surface, the sound it plays will vary
    in volume, depending on its distance to the player. We're doing this so that when
    the dodgeball is far away, the sound volume will be low, and when it's close,
    its volume will be high.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把上一个练习中添加的躲避球弹起时播放的声音变成3D声音。这意味着当躲避球从地面弹起时播放的声音将根据其与玩家的距离而音量有所变化。我们这样做是为了当躲避球远离时，声音音量会很低，而当它靠近时，音量会很高。
- en: 'To use the `BounceAttenuation` asset we created in the previous section, follow
    these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们在上一节中创建的`BounceAttenuation`资产，请按照以下步骤进行：
- en: 'Go to the header file for `DodgeballProjectile` and add a `protected` `class
    USoundAttenuation*` property called `BounceSoundAttenuation`. This property should
    be a `UPROPERTY`, and have the `EditDefaultsOnly` tag so that it can be edited
    in the Blueprint:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DodgeballProjectile`的头文件，并添加一个名为`BounceSoundAttenuation`的`protected` `class
    USoundAttenuation*`属性。这个属性应该是一个`UPROPERTY`，并且有`EditDefaultsOnly`标记，以便可以在蓝图中进行编辑：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go to the `DodgeballProjectile` class'' implementation of the `OnHit` function
    in its source file, and add the following parameters to the call to the `PlaySoundAtLocation`
    function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DodgeballProjectile`类的源文件中的`OnHit`函数的实现，并向`PlaySoundAtLocation`函数的调用添加以下参数：
- en: '`StartTime`, which we''ll pass with a value of `0`. This value indicates the
    time that the sound will start playing. If the sound lasts 2 seconds, we can have
    this sound start at its 1-second mark by passing a value of `1`. We pass a value
    of `0` to have the sound play from the start.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartTime`，我们将传递一个值为`0`。这个值表示声音开始播放的时间。如果声音持续2秒，我们可以通过传递值`1`使这个声音从其1秒标记开始。我们传递一个值`0`，以便从头开始播放声音。'
- en: '`SoundAttenuation`, to which we''ll pass our `BounceSoundAttenuation` property:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundAttenuation`，我们将传递我们的`BounceSoundAttenuation`属性：'
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we only want to pass the additional `SoundAttenuation` parameter, we
    have to pass all the other parameters that come before it as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只想传递额外的`SoundAttenuation`参数，但我们也必须传递所有其他在它之前的参数。
- en: Compile these changes and then open the editor.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改，然后打开编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `BounceSoundAttenuation` property to our `BounceAttenuation` asset:![Figure
    9.9: Setting the BoundSoundAttenuation property to the BounceAttenuation asset'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，转到其`类默认`选项卡，并将`BounceSoundAttenuation`属性设置为我们的`BounceAttenuation`资产：![图9.9：将BoundSoundAttenuation属性设置为BounceAttenuation资产
- en: '](img/B16183_09_09.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_09.jpg)'
- en: 'Figure 9.9: Setting the BoundSoundAttenuation property to the BounceAttenuation
    asset'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：将BoundSoundAttenuation属性设置为BounceAttenuation资产
- en: 'Play the level again and enter the enemy character''s line of sight. You should
    now notice that the sound that plays every time the dodgeball thrown by the enemy
    character hits a wall or the floor will be played at different volumes, depending
    on its distance, and that you won''t hear it if the dodgeball is far away:![Figure
    9.10: The player character causing the enemy character to throw dodgeballs'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放关卡并进入敌人角色的视线范围。您现在应该注意到，每当敌人角色投掷的躲避球击中墙壁或地板时播放的声音会根据距离的不同以不同的音量播放，并且如果躲避球远了，您将听不到它：![图9.10：玩家角色使敌人角色投掷躲避球
- en: '](img/B16183_09_10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_10.jpg)'
- en: 'Figure 9.10: The player character causing the enemy character to throw dodgeballs'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：玩家角色使敌人角色投掷躲避球
- en: With that, we can conclude this exercise. You now know how to play 3D sounds
    using UE4\. We'll add background music to our game in the next exercise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以结束这个练习。您现在知道如何使用UE4播放3D声音。我们将在下一个练习中为我们的游戏添加背景音乐。
- en: 'Exercise 9.04: Adding Background Music to Our Game'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.04：为我们的游戏添加背景音乐
- en: 'In this exercise, we will add background music to our game. We will do this
    by creating a new Actor with an Audio component, which, as we mentioned earlier,
    is appropriate for playing background music. To achieve this, follow these steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们的游戏添加背景音乐。我们将通过创建一个带有音频组件的新Actor来实现这一点，正如我们之前提到的，这是适合播放背景音乐的。要实现这一点，请按照以下步骤进行：
- en: Download the audio file located at [https://packt.live/3pg21sQ](https://packt.live/3pg21sQ)
    and import it into the `Audio` folder of the `Content Browser` interface, just
    like we did in *Exercise 9.01*, *Importing an Audio File*.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载位于[https://packt.live/3pg21sQ](https://packt.live/3pg21sQ)的音频文件，并将其导入到“Content
    Browser”界面的“音频”文件夹中，就像我们在“练习9.01”、“导入音频文件”中所做的那样。
- en: '*Right-click* inside the `Content Browser` interface and create a new C++ class
    with the `Actor` class as its parent class. Name this new class `MusicManager`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“Content Browser”界面内部，并使用“Actor”类作为其父类创建一个新的C++类。将这个新类命名为“MusicManager”。'
- en: When the files for this class are generated and Visual Studio has opened automatically,
    close the editor.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当为这个类生成文件并且Visual Studio自动打开时，关闭编辑器。
- en: 'In the `MusicManager` class''s header file, add a new `protected` property
    of the `class UAudioComponent*` type called `AudioComponent`. Make this a `UPROPERTY`
    and add the `VisibleAnywhere` and `BlueprintReadOnly` tags:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“MusicManager”类的头文件中，添加一个名为“AudioComponent”的新的受保护属性，类型为“class UAudioComponent*”。将其设置为“UPROPERTY”，并添加“VisibleAnywhere”和“BlueprintReadOnly”标签：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `MusicManager` class''s source file, add an `include` for the `AudioComponent`
    class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“MusicManager”类的源文件中，添加“AudioComponent”类的包含：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the constructor for this class, change the `bCanEverTick` property to `false`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类的构造函数中，将“bCanEverTick”属性更改为“false”：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this line, add a new one that creates the `AudioComponent` class by calling
    the `CreateDefaultSubobject` function and passing the `UAudioComponent` class
    as a template parameter and `"Music Component"` as a normal parameter:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行之后，添加一个新的行，通过调用“CreateDefaultSubobject”函数并将“UAudioComponent”类作为模板参数和“Music
    Component”作为普通参数传递来创建“AudioComponent”类：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After making these changes, compile your code and open the editor.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行这些更改后，编译您的代码并打开编辑器。
- en: Go to the `ThirdPersonCPP` -> `Blueprints` folder in the `Content Browser` interface
    and create a new Blueprint class that inherits from the `MusicManager` class.
    Name it `BP_MusicManager`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“Content Browser”界面中的“ThirdPersonCPP” -> “Blueprints”文件夹，并创建一个从“MusicManager”类继承的新蓝图类。将其命名为“BP_MusicManager”。
- en: 'Open this asset, select its `Audio` component, and set that component''s `Sound`
    property to your imported sound:![Figure 9.11: The Sound property being updated'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个资产，选择它的“音频”组件，并将该组件的“声音”属性设置为您导入的声音：![图9.11：更新声音属性
- en: '](img/B16183_09_11.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_11.jpg)'
- en: 'Figure 9.11: The Sound property being updated'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：更新声音属性
- en: Drag an instance of the `BP_MusicManager` class into the level.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“BP_MusicManager”类的实例拖入关卡中。
- en: Play the level. You should notice the music start playing when the game starts
    and it should also loop automatically when it reaches the end (this is done thanks
    to the Audio component).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡。您应该注意到游戏开始时音乐开始播放，并且当它到达结尾时也应该自动循环播放（这是通过音频组件实现的）。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Audio components will automatically loop whatever sound they're playing, so
    there's no need to change that Sound asset's `Looping` property.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 音频组件将自动循环播放它们正在播放的任何声音，因此不需要更改该声音资产的“循环”属性。
- en: After completing all these steps, we've completed this exercise. You now know
    how to add simple background music to your game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，我们已经完成了这个练习。您现在知道如何为您的游戏添加简单的背景音乐了。
- en: Now, let's jump into the next topic, which is Particle Systems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一个话题，即粒子系统。
- en: Particle Systems
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: 'Let''s talk about another very important element of many video games: Particle Systems.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈许多视频游戏中非常重要的另一个元素：粒子系统。
- en: 'In video game terms, a particle is essentially a position in a 3D space that
    can be represented with an image. A Particle System is a collection of many particles,
    potentially with different images, shapes, colors, and sizes. In the following
    image, you will find an example of two Particle Systems made in UE4:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏术语中，粒子实质上是3D空间中可以用图像表示的位置。粒子系统是许多粒子的集合，可能具有不同的图像、形状、颜色和大小。在下图中，您将找到在UE4中制作的两个粒子系统的示例：
- en: '![Figure 9.12: Two different Particle Systems in UE4'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12：UE4中的两个不同的粒子系统'
- en: '](img/B16183_09_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_12.jpg)'
- en: 'Figure 9.12: Two different Particle Systems in UE4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：UE4中的两个不同的粒子系统
- en: The Particle System on the left is supposed to be electrical sparks that could
    come from a cable that has been sliced and is now in short-circuit, while the
    one on the right is supposed to be a fire. Although the particle system on the
    left is relatively simple, you can tell that the one on the right has more than
    one type of particle inside it, which can be combined in the same system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的粒子系统应该是电火花，可能来自被切割并且现在处于短路状态的电缆，而右侧的粒子系统应该是火。虽然左侧的粒子系统相对简单，但您可以看出右侧的粒子系统内有多种类型的粒子，这些粒子可以组合在同一个系统中。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'UE4 has two different tools for creating Particle Systems: `Cascade` and `Niagara`.
    Cascade is the tool that has been present since the beginning of UE4, while Niagara
    is a system that is more recent and sophisticated and has only been production-ready
    since May 2020, as of Unreal Engine version 4.25.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: UE4有两种不同的工具用于创建粒子系统：`Cascade`和`Niagara`。Cascade是自UE4开始就存在的工具，而Niagara是一个更近期和复杂的系统，自2020年5月以来才成熟可用，截至虚幻引擎版本4.25。
- en: Creating Particle Systems in UE4 is outside the scope of this book, but it is
    recommended that you use Niagara over Cascade, given that it is a more recent
    addition to the engine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中创建粒子系统超出了本书的范围，但建议您使用Niagara而不是Cascade，因为它是引擎的最新添加。
- en: 'In this chapter, we will only be using Particle Systems that are already included
    in UE4, but if you want to create your own, these links will give you more information
    about both Cascade and Niagara:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只使用已经包含在UE4中的粒子系统，但如果您想创建自己的粒子系统，这些链接将为您提供有关Cascade和Niagara的更多信息：
- en: 'Cascade: [https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade](https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Cascade：[https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade](https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade)
- en: '[https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)'
- en: 'Niagara: [https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Niagara：[https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html)
- en: '[https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart](https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart](https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart)'
- en: We'll learn how to add Particle Systems to our game in the next exercise. In
    this chapter, we will be simply using existing Particle Systems that were already
    made by the UE4 team.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中学习如何将粒子系统添加到我们的游戏中。在本章中，我们将简单地使用已经由UE4团队制作的现有粒子系统。
- en: 'Exercise 9.05: Spawning a Particle System When the Dodgeball Hits the Player'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：当躲避球击中玩家时生成一个粒子系统
- en: In this exercise, we will get to know how to spawn a Particle System in UE4\.
    In this case, we will be spawning an `explosion` Particle System when a dodgeball
    thrown by the enemy hits the player.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将了解如何在UE4中生成一个粒子系统。在这种情况下，当敌人投掷的躲避球击中玩家时，我们将生成一个`explosion`粒子系统。
- en: 'To achieve this, follow these steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，请按照以下步骤：
- en: Close the editor and open Visual Studio.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，打开Visual Studio。
- en: In the `DodgeballProjectile` class's header file, add a protected `class UParticleSystem*`
    property called `HitParticles`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballProjectile`类的头文件中，添加一个受保护的`class UParticleSystem*`属性，名为`HitParticles`。
- en: 'The `UParticleSystem` type is the designation for a Particle System in UE4\.
    Be sure to make this a `UPROPERTY` and give it the `EditDefaultsOnly` tag so that
    it can be edited in the Blueprint class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`UParticleSystem`类型是UE4中的粒子系统的指定。确保将其设置为`UPROPERTY`并给予`EditDefaultsOnly`标签，以便可以在蓝图类中进行编辑：'
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `DodgeballProjectile` class's source file, inside its implementation
    of the `OnHit` function. Before the call to the `Destroy` function, check whether
    our `HitParticles` property is valid. If it is, call the `GameplayStatics` object's
    `SpawnEmitterAtLocation` function.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballProjectile`类的源文件中，在其`OnHit`函数的实现中。在调用`Destroy`函数之前，检查我们的`HitParticles`属性是否有效。如果有效，调用`GameplayStatics`对象的`SpawnEmitterAtLocation`函数。
- en: 'This function will spawn an actor that will play the Particle System we pass
    as a parameter. It receives the following parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将生成一个将播放我们传递的粒子系统的角色。它接收以下参数：
- en: A `World` object, which we'll pass using the `GetWorld` function.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`World`对象，我们将使用`GetWorld`函数传递。
- en: A `UParticleSystem*` property, which will be our `HitParticles` property.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UParticleSystem*`属性，它将是我们的`HitParticles`属性。
- en: 'The `FTransform` of the actor that will play the Particle System, which we''ll
    pass using the `GetActorTransform` function:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将播放粒子系统的角色的`FTransform`，我们将使用`GetActorTransform`函数传递：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we won't be using it in this project, there is another function related
    to spawning Particle Systems available from the `GameplayStatics` object, which
    is the `SpawnEmitterAttached` function. This function will spawn a Particle System
    and attach it to an actor, which might be useful if you want to, for instance,
    make a moving object light on fire so that the Particle System will always remain
    attached to that object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个项目中不会使用它，但与生成粒子系统相关的另一个函数来自`GameplayStatics`对象，即`SpawnEmitterAttached`函数。此函数将生成一个粒子系统并将其附加到一个角色，如果您想要，例如，使一个移动的物体着火，以便粒子系统始终保持附加到该物体，这可能会有用。
- en: Compile these changes and then open the editor.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改，然后打开编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `HitParticles` property to the `P_Explosion` Particle System asset:![Figure
    9.13: Setting the HitParticles property to P_Explosion'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，转到其`Class Defaults`选项卡，并将`HitParticles`属性设置为`P_Explosion`粒子系统资产：![图9.13：将HitParticles属性设置为P_Explosion
- en: '](img/B16183_09_13.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_13.jpg)'
- en: 'Figure 9.13: Setting the HitParticles property to P_Explosion'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：将HitParticles属性设置为P_Explosion
- en: 'Now, play the level and let your player character get hit by a dodgeball. You
    should now see the explosion Particle System being played:![Figure 9.14: The explosion
    particle system being played when the dodgeball hits the player'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，播放关卡，让您的玩家角色被躲避球击中。现在您应该看到爆炸粒子系统正在播放：![图9.14：当躲避球击中玩家时播放的爆炸粒子系统
- en: '](img/B16183_09_14.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_14.jpg)'
- en: 'Figure 9.14: The explosion particle system being played when the dodgeball
    hits the player'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：当躲避球击中玩家时播放的爆炸粒子系统
- en: And that concludes this exercise. You now know how to play Particle Systems
    in UE4\. Particle Systems will add visual flair to your game and make it more
    visually appealing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这个练习。现在你知道如何在UE4中播放粒子系统。粒子系统将为您的游戏增添视觉效果，使其在视觉上更具吸引力。
- en: In the next activity, we'll be consolidating our knowledge of playing audio
    in UE4 by playing a sound when the dodgeball hits the player.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将通过在躲避球击中玩家时播放声音来巩固我们在UE4中播放音频的知识。
- en: 'Activity 9.01: Playing a Sound When the Dodgeball Hits the Player'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：当躲避球击中玩家时播放声音
- en: In this activity, we will be creating the logic responsible for playing a sound
    every time the player character gets hit by a dodgeball. In a video game, it's
    very important to transmit to the player's crucial information in many ways, so
    in addition to changing the player character's Health Bar, we'll also be playing
    a sound when the player gets hit so that the player knows that the character is
    taking damage.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建逻辑，负责在玩家角色被躲避球击中时每次播放声音。在视频游戏中，以多种方式向玩家传递关键信息非常重要，因此除了改变玩家角色的生命值条外，当玩家被击中时我们还将播放声音，以便玩家知道角色正在受到伤害。
- en: 'To do this, follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤进行：
- en: Import a sound file that will be played when the player character gets hit into
    the `Audio` folder inside the `Content Browser` interface.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个声音文件导入到`内容浏览器`界面内的`Audio`文件夹中，该声音文件将在玩家角色被击中时播放。
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't have a sound file, you can use the one available at [https://www.freesoundeffects.com/free-track/punch-426855/](https://www.freesoundeffects.com/free-track/punch-426855/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有声音文件，您可以使用[https://www.freesoundeffects.com/free-track/punch-426855/](https://www.freesoundeffects.com/free-track/punch-426855/)上提供的声音文件。
- en: Open the `DodgeballProjectile` class's header file. Add a `SoundBase*` property,
    just like we did in *Exercise 9.02*, *Playing a Sound When the Dodgeball Bounces
    off of a Surface*, but this time call it `DamageSound`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DodgeballProjectile`类的头文件。添加一个`SoundBase*`属性，就像我们在*练习9.02*中所做的那样，*当躲避球从表面弹开时播放声音*，但这次称其为`DamageSound`。
- en: Open the `DodgeballProjectile` class's source file. In the `OnHit` function's
    implementation, after you've damaged the player character and before you call
    the `Destroy` function, check whether the `DamageSound` property is valid. If
    it is, call the `GameplayStatics` object's `PlaySound2D` function (mentioned in
    *Exercise 9.02,* *Playing a Sound When the Dodgeball Bounces off of a Surface*),
    passing `this` and `DamageSound` as the parameters to that function call.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DodgeballProjectile`类的源文件。在`OnHit`函数的实现中，在你伤害了玩家角色并在调用`Destroy`函数之前，检查`DamageSound`属性是否有效。如果有效，调用`GameplayStatics`对象的`PlaySound2D`函数（在*练习9.02*中提到，*当躲避球从表面弹开时播放声音*），将`this`和`DamageSound`作为该函数调用的参数。
- en: Compile your changes and open the editor.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的更改并打开编辑器。
- en: Open the `BP_DodgeballProjectile` Blueprint and set its `DamageSound` property
    to the sound file you imported at the start of this activity.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，并将其`DamageSound`属性设置为您在本活动开始时导入的声音文件。
- en: 'When you play the level, you should notice that every time the player gets
    hit by a dodgeball, you will hear the sound you imported being played:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您播放关卡时，您应该注意到每当玩家被躲避球击中时，您将听到您导入的声音被播放：
- en: '![Figure 9.15: A sound should play when the player character gets hit'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：当玩家角色被击中时应该播放声音'
- en: '](img/B16183_09_15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_15.jpg)'
- en: 'Figure 9.15: A sound should play when the player character gets hit'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：当玩家角色被击中时应该播放声音
- en: And with those steps complete, you have finished this activity and consolidated
    the use of playing both 2D and 3D sounds in UE4.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这些步骤后，您已经完成了这个活动，并巩固了在UE4中播放2D和3D声音的使用。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Now, let's wrap up this chapter by learning a bit about the concept of Level
    Design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过学习一些关于关卡设计概念来结束本章。
- en: Level Design
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡设计
- en: Since *Chapter 5*, *Line Traces*, related to our dodgeball game, we've added
    quite a few game mechanics and gameplay opportunities, as well as some audio-visual
    elements, all of which were handled in this chapter. Now that we have all these
    game elements, we must bring them together into a level that can be played from
    start to finish by the player. To do that, let's learn a bit about Level Design
    and level blockouts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 自*第5章*，*线性跟踪*，与我们的躲避球游戏相关，我们已经添加了相当多的游戏机制和游戏机会，以及一些视听元素，所有这些都在本章中处理。现在我们有了所有这些游戏元素，我们必须将它们汇集到一个可以由玩家从头到尾玩的关卡中。为此，让我们学习一些关于关卡设计和关卡布局的知识。
- en: Level Design is a specific Game Design discipline that focuses on building levels
    in a game. The goal of a Level Designer is to make a level that is fun to play,
    introduces new gameplay concepts to the player by using the game mechanics built
    for that game, contains good pacing (a good balance of action-packed and relaxed
    gameplay sequences), and much more.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡设计是一种特定的游戏设计学科，专注于在游戏中构建关卡。关卡设计师的目标是制作一个有趣的关卡，通过使用为该游戏构建的游戏机制向玩家介绍新的游戏玩法概念，包含良好的节奏（充满动作和轻松的游戏序列的良好平衡），以及更多内容。
- en: 'To test the structure of a level, Level Designers will first build what is
    called a **level blockout**. This is a very simple and boiled down version of
    the level that uses most of the elements that the final level will contain, but
    it is made using only simple shapes and geometry. The reason for this is for it
    to be easier and less time-consuming to modify the level in case parts of it need
    to be changed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试关卡的结构，关卡设计师将首先构建所谓的**关卡布局**。这是关卡的一个非常简单和简化版本，使用了最终关卡将包含的大部分元素，但只使用简单的形状和几何图形制作。这样做的原因是为了在需要修改关卡的部分时更容易和节省时间：
- en: '![Figure 9.16: An example of a level blockout made in UE4 using BSP Brushes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：使用BSP Brushes在UE4中制作的关卡布局示例'
- en: '](img/B16183_09_16.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_16.jpg)'
- en: 'Figure 9.16: An example of a level blockout made in UE4 using BSP Brushes'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：使用BSP Brushes在UE4中制作的关卡布局示例
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that Level Design is its own specific game development skill
    and is worthy of its own book, of which there are quite a few, but diving into
    this topic is outside the scope of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，关卡设计是一种特定的游戏开发技能，值得有一本专门的书来介绍，而实际上也有很多这样的书，但是深入讨论这个话题超出了本书的范围。
- en: In the next exercise, we will be building a simple level blockout using the
    mechanics we built in the last few chapters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用我们在最近几章中构建的机制来构建一个简单的关卡布局。
- en: 'Exercise 9.06: Building a Level Blockout'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.06：构建关卡布局
- en: In this exercise, we will be creating a new level blockout that will contain
    some structure, where the player will start in a certain place in the level and
    have to go through a series of obstacles to reach the end of the level. We will
    be using all the mechanics and objects that we built in the last few chapters
    to make a level that the player will be able to complete.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的关卡布局，其中包含一些结构，玩家将从关卡的某个地方开始，并通过一系列障碍物到达关卡的结尾。我们将使用我们在最近几章中构建的所有机制和对象来制作一个玩家能够完成的关卡。
- en: Although in this exercise we will be providing you with a solution, you are
    encouraged to let your creativity loose and come up with your solution, given
    that there is no right or wrong answer in this case.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个练习中我们将为您提供一个解决方案，但鼓励您发挥创造力，提出自己的解决方案，因为在这种情况下没有对错之分。
- en: 'To start this exercise, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个练习，请按照以下步骤操作：
- en: Open the editor.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: Go to the `ThirdPersonCPP` -> `Maps` folder in your `Content Browser`, duplicate
    the `ThirdPersonExampleMap` asset, and name it `Level1`. You can do this by either
    selecting the asset and pressing *Ctrl* + *W* or by right-clicking on the asset
    and selecting `Duplicate` (the third option).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“ThirdPersonCPP”->“内容浏览器”中的“地图”文件夹，复制“ThirdPersonExampleMap”资产，并将其命名为“Level1”。您可以通过选择资产并按下*Ctrl*
    + *W*或右键单击资产并选择“复制”（第三个选项）来执行此操作。
- en: Open the newly created `Level1` map.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的“Level1”地图。
- en: 'Delete all the objects that have a mesh inside the map, except for the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除地图中具有网格的所有对象，除了以下对象：
- en: The player character
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家角色
- en: The enemy character (note that both characters will look the same)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人角色（注意两个角色看起来是一样的）
- en: The floor object
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地板对象
- en: Both the Wall objects that we created
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的墙对象
- en: The Victory Box object
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利箱对象
- en: Keep in mind that assets related to lighting and sound should remain untouched.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与照明和声音相关的资产应保持不变。
- en: Build the lighting for `Level1` by pressing the `Build` button. This button
    is to the left of the `Play` button, in the `Toolbar` at the top of the editor
    window.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下“构建”按钮为“Level1”建立照明。该按钮位于编辑器窗口顶部的“工具栏”中，“播放”按钮的左侧。
- en: 'Once you''ve followed these steps, you should have an empty floor with just
    the objects you''ll be needing for this level (the ones mentioned in *Step 4*).
    Here''s the `Level1` map before and after you followed *Steps 4 and 5*, respectively:![Figure
    9.17: Before deleting the required objects'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您按照这些步骤操作后，您应该有一个空的地板，只有您在这个关卡中需要的对象（在*步骤4*中提到的对象）。以下是在您分别按照*步骤4和5*之后的“Level1”地图之前和之后的情况：![图9.17：删除所需对象之前
- en: '](img/B16183_09_17.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_17.jpg)'
- en: 'Figure 9.17: Before deleting the required objects'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：删除所需对象之前
- en: 'Once you have deleted the objects, your floor should look as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你删除了对象，你的地板应该如下所示：
- en: '![Figure 9.18: After deleting the required objects'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18：删除所需对象后'
- en: '](img/B16183_09_18.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_18.jpg)'
- en: 'Figure 9.18: After deleting the required objects'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：删除所需对象后
- en: Because building a level, even a simple one, is something that takes a lot of
    steps and instructions, you will simply be shown a few screenshots of a possible
    level and, again, be encouraged to come up with your own.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为建立一个关卡，即使是一个简单的关卡，也需要很多步骤和指示，所以我们将简单地展示一些可能的关卡截图，并鼓励您自己想出解决方案。
- en: 'In this case, we have simply used the existing `EnemyCharacter`, `Wall`, and
    `GhostWall` objects and duplicated them several times to create a simple layout
    that the player can traverse from start to finish. We also moved the `VictoryBox`
    object so that it matches the new level''s end location:![Figure 9.19: The created
    level – isometric view'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是简单地使用了现有的“EnemyCharacter”、“Wall”和“GhostWall”对象，并将它们多次复制，以创建玩家可以从头到尾穿越的简单布局。我们还移动了“VictoryBox”对象，使其与新关卡的结束位置匹配：![图9.19：创建的关卡-等距视图
- en: '](img/B16183_09_19.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_19.jpg)'
- en: 'Figure 9.19: The created level – isometric view'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：创建的关卡-等距视图
- en: 'The level can be seen in a top-down view as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡可以从俯视图中看到如下：
- en: '![Figure 9.20: The created level – top-down view with the player'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：创建的关卡-俯视图与玩家'
- en: character marked with an arrow
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用箭头标记的角色
- en: '](img/B16183_09_20.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_09_20.jpg)'
- en: 'Figure 9.20: The created level – top-down view with the player character marked
    with an arrow'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：创建的关卡-俯视图，玩家角色用箭头标记
- en: Once you're happy with the result, this means you have finished your Dodgeball
    game, and can now ask for your friends and family to play it and see what they
    think. Great job – you are one step closer to mastering the art of game development!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对结果满意，这意味着你已经完成了你的躲避球游戏，现在可以邀请你的朋友和家人来玩，并看看他们的想法。干得好 - 你离掌握游戏开发的艺术又近了一步！
- en: Extra Features
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能
- en: 'Before we conclude this chapter, here are some suggestions on what you can
    do next in this dodgeball project:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，这里有一些建议，关于接下来在这个躲避球项目中你可以做些什么：
- en: Make it so that the normal `Wall` class we created in a previous chapter doesn't
    block the enemy's line of sight. This way, the enemy will always throw dodgeballs
    at the player, which should still be blocked from going through this wall.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使之前创建的普通“墙”类不会阻挡敌人的视线。这样，敌人将始终向玩家投掷躲避球，但仍然会被这堵墙挡住。
- en: Add a new feature that will allow the player to visualize where the dodgeball
    thrown by the enemy character will impact first, using the concept of Sweep Traces.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新功能，允许玩家通过“扫描轨迹”概念来可视化敌人角色投掷的躲避球首先会影响到哪里。
- en: Add a new type of wall that blocks the player character, the enemy character,
    and the dodgeballs, but that also takes damage from dodgeballs and gets destroyed
    when it runs out of health points.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一种新类型的墙，可以阻挡玩家角色、敌人角色和躲避球，但也会受到躲避球的伤害，并在耗尽生命值时被摧毁。
- en: There is a whole world of possibilities for expanding the scope of this project.
    You are encouraged to use the skills you've learned, and to do further research,
    to build new features and add more complexity to your game.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的扩展空间是无限的。我们鼓励你运用所学的技能，并进行进一步的研究，为你的游戏添加新功能并增加更多的复杂性。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have now completed the dodgeball game project. In this chapter, you learned
    how to add polish to your game by playing audio and using Particle Systems. You
    now know how to add 2D and 3D sounds to your game, as well as some of the tools
    at your disposal in regard to that. Now, you can try to add even more sounds effects
    to your game, such as a special sound effect for when an enemy character sees
    you for the first time (such as in Metal Gear Solid), a footstep sound effect,
    or a victory sound effect.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了躲避球游戏项目。在本章中，你学会了如何通过播放音频和使用粒子系统来为你的游戏增添亮点。你现在知道如何为你的游戏添加2D和3D声音，以及一些相关的工具。现在，你可以尝试为你的游戏添加更多的声音效果，比如当敌人角色第一次看到你时的特殊声音效果（比如《合金装备》中的情况）、脚步声音效果或者胜利声音效果。
- en: You also built a level using all the tools that you made throughout the last
    few chapters, thus culminating all the logic we built in this project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用了在前几章中制作的所有工具来构建一个关卡，从而汇总了我们在这个项目中构建的所有逻辑。
- en: 'In the next chapter, we''ll be starting a new project: the `SuperSideScroller`
    game. In that project, you''ll be introduced to such topics as power-ups, collectibles,
    enemy **Artificial Intelligence** (**AI**), character animation, and much more.
    You will be creating a side-scrolling platformer game where you control a character
    that must complete a level, collect gems, and use power-ups to avoid the enemies.
    The two most important topics you will learn about are UE4''s behavior trees and
    Blackboards, which fuel the AI system, and Animation Blueprints, which allow you
    to manage your character''s animations.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新项目：《超级横向卷轴》游戏。在那个项目中，你将接触到诸如增益、可收集物品、敌人人工智能（AI）、角色动画等主题。你将创建一个横向卷轴平台游戏，控制一个角色完成关卡，收集宝石，并使用增益来避开敌人。你将学习的两个最重要的主题是UE4的行为树和黑板，它们支持AI系统，以及动画蓝图，它允许你管理角色的动画。
