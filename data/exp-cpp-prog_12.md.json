["```cpp\n#include <pthread.h> \n#include <stdlib.h> \n\n#define NUM_THREADS     5 \n```", "```cpp\nvoid* worker(void* arg) { \n    int value = *((int*) arg); \n\n    // More business logic. \n\n    return 0; \n} \n```", "```cpp\nint main(int argc, char** argv) { \n    pthread_t threads[NUM_THREADS]; \n    int thread_args[NUM_THREADS]; \n    int result_code; \n\n    for (unsigned int i = 0; i < NUM_THREADS; ++i) { \n        thread_args[i] = i; \n        result_code = pthread_create(&threads[i], 0, worker, (void*) &thread_args[i]); \n    } \n```", "```cpp\n    for (int i = 0; i < NUM_THREADS; ++i) { \n        result_code = pthread_join(threads[i], 0); \n    } \n\n    exit(0); \n} \n```", "```cpp\nstatic pthread_mutex_t func_mutex = PTHREAD_MUTEX_INITIALIZER; \n\nvoid func() { \n    pthread_mutex_lock(&func_mutex); \n\n    // Do something that's not thread-safe. \n\n    pthread_mutex_unlock(&func_mutex); \n} \n```", "```cpp\n#include <pthread.h> \n#include <stdlib.h>\n#include <unistd.h>\n\n   #define COUNT_TRIGGER 10 \n   #define COUNT_LIMIT 12 \n\n   int count = 0; \n   int thread_ids[3] = {0,1,2}; \n   pthread_mutex_t count_mutex; \n   pthread_cond_t count_cv; \n```", "```cpp\nvoid* add_count(void* t)  { \n    int tid = (long) t; \n    for (int i = 0; i < COUNT_TRIGGER; ++i) { \n        pthread_mutex_lock(&count_mutex); \n        count++; \n        if (count == COUNT_LIMIT) { \n            pthread_cond_signal(&count_cv); \n        } \n\n        pthread_mutex_unlock(&count_mutex); \n        sleep(1); \n    } \n\n    pthread_exit(0); \n} \n```", "```cpp\nvoid* watch_count(void* t) { \n    int tid = (int) t; \n\n    pthread_mutex_lock(&count_mutex); \n    if (count < COUNT_LIMIT) { \n        pthread_cond_wait(&count_cv, &count_mutex); \n    } \n\n    pthread_mutex_unlock(&count_mutex); \n    pthread_exit(0); \n} \n```", "```cpp\nint main (int argc, char* argv[]) { \n    int tid1 = 1, tid2 = 2, tid3 = 3; \n    pthread_t threads[3]; \n    pthread_attr_t attr; \n\n    pthread_mutex_init(&count_mutex, 0); \n    pthread_cond_init (&count_cv, 0); \n\n    pthread_attr_init(&attr); \n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); \n    pthread_create(&threads[0], &attr, watch_count, (void *) tid1); \n    pthread_create(&threads[1], &attr, add_count, (void *) tid2); \n    pthread_create(&threads[2], &attr, add_count, (void *) tid3); \n\n    for (int i = 0; i < 3; ++i) { \n        pthread_join(threads[i], 0); \n    } \n\n    pthread_attr_destroy(&attr); \n    pthread_mutex_destroy(&count_mutex); \n    pthread_cond_destroy(&count_cv); \n    return 0; \n}  \n```", "```cpp\n#include <pthread.h> \nint pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr); \npthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; \n```", "```cpp\nint pthread_rwlock_rdlock(pthread_rwlock_t* rwlock); \nint pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock); \n```", "```cpp\nint pthread_rwlock_wrlock(pthread_rwlock_t* rwlock); \nint pthread_rwlock_trywrlock(pthread_rwlock_t * rwlock); \n```", "```cpp\npthread_key_t global_var_key;\n\nvoid* worker(void* arg) {\n    int *p = new int;\n    *p = 1;\n    pthread_setspecific(global_var_key, p);\n    int* global_spec_var = (int*) pthread_getspecific(global_var_key);\n    *global_spec_var += 1;\n    pthread_setspecific(global_var_key, 0);\n    delete p;\n    pthread_exit(0);\n}\n```", "```cpp\nint main(void) {\n    pthread_t threads[5];\n\n    pthread_key_create(&global_var_key, 0);\n    for (int i = 0; i < 5; ++i)\n        pthread_create(&threads[i],0,worker,0);\n    for (int i = 0; i < 5; ++i) {\n        pthread_join(threads[i], 0);\n    }\n    return 0;\n}\n```", "```cpp\n#include <windows.h> \n#include <tchar.h> \n#include <strsafe.h> \n\n#define MAX_THREADS 3 \n#define BUF_SIZE 255  \n```", "```cpp\ntypedef struct MyData { \n int val1; \n int val2; \n} MYDATA, *PMYDATA;\n\nDWORD WINAPI worker(LPVOID lpParam) { \n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); \n    if (hStdout == INVALID_HANDLE_VALUE) { \n        return 1; \n    } \n\n    PMYDATA pDataArray =  (PMYDATA) lpParam; \n\n    TCHAR msgBuf[BUF_SIZE]; \n    size_t cchStringSize; \n    DWORD dwChars; \n    StringCchPrintf(msgBuf, BUF_SIZE, TEXT(\"Parameters = %d, %dn\"),  \n    pDataArray->val1, pDataArray->val2);  \n    StringCchLength(msgBuf, BUF_SIZE, &cchStringSize); \n    WriteConsole(hStdout, msgBuf, (DWORD) cchStringSize, &dwChars, NULL); \n\n    return 0;  \n}  \n```", "```cpp\nvoid errorHandler(LPTSTR lpszFunction) { \n    LPVOID lpMsgBuf; \n    LPVOID lpDisplayBuf; \n    DWORD dw = GetLastError();  \n\n    FormatMessage( \n        FORMAT_MESSAGE_ALLOCATE_BUFFER |  \n        FORMAT_MESSAGE_FROM_SYSTEM | \n        FORMAT_MESSAGE_IGNORE_INSERTS, \n        NULL, \n        dw, \n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), \n        (LPTSTR) &lpMsgBuf, \n        0, NULL); \n\n        lpDisplayBuf = (LPVOID) LocalAlloc(LMEM_ZEROINIT,  \n        (lstrlen((LPCTSTR) lpMsgBuf) + lstrlen((LPCTSTR) lpszFunction) + 40) * sizeof(TCHAR));  \n        StringCchPrintf((LPTSTR)lpDisplayBuf,  \n        LocalSize(lpDisplayBuf) / sizeof(TCHAR), \n        TEXT(\"%s failed with error %d: %s\"),  \n        lpszFunction, dw, lpMsgBuf);  \n        MessageBox(NULL, (LPCTSTR) lpDisplayBuf, TEXT(\"Error\"), MB_OK);  \n\n        LocalFree(lpMsgBuf); \n        LocalFree(lpDisplayBuf); \n} \n```", "```cpp\nint _tmain() {\n         PMYDATA pDataArray[MAX_THREADS];\n         DWORD dwThreadIdArray[MAX_THREADS];\n         HANDLE hThreadArray[MAX_THREADS];\n         for (int i = 0; i < MAX_THREADS; ++i) {\n               pDataArray[i] = (PMYDATA) HeapAlloc(GetProcessHeap(),\n                           HEAP_ZERO_MEMORY, sizeof(MYDATA));                     if (pDataArray[i] == 0) {\n                           ExitProcess(2);\n             }\n             pDataArray[i]->val1 = i;\n             pDataArray[i]->val2 = i+100;\n             hThreadArray[i] = CreateThread(\n                  NULL,          // default security attributes\n                  0,             // use default stack size\n                  worker,        // thread function name\n                  pDataArray[i], // argument to thread function\n                  0,             // use default creation flags\n                  &dwThreadIdArray[i]);// returns the thread identifier\n             if (hThreadArray[i] == 0) {\n                         errorHandler(TEXT(\"CreateThread\"));\n                         ExitProcess(3);\n             }\n   }\n         WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE);\n         for (int i = 0; i < MAX_THREADS; ++i) {\n               CloseHandle(hThreadArray[i]);\n               if (pDataArray[i] != 0) {\n                           HeapFree(GetProcessHeap(), 0, pDataArray[i]);\n               }\n         }\n         return 0;\n}\n```", "```cpp\nPOCO\n```", "```cpp\n#include \"Poco/Thread.h\" \n#include \"Poco/Runnable.h\" \n#include <iostream> \n\nclass HelloRunnable: public Poco::Runnable { \n    virtual void run() { \n        std::cout << \"Hello, world!\" << std::endl; \n    } \n}; \n\nint main(int argc, char** argv) { \n    HelloRunnable runnable; \n    Poco::Thread thread; \n    thread.start(runnable); \n    thread.join(); \n    return 0; \n} \n```", "```cpp\n#include \"Poco/ThreadPool.h\" \n#include \"Poco/Runnable.h\" \n#include <iostream> \n\nclass HelloRunnable: public Poco::Runnable { \n    virtual void run() { \n        std::cout << \"Hello, world!\" << std::endl; \n    } \n}; \n\nint main(int argc, char** argv) { \n    HelloRunnable runnable; \n    Poco::ThreadPool::defaultPool().start(runnable); \n    Poco::ThreadPool::defaultPool().joinAll(); \n    return 0; \n} \n```", "```cpp\n#include \"Poco/Thread.h\" \n#include \"Poco/Runnable.h\" \n#include \"Poco/ThreadLocal.h\" \n#include <iostream> \n\nclass Counter: public Poco::Runnable { \n    void run() { \n        static Poco::ThreadLocal<int> tls; \n        for (*tls = 0; *tls < 10; ++(*tls)) { \n            std::cout << *tls << std::endl; \n        } \n    } \n}; \n\nint main(int argc, char** argv) { \n    Counter counter1; \n    Counter counter2; \n    Poco::Thread t1; \n    Poco::Thread t2; \n    t1.start(counter1); \n    t2.start(counter2); \n    t1.join(); \n    t2.join(); \n    return 0; \n} \n```"]