- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating Libraries for FetchContent
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 FetchContent 创建库
- en: In [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065), *Using FetchContent with
    External Dependencies*, we covered a lot of ground understanding how to use `FetchContent`
    as an application developer. This is super useful, and if you’re not interested
    in creating your own libraries, then this knowledge will take you a long way.
    If, however, you’re excited about the possibility of creating a library to share
    across more than one of your projects (or even better, with the broader open source
    community!), then this chapter is for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B21152_03.xhtml#_idTextAnchor065)《使用 FetchContent 处理外部依赖》中，我们详细了解了如何作为应用程序开发者使用
    `FetchContent`。这是非常有用的，如果你不打算创建自己的库，那么这些知识会对你大有帮助。然而，如果你对创建库以在多个项目间共享（或者更好的是，与更广泛的开源社区共享）充满兴趣，那么本章将适合你。
- en: In this chapter, we’re going to cover the CMake commands to create a library,
    and then make it easily accessible through `FetchContent`. The skills you’ll learn
    here are useful for your libraries but can also be applied to other projects not
    using CMake. Depending on the size and complexity of the library, it can often
    only take a few commands to add `FetchContent` support.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍用于创建库的 CMake 命令，并通过 `FetchContent` 使其易于访问。你将在这里学到的技能不仅对你的库有帮助，还可以应用到其他不使用
    CMake 的项目中。根据库的大小和复杂性，通常只需几个命令就能为库添加 `FetchContent` 支持。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Making a library compatible with FetchContent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使库兼容 FetchContent
- en: Moving Game of Life to a library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生命游戏移到库中
- en: Making Game of Life a shared library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生命游戏做成共享库
- en: Final cross-platform additions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的跨平台补充
- en: Interface libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口库
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上进度，请确保你已经满足[*第一章*](B21152_01.xhtml#_idTextAnchor019)《入门》的要求。包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新 **操作系统**（**OS**）的 Windows、Mac 或 Linux 机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可工作的 C/C++ 编译器（如果你还没有的话，建议使用系统默认的编译器，适用于每个平台）
- en: The code examples in this chapter can be found at https://github.com/PacktPublishing/Minimal-CMake.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 https://github.com/PacktPublishing/Minimal-CMake 找到。
- en: Making a library compatible with FetchContent
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使库兼容 FetchContent
- en: 'Returning to our ongoing project, let’s begin by identifying an area of code
    that is ripe for reuse: `array`. Let’s pull this functionality out to a separate
    library so that we can consume it from our main application and potentially reuse
    it in other projects in the future (or share it with other developers who might
    want to try it out).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们正在进行的项目，让我们从识别一块可以重用的代码开始：`array`。我们将把这个功能提取到一个独立的库中，以便从主应用程序中使用，并且将来可能在其他项目中重用（或与其他开发者共享，供他们尝试）。
- en: Project structure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: Before we look at the `CMakeLists.txt` file, let’s make some minor changes to
    the project structure to ensure our library is following common conventions. These
    changes aren’t strictly needed (the libraries we included earlier in [*Chapter
    3*](B21152_03.xhtml#_idTextAnchor065), *Using FetchContent with External Dependencies*
    (`timer_lib` and `as-c-math`), do not adhere to these guidelines), but they’re
    useful to know and will help keep our projects clean and organized as they grow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 `CMakeLists.txt` 文件之前，先对项目结构做一些小的调整，以确保我们的库遵循常见的惯例。这些调整并非严格必要（我们在[*第三章*](B21152_03.xhtml#_idTextAnchor065)《使用
    FetchContent 处理外部依赖》中包含的库（`timer_lib` 和 `as-c-math`）并未遵循这些指南），但了解这些惯例是有用的，并且它们将帮助我们在项目不断发展时保持整洁和有序。
- en: 'Starting with the `array/` folder we saw throughout [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032)*,*
    *Hello, CMake!*, and [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065), *Using FetchContent
    with External Dependencies*, the structure looked like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在[*第二章*](B21152_02.xhtml#_idTextAnchor032)《你好，CMake！》和[*第三章*](B21152_03.xhtml#_idTextAnchor065)《使用
    FetchContent 处理外部依赖》中看到的 `array/` 文件夹开始，结构如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To support reuse, we are going to move `array.h` and `array.c` to a new folder
    outside of our Game of Life application (if you’re following along, create a new
    folder called `minimal-cmake-array` outside the `minimal-cmake` repository and
    copy `array.h` and `array.c` to the locations shown next).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持重用，我们将把`array.h`和`array.c`移到我们“生命游戏”应用程序之外的新文件夹中（如果你在跟随教程，请在`minimal-cmake`仓库之外创建一个名为`minimal-cmake-array`的新文件夹，并将`array.h`和`array.c`复制到接下来展示的位置）。
- en: To keep things self-contained in the *Minimal CMake* book repository ([https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)),
    we’ve moved things to `ch4/part-1/lib/array` for now (think of this as being synonymous
    with a top-level CMake project).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切保持自包含在*Minimal CMake*书籍仓库中（[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)），我们暂时将内容移至`ch4/part-1/lib/array`（可以将其视为顶级CMake项目的同义词）。
- en: 'The structure is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结构如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the introduction of two new directories, `include` and `src`. These names
    are well-established across the open source ecosystem (why `include` and `source`
    or `inc` and `src` are not more common is likely an accident of history). By convention,
    the `include` folder is for public headers (those headers to be included by a
    client); any headers that are solely used within the library itself (private headers)
    should be kept within the `src` folder, along with the source files themselves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意引入了两个新目录，`include`和`src`。这些名称在开源生态系统中已经被广泛采用（为什么`include`和`source`或`inc`和`src`没有更常见，可能是历史上的偶然结果）。根据惯例，`include`文件夹用于公共头文件（那些需要被客户端包含的头文件）；任何仅在库内部使用的头文件（私有头文件）应保存在`src`文件夹中，与源文件本身一起。
- en: 'Another possibility would be to leave `array.h` and `array.c` at the root,
    like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是将`array.h`和`array.c`保留在根目录中，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is arguably fine for small libraries but does come with some downsides.
    If we want to add more source files, these can clutter the root directory and
    make navigation more difficult. Keeping implementation details under the `src`
    folder is a helpful signal to users of the library that they can focus their attention
    elsewhere.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式对于小型库来说无疑是可行的，但也有一些缺点。如果我们想添加更多的源文件，它们可能会使根目录变得杂乱，并增加导航的难度。将实现细节保存在`src`文件夹下，可以给库的用户一个清晰的信号，让他们将注意力集中在其他地方。
- en: An advantage of creating an `include` folder and subdirectory with the name
    of the project is to make `#include` directives in the consuming application or
    library clearer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为项目名称的`include`文件夹及子目录的一个优势是，可以使消费应用程序或库中的`#include`指令更加清晰。
- en: 'It’s much more helpful to see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方式会更加有帮助：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compare the preceding code to the following, which is more difficult to understand:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与以下代码进行对比，后者更难理解：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the first approach, it’s clear exactly where the dependency is coming from.
    This also reduces the likelihood of naming collisions with other libraries (this
    approach falls under the umbrella of *code hygiene*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种方法，可以明确知道依赖项的来源。这还减少了与其他库发生命名冲突的可能性（这种方法属于*代码卫生*的范畴）。
- en: An alternative is to prefix your library files with an identifier. For example,
    we could have decided to rename `array.h` to `mc-array.h`, or `minimal-cmake-array.h`,
    and omitted the subfolder. Prefixing files, as well as function and type names
    (for example, `mc_array_push`) with a project identifier, is also generally good
    practice to help avoid naming collisions with other libraries. In C++, namespaces
    are the preferred mechanism for this, but in C, we must rely on explicit functions
    and type prefixes. This is the approach we’ll take with our array implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是为库文件添加前缀。例如，我们本可以选择将`array.h`重命名为`mc-array.h`，或`minimal-cmake-array.h`，并省略子文件夹。为文件、函数和类型名称（例如，`mc_array_push`）添加项目标识符作为前缀，也是避免与其他库命名冲突的好做法。对于C++，命名空间是首选的机制，但在C语言中，我们必须依赖显式的函数和类型前缀。这也是我们在数组实现中将采用的方法。
- en: In the example presented here, the `src` folder does not have any subfolders.
    This is arbitrary and remains up to the library author to decide. A flat structure
    with no hierarchy under `src` might be fine for a smaller library. For a larger
    library, we might decide to group certain files for better organization. Since
    everything under the `src` folder can be thought of as private to the library,
    the structure under `src` shouldn’t impact clients of the library, so it can be
    anything you like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的示例中，`src` 文件夹没有任何子文件夹。这是随意的，具体如何安排由库的作者决定。对于一个较小的库来说，`src` 下没有层级的扁平结构可能是可以的。而对于较大的库，我们可能会决定将某些文件分组以便更好地组织。由于
    `src` 文件夹下的所有内容都可以视为库的私有部分，因此 `src` 下的结构不应影响库的使用者，所以它可以是你喜欢的任何结构。
- en: 'A quick note about our C implementation is that we may want to use this library
    alongside a C++ application in the future. To accommodate this, we need to wrap
    or annotate all functions with `extern "C"` to ensure that when we’re compiling
    this library with C++, *name mangling* (the process by which C++ supports function
    overloading) doesn’t kick in (in C, you can’t overload functions and the symbol
    names remain unchanged). We also need to ignore `extern "C"` when compiling as
    normal C code. To achieve this, we can use the `__cplusplus` macro to check if
    we’re compiling C++ code or not (`__cplusplus` will only be defined when using
    C++). Putting this all together, we end up with the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的 C 实现有一个简短的说明，我们可能希望将这个库与未来的 C++ 应用程序一起使用。为了适应这种需求，我们需要使用 `extern "C"`
    来包装或注解所有函数，确保当我们用 C++ 编译这个库时，*名称修饰*（C++ 中支持函数重载的过程）不会启动（在 C 中，你不能重载函数，符号名称保持不变）。我们还需要在编译为普通
    C 代码时忽略 `extern "C"`。为了实现这一点，我们可以使用 `__cplusplus` 宏来检查我们是否在编译 C++ 代码（`__cplusplus`
    只有在使用 C++ 时才会定义）。将这一切结合起来，我们得到了如下代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, adopting the folder structure discussed previously will make life easier
    when we reach the topic of installing. In practice, for smaller libraries, this
    may be considered a form of over-engineering, especially if you never plan to
    install such libraries, but we’ve covered it for completeness as this is something
    we’ll need later on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，采用之前讨论的文件夹结构将使得安装时的工作变得更轻松。实际上，对于较小的库来说，这可能被认为是一种过度工程，特别是如果你从不打算安装这些库的话，但我们还是为了完整性考虑介绍了这一部分，因为这是我们后面需要的内容。
- en: The CMakeLists.txt file
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt` 文件'
- en: 'With the folder structure in place, we can review the `CMakeLists.txt` file
    for our new `array` library. The `CMakeLists.txt` file is included in its entirety
    here. We’ll walk through each line step by step, as we did in earlier chapters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在设定好文件夹结构后，我们可以查看新 `array` 库的 `CMakeLists.txt` 文件。此处包含了完整的 `CMakeLists.txt`
    文件。我们将像之前的章节那样，逐行分析：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s skim over the first two lines as they’re the same as before:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们略过前两行，它们与之前相同：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s the obligatory `cmake_minimum_required` command, followed by the equally
    important `project` command. The only difference here is that we’ve given our
    library a name that matches the functionality it provides (an array interface),
    and we’ve also included the prefix we intend to use throughout the project (in
    this case, `mc` for *Minimal CMake*). This might be overkill, and there are alternative
    approaches offered by CMake that let you *namespace* your library by using `ALIAS`.
    We’ll return to this in a later chapter, but what we have here is sufficient for
    our purposes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是强制要求的 `cmake_minimum_required` 命令，后面紧跟着同样重要的 `project` 命令。唯一的区别是，我们为我们的库命名为与其功能相匹配的名称（一个数组接口），并且我们还包含了我们在项目中打算使用的前缀（在这种情况下是
    `mc`，代表*Minimal CMake*）。这可能有些过头，CMake 也提供了其他方法让你通过使用 `ALIAS` 来为库加上*命名空间*。我们将在后面的章节回到这个话题，但目前我们所做的已经足够了。
- en: Creating the library
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建库
- en: 'Next, we have the first new command we’ve seen in a while:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一条很久没见过的新命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we’re creating a library, as opposed to an application, we must use the
    `add_library` command instead of `add_executable`. By default, CMake will create
    a static library for us (with a static library, the contents will be baked into
    our executable and linked at compile time). To override this behavior, when configuring
    the CMake project (running `cmake -B build`), it is possible to pass `-DBUILD_SHARED_LIBS=ON`
    to switch to building a shared library. To ensure this works across all platforms
    (Windows, macOS, and Linux), there’s a bit more we need to do, so we’ll leave
    this for now. To provide a setting different from the default, it’s possible to
    add an option to our `CMakeLists.txt` file, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建的是一个库，而不是一个应用程序，我们必须使用`add_library`命令而不是`add_executable`。默认情况下，CMake会为我们创建一个静态库（对于静态库，内容将会被打包进我们的可执行文件并在编译时链接）。为了覆盖这个行为，在配置CMake项目时（运行`cmake
    -B build`），可以传递`-DBUILD_SHARED_LIBS=ON`来切换到构建共享库。为了确保在所有平台（Windows、macOS和Linux）上都能正常工作，我们需要做一些额外的工作，所以我们暂时不做处理。为了提供不同于默认的设置，可以在我们的`CMakeLists.txt`文件中添加一个选项，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information about the `BUILD_SHARED_LIBS` option, please see [https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html](https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`BUILD_SHARED_LIBS`选项的信息，请参见[https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html](https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html)。
- en: 'To hardcode either static or shared, it’s possible to provide the library type
    to `add_library` by passing `STATIC` or `SHARED` after the library name. Here’s
    an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了硬编码静态或共享库，可以通过在库名后传递`STATIC`或`SHARED`来提供库类型给`add_library`。以下是一个示例：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: target_sources(${PROJECT_NAME} PRIVATE PRIVATE here as array.c is an implementation
    detail and we don’t want – or need it – to be recompiled. The only difference
    is we’re referring to it at its new location.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: target_sources(${PROJECT_NAME} PRIVATE PRIVATE，这里作为`array.c`是实现细节，我们不希望（也不需要）它重新编译。唯一的区别是我们在新的位置引用它。
- en: 'The remaining new command (which we briefly touched on in [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065),
    *Using FetchContent with External Dependencies*, when looking at linking to dependencies),
    is `target_include_directories`:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剩下的新命令（我们在[ *第3章* ](B21152_03.xhtml#_idTextAnchor065)，*使用 FetchContent 与外部依赖项*
    中简要提到过，在查看依赖项链接时）是`target_include_directories`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command tells the dependency the location the include files are relative
    to. We’re setting this directly on the target, and we want this property to be
    visible to clients, or users of the library, which is why we specify `PUBLIC`
    instead of `PRIVATE`.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令告诉依赖项包含文件相对于的位置。我们直接在目标上设置它，并且希望这个属性对客户端或者库的用户可见，这就是为什么我们指定`PUBLIC`而不是`PRIVATE`的原因。
- en: Generator expressions
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'Looking at the previously mentioned `target_include_directories` command, the
    third line of it may look a little alien at first. What you’re seeing is a feature
    provided by CMake called **generator expressions**. If we temporarily remove the
    generator expression, the command looks like this:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看之前提到的`target_include_directories`命令，它的第三行可能一开始看起来有点陌生。你看到的是CMake提供的一项功能，称为**生成器表达式**。如果我们暂时移除生成器表达式，命令看起来是这样的：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s remind ourselves of the file structure we reviewed previously:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前检查过的文件结构：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This ensures an application can include `array.h` by using `#include <minimal-cmake/array.h>`.
    This is great because it means clients don’t need to mess around setting their
    own `include` directories; they just link against the target and inherit this
    property automatically.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样可以确保应用程序通过`#include <minimal-cmake/array.h>`来包含`array.h`。这非常棒，因为这意味着客户端不需要自己设置`include`目录；他们只需链接到目标，并自动继承这个属性。
- en: It’s a nice idea to include an example, either as a small application or a snippet
    in the `README` file of your project to show how to include the dependency and
    what the include paths are. Users can figure this out, but the more information
    you can provide, the easier you make adopting the library and the less likely
    people will get stuck trying to use it.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的项目的`README`文件中包含一个示例，要么是一个小应用程序，要么是一个代码片段，展示如何包含依赖项以及包含路径是什么，这是个不错的主意。用户虽然可以自己搞定，但你提供的信息越多，就越能让使用这个库变得简单，也能降低他们在使用过程中卡住的几率。
- en: 'Let’s return to the generator expression we saw previously:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回到之前看到的生成器表达式：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In its simplest form, the structure is `$<condition:value>`. If `condition`
    is set (it exists), then `value` is provided; otherwise, the expression evaluates
    to nothing. Generator expressions are a bit like a ternary operator (`<condition>
    ? <true> : <false>`) in C or C++. It’s essentially a terse, declarative way to
    write conditions in your `CMakeLists.txt` scripts without resorting to more verbose
    `if`/`else` branches that follow a more imperative approach.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在最简单的形式下，结构为`$<condition:value>`。如果`condition`被设置（即存在），则提供`value`；否则，表达式的结果为空。生成器表达式有点像C或C++中的三元操作符（`<condition>
    ? <true> : <false>`）。它本质上是一种简洁、声明式的方式，用来在`CMakeLists.txt`脚本中编写条件，而不需要依赖更冗长的`if`/`else`分支，这种分支采用的是更命令式的编程风格。'
- en: There’s a balance to strike when using generator expressions; they can be convenient
    and simplify `CMakeLists.txt` files, but if overused, they can make code harder
    to understand. Strive to use them judiciously and if you think something is clearer
    with an explicit `if`/`else` statement, use that approach instead. Splitting up
    complex generator expressions using several CMake variables can also be a valuable
    approach rather than trying to achieve everything in one single expression.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用生成器表达式时需要找到一个平衡点；它们可以方便并简化`CMakeLists.txt`文件，但如果过度使用，可能会让代码更难理解。要明智地使用它们，如果你认为使用显式的`if`/`else`语句更清晰，就应当选择这种方式。通过使用多个CMake变量将复杂的生成器表达式拆解开来也可以是一种有价值的方式，而不是试图将所有内容都写成一个单一的表达式。
- en: 'The term `cmake -B build`, CMake first runs the configure step and then runs
    the generate step. This is where generator expressions are evaluated, and project
    files are created. This is shown in the output of the `cmake` command:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令`cmake -B build`中，CMake首先执行配置步骤，然后执行生成步骤。这时，生成器表达式会被求值，项目文件会被创建。如下所示，这是`cmake`命令的输出：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Working with generator expressions can be difficult, and being able to debug
    what an expression becomes is incredibly useful. Unfortunately, the normal CMake
    `message` statements to output logs to the console don’t work with generator expressions
    due to the time they’re evaluated (configure time versus generation time). To
    work around this, it’s possible to write the result of an expression to a file
    by using this approach:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用生成器表达式可能会很困难，能够调试表达式的结果是非常有用的。不幸的是，普通的CMake `message`语句无法与生成器表达式一起输出日志到控制台，因为它们的求值时间不同（配置时间与生成时间不同）。为了解决这个问题，可以通过以下方法将表达式的结果写入文件：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When running `cmake -B build`, this will write the result of the generator expression
    (`"$<...>"`) to the filename specified (this will be inside the `build/` folder
    if a relative path is provided). The contents of the file can then be checked
    to verify the value is what’s expected.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行`cmake -B build`时，这将把生成器表达式（`"$<...>"`）的结果写入指定的文件名（如果提供了相对路径，它将位于`build/`文件夹内）。然后可以检查文件的内容，确认结果是否符合预期。
- en: To learn more about generator expressions and the many variations supported
    by them, visit [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html).
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要了解更多关于生成器表达式及其支持的多种变体，可以访问[https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)。
- en: Include interfaces
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含接口
- en: 'We covered why specifying `target_include_directories` is important and what
    generator expressions are, but not why we needed `BUILD_LOCAL_INTERFACE` specifically.
    The reason for this is to allow us to use different include paths based on whether
    we’re building the library or using it after it has been installed. Installing
    is important for libraries and is something we’ll cover in more detail in [*Chapter
    7*](B21152_07.xhtml#_idTextAnchor170), *Adding Install Support for Your Libraries*,
    but for now, just knowing this alternative exists is enough. It is common to see
    something akin to this in a library `CMakeLists.txt` file:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经讨论了为什么指定`target_include_directories`很重要以及什么是生成器表达式，但没有解释为什么特别需要`BUILD_LOCAL_INTERFACE`。原因在于，这使得我们能够根据是否在构建库或在安装后使用它来使用不同的包含路径。安装对库来说很重要，这是我们将在[*第7章*](B21152_07.xhtml#_idTextAnchor170)《*为你的库添加安装支持*》中详细讲解的内容，但现在，只需知道有这种替代方案即可。在库的`CMakeLists.txt`文件中，通常会看到类似这样的内容：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Based on the context, the target will have different include paths set if it’s
    depended on and built within the same build tree (as with `FetchContent` or `add_subdirectory`)
    or installed to another location and depended on from there (what’s called an
    imported target). It’s common for include files for an installed library to be
    different from that of the library itself (the developer might wish to flatten
    the include hierarchy to make the library interface simpler to use). It’s generally
    a nice idea to specify `BUILD_LOCAL_INTERFACE` when first creating a library.
    It’s then possible to add `INSTALL_INTERFACE` should you later decide to add install
    support. By being explicit about this, you avoid needing to match the build and
    install interfaces in the future.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据上下文，目标将在以下情况下设置不同的包含路径：如果它依赖于并在同一构建树中构建（如`FetchContent`或`add_subdirectory`），或者安装到另一个位置并从那里依赖（称为导入目标）。安装库的包含文件通常与库本身的不同（开发者可能希望将包含层次结构扁平化，使库接口更易于使用）。通常在创建库时指定`BUILD_LOCAL_INTERFACE`是一个不错的主意。如果以后决定添加安装支持，可以再添加`INSTALL_INTERFACE`。通过明确这一点，您可以避免将来需要匹配构建和安装接口。
- en: BUILD_LOCAL_INTERFACE versus BUILD_INTERFACE
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: BUILD_LOCAL_INTERFACE 与 BUILD_INTERFACE
- en: You’re likely to come across `BUILD_INTERFACE` in addition to `BUILD_LOCAL_INTERFACE`
    out in the wild. The `BUILD_LOCAL_INTERFACE` generator expression is a newer addition
    (added in CMake `3.26`) and it will only expand its contents when used by another
    target in the same build system, whereas `BUILD_INTERFACE` will expand its contents
    when used by another target in the same build system and when the property is
    exported using the `export` command. As we don’t intend to export our targets
    from the build tree, we’re opting for the more restrictive of the two commands.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会遇到`BUILD_INTERFACE`，除此之外还有`BUILD_LOCAL_INTERFACE`。`BUILD_LOCAL_INTERFACE`是一个较新的生成表达式（在CMake
    `3.26`版本中添加），它仅在同一构建系统中的另一个目标使用时才会展开其内容，而`BUILD_INTERFACE`会在同一构建系统中的另一个目标使用时展开其内容，并且当属性通过`export`命令导出时也会展开。由于我们不打算从构建树中导出目标，因此我们选择了这两个命令中限制性更强的那个。
- en: 'Finally, we set the compile features to a standard version to ensure we get
    consistent behavior across different compilers:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们将编译特性设置为标准版本，以确保在不同编译器之间获得一致的行为：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s all we need to make our library available to other users through `FetchContent`.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们通过`FetchContent`将我们的库提供给其他用户所需的一切。
- en: Using our library
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用我们的库
- en: 'We can now update our app’s existing `CMakeLists.txt` file to bring in our
    new array library:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以更新应用程序的现有`CMakeLists.txt`文件，将新的数组库引入：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ├── app
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ├── app
- en: │   ├── CMakeLists.txt
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: │   ├── CMakeLists.txt
- en: │   └── main.c
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: │   └── main.c
- en: └── lib
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: └── lib
- en: └── array
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: └── array
- en: ├── CMakeLists.txt
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ├── CMakeLists.txt
- en: ├── include
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ├── include
- en: └── src
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: └── src
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: FetchContent_Declare(
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: FetchContent_Declare(
- en: minimal-cmake-array
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: minimal-cmake-array
- en: SOURCE_DIR ../../lib/array)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SOURCE_DIR ../../lib/array)
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: // forward declare board
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: // 前向声明板
- en: typedef struct mc_gol_board_t mc_gol_board_t;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: typedef struct mc_gol_board_t mc_gol_board_t;
- en: // lifetime
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: // 生命周期
- en: mc_gol_board_t* mc_gol_create_board(int32_t width, int32_t height);
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: mc_gol_board_t* mc_gol_create_board(int32_t width, int32_t height);
- en: void mc_gol_destroy_board(mc_gol_board_t* board);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: void mc_gol_destroy_board(mc_gol_board_t* board);
- en: // process
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: // 处理
- en: void mc_gol_update_board(mc_gol_board_t* board);
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: void mc_gol_update_board(mc_gol_board_t* board);
- en: // queries
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: // 查询
- en: int32_t mc_gol_board_width(const mc_gol_board_t* board);
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: int32_t mc_gol_board_width(const mc_gol_board_t* board);
- en: int32_t mc_gol_board_height(const mc_gol_board_t* board);
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: int32_t mc_gol_board_height(const mc_gol_board_t* board);
- en: bool mc_gol_board_cell(
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: bool mc_gol_board_cell(
- en: const mc_gol_board_t* board, int32_t x, int32_t y);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: const mc_gol_board_t* board, int32_t x, int32_t y);
- en: // mutations
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: // 变异
- en: void mc_gol_set_board_cell(
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: void mc_gol_set_board_cell(
- en: mc_gol_board_t* board, int32_t x, int32_t y, bool alive);
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: mc_gol_board_t* board, int32_t x, int32_t y, bool alive);
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: option(MC_GOL_SHARED "Enable shared library (dynamic linking)" OFF)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: option(MC_GOL_SHARED "启用共享库（动态链接）" OFF)
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: set(MC_GOL_LIB_TYPE STATIC)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: set(MC_GOL_LIB_TYPE STATIC)
- en: if(MC_GOL_SHARED)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: if(MC_GOL_SHARED)
- en: set(MC_GOL_LIB_TYPE SHARED)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: set(MC_GOL_LIB_TYPE SHARED)
- en: endif()
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: add_library(${PROJECT_NAME} ${MC_GOL_LIB_TYPE})
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: add_library(${PROJECT_NAME} ${MC_GOL_LIB_TYPE})
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: include(GenerateExportHeader)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: include(GenerateExportHeader)
- en: generate_export_header(${PROJECT_NAME} BASE_NAME mc_gol)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: generate_export_header(${PROJECT_NAME} BASE_NAME mc_gol)
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: target_include_directories(
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: target_include_directories(
- en: ${PROJECT_NAME}
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: PUBLIC $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PUBLIC $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>
- en: $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/>)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/>)
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: target_include_directories(
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: target_include_directories(
- en: ${PROJECT_NAME}
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: 'PUBLIC "$<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/build/mc_gol_export.h,
    we’ll see that several macros have been generated for us. The most important one
    for our purposes is MC_GOL_EXPORT. With our current settings on macOS or Linux,
    this will currently expand to nothing (as all symbols are visible/public by default),
    but on Windows, when building a shared library, we’ll see that the following has
    been generated:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PUBLIC "$<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/build/mc_gol_export.h，我们会看到几个宏已为我们生成。对我们而言，最重要的一个是
    MC_GOL_EXPORT。按照我们当前在 macOS 或 Linux 上的设置，它目前不会展开任何内容（因为默认所有符号都是可见/公共的），但在 Windows
    上，当构建共享库时，我们会看到已经生成了以下内容：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The compiler directives, `__declspec(dllexport)` and `__declspec(dllimport)`,
    are Microsoft-specific. When building a shared library, `__declspec(dllexport)`
    is used to make symbols available outside the library, and when a library is used,
    `__declspec(dllimport)` must be present to show which symbols are being imported.
    Leveraging CMake to generate these macros for us is very convenient; it is guaranteed
    to do the right thing whatever platform we build for, and whatever compiler settings
    we have enabled.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译指令 `__declspec(dllexport)` 和 `__declspec(dllimport)` 是微软特有的。当构建共享库时，`__declspec(dllexport)`
    用于使符号可供库外部使用，而在使用库时，必须存在 `__declspec(dllimport)` 来显示哪些符号正在被导入。利用 CMake 为我们生成这些宏非常方便；它保证无论我们为哪个平台构建，或者启用了哪些编译器设置，都会做出正确的处理。
- en: 'If we decide to build `mc-gol` as a static library again, then `MC_GOL_EXPORT`
    will expand to nothing. There is an added `#define` we can set when building a
    static version of the library, which in this case is `MC_GOL_STATIC_DEFINE`. We
    can define this like so:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们决定再次将 `mc-gol` 构建为静态库，那么 `MC_GOL_EXPORT` 将不会展开。构建静态版本库时，我们可以设置一个额外的 `#define`，在这种情况下是
    `MC_GOL_STATIC_DEFINE`。我们可以这样定义：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: MC_GOL_EXPORT mc_gol_board_t* mc_gol_create_board(
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: MC_GOL_EXPORT mc_gol_board_t* mc_gol_create_board(
- en: int32_t width, int32_t height);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: int32_t width, int32_t height);
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: cmake -B build -DMC_GOL_SHARED=ON
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build -DMC_GOL_SHARED=ON
- en: cmake --build build
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ./build/Debug/minimal-cmake_game-of-life_console.exe
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ./build/Debug/minimal-cmake_game-of-life_console.exe
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'C:/Path/to/minimal-cmake/ch4/part-3/app/build/Debug/minimal-cmake_game-of-life_console.exe:
    error while loading shared libraries: ?: cannot open shared object file: No such
    file or directory'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'C:/Path/to/minimal-cmake/ch4/part-3/app/build/Debug/minimal-cmake_game-of-life_console.exe:
    加载共享库时出错：?: 无法打开共享对象文件：没有这样的文件或目录'
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: set PATH=C:\Path\to\minimal-cmake\ch4\part-3\app\build\_deps\minimal-cmake-gol-build\Debug;%PATH%
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: set PATH=C:\Path\to\minimal-cmake\ch4\part-3\app\build\_deps\minimal-cmake-gol-build\Debug;%PATH%
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: if(WIN32)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: if(WIN32)
- en: set_target_properties(
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: mc-gol PROPERTIES RUNTIME_OUTPUT_DIRECTORY
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: mc-gol 属性 RUNTIME_OUTPUT_DIRECTORY
- en: ${CMAKE_CURRENT_BINARY_DIR})
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_CURRENT_BINARY_DIR})
- en: endif()
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: if(WIN32)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: if(WIN32)
- en: add_custom_command(
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: add_custom_command(
- en: TARGET ${PROJECT_NAME}
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TARGET ${PROJECT_NAME}
- en: POST_BUILD
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: POST_BUILD
- en: COMMAND
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND
- en: ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:mc-gol>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:mc-gol>
- en: $<TARGET_FILE_DIR:${PROJECT_NAME}>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: $<TARGET_FILE_DIR:${PROJECT_NAME}>
- en: VERBATIM)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: VERBATIM)
- en: endif()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'dyld[10168]: Library not loaded: @rpath/libmc-gol.dylib'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'dyld[10168]: 未加载库：@rpath/libmc-gol.dylib'
- en: 'Reason: tried: ''/path/to/minimal-cmake/ch4/part-3/app/build/_deps/minimal-cmake-gol-build/libmc-gol.dylib''
    (no such file)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 原因：尝试了：'/path/to/minimal-cmake/ch4/part-3/app/build/_deps/minimal-cmake-gol-build/libmc-gol.dylib'（没有这个文件）
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: set_target_properties(
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: '${PROJECT_NAME} PROPERTIES BUILD_RPATH @loader_path) # macOS only'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '${PROJECT_NAME} 属性 BUILD_RPATH @loader_path) # 仅限 macOS'
- en: set_target_properties(
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: '${PROJECT_NAME} PROPERTIES BUILD_RPATH $ORIGIN) # Linux only'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '${PROJECT_NAME} 属性 BUILD_RPATH $ORIGIN) # 仅限 Linux'
- en: set_target_properties(
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: ${PROJECT_NAME}
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: PROPERTIES
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PROPERTIES
- en: BUILD_RPATH
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: BUILD_RPATH
- en: '"$<$<PLATFORM_ID:Linux>:$ORIGIN>$<$<PLATFORM_ID:Darwin>:@loader_path>")set_target_properties
    for macOS and Linux separately, and then a cross-platform combined version using
    generator expressions to set the right value for the RPATH value, depending on
    the platform (it won’t set anything on Windows in this case).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '"$<$<PLATFORM_ID:Linux>:$ORIGIN>$<$<PLATFORM_ID:Darwin>:@loader_path>")分别为
    macOS 和 Linux 设置 set_target_properties，然后使用生成器表达式来设置正确的 RPATH 值，以便根据平台进行调整（在此情况下不会在
    Windows 上设置任何内容）。'
- en: To inspect the value of `RPATH`, it’s possible to use the `otool` utility on
    macOS or the `readelf` utility on Linux (both are tools that display object files
    for their respective platforms). The `otool -l minimal-cmake_game-of-life_console`
    command on macOS and `readelf -d minimal-cmake_game-of-life_console` on Linux
    will show the values listed.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查 `RPATH` 的值，可以在 macOS 上使用 `otool` 工具或在 Linux 上使用 `readelf` 工具（这两个工具分别显示其平台的对象文件）。在
    macOS 上使用 `otool -l minimal-cmake_game-of-life_console` 命令，以及在 Linux 上使用 `readelf
    -d minimal-cmake_game-of-life_console` 命令，将显示列出的值。
- en: 'The following is a snippet of the output from `otool` on macOS:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是在 macOS 上使用 `otool` 的输出片段：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '0x..001 (NEEDED)  Shared library: [ld-linux-aarch64.so.1]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 0x..001 (NEEDED)  共享库：[ld-linux-aarch64.so.1]
- en: 0x..01d @loader_path and $ORIGIN appear as expected.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 0x..01d @loader_path 和 $ORIGIN 出现如预期。
- en: To learn more about `RPATH` handling in CMake, go to [https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling).
    There are also many different approaches when it comes to configuring shared libraries
    and we’ve only just scratched the surface. Here, we looked at one possible solution,
    but it won’t work for everything. This is an area to continue exploring, depending
    on the types of applications you’ll be creating. We’ll be certain to revisit these
    topics later in this book when we discuss installing libraries and packaging projects.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解有关 `CMake` 中 `RPATH` 处理的更多信息，请访问 [https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling)。在配置共享库时，有许多不同的方法，我们只是初步探讨了一个可能的解决方案。这是一个可以继续探索的领域，具体取决于您将要创建的应用程序类型。在本书后面讨论安装库和打包项目时，我们一定会重新讨论这些主题。
- en: Final cross-platform additions
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终跨平台增强
- en: Before we wrap up, let’s cover a few small updates we can make to ensure our
    library is more consistent across different platforms. We can use the now-familiar
    `set_target_properties` command to apply these settings only to our library.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结束之前，让我们来介绍一些小更新，以确保我们的库在不同平台上更为一致。我们可以使用现在熟悉的 `set_target_properties` 命令，仅对我们的库应用这些设置。
- en: The first two related properties are `C_VISIBILITY_PRESET` and `VISIBILITY_INLINES_HIDDEN`.
    We set `C_VISIBILITY_PRESET` to `hidden` and `VISIBILITY_INLINES_HIDDEN` to `ON`.
    This ensures that the symbol visibility behavior between the Visual Studio compiler
    (MSVC) on Windows and the Clang/GCC compilers on macOS/Linux is the same. This
    will ensure that, by default, unless symbols are explicitly annotated with `MC_GOL_EXPORT`,
    they will remain hidden. This helps prevent incompatibilities between platforms.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前两个相关属性是 `C_VISIBILITY_PRESET` 和 `VISIBILITY_INLINES_HIDDEN`。我们将 `C_VISIBILITY_PRESET`
    设置为 `hidden`，将 `VISIBILITY_INLINES_HIDDEN` 设置为 `ON`。这可以确保在 Windows 上的 Visual Studio
    编译器（MSVC）和 macOS/Linux 上的 Clang/GCC 编译器之间，默认情况下，除非使用 `MC_GOL_EXPORT` 显式注释符号，否则它们将保持隐藏。这有助于防止不同平台之间的不兼容性。
- en: 'With these settings enabled, if we generate our export header again on macOS
    or Linux by running `cmake -B build` as normal, we’ll see the following:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用这些设置后，如果我们在 macOS 或 Linux 上像往常一样运行 `cmake -B build` 来重新生成我们的导出头文件，我们将看到以下内容：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is better than seeing the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这比看到以下内容要好：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With these settings enabled, if we try to use a symbol (a type or function)
    that has not been explicitly exported on macOS or Linux, we’ll get a linker error,
    just as we did on Windows. If we’re working on a cross-platform library, it’s
    advisable to keep behavior as consistent as possible across platforms. There are
    also good reasons for not automatically exporting all symbols by default to reduce
    the export symbol table size and overall binary size.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用这些设置后，如果我们尝试在 macOS 或 Linux 上使用尚未明确导出的符号（类型或函数），我们将会得到链接错误，就像在 Windows 上一样。如果我们正在开发跨平台库，建议尽可能保持行为在各个平台上的一致性。不自动导出所有符号默认有很好的理由，可以减少导出符号表的大小和整体二进制大小。
- en: The next two properties are `C_STANDARD_REQUIRED` and `C_EXTENSIONS`. We’ll
    set `C_STANDARD_REQUIRED` to `ON` and `C_EXTENSIONS` to `OFF`.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来的两个属性是 `C_STANDARD_REQUIRED` 和 `C_EXTENSIONS`。我们将 `C_STANDARD_REQUIRED` 设置为
    `ON`，将 `C_EXTENSIONS` 设置为 `OFF`。
- en: Setting `C_STANDARD_REQUIRED` to `ON` ensures that we get the minimum C language
    version we specified in `target_compile_features` with `c_std_17`. It’s also possible
    to set the language version using `set_target_properties` and `C_STANDARD 17`,
    though it’s arguable that `target_compile_features` is a little clearer, which
    is why it’s preferred in this book.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `C_STANDARD_REQUIRED` 设置为 `ON` 确保我们能够获取到在 `target_compile_features` 中使用 `c_std_17`
    指定的最小 C 语言版本。也可以通过 `set_target_properties` 和 `C_STANDARD 17` 来设置语言版本，尽管可以说，`target_compile_features`
    更加清晰，这也是为什么本书中更倾向于使用它的原因。
- en: Setting `C_EXTENSIONS` to `OFF` ensures we don’t inadvertently use language
    features added by different compiler vendors that do not appear in the C standard
    (or C++ standard if we used `CXX_EXTENSIONS`). Again, this is to help enforce
    cross-platform code that doesn’t rely on features available only on one compiler
    or platform. If you intend to build for one platform or compiler, this is less
    important, but it’s a good practice to get into. This is especially true if one
    day you decide to port your code to another platform. It’ll be a lot easier if
    you aren’t relying on specific compiler features.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `C_EXTENSIONS` 设置为 `OFF` 确保我们不会不小心使用不同编译器厂商添加的、不符合 C 标准（或如果我们使用了 `CXX_EXTENSIONS`
    则是 C++ 标准）的语言特性。同样，这是为了帮助强制执行跨平台代码，使其不依赖于仅在某个编译器或平台上可用的特性。如果你打算只为一个平台或编译器进行构建，这一点不那么重要，但养成这个习惯是个好做法。特别是如果有一天你决定将代码移植到另一个平台，避免依赖特定编译器的特性将让这个过程变得更加容易。
- en: 'The final expression looks like this:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的表达式如下所示：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For good measure, we also add `MC_GOL_STATIC_DEFINE` if we’re not building `mc-gol`
    as a shared library (again, this is not strictly necessary in this case, but it’s
    a good, low-effort defensive measure to avoid potentially annoying link time issues
    in the future, depending on the state of `mc_gol_export.h`).
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更保险起见，如果我们不是以共享库的方式构建 `mc-gol`，我们还会添加 `MC_GOL_STATIC_DEFINE`（尽管在这种情况下，这并不是严格必要的，但这是一个很好的、低成本的防御性措施，可以避免将来可能出现的链接时问题，这取决于
    `mc_gol_export.h` 的状态）。
- en: To see everything in one place, you can go to [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)
    and review `ch4/part-5/lib/gol/CMakeLists.txt`.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若想查看所有内容，可以访问 [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)
    并查看 `ch4/part-5/lib/gol/CMakeLists.txt`。
- en: That wraps up all changes to our *Game of Life* library! There’s just one more
    important topic we’ve yet to cover before we move on to the next chapter.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就完成了我们对 *生命游戏* 库的所有修改！在进入下一章之前，我们还有一个重要的主题尚未讨论。
- en: Interface libraries
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口库
- en: In addition to static and shared libraries, there is another well-known library
    type often referred to as `.h` files). It is not compiled or linked ahead of time,
    the `.h` files are simply included and then compiled with the source of the main
    application.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了静态库和共享库外，还有另一种常见的库类型，通常被称为 `.h` 文件）。它不会在编译或链接时预先处理，`.h` 文件只是被包含进去，然后与主应用程序的源代码一起编译。
- en: Header-only libraries are popular because of their ease of integration (you
    can include the `.h` file in your project and things will usually just work).
    The downside is that you pay a cost by compiling that library whenever you change
    your code, which, depending on the complexity of the library, can add a lot of
    overhead. Header-only libraries tend to be popular in C++ with template libraries,
    which require their implementation to be present in the header file itself.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅头文件库因为其易于集成而非常受欢迎（你只需将 `.h` 文件包含到项目中，通常一切就能正常工作）。缺点是，每当你更改代码时，你必须重新编译该库，这会带来额外的开销，这种开销根据库的复杂度可能会很大。仅头文件库在
    C++ 中尤其常见，尤其是模板库，因为它们的实现必须出现在头文件中。
- en: 'Fortunately, CMake offers a straightforward way to create header-only libraries
    that can be used like any other library. A complete header-only `CMakeLists.txt`
    file is shown here:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，CMake 提供了一种直接的方法来创建仅头文件库，这些库可以像其他库一样使用。这里展示了一个完整的仅头文件 `CMakeLists.txt`
    文件：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The file should look remarkably familiar to the earlier `CMakeLists.txt` files
    we’ve seen. The major difference is the addition of the `INTERFACE` keyword, which
    has replaced the use of `STATIC` or `SHARED` in the `add_library` command, and
    `PUBLIC` or `PRIVATE` in the specific `target_...` commands.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该文件应该与我们之前看到的 `CMakeLists.txt` 文件非常相似。主要的不同点是添加了 `INTERFACE` 关键字，取代了 `add_library`
    命令中的 `STATIC` 或 `SHARED`，以及特定的 `target_...` 命令中的 `PUBLIC` 或 `PRIVATE`。
- en: The `INTERFACE` keyword informs CMake that there are no source files to build
    for this target and that no artifact (library file) will be produced. All it does
    is provide requirements for using it (in our case, we’re specifying where to find
    the include files, and that `c_std_17` or above is needed to use it). The `INTERFACE`
    keyword also allows us to confer a list of source files for a dependent target
    to compile via the `target_sources` command (we'll see a use for this in [*Chapter
    9*](B21152_09.xhtml#_idTextAnchor195)*, Writing Tests for* *the Project*).
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`INTERFACE`关键字告知 CMake 这个目标没有源文件需要构建，也不会生成任何工件（库文件）。它所做的只是提供使用它的要求（在我们的例子中，我们指定了包含文件的位置，并要求使用
    `c_std_17` 或更高版本）。`INTERFACE` 关键字还允许我们通过 `target_sources` 命令为依赖的目标指定一组源文件进行编译（我们将在[*第9章*](B21152_09.xhtml#_idTextAnchor195)中看到此用途，*为项目编写测试*）。'
- en: The preceding code is a contrived example where we’ve extracted a single useful
    utility function not specific to *Game of Life* that we may want to use (and add
    to) in the future. The function is `try_wrap`, which is essentially a more robust
    modulus function that better handles negative numbers when wrapping.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面的代码是一个人为的示例，我们提取了一个不特定于*生命游戏*的单一有用工具函数，未来可能会使用（并且可能会添加）。这个函数是 `try_wrap`，它本质上是一个更强大的取模函数，能在处理负数时更好地进行环绕运算。
- en: 'Now, we can use this library in `mc-gol` like so:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以像下面这样在`mc-gol`中使用这个库：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’re not technically linking against the library, but we must add the target
    as a dependency to `target_link_libraries` so that the include search paths for
    our target application get populated. Then, we just need to add `#include <minimal-cmake/utils.h>`
    to `gol.c` to access the function.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们技术上并没有链接到这个库，但我们必须将目标添加为 `target_link_libraries` 的依赖项，以便为我们的目标应用程序填充包含搜索路径。然后，我们只需要在
    `gol.c` 中添加 `#include <minimal-cmake/utils.h>` 以访问该函数。
- en: As this is still a C header-only library, we need to annotate our function implementation
    with `static` to avoid linker errors. This will cause copies of our function to
    be generated in each translation unit (`.c` file) they are used, which isn’t ideal,
    but will work for us in this simple case. C++ has much better support for header-only
    libraries. In this case, the `inline` keyword should be preferred (`inline` is
    also supported in C, but it means something slightly different than it does in
    C++, and its usage is a bit more complicated).
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这仍然是一个 C 语言的仅头文件库，我们需要用 `static` 来注解我们的函数实现，以避免链接错误。这将导致在每个翻译单元（`.c` 文件）中生成函数的副本，这并不理想，但在这个简单的例子中是可行的。C++
    对仅头文件库的支持要好得多。在这种情况下，应该首选 `inline` 关键字（`inline` 在 C 语言中也受支持，但它在 C 中的含义与 C++ 中有所不同，使用起来也稍微复杂一些）。
- en: Using header-only libraries this way provides all the advantages discussed in
    [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065), *Using FetchContent with External
    Dependencies*, which include keeping your code and dependencies separate, as well
    as making setting up include paths a lot simpler.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式使用仅包含头文件的库提供了在[*第3章*](B21152_03.xhtml#_idTextAnchor065)中讨论的所有优势，*使用 FetchContent
    处理外部依赖项*，包括将代码和依赖项分开，并使设置包含路径变得更加简单。
- en: You can find a full example in `ch4/part6/lib/utils/CMakeLists.txt` and `ch4/part6/app/CMakeLists.txt`.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 `ch4/part6/lib/utils/CMakeLists.txt` 和 `ch4/part6/app/CMakeLists.txt` 中找到完整的示例。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: If you’ve made it this far, give yourself a well-deserved pat on the back –
    you’ve come a long way! In this chapter, we discussed how to make a library compatible
    with `FetchContent`. This involved reviewing the project’s physical structure,
    how to create a library, and how to use generator expressions to control include
    interfaces. Then, we looked at how to make use of our new library. With that in
    place, we extracted our *Game of Life* logic to a separate library with a new
    interface. We looked in depth at how to make it a shared library and the many
    concerns to account for across Windows, macOS, and Linux, as well as how CMake
    can help us (in terms of export headers, custom commands for DLL copying on Windows,
    and customizing target properties to help with relocatable libraries on macOS
    and Linux). We wrapped up by making some minor improvements to help avoid cross-platform
    issues and looking at interface (or header-only) libraries and how to create them
    using CMake.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，给自己一个值得的鼓励——你已经走了很长一段路！在本章中，我们讨论了如何使库与`FetchContent`兼容。这包括回顾项目的物理结构、如何创建库，以及如何使用生成器表达式来控制包含接口。接着，我们查看了如何使用我们的新库。在此基础上，我们将我们的*生命游戏*逻辑提取到一个具有新接口的独立库中。我们深入探讨了如何将其制作成共享库，以及在Windows、macOS和Linux之间需要考虑的许多问题，还探讨了CMake如何帮助我们（通过导出头文件、在Windows上为DLL复制创建自定义命令，以及如何定制目标属性以帮助在macOS和Linux上创建可移动的库）。最后，我们通过做一些小的改进来帮助避免跨平台问题，并查看了接口（或仅头文件）库以及如何使用CMake创建它们。
- en: If you haven’t already, please take some time to familiarize yourself with the
    examples that were discussed throughout this chapter by going to [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)
    and trying to configure and build the projects (see `ch4` for step-by-step examples).
    Working examples are incredibly helpful when it comes to building understanding
    and familiarity with these concepts. Hopefully, some of the examples should be
    easy to extract and build on for your projects. Understanding how to create libraries
    is a major milestone and presents exciting opportunities to write code others
    can easily start using.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还没有，请花一些时间通过访问[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)来熟悉本章讨论的示例，并尝试配置和构建这些项目（请参见`ch4`中的逐步示例）。实际的示例对于构建对这些概念的理解和熟悉非常有帮助。希望其中一些示例应该很容易提取并用于你的项目。了解如何创建库是一个重要的里程碑，并且为编写别人可以轻松使用的代码提供了令人兴奋的机会。
- en: Now that you have a solid understanding of creating libraries, it’s time to
    look at how to leverage some useful CMake features to make day-to-day development
    faster, easier, and more reliable. We’ll do exactly that in the next chapter.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经对创建库有了扎实的理解，是时候看看如何利用一些有用的CMake功能，使日常开发更快、更简单和更可靠了。我们将在下一章中做具体介绍。
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
