- en: Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'In this chapter, we will take a look at a process that has really grown in
    popularity in the recent years—unit testing. We’ll briefly talk about what it
    is and why we would want to do it before covering how to integrate it into our
    solution using Qt’s very own unit testing tool, Qt Test. We will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个近年来真正流行起来的过程——单元测试。我们将简要讨论它是什么以及为什么我们要这样做，然后介绍如何使用Qt自己的单元测试工具Qt
    Test将其集成到我们的解决方案中。我们将涵盖以下主题：
- en: Unit Testing principles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试原则
- en: The default Qt approach
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的Qt方法
- en: An alternative approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法
- en: DataDecorator tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataDecorator测试
- en: Entity tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体测试
- en: Mocking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The essence of unit testing is to break an application down into its smallest
    functional blocks (units) and then test each unit with real-world scenarios within
    the scope of the initiative. For example, take a simple method that takes two
    signed integers and adds them together:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的本质是将应用程序分解为最小的功能块（单元），然后在倡议范围内使用真实场景测试每个单元。例如，考虑一个简单的方法，它接受两个有符号整数并将它们相加：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some example scenarios can be as listed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例场景可以列举如下：
- en: Adding two positive numbers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加两个正数
- en: Adding two negative numbers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加两个负数
- en: Adding two zeroes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加两个零
- en: Adding one positive and one negative number
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个正数和一个负数
- en: Adding zero and a positive number
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加零和一个正数
- en: Adding zero and a negative number
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加零和一个负数
- en: We can write a test for each of these scenarios and then every time our code
    base changes (any code, not just our `add()` method), these tests can be executed
    to ensure that the code still behaves as expected. It is a really valuable tool
    to give you confidence that any code changes you make aren’t having a detrimental
    effect on the existing functionality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每种情况编写一个测试，然后每当我们的代码库发生更改（任何代码，不仅仅是我们的`add()`方法），都可以执行这些测试，以确保代码仍然按预期运行。这是一个非常有价值的工具，可以让您确信您所做的任何代码更改都不会对现有功能产生不利影响。
- en: Historically, these tests would have been performed manually, but tooling exists
    that can enable us to write code to test code automatically, which sounds like
    a bit of a paradox, but it really works. Qt provides a tailored framework for
    unit testing Qt-based applications, called Qt Test, and that is what we will use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，这些测试通常是手动执行的，但现在存在工具可以使我们能够编写代码自动测试代码，听起来有点矛盾，但它确实有效。Qt提供了一个专门为基于Qt的应用程序设计的单元测试框架，称为Qt
    Test，这就是我们将要使用的。
- en: You can use other C++ testing frameworks such as Google test, which arguably
    offer more power and flexibility, particularly when used with Google mock, but
    can be a bit more fiddly to set up.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他C++测试框架，如Google测试，这些框架可能提供更多的功能和灵活性，特别是在与Google模拟一起使用时，但设置起来可能会更加麻烦。
- en: '**Test-driven development** (**TDD**) takes unit testing to the next level
    and actually changes the way you write code in the first place. In essence, you
    write a test first. The test will initially fail (indeed, probably it won’t even
    build) because you have no implementation. You then write the bare minimum of
    code it takes to make the test pass and then move on to writing the next test.
    You iteratively build out your implementation in this way until you have delivered
    the block of functionality required. Finally, you refactor the code to the required
    standard, using the completed unit tests to validate that the refactored code
    still behaves as expected. This is sometimes referred to as *Red-Green-Refactor*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）将单元测试提升到了一个新的水平，并实际上改变了你编写代码的方式。实质上，你首先编写一个测试。测试最初会失败（实际上，可能甚至无法构建），因为你没有实现。然后，你编写最少量的代码使测试通过，然后继续编写下一个测试。你以这种方式迭代地构建你的实现，直到你交付所需的功能块。最后，你根据所需的标准重构代码，使用完成的单元测试来验证重构后的代码仍然按预期运行。有时这被称为*红-绿-重构*。'
- en: This isn’t a book about unit testing, and it is certainly not about TDD, so
    we will be very loose with our approach, but it is a key part of modern application
    development, and it is important to know how it fits into your Qt projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于单元测试的书，当然也不是关于TDD的书，所以我们的方法会很宽松，但它是现代应用程序开发的重要组成部分，了解它如何融入到您的Qt项目中是很重要的。
- en: We’ve demonstrated the mechanism for passing a simple piece of data (the welcome
    message) from our business logic project to our UI, so as always, starting as
    simply as possible, our first goal for this chapter is to write a rudimentary
    unit test for that behavior. Once done, we’ll move on to test the data classes
    we implemented in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了从业务逻辑项目向UI传递简单数据（欢迎消息）的机制，因此，像往常一样，本章的第一个目标是为该行为编写一个基本的单元测试。完成后，我们将继续测试我们在上一章中实现的数据类。
- en: The default Qt approach
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的Qt方法
- en: When we created our `cm-tests` project, Qt Creator helpfully created a `ClientTests`
    class for us to use a starting point, containing a single test named `testCase1`. Let's
    dive straight in and execute this default test and see what happens. We'll then
    take a look at the code and discuss what's going on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`cm-tests`项目时，Qt Creator会为我们创建一个`ClientTests`类，供我们用作起点，其中包含一个名为`testCase1`的单个测试。让我们直接执行这个默认测试，看看会发生什么。然后我们将查看代码并讨论发生了什么。
- en: 'Switch the Run output to `cm-tests`, and compile and run:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将运行输出切换到`cm-tests`，然后编译和运行：
- en: '![](img/41069538-8323-4ea5-8784-a20ae5b91672.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41069538-8323-4ea5-8784-a20ae5b91672.png)'
- en: 'You won’t see any fancy applications spring to life this time, but you will
    see some text in the Application Output pane in Qt Creator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你不会看到任何花哨的应用程序，但你会在Qt Creator的Application Output窗格中看到一些文本：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that three methods have been called, the second of which is our default
    unit test.  The other two functions—`initTestCase()` and `cleanupTestCase()`—are
    special methods that execute before and after the suite of tests in the class,
    allowing you to set up any preconditions required to execute the tests and then
    perform any clean up afterward. All the three steps pass.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到已经调用了三个方法，其中第二个是我们的默认单元测试。另外两个函数——`initTestCase()`和`cleanupTestCase()`——是在类的测试套件之前和之后执行的特殊方法，允许您设置执行测试所需的任何前提条件，然后执行任何清理工作。所有三个步骤都通过了。
- en: 'Now, in `client-tests.cpp`, add another method—`testCase2()`—which is the same
    as `testCase1()` but substitute the `true` condition for `false`. Note that the
    class declaration and method definitions are all in the same `.cpp` file, so you
    need to add the method in both places. Run the tests again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`client-tests.cpp`中，添加另一个方法`testCase2()`，它与`testCase1()`相同，但将`true`条件替换为`false`。请注意，类声明和方法定义都在同一个`.cpp`文件中，所以你需要在两个地方都添加这个方法。再次运行测试：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, you can see that `testCase2()` tried to verify that false was true,
    which of course it isn’t, and our test fails, outputting our failure message in
    the process. `initTestCase()` and `cleanupTestCase()` are still executed at the
    beginning and end of the suite of tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你可以看到`testCase2()`试图验证false是否为true，当然它不是，我们的测试失败了，并在过程中输出了我们的失败消息。`initTestCase()`和`cleanupTestCase()`仍然在测试套件的开始和结束时执行。
- en: Now we've seen what passing and failing tests look like, but what is actually
    going on?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了通过和失败的测试是什么样子的，但实际上发生了什么呢？
- en: We have a `QObject` derived class `ClientTests`, which implements an empty default
    constructor. We then have some methods declared as private `Q_SLOTS`. Much like `Q_OBJECT`,
    this is a macro that injects a bunch of clever boilerplate code for us, and much
    like `Q_OBJECT`, you don’t need to worry about understanding its inner workings
    in order to use it. Each method in the class defined as one of these private slots
    is executed as a unit test.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个派生自`QObject`的类`ClientTests`，它实现了一个空的默认构造函数。然后我们有一些声明为私有`Q_SLOTS`的方法。就像`Q_OBJECT`一样，这是一个宏，为我们注入了一堆聪明的样板代码，而且就像`Q_OBJECT`一样，你不需要担心理解它的内部工作原理就可以使用它。类中定义为这些私有槽之一的每个方法都作为一个单元测试执行。
- en: The unit test methods then use the `QVERIFY2` macro to verify a given boolean
    condition, namely that true is, well, true. If this fails, which we have engineered
    in `testCase2`, the helpful message failure will be output to the console.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，单元测试方法使用`QVERIFY2`宏来验证给定的布尔条件，即true是true。如果失败了，我们在`testCase2`中设计的话，有用的消息失败将被输出到控制台。
- en: If there is a `QVERIFY2`, then presumably there must be a `QVERIFY1`, right?
    Well, nearly, there is `QVERIFY`, which performs the same test but does not have
    the failure message parameter. Other commonly used macros are `QCOMPARE`, which
    verifies that two parameters of the same type are equivalent, and `QVERIFY_EXCEPTION_THROWN`, which
    verifies that an exception is thrown when a given expression is executed. This
    may sound odd, as we don’t ideally want our code to throw exceptions. However,
    things aren’t always ideal, and we should always write negative tests that verify
    how the code behaves when something does go wrong. A common example of this is
    where we have a method that accepts a pointer to an object as a parameter. We
    should write a negative test that verifies what happens if we pass in a `nullptr` (which
    is always a possibility, regardless of how careful you are). We may expect the
    code to happily ignore it and take no further action or we may want some sort
    of null argument exception to throw, which is where `QVERIFY_EXCEPTION_THROWN` comes
    in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个`QVERIFY2`，那么可能会有一个`QVERIFY1`，对吧？嗯，几乎是的，有一个`QVERIFY`，它执行相同的测试，但没有失败消息参数。其他常用的宏是`QCOMPARE`，它验证相同类型的两个参数是否等价，以及`QVERIFY_EXCEPTION_THROWN`，它验证在执行给定表达式时是否抛出了异常。这可能听起来有点奇怪，因为我们理想情况下不希望我们的代码抛出异常。然而，事情并不总是理想的，我们应该始终编写负面测试，验证代码在出现问题时的行为。一个常见的例子是，当我们有一个接受对象指针作为参数的方法时。我们应该编写一个负面测试，验证如果我们传入一个`nullptr`会发生什么（无论你多么小心，这总是可能发生的）。我们可能希望代码忽略它并不再采取进一步的行动，或者我们可能希望抛出某种空参数异常，这就是`QVERIFY_EXCEPTION_THROWN`的用武之地。
- en: After the test case definitions, another macro `QTEST_APPLESS_MAIN` stubs out
    a `main()` hook to execute the tests and the final `#include` statement pulls
    in the .moc file produced by the build process. Every class that inherits from
    QObject will have a `companion .moc` file generated, containing all the magic metadata
    code created by `Q_OBJECT` and other associated macros.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例定义之后，另一个宏`QTEST_APPLESS_MAIN`将一个`main()`钩子桩出来执行测试，最后的`#include`语句引入了构建过程生成的.moc文件。每个继承自QObject的类都会生成一个`companion
    .moc`文件，其中包含由`Q_OBJECT`和其他相关宏创建的所有`magic`元数据代码。
- en: Now, if you’re thinking “why would you test if true is true and false is true?”,
    then you absolutely wouldn’t, this is a totally pointless pair of tests. The purpose
    of this exercise is just to look at how the default approach that Qt Creator has
    pulled together for us works, and it does work, but it has a few key failings
    that we will need to work to fix before we write a real test.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在想“为什么要测试true是否为true，false是否为true？”，那么你绝对不会这样做，这是一对完全无意义的测试。这个练习的目的只是看看Qt
    Creator为我们提供的默认方法是如何工作的，它确实有效，但它有一些关键的缺陷，我们需要在编写真正的测试之前解决这些问题。
- en: The first issue is that `QTEST_APPLESS_MAIN` creates a `main()` method in order
    to run our test cases in `ClientTests`. What happens when we write another test
    class? We’ll have two `main()` methods and things won’t go well. Another issue
    is that our test output is just piped to the Application Output pane. In a business
    environment, it is common to have build servers that pull application code, perform
    a build, run the unit test suite, and flag any test failures for investigation.
    In order for this to work, the build tool needs to be able to access the test
    output and can’t read the Application Output pane in the IDE like a human can.
    Let’s look at an alternative approach that solves these issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是，`QTEST_APPLESS_MAIN`创建了一个`main()`方法，以便在`ClientTests`中运行我们的测试用例。当我们编写另一个测试类时会发生什么？我们将有两个`main()`方法，事情将变得不顺利。另一个问题是，我们的测试输出只是传输到“应用程序输出”窗格。在商业环境中，通常会有构建服务器拉取应用程序代码，执行构建，运行单元测试套件，并标记任何测试失败以进行调查。为了使这项工作正常进行，构建工具需要能够访问测试输出，并且不能像人类一样读取IDE中的“应用程序输出”窗格。让我们看看解决这些问题的另一种方法。
- en: Custom approach
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义方法
- en: The custom approach we will take still applies the same basic concepts we've
    just discussed.  At the heart of it, we will still have a test class that contains
    a suite of unit test methods to be executed. All we will do is supplement this
    with some additional boilerplate code to allow us to easily accommodate multiple
    test classes and pipe the output to files rather than the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的自定义方法仍然适用于我们刚刚讨论的相同基本概念。在其核心，我们仍将拥有一个包含一系列要执行的单元测试方法的测试类。我们将只是补充一些额外的样板代码，以便我们可以轻松地容纳多个测试类，并将输出传输到文件而不是控制台。
- en: 'Let’s begin by adding a new class `TestSuite` to `cm-tests` in the source folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在源文件夹中的`cm-tests`中添加一个新的`TestSuite`类：
- en: '![](img/6e6569fd-21b3-449b-9355-31fd0727841a.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e6569fd-21b3-449b-9355-31fd0727841a.png)'
- en: '`test-suite.h`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`test-suite.h`：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`test-suite.cpp`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`test-suite.cpp`：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are creating a base class that will be used for each of our test classes.
    There is generally a one-to-one relationship between a regular class and a test
    suite class, for example, the `Client` and `ClientTests` classes. Each derived
    instance of `TestSuite` adds itself to a shared vector. This can be a little confusing
    at first glance, so we are also writing some information out to the console using
    `qDebug()` so that you can follow what’s going on. It will make more sense when
    we create our first class deriving from `TestSuite`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个基类，该基类将用于我们的每个测试类。通常情况下，常规类和测试套件类之间是一对一的关系，例如`Client`和`ClientTests`类。`TestSuite`的每个派生实例都会将自己添加到共享向量中。乍一看可能有点混乱，因此我们还使用`qDebug()`向控制台输出一些信息，以便您可以跟踪发生的情况。当我们创建第一个从`TestSuite`派生的类时，这将更有意义。
- en: 'Next, add a new C++ Source File `main.cpp`, again to the source folder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次在源文件夹中添加一个新的C++源文件`main.cpp`：
- en: '`main.cpp`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`：'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks more complicated than it actually is because of the `qDebug()` statements
    added for information. We iterate through each of the registered test classes
    and use the static `QTest::qExec()` method to detect and run all tests discovered
    within them. A key addition, however, is that we create an XML file for each class
    and pipe out the results to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加了用于信息的`qDebug()`语句，这看起来比实际情况更复杂。我们遍历每个注册的测试类，并使用静态的`QTest::qExec()`方法来检测并运行其中发现的所有测试。然而，一个关键的补充是，我们为每个类创建一个XML文件，并将结果传输到其中。
- en: This mechanism solves our two problems. We now have a single `main()` method
    that will detect and run all of our tests, and we get a separate XML file containing
    output for each of our test suites. However, before you can build the project,
    you will need to revisit `client-tests.cpp` and either comment out or remove the
    `QTEST_APPLESS_MAIN` line, or we'll be back to the problem of multiple `main()`
    methods. Don’t worry about the rest of `client-tests.cpp` for now; we’ll revisit
    it later when we start testing our data classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制解决了我们的两个问题。现在我们有一个单一的`main()`方法，将检测并运行我们所有的测试，并且我们得到一个单独的XML文件，其中包含每个测试套件的输出。但是，在构建项目之前，您需要重新查看`client-tests.cpp`，并注释或删除`QTEST_APPLESS_MAIN`行，否则我们将再次面临多个`main()`方法的问题。现在不要担心`client-tests.cpp`的其余部分；当我们开始测试我们的数据类时，我们将稍后重新访问它。
- en: 'Build and run now, and you’ll get a different set of text in `Application Output`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建和运行，您将在“应用程序输出”中获得一组不同的文本：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s go ahead and implement our first `TestSuite`. We have a `MasterController`
    class that presents a message string to the UI, so let''s write a simple test
    that verifies that the message is correct. We will need to reference code from
    `cm-lib` in the `cm-tests` project, so ensure that the relevant `INCLUDE` directives
    are added to `cm-tests.pro`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现我们的第一个`TestSuite`。我们有一个`MasterController`类，向UI呈现消息字符串，因此让我们编写一个简单的测试来验证消息是否正确。我们需要在`cm-tests`项目中引用`cm-lib`中的代码，因此请确保将相关的`INCLUDE`指令添加到`cm-tests.pro`中：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new companion test class called `MasterControllerTests` in `cm-tests/source/controllers`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-tests/source/controllers`中创建一个名为`MasterControllerTests`的新的伴随测试类。
- en: '`master-controller-tests.h`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`master-controller-tests.h`：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve explicitly added the `initTestCase()` and `cleanupTestCase()` scaffolding
    methods so that there is no mystery as to where they come from. We've also added
    another couple of special scaffolding methods for completeness: `init()` and `cleanup()`. The
    difference is that these methods are executed before and after each individual
    test, as opposed to before and after the entire suite of tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确添加了`initTestCase()`和`cleanupTestCase()`支撑方法，这样它们的来源就不再神秘。我们还为完整性添加了另外两个特殊的支撑方法：`init()`和`cleanup()`。不同之处在于这些方法在每个单独的测试之前和之后执行，而不是在整个测试套件之前和之后执行。
- en: None of these methods are doing anything for us and are there just for future
    reference. They can safely be removed if you want to streamline things.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对我们没有任何作用，只是为了将来参考。如果您想简化事情，可以安全地将它们删除。
- en: '`master-controller-tests.cpp`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`master-controller-tests.cpp`：'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We again have a single test, but this time, it actually serves some meaningful
    purpose. We want to test that when we instantiate a `MasterController` object
    and access its `welcomeMessage` method, it returns the message that we want, which
    will be Welcome to the Client Management system!.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有一个单一的测试，但这次它确实有一些有意义的目的。我们希望测试当我们实例化一个`MasterController`对象并访问其`welcomeMessage`方法时，它是否返回我们想要的消息，即Welcome
    to the Client Management system!。
- en: 'Unlike the scaffolding methods, the naming of your tests is entirely down to
    preference. I tend to loosely follow the `methodIAmTesting_givenSomeScenario_doesTheCorrectThing` 
    format, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与搭建方法不同，您的测试命名完全取决于个人喜好。我倾向于松散地遵循`methodIAmTesting_givenSomeScenario_doesTheCorrectThing`的格式，例如：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We construct an instance of `MasterController` as a private member variable
    that we will use to test against. In the implementation, we specify the name of
    the test suite via the constructor, and we also create a static instance of the
    test class. This is the trigger that adds `MasterControllerTests` to the static
    vector we saw in the `TestSuite` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构造一个`MasterController`的实例作为我们将用来测试的私有成员变量。在实现中，我们通过构造函数指定了测试套件的名称，并创建了测试类的静态实例。这是将`MasterControllerTests`添加到我们在`TestSuite`类中看到的静态向量的触发器。
- en: Finally, for the implementation of our test, we test the value of the `welcomeMessage`
    of our `masterController` instance with the message we want using the `QCOMPARE`
    macro. Note that because `QCOMPARE` is a macro, you won’t get implicit typecasting,
    so you need to ensure that the types of the expected and actual results are the
    same. Here, we’ve achieved that by constructing a `QString` object from the literal
    text.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们测试的实现，我们使用`QCOMPARE`宏测试我们`masterController`实例的`welcomeMessage`的值与我们想要的消息。请注意，因为`QCOMPARE`是一个宏，您不会得到隐式类型转换，因此您需要确保期望和实际结果的类型相同。在这里，我们通过从文字构造一个`QString`对象来实现这一点。
- en: 'Run `qmake`, and build and run to see the results of our test in the Application
    Output pane:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`qmake`，构建并运行以查看我们在应用程序输出窗格中的测试结果：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This begins with the registration of the `MasterControllerTests` class via the
    static instance. The `main()` method iterates the collection of registered test
    suites and finds one, then executes all the unit tests within that suite. The
    test suite contains one unit test that runs and promptly fails. This may seem
    to be less helpful than earlier as there is no indication as to which test failed
    or why. However, remember that this output is simply from the `qDebug()` statements
    we added for extra information; it is not the true output from the test execution. 
    In `master-controller-tests.cpp` we instantiated the `TestSuite` with a `testName` parameter
    of `MasterControllerTests`, so the output will have been piped to a file named
    `MasterControllerTests.xml`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这始于通过静态实例注册`MasterControllerTests`类。`main()`方法迭代注册的测试套件集合，并找到一个，然后执行该套件中的所有单元测试。测试套件包含一个运行并立即失败的单元测试。这可能看起来比之前不太有用，因为没有指示哪个测试失败或失败的原因。但是，请记住，这个输出只是我们为额外信息添加的`qDebug()`语句的输出；这不是测试执行的真正输出。在`master-controller-tests.cpp`中，我们使用`TestSuite`实例化了一个`testName`参数为`MasterControllerTests`，因此输出将被导入到名为`MasterControllerTests.xml`的文件中。
- en: 'Navigate to the `cm/binaries` folder and drill down through the folders to
    where we direct our project output for the selected configuration and in there,
    you will see `MasterControllerTests.xml`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`cm/binaries`文件夹，通过文件夹浏览到我们为所选配置指定项目输出的位置，在那里，您将看到`MasterControllerTests.xml`：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have the full output from the tests, and you can see that the failure
    was because the welcome message we got from `masterController` was This is MasterController
    to Major Tom, and we expected Welcome to the Client Management system!.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有来自测试的完整输出，您可以看到失败是因为我们从`masterController`得到的欢迎消息是This is MasterController
    to Major Tom，而我们期望的是Welcome to the Client Management system!。
- en: '`MasterController` is not behaving as expected, and we’ve found a bug, so head
    over to `master-controller.cpp` and fix the problem:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MasterController`的行为与预期不符，我们发现了一个错误，所以前往`master-controller.cpp`并修复问题：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rebuild both projects, execute the tests again, and bask in the glory of a
    100% pass rate:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建两个项目，再次执行测试，并沐浴在100%的通过率的荣耀中：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have the testing framework set up, let’s test something a little
    more complex than a simple string message and validate the work we did in the
    last chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了测试框架，让我们测试一些比简单的字符串消息更复杂的东西，并验证我们在上一章中所做的工作。
- en: DataDecorator tests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataDecorator测试
- en: 'In [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we created
    various classes deriving from `DataDecorator`. Let''s create companion test classes
    for each of those and test the following functionalities:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml)中，*数据*，我们创建了从`DataDecorator`派生的各种类。让我们为每个类创建相应的测试类，并测试以下功能：
- en: Object construction
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象构造
- en: Setting the value
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置值
- en: Getting the value as JSON
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值作为JSON获取
- en: Updating the value from JSON
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JSON更新值
- en: In `cm-tests/source/data`, create the `DateTimeDecoratorTests`, `EnumeratorDecoratorTests`,
    `IntDecoratorTests`, and `StringDecoratorTests` classes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-tests/source/data`中，创建`DateTimeDecoratorTests`、`EnumeratorDecoratorTests`、`IntDecoratorTests`和`StringDecoratorTests`类。
- en: Let’s begin with the simplest suite, `IntDecoratorTests`. The tests will be
    broadly similar across the suites, so once we’ve written one suite, we will be
    able to copy most of it across to the other suites and then supplement as necessary.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的套件`IntDecoratorTests`开始。测试在套件之间基本上是相似的，因此一旦我们编写了一个套件，我们就能够将大部分内容复制到其他套件中，然后根据需要进行补充。
- en: '`int-decorator-tests.h`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`int-decorator-tests.h`：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A common approach is to follow a “method as a unit” approach, where each method
    is the smallest testable unit in a class and then that unit is tested in multiple
    ways. So we begin by testing the constructor, both with and without parameters.
    The `setValue()` method should only do anything when we actually change the value,
    so we test both setting a different value and the same value. Next, we test that
    we can convert the decorator to a JSON value, both with a default value (`0` in
    the case of an `int`) and with a set value. Finally, we perform a couple of tests
    against the `update()` method. If we pass in a JSON that contains the property,
    then we expect the value to be updated as per the JSON value. However, if the
    property is missing from the JSON, we expect the class to handle it gracefully
    and reset to a default value instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是遵循“方法作为单元”的方法，其中每个方法是类中最小的可测试单元，然后以多种方式测试该单元。因此，我们首先测试构造函数，无论是否有参数。`setValue()`方法只有在实际更改值时才会执行任何操作，因此我们测试设置不同的值和相同的值。接下来，我们测试是否可以将装饰器转换为JSON值，无论是使用默认值（在`int`的情况下为`0`）还是使用设置的值。最后，我们对`update()`方法执行了一些测试。如果我们传入包含该属性的JSON，那么我们期望值将根据JSON值进行更新。但是，如果JSON中缺少该属性，我们期望类能够优雅地处理并重置为默认值。
- en: Note that we aren’t explicitly testing the `value()` method. This is just a
    simple accessor method with no side effects, and we will be calling it in the
    other unit tests, so we will be indirectly testing it there. Feel free to create
    additional tests for it if you wish.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们并没有明确测试`value()`方法。这只是一个简单的访问方法，没有副作用，我们将在其他单元测试中调用它，因此我们将在那里间接测试它。如果您愿意，可以为其创建额外的测试。
- en: '`int-decorator-tests.cpp`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`int-decorator-tests.cpp`：'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unit tests tend to follow an *Arrange > Act > Assert* pattern. Preconditions
    for the test are fulfilled first: variables are initialized, classes are configured,
    and so on. Then, an action is performed, generally calling the function being
    tested.  Finally, the results of the action are checked. Sometimes one or more
    of these steps will not be necessary or may be merged with another, but that is
    the general pattern.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常遵循“安排 > 执行 > 断言”的模式。首先满足测试的前提条件：变量被初始化，类被配置等。然后执行一个操作，通常是调用正在测试的函数。最后，检查操作的结果。有时，这些步骤中的一个或多个将是不必要的，或者可能与另一个步骤合并，但这是一般模式。
- en: We begin testing the constructor by initializing a new `IntDecorator` without
    passing in any parameters and then test that the various properties of the object
    have been initialized to expected default values using `QCOMPARE` to match actual
    against expected values. We then repeat the test, but this time, we pass in values
    for each of the parameters and verify that they have been updated in the instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过初始化一个没有传递任何参数的新`IntDecorator`来开始测试构造函数，然后测试对象的各种属性是否已初始化为预期的默认值，使用`QCOMPARE`将实际值与预期值进行匹配。然后我们重复测试，但这次，我们为每个参数传递值，并验证它们是否已在实例中更新。
- en: 'When testing the `setValue()` method, we need to check whether or not the `valueChanged()`
    signal is emitted. We can do this by connecting a lambda to the signal that sets
    a flag when called, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试`setValue()`方法时，我们需要检查`valueChanged()`信号是否被发射。我们可以通过将lambda连接到信号来设置一个标志来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, a much simpler solution we’ve used here is to use Qt’s `QSignalSpy`
    class that keeps track of calls to a specified signal. We can then check how many
    times a signal has been called using the `count()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里使用的一个更简单的解决方案是使用Qt的`QSignalSpy`类来跟踪对指定信号的调用。然后，我们可以使用`count()`方法来检查信号被调用的次数。
- en: 'The first `setValue()` test ensures that when we provide a new value that is
    different to the existing one, the value is updated and the `valueChanged()` signal
    is emitted once. The second test ensures that when we set the same value, no action
    is taken and the signal is not emitted. Note that we use an additional `QCOMPARE`
    call in both cases to assert that the value is what we expect it to be before
    the action is taken. Consider the following pseudo test:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`setValue()`测试确保当我们提供一个与现有值不同的新值时，该值将被更新，并且`valueChanged()`信号将被发射一次。第二个测试确保当我们设置相同的值时，不会采取任何操作，并且信号不会被发射。请注意，在这两种情况下，我们都使用额外的`QCOMPARE`调用来断言在采取行动之前值是否符合我们的预期。考虑以下伪测试：
- en: Set up your class.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的类。
- en: Perform an action.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个操作。
- en: Test that the value is `99`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试值为`99`。
- en: If everything works as expected, step 1 sets the value to `0`, step 2 takes
    the correct action and updates the value to `99`, and step 3 passes because the
    value is `99`. However, step 1 could be faulty and wrongly sets the value to `99`,
    step 2 is not even implemented and takes no action, and yet step 3 (and the test)
    passes because the value is `99`. With a `QCOMPARE` precondition after step 1,
    this is avoided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都按预期工作，第1步将值设置为`0`，第2步执行正确的操作并将值更新为`99`，第3步通过，因为值为`99`。然而，第1步可能是有错误的，并错误地将值设置为`99`，第2步甚至没有实现并且不采取任何行动，但第3步（和测试）通过，因为值为`99`。通过在第1步之后使用`QCOMPARE`前提条件，可以避免这种情况。
- en: The `jsonValue()` tests are simple equality checks, both with a default value
    and a set value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonValue()`测试是简单的相等性检查，无论是使用默认值还是设置值。'
- en: Finally, with the `update()` tests, we construct a couple of JSON objects. In
    one object, we add an item that has the same key as our decorator object (“Test
    Key”), which we expect to be matched and the associated value (`123`) passed through
    to `setValue()`. In the second object, the key is not present. In both cases,
    we also add other extraneous items to ensure that the class can correctly ignore
    them. The post action checks are the same as for the `setValue()` tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`update()`测试中，我们构造了一对JSON对象。在一个对象中，我们添加了一个具有与我们的装饰器对象相同键的项（“Test Key”），我们期望它被匹配，并且相关值（`123`）通过`setValue()`传递。在第二个对象中，该键不存在。在这两种情况下，我们还添加了其他多余的项，以确保类能够正确地忽略它们。后续操作的检查与`setValue()`测试相同。
- en: The `StringDecoratorTests` class is essentially the same as `IntDecoratorTests`,
    just with a different value data type and default values of empty string `""`
    rather than `0`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringDecoratorTests`类基本上与`IntDecoratorTests`相同，只是值数据类型不同，并且默认值为空字符串`""`而不是`0`。'
- en: '`DateTimeDecorator` also follows the same pattern, but with additional tests
    for the string formatting helper methods `toIso8601String()` and so on.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeDecorator`也遵循相同的模式，但还有额外的测试用于字符串格式化辅助方法`toIso8601String()`等。'
- en: '`EnumeratorDecoratorTests` performs the same tests but requires a little more
    setup because of the need for an enumerator and associated mapper. In the body
    of the tests, whenever we test `value()`, we also need to test `valueDescription()`
    to ensure that the two remain aligned. For example, whenever the value is `eTestEnum::Value2`,
    the `valueDescription()` must be `Value 2`. Note that we always use the enumerated
    values in conjunction with the `value()` checks and `static_cast` them to an `int`.
    Consider the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnumeratorDecoratorTests`执行相同的测试，但需要更多的设置，因为需要一个枚举器和相关的映射器。在测试的主体中，每当我们测试`value()`时，我们还需要测试`valueDescription()`以确保两者保持一致。例如，每当值是`eTestEnum::Value2`时，`valueDescription()`必须是`Value
    2`。请注意，我们总是将枚举值与`value()`检查一起使用，并将它们`static_cast`为`int`。考虑以下例子：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It may be tempting to make this much shorter by just using the raw `int` value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用原始的`int`值来缩短这个过程可能很诱人：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The problem with this approach, other than the number 2 having much less meaning
    to readers of the code than the enumerated `Value2`, is that the values of `eTestEnum`
    can change and render the test invalid. Consider this example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题，除了数字2对于代码读者来说比枚举`Value2`的意义要少得多之外，是`eTestEnum`的值可能会改变并使测试无效。考虑这个例子：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Due to the insertion of `MyAmazingNewTestValue`, the numeric equivalent of `Value2`
    is actually now 3\. Any tests that used the number 2 to represent `Value2` are
    now wrong, whereas those that use the more long-winded `static_cast<int>(eTestEnum::Value2)`
    are still correct.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插入了`MyAmazingNewTestValue`，`Value2`的数字等价物实际上现在是3。任何使用数字2表示`Value2`的测试现在都是错误的，而那些使用更冗长的`static_cast<int>(eTestEnum::Value2)`的测试仍然是正确的。
- en: Rebuild and run the new test suites, and they should all happily pass and give
    us renewed confidence in the code we wrote earlier. With the data decorators tested,
    let's move on to our data models next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行新的测试套件，它们应该都能愉快地通过并让我们对之前编写的代码重新获得信心。测试了数据装饰器后，让我们继续测试我们的数据模型。
- en: Entity Tests
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体测试
- en: Now that we have some confidence that our data decorators are working as expected,
    let’s move up a level and test our data entities. The Client class is the root
    of our model hierarchy and by testing that, we can test our other models in the
    process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对数据装饰器的工作有了一些信心，让我们提升一个层次，测试我们的数据实体。Client类是我们模型层次结构的根，通过测试它，我们可以测试我们的其他模型。
- en: We already have `client-tests.cpp` in `cm-tests/source/models` that Qt Creator
    added for us when we created the project, so go ahead and add a companion header
    file `client-tests.h`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`cm-tests/source/models`中有`client-tests.cpp`，这是Qt Creator在创建项目时为我们添加的，所以继续添加一个配套的头文件`client-tests.h`。
- en: '`client-tests.h`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`client-tests.h`：'
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are three main areas we want to test here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个主要的测试区域：
- en: Object construction
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象构造
- en: Serialization to JSON
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化为JSON
- en: Deserialization from JSON
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JSON反序列化
- en: 'As with previous suites, we have a couple of different flavors of test for
    each area—one with default data and one with specified data. In the private section,
    you will see numerous verify methods. They are to encapsulate the functionality
    required to test a particular subset of our data. The advantages of doing this
    are the same as with regular code: they make the unit tests much more concise
    and readable, and they allow easy reuse of the validation rules. Also, in the
    private section, we define a blob of JSON we can use to construct our Client instances.
    A `QByteArray`, as its name suggests, is simply an array of bytes that comes with
    numerous associated helpful functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的套件一样，每个区域都有几种不同的测试方式，一种是使用默认数据，一种是使用指定数据。在私有部分，您会看到许多验证方法。它们用于封装测试特定子集所需的功能。这样做的优势与常规代码相同：它们使单元测试更加简洁和可读，并且允许轻松重用验证规则。此外，在私有部分，我们定义了一个JSON块，我们可以用它来构造我们的Client实例。`QByteArray`，顾名思义，只是一个带有许多相关有用函数的字节数组：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Starting with the constructor tests, we instantiate a new Client, both with
    and without a JSON object. Note that in order to convert our JSON byte array to
    a `QJsonObject`, we need to pass it through a `QJsonDocument`. Once we have our
    initialized client, we check the name property and utilize the verify methods
    to test the state of the child objects for us. Regardless of whether or not we
    supply any initial data via a JSON object, we expect the `supplyAddress` and `billingAddress` objects
    to be created for us automatically as well as the appointments and contacts collections.
    By default, the collections should be empty:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数测试开始，我们实例化一个新的Client，有时带有JSON对象，有时没有。请注意，为了将我们的JSON字节数组转换为`QJsonObject`，我们需要通过`QJsonDocument`进行传递。一旦我们有了初始化的客户端，我们检查名称属性并利用验证方法来测试子对象的状态。无论我们是否通过JSON对象提供任何初始数据，我们都希望`supplyAddress`和`billingAddress`对象以及预约和联系人集合都会自动为我们创建。默认情况下，集合应该是空的：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `toJson()` tests follow much the same pattern. We construct an object without
    a JSON object so that we get default values for all the properties and child objects.
    We then immediately construct a `QJsonDocument` using a call to `toJson()` in
    the constructor to get the serialized JSON object for us. The `name` property
    is tested, and then we utilize the verify methods once more. When constructing
    a **Client** using JSON, we add precondition checks to ensure that our properties
    have been set correctly before we again call `toJson()` and test the results:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`toJson()`测试遵循相同的模式。我们构造一个没有JSON对象的对象，这样我们就可以得到所有属性和子对象的默认值。然后我们立即在构造函数中使用`toJson()`调用来构造一个`QJsonDocument`，以获取序列化的JSON对象。测试`name`属性，然后再次利用验证方法。当使用JSON构造**Client**时，我们添加前置检查，以确保我们的属性在再次调用`toJson()`之前已经正确设置，并测试结果：'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `update()` tests are the same as `toJson()`, but the other way around. This
    time, we construct a JSON object using our byte array and pass it in to `update()`,
    checking the state of the model afterward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`测试与`toJson()`相同，但方向相反。这次，我们使用我们的字节数组构造一个JSON对象，并将其传递给`update()`，然后检查模型的状态。'
- en: 'The various private verification methods are all simply sets of checks that
    save us having to repeat the same code over and over. Consider the given example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 各种私有验证方法只是一系列检查，可以避免我们重复编写相同的代码。考虑以下示例：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Build and run the unit tests again and the new **Client** tests should all happily
    pass.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行单元测试，新的**客户端**测试应该都能顺利通过。
- en: Mocking
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocking
- en: The unit tests we’ve written so far have all been pretty straightforward. While
    our **Client** class isn’t totally independent, its dependencies are all other
    data models and decorators that it can own and change at will. However, looking
    forward, we will want to persist client data in a database. Let's look at a few
    examples of how this can work and discuss how the design decisions we make impact
    the testability of the Client class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的单元测试都相当简单。虽然我们的**Client**类并不是完全独立的，但它的依赖关系都是其他数据模型和装饰器，它可以随意拥有和更改。然而，展望未来，我们将希望将客户端数据持久化到数据库中。让我们看一些如何实现这一点的例子，并讨论我们所做的设计决策如何影响Client类的可测试性。
- en: Open up the `scratchpad` project and create a new header `mocking.h` file, where
    we’ll implement a dummy Client class to play around with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`scratchpad`项目并创建一个新的头文件`mocking.h`，在这里我们将实现一个虚拟的Client类来进行测试。
- en: '`mocking.h`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`mocking.h`：'
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `main.cpp`, `#include <mocking.h>`, update the `engine.load()` line to load
    the default `main.qml` if it doesn’t already and add a few lines to spin up and
    save a dummy Client object:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中，`#include <mocking.h>`，更新`engine.load()`行以加载默认的`main.qml`，如果还没有的话，并添加几行来启动和保存一个虚拟的Client对象：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build and run the app, ignore the window, and take a look at the Application
    Output console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，忽略窗口，查看应用程序输出控制台：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have a way to ask a client to save itself, but it needs a database to save
    itself too. Let’s encapsulate our database management functionality into a `DatabaseController`
    class. In mocking.h, add the following implementation before the Client class.
    Note that you need to forward declare Client:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种方法可以要求客户端保存自身，但它也需要一个数据库来保存自身。让我们将数据库管理功能封装到`DatabaseController`类中。在mocking.h中，在Client类之前添加以下实现。注意，你需要提前声明Client：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, edit the Client class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑Client类：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Back in `main.cpp`, replace the Client lines with the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main.cpp`，用以下内容替换Client行：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we create and save two clients rather than just one. Build, run, and check
    the console again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建并保存两个客户端而不是一个。再次构建、运行，并再次检查控制台：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Okay, now we’re saving our clients to the production database, but we’re creating
    a new database connection for every client, which seems a bit wasteful. The Client
    class needs an instance of a `DatabaseController` to function, and this is known
    as a dependency.  However, we do not need the Client to be responsible for creating
    that instance; we can instead pass—or *inject—*the instance in via the constructor
    and manage the lifetime of the `DatabaseController` elsewhere. This technique
    of Dependency Injection is a form of a broader design pattern known as **Inversion
    of Control**. Let''s pass a reference to a shared `DatabaseController` into our
    Client class instead:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们将客户端保存到生产数据库中，但我们为每个客户端创建了一个新的数据库连接，这似乎有点浪费。Client类需要一个`DatabaseController`的实例来运行，这就是一个依赖关系。然而，我们不需要Client负责创建该实例；我们可以通过构造函数传递或*注入*该实例，并在其他地方管理`DatabaseController`的生命周期。这种依赖注入技术是一种更广泛的设计模式，称为**控制反转**。让我们将一个共享的`DatabaseController`的引用传递给我们的Client类：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Over in `main.cpp`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build and run the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行以下内容：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great, we’ve got a highly-efficient decoupled system architecture in place;
    let’s test it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经建立了一个高效的解耦系统架构；让我们来测试一下。
- en: 'In `mocking.h`, add a pretend test suite after the Client class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mocking.h`中，在Client类之后添加一个假的测试套件：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In `main.cpp`, after saving `client2`, add the following to run our tests:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中，在保存`client2`后，添加以下内容来运行我们的测试：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Build and run this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行这个：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our test passed, fantastic! What’s not to love about that? Well, the fact that
    we’ve just saved some test data to our production database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试通过了，太棒了！有什么不喜欢的呢？嗯，我们刚刚将一些测试数据保存到了我们的生产数据库中。
- en: If you don’t already implement interfaces for the majority of your classes,
    you soon will after you start unit testing for this precise reason. It’s not used
    solely to avoid nasty side effects like writing test data to a production database;
    it allows you to simulate all kinds of behaviors that make unit testing so much
    easier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有为大多数类实现接口，那么在开始单元测试后，你很快就会这样做。这不仅仅是为了避免像将测试数据写入生产数据库这样的不良副作用；它还允许你模拟各种行为，从而使单元测试变得更加容易。
- en: 'So, let’s move our `DatabaseController` behind an interface. Replace the plain
    `DatabaseController` in `mocking.h` with a supercharged interface-driven version:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将`DatabaseController`移到接口后面。用一个超级接口驱动版本替换`mocking.h`中的普通`DatabaseController`：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the interface in place, we can now create a fake or mock implementation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接口已经就位，我们现在可以创建一个虚假或模拟的实现：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, tweak our Client to hold a reference to the interface rather than the
    concrete implementation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调整我们的客户端，保存一个对接口的引用，而不是具体的实现：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, change our test suite to create a mock controller to pass into the
    clients:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，改变我们的测试套件，创建一个模拟控制器传递给客户端：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Build and run this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行这个：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Perfect. By programming to interfaces and injecting dependencies, we can safely
    test in isolation. We can create as many mock implementations as we need and use
    them to simulate whatever behavior we want, enabling us to test multiple different
    scenarios. Once you get more involved in mocking, it really pays to use a dedicated
    framework like **google mock**, as they save you the hassle of having to write
    a bunch of boilerplate mock classes. You can easily mock the interface once using
    helper macros and then specify behaviors for individual methods on the fly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。通过编程接口和注入依赖，我们可以安全地进行隔离测试。我们可以创建尽可能多的模拟实现，并用它们来模拟我们想要的任何行为，从而使我们能够测试多种不同的场景。一旦你更深入地涉足模拟，使用像**google
    mock**这样的专用框架确实很值得，因为它们可以节省你编写大量样板模拟类的麻烦。你可以使用辅助宏轻松地一次性模拟接口，然后在运行时指定各个方法的行为。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve taken our first proper look at the unit testing project,
    and you’ve seen how to implement unit testing using the Qt Test framework. We’ve
    also discussed the importance of programming to interfaces to enable mocking.
    Now we have unit tests in place for our main data classes, so if we ever accidentally
    change the behavior, the unit tests will fail and highlight a potential problem
    for us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首次正式查看了单元测试项目，并且你已经看到了如何使用Qt测试框架实现单元测试。我们还讨论了编程接口的重要性，以实现模拟。现在我们已经为我们的主要数据类准备好了单元测试，所以如果我们不小心改变了行为，单元测试将失败并为我们指出潜在的问题。
- en: As we discussed, this is not a book about test driven development, and we will
    sometimes cut corners and go against the advice in this chapter to keep the explanation
    of other concepts as simple as possible, but I do urge you to implement unit testing
    of some kind in your projects if you can, as it is a very valuable practice that
    is always worth the additional time investment. Some developers like the rigor
    of full-blown TDD, whereas others prefer to write unit test after the fact to
    verify the work they have done. Find an approach that works for you and your coding
    style.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，这不是一本关于测试驱动开发的书，我们有时会采取捷径，违背本章的建议，以尽可能简单地解释其他概念，但我敦促你在项目中实现某种单元测试，因为这是一种非常有价值的实践，总是值得额外的时间投资。一些开发人员喜欢全面的TDD的严谨性，而其他人更喜欢事后编写单元测试来验证他们所做的工作。找到适合你和你编码风格的方法。
- en: We will return to the test project occasionally to demonstrate certain behaviors.
    but we’ll certainly not be achieving 100% code coverage. Now that you have the
    test project and scaffolding in place, it’s just a case of adding further test
    classes for each class you want to test. As long as you inherit from `TestSuite`
    in the same way as we have in this chapter, they will be automatically detected
    and executed when you run the test project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将偶尔返回测试项目，以演示某些行为。但我们肯定不会达到100%的代码覆盖率。现在你已经有了测试项目和脚手架，只需要为想要测试的每个类添加进一步的测试类。只要你像本章中一样从`TestSuite`继承，它们将在运行测试项目时被自动检测和执行。
- en: In [Chapter 7](0563666d-47ad-4c30-abb0-731ed70a5349.xhtml), *Persistence*, we’ll
    go ahead and implement the functionality we just discussed—persisting our data
    to a database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](0563666d-47ad-4c30-abb0-731ed70a5349.xhtml) *持久化*中，我们将继续实现我们刚讨论过的功能——将数据持久化到数据库中。
