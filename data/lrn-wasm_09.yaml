- en: Integrating with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Node.js集成
- en: The modern web leans heavily on Node.js for both development and server-side
    management. With the advent of increasingly complex browser applications that
    perform computationally expensive operations, performance increases can be incredibly
    beneficial. In this chapter, we're going to describe the various ways you can
    integrate WebAssembly with Node.js through the use of various examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web在开发和服务器端管理方面严重依赖Node.js。随着越来越复杂的浏览器应用程序执行计算密集型操作，性能的提升将非常有益。在本章中，我们将描述通过各种示例集成WebAssembly与Node.js的各种方式。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下内容：
- en: The advantages of integrating WebAssembly with Node.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WebAssembly与Node.js集成的优势
- en: How to interact with the Node.js WebAssembly API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与Node.js的WebAssembly API交互
- en: How to utilize Wasm modules in a project that uses Webpack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在使用Webpack的项目中利用Wasm模块
- en: How to write unit tests for WebAssembly modules using `npm` libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`npm`库为WebAssembly模块编写单元测试
- en: Why Node.js?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Node.js？
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, Node.js was described as an asynchronous event-driven JavaScript
    runtime, which is the definition taken from the official website. What Node.js
    represents, however, is a profound shift in the way we build and manage web applications.
    In this section, we will discuss the relationship between WebAssembly and Node.js,
    and why the two technologies complement each other so well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)中，描述了Node.js作为异步事件驱动的JavaScript运行时，这是从官方网站上获取的定义。然而，Node.js代表的是我们构建和管理Web应用程序方式的深刻转变。在本节中，我们将讨论WebAssembly和Node.js之间的关系，以及为什么这两种技术如此互补。
- en: Seamless integration
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝集成
- en: Node.js runs on Google's V8 JavaScript engine, which powers Google Chrome. Since
    V8's WebAssembly implementation adheres to the *Core Specification*, you can interact
    with a WebAssembly module using the same API as the browser. Instead of performing
    a fetch call for a `.wasm` file, you can use Node.js's `fs` module to read the
    contents into a buffer, then call `instantiate()` on the result.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在Google的V8 JavaScript引擎上运行，该引擎驱动着Google Chrome。由于V8的WebAssembly实现遵循*核心规范*，因此您可以使用与浏览器相同的API与WebAssembly模块进行交互。您可以使用Node.js的`fs`模块将`.wasm`文件的内容读入缓冲区，然后对结果调用`instantiate()`，而不是执行`.wasm`文件的fetch调用。
- en: Complementary technologies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互补技术
- en: JavaScript has limitations on the server side as well. Expensive computation
    or working with large numbers can be optimized with WebAssembly's superior performance.
    As a scripting language, JavaScript excels at automating simple tasks. You could
    write a script to compile C/C++ to a Wasm file, copy it to a `build` folder, and
    see the changes reflected in the browser if you're using a tool like `Browsersync`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在服务器端也存在一些限制。使用WebAssembly的卓越性能可以优化昂贵的计算或处理大量数据。作为一种脚本语言，JavaScript擅长自动化简单的任务。您可以编写一个脚本来将C/C++编译为Wasm文件，将其复制到`build`文件夹中，并在浏览器中查看变化（如果使用类似`Browsersync`的工具）。
- en: Development with npm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用npm进行开发
- en: Node.js has an extensive ecosystem of tools and libraries in the form of `npm`.
    Sven Sauleau and other members of the open source community have created `webassemblyjs`,
    an extensive suite of tooling for WebAssembly built with Node.js. The `webassemblyjs`
    site at [https://webassembly.js.org](https://webassembly.js.org) includes the
    tagline *Toolchain for WebAssembly*. There are currently over 20 `npm` packages
    to perform various tasks and aid in development, such as an ESLint plugin, an
    AST validator, and a formatter. AssemblyScript, a TypeScript to WebAssembly compiler,
    allows you to write performant code that compiles to a Wasm module without having
    to learn C or C++. The Node.js community is clearly vested in WebAssembly's success.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js拥有一个庞大的工具和库生态系统，以`npm`的形式存在。Sven Sauleau和其他开源社区成员创建了`webassemblyjs`，这是一个使用Node.js构建的WebAssembly工具套件。`webassemblyjs`网站[https://webassembly.js.org](https://webassembly.js.org)包括标语*WebAssembly的工具链*。目前有超过20个`npm`包可执行各种任务并辅助开发，例如ESLint插件、AST验证器和格式化程序。AssemblyScript是一种TypeScript到WebAssembly的编译器，允许您编写高性能的代码，无需学习C或C++即可编译为Wasm模块。Node.js社区显然对WebAssembly的成功充满信心。
- en: Server-side WebAssembly with Express
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express进行服务器端WebAssembly
- en: Node.js can be used in several ways to add value to a WebAssembly project. In
    this section, we're going to walk through an example Node.js application that
    integrates WebAssembly. The application uses Express with some simple routes to
    call functions from a compiled Wasm module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以以多种方式用于增加WebAssembly项目的价值。在本节中，我们将通过一个示例Node.js应用程序来介绍集成WebAssembly的方法。该应用程序使用Express和一些简单的路由来调用编译后的Wasm模块中的函数。
- en: Overview of the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'The project reuses some of the code from the application we built in [Chapter
    7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating an Application from
    Scratch* (*Cook the Books*) to demonstrate how Node.js can be used with WebAssembly.
    The code for this section is located in the `/chapter-09-node/server-example`
    folder in the `learn-webassembly` repository. We''re going to review portions
    of the application directly applicable to Node.js. The following structure represents
    the file structure for the project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目重用了我们在[第7章](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml)中构建的应用程序（*从头开始创建应用程序*）的一些代码，以演示如何将Node.js与WebAssembly一起使用。本节的代码位于`learn-webassembly`存储库中的`/chapter-09-node/server-example`文件夹中。我们将审查与Node.js直接相关的应用程序部分。以下结构代表项目的文件结构：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With regard to dependencies, the application uses the `express` and `body-parser`
    libraries to set up routes and parse JSON from the body of requests. For data
    management, it uses `lowdb`, a library that provides methods for reading and updating
    a JSON file. The JSON file is located in `/src/assets/db.json` and contains data
    that was slightly modified from the Cook the Books dataset. We're using `nodemon`
    to watch for changes in the `/src` folder and reload the application automatically.
    We're using `rimraf` to manage file deletion. The library is included as a dependency
    in the event that you didn't install it globally in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. Finally, the `node-fetch` library allows us to
    use the fetch API to make HTTP requests when testing the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖项，该应用程序使用`express`和`body-parser`库来设置路由并解析来自请求主体的JSON。对于数据管理，它使用`lowdb`，这是一个提供读取和更新JSON文件方法的库。JSON文件位于`/src/assets/db.json`中，其中包含了从Cook
    the Books数据集中略微修改的数据。我们使用`nodemon`来监视`/src`文件夹中的更改并自动重新加载应用程序。我们使用`rimraf`来管理文件删除。该库作为依赖项包含在事件中，以防您没有在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)中全局安装它，*设置开发环境*。最后，`node-fetch`库允许我们在测试应用程序时使用fetch
    API进行HTTP请求。
- en: To simplify functionality in both the JavaScript and C files, the `rawAmount`
    and `cookedAmount` fields were replaced with a single `amount` field, and the
    `category` field is now `categoryId`, which maps to a `categories` array in `db.json`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化JavaScript和C文件中的功能，`rawAmount`和`cookedAmount`字段被替换为单个`amount`字段，`category`字段现在是`categoryId`，它映射到`db.json`中的`categories`数组。
- en: Express configuration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express配置
- en: 'The application is loaded in `/src/index.js`. The contents of this file are
    shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在`/src/index.js`中加载。该文件的内容如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file sets up a new Express app, adds the `body-parser` middleware, loads
    the mock database and Wasm instance, and assigns routes. Let's move on to discussing
    the difference between instantiating a Wasm module in the browser and Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件设置了一个新的Express应用程序，添加了`body-parser`中间件，加载了模拟数据库和Wasm实例，并分配了路由。让我们继续讨论在浏览器和Node.js中实例化Wasm模块的区别。
- en: Instantiating a Wasm module with Node.js
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js实例化Wasm模块
- en: 'The Wasm files are instantiated in `/src/load-assets.js`. We''re using the
    `memory.wasm` file from Cook the Books, but the `/assets/main.wasm` file is compiled
    from a slightly different version of `main.c`, which is located in the `/lib`
    folder. The `loadWasm()` function performs the same operation as the Wasm initialization
    code from Cook the Books, but the method for passing in the `bufferSource` to
    `WebAssembly.instantiate()` is different. Let''s examine this further by reviewing
    a portion of the code in the `loadWasm()` function of the `load-assets.js file`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm文件在`/src/load-assets.js`中实例化。我们使用了来自Cook the Books的`memory.wasm`文件，但`/assets/main.wasm`文件是从位于`/lib`文件夹中的稍微不同版本的`main.c`编译而来。`loadWasm()`函数执行的操作与Cook
    the Books中的Wasm初始化代码相同，但是将`bufferSource`传递给`WebAssembly.instantiate()`的方法不同。让我们通过查看`load-assets.js`文件中`loadWasm()`函数的部分代码来进一步了解这一点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To elaborate on the differences, here''s some code that instantiates a module
    using `fetch`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明区别，以下是使用`fetch`实例化模块的一些代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using Node.js, the fetch call is replaced by the `fs.readFileSync()` function
    and the `arrayBuffer()` function is no longer required because `fs.readFileSync()`
    returns a buffer that can be passed directly into the `instantiate()` function.
    Once the Wasm module is instantiated, we can start interacting with the instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Node.js时，`fetch`调用被`fs.readFileSync()`函数替换，不再需要`arrayBuffer()`函数，因为`fs.readFileSync()`返回一个可以直接传递给`instantiate()`函数的缓冲区。一旦Wasm模块被实例化，我们就可以开始与实例交互。
- en: Creating a mock database
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模拟数据库
- en: 'The `load-assets.js` file also contains a method for creating a mock database
    instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`load-assets.js`文件还包含了创建模拟数据库实例的方法：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `loadDb()` function loads the contents of `/assets/db.json` into an instance
    of `lowdb`. The default function exported from `load-assets.js` calls the `loadWasm()`
    and `loadDb()` functions and returns an object containing the mock database and
    Wasm instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadDb()`函数将`/assets/db.json`的内容加载到`lowdb`的实例中。从`load-assets.js`中默认导出的函数调用了`loadWasm()`和`loadDb()`函数，并返回一个包含模拟数据库和Wasm实例的对象：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going forward, I'll use the term database to refer to the `lowdb` instance that
    accesses the `db.json` file. Now that the assets are loaded, let's review how
    the application interacts with them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将使用术语数据库来指代访问`db.json`文件的`lowdb`实例。现在资产已加载，让我们回顾一下应用程序如何与它们交互。
- en: Interacting with the WebAssembly module
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与WebAssembly模块交互
- en: 'Interaction with the database and Wasm instance takes place across two files
    in the `/src` folder: `Transaction.js` and `assign-routes.js`. In our example
    application, all communication with the API is performed via HTTP requests. Sending
    a request to a specific endpoint will trigger some interaction with the database/Wasm
    instance on the server. Let''s start by reviewing `Transaction.js`, which interacts
    directly with the database and Wasm instance.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库和Wasm实例的交互发生在`/src`文件夹中的两个文件中：`Transaction.js`和`assign-routes.js`。在我们的示例应用程序中，所有与API的通信都是通过HTTP请求完成的。向特定端点发送请求将触发服务器上与数据库/Wasm实例的一些交互。让我们从直接与数据库和Wasm实例交互的`Transaction.js`开始回顾。
- en: Wrapping interaction in Transaction.js
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Transaction.js中包装交互
- en: 'Just as with Cook the Books, there''s a class that wraps the Wasm interaction
    code and provides a clean interface. The contents of `Transaction.js` are very
    similar to the contents of `/src/store/WasmTransactions.js` from Cook the Books.
    Most of the changes accommodate for the `categoryId` being present in a transaction
    record and a single `amount` field (no more raw and cooked amounts). Additional
    functionality was added to interact with the database. For example, here''s a
    function that edits an existing transaction, both in the database and the linked
    list from the Wasm instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Cook the Books一样，有一个类包装了Wasm交互代码并提供了一个清晰的接口。`Transaction.js`的内容与Cook the Books中的`/src/store/WasmTransactions.js`的内容非常相似。大部分更改是为了适应交易记录中存在`categoryId`和单个`amount`字段（不再有原始和烹饪金额）。还添加了与数据库交互的附加功能。例如，这是一个编辑现有交易的函数，既在数据库中，又在Wasm实例的链接列表中：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `edit()` function updates the database record that corresponds to the `transactionId`
    argument with the values in the `contents` argument. `this.db` is the database
    instance that was created in the `load-assets.js` file. Since the `categoryId`
    field is available on the `updatedTransaction` record, we can pass it directly
    to `this.wasmInstance._editTransaction()`. It gets passed into the constructor
    when a new instance of `Transaction` is created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit()`函数使用`contents`参数中的值更新与`transactionId`参数对应的数据库记录。`this.db`是在`load-assets.js`文件中创建的数据库实例。由于`updatedTransaction`记录上可用`categoryId`字段，我们可以直接将其传递给`this.wasmInstance._editTransaction()`。当创建`Transaction`的新实例时，它会被传递到构造函数中。'
- en: Transaction operations in assign-routes.js
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在assign-routes.js中的交易操作
- en: 'The `assign-routes.js` file defines routes and adds them to the `express` instance
    (`app`) created in `index.js`. In Express, routes can be defined directly on `app`
    (for example, `app.get()`), or through the use of a `Router`. In this case, a
    `Router` was used to add multiple methods to the same route path. The following
    code, taken from the `assign-routes.js` file, creates a `Router` instance and
    adds two routes: a `GET` route that returns all transactions, and a `POST` route
    that creates a new transaction:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign-routes.js`文件定义了路由并将它们添加到`index.js`中创建的`express`实例（`app`）中。在Express中，路由可以直接在`app`上定义（例如`app.get()`），也可以通过使用`Router`来定义。在这种情况下，使用了`Router`来将多个方法添加到相同的路由路径上。以下代码取自`assign-routes.js`文件，创建了一个`Router`实例并添加了两个路由：一个`GET`路由返回所有交易，一个`POST`路由创建一个新的交易。'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `app.use()` function at the end of the snippet specifies that all routes
    defined on the `transactionsRouter` instance are prefixed with `/api/transactions`.
    If you were running the application locally on port `3000`, you could navigate
    to `http://localhost:3000/api/transactions` in your browser and see an array of
    all the transactions in JSON format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 片段末尾的`app.use()`函数指定了在`transactionsRouter`实例上定义的所有路由都以`/api/transactions`为前缀。如果您在本地端口`3000`上运行应用程序，可以在浏览器中导航到`http://localhost:3000/api/transactions`，并以JSON格式查看所有交易的数组。
- en: As you can see from the body of the `get()` and `post()` functions, interactions
    with any transaction records are being delegated to the `Transaction` instance
    created in line `3`. That completes our review of pertinent sections of the code
    base. Each of the files contain comments describing the file's functionality and
    purpose, so you may want to review those before moving on to the next section.
    In the next section, we'll build, run, and interact with the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从`get()`和`post()`函数的主体中可以看出，与任何交易记录的交互都被委托给了第3行创建的`Transaction`实例。这完成了我们对代码库相关部分的审查。每个文件都包含描述文件功能和目的的注释，因此在继续下一部分之前，您可能需要审查这些内容。在下一部分中，我们将构建、运行并与应用程序交互。
- en: Building and running the application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: 'Before we build and test out the project, you''ll need to install the `npm`
    dependencies. Open a terminal within the `/server-example` folder and run the
    following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和测试项目之前，您需要安装`npm`依赖项。在`/server-example`文件夹中打开终端并运行以下命令：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once that's complete, you're ready to move on to the build step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以继续进行构建步骤。
- en: Building the application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'In the case of this application, building refers to compiling the `lib/main.c`
    to a `.wasm` file using the `emcc` command. Since this is a Node.js project, we
    can use the `scripts` key in our `package.json` file to define Tasks. You can
    still use VS Code''s Tasks feature because it automatically detects the scripts
    from your `package.json` file and presents them in the list of tasks when you
    select Tasks | Run Task... from the menu. The following code contains the contents
    of the `scripts` section in this project''s `package.json` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，构建是指使用`emcc`命令将`lib/main.c`编译为`.wasm`文件。由于这是一个Node.js项目，我们可以使用`package.json`文件中的`scripts`键来定义任务。您仍然可以使用VS
    Code的任务功能，因为它会自动检测`package.json`文件中的脚本，并在选择任务时将它们呈现在任务列表中。以下代码包含了该项目`package.json`文件中`scripts`部分的内容：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `build` script was split across multiple lines for display purposes, so
    you''d have to combine those lines for valid JSON. The `prebuild` script removes
    the existing Wasm file, and the `build` script runs the `emcc` command with the
    required flags to compile `lib/main.c` and output the result to `src/assets/main.wasm`.
    To run the script, open a terminal within the `/server-example` folder and run
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`脚本被拆分成多行以便显示，因此您需要将这些行组合成有效的JSON。`prebuild`脚本会删除现有的Wasm文件，而`build`脚本会使用所需的标志运行`emcc`命令，将`lib/main.c`编译并将结果输出到`src/assets/main.wasm`。要运行该脚本，请在`/server-example`文件夹中打开终端并运行以下命令：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the `/src/assets` folder contains a file named `main.wasm`, the build completed
    successfully. If an error has occurred, the terminal should provide a description
    of the error, as well as a stack trace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/src/assets`文件夹中包含名为`main.wasm`的文件，则构建已成功完成。如果发生错误，终端应提供错误的描述以及堆栈跟踪。
- en: You can create `npm` scripts that run before or after a specific script by creating
    an entry with the same name and prefixing it with `pre` or `post`. For example,
    if you wanted to run a script after the `build` script has completed, you can
    create a script named `"postbuild"` and specify the command you want to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建`npm`脚本，在特定脚本之前或之后运行，方法是创建一个与相同名称的条目，并在前面加上`pre`或`post`。例如，如果你想在`build`脚本完成后运行一个脚本，你可以创建一个名为`"postbuild"`的脚本，并指定你想要运行的命令。
- en: Starting and testing out the application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和测试应用程序
- en: 'If you''re making changes to the application or trying to fix a bug, you could
    use the `watch` script to watch for any changes to the contents of the `/src`
    folder and automatically restart the application if a change was made. Since we''re
    just running and testing out the application, we can use the `start` command instead.
    In the terminal, ensure you''re in the `/server-example` folder and run the following
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在对应用程序进行更改或尝试修复错误，你可以使用`watch`脚本来监视`/src`文件夹中内容的任何更改，并在有更改时自动重新启动应用程序。由于我们只是运行和测试应用程序，所以可以使用`start`命令。在终端中，确保你在`/server-example`文件夹中，并运行以下命令：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a message that says `Server is running on port 3000`. You''re
    now able to send HTTP requests to the server. To test the application, open a
    new terminal instance within the `server-example` directory and run the following
    command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个消息，上面写着`服务器正在3000端口上运行`。现在你可以向服务器发送HTTP请求了。要测试应用程序，在`server-example`目录中打开一个新的终端实例，并运行以下命令：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This should log out the response body of the `GET` call to the `/api/transactions`
    endpoint. The `requests.js` file contains functionality that allows you to make
    requests to all of the available routes. The `getFetchActionForId()` function
    returns an object with an endpoint and options value, which corresponds to a route
    in the `assign-routes.js` file. The `actionId` is an arbitrary number to simplify
    testing and reduce the amount of typing for running commands. For example, you
    could run the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该记录下对`/api/transactions`端点的`GET`调用的响应主体。`requests.js`文件包含了允许你对所有可用路由进行请求的功能。`getFetchActionForId()`函数返回一个带有端点和选项值的对象，对应于`assign-routes.js`文件中的一个路由。`actionId`是一个任意的数字，用于简化测试并减少运行命令时的输入量。例如，你可以运行以下命令：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It will log out the sum of all transactions for the *Computer & Internet* category.
    You can pass an additional argument to the `node` command if you want the total
    for a different category. To get the sum of all transactions in the *Insurance*
    category, run this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它将记录下*计算机与互联网*类别的所有交易的总和。如果你想要其他类别的总和，可以向`node`命令传递额外的参数。要获取*保险*类别的所有交易总和，运行以下命令：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try going through each of the requests (there are eight in total). If you make
    a request that adds, removes, or edits a transaction, you should see the changes
    in the `/src/assets/db.json` file. That's it for the Node.js example project.
    In the next section, we'll utilize Webpack to load and interact with a Wasm module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过每个请求（总共有八个）进行。如果你发出了一个添加、删除或编辑交易的请求，你应该在`/src/assets/db.json`文件中看到变化。这就是Node.js示例项目的全部内容。在下一节中，我们将利用Webpack来加载和与Wasm模块交互。
- en: Client-side WebAssembly with Webpack
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack进行客户端WebAssembly
- en: Web applications continue to grow in complexity and size. Simply serving up
    a few handwritten HTML, CSS, and JavaScript files is not feasible for large applications.
    To manage this complexity, web developers use bundlers to allow for modularization,
    ensure browser compatibility, and reduce the size of JavaScript files. In this
    section, we're going to be using a popular bundler, Webpack, to utilize Wasm without
    using `emcc`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序在复杂性和规模上继续增长。简单地提供一些手写的HTML、CSS和JavaScript文件对于大型应用程序来说是不可行的。为了管理这种复杂性，Web开发人员使用捆绑器来实现模块化，确保浏览器兼容性，并减少JavaScript文件的大小。在本节中，我们将使用一种流行的捆绑器Webpack来利用Wasm，而不使用`emcc`。
- en: Overview of the project
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'The example Webpack application extends the functionality of the C code we
    wrote in the *Compiling C without the glue code* section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. Instead of showing a blue rectangle bouncing
    around a red background, we''ll show an alien in a spaceship bouncing around the
    Horsehead Nebula. The collision detection functionality has been modified to accommodate
    for bouncing within a rectangle, so the movement of the spaceship will be random.
    The code for this section is located in the `/chapter-09-node/webpack-example`
    folder in the `learn-webassembly` repository. The file structure for the project
    is shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例Webpack应用程序扩展了我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)的*编译C而不使用粘合代码*部分中编写的C代码的功能，*创建和加载WebAssembly模块*。我们不再展示一个蓝色矩形在红色背景上弹跳，而是展示一个飞船在马头星云中弹跳。碰撞检测功能已经修改，以适应在矩形内弹跳，所以飞船的移动将是随机的。本节的代码位于`learn-webassembly`存储库中的`/chapter-09-node/webpack-example`文件夹中。项目的文件结构如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We'll review the Webpack configuration file in a later section. For now, let's
    take a moment to discuss Webpack in more detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中审查Webpack配置文件。现在，让我们花一点时间更详细地讨论Webpack。
- en: What is Webpack?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Webpack？
- en: The JavaScript ecosystem has been rapidly evolving over the past several years,
    resulting in new frameworks and libraries popping up constantly. Bundlers came
    about as a way to enable developers to split a JavaScript application into several
    files without having to worry about managing global namespaces, script loading
    order, or an incredibly long list of `<script>` tags in the HTML file. A bundler
    combines all of the files into one and resolves any naming collisions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，JavaScript生态系统一直在迅速发展，导致不断涌现新的框架和库。捆绑器的出现使开发人员能够将JavaScript应用程序分成多个文件，而不必担心管理全局命名空间、脚本加载顺序或HTML文件中的一长串`<script>`标签。捆绑器将所有文件合并为一个文件，并解决任何命名冲突。
- en: Webpack is, at the time of writing, one of the most popular bundlers for frontend
    development. It does much more than combine JavaScript files, however. It also
    performs complex tasks such as code-splitting and tree shaking (dead-code elimination).
    Webpack was designed with a plugin architecture, which resulted in a massive amount
    of community-developed plugins. A search for Webpack on `npm` currently returns
    over 12,000 packages! This exhaustive list of plugins, along with its powerful
    built-in feature set, makes Webpack a full-fledged build tool.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，Webpack是前端开发中最流行的打包工具之一。然而，它的功能远不止于合并JavaScript文件。它还执行复杂的任务，如代码拆分和摇树（死代码消除）。Webpack采用了插件架构，这导致了大量由社区开发的插件。在`npm`上搜索Webpack目前返回超过12,000个包！这个详尽的插件列表，加上其强大的内置功能集，使Webpack成为一个功能齐全的构建工具。
- en: Installing and configuring Webpack
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Webpack
- en: 'Before we begin the application walk-through, open up a terminal within the
    `/webpack-example` folder and run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始应用程序演示之前，在`/webpack-example`文件夹中打开终端并运行以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dependencies overview
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖概述
- en: 'The application uses Version 4 of Webpack (the most recent version as of writing
    this) to build our application. We need to use Webpack plugins to load the various
    file types used in the application and Babel to utilize newer JavaScript features.
    The following snippet lists the `devDependencies` we''re using in the project
    (taken from `package.json`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用Webpack的版本4（在撰写本文时为最新版本）来构建我们的应用程序。我们需要使用Webpack插件来加载应用程序中使用的各种文件类型，并使用Babel来利用较新的JavaScript功能。以下片段列出了我们在项目中使用的`devDependencies`（取自`package.json`）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I specified exact versions for some of the libraries to ensure the application
    builds and runs successfully. Any libraries with a name ending in `-loader` or
    `-plugin` are used in conjunction with Webpack. The `cpp-wasm-loader` library
    allows us to import a C or C++ file directly, without having to compile it to
    Wasm first. Webpack 4 has built-in support for importing `.wasm` files, but you
    can't specify an `importObj` argument, which is required for modules generated
    with Emscripten.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一些库指定了确切的版本，以确保应用程序能够成功构建和运行。任何以“-loader”或“-plugin”结尾的库都与Webpack一起使用。`cpp-wasm-loader`库允许我们直接导入C或C++文件，而无需先将其编译为Wasm。Webpack
    4内置支持导入`.wasm`文件，但无法指定`importObj`参数，这是使用Emscripten生成的模块所必需的。
- en: Configuring loaders and plugins in webpack.config.js
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在webpack.config.js中配置加载器和插件
- en: 'We''re using several different file types in addition to JavaScript for the
    application: CSS, SVG, HTML, and so on. Installing the `-loader` dependencies
    is only part of the equation—you also need to tell Webpack how to load them. You
    also need to specify configuration details for any plugins you have installed.
    You can specify the loading and configuration details in a `webpack.config.js`
    file in the root folder of your project. The following snippet contains the contents
    of `/webpack-example/webpack.config.js`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JavaScript之外，我们还在应用程序中使用了几种不同的文件类型：CSS、SVG、HTML等。安装`-loader`依赖项只是问题的一部分——您还需要告诉Webpack如何加载它们。您还需要为已安装的任何插件指定配置详细信息。您可以在项目的根文件夹中的`webpack.config.js`文件中指定加载和配置详细信息。以下片段包含了`/webpack-example/webpack.config.js`的内容：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `rules` section tells Webpack which loader to use for a file extension.
    The fourth item in the array handles C/C++ files (note the `test` field value
    containing `c|cpp`). The `HtmlWebpackPlugin` takes the contents of `/src/index.html`,
    adds any required `<script>` tags, minifies it, and creates an `index.html` in
    the `build` folder, which defaults to `/dist`. The `MiniCssExtractPlugin` copies
    any imported CSS into a single CSS file in the `/dist` folder. We'll review how
    to build the project in a later section, so let's move on to the application code,
    starting with the C file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`rules`部分告诉Webpack使用哪个加载器来处理文件扩展名。数组中的第四项处理C/C++文件（注意`test`字段值包含`c|cpp`）。`HtmlWebpackPlugin`获取`/src/index.html`的内容，添加任何所需的`<script>`标签，对其进行最小化，并在`build`文件夹中创建一个`index.html`，默认为`/dist`。`MiniCssExtractPlugin`将任何导入的CSS复制到`/dist`文件夹中的单个CSS文件中。我们将在后面的部分中讨论如何构建项目，所以让我们继续进行应用程序代码的讲解，从C文件开始。'
- en: The C code
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C代码
- en: 'Since we''re allowed to import C and C++ files directly, the C file is located
    within the `/src` folder. This file, `main.c`, contains logic to manage collision
    detection and move the spaceship around the `<canvas>`. The code is based on the
    `without-glue.c` file we created in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. We''re not going to review the entire file,
    only the sections that have changed and merit explanation. Let''s begin with the
    definitions and declarations section, which includes a new `struct`: `Bounds`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以直接导入C和C++文件，因此C文件位于`/src`文件夹中。这个文件，`main.c`，包含了管理碰撞检测和移动飞船的逻辑。这段代码基于我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中创建的`without-glue.c`文件，*创建和加载WebAssembly模块*。我们不打算审查整个文件，只审查已更改并值得解释的部分。让我们从定义和声明部分开始，其中包括一个新的`struct`：`Bounds`。
- en: Definitions and declarations
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和声明
- en: 'The code containing the definitions and declarations sections is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 包含定义和声明部分的代码如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: New properties were added to the existing `Rect` definition to accommodate for
    flexible sizing and tracking movement in the *x* and *y* directions. We defined
    a new `struct`, `Bounds`, and removed the existing `#define` statements because
    the `<canvas>` element is no longer a square with static dimensions. A new instance
    of both elements is declared when the module loads. The dimensional properties
    of these instances are assigned in the `start()` function, which we'll cover next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有的`Rect`定义添加了新属性，以适应灵活的大小和在*x*和*y*方向上的移动跟踪。我们定义了一个新的`struct`，`Bounds`，并删除了现有的`#define`语句，因为`<canvas>`元素不再是具有静态尺寸的正方形。模块加载时声明了这两个元素的新实例。这些实例的尺寸属性在`start()`函数中赋值，接下来我们将介绍这个函数。
- en: The start() function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: start()函数
- en: 'The updated `start()` function, which acts as the entry point to the module,
    is shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的`start()`函数，作为模块的入口点，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any functions that are called from JavaScript are prepended with the `EMSCRIPTEN_KEEPALIVE`
    statement. We're now passing the width and height of both the `Bounds` and `Rect`
    elements as arguments to the `start()` function, which we assign to the local
    `bounds` and `rect` variables. This allows us to easily change the dimensions
    of either one without having to make any changes to the collision detection logic.
    In the context of this application, the `rect` represents the rectangle in which
    the spaceship image resides. We set the default horizontal and vertical direction
    for the `rect` so the image initially moves to the right and down. Let's move
    on to the `rect` movement/collision detection code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从JavaScript调用的任何函数都以`EMSCRIPTEN_KEEPALIVE`语句为前缀。现在，我们将`Bounds`和`Rect`元素的宽度和高度作为参数传递给`start()`函数，然后将其分配给本地的`bounds`和`rect`变量。这使我们可以轻松地更改任一元素的尺寸，而无需对碰撞检测逻辑进行任何更改。在这个应用程序的上下文中，`rect`表示飞船图像所在的矩形。我们设置了`rect`的默认水平和垂直方向，使图像最初向右和向下移动。让我们继续进行`rect`移动/碰撞检测代码。
- en: The updateRectLocation() function
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`updateRectLocation()`函数
- en: 'The code related to collision detection and the `Rect` movement is handled
    in the `updateRectLocation()` function, which is shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与碰撞检测和`Rect`移动相关的代码在`updateRectLocation()`函数中处理，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The primary difference between this code and the code we wrote in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*, is the collision detection logic. Instead of
    simply tracking the location of the `rect` instance horizontally and changing
    direction when it hits the right boundary, the function now tracks the horizontal
    and vertical directions and manages each independently. Although this isn't the
    most performant algorithm, it does achieve the goal of ensuring the spaceship
    changes direction when it encounters the edge of the `<canvas>`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中编写的代码的主要区别是碰撞检测逻辑。现在，函数不仅仅是水平跟踪`rect`实例的位置，并在其击中右边界时改变方向，而是现在函数同时跟踪水平和垂直方向，并独立管理每个方向。虽然这不是最高效的算法，但它确实实现了确保飞船在遇到`<canvas>`边缘时改变方向的目标。
- en: The JavaScript code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript代码
- en: The only production dependency we're using for the application is Vue. Although
    the application consists of a single component, Vue makes managing data, functions,
    and the component life-cycle much simpler than trying to do it manually. The `index.js`
    file contains the Vue initialization code, while the rendering and application
    logic is in `/src/App.js`. This file has a lot of moving parts, so we're going
    to review the code in chunks, as we did in the previous section. Let's start with
    the `import` statements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序唯一的生产依赖是Vue。虽然应用程序只包含一个组件，但Vue使得管理数据、函数和组件生命周期比手动操作简单得多。`index.js`文件包含了Vue初始化代码，而渲染和应用程序逻辑在`/src/App.js`中。这个文件有很多部分，所以我们将像在上一节一样分块审查代码。让我们从`import`语句开始。
- en: The import statements
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'The following code demonstrates the Webpack loaders in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了Webpack加载器的工作原理：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The loaders we configured in the `webpack.config.js` file understand how to
    handle CSS, C, and image files. Now that we have the required resources available,
    we can start defining our component state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`webpack.config.js`文件中配置的加载器知道如何处理CSS、C和图像文件。现在我们有了所需的资源，我们可以开始定义我们的组件状态。
- en: Component state
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件状态
- en: 'The following code initializes the local state in the `data()` function for
    our component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在`data()`函数中初始化了组件的本地状态：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although the `bounds` and `rect` properties never change, we defined them in
    the local state to keep all the data used by the component in a single location.
    The `speed` property dictates how quickly the spaceship moves across the `<canvas>`
    and has a range of `1` to `10`. The `instance` property is initialized to null,
    but will be used to access the compiled Wasm module's exported functions. Let's
    move on to the Wasm initialization code that compiles the Wasm file and populates
    the `<canvas>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`bounds`和`rect`属性永远不会改变，但我们在本地状态中定义它们，以便将组件使用的所有数据保存在一个位置。`speed`属性决定了飞船在`<canvas>`上移动的速度，并且范围为`1`到`10`。`instance`属性初始化为null，但将用于访问编译后的Wasm模块的导出函数。让我们继续进行编译Wasm文件并填充`<canvas>`的Wasm初始化代码。
- en: Wasm initialization
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm初始化
- en: 'The code to compile the Wasm file and populate the `<canvas>` element is shown
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译Wasm文件并填充`<canvas>`元素的代码如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are additional functions defined in the `methods` key of the component,
    but for now we'll focus on the code that compiles the imported C file to Wasm.
    After `Image` instances are created for the spaceship and background images, the
    `main.c` file (imported as `.wasm`) is compiled to a Wasm module and the resulting
    `exports` is assigned to `this.instance`. Once these operations complete, the
    `start()` function can be called from the exported Wasm module. Since the `initializeWasm()`
    function calls the `<canvas>` element's `getContext()` function, the component
    needs to be mounted before this function can be called. Let's review the rest
    of the `methods` definitions and the `mounted()` event handler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的`methods`键中定义了其他函数，但现在我们将专注于将导入的C文件编译为Wasm的代码。在为飞船和背景图像创建`Image`实例之后，将`main.c`文件（导入为`.wasm`）编译为Wasm模块，并将结果的`exports`分配给`this.instance`。完成这些操作后，可以从导出的Wasm模块中调用`start()`函数。由于`initializeWasm()`函数调用了`<canvas>`元素的`getContext()`函数，因此在调用此函数之前，组件需要被挂载。让我们审查`methods`定义的其余部分和`mounted()`事件处理程序。
- en: Component mounting
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件挂载
- en: 'The remaining `methods` definitions and `mounted()` event handler function
    are shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的`methods`定义和`mounted()`事件处理程序函数如下所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the Wasm module is compiled, the `start()` function is accessible on `this.instance`.
    The `bounds` and `rect` dimensions are passed into the `start()` function, and
    then the `loopRectFunction()` is called to start moving the spaceship. The `onActionClick()`
    event handler function pauses or resumes the movement of the spaceship based on
    whether or not it's currently in motion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Wasm模块被编译，`start()`函数就可以在`this.instance`上访问。`bounds`和`rect`尺寸被传递到`start()`函数中，然后调用`loopRectFunction()`来开始移动飞船。`onActionClick()`事件处理程序函数根据飞船当前是否在运动来暂停或恢复飞船的移动。
- en: The `loopRectMotion()` functions in the same way as the example code from [Chapter
    5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading a WebAssembly
    Module*, except the speed is now adjustable. The `15 - this.speed` calculation,
    which dictates the timeout length, may look a little strange. Since the movement
    speed of the image is based on the amount of time that elapses between function
    calls, increasing this number would actually slow down the spaceship. Consequently,
    `this.speed` is subtracted from `15`, which was chosen because it's slightly greater
    than `10` but won't turn the spaceship into a blur if `this.speed` is increased
    to the maximum. That's it for the component logic; let's move on to the rendering
    section of the code where the `template` is defined.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`loopRectMotion()`函数的工作方式与[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中的示例代码相同，*创建和加载WebAssembly模块*，只是现在速度是可调节的。`15
    - this.speed`的计算可能看起来有点奇怪。由于图像的移动速度是基于函数调用之间经过的时间，增加这个数字实际上会减慢飞船的速度。因此，`this.speed`从`15`中减去，选择`15`是因为它略大于`10`，但不会在将`this.speed`增加到最大值时使飞船变得模糊。这就是组件逻辑；让我们继续到代码的渲染部分，其中定义了`template`。'
- en: Component rendering
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件渲染
- en: 'The contents of the `template` property, which dictates what to render, are
    shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`属性的内容，决定了要渲染的内容，如下所示：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since we're using Vue, we can bind the attributes and event handlers of HTML
    elements to properties and methods defined in our component. In addition to a
    PAUSE/RESUME button, there's a range `<input>` that allows you to change the speed.
    By sliding it to the left or right, you're able to slow down or speed up the spaceship
    and see the changes reflected immediately. That concludes our review; let's see
    how Webpack can be used to build or run the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了Vue，我们可以将HTML元素的属性和事件处理程序绑定到组件中定义的属性和方法。除了一个暂停/恢复按钮，还有一个范围`<input>`，允许您改变速度。通过将其向左或向右滑动，您可以减慢或加快飞船的速度，并立即看到变化。这就结束了我们的回顾；让我们看看Webpack如何用来构建或运行应用程序。
- en: Building and running the application
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: 'Using the `cpp-wasm-loader` library eliminates the need for a build step to
    generate a Wasm module, but we still need to bundle up our application for distribution.
    In the `scripts` section of `package.json`, there''s a `build` and `start` script.
    Running the `build` script executes the `webpack` command that generates the bundle.
    To ensure this is working correctly, open a terminal instance in the `/webpack-example`
    folder and run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cpp-wasm-loader`库可以消除构建步骤生成Wasm模块的需要，但我们仍然需要将应用程序捆绑起来进行分发。在`package.json`的`scripts`部分，有一个`build`和`start`脚本。运行`build`脚本会执行生成捆绑包的`webpack`命令。为了确保这一切都正常工作，打开`/webpack-example`文件夹中的终端实例，并运行以下命令：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It may take a minute to build the project the first time you run it. This can
    be attributed to the Wasm compilation step. However, subsequent builds should
    be much faster. If the build was successful, you should see a newly created `/dist`
    folder with these contents:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行项目构建可能需要一分钟。这可能归因于Wasm编译步骤。但是，后续的构建应该会快得多。如果构建成功，您应该会看到一个新创建的`/dist`文件夹，其中包含以下内容：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing the build
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试构建
- en: 'Let''s try out the build to ensure everything is working correctly. Run the
    following command in your terminal instance to start the application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建以确保一切都正常工作。在终端实例中运行以下命令来启动应用程序：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在浏览器中导航到`http://127.0.0.1:8080/index.html`，您应该会看到这个：
- en: '![](img/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3c1c1f-1f92-41e2-a5e6-27673bc221d8.png)'
- en: Webpack application running in the browser
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack应用程序在浏览器中运行
- en: The spaceship image (taken from [https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg](https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg))
    bounces around within the bounds of the Horsehead Nebula background image (taken
    from [https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg](https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg)).
    When the PAUSE button is pressed, the button's caption changes to RESUME and the
    ship stops moving. Pressing the button again will change the caption back to PAUSE and
    the ship will start moving again. Adjusting the SPEED slider increases or decreases
    the speed of the ship.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船图像（取自[https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg](https://commons.wikimedia.org/wiki/File:Alien_Spaceship_-_SVG_Vector.svg)）在Horsehead星云背景图像（取自[https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg](https://commons.wikimedia.org/wiki/File:Horsehead_Nebula_Christmas_2017_Deography.jpg)）的范围内弹来弹去。当按下暂停按钮时，按钮的标题会更改为恢复，飞船停止移动。再次按下按钮将会将标题更改回暂停，并且飞船将再次开始移动。调整速度滑块会增加或减少飞船的速度。
- en: Running the start script
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行启动脚本
- en: 'The application has the `webpack-dev-server` library installed, which operates
    like `Browsersync.` The library uses LiveReloading, which automatically updates
    the application when you make any changes to the files in `/src`. Since we''re
    using a Webpack loader for C and C++ files, the automatic update event will trigger
    if you change the C file as well. Run the following the command to start the application
    and watch for changes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已安装`webpack-dev-server`库，它的操作方式类似于`Browsersync`。该库使用LiveReloading，在您对`/src`中的文件进行任何更改时会自动更新应用程序。由于我们使用了C和C++文件的Webpack加载器，因此如果您更改了C文件，自动更新事件也会触发。运行以下命令来启动应用程序并监视更改：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A browser window should open automatically when the build completes, and then
    direct you to the running application. To see the live-reloading feature in action,
    try setting the value of the `isRunning` variable in the `setIsRunning()` function
    in `main.c` to false instead of `newIsRunning`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成时，浏览器窗口应该会自动打开，然后将您引导到运行的应用程序。要查看实时重新加载功能的操作，请尝试将`main.c`中的`setIsRunning()`函数中的`isRunning`变量的值设置为false，而不是`newIsRunning`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The spaceship should be stuck in the upper-left corner. If you change it back,
    the spaceship starts moving again. In the next section, we will write unit tests
    in JavaScript to test WebAssembly modules.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船应该被卡在左上角。如果您将其改回，飞船将重新开始移动。在下一节中，我们将编写JavaScript单元测试来测试WebAssembly模块。
- en: Testing WebAssembly modules with Jest
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest测试WebAssembly模块
- en: Well-tested code prevents regression bugs, simplifies refactoring, and alleviates
    some of the frustrations that go along with adding new features. Once you've compiled
    a Wasm module, you should write tests to ensure it's functioning as expected,
    even if you've written tests for C, C++, or Rust code you compiled it from. In
    this section, we'll use **Jest**, a JavaScript testing framework, to test the
    functions in a compiled Wasm module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 经过充分测试的代码可以防止回归错误，简化重构，并减轻添加新功能时的一些挫折感。一旦您编译了一个Wasm模块，您应该编写测试来确保它的功能符合预期，即使您已经为您从中编译出来的C、C++或Rust代码编写了测试。在本节中，我们将使用**Jest**，一个JavaScript测试框架，来测试编译后的Wasm模块中的函数。
- en: The code being tested
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在测试的代码
- en: 'All of the code used in this example is located in the `/chapter-09-node/testing-example`
    folder. The code and corresponding tests are very simple and are not representative
    of real-world applications, but they''re intended to demonstrate how to use Jest
    for testing. The following code represents the file structure of the `/testing-example`
    folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中使用的所有代码都位于`/chapter-09-node/testing-example`文件夹中。代码和相应的测试非常简单，不代表真实应用程序，但旨在演示如何使用Jest进行测试。以下代码表示`/testing-example`文件夹的文件结构：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The contents of the C file that we''ll test, `/src/main.c`, is shown as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的C文件的内容，`/src/main.c`，如下所示：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All three functions in the file are performing simple mathematical operations.
    The `package.json` file includes a script to compile the C file to a Wasm file
    for testing. Run the following command to compile the C file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的所有三个函数都执行简单的数学运算。`package.json`文件包含一个脚本，用于将C文件编译为Wasm文件进行测试。运行以下命令来编译C文件：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There should be a file named `main.wasm` in the `/src` directory. Let's move
    on to describing the testing configuration step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src`目录中应该有一个名为`main.wasm`的文件。让我们继续描述测试配置步骤。'
- en: Testing configuration
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试配置
- en: 'The only dependency we''ll use for this example is Jest, a JavaScript testing
    framework built by Facebook. Jest is an excellent choice for testing because it
    includes most of the features you''ll need out of the box, such as coverage, assertions,
    and mocking. In most cases, you can use it with zero configuration, depending
    on the complexity of your application. If you''re interested in learning more,
    check out Jest''s website at [https://jestjs.io](https://jestjs.io). Open a terminal
    instance in the `/chapter-09-node/testing-example` folder and run the following
    command to install Jest:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Jest作为唯一的依赖项，Jest是Facebook开发的JavaScript测试框架。Jest是测试的绝佳选择，因为它包含大多数您需要的功能，如覆盖率、断言和模拟等。在大多数情况下，您可以在零配置的情况下使用它，具体取决于您的应用程序的复杂性。如果您想了解更多，请访问Jest的网站[https://jestjs.io](https://jestjs.io)。在`/chapter-09-node/testing-example`文件夹中打开一个终端实例，并运行以下命令来安装Jest：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `package.json` file, there are three entries in the `scripts` section:
    `build`, `pretest`, and `test`. The `build` script executes the `emcc` command
    with the required flags to compile `/src/main.c` to `/src/main.wasm`. The `test` script
    executes the `jest` command with the `--verbose flag`, which provides additional
    details for each of the test suites. The `pretest` script simply runs the `build` script
    to ensure `/src/main.wasm` exists prior to running any tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，`scripts`部分有三个条目：`build`、`pretest`和`test`。`build`脚本使用所需的标志执行`emcc`命令，将`/src/main.c`编译为`/src/main.wasm`。`test`脚本使用`--verbose`标志执行`jest`命令，为每个测试套件提供额外的细节。`pretest`脚本只是运行`build`脚本，以确保在运行任何测试之前存在`/src/main.wasm`。
- en: Tests file review
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件审查
- en: 'Let''s walk through the test file, located at `/src/__tests__/main.test.js`,
    and review the purpose of each section of code. The first section of the test
    file instantiates the `main.wasm` file and assigns the result to the local `wasmInstance`
    variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下位于`/src/__tests__/main.test.js`的测试文件，并审查代码的每个部分的目的。测试文件的第一部分实例化`main.wasm`文件，并将结果分配给本地的`wasmInstance`变量：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Jest provides life-cycle methods to perform any setup or teardown actions prior
    to running tests. You can specify functions to run before or after all of the
    tests (`beforeAll()`/`afterAll()`), or before or after each test (`beforeEach()`/`afterEach()`).
    We need a compiled instance of the Wasm module from which we can call exported
    functions, so we put the instantiation code in the `beforeAll()` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了生命周期方法来执行任何设置或拆卸操作以便在运行测试之前进行。您可以指定在所有测试之前或之后运行的函数（`beforeAll()`/`afterAll()`），或者在每个测试之前或之后运行的函数（`beforeEach()`/`afterEach()`）。我们需要一个编译后的Wasm模块实例，从中我们可以调用导出的函数，因此我们将实例化代码放在`beforeAll()`函数中。
- en: 'We''re wrapping the entire test suite in a `describe()` block for the file.
    Jest uses a `describe()` function to encapsulate suites of related tests and `test()`
    or `it()` to represent a single test. Here''s a simple example of this concept:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个测试套件包装在文件的`describe()`块中。Jest使用`describe()`函数来封装相关测试套件，使用`test()`或`it()`来表示单个测试。以下是这个概念的一个简单示例：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next section of code contains all the test suites and tests for each exported
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节代码包含了所有的测试套件和每个导出函数的测试：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first `describe()` block, for the `_addTwoNumbers()` function, has two `test()`
    instances to ensure that the function returns the sum of the two numbers passed
    in as arguments. The next two `describe()` blocks, for the `_divideTwoNumbers()`
    and `_findFactorial()` functions, use Jest's `.each` feature, which allows you
    to run the same test with different data. The `expect()` function allows you to
    make assertions on the value passed in as an argument. The `.toBeCloseTo()` assertion
    in the last `_divideTwoNumbers()` test checks whether the result is within two
    decimal places of `3.77`. The rest use the `.toEqual()` assertion to check for
    equality.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`describe()`块，用于`_addTwoNumbers()`函数，有两个`test()`实例，以确保函数返回作为参数传入的两个数字的总和。接下来的两个`describe()`块，用于`_divideTwoNumbers()`和`_findFactorial()`函数，使用了Jest的`.each`功能，允许您使用不同的数据运行相同的测试。`expect()`函数允许您对作为参数传入的值进行断言。最后一个`_divideTwoNumbers()`测试中的`.toBeCloseTo()`断言检查结果是否在`3.77`的两个小数位内。其余使用`.toEqual()`断言来检查相等性。
- en: Writing tests with Jest is relatively simple, and running them is even easier!
    Let's try running our tests and reviewing some of the CLI flags that Jest provides.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest编写测试相对简单，运行测试甚至更容易！让我们尝试运行我们的测试，并查看Jest提供的一些CLI标志。
- en: Running the tests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'To run the tests, open a terminal instance in the `/chapter-09-node/testing-example`
    folder and run the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请在`/chapter-09-node/testing-example`文件夹中打开终端实例，并运行以下命令：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see the following output in your terminal:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到以下输出：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you have a large number of tests, you could remove the `--verbose` flag
    from the `test` script in `package.json` and only pass the flag to the `npm test`
    command if needed. There are several other CLI flags you can pass to the `jest`
    command. The following list contains some of the more commonly used flags:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大量的测试，可以从`package.json`中的`test`脚本中删除`--verbose`标志，并仅在需要时将标志传递给`npm test`命令。您可以将其他几个CLI标志传递给`jest`命令。以下列表包含一些常用的标志：
- en: '`--bail`: Exits the test suite immediately upon the first failing test suite'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--bail`: 在第一个失败的测试套件后立即退出测试套件'
- en: '`--coverage`: Collects test coverage and displays it in the terminal after
    the tests have run'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--coverage`: 收集测试覆盖率，并在测试运行后在终端中显示'
- en: '`--watch`: Watches files for changes and reruns tests related to changed files'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--watch`: 监视文件更改并重新运行与更改文件相关的测试'
- en: 'You can pass these flags to the `npm` test command by adding them after a `--`.
    For example, if you wanted to use the `--bail` flag, you''d run this command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在“--”之后添加这些标志来将这些标志传递给`npm`测试命令。例如，如果您想使用`--bail`标志，您可以运行以下命令：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can view the entire list of CLI options on the official site at [https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方网站上查看所有CLI选项的完整列表：[https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli)。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the advantages of integrating WebAssembly with
    Node.js and demonstrated how Node.js could be used on the server and client side.
    We evaluated an Express application that uses a Wasm module to perform calculations
    on accounting transactions. We then reviewed a browser-based application that
    utilizes Webpack to import and call functions from a C file without having to
    write any Wasm instantiation code. Finally, we saw how the Jest testing framework
    can be leveraged to test a compiled module and ensure it's functioning correctly.
    In [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*, we'll cover advanced tools and discuss the features that are
    on the horizon for WebAssembly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了将WebAssembly与Node.js集成的优势，并演示了Node.js如何在服务器端和客户端使用。我们评估了一个使用Wasm模块执行会计交易计算的Express应用程序。然后，我们审查了一个基于浏览器的应用程序，该应用程序利用Webpack从C文件中导入和调用函数，而无需编写任何Wasm实例化代码。最后，我们看到了如何利用Jest测试框架来测试编译模块并确保其正常运行。在[第10章](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml)中，*高级工具和即将推出的功能*，我们将介绍高级工具，并讨论WebAssembly即将推出的功能。
- en: Questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is one of the advantages of integrating WebAssembly with Node.js?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将WebAssembly与Node.js集成的优势之一是什么？
- en: What library does the Express application use to read and write data to a JSON
    file?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Express应用程序使用哪个库来读取和写入数据到JSON文件？
- en: What is the difference between loading a module in the browser and in Node.js?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器和Node.js中加载模块有什么区别？
- en: What technique can you use to run an `npm` script before or after an existing
    `npm` script?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用什么技术在现有的`npm`脚本之前或之后运行一个`npm`脚本？
- en: What is the name of the task Webpack performs to eliminate dead code?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack执行的任务名称是什么，以消除死代码？
- en: What is the purpose of a loader in Webpack?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack中加载程序的目的是什么？
- en: What is the difference between the `describe()` and `test()` functions in Jest?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest中`describe()`和`test()`函数之间的区别是什么？
- en: How do you pass additional CLI flags to the `npm test` command?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将额外的CLI标志传递给`npm test`命令？
- en: Further reading
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Express: [https://expressjs.com](https://expressjs.com)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express: [https://expressjs.com](https://expressjs.com)
- en: Webpack: [https://webpack.js.org](https://webpack.js.org)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack: [https://webpack.js.org](https://webpack.js.org)
- en: Jest API: [https://jestjs.io/docs/en/api](https://jestjs.io/docs/en/api)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest API: [https://jestjs.io/docs/en/api](https://jestjs.io/docs/en/api)
