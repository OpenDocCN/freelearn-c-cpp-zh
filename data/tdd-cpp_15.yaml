- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: How to Test With Multiple Threads
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用多个线程进行测试
- en: Multi-threading is one of the most difficult aspects of writing software. Something
    that’s often overlooked is how we can test multiple threads. And can we use TDD
    to help design software that uses multiple threads? Yes, TDD can help and you’ll
    find useful and practical guidance in this chapter that will show you how to use
    TDD with multiple threads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是编写软件中最困难的部分之一。常常被忽视的是我们如何测试多个线程。我们能否使用TDD来帮助设计使用多个线程的软件？是的，TDD可以帮助，你将在本章中找到有用的实用指导，它将向你展示如何使用TDD与多个线程一起工作。
- en: 'The main topics in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括以下几项：
- en: Using multiple threads in tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中使用多个线程
- en: Making the logging library thread-safe
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使日志库线程安全
- en: The need to justify multiple threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要证明多线程的必要性
- en: Changing the service return type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变服务的返回类型
- en: Making multiple service calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行多次服务调用
- en: How to test multiple threads without sleep
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不使用睡眠的情况下测试多个线程
- en: Fixing one last problem detected with logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复检测到的最后一个日志问题
- en: First, we’ll examine what problems you’ll find when using multiple threads in
    your tests. You’ll learn how to use a special helper class in the testing library
    to simplify the extra steps needed when testing with multiple threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查在使用测试中的多个线程时你会遇到什么问题。你将学习如何使用测试库中的一个特殊辅助类来简化测试多个线程时所需的额外步骤。
- en: 'Once we can use multiple threads inside of a test, we’ll use that ability to
    call into the logging library from multiple threads at the same time and see what
    happens. I’ll give you a hint: some changes will need to be made to the logging
    library to make the library behave well when called from multiple threads.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能在测试中使用多个线程，我们就会利用这个能力同时从多个线程调用日志库并观察会发生什么。我会给你一个提示：需要对日志库进行一些修改，以便在从多个线程调用时库能表现得更好。
- en: Then, we’ll go back to the simple service we developed in the previous chapter
    and you’ll learn how to use TDD to design a service that uses multiple threads
    in a way that can support reliable testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将回到上一章中开发的简单服务，你将学习如何使用TDD设计一个使用多个线程的服务，这样就可以支持可靠的测试。
- en: We’ll be working with each project in turn in this chapter. First, we will be
    using the testing library project. Then, we’ll switch over to the logging library
    project. Finally, we’ll use the simple service project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将依次处理每个项目。首先，我们将使用测试库项目。然后，我们将切换到日志库项目。最后，我们将使用简单服务项目。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code in this chapter uses standard C++, which builds on any modern
    C++ 20 or later compiler and standard library. The code in this chapter uses all
    three projects developed in this book: the testing library from *Part 1*, *Testing
    MVP*, the logging library from *Part 2*, *Logging Library*, and the simple service
    from the previous chapter.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都使用标准C++，它基于任何现代C++ 20或更高版本的编译器和标准库。本章中的代码使用了本书中开发的三个项目：来自*第一部分*的测试库*Testing
    MVP*，来自*第二部分*的日志库*Logging Library*，以及上一章中的简单服务。
- en: 'You can find all the code for this chapter in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的GitHub仓库中找到本章的所有代码：[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)。
- en: Using multiple threads in tests
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试中使用多个线程
- en: Adding multiple threads to your tests presents challenges that you need to be
    aware of. I’m not talking about running the tests themselves in multiple threads.
    The testing library registers and runs the tests and it will remain single-threaded.
    What you need to understand are the problems that can arise when multiple threads
    are created inside of a test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中添加多个线程带来的挑战，你需要意识到。我说的不是在多个线程中运行测试本身。测试库注册并运行测试，它将保持单线程。你需要理解的是在测试内部创建多个线程时可能出现的各种问题。
- en: 'To understand these problems, let’s create a test that uses multiple threads
    so that you can see exactly what happens. We’ll be working with the unit test
    library project in this section so, first, add a new test file called `Thread.cpp`.
    The project structure should look like this after you’ve added the new file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些问题，让我们创建一个使用多个线程的测试，这样你就可以确切地看到会发生什么。在本节中，我们将与单元测试库项目一起工作，因此，首先添加一个名为`Thread.cpp`的新测试文件。在你添加了新文件后，项目结构应该看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `Thread.cpp` file, add the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Thread.cpp`文件中，添加以下代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code includes `atomic` so that we can safely modify a `count`
    variable from multiple threads. We need to include `thread` to bring in the definition
    of the thread class. The test creates two threads. The first thread increments
    `count`, while the second thread decrements the same `count`. The final result
    should return `count` to zero because we increment and decrement the same number
    of times.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包括`atomic`，这样我们就可以安全地从多个线程修改`count`变量。我们需要包含`thread`来引入线程类的定义。测试创建了两个线程。第一个线程增加`count`，而第二个线程减少相同的`count`。最终结果应该将`count`返回到零，因为我们增加和减少的次数相同。
- en: 'If you build and run the test application, everything will pass. The new test
    causes no problem at all. Let’s change the third `CONFIRM_THAT` macro so that
    we can try to confirm that `count` is not equal to `0` at the end of the test,
    like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行测试应用程序，一切都会通过。新的测试根本不会造成任何问题。让我们更改第三个`CONFIRM_THAT`宏，以便我们可以尝试在测试结束时确认`count`不等于`0`，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this change, the test fails with this result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改导致测试失败，结果如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, we have a test that uses multiple threads and it works as expected.
    We added some confirmations that can detect and report when a value does not match
    the expected value. You might be wondering what problems multiple threads can
    cause when the threads seem to be working okay so far.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个使用多个线程的测试，它按预期工作。我们添加了一些确认，可以检测并报告当值不匹配预期值时的情况。你可能会想知道当线程似乎到目前为止都在正常工作时，多线程可能会引起什么问题。
- en: 'Here’s the quick answer: creating one or more threads inside of a test causes
    no problem at all – that is, assuming that the threads are managed correctly such
    as making sure they are joined before the test ends. Confirmations work as expected
    from the main test thread itself. You can even have confirmations inside the additional
    threads. One type of problem comes when a confirmation inside one of the additional
    threads fails. To see this, let’s put the final confirmation back to `Equals`
    and change the first confirmation to `Equals` too, like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个快速回答：在测试中创建一个或多个线程根本不会造成任何问题——也就是说，假设线程被正确管理，例如确保在测试结束时它们被连接。确认从主测试线程本身按预期工作。你甚至可以在附加线程中进行确认。当附加线程中的一个确认失败时，会出现一种问题。为了看到这一点，让我们将最终的确认放回`Equals`，并将第一个确认也改为`Equals`，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`count` should never reach `100''001` because we only increment `100''000`
    times. The confirmation always passed before this change, which is why it did
    not cause a problem. But with this change, the confirmation will fail right away.
    If this was a confirmation in the main test thread, then the failure would cause
    the test to fail with a summary message that describes the problem. But we’re
    not in the main test thread now.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`永远不会达到`100''001`，因为我们只增加`100''000`次。在这次更改之前，确认总是通过，这就是为什么它没有引起问题的原因。但是，这次更改后，确认会立即失败。如果这是一个主测试线程中的确认，那么失败会导致测试失败，并带有描述问题的总结消息。但现在我们不在主测试线程中。'
- en: 'Remember that failed confirmations throw exceptions and that an unhandled exception
    inside of a thread will terminate an application. When we confirm that the count
    equals `100''001`, we cause an exception to be thrown. The main test thread is
    managed by the testing library and the main thread is ready to catch any confirmation
    exceptions so that they can be reported. However, our additional thread inside
    the test lambda has no protection against thrown exceptions. So, when we build
    and run the test application, it terminates like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，失败的确认会抛出异常，并且线程内部未处理的异常会导致应用程序终止。当我们确认计数等于`100'001`时，我们导致抛出异常。主要的测试线程由测试库管理，主线程准备好捕获任何确认异常以便报告。然而，测试lambda内部的附加线程没有针对抛出异常的保护。因此，当我们构建和运行测试应用程序时，它会像这样终止：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You might get a slightly different message, depending on what computer you’re
    using. What you won’t get is a test application that runs and reports the results
    of all the tests. The application terminates soon after the confirmation inside
    the additional thread fails and throws an exception.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的计算机不同，你可能会得到一条稍微不同的消息。你不会得到的是运行并报告所有测试结果的应用程序。当附加线程中的确认失败并抛出异常时，应用程序很快就会终止。
- en: Other than confirmations inside a thread failing and throwing exceptions, are
    there any other problems with using multiple threads inside of a test? Yes. Threads
    need to be managed properly – that is, we need to make sure they are either joined
    or detached before going out of scope. You’re unlikely to need to detach a thread
    that was created in a test, so you’re left with making sure that all the threads
    created inside of a test are joined before the test ends. Notice that the test
    we’re using manually joins both threads.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线程内部确认失败并抛出异常之外，在测试中使用多个线程还有其他问题吗？是的。线程需要被正确管理——也就是说，我们需要确保它们在超出作用域之前要么被连接，要么被分离。你不太可能需要在测试中创建的线程上进行分离，所以你只剩下确保在测试结束时所有在测试中创建的线程都被连接。请注意，我们正在使用的测试手动连接了两个线程。
- en: 'If the test has other confirmations, then you need to be sure that a failed
    confirmation doesn’t cause the test to skip the thread joins. This is because
    leaving a test without joining will also cause the application to terminate. Let’s
    see this by putting the first confirmation back to using `NotEquals` so that it
    will not cause any problems. Then, we will add a new confirmation that will fail
    before the joins:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试有其他确认，那么你需要确保失败的确认不会导致测试跳过线程连接。这是因为留下未连接的测试也会导致应用程序终止。让我们通过将第一个确认放回使用`NotEquals`来避免任何问题，这样它就不会引起任何问题。然后，我们将添加一个新的确认，它将在连接之前失败：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The confirmations inside the additional threads no longer cause any problems.
    However, the new `CONFIRM_TRUE` confirmation will cause the joins to be skipped.
    The result is another termination:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 额外线程内的确认不再引起任何问题。然而，新的`CONFIRM_TRUE`确认将导致跳过连接。结果是另一种终止：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’re not going to do anything to help solve this second type of termination.
    You’ll need to make sure that any threads that are created are joined properly.
    You might want to use the new *jthread* in C++20, which will make sure that the
    threads are joined. Alternatively, you might just need to be careful about where
    you put confirmations in the main test thread to make sure that all the joins
    happen first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会做任何事情来帮助解决这种第二种类型的终止问题。你需要确保所有创建的线程都被正确连接。你可能想使用C++20中的新功能*jthread*，这将确保线程被连接。或者，你可能只需要小心地将确认放在主测试线程中的位置，以确保所有连接都首先发生。
- en: We can remove the `CONFIRM_TRUE` confirmation now so that we can focus on fixing
    the first problem of confirmations failing inside the threads.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以移除`CONFIRM_TRUE`确认，这样我们就可以专注于修复线程内部确认失败的第一个问题。
- en: 'What can we do to fix this problem? We could put a try/catch block in the thread,
    which would at least stop the termination:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做些什么来解决这个问题？我们可以在线程中放置一个try/catch块，这至少可以停止终止：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To simplify the code, I removed the second thread. The test now uses a single
    additional thread to increment the count. The result after the thread finishes
    is that `count` should be equal to `100''000`. At no point should `count` reach
    `100''001`, which is confirmed inside the thread. Let’s say we change the confirmation
    inside the thread so that it will fail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码，我移除了第二个线程。现在测试使用一个额外的线程来增加计数。线程完成后，`count`应该等于`100'000`。在任何时候，`count`都不应该达到`100'001`，这在线程内部得到了确认。假设我们改变线程内的确认，使其失败：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the exception is caught and the test fails normally and reports the result.
    Or does it? Building and running this code shows that all the tests pass. The
    confirmation inside the thread is detecting the mismatched values but the exception
    has no way to be reported back to the main test thread. We can’t throw anything
    inside the catch block because that will just terminate the application again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，异常被捕获，测试正常失败并报告结果。或者不是吗？构建和运行此代码显示所有测试都通过了。线程内的确认检测到不匹配的值，但异常没有方法报告回主测试线程。我们无法在catch块中抛出任何内容，因为这只会再次终止应用程序。
- en: We know that we can avoid the test application terminating by catching the confirmation
    exception. And we also know from the first threading test that a confirmation
    that doesn’t throw is also okay. The bigger problem we need to solve is how to
    let the main test thread know about any confirmation failures in the additional
    threads that have been created. Maybe we can inform the main thread in the catch
    block by using a variable passed to the thread.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，通过捕获确认异常，我们可以避免测试应用程序终止。而且，我们从第一次线程测试中得知，没有抛出异常的确认也是可以的。我们需要解决的大问题是，如何让主测试线程知道任何已创建的附加线程中的确认失败情况。也许我们可以通过传递给线程的变量在捕获块中通知主线程。
- en: I want to emphasize this point. If you’re creating threads inside of a test
    simply to divide the work and speed up a test and don’t need to confirm anything
    inside the threads, then you don’t need to do anything special. All you need to
    manage is the normal thread concerns, such as making sure you join all threads
    before the test ends and that none of the threads have unhandled exceptions. The
    only reason to use the following guidance is when you want to put confirmations
    inside of the additional threads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调这一点。如果你在测试中创建线程只是为了分割工作并加快测试速度，而且不需要在线程内进行确认，那么你不需要做任何特殊的事情。你所需要管理的只是正常的线程问题，例如确保在测试结束时连接所有线程，并且没有线程有未处理的异常。唯一需要使用以下指导的原因是当你想在附加线程中放置确认时。
- en: 'After trying out a few alternatives, here is what I came up with:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了几个替代方案后，我提出了以下方案：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the TDD style. Modify the test until you’re happy with the code and
    then get it working. The test assumes a new exception type called `ThreadConfirmException`
    and it creates a local instance called `threadEx`. The `threadEx` variable is
    captured by reference in the thread lambda so that the thread can access `threadEx`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TDD风格。修改测试，直到你对代码满意，然后让它工作。测试假设有一个新的异常类型叫做`ThreadConfirmException`，并创建了一个名为`threadEx`的本地实例。`threadEx`变量通过引用在线程lambda中被捕获，以便线程可以访问`threadEx`。
- en: The thread can use all the normal confirmations it wants, so long as everything
    is inside a try block with a catch block that is looking for the `ConfirmException`
    type. If a confirmation fails, then it will throw an exception that will be caught.
    We can use the line number and reason to set a failure mode in the `threadEx`
    variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以使用它想要的任何正常确认，只要一切都在一个带有捕获异常`ConfirmException`类型的try块中。如果确认失败，它将抛出一个异常，该异常将被捕获。我们可以使用行号和原因在`threadEx`变量中设置一个失败模式。
- en: Once the thread has finished and we’re back in the main thread, we can call
    another method to check for a failure in the `threadEx` variable. If a failure
    was set, then the `checkFailure` method should throw an exception, just like how
    a regular confirmation throws an exception. Because we’re back in the main test
    thread, any confirmation exception that gets thrown will be detected and reported
    in the test summary report.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程完成并且我们回到了主线程，我们可以调用另一个方法来检查`threadEx`变量中的失败情况。如果设置了失败，那么`checkFailure`方法应该抛出异常，就像常规确认抛出异常一样。因为我们回到了主测试线程，所以任何抛出的确认异常都将被检测并在测试总结报告中报告。
- en: 'Now, we need to implement the `ThreadConfirmException` class in `Test.h`, which
    can go right after the `ConfirmException` base class, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Test.h`中实现`ThreadConfirmException`类，它可以直接放在`ConfirmException`基类之后，如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we build and run now, then the confirmation inside the thread will detect
    that `count` does not equal `100''001` and the failure will be reported in the
    summary results, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在构建并运行，那么线程内的确认将检测到`count`不等于`100'001`，失败将在总结结果中报告，如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The question now is, is there any way to simplify the test? The current test
    looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，是否有任何方法可以简化测试？当前的测试看起来是这样的：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have a new `ThreadConfirmException` type, which is good. However, the
    test author still needs to pass an instance of this type to the thread function,
    similar to how `threadEx` is captured by the lambda. The thread function still
    needs a try/catch block and needs to call `setFailure` if an exception is caught.
    Finally, the test needs to check for a failure once it’s back in the main test
    thread. All of these steps are shown in the test.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个新的`ThreadConfirmException`类型，这是好的。然而，测试作者仍然需要将此类型的实例传递给线程函数，类似于`threadEx`被lambda捕获的方式。线程函数仍然需要一个try/catch块，并在捕获到异常时调用`setFailure`。最后，测试需要在回到主测试线程后检查失败。所有这些步骤都在测试中展示。
- en: 'We might be able to use a few macros to hide the try/catch block, but this
    seems fragile. The test author will likely have slightly different needs. For
    example, let’s go back to two threads and see what the test will look like with
    multiple threads. Change the test so that it looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以使用一些宏来隐藏 try/catch 块，但这看起来很脆弱。测试作者可能会有一些不同的需求。例如，让我们回到两个线程，看看多线程的测试会是什么样子。改变测试，使其看起来像这样：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This test is different than the original two-thread test at the beginning of
    this section. I wrote the test differently to show that there are lots of ways
    to write a multi-threaded test. Because we have more code inside the thread to
    handle the confirmation exceptions, I made each thread similar. Instead of one
    thread incrementing the count while another thread decrements, both threads now
    increment. Also, instead of naming each thread `t1` and `t2`, the new test puts
    the threads in a vector. We also have a vector of `ThreadConfirmException` with
    each thread getting a reference to its own `ThreadConfirmException`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与该节开头原始的两个线程测试不同。我以不同的方式编写了这个测试，以展示编写多线程测试有很多种方法。因为我们线程内部有更多的代码来处理确认异常，所以我让每个线程都相似。不再是其中一个线程增加计数，而另一个线程减少，现在两个线程都增加。此外，不再为每个线程命名
    `t1` 和 `t2`，新的测试将线程放入一个向量中。我们还有一个 `ThreadConfirmException` 向量，每个线程都获得对其自己的 `ThreadConfirmException`
    的引用。
- en: One thing to notice about this solution is that while each thread will fail
    its confirmation and both `ThreadConfirmationException` instances will have a
    failure set, only one failure will be reported. In the loop at the end of the
    test that goes through the `threadExs` collection, the moment one `ThreadConfirmationException`
    fails the check, an exception will be thrown. I thought about extending the testing
    library to support multiple failures but decided against the added complexity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个解决方案需要注意的一点是，虽然每个线程都会失败其确认，并且两个 `ThreadConfirmationException` 实例都将有一个失败集，但只会报告一个失败。在测试末尾的循环中，通过
    `threadExs` 集合，一旦一个 `ThreadConfirmationException` 失败检查，就会抛出异常。我曾考虑扩展测试库以支持多个失败，但最终决定不增加复杂性。
- en: If you have a test with multiple threads, then they will likely be working with
    different sets of data. If there happens to be an error that causes multiple threads
    to fail in the same test run, then only one failure will be reported in the test
    application. Fixing that failure and running again may then report the next failure.
    It’s a little tedious to fix problems one after another but not a likely scenario
    that justifies the added complexity to the testing library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个多线程的测试，那么它们可能会使用不同的数据集。如果恰好发生错误导致多个线程在同一测试运行中失败，那么测试应用程序中只会报告一个失败。修复该失败并再次运行可能会报告下一个失败。逐个修复问题虽然有些繁琐，但不太可能需要增加测试库的复杂性。
- en: 'The new test structure with two threads highlights the difficulty of creating
    reasonable macros that can hide all the thread confirmation handling. So far,
    all three versions of the test have been different. There doesn’t seem to be a
    common way to write multi-threaded tests that we would be able to wrap up in some
    macros. I think we’ll stick with what we have now – a `ThreadConfirmException`
    type that can be passed to a thread. The thread will need to catch the `ConfirmException`
    type and call `setFailure`. The main test thread can then check each `ThreadConfirmException`,
    which will throw if the failure was set. Before we move on, let’s change the confirmation
    inside the thread lambda so that it tests for a count not equal to `200''001`,
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新的具有两个线程的测试结构突出了创建可以隐藏所有线程确认处理的合理宏的难度。到目前为止，测试的三个版本都不同。似乎没有一种编写多线程测试的通用方法，我们可以将其封装在某个宏中。我认为我们将坚持我们现在所拥有的——一个可以传递给线程的
    `ThreadConfirmException` 类型。线程需要捕获 `ConfirmException` 类型并调用 `setFailure`。主测试线程然后可以检查每个
    `ThreadConfirmException`，如果设置了失败，它将抛出异常。在我们继续之前，让我们改变线程 lambda 中的确认，使其测试计数不等于
    `200'001`，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `NotEquals` confirmation will let the test pass again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotEquals` 确认将允许测试再次通过。'
- en: With the understanding you’ve gained from this section, you’ll be able to write
    tests that use multiple threads inside the test. You can continue to use the same
    `CONFIRM` and `CONFIRM_THAT` macros to verify the results. The next section will
    use multiple threads to log messages so that we can make sure that the logging
    library is thread-safe. You’ll also learn what it means for code to be thread-safe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节获得的理解，您将能够编写在测试中使用多个线程的测试。您可以继续使用相同的`CONFIRM`和`CONFIRM_THAT`宏来验证结果。下一节将使用多个线程来记录消息，以确保日志库是线程安全的。您还将了解代码线程安全意味着什么。
- en: Making the logging library thread-safe
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使日志库线程安全
- en: We don’t know if a project that uses the logging library will be trying to log
    from multiple threads or a single thread. With an application, we’re in full control
    and can choose to use multiple threads or not. But a library, especially a logging
    library, often needs to be *thread-safe*. This means that the logging library
    needs to behave well when an application uses the library from multiple threads.
    Making code thread-safe adds some extra overhead to the code and is not needed
    if the library will only be used from a single thread.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道使用日志库的项目是会尝试从多个线程或单个线程进行日志记录。在使用应用程序时，我们完全控制，可以选择使用多个线程或不使用。但是，库，尤其是日志库，通常需要是**线程安全的**。这意味着当应用程序从多个线程使用库时，日志库需要表现良好。使代码线程安全会给代码增加一些额外的开销，如果库只会在单个线程中使用，则不需要这样做。
- en: 'What we need is a test that calls `log` from multiple threads that are all
    running at the same time. Let’s write a test with the code we have now and see
    what happens. We’re going to be using the logging project in this section and
    adding a new file to the `tests` folder called `Thread.cpp`. The project structure
    will look like this with the new file added:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个同时从多个线程调用`log`的测试。让我们使用我们现在的代码编写一个测试，看看会发生什么。在本节中，我们将使用日志项目，并在`tests`文件夹中添加一个名为`Thread.cpp`的新文件。添加新文件后的项目结构将如下所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the `Thread.cpp` file, let’s add a test that calls `log` from several
    threads, like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Thread.cpp`文件内部，让我们添加一个测试，从多个线程调用`log`函数，如下所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test does three things. First, it creates `150` messages. We’ll get the
    messages ready before we start the threads so that the threads will be able to
    call `log` as quickly as possible many times in a loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试执行三项操作。首先，它创建`150`条消息。我们将在启动线程之前准备好消息，这样线程就可以尽可能快地多次在循环中调用`log`。
- en: Once the messages are ready, the test starts `3` threads, and each thread will
    log part of the messages that have already been formatted. The first thread will
    log messages `0` to `49`. The second thread will log messages `50` to `99`. Finally,
    the third thread will log messages `100` to `149`. We don’t do any confirmations
    in the threads.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息准备好，测试将启动`3`个线程，每个线程将记录已经格式化的部分消息。第一个线程将记录消息`0`到`49`。第二个线程将记录消息`50`到`99`。最后，第三个线程将记录消息`100`到`149`。我们在线程中不做任何确认。
- en: Once everything has been logged and the threads have been joined, then the test
    confirms that all `150` messages appear in the log file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有消息都已记录，并且线程已合并，测试将确认所有`150`条消息都出现在日志文件中。
- en: Building and running this will almost certainly fail. This type of test goes
    against one of the points that makes a good test, as explained in [*Chapter 8*](B18567_08.xhtml#_idTextAnchor074),
    *What Makes A Good Test?* The reason this is not the best type of test is that
    the test is not completely reproducible. Each time the test application is run,
    you’ll get a slightly different result. You might even find that this test causes
    other tests to fail!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行此测试几乎肯定会失败。这种类型的测试违反了[第8章](B18567_08.xhtml#_idTextAnchor074)中解释的良好的测试的一个要点，即*什么是好的测试？*。这种测试不是最好的类型，因为测试不是完全可重复的。每次运行测试应用程序时，您都会得到一个略有不同的结果。您甚至可能会发现这个测试会导致其他测试失败！
- en: Even though we’re not basing the behavior of the test on random numbers, we’re
    using threads. And thread scheduling is unpredictable. The only way to make this
    test mostly reliable is to log many messages like we’re doing already. The test
    does everything it can to set the threads up for conflicts. This is why the messages
    are preformatted. I wanted the threads to immediately go into a loop of logging
    messages and not spend any extra time formatting messages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不是基于随机数来构建测试的行为，但我们使用了线程。线程调度是不可预测的。使这个测试大部分可靠的方法是记录许多消息，就像我们已经在做的那样。测试会尽其所能设置线程以产生冲突。这就是为什么消息是预格式化的。我希望线程立即进入记录消息的循环，而不是花费额外的时间来格式化消息。
- en: 'When the test fails, it’s because the log file is jumbled. One portion of the
    log file looks like this for one of my test runs:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，是因为日志文件混乱。我的一个测试运行中日志文件的一部分看起来像这样：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I removed the `color` and `log_level` tags so that you can see the messages
    better. The first thing you’ll notice is that some messages are repeated. Number
    `100` appears twice, and number `50` seems to be missing completely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了`color`和`log_level`标签，以便你能更好地看到消息。你首先会注意到一些消息是重复的。编号`100`出现了两次，而编号`50`似乎完全缺失。
- en: To be honest, I expected the log file to be even more jumbled than it is. The
    interleaving between message groups `0-49` and `50-99` and `100-149` is to be
    expected. We do have three threads running at the same time. For example, once
    message number `51` is logged, we should expect to have already seen number `50`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我本以为日志文件会比现在更混乱。消息组`0-49`和`50-99`以及`100-149`之间的交错是预期的。我们确实有三个线程同时运行。例如，一旦消息编号`51`被记录，我们应该已经看到了编号`50`。
- en: Let’s fix the logging code to get the test to pass. It still won’t be the best
    test but it will have a good chance of finding a bug if the logging library is
    not thread-safe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复日志代码，以便测试通过。这仍然不会是最好的测试，但如果日志库不是线程安全的，它将有很大的机会找到错误。
- en: 'The fix is simple: we need a mutex and then we need to lock the mutex. First,
    let’s include the `mutex` standard header at the top of `Log.h`, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很简单：我们需要一个互斥锁，然后我们需要锁定互斥锁。首先，让我们在`Log.h`的顶部包含`mutex`标准头文件，如下所示：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need a place to place a global mutex. Since the logging library is
    a single header file, we can’t declare a global variable without getting a linker
    error. We might be able to declare a global mutex as inline. This is a new feature
    in C++ that I haven’t used that lets you declare inline variables, just like how
    we can declare inline functions. I’m more comfortable with a function that uses
    a static variable. Add the following function to the top of `Log.h`, right after
    the opening namespace of `MereMemo`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个地方放置全局互斥锁。由于日志库是一个单头文件，我们无法声明全局变量而不产生链接错误。我们可能能够将全局互斥锁声明为内联。这是C++中的一个新特性，它允许你声明内联变量，就像我们可以声明内联函数一样。我更习惯于使用静态变量的函数。将以下函数添加到`Log.h`的顶部，紧接在`MereMemo`命名空间的开头之后：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to lock the mutex at the proper spot. At first, I added a lock
    to the `log` function, but that had no effect. This is because the `log` function
    returns a `LogStream` without actually doing any logging. So, the `log` function
    obtained the lock and then released the lock before any logging happened. The
    logging is done in the `LogStream` destructor, so that’s where we need to put
    the lock:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在适当的位置锁定互斥锁。起初，我在`log`函数中添加了锁定，但没有任何效果。这是因为`log`函数在没有实际记录的情况下返回一个`LogStream`。所以，`log`函数在记录发生之前获得了锁并释放了锁。记录是在`LogStream`析构函数中完成的，所以我们需要在那里放置锁：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The lock tries to obtain the mutex and will block if another thread already
    owns the mutex. Only one thread at a time can proceed after the lock and the lock
    is released after the text is sent to all the outputs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 锁尝试获取互斥锁，如果另一个线程已经拥有互斥锁，则会阻塞。一次只有一个线程可以在锁定之后进行，并且在将文本发送到所有输出之后释放锁。
- en: 'If we build and run, the threading problem will be fixed. However, when I ran
    the test application, one of the tests failed. At first, I thought there was still
    a problem with the threads, but the failure was in another test. This is the test
    that failed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建并运行，线程问题将会得到解决。然而，当我运行测试应用程序时，有一个测试失败了。起初，我以为线程仍然存在问题，但失败发生在另一个测试上。这是失败的测试：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test has nothing to do with the multiple thread test. So, why did it fail?
    Well, the problem is that this test is confirming that a particular message does
    not appear in the log file. But the message is just the word `"message "`, followed
    by a random number string. We just added an extra 150 logged messages, which all
    have the same text followed by a random number string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与多线程测试无关。那么，为什么它失败了？嗯，问题在于这个测试正在确认一个特定的消息不会出现在日志文件中。但是这个消息只是单词 `"message"`，后面跟着一个随机数字字符串。我们刚刚添加了额外的150条日志消息，这些消息都有相同的文本，后面跟着一个随机数字字符串。
- en: We have a problem with the tests themselves. The tests can sometimes fail due
    to random numbers. The problem wasn’t noticed when we had a few log messages but
    it’s more noticeable now that we have many more chances for duplicate random numbers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自身在测试上遇到了问题。测试有时会因为随机数而失败。在我们只有少量日志消息时，这个问题并没有被发现，但现在我们有更多机会出现重复的随机数，这个问题就更加明显了。
- en: We could either increase the size of the random number strings added to each
    log message or make the tests more specific so that they all use a different base
    message string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增加添加到每个日志消息中的随机数字字符串的大小，或者使测试更加具体，以便它们都使用不同的基消息字符串。
- en: At this point, you might be wondering why my test has a simple base message
    when we’ve been using unique messages in each test ever since the logging library
    was first created in [*Chapter 9*](B18567_09.xhtml#_idTextAnchor085), *Using Tests*.
    That’s because the code starting in [*Chapter 9*](B18567_09.xhtml#_idTextAnchor085),
    *Using Tests*, originally did have simple, common log messages. I could have left
    those common messages as-is and waited until now to have you go back and change
    all of them. However, I edited the chapters to fix the problem from the beginning.
    It seems like a waste to go through all the tests now just to change a string.
    Therefore, I added an explanation to [*Chapter 9*](B18567_09.xhtml#_idTextAnchor085),
    *Using Tests*. We don’t need to change any of the test messages now because they’ve
    already been fixed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么我的测试有一个简单的基消息，而自从日志库首次创建以来，我们一直在每个测试中使用独特的消息[*第9章*](B18567_09.xhtml#_idTextAnchor085)，*使用测试*。那是因为从[*第9章*](B18567_09.xhtml#_idTextAnchor085)，*使用测试*开始的代码原本就有简单、通用的日志消息。我本可以将这些通用消息保持原样，并等到现在让你回过头来更改它们。然而，我编辑了这些章节，从开始就解决了问题。现在只是为了更改一个字符串而通过所有测试似乎是一种浪费。因此，我在[*第9章*](B18567_09.xhtml#_idTextAnchor085)，*使用测试*中添加了说明。现在我们不需要更改任何测试消息，因为它们已经被修复了。
- en: 'Okay, back to the threading – the new test passes now and the sample from the
    log file looks much better:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，回到多线程的话题——新的测试现在通过了，日志文件中的样本看起来好多了：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, this sample has been modified to remove the `color` and `log_level` tags.
    This change makes each line shorter so that you can see the messages better. The
    messages within each thread are ordered, even though the messages are mixed between
    threads – that is, message number `0` is followed at some point by message number
    `1` and then by number `2`; message number `50` is followed later by number `51`,
    and message number `100` is followed by number `101`. Each following numbered
    message might not immediately follow the previous message. This sample looks better
    because there are no duplicates and no missing messages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个样本已经被修改，以删除`color`和`log_level`标签。这个更改使得每一行都更短，这样你可以更好地看到消息。每个线程中的消息是有序的，即使消息在线程之间混合——也就是说，消息编号`0`在某个时候会被消息编号`1`跟随，然后是编号`2`；消息编号`50`稍后被编号`51`跟随，消息编号`100`被编号`101`跟随。每个后续编号的消息可能不会立即跟随前一个消息。这个样本看起来更好，因为没有重复的消息，也没有缺失的消息。
- en: One final thought is about the thread-safety of the logging library. We tested
    that multiple threads can all safely call `log` without worrying about problems.
    But we didn’t test if multiple threads can manage default tags or filtering, or
    add new outputs. The logging library will likely need more work to be fully thread-safe.
    It will work for our purposes for now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个想法是关于日志库的线程安全性。我们测试了多个线程可以安全地调用`log`而不必担心问题。但我们没有测试多个线程是否可以管理默认标签或过滤，或者添加新的输出。日志库可能需要更多的工作才能完全线程安全。现在它对我们的目的来说已经足够了。
- en: Now that the logging library is mostly thread-safe, the next section will go
    back to the `SimpleService` project and begin exploring how to test code that
    uses multiple threads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志库基本上是线程安全的，下一节将回到`SimpleService`项目，开始探索如何测试使用多线程的代码。
- en: The need to justify multiple threads
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要证明多线程的必要性
- en: So far in this chapter, you’ve learned how to write tests that use multiple
    threads and how to use these extra threads to test the logging library. The logging
    library doesn’t use multiple threads itself, but we needed to make sure that the
    logging library is safe to use with multiple threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学习了如何编写使用多线程的测试，以及如何使用这些额外的线程来测试日志库。日志库本身并不使用多线程，但我们需要确保日志库在使用多线程时是安全的。
- en: The remainder of this chapter will provide some guidance on how to test code
    that does use multiple threads. To test multi-threaded code, we need some code
    that uses multiple threads. For this, we’ll use the `SimpleService` project from
    the previous chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将提供一些关于如何测试使用多线程的代码的指导。为了测试多线程代码，我们需要一些使用多线程的代码。为此，我们将使用上一章的`SimpleService`项目。
- en: We need to modify the simple service so that it uses multiple threads. Right
    now, the simple service is an example of a greeting service that responds to a
    greeting request with a reply based on the user making the request being identified.
    There’s not much of a need for multiple threads in a greeting service. We’re going
    to need something different.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改简单的服务，使其使用多个线程。目前，简单服务是一个问候服务的例子，它根据请求问候的用户进行回复。在问候服务中并不需要太多多线程。我们需要一些不同的东西。
- en: 'This brings us to the first guidance: we need to make sure there is a valid
    need for multiple threads before we try to add multiple threads. Writing multi-threaded
    code is hard and should be avoided if only a single thread is needed. If you only
    need a single thread, then make sure that you follow the advice from the previous
    section and make your code thread-safe if it will be used by multiple threads.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了第一条指导原则：在我们尝试添加多个线程之前，我们需要确保存在一个有效的多线程需求。编写多线程代码很困难，如果只需要一个线程，则应避免使用多线程。如果你只需要一个线程，那么确保遵循上一节的建议，并在代码将被多个线程使用时使其线程安全。
- en: What you want to do is write as much of your code as possible so that it’s single-threaded.
    If you can identify a particular way to calculate a result that only needs some
    input data to arrive at an output, then make that a single-threaded calculation
    if possible. If the amount of input data is large and can be divided and calculated
    separately, then break up the input and pass smaller pieces to your calculation.
    Keep the calculation single-threaded and focused on working with the input provided.
    Then, you can create multiple threads where each thread is given a portion of
    the input data to calculate. This will separate your multi-threaded code from
    your calculations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是尽可能多地编写单线程的代码。如果你能找到一个特定的计算结果的方法，它只需要一些输入数据来得到输出，那么尽可能将其作为单线程计算。如果输入数据量很大，并且可以分割成单独计算的部分，那么将输入分割并传递更小的数据块给计算。保持计算单线程，并专注于处理提供的输入。然后，你可以创建多个线程，每个线程被分配一部分输入数据来计算。这将使你的多线程代码与计算分离。
- en: Isolating your single-threaded code will let you design and test the code without
    you having to worry about thread management. Sure, you might need to make sure
    the code is thread-safe, but that’s easier when thread-safety is all you need
    to worry about.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的单线程代码隔离出来，将允许你在无需担心线程管理的情况下设计和测试代码。当然，你可能需要确保代码是线程安全的，但当你只需要担心线程安全时，这会更容易。
- en: Testing multiple threads is harder because of the randomness of the thread scheduling.
    If possible, try to avoid clunky methods such as *sleeping* to coordinate tests.
    You want to avoid putting actual code threads to sleep to coordinate the order
    between threads. When a thread goes to sleep, it stops running for a while, depending
    on how long of a delay is specified in the sleep call. Other threads that are
    not sleeping can then be scheduled to run.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于线程调度的随机性，测试多线程更困难。如果可能，尽量避免使用诸如*睡眠*之类的笨拙方法来协调测试。你想要避免将实际的代码线程置于睡眠状态以协调线程之间的顺序。当一个线程进入睡眠状态时，它会停止运行一段时间，具体取决于在睡眠调用中指定的延迟时间。其他未睡眠的线程可以被调度运行。
- en: 'We’ll design the code in this chapter to let the test control the thread’s
    synchronization so that we can remove the randomness and make the tests predictable.
    Instead of starting this section with a test, let’s look at a modified service
    that has a reason to use multiple threads. The modified `handleRequest` method
    looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章设计的代码将允许测试控制线程的同步，这样我们就可以去除随机性并使测试可预测。我们不妨从修改后的服务开始，这个服务有使用多个线程的理由。修改后的`handleRequest`方法如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When following TDD, you’ll normally want to start with tests first. So, why
    am I showing you a modified service first? Because our goal is to test multi-threaded
    code. In your projects, you should avoid the desire to use some technology without
    having a good reason. Our reason is that we need an example to learn from. So,
    we’re starting with a backward need to use multi-threading.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循TDD（测试驱动开发）时，你通常会先从测试开始。那么，为什么我先向你展示一个修改后的服务呢？因为我们的目标是测试多线程代码。在你的项目中，你应该避免在没有充分理由的情况下使用某些技术。我们的理由是需要一个可以学习的例子。因此，我们是从反向需求开始使用多线程的。
- en: I tried to think of a good reason for a greeting service to use multiple threads
    and nothing came to mind. So, we’re going to change the service to something a
    little more complicated; I want to explain this new idea before we begin writing
    tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图想出一个问候服务使用多个线程的好理由，但想不出来。所以，我们将服务改为稍微复杂一些的东西；在我们开始编写测试之前，我想解释这个新想法。
- en: The new service is still as simple as I can make it. We’ll continue ignoring
    all the networking and message routing. We’ll need to change the request and response
    types to structs and we’ll continue to ignore serializing the data structs for
    transmission to and from the service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务仍然尽可能简单。我们将继续忽略所有网络和消息路由。我们需要将请求和响应类型更改为结构体，并且我们还将继续忽略将数据结构序列化以传输到和从服务中。
- en: The new service will simulate the calculation of a difficult problem. One valid
    reason to create a new thread is to let the new thread perform some work while
    the original thread continues what it was doing. The idea of the new service is
    that a `Calculate` request can take a long time to complete and we don’t want
    the caller to time out while waiting for the result. So, the service will create
    a new thread to perform the calculation and immediately return a token to the
    caller. The caller can use this token to call back into the service with a different
    `Status` request, which will check on the progress of the calculation that was
    just begun. If the calculation is not done yet, then the response to the `Status`
    request will let the caller know approximately how much has been completed. If
    the calculation is done, then the response will contain the answer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务将模拟一个难题的计算。创建新线程的一个有效理由是让新线程执行一些工作，而原始线程继续它正在做的事情。新服务的设计理念是`Calculate`请求可能需要很长时间才能完成，我们不希望调用者在等待结果时超时。因此，服务将创建一个新线程来执行计算，并立即向调用者返回一个令牌。调用者可以使用这个令牌以不同的`Status`请求回调到服务，这将检查刚刚开始的计算进度。如果计算尚未完成，则`Status`请求的响应将让调用者知道大约完成了多少。如果计算已完成，则响应将包含答案。
- en: 'We now have a justification for multiple threads and can write some tests.
    Let’s take care of an unrelated test that should have been added already. We want
    to make sure that anybody calling the service with an unrecognized request will
    get an unrecognized response. Put the following test in the `Message.cpp` file
    in the `tests` folder of the `SimpleService` project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有理由使用多个线程并可以编写一些测试。让我们处理一个本应已经添加的无关测试。我们想要确保任何使用未识别请求调用服务的人都会收到一个未识别的响应。将以下测试放入`SimpleService`项目的`tests`文件夹中的`Message.cpp`文件中：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I put this test at the top of `Message.cpp`. All it does is send the previous
    greeting request but with an unrecognized expected response.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个测试放在`Message.cpp`的顶部。它所做的只是发送之前的问候请求，但期望得到一个未识别的响应。
- en: 'Let’s also change the name of the test suite to `"Calculation Service"` like
    this in `SetupTeardown.cpp`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还在`SetupTeardown.cpp`中将测试套件的名称更改为`"Calculation Service"`，如下所示：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s remove the greeting test and add the following simple test, which
    makes sure we get something other than the unrecognized response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除问候测试并添加以下简单测试，以确保我们得到除未识别响应之外的其他响应：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This test is the opposite of the unrecognized test and makes sure that the response
    is something other than unrecognized. Normally, it’s better to confirm that a
    result matches what you expect to happen instead of confirming that a result is
    not what you don’t expect. A double negative is not only harder to think about,
    but can lead to problems because it’s not possible to catch all the ways something
    can go wrong. By confirming what you want to happen, you can eliminate all the
    possible error conditions, which are too many to catch individually.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与未识别测试相反，确保响应不是未识别的。通常，确认结果符合预期发生的事情，而不是确认结果不是你不想发生的事情，会更好。双重否定不仅更难思考，而且可能导致问题，因为不可能捕捉到所有可能出错的方式。通过确认你想要发生的事情，你可以消除所有可能的错误条件，这些条件太多，无法单独捕捉。
- en: This test is a little different, though. We’re not interested in the response.
    The test only intends to confirm that the request was recognized. Confirming that
    the response is not unrecognized is appropriate, even though it seems similar
    to the double negative trap we just described.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试有一点不同。我们并不关心响应。这个测试的目的是确认请求已被识别。确认响应不是未识别的，即使这看起来与刚刚描述的双重否定陷阱相似，也是合适的。
- en: 'Building and running this code shows that the unrecognized test passes but
    the `Calculate` request fails:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行此代码显示，未识别的测试通过了，但`Calculate`请求失败了：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It seems that we’re getting an unrecognized response for a request that should
    be valid. This is the value of adding simple tests at the beginning of a project.
    The tests help catch simple errors right away. The problem is in the `handleRequest`
    method. I added the second check for a valid request by copying the first check
    and forgot to change the `if` statement to an `else if` statement. The fix for
    this is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，对于应该有效的请求，我们得到了一个未识别的响应。这就是在项目开始时添加简单测试的价值所在。测试有助于立即捕捉到简单的错误。问题是出在`handleRequest`方法中。我通过复制第一次检查添加了第二次对有效请求的检查，却忘记了将`if`语句更改为`else
    if`语句。修复方法如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To continue further, we’re going to send and receive more than strings. When
    we send a `Calculate` request, we should get back a token value that we can pass
    to the `Status` request. The `Status` response should then contain either the
    answer or an estimate of how much progress has been made. Let’s take this one
    step at a time and define the `Calculate` request and response structures. Add
    the following two struct definitions to the top of `Service.h` inside the `SimpleService`
    namespace:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步进行，我们将发送和接收不仅仅是字符串。当我们发送一个`Calculate`请求时，我们应该得到一个可以传递给`Status`请求的令牌值。然后`Status`响应应该包含答案或进度估计。让我们一步一步来，定义`Calculate`请求和响应结构。将以下两个结构定义添加到`Service.h`文件中的`SimpleService`命名空间顶部：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will let us pass some initial value to be calculated; in return, we will
    get a token that we can use to eventually get the answer. But we have a problem.
    If the `Calculate` request is changed to return a struct, then that will break
    the existing test, which expects a string. We should change the tests so that
    they use the structs, but that leads to another problem: most of the time, we
    need to return the correct response struct. And we need to return an error response
    for error cases.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们传递一些初始值进行计算；作为回报，我们将得到一个可以用来最终获取答案的令牌。但我们有一个问题。如果将`Calculate`请求更改为返回结构体，那么这将破坏现有的测试，因为测试期望得到一个字符串。我们应该改变测试，让它们使用结构体，但这又带来了另一个问题：大多数时候，我们需要返回正确的响应结构体。并且我们需要为错误情况返回错误响应。
- en: What we need is a response that can represent both a good response and an error
    response. Since we’re going to have a response that can serve multiple purposes,
    why not let it also handle a struct for the `Status` response? This means we’ll
    have a single response type that can be either an error response, a calculate
    response, or a status response. And since we have a multi-purpose response type,
    why not create a multi-purpose request type? Let’s change the tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是可以代表良好响应和错误响应的响应。既然我们将有一个可以服务于多个目的的响应，为什么不让它也处理`Status`响应的结构体呢？这意味着我们将有一个单一的响应类型，它可以是一个错误响应、计算响应或状态响应。既然我们有一个多用途的响应类型，为什么不创建一个多用途的请求类型呢？让我们改变一下测试。
- en: We’re going to use `std::variant` to hold the different types of requests and
    responses. We can remove the test that sent a request string that was not valid.
    We can still get an invalid request but only with mismatched service versions
    between the caller and the service. That’s a little more involved, so we’ll ignore
    the possibility that a service can be called with a different idea of what requests
    are available than the service knows about. If you’re writing a real service,
    then this is a possibility that needs to be addressed and tested. You’ll probably
    want to use something different than a variant too. A good choice would be something
    such as Google’s *Protocol Buffers*, where the service would accept Protocol Buffer
    messages. While using Protocol Buffers is a better choice than simple structs,
    the design is also a lot more complicated and would make this explanation much
    longer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `std::variant` 来存储不同类型的请求和响应。我们可以移除发送了无效请求字符串的测试。我们仍然可能会收到无效请求，但这仅发生在调用者和服务之间的服务版本不匹配。这稍微复杂一些，所以我们暂时忽略服务可能对请求可用性的理解与实际服务知识不一致的情况。如果你正在编写一个真实的服务，那么这是一个需要解决和测试的可能性。你可能还想使用不同于变体的其他东西。一个好的选择可能是类似于谷歌的
    *Protocol Buffers*，其中服务将接受 Protocol Buffer 消息。虽然使用 Protocol Buffers 比简单的结构体更好，但其设计也更加复杂，这将使解释变得更加冗长。
- en: 'We’ll have a single test in `Message.cpp` that will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Message.cpp` 中，我们将有一个单独的测试，其外观如下：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This test focuses on the request type first and leaves the response type as
    a string. We’ll make the changes one step at a time. This is especially good advice
    when working with `std::variant` because it can be challenging if you’re not familiar
    with variants. We’ll have a variant type called `RequestVar` that can be initialized
    with a specific request type. We’re initializing the request with a `CalculateRequest`
    and using the *designated initializer* syntax to set the `mSeed` value. The designated
    initializer syntax is fairly new to C++. It lets us set data member values based
    on the name by putting a dot in front of the data member’s name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试首先关注请求类型，并将响应类型留为字符串。我们将逐步进行更改。这对于使用 `std::variant` 尤其是当你不熟悉变体时非常有用。我们将有一个名为
    `RequestVar` 的变体类型，它可以被初始化为特定的请求类型。我们使用 `CalculateRequest` 初始化请求，并使用 *指定初始化器*
    语法设置 `mSeed` 值。指定初始化器语法在 C++ 中相对较新，它允许我们通过在数据成员名称前放置一个点来根据名称设置数据成员的值。
- en: 'Now, let’s define the request types in `Service.h`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `Service.h` 中定义请求类型：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that we need to include the standard `variant` header file. The `RequestVar`
    type can now only be either a `CalculateRequest` or a `StatusRequest`. We need
    to make one more change in `Service.h` to the `handleRequest` method in the `Service`
    class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要包含标准 `variant` 头文件。`RequestVar` 类型现在只能是 `CalculateRequest` 或 `StatusRequest`
    之一。我们还需要在 `Service.h` 中的 `Service` 类的 `handleRequest` 方法中进行一个额外的更改：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Service.cpp` file needs to be changed so that it updates the `handleRequest`
    method, like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改 `Service.cpp` 文件，以便更新 `handleRequest` 方法，如下所示：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The updated `handleRequest` method continues to check for an unknown request
    type. All the responses are strings that will need to change. We’re not looking
    at the seed or token values yet, but we have enough that can be built and tested.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `handleRequest` 方法继续检查未知请求类型。所有响应都是字符串，需要更改。我们目前还没有查看种子或令牌值，但我们已经有了足够的内容可以构建和测试。
- en: Now that the single test passes, in the next section, we will look at the responses
    and use structs instead of response strings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单个测试通过后，在下一节中，我们将查看响应并使用结构体而不是响应字符串。
- en: Changing the service return type
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改服务返回类型
- en: We’ll be making a similar change in this section to move away from strings and
    use a struct in the service request handling. The previous section changed the
    service request type; this section will change the service return type. We need
    to make these changes so that we can get the service to a level of functionality
    where it can support the need for an additional thread.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中进行类似的更改，以摆脱字符串并使用结构体来处理服务请求。上一节更改了服务请求类型；本节将更改服务返回类型。我们需要进行这些更改，以便将服务提升到能够支持额外线程需求的功能水平。
- en: The `SimpleService` project that we’re using started as a greeting service and
    I could not think of any reason for such a simple service to need another thread.
    We started adapting the service to a calculation service in the previous section;
    now, we need to modify the return types that the service returns when handling
    requests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`SimpleService`项目最初是一个问候服务，我无法想出任何理由说明这样一个简单的服务需要另一个线程。我们在上一节中开始将服务调整为计算服务；现在，我们需要修改服务在处理请求时返回的返回类型。
- en: 'First, let’s define the return type structs in `Service.h`, which come right
    after the request types. Add the following code to `Service.h`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`Service.h`中定义返回类型结构体，它紧随请求类型之后。将以下代码添加到`Service.h`中：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These structs and the variant are following the same pattern that was used
    for the requests. One small difference is that we now have an `ErrorResponse`
    type, which will be returned for any errors. We can modify the test in `Message.cpp`
    so that it looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构和变体遵循与请求相同的模式。一个小差异是，我们现在有一个`ErrorResponse`类型，它将用于任何错误。我们可以修改`Message.cpp`中的测试，使其看起来像这样：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This test will call the service as it did previously with a calculate request;
    the response that comes back is tested to see if it is a calculate response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将像之前一样调用服务，使用计算请求；返回的响应将被测试以确认它是否是计算响应。
- en: 'For the code to compile, we need to change the `handleRequest` declaration
    in `Service.h` so that it returns the new type, like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码能够编译，我们需要更改`Service.h`中的`handleRequest`声明，使其返回新的类型，如下所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we need to change the implementation of `handleRequest` in `Service.cpp`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更改`Service.cpp`中`handleRequest`的实现：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code is getting a little more complicated. I removed the log at the end,
    which was used to log the response before returning. We could put the log back
    in but that would require the ability to convert a `ResponseVar` into a string.
    Alternatively, we would need to log the response in multiple places like the code
    does for the request. That’s a detail that we can skip.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得越来越复杂。我在返回前移除了日志记录，之前它是用来记录响应的。我们可以把日志记录放回去，但这需要将`ResponseVar`转换为字符串的能力。或者，我们可以在多个地方记录响应，就像代码中对请求所做的那样。这是一个我们可以跳过的细节。
- en: The new `handleRequest` method does almost the same things it used to do except
    that it now initializes a `ResponseVar` type instead of returning a string. This
    allows us to return different types with more detailed information than before
    when we were returning a string for both the requests and the error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`handleRequest`方法几乎与之前所做的一样，只是现在它初始化一个`ResponseVar`类型而不是返回一个字符串。这允许我们在返回请求和错误时，提供比之前更详细的信息。
- en: To add a test for an unrecognized request, we would need to add a new request
    type to `RequestVar` but ignore the new request type in the `if` statements inside
    the `handleRequest` method. We’re going to skip that test too because we really
    should be using something other than a `std::variant`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个测试来识别未知的请求，我们需要在`RequestVar`中添加一个新的请求类型，但在`handleRequest`方法内的`if`语句中忽略这个新的请求类型。我们也将跳过这个测试，因为我们真的应该使用除了`std::variant`之外的其他东西。
- en: The only reason we’re using `std::variant` for this example is to avoid extra
    complexity. We’re trying to get the code ready to support another thread.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中使用`std::variant`的唯一原因是为了避免额外的复杂性。我们试图使代码准备好支持另一个线程。
- en: In the next section, we will add a test that uses both request types. The first
    request will begin a calculation, while the second request will check the status
    of the calculation and get the result when the calculation is complete.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加一个使用两种请求类型的测试。第一个请求将开始计算，而第二个请求将在计算完成时检查计算状态并获取结果。
- en: Making multiple service calls
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行多次服务调用
- en: If you’re considering using multiple threads to speed up a calculation, then
    I recommend that you get the code tested and working with a single thread before
    taking on the additional complexity of multiple threads.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑使用多线程来加速计算，那么我建议你在承担多线程的额外复杂性之前，先使用单线程测试并确保代码能够正常工作。
- en: For the service we’re working on, the reason to add a second thread is not to
    increase the speed of anything. We need to avoid a timeout for a calculation that
    might take a long time. The additional thread we’re going to add is not designed
    to make the calculation any faster. Once we get the calculation working with one
    additional thread, we can consider adding more threads to speed up the calculation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在工作的服务，添加第二个线程的原因不是为了提高任何东西的速度。我们需要避免一个可能需要很长时间的计算超时。我们将添加的额外线程不是为了使计算更快。一旦我们使用一个额外的线程使计算工作，我们就可以考虑添加更多线程来加快计算速度。
- en: The need to create a thread to do some work while the original thread continues
    with something else is common. This is not an optimization that should be done
    later. This is part of the design and the additional thread should be included
    from the very beginning.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始线程继续做其他事情的同时创建一个线程来执行一些工作是常见的。这不是应该在以后进行的优化。这是设计的一部分，并且应该从一开始就包含额外的线程。
- en: 'Let’s begin by adding a new test to `Message.cpp` that looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `Message.cpp` 添加一个新测试开始，这个测试看起来是这样的：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All the code is already in place for this new test to compile. Now, we can
    run the tests to see what happens. The test will fail, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都已经就绪，以便这个新测试可以编译。现在，我们可以运行测试以查看会发生什么。测试将失败，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What does the test do? First, it creates a calculate request l and gets back
    a hardcoded token value. There is no calculation for when the service begins yet,
    so when we make a status request with the token, the service responds with a hardcoded
    response that says the calculation is not done yet. The test is looking for a
    status response that says the calculation is complete. The test tries making a
    status request five times before giving up, which causes the confirmation at the
    end of the test to fail because we didn’t get the expected result. Note that even
    trying multiple times is not the best way to proceed. Threads are unpredictable
    and your computer may make all five attempts before the service can complete the
    request. You might need to increase the number of attempts if your test continues
    to fail or wait for a reasonable amount of time. Our calculation will eventually
    multiply the seed by `10`. So, when we give an initial seed of `5`, we should
    expect a final result of `50`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试做什么？首先，它创建一个计算请求 l 并获取一个硬编码的令牌值。在服务开始时还没有进行计算，所以当我们用令牌发出状态请求时，服务会响应一个硬编码的响应，表示计算尚未完成。测试正在寻找一个表示计算已完成的状态响应。测试尝试进行五次状态请求然后放弃，这导致测试结束时的确认失败，因为我们没有得到预期的结果。请注意，即使尝试多次也不是最好的做法。线程是不可预测的，你的电脑可能在服务完成请求之前就尝试了所有五次。如果你的测试继续失败，你可能需要增加尝试的次数，或者等待一段合理的时间。我们的计算最终会将种子乘以
    `10`。所以，当我们给出初始种子 `5` 时，我们应该期望最终结果为 `50`。
- en: 'We need to implement the calculation and status request handling in the service
    so that we can use a thread to get the test to pass. The first thing we need to
    do is include `mutex`, `thread`, and `vector` at the top of `Service.cpp`. We
    also need to add an unnamed namespace, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务中实现计算和状态请求处理，这样我们就可以使用一个线程来使测试通过。我们首先需要做的是在 `Service.cpp` 的顶部包含 `mutex`、`thread`
    和 `vector`。我们还需要添加一个无名的命名空间，如下所示：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We’re going to need some locking so that we don’t try to read the calculation
    status while the status is being updated by a thread. To do the synchronization,
    we’ll use a mutex and a lock, as we did in the logging library. There are other
    designs you might want to explore, such as locking data for different calculation
    requests separately. We’re going to use a simple approach and have a single lock
    for everything. Add the following function inside the unnamed namespace:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些锁定机制，这样我们就不在状态被线程更新时尝试读取计算状态。为了进行同步，我们将使用互斥锁和锁，就像我们在日志库中做的那样。你可能还想探索其他设计，例如为不同的计算请求分别锁定数据。我们将采用简单的方法，并为所有内容使用单个锁。在无名的命名空间内添加以下函数：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We need something to keep track of the completion status, the progress, and
    the result for each calculation request. We’ll create a class to hold this information
    called `CalcRecord` inside the unnamed namespace, right after the `getCalcMutex`
    function, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要某种东西来跟踪每个计算请求的完成状态、进度和结果。我们将在无名的命名空间内创建一个类来保存这些信息，称为 `CalcRecord`，就在 `getCalcMutex`
    函数之后，如下所示：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It looks like there’s a lot more to this class, but it’s fairly simple. The
    default constructor doesn’t need to do anything because the data members already
    define their default values. The only reason we need a default constructor is
    that we also have a copy constructor. And the only reason we need a copy constructor
    is so that we can lock the mutex before copying the data members.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个类还有很多其他的功能，但它相当简单。默认构造函数不需要做任何事情，因为数据成员已经定义了它们的默认值。我们需要默认构造函数的唯一原因是我们还有一个拷贝构造函数。而我们需要拷贝构造函数的唯一原因是为了在复制数据成员之前锁定互斥锁。
- en: Then, we have a method to get the data members all at once and another method
    to set the data members. Both the getter and the setter need to acquire the lock
    before proceeding.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个方法可以一次性获取所有数据成员，还有一个方法可以设置数据成员。获取器和设置器在继续之前都需要获取锁。
- en: There should be no need to assign one `CalcRecord` to another, so the assignment
    operator has been deleted.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要将一个`CalcRecord`赋值给另一个，因此已经删除了赋值运算符。
- en: 'The last thing we need in the unnamed namespace is a vector of `CalcRecord`,
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在未命名的命名空间中，我们还需要一个`CalcRecord`的向量，如下所示：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’re going to add a `CalcRecord` to the `calculations` collection every time
    a calculation request is made. A real service would want to clean up or reuse
    `CalcRecord` entries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次有计算请求时，我们都会将一个`CalcRecord`添加到`calculations`集合中。一个真正的服务会希望清理或重用`CalcRecord`条目。
- en: 'We need to modify the request handling in `Service.cpp` so that a thread gets
    created to use a new `CalcRecord` every time we get a calculation request, like
    this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`Service.cpp`中的请求处理，以便每次收到计算请求时都创建一个线程来使用一个新的`CalcRecord`，如下所示：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What happens when we get a calculation request? First, we add a new `CalcRecord`
    to the end of the `calculations` vector. We’ll use the index of `CalcRecord` as
    the token that gets returned in the response. This is the simplest design I could
    think of to identify a calculation request. A real service would want to use a
    more secure token. The request handler then starts a thread to do the calculation
    and detaches from the thread.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到一个计算请求时会发生什么？首先，我们在`calculations`向量的末尾添加一个新的`CalcRecord`。我们将使用`CalcRecord`的索引作为响应中返回的令牌。这是我能够想到的识别计算请求的最简单设计。一个真正的服务会希望使用一个更安全的令牌。然后，请求处理器启动一个线程来进行计算，并从线程中分离出来。
- en: Most threading code that you’ll write will create a thread and then join the
    thread. It’s not very common to create a thread and then detach from the thread.
    Alternatively, you can use a pool of threads when you want to do some work and
    not worry about joining. The reason for detaching is that I wanted the most simple
    example without bringing in thread pools.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的绝大多数线程代码都会创建一个线程然后加入该线程。创建一个线程然后从线程中分离出来并不常见。作为替代，当你想要做一些工作而不必担心加入线程时，你可以使用线程池。分离线程的原因是我想要一个最简单的例子，而不引入线程池。
- en: The thread itself is very simple because it immediately sets `CalcRecord` to
    complete with a progress of `100` and a result of `50`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本身非常简单，因为它立即将`CalcRecord`设置为完成，进度为`100`，结果为`50`。
- en: 'We can build and run the test application now, but we will get the same failure
    we did previously. That’s because the status request handling still returns a
    hardcoded response. We need to modify the request handler like this for the status
    request:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建并运行测试应用程序了，但我们会得到之前相同的失败。那是因为状态请求处理仍然返回硬编码的响应。我们需要像这样修改请求处理器来处理状态请求：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this change, the status request converts the token into an index that it
    uses to find the correct `CalcRecord`. Then, it gets the current data from `CalcRecord`
    to be returned in the response.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，状态请求将令牌转换为它用来查找正确`CalcRecord`的索引。然后，它从`CalcRecord`获取当前数据，并将其作为响应返回。
- en: You may also want to consider adding sleep to the test loop that attempts five
    service call requests so that the total time given to the service is reasonable.
    The current test will fail if all five attempts are made quickly before the service
    has time to complete even a simple calculation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想要考虑在尝试五次服务调用请求的测试循环中添加睡眠，以便给服务提供合理的时间。如果所有五次尝试都在服务完成甚至一个简单的计算之前快速完成，当前的测试将会失败。
- en: All the tests pass after building and running the test application. Are we done
    now? Not yet. All of these changes let the service calculate a result in a separate
    thread while continuing to handle requests on the main thread. The whole point
    of adding another thread is to avoid timeouts due to calculations that take a
    long time. But our calculation is very quick. We need to slow the calculation
    down so that we can test the service with a reasonable response time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和运行测试应用程序后，所有测试都通过了。我们现在就完成了吗？还没有。所有这些更改都让服务能够在单独的线程中计算结果，同时继续在主线程上处理请求。添加另一个线程的整个目的是为了避免由于长时间计算导致的超时。但我们的计算非常快。我们需要减慢计算速度，以便我们可以以合理的响应时间测试服务。
- en: How will we slow down the thread? And what amount of time should the calculation
    require to complete? These are the questions that we’ve been building code to
    answer in this chapter. The next section will explain how you can test services
    that use multiple threads. And now that we have a service that uses another thread
    for the calculation, we can explore the best way to test this situation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何减慢线程的运行？以及计算需要多少时间来完成？这些问题是我们在本章中编写代码来回答的。下一节将解释如何测试使用多个线程的服务。现在我们有一个使用另一个线程进行计算的服务，我们可以探索测试这种情况的最佳方法。
- en: I’d also like to clarify that what the next section does is different than adding
    a delay to the five service call attempts. A delay in the test loop will improve
    the reliability of the test we have now. The next section will remove the loop
    completely and show you how to coordinate a test with another thread so that both
    the test and the thread proceed together.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想澄清，下一节所做的是与在五个服务调用尝试中添加延迟不同。在测试循环中添加延迟将提高我们目前测试的可靠性。下一节将完全删除循环，并展示如何与其他线程协调测试，以便测试和线程可以一起进行。
- en: How to test multiple threads without sleep
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在不使用sleep的情况下测试多个线程
- en: 'Earlier in this chapter, in the *The need to justify multiple threads* section,
    I mentioned that you should try to do as much work as possible with single threads.
    We’re going to follow this advice now. In the current request handling for the
    calculate request, the code creates a thread that does a simple calculation, like
    this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，在*需要证明多线程的必要性*部分，我提到你应该尽量使用单线程完成尽可能多的工作。我们现在将遵循这个建议。在当前的计算请求处理中，代码创建了一个执行简单计算的线程，如下所示：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, maybe a simple calculation is the wrong way to describe what the thread
    does. The thread sets the result to a hardcoded value. We know this is temporary
    code and that we’ll need to change the code to multiply the seed value by `10`,
    which is what the tests expect.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许简单计算不是描述线程所做事情的正确方式。线程将结果设置为硬编码的值。我们知道这是临时代码，我们需要将代码更改为将种子值乘以`10`，这正是测试所期望的。
- en: Where should the calculation be done? It would be easy to do the calculation
    in the thread lambda, but that would go against the advice of doing as much work
    as possible with a single thread.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 计算应该在何处进行？在线程lambda中进行计算很容易，但这将违反尽量使用单线程完成尽可能多的工作的建议。
- en: What we want to do is create a calculation function that the thread can call.
    This will let us test the calculation function separately without worrying about
    any threading issues and make sure that the calculation is correct.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是创建一个线程可以调用的计算函数。这将使我们能够单独测试计算函数，而不必担心任何线程问题，并确保计算是正确的。
- en: 'And here’s the really interesting part: creating a function to do the calculation
    will help us test the thread management too! How? Because we’re going to create
    two calculation functions.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个真正有趣的部分：创建一个执行计算的函数将帮助我们测试线程管理！如何？因为我们将创建两个计算函数。
- en: One function will be the real calculation function, which can be tested independently
    of any threads. For our project, the real calculation will still be simple and
    fast. We’re not going to try to do a lot of work to slow down the calculation
    and we’re not going to put the thread to sleep either. And we’re not going to
    write a bunch of tests to make sure the calculation is correct. This is just an
    example of a pattern that you can follow in your projects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数将是真正的计算函数，可以独立于任何线程进行测试。对于我们的项目，真正的计算仍然简单且快速。我们不会尝试做很多工作来减慢计算，也不会让线程休眠。我们也不会编写大量测试来确保计算正确。这只是一个你可以遵循的项目模式示例。
- en: The other function will be a test calculation function and will do some fake
    calculations designed to match the real calculation result. The test calculation
    function will also contain some thread management code designed to coordinate
    the thread’s activity. We’ll use the thread management code in the test calculation
    function to slow down the thread so that we can simulate a calculation that takes
    a long time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数将是一个测试计算函数，它将执行一些旨在匹配真实计算结果的假计算。测试计算函数还将包含一些线程管理代码，用于协调线程的活动。我们将使用测试计算函数中的线程管理代码来减慢线程速度，以便模拟耗时较长的计算。
- en: What we’re doing is mocking the real calculation with code that is less focused
    on the calculation and more focused on the thread’s behavior. Any test that wants
    to test the real calculation can use the real calculation function, while any
    test that wants to test the thread timing and coordination can use the test calculation
    function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是用代码模拟真实计算，这些代码更关注线程的行为而非计算本身。任何想要测试真实计算的测试都可以使用真实计算函数，而任何想要测试线程定时和协调的测试都可以使用测试计算函数。
- en: 'First, we’ll declare the two functions in `Service.h` right before the `Service`
    class, like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `Service.h` 中声明这两个函数，位于 `Service` 类之前，如下所示：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can define your calculation functions in your projects to do whatever you
    need. Your functions will likely be different. The main point to understand is
    that they should have the same signature so that the test function can be substituted
    for the real function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目中定义自己的计算函数以执行所需的任何操作。您的函数可能不同。需要理解的主要点是它们应该具有相同的签名，以便测试函数可以替换真实函数。
- en: 'The `Service` class needs to be changed so that one of these functions can
    be injected into the service. We’ll set up the calculation function in the constructor
    and use the real function as the default, like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service` 类需要修改，以便可以将这些函数之一注入到服务中。我们将在构造函数中设置计算函数，并使用真实函数作为默认值，如下所示：'
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Service` class now has a member function pointer that will point to one
    of the calculation functions. Which one will be called is determined when the
    `Service` class is created.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service` 类现在有一个成员函数指针，它将指向其中一个计算函数。具体调用哪个函数是在创建 `Service` 类时确定的。'
- en: 'Let’s implement the two functions in `Service.cpp`, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照如下方式实现这两个函数在 `Service.cpp` 中：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the moment, both functions are the same. We’ll take this one step at a time.
    Each function just sets `progress` to `100` and `result` to `seed` times `10`.
    We’re going to leave the real or normal function as-is. Eventually, we’ll change
    the test function so that it controls the thread.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这两个函数是相同的。我们将一步一步来。每个函数只是将 `progress` 设置为 `100`，将 `result` 设置为 `seed` 乘以
    `10`。我们将保持真实或正常函数不变。最终，我们将修改测试函数，使其控制线程。
- en: 'Now, we can change the calculate request handler in `Service.cpp` so that it
    uses the calculation function, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改 `Service.cpp` 中的计算请求处理程序，使其使用计算函数，如下所示：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the thread lambda, we call `mCalc` instead of setting `progress` and `result`
    to hardcoded values. Which calculation function is called depends on which function
    `mCalc` points to.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程 lambda 中，我们调用 `mCalc` 而不是将 `progress` 和 `result` 设置为硬编码的值。调用哪个计算函数取决于 `mCalc`
    指向哪个函数。
- en: 'If we build and run the test application, we’ll see that the tests pass. But
    there’s something wrong with how we’re calling `mCalc`. We want to get intermediate
    progress so that a caller can make status requests and see the progress increasing
    until the calculation is finally complete. By calling `mCalc` once, we only give
    the function one chance to do something. We should be calling the `mCalc` function
    in a loop until `progress` reaches `100` percent. Let’s change the lambda code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建并运行测试应用程序，我们会看到测试通过。但我们在调用 `mCalc` 方式上存在问题。我们希望获取中间进度，以便调用者可以发出状态请求并看到进度增加，直到计算最终完成。通过一次调用
    `mCalc`，我们只给函数一次做事情的机会。我们应该在 `progress` 达到 `100` 百分比之前循环调用 `mCalc` 函数。让我们更改 lambda
    代码：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This change does not affect the tests because the `mCalc` function currently
    sets `progress` to `100` on the first call; therefore, the while loop will only
    run once. We don’t want the thread to take too long to run without some synchronization
    with the tests because we’ll never join with the thread. If this was a real project,
    we would want to use threads from a thread pool and wait for the threads to complete
    before stopping the service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改不会影响测试，因为当前的`mCalc`函数在第一次调用时将`progress`设置为`100`；因此，while循环只会运行一次。我们不希望线程在没有与测试同步的情况下运行得太久，因为我们永远不会与线程连接。如果这是一个真实的项目，我们希望使用线程池中的线程，并在停止服务之前等待线程完成。
- en: Making a change that does not affect the tests is a great way to verify changes.
    Take small steps instead of trying to do everything in one giant set of changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对测试不产生影响的更改是一种很好的验证更改的方法。采取小步骤，而不是试图在一次巨大的更改集中完成所有事情。
- en: 'Next, we’re going to duplicate the test that generates a result except we will
    use the test calculation function in the duplicate test. The test will need to
    be modified slightly so that it can use the test calculation function. But for
    the most part, the test should remain almost identical. The new test goes in `Message.cpp`
    and looks like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将复制生成结果的测试，但我们将使用复制测试中的测试计算函数。测试需要稍作修改，以便可以使用测试计算函数。但大部分测试应该几乎保持不变。新测试放在`Message.cpp`中，如下所示：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The only changes are to give the test a different name so that it uses a new
    test suite called `"Service 2"`, and then use a different global service called
    `gService2`. Here, we expect a slightly different result. We’ll be changing this
    test soon so that it will eventually contribute more value than it does now, and
    we’ll be removing the loop that tries to make the request five times. Making these
    changes in small steps will let us verify that we don’t break anything major.
    And expecting a slightly different result will let us verify that we are using
    a different calculation function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的更改是给测试一个不同的名称，以便它使用一个名为`"Service 2"`的新测试套件，然后使用一个不同的全局服务`gService2`。在这里，我们期望得到略微不同的结果。我们很快就会更改这个测试，使其最终比现在更有价值，并且我们会移除尝试进行五次请求的循环。分步骤进行这些更改将使我们能够验证我们没有破坏任何主要的东西。并且期望得到略微不同的结果将使我们能够验证我们是否使用了不同的计算函数。
- en: 'To build the project, we need to define `gService2`, which will use a new setup
    and teardown class. Add the following code to `SetupTeardown.h`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建项目，我们需要定义`gService2`，它将使用一个新的设置和销毁类。将以下代码添加到`SetupTeardown.h`中：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `TestServiceSetup` class defines a constructor that initializes the `mService`
    data member with the `testCalc` function. The `gService2` declaration uses `TestServiceSetup`.
    We need to make a small change in `SetupTeardown.cpp` for `gService2`, like so:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestServiceSetup`类定义了一个构造函数，该构造函数使用`testCalc`函数初始化`mService`数据成员。`gService2`声明使用`TestServiceSetup`。我们需要在`SetupTeardown.cpp`中对`gService2`进行一些小的更改，如下所示：'
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `SetupTeardown.cpp` file is short and only needs to define instances of
    `gService1` and `gService2`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupTeardown.cpp`文件很短，只需要定义`gService1`和`gService2`的实例。'
- en: 'We need to change the `testCalc` function so that it will multiply by `8` to
    give an expected result of `40` instead of `50`. Here are both calculation functions
    in `Service.cpp`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`testCalc`函数，使其乘以`8`后得到预期的结果`40`而不是`50`。以下是`Service.cpp`中的两个计算函数：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Building and running the test application shows that all the tests pass. We
    now have two test suites. The output looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行测试应用程序显示所有测试都通过了。我们现在有两个测试套件。输出如下：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we introduced a new service that uses a slightly different calculation
    function and can use both services in the tests. The tests pass with minimal changes.
    Now, we’re ready to make more changes to coordinate the threads. This is a better
    approach than jumping directly into the thread management code and adding the
    new service and calculation function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了一个使用略微不同的计算函数的新服务，并且可以在测试中使用这两个服务。测试通过，且仅进行了最小改动。现在，我们准备进行更多更改以协调线程。这种方法比直接跳入线程管理代码并添加新服务和计算函数要好。
- en: 'When following TDD, the process is always the same: get the tests to pass,
    make small changes to the tests or add new tests, and get the tests to pass again.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循TDD（测试驱动开发）时，过程始终相同：让测试通过，对测试进行小改动或添加新测试，然后再次让测试通过。
- en: The next step will complete this section. We’re going to control the speed at
    which the `testCalc` function works so that we can make multiple status requests
    to get a complete result. We’ll wait inside the test calculation function so that
    the test has time to verify that the progress does indeed increase over time until
    the result is finally calculated once the progress reaches 100%.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将完成这一部分。我们将控制`testCalc`函数的工作速度，以便我们可以进行多次状态请求以获得完整的结果。我们将在测试计算函数内部等待，以便测试有时间验证进度确实随着时间的推移而增加，直到进度达到100%时最终计算出结果。
- en: Let’s start with the test. We’re going to signal the calculation thread from
    within the test thread so that the calculation thread will progress in-step with
    the test. This is what I meant by testing multiple threads without using sleep.
    Sleeping within a thread is not a good solution because it’s not reliable. You
    might be able to get a test to pass only to have the same test fail later when
    the timing changes. The solution you’ll learn here can be applied to your testing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试开始。我们将在测试线程内部向计算线程发送信号，以便计算线程能够与测试同步进行。这就是我不使用睡眠来测试多个线程的意思。在线程内部睡眠不是一个好的解决方案，因为它不可靠。你可能能够通过测试，但后来当时间变化时，同样的测试可能会失败。这里你将学到的解决方案可以应用于你的测试。
- en: 'All you need to do is create a test version of part of your code that can be
    substituted for the real code. In our case, we have a `testCalc` function that
    can be substituted for the `normalCalc` function. Then, you can add one or more
    *condition variables* to your test and wait on those condition variables from
    within the test version of your code. A condition variable is a standard and supported
    way in C++ to let one thread wait until a condition is met before proceeding.
    The test calculation function will wait on the condition variable. The test will
    notify the condition variable when it’s ready for the calculation to continue.
    Notifying the condition variable will unblock the waiting calculation thread at
    exactly the right time so that the test can verify the proper thread behavior.
    Then, the test will wait until the calculation has been completed before continuing.
    We’ll need to include `condition_variable` at the top of `Service.h`, like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的只是创建你代码的一部分的测试版本，它可以替换真实代码。在我们的例子中，我们有一个`testCalc`函数可以替换`normalCalc`函数。然后，你可以在测试中添加一个或多个*条件变量*，并在你的代码的测试版本中等待这些条件变量。条件变量是C++中一个标准且受支持的方式，允许一个线程在满足条件之前等待。测试计算函数将等待条件变量。当测试准备好继续计算时，它将通知条件变量。通知条件变量将在正确的时间解除等待的计算线程，以便测试可以验证适当的线程行为。然后，测试将等待计算完成后再继续。我们需要在`Service.h`的顶部包含`condition_variable`，如下所示：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we need to declare a mutex, two condition variables, and two bools in
    `Service.h` so that they can be used by the test calculation function and by the
    test. Let’s declare the mutex, condition variables, and the bools right before
    the test calculation function, like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Service.h`中声明一个互斥锁、两个条件变量和两个布尔值，以便它们可以被测试计算函数和测试使用。让我们在测试计算函数之前声明互斥锁、条件变量和布尔值，如下所示：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here is the modified test in `Message.cpp`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的`Message.cpp`测试代码：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The test is a bit longer than it used to be. We’re no longer making status requests
    in a loop while looking for a completed response. This test takes a more deliberate
    approach and knows exactly what it expects at each step. The initial calculation
    request and calculation response are the same. The test knows that the calculation
    will be paused, so the first status request will return an uncompleted response
    with zero progress.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 测试比以前要长一些。我们不再在寻找完成响应的同时在循环中发出状态请求。这个测试采取了一种更谨慎的方法，并且确切地知道每个步骤的期望结果。初始的计算请求和计算响应是相同的。测试知道计算将被暂停，因此第一个状态请求将返回一个未完成的响应，进度为零。
- en: After the first status request has been confirmed, the test notifies the calculation
    thread that it can continue and then the test waits. Once the calculation is complete,
    the calculation thread will notify the test that the test can continue. At all
    times, the test and the calculation thread are taking turns, which lets the test
    confirm each step. There is a small race condition in the test calculation thread
    that I’ll explain after you’ve seen the code. A race condition is a problem where
    two or more threads can interfere with each other and the result is not completely
    predictable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次状态请求被确认后，测试会通知计算线程可以继续，然后测试等待。一旦计算完成，计算线程将通知测试可以继续。在所有时候，测试和计算线程都在轮流进行，这样测试可以确认每一步。测试计算线程中存在一个小小的竞争条件，我会在你看到代码后解释。竞争条件是指两个或多个线程可能会相互干扰，导致结果不可完全预测的问题。
- en: 'Let’s look at the other half now – the test calculation function. We need to
    declare the mutex, condition variables, and the bools too. The variables and the
    test calculation function should look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一半——测试计算函数。我们需要声明互斥锁、条件变量以及布尔值。变量和测试计算函数应该看起来像这样：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first thing that the test calculation function does is wait. No calculation
    progress will be made until the test has a chance to confirm the initial status.
    Once the test calculation thread is allowed to proceed, it needs to notify the
    test before returning so that the test can make another status request.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 测试计算函数的第一件事是等待。除非测试有机会确认初始状态，否则不会进行任何计算进度。一旦允许测试计算线程继续，它需要在返回之前通知测试，以便测试可以再次进行状态请求。
- en: The most important thing to understand about this process is that the test calculation
    function should be the only code interacting with the test. You shouldn’t put
    any waits or notifications in the main service response handler or even in the
    lambda that is defined in the response handler. Only the test calculation function
    that gets swapped out for the real calculation function should have any awareness
    that a test is being run. In other words, you should put all the waiting and condition
    variable notifications in `testCalc`. This is the source of the race condition
    that I mentioned. When the `testCalc` function notifies the test thread that the
    calculation is complete, it’s not completely correct. The calculation is only
    complete when `setData` finishes updating `CalcRecord`. However, we don’t want
    to send the notification after calling `setData` because that would put the notification
    outside of the `testCalc` function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个过程的最重要的地方是，测试计算函数应该是唯一与测试交互的代码。你不应该在主服务响应处理器中，甚至是在响应处理器中定义的lambda中放置任何等待或通知。只有替换为实际计算函数的测试计算函数应该有测试正在运行的任何意识。换句话说，你应该将所有的等待和条件变量通知放在`testCalc`中。这就是我提到的竞争条件的来源。当`testCalc`函数通知测试线程计算已完成时，这并不完全正确。只有当`setData`完成更新`CalcRecord`时，计算才算完成。然而，我们不想在调用`setData`后发送通知，因为这会将通知放在`testCalc`函数之外。
- en: Ideally, we would change the design so that the calculation function is called
    one additional time after completing the calculation. We could say that this gives
    the calculation function a chance to clean up any resources used during the calculation.
    Or maybe we can create another set of functions for cleaning up. One cleanup function
    could be the normal cleanup, while the other function could be substituted for
    test cleanup. Either approach would let us notify the test that the calculation
    has finished, which would eliminate the race condition.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会在计算完成后调用计算函数一次额外的次数。我们可以说这给了计算函数一个清理计算期间使用的任何资源的机会。或者也许我们可以创建另一组用于清理的函数。一个清理函数可以是正常的清理，而另一个函数可以是用于测试清理的替代品。任何一种方法都可以让我们通知测试计算已完成，这将消除竞争条件。
- en: Building and running these tests shows that all the tests continue to pass.
    We’re almost done. We’ll leave the race condition as-is because fixing it would
    only add extra complexity to this explanation. The only remaining task is to fix
    a problem that I noticed in the log file. I’ll explain more about this new problem
    in the next section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行这些测试表明所有测试仍然通过。我们几乎完成了。我们将保持竞争条件不变，因为修复它只会给这个解释增加额外的复杂性。唯一剩下的任务是在日志文件中修复我注意到的问题。我将在下一节中解释这个新问题的更多内容。
- en: Fixing one last problem detected with logging
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复最后通过日志检测到的问题
- en: There’s a big reason why I choose to build a logging library in *Part 2*, *Logging
    Library*, of this book. Logging can be a huge help when debugging known problems.
    Something that’s often overlooked is the benefit that logging provides when looking
    for bugs that haven’t been detected yet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在本书的*第2部分*，*日志库*中构建日志库有一个很大的原因。日志记录在调试已知问题时可以提供巨大的帮助。常常被忽视的是，日志记录在寻找尚未检测到的错误时提供的益处。
- en: 'I’ll often look at the log file after running tests to make sure the messages
    match what I expect. After making the enhancements in the previous section for
    the thread coordination between the test and the test calculation thread, I noticed
    something strange in the log file. The log file looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常会在运行测试后查看日志文件，以确保消息与我预期的相符。在上一节中对测试和测试计算线程之间的线程协调进行了增强后，我在日志文件中注意到了一些奇怪的现象。日志文件看起来是这样的：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: I removed the `log_level` and `logpath` tags just to shorten the messages so
    that you can see the important parts better. The first strange thing that I noticed
    is that the service was started three times. We only have `gService1` and `gService2`,
    so the service should only have been started twice.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了`log_level`和`logpath`标签，只是为了缩短消息，以便你能更好地看到重要部分。我首先注意到的一个奇怪现象是服务启动了三次。我们只有`gService1`和`gService2`，所以服务应该只启动了两次。
- en: The first four lines in the log file make sense. We start `gService1` and then
    run a simple test that requests a calculation and checks that the response is
    of the proper type. Then, we run another test that makes a status request up to
    five times while looking for a complete response. The first status request finds
    the complete response, so no additional status requests are needed. The token
    for the first status request is `1`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件的前四行是有意义的。我们启动`gService1`，然后运行一个简单的测试，请求一个计算并检查响应是否为正确的类型。然后，我们运行另一个测试，在寻找完整响应的同时，最多进行五次状态请求。第一次状态请求找到了完整的响应，因此不需要额外的状态请求。第一次状态请求的令牌是`1`。
- en: Line 5 in the log file, which is where the service is started for the second
    time, is where the log file begins to look strange. We should only need to start
    the second service, make a single additional request, and then make two status
    requests. It looks like the log file is getting duplicate messages from line 5
    until the end.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件的第5行，即第二次启动服务的地方，是日志文件开始看起来奇怪的地方。我们只需要启动第二个服务，进行一次额外的请求，然后进行两次状态请求。看起来日志文件从第5行到结尾都在接收重复的消息。
- en: 'After a little debugging and the hint that we’re duplicating log messages,
    I found the problem. When I originally designed the service, I configured the
    logging in the `Service::start` method. I should have kept the logging configuration
    in the `main` function. Everything worked until we needed to create and start
    a second service so that the second service could be configured to use a test
    calculation function. Well, the second service was also configuring the logging
    when it started, and it added another file output. The second file’s output caused
    all the log messages to be sent to the log file twice. The solution is simple:
    we need to configure the logging in `main` like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一点调试和提示我们正在重复日志消息后，我发现问题所在。当我最初设计该服务时，我在`Service::start`方法中配置了日志记录。我应该将日志配置保留在`main`函数中。一切正常，直到我们需要创建并启动第二个服务，以便第二个服务可以配置为使用测试计算函数。嗯，第二个服务在启动时也配置了日志，并添加了另一个文件输出。第二个文件的输出导致所有日志消息被发送到日志文件两次。解决方案很简单：我们需要像这样在`main`中配置日志：
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we need to remove the logging configuration from the service `start`
    method so that it looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从服务的`start`方法中移除日志配置，使其看起来像这样：
- en: '[PRE64]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With these changes, the tests still pass and the log file looks better. Again,
    I removed some tags to shorten the log message lines. Now, the content of the
    log file is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，测试仍然通过，日志文件看起来更好。再次，我移除了一些标签以缩短日志消息行。现在，日志文件的内容如下：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: While the problem ended up being a mistake in how the logging was configured,
    the point I wanted to make is to remind you to look through the log files periodically
    and make sure the log messages make sense.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然问题最终是日志配置错误导致的，但我想要强调的是，提醒你定期查看日志文件，确保日志消息是有意义的。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This is the last chapter of this book and it explained one of the most confusing
    and difficult aspects of writing software: how to test multiple threads. You’ll
    find a lot of books that explain multi-threading but fewer will give you advice
    and show you effective ways to test multiple threads.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，它解释了编写软件中最令人困惑和难以理解的一个方面：如何测试多线程。你会发现很多书籍解释了多线程，但很少会给你提供建议并展示有效测试多线程的方法。
- en: Because the target customer of this book is a microservices C++ developer who
    wants to learn how to use TDD to design better software, this chapter tied everything
    in this book together to explain how to test multi-threaded services.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的目标客户是希望学习如何使用TDD来设计更好软件的微服务C++开发者，因此本章将本书中的所有内容串联起来，解释如何测试多线程服务。
- en: First, you learned how to use multiple threads in your tests. You need to make
    sure you handle exceptions inside tests that start additional threads. Exceptions
    are important because the testing library uses exceptions to handle failed confirmations.
    You also learned how to use a special helper class to report failed confirmations
    that arise in additional threads.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学会了如何在测试中使用多个线程。你需要确保你处理在启动额外线程的测试中出现的异常。异常很重要，因为测试库使用异常来处理失败的确认。你还学会了如何使用一个特殊的辅助类来报告在额外线程中出现的失败确认。
- en: Threads must also be considered when writing and using libraries. You saw how
    to test a library to make sure it’s thread-safe.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写和使用库时，也必须考虑线程。你看到了如何测试库以确保它是线程安全的。
- en: Finally, you learned how to test multi-threaded services in a fast and reliable
    manner that avoids putting threads to sleep in an attempt to coordinate the actions
    of multiple threads. You learned how to refactor your code so that you can test
    as much as possible in a single-threaded manner and then how to substitute the
    normal code for special test-aware code that works with a test. You can use this
    technique any time you need a test and multi-threaded code to work together so
    that the test can take specific and reliable steps and confirm your expectations
    along the way.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了如何以快速和可靠的方式测试多线程服务，避免了在尝试协调多个线程的动作时让线程休眠。你学会了如何重构你的代码，以便尽可能地在单线程模式下进行测试，然后如何用特殊的测试感知代码替换正常代码，这些代码与测试一起工作。当你需要测试和多线程代码一起工作时，你可以使用这种技术，以便测试可以采取具体和可靠的步骤，并在过程中确认你的期望。
- en: Congratulations on reaching the end of this book! This chapter visited all the
    projects we’ve been working on. We enhanced the unit testing library to help you
    use multiple threads in your tests. We also made the logging library thread-safe.
    Finally, we enhanced the service so that it can coordinate multiple threads between
    the service and the tests. You now have all the skills you’ll need to apply TDD
    to your projects.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这本书的阅读！本章回顾了我们一直在工作的所有项目。我们增强了单元测试库，帮助你可以在测试中使用多个线程。我们还使日志库线程安全。最后，我们增强了服务，使其能够在服务和测试之间协调多个线程。你现在拥有了将TDD应用到你的项目中所需要的所有技能。
