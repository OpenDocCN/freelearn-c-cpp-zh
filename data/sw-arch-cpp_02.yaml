- en: Importance of Software Architecture and Principles of Great Design
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构的重要性和优秀设计原则
- en: The purpose of this introductory chapter is to show what role software architecture
    plays in software development. It will focus on the key aspects to keep in mind
    when designing the architecture of a C++ solution. We'll discuss how to design
    efficient code with convenient and functional interfaces. We'll also introduce
    a domain-driven approach for both code and architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个介绍性章节的目的是展示软件架构在软件开发中的作用。它将专注于设计C++解决方案架构时需要牢记的关键方面。我们将讨论如何设计具有方便和功能性接口的高效代码。我们还将介绍一个面向领域的方法，用于代码和架构。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding software architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件架构
- en: Learning the importance of proper architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习适当架构的重要性
- en: Exploring the fundamentals of good architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索良好架构的基本原理
- en: Developing architecture using Agile principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用敏捷原则开发架构
- en: The philosophy of C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的哲学
- en: Following the SOLID and DRY principles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循SOLID和DRY原则
- en: Domain-driven design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: Coupling and cohesion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耦合和内聚
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To play with the code from this chapter, you''ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您需要以下内容：
- en: A Git client for checking out the repositories given shortly.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Git客户端，用于检出即将给出的存储库。
- en: A C++20-compliant compiler to compile all the snippets. Most of them are written
    in C++11/14/17, but concept support is required to experiment with the few that
    touch the subject.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个符合C++20标准的编译器来编译所有的代码片段。其中大部分是用C++11/14/17编写的，但是需要概念支持来实验一下涉及该主题的少数代码片段。
- en: 'GitHub link for code snippets: [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter01](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter01).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码片段的GitHub链接：[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter01](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter01)。
- en: 'GitHub link for GSL: [https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GSL的GitHub链接：[https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)
- en: Understanding software architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件架构
- en: Let's begin by defining what software architecture actually is. When you create
    an application, library, or any software component, you need to think about how
    the elements you write will look and how they will interact with each other. In
    other words, you're designing them and their relations with their surroundings.
    Just like with urban architecture, it's important to think about the bigger picture
    to not end up in a haphazard state. On a small scale, every single building looks
    okay, but they don't combine into a sensible bigger picture – they just don't
    fit together well. This is what's called accidental architecture and it is one
    of the outcomes you want to avoid. However, keep in mind that whether you're putting
    your thoughts into it or not, when writing software you are creating an architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义软件架构的实际含义开始。当您创建一个应用程序、库或任何软件组件时，您需要考虑您编写的元素将如何呈现以及它们将如何相互交互。换句话说，您正在设计它们及其与周围环境的关系。就像城市建筑一样，重要的是要考虑整体情况，以免最终陷入杂乱状态。在小范围内，每栋建筑看起来都还不错，但它们无法合理地组合在一起，它们只是无法很好地结合在一起。这就是所谓的偶然架构，这是您要避免的结果之一。但是，请记住，无论您是否在思考，编写软件都是在创建架构。
- en: 'So, what exactly should you be creating if you want to mindfully define the
    architecture of your solution? The Software Engineering Institute has this to
    say:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您想要有意识地定义解决方案的架构，您应该创建什么？软件工程研究所有这样说：
- en: The software architecture of a system is the set of structures needed to reason
    about the system, which comprise software elements, relations among them, and
    properties of both.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的软件架构是理解系统所需的结构集合，包括软件元素、它们之间的关系以及两者的属性。
- en: This means that in order to define an architecture thoroughly, we should think
    about it from a few perspectives instead of just hopping into writing code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了彻底定义架构，我们应该从几个角度来考虑它，而不是只是匆忙地编写代码。
- en: Different ways to look at architecture
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察架构的不同方式
- en: 'There are several scopes that can be used to look at architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个范围可以用来观察架构：
- en: Enterprise architecture deals with the whole company or even a group of companies.
    It takes a holistic approach and is concerned about the strategy of whole enterprises.
    When thinking about enterprise architecture, you should be looking at how all
    the systems in a company behave and cooperate with each other. It's concerned
    about the alignment between business and IT.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业架构涉及整个公司甚至一组公司。它采用全面的方法，关注整个企业的战略。在考虑企业架构时，您应该关注公司中所有系统的行为以及它们如何相互合作。它关注业务和IT之间的对齐。
- en: Solution architecture is less abstract than its enterprise counterpart. It stands
    somewhere in the middle between enterprise and software architecture. Usually,
    solution architecture is concerned with one specific system and the way it interacts
    with its surroundings. A solution architect needs to come up with a way to fulfill
    a specific business need, usually by designing a whole software system or modifying
    existing ones.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案架构比企业架构更具体。它处于企业架构和软件架构之间的中间位置。通常，解决方案架构关注的是一个特定系统以及它与周围环境的交互方式。解决方案架构师需要想出一种方式来满足特定的业务需求，通常是通过设计整个软件系统或修改现有系统。
- en: Software architecture is even more concrete than solution architecture. It concentrates
    on a specific project, the technologies it uses, and how it interacts with other
    projects. A software architect is interested in the internals of the project's
    components.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构甚至比解决方案架构更具体。它集中在一个特定项目、它使用的技术以及它与其他项目的交互方式。软件架构师对项目组件的内部感兴趣。
- en: Infrastructure architecture is, as the name suggests, concerned about the infrastructure
    that the software will use. It defines the deployment environment and strategy,
    how the application will scale, failover handling, site reliability, and other
    infrastructure-oriented aspects.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础架构架构如其名称所示，关注软件将使用的基础架构。它定义了部署环境和策略，应用程序的扩展方式，故障处理，站点可靠性以及其他基础架构导向的方面。
- en: 'Solution architecture is based on both software and infrastructure architectures
    to satisfy the business requirements. In the following sections, we will talk
    about both those aspects to prepare you for both small- and large-scale architecture
    design. Before we jump into that, let''s also answer one fundamental question:
    why is architecture important?'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案架构基于软件和基础架构架构，以满足业务需求。在接下来的章节中，我们将讨论这两个方面，为您准备好小规模和大规模架构设计。在我们深入讨论之前，让我们也回答一个基本问题：为什么架构很重要？
- en: Learning the importance of proper architecture
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习正确架构的重要性
- en: 'Actually, a better question would be: why is caring about your architecture
    important? As we mentioned earlier, regardless of whether you put conscious effort
    into building it or not, you will end up with some kind of architecture. If after
    several months or even years of development you still want your software to retain
    its qualities, you need to take some steps earlier in the process. If you won''t
    think about your architecture, chances are it won''t ever present the required
    qualities.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个更好的问题应该是：为什么关心您的架构很重要？正如我们之前提到的，无论您是否有意识地努力构建它，您最终都会得到某种类型的架构。如果在数月甚至数年的开发之后，您仍希望您的软件保持其品质，您需要在过程的早期采取一些步骤。如果您不考虑您的架构，那么它可能永远不会呈现所需的品质。
- en: So, in order for your product to meet the business requirements and attributes
    such as performance, maintainability, scalability, or others, you need to take
    care of its architecture, and it is best if you do it as early as you can in the
    process. Let's now discuss two things that each good architect wants to protect
    their projects from.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使您的产品满足业务需求和性能、可维护性、可扩展性或其他属性，您需要关注其架构，并且最好在过程的早期就这样做。现在让我们讨论每个优秀架构师都想保护其项目免受的两件事。
- en: Software decay
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件腐败
- en: Even after you did the initial work and had a specific architecture in mind,
    you need to continuously monitor how the system evolves and whether it still aligns
    with its users' needs, as those may also change during the development and lifetime
    of your software. Software decay, sometimes also called erosion, occurs when the
    implementation decisions don't correspond to the planned architecture. All such
    differences should be treated as technical debt.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在您进行了最初的工作并有特定的架构构想之后，您仍需要不断监测系统的演变以及它是否仍然符合用户的需求，因为这些需求在软件的开发和生命周期中也可能发生变化。软件腐败，有时也称为侵蚀，发生在实现决策与计划的架构不相符时。所有这些差异都应被视为技术债务。
- en: Accidental architecture
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意外架构
- en: Failing to track if the development adheres to the chosen architecture or failing
    to intentionally plan how the architecture should look will often result in a
    so-called accidental architecture, and it can happen regardless of applying best
    practices in other areas, such as testing or having any specific development culture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 未能跟踪开发是否遵循所选择的架构，或者未能有意地规划架构的外观，通常会导致所谓的意外架构，这可能会发生，无论在其他领域应用最佳实践，如测试或具有任何特定的开发文化。
- en: There are several anti-patterns that suggest your architecture is accidental.
    Code resembling a big ball of mud is the most obvious one. Having god objects
    is another important sign of this. Generally speaking, if your software is getting
    tightly coupled, perhaps with circular dependencies, but wasn't like that in the
    first place, it's an important signal to put more conscious effort into how the
    architecture looks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种反模式表明您的架构是意外的。类似一团泥的代码是最明显的一个。拥有上帝对象是另一个重要的迹象。一般来说，如果您的软件变得紧密耦合，可能存在循环依赖，但最初并非如此，这是一个重要的信号，需要更多有意识的努力来规划架构的外观。
- en: Let's now describe what an architect must understand to deliver a viable solution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们描述一下架构师必须了解以交付可行解决方案的内容。
- en: Exploring the fundamentals of good architecture
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索良好架构的基本原理
- en: It's important to know how to recognize a good architecture from a bad one,
    but it's not an easy task. Recognizing anti-patterns is an important aspect of
    it, but for an architecture to be good, primarily it has to support delivering
    what's expected from the software, whether it's about functional requirements,
    attributes of the solution, or dealing with the constraints coming from various
    places. Many of those can be easily derived from the architecture context.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道如何识别好的架构和坏的架构，但这并不是一件容易的事。识别反模式是其中的一个重要方面，但要使架构良好，首先它必须支持交付软件所期望的内容，无论是功能要求、解决方案的属性，还是处理来自各个方面的约束。其中许多可以很容易地从架构背景中得出。
- en: Architecture context
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构背景
- en: The context is what an architect takes into account when designing a solid solution.
    It comprises requirements, assumptions, and constraints, which can come from the
    stakeholders, as well as the business and technical environments. It also influences
    the stakeholders and the environments, for example, by allowing the company to
    enter a new market segment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是架构师在设计坚实解决方案时考虑的因素。它包括需求、假设和约束，这些可以来自利益相关者，以及业务和技术环境。它还影响利益相关者和环境，例如，通过允许公司进入新的市场细分。
- en: Stakeholders
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利益相关者
- en: Stakeholders are all the people that are somehow involved with the product.
    Those can be your customers, the users of your system, or the management. Communication
    is a key skill for every architect and properly managing your stakeholder's needs
    is key to delivering what they expected and in a way they wanted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者是所有与产品有关的人。这些可以是你的客户，系统的用户，或者管理层。沟通是每个架构师的关键技能，妥善管理利益相关者的需求对于交付他们期望的东西以他们想要的方式至关重要。
- en: Different things are important to different groups of stakeholders, so try to
    gather input from all those groups.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的利益相关者群体对不同的事情都很重要，所以尽量收集所有这些群体的意见。
- en: Your customers will probably care about the cost of writing and running the
    software, the functionality it delivers, its lifetime, time to market, and the
    quality of your solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的客户可能会关心编写和运行软件的成本、软件提供的功能、其寿命、上市时间以及你的解决方案的质量。
- en: 'The users of your system can be divided into two groups: end users and administrators.
    The first ones usually care about things such as the usability, user experience,
    and performance of the software. For the latter, more important aspects are user
    management, system configuration, security, backups, and recovery.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的用户可以分为两组：最终用户和管理员。前者通常关心的是软件的可用性、用户体验和性能。对于后者来说，更重要的方面是用户管理、系统配置、安全性、备份和恢复。
- en: Finally, things that could matter for stakeholders working in management are
    keeping the development costs low, achieving business goals, being on track with
    the development schedule, and maintaining product quality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于管理工作中的利益相关者来说，重要的事情包括降低开发成本，实现业务目标，按照开发进度表进行，以及保持产品质量。
- en: Business and technical environments
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商业和技术环境
- en: Architecture can be influenced by the business side of the company. Important
    related aspects are the time to market, the rollout schedule, the organizational
    structure, utilization of the workforce, and investment in existing assets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 架构可以受到公司业务方面的影响。重要的相关方面包括上市时间、发布计划、组织结构、劳动力利用率以及对现有资产的投资。
- en: 'By technical environment, we mean the technologies already used in a company
    or those that are for any reason required to be part of the solution. Other systems
    that we need to integrate with are also a vital part of the technical environment.
    The technical expertise of the available software engineers is of importance here,
    too: the technological decisions an architect makes can impact staffing the project,
    and the ratio of junior to senior developers can influence how a project should
    be governed. Good architecture should take all of that into account.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 技术环境指的是公司已经使用的技术或因某种原因需要成为解决方案一部分的技术。我们还需要集成的其他系统也是技术环境的重要组成部分。此外，可用软件工程师的技术专长在这里也很重要：架构师所做的技术决策可能会影响项目的人员配备，初级开发人员与高级开发人员的比例可能会影响项目的治理方式。良好的架构应该考虑到所有这些。
- en: Equipped with all this knowledge, let's now discuss a somewhat controversial
    topic that you'll most probably encounter as an architect in your daily work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，凭借所有这些知识，让我们讨论一个可能会在你日常工作中遇到的颇具争议的话题。
- en: Developing architecture using Agile principles
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用敏捷原则开发架构
- en: Seemingly, architecture and Agile development methodologies are in an adversarial
    relationship, and there are many myths around this topic. There are a few simple
    principles that you should follow in order to develop your product in an Agile
    way while still caring about its architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，架构和敏捷开发方法之间存在对抗性关系，并且围绕这个话题有许多神话。有一些简单的原则你应该遵循，以便以敏捷方式开发产品，同时关注其架构。
- en: Agile, by nature, is iterative and incremental. This means preparing a big,
    upfront design is not an option in an Agile approach to architecture. Instead,
    a small, but still reasonable upfront design should be proposed. It's best if
    it comes with a log of decisions with the rationale for each of them. This way,
    if the product vision changes, the architecture can evolve with it. To support
    frequent release delivery, the upfront design should then be updated incrementally.
    Architecture developed this way is called evolutionary architecture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷本质上是迭代和增量的。这意味着在敏捷架构方法中，准备大量的预先设计不是一个选择。相反，应该提出一个小型但仍合理的预先设计。最好附带有每个决定的理由。这样，如果产品愿景发生变化，架构也可以随之发展。为了支持频繁的发布交付，预先设计应该逐步更新。以这种方式开发的架构被称为演进式架构。
- en: Managing architecture doesn't need to mean keeping massive documentation. In
    fact, documentation should cover only what's essential as this way it's easier
    to keep it up to date. It should be simple and cover only the relevant views of
    the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 管理架构并不意味着保留大量文档。事实上，文档应该只涵盖必要的内容，这样更容易保持其最新。它应该简单，只涵盖系统的相关视图。
- en: There's also the myth of the architect as the single source of truth and the
    ultimate decision-maker. In Agile environments, it's the teams who are making
    decisions. Having said that, it's crucial that the stakeholders are contributing
    to the decision-making process – after all, their points of view shape how the
    solution should look.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于架构师作为唯一真理来源和最终决策者的神话。在敏捷环境中，是团队在做决定。话虽如此，利益相关者对决策过程的贡献至关重要 - 毕竟，他们的观点决定了解决方案应该是什么样子。
- en: An architect should remain part of the development team as often they're bringing
    strong technical expertise and years of experience to the table. They should also
    take part in making estimations and plan the architecture changes needed before
    each iteration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师应该始终是开发团队的一部分，因为他们通常会为团队带来强大的技术专业知识和多年的经验。他们还应该参与估算，并在每次迭代之前计划所需的架构变更。
- en: In order for your team to remain Agile, you should think of ways to work efficiently
    and only on what's important. A good idea to embrace to achieve those goals is
    domain-driven design.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的团队保持敏捷，您应该考虑如何高效地工作，只专注于重要的事情。实现这些目标的一个好主意是领域驱动设计。
- en: Domain-driven design
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: Domain-driven design, or DDD for short, is a term introduced by Eric Evans in
    his book of the same title. In essence, it's about improving communication between
    business and engineering and bringing the developers' attention to the domain
    model. Basing the implementation of this model often leads to designs that are
    easier to understand and evolve together with the model changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计，简称DDD，是埃里克·埃文斯在他的同名书中引入的一个术语。本质上，它是关于改善业务和工程之间的沟通，并将开发人员的注意力引向领域模型。基于该模型的实现通常会导致更容易理解并随着模型变化而发展的设计。
- en: 'What has DDD got to do with Agile? Let''s recall a part of the Agile Manifesto:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DDD与敏捷有什么关系？让我们回顾一下敏捷宣言的一部分：
- en: '**Individuals and interactions** over processes and tools'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人和互动**优于流程和工具'
- en: '**Working software** over comprehensive documentation'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作软件**优于全面文档'
- en: '**Customer collaboration** over contract negotiation'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户协作**优于合同谈判'
- en: '**Responding to change** over following a plan'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应变化**优于遵循计划'
- en: — The Agile Manifesto
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '- 敏捷宣言'
- en: In order to make the proper design decisions, you must understand the domain
    first. To do so, you'll need to talk to people a lot and encourage your developer
    teams to narrow the gap between them and business people. The concepts in the
    code should be named after entities that are part of *ubiquitous language*. It's
    basically the common part of business experts' jargon and technical experts' jargon.
    Countless misunderstandings can be caused by each of these groups using terms
    that the other understands differently, leading to flaws in business logic implementations
    and often subtle bugs. Naming things with care and using terms agreed by both
    groups can mean bliss for the project. Having a business analyst or other business
    domain experts as part of the team can help a lot here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出正确的设计决策，您必须首先了解领域。为此，您需要经常与人交谈，并鼓励您的开发团队缩小他们与业务人员之间的差距。代码中的概念应该以*普遍语言*中的实体命名。这基本上是业务专家术语和技术专家术语的共同部分。由于每个群体使用另一方不同理解的术语，可能会导致无数误解，从而导致业务逻辑实现中的缺陷和常常微妙的错误。谨慎命名事物并使用双方同意的术语可能对项目意味着幸福。在团队中有业务分析师或其他业务领域专家可以在很大程度上帮助。
- en: If you're modeling a bigger system, it might be hard to make all the terms mean
    the same to different teams. This is because each of those teams really operates
    in a different context. DDD proposes the use of *bounded contexts* to deal with
    this. If you're modeling, say, an e-commerce system, you might want to think of
    the terms just in terms of a shopping context, but upon a closer look, you may
    discover that the inventory, delivery, and accounting teams actually all have
    their own models and terms.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在建模一个更大的系统，可能很难使所有术语对不同团队意味着相同的事情。这是因为这些团队中的每一个实际上都在不同的上下文中操作。DDD建议使用*有界上下文*来处理这个问题。例如，如果您正在建模一个电子商务系统，您可能只想从购物的角度考虑这些术语，但仔细观察后，您可能会发现库存、交付和会计团队实际上都有自己的模型和术语。
- en: 'Each of those is a different subdomain of your e-commerce domain. Ideally,
    each can be mapped to its own bounded context – a part of your system with its
    own vocabulary. It''s important to set clear boundaries of such contexts when
    splitting your solution into smaller modules. Just like its context, each module
    has clear responsibilities, its own database schema, and its own code base. To
    help communicate between the teams in larger systems, you might want to introduce
    a context map, which will show how the terms from different contexts relate to
    each other:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一个都是您电子商务领域的不同子领域。理想情况下，每个子领域都可以映射到自己的有界上下文——系统的一部分，具有自己的词汇。在将解决方案拆分为较小的模块时，设置这些上下文的清晰边界非常重要。就像它的上下文一样，每个模块都有明确的责任、自己的数据库架构和自己的代码库。为了在更大的系统中在团队之间进行沟通，您可能希望引入一个上下文地图，它将显示不同上下文的术语之间的关系：
- en: '![](img/8195a246-af38-44ec-ab1d-f293783a78d0.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8195a246-af38-44ec-ab1d-f293783a78d0.png)'
- en: 'Figure 1.1 – Two bounding contexts with the matching terms mapped between them
    (image from one of Martin Fowler''s articles on DDD: https://martinfowler.com/bliki/BoundedContext.html)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1-两个有界上下文及其之间匹配术语的映射（来自Martin Fowler关于DDD的一篇文章：https://martinfowler.com/bliki/BoundedContext.html）
- en: As you now understand some of the important project-management topics, we can
    switch to a few more technical ones.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了一些重要的项目管理主题，我们可以转向一些更技术性的话题。
- en: The philosophy of C++
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的哲学
- en: 'Let''s now move closer to the programming language we''ll be using the most
    throughout this book. C++ is a multi-paradigm language that has been around for
    a few decades now. During the years since its inception, it has changed a lot.
    When C++11 came out, Bjarne Stroustrup, the creator of the language, said that
    it felt like a completely new language. The release of C++20 marks another milestone
    in the evolution of this beast, bringing a similar revolution to how we write
    code. One thing, however, stayed the same during all those years: the language''s
    philosophy.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更接近我们将在本书中大部分时间使用的编程语言。C++是一种多范式语言，已经存在了几十年。自其诞生以来，它发生了很大变化。当C++11发布时，语言的创造者Bjarne
    Stroustrup说感觉像是一种全新的语言。C++20的发布标志着这个怪物演变的又一个里程碑，带来了类似的革命，改变了我们编写代码的方式。然而，在这些年里有一件事始终没有改变：语言的哲学。
- en: 'In short, it can be summarized by three rules:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它可以总结为三条规则：
- en: There should be no language beneath C++ (except assembly).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++之下不应该有其他语言（除了汇编）。
- en: You only pay for what you use.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只为你使用的东西付费。
- en: Offer high-level abstractions at low cost (there's a strong aim for zero-cost).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以低成本提供高级抽象（有强烈的零成本目标）。
- en: Not paying for what you don't use means that, for example, if you want to have
    your data member created on the stack, you can. Many languages allocate their
    objects on the heap, but it's not necessary for C++. Allocating on the heap has
    some cost to it – probably your allocator will have to lock a mutex for this,
    which can be a big burden in some types of applications. The good part is you
    can easily allocate variables without dynamically allocating memory each time
    pretty easily.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不为你不使用的东西付费意味着，例如，如果你想在堆栈上创建数据成员，你可以。许多语言在堆上分配它们的对象，但对于C++来说并不是必要的。在堆上分配是有一些成本的
    - 可能你的分配器将不得不为此锁定互斥锁，在某些类型的应用程序中可能是一个很大的负担。好处是你可以很容易地分配变量而不需要每次动态分配内存。
- en: 'High-level abstractions are what differentiate C++ from lower-level languages
    such as C or assembly. They allow for expressing ideas and intent directly in
    the source code, which plays great with the language''s type safety. Consider
    the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 高级抽象是区分C++与低级语言（如C或汇编）的特点。它们允许直接在源代码中表达想法和意图，这与语言的类型安全非常契合。考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A much better idea would be to leverage the type-safety features offered by
    the language:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的主意是利用语言提供的类型安全特性：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding abstraction can save us from mistakes and doesn't cost us anything
    while doing so; the assembly generated would be the same as for the first example.
    That's why it's called a zero-cost abstraction. Sometimes C++ allows us to use
    abstractions that actually result in better code than if they were not used. One
    example of a language feature that, when used, could often result in such benefit
    is coroutines from C++20.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的抽象可以帮助我们避免错误，并且在这样做时不会花费我们任何东西；生成的汇编代码与第一个示例相同。这就是为什么它被称为零成本抽象。有时C++允许我们使用抽象，实际上会导致比不使用更好的代码。一个例子是C++20中的协程，当使用时通常会产生这样的好处。
- en: Another great set of abstractions, offered by the standard library, are algorithms.
    Which of the following code snippets do you think is easier to read and easier
    to prove bug-free? Which expresses the intent better?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供的另一组很棒的抽象是算法。以下哪个代码片段你认为更容易阅读和更容易证明没有错误？哪个更好地表达了意图？
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Okay, the second function has a different interface, but even it if was to stay
    the same, we could just create `std::string_view` from the pointer and the length.
    Since it's such a lightweight type, it should be optimized away by your compiler.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，第二个函数有一个不同的接口，但即使它保持不变，我们也可以从指针和长度创建`std::string_view`。由于它是一种轻量级类型，它应该被编译器优化掉。
- en: Using higher-level abstractions leads to simpler, more maintainable code. The
    C++ language has strived to provide zero-cost abstractions since its inception,
    so build upon that instead of redesigning the wheel using lower levels of abstraction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级抽象会导致更简单、更易维护的代码。C++语言自其诞生以来一直致力于提供零成本的抽象，因此应该建立在此基础上，而不是使用更低级别的抽象重新设计轮子。
- en: Speaking of simple and maintainable code, the next section introduces some rules
    and heuristics that are invaluable on the path to writing such code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 说到简单和易维护的代码，接下来的部分介绍了一些在编写这种代码的过程中非常宝贵的规则和启发式方法。
- en: Following the SOLID and DRY principles
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循SOLID和DRY原则
- en: 'There are many principles to keep in mind when writing code. When writing object-oriented
    code, you should be familiar with the quartet of abstraction, encapsulation, inheritance,
    and polymorphism. Regardless of whether your writing C++ in a mostly object-oriented
    programming manner or not, you should keep in mind the principles behind the two
    acronyms: SOLID and DRY.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时要牢记许多原则。在编写面向对象的代码时，你应该熟悉抽象、封装、继承和多态的四个要素。无论你是以大部分面向对象编程的方式编写C++代码，还是以其他方式编写，你都应该牢记这两个首字母缩略词背后的原则：SOLID和DRY。
- en: 'SOLID is a set of practices that can help you write cleaner and less bug-prone
    software. It''s an acronym made from the first letters of the five concepts behind
    it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一组实践，可以帮助你编写更清洁、更少错误的软件。它是由其背后的五个概念的首字母组成的首字母缩略词：
- en: Single responsibility principle
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open-closed principle
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution principle
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则
- en: Interface segregation
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Dependency Inversion
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转
- en: We assume you already have the idea of how those principles relate to object-oriented
    programming, but since C++ is not always object-oriented, let's look at how they
    apply to different areas.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经了解了这些原则与面向对象编程的关系，但由于C++并不总是面向对象的，让我们看看它们如何适用于不同的领域。
- en: Some of the examples use dynamic polymorphism, but the same would apply to static
    polymorphism. If you're writing performance-oriented code (and you probably are
    if you chose C++), you should know that using dynamic polymorphism can be a bad
    idea in terms of performance, especially on the hot path. Further on in the book,
    you'll learn how to write statically polymorphic classes using the **Curiously
    Recurring Template Pattern** (**CRTP**).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例使用了动态多态性，但同样适用于静态多态性。如果你正在编写性能导向的代码（如果你选择了C++，你可能是这样做的），你应该知道使用动态多态性在性能方面可能是一个坏主意，特别是在热路径上。在本书的后面，你将学习如何使用**奇怪的递归模板模式**（**CRTP**）编写静态多态类。
- en: Single responsibility principle
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: In short, the **Single Responsibility Principle** (**SRP**) means each code
    unit should have exactly one responsibility. This means writing functions that
    do one thing only, creating types that are responsible for a single thing, and
    creating higher-level components that are focused on one aspect only.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**单一职责原则**（**SRP**）意味着每个代码单元应该只有一个责任。这意味着编写只做一件事的函数，创建负责一件事的类型，以及创建专注于一个方面的高级组件。
- en: This means that if your class manages some type of resources, such as file handles,
    it should do only that, leaving parsing them, for example, to another type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你的类管理某种资源，比如文件句柄，它应该只做这个，例如，将解析留给另一种类型。
- en: Often, if you see a function with "And" in its name, it's violating the SRP
    and should be refactored. Another sign is when a function has comments indicating
    what each section of the function (sic!) does. Each such section would probably
    be better off as a distinct function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你看到一个函数的名字中有“和”字，它就违反了SRP，应该进行重构。另一个标志是当一个函数有注释指示函数的每个部分（译注：原文中的“section”可能是笔误，应为“function”）做什么。每个这样的部分可能最好作为一个独立的函数。
- en: A related topic is the principle of least knowledge. In its essence, it says
    that no object should know no more than necessary about other objects, so it doesn't
    depend on any of their internals, for example. Applying it leads to more maintainable
    code with fewer interdependencies between components.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的主题是最少知识原则。本质上，它说任何对象都不应该知道关于其他对象的比必要更多的东西，因此它不依赖于它们的内部，例如。应用它会导致更易于维护的代码，组件之间的相互依赖更少。
- en: Open-closed principle
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开闭原则
- en: 'The **Open-Closed Principle** (**OCP**) means that code should be open for
    extension but closed for modification. Open for extension means that we could
    extend the list of types the code supports easily. Closed for modification means
    existing code shouldn''t change, as this can often cause bugs somewhere else in
    the system. A great feature of C++ demonstrating this principle is `operator<<`
    of `ostream`. To extend it so that it supports your custom class, all you need
    to do is to write code similar to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）意味着代码应该对扩展开放但对修改关闭。对扩展开放意味着我们可以轻松地扩展代码支持的类型列表。对修改关闭意味着现有的代码不应该改变，因为这往往会在系统的其他地方引起错误。C++中展示这一原则的一个很好的特性是`ostream`的`operator<<`。要扩展它以支持你的自定义类，你只需要编写类似以下的代码：'
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that our implementation of `operator<<` is a free (non-member) function.
    You should prefer those to member functions if possible as it actually helps encapsulation.
    For more details on this, consult the article by Scott Meyers in the *Further
    reading* section at the end of this chapter. If you don''t want to provide public
    access to some field that you wish to print to `ostream`, you can make `operator<<`
    a friend function, like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对`operator<<`的实现是一个自由（非成员）函数。如果可能的话，你应该更喜欢这些而不是成员函数，因为它实际上有助于封装。有关此更多详细信息，请参阅本章末尾的*进一步阅读*部分中Scott
    Meyers的文章。如果你不想为希望打印到`ostream`的某个字段提供公共访问权限，你可以将`operator<<`设置为友元函数，就像这样：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this definition of OCP is slightly different from the more common
    one related to polymorphism. The latter is about creating base classes that can't
    be modified themselves, but are open for others to inherit from them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个OCP的定义与与多态性相关的更常见的定义略有不同。后者是关于创建不能被修改但可以被继承的基类，但对其他类开放。
- en: Speaking of polymorphism, let's move on to the next principle as it is all about
    using it correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 说到多态性，让我们继续讨论下一个原则，因为它完全是关于正确使用它。
- en: Liskov substitution principle
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: In essence, the **Liskov Substitution Principle** (**LSP**) states that if a
    function works with a pointer or reference to a base object, it must also work
    with a pointer or reference to any of its derived objects. This rule is sometimes
    broken because the techniques we apply in source code do not always work in real-world
    abstractions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，**里氏替换原则**（**LSP**）规定，如果一个函数使用基对象的指针或引用，它也必须使用任何派生对象的指针或引用。这个规则有时会被打破，因为我们在源代码中应用的技术并不总是适用于现实世界的抽象。
- en: 'A famous example is a square and a rectangle. Mathematically speaking, the
    former is a specialization of the latter, so there''s an "is a" relationship from
    one to the other. This tempts us to create a `Square` class that inherits from
    the `Rectangle` class. So, we could end up with code like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的例子是正方形和矩形。从数学上讲，前者是后者的一个特例，所以从一个到另一个有一个“是一个”关系。这引诱我们创建一个从`Rectangle`类继承的`Square`类。因此，我们可能会得到以下代码：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'How should we implement the members of the `Square` class? If we want to follow
    the LSP and save the users of such classes from surprises, we can''t: our square
    would stop being a square if we called `setWidth`. We can either stop having a
    square (not expressible using the preceding code) or modify the height as well,
    thus making the square look different than a rectangle.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何实现`Square`类的成员？如果我们想遵循LSP并避免这些类的用户受到意外的影响，我们不能：如果我们调用`setWidth`，我们的正方形将停止成为正方形。我们可以停止拥有一个正方形（无法使用前面的代码表达）或者修改高度，从而使正方形看起来与矩形不同。
- en: If your code violates the LSP, it's likely that you're using an incorrect abstraction.
    In our case, `Square` shouldn't inherit from `Rectangle` after all. A better approach
    could be making the two implement a `GeometricFigure` interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码违反了LSP，很可能你正在使用一个不正确的抽象。在我们的情况下，`Square`毕竟不应该从`Rectangle`继承。一个更好的方法可能是让这两个实现一个`GeometricFigure`接口。
- en: Since we are on the topic of interfaces, let's move on to the next item, which
    is also related to them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们正在讨论接口，让我们继续讨论下一个与之相关的项目。
- en: Interface segregation principle
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: 'The interface segregation principle is just about what its name suggests. It
    is formulated as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则就是其名字所暗示的。它的表述如下：
- en: No client should be forced to depend on methods that it does not use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 没有客户端应该被强迫依赖它不使用的方法。
- en: That sounds pretty obvious, but it has some connotations that aren't that obvious.
    Firstly, you should prefer more but smaller interfaces to a single big one. Secondly,
    when you're adding a derived class or are extending the functionality of an existing
    one, you should think before you extend the interface the class implements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来非常明显，但它有一些不那么明显的内涵。首先，你应该更喜欢更多但更小的接口而不是一个大的接口。其次，当你添加一个派生类或扩展现有类的功能时，你应该在扩展类实现的接口之前考虑一下。
- en: 'Let''s show this on an example that violates this principle, starting with
    the following interface:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以违反这一原则的一个例子来展示这一点，从以下接口开始：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could have a simple class that implements it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个简单的实现它的类：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far so good. Now say we want to model another, more advanced food processor
    and we recklessly tried to add more methods to our interface:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止还不错。现在假设我们想要模拟另一个更高级的食品加工器，并且我们鲁莽地尝试向我们的接口添加更多方法：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have an issue with the `Blender` class as it doesn''t support this new
    interface – there''s no proper way to implement it. We could try to hack a workaround
    or throw `std::logic_error`, but a much better solution would be to just split
    the interface into two, each with a separate responsibility:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个问题，`Blender`类不支持这个新接口 - 没有适当的方法来实现它。我们可以尝试通过一些变通方法或抛出`std::logic_error`来解决，但更好的解决方案是将接口分成两个，每个负责不同的功能：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now our `AnotherFoodProcessor` can just implement both interfaces, and we don't
    need to change the implementation of our existing food processor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`AnotherFoodProcessor`可以实现两个接口，我们不需要更改现有食品加工器的实现。
- en: We have one last SOLID principle left, so let's learn about it now.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还剩下最后一个SOLID原则，所以现在让我们学习一下。
- en: Dependency inversion principle
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: Dependency inversion is a principle useful for decoupling. In essence, it means
    that high-level modules should not depend on lower-level ones. Instead, both should
    depend on abstractions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖反转是一个有用的解耦原则。实质上，它意味着高级模块不应该依赖于低级模块。相反，两者都应该依赖于抽象。
- en: C++ allows two ways to inverse the dependencies between your classes. The first
    one is the regular, polymorphic approach and the second uses templates. Let's
    see how to apply both of them in practice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许两种方式来反转类之间的依赖关系。第一种是常规的多态方法，第二种使用模板。让我们看看如何在实践中应用这两种方法。
- en: 'Assume you''re modeling a software development project that is supposed to
    have frontend and backend developers. A simple approach would be to write it like
    so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在建模一个软件开发项目，该项目应该有前端和后端开发人员。一个简单的方法是这样写：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each developer is constructed by the `Project` class. This approach is not
    ideal, though, since now the higher-level concept, `Project`, depends on lower-level
    ones – modules for individual developers. Let''s see how applying dependency inversion
    using polymorphism changes this. We can define our developers to depend on an
    interface as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发人员都由`Project`类构建。然而，这种方法并不理想，因为现在更高级的概念`Project`依赖于更低级的模块 - 个别开发人员的模块。让我们看看如何应用多态来应用依赖反转。我们可以定义我们的开发人员依赖于一个接口，如下所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, the `Project` class no longer has to know the implementations of the developers.
    Because of this, it has to accept them as constructor arguments:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Project`类不再需要知道开发人员的实现。因此，它必须将它们作为构造函数参数接受：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this approach, `Project` is decoupled from the concrete implementations and
    instead depends only on the polymorphic interface named `Developer`. The "lower-level"
    concrete classes also depend on this interface. This can help you shorten your
    build time and allows for much easier unit testing – now you can easily pass mocks
    as arguments in your test code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，`Project`与具体实现解耦，而是仅依赖于名为`Developer`的多态接口。"低级"具体类也依赖于这个接口。这可以帮助您缩短构建时间，并且可以更容易进行单元测试
    - 现在您可以在测试代码中轻松地传递模拟对象作为参数。
- en: Using dependency inversion with virtual dispatch comes at a cost, however, as
    now we're dealing with memory allocations and the dynamic dispatch has overhead
    on its own. Sometimes C++ compilers can detect that only one implementation is
    being used for a given interface and will remove the overhead by performing devirtualization
    (often you need to mark the function as `final` for this to work). Here, however,
    two implementations are used, so the cost of dynamic dispatch (commonly implemented
    as jumping through **virtual method tables**, or **vtables** for short) must be
    paid.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖反转和虚拟调度是有成本的，因为现在我们要处理内存分配，动态调度本身也有开销。有时，C++编译器可以检测到对于给定接口只使用了一个实现，并通过执行去虚拟化来消除开销（通常需要将函数标记为`final`才能实现这一点）。然而，在这里，使用了两个实现，因此必须支付动态调度的成本（通常实现为跳转到**虚拟方法表**或**vtables**）。
- en: 'There is another way of inverting dependencies that doesn''t have those drawbacks.
    Let''s see how this can be done using a variadic template, a generic lambda from
    C++14, and `variant`, either from C++17 or a third-party library such as Abseil
    or Boost. First are the developer classes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种反转依赖的方式，它没有这些缺点。让我们看看如何使用可变模板、C++14的通用lambda和`variant`（C++17或第三方库，如Abseil或Boost）来实现这一点。首先是开发人员类：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we don''t rely on an interface anymore, so no virtual dispatch will be
    done. The `Project` class will still accept a vector of `Developers`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再依赖于接口，因此不会进行虚拟调度。`Project`类仍然将接受一个`Developers`的向量：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you're not familiar with `variant`, it's just a class that can hold any of
    the types passed as template parameters. Because we're using a variadic template,
    we can pass however many types we like. To call a function on the object stored
    in the variant, we can either extract it using `std::get` or use `std::visit`
    and a callable object – in our case, the generic lambda. It shows how duck-typing
    looks in practice. Since all our developer classes implement the `develop` function,
    the code will compile and run. If your developer classes would have different
    methods, you could, for instance, create a function object that has overloads
    of `operator()` for different types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`variant`，它只是一个可以容纳模板参数传递的任何类型的类。因为我们使用了可变模板，我们可以传递任意多个类型。要在variant中存储的对象上调用函数，我们可以使用`std::get`来提取它，或者使用`std::visit`和一个可调用对象
    - 在我们的例子中，是通用lambda。它展示了鸭子类型在实践中的样子。由于我们所有的开发人员类都实现了`develop`函数，所以代码将编译并运行。如果您的开发人员类有不同的方法，您可以创建一个函数对象，该对象具有不同类型的`operator()`重载。
- en: 'Because `Project` is now a template, we have to either specify the list of
    types each time we create it or provide a type alias. You can use the final class
    like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Project`现在是一个模板，我们必须每次创建它时要么指定类型列表，要么提供一个类型别名。您可以像这样使用最终类：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach is guaranteed to not allocate separate memory for each developer
    or use a virtual table. However, in some cases, this approach results in less
    extensibility, since once the variant is declared, you cannot add another type
    to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保证不为每个开发人员分配单独的内存，也不使用虚拟表。然而，在某些情况下，这种方法会导致较少的可扩展性，因为一旦声明了变体，就无法向其添加另一种类型。
- en: As the last thing to mention about dependency inversion, we'd like to note that
    there is a similarly named idea called dependency injection, which we even used
    in our examples. It's about injecting the dependencies through constructors or
    setters, which can be beneficial to code testability (think about injecting mock
    objects, for example). There are even whole frameworks for injecting dependencies
    throughout whole applications, such as Boost.DI. Those two concepts are related
    and often used together.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖倒置的最后一点要提到的是，还有一个名为依赖注入的类似概念，我们甚至在我们的例子中使用过。它是关于通过构造函数或设置器注入依赖项，这对于代码的可测试性可能是有益的（例如，考虑注入模拟对象）。甚至有整个框架用于在整个应用程序中注入依赖项，比如Boost.DI。这两个概念是相关的，经常一起使用。
- en: The DRY rule
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY原则
- en: DRY is short for "don't repeat yourself." It means you should avoid code duplication
    and reuse when it's possible. This means you should extract a function or a function
    template when your code repeats similar operations a few times. Also, instead
    of creating several similar types, you should consider writing a template.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DRY是“不要重复自己”的缩写。这意味着在可能的情况下应避免代码重复和重用。这意味着当您的代码多次重复类似操作时，应提取函数或函数模板。此外，您应该考虑编写模板，而不是创建几个类似的类型。
- en: 'It''s also important not to reinvent the wheel when it''s not necessary, that
    is, not to repeat others'' work. Nowadays there are dozens of well-written and
    mature libraries that can help you with writing high-quality software faster.
    We''d like to specifically mention a few of them:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当不必要时，重复造轮子是不重要的，也就是说，不要重复他人的工作。如今有数十个编写高质量软件的成熟库，可以帮助您更快地编写高质量的软件。我们想特别提到其中的一些：
- en: Boost C++ Libraries ([https://www.boost.org/](https://www.boost.org/))
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost C++ Libraries（[https://www.boost.org/](https://www.boost.org/)）
- en: Facebook's Folly ([https://github.com/facebook/folly](https://github.com/facebook/folly))
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook的Folly（[https://github.com/facebook/folly](https://github.com/facebook/folly)）
- en: Electronic Arts' EASTL ([https://github.com/electronicarts/EASTL](https://github.com/electronicarts/EASTL))
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Electronic Arts的EASTL（[https://github.com/electronicarts/EASTL](https://github.com/electronicarts/EASTL)）
- en: Bloomberg's BDE ([https://github.com/bloomberg/bde](https://github.com/bloomberg/bde))
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bloomberg的BDE（[https://github.com/bloomberg/bde](https://github.com/bloomberg/bde)）
- en: Google's Abseil ([https://abseil.io/](https://abseil.io/))
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google的Abseil（[https://abseil.io/](https://abseil.io/)）
- en: The Awesome Cpp list ([https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp))
    with dozens more
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Awesome Cpp列表（[https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp)）还有数十个
- en: Sometimes duplicating code can have its benefits, however. One such scenario
    is developing microservices. Of course, it's always a good idea to follow DRY
    inside a single microservice, but violating the DRY rule for code used in multiple
    services can actually be worth it. Whether we're talking about model entities
    or logic, it's easier to maintain multiple services when code duplication is allowed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时复制代码也有其好处。一个这样的情景是开发微服务。当然，在单个微服务内遵循DRY原则总是一个好主意，但是允许在多个服务中重复代码实际上是值得的。无论是模型实体还是逻辑，允许代码重复可以更容易地维护多个服务。
- en: Imagine having multiple microservices reusing the same code for an entity. Suddenly
    one of them needs to modify one field. All the other services now have to be modified
    as well. The same goes for dependencies of any common code. With dozens or more
    microservices that have to be modified because of changes unrelated to them, it's
    often easier for maintenance to just duplicate the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有多个微服务重用同一实体的相同代码。突然其中一个需要修改一个字段。所有其他服务现在也必须进行修改。对于任何公共代码的依赖也是如此。有数十个或更多微服务因为与它们无关的更改而必须进行修改，通常更容易进行维护，只需复制代码。
- en: Since we're talking about dependencies and maintenance, let's proceed to the
    next section, which discusses a closely related topic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论依赖和维护，让我们继续下一节，讨论一个密切相关的主题。
- en: Coupling and cohesion
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耦合和内聚
- en: Coupling and cohesion are two terms that go hand in hand in software. Let's
    see what each of them means and how they relate to each other.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合和内聚是软件中相互关联的两个术语。让我们看看它们各自的含义以及它们如何相互关联。
- en: Coupling
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 耦合
- en: Coupling is a measure of how strongly one software unit depends on other units.
    A unit with high coupling relies on many other units. The lower the coupling,
    the better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是衡量一个软件单元对其他单元依赖程度的指标。具有高耦合的单元依赖于许多其他单元。耦合越低，越好。
- en: For example, if a class depends on private members of another class, it means
    they're tightly coupled. A change in the second class would probably mean that
    the first one needs to be changed as well, which is why it's not a desirable situation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个类依赖于另一个类的私有成员，这意味着它们耦合紧密。第二个类的更改可能意味着第一个类也需要进行更改，这就是为什么这不是一种理想的情况。
- en: To weaken the coupling in the preceding scenario, we could think about adding
    parameters for the member functions instead of directly accessing other classes'
    private members.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减弱前面情景中的耦合，我们可以考虑为成员函数添加参数，而不是直接访问其他类的私有成员。
- en: 'Another example of tightly coupled classes is the first implementation of the
    `Project` and developer classes in the dependency inversion section. Let''s see
    what would happen if we were to add yet another developer type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个耦合紧密的类的例子是依赖倒置部分中的`Project`和开发人员类的第一个实现。让我们看看如果我们要添加另一种开发人员类型会发生什么：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It looks like instead of just adding the `MiddlewareDeveloper` class, we had
    to modify the public interface of the `Project` class. This means they''re tightly
    coupled and that this implementation of the `Project` class actually breaks the
    OCP. For comparison, let''s now see how the same modification would be applied
    to the implementation using dependency inversion:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，我们不仅仅是添加了`MiddlewareDeveloper`类，而是必须修改了`Project`类的公共接口。这意味着它们耦合度高，并且`Project`类的这种实现实际上违反了OCP。为了对比，现在让我们看看如何将相同的修改应用于使用依赖反转的实现：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'No changes to the `Project` class were required, so now the classes are loosely
    coupled. All we needed to do was to add the `MiddlewareDeveloper` class. Structuring
    our code this way allows for smaller rebuilds, faster development, and easier
    testing, all with less code that''s easier to maintain. To use our new class,
    we only need to modify the calling code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project`类不需要进行任何更改，所以现在这些类是松耦合的。我们需要做的只是添加`MiddlewareDeveloper`类。以这种方式构建我们的代码可以实现更小的重建、更快的开发和更容易的测试，而且代码更少且更易于维护。要使用我们的新类，我们只需要修改调用代码：'
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This shows coupling on a class level. On a larger scale, for instance, between
    two services, the low coupling can be achieved by introducing techniques such
    as message queueing. The services wouldn't then depend on each other directly,
    but just on the message format. If you're having a microservice architecture,
    a common mistake is to have multiple services use the same database. This causes
    coupling between those services as you cannot freely modify the database schema
    without affecting all the microservices that use it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了类级别的耦合。在更大的范围内，例如两个服务之间，通过引入诸如消息队列等技术可以实现低耦合。这样服务就不会直接依赖于彼此，而只依赖于消息格式。如果您使用微服务架构，一个常见的错误是让多个服务使用相同的数据库。这会导致这些服务之间的耦合，因为您不能自由修改数据库架构而不影响使用它的所有微服务。
- en: Let's now move on to cohesion.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向内聚性。
- en: Cohesion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内聚性
- en: Cohesion is a measure of how strongly a software unit's elements are related.
    In a highly cohesive system, the functionality offered by components in the same
    module is strongly related. It feels like such components just belong together.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 内聚性是衡量软件单元元素之间关系强度的指标。在高度内聚的系统中，同一模块中组件提供的功能是强相关的。感觉这样的组件就像是天生一对。
- en: On a class level, the more fields a method manipulates, the more cohesive it
    is to the class. This means that the most commonly spotted low-cohesion data types
    are those big monolithic ones. When there's too much going on in a class, it most
    probably is not cohesive and breaks the SRP, too. This makes such classes hard
    to maintain and bug-prone.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别上，方法操作的字段越多，它对类的内聚性就越高。这意味着最常见的低内聚数据类型是那些庞大的单体类型。当一个类中发生太多事情时，它很可能不是内聚的，也会违反SRP。这使得这样的类难以维护且容易出错。
- en: 'Smaller classes can be incohesive as well. Consider the following example.
    It may seem trivial, but posting real-life scenarios, often hundreds if not thousands
    of lines long, would be impractical:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的类也可能缺乏内聚性。考虑以下例子。这可能看起来微不足道，但发布现实生活中的场景，通常有数百甚至数千行长，是不切实际的：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see that our processor actually does three types of work: the actual
    work, the caching of the results, and managing listeners. A common way to increase
    cohesion in such scenarios is to extract a class or even multiple ones:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的处理器实际上做了三种工作：实际工作、结果的缓存和管理监听器。在这种情况下增加内聚性的常见方法是提取一个类，甚至多个类：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now each part is done by a separate, cohesive entity. Reusing them is now possible
    without much hassle. Even making them a template class should require little work.
    Last but not least, testing such classes should be easier as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个部分都由一个单独的内聚实体完成。现在可以轻松地重用它们。甚至将它们制作成模板类应该也需要很少的工作。最后但并非最不重要的，测试这样的类应该也更容易。
- en: 'Putting this on a component or system level is straightforward – each component,
    service, and system you design should be concise and focus on doing one thing
    and doing it right:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个概念应用到组件或系统级别很简单 - 您设计的每个组件、服务和系统都应该简洁，并专注于做一件事并做到完美：
- en: '![](img/2725a1cd-0ae9-4267-b01e-f71277e83221.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2725a1cd-0ae9-4267-b01e-f71277e83221.png)'
- en: Figure 1.2 – Coupling versus cohesion
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 耦合与内聚
- en: Low cohesion and high coupling are usually associated with software that's difficult
    to test, reuse, maintain, or even understand, so it lacks many of the quality
    attributes usually desired to have in software.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 低内聚和高耦合通常与难以测试、重用、维护甚至理解的软件相关联，因此它缺乏许多通常在软件中期望具有的质量属性。
- en: Those terms often go together because often one trait influences the other,
    regardless of whether the unit we talk about is a function, class, library, service,
    or even a whole system. To give an example, usually, monoliths are highly coupled
    and low cohesive, while distributed services tend to be at the other end of the
    spectrum.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语经常一起出现，因为通常一个特征会影响另一个特征，无论我们谈论的单元是函数、类、库、服务，甚至是整个系统。举个例子，通常来说，单体系统耦合度高，内聚性低，而分布式服务往往处于光谱的另一端。
- en: This concludes our introductory chapter. Let's now summarize what we've learned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的介绍性章节。现在让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed what software architecture is and why it's worth
    caring about it. We've shown what happens when architecture is not updated along
    with the changing requirements and implementation and how to treat architecture
    in an Agile environment. Then we moved on to some core principles of the C++ language.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了软件架构是什么，以及为什么值得关注它。我们展示了当架构没有随着需求和实现的变化而更新时会发生什么，以及如何在敏捷环境中处理架构。然后我们转向了C++语言的一些核心原则。
- en: We learned that many terms from software development can be perceived differently
    in C++ because C++ allows more than writing object-oriented code. Finally, we
    discussed terms such as coupling and cohesion.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，许多软件开发术语在C++中可能有不同的理解，因为C++允许编写面向对象的代码以外的内容。最后，我们讨论了耦合和内聚等术语。
- en: You should now be able to point out many design flaws in code reviews and refactor
    your solutions for greater maintainability, as well as being less bug-prone as
    a developer. You can now design class interfaces that are robust, self-explanatory,
    and complete.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够在代码审查中指出许多设计缺陷，并重构您的解决方案以获得更好的可维护性，以及作为开发人员更少容易出现错误。您现在可以设计健壮、自解释和完整的类接口。
- en: In the next chapter, we will learn about the different architectural approaches
    or styles. We will also learn about how and when we can use them to gain better
    results.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习不同的架构方法或风格。我们还将学习如何以及何时可以使用它们来获得更好的结果。
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why care about software architecture?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要关心软件架构？
- en: Should the architect be the ultimate decision-maker in an Agile team?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敏捷团队中，架构师应该是最终的决策者吗？
- en: How is the SRP related to cohesion?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SRP与内聚性有什么关系？
- en: In what phases of a project's lifetime can it benefit from having an architect?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的生命周期的哪些阶段可以从有架构师受益？
- en: What's the benefit of following the SRP?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循SRP有什么好处？
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Eric Evans, *Domain-Driven Design: Tackling Complexity in the Heart of Software*'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯，《领域驱动设计：应对软件核心的复杂性》
- en: Scott Meyers, *How Non-member Functions Improve Encapsulation*, [https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197](https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 斯科特·迈尔斯，《非成员函数如何改善封装》，[https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197](https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197)
