- en: 7\. Graph Algorithms II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 图算法II
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Describe the inherent problems of Dijkstra's algorithm and demonstrate how it
    can be modified and/or combined with other algorithms to circumvent those issues
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Dijkstra算法的固有问题，并演示如何修改和/或与其他算法结合以规避这些问题
- en: Find the shortest path in a graph using the Bellman-Ford and Johnson's algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用贝尔曼-福特和约翰逊算法在图中找到最短路径
- en: Describe the significance of strongly connected components in a garaph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述图中强连通分量的重要性
- en: Use Kosaraju's algorithm to find strongly connected components in a graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kosaraju算法在图中找到强连通分量
- en: Describe the difference between connectivity in directed and undirected graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述有向图和无向图中连通性的区别
- en: Implement depth-first search for complicated problems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复杂问题的深度优先搜索
- en: Evaluate negative weight cycles in a graph
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估图中的负权重循环
- en: This chapter builds upon the previous chapter by introducing some more advanced
    algorithms for graphs. You will also learn how to deal with negative weights and
    handle the exceptions of negative weight cycles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在上一章的基础上介绍了一些更高级的图算法。你还将学习如何处理负权重，并处理负权重循环的异常情况。
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have explored a variety of common programming structures and paradigms.
    Now, we are going to delve into several techniques that expand on the topics we
    discussed previously, beginning with an assortment of advanced graph problems,
    and then shifting focus toward the expansive subject of dynamic programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了各种常见的编程结构和范式。现在，我们将深入探讨一些扩展我们之前讨论的主题的技术，首先是一系列高级图问题，然后转向动态规划这个广泛的主题。
- en: In this chapter, we will discuss three well-known algorithms, namely the Bellman-Ford
    algorithm, Johnson's algorithm, and Kosaraju's algorithm. All of these algorithms
    share clear similarities with ones we have already covered in this book but extend
    and combine them in various ways to solve potentially complex problems with much
    greater efficiency than suboptimal implementations would allow. In addition to
    learning these specific techniques, this chapter should also increase your general
    familiarity with the use of fundamental graph-related techniques and provide greater
    insight into how those fundamentals can be applied to a diverse range of different
    problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论三种著名的算法，即贝尔曼-福特算法、约翰逊算法和Kosaraju算法。所有这些算法与我们在本书中已经涵盖的算法有明显的相似之处，但它们以各种方式扩展和组合这些算法，以比次优实现更高效地解决潜在复杂的问题。除了学习这些具体的技术，本章还应该增加你对基本图相关技术的一般熟悉度，并提供更深入的洞察力，了解这些基本技术如何应用于不同问题的各种不同范围。
- en: Revisiting the Shortest Path Problem
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视最短路径问题
- en: We previously discussed several ways to find the shortest path between two nodes
    in a graph. We began by exploring the most standard forms of graph traversal,
    namely depth-first search and breadth-first search, and eventually discussed how
    to approach the more problematic case of graphs containing weighted edges. We
    demonstrated how Dijkstra's algorithm could be used to efficiently find the shortest
    distances in weighted graphs by greedily prioritizing each step in the traversal
    according to the best option immediately available. However, despite the improvement
    in performance that Dijkstra's algorithm provides, it is not applicable to every
    situation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了几种在图中找到两个节点之间最短路径的方法。我们首先探讨了最常见的图遍历形式，即深度优先搜索和广度优先搜索，最终讨论了如何处理包含加权边的图的更为棘手的情况。我们演示了如何使用Dijkstra算法来高效地找到加权图中的最短距离，通过贪婪地优先考虑遍历中的每一步，根据当前可用的最佳选项。然而，尽管Dijkstra算法提供了性能的改进，但它并不适用于每种情况。
- en: Consider a Wi-Fi signal that is being broadcast through a network; as it travels
    beyond the point at which it is originally transmitted, its strength is likely
    to be affected by numerous factors, such as the distance it travels and the number
    of walls and other obstacles it must pass through. If you wanted to determine
    the path that the signal will take to each destination that will minimize its
    deterioration, you could create a weighted graph with each point in the network
    represented by a node and the degree of signal loss between any two points represented
    by weighted edges. You could then calculate the shortest distances in the graph
    using Dijkstra's algorithm to determine the least costly paths in the network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个Wi-Fi信号通过网络进行广播；随着信号传播到原始传输点之外，其强度可能会受到许多因素的影响，比如传播距离和必须穿过的墙壁和其他障碍物的数量。如果你想确定信号到达每个目的地的路径，以最小化信号衰减，你可以创建一个加权图，网络中的每个点都由一个节点表示，任意两点之间的信号损失程度由加权边表示。然后，你可以使用Dijkstra算法计算图中的最短距离，以确定网络中成本最低的路径。
- en: Now, suppose that a repeater/booster is installed in the network to increase
    the strength of the signal at a particular point – how might this addition be
    represented in your graph? The most obvious approach would be to set the outgoing
    edge weights from the booster's node to negative values (equivalent to the degree
    by which it increases the signal strength), which would decrease the total distance/deterioration
    of any path passing through it. How might this affect our results if we used Dijkstra's
    algorithm on the network's graph?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设网络中安装了中继器/增强器来增加特定点的信号强度-这种添加可能如何在你的图中表示？最明显的方法是将增强器节点的出边权重设置为负值（相当于它增加信号强度的程度），这将减少通过它的任何路径的总距离/衰减。如果我们在网络图上使用Dijkstra算法，这将如何影响我们的结果？
- en: As we discussed in the previous chapter, Dijkstra's algorithm takes a greedy
    approach in terms of how it selects each vertex in the traversal. At every step,
    it finds the closest unvisited vertex and adds it to the visited set, excluding
    it from further consideration. The assumption that's being made by Dijkstra's
    algorithm is that the shortest path to every vertex that's been considered so
    far has already been found, so searching for better alternatives would be pointless.
    However, in graphs containing negative edge weights, this approach would not explore
    the possibilities that lead to the optimal solution if they produced a higher
    sum in the early stages of the traversal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，Dijkstra算法在选择遍历中的每个顶点时采取了贪婪的方法。在每一步中，它找到最近的未访问的顶点，并将其添加到已访问的集合中，从而排除它不再考虑。Dijkstra算法所做的假设是，到目前为止已经考虑的每个顶点的最短路径已经被找到，因此寻找更好的替代方案是没有意义的。然而，在包含负边权的图中，这种方法不会探索导致最佳解决方案的可能性，如果它们在遍历的早期阶段产生了更高的总和。
- en: 'Consider a graph with a negative edge weight, as shown in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个带有负边权的图，如下图所示：
- en: '![Figure 7.1: Applying Dijkstra''s algorithm to a graph with a negative weight'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：将Dijkstra算法应用于带有负权的图
- en: '](img/C14498_07_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_01.jpg)'
- en: 'Figure 7.1: Applying Dijkstra''s algorithm to a graph with a negative weight'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.1：将Dijkstra算法应用于带有负权的图
- en: 'In the preceding figure, the path that''s traversed by Dijkstra''s algorithm
    is indicated in red. Assuming we start at vertex A, there will be two potential
    options after the first move from node *A* to node *B*: *B —> C*, which has an
    edge weight of *5*, and *B —> D*, which has an edge weight of *10*. Because of
    Dijkstra''s greedy approach, *C* will be chosen as the next node in the shortest
    path, but we can clearly see that the other option (*B —> D —> C = 10 + –7 = 3*)
    is actually the optimal choice.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，Dijkstra算法遍历的路径用红色表示。假设我们从顶点A开始，第一次从节点*A*到节点*B*移动后，将有两个潜在的选择：*B —> C*，边权为*5*，和*B
    —> D*，边权为*10*。由于Dijkstra的贪婪方法，*C*将被选择为最短路径的下一个节点，但我们可以清楚地看到另一个选择（*B —> D —> C
    = 10 + -7 = 3*）实际上是最佳选择。
- en: When faced with negative edge weights, the inherent optimizations in Dijkstra's
    algorithm that enable its high level of efficiency ultimately lead to its downfall.
    Thankfully, for such graphs, we can employ an alternative approach that is quite
    similar to Dijkstra's algorithm and arguably simpler to implement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 面对负边权时，Dijkstra算法中固有的优化最终导致了它的失败。幸运的是，对于这样的图，我们可以采用一种类似于Dijkstra算法的替代方法，实现起来可能更简单。
- en: The Bellman-Ford Algorithm
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bellman-Ford算法
- en: We can use the **Bellman-Ford algorithm** to handle graphs with negative weights.
    It replaces Dijkstra's method of greedy selection with an alternative approach
    of iterating across every edge in the graph *V – 1* times (where *V* is equal
    to the total number of vertices) and finding progressively optimal distance values
    from the source node across each iteration. Naturally, this gives it a higher
    asymptotic complexity than Dijkstra's algorithm, but it also allows it to produce
    correct results for graphs that Dijkstra's algorithm would misinterpret. The following
    exercise shows how to implement the Bellman-Ford algorithm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**Bellman-Ford算法**来处理带有负权的图。它用图中每条边的替代方法替换了Dijkstra的贪婪选择方法，需要在图中迭代*V-1*次（其中*V*等于顶点的总数），并在每次迭代中找到从源节点到目的节点的逐渐最优距离值。这自然使其具有比Dijkstra算法更高的渐近复杂度，但也使其能够为Dijkstra算法会误解的图产生正确的结果。下面的练习展示了如何实现Bellman-Ford算法。
- en: 'Exercise 32: Implementing the Bellman-Ford Algorithm (Part I)'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习32：实现Bellman-Ford算法（第一部分）
- en: 'In this exercise, we will work with the basic Bellman-Ford algorithm to find
    the shortest distance in a graph with negative weights. Let''s get started:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用基本的Bellman-Ford算法来找到带有负权的图中的最短距离。让我们开始吧：
- en: 'First, set up your code by including the necessary libraries (as well as the
    `namespace std` for convenience):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过包括必要的库（以及为了方便起见，`namespace std`）来设置您的代码：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s begin by defining a representation of the edges in our graph, which
    will require three variables: the source node''s index, the destination node''s
    index, and the cost of traversing between them:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义图中边的表示，这将需要三个变量：源节点的索引、目的节点的索引和它们之间的遍历成本：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To implement the Bellman-Ford algorithm, we will need to have some representation
    of our graph. For the sake of simplicity, let''s assume that our graph can be
    represented by an integer, `V`, the total number of vertices in the graph, and
    a vector, `edges` (a collection of pointers to ''edge'' objects that define the
    graph''s adjacencies). Let''s also define an integer constant, `UNKNOWN`, which
    we can set to some arbitrary high value that will always be greater than the sum
    of any subset of edge weights in the graph (the `INT_MAX` constant defined in
    `climits` works well for this purpose):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现Bellman-Ford算法，我们需要对图进行一些表示。为了简单起见，让我们假设我们的图可以用一个整数`V`来表示，表示图中顶点的总数，以及一个向量`edges`（指向定义图的邻接的'edge'对象的指针集合）。让我们还定义一个整数常量`UNKNOWN`，我们可以将其设置为某个始终大于图中任何边权子集的总和的任意高值（在`climits`中定义的`INT_MAX`常量很适合这个目的）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s also write some code for collecting the graph''s data as user input:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也编写一些代码来收集图的数据作为用户输入：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can start implementing the Bellman-Ford algorithm itself. For our purposes,
    let''s create a function called `BellmanFord()` that takes one argument – `start`
    (the starting node from which we want to find the shortest paths in the graph)
    – and returns `void`. Then, we will define a distance array of size `V`, with
    every element initialized to `UNKNOWN` except for the starting node, whose index
    is initialized to `0`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现贝尔曼-福特算法本身。为了我们的目的，让我们创建一个名为`BellmanFord()`的函数，它接受一个参数`start`（我们要在图中找到最短路径的起始节点）并返回`void`。然后，我们将定义一个大小为`V`的距离数组，其中每个元素都初始化为`UNKNOWN`，除了起始节点，其索引初始化为`0`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The bulk of the work is done in the next step, where we define a loop that
    lasts for `V – 1` iterations and iterates through the entire set of edges on every
    repetition. For each edge, we check to see whether its source node''s current
    distance value is not equal to `UNKNOWN` (which, in the first iteration, only
    applies to the starting node). Assuming this is true, we then compare the current
    distance value of its destination node to the sum of the source node''s distance
    with the weight of the edge. If the result of adding the edge weight to the current
    node''s distance is less than the stored distance of the destination node, we
    replace its value in the distance array with the new sum:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分工作是在下一步完成的，在那里我们定义一个持续`V-1`次迭代并在每次重复中遍历整个边集的循环。对于每条边，我们检查其源节点的当前距离值是否不等于`UNKNOWN`（在第一次迭代中，这仅适用于起始节点）。假设这是真的，然后我们将其目标节点的当前距离值与边的权重与源节点的距离的总和进行比较。如果将边权重添加到当前节点的距离的结果小于目标节点的存储距离，则用新的总和替换距离数组中的值：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the end of our function, we can now iterate through the `distance` array
    and output the shortest distances from the source to every other node in the graph:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数结束时，我们现在可以遍历`distance`数组并输出从源到图中每个其他节点的最短距离：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can return to our `main()` method and make a call to our newly implemented
    `BellmanFord()` function. Let''s test our implementation on the example graph
    from *figure 7.1*. To do so, we should run our code and enter the following input:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以返回到我们的`main()`方法，并调用我们新实现的`BellmanFord()`函数。让我们在*图7.1*中的示例图上测试我们的实现。为此，我们应该运行我们的代码并输入以下输入：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our program should output the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序应该输出以下内容：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, Bellman-Ford avoids the trap that would lead Dijkstra's algorithm
    to evaluate the shortest paths incorrectly. However, there is still another significant
    problem to contend with, which we will discuss in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，贝尔曼-福特避免了导致狄克斯特拉算法错误评估最短路径的陷阱。然而，仍然存在另一个重要的问题需要解决，我们将在下一节中讨论。
- en: The Bellman-Ford Algorithm (Part II) – Negative Weight Cycles
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贝尔曼-福特算法（第二部分）-负权重循环
- en: 'Consider the graph shown in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下图中显示的图形：
- en: '![](img/C14498_07_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_07_02.jpg)'
- en: 'Figure 7.2: Graph with a negative weight cycle'
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.2：带有负权重循环的图
- en: The edges highlighted in red indicate a negative weight cycle or a cycle in
    the graph where the combined edge weights produce a negative sum. In such a situation,
    this cycle would be considered repeatedly, and the final results would be skewed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用红色突出显示的边表示负权重循环或图中产生负和的组合边权重的循环。在这种情况下，将重复考虑此循环，并且最终结果将被扭曲。
- en: For the sake of comparison, consider a graph with only positive edge weights.
    A cycle in such a graph would never be considered in the solution because the
    shortest distance to the first node in the cycle would have been found already.
    To demonstrate this, imagine that the edge weight between nodes *B* and *D* in
    the preceding figure is positive. Starting from node *A*, the first iteration
    through the edges would determine that the shortest distance to node *B* is equal
    to *3*. After two more iterations, we would also know the shortest distance from
    *A* to *C* (*A —> B —> D —> C*), which is equal to *14* (*3 + 8 + 3*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，考虑一个仅具有正边权重的图。在这样的图中，循环永远不会被考虑在解决方案中，因为已经找到了到循环中第一个节点的最短距离。为了证明这一点，想象一下在前面的图中节点*B*和*D*之间的边权重是正的。从节点*A*开始，通过边的第一次迭代将确定到节点*B*的最短距离等于*3*。再经过两次迭代，我们还将知道从*A*到*C*的最短距离（*A—>B—>D—>C*），它等于*14*（*3+8+3*）。
- en: Obviously, no positive number can be added to 14 that will produce a sum of
    less than 3\. As there can be at most *| V – 1 |* steps in any graph traversal
    where each node is visited only once, we can be certain that *| V – 1 |* iterations
    through the graph's edges are sufficient to determine every possible shortest
    distance. By extension, we can conclude that the only way an even shorter path
    can exist after *| V – 1 |* iterations is if a node is revisited and the edge
    weight leading to it is negative. Thus, the final step of the Bellman-Ford algorithm
    consists of performing one more iteration through the edges to check for the existence
    of such cycles.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，无法将任何正数添加到14中，以产生小于3的总和。在任何图遍历中最多可以有*| V-1 |*步骤，其中每个节点仅访问一次，我们可以确定*| V-1
    |*次迭代足以确定每个可能的最短距离。通过推论，我们可以得出结论，在*| V-1 |*次迭代后，唯一可能存在更短路径的方式是如果重新访问节点并且导致它的边权重为负。因此，贝尔曼-福特算法的最后一步包括通过边执行一次迭代以检查是否存在这样的循环。
- en: 'We can accomplish this with the same logic we used to find the shortest paths:
    by checking whether the sum of each edge''s weight with the distance value of
    its source node is less than the currently stored distance to its destination
    node. If a shorter path is found during this step, we terminate the algorithm
    and report the existence of a negative cycle.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过与找到最短路径时使用的相同逻辑来实现这一点：通过检查每条边的权重与其源节点的距离值的总和是否小于其目标节点的当前存储距离。如果在此步骤中找到了更短的路径，则终止算法并报告存在负循环。
- en: We will explore this implementation of the algorithm in the following exercise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中探讨该算法的实现。
- en: 'Exercise 33: Implementing the Bellman-Ford Algorithm (Part II)'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习33：实现贝尔曼-福特算法（第二部分）
- en: 'In this exercise, we will modify the implementation in *Exercise 32*, *Implementing
    the Bellman-Ford Algorithm (Part I)*, to deal with a graph with negative weight
    cycles. Let''s get started:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改*练习32*中的实现，*实现贝尔曼-福特算法（第一部分）*，以处理具有负权重循环的图。让我们开始吧：
- en: 'We can essentially copy our code from the previous step verbatim. However,
    this time, we will replace the code under the condition that determines whether
    a shorter path has been found with some sort of output indicating that the graph
    contains a negative cycle, thus rendering it invalid:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们基本上可以直接从上一步复制我们的代码。但是，这次，我们将用某种输出替换在确定是否找到了更短路径的条件下的代码，指示图包含负循环，从而使其无效：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we can still find a path shorter than the one we have already found, the
    graph must contain a negative cycle. Let''s check for a negative weight cycle
    with the following `if` statement:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们仍然可以找到比我们已经找到的路径更短的路径，则图必须包含负循环。让我们用以下`if`语句检查负权重循环：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s insert this block of code in-between the end of the first `for`
    loop and the first output line:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这段代码块插入到第一个`for`循环结束和第一行输出之间：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To test the logic we''ve added, let''s run the algorithm on the following input:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们添加的逻辑，让我们在以下输入上运行算法：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our program should output the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序应输出以下内容：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Activity 15: Greedy Robot'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：贪婪机器人
- en: You are developing a pathfinding robot that must find the most efficient path
    through an obstacle course. For testing purposes, you have designed several courses,
    each in the shape of a square grid. Your robot is able to traverse any obstacle
    it encounters, but this also requires a greater expenditure of power. Assuming
    your robot starts in the top-left corner of the grid and can move in any of the
    four cardinal directions (north, south, east, and west), you must implement an
    algorithm that determines the maximum amount of energy your robot can finish the
    course with.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在开发一款寻路机器人，必须找到通过障碍课程的最有效路径。为了测试目的，您设计了几个课程，每个课程都是一个方形网格。您的机器人能够穿越遇到的任何障碍，但这也需要更多的能量消耗。假设您的机器人从网格的左上角开始，并且可以沿着四个基本方向（北、南、东、西）移动，您必须实现一个算法，确定您的机器人可以以最大能量完成课程的数量。
- en: Since the amount of energy that's required to perform this traversal can be
    high, you have interspersed power stations throughout the grid, which your robot
    has the capability of using to recharge itself. Unfortunately, it appears that
    your robot is quite greedy in terms of energy consumption – if it can reach an
    energy station multiple times without having to backtrack, it will continually
    return to the same location until it inevitably overcharges and explodes! Because
    of this, you will need to predict whether your robot will end up revisiting a
    power station and abort the traversal attempt before disaster ensues.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行此遍历所需的能量可能很高，您已经在整个网格中间插入了充电站，您的机器人有能力使用这些充电站来充电。不幸的是，您的机器人在能源消耗方面非常贪婪-如果它可以在不必回头的情况下多次到达一个能源站，它将不断返回到相同的位置，直到最终过度充电并爆炸！因此，您需要预测您的机器人是否会重新访问一个充电站，并在灾难发生之前中止遍历尝试。
- en: '**Input**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: The first line contains a single integer, `N`, which is the height and width
    of the course.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含一个整数`N`，即课程的高度和宽度。
- en: The next `N``2` `- 1` lines each contain the `directions` string and an integer
    called `power`. Each set of `N` lines corresponds to a single row, beginning from
    the top of the grid, where each cell's data is defined from left to right (for
    example, in a *3 x 3* grid, *0 —> [0, 0], 1 —> [0, 1], 2 —> [0, 2], 3 —> [1, 0],
    4 —> [1, 1]*, and so on).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的`N``2` `- 1`行每行包含`directions`字符串和称为`power`的整数。每组`N`行对应于单行，从网格的顶部开始，每个单元格的数据从左到右定义（例如，在*3
    x 3*网格中，*0 —> [0, 0], 1 —> [0, 1], 2 —> [0, 2], 3 —> [1, 0], 4 —> [1, 1]*，依此类推）。
- en: '`directions` contains 0-3 characters from the set { ''`N`'', ''`S`'', ''`E`'',
    ''`W`'' }, which represent the cells that your robot can visit from each point.
    Thus, if the `directions` string is `SW`, then the robot can move south or west
    from that point. `power` represents the energy expenditure required to cross the
    cell. Positive values for `power` indicate that a charging station is located
    within the cell.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “directions”包含来自集合{ '`N`'，'`S`'，'`E`'，'`W`' }的0-3个字符，它们代表您的机器人可以从每个点访问的单元格。因此，如果“directions”字符串是“SW”，则机器人可以从该点向南或向西移动。`power`表示穿过单元格所需的能量消耗。`power`的正值表示充电站位于单元格内。
- en: '**Output**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: If traversing the course causes the robot to explode, print a single line –
    `TRAVERSAL ABORTED`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遍历课程导致机器人爆炸，请打印一行- `遍历中止`。
- en: Otherwise, print the maximum amount of energy your robot can have upon reaching
    the bottom-right cell of the course, relative to the amount of energy it started
    with. For example, if the robot can finish the maze with 10 more units of energy
    than it started with, print `10`; if it finishes the maze with 10 fewer units
    of energy than it started with, print `-10`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，打印出机器人在到达课程的右下角时可以拥有的最大能量，相对于它开始时的能量。例如，如果机器人可以比开始时多10个能量单位完成迷宫，则打印`10`；如果它完成迷宫时比开始时少10个能量单位，则打印`-10`。
- en: '**Example**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**例子**'
- en: 'Let''s say we had the following input:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下输入：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The grid''s layout would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的布局如下：
- en: '![Figure 7.3: Grid for the robot''s traversal'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：机器人遍历的网格'
- en: '](img/C14498_07_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_03.jpg)'
- en: 'Figure 7.3: Grid for the robot''s traversal'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.3：机器人遍历的网格
- en: 'The path that reaches the bottom-right cell with the most energy is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 达到右下角单元格的路径如下：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Therefore, your program should output `11`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的程序应输出`11`。
- en: '**Test Cases**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**'
- en: 'The following test cases should help you understand this problem better:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试用例应帮助您更好地理解这个问题：
- en: '![Figure 7.4: Test case 1 for Activity 15'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：活动15的测试用例1'
- en: '](img/C14498_07_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_04.jpg)'
- en: 'Figure 7.4: Test case 1 for Activity 15'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：活动15的测试案例1
- en: '![Figure 7.5: Test case 2 for Activity 15'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：活动15的测试案例2'
- en: '](img/C14498_07_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_05.jpg)'
- en: 'Figure 7.5: Test case 2 for Activity 15'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：活动15的测试案例2
- en: '![Figure 7.6: Test case 3 for Activity 15'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：活动15的测试案例3'
- en: '](img/C14498_07_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_06.jpg)'
- en: 'Figure 7.6: Test case 3 for Activity 15'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.6：活动15的测试案例3
- en: '![Figure 7.7: Test case 4 for Activity 15'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：活动15的测试案例4'
- en: '](img/C14498_07_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_07.jpg)'
- en: 'Figure 7.7: Test case 4 for Activity 15'
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：活动15的测试案例4
- en: '![Figure 7.8: Test case 5 for Activity 15'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：活动15的测试案例5'
- en: '](img/C14498_07_08.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_08.jpg)'
- en: 'Figure 7.8: Test case 5 for Activity 15'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：活动15的测试案例5
- en: '**Activity Guidelines**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: No algorithms beyond what was covered in *Exercise 33*, *Implementing the Bellman-Ford
    Algorithm (Part II)*, are required.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要超出*练习33*，*实现贝尔曼-福特算法（第二部分）*中涵盖的算法。
- en: You may need to reinterpret some of the input so that it corresponds to the
    actual problem you are trying to solve.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要重新解释一些输入，以使其与您试图解决的实际问题相对应。
- en: There is no need to represent the grid as two-dimensional.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需将网格表示为二维。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 537.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第537页找到。
- en: We have now established that Bellman-Ford is more versatile than Dijkstra's
    algorithm since it possesses the capability to produce correct solutions in cases
    where Dijkstra's algorithm would yield incorrect results. However, if the graph
    we are considering does not contain any negative edge weights, Dijkstra's algorithm
    is the obvious choice between the two due to the potentially significant efficiency
    advantages afforded by its greedy approach. Now, we will explore how Bellman-Ford
    can be used in conjunction with Dijkstra's algorithm so that it can be used for
    graphs with negative weights.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经确定贝尔曼-福特比迪杰斯特拉算法更加灵活，因为它具有在迪杰斯特拉算法产生错误结果的情况下产生正确解决方案的能力。然而，如果我们考虑的图中不包含任何负边权，那么在这两者之间显然应选择迪杰斯特拉算法，因为其贪婪方法可能带来的潜在效率优势。现在，我们将探讨如何将贝尔曼-福特算法与迪杰斯特拉算法结合使用，以便用于具有负权重的图。
- en: Johnson's Algorithm
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约翰逊算法
- en: Having compared the relative merits and disadvantages of the Bellman-Ford algorithm
    and Dijkstra's algorithm, we will now discuss an algorithm that combines both
    of them to retrieve the shortest paths between every pair of vertices in a graph.
    **Johnson's algorithm** provides us with the advantage of being able to utilize
    the efficiency of Dijkstra's algorithm while still producing correct results for
    graphs with negative edge weights.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较了贝尔曼-福特算法和迪杰斯特拉算法的相对优点和缺点之后，我们现在将讨论一种将它们两者结合起来以检索图中每对顶点之间的最短路径的算法。**约翰逊算法**为我们提供了利用迪杰斯特拉算法的效率，同时为具有负边权的图产生正确结果的优势。
- en: The concept behind Johnson's algorithm is quite novel – to contend with Dijkstra's
    limitations when dealing with negative weights, Johnson's algorithm simply reweights
    the edges in the graph so they are uniformly non-negative. This is accomplished
    with the rather creative use of Bellman-Ford combined with some particularly elegant
    mathematical logic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰逊算法的概念非常新颖 - 为了应对迪杰斯特拉处理负权重时的局限性，约翰逊算法简单地重新调整图中的边，使它们统一为非负数。这是通过贝尔曼-福特算法与一些特别优雅的数学逻辑相结合而实现的。
- en: The first step in Johnson's algorithm is to add a new 'dummy' vertex to the
    graph, which is subsequently connected to every other vertex by zero-weighted
    edges. Bellman-Ford is then used to find the shortest paths between the new vertex
    and the rest, and the distances are stored for later use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰逊算法的第一步是向图中添加一个新的“虚拟”顶点，然后通过权重为零的边将其连接到其他每个顶点。然后使用贝尔曼-福特算法找到新顶点与其余顶点之间的最短路径，并将距离存储以备后用。
- en: 'Consider the implications of the addition of this new vertex: because it has
    a 0-weighted edge connecting it to every other node in the graph, none of its
    shortest path distances will ever be positive. Furthermore, its connectivity to
    every node in the graph ensures that its distance values maintain a constant relation
    across all the potential traversal paths, which causes the sum that''s formed
    by these values and their corresponding edge weights to ''telescope'', in other
    words, subsequent terms in the sequence cancel each other out, making the summation
    equivalent to the difference of the first and last terms. Take a look at the following
    figure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑添加这个新顶点的影响：因为它与图中每个其他节点都有一条权重为0的边相连，所以它的最短路径距离永远不会是正数。此外，它与图中每个节点的连接确保了它的距离值在所有潜在遍历路径上保持恒定的关系，这导致这些值及其相应边权重形成的总和“望远镜”，换句话说，序列中的后续项互相抵消，使总和等同于第一项和最后一项的差。看一下下面的图：
- en: '![Figure 7.9: Applying Johnson''s algorithm on a graph with negative weights'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：在具有负权重的图上应用约翰逊算法'
- en: '](img/C14498_07_09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_09.jpg)'
- en: 'Figure 7.9: Applying Johnson''s algorithm on a graph with negative weights'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：在具有负权重的图上应用约翰逊算法
- en: In the preceding graph, the diamond-shaped node labeled `S` represents the dummy
    vertex, the black parenthesized numbers represent edge weights, the red text represents
    the shortest paths from `S` to each node, the orange arrows represent the optimal
    paths traversed from `S`, and the blue arrows represent 0-weighted edges branching
    from `S` that are not included in any of `S`'s shortest paths.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，标有`S`的菱形节点代表虚拟顶点，黑色括号中的数字代表边权重，红色文本代表从`S`到每个节点的最短路径，橙色箭头代表从`S`遍历的最佳路径，蓝色箭头代表从`S`分支出的权重为0的边，这些边不包括在任何`S`的最短路径中。
- en: 'Let''s take the new distance values and arrange them in a sequence according
    to their appearance in this traversal of the graph – `A --> B --> C --> A -->
    D --> E`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新的距离值按照它们在图的遍历中的出现顺序排列成一个序列 - `A --> B --> C --> A --> D --> E`：
- en: '![Figure 7.10: Distance for traversing at each node'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：在每个节点遍历的距离'
- en: '](img/C14498_07_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_10.jpg)'
- en: 'Figure 7.10: Distance for traversing at each node'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：每个节点遍历的距离
- en: 'If we insert the original edge weights in-between the distance values of the
    nodes they connect to, the sequence will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将原始边权重插入到它们连接的节点的距离值之间，序列将如下所示：
- en: '![Figure 7.11: Calculating the distance that''s been traversed'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11：计算已经遍历的距离'
- en: '](img/C14498_07_11.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_11.jpg)'
- en: 'Figure 7.11: Calculating the distance that''s been traversed'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：计算已经遍历的距离
- en: 'Now, let''s apply the following formula to the edge values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下公式应用于边值：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `w(uv)` represents the original edge weight between nodes `u` and `v`,
    `d[s, u]` and `d[s, v]` represent the shortest path distances between `S` and
    `u/v`, and `W(uv)` represents the transformed edge weight values. Applying this
    formula yields the following result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`w(uv)`表示节点`u`和`v`之间的原始边权重，`d[s, u]`和`d[s, v]`表示`S`和`u/v`之间的最短路径距离，`W(uv)`表示转换后的边权重值。应用这个公式得到以下结果：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice how the third term in the expression is always canceled out by the middle
    term in subsequent iterations; this demonstrates the "telescoping" property of
    the formula. Because of this property, the following two expressions representing
    the distance between node A and E are equivalent:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表达式中的第三项总是在后续迭代中被中间项抵消；这展示了公式的“折叠”特性。由于这个特性，表示节点A和E之间距离的以下两个表达式是等价的：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This implies that the amount of weight being added to any path in the graph
    is equal to the amount of weight being added to its subpaths. We know that the
    results of adding these values will always be non-negative because the distance
    array that's returned by Bellman-Ford ensures that we have `d[s, u] + weight(u,
    v) >= d[s, v]` for any pair, `u,v`. Thus, the value of `w(u, v) + d[s, u] - d[s,
    v]` can never be less than 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在图中任何路径上添加的权重量等于添加到其子路径的权重量。我们知道，由于Bellman-Ford返回的距离数组确保对于任何一对`u,v`，我们有`d[s,
    u] + weight(u, v) >= d[s, v]`，因此这些值的相加结果总是非负的。因此，`w(u, v) + d[s, u] - d[s, v]`的值永远不会小于0。
- en: As a result of the applied transformation, each edge that will be traversed
    in any shortest path in the graph will be reweighted to zero, which leaves us
    with non-negative weight values that, quite remarkably, have still retained their
    original shortest path orderings! We can now perform Dijkstra's algorithm on the
    graph using these new weight values to efficiently retrieve the shortest paths
    for every pair of nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用了转换，图中任何最短路径中将要遍历的每条边都将被重新加权为零，这使我们得到了非负的权重值，而且令人惊讶的是，它们仍然保留了原始的最短路径顺序！现在我们可以使用这些新的权重值在图上执行Dijkstra算法，以高效地检索每对节点的最短路径。
- en: We will explore the implementation of Johnson's algorithm in the following exercise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中探讨Johnson的算法的实现。
- en: 'Exercise 34: Implementing Johnson''s Algorithm'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习34：实现Johnson的算法
- en: 'In this exercise, we will implement Johnson''s algorithm to find the shortest
    distance from each node to every other node in a graph with negative weights.
    Let''s get started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现Johnson的算法，以找到具有负权重的图中每个节点到其他每个节点的最短距离。让我们开始吧：
- en: 'We can reuse most of our code from the previous exercise, including our `Edge`
    structure, `UNKNOWN` constant, and graph data:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以重用前一个练习中的大部分代码，包括我们的`Edge`结构，`UNKNOWN`常量和图数据：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We should modify our function declaration for Bellman-Ford so that it accepts
    two arguments (an integer, `V`, and a vector or `Edge` pointers, `edges`) and
    returns an integer vector. We can also remove the `start` parameter:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该修改Bellman-Ford的函数声明，使其接受两个参数（一个整数`V`和一个`Edge`指针的向量`edges`），并返回一个整数向量。我们还可以删除`start`参数：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will begin by adding the dummy vertex, `S`, to the graph. Because `S` essentially
    has no influence on the rest of the graph, this is as simple as increasing the
    distance array''s size to *| V + 1 |* and adding an edge between `S` and every
    other node:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先向图中添加虚拟顶点`S`。因为`S`实际上对图的其余部分没有影响，所以这只是简单地增加距离数组的大小到*| V + 1 |*并在`S`和每个其他节点之间添加一条边：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We proceed to apply the standard implementation of Bellman-Ford to the modified
    graph, using `S` as the source node:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续将Bellman-Ford的标准实现应用于修改后的图，使用`S`作为源节点：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This time, let''s move the final check for negative cycles into its own function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，让我们将负循环的最终检查移到自己的函数中：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can call it at the end of the original function and return an empty
    array if a negative cycle is found:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在原始函数的末尾调用它，如果发现负循环，则返回一个空数组：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After ensuring that the graph has no negative cycles, we can return the resultant
    set of distance values to the calling function and apply the reweighting formula
    to every edge in the graph. But first, let''s implement Dijkstra''s algorithm:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确保图中没有负循环之后，我们可以将结果距离值集返回给调用函数，并对图中的每条边应用重新加权公式。但首先，让我们实现Dijkstra的算法：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s declare an integer vector, `distance`, and a Boolean vector, `visited`.
    As usual, every index of `distance` will be initialized to `UNKNOWN` (except for
    the starting vertex), and every index of `visited` will be initialized to false:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们声明一个整数向量`distance`和一个布尔向量`visited`。通常情况下，`distance`的每个索引都将初始化为`UNKNOWN`（除了起始顶点），`visited`的每个索引都将初始化为false：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our implementation of Dijkstra''s algorithm will utilize a simple iterative
    approach using a `for` loop. As you may recall from earlier chapters, Dijkstra''s
    algorithm needs to find the node with the minimum distance value at each step
    in the traversal. While this is often done via a priority queue, we will accomplish
    this by coding another short function, `GetMinDistance()`, which will take the
    distance and visited arrays as arguments and return the index of the node with
    the shortest path value:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Dijkstra算法实现将利用一个简单的迭代方法，使用`for`循环。正如你可能还记得的，Dijkstra算法需要在遍历的每一步中找到具有最小距离值的节点。虽然通常是通过优先队列来实现这一点，但我们将通过编写另一个短函数`GetMinDistance()`来实现这一点，该函数将以距离和访问数组作为参数，并返回具有最短路径值的节点的索引：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now finish implementing Dijkstra''s algorithm:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成实现Dijkstra算法：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have everything we need to perform Johnson''s algorithm. Let''s declare
    a new function, `Johnson()`, which also takes `V` and `edges` as arguments:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了执行Johnson算法所需的一切。让我们声明一个新函数`Johnson()`，它也将以`V`和`edges`作为参数：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We start by creating an integer vector, `h`, and setting it to the output of
    `BellmanFord()`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个整数向量`h`，并将其设置为`BellmanFord()`的输出：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We check whether `h` is empty. If it is, we terminate the function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`h`是否为空。如果是，我们终止函数：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Otherwise, we apply the reweighting formula:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们应用重新加权公式：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To store the shortest path distances for every pair of nodes, we initialize
    a matrix with `V` rows (so that each pair of two-dimensional indices, `[i, j]`,
    represents the shortest path between vertex `i` and vertex `j`). We then perform
    `V` calls to Dijkstra''s algorithm, which returns the `distance` array for each
    starting node:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储每对节点的最短路径距离，我们初始化一个具有`V`行的矩阵（这样每对二维索引`[i, j]`表示顶点`i`和顶点`j`之间的最短路径）。然后我们对Dijkstra算法进行`V`次调用，它返回每个起始节点的`distance`数组：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unsurprisingly, the results we have accumulated in this step are quite inaccurate.
    Every distance value is now positive as a result of our reweighting operation.
    However, this can be rectified quite simply by applying the same formula to each
    result in reverse:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们在这一步积累的结果相当不准确。由于我们的重新加权操作，现在每个距离值都是正的。然而，这可以通过将相同的公式逆向应用于每个结果来很简单地纠正：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s return to our `main()` function and implement the code for handling
    input. After we have collected the edges of the input graph, we simply need to
    perform a single call to `Johnson()` and our work is done:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`main()`函数并实现处理输入的代码。在我们收集了输入图的边之后，我们只需要对`Johnson()`进行一次调用，我们的工作就完成了：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s test our algorithm using the following input:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下输入来测试我们的算法：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output should be as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the preceding output, we have successfully printed the shortest
    distance from each node to every other node.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，我们已成功打印了从每个节点到其他每个节点的最短距离。
- en: 'Activity 16: Randomized Graph Statistics'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动16：随机图统计
- en: You are a developer at a well-known software company that receives a high volume
    of new job applicants every year. As such, it is a requirement for every employee
    to participate in the process of conducting technical interviews. Before every
    interview, you are given a set of three programming problems, each containing
    a short description, and two to three test cases of increasing difficulty.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一家知名软件公司的开发人员，每年都会接收大量的新求职者。因此，每个员工都必须参与进行技术面试的过程。在每次面试之前，你会得到一组三个编程问题，每个问题包含一个简短的描述，以及两到三个不断增加难度的测试用例。
- en: It was recently brought to your attention that a number of interviewees managed
    to acquire the test cases for certain interview questions in advance. As a result,
    the powers that be have called on you to create new sets of test cases every couple
    of weeks. Producing decent test cases for most problems is not particularly challenging,
    except for questions concerning graph theory. You have noticed that the process
    of designing a graph that is both valid and relevant to the problem can be a bit
    time-consuming, so you have become determined to automate the process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最近有人向你提出，一些面试者事先获得了某些面试问题的测试用例。因此，有关方面要求你每隔几周就创建新的测试用例集。对大多数问题产生合理的测试用例并不特别具有挑战性，除了涉及图论的问题。你已经注意到设计一个既有效又与问题相关的图的过程可能有点耗时，因此你已决定自动化这个过程。
- en: 'The most common graph-related interview question your company uses is the all-pairs
    shortest path problem, which requires the interviewee to find the shortest distances
    between every pair of vertices in a directed graph with weighted edges. Because
    of the nature of this problem, you want the graphs that are produced by your generator
    utility to be useful in assessing the interviewees'' understanding of the problem.
    You''ve decided that a graph will be useful for technical interviews if it meets
    the following criteria:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你的公司最常见的与图相关的面试问题是全对最短路径问题，这要求面试者找到有向加权边图中每对顶点之间的最短距离。由于这个问题的性质，你希望生成的图对于评估面试者对问题的理解是有用的。你决定如果一个图符合以下标准，它将对技术面试有用：
- en: It is a directed graph that can contain both positive and negative edge weights.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个有向图，可以包含正边权和负边权。
- en: There should only be one edge between any pair of nodes, and no node should
    have an edge to itself.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一对节点之间应该只有一条边，且没有节点应该有指向自身的边。
- en: Every node should have at least one incoming or outgoing edge.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点应至少有一条入边或出边。
- en: The absolute value of any edge weight should be less than 100.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何边权的绝对值应小于100。
- en: 'The utility should take the following inputs:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序应接受以下输入：
- en: '`seed`: A seed value for random number generation'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed`：用于随机数生成的种子值'
- en: '`iterations`: The number of graphs to generate'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterations`：要生成的图的数量'
- en: '`V`: The number of vertices'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V`：顶点的数量'
- en: '`E`: The number of edges'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`：边的数量'
- en: The utility should handle the generation of every edge using calls to `std::rand()`.
    In the event that it attempts to create a second edge between the same pair of
    nodes, it should stop generating new edges until a valid pair is found.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具应该使用对`std::rand()`的调用来处理每条边的生成。如果它尝试在相同节点对之间创建第二条边，则应停止生成新的边，直到找到有效的节点对。
- en: 'Graph generation should be done as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图的生成应按以下方式进行：
- en: 1.  Receive input (`seed`, `iterations`, `V`, and `E`)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 接收输入（`seed`，`iterations`，`V`和`E`）
- en: 2.  Set the random number generator's seed value
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 设置随机数生成器的种子值
- en: '3  For each iteration, do the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 对于每次迭代，执行以下操作：
- en: Set `i = 0`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将i设置为0
- en: - Attempt to create an edge by performing three calls to `rand()` in order to
    generate the values for the source node, destination node, and edge weight (in
    that order).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '- 尝试通过执行三次`rand()`调用来创建边，以生成源节点、目标节点和边权值（按顺序）的值。'
- en: - Check whether the next value that's generated by `rand()` is evenly divisible
    by `3;` if so, make the edge weight negative.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '- 检查`rand()`生成的下一个值是否能被`3`整除；如果可以，使边权值为负数。'
- en: 'If an edge between the source and destination nodes already exists, try again:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源节点和目标节点之间已经存在一条边，请重试：
- en: - Add `edge(source, destination, weight)` to the set of edges and increment
    `i`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '- 将`edge(source, destination, weight)`添加到边集合中并递增`i`。'
- en: - If after `E` edges have been created there is a node that is not part of an
    edge, the graph is considered invalid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果创建了`E`条边后存在一个不属于任何边的节点，则认为图无效。'
- en: If the generated graph is valid, you should find the shortest paths between
    every pair of nodes in the graph, as we would be expected to do during an interview.
    For each node in the graph, you want to find the average shortest distance across
    all of its paths (that is, the sum of distance values divided by the number of
    reachable nodes). The average distance of the graph will be defined as the average
    of these values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成的图是有效的，您应该找到图中每对节点之间的最短路径，就像我们在面试中所期望的那样。对于图中的每个节点，您希望找到其所有路径的平均最短距离（即距离值之和除以可到达节点的数量）。图的平均距离将被定义为这些值的平均值。
- en: You are also interested in which sets of values tend to produce the greatest
    number of "interesting" graphs. You consider graphs to be interesting when the
    average distance of the graph is less than half of that of the highest-valued
    edge weight. Your algorithm should, therefore, output the ratio of interesting
    graphs to the total number of valid graphs as a percentage (rounded to two decimal
    places). Note that for this particular purpose, you consider a connected graph
    with negative weight cycles to be valid but not interesting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您还对哪些值集合倾向于产生最多“有趣”的图感兴趣。当图的平均距离小于最高边权值的一半时，您认为图是有趣的。因此，您的算法应该输出有趣图与有效图的比率（以百分比显示并四舍五入到两位小数）。请注意，对于这个特定目的，您认为具有负权重环的连通图是有效但不是有趣的。
- en: '**Input Format**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入格式**'
- en: One line containing four integers; that is, `seed`, `iterations`, `V`, and `E`,
    respectively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 包含四个整数的一行；即`seed`，`iterations`，`V`和`E`。
- en: '**Output Format**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出格式**'
- en: Two lines, the first containing the `INVALID:` string, followed by the number
    of invalid graphs, and the second containing the `PERCENT INTERESTING:` string,
    followed by the ratio of interesting to valid graphs, displayed as a percentage
    rounded to two decimal places.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 两行，第一行包含`INVALID:`字符串，后面是无效图的数量，第二行包含`PERCENT INTERESTING:`字符串，后面是有趣图与有效图的比率，以百分比显示并四舍五入到两位小数。
- en: '**Activity Guidelines**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: 'Calls to `std::rand()` will not necessarily produce the same value in every
    environment. To ensure consistency, you can copy/paste the following code into
    your program (taken from the C standard):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对`std::rand()`的调用在每个环境中不一定会产生相同的值。为了确保一致性，您可以将以下代码复制/粘贴到您的程序中（取自C标准）：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When implementing the graph generation utility, make sure that the steps are
    followed in the exact order described in the problem description.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现图生成工具时，请确保按照问题描述中的确切顺序进行步骤。
- en: '**Test Cases**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**'
- en: 'Here are some sample inputs and outputs that should help you understand the
    problem better:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例输入和输出，应该帮助您更好地理解问题：
- en: '![Figure 7.12: Test cases for Activity 16'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12：活动16的测试用例'
- en: '](img/C14498_07_12.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_12.jpg)'
- en: 'Figure 7.12: Test cases for Activity 16'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：活动16的测试用例
- en: Note
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 541.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第541页找到。
- en: Strongly Connected Components
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强连通分量
- en: In the previous chapters, we discussed several classifications of graphs. Among
    the most common ways of describing the characteristics of a graph is stating whether
    it is directed or undirected. The latter defines graphs in which the edges are
    bidirectional by default (if node A has an edge connecting to node B, then node
    B has an edge connecting to node A), while the former describes graphs with edges
    oriented toward specific 'directions'.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了图的几种分类。描述图特征的最常见方式之一是说明它是有向的还是无向的。后者定义了边默认是双向的图（如果节点A有一条连接到节点B的边，则节点B也有一条连接到节点A的边），而前者描述了具有定向边的图。
- en: Imagine you are an employee for a video hosting website and are tasked with
    producing statistics about commonalities between subscribers to various channels.
    Your company is particularly interested in discovering patterns between the individuals
    who subscribe to certain channels and the subscriptions of the channels' respective
    owners, hoping to gain greater insight into how their targeted advertising service
    should be directed. The service your company provides has become rather expansive
    recently, so you need a method of organizing the relevant data in a way that is
    clear enough to produce useful statistical information.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一个视频托管网站的员工，负责制作关于各个频道订阅者之间共同点的统计数据。你的公司特别希望发现订阅某些频道的个人与频道所有者的订阅之间的模式，希望更深入地了解他们的定向广告服务应该如何定位。你的公司提供的服务最近变得相当广泛，因此你需要一种方法来以清晰的方式组织相关数据，以产生有用的统计信息。
- en: Let's visualize the channels of every user of the site as nodes in a directed
    graph, with the adjacencies between them representing the other channel's respective
    owner that they're subscribed to. We would likely notice that even among large
    groups of users that share subscriptions to the same channels, the amount of diversity
    in all of their individual sets of subscriptions would greatly complicate our
    ability to find any distinguishing similarities between them. Ideally, we would
    want to untangle the massive jumble of connections in our graph and place the
    data into distinct groups in which every user's subscriptions are somehow related
    to the other users'.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将网站每个用户的频道视为定向图中的节点，它们之间的邻接表示他们订阅的其他频道的所有者。我们可能会注意到，即使在订阅相同频道的大群用户中，所有个人订阅集合的多样性也会极大地复杂化我们找到它们之间的任何区别相似性的能力。理想情况下，我们希望解开图中庞大的连接混乱，并将数据放入明确的组中，其中每个用户的订阅与其他用户的订阅有某种关联。
- en: We can unravel the complexity of this particular problem by observing certain
    characteristics that are common to directed graphs. Because the edges of a directed
    graph are not guaranteed to be bidirectional, we can logically conclude that access
    to certain parts of the graph could potentially be restricted depending on which
    node you start traversing from. If you were to divide a graph into distinct sets
    so that any pair of vertices in the same set has a connective path between them,
    the resulting groups would represent the graph's strongly connected components.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过观察定向图的某些共同特征来解开这个特定问题的复杂性。因为定向图的边不一定是双向的，我们可以逻辑推断出，取决于从哪个节点开始遍历，对图的某些部分的访问可能会受到限制。如果你将一个图分成不同的集合，使得同一集合中的任意一对顶点之间都有连接路径，那么得到的组将代表图的强连通分量。
- en: Connectivity in Directed and Undirected Graphs
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定向图和无向图中的连通性
- en: An undirected graph's connected components can be described as the set of maximum-sized
    subgraphs comprising the primary graph in which every node within the same group
    is 'connected' to the others (that is, access between any two nodes in a single
    component is unrestricted). In a connected graph, every node can be reached, regardless
    of where a traversal begins, so we can deduce that such graphs consist of a single
    connected component (the entire graph). Conversely, any graph that has restricted
    access from one point to another is described as disconnected.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图的连通分量可以描述为主图中包括每个节点的最大子图的集合，其中同一组内的每个节点都与其他节点“连接”（即，单个分量内任意两个节点之间的访问是无限制的）。在一个连通图中，无论遍历从哪里开始，每个节点都可以被访问，因此我们可以推断出这样的图由单个连通分量（整个图）组成。相反，任何具有从一点到另一点受限制访问的图被描述为不连通。
- en: 'So-called ''strong'' connectivity, on the other hand, is a characteristic that''s
    exclusive to directed graphs. To comparatively understand the difference in terms
    of how ''strong connectivity'' is defined, observe the following example of an
    undirected graph:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，所谓的“强”连通性是定向图所特有的特征。为了相对地理解“强连通性”的定义上的差异，观察以下无向图的例子：
- en: '![](img/C14498_07_13.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_07_13.jpg)'
- en: 'Figure 7.13: Graph with different connected components'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：具有不同连通分量的图
- en: The three colored subgraphs each represent a separate connected component. As
    we stated previously, their connectivity is defined by the fact that every vertex
    has a path connecting it to the others within the same group. Furthermore, no
    vertex from one component has a path that connects it to a different component.
    From the preceding figure, we can see that the connected components of an undirected
    graph are divided into distinctly separate groups, where the sets of nodes and
    edges of any component are cut off completely from the others.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 三个彩色子图分别代表一个独立的连通分量。正如我们之前所述，它们的连通性是由每个顶点都与同一组内的其他顶点有路径连接这一事实所定义的。此外，来自一个分量的任何顶点都没有与不同分量连接的路径。从前面的图中，我们可以看到无向图的连通分量被划分为完全独立的组，其中任何分量的节点和边都与其他分量完全隔离。
- en: 'Strongly connected components, by contrast, don''t need to be completely isolated
    from the other components in the graph – that is to say, paths can exist that
    overlap between components:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，强连通分量不需要完全与图中的其他分量隔离 - 也就是说，可以存在在分量之间重叠的路径：
- en: '![Figure 7.14: Graph with different strongly connected components'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：具有不同强连通分量的图'
- en: '](img/C14498_07_14.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/C14498_07_14.jpg)'
- en: 'Figure 7.14: Graph with different strongly connected components'
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：具有不同强连通分量的图
- en: 'In the preceding figure, we can see that there are four strongly connected
    components: *A*, *B*, *CEFG*, and *DHI*. Notice that nodes *A* and *B* are the
    only members in their respective sets. By investigating node *A* further, we can
    see that though *A* has a path to every node in the *DHI* set, none of the nodes
    in set *DHI* have any path leading to node *A*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到有四个强连通分量：*A*，*B*，*CEFG*和*DHI*。请注意，节点*A*和*B*是它们各自集合中唯一的成员。通过进一步研究节点*A*，我们可以看到，尽管*A*与*DHI*集合中的每个节点都有路径，但*DHI*集合中的节点没有任何通往节点*A*的路径。
- en: 'Returning to our video hosting website example, we could define the network
    graph''s strongly connected components as groups in which every channel can be
    found by navigating through the ''path'' of subscriptions associated with other
    users'' channels within the same group. Breaking apart the potentially vast amount
    of data in this way could potentially help in isolating relevant sets of graph
    relations from those that have no distinguishing similarities:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的视频托管网站示例，我们可以将网络图的强连通分量定义为组，其中每个频道都可以通过在同一组内与其他用户频道的订阅路径中找到。以这种方式分解潜在的大量数据可能有助于从没有区别相似性的图关系中隔离出相关的图关系集：
- en: '![Figure 7.15: Example dataset represented as a graph with different strongly
    connected components'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15：将不同强连通分量表示为图的示例数据集'
- en: '](img/C14498_07_15.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_15.jpg)'
- en: 'Figure 7.15: Example dataset represented as a graph with different strongly
    connected components'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：将不同强连通分量表示为图的示例数据集
- en: Kosaraju's Algorithm
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kosaraju's Algorithm
- en: One of the most common and conceptually easy to grasp methods of finding the
    strongly connected components of a graph is Kosaraju's algorithm. Kosaraju's algorithm
    works by performing two independent sets of DFS traversals, first exploring the
    graph in its original form, and then doing the same with its transpose.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 找到图的强连通分量最常见且概念上容易理解的方法之一是Kosaraju算法。Kosaraju算法通过执行两组独立的DFS遍历来工作，首先探索原始形式的图，然后对其进行转置。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Though DFS is the type of traversal typically used in Kosaraju's algorithm,
    BFS is also a viable option. For the explanations and exercises included in this
    chapter, however, we will stick with the traditional DFS-based approach.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管DFS是Kosaraju算法中通常使用的遍历类型，但BFS也是一个可行的选择。然而，在本章中包括的解释和练习中，我们将坚持传统的基于DFS的方法。
- en: 'The transpose of a graph is essentially identical to the original graph, except
    that the source/destination vertices in each of its edges are swapped (that is,
    if there is an edge from node *A* to node *B* in the original graph, the transposed
    graph will have an edge from node *B* to node *A*):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图的转置与原始图本质上相同，只是其每条边中的源/目标顶点被交换（也就是说，如果原始图中有一条从节点*A*到节点*B*的边，转置图中将有一条从节点*B*到节点*A*的边）：
- en: '![Figure 7.16: Transpose of a graph'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16：图的转置'
- en: '](img/C14498_07_16.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_16.jpg)'
- en: 'Figure 7.16: Transpose of a graph'
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：图的转置
- en: The first step of the algorithm (after initialization) is to iterate through
    the vertices of the graph and perform a DFS traversal, starting from each node
    that has not yet been visited in a previous traversal. At the beginning of each
    point in the DFS, the current node is marked as visited, and then all of its unvisited
    neighbors are explored. After each current node's adjacencies have been investigated,
    it is added to the top of a stack before the current recursive subtree is terminated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一步（初始化后）是遍历图的顶点并执行DFS遍历，从尚未在先前遍历中访问过的每个节点开始。在DFS的每个点开始时，当前节点被标记为已访问，然后探索其所有未访问的邻居。在调查完每个当前节点的邻接点之后，它被添加到栈的顶部，然后当前递归子树被终止。
- en: After exploring every vertex in the original graph, the same is done with its
    transpose, starting from each unvisited node, which is popped from the top of
    the stack. At this point, the set of nodes that are encountered during each subsequent
    DFS traversal with a unique starting point represents a strongly connected component
    of the graph.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索原始图中的每个顶点之后，从栈的顶部弹出的每个未访问节点也会在其转置中执行相同的操作。在这一点上，每次以唯一起点进行的后续DFS遍历遇到的节点集合代表了图的一个强连通分量。
- en: Kosaraju's algorithm is quite effective in terms of how it intuitively simplifies
    a potentially complex problem, reducing it into something rather straightforward
    to implement. Additionally, assuming that the input graph has an adjacency list
    representation, it is also quite efficient since it has a linear asymptotic complexity
    of *O(V + E)*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju算法在直观上简化了一个潜在复杂的问题，将其简化为相当容易实现的东西，因此在效率上也是相当高效的，假设输入图具有邻接表表示，它的渐近复杂度也是线性的*O(V
    + E)*。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The use of adjacency matrices with this algorithm is not recommended due to
    the significant amount of additional iterations required to find the neighbors
    of each vertex in the traversal.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在遍历中需要大量额外的迭代来查找每个顶点的邻居，因此不建议使用此算法的邻接矩阵。
- en: We will take a look at the implementation of Kosarju's algorithm in the following
    exercise.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的练习中看一下Kosarju算法的实现。
- en: 'Exercise 35: Implementing Kosaraju''s Algorithm'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习35：实现Kosaraju算法
- en: 'In this exercise, we will find the strongly connected components in a graph
    using Kosaraju''s algorithm. Let''s get started:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Kosaraju算法找到图中的强连通分量。让我们开始吧：
- en: 'For our implementation of Kosaraju''s algorithm, we will need to include the
    following headers:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们实现Kosaraju算法，我们需要包括以下头文件：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s define a function called `Kosaraju()` that takes two arguments – an
    integer, `V`, (the number of vertices) and a vector of integer vectors, `adj`
    (an adjacency list representation of the graph) – and returns a vector of integer
    vectors representing the set of node indices in each strongly connected component
    of the input graph:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`Kosaraju()`的函数，它接受两个参数 - 一个整数`V`（顶点的数量），一个整数向量的向量`adj`（图的邻接表表示） -
    并返回一个整数向量的向量，表示输入图的每个强连通分量中的节点索引集合：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our first step is to declare our stack container and visited array (with every
    index initialized to `false`). We then iterate through each node of the graph,
    beginning our DFS traversals at every index that has not yet been marked as `visited`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是声明我们的堆栈容器和访问数组（每个索引都初始化为`false`）。然后我们遍历图的每个节点，从尚未标记为`visited`的每个索引开始我们的DFS遍历：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our first DFS function, `FillStack()`, takes four arguments: an integer node
    (the index of the vertex at the current point in the traversal), a Boolean vector
    called `visited` (the set of nodes that were previously traversed), and two integer
    vectors, `adj` (the graph''s adjacency list) and `stack` (a list of visited node
    indices, ordered according to when they were explored). The last three arguments
    will be passed by reference from the calling function. The DFS is implemented
    in the standard way, except with an additional step in which the current node''s
    index is pushed to the stack at the end of each function call:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个DFS函数`FillStack()`接受四个参数：一个整数节点（遍历中当前点的顶点索引），一个名为`visited`的布尔向量（先前遍历的节点集），以及两个整数向量`adj`（图的邻接表）和`stack`（按照探索顺序排列的已访问节点索引列表）。最后三个参数将从调用函数中传递引用。DFS是以标准方式实现的，除了在每个函数调用结束时将当前节点的索引推送到堆栈的附加步骤：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s define another function, `Transpose()`, which takes the parameters
    of the original graph as arguments and returns an adjacency list of its transpose:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义另一个名为`Transpose()`的函数，它接受原始图的参数，并返回其转置的邻接表：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In preparation for the next set of traversals, we declare the adjacency list
    transpose (initialized to the output of our `Transpose()` function) and reinitialize
    our visited array to `false`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了准备下一组遍历，我们声明了邻接表转置（初始化为我们的`Transpose()`函数的输出），并重新将我们的访问数组初始化为`false`：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the second half of our algorithm, we will need to define our second DFS
    function, `CollectConnectedComponents()`, which takes the same arguments as `FillStack()`,
    except the fourth parameter is now replaced with a reference to an integer vector
    component. This vector component is where we will store the node indices of each
    strongly connected component in the graph. The implementation of the traversal
    is also almost identical to the `FillStack()` function, except we remove the line
    that pushes nodes to the stack. Instead, we include a line at the beginning of
    the function that collects the traversed nodes in the component vector:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的算法的第二部分，我们需要定义我们的第二个DFS函数`CollectConnectedComponents()`，它与`FillStack()`接受相同的参数，除了第四个参数现在被替换为整数向量组件的引用。这个向量组件是我们将在图中存储每个强连通分量的节点索引的地方。遍历的实现也几乎与`FillStack()`函数相同，除了我们删除将节点推入堆栈的行。相反，我们在函数的开头包含一行，将遍历的节点收集到组件向量中：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Returning to our `Kosaraju()` function, we define a vector of integer vectors
    called `connectedComponents`, which is where we will store the result of each
    traversal we perform on the transpose. We then iteratively pop elements from the
    stack in a `while` loop, once again beginning each DFS traversal exclusively from
    unvisited nodes. Before each call to the DFS function, we declare the component
    vector that is referenced by `CollectConnectedComponents()` and then push it to
    `connectedComponents` upon completion of the traversal. The algorithm is complete
    when the stack is empty, after which we return `connectedComponents`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`Kosaraju()`函数，我们定义了一个称为`connectedComponents`的整数向量的向量，这是我们将存储在转置上执行的每次遍历的结果的地方。然后，我们在`while`循环中迭代地从堆栈中弹出元素，再次从未访问的节点开始每次DFS遍历。在每次调用DFS函数之前，我们声明由`CollectConnectedComponents()`引用的组件向量，然后在遍历完成后将其推送到`connectedComponents`。当堆栈为空时，算法完成，之后我们返回`connectedComponents`：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'From our `main()` function, we can now output the results of each strongly
    connected component by printing the values of each vector on a separate line:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的`main()`函数中，我们现在可以通过在单独的行上打印每个向量的值来输出每个强连通分量的结果：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To test the functionality of our newly implemented algorithm, let''s create
    an adjacency list representation based on the following graph:![Figure 7.17: Graphical
    representation of sample input data'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们新实现的算法的功能，让我们基于以下图创建一个邻接表表示：![图7.17：示例输入数据的图形表示
- en: '](img/C14498_07_17.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_17.jpg)'
- en: 'Figure 7.17: Graphical representation of sample input data'
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.17：示例输入数据的图形表示
- en: 'In `main()`, `V` and `adj` would be defined as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，`V`和`adj`将被定义如下：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Upon executing our program, the following output should be displayed:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们的程序后，应该显示以下输出：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Activity 17: Maze-Teleportation Game'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：迷宫传送游戏
- en: You are designing a game where multiple players are placed randomly in a maze
    of rooms. Each room contains one or more teleportation devices that the players
    can use to travel between different parts of the maze. Every teleporter has a
    value associated with it, which is added to any player's score who uses it. Players
    alternately take turns traversing the maze until every room has been visited at
    least once, at which point the round ends and the player with the lowest score
    is the winner.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在设计一个游戏，其中多个玩家随机放置在一个迷宫的房间中。每个房间都包含一个或多个传送装置，玩家可以使用它们在迷宫的不同部分之间旅行。每个传送装置都有一个与之关联的值，这个值将被添加到使用它的任何玩家的得分中。玩家轮流穿越迷宫，直到每个房间至少被访问一次为止，然后回合结束，得分最低的玩家获胜。
- en: You have implemented a system that procedurally generates a new maze at the
    beginning of every game. Unfortunately, you recently discovered that some of the
    generated mazes contained loops that a player could use to endlessly reduce their
    score. You also noticed that players frequently had an unfair advantage, depending
    on the room they started in. Worst of all, the teleporters are often dispersed
    in such a way that a player can end up being cut off from the rest of the maze
    for the duration of the round.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经实施了一个系统，在每场比赛开始时会程序生成一个新的迷宫。不幸的是，您最近发现一些生成的迷宫包含了玩家可以使用的循环，无限降低他们的得分。您还注意到玩家经常根据他们所在的房间拥有不公平的优势。最糟糕的是，传送门经常分散在这样的方式，以至于玩家最终可能被隔离在迷宫的某个部分，持续一轮比赛。
- en: You want to implement a testing procedure to make sure that the generated maze
    is fair and properly balanced. Your test should first determine whether the maze
    contains a path that can be used to endlessly lower a player's score. If so, it
    should output `INVALID MAZE`. If the maze is valid, you should find the lowest
    scores that can be achieved from each starting point and report them (or `DEAD
    END`, in the case of a room that has no teleporter).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望实施一个测试程序，以确保生成的迷宫是公平且平衡的。您的测试应该首先确定迷宫是否包含可用于无限降低玩家得分的路径。如果是，它应该输出“INVALID
    MAZE”。如果迷宫有效，您应该找到可以从每个起点获得的最低分数并报告它们（或在没有传送门的房间的情况下报告“DEAD END”）。
- en: Additionally, you would like to prevent the possibility of getting stuck in
    a particular section of the maze, and so your test should also output any groups
    of rooms from which players are unable to access other portions of the maze.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您希望防止在迷宫的特定部分中被困住的可能性，因此您的测试还应输出玩家无法访问迷宫其他部分的任何房间组。
- en: '**Expected Input**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输入**'
- en: 'Each test should receive the following input:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试应该接收以下输入：
- en: The number of rooms in the maze
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷宫中的房间数量
- en: The number of teleporters in the maze
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷宫中的传送门数量
- en: The source room, destination room, and the number of points associated with
    each teleporter
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源房间、目标房间以及与每个传送门相关联的点数
- en: '**Expected Output**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**'
- en: 'For each test, the program should first determine whether there are any paths
    in the maze that can be used to infinitely reduce a player''s score. If so, it
    should print a single line: `INVALID MAZE`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试，程序应首先确定迷宫中是否存在可以用于无限降低玩家得分的路径。如果是，它应该打印一行：“INVALID MAZE”。
- en: If the maze is valid, your program should output the lowest score that can be
    achieved, starting from each room (or `DEAD END`, if the room does not have a
    teleporter), assuming that at least one move is made and that the entire maze
    can only be traversed once. Finally, your program should list any groups of rooms
    in which players can get 'stuck' (that is, they are completely restricted from
    accessing other parts of the maze); for every such group, your program should
    print the indices of all the rooms within each one on a separate line.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迷宫有效，您的程序应输出可以从每个房间开始实现的最低分数（或在房间没有传送门的情况下输出“DEAD END”），假设至少进行一次移动并且整个迷宫只能遍历一次。最后，您的程序应列出玩家可能被“困住”的房间组（即，他们完全无法访问迷宫的其他部分）；对于每个这样的组，您的程序应在单独的行上打印每个房间的索引。
- en: '**Sample Input and Output**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**样本输入和输出**'
- en: 'Here are a few sample inputs that should help you understand this problem better:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些样本输入，应该帮助您更好地理解这个问题：
- en: '![Figure 7.18: Test case 1 for Activity 17'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.18：活动17的测试用例1'
- en: '](img/C14498_07_18.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_18.jpg)'
- en: 'Figure 7.18: Test case 1 for Activity 17'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.18：活动17的测试用例1
- en: '![Figure 7.19: Test case 2 for Activity 17'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19：活动17的测试用例2'
- en: '](img/C14498_07_19.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_19.jpg)'
- en: 'Figure 7.19: Test case 2 for Activity 17'
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.19：活动17的测试用例2
- en: '![Figure 7.20: Test case 3 for Activity 17'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20：活动17的测试用例3'
- en: '](img/C14498_07_20.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_20.jpg)'
- en: 'Figure 7.20: Test case 3 for Activity 17'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.20：活动17的测试用例3
- en: '![Figure 7.21: Test case 4 for Activity 17'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21：活动17的测试用例4'
- en: '](img/C14498_07_21.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_21.jpg)'
- en: 'Figure 7.21: Test case 4 for Activity 17'
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.21：活动17的测试用例4
- en: '![Figure 7.22: Test case 5 for Activity 17'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22：活动17的测试用例5'
- en: '](img/C14498_07_22.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_22.jpg)'
- en: 'Figure 7.22: Test case 5 for Activity 17'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.22：活动17的测试用例5
- en: '![Figure 7.23: Test case 6 for Activity 3'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.23：活动3的测试用例6'
- en: '](img/C14498_07_23a.jpg)![Figure 7.23: Test case 6 for Activity 17'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_23a.jpg)![图7.23：活动17的测试用例6'
- en: '](img/C14498_07_23b.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_23b.jpg)'
- en: 'Figure 7.23: Test case 6 for Activity 17'
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.23：活动17的测试用例6
- en: '![Figure 7.24: Test case 7 for Activity 17'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24：活动17的测试用例7'
- en: '](img/C14498_07_24.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_07_24.jpg)'
- en: 'Figure 7.24: Test case 7 for Activity 17'
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.24：活动17的测试用例7
- en: '**Activity Guidelines**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: Do not get distracted by irrelevant information. Ask yourself what specifically
    needs to be accomplished.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要被无关的信息分散注意力。问问自己需要完成什么具体任务。
- en: 'The first condition of the problem (determining whether or not the maze contains
    a path that can infinitely reduce our score) can also be expressed as follows:
    if the maze is represented as a weighted graph, does a cycle exist on any path
    that produces a negative sum? Clearly, this is a problem we are well-equipped
    to handle! You probably also recognize that the second condition (finding the
    minimum scores that can be acquired by a player starting at a given point) is
    closely related to the first.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题的第一个条件（确定迷宫是否包含可以无限降低我们得分的路径）也可以表述为：如果将迷宫表示为加权图，是否存在任何产生负总和的路径上的循环？显然，这是我们有能力处理的问题！您可能还意识到第二个条件（找到可以从给定点开始获得的最低分数）与第一个条件密切相关。
- en: The last condition is a bit more challenging. Consider how you might redefine
    being "stuck" in a section of the maze according to the graph terminology we have
    discussed in this chapter. What might a maze with this property look like?
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个条件有点更具挑战性。考虑如何根据我们在本章讨论过的图术语重新定义在迷宫的某个部分被“困住”的情况。具有这种属性的迷宫会是什么样子？
- en: Consider drawing one or several of the input graphs on paper. What characterizes
    the groups of rooms in which a player can get stuck?
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在纸上绘制一个或多个输入图。什么特征表征了玩家可能被困的房间组？
- en: Note
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 550.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第550页找到。
- en: Choosing the Right Approach
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的方法
- en: By now, it is probably apparent that there is rarely a single 'perfect' approach
    to implementing graph structures. The characteristics of the data we are representing,
    combined with the details of the problem we are trying to solve, can make certain
    approaches unreasonably inefficient, despite the fact that they may be perfectly
    acceptable under different sets of conditions.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显很少有单一的“完美”图结构实现方法。我们所代表的数据的特征，加上我们试图解决的问题的细节，可能会使某些方法在不同条件下变得不合理低效。
- en: Whenever you are trying to determine whether to use adjacency lists versus matrices,
    classes/structs versus simple arrays, Bellman-Ford versus Johnson's algorithm,
    BFS versus DFS, and so on, the final decision should be primarily dependent upon
    the specifics of the data and how you intend to use it. For example, if you want
    to find the shortest distances between every pair of nodes in a graph, Johnson's
    algorithm would be an excellent choice. However, if you only need to sporadically
    find the shortest distances for a single starting node, Johnson's algorithm would
    perform quite a bit of unnecessary work, whereas a single call to Bellman-Ford
    would be sufficient.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您试图确定是使用邻接表还是矩阵，类/结构还是简单数组，贝尔曼-福特还是约翰逊算法，BFS还是DFS等，最终决定应主要取决于数据的具体情况以及您打算如何使用它。例如，如果您想要在图中的每对节点之间找到最短距离，约翰逊算法将是一个很好的选择。然而，如果您只需要偶尔为单个起始节点找到最短距离，约翰逊算法将执行相当多不必要的工作，而一次贝尔曼-福特的调用就足够了。
- en: It is a beneficial exercise to try writing each of the algorithms we've discussed
    in this chapter using different forms of graph representations. For example, Bellman-Ford
    can be just as easily implemented by replacing the vector of `Edge` pointers that
    we used in the first exercise with an adjacency list and a two-dimensional matrix
    of edge weights. In some cases, the efficiency potential that's offered by one
    implementation may only be marginally better than another; at other times, the
    difference can be quite significant. And then, sometimes, the value of a certain
    approach has more to do with simplicity and readability than any measurable performance
    benchmark. Comparing how the performance of various algorithms scales across different
    data sets and scenarios can be very informative and is often an essential practice
    in real-world development.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同形式的图表示来编写我们在本章讨论过的每个算法是一种有益的练习。例如，贝尔曼-福特可以通过用邻接表和边权重的二维矩阵替换我们在第一个练习中使用的`Edge`指针向量来轻松实现。在某些情况下，一个实现所提供的效率潜力可能只比另一个略好一些；而在其他时候，差异可能相当显著。有时，某种方法的价值更多地与简单性和可读性有关，而不是任何可衡量的性能基准。比较各种算法在不同数据集和场景中的性能扩展如何，通常是真实开发中的一个重要实践。
- en: 'In your endeavors to develop a better understanding of graph theory and implementation,
    we offer the following recommendations:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在努力发展对图论和实现的更好理解时，我们提供以下建议：
- en: Resist the urge to use the 'copy-paste' approach to implementing a new algorithm.
    If you do not understand the underlying principles behind why an algorithm works,
    you will have a very high likelihood of using it incorrectly. Furthermore, even
    if it functions the way you want it to, it is important to remember that graph
    implementations are highly specific to the context. Blindly using any algorithm
    means you will lack the understanding that's necessary to extend the functionality
    of the solution across different sets of parameters.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抵制使用“复制粘贴”方法来实现新算法的冲动。如果您不理解算法的工作原理，您很有可能会错误地使用它。此外，即使它能够按照您的意愿运行，重要的是要记住，图的实现高度特定于上下文。盲目使用任何算法意味着您将缺乏扩展解决方案功能所必需的理解。
- en: When putting new concepts into practice, avoid relying entirely on abstract,
    non-contextual implementations. After using a certain algorithm on purely theoretical
    data, try to modify it to fit some sort of actual data model (even if that data
    itself is hypothetical). Imagining real scenarios in which you can use your newly
    acquired algorithmic knowledge will increase the probability that you will know
    when and how to use it on the job.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将新概念付诸实践时，避免完全依赖抽象的、非情境化的实现。在纯理论数据上使用某种算法后，尝试修改它以适应某种实际数据模型（即使该数据本身是假设的）。想象您可以在哪些真实场景中使用您新获得的算法知识，将增加您在工作中知道何时以及如何使用它的可能性。
- en: 'Avoid implementing your graph before you have really considered the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在您真正考虑以下内容之前，避免实现您的图：
- en: Its fundamental purpose(s) and the essential functionality required to accomplish
    that purpose (that is, the data it describes, the types of queries it needs to
    perform, how dynamic it needs to be, and so on)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的基本目的和实现该目的所需的基本功能（即它描述的数据，它需要执行的查询类型，它需要多动态等）
- en: The most basic components it needs to represent the relevant information about
    the problem
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要表示有关问题的相关信息的最基本组件
- en: Failure to evaluate these key ideas could lead to cluttered and overly verbose
    code, packed with unnecessary data and functions that essentially contribute nothing
    of value to the actual solution. Planning out the necessary components of your
    graph prior to writing any code will potentially save you quite a bit of confusion
    and tedious refactoring.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 未能评估这些关键思想可能导致混乱和过于冗长的代码，其中包含不必要的数据和函数，实质上对实际解决方案没有任何价值。在编写任何代码之前规划图的必要组件可能会节省您相当多的混乱和繁琐的重构。
- en: Ultimately, developing a comprehensive understanding of graph programming is
    a skill that extends far beyond the scope of simply learning all the right algorithms.
    A simple web search related to any non-trivial graphing problem will lead to a
    plethora of deeply analytical research articles, a comparative evaluation of different
    approaches, and conjectured solutions for which a reasonable implementation has
    yet to be discovered. As always, consistent practice is the best method for mastering
    any programming skillset; and graph theory, being a vast and dynamic subject of
    study, is certainly no exception!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，全面理解图形编程是一项技能，远远超出了简单学习所有正确算法的范围。与任何非平凡图形问题相关的简单网络搜索将导致大量深入分析的研究文章，对不同方法的比较评估，以及尚未发现合理实现的猜想解决方案。一如既往，持续的实践是掌握任何编程技能的最佳方法；而图形理论作为一个广阔而动态的研究领域，当然也不例外！
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: So far, we have covered graphs in fairly comprehensive detail. You should now
    have a solid understanding of some of the basic uses of graph theory in software
    development, as well as an appreciation for how graph-based solutions can be used
    to encapsulate complex data in a way that allows us to query and manipulate it
    with relative ease. Having learned the fundamentals of graph structures and traversals
    in *Chapter 6*, *Graph Algorithms I*, and then extended them to solve more advanced
    problems in this chapter, you should now be well-equipped to explore much deeper
    graph implementations in the future since these basic concepts are at the core
    of all of them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经相当全面地涵盖了图形。现在你应该对图形理论在软件开发中的一些基本用途有了扎实的理解，同时也能够欣赏到基于图形的解决方案如何能够以相对容易的方式封装复杂数据，使我们能够查询和操作它。在*第6章*中学习了图形结构和遍历的基础知识后，然后在本章中扩展了它们以解决更高级的问题，你现在应该已经准备好在未来探索更深入的图形实现，因为这些基本概念是它们所有的核心。
- en: Though this chapter does not completely conclude our discussion of graph algorithms
    for this book, we will now take a break from graphs to explore one of the most
    powerful and challenging programming techniques in the modern developer's repertoire.
    Like graph algorithms, the subject we will cover next is so expansive and conceptually
    abstract that it will span two separate chapters. However, because of its usefulness
    (and its difficulty), it is a favorite of many software companies during technical
    interviews.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章并没有完全结束我们对本书中图形算法的讨论，但我们现在将暂时停止讨论图形，转而探讨现代开发人员技能库中最强大和具有挑战性的编程技术之一。与图形算法一样，我们接下来要讨论的主题是如此广泛和概念抽象，以至于它将跨越两个单独的章节。然而，由于它的实用性（和难度），它是许多软件公司在技术面试中喜欢的一个主题。
