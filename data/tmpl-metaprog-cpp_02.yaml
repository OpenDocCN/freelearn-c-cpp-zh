- en: '*Chapter 1*: An Introduction to Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：模板简介'
- en: As a C++ developer, you should be at least familiar if not well versed in **template
    metaprogramming**, in general, referred to in short as **templates**. Template
    metaprogramming is a programming technique that uses templates as blueprints for
    the compiler to generate code and help developers avoid writing repetitive code.
    Although general-purpose libraries use templates heavily, the syntax and the inner
    workings of templates in the C++ language can be discouraging. Even *C++ Core
    Guidelines*, which is a collection of dos and don'ts edited by *Bjarne Stroustrup*,
    the creator of the C++ language, and *Herb Sutter*, the chair of the C++ standardization
    committee, calls templates *pretty horrendous*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 C++ 开发者，你应该至少熟悉，如果不是精通**模板元编程**，通常简称为**模板**。模板元编程是一种编程技术，它使用模板作为编译器生成代码的蓝图，并帮助开发者避免编写重复的代码。尽管通用库大量使用模板，但
    C++ 语言中模板的语法和内部工作原理可能会让人望而却步。甚至由 C++ 语言的创造者 Bjarne Stroustrup 和 C++ 标准化委员会主席 Herb
    Sutter 编辑的 *C++ Core Guidelines* 也称模板为“相当糟糕”。
- en: This book is intended to shed light on this area of the C++ language and help
    you become prolific in template metaprogramming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书旨在阐明 C++ 语言这一领域，并帮助你成为模板元编程的大师。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the need for templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板的需求
- en: Writing your first templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个模板
- en: Understanding template terminology
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板术语
- en: A brief history of templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板简史
- en: The pros and cons of templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板的优势与劣势
- en: The first step in learning how to use templates is to understand what problem
    they actually solve. Let's start with that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用模板的第一步是理解它们实际上解决了什么问题。让我们从这一点开始。
- en: Understanding the need for templates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板的需求
- en: Each language feature is designed to help with a problem or task that developers
    face when using that language. The purpose of templates is to help us avoid writing
    repetitive code that only differs slightly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语言特性都是为了帮助开发者在使用该语言时解决遇到的问题或任务。模板的目的是帮助我们避免编写只略有不同的重复代码。
- en: 'To exemplify this, let''s take the classical example of a `max` function. Such
    a function takes two numerical arguments and returns the largest of the two. We
    can easily implement this as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们以经典的 `max` 函数为例。这样的函数接受两个数值参数，并返回两个中的较大值。我们可以轻松地实现如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This works pretty well, but as you can see, it will only work for values of
    the type `int` (or those that are convertible to `int`). What if we need the same
    function but with arguments of the type `double`? Then, we can overload this function
    (create a function with the same name but a different number or type of arguments)
    for the `double` type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果相当不错，但正如你所见，它只适用于 `int` 类型的值（或可转换为 `int` 的类型）。如果我们需要相同的功能，但参数类型为 `double`
    呢？那么，我们可以为 `double` 类型重载这个函数（创建一个具有相同名称但参数数量或类型不同的函数）：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, `int` and `double` are not the only numeric types. There is `char`,
    `short`, `long`, `long` and their unsigned counterparts, `unsigned char`, `unsigned
    short`, `unsigned long`, and `unsigned long`. There are also the types `float`
    and `long double`. And other types, such as `int8_t`, `int16_t`, `int32_t`, and
    `int64_t`. And there could be other types that can be compared, such as `bigint`,
    `Matrix`, `point2d`, and any user-defined type that overloads `operator>`. How
    can a general-purpose library provide a general-purpose function such as `max`
    for all these types? It can overload the function for all the built-in types and
    perhaps other library types but cannot do so for any user-defined type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`int` 和 `double` 并不是唯一的数值类型。还有 `char`、`short`、`long`、`long` 以及它们的无符号版本，`unsigned
    char`、`unsigned short`、`unsigned long` 和 `unsigned long`。还有 `float` 和 `long double`
    这两种类型。还有其他类型，例如 `int8_t`、`int16_t`、`int32_t` 和 `int64_t`。还可能有其他可以比较的类型，例如 `bigint`、`Matrix`、`point2d`
    以及任何重载了 `operator>` 的用户定义类型。一个通用库如何为所有这些类型提供一个通用的函数，比如 `max` 呢？它可以重载所有内置类型的函数，也许还可以重载其他库类型，但不能为任何用户定义类型重载。
- en: An alternative to overloading functions with different parameters is to use
    `void*` to pass arguments of different types. Keep in mind this is a bad practice
    and the following example is shown only as a possible alternative in a world without
    templates. However, for the sake of discussion, we can design a sorting function
    that will run the quick sort algorithm on an array of elements of any possible
    type that provides a strict weak ordering. The details of the quicksort algorithm
    can be looked up online, such as on Wikipedia at [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同参数重载函数的替代方法是使用`void*`来传递不同类型的参数。请记住，这是一个不好的做法，以下示例仅作为一个在没有模板的世界中可能的选择。然而，为了讨论的目的，我们可以设计一个排序函数，该函数将对任何可能类型的元素数组执行快速排序算法，这些类型提供了严格的弱排序。快速排序算法的详细信息可以在网上找到，例如在维基百科上[https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)。
- en: 'The quicksort algorithm needs to compare and swap any two elements. However,
    since we don''t know their type, the implementation cannot do this directly. The
    solution is to rely on **callbacks**, which are functions passed as arguments
    that will be invoked when necessary. A possible implementation can be as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法需要比较和交换任意两个元素。然而，由于我们不知道它们的类型，实现不能直接这样做。解决方案是依赖于**回调函数**，这些函数作为参数传递，并在必要时被调用。一个可能的实现如下：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to invoke the `quicksort` function, we need to provide implementations
    for these comparisons and swapping functions for each type of array that we pass
    to the function. The following are implementations for the `int` type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用`quicksort`函数，我们需要为每种类型提供这些比较和交换函数的实现，我们将这些类型作为数组传递给函数。以下是`int`类型的实现：
- en: '[PRE36]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With all these defined, we can write code that sorts arrays of integers as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些定义完成后，我们可以编写如下代码来对整数数组进行排序：
- en: '[PRE48]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'These examples focused on functions but the same problem applies to classes.
    Consider that you want to write a class that models a collection of numerical
    values that has variable size and stores the elements contiguously in memory.
    You could provide the following implementation (only the declaration is sketched
    here) for storing integers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例主要关注函数，但相同的问题也适用于类。假设你想编写一个类，该类模拟一个具有可变大小且在内存中连续存储元素的数值集合。你可以提供以下实现（这里只展示了声明部分）来存储整数：
- en: '[PRE54]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This all looks good but the moment you need to store values of the type `double`,
    or `std::string`, or any user-defined type you'll have to write the same code,
    each time only changing the type of the elements. This is something nobody wants
    to do because it is repetitive work and because when something needs to change
    (such as adding a new feature or fixing a bug) you need to apply the same change
    in multiple places.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很不错，但当你需要存储`double`类型、`std::string`类型或任何用户定义类型的值时，你必须编写相同的代码，每次只更改元素的类型。这并不是人们想要做的事情，因为它是一项重复性的工作，而且当需要更改某些内容（例如添加新功能或修复错误）时，你需要在多个地方应用相同的更改。
- en: 'Lastly, a similar problem can be encountered, although less often, when you
    need to define variables. Let''s consider the case of a variable that holds the
    new line character. You can declare it as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你需要定义变量时，可能会遇到类似的问题，尽管这种情况不太常见。让我们考虑一个持有换行符的变量的情况。你可以这样声明它：
- en: '[PRE71]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'What if you need the same constant but for a different encoding, such as wide
    string literals, UTF-8, and so on? You can have multiple variables, having different
    names, such as in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要相同的常量，但用于不同的编码，例如宽字符串字面量、UTF-8等，你可以有多个变量，具有不同的名称，如下例所示：
- en: '[PRE72]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Templates are a technique that allows developers to write blueprints that enable
    the compiler to generate all this repetitive code for us. In the following section,
    we will see how to transform the preceding snippets into C++ templates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一种技术，允许开发者编写蓝图，使编译器能够为我们生成所有这些重复的代码。在下一节中，我们将看到如何将前面的代码片段转换为C++模板。
- en: Writing your first templates
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个模板
- en: It is now time to see how templates are written in the C++ language. In this
    section, we will start with three simple examples, one for each of the snippets
    presented earlier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看在C++语言中如何编写模板了。在本节中，我们将从三个简单的示例开始，每个示例对应前面展示的代码片段。
- en: 'A template version of the `max` function discussed previously would look as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的`max`函数的模板版本看起来如下：
- en: '[PRE76]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will notice here that the type name (such as `int` or `double`) has been
    replaced with `T` (which stands for *type*). `T` is called a `template<typename
    T> or typename<class T>`. Keep in mind that `T` is a parameter, therefore it can
    have any name. We will learn more about template parameters in the next chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，类型名（如`int`或`double`）已被替换为`T`（代表*类型*）。`T`被称为`template<typename T>`或`typename<class
    T>`。请记住，`T`是一个参数，因此它可以有任何一个名字。我们将在下一章中了解更多关于模板参数的内容。
- en: 'At this point, this template that you put in the source code is only a blueprint.
    The compiler will generate code from it based on its use. More precisely, it will
    instantiate a function overload for each type the template is used with. Here
    is an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你放在源代码中的这个模板只是一个蓝图。编译器将根据其使用情况生成代码。更确切地说，它将为模板使用的每个类型实例化一个函数重载。以下是一个示例：
- en: '[PRE81]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this snippet, we are first calling `max` with two integers, which is OK because
    `operator>` is available for the type `int`. This will generate an overload `int
    max(int const a, int const b)`. Second, we are calling `max` with two doubles,
    which again is all right since `operator>` works for doubles. Therefore, the compiler
    will generate another overload, `double max(double const a, double const b)`.
    However, the third call to `max` will generate a compiler error, because the `foo`
    type does not have the `operator>` overloaded.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先用两个整数调用`max`函数，这是可以的，因为`operator>`对于`int`类型是可用的。这将生成一个重载`int max(int
    const a, int const b)`。其次，我们用两个双精度浮点数调用`max`函数，这同样是可以的，因为`operator>`对于双精度浮点数也是可用的。因此，编译器将生成另一个重载`double
    max(double const a, double const b)`。然而，对`max`的第三次调用将生成编译器错误，因为`foo`类型没有重载`operator>`。
- en: 'Without getting into too many details at this point, it should be mentioned
    that the complete syntax for calling the `max` function is the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不深入太多细节的情况下，应该提到调用`max`函数的完整语法如下：
- en: '[PRE90]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The compiler is able to deduce the type of the template parameter, making it
    redundant to write it. There are cases, however, when that is not possible; in
    those situations, you need to specify the type explicitly, using this syntax.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器能够推导出模板参数的类型，因此没有必要写出它。然而，在某些情况下，这是不可能的；在这些情况下，你需要显式指定类型，使用这种语法。
- en: 'The second example involving functions from the previous section, *Understanding
    the need for templates*, was the `quicksort()` implementation that dealt with
    `void*` arguments. The implementation can be easily transformed into a template
    version with very few changes. This is shown in the following snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中涉及函数的第二个例子是处理`void*`参数的`quicksort()`实现。这个实现可以很容易地转换成模板版本，只需做很少的修改。以下是一个示例：
- en: '[PRE93]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The use of the `quicksort` function template is very similar to what we have
    seen earlier, except there is no need to pass pointers to callback functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksort`函数模板的使用与之前所见非常相似，只是不需要传递回调函数的指针：'
- en: '[PRE126]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The third example we looked at in the previous section was the `vector` class.
    A template version of it will look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论的第三个例子是`vector`类。它的模板版本如下所示：
- en: '[PRE132]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'As in the case of the `max` function, the changes are minimal. There is the
    template declaration on the line above the class and the type `int` of the elements
    has been replaced with the type template parameter `T`. This implementation can
    be used as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与`max`函数的情况一样，变化很小。在类的上方一行有模板声明，元素类型`int`已被类型模板参数`T`所取代。这个实现可以这样使用：
- en: '[PRE150]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: One thing to notice here is that we have to specify the type of the elements
    when declaring the variable `v`, which is `int` in our snippet because the compiler
    would not be able to infer their type otherwise. There are cases when this is
    possible, in C++17, and this topic, called **class template argument deduction**,
    will be discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced
    Template Concepts*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，在声明变量`v`时，我们必须指定其元素类型，在我们的代码片段中是`int`，因为否则编译器无法推断它们的类型。在C++17中，这种情况是可能的，这个主题被称为**类模板参数推导**，将在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)
    *高级模板概念*中讨论。
- en: 'The fourth and last example concerned the declaration of several variables
    when only the type was different. We could replace all those variables with a
    template, as shown in the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个也是最后一个例子是关于当只有类型不同时声明多个变量。我们可以用模板替换所有这些变量，如下面的代码片段所示：
- en: '[PRE156]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This template can be used as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板可以按以下方式使用：
- en: '[PRE158]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The examples in this section show that the syntax for declaring and using templates
    is the same whether they represent functions, classes, or variables. This leads
    us to the next section where we will discuss the types of templates and template
    terminology.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例表明，无论模板代表函数、类还是变量，其声明和使用语法都是相同的。这引导我们进入下一节，我们将讨论模板的类型和模板术语。
- en: Understanding template terminology
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板术语
- en: 'So far in this chapter, we have used the general term templates. However, there
    are four different terms describing the kind of templates we have written:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们使用了通用术语模板。然而，有四个不同的术语描述了我们所编写的模板类型：
- en: '`max` template seen previously.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前见过的 `max` 模板。
- en: '`class`, `struct`, or `union` keyword). An example is the `vector` class we
    wrote in the previous section.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`、`struct` 或 `union` 关键字）。一个例子是我们之前章节中编写的 `vector` 类。'
- en: '`NewLine` template from the previous section.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前章节中的 `NewLine` 模板。
- en: '**Alias template** is the term used for templated type aliases. We will see
    examples for alias templates in the next chapter.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别名模板**是用于模板化类型别名的术语。我们将在下一章中看到别名模板的示例。'
- en: 'Templates are parameterized with one or more parameters (in the examples we
    have seen so far, there was a single parameter). These are called **template parameters**
    and can be of three categories:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以用一个或多个参数进行参数化（在我们迄今为止的示例中，有一个单个参数）。这些被称为**模板参数**，可以分为三类：
- en: '`template<typename T>`, where the parameter represents a type specified when
    the template is used.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template<typename T>`，其中参数代表在模板使用时指定的类型。'
- en: '`template<size_t N>` or `template<auto n>`, where each parameter must have
    a structural type, which includes integral types, floating-point types (as for
    C++20), pointer types, enumeration types, lvalue reference types, and others.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template<size_t N>` 或 `template<auto n>`，其中每个参数都必须有一个结构化类型，这包括整数类型、浮点类型（对于
    C++20）、指针类型、枚举类型、左值引用类型以及其他类型。'
- en: '`template<typename K, typename V, template<typename> typename C>`, where the
    type of a parameter is another template.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template<typename K, typename V, template<typename> typename C>`，其中参数的类型是另一个模板。'
- en: 'Templates can be specialized by providing alternative implementations. These
    implementations can depend on the characteristics of the template parameters.
    The purpose of specialization is to enable optimizations or reduce code bloat.
    There are two forms of specialization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过提供替代实现来专门化模板。这些实现可以依赖于模板参数的特性。专门化的目的是为了实现优化或减少代码膨胀。有两种专门化的形式：
- en: '**Partial specialization**: This is an alternative implementation provided
    for only some of the template parameters.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分专门化**：这是只为部分模板参数提供的替代实现。'
- en: '**(Explicit) full specialization**: This is a specialization of a template
    when all the template arguments are provided.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**（显式）完全专门化**：这是当所有模板参数都提供时模板的专门化。'
- en: The process of generating code from a template by the compiler is called `vector<int>`,
    the compiler substituted the `int` type in every place where `T` appeared.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器从模板生成代码的过程称为 `vector<int>`，编译器在 `T` 出现的每个地方都替换了 `int` 类型。
- en: 'Template instantiation can have two forms:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化可以有两种形式：
- en: '`vector<int>` and `vector<double>`, it will instantiate the `vector` class
    template for the types `int` and `double` and nothing more.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector<int>` 和 `vector<double>`，它将为 `int` 和 `double` 类型实例化 `vector` 类模板，而不会更多。'
- en: '**Explicit instantiation**: This is a way to explicitly tell the compiler what
    instantiations of a template to create, even if those instantiations are not explicitly
    used in your code. This is useful, for instance, when creating library files,
    because uninstantiated templates are not put into object files. They also help
    reduce compile times and object sizes, in ways that we will see at a later time.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式实例化**：这是一种明确告诉编译器要创建哪些模板实例化的方法，即使这些实例化在您的代码中没有被明确使用。这在创建库文件时很有用，因为未实例化的模板不会被放入对象文件中。它们还有助于减少编译时间和对象大小，我们将在稍后看到。'
- en: All the terms and topics mentioned in this section will be detailed in other
    chapters of the book. This section is intended as a short reference guide to template
    terminology. Keep in mind though that there are many other terms related to templates
    that will be introduced at the appropriate time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到的所有术语和主题将在本书的其他章节中详细说明。本节旨在作为模板术语的简要参考指南。但请记住，还有许多与模板相关的其他术语将在适当的时候介绍。
- en: A brief history of templates
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板的历史简述
- en: 'Template metaprogramming is the C++ implementation of generic programming.
    This paradigm was first explored in the 1970s and the first major languages to
    support it were Ada and Eiffel in the first half of the 1980s. David Musser and
    Alexander Stepanov defined generic programming, in a paper called *Generic Programming*,
    in 1989, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程是C++的泛型编程实现。这种范式最早在20世纪70年代被探索，而第一个支持它的主要语言是20世纪80年代上半叶的Ada和Eiffel。David
    Musser和Alexander Stepanov在1989年的一篇名为《泛型编程》的论文中定义了泛型编程，如下所述：
- en: Generic programming centers around the idea of abstracting from concrete, efficient
    algorithms to obtain generic algorithms that can be combined with different data
    representations to produce a wide variety of useful software.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程围绕着从具体、高效的算法抽象出通用算法的想法，这些通用算法可以与不同的数据表示结合，以产生各种有用的软件。
- en: This defines a paradigm of programming where algorithms are defined in terms
    of types that are specified later and instantiated based on their use.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一种编程范式，其中算法是根据稍后指定的类型定义的，并根据其使用进行实例化。
- en: Templates were not part of the initial **C with Classes** language developed
    by Bjarne Stroustrup. Stroustrup's first papers describing templates in C++ appeared
    in 1986, one year after the publication of his book, *The C++ Programming Language,
    First Edition*. Templates became available in the C++ language in 1990, before
    the ANSI and ISO C++ committees for standardization were founded.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模板不是Bjarne Stroustrup开发的最初**C with Classes**语言的组成部分。Stroustrup描述C++中模板的第一篇论文出现在1986年，即他的书《C++编程语言，第一版》出版后一年。模板在1990年成为C++语言的一部分，在ANSI和ISO
    C++标准化委员会成立之前。
- en: In the early 1990s, Alexander Stepanov, David Musser, and Meng Lee experimented
    with the implementation in C++ of various generic concepts. This led to the first
    implementation of the **Standard Template Library** (**STL**). When the ANSI/ISO
    committee became aware of the library in 1994, it quickly added it to the drafted
    specifications. STL was standardized along with the C++ language in 1998 in what
    became known as C++98.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代初，Alexander Stepanov、David Musser和Meng Lee在C++中对各种泛型概念进行了实验。这导致了**标准模板库**（**STL**）的第一个实现。当ANSI/ISO委员会在1994年了解到这个库时，它迅速将其添加到草案规范中。STL与C++语言一起在1998年标准化，这被称为C++98。
- en: 'Newer versions of the C++ standard, collectively referred to as **modern C++**,
    have introduced various improvements to template metaprogramming. The following
    table lists them briefly:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准的较新版本，统称为**现代C++**，引入了各种对模板元编程的改进。以下表格简要列出它们：
- en: '![Table 1.1'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 1.1'
- en: '](img/B18367_Table_1.1.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18367_Table_1.1.jpg]'
- en: Table 1.1
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1
- en: All these features, along with other aspects of template metaprogramming, will
    make the sole subject of this book and will be presented in detail in the following
    chapters. For now, let's see what the advantages and disadvantages are of using
    templates.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性，以及模板元编程的其他方面，将是本书的唯一主题，将在以下章节中详细介绍。现在，让我们看看使用模板的优势和劣势是什么。
- en: The pros and cons of templates
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板的优势和劣势
- en: Before you start using templates, it's important to understand the benefits
    of using them as well as the disadvantages they may incur.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用模板之前，了解使用模板的好处以及它们可能带来的劣势是很重要的。
- en: 'Let''s start by pointing out the advantages:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先指出其优势：
- en: Templates help us avoid writing repetitive code.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板帮助我们避免编写重复的代码。
- en: Templates foster the creation of generic libraries providing algorithms and
    types, such as the standard C++ library (sometimes incorrectly referred to as
    the STL), which can be used in many applications, regardless of their type.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板促进了通用库的创建，这些库提供算法和类型，例如标准C++库（有时错误地称为STL），它可以在许多应用中使用，无论它们的类型如何。
- en: The use of templates can result in less and better code. For instance, using
    algorithms from the standard library can help write less code that is likely easier
    to understand and maintain and also probably more robust because of the effort
    put into the development and testing of these algorithms.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板的使用可以导致代码更少且更好。例如，使用标准库中的算法可以帮助编写更少的代码，这些代码可能更容易理解和维护，并且由于这些算法的开发和测试所付出的努力，可能更健壮。
- en: 'When it comes to disadvantages, the following are worth mentioning:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到劣势时，以下几点值得提及：
- en: The syntax is considered complex and cumbersome, although with a little practice
    this should not really pose a real hurdle in the development and use of templates.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然语法被认为是复杂且繁琐的，但只要稍加练习，这实际上不应该在模板的开发和使用中构成真正的障碍。
- en: Compiler errors related to template code can often be long and cryptic, making
    it very hard to identify their cause. Newer versions of the C++ compilers have
    made progress in simplifying these kinds of errors, although they generally remain
    an important issue. The inclusion of concepts in the C++20 standard has been seen
    as an attempt, among others, to help provide better diagnostics for compiling
    errors.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模板代码相关的编译器错误通常很长且难以理解，这使得确定其原因是极其困难的。较新的C++编译器在这些类型的错误简化方面取得了进展，尽管它们通常仍然是一个重要问题。C++20标准中包含的概念被看作是尝试之一，旨在为编译错误提供更好的诊断。
- en: They increase the compilation times because they are implemented entirely in
    headers. Whenever a change to a template is made, all the translation units in
    which that header is included must be recompiled.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们完全在头文件中实现，因此它们会增加编译时间。每当对模板进行更改时，包含该头文件的所有翻译单元都必须重新编译。
- en: Template libraries are provided as a collection of one or more headers that
    must be compiled together with the code that uses them.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板库以一组一个或多个头文件的形式提供，这些头文件必须与使用它们的代码一起编译。
- en: Another disadvantage that results from the implementation of templates in headers
    is that there is no information hiding. The entire template code is available
    in headers for anyone to read. Library developers often resort to the use of namespaces
    with names such as `detail` or `details` to contain code that is supposed to be
    internal for a library and should not be called directly by those using the library.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模板在头文件中的实现中产生的另一个缺点是缺乏信息隐藏。整个模板代码都可在头文件中供任何人阅读。库开发者经常求助于使用诸如`detail`或`details`之类的命名空间来包含库内部应使用且不应直接被库使用者调用的代码。
- en: They could be harder to validate since code that is not used is not instantiated
    by the compiler. It is, therefore, important that when writing unit tests, good
    code coverage must be ensured. This is especially the case for libraries.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于未使用的代码不会被编译器实例化，因此它们可能更难验证。因此，在编写单元测试时，必须确保良好的代码覆盖率。这对于库尤其如此。
- en: Although the list of disadvantages may seem longer, the use of templates is
    not a bad thing or something to be avoided. On the contrary, templates are a powerful
    feature of the C++ language. Templates are not always properly understood and
    sometimes are misused or overused. However, the judicious use of templates has
    unquestionable advantages. This book will try to provide a better understanding
    of templates and their use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缺点列表可能看起来更长，但使用模板并不是一件坏事或需要避免的事情。相反，模板是C++语言的一个强大功能。模板并不总是被正确理解，有时会被误用或过度使用。然而，模板的明智使用无疑具有优势。本书将尝试提供对模板及其使用的更好理解。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of templates in the C++ programming language.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C++编程语言中模板的概念。
- en: We started by learning about the problems for which the solution is the use
    of templates. We then saw how templates look with simple examples of function
    templates, class templates, and variable templates. We introduced the basic terminology
    for templates, which we will discuss more in the forthcoming chapters. Toward
    the end of the chapter, we saw a brief history of templates in the C++ programming
    language. We ended the chapter with a discussion on the advantages and disadvantages
    of using templates. All these topics will lead us to understand the next chapters
    better.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了那些解决方案是使用模板的问题。然后，我们通过函数模板、类模板和变量模板的简单示例来了解模板的外观。我们介绍了模板的基本术语，这些内容将在接下来的章节中进一步讨论。在章节的末尾，我们简要回顾了C++编程语言中模板的历史。我们以讨论使用模板的优缺点结束本章。所有这些主题都将帮助我们更好地理解下一章的内容。
- en: In the next chapter, we will explore the fundamentals of templates in C++.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C++中模板的基础知识。
- en: Questions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need templates? What advantages do they provide?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要模板？它们提供了哪些优势？
- en: How do you call a function that is a template? What about a class that is a
    template?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何调用模板函数？对于模板类又是如何？
- en: How many kinds of template parameters exist and what are they?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在多少种模板参数类型，它们是什么？
- en: What is partial specialization? What about full specialization?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是部分专业化？什么是完全专业化？
- en: What are the main disadvantages of using templates?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板的主要缺点是什么？
- en: Further reading
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Generic Programming, David Musser, Alexander Stepanov*, [http://stepanovpapers.com/genprog.pdf](http://stepanovpapers.com/genprog.pdf)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型编程，David Musser，Alexander Stepanov*，[http://stepanovpapers.com/genprog.pdf](http://stepanovpapers.com/genprog.pdf)'
- en: '*A History of C++: 1979−1991, Bjarne Stroustrup*, [https://www.stroustrup.com/hopl2.pdf](https://www.stroustrup.com/hopl2.pdf)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++历史：1979−1991，Bjarne Stroustrup*，[https://www.stroustrup.com/hopl2.pdf](https://www.stroustrup.com/hopl2.pdf)'
- en: '*History of C++*, [https://en.cppreference.com/w/cpp/language/history](https://en.cppreference.com/w/cpp/language/history)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++历史*，[https://en.cppreference.com/w/cpp/language/history](https://en.cppreference.com/w/cpp/language/history)'
- en: '*Templates in C++ - Pros and Cons, Sergey Chepurin*, [https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons](https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++模板：利与弊，Sergey Chepurin*，[https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons](https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons)'
