- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Navigating through the Filesystems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件系统中导航
- en: In this chapter, we will revisit the concepts of a file, which were discussed
    briefly in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014). You will learn in
    detail about the **filesystem** (**FS**) in Linux and its specifics. We will not
    go to certain filesystem implementations, as you will see there’re many, but we
    will establish the fundamentals of working with them. You will learn more about
    Linux’s FS hierarchy – its partitions, object types, and some frequently used
    operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾在[*第1章*](B20833_01.xhtml#_idTextAnchor014)中简要讨论的文件概念。你将详细了解Linux中的**文件系统**（**FS**）及其具体细节。我们不会深入到某些文件系统实现中，因为你会看到有很多，但我们将建立与之工作的基础。你将了解更多关于Linux的FS层次结构——它的分区、对象类型和一些常用操作。
- en: You will get familiar with the `string_views`. Some of the operations you learn
    about here will be revisited again in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075),
    when we will discuss error handling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将熟悉`string_views`。在这里你将学习的一些操作将在[*第5章*](B20833_05.xhtml#_idTextAnchor075)中再次回顾，届时我们将讨论错误处理。
- en: Last but not least, you will learn hands-on about the fundamental **inter-process
    communication** (**IPC**) mechanism known as **pipes**. We will also discuss signals
    as system entities and their impact on communication. If you’re unfamiliar with
    data transfers between processes, then this is where you should start. If you
    are experienced, then you may notice that the code could be much more complicated
    – implementing server-client applications with pipes, for example. We are aware
    of that, but we believe that the examples are a good basis to start from – additional
    scalability of this mechanism has unwanted knock-on effects. We discuss this more
    in [*Chapter 7*](B20833_07.xhtml#_idTextAnchor101).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你将亲身体验到被称为**管道**的基本**进程间通信**（**IPC**）机制。我们还将讨论作为系统实体的信号及其对通信的影响。如果你对进程间的数据传输不熟悉，那么你应该从这里开始。如果你有经验，你可能会注意到代码可能更加复杂——例如，使用管道实现服务器-客户端应用程序。我们了解这一点，但我们相信这些示例是一个很好的起点——这种机制的额外可扩展性会产生不希望的影响。我们将在[*第7章*](B20833_07.xhtml#_idTextAnchor101)中进一步讨论这一点。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Going through Linux’s filesystem fundamentals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Linux的文件系统基础
- en: Executing filesystem operations with C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++执行文件系统操作
- en: IPC through anonymous pipes and named pipes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过匿名管道和命名管道进行IPC
- en: Briefly observing the signal handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要观察信号处理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to run the code examples, the reader must prepare the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码示例，读者必须准备以下内容：
- en: 'A Linux-based system capable of compiling and executing C and C++20 (for example,
    Linux Mint 21):'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C和C++20的基于Linux的系统（例如，Linux Mint 21）：
- en: '**gcc12.2** compiler: [https://gcc.gnu.org/git/gcc.git gcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gcc12.2**编译器：[https://gcc.gnu.org/git/gcc.git gcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source)'
- en: '**g++** with **-std=c++2a** flags for the C++ code'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有**-std=c++2a**标志的**g++**编译C++代码
- en: '**gcc** without flags for the C code'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译C代码时不带**gcc**标志
- en: For all the examples, you can alternatively use [https://godbolt.org/.](https://godbolt.org/%0D)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有示例，你也可以使用[https://godbolt.org/.](https://godbolt.org/%0D)
- en: 'Code examples could be found here: [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码示例可以在这里找到：[https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203)
- en: Going through Linux’s filesystem fundamentals
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Linux的文件系统基础
- en: 'We went through some of the Unix (and Linux) filesystem definitions in [*Chapter
    1*](B20833_01.xhtml#_idTextAnchor014). Let’s see how they really matter in the
    bigger picture of system programming. You probably remember what types of files
    there are in the Linux system – regular files, directories, special files, links,
    sockets, and named pipes. We are going to deal with most of them in this chapter
    and learn about what purpose they serve. One way to think about files in Unix,
    including Linux, is the following simple statement:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第1章*](B20833_01.xhtml#_idTextAnchor014)中介绍了一些Unix（和Linux）文件系统的定义。让我们看看它们在系统编程的更大图景中真正意味着什么。你可能还记得Linux系统中有哪些类型的文件——常规文件、目录、特殊文件、链接、套接字和命名管道。我们将在本章中处理其中大部分，并了解它们各自的作用。关于Unix中的文件，包括Linux，可以这样简单思考：
- en: “*On a UNIX system, everything is a file; if something is not a file, it is*
    *a process.*”
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “在UNIX系统中，一切皆文件；如果某物不是文件，那么它就是一个*进程*。”
- en: So, everything that’s not a process has an API, which includes file operation
    system calls. Let’s agree that a file is the main instrument for the logical organization
    of data. Then there must be something that is the main instrument for file organization.
    Well, this is where the file management system, or simply the FS, comes into play.
    It looks after the files’ layout on the physical medium – the `open()`, `write()`),
    and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有不是进程的东西都有一个API，这包括文件操作系统调用。让我们同意文件是数据逻辑组织的主要工具。那么，必然存在某种是文件组织的主要工具。好吧，这就是文件管理系统，或者简单地说是文件系统，发挥作用的地方。它负责物理介质上的文件布局——例如，`open()`、`write()`等。
- en: The FS also allows the user to forget the hardware’s specifics for a moment
    and focus on data operations, as well as using the FS like an ordered catalog.
    It helps with the files’ structure and data visualization on the UI or CLI, access
    permissions, and the effective usage of resources. While the user has the chance
    to focus on file creation, deletion, modifications, and sharing, the FS cares
    more about data accuracy, device driver error handling, multiple user accesses,
    and so on. This is an important point, as we will observe some error states later
    in the book – for example, in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075),
    where the FS is the entity that creates the exception cases. And it also affects
    task scheduling, as we mentioned earlier. Let’s look at the FS structure and its
    specifics in Linux.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统还允许用户暂时忘记硬件的细节，专注于数据操作，以及像有序目录一样使用文件系统。它帮助在用户界面或命令行界面上的文件结构和数据可视化，访问权限，以及资源的有效使用。当用户有机会专注于文件创建、删除、修改和共享时，文件系统更关注数据准确性、设备驱动程序错误处理、多用户访问等问题。这是一个重要的观点，因为我们将在本书后面的某些地方观察到一些错误状态——例如，在[*第五章*](B20833_05.xhtml#_idTextAnchor075)，其中文件系统是创建异常情况的实体。它还影响任务调度，正如我们之前提到的。让我们看看Linux中的文件系统结构和其具体细节。
- en: Linux’s FS
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux的文件系统（FS）
- en: We have to mention that there are many kinds of FSs. Each of them suits its
    own purposes, as the user experience implies multiple preferences, and not all
    of them exist together. Linux has the strength to support over 100 FSes. A combination
    of them can run simultaneously on a single system. This provides an opportunity
    for the user to operate with them optimally and benefit from all of them. If the
    FS is required just to organize the file structure, then an ordinary one could
    do the trick – for example, `ext2` or `FAT`. If we want file consistency and less
    error-prone operations, then a `ext4`, `ReiserFS`, or `XFS`. For online data stores,
    `NFS` and `CIFS`, might come in handy. Large files and a large number of small
    files require specific management, too, so `ZFS` and `btrfs`, are useful. Last,
    but not least, there are FSes that are not backed by physical storage but represent
    entities in the `proc`, `sys`, `ram`, and `tmp`. However, at an abstract level,
    the file operations seem to be the same. So, we can have a unified interface.
    It not only allows system programmers to use the different FSes in the same way
    but also allows the OS’s UI to visualize the file structure – all of the files
    and directories – under the same FS tree. Linux realizes this through the **virtual
    filesystem** (**VFS**). It is also referred to as **virtual FS switch** – a layer
    residing in the kernel, providing a generic interface for the programs. Before
    we go into detail, let’s see how it looks from a design standpoint.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提到，存在许多种类的文件系统。每种文件系统都适合其特定的用途，正如用户体验所暗示的，存在多种偏好，并不是所有文件系统都同时存在。Linux具有支持超过100种文件系统的能力。它们可以组合运行在单个系统上。这为用户提供了最佳操作的机会，并使他们能够从中受益。如果文件系统只需要组织文件结构，那么一个普通的文件系统就可以做到这一点——例如，`ext2`或`FAT`。如果我们想要文件一致性和更少出错的操作，那么可以选择`ext4`、`ReiserFS`或`XFS`。对于在线数据存储，`NFS`和`CIFS`可能很有用。对于大文件和大量小文件，也需要特定的管理，因此`ZFS`和`btrfs`很有用。最后但同样重要的是，还有一些文件系统不是基于物理存储，而是在`proc`、`sys`、`ram`和`tmp`中代表实体。然而，在抽象层面上，文件操作似乎是一样的。因此，我们可以有一个统一的接口。这不仅允许系统程序员以相同的方式使用不同的文件系统，而且还允许操作系统的用户界面可视化同一文件树下的所有文件和目录。Linux通过**虚拟文件系统**（**VFS**）实现这一点。它也被称为**虚拟文件系统切换器**——一个位于内核中的层，为程序提供通用接口。在详细探讨之前，让我们从设计角度看看它是什么样的。
- en: '![Figure 3.1 – A VFS software layer in Linux kernel](img/Figure_3.1_B20833.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Linux内核中的VFS软件层](img/Figure_3.1_B20833.jpg)'
- en: Figure 3.1 – A VFS software layer in Linux kernel
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Linux内核中的VFS软件层
- en: Additionally, the VFS is object-oriented. This will not help us much with C++
    code, unfortunately. Still, it is a good example of object-oriented programming
    in C, as the objects are actually of a `struct` type, containing file data and
    function pointers to the file operations. We will talk about those objects a bit
    later in the chapter. Let’s look at the directory structure and standardized partitioning
    now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，VFS是面向对象的。不幸的是，这不会对我们使用C++代码有很大帮助。不过，它是一个C语言中面向对象编程的好例子，因为对象实际上是`struct`类型，包含文件数据和指向文件操作的函数指针。我们将在本章稍后讨论这些对象。现在让我们看看目录结构和标准化分区。
- en: Directory structure and partitioning
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录结构和分区
- en: 'The directory structure in Linux is well presented in the `#!`. You can read
    more about them by executing this command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的目录结构在`#!`中得到了很好的展示。你可以通过执行此命令了解更多信息：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Getting back to the FS structure – it starts with the `root` directory, denoted
    with `/`. The `root` FS is mounted on that directory in the early stages of the
    system’s boot sequence. Every other FS is mounted during the OS startup or even
    later during normal operations. You can check your own configuration as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文件系统结构——它从`root`目录开始，用`/`表示。在系统引导序列的早期阶段，`root`文件系统被挂载到该目录上。其他所有文件系统都在操作系统启动期间或甚至在正常操作期间挂载。你可以按照以下方式检查自己的配置：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It provides information about the *mount points* and the respective FS types.
    Outside this file, the FSes will be visible in the system as separate directories
    with their exact paths. Every one of them can be accessed through the `root` directory.
    An important point is that `/` and `/root` are different directories, as the first
    is the `root` directory and the latter is the home directory of the *root user*.
    Some other important partitions and directories are the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了有关*挂载点*和相应文件系统类型的详细信息。在此文件之外，文件系统将以具有确切路径的单独目录的形式在系统中可见。每个目录都可以通过`root`目录访问。一个重要点是`/`和`/root`是不同的目录，因为前者是`root`目录，而后者是*root用户*的主目录。其他一些重要的分区和目录如下：
- en: '`/bin`: Includes common user executables.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`: 包括常用用户可执行文件。'
- en: '`/boot`: Includes the Linux system startup files, the static part of the kernel,
    and the bootloader configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`: 包括Linux系统启动文件、内核的静态部分和引导加载程序配置。'
- en: '`/dev`: Includes references to all peripheral hardware, which is represented
    through files with a special file type, `''c''` or `''b''`, and they provide access
    to the real devices. We mentioned these special file types in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`: 包括对所有外围硬件的引用，这些硬件通过具有特殊文件类型`''c''`或`''b''`的文件表示，并提供对真实设备的访问。我们曾在[*第一章*](B20833_01.xhtml#_idTextAnchor014)中提到过这些特殊文件类型。'
- en: '`/etc`: Includes the system configuration files.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`: 包括系统配置文件。'
- en: '`/home`: This is the top-level directory, which is available for user files,
    and all users have their respective common subdirectory there.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`: 这是顶级目录，可供用户文件使用，所有用户都有各自的公共子目录。'
- en: '`/lib`: This includes shared library files that are needed to start the system.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`: 这包括启动系统所需的共享库文件。'
- en: '`/mnt`: The temporary mount point for external FSes. It makes a good combination
    with `/media`, where media devices such as USB flash drives are mounted.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt`: 外部文件系统的临时挂载点。它与`/media`结合得很好，其中媒体设备（如USB闪存驱动器）被挂载。'
- en: '`/opt`: This consists of optional files and third-party software applications.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/opt`: 这包括可选文件和第三方软件应用程序。'
- en: '`/proc`: This contains information about the system resources.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`: 这包含有关系统资源的信息。'
- en: '`/tmp`: This is a temporary directory used by the OS and several programs for
    temporal storage – it will be cleaned up after reboot.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`: 这是一个由操作系统和多个程序用于临时存储的临时目录——重启后会进行清理。'
- en: '`/sbin`: This includes the system binary files, usually utilized by the system
    administrator.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`: 这包括系统二进制文件，通常由系统管理员使用。'
- en: '`/usr`: This includes read-only files most of the time, but there are exceptions.
    It is for programs, libraries and binaries, *man* files, and documentation.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`: 这通常包括只读文件，但也有一些例外。它是用于程序、库和二进制文件、*man*文件和文档的。'
- en: '`/var`: This includes variable data files – usually log files, database files,
    archived e-mails, and so on.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`: 这包括可变数据文件——通常是日志文件、数据库文件、存档电子邮件等。'
- en: Let’s get back to **mount points** and **FS partitions**. As not many people
    are familiar with those, we will take the opportunity to briefly explain them.
    A good reason for this is that, as already mentioned, system programmers work
    with many FSes at a time, and some of them are related to network drives or different
    devices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到**挂载点**和**文件系统分区**。由于很多人对这些不太熟悉，我们将借此机会简要解释它们。一个很好的理由是，正如已经提到的，系统程序员一次要处理许多文件系统（FSes），其中一些与网络驱动器或不同设备相关。
- en: Linux does not assign a letter to a partition as Windows does; therefore, you
    can easily confuse a separate device for a simple directory. Most of the time,
    this shouldn’t be a big deal, but it might become a problem when you care about
    resource management, resiliency, and security. For example, vehicles overall have
    strict requirements for hardware durability, which extends to 10-15 years of serviceability.
    With this in mind, you must be aware of a device’s characteristics, especially
    if you write on it frequently or fill its entire space meaninglessly. The way
    an FS manages the data is also crucial to a peripheral’s memory exhaustion in
    time, so this choice is important.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Linux不像Windows那样给分区分配字母；因此，你很容易将一个单独的设备与一个简单的目录混淆。大多数时候，这不会成为大问题，但如果你关心资源管理、弹性和安全性，可能会成为问题。例如，车辆对硬件耐用性有严格的要求，这延伸到10-15年的可服务性。考虑到这一点，你必须了解设备的特性，尤其是如果你经常在其上写入或无意义地填满其整个空间。文件系统管理数据的方式对于及时耗尽外围设备的内存也非常关键，因此这个选择很重要。
- en: '`fstab` shows where FSes are mounted, but it also describes something else.
    First of all, let’s remember that **FS partitions** have the purpose of separating
    a single device – a hard drive, for example – into multiple partitions. This is
    used mostly in embedded systems with safety requirements. However, Linux also
    provides **Logical Volume Manager** (**LVM**), which allows flexible setups. In
    other words, FSes can easily get shrunk or enlarged, which is preferable on larger-scale
    systems.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`fstab`显示了文件系统挂载的位置，但它还描述了其他内容。首先，让我们记住**文件系统分区**的目的是将单个设备——例如硬盘驱动器——分成多个分区。这主要用于具有安全要求的嵌入式系统。然而，Linux还提供了**逻辑卷管理器**（**LVM**），它允许灵活的设置。换句话说，文件系统可以很容易地缩小或扩大，这在更大规模系统中更受欢迎。'
- en: The creation of multiple FSs serves not only as a user data grouping tool but
    also allows other partitions to remain intact if one goes out due to failure.
    Another usage is when a device’s storage is unavailable – often, it’s just full
    of data. The entire system might stop working because it also relies on storage
    space. Therefore, it is better to fill only a single FS entirely and raise an
    error. The other FS will be left intact, and the system will continue working.
    From that point of view, it is a secure and robust solution. Just keep in mind
    that it doesn’t protect you from overall device failure. For that reason, many
    network storage devices rely on a **Redundant Array of Inexpensive Disks** (**RAID**).
    We will not deal with it here, but we encourage you to read more about it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个文件系统不仅作为用户数据分组工具，还允许在某个分区因故障而损坏时保持其他分区完整。另一种用法是当设备的存储不可用时——通常，它只是充满了数据。整个系统可能会停止工作，因为它也依赖于存储空间。因此，最好只完全填充一个文件系统并引发错误。其他文件系统将保持完整，系统将继续工作。从这个角度来看，这是一个安全且稳健的解决方案。但请记住，它不能保护你免受整体设备故障的影响。因此，许多网络存储设备依赖于**廉价磁盘冗余阵列**（**RAID**）。我们在这里不会处理它，但我们鼓励你阅读更多关于它的内容。
- en: 'Now, you probably observed some additional data in the `fstab` output earlier.
    Except for the **root partition**, we actually divide the partition types into
    **data** and **swap** partitions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到了之前`fstab`输出中的一些额外数据。除了**根分区**外，我们实际上将分区类型分为**数据**和**交换**分区：
- en: '**The data partition**: This includes the root partition, together with all
    necessary information for system startup and normal run. It also includes standard
    data on Linux.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分区**：这包括根分区，以及系统启动和正常运行所需的所有必要信息。它还包括Linux的标准数据。'
- en: '`swap` in `fstab`, and it provides the system with the option to move data
    from the main memory to the NVM in cases of memory overflow. It is visible only
    to the system itself. This doesn’t mean you should overflow your RAM, but just
    keep it for extra flexibility in order to not compromise the system’s availability.
    Just remember, the NVM is much slower than the main memory chips!'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `fstab` 中的 `swap`，它为系统提供了在内存溢出时将数据从主内存移动到 NVM 的选项。这仅对系统本身可见。这并不意味着你应该溢出你的
    RAM，但只是为了保持额外的灵活性，以免影响系统的可用性。记住，NVM 比主存储芯片慢得多！
- en: Important note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The system administrator generally configures the partitions’ layout. Sometimes,
    one partition is spread across multiple NVM devices. This design is strictly related
    to the system’s purpose. Once the partitions are available to you as a user, you
    can only add more. We strongly discourage you from changing their properties unless
    you’re well aware of what you’re doing and why.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员通常配置分区布局。有时，一个分区会跨越多个 NVM 设备。这种设计严格与系统的用途相关。一旦分区对您作为用户可用，您就只能添加更多。我们强烈建议您除非您非常清楚自己在做什么以及为什么这么做，否则不要更改它们的属性。
- en: 'What about the `df` command. In our case, this is the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `df` 命令，在我们的例子中，它是这样的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is easy to see the relationship between the FS type and the mount point,
    for example, the `Filesystem` and `Mounted on` columns. We will not go into more
    detail on this, but we encourage you to read more about the `parted` tool, which
    is used exactly for the creation and editing of partitions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出文件系统类型和挂载点之间的关系，例如，`文件系统` 和 `挂载在` 列。我们不会对此进行更详细的说明，但我们鼓励您阅读更多关于 `parted`
    工具的信息，该工具正是用于创建和编辑分区的。
- en: Linux FS objects
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 文件系统对象
- en: 'As we already mentioned in the previous section, the FS is realized through
    objects, and there are four main types we care about:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，文件系统是通过对象实现的，我们关注的主要有四种类型：
- en: '**Superblock**: This represents the mounted FS metadata – the respective device,
    the modification flags, the corresponding FS type, the FS access permissions,
    the modified files, and so on.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超级块**：这代表挂载的文件系统元数据——相应的设备、修改标志、相应的文件系统类型、文件系统访问权限、修改的文件等等。'
- en: '`open()`, `create()`, `lookup()`, `mkdir()`. Regular files, special files,
    directories, and `stat` command:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()`、`create()`、`lookup()`、`mkdir()`。常规文件、特殊文件、目录和 `stat` 命令：'
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, look at the permission bits – `0775/-rwxrwxr-x`. Both the numbers and the
    symbol flags have the same meaning but are different representations. `-` means
    the flag is not set. `r` means the file is readable by the current user, group,
    or everyone (reading left to right). `w` means `x` stands for `p` in front, it
    marks this file as a `1`. Other symbols you might see during your operations are
    `d` for `b` for `c` for `s` for **sockets**.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，看看权限位——`0775/-rwxrwxr-x`。数字和符号标志具有相同的意义，但表示方式不同。`-` 表示标志未设置。`r` 表示文件可以被当前用户、组或所有人读取（从左到右读取）。`w`
    表示 `x` 代表 `p` 在前面，它将此文件标记为 `1`。在操作过程中可能会看到的其他符号包括 `d` 代表 `b` 代表 `c` 代表 `s` 代表
    **套接字**。
- en: '**Directory entry (dentry)**: For usability, we will not refer to physical
    files using numbers as the inode does but, instead, using names and locations.
    So, we need a translation table, mapping symbolic names (for users) to inode numbers
    (for the kernel). The easiest way to represent this is through the pathname, such
    as the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录项（dentry）**：为了便于使用，我们不会像inode那样用数字来引用物理文件，而是使用名称和位置。因此，我们需要一个转换表，将符号名称（用于用户）映射到inode编号（用于内核）。最简单的方法是通过路径名来表示，如下所示：'
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the inode is the same as the previous example – `696116`, and
    the symbolic name is `test`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，inode 与上一个例子相同——`696116`，符号名称是 `test`。
- en: '`open()` and destroyed at `close()`. Some of the members this object contains
    are the `open()` method is called for the specific FS realization, and the file
    is placed into the file descriptor table of the calling process. In user-space,
    the file descriptor is used for the application’s file operations.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()` 在 `close()` 时被销毁。这个对象包含的一些成员是，当为特定的文件系统实现调用 `open()` 方法时，文件被放置在调用进程的文件描述符表中。在用户空间中，文件描述符用于应用程序的文件操作。'
- en: 'The following diagram provides an overview of single-file access through multiple
    processes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表提供了通过多个进程访问单个文件的概述：
- en: '![Figure 3.2 – File access organization](img/Figure_3.2_B20833.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 文件访问组织](img/Figure_3.2_B20833.jpg)'
- en: Figure 3.2 – File access organization
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 文件访问组织
- en: We can see a few interesting things here. Although the processes open the same
    file, they go through different execution paths before reaching the real data.
    First of all, the processes have their own `fork()`, the child gets the same **open
    file table**. The independent process points to a separate one. Then, let’s say
    we have two **dentries** for the same file and our file objects point to it. Such
    a situation occurs when we reach the same physical file through different pathnames.
    As we work with the same file, the entries will point to a single inode and **superblock**
    instances. From then on, the exact FS, where the file resides, will take over
    with its specific functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到一些有趣的事情。尽管进程打开的是同一个文件，但在到达真实数据之前，它们会经过不同的执行路径。首先，进程有自己的`fork()`，子进程获得相同的**打开文件表**。独立进程指向一个单独的表。然后，假设我们有两个指向同一文件的**dentry**，我们的文件对象指向它。这种情况发生在我们通过不同的路径名到达同一物理文件时。当我们处理同一个文件时，条目将指向单个inode和**超级块**实例。从那时起，确切地讲，文件所在的文件系统将接管其特定的功能。
- en: 'One disclaimer, though – the OS is not an arbiter of simultaneous file updates
    by multiple processes. It will schedule those operations by the rules we discussed
    in the previous chapter. If you want to make a specific policy for such actions,
    then this must be designed and applied explicitly. Although the FS provides file
    locking as a `sudo rm -rf`, you might delete ones that are currently in use. This
    can lead to irreversible system issues. We use file locking to ensure safe, concurrent
    access to the file’s contents. It allows only one process to access the file at
    a given time, thus avoiding possible race conditions, which you will learn about
    in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086). Linux supports two kinds of
    file locks – advisory locks and mandatory locks, which you can read more about
    here: [https://www.kernel.org/doc/html/next/filesystems/locking.xhtml](https://www.kernel.org/doc/html/next/filesystems/locking.xhtml).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，但有一个免责声明——操作系统不是多个进程同时更新文件的仲裁者。它将按照我们在上一章中讨论的规则调度这些操作。如果您想为这样的操作制定特定的策略，那么这必须被明确设计和应用。尽管文件系统提供了文件锁定作为`sudo
    rm -rf`，但你可能会删除当前正在使用的文件。这可能导致不可逆转的系统问题。我们使用文件锁定来确保对文件内容的并发访问安全。它允许一次只有一个进程访问文件，从而避免可能的竞争条件，你将在[*第六章*](B20833_06.xhtml#_idTextAnchor086)中了解到这一点。Linux支持两种类型的文件锁定——建议性锁定和强制锁定，你可以在这里了解更多信息：[https://www.kernel.org/doc/html/next/filesystems/locking.xhtml](https://www.kernel.org/doc/html/next/filesystems/locking.xhtml)。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The unique numbers for physical file identification through the respective inodes
    are not endless. The VFS might contain so many tiny files that it exhausts its
    abilities to create new files, while there’s still free space on the NVM. This
    error is observed on high-scale systems more often than you may think.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过各自的inode进行物理文件唯一标识的数字不是无限的。VFS可能包含如此多的微小文件，以至于它耗尽了创建新文件的能力，而NVM上仍有空闲空间。这种情况在高规模系统中比你想的更常见。
- en: 'You’ve probably also wondered about the ways to reach the same file through
    different pathnames. Well, do you recall our discussion on link files in [*Chapter
    1*](B20833_01.xhtml#_idTextAnchor014)? We talked about **hard links** and **symbolic
    links**. The first ones are always available for a given file – for example, when
    there’s at least one hard link, related to a piece of data, then the corresponding
    file is considered to exist in the FS. Through it, a pathname is directly associated
    with the point on the NVM where the file resides and can be opened from. Multiple
    pathnames to the same point on the device lead to multiple hard link constructions.
    Let’s check it out. First, we will list the data for some of our files:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也想知道如何通过不同的路径名访问相同的文件。嗯，你还记得我们在[*第一章*](B20833_01.xhtml#_idTextAnchor014)中关于链接文件的讨论吗？我们谈到了**硬链接**和**符号链接**。对于给定的文件，硬链接总是可用的——例如，当至少有一个与数据相关的硬链接时，相应的文件被认为是存在于文件系统中的。通过它，路径名直接与文件所在的NVM上的点相关联，并且可以从那里打开。指向设备上同一点的多个路径名会导致多个硬链接构造。让我们来看看。首先，我们将列出一些文件的详细信息：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will create a hard link for the same file through the `ln` command,
    and list both files:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过`ln`命令为同一文件创建一个硬链接，并列出这两个文件：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, they both have the same inode because they have different character
    names, but they are the same file. The only true representation of the file is
    the `695571`. This means they truly point to the same block of the hard drive.
    Then, we see that the hard link counter has increased from `1` to `2` (between
    the access permissions and the `uid` columns).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们都具有相同的inode，因为它们具有不同的字符名称，但它们是同一文件。文件的唯一真实表示是`695571`。这意味着它们真正指向硬盘上的同一块。然后，我们看到硬链接计数已从`1`增加到`2`（在访问权限和`uid`列之间）。
- en: '`ln` command again, but this time we will add the `-s` option. We will list
    all of the files so far:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`ln`命令，但这次我们将添加`-s`选项。我们将列出迄今为止的所有文件：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can easily see that the new file – `some_data_sl` – has a different inode
    from the original file and its hard link. It points to a new location in the NVM
    and has its own access permissions. In addition, it shows visually which pathname
    it truly points to. Even if there’s a symbolic link to a symbolic link, `ls -li`
    will still present the file a symbolic link is set to point to, such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地看到新文件 – `some_data_sl` – 与原始文件及其硬链接有不同的inode。它指向NVM中的新位置，并有自己的访问权限。此外，它还直观地显示了它真正指向的路径名。即使存在指向符号链接的符号链接，`ls
    -li`也会显示符号链接设置的指向文件，如下所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And check out the sizes in bytes – the original file is only `4247` bytes in
    size, while the symbolic link is `8` bytes, and the next is `10`. Actually, the
    original file size doesn’t matter for the symbolic link’s size, but something
    else does – you could figure it out by counting the number of characters in the
    referred file’s **pathname**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后查看字节大小 – 原始文件的大小仅为`4247`字节，而符号链接的大小为`8`字节，下一个为`10`。实际上，原始文件的大小对符号链接的大小没有影响，但其他因素确实如此
    – 您可以通过计算引用文件**路径名**中的字符数来找出它。
- en: 'All of the preceding filenames will provide you with the ability to access
    and modify the file. They also provide you with the flexibility to get data from
    multiple access points without duplication and meaningless usage of extra storage
    space. Many system programmers use symbolic links to reorder the FS, just for
    the purposes of easier data management for some specialized user processes. The
    Linux system itself does that, just to reorder the FS hierarchy for the same reasons.
    Let’s create an overview of this example through the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前缀文件名都将为您提供访问和修改文件的能力。它们还为您提供从多个访问点获取数据的灵活性，而无需重复使用和无效地使用额外的存储空间。许多系统程序员使用符号链接来重新排序文件系统，仅为了便于某些专用用户进程的数据管理。Linux系统本身也这样做，只是为了重新排序文件系统层次结构，出于同样的原因。让我们通过以下图表创建这个示例的概述：
- en: '![Figure 3.3 – A hard link and symbolic link overview](img/Figure_3.3_B20833.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 硬链接和符号链接概述](img/Figure_3.3_B20833.jpg)'
- en: Figure 3.3 – A hard link and symbolic link overview
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 硬链接和符号链接概述
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Even if the original file is moved or deleted, the symbolic link will continue
    to point to its pathname as a target, while the hard link must point to an existing
    file. The symbolic link will work across partitions, but the hard link doesn’t
    link paths on different volumes or FSes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使原始文件被移动或删除，符号链接也会继续指向其路径名作为目标，而硬链接必须指向一个现有文件。符号链接可以在分区间工作，但硬链接不能在不同卷或文件系统上的路径之间建立链接。
- en: In the next section, we will continue to manipulate files, but this time through
    C++ code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续操作文件，但这次是通过C++代码。
- en: Executing FS operations with C++
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++执行文件系统操作
- en: 'With C++17 FS operations that are closer to the system programming are facilitated.
    The FS library allows the C++ developer to distinguish between the Linux fs types
    and perform certain operations with them. Let’s take a look at an exemplary interface:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，更接近系统编程的文件系统操作得到了简化。FS库允许C++开发者区分Linux的文件系统类型，并对其执行某些操作。让我们看看一个示例接口：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method checks whether a given pathname is a `is_fifo()`, `is_regular_file()`,
    `is_socket()`, and `is_symlink()`. Can you tell why we don’t have the `is_hardlink()`
    method? That’s right – if two files with different character names point to a
    single inode, then both of them provide access to the same content. It doesn’t
    matter whether the inode’s hard link counter is higher than one, although we could
    get it through the `hard_link_count()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查给定的路径名是否是`is_fifo()`、`is_regular_file()`、`is_socket()`和`is_symlink()`。你能告诉我为什么我们没有`is_hardlink()`方法吗？没错——如果两个具有不同字符名称的文件指向同一个inode，那么它们都提供了对相同内容的访问。尽管我们可以通过`hard_link_count()`方法获取inode的硬链接计数器，但这并不重要。
- en: As the C++ language is compilable on multiple OSes, the FS functions are also
    dependent on the respective FSes for those exact systems. For example, FAT does
    not support symbolic links; therefore, the methods related to them will fail,
    and the error handling is left to the system programmer. You can use the `std::filesystem::filesystem_error`
    exception object to get details about the current error’s FS error state. Such
    discussions are available in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++语言可以在多个操作系统上编译，FS函数也依赖于那些特定系统的相应FS。例如，FAT不支持符号链接；因此，与之相关的函数将失败，错误处理留给系统程序员。你可以使用`std::filesystem::filesystem_error`异常对象来获取当前错误FS错误状态的相关细节。这类讨论可以在[*第五章*](B20833_05.xhtml#_idTextAnchor075)中找到。
- en: We mentioned earlier that the concurrent file access has to be managed by the
    software engineer, or the OS will schedule the operations as it sees fit. The
    same goes for this library, too. Don’t expect it to handle race conditions or
    modification conflicts itself. Now, let’s see how some of the operations can be
    used. One disclaimer though – as mentioned, error conditions will be discussed
    later, so we will not focus on them here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，并发文件访问必须由软件工程师管理，否则操作系统将根据其看法调度操作。这个库也是如此。不要期望它能够自行处理竞争条件或修改冲突。现在，让我们看看一些操作如何使用。不过有一个免责声明——正如之前提到的，错误条件将在稍后讨论，所以这里不会关注它们。
- en: 'We will create a new directory (marker `{1}` in the following code segment):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下代码段中的标记 `{1}`处创建一个新的目录：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s see what happened on the FS:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看FS上发生了什么：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you call the program again, it will fail, as the directory already exists:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次调用程序，它将失败，因为目录已经存在：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We populate the new directory, as described in the example earlier (*see* *Figure
    3**.3*), but this time with C++ code (markers `{1}` and `{2}` in the following
    code):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照之前的示例（*见图3**.3*）描述的方式填充新目录，但这次使用C++代码（以下代码中的标记 `{1}` 和 `{2}`）：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Of course, it is important to call the program from the directory, where `some_data`
    is, or provide its pathname accordingly – through the `some_data`, so it’s `9`
    bytes in size. Still, the picture is almost the same – of course, the inodes are
    different:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从`some_data`所在的目录调用程序，或者相应地提供其路径名——通过`some_data`，所以它的大小是`9`字节。尽管如此，画面几乎相同——当然，inode是不同的：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also create by hand a new inner directory, called `inner_test_dir`, with
    a new file, called `inner_some_data`. Let’s iterate through the directory, both
    non-recursively (marker `{1}` in the following code) and recursively, and print
    out the directory contents (marker `{2}` in the following code):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还手动创建了一个新的内部目录，称为`inner_test_dir`，并添加了一个新文件，称为`inner_some_data`。让我们迭代目录，既非递归（以下代码中的标记
    `{1}`），也递归（以下代码中的标记 `{2}`），并打印出目录内容：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is not surprising:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出并不令人惊讶：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we want to check whether some of the files are symbolic links (marker
    `{1}` in the following code), and if so, let’s print out their targets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要检查一些文件是否是符号链接（以下代码中的标记 `{1}`），如果是，就打印出它们的目标：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, the output is as expected – the target is the initial source file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，输出符合预期——目标是初始源文件：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s try to rename the symbolic link file (marker `{1}` in the following code
    segment), before we continue with some other modifications:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行其他修改之前，让我们尝试重命名符号链接文件（以下代码段中的标记 `{1}`），：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We see that the renaming is successful:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到重命名是成功的：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s remove the initial file – `some_data` (marker `{2}` in the following
    code), and observe the free space on the system changing (markers `{1}` and `{3}`
    in the following code):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除初始文件——`some_data`（以下代码中的标记 `{2}`），并观察系统上的空闲空间变化（以下代码中的标记 `{1}` 和 `{3}`）：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here’s the output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see `4096` bytes have been freed, although the file was only `9`
    bytes in size. This is because the minimum value we actually use is the size of
    one NVM block – the smallest unit of data the OS can write in or read from a file.
    In this case, it is 4 KB. If the details are not interesting to you, but you only
    want to check whether the space values have been updated, then with C++ 20, you
    also have the `==` operator overload; thus you can directly compare the two `space_info`
    objects, which are actually behind the returned values of `space()` (markers `{1}`
    and `{3}`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，已经释放了 `4096` 字节，尽管文件的大小只有 `9` 字节。这是因为我们实际使用的最小值是一个 NVM 块的大小——操作系统可以写入或从文件中读取的最小数据单元。在这种情况下，它是
    4 KB。如果你对细节不感兴趣，但只想检查空间值是否已更新，那么在 C++ 20 中，你也有 `==` 操作符重载；因此，你可以直接比较两个 `space_info`
    对象，这些对象实际上是 `space()` 返回的值（标记 `{1}` 和 `{3}`）。
- en: We used these code examples to go quickly through the C++ filesystem library.
    We hope it is a good overview for you, although we have jumped a bit from function
    to function. It should be useful in your work. The next section deals with something
    very important – the fundamentals of multi-process communication. As you already
    know from the beginning of this chapter, Linux treats everything that’s not a
    process as a file. The same goes for communication resources, and we will delve
    into them armed with our C++ knowledge. There will be a bit more theory, so stay
    with us!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些代码示例快速浏览了 C++ 文件系统库。我们希望这对您来说是一个很好的概述，尽管我们从函数跳到了函数。它应该对您的工作有所帮助。下一节将处理一个非常重要的话题——多进程通信的基础。正如您从本章的开头就已经知道的那样，Linux
    将一切不是进程的东西都视为文件。通信资源也是如此，我们将带着我们的 C++ 知识深入探讨。会有一些更多的理论，所以请继续关注我们！
- en: IPC through anonymous pipes and named pipes
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过匿名管道和命名管道进行 IPC
- en: 'Before we even start working on this topic, let us ask you this. Have you ever
    done the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始研究这个主题之前，让我们问你这个问题。你曾经做过以下事情吗？
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If yes, then you probably call `|` a `|`-symbolled pipe the same as them? No!
    That’s an anonymous pipe. System programmers differentiate between the so-called
    `pipefs`, while the user executes the standard VFS system calls. We are going
    to use pipes as examples to visualize some observations for the FS as well. Let’s
    get into it then!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是的话，那么你可能把 `|` 称为带有 `|` 符号的管道，和它们一样？不！那是一个匿名管道。系统程序员在所谓的 `pipefs` 之间进行区分，而用户执行标准的
    VFS 系统调用。我们将使用管道作为例子来可视化一些关于文件系统的观察。那么，让我们开始吧！
- en: Anonymous or unnamed pipes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名或未命名的管道
- en: '`|` symbol, you can easily conclude that such implementation is related more
    to short-term communication, and it is not persistent in time. Anonymous pipes
    have two endpoints – a read one and a write one. Both of these are represented
    by a file descriptor. As soon as both endpoints are closed, the pipe will be destroyed,
    as there are no more ways to reference it through an open file descriptor. In
    addition, this type of communication is known as a simplex FIFO communication
    – for example, it creates a one-way-only data transfer – most often from a parent
    process to a child. Let’s see one example, which uses the system calls to create
    an anonymous pipe and a simple data transfer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 符号，你可以很容易地得出结论，这种实现更多地与短期通信相关，并且它在时间上不是持久的。匿名管道有两个端点——一个读端和一个写端。这两个端点都由一个文件描述符表示。一旦两个端点都关闭，管道就会被销毁，因为没有更多的方式可以通过打开的文件描述符来引用它。此外，这种类型的通信被称为单工
    FIFO 通信——例如，它创建了一个单向数据传输——通常是从父进程到子进程。让我们看一个例子，它使用系统调用创建一个匿名管道和一个简单的数据传输：'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We require an integer array to hold the file descriptors, representing the
    pipe’s *in* and *out* endpoints – `a_pipe`. Then, this array is passed to the
    `pipe()` system call, which will return `-1` if there is an error, or `0` on success
    (see marker `{1}`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个整数数组来保存文件描述符，表示管道的 *in* 和 *out* 端点——`a_pipe`。然后，这个数组被传递给 `pipe()` 系统调用，如果发生错误，它将返回
    `-1`，如果成功，则返回 `0`（见标记 `{1}`）：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create a new process through `fork()`, as we did in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029).
    Knowing this, can you tell how many pipes are created at the end? That’s right
    – one pipe is created, and the file descriptors are shared between the processes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `fork()` 创建一个新的进程，就像我们在 [*第 2 章*](B20833_02.xhtml#_idTextAnchor029) 中做的那样。了解这一点后，你能告诉我最后创建了多少个管道吗？没错——创建了一个管道，文件描述符在进程之间共享。
- en: 'As the data transfer is one-way, we need to close the unused endpoint for each
    process – markers `{2}` and `{4}`. If the process writes and reads its own **pipe**
    in and out file descriptors, it will only get the information that it has written
    there beforehand:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据传输是单向的，我们需要为每个进程关闭未使用的端点 – 标记 `{2}` 和 `{4}`。如果进程在其自己的**管道**中写入和读取文件描述符，它将只能获得之前写入那里的信息：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In other words, we forbid the child from *talking* *back* to the parent, and
    the parent can only send data to the child. The data is sent simply by writing
    it into a file and reading from it (see markers `{3}` and `{5}`). This is a very
    simple piece of code, and usually, the communication through anonymous pipes is
    that simple. However, be careful – `write()` and `read()` are blocking calls;
    if there’s nothing to be read from the pipe (the pipe buffer is empty), the respective
    process-reader will be blocked. If the pipe capacity is exhausted (the pipe buffer
    is full), the process-writer will be blocked. If there’s no reader to consume
    the data, `SIGPIPE` will be triggered. We will provide such an example in the
    last section of this chapter. There’s no risk of race conditions in the way we
    will present them in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086), but synchronization
    of data creation and consumption is still in the programmer’s hands. The next
    diagram provides you with some additional information on what happens when we
    use the anonymous pipe:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们禁止孩子*回嘴*父母，而父母只能向孩子发送数据。数据通过将其写入文件并从中读取（见标记 `{3}` 和 `{5}`）来发送。这是一段非常简单的代码，通常，通过匿名管道的通信就是那么简单。然而，请注意
    – `write()` 和 `read()` 是阻塞调用；如果没有从管道中读取的内容（管道缓冲区为空），相应的进程读取器将被阻塞。如果管道容量耗尽（管道缓冲区已满），进程写入器将被阻塞。如果没有读取器来消耗数据，将触发
    `SIGPIPE`。我们将在本章的最后部分提供一个这样的例子。在[*第 6 章*](B20833_06.xhtml#_idTextAnchor086)中，我们将展示的方式不会有竞态条件风险，但数据创建和消费的同步仍然掌握在程序员手中。下面的图表提供了当我们使用匿名管道时发生的一些额外信息：
- en: '![Figure 3.4 – An anonymous pipe communication mechanism](img/Figure_3.4_B20833.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 匿名管道通信机制](img/Figure_3.4_B20833.jpg)'
- en: Figure 3.4 – An anonymous pipe communication mechanism
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 匿名管道通信机制
- en: 'In the background, at the kernel level, there are a few more operations going
    on:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，在内核级别，还有一些其他操作在进行：
- en: '![Figure 3.5 – Anonymous pipe creation](img/Figure_3.5_B20833.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 匿名管道创建](img/Figure_3.5_B20833.jpg)'
- en: Figure 3.5 – Anonymous pipe creation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 匿名管道创建
- en: The pipe’s capacity can be checked and set using the `fcntl(fd, F_GETPIPE_SZ)`
    and `F_SETPIPE_SZ` operations, respectively. You can see that the pipe has 16
    *pages* by default. The *page* is the smallest unit of data the *virtual memory*
    can manage. If a single page is 4,096 KB, then it could transfer 65,536 bytes
    of data before it overflows. We will discuss this later in the chapter. However,
    keep in mind that some systems may vary, and the info from *Figure 3**.5* might
    be wrong for you. In a similar fashion, we can represent what happens at a lower
    level during `read()` and `write()` operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `fcntl(fd, F_GETPIPE_SZ)` 和 `F_SETPIPE_SZ` 操作分别检查和设置管道的容量。您可以看到，管道默认有 16
    个 *页面*。*页面*是虚拟内存可以管理的最小数据单位。如果一个页面是 4,096 KB，那么在溢出之前它可以传输 65,536 字节的数据。我们将在本章后面讨论这个问题。然而，请记住，一些系统可能会有所不同，*图
    3**.5* 中的信息可能对您是错误的。以类似的方式，我们可以在 `read()` 和 `write()` 操作的较低级别表示发生的事情。
- en: In the following diagram, the question of using an FS as a shared (global) memory
    arises. Note that although the FS has its own protection mechanisms through mutexes,
    this will not help us at a user level to synchronize the data correctly. Simply
    modifying a regular file through multiple processes will cause trouble, as mentioned
    earlier. Doing so with a pipe will cause less trouble, but we are still not on
    the safe side. As you can see, the **scheduler** is involved, and we might end
    up in a **deadlock** of constantly waiting processes. This is easier to avoid
    with anonymous pipes than with named pipes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，使用文件系统作为共享（全局）内存的问题出现了。请注意，尽管文件系统通过互斥锁有自己的保护机制，但这在用户级别上并不能帮助我们正确同步数据。通过多个进程简单地修改常规文件将导致问题，如前所述。使用管道这样做会带来较少的问题，但我们仍然不处于安全状态。正如您所看到的，**调度器**参与了其中，我们可能会陷入不断等待的进程的**死锁**。与命名管道相比，使用匿名管道更容易避免这种情况。
- en: '![Figure 3.6 – Pipe read and write operations](img/Figure_3.6_B20833.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 管道读写操作](img/Figure_3.6_B20833.jpg)'
- en: Figure 3.6 – Pipe read and write operations
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 管道读写操作
- en: Now that we have our communication established, why do we need an additional
    file type such as the named pipe? We will discuss this in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了通信，为什么还需要像命名管道这样的额外文件类型呢？我们将在下一节中讨论这个问题。
- en: Named pipes
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名管道
- en: 'Named pipes are *a bit more complex* than anonymous pipes, as there’s more
    programable context to them. For example, they have character names and are observable
    by a user in an FS. They are not destroyed after a process finishes working with
    them but, instead, when a specific system call for the file removal is executed
    – `unlink()`. Therefore, we can say that they provide *persistency*. In a similar
    fashion to anonymous pipes, we can demonstrate named pipes in the following CLI
    command, creating `fifo_example` as a result:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道比匿名管道要复杂一些，因为它们有更多的可编程上下文。例如，它们有字符名称，并且可以在文件系统（FS）中被用户观察到。它们在进程完成与它们的工作后不会被销毁，而是在执行特定系统调用以删除文件时——`unlink()`——才会被销毁。因此，我们可以说它们提供了
    *持久性*。与匿名管道类似，我们可以在以下 CLI 命令中演示命名管道，结果创建 `fifo_example`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, the communication is duplexed – for example, the data transfer could
    work both ways. Still, your work might push you in the direction of wrapping system
    calls with C++ code. The next example provides a sample overview, with the disclaimer
    that it is exemplary, and as C++ context is added to the code, the program becomes
    larger in size. Let’s get an example from the **pipe** from earlier, which we
    can modify with C++ code, but the behavior remains the same:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通信是双向的——例如，数据传输可以双向工作。尽管如此，你的工作可能会推动你使用 C++ 代码封装系统调用。下一个示例提供了一个示例概述，免责声明是它是例示性的，并且随着
    C++ 上下文被添加到代码中，程序的大小会变大。让我们从一个早期的 **管道** 示例中获取一个例子，我们可以用 C++ 代码对其进行修改，但行为保持不变：（注意：由于原文中未提供具体的代码示例，因此译文中的“Let’s
    get an example from the **pipe** from earlier, which we can modify with C++ code,
    but the behavior remains the same:”部分仅作为示例，实际翻译时需要根据具体代码内容进行。）
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At marker `{1}`, we introduce the `string_view` object. It represents a pair
    of pointers to a string or an array, and its respective size. As it is a `view-handle`
    class type, we preferably and cheaply pass it by value (see marker `{2}`), together
    with the expected substring operation interface. It is always `const`, so you
    don’t need to declare it as such. So, it’s an object and it’s bigger in size,
    but it has the benefit of being unconditionally safe – taking care of typical
    C string error cases, such as `NULL-termination`. Any issue will be handled at
    compile time. In our case, we can simply use it as a `const char*` or `const string`
    alternative. Let’s proceed with the reader:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记 `{1}` 处，我们引入了 `string_view` 对象。它代表一个指向字符串或数组的指针对及其相应的尺寸。由于它是一个 `view-handle`
    类类型，我们最好以值的方式传递它（见标记 `{2}`），同时提供预期的子字符串操作接口。它始终是 `const`，因此你不需要将其声明为 `const`。所以，它是一个对象，它的大小更大，但它有一个好处，即无条件地安全——处理典型的
    C 字符串错误情况，如 `NULL-termination`。任何问题都会在编译时得到处理。在我们的情况下，我们可以简单地将其用作 `const char*`
    或 `const string` 的替代品。让我们继续进行读取操作：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Markers `{2}` and `{3}` show the C++ wrappers of `write()` and `read()` respectively.
    You can see that instead of doing `strlen()` or `sizeof()` acrobatics, we use
    the `string_view`’s and the `array`’s `data()` and `size()`, respectively, because
    they are packed together through the respective object. One important point is
    that we use `array<char, buf_size>` to be specific about the buffer size and type.
    Similarly, we can use `string` instead of `array`, as it is defined as `basic_string<char>`,
    and we can limit its size with `reserve(buf_size)`. The choice really depends
    on your needs later in the function. In our case, we will use `array` as a direct
    representation of reading a fixed-sized `char` buffer from the pipe. We construct
    the resultant `string` afterward or leave it empty (see marker `{4}`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标记 `{2}` 和 `{3}` 显示了 `write()` 和 `read()` 的 C++ 封装。你可以看到，我们不是做 `strlen()` 或
    `sizeof()` 的杂技，而是分别使用 `string_view` 的 `data()` 和 `array` 的 `size()`，因为它们通过相应的对象打包在一起。一个重要点是，我们使用
    `array<char, buf_size>` 来具体指定缓冲区大小和类型。同样，我们可以使用 `string` 而不是 `array`，因为它定义为 `basic_string<char>`，并且我们可以使用
    `reserve(buf_size)` 来限制其大小。选择实际上取决于你在函数后面的需求。在我们的情况下，我们将使用 `array` 作为从管道直接读取固定大小
    `char` 缓冲区的直接表示。之后我们构建结果 `string` 或者让它为空（见标记 `{4}`）。
- en: 'Now, we will use the already known `exists()` function to discard a second
    `mkfifo()` call by the process that arrives second. Then, we check whether the
    file is truly a FIFO (see marker `{6}`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用已知的 `exists()` 函数来丢弃第二个 `mkfifo()` 调用，该调用由第二个到达的进程执行。然后，我们检查文件是否真正是
    FIFO（见标记 `{6}`）：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, look at markers `{7}` and `{10}`. Do you see where we open the pipe, where
    we keep this result, and where we check its value? Correct – we keep these operations
    packed together in the `if` statement, thus focusing our scope on the same logical
    place. Then, we read from the pipe through the newly added function wrapper (markers
    `{8}` and `{12}`). And then we write to the pipe through the `write()` wrapper
    (markers `{9}` and `{11}`). Note that at marker `{9}`, we pass `string_view` to
    the function, while at marker `{11}`, we pass a `string`. It works for both cases,
    thus additionally proving our point of using `string_views` for such interfaces,
    instead of `const string`, `const char *`, and so on:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看标记 `{7}` 和 `{10}`。你看到我们打开管道、保留这个结果以及检查其值的地方了吗？正确——我们将这些操作打包在一起放在 `if` 语句中，从而将我们的作用域集中在同一个逻辑位置。然后，我们通过新添加的功能包装器（标记
    `{8}` 和 `{12}`）从管道中读取。然后我们通过 `write()` 包装器（标记 `{9}` 和 `{11}`）向管道写入。请注意，在标记 `{9}`
    时，我们向函数传递 `string_view`，而在标记 `{11}` 时，我们传递一个 `string`。这在两种情况下都有效，从而进一步证明了我们使用
    `string_views` 而不是 `const string`、`const char *` 等来处理此类接口的观点：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The pipe is removed at marker `{13}`, but we will keep it for experiments.
    For example, we can list the named pipe:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 管道在标记 `{13}` 处被移除，但我们将保留它进行实验。例如，我们可以列出命名管道：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Please observe that its size is `0`. This means that everything written in was
    consumed. On `close()`, the kernel will flush the file descriptors and will destroy
    the FIFO object in the main memory, as it did for the anonymous pipe. It is possible
    sometimes that the *reader* doesn’t consume the data fully. As you may remember,
    it can store data for 16 pages. That’s why we encourage you to use the number
    of bytes, returned by the `read()` and `write()` functions, to decide whether
    the processes have to be terminated or not. Now, look at the permission bits –
    do you see something interesting there? Yes – there is an extra `p` in front of
    them, which marks this file as a pipe. Did you observe this somewhere earlier
    in the chapter? If not, you can go back and check the permissions bits of the
    inode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其大小为 `0`。这意味着写入的内容已被全部消耗。在 `close()` 时，内核将刷新文件描述符，并在主内存中销毁 FIFO 对象，就像匿名管道那样。有时可能会发生
    *reader* 没有完全消耗数据的情况。如您所记得，它可以存储 16 页的数据。这就是我们鼓励您使用 `read()` 和 `write()` 函数返回的字节数来决定是否需要终止进程的原因。现在，看看权限位——你注意到什么有趣的地方了吗？是的——它们前面有一个额外的
    `p`，这标志着这个文件是一个管道。你之前在章节中观察到这一点了吗？如果没有，你可以回过头去检查inode的权限位。
- en: 'Let’s continue with the last code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看最后的代码片段：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a simple one-time ping-pong application with the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的单次 ping-pong 应用程序，其输出如下：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can still use an IO operation to send the message, but then `string_view`
    wouldn’t do. In the next section, we will provide a brief overview of what happens
    when communication through a pipe is disturbed. To keep the focus on system calls,
    we will put aside C++ for now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以使用 IO 操作来发送消息，但那时 `string_view` 就不适用了。在下一节中，我们将简要概述当通过管道进行通信被干扰时会发生什么。为了保持对系统调用的关注，我们暂时将
    C++ 放在一边。
- en: 'Let’s now return to the C++ filesystem library. We can check whether the current
    file is truly a FIFO file through the library operations. If so, let’s delete
    it with the `remove()` function. It will be the same as `unlink()`, although one
    level of abstraction over the system call itself. Again, this will give us some
    platform independency:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 C++ 文件系统库。我们可以通过库操作检查当前文件是否真的是 FIFO 文件。如果是，我们可以使用 `remove()` 函数将其删除。这和
    `unlink()` 一样，尽管它比系统调用本身多了一层抽象。同样，这将给我们一些平台无关性：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you see, we use the already known methods, which were explained earlier
    in the chapter. Let’s see what happens at the VFS and kernel levels now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用了本章前面解释过的已知方法。现在让我们看看在 VFS 和内核级别会发生什么：
- en: '![Figure 3.7 – Named pipe creation system operations](img/Figure_3.7_B20833.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 命名管道创建系统操作](img/Figure_3.7_B20833.jpg)'
- en: Figure 3.7 – Named pipe creation system operations
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 命名管道创建系统操作
- en: 'This diagram, as well as the next one, gives you an example of why the anonymous
    pipe is considered a bit more lightweight. See how many functions calls there
    are between the initial system call from the process caller until the actual FS
    inode operation is executed. That said, together with the additional effort to
    close and delete files, it is easy to conclude that even the related code is larger.
    Still, the named pipe is used for persistency and communication between different
    processes, including ones that don’t have a parent-child relationship. Just think
    about it – you have the communication resource endpoint in the FS, you know its
    character name, and then you only have to open it from two independent processes,
    and start the data transfer. A similar approach is used by other IPC mechanisms,
    as we will discuss later in [*Chapter 7*](B20833_07.xhtml#_idTextAnchor101). Until
    then, check out the following diagram to see how many operations there are between
    the simple `open()` function and the creation of the FIFO buffer in the kernel:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图以及下一个图给你提供了一个例子，说明了为什么匿名管道被认为稍微轻量一些。看看从进程调用者的初始系统调用到实际FSinode操作执行之间有多少个函数调用。话虽如此，再加上关闭和删除文件所做的额外努力，很容易得出结论，即使是相关的代码也更大。尽管如此，命名管道用于持久性和不同进程之间的通信，包括那些没有父子关系的进程。想想看——你在FS中有通信资源端点，你知道它的字符名称，然后你只需要从两个独立的过程中打开它，并开始数据传输。其他IPC机制也使用了类似的方法，我们将在后面的[*第7章*](B20833_07.xhtml#_idTextAnchor101)中讨论。在此之前，查看以下图表，看看在简单的`open()`函数和内核中创建FIFO缓冲区之间有多少个操作：
- en: '![Figure 3.8 – Named pipe opening and transformation to pipe](img/Figure_3.8_B20833.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 命名管道的打开和转换为管道](img/Figure_3.8_B20833.jpg)'
- en: Figure 3.8 – Named pipe opening and transformation to pipe
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 命名管道的打开和转换为管道
- en: The filesystem library doesn’t allow you to directly work with the file descriptors.
    At the same time, the system calls expect them. Someday, it might be different
    in the C++ Standard.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统库不允许你直接与文件描述符一起工作。同时，系统调用期望它们。将来，在C++标准中可能会有所不同。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There’s an already known non-standard approach to associating a file descriptor
    with `iostream`. You can refer to it here: [http://www.josuttis.com/cppcode/fdstream.xhtml](http://www.josuttis.com/cppcode/fdstream.xhtml).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 已知有一种非标准的将文件描述符与`iostream`关联的方法。你可以在这里参考：[http://www.josuttis.com/cppcode/fdstream.xhtml](http://www.josuttis.com/cppcode/fdstream.xhtml)。
- en: We will use the next section to provide a brief overview of what happens when
    communication through a pipe is disturbed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中简要概述当通过管道进行通信被干扰时会发生什么。
- en: Briefly observing signal handling
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要观察信号处理
- en: Signals in Linux are a powerful and simple way to synchronize processes through
    software interrupts sent to them, indicating that an important event has occurred.
    They have a different nature, depending on their roles. Some of them are ignorable,
    while others are not and cause a process to be blocked, unblocked, or terminated.
    We discussed those behaviors in the previous chapter, but is there something we
    could do to gracefully handle them? We will use the anonymous pipe example to
    trigger a `SIGPIPE` signal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，信号是一种强大且简单的方式，通过向它们发送软件中断来同步进程，表明已发生重要事件。它们具有不同的性质，取决于其角色。其中一些是可以忽略的，而另一些则不行，会导致进程被阻塞、解除阻塞或终止。我们在上一章讨论了这些行为，但我们可以做些什么来优雅地处理它们呢？我们将使用匿名管道示例来触发`SIGPIPE`信号。
- en: 'Let’s see the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We define a `SIGPIPE` handler (marker `{1}`), where we could provide additional
    functionality if this signal is triggered. We intentionally close both the pipe
    endpoints of the child, so there’s no process that would read from it. Then, we
    declare a signal action, which maps the signal handler to the action itself (markers
    `{3}` and `{4}`). We provide some time for the child to close the file descriptors,
    and then we try to write in the **pipe**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`SIGPIPE`处理程序（标记`{1}`），如果这个信号被触发，我们可以提供额外的功能。我们故意关闭子进程的管道端点，这样就没有进程会从它那里读取。然后，我们声明一个信号动作，它将信号处理程序映射到动作本身（标记`{3}`和`{4}`）。我们给子进程一些时间来关闭文件描述符，然后我们尝试在**管道**中写入：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The kernel will trigger `SIGPIPE`, which intends to block the parent until
    there’s someone to read from it. In this case, we print out a message, telling
    the user that the signal is received and the parent process will be terminated.
    Actually, this is the default behavior to handle such a signal. We use the handle
    to inform the user accordingly:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将触发 `SIGPIPE` 信号，其目的是阻塞父进程，直到有读取者出现。在这种情况下，我们会打印一条消息，告知用户已收到信号，父进程将被终止。实际上，这是处理此类信号默认的行为。我们使用处理程序来相应地通知用户：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, we can also ignore the signal through the following simple change
    on marker `{3}`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以通过在标记 `{3}` 上进行以下简单更改来忽略信号：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Calling the program once again will not trigger the handler, which means that
    the signal is ignored and the process will continue as per its workflow. You can
    use both approaches in your code, but be careful – some signals cannot be ignored.
    We will use this knowledge later in the book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用程序不会触发处理程序，这意味着信号被忽略，进程将按照其工作流程继续执行。你可以在代码中使用这两种方法，但请注意——某些信号不能被忽略。我们将在本书的后续内容中使用这一知识。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we didn’t show any examples of file data modifications through
    C++. Our goals were mostly related to explaining the different Linux FS entities.
    We use the C++ filesystem library to enrich the knowledge in this direction –
    for example, improving system programming awareness. You learned about the roles
    of the different FS objects and their specifics. You also have the C++ instruments
    to manage file resources and level up your abstraction. There were also some hands-on
    examples of how to communicate between processes through anonymous and named pipes.
    Their implementation at the OS level was discussed as well, and we briefly explored
    signal handling in Linux.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有展示通过 C++ 修改文件数据的任何示例。我们的目标主要是解释不同的 Linux 文件系统实体。我们使用 C++ 文件系统库来丰富这方面的知识——例如，提高系统编程意识。你了解了不同文件系统对象的作用及其具体细节。你还拥有了
    C++ 工具来管理文件资源并提升你的抽象能力。还有一些关于如何通过匿名和命名管道在进程间通信的实践示例。我们还讨论了它们在操作系统层面的实现，并简要探讨了
    Linux 中的信号处理。
- en: In the next chapter, we will finally dive deeper into the C++ language, laying
    the foundations for its safe and secure usage, according to the latest standard.
    Later in the book, we will revisit some code segments shown in this chapter. We
    will continuously improve them through the usage of new C++ features.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 C++ 语言，根据最新的标准为其安全使用奠定基础。在本书的后续部分，我们将重新审视本章中展示的一些代码片段。我们将通过使用新的
    C++ 特性来不断改进它们。
