- en: Advanced Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级渲染
- en: Often, the first impression that a player will get off your game is from the
    visuals on the screen. Having a strong understanding of creating advanced rendering
    techniques is crucial in building a compelling and immersive experience. In this
    chapter, we look at how we can create some advanced rendering effects by implementing
    shader techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家对游戏的第一印象通常来自屏幕上的视觉效果。深入了解创建高级渲染技术对于构建引人入胜和沉浸式体验至关重要。在本章中，我们将探讨如何通过实现着色器技术来创建一些高级渲染效果。
- en: Introduction to shaders
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器简介
- en: Lighting techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照明技术
- en: Using shaders to create effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用着色器创建效果
- en: Introduction to shaders
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器简介
- en: Simply put, a shader is a computer program that is used to do image processing
    such as special effects, color effects, lighting, and, well, shading. The position,
    brightness, contrast, hue, and other effects on all pixels, vertices, or textures
    used to produce the final image on the screen can be altered during runtime, using
    algorithms constructed in the shader program(s). These days, most shader programs
    are built to run directly on the **Graphical Processing Unit** (**GPU**). Shader
    programs are executed in parallel. This means, for example, that a shader might
    be executed once per pixel, with each of the executions running simultaneously
    on different threads on the GPU. The amount of simultaneous threads depends on
    the graphics card specific GPU, with modern cards sporting processors in the thousands.
    This all means that shader programs can be very performant and provide developers
    with lots of creative flexibility. In this section, we are going to get acquainted
    with shaders and implement our own shader infrastructure for the example engine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，着色器是用于进行图像处理的计算机程序，例如特效、颜色效果、照明和着色。在运行时，可以使用在着色器程序中构建的算法改变屏幕上所有像素、顶点或纹理的位置、亮度、对比度、色调和其他效果，以产生最终图像。如今，大多数着色器程序都是为了直接在**图形处理单元**（**GPU**）上运行而构建的。着色器程序是并行执行的。这意味着，例如，一个着色器可能会在每个像素上执行一次，每次执行都在GPU上的不同线程上同时运行。同时执行的线程数量取决于图形卡特定的GPU，现代卡配备了数千个处理器。所有这些意味着着色器程序可以非常高效，并为开发人员提供了很多创造性的灵活性。在本节中，我们将熟悉着色器并为示例引擎实现自己的着色器基础设施。
- en: Shader languages
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器语言
- en: With advances in graphics card technology, more flexibility has been added to
    the rendering pipeline. Where at one time developers had little control over concepts
    such as fixed-function pipeline rendering, new advancements have allowed programmers
    to take deeper control of graphics hardware for rendering their creations. Originally,
    this deeper control was achieved by writing shaders in assembly language, which
    was a complex and cumbersome task. It wasn't long before developers yearned for
    a better solution. Enter the shader programming languages. Let's take a brief
    look at a few of the more common languages in use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着图形卡技术的进步，渲染管线增加了更多的灵活性。曾经开发人员对于固定功能管线渲染等概念几乎没有控制权，新的进步使程序员能够更深入地控制图形硬件来渲染他们的作品。最初，这种更深入的控制是通过使用汇编语言编写着色器来实现的，这是一项复杂而繁琐的任务。不久之后，开发人员渴望有一个更好的解决方案。着色器编程语言应运而生。让我们简要地看一下一些常用的语言。
- en: '**C for graphics** (**Cg**) is a shading language originally developed by the
    Nvidia graphics company. Cg is based on the C programming language and, although
    they share the same syntax, some features of C were modified and new data types
    were added to make Cg more suitable for programming GPUs. Cg compilers can output
    shader programs supported by both DirectX and OpenGL. While Cg was mostly deprecated,
    it has seen a resurgence in a new form with its use in the Unity game engine.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形C**（**Cg**）是由Nvidia图形公司最初开发的着色语言。Cg基于C编程语言，尽管它们共享相同的语法，但对C的一些特性进行了修改，并添加了新的数据类型，使Cg更适合于编程GPU。Cg编译器可以输出由DirectX和OpenGL都支持的着色器程序。虽然Cg大部分已经被淘汰，但它在Unity游戏引擎中的使用使其以一种新形式复兴。'
- en: '**High-Level Shading Language** (**HLSL**) is a shading language developed
    by the Microsoft Corporation for use with the DirectX graphics API. HLSL is again
    modeled after the C programming language and shares many similarities to the Cg
    shading language. HLSL is still in development and continues to be the shading
    language of choice for DirectX. Since the release, DirectX 12 the HLSL language
    supports even lower level hardware control and has seen dramatic performance improvements.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级着色语言**（**HLSL**）是由微软公司为DirectX图形API开发的着色语言。HLSL再次是基于C编程语言建模，并且与Cg着色语言有许多相似之处。HLSL仍在开发中，并且继续是DirectX的首选着色语言。自DirectX
    12发布以来，HLSL语言甚至支持更低级的硬件控制，并且性能有了显著的改进。'
- en: '**OpenGL Shading Language** (**GLSL**) is a shading language that is also based
    on the C programming language. It was created by the **OpenGL Architecture Review
    Board** (**OpenGL ARB**) to give developers more direct control of the graphics
    pipeline without having to use ARB assembly language or other hardware-specific
    languages. The language is still in open development and will be the language
    we will focus on in our examples.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL着色语言**（**GLSL**）是一种基于C编程语言的着色语言。它是由**OpenGL架构审查委员会**（**OpenGL ARB**）创建的，旨在使开发人员能够更直接地控制图形管线，而无需使用ARB汇编语言或其他硬件特定语言。该语言仍在开发中，并且将是我们在示例中专注的语言。'
- en: Building a shader program infrastructure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建着色器程序基础设施
- en: 'Most modern shader programs are composed of up to five different types of shader
    files: fragment or pixel shaders, vertex shaders, geometry shaders, compute shaders,
    and tessellation shaders. When building a shader program, each of these shader
    files must be compiled and linked together for use, much like how a C++ program
    is compiled and linked. Next, we are going to walk you through how this process
    works and see how we can build an infrastructure to allow for easier interaction
    with our shader programs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代着色器程序由多达五种不同类型的着色器文件组成：片段或像素着色器、顶点着色器、几何着色器、计算着色器和镶嵌着色器。构建着色器程序时，每个这些着色器文件必须被编译和链接在一起以供使用，就像C++程序的编译和链接一样。接下来，我们将带您了解这个过程是如何工作的，看看我们如何构建一个基础设施，以便更轻松地与我们的着色器程序进行交互。
- en: To get started, let's look at how we compile a GLSL shader. The GLSL compiler
    is part of the OpenGL library itself, and our shaders can be compiled within an
    OpenGL program. We are going to build an architecture to support this internal
    compilation. The whole process of compiling a shader can be broken down into some
    simple steps. First, we have to create a shader object, then provide the source
    code to the shader object. We can then ask the shader object to be compiled. These
    steps can be represented in the following three basic calls to the OpenGL API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何编译GLSL着色器。GLSL编译器是OpenGL库的一部分，我们的着色器可以在OpenGL程序中进行编译。我们将构建一个支持内部编译的架构。编译着色器的整个过程可以分解为一些简单的步骤。首先，我们必须创建一个着色器对象，然后将源代码提供给着色器对象。然后我们可以要求着色器对象被编译。这些步骤可以用以下三个基本调用来表示OpenGL
    API。
- en: 'First, we create the shader object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建着色器对象：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create the shader object using the `glCreateShader()` function. The argument
    we pass in is the type of shader we are trying to create. The types of shaders
    can be `GL_VERTEX_SHADER`, `GL_FRAGMENT_SHADER`, `GL_GEOMETRY_SHADER`, `GL_TESS_EVALUATION_SHADER`,
    `GL_TESS_CONTROL_SHADER`, or `GL_COMPUTE_SHADER`. In our example case, we are
    trying to compile a vertex shader, so we use the `GL_VERTEX_SHADER` type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`glCreateShader()`函数创建着色器对象。我们传递的参数是我们要创建的着色器的类型。着色器的类型可以是`GL_VERTEX_SHADER`、`GL_FRAGMENT_SHADER`、`GL_GEOMETRY_SHADER`、`GL_TESS_EVALUATION_SHADER`、`GL_TESS_CONTROL_SHADER`或`GL_COMPUTE_SHADER`。在我们的示例中，我们尝试编译一个顶点着色器，所以我们使用`GL_VERTEX_SHADER`类型。
- en: 'Next, we copy the shader source code into the shader object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将着色器源代码复制到着色器对象中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we are using the `glShaderSource()` function to load our shader source
    to memory. This function accepts an array of strings, so before we call `glShaderSource()`,
    we create a pointer to the start of the `shaderCode` array object using a still-to-be-created
    method. The first argument to `glShaderSource()` is the handle to the shader object.
    The second is the number of source code strings that are contained in the array.
    The third argument is a pointer to an array of source code strings. The final
    argument is an array of `GLint` values that contains the length of each source
    code string in the previous argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`glShaderSource()`函数将我们的着色器源代码加载到内存中。这个函数接受一个字符串数组，所以在调用`glShaderSource()`之前，我们使用一个尚未创建的方法创建一个指向`shaderCode`数组对象开头的指针。`glShaderSource()`的第一个参数是着色器对象的句柄。第二个是包含在数组中的源代码字符串的数量。第三个参数是指向源代码字符串数组的指针。最后一个参数是包含前一个参数中每个源代码字符串的长度的`GLint`值的数组。
- en: 'Finally, we compile the shader:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编译着色器：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last step is to compile the shader. We do this by calling the OpenGL API
    method, `glCompileShader()`, and passing the handle to the shader that we want
    compiled.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是编译着色器。我们通过调用OpenGL API方法`glCompileShader()`来实现这一点，并传递我们想要编译的着色器的句柄。
- en: Of course, because we are using memory to store the shaders, we should know
    how to clean up when we are done. To delete a shader object, we can call the `glDeleteShader()`
    function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为我们正在使用内存来存储着色器，我们应该知道如何在完成后进行清理。要删除着色器对象，我们可以调用`glDeleteShader()`函数。
- en: Deleting a Shader `ObjectShader` objects can be deleted when no longer needed
    by calling `glDeleteShader()`. This frees the memory used by the shader object.
    It should be noted that if a shader object is already attached to a program object,
    as in linked to a shader program, it will not be immediately deleted, but rather
    flagged for deletion. If the object is flagged for deletion, it will be deleted
    when it is detached from the linked shader program object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 删除着色器对象当不再需要着色器对象时，可以通过调用`glDeleteShader()`来删除。这将释放着色器对象使用的内存。应该注意，如果着色器对象已经附加到程序对象，即链接到着色器程序，它不会立即被删除，而是被标记为删除。如果对象被标记为删除，它将在从链接的着色器程序对象中分离时被删除。
- en: Once we have compiled our shaders, the next step we need to take before we can
    use them in our program is to link them together into a complete shader program.
    One of the core aspects of the linking step involves making the connections between
    input variables from one shader to the output variables of another and making
    the connections between the input/output variables of a shader to appropriate
    locations in the OpenGL program itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了我们的着色器，我们在将它们用于程序之前需要采取的下一步是将它们链接在一起成为一个完整的着色器程序。链接步骤的核心方面之一涉及从一个着色器的输入变量到另一个着色器的输出变量之间建立连接，并在着色器的输入/输出变量与OpenGL程序本身的适当位置之间建立连接。
- en: 'Linking is much like compiling the shader. We create a new shader program and
    attach each shader object to it. We then tell the shader program object to link
    everything together. The steps to accomplish this in the OpenGL environment can
    be broken down into a few calls to the API, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 链接与编译着色器非常相似。我们创建一个新的着色器程序，并将每个着色器对象附加到它上。然后我们告诉着色器程序对象将所有内容链接在一起。在OpenGL环境中实现这些步骤可以分解为对API的几个调用，如下所示：
- en: 'First, we create the shader program object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建着色器程序对象：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To start, we call the `glCreateProgram()` method to create an empty program
    object. This function returns a handle to the shader program object which, in
    this example, we are storing in a variable named `shaderProgram`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`glCreateProgram()`方法创建一个空的程序对象。这个函数返回一个句柄给着色器程序对象，这个例子中我们将其存储在一个名为`shaderProgram`的变量中。
- en: 'Next, we attach the shaders to the program object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将着色器附加到程序对象：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To load each of the shaders into the shader program, we use the `glAttachShader()`
    method. This method takes two arguments. The first argument is the handle to the
    shader program object, and the second is the handle to the shader object to be
    attached to the shader program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将每个着色器加载到着色器程序中，我们使用`glAttachShader()`方法。这个方法接受两个参数。第一个参数是着色器程序对象的句柄，第二个是要附加到着色器程序的着色器对象的句柄。
- en: 'Finally, we link the program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们链接程序：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we are ready to link the shaders together we call the `glLinkProgram()`
    method. This method has only one argument: the handle to the shader program we
    want to link.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备将着色器链接在一起时，我们调用`glLinkProgram()`方法。这个方法只有一个参数：我们要链接的着色器程序的句柄。
- en: 'It''s important that we remember to clean up any shader programs that we are
    not using anymore. To remove a shader program from the OpenGL memory, we call
    `glDeleteProgram()` method. The `glDeleteProgram()` method takes one argument:
    the handle to the shader program that is to be deleted. This method call invalidates
    the handle and frees the memory used by the shader program. It is important to
    note that if the shader program object is currently in use, it will not be immediately
    deleted, but rather flagged for deletion. This is similar to the deletion of shader
    objects. It is also important to note that the deletion of a shader program will
    detach any shader objects that were attached to the shader program at linking
    time. This, however, does mean the shader object will be deleted immediately unless
    those shader objects have already been flagged for deletion by a previous call
    to the `glDeleteShader()` method.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们记得清理掉我们不再使用的任何着色器程序。要从OpenGL内存中删除着色器程序，我们调用`glDeleteProgram()`方法。`glDeleteProgram()`方法接受一个参数：要删除的着色器程序的句柄。这个方法调用使句柄无效，并释放着色器程序使用的内存。重要的是要注意，如果着色器程序对象当前正在使用，它不会立即被删除，而是被标记为删除。这类似于删除着色器对象。还要注意，删除着色器程序将分离在链接时附加到着色器程序的任何着色器对象。然而，这并不意味着着色器对象会立即被删除，除非这些着色器对象已经被之前调用`glDeleteShader()`方法标记为删除。
- en: So those are the simplified OpenGL API calls required to create, compile, and
    link shader programs. Now we are going to move onto implementing some structure
    to make the whole process much easier to work with. To do this, we are going to
    create a new class called `ShaderManager`. This class will act as the interface
    for compiling, linking, and managing the cleanup of shader programs. To start
    with, let's look at the implementation of the `CompileShaders()` method in the
    `ShaderManager.cpp` file. I should note that I will be focusing on the important
    aspects of the code that pertain to the implementation of the architecture. The
    full source code for this chapter can be found in the `Chapter07` folder in the
    GitHub repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是创建、编译和链接着色器程序所需的简化OpenGL API调用。现在我们将继续实现一些结构，使整个过程更容易处理。为此，我们将创建一个名为`ShaderManager`的新类。这个类将充当编译、链接和管理着色器程序清理的接口。首先，让我们看一下`ShaderManager.cpp`文件中`CompileShaders()`方法的实现。我应该指出，我将专注于与架构实现相关的代码的重要方面。本章的完整源代码可以在GitHub存储库的`Chapter07`文件夹中找到。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To begin, for this example we are focusing on two of the shader types, so our
    `ShaderManager::CompileShaders()` method accepts two arguments. The first argument
    is the file path location of the vertex shader file, and the second is the file
    path location to the fragment shader file. Both are strings. Inside the method
    body, we first create the shader program handle using the `glCreateProgram()`
    method and store it in the `m_programID` variable. Next, we create the handles
    for the vertex and fragment shaders using the `glCreateShader()` command. We check
    for any errors when creating the shader handles, and if we find any we throw an
    exception with the shader name that failed. Once the handles have been created,
    we then call the `CompileShader()` method, which we will look at next. The `CompileShader()`
    function takes two arguments: the first is the path to the shader file, and the
    second is the handle in which the compiled shader will be stored.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于这个示例，我们专注于两种着色器类型，所以我们的`ShaderManager::CompileShaders()`方法接受两个参数。第一个参数是顶点着色器文件的文件路径位置，第二个是片段着色器文件的文件路径位置。两者都是字符串。在方法体内，我们首先使用`glCreateProgram()`方法创建着色器程序句柄，并将其存储在`m_programID`变量中。接下来，我们使用`glCreateShader()`命令创建顶点和片段着色器的句柄。我们在创建着色器句柄时检查是否有任何错误，如果有，我们会抛出一个带有失败的着色器名称的异常。一旦句柄被创建，我们接下来调用`CompileShader()`方法，接下来我们将看到。`CompileShader()`函数接受两个参数：第一个是着色器文件的路径，第二个是编译后的着色器将被存储的句柄。
- en: 'The following is the full `CompileShader()` function. It handles the look and
    loading of the shader file from storage, as well as calling the OpenGL compile
    command on the shader file. We will break it down chunk by chunk:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的`CompileShader()`函数。它处理了从存储中查找和加载着色器文件，以及在着色器文件上调用OpenGL编译命令。我们将逐块地分解它：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To start the function, we first use an `ifstream` object to open the file with
    the shader code in it. We also check to see if there were any issues loading the
    file and if, there were, we throw an exception notifying us that the file failed
    to open:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用一个`ifstream`对象打开包含着色器代码的文件。我们还检查是否有任何加载文件的问题，如果有，我们会抛出一个异常通知我们文件打开失败：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to parse the shader. To do this, we create a string variable
    called `fileContents` that will hold the text in the shader file. We then create
    another string variable named line; this will be a temporary holder for each line
    of the shader file we are trying to parse. Next, we use a `while` loop to step
    through the shader file, parsing the contents line by line and saving each loop
    into the `fileContents` string. Once all the lines have been read into the holder
    variable, we call the close method on the `shaderFile` `ifstream` object to free
    up the memory used to read the file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要解析着色器。为此，我们创建一个名为`fileContents`的字符串变量，它将保存着色器文件中的文本。然后，我们创建另一个名为line的字符串变量；这将是我们试图解析的着色器文件的每一行的临时持有者。接下来，我们使用`while`循环逐行遍历着色器文件，逐行解析内容并将每个循环保存到`fileContents`字符串中。一旦所有行都被读入持有变量，我们调用`shaderFile`的`ifstream`对象上的close方法，以释放用于读取文件的内存：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You might remember from earlier in the chapter that I mentioned that when we
    are using the `glShaderSource()` function, we have to pass the shader file text
    as a pointer to the start of a character array. In order to meet this requirement,
    we are going to use a neat trick where we use the C string conversation method
    built into the string class to allow us to pass back a pointer to the start of
    our shader character array. This, in case you are unfamiliar, is essentially what
    a string is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得本章前面提到的，当我们使用`glShaderSource()`函数时，我们必须将着色器文件文本作为指向字符数组开头的指针传递。为了满足这一要求，我们将使用一个巧妙的技巧，即利用字符串类内置的C字符串转换方法，允许我们返回指向我们着色器字符数组开头的指针。如果您不熟悉，这本质上就是一个字符串：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have a pointer to the shader text, we can call the `glShaderSource()`
    method to tell OpenGL that we want to use the contents of the file to compile
    our shader. Then, finally, we call the `glCompileShader()` method with the handle
    to the shader as the argument:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了指向着色器文本的指针，我们可以调用`glShaderSource()`方法告诉OpenGL我们要使用文件的内容来编译我们的着色器。最后，我们使用着色器的句柄作为参数调用`glCompileShader()`方法：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That handles the compilation, but it is a good idea to provide ourselves with
    some debug support. We implement this compilation debug support by closing out
    the `CompileShader()` function by first checking to see if there were any errors
    during the compilation process. We do this by requesting information from the
    shader compiler through `glGetShaderiv()` function, which, among its arguments,
    takes an enumerated value that specifies what information we would like returned.
    In this call, we are requesting the compile status:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了编译，但是为自己提供一些调试支持是个好主意。我们通过在`CompileShader()`函数中首先检查编译过程中是否有任何错误来实现这种编译调试支持。我们通过请求来自着色器编译器的信息来做到这一点，通过`glGetShaderiv()`函数，其中，它的参数之一是指定我们想要返回的信息。在这个调用中，我们请求编译状态：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we check to see if the returned value is `GL_FALSE`, and if it is, that
    means we have had an error and should ask the compiler for more information about
    the compile issues. We do this by first asking the compiler what the max length
    of the error log is. We use this max length value to then create a vector of character
    values called errorLog. Then we can request the shader compile log by using the
    `glGetShaderInfoLog()` method, passing in the handle to the shader file the number
    of characters we are pulling, and where we want to save the log:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查返回的值是否为`GL_FALSE`，如果是，那意味着我们出现了错误，应该向编译器请求更多关于编译问题的信息。我们首先询问编译器错误日志的最大长度。我们使用这个最大长度值来创建一个名为errorLog的字符值向量。然后，我们可以通过使用`glGetShaderInfoLog()`方法请求着色器编译日志，传入着色器文件的句柄、我们要提取的字符数以及我们要保存日志的位置：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have the log file saved, we go ahead and delete the shader using the
    `glDeleteShader()` method. This ensures we don''t have any memory leaks from our
    shader:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们保存了日志文件，我们继续使用`glDeleteShader()`方法删除着色器。这确保我们不会因为着色器而产生任何内存泄漏：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we first print the error log to the console window. This is great
    for runtime debugging. We also throw an exception with the shader name/file path,
    and the message that it failed to compile:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们首先将错误日志打印到控制台窗口。这对于运行时调试非常有用。我们还会抛出一个异常，其中包括着色器名称/文件路径以及编译失败的消息：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That really simplifies the process of compiling our shaders by providing a
    simple interface to the underlying API calls. Now, in our example program, to
    load and compile our shaders we use a simple line of code similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供简单的接口来调用底层API，这真的简化了编译着色器的过程。现在，在我们的示例程序中，要加载和编译着色器，我们使用类似以下的一行简单代码：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Having now compiled the shaders, we are halfway to a useable shader program.
    We still need to add one more piece, linking. To abstract away some of the processes
    of linking the shaders and to provide us with some debugging capabilities, we
    are going to create the `LinkShaders()` method for our `ShaderManager` class.
    Let''s take a look and then break it down:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译了着色器，我们已经完成了可用着色器程序的一半。我们仍然需要添加一个部分，即链接。为了抽象出一些链接着色器的过程并为我们提供一些调试功能，我们将为我们的`ShaderManager`类创建`LinkShaders()`方法。让我们看一下，然后分解它：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To start our `LinkShaders()` function, we call the `glAttachShader()` method
    twice, using the handle to the previously created shader program object, and the
    handle to each shader we wish to link, respectively:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的`LinkShaders()`函数，我们调用`glAttachShader()`方法两次，分别使用先前创建的着色器程序对象的句柄和我们希望链接的每个着色器的句柄：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we perform the actual linking of the shaders into a usable shader program
    by calling the `glLinkProgram()` method, using the handle to the program object
    as its argument:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`glLinkProgram()`方法，使用程序对象的句柄作为参数，执行实际的着色器链接，将它们链接成一个可用的着色器程序：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then check to see if the linking process has completed without any errors
    and provide ourselves with any debug information that we might need if there were
    any errors. I am not going to go through this code chunk line by line since it
    is nearly identical to what we did with the `CompileShader()` function. Do note,
    however, that the function to return the information from the linker is slightly
    different and uses `glGetProgram*` instead of the `glGetShader*` functions from
    before:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以检查链接过程是否已经完成，没有任何错误，并提供任何调试信息，如果有任何错误的话。我不会逐行讲解这段代码，因为它几乎与我们使用`CompileShader()`函数时所做的工作完全相同。但是请注意，从链接器返回信息的函数略有不同，使用的是`glGetProgram*`而不是之前的`glGetShader*`函数：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly, if we are successful in the linking process, we need to clean it up
    a bit. First, we detach the shaders from the linker using the `glDetachShader()`
    method. Next, since we have a completed shader program, we no longer need to keep
    the shaders in memory, so we delete each shader with a call to the `glDeleteShader()`
    method. Again, this will ensure we do not leak any memory in our shader program
    creation process:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们在链接过程中成功了，我们需要稍微清理一下。首先，我们使用`glDetachShader()`方法从链接器中分离着色器。接下来，由于我们有一个完成的着色器程序，我们不再需要保留着色器在内存中，所以我们使用`glDeleteShader()`方法删除每个着色器。同样，这将确保我们在着色器程序创建过程中不会泄漏任何内存：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now have a simplified way of linking our shaders into a working shader program.
    We can call this interface to the underlying API calls by simply using one line
    of code, similar to the following one:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简化的方式将我们的着色器链接到一个工作的着色器程序中。我们可以通过简单地使用一行代码来调用这个接口到底层的API调用，类似于以下的代码：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So that handles the process of compiling and linking our shaders, but there
    is another key aspect to working with shaders, which is the passing of data to
    and from the running program/the game and the shader programs running on the GPU.
    We will look at this process and how we can abstract it into an easy-to-use interface
    for our engine next.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样处理了编译和链接着色器的过程，但与着色器一起工作的另一个关键方面是将数据传递给运行在GPU上的程序/游戏和着色器程序之间的数据传递。我们将看看这个过程，以及如何将其抽象成一个易于使用的接口，用于我们引擎。接下来。
- en: Working with shader data
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理着色器数据
- en: 'One of the most important aspects of working with shaders is the ability to
    pass data to and from the shader programs running on the GPU. This can be a deep
    topic, and much like other topics in this book has had its own dedicated books.
    We are going to stay at a higher level when discussing this topic and again will
    focus on the two needed shader types for basic rendering: the vertex and fragment
    shaders.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与着色器一起工作的最重要的方面之一是能够将数据传递给运行在GPU上的着色器程序，并从中传递数据。这可能是一个深入的话题，就像本书中的其他话题一样，有专门的书籍来讨论。在讨论这个话题时，我们将保持在较高的层次上，并再次专注于基本渲染所需的两种着色器类型：顶点和片段着色器。
- en: To begin with, let's take a look at how we send data to a shader using the vertex
    attributes and **Vertex Buffer Objects** (**VBO**). A vertex shader has the job
    of processing the data that is connected to the vertex, doing any modifications,
    and then passing it to the next stage of the rendering pipeline. This occurs once
    per vertex. In order for the shader to do its thing, we need to be able to pass
    it data. To do this, we use what are called vertex attributes, and they usually
    work hand in hand with what is referred to as VBO.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用顶点属性和**顶点缓冲对象**（**VBO**）将数据发送到着色器。顶点着色器的工作是处理与顶点连接的数据，进行任何修改，然后将其传递到渲染管线的下一阶段。这是每个顶点发生一次。为了使着色器发挥作用，我们需要能够传递数据给它。为此，我们使用所谓的顶点属性，它们通常与所谓的VBO紧密配合工作。
- en: 'For the vertex shader, all per-vertex input attributes are defined using the
    keyword `in`. So, for example, if we wanted to define a vector 3 input attribute
    named VertexColour, we could write something like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶点着色器，所有每个顶点的输入属性都使用关键字`in`进行定义。例如，如果我们想要定义一个名为`VertexColour`的三维向量输入属性，我们可以写如下内容：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the data for the `VertexColour` attribute has to be supplied by the program/game.
    This is where VBO come in. In our main game or program, we make the connection
    between the input attribute and the vertex buffer object, and we also have to
    define how to parse or step through the data. That way, when we render, the OpenGL
    can pull data for the attribute from the buffer for each call of the vertex shader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`VertexColour`属性的数据必须由程序/游戏提供。这就是VBO发挥作用的地方。在我们的主游戏或程序中，我们建立输入属性和顶点缓冲对象之间的连接，还必须定义如何解析或遍历数据。这样，当我们渲染时，OpenGL可以从缓冲区中为每个顶点着色器调用提取属性的数据。
- en: 'Let''s take a look a very simple vertex shader:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常简单的顶点着色器：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, there are just two input variables for this vertex shader,
    `VertexPosition` and `VertexColor`. Our main OpenGL program needs to supply the
    data for these two attributes for each vertex. We will do so by mapping our polygon/mesh
    data to these variables. We also have one output variable named Colour, which
    will be sent to the next stage of the rendering pipeline, the fragment shader.
    In this example, Colour is just an untouched copy of `VertexColour`. The `VertexPosition`
    attribute is simply expanded and passed along to the OpenGL API output variable
    `gl_Position` for more processing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这个顶点着色器只有两个输入变量，`VertexPosition`和`VertexColor`。我们的主OpenGL程序需要为每个顶点提供这两个属性的数据。我们将通过将我们的多边形/网格数据映射到这些变量来实现。我们还有一个名为`Colour`的输出变量，它将被发送到渲染管线的下一阶段，即片段着色器。在这个例子中，`Colour`只是`VertexColour`的一个未经处理的副本。`VertexPosition`属性只是被扩展并传递到OpenGL
    API输出变量`gl_Position`以进行更多处理。
- en: 'Next, let''s take a look at a very simple fragment shader:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一个非常简单的片段着色器：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this fragment shader example, there is only one input attribute, `Colour`.
    This input corresponds to the output of the previous rendering stage, the vertex
    shader's `Colour` output. For simplicity's sake, we are just expanding the `Colour`
    and outputting it as the variable `FragColour` for the next rendering stage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段着色器示例中，只有一个输入属性`Colour`。这个输入对应于前一个渲染阶段的输出，顶点着色器的`Colour`输出。为了简单起见，我们只是扩展了`Colour`并将其输出为下一个渲染阶段的变量`FragColour`。
- en: That sums up the shader side of the connection, so how do we compose and send
    the data from inside our engine? We can accomplish this in basically four steps.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了连接的着色器部分，那么我们如何在引擎内部组合和发送数据呢？我们可以基本上通过四个步骤来完成这个过程。
- en: 'First, we create a **Vertex Array Object** (**VAO**) instance to hold our data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个**顶点数组对象**（**VAO**）实例来保存我们的数据：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we create and populate the VBO for each of the shaders'' input attributes.
    We do this by first creating a VBO variable, then, using the `glGenBuffers()`
    method, we generate the memory for the buffer objects. We then create handles
    to the different attributes we need buffers for, assigning them to elements in
    the VBO array. Finally, we populate the buffers for each attribute by first calling
    the `glBindBuffer()` method, specifying the type of object being stored. In this
    case, it is a `GL_ARRAY_BUFFER` for both attributes. Then we call the `glBufferData()`
    method, passing the type, size, and handle to bind. The last argument for the
    `glBufferData()` method is one that gives OpenGL a hint about how the data will
    be used so that it can determine how best to manage the buffer internally. For
    full details about this argument, take a look at the OpenGL documentation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个着色器的输入属性创建和填充VBO。我们首先创建一个VBO变量，然后使用`glGenBuffers()`方法生成缓冲对象的内存。然后，我们为我们需要缓冲区的不同属性创建句柄，并将它们分配给VBO数组中的元素。最后，我们通过首先调用`glBindBuffer()`方法为每个属性填充缓冲区，指定要存储的对象类型。在这种情况下，对于两个属性，它是`GL_ARRAY_BUFFER`。然后我们调用`glBufferData()`方法，传递类型、大小和绑定句柄。`glBufferData()`方法的最后一个参数是一个提示OpenGL如何最好地管理内部缓冲区的参数。有关此参数的详细信息，请参阅OpenGL文档：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The third step is to create and define the VAO. This is how we will define
    the relationship between the input attributes of the shader and the buffers we
    just created. The VAO contains this information about the connections. To create
    a VAO, we use the `glGenVertexArrays()` method. This gives us a handle to our
    new object, which we store in our previously created VAO variable. Then, we enable
    the generic vertex attribute indexes 0 and 1 by calling the `glEnableVertexAttribArray()`
    method. By making the call to enable the attributes, we are specifying that they
    will be accessed and used for rendering. The last step makes the connection between
    the buffer objects we have created and the generic vertex attribute indexes the
    match too:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是创建和定义VAO。这是我们将定义着色器的输入属性和我们刚刚创建的缓冲区之间关系的方法。VAO包含了关于这些连接的信息。要创建一个VAO，我们使用`glGenVertexArrays()`方法。这给了我们一个新对象的句柄，我们将其存储在之前创建的VAO变量中。然后，我们通过调用`glEnableVertexAttribArray()`方法来启用通用顶点属性索引0和1。通过调用启用属性，我们指定它们将被访问和用于渲染。最后一步是将我们创建的缓冲对象与通用顶点属性索引进行匹配：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, in our `Draw()` function call, we bind to the VAO and call `glDrawArrays()`
    to perform the actual render:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`Draw()`函数调用中，我们绑定到VAO并调用`glDrawArrays()`来执行实际的渲染：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we move on to another way to pass data to the shader, there is one more
    piece of this attribute connection structure we need to discuss. As mentioned,
    the input variables in a shader are linked to the generic vertex attribute we
    just saw, at the time of linking. When we need to specify the relationship structure,
    we have a few different choices. We can use what are known as layout qualifiers
    within the shader code itself. The following is an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续传递数据到着色器的另一种方式之前，我们需要讨论这种属性连接结构的另一个部分。如前所述，着色器中的输入变量在链接时与我们刚刚看到的通用顶点属性相关联。当我们需要指定关系结构时，我们有几种不同的选择。我们可以在着色器代码本身中使用称为布局限定符的内容。以下是一个例子：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Another choice is to just let the linker create the mapping when linking, and
    then query for them afterward. The third and the one I personally prefer is to
    specify the relationship prior to the linking process by making a call to the
    `glBindAttribLocation()` method. We will see how this is implemented shortly when
    we discuss how to abstract these processes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是让链接器在链接时创建映射，然后在之后查询它们。我个人更喜欢的第三种方法是在链接过程之前指定关系，通过调用`glBindAttribLocation()`方法。我们将在讨论如何抽象这些过程时很快看到这是如何实现的。
- en: 'We have described how we can pass data to a shader using attributes, but there
    is another option: uniform variables. Uniform variables are specifically used
    for data that changes infrequently. For example, matrices are great candidates
    for uniform variables. Within a shader, a uniform variable is read-only. That
    means the value can only be changed from outside the shader. They can also appear
    in multiple shaders within the same shader program. They can be declared in one
    or more shaders within a program, but if a variable with a given name is declared
    in more than one shader, its type must be the same in all shaders. This gives
    us insight into the fact that the uniform variables are actually held in a shared
    namespace for the whole of the shader program.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了如何使用属性将数据传递给着色器，但还有另一个选择：统一变量。统一变量专门用于不经常更改的数据。例如，矩阵非常适合作为统一变量的候选对象。在着色器内部，统一变量是只读的。这意味着该值只能从着色器外部更改。它们还可以出现在同一着色器程序中的多个着色器中。它们可以在程序中的一个或多个着色器中声明，但是如果具有给定名称的变量在多个着色器中声明，则其类型在所有着色器中必须相同。这使我们了解到统一变量实际上是在整个着色器程序的共享命名空间中保存的。
- en: 'To use a uniform variable in your shader, you first have to declare it in the
    shader file using the uniform identifier keyword. The following is what this might
    look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在着色器中使用统一变量，首先必须在着色器文件中使用统一标识符关键字声明它。以下是这可能看起来的样子：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then need to provide the data for the uniform variable from inside our game/program.
    We do this by first finding the location of the variable using the `glGetUniformLocation()`
    method. Then we assign a value to the found location using one of the `glUniform()`
    methods. The code for this process could look something like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要从游戏/程序内部提供统一变量的数据。我们通过首先使用`glGetUniformLocation()`方法找到变量的位置，然后使用`glUniform()`方法之一为找到的位置赋值。这个过程的代码可能看起来像下面这样：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We then assign a value to the uniform variable's location using the `glUniformMatrix4fv()`
    method. The first argument is the uniform variable's location. The second argument
    is the number of matrices that are being assigned. The third is a GL `bool` type
    specifying whether or not the matrix should be transposed. Since we are using
    the GLM library for our matrices, a transpose is not required. If you were implementing
    the matrix using data that was in row-major order, instead of column-major order,
    you might need to use the `GL_TRUE` type for this argument. The last argument
    is a pointer to the data for the uniform variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`glUniformMatrix4fv()`方法为统一变量的位置赋值。第一个参数是统一变量的位置。第二个参数是正在分配的矩阵的数量。第三个是GL
    `bool`类型，指定矩阵是否应该被转置。由于我们在矩阵中使用GLM库，不需要转置。如果您使用的是按行顺序而不是按列顺序的数据来实现矩阵，您可能需要对这个参数使用`GL_TRUE`类型。最后一个参数是统一变量的数据的指针。
- en: Uniform variables can be any GLSL type, and this includes complex types such
    as structures and arrays. The OpenGL API provides a `glUniform()` function with
    the different suffixes that match each type. For example, to assign to a variable
    of type `vec3`, we would use `glUniform3f()` or `glUniform3fv()` methods. (the
    *v* denotes multiple values in the array).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 统一变量可以是任何GLSL类型，包括结构和数组等复杂类型。OpenGL API提供了与每种类型匹配的不同后缀的`glUniform()`函数。例如，要分配给`vec3`类型的变量，我们将使用`glUniform3f()`或`glUniform3fv()`方法（*v*表示数组中的多个值）。
- en: So, those are the concepts and techniques for passing data to and from our shader
    programs. However, as we did for the compiling and linking of our shaders, we
    can abstract these processes into functions housed in our `ShaderManager` class.
    We are going to focus on working with attributes and uniform variables. We do
    have a great class that abstracts the creation of VAO and VBO for models/meshes,
    that we walked through in great detail back in [Chapter 4](9379b574-a962-466b-9efe-d21b410c51c0.xhtml),
    *Building Gameplay Systems*, when we discussed building an asset pipeline. To
    see how that was constructed, either flip back to [Chapter 4](https://cdp.packtpub.com/mastering_c___game_development/wp-admin/post.php?post=325&action=edit#post_245), *Building
    Gameplay Systems,* or check out the implementation in the `Mesh.h` and `Mesh.cpp`
    files of the `BookEngine` solution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些是将数据传递给着色器程序和从着色器程序传递数据的概念和技术。然而，就像我们为编译和链接着色器所做的那样，我们可以将这些过程抽象成我们`ShaderManager`类中的函数。我们将专注于处理属性和统一变量。我们有一个很好的类来抽象模型/网格的VAO和VBO的创建，我们在[第4章](9379b574-a962-466b-9efe-d21b410c51c0.xhtml)中详细讨论了这一点，*构建游戏系统*，当时我们讨论了构建资产流水线。要查看它是如何构建的，要么翻回到[第4章](https://cdp.packtpub.com/mastering_c___game_development/wp-admin/post.php?post=325&action=edit#post_245)，*构建游戏系统*，要么查看`BookEngine`解决方案的`Mesh.h`和`Mesh.cpp`文件中的实现。
- en: 'First, we will look at the abstraction of adding attribute bindings using the
    `AddAttribute()` function of the `ShaderManger` class. This function takes one
    argument, the attribute''s name, to be bound as a string. We then call the `glBindAttribLocation()`
    function, passing the program''s handle and the current index or number of attributes,
    which we increase on call, and finally the C string conversion of the `attributeName`
    string, which provides a pointer to the first character in the string array. This
    function must be called after compilation, but before the linking of the shader
    program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下使用`ShaderManger`类的`AddAttribute()`函数添加属性绑定的抽象。这个函数接受一个参数，作为字符串绑定的属性名称。然后我们调用`glBindAttribLocation()`函数，传递程序的句柄和当前属性的索引或数量，我们在调用时增加，最后是`attributeName`字符串的C字符串转换，它提供了指向字符串数组中第一个字符的指针。这个函数必须在编译之后调用，但在着色器程序链接之前调用。
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For the uniform variables, we create a function that abstracts looking up the
    location of the uniform in the shader program, the `GetUniformLocation()` function.
    This function again takes only one variable which is a uniform name in the form
    of a string. We then create a temporary holder for the location and assign it
    the returned value of the `glGetUniformLocation()` method call. We check to make
    sure the location is valid, and if not we throw an exception letting us know about
    the error. Finally, we return the valid location if found:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统一变量，我们创建一个抽象查找着色器程序中统一变量位置的函数`GetUniformLocation()`。这个函数再次只接受一个变量，即以字符串形式的统一变量名称。然后我们创建一个临时持有者来保存位置，并将其赋值为`glGetUniformLocation()`方法调用的返回值。我们检查位置是否有效，如果不是，我们抛出一个异常，让我们知道错误。最后，如果找到，我们返回有效的位置。
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This gives us the abstraction for binding our data, but we still need to assign
    which shader should be used for a certain draw call, and to activate any attributes
    we need. To accomplish this, we create a function in the `ShaderManager` called
    `Use()`. This function will first set the current shader program as the active
    one using the `glUseProgram()` API method call. We then use a for loop to step
    through the list of attributes for the shader program, activating each one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们绑定数据提供了抽象，但我们仍然需要指定哪个着色器应该用于某个绘制调用，并激活我们需要的任何属性。为了实现这一点，我们在`ShaderManager`中创建一个名为`Use()`的函数。这个函数将首先使用`glUseProgram()`API方法调用将当前着色器程序设置为活动的着色器程序。然后我们使用一个for循环来遍历着色器程序的属性列表，激活每一个：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Of course, since we have an abstracted way to enable the shader program, it
    only makes sense that we should have a function to disable the shader program.
    This function is very similar to the `Use()` function, but in this case, we are
    setting the program in use to 0, effectively making it `NULL`, and we use the
    `glDisableVertexAtrribArray()` method to disable the attributes in the for loop:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们有一种抽象的方法来启用着色器程序，所以我们应该有一个函数来禁用着色器程序。这个函数与`Use()`函数非常相似，但在这种情况下，我们将正在使用的程序设置为0，有效地使其为`NULL`，并使用`glDisableVertexAtrribArray()`方法在for循环中禁用属性：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The net effect of this abstraction is we can now set up our entire shader program
    structure with a few simple calls. Code similar to the following would create
    and compile the shaders, add the necessary attributes, link the shaders into a
    program, locate a uniform variable, and create the VAO and VBO for a mesh:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象的净效果是，我们现在可以通过几个简单的调用来设置整个着色器程序结构。类似以下的代码将创建和编译着色器，添加必要的属性，将着色器链接到程序中，找到一个统一变量，并为网格创建VAO和VBO：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, in our `Draw` loop, if we want to use this shader program to draw, we
    can simply use the abstracted functions to activate and deactivate our shader,
    similar to the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`Draw`循环中，如果我们想要使用这个着色器程序进行绘制，我们可以简单地使用抽象函数来激活和停用我们的着色器，类似于以下代码：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This makes it much easier for us to work with and test out advanced rendering
    techniques using shaders. We will be using this structure to build out the examples
    in the rest of this chapter and in fact the rest of the book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们更容易使用着色器来测试和实现高级渲染技术。我们将使用这种结构来构建本章剩余部分以及实际上整本书的示例。
- en: Lighting effects
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照效果
- en: One of the most common uses for shaders is creating lighting and reflection
    effects. Lighting effects achieved from the use of shaders help provide a level
    of polish and detail that every modern game strives for. In the next section,
    we will look at some of the well-known models for creating different surface appearance
    effects, with examples of shaders you can implement to replicate the discussed
    lighting effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器最常见的用途之一是创建光照和反射效果。通过使用着色器实现的光照效果有助于提供每个现代游戏都追求的一定程度的光泽和细节。在接下来的部分，我们将看一些用于创建不同表面外观效果的知名模型，并提供可以实现所讨论的光照效果的着色器示例。
- en: Per-vertex diffuse
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每顶点漫反射
- en: To start with, we will look at one of the simpler lighting vertex shaders, the
    diffuse reflection shader. Diffuse is considered simpler since we assume that
    the surface we are rendering appears to scatter the light in all directions equally.
    With this shader, the light makes contact with the surface and slightly penetrates
    before being cast back out in all directions. This means that some of the light's
    wavelength will be at least partially absorbed. A good example of what a diffuse
    shader looks like is to think of matte paint. The surface has a very dull look
    with no shine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下其中一个较为简单的光照顶点着色器，即漫反射反射着色器。漫反射被认为更简单，因为我们假设我们正在渲染的表面看起来在所有方向上均匀地散射光线。通过这个着色器，光线与表面接触并在稍微穿透后在所有方向上被投射出去。这意味着一些光的波长至少部分被吸收。漫反射着色器的一个很好的例子是哑光油漆。表面看起来非常暗淡，没有光泽。
- en: 'Let''s take a quick look at the mathematical model for a diffuse reflection.
    This reflection model takes two vectors. One is the direction of the surface contact
    point to the initial light source, and the second is the normal vector of that
    same surface contact point. This would look something like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下漫反射的数学模型。这个反射模型需要两个向量。一个是表面接触点到初始光源的方向，另一个是同一表面接触点的法向量。这看起来像下面这样：
- en: '![](img/61cd3123-d51e-46a5-9e49-fe95a5c7b232.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61cd3123-d51e-46a5-9e49-fe95a5c7b232.png)'
- en: 'It''s worth noting that the amount of light that strikes the surface is partially
    dependent on the surface in relation to the light source and that the amount of
    light that reaches a single point will be at its maximum along the normal vector,
    and its lowest when perpendicular to the normal vector. Dusting off our physics
    knowledge toolbox, we are able to express this relationship given the amount of
    light making contact with a point by calculating the dot product of the point
    normal vector and incoming light vector. This can be expressed by the following
    formula:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，击中表面的光量部分取决于表面与光源的关系，而达到单个点的光量在法向量上最大，在法向量垂直时最低。通过计算点法向量和入射光线的点积，我们可以表达这种关系。这可以用以下公式表示：
- en: '*Light Density(Source Vector) Normal Vector*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*光密度（源向量）法向量*'
- en: The source and normal vector in this equation are assumed to be normalized.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程中的源向量和法向量被假定为归一化。
- en: 'As mentioned before, some of the light striking the surface will be absorbed
    before it is re-cast. To add this behavior to our mathematical model, we can add
    a reflection coefficient, also referred to as the diffuse reflectivity. This coefficient
    value becomes the scaling factor for the incoming light. Our new formula to specify
    the outgoing intensity of the light will now look like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，表面上的一些光线在重新投射之前会被吸收。为了将这种行为添加到我们的数学模型中，我们可以添加一个反射系数，也称为漫反射率。这个系数值成为入射光的缩放因子。我们指定出射光强度的新公式现在看起来像下面这样：
- en: '*Outgoing Light = (Diffuse Coefficient x Light Density x Source Vector) Normal
    Vector*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 出射光 = (漫反射系数 x 光密度 x 光源向量) 法向量
- en: With this new formula, we now have a lighting model that represents an omnidirectional,
    uniform scattering.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新的公式，我们现在有了一个代表全向均匀散射的光照模型。
- en: 'OK, now that we know the theory, let''s take a look at how we can implement
    this lighting model in a GLSL shader. The full source for this example can be
    found in the `Chapter07` folder of the GitHub repository, starting with the Vertex
    Shader shown as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们知道了理论，让我们看看如何在GLSL着色器中实现这个光照模型。这个例子的完整源代码可以在GitHub存储库的`Chapter07`文件夹中找到，从以下所示的顶点着色器开始：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll go through this shader block by block. To start out, we have our attributes,
    `vertexPosition_modelspace`, `vertexUV`, and `vertexNormal`. These will be set
    by our game application, which we will look at after we go through the shader.
    Then we have our out variables, UV and `LightIntensity`. These values will be
    calculated in the shader itself. We then have our uniforms. These include the
    needed values for our reflection calculation, as we discussed. It also includes
    all the necessary matrices. Like the attributes, these uniform values will be
    set via our game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐块地浏览这个着色器。首先，我们有我们的属性，`vertexPosition_modelspace`，`vertexUV`和`vertexNormal`。这些将由我们的游戏应用程序设置，在我们浏览完着色器之后我们会看到。然后我们有我们的输出变量，UV和`LightIntensity`。这些值将在着色器中计算。然后我们有我们的uniform变量。这些包括我们讨论过的反射计算所需的值。它还包括所有必要的矩阵。与属性一样，这些uniform值将通过我们的游戏设置。
- en: Inside of the main function of this shader, our diffuse reflection is going
    to be calculated in the camera relative coordinates. To accomplish this, we first
    normalize the vertex normal by multiplying it by the normal matrix and storing
    the results in a vector 3 variable named `tnorm`. Next, we convert the vertex
    position that is currently in model space to camera coordinates by transforming
    it with the model view matrix. We then calculate the incoming light direction,
    normalized, by subtracting the vertex position in the camera coordinates from
    the light's position. Next, we calculate the outgoing light intensity by using
    the formula we went through earlier. A point to note here is the use of the max
    function. This is a situation when the light direction is greater than 90 degrees,
    as in the light is coming from inside the object. Since in our case we don't need
    to support this situation, we just use a value of `0.0` when this arises. To close
    out the shader, we store the model view projection matrix, calculated in clip
    space, in the built-in outbound variable `gl_position`. We also pass along the
    UV of the texture, unchanged, which we are not actually using in this example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器的主函数内部，我们的漫反射将在相机相对坐标中计算。为了实现这一点，我们首先通过将顶点法线乘以法线矩阵来归一化顶点法线，并将结果存储在一个名为`tnorm`的向量3变量中。接下来，我们通过使用模型视图矩阵将目前在模型空间中的顶点位置转换为相机坐标，从而计算出入射光方向，归一化，通过从相机坐标中的顶点位置减去光的位置。接下来，我们通过使用我们之前讨论过的公式计算出射光强度。这里需要注意的一点是使用max函数。这是当光线方向大于90度时的情况，就像光线是从物体内部发出一样。由于在我们的情况下，我们不需要支持这种情况，所以当出现这种情况时，我们只使用`0.0`的值。为了关闭着色器，我们将在裁剪空间中计算的模型视图投影矩阵存储在内置的输出变量`gl_position`中。我们还传递纹理的UV，未更改，这在这个例子中实际上并没有使用。
- en: 'Now that we have the shader in place, we need to provide the values needed
    for the calculations. As we learned in the first section of this chapter, we do
    this by setting the attributes and uniforms. We built an abstraction layer to
    help with this process, so let''s take a look at how we set these values in our
    game code. Inside the `GamePlayScreen.cpp` file, we are setting these values in
    the `Draw()` function. I should point out this is for the example, and in a production
    environment, you would only want to set the changing values in a loop for performance
    reasons. Since this is an example, I wanted to make it slightly easier to follow:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了着色器，我们需要提供计算所需的值。正如我们在本章的第一节中所学的，我们通过设置属性和uniform来实现这一点。我们构建了一个抽象层来帮助这个过程，所以让我们看看我们如何在游戏代码中设置这些值。在`GamePlayScreen.cpp`文件中，我们在`Draw()`函数中设置这些值。我应该指出，这是一个例子，在生产环境中，出于性能原因，你只想在循环中设置变化的值。由于这是一个例子，我想让它稍微容易一些：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I won''t go through each line since I am sure you can see the pattern. We first
    use the shader manager''s `GetUniformLocation()` method to return the location
    for the uniform. Next, we set the value for this uniform using the OpenGL `glUniform*()`
    method that matches the value type. We do this for all uniform values needed.
    We also have to set our attributes, and as discussed in the beginning of the chapter,
    we do this in between the compilation and linking processes. In this example case,
    we are setting these values in the `OnEntry()` method of the `GamePlayScreen()`
    class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会逐行进行，因为我相信你可以看到模式。我们首先使用着色器管理器的`GetUniformLocation()`方法返回uniform的位置。接下来，我们使用OpenGL的`glUniform*()`方法设置这个uniform的值，该方法与值类型匹配。我们对所有需要的uniform值都这样做。我们还必须设置我们的属性，并且正如本章开头讨论的那样，我们要在编译和链接过程之间进行这样的操作。在这个例子中，我们在`GamePlayScreen()`类的`OnEntry()`方法中设置这些值：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That takes care of the vertex shader and passed in values needed, so next,
    let''s look at the fragment shader for this example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了顶点着色器和传入所需的值，接下来，让我们看看这个例子的片段着色器：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For this example, our fragment shader is extremely simple. To begin, we have
    the in values for our UV and `LightIntensity`, and we will only use the `LightIntensity`
    this time. We then declare our out color value, specified as a vector 3\. Next,
    we have the `sampler2D` uniform that we use for texturing, but again we won't
    be using this value in the example. Finally, we have the main function. This is
    where we set the final output color by simply passing the `LightIntensity` through
    to the next stage in the pipeline.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们的片段着色器非常简单。首先，我们有我们的UV和`LightIntensity`的输入值，这次我们只使用`LightIntensity`。然后，我们声明了我们的输出颜色值，指定为一个矢量3。接下来，我们有用于纹理的`sampler2D`统一变量，但在这个示例中我们也不会使用这个值。最后，我们有主函数。这是我们通过简单地将`LightIntensity`传递到管道中的下一个阶段来设置最终输出颜色的地方。
- en: 'If you run the example project, you will see the diffuse reflection in action.
    The output should look like the following screenshot. As you can see, this reflection
    model works well for surfaces that are very dull but has limited use in a practical
    environment. Next, we will look at a reflection model that will allow us to depict
    more surface types:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行示例项目，你会看到漫反射的效果。输出应该看起来像下面的屏幕截图。正如你所看到的，这种反射模型对于非常迟钝的表面效果很好，但在实际环境中的使用有限。接下来，我们将看一下一个反射模型，它将允许我们描绘更多的表面类型：
- en: '![](img/8e83e885-ac5e-4c00-91b7-03998dd9380e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e83e885-ac5e-4c00-91b7-03998dd9380e.png)'
- en: Per-vertex ambient, diffuse, and specular
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每顶点环境、漫反射和镜面
- en: The **ambient**, **diffuse**, **and specular** (**ADS**) reflection model, also
    commonly known as the **Phong reflection model**, provides a method of creating
    a reflective lighting shader. This technique models the interaction of light on
    a surface using a combination of three different components. The ambient component
    models the light that comes from the environment; this is intended to model what
    would happen if the light was reflected many times, where it appears as though
    it is emanating from everywhere. The diffuse component, which we modeled in our
    previous example, represents an omnidirectional reflection. The last component,
    the specular component, is meant to represent the reflection in a preferred direction,
    providing the appearance of a light *glare* or bright spot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**、**漫反射**和**镜面**（**ADS**）反射模型，也通常被称为**冯氏反射模型**，提供了一种创建反射光照着色器的方法。这种技术使用三种不同组件的组合来模拟光线在表面上的相互作用。环境组件模拟来自环境的光线；这意味着模拟光线被反射多次的情况，看起来好像它从任何地方都发出。我们在之前的示例中建模的漫反射组件代表了一个全向反射。最后一个组件，镜面组件，旨在表示在一个首选方向上的反射，提供了光*眩光*或明亮的点的外观。'
- en: 'This combination of components can be visualized using the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件的组合可以使用以下图表来可视化：
- en: '![](img/45633898-8754-47a0-b4b8-f102297cca8f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45633898-8754-47a0-b4b8-f102297cca8f.png)'
- en: 'Source: Wikipedia'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：维基百科
- en: This process can be broken down into separate components for discussion. First,
    we have the ambient component that represents the light that will illuminate all
    of the surfaces equally and reflect uniformly in all directions. This lighting
    effect does not depend on the incoming or the outgoing vectors of the light since
    it is uniformly distributed and can be expressed by simply multiplying the light
    source's intensity with the surface reflectivity. This is shown in the mathematical
    formula *I[a] = L[a]K[a]*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以分解成讨论各个组件。首先，我们有环境组件，代表将均匀照亮所有表面并在所有方向上均匀反射的光线。这种光照效果不依赖于光线的入射或出射向量，因为它是均匀分布的，可以简单地通过将光源强度与表面反射性相乘来表示。这在数学公式
    *I[a] = L[a]K[a]* 中显示。
- en: The next component is the diffuse component we discussed earlier. The diffuse
    component models a dull or rough surface that scatters light in all directions.
    Again, this can be expressed with the mathematical formula *I[d] = L[d]K[d](sn)*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是我们之前讨论过的漫反射组件。漫反射组件模拟了一个粗糙或粗糙的表面，将光线散射到所有方向。同样，这可以用数学公式 *I[d] = L[d]K[d](sn)*
    来表示。
- en: 'The final component is the specular component, and it is used to model the
    *shininess* of the surface. This creates a *glare* or bright spot that is common
    on surfaces that exhibit glossy properties. We can visualize this reflection effect
    using the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件是镜面组件，它用于模拟表面的*光泽*。这会产生一个*眩光*或明亮的点，在表现出光滑特性的表面上很常见。我们可以使用以下图表来可视化这种反射效果：
- en: '![](img/46525544-c9ce-4200-b03c-bf4de5fc5118.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46525544-c9ce-4200-b03c-bf4de5fc5118.png)'
- en: 'For the specular component, ideally, we would like the reflection to be at
    is most apparent when viewed aligned with the reflection vector, and then to fade
    off as the angle is increased or decreased from this alignment. We can model this
    effect using the cosine of the angle between our viewing vector and the reflection
    angle, which is then raised by some power, as shown in this equation: *(r v) ^p*.
    In this equation, *p* represents the specular highlight, the *glare* spot. The
    larger the value input for *p*, the smaller the spot will appear, and the *shinier* the
    surface will look. After adding the values to represent the reflectiveness of
    the surface and the specular light intensity, the formula for calculating the
    specular effect for the surface looks like so: *I[s] = L[s]K[s](r v) ^p*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于镜面分量，理想情况下，我们希望当与反射向量对齐时，反射最明显，然后随着角度的增加或减小而逐渐减弱。我们可以使用我们的观察向量和反射角之间的角度的余弦来模拟这种效果，然后将其提高到某个幂，如下面的方程所示：*(r
    v) ^p*。在这个方程中，*p*代表镜面高光，*眩光*点。输入的*p*值越大，点的大小就会越小，表面看起来就会*更光滑*。在添加了表示表面反射性和镜面光强度的值之后，用于计算表面镜面效果的公式如下：*I[s]
    = L[s]K[s](r v) ^p*。
- en: So, now, if we take all of our components and put them together in a formula,
    we come up with *I = I[a] + I[d] + I[s]* or breaking it down more, *I = L[a]K[a]
    + L[d]K[d](sn) + L[s]K[s](r v) ^p* .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将所有组件放在一起并用一个公式表示，我们得到 *I = I[a] + I[d] + I[s]* 或者更详细地分解为 *I = L[a]K[a]
    + L[d]K[d](sn) + L[s]K[s](r v) ^p*。
- en: 'With our theory in place, let''s see how we can implement this in a per-vertex
    shader, beginning with our vertex shader as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的理论基础，让我们看看如何在每顶点着色器中实现这一点，从我们的顶点着色器开始如下：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's take a look at the what is different to start with. In this shader, we
    are introducing a new concept, the uniform struct. We are declaring two `struct`,
    one to describe the light, `LightInfo`, and one to describe the material, `MaterialInfo`.
    This is a very useful way of containing values that represent a portion in the
    formula as a collection. We will see how we can set the values of these `struct`
    elements from the game code shortly. Moving on to the main function of the function.
    First, we start as we did in the previous example. We calculate the `tnorm`, `CameraCoords`,
    and the light source vector(s). Next, we calculate the vector in the direction
    of the viewer/camera (v), which is the negative of the normalized `CameraCoords`.
    We then calculate the direction of the *pure* reflection using the provided GLSL
    method, reflect. Then we move on to calculating the values of our three components.
    The ambient is calculated by multiplying the light ambient intensity and the surface's
    ambient reflective value. The `diffuse` is calculated using the light intensity,
    the surface diffuse reflective value of the surface, and the result of the dot
    product of the light source vector and the `tnorm`, which we calculated just before
    the ambient value. Before computing the specular value, we check the value of
    `sDotN`. If `sDotN` is zero, then there is no light reaching the surface, so there
    is no point in computing the specular component. If `sDotN` is greater than zero,
    we compute the specular component. As in the previous example, we use a GLSL method
    to limit the range of values of the dot product to between `1` and `0`. The GLSL
    function `pow` raises the dot product to the power of the surface's shininess
    exponent, which we defined as `p` in our shader equation previously.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看有什么不同。在这个着色器中，我们引入了一个新概念，即统一结构。我们声明了两个`struct`，一个用于描述光线，`LightInfo`，一个用于描述材质，`MaterialInfo`。这是一种非常有用的方式，可以将代表公式中一部分的值作为集合来包含。我们很快就会看到如何设置这些`struct`元素的值从游戏代码中。接着是函数的主要部分。首先，我们像在上一个例子中一样开始。我们计算`tnorm`，`CameraCoords`和光源向量。接下来，我们计算指向观察者/摄像机的向量(v)，这是规范化的`CameraCoords`的负值。然后，我们使用提供的GLSL方法计算*纯*反射的方向。然后我们继续计算我们三个分量的值。环境光通过将光环境强度和表面的环境反射值相乘来计算。`diffuse`使用光强度、表面漫反射值和光源向量与`tnorm`的点积的结果来计算，我们刚刚在环境值之前计算了这个值。在计算镜面反射值之前，我们检查了`sDotN`的值。如果`sDotN`为零，则没有光线到达表面，因此没有计算镜面分量的意义。如果`sDotN`大于零，我们计算镜面分量。与前面的例子一样，我们使用GLSL方法将点积的值限制在`1`和`0`之间。GLSL函数`pow`将点积提升到表面光泽指数的幂，我们之前在着色器方程中定义为`p`。
- en: Finally, we add all three of our component values together and pass their sum
    to the fragment shader in the form of the out variable, `LightIntensity`. We end
    by transforming the vertex position to clip space and passing it off to the next
    stage by assigning it to the `gl_Position` variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这三个分量值相加，并将它们的总和作为out变量`LightIntensity`传递给片段着色器。最后，我们将顶点位置转换为裁剪空间，并通过将其分配给`gl_Position`变量将其传递到下一个阶段。
- en: 'For the setting of the attributes and uniforms needed for our shader, we handle
    the process just as we did in the previous example. The main difference here is
    that we need to specify the elements of the `struct` we are assigning when getting
    the uniform location. An example would look similar to the following, and again
    you can see the full code in the example solution in the `Chapter07` folder of
    the GitHub repository:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们着色器所需的属性和统一变量的设置，我们处理过程与前面的例子中一样。这里的主要区别在于，我们需要在获取统一位置时指定我们正在分配的`struct`的元素。一个示例看起来类似于以下内容，您可以在GitHub存储库的`Chapter07`文件夹中的示例解决方案中看到完整的代码：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The fragment shader used for this example is the same as the one we used for
    the diffuse example, so I won't cover it again here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用的片段着色器与我们用于漫反射的片段着色器相同，所以我在这里不再介绍它。
- en: 'When you run the ADS example from the `Chapter07` code solution of the GitHub
    repository, you will see our newly created shader in effect, with an output looking
    similar to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从GitHub存储库的`Chapter07`代码解决方案中运行ADS示例时，您将看到我们新创建的着色器生效，输出类似于以下内容：
- en: '![](img/1b255e28-0a5a-4456-8efc-86158d5d6514.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b255e28-0a5a-4456-8efc-86158d5d6514.png)'
- en: In this example, we calculated the shading equation within the vertex shader;
    this is referred to as a per-vertex shader. One issue that can arise from this
    approach is that our
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在顶点着色器中计算了阴影方程；这被称为每顶点着色器。这种方法可能会出现的一个问题是我们
- en: '*glare* spots, the specular highlights, might appear to warp or disappear.
    This is caused by the shading being interpolated and not calculated for each point
    across the face. For example, a spot that was set near the middle of the face
    might not appear due to the fact that the equation was calculated at the vertices
    where the specular component was near to zero. In the next example, we will look
    at a technique that can eliminate the issue by calculating the reflection in the
    fragment shader.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*眩光*点，镜面高光，可能会出现扭曲或消失的现象。这是由于阴影被插值而不是针对脸部的每个点进行计算造成的。例如，设置在脸部中间附近的点可能不会出现，因为方程是在镜面分量接近零的顶点处计算的。在下一个例子中，我们将看一种可以通过在片段着色器中计算反射来消除这个问题的技术。'
- en: Per-fragment Phong interpolation
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每片段Phong插值
- en: In the previous examples, we have been using the vertex shaders to handle the
    lighting calculations. One issue when using a vertex shader to evaluate the color
    of each vertex, as mentioned in the last example, is that color is then interpolated
    across the face. This can cause some less than favorable effects. There is another
    way to accomplish this same lighting effect, but with improved accuracy. We can
    move the calculation to the fragment shader instead. In the fragment shader, instead
    of interpolating across the face, we interpolate normal and position and use these
    values to calculate at each fragment instead. This technique is often called **Phong
    interpolation**. The results of this techniques are much more accurate than when
    using a per-vertex implementation. However, since this per-fragment implementation
    evaluates each fragment, as opposed to just the vertices, this implementation
    will run slower than the per-vertex technique.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的例子中，我们一直在使用顶点着色器来处理光照计算。使用顶点着色器来评估每个顶点的颜色时会出现一个问题，就像在上一个例子中提到的那样，即颜色然后在整个面上进行插值。这可能会导致一些不太理想的效果。有另一种方法可以实现相同的光照效果，但精度更高。我们可以将计算移到片段着色器中。在片段着色器中，我们不是在整个面上进行插值，而是在法线和位置上进行插值，并使用这些值来在每个片段上计算。这种技术通常被称为**冯氏插值**。这种技术的结果比使用每个顶点实现的结果要准确得多。然而，由于这种按片段实现会评估每个片段，而不仅仅是顶点，所以这种实现比按顶点的技术运行得更慢。
- en: 'Let''s start our look at the shader implementation by looking at the vertex
    shader for this example first:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看这个例子的顶点着色器开始实现着色器的实现：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since this technique uses the fragment shader to perform the calculations, our
    vertex shader is considerably light. For the most part, we are doing a few simple
    equations to calculate the normal and the position, and then passing the values
    along to the next stage.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种技术使用片段着色器来执行计算，我们的顶点着色器相当轻。在大多数情况下，我们正在进行一些简单的方程来计算法线和位置，然后将这些值传递到下一个阶段。
- en: 'Next, we will look at the core of this technique''s implementation in the fragment
    shader. Following is the complete fragment shader, and we will cover the differences
    from the previous examples:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下这种技术在片段着色器中的核心实现。以下是完整的片段着色器，我们将介绍与以前例子的不同之处：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This fragment shader should look very familiar, as this is nearly identical
    to the vertex shader from our previous examples. The big difference, besides the
    fact that this will run per fragment, not per vertex, is that we have cleaned
    up the shader by implementing a function to handle the Phong model calculation.
    We are also going to pass through a texture this time, to give our texture back
    to the gnome. The Phong model calculation is exactly the same as we have seen
    before, so I won't cover it again. The reason we moved it out into a function
    is mostly for readability, as it keeps the main function uncluttered. Creating
    a function in GLSL is nearly the same as in C++ and C. You have a return type,
    a function name followed by arguments, and a body. I highly recommend using functions
    in any shader more complex than a few lines.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段着色器应该看起来非常熟悉，因为它几乎与我们以前的例子中的顶点着色器相同。除了这将按片段而不是按顶点运行之外，另一个重要的区别是我们通过实现一个处理冯氏模型计算的函数来清理着色器。这次我们还要传递一个纹理，把纹理还给小矮人。冯氏模型计算与我们以前看到的完全相同，所以我不会再次介绍它。我们将它移到一个函数中的原因主要是为了可读性，因为它使主函数保持整洁。在GLSL中创建函数几乎与在C++和C中相同。你有一个返回类型，一个函数名，后面跟着参数和一个主体。我强烈建议在任何比几行更复杂的着色器中使用函数。
- en: To connect our shaders to the values from our game, we follow the same technique
    as before, where we set the needed attributes and uniform values. For this example,
    we must supply the values for Ka, Kd, Ks, Material Shininess, `LightPosition`,
    and `LightIntensity`. These values match up with the previously described ADS
    equation. We also need to pass in the usual matrices values. The full code can
    again be found in the `Chapter07` folder of the GitHub repository.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的着色器连接到游戏中的值，我们遵循与之前相同的技术，在那里我们设置所需的属性和统一值。在这个例子中，我们必须提供Ka、Kd、Ks、材料光泽度、`LightPosition`和`LightIntensity`的值。这些值与先前描述的ADS方程相匹配。我们还需要传递通常的矩阵值。完整的代码可以再次在GitHub存储库的`Chapter07`文件夹中找到。
- en: 'If we run the `Phong_Example` from the `Chapter07` solution, we will see the
    new shader in action, complete with texture and a more accurate reflection representation.
    The following is a screenshot of the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`Chapter07`解决方案中的`Phong_Example`，我们将看到新的着色器在运行中，包括纹理和更准确的反射表示。以下是输出的屏幕截图：
- en: '![](img/5fcd5f76-14f7-4684-a7a6-45e392f66a21.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fcd5f76-14f7-4684-a7a6-45e392f66a21.png)'
- en: 'We will end our discussion on lighting techniques here, but I encourage you
    to continue your research on the topic. There are many interesting lighting effects
    that you can achieve with shaders, and we have only really begun to scratch the
    surface. In the next section, we will look at another common use for shaders:
    rendering effects.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束我们对光照技术的讨论，但我鼓励你继续研究这个主题。使用着色器可以实现许多有趣的光照效果，我们只是刚刚开始涉及。在下一节中，我们将看一下着色器的另一个常见用途：渲染效果。
- en: Using Shaders to create effects
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用着色器创建效果
- en: Shaders are not just limited to creating lighting effects. You can create many
    different visual effects using different shader techniques. In this section, we
    will cover a couple of interesting effects that you can achieve, including using
    the discard keyword to *throw away* pixels, and using shaders to create a simple
    particle effect system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器不仅仅局限于创建光照效果。您可以使用不同的着色器技术创建许多不同的视觉效果。在本节中，我们将介绍一些有趣的效果，包括使用丢弃关键字来*丢弃*像素，并使用着色器创建一个简单的粒子效果系统。
- en: Discarding fragments
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丢弃片段
- en: With the use of fragment shader tools, we are able to create some cool effects.
    One of these tools is the use of the discard keyword. The discard keyword, like
    its name suggests, removes or throws away fragments. When the discard keyword
    is used, the shader immediately stops its execution and skips the fragment, not
    writing any data to the output buffer. The created effect is holes in the polygon
    faces without using a blending effect. The discard keyword can also be combined
    with the use of alpha maps to allow textures to specify what fragments should
    be discarded. This can be a handy technique when modeling effects such as damage
    to an object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用片段着色器工具，我们能够创建一些很酷的效果。其中一个工具就是使用丢弃关键字。丢弃关键字，顾名思义，移除或丢弃片段。当使用丢弃关键字时，着色器立即停止执行并跳过片段，不向输出缓冲区写入任何数据。创建的效果是多边形面上的孔洞，而不使用混合效果。丢弃关键字也可以与alpha贴图结合使用，以允许纹理指定应丢弃哪些片段。在建模损坏对象等效果时，这可能是一个方便的技术。
- en: For this example, we are going to create a fragment shader that will use the
    discard keyword to remove certain fragments based on the UV texture coordinates.
    The effect will be a lattice or perforated look for our gnome model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个片段着色器，使用丢弃关键字根据UV纹理坐标移除某些片段。效果将是我们的小矮人模型呈现出格子或穿孔的外观。
- en: 'Let''s begin with looking at the vertex shader for this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看这个例子的顶点着色器开始：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, we are moving our lighting calculation back to the vertex shader.
    You may have noticed that this vertex shader is very similar to the previous example,
    with some slight changes. The first change to note is that we are using the UV
    texture coordinates in this example. We use the texture coordinates to determine
    the fragments to throw away, and we are not going to render the texture of the
    model this time. Since we are going to be discarding some fragments of the gnome
    model, we will be able to see through the model to the other and inside. This
    means we will need to calculate the lighting equation for both the front and back
    of the face. We accomplish this by calculating the Phong model for each side,
    changing the normal vector being passed in. We then store those values for each
    vertex in the `FrontColor` and `BackColor` variables to be passed along to the
    fragment shader. To again make our main class slightly easier to read, we also
    move the camera space transformation to a function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将光照计算移回到顶点着色器。您可能已经注意到，这个顶点着色器与上一个例子非常相似，只是有一些细微的变化。要注意的第一个变化是，我们在这个例子中使用了UV纹理坐标。我们使用纹理坐标来确定要丢弃的片段，并且这次我们不打算渲染模型的纹理。由于我们将丢弃一些小矮人模型的片段，我们将能够看到模型的内部和另一侧。这意味着我们需要为脸的正面和背面都计算光照方程。我们通过为每一侧计算冯氏模型来实现这一点，改变传入的法向量。然后我们将这些值存储在`FrontColor`和`BackColor`变量中，以便传递到片段着色器。为了使我们的主类再次更易于阅读，我们还将相机空间转换移到一个函数中。
- en: 'Next, let''s look at the fragment shader for this example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下这个例子的片段着色器：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In our fragment shader, we are calculating which fragment to discard to give
    us the desired perforated effect. To accomplish this, we first scale the UV coordinate
    using our scaling factor. This scaling factor represents the number of perforated
    rectangles per texture coordinate. Next, we calculate the fractional part of the
    texture coordinate components by using the GLSL function `fract()`. We then compare
    each *x* and *y* component to the float value of 0.2 using another GLSL function,
    `greaterThan()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的片段着色器中，我们正在计算要丢弃的片段，以实现所需的穿孔效果。为了实现这一点，我们首先使用我们的缩放因子来缩放UV坐标。这个缩放因子代表每个纹理坐标的穿孔矩形的数量。接下来，我们使用GLSL函数`fract()`来计算纹理坐标分量的小数部分。然后，我们使用另一个GLSL函数`greaterThan()`将每个*x*和*y*分量与0.2的浮点值进行比较。
- en: If both the *x* and *y* components of the vector in the `toDiscard` variable
    evaluate to true, this means the fragment lies within the perforated rectangle's
    frame, and we want to discard it. We can use the GLSL function to help us perform
    this check. The function call will return true if all of the components of the
    parameter vector are true. If the function returns true, we execute the `discard`
    statement to throw away that fragment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`toDiscard`变量中的向量的*x*和*y*分量都评估为true，这意味着片段位于穿孔矩形的边框内，我们希望丢弃它。我们可以使用GLSL函数来帮助我们执行这个检查。如果函数调用返回true，我们执行`discard`语句来丢弃该片段。
- en: Next, we have an `else` block where we color the fragment depending on whether
    it is a back-facing or front-facing polygon. To help us, we use the `gl_FronFacing()`
    function to return true or false based on the polygon's normal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`else`块，根据片段是背面还是正面多边形来着色。为了帮助我们，我们使用`gl_FronFacing()`函数根据多边形的法线返回true或false。
- en: 'Just as we have in the previous examples, we must again make sure to set the
    attributes and uniform variables needed for the shader in our game program. To
    see the full implementation of the example, see the `Chapter07`, `DiscardExample`,
    project. If we run this example program, you will see our gnome model looking
    as if he was made of lattice. The following is a screenshot of the output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的例子中一样，我们必须再次确保在游戏程序中设置着色器所需的属性和统一变量。要查看示例的完整实现，请参见`Chapter07`，`DiscardExample`项目。如果我们运行这个例子程序，您将看到我们的小矮人模型看起来好像是由格子制成的。以下是输出的屏幕截图：
- en: '![](img/e90cca70-3782-4848-8bee-a2e50889ee8d.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e90cca70-3782-4848-8bee-a2e50889ee8d.png)'
- en: Generating particles
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成粒子
- en: Another effect that you can achieve through the use of shaders is what is commonly
    referred to as particle effects. You can think of a particle system as a group
    of objects that are used in unison to create the visual appearance of smoke, fire,
    explosions, and so on. A single particle in the system is considered to be a point
    object with a position, but no size. To render these point objects, the `GL_POINTS`
    primitive is usually the most common method. You can, however, render particles
    just like any other object, using triangles or quads.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用着色器，您可以实现的另一个效果是通常称为粒子效果的效果。您可以将粒子系统视为一组对象，这些对象一起用于创建烟雾、火灾、爆炸等的视觉外观。系统中的单个粒子被认为是一个具有位置但没有大小的点对象。要渲染这些点对象，`GL_POINTS`原语通常是最常见的方法。但是，您也可以像渲染任何其他对象一样渲染粒子，使用三角形或四边形。
- en: 'For our example, we are going to implement a simple particle system that will
    have a fountain appearance. Each particle in our system will follow these rules.
    It will have a limited lifetime, it will be created and animated based on defined
    criteria, and will then terminate. In some particle systems, you could then recycle
    the particle, but for simplicity''s sake, our example here will not. The animation
    criteria for a particle is most often based on kinematic equations which define
    the movement of the particle based on gravitational acceleration, wind, friction,
    and other factors. Again, to keep our example simple, we will animate our particles
    using the standard kinematics calculation for objects under constant acceleration.
    The following equation describes the position of a particle at a given time *t*,
    where *P[0]* is the initial position, *V[0]t* is the initial velocity, and *a*
    represents the acceleration:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将实现一个简单的粒子系统，它将呈现出一个喷泉的外观。我们系统中的每个粒子都将遵循这些规则。它将有一个有限的寿命，它将根据定义的标准被创建和动画化，然后终止。在一些粒子系统中，您可以回收粒子，但为了简单起见，我们的示例不会这样做。粒子的动画标准通常基于运动方程，这些方程定义了粒子的运动，基于重力加速度、风、摩擦和其他因素。同样，为了保持我们的示例简单，我们将使用标准的运动学计算来对粒子进行动画处理。以下方程描述了给定时间*t*时粒子的位置，其中*P[0]*是初始位置，*V[0]t*是初始速度，*a*代表加速度：
- en: '*P(t) = P[0]+ V­[0]t + ½at²*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*P(t) = P[0]+ V­[0]t + ½at²*'
- en: In our example, we will define the initial position of the particles to be at
    the origin (0,0,0). The initial velocity will be calculated randomly within a
    range. Since each particle will be created at a different time interval in our
    equation, time will be relative to the creation time of that particle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将定义粒子的初始位置为原点(0,0,0)。初始速度将在一个范围内随机计算。由于每个粒子将在我们方程中的不同时间间隔内创建，时间将相对于该粒子的创建时间。
- en: 'Since the initial position is the same for all particles, we won''t need to
    provide it as an attribute to our shader. We will only have to provide two vertex
    attributes: the initial velocity and the start time for the particles. As mentioned
    previously, we will render each particle using `GL_POINTS`. The cool thing about
    using `GL_POINTS` is it is easy to apply a texture to a point sprite because OpenGL
    will automatically generate texture coordinates and pass them to the fragment
    shader via the GLSL variable `gl_PointCoord`. To give the appearance of the particle
    fading away, we will also increase the transparency of the point object linearly
    over the lifetime of the particle.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有粒子的初始位置相同，我们不需要将其作为着色器的属性提供。我们只需要提供两个顶点属性：粒子的初始速度和开始时间。如前所述，我们将使用`GL_POINTS`来渲染每个粒子。使用`GL_POINTS`的好处是很容易将纹理应用到点精灵上，因为OpenGL会自动生成纹理坐标并通过GLSL变量`gl_PointCoord`将其传递给片段着色器。为了使粒子看起来逐渐消失，我们还将在粒子的寿命内线性增加点对象的透明度。
- en: 'Let''s begin with a look at the vertex shader for this example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个示例的顶点着色器开始：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our shader begins with the two required input attributes, the initial velocity
    of the particle, `VertexInitVel`, and the start time of the particle, `StartTime`.
    We then have the output variable `Transp` which will hold the calculation of the
    particle''s transparency to be passed to the next shader stage. Next, we have
    our uniform variables: time, the animation runtime, gravity, used to calculate
    the constant acceleration, and `ParticleLifetime`, which specifies the maximum
    amount of time a particle can stay active. In the main function, we first set
    the initial position of the particle to be the origin, in this case (0,0,0). We
    then set the transparency to 0\. Next, we have a conditional that checks if the
    particle has been activated yet. If the current time is greater than the start
    time, the particle is active, or else the particle is not active. If the particle
    is not active, the position is left at the origin and the particle is rendered
    with full transparency. Then, if the particle is alive, we determine the current
    *age* of the particle by subtracting the start time from the current time, and
    we store the result in a float value `t`. We then check `t` against the `ParticleLiftime`
    value, and if `t` is greater than the lifetime value for the particle, the particle
    has already run through its lifetime animation and is then rendered fully transparent.
    If `t` is not greater than the lifetime value, the particle is in an active state
    and we animate the particle. We accomplish this animation using the equation we
    discussed previously. The transparency is determined by interpolation based on
    the runtime or *age* of the particle.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的着色器以两个必需的输入属性开始，即粒子的初始速度`VertexInitVel`和粒子的开始时间`StartTime`。然后我们有输出变量`Transp`，它将保存粒子透明度的计算结果传递到下一个着色器阶段。接下来，我们有我们的统一变量：时间，动画运行时间，重力，用于计算恒定加速度，以及`ParticleLifetime`，它指定粒子可以保持活动状态的最长时间。在主函数中，我们首先将粒子的初始位置设置为原点，在本例中为(0,0,0)。然后我们将透明度设置为0。接下来，我们有一个条件，检查粒子是否已激活。如果当前时间大于开始时间，则粒子处于活动状态，否则粒子处于非活动状态。如果粒子处于非活动状态，则位置保持在原点，并且以完全透明度渲染粒子。然后，如果粒子仍然存活，我们通过从当前时间减去开始时间来确定粒子的当前*年龄*，并将结果存储在浮点值`t`中。然后我们将`t`与`ParticleLiftime`值进行比较，如果`t`大于粒子的寿命值，则粒子已经完成了其寿命动画，然后以完全透明度渲染。如果`t`不大于寿命值，则粒子处于活动状态，我们对粒子进行动画处理。我们使用我们之前讨论的方程来实现这种动画。透明度是根据粒子的运行时间或*年龄*进行插值确定的。
- en: 'Now let''s look at the fragment shader for this example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下这个例子的片段着色器：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our fragment shader for this example is pretty basic. Here, we are setting the
    color of the fragment based on its texture lookup value. As mentioned previously,
    because we are using the `GL_POINT` primitive, the texture coordinates are automatically
    calculated by OpenGL's `gl_PointCoord` variable. To wrap up, we multiply the alpha
    value of the fragment's final color by the `Transp` input variable. This will
    give us the fade away effect as our particle's runtime elapses.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个例子的片段着色器非常基本。在这里，我们根据其纹理查找值设置片段的颜色。如前所述，因为我们使用`GL_POINT`原语，所以纹理坐标由OpenGL的`gl_PointCoord`变量自动计算。最后，我们将片段的最终颜色的alpha值乘以`Transp`输入变量。这将在我们的粒子运行时消逝时给我们淡出效果。
- en: In our game code, we need to create two buffers. The first buffer will store
    the initial velocity for each of the particles. The second buffer will store the
    start time for each particle. We will also have to set the uniform variables needed,
    including the `ParticleTex` for the particle texture, the `Time` variable for
    the amount of time that has elapsed since the animation beginning, the `Gravity`
    variable for representing the acceleration constant, and the `ParticleLifetime`
    variable for defining how long a particle will run its animation for. For brevity's
    sake, I will not go through the code here, but you can see the implementation
    of `Chapter07` folder's particle example project.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏代码中，我们需要创建两个缓冲区。第一个缓冲区将存储每个粒子的初始速度。第二个缓冲区将存储每个粒子的开始时间。我们还必须设置所需的统一变量，包括`ParticleTex`用于粒子纹理，`Time`变量用于表示动画开始后经过的时间量，`Gravity`变量用于表示加速度常数，以及`ParticleLifetime`变量用于定义粒子运行动画的持续时间。为了简洁起见，我不会在这里介绍代码，但您可以查看`Chapter07`文件夹中粒子示例项目的实现。
- en: 'Before testing our example, we also need to make sure that depth test is off
    and that enable alpha blending is on. You can do this with the following lines
    of code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的示例之前，我们还需要确保深度测试关闭，并且启用了alpha混合。您可以使用以下代码来实现：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You may also want to change the point object size to be a more reasonable value.
    You can set the value to 10 pixels using the following line of code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想将点对象的大小更改为更合理的值。您可以使用以下代码将值设置为10像素：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we now run our example project, we will see a particle effect similar to
    a fountain. A couple of captured frames can be seen as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的示例项目，我们将看到类似喷泉的粒子效果。可以看到一些捕获的帧如下：
- en: '![](img/245c79e2-56a5-44c1-9414-d1040716729a.png)![](img/e5b65410-4810-4b6b-94d4-6aeba4eca42e.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/245c79e2-56a5-44c1-9414-d1040716729a.png)![](img/e5b65410-4810-4b6b-94d4-6aeba4eca42e.png)'
- en: While this is a simple example, it has room for a lot of performance and flexibility
    increases, and it should provide you with a good starting point for implementing
    GPU based particle systems. Feel free to experiment with different input values,
    maybe even adding more factors to the particles animation calculation. Experimentation
    can lead to a lot of interesting outcomes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个简单的例子，但它有很大的性能和灵活性提升空间，应该为您实现基于GPU的粒子系统提供了一个很好的起点。请随意尝试不同的输入值，甚至可以添加更多因素到粒子动画计算中。实验可能会带来很多有趣的结果。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of working with shaders. We learned how
    we can build a compiler and link abstraction layers to save us time. We gained
    knowledge about lighting technique theories and how we can implement them in shader
    language. Finally, we closed out the chapter by looking at other uses for shaders
    such as creating particle effects. In the next chapter, we will expand our example
    game framework further by creating advanced gameplay systems.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用着色器的基础知识。我们学习了如何构建编译器和链接抽象层，以节省时间。我们了解了光照技术理论以及如何在着色器语言中实现它们。最后，我们通过研究着色器的其他用途，比如创建粒子效果，结束了本章。在下一章中，我们将通过创建高级游戏玩法系统进一步扩展我们的示例游戏框架。
