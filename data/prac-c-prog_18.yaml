- en: Applying Security in Coding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编码中应用安全性
- en: While coding, sometimes you may use functions that don't check or constrain
    the data entered by the user. The user either may enter incorrect data or content
    that might be larger than the capacity of the receiving variable. In such a situation,
    a buffer overflow or segmentation fault may occur. Consequently, the program will
    give an erroneous output.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码过程中，有时你可能使用不检查或约束用户输入数据的函数。用户可能输入错误的数据或内容，可能比接收变量的容量大。在这种情况下，可能会发生缓冲区溢出或段错误。因此，程序将给出错误输出。
- en: 'In this chapter, we will use the following recipes to see how we can error-proof
    the entering of data in a program:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下方法来查看我们如何使程序中的数据输入无错误：
- en: Avoiding buffer overflow while reading strings from the keyboard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免从键盘读取字符串时的缓冲区溢出
- en: Writing secure code while copying strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复制字符串时编写安全代码
- en: Avoiding errors while string formatting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免字符串格式化时的错误
- en: Avoid vulnerabilities while accessing files in C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在C中访问文件时的漏洞
- en: Buffer overflow
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: The most common vulnerability in C programming is buffer overflows. The buffer,
    as the name suggests, represents a temporary area of memory storage in the RAM
    that a program uses to run itself. Usually, all the variables used in a program
    are assigned temporary buffer storage for keeping the values assigned to them.
    Some functions don't limit the data within the buffer boundaries while assigning
    larger values (larger than the assigned buffer) to the variables, leading to overflowing
    of the buffer. The overflowing data corrupts or overwrites data of other buffers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程中最常见的漏洞是缓冲区溢出。缓冲区，正如其名所示，代表程序在RAM中使用的临时内存存储区域。通常，程序中使用的所有变量都被分配临时缓冲区存储，以保持分配给它们的值。一些函数在将较大的值（大于分配的缓冲区）赋给变量时，不限制缓冲区内的数据，导致缓冲区溢出。溢出的数据会破坏或覆盖其他缓冲区中的数据。
- en: These buffer overflows might be used by hackers or malicious users to damage
    files or data or to extract sensitive information. That is, an attacker might
    enter such an input that leads to buffer overflows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓冲区溢出可能被黑客或恶意用户用来损坏文件或数据，或提取敏感信息。也就是说，攻击者可能会输入导致缓冲区溢出的输入。
- en: While assigning values to an array, there are no bounds checks and the code
    might work, whether the memory being accessed belongs to your program or not.
    In most cases, it leads to a segmentation fault, overwriting data in another memory
    region.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在为数组赋值时，没有边界检查，代码可能工作，无论访问的内存是否属于你的程序。在大多数情况下，这会导致段错误，覆盖另一个内存区域中的数据。
- en: We will be using some terms and functions repeatedly in this program. Let's
    do a quick overview of them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将反复使用一些术语和函数。让我们快速概述一下它们。
- en: gets()
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gets()
- en: 'The `gets()` function reads characters from the standard input device and assigns
    them to the specified string. Reading of characters stops when the newline character
    is reached. This function does not check for buffer length and always results
    in a vulnerability. Here is its syntax:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`gets()` 函数从标准输入设备读取字符，并将它们分配到指定的字符串中。读取字符在遇到换行符时停止。此函数不检查缓冲区长度，总是导致漏洞。以下是它的语法：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `str` represents the pointer to the string (array of characters) to which
    the read characters are assigned.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`str` 代表指向字符串（字符数组）的指针，读入的字符将被分配到该字符串中。
- en: On successful execution, the function returns `str` and `NULL` if any error
    occurs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行的情况下，该函数返回 `str`，如果发生任何错误则返回 `NULL`。
- en: fgets()
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fgets()
- en: 'The `fgets()` function is used for reading a string from the specified source,
    where the source can be any file, keyboard, or another input device. Here is its
    syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets()` 函数用于从指定的源读取字符串，其中源可以是任何文件、键盘或其他输入设备。以下是它的语法：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `numb` number of bytes are read from the specified source `src` and assigned
    to the string pointed to by `str`. The function either reads `numb-1` bytes, or
    until a newline (`\n`) is reached, or an end of file is encountered, whichever
    happens first.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从指定的源 `src` 读取 `numb` 个字节，并将它们分配到由 `str` 指向的字符串中。该函数要么读取 `numb-1` 个字节，要么直到遇到换行符
    (`\n`) 或文件结束，以先到者为准。
- en: The function also appends the null character (`\0`) to the string that is read
    to terminate the string. If executed successfully, the function returns a pointer
    to `str` and returns `NULL` if an error occurs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还会将空字符 (`\0`) 添加到读取的字符串中，以终止字符串。如果执行成功，函数返回指向 `str` 的指针；如果发生错误，则返回 `NULL`。
- en: fpurge(stdin)
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fpurge(stdin)
- en: The `fpurge(stdin)` function is used to flush or clear out the input buffer
    of the stream. Sometimes, after feeding data for some variables, the data (which
    might be in the form of spaces or a newline character) is left behind in the buffer
    and is not cleared. In such cases, this function is used. If executed successfully,
    the function returns zero, else it returns EOF.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpurge(stdin)` 函数用于清除或清空流的输入缓冲区。有时，在为一些变量提供数据后，数据（可能是空格或换行符的形式）会留在缓冲区中，没有被清除。在这种情况下，使用此函数。如果执行成功，函数返回零，否则返回
    EOF。'
- en: 'Here is its syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的语法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: sprintf()
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sprintf()`'
- en: 'The `sprintf()` function is used for assigning formatted text to a string.
    Here is its syntax:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf()` 函数用于将格式化文本分配到字符串中。以下是它的语法：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `str` is a pointer to the string where the formatted string has to be
    assigned, and `format` is the same as in a `printf` statement, where different
    formatting tags such as `%d` and `%s` can be used to format the content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`str` 是一个指向字符串的指针，格式化字符串需要被分配到这个字符串中，而 `format` 与 `printf` 语句中的用法相同，可以使用不同的格式化标签，如
    `%d` 和 `%s` 来格式化内容。
- en: snprintf()
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`snprintf()`'
- en: 'The `snprintf()` function formats the given content and assigns it to the specified
    string. Only the specified number of bytes will be assigned to the destination
    string. Here is its syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`snprintf()` 函数格式化给定内容并将其分配到指定的字符串。只有指定数量的字节将被分配到目标字符串。以下是它的语法：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s a breakdown of what the preceding code represents:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: '`*str`: Represents the pointer that points to the string where formatted content
    will be assigned.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*str`：表示指向字符串的指针，格式化内容将被分配到该字符串。'
- en: '`numb`: Represents the maximum number of bytes that can be assigned to the
    string.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numb`：表示可以分配到字符串的最大字节数。'
- en: '`format`: Like the `printf` statement, several formatting tags such as `%d` and `%s` can
    be used to format the content.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：与 `printf` 语句类似，可以使用多个格式化标签，如 `%d` 和 `%s` 来格式化内容。'
- en: 'Note: `snprintf` automatically appends a null character to the formatted string.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`snprintf` 自动将空字符追加到格式化字符串中。
- en: strcpy()
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`strcpy()`'
- en: 'The `strcpy()` function is used for copying the content from one string to
    another. Here is its syntax:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcpy()` 函数用于从一个字符串复制内容到另一个字符串。以下是它的语法：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `src` represents the pointer to the source string from where the content
    has to be copied and `dest` represents the pointer to the destination string to
    which the content has to be copied.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`src` 代表源字符串的指针，内容需要从该字符串复制，而 `dest` 代表目标字符串的指针，内容需要复制到该字符串。
- en: strncpy( )
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`strncpy( )`'
- en: 'The `strncpy()` function is used for copying the specified number of bytes
    from one string into another. Here is its syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`strncpy()` 函数用于从字符串复制指定数量的字节到另一个字符串。以下是它的语法：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a breakdown of what the preceding code represents:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: '`dest`: Represents the pointer to the destination string to where the bytes
    have to be copied'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`：表示复制到目标字符串的指针'
- en: '`src`: Represents the pointer to the source string from where the bytes have
    to be copied'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：表示从源字符串复制字节的指针'
- en: '`numb`: Represents the number of bytes to be copied from source to the destination
    string'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numb`：表示从源字符串复制到目标字符串的字节数'
- en: If the value of the `numb` parameter is larger than the length of the source
    string, the destination string will be padded with null bytes. If the length of
    the destination string is smaller than the `numb` parameter, then the string will
    be truncated to be equal to the length of the destination string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `numb` 参数的值大于源字符串的长度，目标字符串将以空字节填充。如果目标字符串的长度小于 `numb` 参数，则字符串将被截断以等于目标字符串的长度。
- en: Let's now begin our journey for secure coding with the first recipe.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始我们的安全编码之旅，从第一个菜谱开始。
- en: Understanding how a buffer overflow occurs
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓冲区溢出是如何发生的
- en: In this recipe, we will learn to get input from the user and will see the situations
    that lead to a buffer overflow and result in ambiguous output. We will also learn
    the procedure to avoid a buffer overflow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何从用户那里获取输入，并看到导致缓冲区溢出并产生模糊输出的情况。我们还将学习避免缓冲区溢出的方法。
- en: Basically, we will make a structure comprising two members and in one of the
    members, we will deliberately enter text that is larger than its capacity, as
    a result of which a buffer overflow will occur. This will lead to the overwriting
    of the content of another member of the structure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将创建一个包含两个成员的结构体，并在其中一个成员中故意输入超过其容量的文本，从而导致缓冲区溢出。这将导致结构体另一个成员的内容被覆盖。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to make a program that will lead to a buffer overflow:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建会导致缓冲区溢出的程序的步骤：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`name`和`orderid`两个成员的结构体。
- en: Define two variables of the structure type defined in *step 1*. In one of the
    structure variables, we will deliberately generate a buffer overflow by entering
    a large amount of data.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类型为*步骤1*中定义的结构体的变量。在其中一个结构体变量中，我们将故意输入大量数据以生成缓冲区溢出。
- en: Prompt the user to enter a value for the `orderid` member for the first structure.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户为第一个结构体输入`orderid`成员的值。
- en: Invoke the `fpurge` function to empty out the input stream buffer before invoking
    the `gets` function.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`gets`函数之前，调用`fpurge`函数以清空输入流缓冲区。
- en: Invoke the `gets` function to enter data for the `name` member for the first
    structure. Enter text that is larger than the length of the `name` member.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`gets`函数为第一个结构体的`name`成员输入数据。输入比`name`成员长度更大的文本。
- en: Repeat *steps 3* to *5* to enter data for the `orderid` and `name` members for
    the second structure. This time, enter data within the capacity of the `name`
    member.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤3*到*5*以输入第二个结构体的`orderid`和`name`成员的数据。这次，请输入在`name`成员容量内的数据。
- en: Display data assigned to the `orderid` and `name` members of the first structure.
    Buffer overflow will occur in the case of the first structure and you will get
    an ambiguous output while displaying the `orderid` value.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给第一个结构体的`orderid`和`name`成员的数据。在第一个结构体中将会发生缓冲区溢出，您在显示`orderid`值时将得到一个模糊的输出。
- en: Display data assigned to the `orderid` and `name` member of the second structure.
    No buffer overflow takes place in this structure and you get exactly the same
    data that was entered for both the members.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给第二个结构体的`orderid`和`name`成员的数据。在这个结构体中没有发生缓冲区溢出，您将得到与两个成员输入完全相同的数据。
- en: 'The following program will take the name and order number values for two structures.
    In one member of the structure, we will enter data that is larger than its capacity
    to generate a buffer overflow:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将获取两个结构体的名称和订单号值。在结构体的一个成员中，我们将输入超过其容量的数据以生成缓冲区溢出：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解其工作原理。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The program will ask for two pairs of names and order numbers. In the first
    pair, we will deliberately generate a buffer overflow by entering text that is
    longer than the variable size, whereas for the second pair, we will enter the
    data within the specified range. Consequently, the information of the first user
    (pair) will be displayed incorrectly, that is, the data will not appear exactly
    the same as it was entered, whereas that of the second user will appear correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将要求输入两对名称和订单号。在第一对中，我们将通过输入比变量大小更长的文本来故意生成缓冲区溢出，而对于第二对，我们将输入指定范围内的数据。因此，第一个用户（对）的信息将显示不正确，即数据不会与输入的完全相同，而第二个用户的信息将正确显示。
- en: So, we will define a structure called `users` with two fields or members called
    `name` and `orderid`, where `name` is defined as a string of size 10 bytes and
    `orderid` is defined as an int variable of 2 bytes. Then, we will define two variables
    `user1` and `user2` of the `users` structure type; that means both the `user1`
    and `user2` variables will get a `name` and `orderid` member each.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将定义一个名为`users`的结构体，其中包含两个字段或成员，分别称为`name`和`orderid`，其中`name`被定义为大小为10字节的字符串，`orderid`被定义为2字节的int变量。然后，我们将定义两个`users`结构体类型的变量`user1`和`user2`；这意味着`user1`和`user2`变量都将各自获得一个`name`和`orderid`成员。
- en: You will be prompted to enter the username and order number twice. The first
    pair of names and the order numbers entered will be assigned to `user1` and the
    second to `user2`. The entered information of the two users is then displayed
    on the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示两次输入用户名和订单号。输入的第一组名称和订单号将被分配给`user1`，第二组分配给`user2`。然后，两个用户的输入信息将在屏幕上显示。
- en: 'Let''s use GCC to compile the `getsproblem.c` program. If you get no errors
    or warnings, it means the `getsproblem.c` program has compiled into an executable
    file: `getsproblem.exe`. Let''s run this file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`getsproblem.c`程序。如果你没有错误或警告，这意味着`getsproblem.c`程序已编译成可执行文件：`getsproblem.exe`。让我们运行这个文件：
- en: '![](img/aa9293f3-cf51-44ab-87b7-7c2384259cb4.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa9293f3-cf51-44ab-87b7-7c2384259cb4.png)'
- en: Figure 18.1
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1
- en: We can see in the preceding output that because of the buffer overflow made
    by the `name` member in the first structure, the value of the `orderid` member,
    which was `101`, is overwritten. Consequently, we get a garbage value for the
    `orderid` of the first structure. The output of the second structure is correct
    because the value entered for its members is within their capacity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的输出中看到，由于第一个结构体中`name`成员造成的缓冲区溢出，`orderid`成员的值`101`被覆盖。因此，我们得到第一个结构体的`orderid`的垃圾值。第二个结构体的输出是正确的，因为为其成员输入的值在其容量范围内。
- en: To avoid overflow while entering data, we simply replace the `gets` function
    with the `fgets` function. With the `fgets` function, we can specify the maximum
    number of characters that can be allowed in the specified string. The extra text
    will be truncated and will not be assigned to the specified string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在输入数据时发生溢出，我们只需将`gets`函数替换为`fgets`函数。使用`fgets`函数，我们可以指定允许在指定字符串中的最大字符数。超出部分的文本将被截断，并且不会分配给指定的字符串。
- en: Learning how to avoid a buffer overflow
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何避免缓冲区溢出
- en: In the previous recipe, we defined two structure variables because we wanted
    to show that if data entered is larger in size than the member field allows, it
    will result in ambiguous output; and if data is entered within the capacity of
    the receiving variables, it will generate the correct output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们定义了两个结构体变量，因为我们想展示，如果输入的数据大小大于接收变量字段允许的大小，将导致模糊的输出；如果输入的数据在接收变量的容量范围内，将生成正确的输出。
- en: In the following recipe, we don't need two structure variables as we will be
    using the `fgets` function to address our concern. This function never results
    in a buffer overflow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的步骤中，我们不需要两个结构体变量，因为我们将会使用`fgets`函数来解决问题。这个函数永远不会导致缓冲区溢出。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps for avoiding a buffer overflow using the `fgets` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`fgets`函数避免缓冲区溢出的步骤：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的结构体，`name`和`orderid`。
- en: Define a variable of the structure type defined in *step 1*.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类型为*步骤1*中定义的结构体的变量。
- en: Prompt the user to enter a value for the `orderid` member of the structure.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户为结构体的`orderid`成员输入一个值。
- en: Invoke the `fpurge` function to empty out the input stream buffer before invoking
    the `fgets` function.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`fgets`函数之前，调用`fpurge`函数清空输入流缓冲区。
- en: Invoke the `fgets` function to enter data for the `name` member of the structure.
    In order to constrain the size of the text to be assigned to `name` member, its
    length is computed by invoking the `sizeof` function and that length of string
    is supplied to the `fgets` function.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fgets`函数为结构体的`name`成员输入数据。为了限制分配给`name`成员的文本的大小，通过调用`sizeof`函数计算其长度，并将该字符串长度提供给`fgets`函数。
- en: Add a null character to the string, if one is not already there, to terminate
    the string.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符串中还没有空字符，则添加一个空字符以终止字符串。
- en: Display data assigned to the `orderid` and `name` members of the structure to
    verify that there is no buffer overflow.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给结构体成员`orderid`和`name`的数据，以验证没有缓冲区溢出。
- en: 'The following program defines a structure consisting of two members and explains
    how a buffer overflow can be avoided while entering data through the keyboard:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序定义了一个包含两个成员的结构体，并解释了如何在通过键盘输入数据时避免缓冲区溢出：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the program, the `fgets` function takes input from the standard input device
    and the maximum number of characters that will be read from the input device will
    be equal to the number of bytes allowed in the `name` variable of the `user1`
    structure. As a result, even if the user enters a larger string, only the specified
    number of bytes from the input will be picked up; that is, only the first 10 characters
    in the input will be picked up and assigned to the `name` member of the `user1`
    structure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`fgets` 函数从标准输入设备获取输入，从输入设备读取的最大字符数将等于 `user1` 结构体中 `name` 变量允许的字节数。因此，即使用户输入了较长的字符串，也只会从输入中选取指定的字节数；也就是说，只会选取输入中的前10个字符并分配给
    `user1` 结构体的 `name` 成员。
- en: The `fgets` function appends the null character (`\0`) to the string, provided
    the number of characters entered is one less than the maximum length specified
    in the function. But for the string that is larger than the specified length,
    we need to insert the null character at the end of the string. To do so, we need
    to check if the newline character is there as the last character of the string.
    If yes, then we replace the newline character in the string with the null character
    to terminate the string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets` 函数会将空字符 (`\0`) 追加到字符串中，前提是输入的字符数比函数中指定的最大长度少一个。但对于比指定长度大的字符串，我们需要在字符串的末尾插入空字符。为此，我们需要检查换行符是否作为字符串的最后一个字符存在。如果是，那么我们将字符串中的换行符替换为空字符以终止字符串。'
- en: 'Let''s use GCC to compile the `getssolved.c` program. If you get no errors
    or warnings, it means the `getssolved.c` program has compiled into an executable
    file: `getssolved.exe`. Let''s run this file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `getssolved.c` 程序。如果你没有错误或警告，这意味着 `getssolved.c` 程序已编译成可执行文件：`getssolved.exe`。让我们运行这个文件：
- en: '![](img/e4374252-eb37-4725-a33a-1db7f9bfb903.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4374252-eb37-4725-a33a-1db7f9bfb903.png)'
- en: Figure 18.2
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2
- en: We can see in the preceding output that the larger text assigned to the `name`
    member of the structure is truncated as per the member's size, hence no buffer
    overflow occurs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的输出中看到，分配给结构体成员 `name` 的较长的文本被截断，按照成员的大小进行截断，因此不会发生缓冲区溢出。
- en: Understanding how a vulnerability occurs while copying strings
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解在复制字符串时如何发生漏洞
- en: In this recipe, we will see the vulnerability that might occur while copying
    a string. We will also see how to avoid that vulnerability. We will first define
    a structure consisting of two members. In one of the members, we will be copying
    a text that is larger than its capacity, which will result in overwriting the
    content of another member.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到在复制字符串时可能发生的漏洞。我们还将看到如何避免这个漏洞。我们首先定义一个由两个成员组成的结构体。在一个成员中，我们将复制一个比其容量大的文本，这将导致覆盖另一个成员的内容。
- en: In the next recipe, we will learn how to avoid this problem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习如何避免这个问题。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to understand how a vulnerability occurs while copying a
    string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是理解在复制字符串时如何发生漏洞的步骤：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的结构体，`name` 和 `orderid`。
- en: Define a variable of the structure type defined in *step 1*.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个由步骤1中定义的结构体类型定义的变量。
- en: Assign any integer value to the `orderid` member of the structure.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何整数值分配给结构体的 `orderid` 成员。
- en: Invoke the `strcpy` function to assign text to the `name` member of the structure.
    In order to generate a buffer overflow, assign a larger text to it.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `strcpy` 函数将文本分配给结构体的 `name` 成员。为了生成缓冲区溢出，向其分配较长的文本。
- en: Display data assigned to the `orderid` and `name` members of the structure to
    confirm if the ambiguous output is generated, which verifies that a buffer overflow
    has occurred.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给结构体成员 `orderid` 和 `name` 的数据，以确认是否生成了模糊的输出，这验证了发生了缓冲区溢出。
- en: 'The program that shows a vulnerability when copying a string is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在复制字符串时出现漏洞的程序如下：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To enter the name and order number of a customer, define a structure called
    users with two members, `name` and `orderid`. The `name` member is a character
    array or string of 10 bytes in length, and the `orderid` member is a variable
    of the `int` data type consisting of 2 bytes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输入客户的名称和订单号，定义一个名为 `users` 的结构体，包含两个成员，`name` 和 `orderid`。`name` 成员是一个长度为10个字节的字符数组或字符串，而
    `orderid` 成员是一个由2个字节组成的 `int` 数据类型的变量。
- en: A variable, `user1`, is defined as the `users` structure type; hence, the `user1`
    structure will get two members, `name` and `orderid`. An integer value 101 is
    assigned to the `orderid` member of `user1` structure. Also, a string, `administrator`,
    is assigned to the `name` member of `user1`. Because the string administrator
    is larger than the size of the `name` member, a buffer overflow will occur, overwriting
    the memory of the next memory location, that is, of the `orderid` member. Consequently,
    while displaying the information of the user, though the data in the `name` member
    may appear correctly, the content of `orderid` member will appear incorrectly,
    as its content is overwritten.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`user1`的变量，其类型为`users`结构；因此，`user1`结构将获得两个成员，`name`和`orderid`。将整数值101分配给`user1`结构中`orderid`成员。同时，将字符串`administrator`分配给`user1`的`name`成员。由于字符串`administrator`的大小超过了`name`成员的大小，将发生缓冲区溢出，覆盖下一个内存位置的内存，即`orderid`成员的内存。因此，在显示用户信息时，尽管`name`成员中的数据可能显示正确，但`orderid`成员的内容将显示错误，因为其内容已被覆盖。
- en: 'Let''s use GCC to compile the `strcpyproblem.c` program. If you get no errors
    or warnings, it means the `strcpyproblem.c` program has compiled into an executable
    file: `strcpyproblem.exe`. Let''s run this file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`strcpyproblem.c`程序。如果你没有错误或警告，这意味着`strcpyproblem.c`程序已编译成可执行文件：`strcpyproblem.exe`。让我们运行这个文件：
- en: '![](img/9720450c-8077-47f1-b468-e088eac27fa0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9720450c-8077-47f1-b468-e088eac27fa0.png)'
- en: Figure 18.3
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3
- en: In the preceding output, you can see that because the `name` member is assigned
    a string that is larger than its size, this results in it overwriting the content
    of another member, `orderid`. The content of the `name` member appears the same
    as entered by the user, whereas that of `orderid` is displayed incorrectly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到，由于`name`成员被分配了一个比其大小大的字符串，这导致它覆盖了另一个成员`orderid`的内容。`name`成员的内容与用户输入的相同，而`orderid`的内容显示错误。
- en: Learning how to write secure code while copying strings
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何在复制字符串时编写安全的代码
- en: To avoid the buffer overflow that occurs when using the `strcpy` function, simply
    replace the `strcpy` function with the `strncpy` function. `strncpy` will copy
    only the specified number of bytes into the destination string, hence buffer overflows
    don't occur in this function. Let's see how it is done.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用`strcpy`函数时发生的缓冲区溢出，只需将`strcpy`函数替换为`strncpy`函数。`strncpy`将只复制指定数量的字节到目标字符串，因此在这个函数中不会发生缓冲区溢出。让我们看看它是如何完成的。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to make secure code while copying a string:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制字符串时编写安全代码的步骤如下：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员`name`和`orderid`的结构。
- en: Define a variable of the structure type defined in *step 1*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类型为*步骤1*中定义的结构类型的变量。
- en: Assign any integer value to the `orderid` member of the structure.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何整数值分配给结构的`orderid`成员。
- en: Determine the length of the `name` member of the structure to find the maximum
    number of characters that it can accommodate.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定结构的`name`成员的长度，以找到它可以容纳的最大字符数。
- en: Invoke the `strncpy` function for copying a text to the `name` member of the
    structure. Pass the length of the `name` member, too, to the `strncpy` function
    to truncate the text if it is larger than the capacity of the `name` member.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`strncpy`函数将文本复制到结构的`name`成员。同时，也将`name`成员的长度传递给`strncpy`函数，以便在文本大于`name`成员容量时截断文本。
- en: Add a null character to the string, if it is not there already, to terminate
    it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符串中还没有空字符，请添加一个空字符以终止它。
- en: Display data assigned to the `orderid` and `name` members of the structure to
    verify that a buffer overflow does not occur and the same data is displayed as
    was entered.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给结构的`orderid`和`name`成员的数据，以验证没有发生缓冲区溢出，并且显示的数据与输入的数据相同。
- en: 'The program that is secure enough for copying strings is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个足够安全的字符串复制程序：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, everything is the same as the previous recipe. The point of
    difference is that we invoke the `strncpy` function. When this function is invoked,
    only the `strsize` number of bytes from the administrator text is assigned to
    the `name` member of the `user1` structure. Because `strsize` contains the maximum
    length of the `name` member, no buffer overflow will occur in this case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，一切与上一个菜谱相同。不同之处在于我们调用了`strncpy`函数。当调用此函数时，只有从`administrator`文本中分配的`strsize`个字节被分配给`user1`结构体的`name`成员。因为`strsize`包含`name`成员的最大长度，所以在这种情况下不会发生缓冲区溢出。
- en: Finally, we check if the null character, `\0`, exists as the last character
    in the `name` member. If not, then the null character is added at its end to terminate
    the string. On displaying the information of the user, we see that because the
    length of the `name` member is 10, only the first 9 characters from the text `administrator`
    are assigned to the `name` member, followed by a null character. As a result of
    this, the value of the `orderid` member will also appear correctly, exactly the
    same as was entered.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查空字符`\0`是否存在于`name`成员的最后一个字符。如果没有，则在末尾添加空字符以终止字符串。在显示用户信息时，我们可以看到，由于`name`成员的长度为10，只有文本`administrator`的前9个字符被分配给`name`成员，后面跟着一个空字符。因此，`orderid`成员的值也将正确显示，与输入的完全相同。
- en: 'Let''s use GCC to compile the `strcpysolved.c` program. If you get no errors
    or warnings, it means the `strcpysolved.c` program has compiled into an executable
    file: `strcpysolved.exe`. Let''s run this file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`strcpysolved.c`程序。如果你没有错误或警告，这意味着`strcpysolved.c`程序已编译成可执行文件：`strcpysolved.exe`。让我们运行这个文件：
- en: '![](img/2b32d2d3-e0db-4caf-a6ab-119f39ed60e0.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b32d2d3-e0db-4caf-a6ab-119f39ed60e0.png)'
- en: Figure 18.4
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4
- en: You can see in the preceding output that whatever value is entered for the two
    members, we get exactly the same output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的输出中看到，无论为两个成员输入什么值，我们都会得到完全相同的输出。
- en: Understanding the errors that occur while formatting strings
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解字符串格式化时出现的错误
- en: In this recipe, we will understand what kind of error might occur while formatting
    strings. We will also see how to avoid that error. We will define a structure
    consisting of two members, and to one member, we will be assigning a formatted
    string. Let's see what error we come across.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解在格式化字符串时可能会发生什么样的错误。我们还将看到如何避免这种错误。我们将定义一个包含两个成员的结构，并将格式化字符串分配给其中一个成员。让我们看看我们会遇到什么错误。
- en: In the next recipe, we will see how to avoid it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将看到如何避免这种情况。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to make a program in which an error occurs due to string
    formatting:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是制作一个由于字符串格式化而出现错误的程序的步骤：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员`name`和`orderid`的结构。
- en: Define a variable of the structure type defined in *step 1*.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个在*步骤1*中定义的结构类型的变量。
- en: Assign any integer value to the `orderid` member of the structure.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何整数值分配给结构体的`orderid`成员。
- en: Invoke the `sprintf` function to assign formatted text to the `name` member
    of the structure. In order to generate a buffer overflow, assign a larger text
    to it.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`sprintf`函数将格式化文本分配给结构的`name`成员。为了生成缓冲区溢出，请分配一个较长的文本。
- en: Display data assigned to the `orderid` and `name` members of the structure to
    confirm if the ambiguous output is generated to verify whether buffer overflow
    has occurred.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给结构体成员`orderid`和`name`的数据，以确认是否生成了模糊的输出，以验证是否发生了缓冲区溢出。
- en: 'The following is the program that generates an erroneous output because of
    applying string formatting:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个由于应用字符串格式化而产生错误输出的程序：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We want to enter information about the customer's name and the order placed
    by them. So, we define a structure called `users` with two members, `name` and
    `orderid`, where the `name` member is defined as a character array of length 10
    bytes, and the `orderid` member is defined of the int data type consisting of
    2 bytes. A variable, `user1`, is defined of the `users` structure type, hence
    the `user1` structure will get two members, `name` and `orderid`. An integer of
    value `101` is assigned to the `orderid` member of the `user1` structure.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想输入关于客户名称和他们下订单的信息。因此，我们定义了一个名为`users`的结构体，包含两个成员，`name`和`orderid`，其中`name`成员定义为长度为10字节的字符数组，而`orderid`成员定义为2字节的int数据类型。定义了一个`users`结构体类型的变量`user1`，因此`user1`结构体会获得两个成员，`name`和`orderid`。将值`101`的整数赋值给`user1`结构体的`orderid`成员。
- en: Using the `sprintf` function, a string, `bintuharwani`, is assigned to the `name`
    member of the `user1` structure. The `bintuharwani` string is larger than the
    `name` member, hence a buffer overflow will occur, overwriting the memory of the
    next memory location, that is, the memory of the `orderid` member. So, while displaying
    the information of the user, the name will appear correctly but you will get a
    different or ambiguous value for the `orderid` member.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sprintf`函数，将字符串`bintuharwani`赋值给`user1`结构体的`name`成员。由于`bintuharwani`字符串的大小超过了`name`成员，因此将发生缓冲区溢出，覆盖下一个内存位置的内存，即`orderid`成员的内存。因此，在显示用户信息时，名称将正确显示，但你将得到`orderid`成员的不同或模糊的值。
- en: 'Let''s use GCC to compile the `sprintfproblem.c` program. If you get no errors
    or warnings, it means the `sprintfproblem.c` program has compiled into an executable
    file: `sprintfproblem.exe`. Let''s run this file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`sprintfproblem.c`程序。如果没有错误或警告，这意味着`sprintfproblem.c`程序已编译成可执行文件：`sprintfproblem.exe`。让我们运行这个文件：
- en: '![](img/18cee49a-1d7f-44c9-9e93-0c6e5f435e65.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18cee49a-1d7f-44c9-9e93-0c6e5f435e65.png)'
- en: Figure 18.5
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5
- en: In the output, you can see that the order number is displayed incorrectly; that
    is, instead of the assigned value, `101`, it displays the value `0`. This is because
    on assigning the `bintuharwani` string to the `name` member, the fact that the
    string is larger in size than the capacity of the `name` member leads to a buffer
    overflow that overwrites the value of the `orderid` member.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到订单号显示错误；也就是说，不是显示分配的值`101`，而是显示值`0`。这是因为将`bintuharwani`字符串赋值给`name`成员时，由于字符串的大小超过了`name`成员的容量，导致缓冲区溢出，覆盖了`orderid`成员的值。
- en: Learning how to avoid errors while formatting strings
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何在格式化字符串时避免错误
- en: In this recipe, we will use the `snprintf` function. The `snprintf` function
    will assign the formatted text to the `name` member but will limit the size of
    the string assigned to it. The difference between the `sprintf` and `snprintf`
    functions is that `sprintf` simply assigns the complete formatted text to the
    destination string no matter what its capacity, whereas `snprintf` allows us to
    specify the maximum length of the text that can be assigned to the destination
    string. Therefore, a buffer overflow will not occur as only the specified size
    of the text is assigned to the destination string.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`snprintf`函数。`snprintf`函数将格式化文本赋值给`name`成员，但会限制分配给它的字符串的大小。`sprintf`和`snprintf`函数之间的区别在于，`sprintf`无论目标字符串的容量如何，都会简单地将完整的格式化文本赋值给目标字符串，而`snprintf`允许我们指定可以分配给目标字符串的文本的最大长度。因此，不会发生缓冲区溢出，因为只将指定的文本大小分配给目标字符串。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to make a program in which an error occurs due to string
    formatting:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建一个由于字符串格式化而出现错误的程序的步骤：
- en: Define a structure consisting of two members, `name` and `orderid`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的结构体，`name`和`orderid`。
- en: Define a variable of the structure type defined in *step 1*.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个由步骤1中定义的结构体类型变量。
- en: Assign any integer value to the `orderid` member of the structure.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何整数值赋给结构体的`orderid`成员。
- en: Invoke the `snprintf` function to assign formatted text to the `name` member
    of the structure. Pass the length of the `name` member to the `snprintf` function,
    as well, to truncate the text if it is larger than the capacity of the `name`
    member.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`snprintf`函数将格式化文本赋值给结构体的`name`成员。同时将`name`成员的长度传递给`snprintf`函数，以便在文本大于`name`成员的容量时截断文本。
- en: Display data assigned to the `orderid` and `name` members of the structure to verify
    that a buffer overflow does not occur and the same data is displayed as was entered.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示结构体`orderid`和`name`成员分配的数据，以验证不会发生缓冲区溢出，并且显示的数据与输入的数据相同。
- en: 'The following program shows how the error related to string formatting can
    be avoided:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了如何避免与字符串格式化相关的错误：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，更好地理解代码。
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To constrain the size of the content assigned to the `name` member of the `user1`
    structure, we will make use of the `snprintf` function. You can see that through
    the `snprintf` function, only the first 10 characters from the text `bintuharwani`
    are assigned to the `name` member. Because the length of the `name` member is
    10, it is capable of storing 10 characters and hence no buffer overflow occurs
    and the value assigned to the `orderid` member will remain intact and undisturbed.
    On displaying the values of the `orderid` and `name` members, both of their values
    will be displayed correctly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制分配给`user1`结构体`name`成员的内容大小，我们将使用`snprintf`函数。你可以看到，通过`snprintf`函数，只有文本`bintuharwani`的前10个字符被分配给`name`成员。因为`name`成员的长度是10，它能够存储10个字符，因此不会发生缓冲区溢出，分配给`orderid`成员的值将保持完整和未受干扰。在显示`orderid`和`name`成员的值时，它们的值都将正确显示。
- en: 'Let''s use GCC to compile the `sprintfsolved.c` program. If you get no errors
    or warnings, it means the `sprintfsolved.c` program has compiled into an executable
    file: `sprintfsolved.exe`. Let''s run this file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`sprintfsolved.c`程序。如果你没有错误或警告，这意味着`sprintfsolved.c`程序已编译成可执行文件：`sprintfsolved.exe`。让我们运行这个文件：
- en: '![](img/a61c9e8f-fc93-4768-bd4a-38b57a818263.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a61c9e8f-fc93-4768-bd4a-38b57a818263.png)'
- en: Figure 18.6
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6
- en: In the preceding output, we can see that the extra formatted text that is assigned
    to the `name` member is truncated, hence the correct output of the `name` and
    `orderid` members is displayed on the screen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到分配给`name`成员的额外格式化文本被截断，因此正确显示在屏幕上的`name`和`orderid`成员的输出。
- en: Understanding how vulnerabilities occur while accessing files in C
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解在C语言访问文件时如何出现漏洞
- en: Let's assume that you wrote a program to create a text file named `file1.txt`.
    In such programs, a malicious user or hacker might add some soft links to some
    important or sensitive file in the file that you want to create. As a result,
    it will lead to overwriting of the important file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你编写了一个程序来创建一个名为`file1.txt`的文本文件。在这样的程序中，恶意用户或黑客可能会在你要创建的文件中添加一些软链接到某些重要或敏感文件。结果，这会导致重要文件的覆盖。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start by assuming that some important file by the name of `file2.txt`
    already exists on your computer and contains some sensitive information. Here
    are the steps that a malicious user or hacker can use in your program to create
    a file to overwrite `file2.txt`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先假设一个名为`file2.txt`的重要文件已经存在于你的计算机上，并包含一些敏感信息。以下是恶意用户或黑客可以在你的程序中使用的步骤来创建一个覆盖`file2.txt`的文件：
- en: A file pointer is defined.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个文件指针。
- en: The hacker might create a soft link and attach a sensitive file to the file
    that we want to create.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黑客可能会创建一个软链接，并将一个敏感文件附加到我们想要创建的文件上。
- en: Open the file to which we want to write the content. But in reality, the sensitive
    file that is attached to our file will be opened in write-only mode.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们想要写入内容的文件。但在现实中，附加到我们的文件上的敏感文件将以只写模式打开。
- en: Prompt the user to enter the lines of text to be written into the file.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入要写入文件的文本行。
- en: Write the lines entered by the user into the file.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户输入的行写入文件。
- en: Repeat *steps 4* and *5* until the user enters `stop`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤4*和*步骤5*，直到用户输入`stop`。
- en: Close the file pointed to by the file pointer, `fp`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭由文件指针`fp`指向的文件。
- en: 'Following is the program that a malicious user can use to link some important
    file to the file that you want to create, and hence can overwrite and destroy
    that important file on your system:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个恶意用户可以用来将某些重要文件链接到你要创建的文件，从而覆盖和破坏系统上该重要文件的程序：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，更好地理解代码。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A file pointer is defined by the name `fp`. At this stage, a hacker or malicious
    user might invoke the `symlink` function to create a soft link named `file1.txt`
    to the file named `file2.txt`. In this program, `file2.txt` can be replaced by
    the password file or some other sensitive file that the malicious user may want
    to overwrite or destroy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 文件指针由名称 `fp` 定义。在这个阶段，黑客或恶意用户可能会调用 `symlink` 函数创建一个名为 `file1.txt` 的软链接指向名为 `file2.txt`
    的文件。在这个程序中，`file2.txt` 可以是密码文件或其他恶意用户可能想要覆盖或破坏的敏感文件。
- en: Because the program is for creating a new file, the program invokes the `fopen`
    function to open `file1.txt` in write-only mode and the opened file will be pointed
    at by `fp`, the file pointer. But because `file1.txt` and `file2.txt` are linked,
    `file2.txt` will be actually opened instead of `file1.txt`, and in write-only
    mode, and will be pointed at by the file pointer, `fp`. The program will terminate
    if the file cannot be opened in write-only mode or some other error occurs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序是用来创建新文件的，程序调用 `fopen` 函数以写入模式打开 `file1.txt`，打开的文件将由文件指针 `fp` 指向。但由于 `file1.txt`
    和 `file2.txt` 是链接的，实际上会打开 `file2.txt`，并以写入模式指向，由文件指针 `fp` 指向。如果无法以写入模式打开文件或发生其他错误，程序将终止。
- en: The user is prompted to enter lines of text for the file. The lines entered
    by the user are assigned to the `str` string. The `fputs` function is invoked
    to write the content assigned to the `str` string into the file pointed at by
    the file pointer, `fp`. Consequently, the sensitive file will be overwritten.
    The user can enter as many lines of text as desired and can enter `stop` when
    they are done. So a `while` loop is set to execute that will keep taking lines
    of text from the user and will keep writing them into the file until `stop` is
    entered. Finally, the file pointed to by the file pointer, `fp`,  is closed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被提示输入文件的文本行。用户输入的行被分配给 `str` 字符串。调用 `fputs` 函数将分配给 `str` 字符串的内容写入由文件指针 `fp`
    指向的文件。因此，敏感文件将被覆盖。用户可以输入任意多的文本行，并在完成后输入 `stop`。因此，设置了一个 `while` 循环来执行，将不断从用户那里获取文本行并将它们写入文件，直到输入
    `stop`。最后，关闭由文件指针 `fp` 指向的文件。
- en: 'Let''s use GCC to compile the `fileproblem.c` program as shown in the following
    screenshot. If you get no errors or warnings, it means the `fileproblem.c` program has
    compiled into an executable file: `fileproblem.exe`. Let''s run this file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `fileproblem.c` 程序，如下面的截图所示。如果你没有错误或警告，这意味着 `fileproblem.c` 程序已编译成可执行文件：`fileproblem.exe`。让我们运行这个文件：
- en: '![](img/cf883cc0-f3ab-4093-bd35-8832b53a9a6c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf883cc0-f3ab-4093-bd35-8832b53a9a6c.png)'
- en: Figure 18.7
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7
- en: 'The preceding text will not go into the desired file, `file1.txt`, but will
    overwrite the sensitive file, `file2.txt`, deleting its earlier content, if any.
    If we look at the content of the `file2.txt` file, we will see the content that
    was supposed to be written into `file1.txt`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文本不会进入期望的文件 `file1.txt`，而是会覆盖敏感文件 `file2.txt`，如果有的话，删除其早期内容。如果我们查看 `file2.txt`
    文件的内容，我们将看到本应写入 `file1.txt` 的内容：
- en: '![](img/96d98c10-a207-4c8f-b8b2-98656963c2df.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96d98c10-a207-4c8f-b8b2-98656963c2df.png)'
- en: Figure 18.8
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8
- en: Now, let's rewrite the program to remove the file vulnerabilities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重写程序以消除文件漏洞。
- en: Learning how to avoid vulnerabilities while writing a file in C
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何在编写 C 语言文件时避免漏洞
- en: The special care we will take in this recipe is that we will unlink all the
    links (if any) to the file that we are going to create. We will also ensure that
    our program does not overwrite any file if it already exists.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将特别注意：我们将解除所有（如果有）到我们要创建的文件的链接。我们还将确保如果文件已存在，我们的程序不会覆盖任何文件。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to write a program to avoid vulnerabilities while creating
    a file in C:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序以避免在 C 语言中创建文件时的漏洞的步骤如下：
- en: A file pointer is defined.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个文件指针。
- en: The hacker might create a soft link and attach a sensitive file to the file
    that we want to create.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黑客可能会创建一个软链接并将敏感文件附加到我们想要创建的文件上。
- en: Remove the links from the file that you want to write in.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你想要写入的文件中删除链接。
- en: Open the file using the flags that check whether the file already exists or
    not. If the file exists, it should be overwritten.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用检查文件是否存在的标志打开文件。如果文件存在，它应该被覆盖。
- en: Associate the file descriptor with the file stream.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件描述符与文件流关联。
- en: Prompt the user to enter the lines of text to be written into the file.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入要写入文件的文本行。
- en: Write the lines entered by the user into the file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户输入的行写入文件。
- en: Repeat *steps 5* and *6* until the user enters `stop`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 5* 和 *步骤 6*，直到用户输入 `stop`。
- en: Close the file pointed to by the file pointer, `fp`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭由文件指针 `fp` 指向的文件。
- en: 'The following is the program that removes vulnerabilities while creating a
    text file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在创建文本文件时移除漏洞的程序：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的情况。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can see in the program that a file pointer is defined by the name `fp`.
    We are expecting that a hacker or malicious user might have created a soft link called `file1.txt`
    to the existing file, `file2.txt`. `file2.txt` is a sensitive file that we don't
    want to be overwritten or destroyed. To make the program free from any vulnerability,
    the `unlink()` function is invoked to remove any links to the `file1.txt`. This
    will avoid overwriting of any sensitive file that might be linked with `file1.txt`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中看到定义了一个名为 `fp` 的文件指针。我们预计黑客或恶意用户可能已创建一个名为 `file1.txt` 的软链接到现有文件 `file2.txt`。`file2.txt`
    是一个敏感文件，我们不希望它被覆盖或破坏。为了使程序无任何漏洞，调用 `unlink()` 函数来删除对 `file1.txt` 的任何链接。这将避免覆盖可能与
    `file1.txt` 链接的任何敏感文件。
- en: Also, the `open` function is invoked to open the file instead of the traditional
    `fopen` function. The `open` function opens the `file1.txt` file in write-only
    mode with the `O_CREAT` and `O_EXCL` flags, which will fail the `open` function
    if the file already exists. This will ensure that no existing sensitive file will
    be overwritten accidentally in case it is linked to `file1.txt`. The `open` function
    will return a file descriptor for the opened file that will be assigned to the
    `ifp` variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用的是 `open` 函数来打开文件，而不是传统的 `fopen` 函数。`open` 函数以只写模式打开 `file1.txt` 文件，并带有
    `O_CREAT` 和 `O_EXCL` 标志，如果文件已存在，则 `open` 函数将失败。这将确保不会意外覆盖任何与 `file1.txt` 链接的现有敏感文件。`open`
    函数将返回一个打开文件的文件描述符，该描述符将被分配给 `ifp` 变量。
- en: To work with the file, we need a file stream. So the `fdopen` function is invoked
    to associate a file stream with the `ifp` file descriptor that is generated through
    the `open` function. The `fdopen` function returns a pointer to the file stream
    that is assigned to the file pointer, `fp`. In addition, the `w` mode is used
    in the `fdopen` function because although it opens the file in write mode, it
    will never cause truncation of the file. This makes the program much safer and
    avoids the accidental deletion of any file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要与文件一起工作，我们需要一个文件流。因此，调用 `fdopen` 函数将文件流与通过 `open` 函数生成的 `ifp` 文件描述符关联。`fdopen`
    函数返回一个指向文件流的指针，该指针被分配给文件指针 `fp`。此外，在 `fdopen` 函数中使用 `w` 模式，因为尽管它以写入模式打开文件，但它永远不会导致文件截断。这使得程序更加安全，避免了意外删除任何文件。
- en: Thereafter, the program is the same as the previous program. It asks the user
    to enter certain lines, which are then written in  `file1.txt`. Finally, the file
    pointed to by the file pointer, `fp`, is closed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，程序与之前的程序相同。它要求用户输入某些行，然后这些行被写入 `file1.txt`。最后，关闭由文件指针 `fp` 指向的文件。
- en: 'Let''s use GCC to compile the `filesolved.c` program, as shown in the following
    screenshot. If you get no errors or warnings, it means the `filesolved.c` program has
    compiled into an executable file: `filesolved.exe`. Let''s run this file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `filesolved.c` 程序，如下所示截图所示。如果你没有错误或警告，这意味着 `filesolved.c` 程序已编译成可执行文件：`filesolved.exe`。让我们运行这个文件：
- en: '![](img/78fb48b4-a144-4251-bc2c-a4f0a8456e13.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78fb48b4-a144-4251-bc2c-a4f0a8456e13.png)'
- en: Figure 18.9
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9
- en: 'We can verify whether the content entered while running the program has gone
    into `file1.txt` or not. To do so, we will open `file1.txt` to see its contents
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证在运行程序时输入的内容是否已进入 `file1.txt`。为此，我们将打开 `file1.txt` 来查看其内容如下：
- en: '![](img/93d61213-b17e-450f-86a0-e6ca54bc1c03.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93d61213-b17e-450f-86a0-e6ca54bc1c03.png)'
- en: Figure 18.10
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10
- en: We can see that the content entered by the user has gone into `file1.txt`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户输入的内容已进入 `file1.txt`。
- en: 'The contents of `file2.txt` are intact as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`file2.txt` 的内容如下所示：'
- en: '![](img/fb799e9d-66c3-4c79-88a3-854900d7458a.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb799e9d-66c3-4c79-88a3-854900d7458a.png)'
- en: Figure 18.11
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.11
