["```cpp\n      #include <iostream>\n      #include <vector>\n      #include <random>\n      #include <algorithm>\n      #include <execution>      \n\n      using namespace std;\n```", "```cpp\n      static bool odd(int n) { return n % 2; }\n```", "```cpp\n      int main()\n      {\n          vector<int> d (50000000);\n```", "```cpp\n          mt19937 gen;\n          uniform_int_distribution<int> dis(0, 100000);\n\n          auto rand_num ([=] () mutable { return dis(gen); });\n```", "```cpp\n          generate(execution::par, begin(d), end(d), rand_num);\n```", "```cpp\n          sort(execution::par, begin(d), end(d));\n```", "```cpp\n          reverse(execution::par, begin(d), end(d));\n```", "```cpp\n          auto odds (count_if(execution::par, begin(d), end(d), odd));\n```", "```cpp\n          cout << (100.0 * odds / d.size()) \n               << \"% of the numbers are odd.n\";\n      }\n```", "```cpp\n      $ ./auto_parallel\n      50.4% of the numbers are odd.\n```", "```cpp\ngenerate(execution::par, begin(d), end(d), rand_num);\nsort(    execution::par, begin(d), end(d));\nreverse( execution::par, begin(d), end(d));\n\nauto odds (count_if(execution::par, begin(d), end(d), odd));\n```", "```cpp\nstd::vector<int> v {1, 2, 3, 4, 5, 6, 7 /*...*/};\n\nint sum {std::accumulate(v.begin(), v.end(), 0)};\n```", "```cpp\nint sum {0};\nfor (size_t i {0}; i < v.size(); ++i) {\n    sum += v[i];\n}\n```", "```cpp\nint sum {0};\nfor (size_t i {0}; i < v.size() / 4; i += 4) {\n    sum += v[i] + v[i+1] + v[i + 2] + v[i + 3];\n}\n// if v.size() / 4 has a remainder, \n// real code has to deal with that also.\n```", "```cpp\n      #include <iostream>\n      #include <chrono>\n      #include <thread>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      int main()\n      {\n          cout << \"Going to sleep for 5 seconds\"\n                  \" and 300 milli seconds.n\";\n\n          this_thread::sleep_for(5s + 300ms);\n```", "```cpp\n          cout << \"Going to sleep for another 3 seconds.n\";\n\n          this_thread::sleep_until(\n              chrono::high_resolution_clock::now() + 3s);\n```", "```cpp\n          cout << \"That's it.n\";\n      }\n```", "```cpp\n      $ time ./sleep \n      Going to sleep for 5 seconds and 300 milli seconds.\n      Going to sleep for another 3 seconds.\n      That's it.\n\n      real 0m8.320s\n      user 0m0.005s\n      sys  0m0.003s\n```", "```cpp\n      #include <iostream>\n      #include <thread>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      static void thread_with_param(int i)\n      {\n          this_thread::sleep_for(1ms * i);\n\n          cout << \"Hello from thread \" << i << 'n';\n\n          this_thread::sleep_for(1s * i);\n\n          cout << \"Bye from thread \" << i << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          cout << thread::hardware_concurrency()\n               << \" concurrent threads are supported.n\";\n```", "```cpp\n          thread t1 {thread_with_param, 1};\n          thread t2 {thread_with_param, 2};\n          thread t3 {thread_with_param, 3};\n```", "```cpp\n          t1.join();\n          t2.join();\n```", "```cpp\n          t3.detach();\n```", "```cpp\n          cout << \"Threads joined.n\";\n      }\n```", "```cpp\n      $ ./threads \n      8 concurrent threads are supported.\n      Hello from thread 1\n      Hello from thread 2\n      Hello from thread 3\n      Bye from thread 1\n      Bye from thread 2\n      Threads joined.\n```", "```cpp\nvoid f(int i) { cout << i << 'n'; }\n\nint main()\n{\n    thread t {f, 123};\n    t.join();\n}\n```", "```cpp\n      #include <iostream>\n      #include <shared_mutex>\n      #include <thread>\n      #include <vector>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      shared_mutex shared_mut;\n```", "```cpp\n      using shrd_lck = shared_lock<shared_mutex>;\n      using uniq_lck = unique_lock<shared_mutex>;\n```", "```cpp\n      static void print_exclusive()\n      {\n          uniq_lck l {shared_mut, defer_lock};\n\n          if (l.try_lock()) {\n              cout << \"Got exclusive lock.n\";\n          } else {\n              cout << \"Unable to lock exclusively.n\";\n          }\n      }\n```", "```cpp\n      static void exclusive_throw()\n      {\n          uniq_lck l {shared_mut};\n          throw 123;\n      }\n```", "```cpp\n      int main()\n      {\n          {\n              shrd_lck sl1 {shared_mut};\n\n              cout << \"shared lock once.n\";\n```", "```cpp\n              {\n                  shrd_lck sl2 {shared_mut};\n\n                  cout << \"shared lock twice.n\";\n\n                  print_exclusive();\n              }\n```", "```cpp\n              cout << \"shared lock once again.n\";\n\n              print_exclusive();\n\n          }\n          cout << \"lock is free.n\";\n```", "```cpp\n          try {\n              exclusive_throw();\n          } catch (int e) {\n              cout << \"Got exception \" << e << 'n';\n          }\n\n          print_exclusive();\n      }\n```", "```cpp\n      $ ./shared_lock \n      shared lock once.\n      shared lock twice.\n      Unable to lock exclusively.\n      shared lock once again.\n      Unable to lock exclusively.\n      lock is free.\n      Got exception 123\n      Got exclusive lock.\n```", "```cpp\nvoid critical_function()\n{\n    lock_guard<mutex> l {some_mutex};\n\n    // critical section\n}\n```", "```cpp\nint main()\n{\n    {\n        shrd_lck sl1 {shared_mut};\n        {\n            shrd_lck sl2 {shared_mut};\n\n            print_exclusive();\n        }\n        print_exclusive();\n    }\n\n    try {\n        exclusive_throw();\n    } catch (int e) {\n        cout << \"Got exception \" << e << 'n';\n    }\n    print_exclusive();\n}\n```", "```cpp\nvoid print_exclusive()\n{\n    uniq_lck l {shared_mut, defer_lock};\n\n    if (l.try_lock()) {\n        // ...\n    }\n}\n```", "```cpp\n      #include <iostream>\n      #include <thread>\n      #include <mutex>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      mutex mut_a;\n      mutex mut_b;\n```", "```cpp\n      static void deadlock_func_1()\n      {\n          cout << \"bad f1 acquiring mutex A...\" << endl;\n          lock_guard<mutex> la {mut_a};\n\n          this_thread::sleep_for(100ms);\n\n          cout << \"bad f1 acquiring mutex B...\" << endl;\n          lock_guard<mutex> lb {mut_b};\n\n          cout << \"bad f1 got both mutexes.\" << endl;\n      }\n```", "```cpp\n      static void deadlock_func_2()\n      {\n          cout << \"bad f2 acquiring mutex B...\" << endl;\n          lock_guard<mutex> lb {mut_b};\n\n          this_thread::sleep_for(100ms);\n\n          cout << \"bad f2 acquiring mutex A...\" << endl;\n          lock_guard<mutex> la {mut_a};\n\n          cout << \"bad f2 got both mutexes.\" << endl;\n      }\n```", "```cpp\n      static void sane_func_1()\n      {\n          scoped_lock l {mut_a, mut_b};\n\n          cout << \"sane f1 got both mutexes.\" << endl;\n      }\n\n      static void sane_func_2()\n      {\n          scoped_lock l {mut_b, mut_a};\n\n          cout << \"sane f2 got both mutexes.\" << endl;\n      }\n```", "```cpp\n      int main()\n      {\n          {\n              thread t1 {sane_func_1};\n              thread t2 {sane_func_2};\n\n              t1.join();\n              t2.join();\n          }\n```", "```cpp\n          {\n              thread t1 {deadlock_func_1};\n              thread t2 {deadlock_func_2};\n\n              t1.join();\n              t2.join();\n          }\n      }\n```", "```cpp\n      $ ./avoid_deadlock \n      sane f1 got both mutexes\n      sane f2 got both mutexes\n      bad f2 acquiring mutex B...\n      bad f1 acquiring mutex A...\n      bad f1 acquiring mutex B...\n      bad f2 acquiring mutex A...\n```", "```cpp\n      #include <iostream>\n      #include <thread>\n      #include <mutex>\n      #include <sstream>\n      #include <vector>      \n\n      using namespace std;\n```", "```cpp\n      struct pcout : public stringstream {\n          static inline mutex cout_mutex;\n\n          ~pcout() {\n              lock_guard<mutex> l {cout_mutex};\n              cout << rdbuf();\n              cout.flush();\n          }\n      };\n```", "```cpp\n      static void print_cout(int id)\n      {\n          cout << \"cout hello from \" << id << 'n';\n      }\n\n      static void print_pcout(int id)\n      {\n           pcout{} << \"pcout hello from \" << id << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          vector<thread> v;\n\n          for (size_t i {0}; i < 10; ++i) {\n              v.emplace_back(print_cout, i);\n          }\n\n          for (auto &t : v) { t.join(); }\n```", "```cpp\n          cout << \"=====================n\";\n\n          v.clear();\n          for (size_t i {0}; i < 10; ++i) {\n              v.emplace_back(print_pcout, i);\n          }\n\n          for (auto &t : v) { t.join(); }\n      }\n```", "```cpp\nstringstream ss;\nss << \"This is some printed line \" << 123 << 'n';\n```", "```cpp\n{\n    lock_guard<mutex> l {cout_mutex};\n```", "```cpp\n    cout << ss.rdbuf();\n    cout.flush();\n}\n```", "```cpp\nstringstream{} << \"This is some printed line \" << 123 << 'n';\n```", "```cpp\nstruct pcout : public stringstream {\n    ~pcout() {\n        lock_guard<mutex> l {cout_mutex};\n        cout << rdbuf();\n        cout.flush();\n    }\n};\n```", "```cpp\n      #include <iostream>\n      #include <thread>\n      #include <mutex>\n      #include <vector>     \n\n      using namespace std;\n```", "```cpp\n      once_flag callflag;\n```", "```cpp\n      static void once_print()\n      {\n          cout << '!';\n      }\n```", "```cpp\n      static void print(size_t x)\n      {\n          std::call_once(callflag, once_print);\n          cout << x;\n      }\n```", "```cpp\n      int main()\n      {\n          vector<thread> v;\n\n          for (size_t i {0}; i < 10; ++i) {\n              v.emplace_back(print, i);\n          }\n\n          for (auto &t : v) { t.join(); }\n          cout << 'n';\n      }\n```", "```cpp\n      $ ./call_once\n      !1239406758\n```", "```cpp\nstd::thread t {my_function, arg1, arg2, ...};\n// do something else\nt.join(); // wait for thread to finish\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <map>\n      #include <string>\n      #include <algorithm>\n      #include <iterator>\n      #include <future>      \n\n      using namespace std;\n```", "```cpp\n      static map<char, size_t> histogram(const string &s)\n      {\n          map<char, size_t> m;\n\n          for (char c : s) { m[c] += 1; }\n\n          return m;\n      }\n```", "```cpp\n      static string sorted(string s)\n      {\n          sort(begin(s), end(s));\n          return s;\n      }\n```", "```cpp\n      static bool is_vowel(char c)\n      {\n          char vowels[] {\"aeiou\"};\n          return end(vowels) != \n                 find(begin(vowels), end(vowels), c);\n      }\n\n      static size_t vowels(const string &s)\n      {\n          return count_if(begin(s), end(s), is_vowel);\n      }\n```", "```cpp\n      int main()\n      {\n          cin.unsetf(ios::skipws);\n          string input {istream_iterator<char>{cin}, {}};\n          input.pop_back();\n```", "```cpp\n          auto hist        (async(launch::async, \n                                  histogram, input));\n          auto sorted_str  (async(launch::async, \n                                  sorted,    input));\n          auto vowel_count (async(launch::async, \n                                  vowels,    input));\n```", "```cpp\n          for (const auto &[c, count] : hist.get()) {\n              cout << c << \": \" << count << 'n';\n          }\n\n          cout << \"Sorted string: \" \n               << quoted(sorted_str.get()) << 'n'\n               << \"Total vowels: \"  \n               << vowel_count.get()        << 'n';\n      }\n```", "```cpp\n      $ echo \"foo bar baz foobazinga\" | ./async \n       : 3\n      a: 4\n      b: 3\n      f: 2\n      g: 1\n      i: 1\n      n: 1\n      o: 4\n      r: 1\n      z: 2\n      Sorted string: \"   aaaabbbffginoooorzz\"\n      Total vowels: 9\n```", "```cpp\nauto hist        (histogram(input));\nauto sorted_str  (sorted(   input));\nauto vowel_count (vowels(   input));\n\nfor (const auto &[c, count] : hist) {\n    cout << c << \": \" << count << 'n';\n}\ncout << \"Sorted string: \" << quoted(sorted_str) << 'n';\ncout << \"Total vowels: \"  << vowel_count        << 'n';\n```", "```cpp\nauto hist        (async(launch::async, histogram, input));\nauto sorted_str  (async(launch::async, sorted,    input));\nauto vowel_count (async(launch::async, vowels,    input));\n\nfor (const auto &[c, count] : hist.get()) {\n    cout << c << \": \" << count << 'n';\n}\ncout << \"Sorted string: \" \n     << quoted(sorted_str.get()) << 'n'\n     << \"Total vowels: \"  \n     << vowel_count.get()        << 'n';\n```", "```cpp\nauto x (f(1, 2, 3));\ncout << x;\n```", "```cpp\nauto x (async(launch::async, f, 1, 2, 3));\ncout << x.get();\n```", "```cpp\nasync(launch::async, f);\nasync(launch::async, g);\n```", "```cpp\n      #include <iostream>\n      #include <queue>\n      #include <tuple>\n      #include <condition_variable>\n      #include <thread>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      queue<size_t>      q;\n      mutex              mut;\n      condition_variable cv;\n      bool               finished {false};\n```", "```cpp\n      static void producer(size_t items) {\n          for (size_t i {0}; i < items; ++i) {\n              this_thread::sleep_for(100ms);\n              {\n                  lock_guard<mutex> lk {mut};\n                  q.push(i);\n              }\n              cv.notify_all();\n          }\n```", "```cpp\n          {\n              lock_guard<mutex> lk {mut};\n              finished = true;\n          }\n          cv.notify_all();\n      }\n```", "```cpp\n      static void consumer() {\n          while (!finished) {\n              unique_lock<mutex> l {mut};\n\n              cv.wait(l, [] { return !q.empty() || finished; });\n```", "```cpp\n              while (!q.empty()) {\n                  cout << \"Got \" << q.front() \n                       << \" from queue.n\";\n                  q.pop();\n              }\n          }\n      }\n```", "```cpp\n      int main() {\n          thread t1 {producer, 10};\n          thread t2 {consumer};\n          t1.join();\n          t2.join();\n          cout << \"finished!n\";\n      }\n```", "```cpp\n      $ ./producer_consumer\n      Got 0 from queue.\n      Got 1 from queue.\n      Got 2 from queue.\n      Got 3 from queue.\n      Got 4 from queue.\n      Got 5 from queue.\n      Got 6 from queue.\n      Got 7 from queue.\n      Got 8 from queue.\n      Got 9 from queue.\n      finished!\n```", "```cpp\nqueue<size_t>      q;\nmutex              mut;\ncondition_variable cv;\nbool               finished {false};\n```", "```cpp\nwhile (!finished) {\n    unique_lock<mutex> l {mut};\n\n cv.wait(l, [] { return !q.empty() || finished; });\n\n    while (!q.empty()) {\n        // consume\n    }\n}\n```", "```cpp\nwhile (!finished) {\n    unique_lock<mutex> l {mut};\n\n while (q.empty() && !finished) {\n l.unlock();\n l.lock();\n }\n\n    while (!q.empty()) {\n        // consume\n    }\n}\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <sstream>\n      #include <vector>\n      #include <queue>\n      #include <thread>\n      #include <mutex>\n      #include <condition_variable>\n      #include <chrono>     \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      struct pcout : public stringstream {\n          static inline mutex cout_mutex;\n          ~pcout() {\n              lock_guard<mutex> l {cout_mutex};\n              cout << rdbuf();\n          }\n      };\n```", "```cpp\n      queue<size_t> q;\n      mutex         q_mutex; \n      bool          production_stopped {false};\n```", "```cpp\n      condition_variable go_produce;\n      condition_variable go_consume;\n```", "```cpp\n      static void producer(size_t id, size_t items, size_t stock)\n      {\n          for (size_t i = 0; i < items; ++i) {\n              unique_lock<mutex> lock(q_mutex);\n              go_produce.wait(lock, \n                  [&] { return q.size() < stock; });\n```", "```cpp\n              q.push(id * 100 + i);\n\n              pcout{} << \"   Producer \" << id << \" --> item \"\n                      << setw(3) << q.back() << 'n';\n```", "```cpp\n              go_consume.notify_all();\n              this_thread::sleep_for(90ms);\n           }\n\n           pcout{} << \"EXIT: Producer \" << id << 'n';\n      }\n```", "```cpp\n      static void consumer(size_t id)\n      {\n           while (!production_stopped || !q.empty()) {\n               unique_lock<mutex> lock(q_mutex);\n```", "```cpp\n               if (go_consume.wait_for(lock, 1s, \n                       [] { return !q.empty(); })) {\n                   pcout{} << \"                  item \"\n                           << setw(3) << q.front() \n                           << \" --> Consumer \"\n                           << id << 'n';\n                   q.pop();\n```", "```cpp\n                  go_produce.notify_all();\n                  this_thread::sleep_for(130ms);\n              }\n          }\n\n          pcout{} << \"EXIT: Producer \" << id << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          vector<thread> workers;\n          vector<thread> consumers;\n```", "```cpp\n          for (size_t i = 0; i < 3; ++i) {\n              workers.emplace_back(producer, i, 15, 5);\n          }\n\n          for (size_t i = 0; i < 5; ++i) {\n              consumers.emplace_back(consumer, i);\n          }\n```", "```cpp\n          for (auto &t : workers)   { t.join(); }\n          production_stopped = true;\n          for (auto &t : consumers) { t.join(); }\n      }\n```", "```cpp\n      $ ./multi_producer_consumer\n         Producer 0 --> item   0\n         Producer 1 --> item 100\n                        item   0 --> Consumer 0\n         Producer 2 --> item 200\n                        item 100 --> Consumer 1\n                        item 200 --> Consumer 2\n         Producer 0 --> item   1\n         Producer 1 --> item 101\n                        item   1 --> Consumer 0\n      ...\n         Producer 0 --> item  14\n      EXIT: Producer 0\n         Producer 1 --> item 114\n      EXIT: Producer 1\n                        item  14 --> Consumer 0\n         Producer 2 --> item 214\n      EXIT: Producer 2\n                        item 114 --> Consumer 1\n                        item 214 --> Consumer 2\n      EXIT: Consumer 2\n      EXIT: Consumer 3\n      EXIT: Consumer 4\n      EXIT: Consumer 0\n      EXIT: Consumer 1\n```", "```cpp\nif (go_consume.wait_for(lock, 1s, [] { return !q.empty(); })) {\n    // got the event without timeout\n}\n```", "```cpp\ngo_produce.wait(lock, [&] { return q.size() < stock; });\n```", "```cpp\n      #include <iostream>\n      #include <algorithm>\n      #include <iterator>\n      #include <complex>\n      #include <numeric>\n      #include <vector>\n #include <future>      \n\n      using namespace std;\n```", "```cpp\n      using cmplx = complex<double>;\n\n      static auto scaler(int min_from, int max_from,\n                         double min_to, double max_to)\n      {\n          const int w_from {max_from - min_from};\n          const double w_to {max_to - min_to};\n          const int mid_from {(max_from - min_from) / 2 + min_from};\n          const double mid_to {(max_to - min_to) / 2.0 + min_to};\n\n          return [=] (int from) {\n              return double(from - mid_from) / w_from * w_to + mid_to;\n          };\n      }\n\n      template <typename A, typename B>\n      static auto scaled_cmplx(A scaler_x, B scaler_y)\n      {\n          return [=](int x, int y) {\n              return cmplx{scaler_x(x), scaler_y(y)};\n          };\n      }\n```", "```cpp\n      static auto mandelbrot_iterations(cmplx c)\n      {\n          cmplx z {};\n          size_t iterations {0};\n          const size_t max_iterations {100000};\n          while (abs(z) < 2 && iterations < max_iterations) {\n              ++iterations;\n              z = pow(z, 2) + c;\n          }\n          return iterations;\n      }\n```", "```cpp\n      int main()\n      {\n          const size_t w {100};\n          const size_t h {40};\n\n          auto scale (scaled_cmplx(\n              scaler(0, w, -2.0, 1.0),\n              scaler(0, h, -1.0, 1.0)\n          ));\n\n          auto i_to_xy ([=](int x) { \n              return scale(x % w, x / w); \n          });\n```", "```cpp\n          auto to_iteration_count ([=](int x) {\n              return async(launch::async,\n mandelbrot_iterations, i_to_xy(x));\n          });\n```", "```cpp\n          vector<int> v (w * h);\n vector<future<size_t>> r (w * h);\n          iota(begin(v), end(v), 0);\n          transform(begin(v), end(v), begin(r), \n                    to_iteration_count);\n```", "```cpp\n          auto binfunc ([w, n{0}] (auto output_it, future<size_t> &x) \n                  mutable {\n              *++output_it = (x.get() > 50 ? '*' : ' ');\n              if (++n % w == 0) { ++output_it = 'n'; }\n              return output_it;\n          });\n\n          accumulate(begin(r), end(r), \n                     ostream_iterator<char>{cout}, binfunc);\n      }\n```", "```cpp\ntransform(begin(v), end(v), begin(r), to_iteration_count);\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <thread>\n      #include <string>\n      #include <sstream>\n      #include <future>      \n\n      using namespace std;\n      using namespace chrono_literals;\n```", "```cpp\n      struct pcout : public stringstream {\n          static inline mutex cout_mutex;\n\n          ~pcout() {\n              lock_guard<mutex> l {cout_mutex};\n              cout << rdbuf();\n              cout.flush();\n          }\n      };\n```", "```cpp\n      static string create(const char *s)\n      {\n          pcout{} << \"3s CREATE \" << quoted(s) << 'n';\n          this_thread::sleep_for(3s);\n          return {s};\n      }\n```", "```cpp\n      static string concat(const string &a, const string &b)\n      {\n          pcout{} << \"5s CONCAT \"\n                  << quoted(a) << \" \"\n                  << quoted(b) << 'n';\n          this_thread::sleep_for(5s);\n          return a + b;\n      }\n```", "```cpp\n      static string twice(const string &s)\n      {\n          pcout{} << \"3s TWICE \" << quoted(s) << 'n';\n          this_thread::sleep_for(3s);\n          return s + s;\n      }\n```", "```cpp\n      template <typename F>\n      static auto asynchronize(F f)\n      {\n          return [f](auto ... xs) {\n              return [=] () {\n                  return async(launch::async, f, xs...);\n              };\n          };\n      }\n```", "```cpp\n      template <typename F>\n      static auto fut_unwrap(F f)\n      {\n          return [f](auto ... xs) {\n              return f(xs.get()...);\n          };\n      }\n```", "```cpp\n      template <typename F>\n      static auto async_adapter(F f)\n      {\n          return [f](auto ... xs) {\n              return [=] () {\n                  return async(launch::async, \n                               fut_unwrap(f), xs()...);\n              };\n          };\n      }\n```", "```cpp\n      int main()\n      {\n          auto pcreate (asynchronize(create));\n          auto pconcat (async_adapter(concat));\n          auto ptwice  (async_adapter(twice));\n```", "```cpp\n          auto result (\n              pconcat(\n                  ptwice(\n                      pconcat(\n                          pcreate(\"foo \"),\n                          pcreate(\"bar \"))),\n                  pconcat(\n                      pcreate(\"this \"),\n                      pcreate(\"that \"))));\n\n          cout << \"Setup done. Nothing executed yet.n\";\n\n          cout << result().get() << 'n';\n      }\n```", "```cpp\n      $ ./chains \n      Setup done. Nothing executed yet.\n      3s CREATE \"foo \"\n      3s CREATE \"bar \"\n      3s CREATE \"this \"\n      3s CREATE \"that \"\n      5s CONCAT \"this \" \"that \"\n      5s CONCAT \"foo \" \"bar \"\n      3s TWICE  \"foo bar \"\n      5s CONCAT \"foo bar foo bar \" \"this that \"\n      foo bar foo bar this that\n```", "```cpp\nint main()\n{\n    string result {\n        concat(\n            twice(\n                concat(\n                    create(\"foo \"),\n                    create(\"bar \"))),\n            concat(\n                create(\"this \"),\n                create(\"that \"))) };\n\n    cout << result << 'n';\n}\n```", "```cpp\nstring result {concat( ... )};\ncout << result << 'n';\n```", "```cpp\nauto result (pconcat( ... ));\ncout << result().get() << 'n';\n```", "```cpp\nauto a (async(launch::async, create, \"foo \"));\nauto b (async(launch::async, create, \"bar \"));\nauto c (async(launch::async, create, \"this \"));\nauto d (async(launch::async, create, \"that \"));\nauto e (async(launch::async, concat, a.get(), b.get()));\nauto f (async(launch::async, concat, c.get(), d.get()));\nauto g (async(launch::async, twice, e.get()));\nauto h (async(launch::async, concat, g.get(), f.get()));\n```", "```cpp\ntemplate <typename F>\nstatic auto asynchronize(F f)\n{\n    return [f](auto ... xs) {\n        return [=] () {\n            return async(launch::async, f, xs...);\n        };\n    };\n}\n```", "```cpp\nauto f2 ( asynchronize(f) );\nauto f3 ( f2(1, 2) );\nauto f4 ( f3() );\nint result { f4.get() };\n```", "```cpp\ntemplate <typename F>\nstatic auto async_adapter(F f)\n{\n    return [f](auto ... xs) {\n        return [=] () {\n            return async(launch::async, fut_unwrap(f), xs()...);\n        };\n    };\n}\n```", "```cpp\ntemplate <typename F>\nstatic auto fut_unwrap(F f)\n{\n    return [f](auto ... xs) {\n        return f(xs.get()...);\n    };\n}\n```"]