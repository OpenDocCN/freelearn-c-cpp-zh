["```cpp\nclass IGUIElement\n{\npublic:\nvirtual void Update() = 0;\nglm::vec2 GetPosition() { return m_position; };\nprotected:\nglm::vec2 m_position;\n};\n}\n```", "```cpp\n...\nstatic enum class GUIAnchorPos {\nTopRight,\nTopLeft,\nBottomRight,\nBottomLeft,\nCenter\n};\n...\n```", "```cpp\n...\nIGUIPanel(glm::vec4 panelBounds = glm::vec4(0,0,200,480),\nglm::vec2 panelAnchor = glm::vec2(0,0),\nglm::vec2 offset = glm::vec2(0,0));\n...\n```", "```cpp\nIGUIPanel::IGUIPanel(glm::vec4 panelBounds, glm::vec2 panelAnchor, glm::vec2 offset) : m_bounds(panelBounds), m_offset(offset)\n{\n  m_Pos = panelAnchor + m_offset;\n  m_panelWidth = m_bounds.z;\n  m_panelHeight = m_bounds.w;\n}\n```", "```cpp\n...\n  void IGUIPanel::AddGUIElement(IGUIElement & GUIElement)\n  {\n     m_GUIElement.List.push_back(&GUIElement);\n  }\n...\n```", "```cpp\nvirtual std::vector<IGUIElements*>& GetGUIElementList() \n{ \n   return m_ GetGUIElementList; \n};\n```", "```cpp\nvoid IGUIPanel::Update()\n{\n  for (auto const& element : m_ m_GUIElement.List)\n  {\n     element ->Update();\n  }\n}\n```", "```cpp\nIGUIPanel::~IGUIPanel()\n{\n  std::for_each(m_GUIElementList.begin(),\n  m_ GUIElementList.end(),\n  std::default_delete<IGUIElement>());\n}\n```", "```cpp\n...\nclass IGUIButton : public IGUIElement\n{\n public:\n IGUIButton(glm::vec4& bounds,\n glm::vec2& position,\n GLTexture* texture,\n std::string label,\n SpriteFont* font,\n glm::vec2& fontScale = glm::vec2(1.0f),\n IGUIPanel* panel = NULL);\n ~IGUIButton();\n virtual void Update() override;\n...\n```", "```cpp\n\nm_texture(*texture),\nm_buttonLabel(label),\nm_spriteFont(font),\nm_fontScale(fontScale),\nm_panel(panel)\n{\n   m_bounds = bounds;\n   if (m_panel != NULL)\n   {\n   m_position = *m_panel->GetPosition() + position;\n```", "```cpp\n//Move to just below the last element in the list\nif (!m_panel->GetGUIElementList().empty())\n{\n  IGUIElement* lastElement = m_panel-> GetGUIElementList().back();\n  m_position.y = lastElement ->GetPosition().y -\n  lastElement ->GetBounds().w -\n  10.0f; // Used as default padding (should be dynamic)\n}\nelse\n{\n   //Move to top of panel\n   m_position.y += m_panel->GetBounds()->w - m_bounds.w;\n   }\n  }\n}\n```", "```cpp\nIGUI::IGUI(Window& window) : m_window(window)\n{\n...\nm_BL = new glm::vec2( \n                      0,\n                      0\n                      );\nm_BR = new glm::vec2( \n                      m_window.GetScreenWidth(),\n                      0\n                      );\nm_TL = new glm::vec2( \n                      0,\n                      m_window.GetScreenHeight()\n                      );\nm_TR = new glm::vec2( \n                      m_window.GetScreenWidth(),                     \n                      m_window.GetScreenHeight()\n                     );\nm_C = new glm::vec2( \n                     m_window.GetScreenWidth() * 0.5f,                 \n                     m_window.GetScreenHeight() * 0.5f\n                     );\n ...\n```", "```cpp\nvoid IGUI::AddGUIElement(IGUIElement& GUIElement)\n{\n   if (!m_GUIPanelsList.empty())\n  {\n   m_GUIPanelsList[0]->AddGUIObject(GUIElement);\n   }\n   else\n   {\n   IGUIPanel* panel = new IGUIPanel();\n   m_GUIPanelsList.push_back(panel);\n   m_GUIPanelsList[0]->AddGUIObject(GUIElement);\n   }\n}\n```", "```cpp\nvoid IGUI::AddGUIPanel(IGUIPanel& GUIPanel)\n{\n  m_GUIPanelsList.push_back(&GUIPanel);\n}\n```", "```cpp\n...\nglm::vec2* IGUI::GetAnchorPos(GUIAnchorPos anchorPos, glm::vec4 bounds)\n{\n  switch (anchorPos)\n  {\n    case(GUIAnchorPos::TopRight):\n    m_TR->y -= bounds.w;\n    m_TR->x -= bounds.z;\n    return m_TR;\n    break;\n    case(GUIAnchorPos::TopLeft):\n    m_TL->y -= bounds.w;\n    return m_TL;\n    break;\n    case(GUIAnchorPos::BottomRight):\n    m_BR->x -= bounds.z;\n    return m_BR;\n    break;\n    case(GUIAnchorPos::BottomLeft):\n    return m_BL;\n    break;\n    case(GUIAnchorPos::Center):\n    m_C->y -= bounds.w;\n    return m_C;\n    break;\n  }\n}\n...\n```", "```cpp\nSDL_Event event;\nwhile (SDL_PollEvent(&event))\n{\n  m_game->OnSDLEvent(event);\n}\n```", "```cpp\nenum class GUIEvent\n{\n HoverOver,\n Released,\n Clicked,\n};\n```", "```cpp\nvirtual void OnNotify(IGUIElement& element, GUIEvent event) = 0;\n```", "```cpp\nvoid IGUIButton::OnNotify(IGUIElement & button, GUIEvent event)\n{\n   If(event == GUIEvent::HoverOver)\n  {\n   //Handle Hover\n  }\n}\n```", "```cpp\nvoid IGUI::CheckInput(InputManager inputManager)\n{\n   float pointX = inputManager.GetMouseCoords().x;\n   float pointY = inputManager.GetMouseCoords().y;\n   for (auto &panel : m_GUIPanelsList) // access by reference to avoid                  \n                                          copying\n   {\n    for (auto& object : panel->GetGUIElementList())\n    {\n    //Convert Y coordinate position to top upper left origin, y-down\n     float convertedY =\n     m_window.GetScreenHeight() -\n     (object->GetPosition().y + object->GetBounds().w);\n     if (pointX < object->GetPosition().x + (object->GetBounds().z) &&\n     pointX >(object->GetPosition().x - (object->GetBounds().z)) &&\n     pointY < convertedY + object->GetBounds().w &&\n     pointY > convertedY - object->GetBounds().w)\n    {\n      object->OnNotify(*object, GUIEvent::HoverOver); \n      }\n    }\n  }\n}\n```", "```cpp\nvoid IGUI::CheckInput(InputManager inputManager)\n{\nfloat pointX = inputManager.GetMouseCoords().x;\nfloat pointY = inputManager.GetMouseCoords().y;\n```", "```cpp\nfor (auto &panel : m_GUIPanelsList) // access by reference to avoid copying\n{\nfor (auto& object : panel->GetGUIElementList())\n{\n```", "```cpp\nfloat convertedY = m_window.GetScreenHeight() -\n                  (object->GetPosition().y + object->GetBounds().w);\n```", "```cpp\nif (pointX <element->GetPosition().x + (element->GetBounds().z) &&\npointX >(element->GetPosition().x - (element->GetBounds().z)) &&\npointY < convertedY + element->GetBounds().w &&\npointY > convertedY - element->GetBounds().w)\n{\n   object->OnNotify(*object, GUIEvent::HoverOver);\n}\n...\n```", "```cpp\nvoid ExampleScreen::CheckInput(float deltaTime)\n{\n   SDL_Event event;\n   while (SDL_PollEvent(&event))\n   {\n   m_game->OnSDLEvent(event);\n   }\n   ...\n   m_gui->CheckInput(m_game->GetInputManager());\n   ...\n}\n```", "```cpp\nstd::unique_ptr<Camera2D> m_camera = nullptr; \n\n        std::unique_ptr<ShaderManager> m_textureProgram = nullptr; \n        std::unique_ptr<SpriteBatch> m_spriteBatch = nullptr; \n\n```", "```cpp\nIGUI::IGUI(Window& window) : m_window(window)\n{\n   m_camera = std::make_unique<Camera2D>();\n   ...\n   m_textureProgram = std::make_unique<BookEngine::ShaderManager>();\n   m_spriteBatch = std::make_unique<BookEngine::SpriteBatch>();\n}\n```", "```cpp\nvoid ExampleGUI::OnInit()\n{\nm_textureProgram->CompileShaders(\n                        \"Shaders/textureShading.vert\",\n                        \"Shaders/textureShading.frag\");\nm_textureProgram->AddAttribute(\"vertexPosition\");\nm_textureProgram->AddAttribute(\"vertexColor\");\nm_textureProgram->AddAttribute(\"vertexUV\");\nm_textureProgram->LinkShaders();\nm_spriteBatch->Init();\nm_camera->Init(m_window.GetScreenWidth(), \n               m_window.GetScreenHeight());\nm_camera->SetPosition(glm::vec2(\n                                m_window.GetScreenWidth() * 0.5f, \n                                m_window.GetScreenHeight()* 0.5f));\npanel = new BookEngine::IGUIPanel(\n                                glm::vec4(0, 0, 150, 500),\n                                *GetAnchorPos(\n                                   BookEngine::GUIAnchorPos:BottomLeft,\n                                    glm::vec4(0, 0, 150, 500)\n                                  ),\n                                  glm::vec2(0,0));\nAddGUIPanel(*panel);\n\n      BookEngine::GLTexture texture\n    =BookEngine::ResourceManager::GetTexture(\"Textures/button.png\");\n\nbutton = new BookEngine::IGUIButton(\n    glm::vec4(0, 0, 100, 50),\n    glm::vec2(10, -10),\"My Button\", &texture,\n    new BookEngine::SpriteFont(\"Fonts/Impact_Regular.ttf\", 72),\n       glm::vec2(0.2f), panel);\n\n       AddGUIElement (*button);\n}\n```", "```cpp\nm_textureProgram->CompileShaders(\n\"Shaders/textureShading.vert\",\n\"Shaders/textureShading.frag\");\nm_textureProgram->AddAttribute(\"vertexPosition\");\nm_textureProgram->AddAttribute(\"vertexColor\");\nm_textureProgram->AddAttribute(\"vertexUV\");\nm_textureProgram->LinkShaders();\nNext, we call Init on the sprite batch for the GUI instance:\nm_spriteBatch->Init();\n```", "```cpp\nm_camera->Init(m_window.GetScreenWidth(), \n               m_window.GetScreenHeight());\nm_camera->SetPosition(glm::vec2(\n                       m_window.GetScreenWidth() * 0.5f,\n                       m_window.GetScreenHeight()* 0.5f));\n```", "```cpp\npanel = new BookEngine::IGUIPanel(glm::vec4(0, 0, 150, 500),\n                                 *GetAnchorPos(\n                                 BookEngine::GUIAnchorPos:BottomLeft,                                  \n                                 glm::vec4(0, 0, 150, 500)\n                                 ),\n  glm::vec2(0,0));\n  AddGUIPanel(*panel);\n```", "```cpp\nBookEngine::GLTexture texture = BookEngine::ResourceManager::GetTexture(\"Textures/button.png\");\nbutton = new BookEngine::IGUIButton(\n           glm::vec4(0, 0, 100, 50),\n           glm::vec2(10, -10),\n           \"My Button\",\n           &texture,\n           new BookEngine::SpriteFont(\"Fonts/Impact_Regular.ttf\", 72),\nglm::vec2(0.2f), panel);\nAddGUIElement (*button);\n```", "```cpp\nvoid ExampleGUI::Draw() \n{ \n\n    ... \n\n    m_textureProgram->Use(); \n\n    ... \n\n    m_spriteBatch->Begin(); \n\n    //Draw all of the panels \n    for (auto const&panel : m_GUIPanelsList) \n    { \n        panel->Draw(*m_spriteBatch); \n    } \n\n    m_spriteBatch->End(); \n    m_spriteBatch->BatchRender(); \n    m_textureProgram->UnUse(); \n\n} \n```", "```cpp\nvoid IGUIPanel::Draw(SpriteBatch& spriteBatch) \n    { \nspriteBatch.Draw(glm::vec4(m_Pos.x,  \nm_Pos.y, \nm_panelWidth,  \nm_panelHeight), \n glm::vec4(0,0,1,1), \nBookEngine::ResourceManager::GetTexture( \n\"Textures/background.png\").id,  \n-0.1f,  \nColorRGBA8(0,0,0,75) \n); \n\n        for (auto const&element : m_GUIElementList) \n        { \n            element->Draw(spriteBatch); \n        } \n    } \n```", "```cpp\nvirtual void Draw(SpriteBatch& spriteBatch) = 0;\n```", "```cpp\nvoid IGUIButton::Draw(SpriteBatch& spriteBatch)   { \n        ... \n\n        spriteBatch.Draw(glm::vec4(m_position.x, \n m_position.y,  \nm_bounds.z,  \nm_bounds.w),  \nuvRect,  \nm_texture.id,  \n0.0f,  \nColorRGBA8(255, 255, 255, 255)); \n\n        char buffer[256]; \n        m_spriteFont->Draw(spriteBatch,  \nbuffer,  \nglm::vec2( \nm_position.x + (m_bounds.z * 0.5f),  \n(m_position.y + (m_bounds.w * 0.5f)) - ((m_spriteFont->GetFontHeight() * m_fontScale.y) * 0.5f) \n), \n                            m_fontScale,  \n0.2f,  \nBookEngine::ColorRGBA8(255, 255, 255, 255), \nJustification::MIDDLE);         \n    } \n\n```", "```cpp\nvoid EditorScreen::Draw()\n{ \n... \n    m_gui->Draw(); \n} \n\n```", "```cpp\n panel = new BookEngine::IGUIPanel(glm::vec4(0, 0, 150, 500), \n*GetAnchorPos( \nBookEngine::GUIAnchorPos::BottomRight, \nglm::vec4(0, 0, 150, 500) \n), \n glm::vec2(0,0)); \n```"]