- en: Introduction to Building C++ Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C++应用程序的简介
- en: Programming languages differ by their program execution model; the most common
    are interpreted and compiled languages. Compilers translate source code into machine
    code, which a computer can run without intermediary support systems. Interpreted
    language code, on the other hand, requires support systems, interpreters, and
    the virtual environment to work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言通过其程序执行模型而有所不同；最常见的是解释型语言和编译型语言。编译器将源代码转换为机器代码，计算机可以在没有中介支持系统的情况下运行。另一方面，解释型语言代码需要支持系统、解释器和虚拟环境才能工作。
- en: C++ is a compiled language, which makes programs run faster than their interpreted
    counterparts. While C++ programs should be compiled for each platform, interpreted
    programs can operate cross-platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种编译型语言，使得程序运行速度比解释型语言更快。虽然C++程序应该为每个平台进行编译，但解释型程序可以跨平台操作。
- en: We are going to discuss the details of a program-building process, starting
    with the phases of processing the source code – done by the compiler- and ending
    with the details of the executable file (the compiler's output). We will also
    learn why a program built for one platform won't run on another one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论程序构建过程的细节，从编译器处理源代码的阶段开始，到可执行文件的细节（编译器的输出）结束。我们还将了解为什么为一个平台构建的程序在另一个平台上无法运行。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to C++20
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20简介
- en: Details of the C++ preprocessor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++预处理器的细节
- en: Under the hood of the source code compilation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码编译的底层细节
- en: Understanding the linker and its functionality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解链接器及其功能
- en: The process of loading and running an executable file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件的加载和运行过程
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the option `-std=c++2a` is used to compile the examples
    throughout the chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选项`-std=c++2a`的g++编译器用于编译本章中的示例。您可以在本章中找到使用的源文件[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Introduction to C++20
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++20简介
- en: C++ has evolved over the years and now it has a brand-new version, C++20\. Since
    C++11, the C++ standard has grown the language feature set tremendously. Let's
    look at notable features in the new C++20 standard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++经过多年的发展，现在有了全新的版本，C++20。自C++11以来，C++标准大大扩展了语言特性集。让我们来看看新的C++20标准中的显著特性。
- en: Concepts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: 'Concepts are a major feature in C++20 that provides a set of requirements for
    types. The basic idea behind concepts is the compile-time validation of template
    arguments. For example, to specify that the template argument must have a default
    constructor, we use the `default_constructible` concept in the following way:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是C++20中的一个重要特性，它为类型提供了一组要求。概念背后的基本思想是对模板参数进行编译时验证。例如，要指定模板参数必须具有默认构造函数，我们可以如下使用`default_constructible`概念：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we missed the `typename` keyword. Instead, we set a concept
    that describes the `T` parameter of the `template` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们错过了`typename`关键字。相反，我们设置了描述`template`函数的`T`参数的概念。
- en: We can say that concepts are types that describe other types – meta-types, so
    to speak. They allow the compile-time validation of template parameters along
    with a function invocation based on type properties. We will discuss concepts
    in detail in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details
    of Object-Oriented Programming*, and [Chapter 4](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml),
    *Understanding and Designing Templates*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说概念是描述其他类型的类型 - 元类型，可以这么说。它们允许在类型属性的基础上对模板参数进行编译时验证以及函数调用。我们将在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)和[第4章](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml)中详细讨论概念，*面向对象编程的细节*和*理解和设计模板*。
- en: Coroutines
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: 'Coroutines are special functions able to stop at any defined point of execution
    and resume later. Coroutines extend the language with the following new keywords:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是特殊的函数，能够在任何定义的执行点停止并稍后恢复。协程通过以下新关键字扩展了语言：
- en: '`co_await` suspends the execution of the coroutine.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await` 暂停协程的执行。'
- en: '`co_yield` suspends the execution of the coroutine while also returning a value.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_yield` 暂停协程的执行，同时返回一个值。'
- en: '`co_return` is similar to the regular `return` keyword; it finishes the coroutine
    and returns a value. Take a look at the following classic example:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_return` 类似于常规的`return`关键字；它结束协程并返回一个值。看看以下经典示例：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A coroutine is associated with a `promise` object. The `promise` object stores
    and alerts the *state* of the coroutine. We will dive deeper into coroutines in
    [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml), *Concurrency and Multithreading*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 协程与`promise`对象相关联。`promise`对象存储和警报协程的*状态*。我们将在[第8章](fc8fb840-e179-4725-9e44-403b63be460d.xhtml)中深入讨论协程，*并发和多线程*。
- en: Ranges
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'The `ranges` library provides a new way of working with ranges of elements.
    To use them, you should include the `<ranges>` header file. Let''s look at `ranges`
    with an example. A range is a sequence of elements having a beginning and an end.
    It provides a `begin` iterator and an `end` sentinel. Consider the following vector
    of integers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges`库提供了一种新的处理元素范围的方式。要使用它们，您应该包含`<ranges>`头文件。让我们通过一个例子来看`ranges`。范围是具有开始和结束的元素序列。它提供了一个`begin`迭代器和一个`end`哨兵。考虑以下整数向量：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ranges accompanied by range adapters (the `|` operator) provide powerful functionality
    to deal with a range of elements. For example, examine the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 范围和范围适配器（`|`运算符）提供了处理一系列元素的强大功能。例如，查看以下代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we filtered the range for even integers using `ranges::view::filter()`.
    Pay attention to the range adapter `|` applied to the elements vector. We will
    discuss ranges and their powerful features in [Chapter 7](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml), *Functional
    Programming*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`ranges::view::filter()`过滤了偶数整数的范围。注意应用于元素向量的范围适配器`|`。我们将在[第7章](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml)中讨论范围及其强大的功能，*函数式编程*。
- en: More C++20 features
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的C++20功能
- en: C++20 is a new big release of the C++ language. It contains many features that
    make the language more complex and flexible. **Concepts**, **ranges**, and **coroutines**
    are some of the many features that will be discussed throughout the book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++20是C++语言的一个新的重大发布。它包含许多使语言更复杂和灵活的功能。**概念**、**范围**和**协程**是本书中将讨论的许多功能之一。
- en: One of the most anticipated features is **modules**, which provide the ability
    to declare modules and export types and values within those modules. You can consider
    modules an improved version of header files with the now redundant include-guards. We'll
    cover C++20 modules in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最受期待的功能之一是**模块**，它提供了在模块内声明模块并导出类型和值的能力。您可以将模块视为带有现在多余的包含保护的头文件的改进版本。我们将在本章中介绍C++20模块。
- en: 'Besides notable features added in C++20, there is a list of other features
    that we will discuss throughout the book:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C++20中添加的显着功能之外，还有一系列其他功能，我们将在整本书中讨论：
- en: 'The spaceship operator: `operator<=>()`. The verbosity of operator overloading
    can now be controlled by leveraging `operator<=>()`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太空船操作符：`operator<=>()`。现在可以通过利用`operator<=>()`来控制运算符重载的冗长。
- en: '`constexpr` conquers more and more space in the language. C++20 now has the `consteval`
    function, `constexpr std::vector` and `std::string`, and many more.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr`在语言中占据越来越多的空间。C++20现在有了`consteval`函数，`constexpr std::vector`和`std::string`，以及许多其他功能。'
- en: Math constants, such as `std::number::pi` and `std::number::log2e`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学常数，例如`std::number::pi`和`std::number::log2e`。
- en: Major updates to the Thread library, including stop tokens and joining threads.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程库的重大更新，包括停止令牌和加入线程。
- en: The iterator concepts.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器概念。
- en: Move-only views and other features.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动视图和其他功能。
- en: To better understand some new features and also dive into the essence of the
    language, we will introduce the language's core starting from previous versions.
    This will help us to find better uses for new features compared to older ones,
    and will also help in supporting legacy C++ code. Let's now start by gaining an
    understanding of the C++ application building-process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解一些新功能，并深入了解语言的本质，我们将从以前的版本开始介绍语言的核心。这将帮助我们找到比旧版本更好的新功能的用途，并且还将有助于支持旧版C++代码。现在让我们开始了解C++应用程序的构建过程。
- en: Building and running programs
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行程序
- en: You can use any text editor to write code, because, ultimately, code is just
    text. To write code, you are free to choose between simple text editors such as
    *Vim*, or an advanced **integrated development environment** (**IDE**) such as
    *MS Visual Studio*. The only difference between a love letter and source code
    is that the latter might be interpreted by a special program called a **compiler**
    (while the love letter cannot be compiled into a program, it might give you butterflies
    in your stomach).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何文本编辑器来编写代码，因为最终，代码只是文本。要编写代码，您可以自由选择简单的文本编辑器，如*Vim*，或者高级的**集成开发环境**（**IDE**），如*MS
    Visual Studio*。情书和源代码之间唯一的区别是后者可能会被称为**编译器**的特殊程序解释（而情书无法编译成程序，它可能会让您心跳加速）。
- en: To mark the difference between a plain text file and source code, a special
    file extension is used. C++ operates with the `.cpp` and `.h` extensions (you
    may also occasionally encounter `.cxx` and `.hpp` as well). Before getting into
    the details, think of the compiler as a tool that translates the source code into
    a runnable program, known as an executable file or just an **executable**. The
    process of making an executable from the source code is called **compilation**.
    Compiling a C++ program is a sequence of complex tasks that results in machine
    code generation. **Machine code** is the native language of the computer— that's
    why it's called machine code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分纯文本文件和源代码，使用了特殊的文件扩展名。C++使用`.cpp`和`.h`扩展名（您可能偶尔也会遇到`.cxx`和`.hpp`）。在深入细节之前，将编译器视为将源代码转换为可运行程序（称为可执行文件或**可执行文件**）的工具。从源代码生成可执行文件的过程称为**编译**。编译C++程序是一系列复杂任务的序列，最终产生机器代码。**机器代码**是计算机的本机语言，这就是为什么它被称为机器代码。
- en: Typically, a C++ compiler parses and analyzes the source code, then generates
    intermediate code, optimizes it, and finally, generates machine code in a file
    called an **object file**. You may have already encountered object files; they
    have individual extensions – `.o` in Linux and `.obj` in Windows. The created
    object file contains more than just machine code that can be run by the computer.
    Compilation usually involves several source files, and compiling each source file
    produces a separate object file. These object files are then linked together by
    a tool called the **linker** to form a single executable file. The linker uses
    additional information stored in object files to link them properly (linking will
    be discussed later in this chapter).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C++编译器会解析和分析源代码，然后生成中间代码，对其进行优化，最后生成一个名为**目标文件**的机器代码文件。您可能已经遇到过目标文件；它们在Linux中有单独的扩展名`.o`，在Windows中有单独的扩展名`.obj`。创建的目标文件包含不仅可以由计算机运行的机器代码。编译通常涉及多个源文件，编译每个源文件会产生一个单独的目标文件。然后，这些目标文件由一个称为**链接器**的工具链接在一起，形成一个单独的可执行文件。链接器使用存储在目标文件中的附加信息来正确地链接它们（链接将在本章后面讨论）。
- en: 'The following diagram depicts the program-building phases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了程序构建的阶段：
- en: '![](img/c5d04f78-da90-4c83-88ac-d152f1e9d2b1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5d04f78-da90-4c83-88ac-d152f1e9d2b1.png)'
- en: 'The C++ application-building process consists of three major steps: **preprocessing**,
    **compiling**, and **linking**. All of these steps are done using different tools,
    but modern compilers encapsulate them in a single tool, thereby providing a single
    and more straightforward interface for programmers.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C++应用程序构建过程包括三个主要步骤：**预处理**、**编译**和**链接**。所有这些步骤都使用不同的工具完成，但现代编译器将它们封装在一个单一的工具中，为程序员提供了一个更简单的接口。
- en: The generated executable file persists on the hard drive of the computer. In
    order to run it, it should be copied to the main memory, the RAM. The copying
    is done by another tool, named the **loader**. The loader is a part of the operating
    system that knows what and where should be copied from the contents of the executable
    file. After loading the executable file to the main memory, the original executable
    file won't be deleted from the hard drive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行文件保存在计算机的硬盘上。为了运行它，应将其复制到主内存RAM中。复制由另一个名为**加载器**的工具完成。加载器是操作系统的一部分，它知道应从可执行文件的内容中复制什么和复制到哪里。将可执行文件加载到主内存后，原始可执行文件不会从硬盘中删除。
- en: The loading and running of a program is done by the **operating system** (**OS**).
    The OS manages the execution of the program, prioritizes it over other programs,
    unloads it when it's done, and so on. The running copy of the program is called
    a **process**. A process is an instance of an executable file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的加载和运行由操作系统（OS）完成。操作系统管理程序的执行，优先级高于其他程序，在完成后卸载程序等。程序的运行副本称为进程。进程是可执行文件的一个实例。
- en: Understanding preprocessing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解预处理
- en: 'A **preprocessor** is intended to process source files to make them ready for
    compilation. A preprocessor works with preprocessor **directives**, such as `#define`, `#include`,
    and so on. Directives don''t represent program statements, but they are commands
    for the preprocessor, telling it what to do with the text of the source file.
    The compiler cannot recognize those directives, so whenever you use preprocessor
    directives in your code, the preprocessor resolves them accordingly before the
    actual compilation of the code begins. For example, the following code will be
    changed before the compiler starts to compile it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理器**旨在处理源文件，使其准备好进行编译。预处理器使用预处理器**指令**，如`#define`、`#include`等。指令不代表程序语句，而是预处理器的命令，告诉它如何处理源文件的文本。编译器无法识别这些指令，因此每当在代码中使用预处理器指令时，预处理器会在实际编译代码之前相应地解析它们。例如，编译器开始编译之前，以下代码将被更改：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Everything that is defined using the `#define` directive is called a **macro**.
    After preprocessing, the compiler gets the transformed source in this form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#define`指令定义的所有内容都称为**宏**。经过预处理后，编译器以这种形式获得转换后的源代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As already mentioned, the preprocessor is just processing the text and does
    not care about language rules or its syntax. Using preprocessor directives, especially
    macro definitions, as in the previous example, `#define NUMBER 41` is error-prone,
    unless you realize that the preprocessor simply replaces any occurrence of `NUMBER` with `41`without
    interpreting `41` as an integer. For the preprocessor, the following lines are
    both valid:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，预处理器只是处理文本，不关心语言规则或其语法。特别是使用宏定义的预处理器指令，如前面的例子中的`#define NUMBER 41`，除非你意识到预处理器只是简单地将`NUMBER`的任何出现替换为`41`，而不将`41`解释为整数。对于预处理器来说，以下行都是有效的：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This produces the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the compiler starts compilation, it finds the assignment `t = 41` erroneous
    because there is `no viable conversion from 'int' to 'T'`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器开始编译时，它会发现赋值`t = 41`是错误的，因为从'int'到'T'没有可行的转换。
- en: 'It is even dangerous to use macros that are correct syntactically but have
    logical errors:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至使用在语法上正确但存在逻辑错误的宏也是危险的：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preprocessor will replace any occurrence of `DOUBLE_IT(arg)` with `(arg * arg)`,
    therefore the following code will output `16`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器将任何`DOUBLE_IT(arg)`的出现替换为`(arg * arg)`，因此以下代码将输出`16`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The compiler will receive this code as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将接收到这段代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Problems arise when we use complex expressions as a macro argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将复杂表达式用作宏参数时会出现问题：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Intuitively, this code will produce `25`, but the truth is that the preprocessor
    doesn''t do anything but text processing, and in this case, it replaces the macro
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，这段代码将产生`25`，但事实上预处理器只是进行文本处理，而在这种情况下，它会这样替换宏：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This outputs `9`, and `9` is obviously not `25`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`9`，显然`9`不是`25`。
- en: 'To fix the macro definition, surround the macro argument with additional parentheses:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复宏定义，需要用额外的括号括住宏参数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the expression will take this form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表达式将采用这种形式：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is strongly suggested to use `const` declarations instead of macro definitions
    wherever applicable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在适用的地方使用`const`声明，而不是宏定义。
- en: As a rule of thumb, avoid using macro definitions. Macros are error-prone and
    C++ provides a set of constructs that make the use of macros obsolete.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应避免使用宏定义。宏容易出错，而C++提供了一组构造，使得宏的使用已经过时。
- en: 'The same preceding example would be type-checked and processed at compile time
    if we used a `constexpr` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`constexpr`函数，同样的前面的例子将在编译时进行类型检查和处理：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the `constexpr` specifier to make it possible to evaluate the return value
    of the function (or the value of a variable) at compile time. The example with
    the `NUMBER` definition would be better rewritten using a `const` variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`constexpr`限定符使得能够在编译时评估函数的返回值（或变量的值）。使用`const`变量重新编写`NUMBER`定义的示例会更好：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Header files
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件
- en: 'The most common use of the preprocessor is the `#include` directive, intended
    to include header files in the source code. Header files contain definitions for
    functions, classes, and so on:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器最常见的用法是`#include`指令，用于在源代码中包含头文件。头文件包含函数、类等的定义：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s suppose the header file `rect.h` is defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设头文件 `rect.h` 定义如下：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementation is contained in `rect.cpp`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现包含在 `rect.cpp` 中：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After the preprocessor examines `main.cpp` and `rect.cpp`, it replaces the `#include` directives
    with corresponding contents of `iostream` and `rect.h` for `main.cpp` and `rect.h` for
    `rect.cpp`. C++17 introduces the `__has_include` preprocessor constant expression. `__has_include` evaluates
    to `1` if the file with the specified name is found and `0` if not:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器检查 `main.cpp` 和 `rect.cpp` 后，将用 `main.cpp` 的 `#include` 指令替换为 `iostream`
    和 `rect.h` 的相应内容，用 `rect.cpp` 的 `#include` 指令替换为 `rect.h`。C++17 引入了 `__has_include`
    预处理器常量表达式。如果找到指定名称的文件，`__has_include` 的值为 `1`，否则为 `0`：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When declaring header files, it''s strongly advised to use so-called *include-guards*
    (`#ifndef, #define, #endif`) to avoid double declaration errors. We are going
    to introduce the technique shortly. Those are, again, preprocessor directives
    that allow us to avoid the following scenario: type `Square` is defined in `square*.*h`,
    which includes `rect.h` in order to derive `Square` from `Rect`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '在声明头文件时，强烈建议使用所谓的*包含保护*（`#ifndef, #define, #endif`）来避免双重声明错误。我们将很快介绍这种技术。这些又是预处理指令，允许我们避免以下情况：`Square`
    类在 `square*.*h` 中定义，它包含 `rect.h` 以从 `Rect` 派生 `Square`：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Including both `square.h` and `rect.h` in `main.cpp` leads to including `rect.h`
    twice:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中包含 `square.h` 和 `rect.h` 会导致 `rect.h` 被包含两次：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After preprocessing, the compiler will receive `main.cpp` in the following
    form:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理后，编译器将以以下形式接收 `main.cpp`：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The compiler will then produce an error because it encounters two declarations
    of type `Rect`. A header file should be guarded against multiple inclusions by
    using include-guards in the following way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器会产生一个错误，因为它遇到了两个类型为 `Rect` 的声明。头文件应该通过使用包含保护来防止多次包含，方法如下：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the preprocessor meets the header for the first time, `RECT_H` is not defined
    and everything between `#ifndef` and `#endif` will be processed accordingly, including
    the `RECT_H` definition. The second time the preprocessor includes the same header
    file in the same source file, it will omit the contents because `RECT_H` has already
    been defined.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当预处理器第一次遇到头文件时，`RECT_H` 未定义，`#ifndef` 和 `#endif` 之间的所有内容都将被相应处理，包括 `RECT_H`
    的定义。当预处理器在同一源文件中第二次包含相同的头文件时，它将省略内容，因为 `RECT_H` 已经被定义。
- en: These include-guards are part of directives that control the compilation of
    parts of the source file. All of the conditional compilation directives are `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`,
    and `#endif`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包含保护是控制源文件部分编译的指令的一部分。所有条件编译指令都是 `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`,
    和 `#endif`。
- en: 'Conditional compilation is useful in many cases; one of them is logging function
    calls in so-called **debug** mode. Before releasing the program, it is advised
    to debug your program and test against logical flaws. You might want to see what
    happens in the code after invoking a certain function, for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译在许多情况下都很有用；其中之一是在所谓的**调试**模式下记录函数调用。在发布程序之前，建议调试程序并测试逻辑缺陷。您可能想要查看在调用某个函数后代码中发生了什么，例如：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each function calls the `log()` function, which is implemented as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数调用 `log()` 函数，其实现如下：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `log()` function will print the `msg` if `DEBUG` is defined. If you compile
    the project enabling `DEBUG` (using compiler flags, such as `-D` in g++), then
    the `log()` function will print the string passed to it; otherwise, it will do
    nothing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了 `DEBUG`，`log()` 函数将打印 `msg`。如果编译项目时启用了 `DEBUG`（使用编译器标志，如 g++ 中的 `-D`），那么
    `log()` 函数将打印传递给它的字符串；否则，它将什么也不做。
- en: Using modules in C++20
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++20 中使用模块
- en: 'Modules fix header files with annoying include-guard issues. We can now get
    rid of preprocessor macros. Modules incorporate two keywords, `import` and `export`.
    To use a module, we `import` it. To declare a module with its exported properties,
    we use `export`. Before listing the benefits of using modules, let''s look at
    a simple usage example. The following code declares a module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 模块修复了头文件中令人讨厌的包含保护问题。我们现在可以摆脱预处理宏。模块包括两个关键字，`import` 和 `export`。要使用一个模块，我们使用
    `import`。要声明一个模块及其导出的属性，我们使用 `export`。在列出使用模块的好处之前，让我们看一个简单的使用示例。以下代码声明了一个模块：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first line declares the module named `test`. Next, we declared the `twice()`
    function and set it to `export`. This means that we can have functions and other
    entities that are not exported, thus, they will be private outside of the module.
    By exporting an entity, we set it `public` to `module` users. To use `module`,
    we import it as done in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了名为 `test` 的模块。接下来，我们声明了 `twice()` 函数并将其设置为 `export`。这意味着我们可以有未导出的函数和其他实体，因此它们在模块外部将是私有的。通过导出实体，我们将其设置为模块用户的
    `public`。要使用 `module`，我们像以下代码中那样导入它：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modules are a long-awaited feature of C++ that provides better performance
    in terms of compilation and maintenance. The following features make modules better
    in the competition with regular header files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 C++ 中期待已久的功能，它在编译和维护方面提供了更好的性能。以下功能使模块在与常规头文件的竞争中更胜一筹：
- en: A module is imported only once, similar to precompiled headers supported by
    custom language implementations. This reduces the compile time drastically. Non-exported
    entities have no effect on the translation unit that imports the module.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块只被导入一次，类似于自定义语言实现支持的预编译头文件。这大大减少了编译时间。未导出的实体对导入模块的翻译单元没有影响。
- en: Modules allow expressing the logical structure of code by allowing you to select
    which units should be exported and which should not. Modules can be bundled together
    into bigger modules.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块允许通过选择应该导出和不应该导出的单元来表达代码的逻辑结构。模块可以捆绑在一起形成更大的模块。
- en: Getting rid of workarounds such as include-guards, described earlier. We can
    import modules in any order. There are no more concerns for macro redefinitions.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆脱之前描述的包含保护等变通方法。我们可以以任何顺序导入模块。不再担心宏的重新定义。
- en: 'Modules can be used together with header files. We can both import and include
    headers in the same file, as demonstrated in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以与头文件一起使用。我们可以在同一个文件中导入和包含头文件，就像下面的例子所示：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When creating modules, you are free to export entities in the interface file
    of the module and move the implementations to other files. The logic is the same
    as in managing `.h` and `.cpp` files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块时，您可以在模块的接口文件中导出实体，并将实现移动到其他文件中。逻辑与管理`.h`和`.cpp`文件相同。
- en: Understanding Compiling
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解编译
- en: 'The C++ compilation process consists of several phases. Some of the phases
    are intended to analyze the source code, and others generate and optimize the
    target machine code. The following diagram shows the phases of compilation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译过程由几个阶段组成。一些阶段旨在分析源代码，而其他阶段则生成和优化目标机器代码。以下图表显示了编译的各个阶段：
- en: '![](img/c7f00317-dd05-467d-af51-d4c5a14858a4.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7f00317-dd05-467d-af51-d4c5a14858a4.png)'
- en: Let's look at each of these phases in detail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些阶段中的每一个。
- en: Tokenization
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记化
- en: 'The analysis phase of the compiler aims to split the source code into small
    units called tokens. A **token** may be a word or just a single symbol, such as
    `=` (the equals sign). A token is the *smallest unit* of the source code that
    carries meaningful value for the compiler. For example, the expression `int a
    = 42;` will be divided into the tokens `int`, `a`, `=`, `42`, and `;`. The expression
    isn''t just split by spaces, because the following expression is being split into
    the same tokens (though it is advisable not to forget the spaces between operands):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的分析阶段旨在将源代码分割成称为标记的小单元。**标记**可以是一个单词或一个单一符号，比如`=`（等号）。标记是源代码的*最小单元*，对于编译器来说具有有意义的价值。例如，表达式`int
    a = 42;`将被分成标记`int`、`a`、`=`、`42`和`;`。表达式不仅仅是通过空格分割，因为以下表达式也被分成相同的标记（尽管建议不要忘记操作数之间的空格）：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The splitting of the source code into tokens is done using sophisticated methods
    using regular expressions. It is known as **l****exical analysis**, or **tokenization**
    (dividing into tokens). For compilers, using a tokenized input presents a better
    way to construct internal data structures used to analyze the syntax of the code.
    Let's see how.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复杂的方法和正则表达式将源代码分割成标记。这被称为**词法分析**或**标记化**（分成标记）。对于编译器来说，使用标记化的输入提供了一种更好的方式来构建用于分析代码语法的内部数据结构。让我们看看。
- en: Syntax analysis
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法分析
- en: 'When speaking about programming language compilation, we usually differentiate
    two terms: syntax and semantics. The syntax is the structure of the code; it defines
    the rules by which tokens combined make structural sense. For example, *day nice*
    is a syntactically correct phrase in English because it doesn''t contain errors
    in either of the tokens. **Semantics**, on the other hand, concerns the actual
    meaning of the code. That is, *day nice* is semantically incorrect and should
    be corrected as *a nice day*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论编程语言编译时，我们通常区分两个术语：语法和语义。语法是代码的结构；它定义了标记组合成结构上下文的规则。例如，*day nice*是英语中的一个语法正确的短语，因为它的标记中没有错误。**语义**则关注代码的实际含义。也就是说，*day
    nice*在语义上是不正确的，应该改为*a nice day*。
- en: 'Syntax analysis is a crucial part of source analysis, because tokens will be
    analyzed syntactically and semantically, that is, as to whether they bear any
    meaning that conforms to the general grammar rules. Take the following, for example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 语法分析是源代码分析的关键部分，因为标记将被语法和语义地分析，即它们是否具有符合一般语法规则的任何含义。例如，接下来的例子：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It may not make sense for us, because adding zero to the variable won''t change
    its value, but the compiler doesn''t look on logical meaning here—it looks for
    the *syntactic correctness* of the code (a missing semicolon, a missing closing
    parenthesis, and more). Checking the syntactic correctness of the code is done
    in the syntax analysis phase of compilation. The lexical analysis divides the
    code into tokens; **syntax analysis** checks for syntactic correctness, which
    means that the aforementioned expression will produce a syntax error if we have
    missed a semicolon:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说可能没有意义，因为将零添加到变量不会改变其值，但是编译器在这里并不关心逻辑含义，而是关心代码的*语法正确性*（缺少分号、缺少右括号等）。检查代码的语法正确性是在编译的语法分析阶段完成的。词法分析将代码分成标记；**语法分析**检查语法正确性，这意味着如果我们漏掉了一个分号，上述表达式将产生语法错误：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: g++ will complain with the `expected ';' at end of declaration` error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: g++将报错`expected ';' at end of declaration`。
- en: Semantic analysis
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义分析
- en: If the previous expression was something like `it b = a + 0; `, the compiler
    would divide it into the tokens `it`, `b`, `=`, and others. We already see that
    `it` is something unknown, but for the compiler, it is fine at this point. This
    would lead to the compilation error `unknown type name "it"` in g++. Finding the
    meaning behind expressions is the task of **semantic analysis **(parsing).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的表达式是`it b = a + 0;`，编译器会将其分成标记`it`、`b`、`=`和其他。我们已经看到`it`是未知的，但对于编译器来说，这个时候还可以接受。这将导致g++中的编译错误`unknown
    type name "it"`。找到表达式背后的含义是**语义分析**（解析）的任务。
- en: Intermediate code generation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间代码生成
- en: 'After all the analysis is completed, the compiler generates intermediate code
    that is a light version of C++ mostly C. A simple example would be the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有分析之后，编译器将生成中间代码，这是C++的轻量级版本，主要是C。一个简单的例子是：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After analyzing the code, *intermediate code* will be generated (this is an
    abstract example meant to show the idea of the intermediate code generation; compilers
    may differ in implementation):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码之后，将生成*中间代码*（这是一个抽象的例子，旨在展示中间代码生成的概念；编译器在实现上可能有所不同）。
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Optimization
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: 'Generating intermediate code helps the compiler to make optimizations in the
    code. Compilers try to optimize code a lot. Optimizations are done in more than
    one pass. For example, take the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 生成中间代码有助于编译器对代码进行优化。编译器试图大量优化代码。优化不止一次进行。例如，看下面的代码：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will be optimized into this during compilation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译期间，这将被优化为这个：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This again will be optimized into the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次被优化为以下内容：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Some programmers have no doubt that, nowadays, compilers code better than programmers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员毫无疑问地认为，如今，编译器编写的代码比程序员更好。
- en: Machine code generation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器代码生成
- en: 'Compiler optimizations are done in both intermediate code and generated machine
    code. So what is it like when we compile the project? Earlier in the chapter,
    when we discussed the preprocessing of the source code, we looked at a simple
    structure containing several source files, including two headers, `rect.h` and `square.h`,
    each with its `.cpp` files, and `main.cpp`*, *which contained the program entry
    point (the `main()` function). After the preprocessing, the following units are
    left as input for the compiler: `main.cpp`, `rect.cpp`, and `square.cpp`*, *as
    depicted in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器优化在中间代码和生成的机器代码中都进行。那么当我们编译项目时会是什么样子呢？在本章的前面，当我们讨论源代码的预处理时，我们看到了一个简单的结构，其中包含了几个源文件，包括两个头文件`rect.h`和`square.h`，每个都有其对应的`.cpp`文件，以及包含程序入口点（`main()`函数）的`main.cpp`。预处理后，以下单元作为编译器的输入：`main.cpp`，`rect.cpp`和`square.cpp`，如下图所示：
- en: '![](img/168390a7-7c88-4574-adb4-af6fce28f5ce.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/168390a7-7c88-4574-adb4-af6fce28f5ce.png)'
- en: The compiler will compile each separately. Compilation units, also known as
    source files, are *independent* of each other in some way. When the compiler compiles
    `main.cpp`, which has a call to the `get_area()` function in `Rect`, it does not
    include the `get_area()` implementation in `main.cpp`. Instead, it is just sure
    that the function is implemented somewhere in the project. When the compiler gets
    to `rect*.*cpp`, it does not know that the `get_area()` function is used somewhere.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将分别编译每个单元。编译单元，也称为源文件，在某种程度上是*独立*的。当编译器编译`main.cpp`时，在`Rect`中调用`get_area()`函数，它不会在`main.cpp`中包含`get_area()`的实现。相反，它只是确信该函数在项目的某个地方被实现。当编译器到达`rect*.*cpp`时，它并不知道`get_area()`函数在某处被使用。
- en: 'Here''s what the compiler gets after `main.cpp` passes the preprocessing phase:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.cpp`经过预处理阶段后编译器得到的结果：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After analyzing `main.cpp`, the compiler generates the following intermediate
    code (many details are omitted to simply express the idea behind compilation):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`main.cpp`后，编译器生成以下中间代码（为了简单表达编译背后的思想，许多细节被省略）：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The compiler will remove the `Square` struct with its constructor function (we
    named it `_Square_init_`) while optimizing the code because it was never used
    in the source code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在优化代码时会删除`Square`结构及其构造函数（我们将其命名为`_Square_init_`），因为它在源代码中从未被使用。
- en: At this point, the compiler operates with `main.cpp` only, so it sees that we
    called the `_Rect_init_` and `_Rect_get_area_` functions but did not provide their
    implementation in the same file. However, as we did provide their declarations
    beforehand, the compiler trusts us and believes that those functions are implemented
    in other compilation units. Based on this trust and the minimum information regarding
    the function signature (its return type, name, and the number and types of its
    parameters), the compiler generates an object file that contains the working code
    in `main.cpp` and somehow marks the functions that have no implementation but
    are trusted to be resolved later. The resolving is done by the linker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，编译器仅处理`main.cpp`，因此它看到我们调用了`_Rect_init_`和`_Rect_get_area_`函数，但没有在同一文件中提供它们的实现。然而，由于我们之前提供了它们的声明，编译器相信我们，并相信这些函数在其他编译单元中被实现。基于这种信任和关于函数签名的最小信息（返回类型、名称以及参数的数量和类型），编译器生成一个包含`main.cpp`中工作代码的目标文件，并以某种方式标记那些没有实现但被信任稍后解决的函数。解决是由链接器完成的。
- en: 'In the following example, we have the simplified variant of the generated object
    file, which contains two sections—code and information. The code section has addresses
    for each instruction (the hexadecimal values):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有生成的简化对象文件的变体，其中包含两个部分——代码和信息。代码部分包含每条指令的地址（十六进制值）：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Take a look at the `information` section. The compiler marks all the functions
    used in the code section that were not found in the same compilation unit with
    `????`. These question marks will be replaced by the actual addresses of the functions
    found in other units by the linker. Finishing with `main.cpp`, the compiler starts
    to compile the `rect.cpp` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`信息`部分。编译器用`????`标记了代码部分中使用但在同一编译单元中找不到的所有函数。这些问号将由链接器替换为其他单元中找到的函数的实际地址。完成`main.cpp`后，编译器开始编译`rect.cpp`文件：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Following the same logic here, the compilation of this unit produces the following
    output (don''t forget, we''re still providing abstract examples):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑，编译此单元产生以下输出（不要忘记，我们仍然提供抽象示例）：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This output has all the addresses of the functions in it, so there is no need
    to wait for some functions to be resolved later.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出中包含了所有函数的地址，因此不需要等待某些函数稍后解决。
- en: Platforms and object files
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台和目标文件
- en: The abstract output that we just saw is somewhat similar to the actual object
    file structure that the compiler produces after the compilation of a unit. The
    structure of an object file depends on the platform; for example, in *Linux,*
    it is represented in *ELF* format (*ELF* stands for *Executable and Linkable Format*).
    A **platform** is an environment in which a program is executed. In this context,
    by platform, we mean the combination of the computer architecture (more specifically,
    the *instruction set architecture*) and operating system. Hardware and operating
    systems are designed and created by different teams and companies. Each of them
    has different solutions to design problems, which leads to major differences between
    platforms. Platforms differ in many ways, and those differences are projected
    onto the executable file format and structure as well. For example, the executable
    file format in Windows systems is **Portable Executable** (**PE**), which has
    a different structure, number, and sequence of sections than the ELF format in
    Linux.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的抽象输出在某种程度上类似于编译器在编译单元后产生的实际目标文件结构。目标文件的结构取决于平台；例如，在*Linux*中，它以*ELF*格式表示（*ELF*代表*可执行和可链接格式*）。**平台**是程序执行的环境。在这个上下文中，平台指的是计算机架构（更具体地说是*指令集架构*）和操作系统的组合。硬件和操作系统由不同的团队和公司设计和创建。它们每个都有不同的解决方案来解决问题，这导致平台之间存在重大差异。平台在许多方面有所不同，这些差异也反映在可执行文件的格式和结构上。例如，Windows系统中的可执行文件格式是**可移植可执行文件**（**PE**），它具有不同的结构、部分数量和顺序，与Linux中的ELF格式不同。
- en: An object file is divided into **sections**. Most important for us are the code
    sections (marked as `.text`) and the data section (`.data`). The` .text` section
    holds the program instructions and the `.data` section holds the data used by
    instructions. Data itself may be split into several sections, such as *initialized*,
    *uninitialized*, and *read-only* data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件被分成**部分**。对我们来说最重要的是代码部分（标记为`.text`）和数据部分（`.data`）。`.text`部分包含程序指令，`.data`部分包含指令使用的数据。数据本身可以分为多个部分，如*初始化*、*未初始化*和*只读*数据。
- en: An important part of the object files in addition to the `.text` and `.data`
    sections is the **symbol table**. The symbol table stores the mappings of strings
    (symbols) to locations in the object file. In the preceding example, the compiler-generated
    output had two portions, the second portion of which was marked as `information:`,
    which holds the names of the functions used in the code and their relative addresses.
    This `information:` is the abstract version of the actual symbol table of the
    object file. The symbol table holds both symbols defined in the code and symbols
    used in the code that need to be resolved. This information is then used by the
    linker in order to link the object files together to form the final executable
    file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`.text`和`.data`部分之外，目标文件的一个重要部分是**符号表**。符号表存储了字符串（符号）到目标文件中的位置的映射。在前面的示例中，编译器生成的输出有两部分，其中的第二部分标记为`information:`，其中包含代码中使用的函数的名称和它们的相对地址。这个`information:`是目标文件的实际符号表的抽象版本。符号表包含代码中定义的符号和代码中需要解析的符号。然后链接器使用这些信息将目标文件链接在一起形成最终的可执行文件。
- en: Introducing Linking
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入链接
- en: 'The compiler outputs an object file for each compilation unit. In the previous
    example, we had three `.cpp` files and the compiler produced three object files.
    The task of the linker is to combine these object files together into a single
    object file. Combining files together results in relative address changes; for
    example, if the linker puts the `rect.o` file after `main.o`, the starting address
    of `rect.o` becomes `0x04` instead of the previous value of `0x00`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为每个编译单元输出一个目标文件。在前面的示例中，我们有三个`.cpp`文件，编译器产生了三个目标文件。链接器的任务是将这些目标文件组合成一个单一的目标文件。将文件组合在一起会导致相对地址的变化；例如，如果链接器将`rect.o`文件放在`main.o`之后，`rect.o`的起始地址将变为`0x04`，而不是之前的`0x00`的值。
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The linker correspondingly updates the symbol table addresses (the `information:`
    section in our example). As mentioned previously, each object file has its symbol
    table, which maps the string name of the symbol to its relative location (address)
    in the file. The next step of linking is to resolve all the unresolved symbols
    in the object file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器相应地更新符号表地址（我们示例中的`information:`部分）。如前所述，每个目标文件都有其符号表，将符号的字符串名称映射到文件中的相对位置（地址）。链接的下一步是解析目标文件中的所有未解析符号。
- en: Now that the linker has combined `main.o` and `rect.o` together, it knows the
    relative location of unresolved symbols because they are now located in the same
    file. The `printf` symbol will be resolved the same way, except this time it will
    link the object files with the standard library. After all the object files are
    combined together (we omitted the linking of `square.o` for brevity), all addresses
    are updated, and all the symbols are resolved, the linker outputs the one final
    object file that can be executed by the operating system. As discussed earlier
    in the chapter, the OS uses a tool called the loader to load the contents of the
    executable file into the memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在链接器已经将`main.o`和`rect.o`组合在一起，它知道未解析符号的相对位置，因为它们现在位于同一个文件中。`printf`符号将以相同的方式解析，只是这次它将链接对象文件与标准库一起。当所有目标文件都组合在一起后（我们为简洁起见省略了`square.o`的链接），所有地址都被更新，所有符号都被解析，链接器输出一个最终的可执行文件，可以被操作系统执行。正如本章前面讨论的那样，操作系统使用一个称为加载器的工具将可执行文件的内容加载到内存中。
- en: Linking libraries
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接库
- en: 'A library is similar to an executable file, with one major difference: it does
    not have a `main()` function, which means that it cannot be invoked as a regular
    program. Libraries are used to combine code that might be reused with more than
    one program. You already linked your programs with the standard library by including
    the `<iostream>` header, for example.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 库类似于可执行文件，但有一个主要区别：它没有`main()`函数，这意味着它不能像常规程序那样被调用。库用于将可能被多个程序重复使用的代码组合在一起。例如，通过包含`<iostream>`头文件，您已经将程序与标准库链接起来。
- en: 'Libraries can be linked with the executable file either as **static** or **dynamic**
    libraries. When you link them as a static library, they become a part of the final
    executable file. A dynamically linked library should also be loaded into memory
    by the OS to provide your program with the ability to call its functions. Let''s
    suppose we want to find the square root of a function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以链接到可执行文件中，可以是**静态**库，也可以是**动态**库。当将它们链接为静态库时，它们将成为最终可执行文件的一部分。动态链接库也应该由操作系统加载到内存中，以便为程序提供调用其函数的能力。假设我们想要找到一个函数的平方根：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The C++ standard library provides the `sqrt()` function, which returns the
    square root of its argument. If you compile the preceding example, it will produce
    an error insisting that the `sqrt` function has not been declared. We know that
    to use the standard library function, we should include the corresponding `<cmath>` header.
    But the header file does not contain the implementation of the function; it just
    declares the function (in the `std` namespace), which is then included in our
    source file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了`sqrt()`函数，它返回其参数的平方根。如果编译前面的示例，它将产生一个错误，坚持认为`sqrt`函数未被声明。我们知道要使用标准库函数，应该包含相应的`<cmath>`头文件。但是头文件不包含函数的实现；它只是声明函数（在`std`命名空间中），然后包含在我们的源文件中：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The compiler marks the address of the `sqrt` symbol as unknown, and the linker
    should resolve it in the linking stage. The linker will fail to resolve it if
    the source file is not linked with the standard library implementation (the object
    file containing the library functions).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`sqrt`符号的地址标记为未知，链接器应在链接阶段解析它。如果源文件未与标准库实现（包含库函数的目标文件）链接，链接器将无法解析它。
- en: The final executable file generated by the linker will consist of both our program
    and the standard library if the linking was static. On the other hand, if the
    linking is dynamic, the linker marks the `sqrt` symbol to be found at runtime.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器生成的最终可执行文件将包含我们的程序和标准库（如果链接是静态的）。另一方面，如果链接是动态的，链接器将标记`sqrt`符号在运行时被找到。
- en: Now when we run the program, the loader also loads the library that was dynamically
    linked to our program. It loads the contents of the standard library into the
    memory as well and then resolves the actual location of the `sqrt()` function
    in memory. The same library that is already loaded into the memory can be used
    by other programs as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行程序时，加载程序的同时也加载了动态链接到我们程序的库。它还将标准库的内容加载到内存中，然后解析`sqrt()`函数在内存中的实际位置。已加载到内存中的相同库也可以被其他程序使用。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched on a few of the many new features of C++20 and are
    now ready to dive deeper into the language. We discussed the process of building
    a C++ application and its compilation phases. This includes analyzing the code
    to detect syntactical and grammatical errors, generating intermediate code to
    make optimizations, and finally, generating the object file that will be linked
    together with other generated object files to form the final executable file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了C++20的一些新特性，并准备深入了解该语言。我们讨论了构建C++应用程序及其编译阶段的过程。这包括分析代码以检测语法和语法错误，生成中间代码以进行优化，最后生成将与其他生成的目标文件链接在一起形成最终可执行文件的目标文件。
- en: In the next chapter, we will learn about C++ data types, arrays, and pointers.
    We will also gain an understanding of what pointers are and look at low-level
    details of conditionals.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习C++数据类型、数组和指针。我们还将了解指针是什么，并查看条件的低级细节。
- en: Questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a compiler and an interpreter?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器和解释器之间有什么区别？
- en: List the program compilation phases.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出程序编译阶段。
- en: What does the preprocessor do?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预处理器的作用是什么？
- en: What are the tasks of the linker?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器的任务是什么？
- en: What is the difference between statically and dynamically linked libraries?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态链接库和动态链接库之间有什么区别？
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information, refer to *A**dvanced C and C++ Compiling* at [https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/](https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/](https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/)中的*A**dvanced
    C and C++ Compiling*。
- en: LLVM Essentials, https://www.packtpub.com/application-development/llvm-essentials
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM Essentials, https://www.packtpub.com/application-development/llvm-essentials
