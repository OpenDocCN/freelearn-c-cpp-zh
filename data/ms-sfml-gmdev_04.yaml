- en: Chapter 4. Have Thy Gear Ready - Building Game Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 准备好你的装备 - 构建游戏工具
- en: Making games is a fine art. It is entirely possible, of course, to make art
    with the most basic of tools, but most commonly, developers need a strong toolkit
    supporting them in order to efficiently and professionally create quick, painless
    edits to their game. Building the said toolkit is arguably on a par with the difficulty
    of building the actual game, but the work spent on proper tools offsets the difficulty
    and frustrations that come with direct file edits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏是一门艺术。当然，使用最基本的工具制作艺术是完全可能的，但通常，开发者需要一个强大的工具集来支持他们，以便高效和专业地快速进行游戏编辑，而无需痛苦。构建这个工具集可以说与构建实际游戏一样困难，但投入在适当工具上的工作抵消了直接文件编辑带来的困难和挫折。
- en: 'In this chapter, we''re going to be covering these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Building a graphical means of file management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图形化的文件管理系统
- en: File loading in a separate thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的线程中加载文件
- en: Establishing a state and means of controls for map editing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立地图编辑的状态和控制系统
- en: There's lots of ground to cover, so let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容需要覆盖，所以让我们开始吧！
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的利用
- en: 'As usual, let us give proper thanks to the artists and their assets that made
    this possible:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们向艺术家及其资产表示感谢，是他们使这一切成为可能：
- en: '*Folder Orange* by *sixsixfive* under the **CC0** license (public domain): [https://openclipart.org/detail/212337/folder-orange](https://openclipart.org/detail/212337/folder-orange)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Folder Orange* 由 *sixsixfive* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/212337/folder-orange](https://openclipart.org/detail/212337/folder-orange)'
- en: '*Generic Document* by *isendrak* under the **CC0** license (public domain): [https://openclipart.org/detail/212798/generic-document](https://openclipart.org/detail/212798/generic-document)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Generic Document* 由 *isendrak* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/212798/generic-document](https://openclipart.org/detail/212798/generic-document)'
- en: '*Tango Media Floppy* by *warszawianka* under the **CC0** license (public domain): [https://openclipart.org/detail/34579/tango-media-floppy](https://openclipart.org/detail/34579/tango-media-floppy)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tango Media Floppy* 由 *warszawianka* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/34579/tango-media-floppy](https://openclipart.org/detail/34579/tango-media-floppy)'
- en: '*Close* by *danilo* under the **CC0** license (public domain): [https://openclipart.org/detail/215431/close](https://openclipart.org/detail/215431/close)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Close* 由 *danilo* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/215431/close](https://openclipart.org/detail/215431/close)'
- en: '*Hand Prints* by *kattekrab* under the **CC0** license (public domain): [https://openclipart.org/detail/16340/hand-prints](https://openclipart.org/detail/16340/hand-prints)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hand Prints* 由 *kattekrab* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/16340/hand-prints](https://openclipart.org/detail/16340/hand-prints)'
- en: '*Paint Brush with Dark Red Dye* by *Astro* under the **CC0** license (public
    domain): [https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11](https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Paint Brush with Dark Red Dye* 由 *Astro* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11](https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11)'
- en: '*Primary Eraser* by *dannya* under the **CC0** license (public domain): [https://openclipart.org/detail/199463/primary-eraser](https://openclipart.org/detail/199463/primary-eraser)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Primary Eraser* 由 *dannya* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/199463/primary-eraser](https://openclipart.org/detail/199463/primary-eraser)'
- en: '*Mono Tool Rect Selection* by *dannya* under the **CC0** license (public domain): [https://openclipart.org/detail/198758/mono-tool-rect-selection](https://openclipart.org/detail/198758/mono-tool-rect-selection)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mono Tool Rect Selection* 由 *dannya* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/198758/mono-tool-rect-selection](https://openclipart.org/detail/198758/mono-tool-rect-selection)'
- en: '*Color Bucket Red* by *frankes* under the **CC0** license (public domain): [https://openclipart.org/detail/167327/color-bucket-red](https://openclipart.org/detail/167327/color-bucket-red)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Color Bucket Red* 由 *frankes* 根据 **CC0** 许可（公有领域）：[https://openclipart.org/detail/167327/color-bucket-red](https://openclipart.org/detail/167327/color-bucket-red)'
- en: File management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件管理
- en: The success and usability of the map editor tool is going to rely heavily on
    one specific interfacing element here, which is file access and management. In
    order to provide efficient means of file access, loading and saving, we are going
    to work on developing the means of visually guiding our user through the file
    system. The entire system consists of a few moving parts. For now, let us solely
    focus on the interface aspect of this idea.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 地图编辑工具的成功和可用性将严重依赖于这里的一个特定接口元素，即文件访问和管理。为了提供高效的文件访问、加载和保存方法，我们将致力于开发引导用户通过文件系统的视觉引导手段。整个系统由几个部分组成。目前，让我们只关注这个想法的界面方面。
- en: File manager interface
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件管理器接口
- en: 'Before we can successfully work with any kind of map data, it is important
    to have a comfortable means of loading and saving. This can be offloaded to a
    file manager interface, which is going to be responsible for displaying directory
    information. Let us take a look at what ours is going to look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够成功处理任何类型的地图数据之前，有一个舒适的方法来加载和保存是很重要的。这可以委托给文件管理器接口，该接口将负责显示目录信息。让我们看看我们的样子：
- en: '![File manager interface](img/image_04_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![文件管理器接口](img/image_04_001.jpg)'
- en: 'With this goal in mind, let us begin planning a class for it, starting with
    the header:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个目标，让我们开始规划这个类的实现，从头部开始：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Evidently, this class is a slightly more complex manifestation of a wrapper
    for a `GUI_Interface` instance. It is responsible for keeping track of the current
    directory we are in, as well as invoking a callback function/method when a file
    is selected to be loaded or saved. The callback function only takes a string argument,
    which carries the full path to the file that was selected to be loaded or saved,
    and can be registered like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个类是`GUI_Interface`实例包装的一个稍微复杂的表现形式。它负责跟踪我们当前所在的目录，以及在选中文件进行加载或保存时调用回调函数/方法。回调函数只接受一个字符串参数，该参数携带要加载或保存的文件的完整路径，并且可以像这样注册：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing too complicated yet. Let us move on to actually implementing the class!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么太复杂的。让我们继续进行类的实际实现！
- en: Implementing the file manager
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现文件管理器
- en: 'With the class definition out of the way, it is time to take a look at the
    actual code that makes the file manager tick. Let''s start by implementing the
    constructor of this class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完类定义之后，是时候看看使文件管理器工作的实际代码了。让我们从这个类的构造函数开始实现：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we load the interface and store its pointer in the designated data member.
    We also want to store the current state of the application, and obtain the style
    names of the elements, called `FolderEntry` and `FileEntry`, which are then removed.
    This makes the interface file a sort of template that gets filled in with all
    the right information later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载界面并将指针存储在指定的数据成员中。我们还想存储应用程序的当前状态，并获取元素的风格名称，称为`FolderEntry`和`FileEntry`，然后将其移除。这使得界面文件成为一种模板，稍后将被所有正确的信息填充。
- en: Once the appropriate content size and offset are set, the interface is positioned
    in the centre of the screen. We then subscribe to relevant GUI interface events
    and set our file manager directory as the current directory the application is
    in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了适当的内容大小和偏移量，界面就被定位在屏幕中央。然后我们订阅相关的GUI界面事件，并将我们的文件管理器目录设置为应用程序当前所在的目录。
- en: 'The callbacks and interfaces created in this class obviously need to be removed
    once they are no longer in use. This is where the destructor comes in:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中创建的回调和接口显然在不再使用时需要被移除。这就是析构函数发挥作用的地方：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, it is important for the file manager class to have a way to easily change
    its current directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于文件管理类来说，有一个方便地更改当前目录的方法是很重要的：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A couple of interesting things happened. Right after the argument is stored;
    all of the backward slashes in the directory string are replaced with forward
    slashes, in order to maintain compatibility with multiple other operating systems
    that do not play well with the former. The interface is then instructed to destroy
    all elements it has that begin with the `""Entry_""` string. This is done in order
    to clear out all file and directory entries that may already exist. Finally, `ListFiles()`
    method is invoked, which populates the file manager with all of the files and
    folders inside the new directory. Let'' us take a look at how that can be done:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了一些有趣的事情。在参数存储后不久；目录字符串中的所有反斜杠都被替换为正斜杠，以便与不兼容前者的多个其他操作系统保持兼容。然后，界面被指示销毁所有以`"Entry_"`字符串开头的元素。这样做是为了清除可能已经存在的所有文件和目录条目。最后，调用`ListFiles()`方法，该方法将新目录中的所有文件和文件夹填充到文件管理器中。让我们看看这是如何实现的：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the `Directory` element is obtained in order to change its text. It represents
    the full path of the current working directory. The complete file list inside
    that directory is then obtained, including other folders. After it gets sorted
    alphabetically and by type, the parent directory element is obtained to calculate
    the starting coordinates of the first element on the list, which is, in turn,
    iterated over. Non-physical directories, such as `"."` or `".."`, are dismissed.
    A new element is then added to the interface, with an appropriate name that varies
    depending on whether we are working with a file or a folder. That same element
    is then updated to have the entry name, be in the right position and have a correct
    style attached to it. Finally, the *y* coordinate is incremented for the next
    element on the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取`Directory`元素以更改其文本。它表示当前工作目录的完整路径。然后获取该目录中包括其他文件夹在内的完整文件列表。在按字母顺序和类型排序后，获取父目录元素以计算列表中第一个元素的起始坐标，然后迭代它。忽略非物理目录，例如`"."`或`".."`。然后向界面添加一个新元素，其名称根据我们是在处理文件还是文件夹而变化。然后更新该元素，使其具有条目名称，处于正确的位置，并附加正确的样式。最后，为列表中的下一个元素递增`y`坐标。
- en: 'With the directory structure being visually represented, let us take a look
    at what needs to happen when one of its entries is actually clicked:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当目录结构以可视化的形式呈现时，让我们看看当点击其条目之一时需要发生什么：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first check here lets us know whether the item clicked on was a directory
    or a file. In case of a folder click, we want to be able to traverse the filesystem
    by taking its name and adding it onto our existing directory path. The vertical
    scroll of the interface is then set back to zero, in order to move the content
    back up to the top if any scrolling has been done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个检查告诉我们点击的项是目录还是文件。在文件夹点击的情况下，我们希望能够通过取其名称并将其添加到现有的目录路径中来遍历文件系统。然后，界面的垂直滚动被设置回零，以便在执行任何滚动后，将内容移回顶部。
- en: A file click is a simpler matter. All we need to do in that case is obtain the
    text-field element that holds the filename, and change its contents to the name
    of the file that was just clicked on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文件点击是一个简单的问题。在这种情况下，我们只需要获取包含文件名的文本字段元素，并将其内容更改为刚刚点击的文件名。
- en: 'All of this works perfectly for forward-traversal, but what if we want to go
    backwards? The parent directory element helps us out here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对于向前遍历都工作得很好，但如果我们想向后移动呢？父目录元素在这里帮了我们大忙：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, it simply comes down to basic string manipulation. The very last instance
    of the forward slash character is first attempted to be located inside the directory
    string. If one is found, the string is simply *clipped* at that point, in order
    to drop everything that comes after it. The shortened path is then set as the
    current directory, where the rest of the magic that we've already covered happens.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，这仅仅归结为基本的字符串操作。首先尝试在目录字符串中找到最后一个正斜杠字符。如果找到了，字符串就简单地在这个点被*剪切*，以丢弃其后的所有内容。然后将缩短的路径设置为当前目录，在那里发生我们之前已经覆盖的其余魔法。
- en: 'The last piece of the puzzle in making this work is handling the button press
    action:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切工作起来的最后一部分是处理按钮点击动作：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we need to make sure the action callback is actually set. If it is,
    it gets invoked with the path to the currently selected file as its argument.
    The only other action button we have to worry about after this point is the close
    button:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保动作回调确实被设置。如果设置了，它将使用当前选中文件的路径作为其参数来调用。在此之后，我们唯一需要担心的其他动作按钮就是关闭按钮：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It simply invokes the `Hide()` method, which is covered here, along with its
    counterpart:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用`Hide()`方法，该方法在本节中有所介绍，以及其对应的方法：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When an interface is hidden, it's simply set to inactive. Showing it requires
    setting it back to being active, except we also want to position it in the absolute
    centre of the screen in this instance. In addition to that, it is a good idea
    to refresh its content, as the file structure may have changed while it was hidden.
    Lastly, the interface is focused, in order to bring it to the front of the drawing
    queue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个界面被隐藏时，它只是被设置为不活动状态。显示它需要将其重新设置为活动状态，但在这个例子中，我们还想将其定位在屏幕的绝对中心。此外，刷新其内容也是一个好主意，因为文件结构可能在它被隐藏时发生了变化。最后，界面被聚焦，以便将其带到绘图队列的前面。
- en: 'The final bits of helpful code for this class consist of these methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一些有用的代码包括这些方法：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: They help our other classes interface with this one more easily, by allowing
    them to determine if the file manager is in `Save` or `Load` mode, and to switch
    between the two.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通过允许它们确定文件管理器是否处于`保存`或`加载`模式，并在两者之间切换，帮助我们的其他类更容易地与这个类接口。
- en: Loading files in a separate thread
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单独的线程中加载文件
- en: 'We have covered the threaded worker base class previously in [Chapter 1](ch01.html
    "Chapter 1. Under the Hood - Setting up the Backend"), *Under the Hood - Setting
    up the Backend*. This is exactly where it will come in handy. In order to make
    the application seem more user-friendly, we want to render a nice loading bar
    that shows progress while the files are being loaded. Let us start by first defining
    a data type, used to store file paths that need to be loaded:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。内部机制 - 设置后端")中介绍了线程工作基类，*内部机制 - 设置后端*。这正是它将派上用场的地方。为了使应用程序看起来更用户友好，我们想要渲染一个漂亮的加载条，在文件加载时显示进度。让我们首先定义一个数据类型，用于存储需要加载的文件路径：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `size_t` here represents the number of lines that are in the file, which
    makes it easy for us to determine the current loading progress. With that out
    of the way, let us work on the header file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`size_t`表示文件中的行数，这使得我们很容易确定当前的加载进度。处理完这一点后，让我们来处理头文件：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Any `FileLoader` class in our code base needs to implement the `ProcessLine`
    method, which simply defines what needs to happen as each individual line of the
    file is being parsed. If necessary, it can also take advantage of `SaveToFile`,
    which, as the name states, defines the process of writing the class data out,
    and `ResetForNextFile`. The latter method is invoked after every file that has
    finished loading, in order to give derivative classes a chance to clean up their
    internal state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码库中的任何`FileLoader`类都需要实现`ProcessLine`方法，该方法简单地定义了在解析文件的每一行时需要发生什么。如果需要，它还可以利用`SaveToFile`，正如其名称所表明的，它定义了将类数据写出的过程，以及`ResetForNextFile`。后者方法在加载完每个文件后调用，以便给派生类一个清理其内部状态的机会。
- en: As far as data members go, we have a list of loader paths that are to be loaded,
    the number of total lines of all files that are supposed to be parsed, and the
    number of the current line being read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就数据成员而言，我们有一个要加载的加载器路径列表，要解析的所有文件的行总数，以及正在读取的当前行数。
- en: Implementing the file loader
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现文件加载器
- en: 'Let us start simply, and cover the one-liner methods first:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始，首先介绍单行方法：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The constructor simply initializes a few of the class data members to their
    default values. The `AddFile()` method inserts the argument to the file container
    with the line count *zero*. The next two methods are simple getters, while the
    last two are not even implemented, as they are optional.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是将一些类数据成员初始化为其默认值。`AddFile()` 方法将参数插入到文件容器中，行计数为零。接下来的两个方法是简单的获取器，而最后的两个方法甚至尚未实现，因为它们是可选的。
- en: 'Next, let us work on the method that will actually be running in a thread and
    parse the file information:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理将在线程中实际运行的解析文件信息的方法：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, a private method for counting all file lines is invoked. This is necessary,
    as we want to be able to calculate our progress, and knowing how much work there
    is in total is needed for that. If after this method is called, the total number
    of lines is zero, we simply return as there is nothing to process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用一个用于计算所有文件行数的私有方法。这是必要的，因为我们想要能够计算我们的进度，而知道总工作量是必要的。如果调用此方法后，总行数为零，我们简单地返回，因为没有要处理的内容。
- en: We then enter a loop that runs once for each file on the list. The class is
    reset for new file iteration, and a line from the input stream is created. The
    number of lines remaining to be processed is created, and another loop is entered
    that will execute once for each line in the file. Our `sf::Mutex` object is then
    locked in order to safely manipulate the two line data members that are used for
    progress tracking.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入一个循环，为列表中的每个文件运行一次。类被重置以进行新的文件迭代，并从输入流中创建一个行。创建剩余要处理的行数，然后进入另一个循环，该循环为文件中的每行执行一次。然后锁定我们的`sf::Mutex`对象，以安全地操作用于进度跟踪的两个行数据成员。
- en: If the first character of our line is a pipe, `|`, it means we ran into a commented
    line and should just skip the current iteration. Otherwise, an `std::stringstream`
    of the current line is created and passed into the pure virtual `ProcessLine()`
    method, which is encapsulated in an `if` statement to catch a possible failure,
    in which case the remainder of lines inside the current file are simply added
    to the current line counter and the loop is broken out of.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们行的第一个字符是一个管道`|`，这意味着我们遇到了一条注释行，应该跳过当前迭代。否则，创建一个包含当前行的`std::stringstream`并将其传递给封装在`if`语句中的纯虚`ProcessLine()`方法，以捕获可能出现的失败情况，在这种情况下，当前文件中剩余的行将简单地添加到当前行计数器中，并跳出循环。
- en: Once the processing of all files is complete, the `Done()` method is invoked
    in order to terminate the thread and let the outside code know we've finished.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完所有文件，将调用`Done()`方法来终止线程，并让外部代码知道我们已经完成。
- en: 'Another equally as important process is counting the lines of all file entries
    inside this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个同样重要的过程是计算这个类中所有文件条目的行数：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one is fairly straightforward. After the two counters are zeroed out, we
    begin iterating over each path inside the file list. If the name of it is empty,
    the element is removed. Otherwise, we attempt to open the files. If that fails,
    the path is also erased. Otherwise, the file stream is requested to not skip whitespaces,
    and we enter a `sf::Mutex` lock, where the number of lines in the file stream
    is calculated using `std::count`, and added to the total line counter. The path
    iterator is then moved forward, and the file is closed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法相当直接。在两个计数器归零后，我们开始遍历文件列表中的每个路径。如果它的名字为空，则移除该元素。否则，我们尝试打开文件。如果失败，则也删除该路径。否则，请求文件流不要跳过空白字符，并进入一个`sf::Mutex`锁，其中使用`std::count`计算文件流中的行数，并将其添加到总行计数器中。然后，路径迭代器向前移动，文件被关闭。
- en: The loading state
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载状态
- en: 'The last piece of the threaded file loading puzzle is the loading state. In
    order to avoid other logic going on and simply focus on the graphical progress
    representation, it''s a good idea to just switch to a dedicated state that will
    handle all loading logic inside it. Let us begin by defining a data type for holding
    pointers to `FileLoader*` instances:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 线程化文件加载的最后一块是加载状态。为了避免其他逻辑的干扰并专注于图形进度表示，切换到一个专门的状态来处理其中的所有加载逻辑是个好主意。让我们首先定义一个用于存储指向`FileLoader*`实例指针的数据类型：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The actual loading state header will end up looking something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的加载状态头文件最终看起来可能像这样：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we have one event callback method, a couple of helper methods,
    the container for loader pointers, an instance of `sf::Text` and `sf::RectangleShape`
    to represent the loading bar, a number to represent the progress percentage, and
    the number of lines inside all files we originally started with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个事件回调方法，几个辅助方法，用于存储加载指针的容器，一个`sf::Text`和`sf::RectangleShape`的实例来表示加载条，一个表示进度百分比的数字，以及我们最初开始的所有文件中的行数。
- en: Implementing the loading state
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现加载状态
- en: 'All of this data needs to be initialized before it being used, so let us take
    a look at the `OnCreate()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，所有这些数据都需要初始化，因此让我们看看`OnCreate()`方法：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because we are going to be using text, we need to have a font to work with.
    After one is acquired and all of the stylistic text settings are handled, we set
    up the rectangle to be exactly in the centre of the screen and register an event
    callback for proceeding out of the loading state, if the manual continue flag
    is set to `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用文本，我们需要有一个字体来工作。在获取一个字体并处理所有样式文本设置后，我们将矩形设置为正好位于屏幕中央，并注册一个事件回调以从加载状态中继续，如果手动继续标志设置为`true`。
- en: 'Destroying this state also means the event callback and the font need to be
    released:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁此状态也意味着需要释放事件回调和字体：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let us take a look at the updated logic:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看更新的逻辑：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, a check is made to determine if we are ready to exit the state, given
    all of the work that has been done. If the manual continue flag is set to `false`,
    we simply invoke the Proceed callback directly by passing `nullptr` as the `EventDetails`
    pointer, since it is not used there anyway. The update method is then returned
    from.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一次检查以确定我们是否准备好退出状态，考虑到已经完成的所有工作。如果手动继续标志设置为`false`，我们只需直接通过传递`nullptr`作为`EventDetails`指针来调用Proceed回调，因为那里根本不需要使用它。然后从更新方法返回。
- en: If we still have some work to do, the first element on the loader list is checked
    to see if it's done. If it is, the loader is removed, and if it was the last one,
    the size of the rectangle is set to match the full size of the window on the x
    axis, which shows full completion. The text in the middle is also updated to let
    the user know they need to press the spacebar key to continue. Finally, the update
    method is returned from once again, to prevent further logic from executing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还有一些工作要做，就会检查加载列表中的第一个元素，看它是否已完成。如果已完成，则从列表中移除加载器，如果它是最后一个，则将矩形的尺寸设置为与窗口在x轴上的完整尺寸相匹配，这表明已完全完成。中间的文本也会更新，以告知用户他们需要按空格键继续。最后，再次从更新方法返回，以防止执行更多逻辑。
- en: If none of those conditions were met, the first element on the loader list is
    checked to see if it has started its work. If it has not yet started, its `Begin`
    method is invoked. This is quickly followed by the percentage calculation, which
    is then used to update the text in the middle of the screen and adjust the size
    of the progress bar rectangle to match said percentage.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述条件都不满足，就会检查加载器列表中的第一个元素是否已经开始工作。如果没有开始，就会调用其`Begin`方法。紧接着是百分比计算，然后用于更新屏幕中间的文本并调整进度条矩形的尺寸以匹配该百分比。
- en: 'Drawing in this state simply comes down to two calls:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此状态下绘图简化为两个调用：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All we need to do here is render the rectangle and the text instances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的只是渲染矩形和文本实例。
- en: 'Next, let us take a look at the helper method that updates our text instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看更新我们的文本实例的辅助方法：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the text string is updated, its position is updated to be directly in
    the middle of the screen. Since updating its contents may change the bounding
    box, and thus how it is centered, a helper function inside our `Utils` namespace
    is used to center it properly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本字符串更新后，其位置被更新为屏幕正中央。由于更新其内容可能会改变边界框，从而影响其居中方式，我们在`Utils`命名空间内部使用一个辅助函数来正确地居中它。
- en: 'Next, let us calculate the actual progress of the loading procedure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们计算加载过程的实际进度：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After an absolute value of `100.f` is created, the current progress is calculated
    by first determining the progress of how many files have been already loaded out
    of the number we began with, followed by the progress of the current file being
    calculated and used to determine absolute progress, which is then returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建绝对值`100.f`之后，首先确定已加载的文件数量与开始时的数量之间的进度，然后计算当前文件的进度并用于确定绝对进度，然后返回。
- en: 'Once all of the work is done, the `Proceed()` method is invoked to return to
    the previous state:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有工作完成，就会调用`Proceed()`方法返回到上一个状态：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obviously it needs to check if the list of file loaders is actually empty first.
    If it is, the state manager is instructed to switch to the state that comes just
    before this one, which means it is the one that initiated the loading procedure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它需要首先检查文件加载器列表是否实际上为空。如果是，则指示状态管理器切换到紧接此状态之前的状态，这意味着它是启动加载过程的状态。
- en: 'Finally, what would a class be without some helper methods? Let us take a look
    at them now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个类如果没有一些辅助方法会是什么样子？现在让我们看看它们：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating the map editor state
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图编辑状态
- en: 'Now we''re finally ready to actually tackle the state, in which all of the
    map editing is going to take place. Let us take a gander at its header file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好实际处理状态了，在这个状态下，所有的地图编辑都将发生。让我们看看它的头文件：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `State_MapEditor` class is going to be the frontier that deals with the
    most general editor events. Note the highlighted data member here. We have not
    yet covered this class, but it is responsible for handling the finer aspects of
    control for this application. It will be covered in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`State_MapEditor`类将成为处理最一般编辑事件的先锋。注意这里突出显示的数据成员。我们还没有介绍这个类，但它负责处理这个应用程序的更精细的控制方面。它将在下一章中介绍。
- en: Aside from the `MapControls` class, we also have the file manager, a string
    for the path to a file that is currently being worked on, and a *boolean* flag
    that keeps track of whether the game map should be redrawn or not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`MapControls`类之外，我们还有文件管理器、一个字符串，用于当前正在处理的文件的路径，以及一个*布尔*标志，用于跟踪游戏地图是否应该被重新绘制。
- en: Implementing the state
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态
- en: 'As always, let us begin by tackling the construction of all the important data
    inside this state:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，让我们从处理这个状态中所有重要数据的构建开始：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After all of the event callbacks are set up, the file manager class is provided
    with its own callback for either loading or saving a file, as well as the starting
    directory it needs to be in. In this case, appropriately enough, it is the maps
    folder. The manager is then hidden, and another interface is loaded and positioned
    on screen. `MapEditorTop` is the control strip on the very top of the screen that
    has buttons for creating a new map, loading, saving, and exiting the application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有事件回调设置完毕后，文件管理器类被提供了它自己的回调，用于加载或保存文件，以及它需要所在的起始目录。在这种情况下，恰如其分，它是地图文件夹。然后管理器被隐藏，另一个界面被加载并放置在屏幕上。`MapEditorTop`是屏幕顶部的控制条，上面有创建新地图、加载、保存和退出应用程序的按钮：
- en: '![Implementing the state](img/image_04_002.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![实现状态](img/image_04_002.jpg)'
- en: 'Once the state is finished and is about to be destroyed, it needs to remove
    all call-backs that it set up. This can be done in the `OnDestroy()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦状态完成并且即将被销毁，它需要移除它设置的所有回调。这可以在`OnDestroy()`方法中完成：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition to callbacks, the map is also purged just before its size is set
    back to absolute zero. Since we are on the subject of callbacks, let us just cover
    most of them in a single go:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了回调之外，地图在其大小被设置回绝对零之前也会被清除。既然我们提到了回调，让我们一次性覆盖它们中的大多数：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the **New** map button is clicked, we want to invoke a special method of
    the `MapControls` class that will handle it. If the **Load** button is clicked,
    we simply switch the mode of the file manager to load, and show it on screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**新建**地图按钮时，我们希望调用`MapControls`类的一个特殊方法来处理它。如果点击**加载**按钮，我们只需将文件管理器的模式切换到加载，并在屏幕上显示它。
- en: Clicking the **Save** button can have two behaviors. First, if we are dealing
    with a fresh, new map that has not been saved yet, it is the same as clicking
    the **Save As...** button, which switches the file manager to save mode and shows
    it on screen. However, if we have loaded a map or have previously saved a new
    one, the state remembers where it was saved, as well as its name. Prompting the
    user to enter a filename again would be pointless here, so the map is simply written
    to the exact same location, with the exact same name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**按钮可能会有两种行为。首先，如果我们正在处理一个全新的地图，尚未保存，那么这和点击**另存为...**按钮是一样的，它会切换文件管理器到保存模式并在屏幕上显示。然而，如果我们已经加载了一个地图或者之前保存了一个新的地图，状态会记住它保存的位置以及它的名称。提示用户再次输入文件名在这里是毫无意义的，所以地图将简单地写入到完全相同的地点，使用完全相同的名称。
- en: Finally, if the **Exit** button is clicked, we simply switch back to the main
    menu state and remove this one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果点击**退出**按钮，我们只需切换回主菜单状态并移除这个状态。
- en: 'With the UI code out of the way, let us take a look at what needs to happen
    when a map is being loaded:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI代码处理完毕后，让我们看看在加载地图时需要发生什么：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since we want a nice loading bar to appear as a map is being read in, we are
    going to be using the loading state. After it is obtained, both the particle system
    and the map are purged. The map, which inherits from the `FileLoader` class, is
    then reset. The file path that was provided as an argument is then added to it
    to be loaded, and the loading state itself is set up to automatically dismiss
    itself once the loading is done. At the same time, we make sure that the map is
    going to be re-drawn as the map editor state resumes, and that it remembers the
    path of the map if it is to be saved later. Finally, we can switch to the loading
    state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在读取地图时出现一个漂亮的加载条，我们将使用加载状态。在获取到它之后，粒子系统和地图都会被清除。地图继承自`FileLoader`类，然后被重置。提供的文件路径随后被添加到其中以进行加载，加载状态本身被设置为在加载完成后自动消失。同时，我们确保地图将在地图编辑器状态恢复时重新绘制，并且如果将来要保存，它将记住地图的路径。最后，我们可以切换到加载状态。
- en: 'Next, let us work on the code that is responsible for saving the map:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看负责保存地图的代码：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is much simpler than the previous method. The path is simply passed to
    the `SaveToFile` method of the game map class, and stored for later use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前的方法简单得多。路径只是简单地传递给游戏地图类的`SaveToFile`方法，并存储起来以供以后使用。
- en: 'The actual callback of the file manager that mediates between the load and
    save methods can be implemented like :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件管理器的实际回调函数，它介于加载和保存方法之间，可以像这样实现：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Depending on the mode the file manager is in, the appropriate method is called
    with the path being passed in as the argument. The actual interface is then hidden.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件管理器所处的模式，将调用适当的方法，并将路径作为参数传递。实际的接口随后被隐藏。
- en: 'Because we want to re-draw the map after it was loaded, the perfect place for
    that logic is inside the `Activate()` method, as it gets called right when a state
    is switched to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在加载后重新绘制地图，因此逻辑的最佳位置是在`Activate()`方法内部，因为它在状态切换时立即被调用：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the `m_mapRedraw` flag is not on, there is no need to do anything at this
    point. Otherwise, we want to redraw the map and provide the `mapControls` class
    with the tile-sheet texture name, so that it can perform its own logic, such as,
    for example, tile selection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_mapRedraw`标志未开启，此时无需做任何事情。否则，我们希望重新绘制地图，并向`mapControls`类提供瓦片纹理的名称，以便它能够执行自己的逻辑，例如，例如，瓦片选择。
- en: 'Next, let us take a look at what needs to be updated while the application
    is in this state:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在应用程序处于此状态时需要更新什么：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alongside the `mapControls` class, the game map, ECS system manager, and the
    particle system also need to be updated, because we are going to be using all
    of these classes while building maps. Predictably enough, these are the same objects
    that also need to be drawn:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`mapControls`类之外，游戏地图、ECS系统管理器和粒子系统也需要更新，因为我们在构建地图时将使用所有这些类。不出所料，这些也是需要绘制相同对象：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the `from` and `to` variables. The `mapControl` class is going to provide
    us with a way to switch between layers/elevations, so we need to obtain that information
    before anything is rendered, in order to make sure only the appropriate layers
    are drawn on screen. `DrawSelectedLayers` simply returns a *boolean* value that
    determines whether or not all layers should be drawn, or just the selected ones.
    Once the loop has iterated over the appropriate elevations, we make sure to draw
    the remaining particles that are above the maximum elevation, provided, of course,
    everything needs to be rendered. This is topped off by the map controls being
    drawn over everything else.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`from`和`to`变量。`mapControl`类将为我们提供在层/海拔之间切换的方法，因此我们需要在渲染任何内容之前获取这些信息，以确保只绘制屏幕上的适当层。`DrawSelectedLayers`简单地返回一个布尔值，以确定是否应该绘制所有层或仅绘制选定的层。一旦循环遍历了适当的层，我们确保绘制所有高于最大海拔的剩余粒子，当然，前提是所有内容都需要被渲染。地图控制被绘制在其他所有内容之上，作为收尾。
- en: 'For other outside communications with this class, we provide two basic setter
    methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与其他类的外部通信，我们提供了两个基本的设置方法：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are going to be used inside the control classes to communicate events,
    such as a new map being created, or it needing to be re-drawn.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在控制类内部使用，用于通信事件，例如创建新地图或需要重新绘制。
- en: Building the control mechanism
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建控制机制
- en: 'While building maps, the user tends to run into situations where they need
    more than just a tile being placed where the mouse clicks. It would definitely
    be useful to have tools that would enable them to freely pan around, select chunks
    of the map for deletion or copying, erase them and so on. Our control class is
    going to serve this exact purpose. It will provide a set of tools that can be
    used for multiple different situations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建地图时，用户往往会遇到需要不仅仅是在鼠标点击的位置放置瓦片的情况。拥有能够让他们自由平移、选择地图的一部分进行删除或复制、擦除等的工具肯定会很有用。我们的控制类将正好起到这个作用。它将提供一套可用于多种不同情况下的工具：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding control mode enumeration represents a couple of the most common
    tools that come in a variety of different pieces of software. We''re going to
    implement some of them here, and leave the rest up to you! In the end, we should
    have a control interface that looks a little like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制模式枚举代表了一些在多种不同软件中常见的工具。我们将在这里实现其中一些，其余的留给你们！最终，我们应该有一个看起来像这样的控制界面：
- en: '![Building the control mechanism](img/image_04_003.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![构建控制机制](img/image_04_003.jpg)'
- en: 'Let us get to actually writing out the header for the control class. For clarity,
    we are going to be discussing its methods and data members separately, starting
    with the member functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写控制类的头文件。为了清晰起见，我们将分别讨论其方法和数据成员，从成员函数开始：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to all of the helper methods for setting and getting the class
    parameters, we have a whole bunch of event callbacks, as well as individual update
    methods for every kind of map tool we''re going to be working with. Next, let
    us take a look at the data members we are going to be working with:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置和获取类参数的所有辅助方法之外，我们还有一大堆事件回调，以及针对我们将要使用的每种地图工具的单独更新方法。接下来，让我们看看我们将要工作的数据成员：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Alongside the `ControlMode` that this class is currently in, we are also going
    to be storing a couple of flags. The `m_action` flag will be used with tools,
    as well as `m_secondaryAction`. The former simply denotes whether the left mouse
    button is pressed or not, while the latter is used with an action that can only
    happen once the mouse position has changed. This will prove useful when we are
    trying to optimize certain things to not happen, unless they absolutely have to.
    The last two flags signify whether we are currently right-click panning, and whether
    only the selected layers should be drawn on screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个类当前所在的`ControlMode`之外，我们还将存储几个标志。`m_action`标志将与工具一起使用，以及`m_secondaryAction`。前者简单地表示左鼠标按钮是否被按下，而后者用于只有在鼠标位置改变后才能发生的行为。这将在我们尝试优化某些事情以避免它们发生时非常有用。最后两个标志表示我们是否正在使用右键进行平移，以及是否只应在屏幕上绘制选定的图层。
- en: Below that, there are a couple of 2D vectors, used to store mouse information,
    such as its current position, where a left-click first happened, the difference
    between the current and last frame in the mouse position, its current position
    in tile coordinates, and its starting position in tile coordinates. Additionally,
    we also have a floating point value for the current zoom factor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，有一些用于存储鼠标信息的二维向量，例如其当前位置、左键第一次点击的位置、鼠标位置当前帧与上一帧之间的差异、其在瓦片坐标中的当前位置以及其在瓦片坐标中的起始位置。此外，我们还有一个用于当前缩放因子的浮点值。
- en: For the brush that will be used to paint with, we simply use a `TileMap` structure,
    just like the game map class does. Since the brush is going to have to be drawn
    on screen, we need to store a texture for it, as well as another drawable object
    that will be used to show it. Finally, a `sf::RectangleShape` type is going to
    more than suffice for showing the boundaries of the map on screen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将要用来绘画的刷子，我们简单地使用一个`TileMap`结构，就像游戏地图类所做的那样。由于刷子将要被绘制在屏幕上，我们需要为其存储一个纹理，以及另一个将被用来显示它的可绘制对象。最后，一个`sf::RectangleShape`类型将足以显示地图在屏幕上的边界。
- en: 'Additional code separation, especially when code is becoming quite lengthy,
    is always a good idea. For this purpose, other non-general-control logic is going
    to be spread out into two additional interface classes: a tile selector, and the
    selection options. A tile selector is a simple window that shows the entire tile-sheet
    and allows the user to select tiles they want to paint with, while selection options
    is a separate interface that provides us with a myriad of settings that can be
    tweaked when specific things on screen are selected. Both of these classes are
    going to be covered in the next chapter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码变得相当长时，进行额外的代码分离总是一个好主意。为此，其他非通用控制逻辑将被分散到两个额外的接口类中：一个瓦片选择器和选择选项。瓦片选择器是一个简单的窗口，显示整个瓦片图集，并允许用户选择他们想要绘制的瓦片，而选择选项是一个单独的接口，它为我们提供了一系列设置，可以在屏幕上选择特定事物时进行调整。这两个类都将在下一章中介绍。
- en: Lastly, we have another interface, named `m_mapSettings`, the logic of which
    is going to be handled within the `MapControls` class. When creating new maps,
    we need a neat little window that is going to allow us to configure the size of
    the map, its default friction value, and the name of the tile-sheet it is going
    to be using. This is exactly the purpose the map settings interface is going to
    serve.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个名为 `m_mapSettings` 的接口，其逻辑将在 `MapControls` 类中处理。当创建新地图时，我们需要一个整洁的小窗口，它将允许我们配置地图的大小、默认摩擦值以及它将要使用的瓦片图集的名称。这正是地图设置接口要服务的目的。
- en: Implementing controls
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现控制
- en: 'There are quite a few data members to initialize, so let us take a look at
    how the constructor manages it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多数据成员需要初始化，让我们看看构造函数是如何管理它们的：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, there is quite a lot going on here. Let us zip through it section
    by section. Right after the arguments of the constructor are processed, we set
    up the data members of this class to hold their initial values. Shortly after
    that, the custom interface classes get set up, with all the necessary arguments
    being passed to their constructors. For now, we are not going to be worrying about
    them, as they will be covered in the next chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里有很多事情在进行。让我们逐节快速浏览一下。在处理完构造函数的参数后，我们设置这个类的数据成员以保存它们的初始值。在那之后不久，自定义接口类被设置，所有必要的参数都传递给了它们的构造函数。目前，我们不会担心它们，因为它们将在下一章中介绍。
- en: 'Let us take a look at the actual constructor body next:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际的构造函数体：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Right after all event callbacks get set up, we begin working on the interfaces.
    The actual tools interface is loaded and positioned on screen, as well as the
    new map settings window, which we are going to keep track of by storing its pointer
    as one of our data members. It gets positioned in the centre of the screen and
    set as inactive for the time being.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有事件回调设置完毕后，我们开始处理接口。实际的工具界面被加载并放置在屏幕上，以及新的地图设置窗口，我们将通过将其指针存储为我们数据成员之一来跟踪它。它被放置在屏幕中央，并暂时设置为不活动状态。
- en: The next segment simply deals with the stylistic aspects of the brush drawable,
    as well as the map boundaries rectangle. These values can obviously be customized
    to look completely different.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分仅仅处理画笔可绘制的风格方面以及地图边界矩形。显然，这些值可以被定制以看起来完全不同。
- en: Lastly, we need to make sure to populate the drop-down element for sheet selection
    inside the new map settings interface. After the element is obtained and cleared
    of all other entries, the list of all filenames that are of type `.tilesheet`
    inside the appropriate location is obtained and iterated over, stripping away
    the file format from each one and adding it to the drop-down list, which is then
    re-drawn to reflect all changes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保在新的地图设置界面中填充用于选择工作表的下拉元素。在获取元素并清除所有其他条目后，从适当位置获取所有类型为 `.tilesheet`
    的文件名列表，并对每个文件名进行迭代，移除文件格式并将其添加到下拉列表中，然后重新绘制以反映所有更改。
- en: Keep in mind that all interfaces and callbacks that were created here need to
    be removed, which is all that happens in the destructor. For that specific reason,
    we are not going to be covering that here, as it is redundant.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这里创建的所有接口和回调都需要被移除，这就是析构函数中发生的一切。正因为如此，我们在这里不会介绍它，因为它是不必要的。
- en: 'Let us take a look at what needs to happen when this class is being updated:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当这个类被更新时需要发生什么：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we handle any possible changes in size of the map class. The map boundary
    rectangle is updated here to reflect them. Next, we must make sure the mouse is
    updated properly. All of that logic is contained within the `UpdateMouse` method,
    which is invoked here. Finally, depending on the current `ControlMode`, we need
    to invoke the appropriate update method for the specific tool that is selected.
    The pan tool is special in a way, because it will be updated when it is selected
    as a tool, and when the right mouse button is being pressed as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理地图类大小的任何可能变化。地图边界矩形在这里更新以反映这些变化。接下来，我们必须确保鼠标被正确更新。所有这些逻辑都包含在`UpdateMouse`方法中，该方法在此处被调用。最后，根据当前的`ControlMode`，我们需要调用所选特定工具的适当更新方法。平移工具是特殊的，因为它在选择为工具时以及当按下鼠标右键时都会被更新。
- en: 'Drawing all of these objects may be simpler than you think:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制所有这些对象可能比你想象的要简单：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this specific instance, all we need to render is the rectangle of the `mapBoundaries`,
    the brush, if the `ControlMode` is set to `Brush`, and the `SelectionOptions`
    class, which has its own `Draw` method. More on that will be covered in the next
    chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定实例中，我们只需要渲染`mapBoundaries`的矩形、画笔，如果`ControlMode`设置为`Brush`，以及具有自己`Draw`方法的`SelectionOptions`类。关于这一点将在下一章中详细说明。
- en: 'Next, let us implement everything necessary to keep track of all the relevant
    mouse information:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现所有必要的功能来跟踪所有相关的鼠标信息：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After the current mouse position is obtained, it is used to compute the coordinate
    difference between the current frame and the previous one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 获得当前鼠标位置后，它被用来计算当前帧和前一帧之间的坐标差异。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the mouse difference is expressed in **global coordinates**, we must remember
    to multiply them by the *zoom factor*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于鼠标差异是用**全局坐标**表示的，我们必须记住将它们乘以*缩放因子*。
- en: The mouse position is then stored for the next frame, so this process can take
    place all over again. The current `sf::View` is then obtained for calculating
    the current **global** position of the camera. From this, we can calculate the
    global mouse position (adjusted for zoom, of course), and the mouse tile position,
    which is simply the tile that's being pointed at.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将鼠标位置存储到下一帧，这样这个过程可以再次发生。然后获取当前的`sf::View`以计算摄像机的当前**全局**位置。从这一点，我们可以计算全局鼠标位置（当然，调整了缩放），以及鼠标瓦片位置，这仅仅是当前指向的瓦片。
- en: The current mouse tile position is then checked against the calculated result
    for being different. If it is, and the left mouse button is currently being pressed
    (as shown by the `m_action` data member), the secondary action flag is turned
    on. The mouse tile position is then stored for the next frame.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查当前鼠标瓦片位置是否与计算结果不同。如果是，并且当前左鼠标按钮被按下（如`m_action`数据成员所示），则次要动作标志被打开。然后鼠标瓦片位置被存储以供下一帧使用。
- en: 'The next method in the mouse variety deals with left and right clicks, and
    can be implemented like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标类中的下一个方法处理左右点击，可以像这样实现：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Because something else may have already processed a mouse event, we need to
    check for the event details that get submitted as an argument. We do not want
    to accidentally paint some tiles on the map if we are simply interacting with
    an interface, for example. Next, the key code of the event is checked to see whether
    it is the left mouse button. If it is not, all we need to worry about is setting
    the right-click pan flag to `true` and returning.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可能已经有其他东西处理了鼠标事件，我们需要检查作为参数提交的事件细节。如果我们只是与界面交互，我们不希望意外地在地图上绘制一些瓦片。接下来，检查事件的关键代码以确定它是否是左鼠标按钮。如果不是，我们只需要担心将右键点击平移标志设置为`true`并返回。
- en: If we indeed have a left-click, on the other hand, the current mouse position
    is stored as both the starting and the current positions. A very similar process
    to updating the mouse takes place here, leading to the calculation of the global
    mouse coordinates. They are then passed into the `MouseClick()` method of the
    selection options class, which returns a *boolean* flag, signifying whether any
    entities or particle emitters have been selected. We will be dealing with that
    in the next chapter. If that is not the case, however, both the action and secondary
    action flags are set to `true` in order to use the currently selected tool.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实有一个左键点击，另一方面，当前鼠标位置被存储为起始位置和当前位置。这里发生了一个与更新鼠标位置非常相似的过程，导致全局鼠标坐标的计算。然后，这些坐标被传递到选择选项类的`MouseClick()`方法中，该方法返回一个*布尔*标志，表示是否选择了任何实体或粒子发射器。我们将在下一章中处理这个问题。然而，如果情况不是这样，动作标志和次要动作标志都将设置为`true`，以便使用当前选定的工具。
- en: 'In the same way that for every action there is an equal and opposite reaction,
    for each click we need to have a release:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每个动作都有一个相等且相反的反应一样，对于每个点击，我们都需要有一个释放：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All we need to worry about here is resetting all of the action flags that are
    used while the mouse is active. This includes the right-click panning, and both
    action flags. The selection options interface also needs to be notified of a release.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要重置在鼠标活动期间使用的所有动作标志。这包括右键平移和两个动作标志。选择选项接口还需要通知释放事件。
- en: 'A neat little feature that is going to help out a lot is being able to zoom
    in and out. It is handled here as an event:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常实用的功能是能够放大和缩小。这里将其处理为一个事件：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If this event has not already been processed by something else, we proceed to
    calculate the amount of zoom that needs to happen. A `float factor` value is defined
    here, and is multiplied by the change in the mouse wheel position. In order for
    it to be treated as a scale factor, it is subtracted from `1.f`, and then used
    to zoom in the view. Finally, in order to keep track of the current zoom value,
    we must multiply it by the said scale factor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个事件还没有被其他东西处理，我们就继续计算需要发生的缩放量。这里定义了一个`float factor`值，并将其乘以鼠标滚轮位置的变化。为了将其视为一个缩放因子，我们从`1.f`中减去它，然后用于放大视图。最后，为了跟踪当前的缩放值，我们必须将其乘以这个缩放因子。
- en: 'The next event we need to worry about is one of the tools being selected:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的下一个事件是选择其中一个工具：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is quite simple, as we basically map the names of elements to their `ControlMode`
    counter-parts. The appropriate mode is then selected on the bottom.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为我们基本上将元素的名称映射到它们的`ControlMode`对应物。然后在底部选择适当的模式。
- en: 'Speaking of tools, each one of them has their own individual update method.
    Let us begin by taking a look at how the pan tool is updated:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 说到工具，每个工具都有自己的更新方法。让我们首先看看平移工具是如何更新的：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We obviously do not want the screen to move if the mouse is not being clicked,
    or if the mouse position delta between frames is absolute zero. Given that both
    those conditions are satisfied, however, all we need to do is move the centre
    of the view to a different location. This location is calculated by adding its
    current position with the mouse position difference, which has to have its sign
    flipped. We do this, because as the mouse is clicked and moved left, for example,
    the view needs to shift right in order to feel natural. The same is true for the
    *x* axis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不想在鼠标没有被点击，或者鼠标位置在帧之间的变化是绝对零的情况下移动屏幕。然而，如果这两个条件都满足，我们只需要将视图的中心移动到不同的位置。这个位置是通过将其当前位置与鼠标位置差异相加来计算的，这个差异的符号需要翻转。我们这样做是因为，当鼠标点击并移动到左边，例如，视图需要向右移动以感觉自然。对于*x*轴也是同样的道理。
- en: 'In the case of a brush tool, the logic goes like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于画笔工具，逻辑是这样的：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, the global position of the tile the mouse is over currently is calculated,
    which the brush drawable is set to match. Doing it like this creates a feel of
    the brush being locked to a grid. Another method is then invoked for placing the
    tiles:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算鼠标当前所在的瓦片的全局位置，并将画笔可绘制设置为匹配。这样做会给人一种画笔被锁定到网格上的感觉。然后调用另一个方法来放置瓦片：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first and most obvious check here is to make sure that both the primary
    and secondary actions are on. We do not want to be placing tiles if the mouse
    is not being clicked, or if it already has been clicked, but is still at the same
    location. Otherwise, we are good to go on painting, which begins by the brush
    tile map being placed on the game maps tile map at the current mouse tile position,
    starting at the lowest layer currently selected by the selection options. Even
    though we may be able to shift through elevations at ease, we still need to tell
    this method about the lowest current elevation selected, because the brush tile
    map itself still begins at elevation *0*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先和最明显的检查是确保主操作和辅助操作都处于开启状态。我们不希望在鼠标未被点击或已经点击但仍在同一位置时放置瓦片。否则，我们可以开始绘画，这从将画笔瓦片图放置在当前鼠标瓦片位置的游戏地图瓦片图上开始，从当前由选择选项选择的最低层开始。尽管我们可以轻松地切换高度，但我们仍然需要告诉这个方法关于当前选定的最低高度，因为画笔瓦片图本身仍然从高度*0*开始。
- en: After the map has been updated, the tile coordinate range to be redrawn is calculated
    and passed to the `MapControls` class to be rendered on screen. We do not want
    to re-draw the whole map, as that would take more time and introduce latency.
    Lastly, the secondary action flag is set to `false` in order to indicate that
    a placement has been made at these coordinates already.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 地图更新后，计算要重新绘制的瓦片坐标范围，并将其传递给`MapControls`类以在屏幕上渲染。我们不希望重新绘制整个地图，因为这会花费更多时间并引入延迟。最后，将辅助操作标志设置为`false`，以指示在这些坐标上已经进行了放置。
- en: 'The next tool we need to update is the selection box:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的下一个工具是选择框：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, all of that logic is handled by the `SelectionOptions` class.
    For now, we simply need to worry about invoking this method
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有这些逻辑都是由`SelectionOptions`类处理的。目前，我们只需要关注调用这个方法。
- en: 'The same `SelectionOptions` interface may be responsible for manipulating our
    brush, which means we need to have a method for redrawing it to reflect changes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`SelectionOptions`接口可能负责操作我们的画笔，这意味着我们需要一个方法来重新绘制它以反映更改：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, the real pixel brush size is calculated from the size of its tile map.
    If it does not match the current dimensions of the texture that represents it,
    the texture needs to be re-created. Once that is taken care of, the texture is
    cleared to all transparent pixels, and we begin iterating over each tile and layer
    inside said brush. Given it is a valid tile that has proper ties to an information
    structure that holds its sprite for rendering, the latter is set to the correct
    position on the texture and drawn to it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，真正的像素画笔大小是从其瓦片图的尺寸计算得出的。如果它与表示它的纹理的当前维度不匹配，则需要重新创建纹理。一旦处理完毕，纹理就会被清除到所有透明像素，然后我们开始遍历画笔内部的每个瓦片和层。鉴于这是一个有效的瓦片，并且与包含其精灵以供渲染的信息结构有适当的关联，后者被设置为纹理上的正确位置并绘制到上面。
- en: Once this is done, the texture's display method is invoked to show all the changes,
    and the drawable object of the brush is bound to the texture again. The drawables
    size and texture rectangle is also reset, because the dimensions of the texture
    could have changed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，将调用纹理的显示方法以显示所有更改，并将画笔的可绘制对象再次绑定到纹理上。同时，可绘制对象的大小和纹理矩形也会重置，因为纹理的尺寸可能已经改变。
- en: 'In this type of an application, it''s important to have a quick and easy way
    of deleting something that''s currently selected. For this, we''re going to be
    processing the event that''s bound to the *Delete* key on your keyboard:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类应用程序中，有一个快速且简单的方法来删除当前选定的内容非常重要。为此，我们将处理绑定到键盘上的*Delete*键的事件：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is a very simple callback. It simply checks if the current `ControlMode`
    is selected, and passes its details to another callback that belongs to the `selectionOptions`
    class. It will be dealing with all removals.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的回调。它只是检查当前的`ControlMode`是否被选中，并将详细信息传递给属于`selectionOptions`类的另一个回调。它将处理所有删除操作。
- en: 'When a new tool is being selected, we must reset all data members we work with
    to their initial values in order to avoid weird bugs. This is where the `ResetTools()`
    method comes in:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择新工具时，我们必须将我们与之工作的所有数据成员重置为其初始值，以避免奇怪的错误。这就是`ResetTools()`方法的作用所在：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It simply resets certain mouse data to a default uninitialized state. The `m_selectionOptions
    Reset()` method is also invoked, so that it can deal with its own resetting. Lastly,
    the `tileSelector` interface is hidden here as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将某些鼠标数据重置为默认未初始化状态。同时也会调用`m_selectionOptions Reset()`方法，以便它可以处理自己的重置。最后，也在这里隐藏了`tileSelector`界面。
- en: 'Another useful little method is for resetting the zoom of the current view
    to a normal level:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的简单方法是重置当前视图的缩放到正常水平：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By dividing `1.f` by the current zoom factor, we obtain a scale value, which,
    when scaled by, the view returns to its normal state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`1.f`除以当前的缩放因子，我们获得一个缩放值，当缩放时，视图会返回到正常状态。
- en: 'Next, let us see what needs to happen in order for this class to change its
    `ControlMode`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个类要改变其`ControlMode`需要发生什么：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After the tools are reset, the mode passed in as the argument is stored. If
    the mode being applied is a brush, it needs to be re-drawn. Lastly, the `selectionOptions`
    class is notified of the mode change, so that it can perform its own logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具被重置后，作为参数传入的模式被存储。如果应用的模式是画笔，则需要重新绘制。最后，通知`selectionOptions`类模式已更改，以便它可以执行自己的逻辑。
- en: 'Finally, one of the last key pieces of code is the creation of a new map:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分关键代码是创建一个新的地图：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, we obtain the size values from the text-fields of the map settings interface.
    In addition to that, we also grab the friction value, as well as the current selection
    of the tile-sheet drop–down menu. If the latter is empty, we simply return, as
    no tile-sheet has been selected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从地图设置界面的文本框中获取大小值。此外，我们还获取了摩擦值，以及当前选中的瓦片集下拉菜单中的选择。如果后者为空，我们直接返回，因为没有选择瓦片集。
- en: If we do proceed, the particle system and the map both need to be purged. The
    `MapEditor` state is then notified to reset its save path, which forces the user
    to re-enter a filename when saving.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续进行，粒子系统和地图都需要进行清理。然后通知`MapEditor`状态重置其保存路径，这会强制用户在保存时重新输入文件名。
- en: The map's size is then set up, alongside the default friction value. The selected
    tile-sheet file is added for further loading in a separate thread, and its name
    is registered inside the game map's internal `TileSet` data member.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置地图的大小，以及默认的摩擦值。选定的瓦片集文件被添加到单独的线程中进一步加载，并且其名称被注册在游戏地图内部`TileSet`数据成员中。
- en: Finally, the loading state is obtained, the tile-set is added to it, and the
    manual continue flag is set to `false`, in order to make the loading screen simply
    go back to the current state after it is done. The new map settings interface
    is then hidden, and we can finally switch to the loading state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取加载状态，将瓦片集添加到其中，并将手动继续标志设置为`false`，以便在加载完成后加载屏幕简单地返回到当前状态。然后隐藏新的地图设置界面，我们最终可以切换到加载状态。
- en: 'In case a mistake happens, the user must have a way to close the new `m_mapSettings`
    interface:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，用户必须有一种方法来关闭新的`m_mapSettings`界面：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This callback gets invoked when the **close** button of the interface is pressed.
    All it does is simply hiding it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当界面上的**关闭**按钮被按下时，此回调会被调用。它所做的只是简单地隐藏它。
- en: 'Finally, we have a bunch of setters and getters that do not add up to much
    on their own, but are useful in the long run:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一系列设置器和获取器，它们单独看起来并不重要，但从长远来看是有用的：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You may have noticed that we have not yet covered the bucket and eraser tools.
    This is what is usually referred to as homework, which should serve as good practice:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们尚未介绍桶和橡皮擦工具。这通常被称为作业，应该作为良好的练习：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Keep in mind that as we have not yet implemented everything that makes the map
    editor tick, this should probably wait until the next chapter is wrapped up.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于我们尚未实现使地图编辑器正常工作的所有功能，这可能需要等到下一章完成后再进行。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced and implemented the concept of graphical
    file management, as well as laid the foundations for one of the most important
    tools a small RPG-style game uses. There is still a lot left to do before we can
    start reaping the benefits of having proper tools. In the next chapter, we will
    be covering the finishing touches of the map editor, as well as implementing a
    different tool for managing entities. See you there!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了并实现了图形文件管理的概念，并为小型RPG风格游戏使用的重要工具奠定了基础。在我们能够开始享受拥有适当工具的好处之前，还有很多工作要做。在下一章中，我们将介绍地图编辑器的收尾工作，以及实现用于管理实体的不同工具。那里见！
