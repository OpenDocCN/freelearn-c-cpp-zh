- en: Building a Voice-Controlled Robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个语音控制的机器人
- en: In 2012, I wanted to create a robot that could be controlled by an Android smartphone.
    At that time, however, I did not know much about Android programming. To my surprise,
    I came across an amazing website called **App Inventor** ([http://www.appinventor.org/](http://www.appinventor.org/)),
    which allows users to develop Android applications by joining programming blocks
    in the same way as joining pieces in a puzzle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，我想创建一个可以由Android智能手机控制的机器人。然而，当时我对Android编程并不了解。令我惊讶的是，我发现了一个名为App Inventor的神奇网站（[http://www.appinventor.org/](http://www.appinventor.org/)），它允许用户通过将编程块连接在一起的方式来开发Android应用，就像拼图一样。
- en: 'In this final chapter, we will use the App Inventor website and learn to control
    our robot with an Android smartphone using our voice as an input. We will cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将使用App Inventor网站，并学习如何使用我们的声音作为输入，用Android智能手机来控制我们的机器人。我们将涵盖以下主题：
- en: An introduction to App Inventor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Inventor简介
- en: Creating a voice application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建语音应用
- en: Pairing the Android smartphone and **Raspberry Pi** (**RPi**) via Bluetooth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过蓝牙将Android智能手机和树莓派（RPi）配对
- en: Developing the Bluetooth program for RPi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为RPi开发蓝牙程序
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: An Android smartphone running on Android version Lollipop (version number 5.0-5.1.1)
    or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Android版本Lollipop（版本号5.0-5.1.1）或更高版本的Android智能手机
- en: Raspberry Pi robot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派机器人
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从[https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09)下载。
- en: An introduction to App Inventor
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App Inventor简介
- en: App Inventor is an open source web-based application that was originally developed
    by Google. It is currently maintained by the **Massachusetts Institute of Technology**
    (**MIT**). It allows users to develop Android applications using its state-of-the-art
    graphical programming interface, which is similar to Scratch. Developers have
    to drag and drop visual blocks to create an Android app with App Inventor. The
    current version of App Inventor is referred to as **App Inventor 2** (version
    2), or **AI2**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: App Inventor是一个由Google最初开发的开源基于Web的应用程序。目前由麻省理工学院（MIT）维护。它允许用户使用类似于Scratch的最先进的图形编程界面开发Android应用程序。开发人员必须拖放可视块来创建一个App
    Inventor的Android应用。App Inventor的当前版本被称为App Inventor 2（版本2）或AI2。
- en: 'In the following diagram you can see how each programming block is connected
    to each other like a puzzle:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到每个编程块如何连接在一起，就像拼图一样：
- en: '![](img/106e3ae8-18e2-4d62-8fed-508cc292b450.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/106e3ae8-18e2-4d62-8fed-508cc292b450.png)'
- en: In this section, we'll look at how to create an App Inventor account and then
    create our first Android app using App Inventor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何创建App Inventor帐户，然后使用App Inventor创建我们的第一个Android应用。
- en: Creating a Talking Pi Android app
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Talking Pi Android应用
- en: 'Talking Pi is a simple Android application in which you type text inside a
    textbox and the smartphone displays and reads out the text. Before creating this
    Android app, we first need to get access to the App Inventor 2 dashboard. The
    final layout of the Talking Pi application will look somewhat like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Talking Pi是一个简单的Android应用程序，您可以在文本框中输入文本，智能手机会显示并朗读文本。在创建此Android应用程序之前，我们首先需要访问App
    Inventor 2仪表板。Talking Pi应用程序的最终布局将如下所示：
- en: '![](img/262e76be-be85-4a38-8b33-c4bcea156dab.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/262e76be-be85-4a38-8b33-c4bcea156dab.png)'
- en: 'To create Android applications using App Inventor 2, you must have a Gmail
    account. If you have one already, sign in on a browser of your choice. If you
    do not have one, you will need to create one. Let''s now look at the steps for
    linking App Inventor 2 with your Gmail account:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用App Inventor 2创建Android应用程序，您必须拥有一个Gmail帐户。如果您已经有一个，请在您选择的浏览器上登录。如果没有，请创建一个。现在让我们看看将App
    Inventor 2与您的Gmail帐户链接的步骤：
- en: 'After signing in, go to the following link: [ai2.appinventor.mit.edu/](http://ai2.appinventor.mit.edu/).
    If you have signed in with multiple Gmail accounts inside your browser, you''ll
    need to select one ID in particular:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，转到以下链接：[ai2.appinventor.mit.edu/](http://ai2.appinventor.mit.edu/)。如果您在浏览器中使用多个Gmail帐户登录，您需要选择一个特定的ID：
- en: '![](img/6e92662e-a4f0-4f96-ab82-217da900b7de.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e92662e-a4f0-4f96-ab82-217da900b7de.png)'
- en: 'Next, you''ll need to agree to the AI2 terms of service. You''ll then be ready
    to create your Talking Pi application. To create a new Android application project,
    click on the Start new project button as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要同意AI2的服务条款。然后，您将准备好创建Talking Pi应用程序。要创建一个新的Android应用程序项目，请单击“开始新项目”按钮，如下所示：
- en: '![](img/cd3bf335-2e0c-45d2-97e5-0502451e4489.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd3bf335-2e0c-45d2-97e5-0502451e4489.png)'
- en: 'Next, name the project `TalkingPi` and then click OK:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将项目命名为`TalkingPi`，然后单击确定：
- en: '![](img/370d2f1e-a6ed-4e83-a8a8-8dbbe810fbe8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/370d2f1e-a6ed-4e83-a8a8-8dbbe810fbe8.png)'
- en: 'After creating your project, you will see the following four main panels inside
    App Inventor called Palette, Viewer, Components, and Properties:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，您将在App Inventor中看到以下四个主要面板，称为Palette、Viewer、Components和Properties：
- en: '![](img/9e5e655d-b757-4d9f-81b8-1d7dbe73c611.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e5e655d-b757-4d9f-81b8-1d7dbe73c611.png)'
- en: 'Let''s now understand the workings of each of these panels as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解每个面板的工作原理：
- en: The Palette panel consists of different components such as buttons, textboxes,
    canvases, Bluetooth, a video player, and so on.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Palette面板包括不同的组件，如按钮、文本框、画布、蓝牙、视频播放器等。
- en: The Viewer panel consists of a screen in which we can drag and drop UI components
    from the Palette.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Viewer面板由一个屏幕组成，我们可以从Palette中拖放UI组件。
- en: The Components panel displays a list of visible and non-visible components that
    are added inside the screen. A button, for example, is a visible component, as
    it is visible on the screen. On the other hand, Bluetooth is a non-visible component
    as it is not visible on the screen, but it functions in the background. All invisible
    components are displayed below the screen.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件面板显示了添加到屏幕内的可见和不可见组件的列表。例如，按钮是一个可见组件，因为它在屏幕上可见。另一方面，蓝牙是一个不可见组件，因为它在屏幕上不可见，但它在后台起作用。所有不可见组件都显示在屏幕下方。
- en: The Properties panel allows us to modify the properties of the components that
    are selected in the Components panel.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性面板允许我们修改组件的属性，这些组件在组件面板中被选中。
- en: Let's now move on to designing the app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续设计应用程序。
- en: Designing the app
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序
- en: 'In our Talking Pi app, we are going to add four main components: TextBox, Button,
    Label, and TextToSpeech. The TextBox, Button, and Label components are inside
    the User Interface option. Take the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Talking Pi应用程序中，我们将添加四个主要组件：TextBox、Button、Label和TextToSpeech。TextBox、Button和Label组件位于用户界面选项中。按照以下步骤：
- en: 'You can drag the TextBox, Button, and Label components one by one inside the
    screen as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以依次将TextBox、Button和Label组件拖放到屏幕上，如下所示：
- en: '![](img/b28a61d6-d43b-4cc6-8a18-634d0fd00ac4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b28a61d6-d43b-4cc6-8a18-634d0fd00ac4.png)'
- en: 'After adding these three components, you will notice that they are aligned
    to the top-left of the screen, which looks a bit odd. To position them horizontally
    in the center of the screen, select **Screen1** from the Components panel and
    change **AlignHorizontal** to **Center**, as shown in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这三个组件后，您会注意到它们都对齐到屏幕的左上角，看起来有点奇怪。为了将它们水平定位在屏幕的中心，从组件面板中选择**Screen1**，并将**AlignHorizontal**更改为**Center**，如下截图所示：
- en: '![](img/419d3883-e216-4906-9d59-bff0f83ee91b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/419d3883-e216-4906-9d59-bff0f83ee91b.png)'
- en: 'Next, to add some spacing between the three components, we can add layout components
    in between the TextBox, Button, and Label components. You can choose either a
    HorizontalArrangement or VerticalArrangement, for example:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了在三个组件之间添加一些间距，我们可以在TextBox、Button和Label组件之间添加布局组件。例如，您可以选择HorizontalArrangement或VerticalArrangement：
- en: '![](img/a3da6e22-7752-49dd-91a8-2c58159430a3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3da6e22-7752-49dd-91a8-2c58159430a3.png)'
- en: 'If you want to vary the distance between two components, you will need to change
    the height of the HorizontalArrangement. To do this, select the Height property
    and set a particular pixel value on the HorizontalArrangement, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要改变两个组件之间的距离，您需要更改HorizontalArrangement的高度。为此，请选择高度属性，并在HorizontalArrangement上设置特定的像素值，如下所示：
- en: '![](img/6a15c482-e6b7-4407-91d5-fee5d10b6d9f.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a15c482-e6b7-4407-91d5-fee5d10b6d9f.png)'
- en: 'Next, select the **Button1** component and change its text to `CLICK HERE`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**Button1**组件，并将其文本更改为`CLICK HERE`：
- en: '![](img/d404157c-e941-47c0-987a-4e89b611b19b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d404157c-e941-47c0-987a-4e89b611b19b.png)'
- en: 'Similarly, select the **Label1** component, change its text to `TalkingPi`,
    and increase its **FontSize** to `24`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，选择**Label1**组件，将其文本更改为`TalkingPi`，并将其**FontSize**增加到`24`：
- en: '![](img/0e8f19dd-4871-4d1d-93bd-afdd42f33a62.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e8f19dd-4871-4d1d-93bd-afdd42f33a62.png)'
- en: 'Finally, open the Media option and drag the TextToSpeech component on to the
    screen. Since the TextToSpeech component is a non-visible component, it will appear
    below the screen as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开媒体选项并将TextToSpeech组件拖到屏幕上。由于TextToSpeech组件是一个不可见组件，它将显示在屏幕下方，如下所示：
- en: '![](img/682dd31f-c4d1-42b2-a098-425547639ea4.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/682dd31f-c4d1-42b2-a098-425547639ea4.png)'
- en: We have now basically finished designing the Talking Pi application. Let's now
    go inside the Blocks option and create the programming blocks for displaying the
    text and translating it into speech at the click of a button.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在基本上已经完成了Talking Pi应用程序的设计。现在让我们进入Blocks选项，并为显示文本并在点击按钮时将其转换为语音创建编程块。
- en: Programming the blocks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程块
- en: 'After designing the UI for the app, click on the Blocks button, which is next
    to the Design button, as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序的UI后，点击Blocks按钮，该按钮位于Design按钮旁边，如下截图所示：
- en: '![](img/914d6df9-254d-4e2d-88db-80354357d845.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/914d6df9-254d-4e2d-88db-80354357d845.png)'
- en: 'Inside the block section, on the left side you will see **Screen1**, which
    contains all the components (both visible and non-visible) that we have dragged
    onto the screen. If you click on any of the components, you will notice the following
    types of blocks for each component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在块部分，左侧将看到**Screen1**，其中包含我们拖放到屏幕上的所有组件（可见和不可见）。如果点击任何组件，您将注意到每个组件的以下类型的块：
- en: '![](img/d682f238-1e76-453e-b7c0-3201187fa27e.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d682f238-1e76-453e-b7c0-3201187fa27e.png)'
- en: 'We will focus our attention mainly on the three types of block that make up
    each component. We will refer to these as **Main block**, **Intermediate block**,
    and **Final block**. Each of these blocks must be connected in the correct sequence
    to get a proper working program, as shown in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要关注构成每个组件的三种类型的块。我们将这些称为**主块**、**中间块**和**最终块**。这些块中的每一个必须按正确的顺序连接以获得一个正常工作的程序，如下图所示：
- en: '![](img/1a0288f5-fecf-43b9-9256-d0dc6e1f482b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a0288f5-fecf-43b9-9256-d0dc6e1f482b.png)'
- en: Let's take a look at each block.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个块。
- en: Main block
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主块
- en: 'The **main block** inside App Inventor 2 is similar to a **when** loop, which
    indicates an action to carry out when something happens. The **main block** is
    always connected to an **intermediate block**. We cannot connect the **final block**
    directly to the **main block**. The main block consists of a drop-down menu from
    which we can choose between multiple components that are of the same type. For
    example, look at the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: App Inventor 2中的**主块**类似于**when**循环，表示发生某事时要执行的操作。**主块**始终连接到**中间块**。我们不能直接将**最终块**连接到**主块**。主块包括一个下拉菜单，我们可以从中选择多个相同类型的组件。例如，看下面的截图：
- en: '![](img/7a63e10e-f7ea-49bd-ad90-c5389660e864.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a63e10e-f7ea-49bd-ad90-c5389660e864.png)'
- en: You can see that in a scenario where you have multiple buttons, you can choose
    a particular button from the drop-down list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在有多个按钮的情况下，可以从下拉列表中选择特定的按钮。
- en: Intermediate block
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间块
- en: 'The **intermediate block** consists of an **input socket** and an **output
    socket**. The **input socket** is connected to the **main block** and the **output
    socket** is connected to the **final block**, as shown in the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间块**包括一个**输入插座**和一个**输出插座**。**输入插座**连接到**主块**，**输出插座**连接到**最终块**，如下图所示：'
- en: '![](img/9ec27222-399b-4c55-aaad-ed05547a438d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec27222-399b-4c55-aaad-ed05547a438d.png)'
- en: 'The **intermediate block** consists of two drop-down menus. The first drop-down
    menu represents the components of the same type. For example, if you have multiple
    labels, you can choose a particular label from the first drop-down menu. The second
    drop-down menu represents the properties of the component. For **Label1**, for
    example, we have **Text**, **BackgroundColor**, **Width**, and so on, as shown
    in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间块**包括两个下拉菜单。第一个下拉菜单代表相同类型的组件。例如，如果有多个标签，可以从第一个下拉菜单中选择特定的标签。第二个下拉菜单代表组件的属性。例如，对于**Label1**，我们有**Text**、**BackgroundColor**、**Width**等，如下图所示：'
- en: '![](img/13e026f4-ee9d-48bf-83c8-15fcaedeefd6.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13e026f4-ee9d-48bf-83c8-15fcaedeefd6.png)'
- en: For example, **Label1** . **Text** means that we want to set or change the text
    of **Label1**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**Label1** . **Text**表示我们要设置或更改**Label1**的文本。
- en: Final block
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终块
- en: 'The **final block** is connected to the **intermediate block**. It also consists
    of two drop-down menus from which we can select a particular component and its
    specific properties, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终块**连接到**中间块**。它还包括两个下拉菜单，我们可以从中选择特定的组件及其特定属性，如下图所示：'
- en: '![](img/cea0ac6c-7000-41a7-aba9-65e319e70faf.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cea0ac6c-7000-41a7-aba9-65e319e70faf.png)'
- en: We will be using these three types of blocks to create our Talking Pi program.
    Let's start with the block programming.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这三种类型的块来创建我们的Talking Pi程序。让我们从块编程开始。
- en: The Talking Pi program
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Talking Pi程序
- en: 'The Talking Pi programming logic is very simple. When **Button1** is pressed,
    **Label1** must display the text that is typed inside **Textbox1** and **TextToSpeech1**
    must read out that text. The steps for executing this block program are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Talking Pi编程逻辑非常简单。当按下**Button1**时，**Label1**必须显示在**Textbox1**内键入的文本，并且**TextToSpeech1**必须朗读该文本。执行此块程序的步骤如下：
- en: 'First, click on the **Button1** component and select the **when Button1.Click**
    main block:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击**Button1**组件并选择**when Button1.Click**主块：
- en: '![](img/651bb807-3f0a-48a0-bf79-7bee856033b7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/651bb807-3f0a-48a0-bf79-7bee856033b7.png)'
- en: 'Next, since we want to change the text of **Label1** when **Button1** is clicked,
    choose the **Label1.Text** block from the **Label1** component:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，由于我们希望在单击**Button1**时更改**Label1**的文本，因此选择**Label1**组件中的**Label1.Text**块：
- en: '![](img/9c70ab7e-e25c-4e0a-b272-6c9a9ea59e76.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c70ab7e-e25c-4e0a-b272-6c9a9ea59e76.png)'
- en: 'Next, drag the **Label1.Text** block inside the **Button1.Click** block to
    join both the blocks. Once both the blocks are joined, you will hear a click sound:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将**Label1.Text**块拖到**Button1.Click**块内以连接这两个块。一旦连接了两个块，就会听到点击声音：
- en: '![](img/9b1ff765-8f38-4439-b3e3-21056ba5ee2c.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b1ff765-8f38-4439-b3e3-21056ba5ee2c.png)'
- en: 'Now, we want to display the text inside the TextBox in the label component.
    From the **TextBox1** component, select the **TextBox1.Text** block as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望在标签组件中显示文本框内的文本。从**TextBox1**组件中，选择如下**TextBox1.Text**块：
- en: '![](img/8aca2f50-3528-43e9-bc39-ef5d90bada51.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aca2f50-3528-43e9-bc39-ef5d90bada51.png)'
- en: 'Next, attach the **TextBox1.Text** block to the **Label1.Text** block. Now,
    when you press the button, the label will display the text that is written inside
    the Textbox. **Label1** is now set to display the text that is inside **TextBox1**,
    as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将**TextBox1.Text**块连接到**Label1.Text**块。现在，当您按下按钮时，标签将显示文本框内的文本。**Label1**现在设置为显示**TextBox1**内的文本，如下所示：
- en: '![](img/09643073-3089-4413-9015-0cb7d4e35fb8.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09643073-3089-4413-9015-0cb7d4e35fb8.png)'
- en: 'After this, to read out the text that is inside the textbox, click on the **TextToSpeech1**
    component and choose the **call TextToSpeech1.Speak** block, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，要朗读文本框内的文本，点击**TextToSpeech1**组件并选择**call TextToSpeech1.Speak**块，如下所示：
- en: '![](img/5b82dfd6-2a49-4369-a390-b4e43953c594.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b82dfd6-2a49-4369-a390-b4e43953c594.png)'
- en: 'Connect this block below the **Label1.Text** block. Inside the message socket,
    connect the **TextBox1.Text** final block. This means that whatever text is written
    inside the textBox will be spoken as a message by the **TextToSpeech1** block,
    for example:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此块连接到**Label1.Text**块下方。在消息插座内，连接**TextBox1.Text**最终块。这意味着文本框内键入的任何文本都将被**TextToSpeech1**块朗读，例如：
- en: '![](img/44c3d91d-4f08-41d4-b742-8ad44a514e19.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44c3d91d-4f08-41d4-b742-8ad44a514e19.png)'
- en: 'We have now finished designing our block program. To build and run this app
    inside your Android smartphone, click on the Build drop-down menu and choose between
    the two build types, as illustrated in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了设计我们的块程序。要在Android智能手机内构建和运行此应用程序，请单击“构建”下拉菜单，并在两种构建类型之间进行选择，如下图所示：
- en: '![](img/805760c9-7fde-42fb-9eec-a15bc29e16ec.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/805760c9-7fde-42fb-9eec-a15bc29e16ec.png)'
- en: The first option, App (provide QR Code for .apk), will generate a QR code that
    you can scan with your Android smartphone (using a QR scanner app). After scanning
    the QR code, the `.apk` file of the application will be downloaded inside your
    Android smartphone. Install the `.apk` file to test the output of the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项，应用程序（为.apk提供QR码），将生成一个QR码，您可以使用Android智能手机（使用QR扫描器应用程序）扫描。扫描QR码后，应用程序的`.apk`文件将下载到您的Android智能手机内。安装`.apk`文件以测试应用程序的输出。
- en: The second option, App (save .apk to my computer), will generate and download
    a `.apk` file inside your computer. You will need to transfer the `.apk` file
    from your computer to your smartphone and install the `.apk` file. I personally
    prefer the first option as the `.apk` file is directly downloaded inside the smartphone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项，应用程序（将.apk保存到我的计算机），将在您的计算机内生成并下载一个`.apk`文件。您需要将`.apk`文件从计算机传输到智能手机并安装`.apk`文件。我个人更喜欢第一个选项，因为`.apk`文件直接下载到智能手机内。
- en: 'You can also download the MIT AI2 companion application from the Android play
    store and install it inside your Android smartphone to test the application in
    real time. So in the play store, search for **MIT AI2 Companion** and then click
    on the Install button to install the app. The app page is shown in the following
    screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从Android应用商店下载MIT AI2 Companion应用程序，并将其安装在您的Android智能手机上，以实时测试应用程序。因此，在应用商店中搜索**MIT
    AI2 Companion**，然后点击安装按钮安装该应用程序。应用程序页面如下截图所示：
- en: '![](img/e8719229-0505-4088-9e0c-b1236135caa0.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8719229-0505-4088-9e0c-b1236135caa0.png)'
- en: 'After installing the MIT AI2 Companion app inside your Android smartphone,
    click on the **Scan QR code** button or enter the six-digit alphabetical code
    (next to the QR code) inside the MIT AI2 Companion app, and then click on the **Connect
    with code** button. To generate the QR code or the six-digit number, click on
    **Connect** and then select **AI Companion**, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Android智能手机内安装MIT AI2 Companion应用程序后，点击**扫描QR码**按钮或输入MIT AI2 Companion应用程序内的六位字母代码（在QR码旁边），然后点击**用代码连接**按钮。要生成QR码或六位数，请点击**连接**，然后选择**AI
    Companion**，如下所示：
- en: '![](img/394cd7a3-2ca9-4f83-b9cd-7ec0198c74f5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/394cd7a3-2ca9-4f83-b9cd-7ec0198c74f5.png)'
- en: Importing and exporting the .aia file of the app
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和导出应用程序的.aia文件
- en: 'You can export your Android application by generating its `.aia` file. To create
    a `.aia` file, follow any one of these steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过生成其`.aia`文件导出您的Android应用程序。要创建`.aia`文件，请执行以下任一步骤：
- en: 'Click on **Projects** and then select **Export selected project (.aia) to my
    computer**:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**项目**，然后选择**将选定的项目导出（.aia）到我的计算机**：
- en: '![](img/5142d183-0049-409a-bba4-9ca708771ebb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5142d183-0049-409a-bba4-9ca708771ebb.png)'
- en: 'Similarly, you can click on **Projects** and then select **Import project (.aia)
    from my computer**:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，您可以点击**项目**，然后选择**从我的计算机导入项目（.aia）**：
- en: '![](img/6fbc06a5-67d6-401f-bc17-811cf2030309.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fbc06a5-67d6-401f-bc17-811cf2030309.png)'
- en: You can download the `.aia` file of the Talking Pi and voice-control bot application
    file from the `Chapter09` folder of GitHub repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub存储库的`Chapter09`文件夹中下载Talking Pi和语音控制机器人应用程序文件的`.aia`文件。
- en: Creating a voice-controlled bot app
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个语音控制机器人应用
- en: 'The voice-controlled bot application is the main focus of this chapter. The
    following are the three main parts involved in creating a voice-controlled robot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 语音控制机器人应用程序是本章的主要焦点。创建语音控制机器人涉及以下三个主要部分：
- en: '**A voice recognition application**: The voice recognition application will
    recognize our voice and send data as text when a particular word is recognized.
    For example, if we say the word **forward**, the application would send an **F**
    to the robot.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音识别应用程序**：语音识别应用程序将识别我们的声音，并在识别特定单词时发送数据为文本。例如，如果我们说**向前**，应用程序将向机器人发送**F**。'
- en: '**Bluetooth connection**: This involves establishing a working connection between
    the Bluetooth of the smartphone and the Bluetooth of the RPi.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙连接**：这涉及在智能手机的蓝牙和RPi的蓝牙之间建立工作连接。'
- en: '**RPi Robot program**: In this section, we will decode the text information
    that is transmitted from the smartphone and move the robot accordingly. For example,
    if the incoming text is **F**, then we will write a program to move the robot
    forward.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPi机器人程序**：在这一部分，我们将解码从智能手机传输的文本信息，并相应地移动机器人。例如，如果传入的文本是**F**，那么我们将编写一个程序来使机器人向前移动。'
- en: In this section, we will create a voice recognition application. In the later
    sections, we will look at establishing a Bluetooth connection and programming
    our robot. You can download the `VoiceControlBot.aia` file from the `Chapter09` folder
    of GitHub repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个语音识别应用程序。在后面的部分，我们将研究建立蓝牙连接和编程我们的机器人。您可以从GitHub存储库的`Chapter09`文件夹中下载`VoiceControlBot.aia`文件。
- en: To create the `VoiceControlBot` app, click on **Projects** and then select **Start
    new Project:**
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`VoiceControlBot`应用程序，请点击**项目**，然后选择**开始新项目：**
- en: '![](img/dde256fe-6d86-4dd0-8a00-f963492b4781.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dde256fe-6d86-4dd0-8a00-f963492b4781.png)'
- en: 'Call it `VoiceControlBot` and then press the OK button:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将其命名为`VoiceControlBot`，然后按下**确定**按钮：
- en: '![](img/8ba3cead-a20e-47dd-b381-85b83363437b.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ba3cead-a20e-47dd-b381-85b83363437b.png)'
- en: Let's now move on to the designing part.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续进行设计部分。
- en: Designing the app
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序
- en: 'Designing the voice-control bot application is very easy. The final application
    will look as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 设计语音控制机器人应用程序非常容易。最终应用程序将如下所示：
- en: '![](img/fab12089-edf9-4cd6-8b52-6d65136ef364.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fab12089-edf9-4cd6-8b52-6d65136ef364.png)'
- en: 'The following components will be used for designing the application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件将用于设计应用程序：
- en: '**ListPicker**: The ListPicker will display a list of Bluetooth devices that
    are connected to our smartphone.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ListPicker**：ListPicker将显示连接到我们智能手机的蓝牙设备列表。'
- en: '**Speech-recognizer**: The speech-recognizer component will listen to what
    we are saying.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音识别器**：语音识别器组件将听取我们说的话。'
- en: '**Speech-recognizer button**: When the speech-recognizer button is clicked,
    the speech-recognizer component will be called, which will listen to what we are
    saying.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音识别按钮**：单击语音识别按钮时，将调用语音识别器组件，该组件将听取我们说的话。'
- en: '**Disconnect button**: The disconnect button is used to disconnect the smartphone
    from the RPi.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断开按钮**：断开按钮用于将智能手机与RPi断开连接。'
- en: '**Label**: The label component will display the text that is spoken by the
    user.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：标签组件将显示用户说的文本。'
- en: '**Bluetooth client**: The Bluetooth client component activates our smartphone''s
    Bluetooth connection.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙客户端**：蓝牙客户端组件激活了我们智能手机的蓝牙连接。'
- en: '**Horizontal or vertical arrangement**: We have one horizontal arrangement
    component to position the speech-recognizer button properly in the center of the
    screen.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平或垂直排列**：我们有一个水平排列组件，将语音识别按钮正确放置在屏幕中央。'
- en: Next let's see how to add and customize components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看如何添加和自定义组件。
- en: Adding and customizing the components
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和自定义组件
- en: 'To design the `VoiceControlBot` application, drag the **ListPicker **(not ListView)
    component inside the screen. Next, drag a **Horizontal Arrangement** and, inside
    that, drag a **Button**. Below the **Horizontal Arrangement**, drag a **Label **and
    then another **Button**. If you have dragged all the components correctly, your
    screen should look as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计`VoiceControlBot`应用程序，将**ListPicker**（不是ListView）组件拖到屏幕中。接下来，拖一个**水平排列**，在里面拖一个**按钮**。在**水平排列**下方，拖一个**标签**，然后再拖一个**按钮**。如果你已经正确拖动了所有组件，你的屏幕应该如下所示：
- en: '![](img/05facfe8-3140-4b76-9dde-0599a293df2f.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05facfe8-3140-4b76-9dde-0599a293df2f.png)'
- en: 'In the following steps, I have customized each component in the app based on
    my own requirements. You can customize the components as you wish. Take the following
    steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我根据自己的需求定制了应用程序中的每个组件。您可以按照以下步骤自定义组件：
- en: 'First, with the **ListPicker1** selected, change the **background color** to
    green, set the **Width** to `Fill parent`, and change the **text** to `CONNECT`,
    as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择**ListPicker1**，将**背景颜色**更改为绿色，将**宽度**设置为`填充父级`，并将**文本**更改为`连接`，如下所示：
- en: '![](img/2d73397d-7f19-4ade-a0f5-88c352e006ad.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d73397d-7f19-4ade-a0f5-88c352e006ad.png)'
- en: 'Next, select the **HorizontalArrangement1** and change both its **Height**
    and **Width** to `Fill parent`*.* Change the **AlignHorizontal** and **AlignVertical**
    to `Center` so that Button1 is positioned in the center of the HorizontalArrangement1,
    as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**HorizontalArrangement1**，将其**高度**和**宽度**都更改为`填充父级`。将**AlignHorizontal**和**AlignVertical**更改为`Center`，以便Button1位于HorizontalArrangement1的中心，如下所示：
- en: '![](img/67ad4bf4-0936-4922-8a13-8cda872d12b0.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ad4bf4-0936-4922-8a13-8cda872d12b0.png)'
- en: After this, select **Button1**, click on the Rename button and rename Button1
    to `SRButton`. **SR** is short for **speech recognition:**
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，选择**Button1**，单击重命名按钮，并将Button1重命名为`SRButton`。**SR**是**语音识别**的缩写：
- en: '![](img/1f4287f6-9635-4862-ada0-f21ab0585b38.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f4287f6-9635-4862-ada0-f21ab0585b38.png)'
- en: 'Next, we will add a microphone image as the background of the **SRButton**.
    You can download this image from the `Chapter09` folder of the GitHub repository.
    To add a background image, change the **Width** and **Height** of the button to
    `200 pixels`, so that the button is square. Next, remove the default text from
    the Text box, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在**SRButton**的背景中添加一个麦克风图像。您可以从GitHub存储库的`Chapter09`文件夹中下载此图像。要添加背景图像，将按钮的**宽度**和**高度**更改为`200像素`，使按钮成为正方形。接下来，从文本框中删除默认文本，如下所示：
- en: '![](img/309fffc8-c084-476c-9b37-2125c16b18b5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/309fffc8-c084-476c-9b37-2125c16b18b5.png)'
- en: 'After this, click on the Image option and then select the mic image to set
    it as the background image for the SRButton:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击图像选项，然后选择麦克风图像将其设置为SRButton的背景图像：
- en: '![](img/95f8e5eb-08d9-4446-b581-1027ef944556.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95f8e5eb-08d9-4446-b581-1027ef944556.png)'
- en: 'Next, with **Label1** selected, change the **FontSize** to `20` and the **Text**
    to `WORD SPOKEN` as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**Label1**，将**字体大小**更改为`20`，**文本**更改为`WORD SPOKEN`，如下所示：
- en: '![](img/e623b52d-85d6-437e-ab2e-f6ae0bfc7ab4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e623b52d-85d6-437e-ab2e-f6ae0bfc7ab4.png)'
- en: After this, to position Label1 horizontally in the center of the screen, select
    Screen1 and set **AlignHorizontal** to `Center`*.*
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为了将Label1水平居中在屏幕上，选择Screen1并将**AlignHorizontal**设置为`Center`。
- en: 'Finally, select **Button2** and rename it as `DeleteButton`. Change its **Background
    color** to `RED`, its **Width** to `Fill parent`, its **Text** to `DELETE`, and
    the **TextColor** to `White`, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择**Button2**并将其重命名为`DeleteButton`。将其**背景颜色**更改为`红色`，**宽度**更改为`填充父级`，**文本**更改为`删除`，**文本颜色**更改为`白色`，如下所示：
- en: '![](img/28951a7e-5e5f-4635-a1e7-0cb7cf7ed4ee.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28951a7e-5e5f-4635-a1e7-0cb7cf7ed4ee.png)'
- en: 'After designing the UI for the app, we need to drag the BluetoothClient and
    the SpeechRecognizer component to our screen. The BluetoothClient is inside the
    Connectivity option and the SpeechRecognizer component is inside the Media option:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计应用程序的用户界面后，我们需要将蓝牙客户端和语音识别器组件拖到我们的屏幕上。蓝牙客户端在连接选项中，语音识别器组件在媒体选项中：
- en: '![](img/228a02e6-fa7c-420a-8aa5-c6d088c17e81.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/228a02e6-fa7c-420a-8aa5-c6d088c17e81.png)'
- en: 'Once you have added all the necessary components, your screen should look as
    follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您添加了所有必要的组件，您的屏幕应该如下所示：
- en: '![](img/90f1bd01-9822-4439-8786-506a69911348.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f1bd01-9822-4439-8786-506a69911348.png)'
- en: Let's now move on to programming the voice-controlled bot block.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续编程语音控制机器人块。
- en: Programming the voice-controlled bot block
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语音控制机器人块
- en: 'After designing the app, it''s time to program the voice-controlled bot application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序后，是时候编程语音控制机器人应用程序了：
- en: 'First, we will use the **ListPicker1.BeforePicking** block from **ListPicker1** and
    display the Bluetooth devices connected to our smartphone in a list as list items.
    Connect this block to the ListPicker1.Elements blocks. Next, from the **BluetoothClient1**
    components, connect the **BluetoothClient1.AddressAndNames** block to the **ListPicker1.Elements** block,
    as shown in the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用**ListPicker1.BeforePicking**块从**ListPicker1**中，并在列表中显示连接到我们智能手机的蓝牙设备。将此块连接到**ListPicker1.Elements**块。接下来，从**BluetoothClient1**组件中，将**BluetoothClient1.AddressAndNames**块连接到**ListPicker1.Elements**块，如下截图所示：
- en: '![](img/84aef84e-245b-4f46-ba1d-450e3d5ebcc8.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84aef84e-245b-4f46-ba1d-450e3d5ebcc8.png)'
- en: The **ListPicker1.Elements** represents the elements (the list items) in the
    list, which are the addresses and names of the devices that are paired to our
    smartphone's Bluetooth. If we select an element from the list, the **ListPicker1.AfterPicking**
    block comes into play.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**ListPicker1.Elements**代表列表中的元素（列表项），这些元素是配对到我们智能手机蓝牙的设备的地址和名称。如果我们从列表中选择一个元素，**ListPicker1.AfterPicking**块就会起作用。'
- en: 'The **ListPicker1.AfterPicking** block is used to connect to the **AddressesAndNames** Bluetooth, which
    is selected from the list, as shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ListPicker1.AfterPicking**块用于连接到从列表中选择的**AddressesAndNames**蓝牙，如下截图所示：'
- en: '![](img/b55fbc71-ed73-4706-a3d2-77cd86ee98a1.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b55fbc71-ed73-4706-a3d2-77cd86ee98a1.png)'
- en: 'Once both the devices are connected using Bluetooth, choose the **SRbutton.Click**
    block from the **SRbutton**. Then, select the **SpeechRecognizer1.GetText** from
    the **SpeechRecognizer1** block and connect it to the **SRbutton.Click** block
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦两台设备使用蓝牙连接，就从**SRbutton**中选择**SRbutton.Click**块。然后，从**SpeechRecognizer1**块中选择**SpeechRecognizer1.GetText**，并将其连接到**SRbutton.Click**块，如下所示：
- en: '![](img/6ff28c2d-e164-4b06-a24c-4ab846f237f1.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ff28c2d-e164-4b06-a24c-4ab846f237f1.png)'
- en: The **SpeechRecognizer1.GetText** block will activate the Google speech recognizer
    and try to recognize what you are saying. It will convert your spoken words into
    text.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpeechRecognizer1.GetText**块将激活Google语音识别器，并尝试识别您说的话。它将把您说的话转换成文本。'
- en: 'Next, using the **SpeechRecognizer1.AfterGettingText** block, we will display
    the spoken text inside the label, for example:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用**SpeechRecognizer1.AfterGettingText**块，我们将在标签内显示口头文本，例如：
- en: '![](img/35e8844c-41c2-48a4-9414-e80e50def2d4.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e8844c-41c2-48a4-9414-e80e50def2d4.png)'
- en: 'After this, using the `if...then` blocks, we will establish whether the spoken
    words are forward, back, left, right, or stop. If any of these words are detected,
    then we will send an alphabetical character to our RPi robot using the BluetoothClient
    component. The if...then block is inside the **Control** option, as shown in the
    following screenshot:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用`if...then`块，我们将确定口头词是前进、后退、左转、右转还是停止。如果检测到任何这些词，我们将使用BluetoothClient组件向我们的RPi机器人发送一个字母字符。`if...then`块位于**Control**选项内，如下截图所示：
- en: '![](img/59e27c2a-8ac1-46d3-8eec-96918847caca.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59e27c2a-8ac1-46d3-8eec-96918847caca.png)'
- en: 'Select the if...then block and place it below the **Label1.Text** block inside
    the **SpeechRecognizer1.AfterGettingText** block, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`if...then`块，并将其放置在**SpeechRecognizer1.AfterGettingText**块内的**Label1.Text**块下方，如下所示：
- en: '![](img/f14e0c62-1d88-4c39-93c3-6a2a791a9dce.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f14e0c62-1d88-4c39-93c3-6a2a791a9dce.png)'
- en: 'Next, to understand the spoken words, we will use the comparison operator,
    which is inside the **Logic** option, as shown in the following screenshot:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了理解口头词，我们将使用比较运算符，该运算符位于**Logic**选项内，如下截图所示：
- en: '![](img/129dba10-c6d5-42f1-b05e-674af198a213.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/129dba10-c6d5-42f1-b05e-674af198a213.png)'
- en: 'Connect the comparison block in the `if` socket of the `if...then` block as
    follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比较块连接到`if...then`块的`if`插座中，如下所示：
- en: '![](img/95be015b-a9ef-4c6d-bd38-ac634449a678.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95be015b-a9ef-4c6d-bd38-ac634449a678.png)'
- en: 'In the left socket of the comparison operator, connect the SpeechRecognizer1.Result
    block:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较运算符的左插座中，连接**SpeechRecognizer1.Result**块：
- en: '![](img/08b441c4-62f7-4e87-9331-6f9c3f8324b9.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08b441c4-62f7-4e87-9331-6f9c3f8324b9.png)'
- en: 'In the right socket of the comparison operator, connect an empty text string
    box. The text string box is inside the Text option:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较运算符的右插座中，连接一个空的文本字符串框。文本字符串框位于Text选项内：
- en: '![](img/ccdb09c2-5bc7-41a0-a77b-d69993fef890.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccdb09c2-5bc7-41a0-a77b-d69993fef890.png)'
- en: 'After connecting the text string box to the comparison operator, enter the
    text `forward` inside it as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字符串框连接到比较运算符后，如下输入文本`forward`：
- en: '![](img/8e8494eb-9e5e-45cd-ad36-f555007f4d1d.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e8494eb-9e5e-45cd-ad36-f555007f4d1d.png)'
- en: 'This means that if the **SpeechRecognizer1.Result** is equal to **forward**,
    then inside the then socket, we will add a BluetoothClient1.SendText block. After
    this, we will connect a textbox to the BluetoothClient1.SendText block and enter
    the letter `F`, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着如果**SpeechRecognizer1.Result**等于**forward**，那么在then插座内，我们将添加一个**BluetoothClient1.SendText**块。之后，我们将连接一个文本框到**BluetoothClient1.SendText**块，并输入字母`F`，如下所示：
- en: '![](img/47f31e36-eb36-4583-beee-94f4e0185f8f.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47f31e36-eb36-4583-beee-94f4e0185f8f.png)'
- en: This means that when the word forward is detected, the character **F** will
    be sent from the smartphone's Bluetooth to the RPi's Bluetooth.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当检测到单词forward时，将从智能手机的蓝牙发送字符**F**到RPi的蓝牙。
- en: 'Right-click on the `if...then` block and duplicate it to create four additional
    blocks for the words back, left, right, and stop. When the word **back** is detected,
    you should send the letter **B**; when the word **left** is detected, you should
    send **L**; when the word **right** is detected, you should send **R**; and, finally,
    when the word **stop** is detected, you should send **S.** This is shown in the
    following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`if...then`块并复制它，创建四个额外的块，用于单词**back**、**left**、**right**和**stop**。当检测到单词**back**时，应发送字母**B**；当检测到单词**left**时，应发送**L**；当检测到单词**right**时，应发送**R**；最后，当检测到单词**stop**时，应发送**S**。如下截图所示：
- en: '![](img/2f7bb1f6-10a9-45ce-9a4b-33e26238d660.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f7bb1f6-10a9-45ce-9a4b-33e26238d660.png)'
- en: 'After this, connect the BluetoothClient1.Disconnect block to the **Disconnectbutton**,
    so that the Bluetooth connection is disconnected when this button is pressed:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将**BluetoothClient1.Disconnect**块连接到**Disconnectbutton**，这样当按下此按钮时，蓝牙连接将断开：
- en: '![](img/2e3999fc-4cfc-479f-baa7-2dc65b0288cf.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e3999fc-4cfc-479f-baa7-2dc65b0288cf.png)'
- en: We have now finished designing and programming our `VoiceControlBot` application.
    You can download and install this application inside your Android smartphone.
    In the next section, we will pair our smartphone's Bluetooth with the RPi's Bluetooth.
    Power up your RPi and let's get started with the pairing process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了设计和编程我们的`VoiceControlBot`应用程序。您可以在Android智能手机上下载并安装此应用程序。在下一节中，我们将把我们的智能手机的蓝牙与RPi的蓝牙配对。启动您的RPi，让我们开始配对过程。
- en: Pairing the Android smartphone and RPi via Bluetooth
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过蓝牙配对Android智能手机和RPi
- en: 'In this section, we will use the Terminal window to pair the Android''s Bluetooth
    with the RPi''s Bluetooth. Before we start with the pairing process, we need to
    install a Bluetooth package inside our RPi and make modifications to certain files.
    To do this, take the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用终端窗口将Android的蓝牙与RPi的蓝牙配对。在开始配对过程之前，我们需要在RPi内安装蓝牙软件包并对某些文件进行修改。为此，请按以下步骤操作：
- en: 'First, to install the Bluetooth package, enter the following command in the
    Terminal window:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，要安装蓝牙软件包，请在终端窗口中输入以下命令：
- en: '[PRE0]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下截图中看到上述命令的输出：
- en: '![](img/55c769ea-0d89-4a7a-8250-5065f7c184de.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55c769ea-0d89-4a7a-8250-5065f7c184de.png)'
- en: 'Next, we will open the `bluetooth.service` file and make some minor modifications.
    To open the file, enter the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开`bluetooth.service`文件并进行一些小的修改。要打开文件，请输入以下命令：
- en: '[PRE1]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, type `-C` after `/bluetoothd`. This will turn on the compatible mode
    of the RPi''s Bluetooth as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在/bluetoothd后键入“-C”。这将打开RPi蓝牙的兼容模式如下：
- en: '![](img/cda6bf7f-765c-45db-aacc-e949c78539fe.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda6bf7f-765c-45db-aacc-e949c78539fe.png)'
- en: 'After this, press *Ctrl* + *O* and then hit *Enter* to **save** the file. Next,
    press *Ctrl* + *X* to exit the file. Reboot your RPi with the following command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按下*Ctrl* + *O*，然后按*Enter*来**保存**文件。接下来，按*Ctrl* + *X*退出文件。使用以下命令重新启动您的RPi：
- en: '[PRE2]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the RPi has restarted, check its status by entering the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPi重新启动后，输入以下命令检查其状态：
- en: '[PRE3]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should now see `-C` next to `bluetoothhd`. If, after entering the preceding
    command, you see `lines 1-19/19(END)` and you can''t enter any new commands in
    the Terminal window, close the Terminal window and reopen it again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在`bluetoothhd`旁看到`-C`。如果在输入上述命令后，您看到`lines 1-19/19(END)`并且无法在终端窗口中输入任何新命令，请关闭终端窗口，然后再次打开：
- en: '![](img/c7008cf9-f4c0-47e5-9d67-d7c8803aecd2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7008cf9-f4c0-47e5-9d67-d7c8803aecd2.png)'
- en: 'Next, to pair the RPi''s Bluetooth with the smartphone''s Bluetooth, we first
    need to make the RPi''s Bluetooth discoverable. To pair the devices, enter the
    following command:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，要将RPi的蓝牙与智能手机的蓝牙配对，我们首先需要使RPi的蓝牙可发现。要配对设备，请输入以下命令：
- en: '[PRE4]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should now see the **Media Access Control** (**MAC**) address of your Bluetooth
    along with its name. The MAC address is a 12-digit address and is unique for each
    Bluetooth device. Your RPi''s Bluetooth will have a default name of `raspberrypi`,
    as you can see in the following screenshot:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该看到您的蓝牙的**媒体访问控制**（**MAC**）地址以及其名称。MAC地址是一个12位地址，对于每个蓝牙设备都是唯一的。您的RPi的蓝牙将具有默认名称`raspberrypi`，如下截图所示：
- en: '![](img/5f4ba947-718b-4b1f-8d7f-c7e30c1f82ea.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f4ba947-718b-4b1f-8d7f-c7e30c1f82ea.png)'
- en: 'Before entering the next set of code,**turn your Android device''s Bluetooth** **on**
    and click on the **Pair new device** option as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入下一组代码之前，**打开您的Android设备的蓝牙**并点击**配对新设备**选项如下：
- en: '![](img/f8b328de-b207-4913-96ab-404697f58fc7.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8b328de-b207-4913-96ab-404697f58fc7.png)'
- en: 'After this, enter the following five commands one by one to put the RPi''s
    Bluetooth in discoverable mode:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，逐一输入以下五个命令，将RPi的蓝牙置于可发现模式：
- en: '[PRE5]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After turning discoverable mode on, you should see the name raspberrypi in
    the Available devices option. Select this option:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开可发现模式后，您应该在“可用设备”选项中看到名称为raspberrypi。选择此选项：
- en: '![](img/97034ce4-49d1-47d1-9381-114fab195e8f.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97034ce4-49d1-47d1-9381-114fab195e8f.png)'
- en: 'After selecting the **raspberrypi** option, you will see a pop-up box asking
    you whether you want to pair with the Raspberry Pi''s Bluetooth. Click on the
    PAIR button:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**raspberrypi**选项后，您将看到一个弹出框，询问您是否要与Raspberry Pi的蓝牙配对。点击PAIR按钮：
- en: '![](img/f4793582-30a7-4640-91b1-ce6bb3d78791.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4793582-30a7-4640-91b1-ce6bb3d78791.png)'
- en: 'Next, inside the Terminal window, you will see a message asking whether you
    want to pair with your smartphone''s Bluetooth. Type `yes` (in lower-case letters)
    and press *Enter*:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在终端窗口中，您将看到一条消息，询问您是否要与智能手机的蓝牙配对。键入`yes`（小写字母）并按*Enter*：
- en: '![](img/cb92f9f2-4914-4dd9-828c-112ac6182c57.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb92f9f2-4914-4dd9-828c-112ac6182c57.png)'
- en: Next, you will see a small pop-up box in the Terminal window asking if you want
    to accept the pairing request. Click **OK:**
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将在终端窗口中看到一个小弹出框，询问您是否要接受配对请求。点击**OK**：
- en: '![](img/138b4adb-16f2-4fc8-904e-9fde1388e81e.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/138b4adb-16f2-4fc8-904e-9fde1388e81e.png)'
- en: 'You may then see another pop-up box stating that the connection failed. Ignore
    this error and press OK:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可能会看到另一个弹出框，指出连接失败。忽略此错误并点击OK：
- en: '![](img/4522e413-52a0-462b-ac52-1a4627795a77.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4522e413-52a0-462b-ac52-1a4627795a77.png)'
- en: 'After this, type `exit`. You can now check whether the device is paired to
    your RPi by typing `sudo bluetoothctl`, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，键入`exit`。您现在可以通过输入`sudo bluetoothctl`来检查设备是否已与RPi配对：
- en: '![](img/1b51d761-18b3-45be-bb0d-51bf542ff1e8.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b51d761-18b3-45be-bb0d-51bf542ff1e8.png)'
- en: So we have finished pairing the RPi's Bluetooth to the Android smartphone's
    Bluetooth. Next we will enable the serial port of the RPi Bluetooth.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了将RPi的蓝牙与Android智能手机的蓝牙配对。接下来，我们将启用RPi蓝牙的串行端口。
- en: Enabling the Bluetooth serial port
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用蓝牙串行端口
- en: 'After pairing the devices, we need to create a script for enabling the Bluetooth
    serial port. We will name this script `bt_serial` (**bt** being short for **Bluetooth**).
    To create this script, follow these instructions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 配对设备后，我们需要创建一个启用蓝牙串行端口的脚本。我们将命名此脚本为`bt_serial`（**bt**代表**蓝牙**）。按照以下说明创建此脚本：
- en: 'Type the following command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside this script, enter the following lines:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个脚本中，输入以下行：
- en: '[PRE7]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/ca062cf5-1ed9-49f2-95f5-56760e768db0.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca062cf5-1ed9-49f2-95f5-56760e768db0.png)'
- en: Next, save (*Ctrl* + *O*) and exit (*Ctrl* + *X*) this script.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，保存（*Ctrl* + *O*）并退出（*Ctrl* + *X*）此脚本。
- en: 'We then need to execute and run this script. Type the following commands: `sudo
    chmod +x bt_serial` (this is the execution command) and `sudo ./bt_serial` (this
    is the run command):'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后需要执行并运行此脚本。输入以下命令：`sudo chmod +x bt_serial`（这是执行命令）和`sudo ./bt_serial`（这是运行命令）：
- en: '![](img/a21cf02b-bf28-4249-a579-60a0637d484e.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a21cf02b-bf28-4249-a579-60a0637d484e.png)'
- en: After running the script, you will see the message `Serial Port service registered`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您将看到消息`Serial Port service registered`。
- en: Developing the Bluetooth program for RPi
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为RPi开发蓝牙程序
- en: After designing the Android application, pairing the devices, and enabling the
    serial port, it is now time to program the RPi so that it can receive text data
    from the Android smartphone. To receive incoming text data from the smartphone,
    we are going to use sockets from socket programming.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 设计完Android应用程序，配对设备并启用串行端口后，现在是时候对RPi进行编程，以便它可以从Android智能手机接收文本数据。为了从智能手机接收传入的文本数据，我们将使用套接字编程中的套接字。
- en: Socket programming
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程
- en: A socket is an endpoint of a two-way communication system in a network. We create
    sockets so that we can send bits of information through them. To establish a Bluetooth
    communication between the devices, we need to create a socket. One socket will
    be on the server side and the other will be on the client side. In our case, the
    Android smartphone is the client and the RPi is the server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是网络中双向通信系统的端点。我们创建套接字以便通过它们发送信息位。为了在设备之间建立蓝牙通信，我们需要创建一个套接字。一个套接字将位于服务器端，另一个将位于客户端。在我们的情况下，Android智能手机是客户端，RPi是服务器。
- en: 'The client socket tries to establish a connection with the server socket, while
    the server socket tries to listen to the incoming connection request from the
    client socket. In Bluetooth programming, we can choose between two socket options,
    RFCOMM and L2CAP, as represented in the following diagram:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端套接字尝试与服务器套接字建立连接，而服务器套接字尝试监听来自客户端套接字的传入连接请求。在蓝牙编程中，我们可以在RFCOMM和L2CAP之间进行选择，如下图所示：
- en: '![](img/53c12a55-31de-43d5-9dc1-eea624977799.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c12a55-31de-43d5-9dc1-eea624977799.png)'
- en: 'In a socket program, the following connection steps have to happen one after
    another from the client and server side. Each step represents a function, which
    is declared either in the client, server, or both scripts. Take the following
    steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字程序中，以下连接步骤必须依次从客户端和服务器端进行。每个步骤代表一个函数，该函数在客户端、服务器或两个脚本中声明。按照以下步骤进行：
- en: '**Socket creation (client/server)**: Creates sockets in the client and server
    programs as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**套接字创建（客户端/服务器）**：在客户端和服务器程序中创建套接字如下：'
- en: '[PRE8]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this function, the first parameter refers to the communication domain. In
    our case, the communication domain is Bluetooth (`AF_BLUETOOTH`). The second parameter refers
    to the communication type (`SOCK_STREAM`). The third parameterrefers to the communication
    protocol. In Bluetooth programming, we can choose the **Radio Frequency Communication**
    (**RFCOMM**) protocol or the **Logical Link Control and Adaption Protocol** (**L2CAP**).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，第一个参数是指通信域。在我们的情况下，通信域是蓝牙（`AF_BLUETOOTH`）。第二个参数是指通信类型（`SOCK_STREAM`）。第三个参数是指通信协议。在蓝牙编程中，我们可以选择**无线电频率通信**（**RFCOMM**）协议或**逻辑链路控制和适配协议**（**L2CAP**）。
- en: '**Connect (client)**: This function tries to establish a connection with the
    server socket:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接（客户端）**：此函数尝试与服务器套接字建立连接：'
- en: '[PRE9]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this function, the first parameter refers to the socket, the second parameter
    refers to the address of the server, and the third parameter is used to find the
    size of device address. In our case, the device address is the RPi address.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，第一个参数是指套接字，第二个参数是指服务器的地址，第三个参数用于查找设备地址的大小。在我们的情况下，设备地址是树莓派的地址。
- en: '**Bind (server)**: The `bind` function binds the address and port number of
    the server device. The MAC address of the RPi will be stored inside the bind function
    as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绑定（服务器）**：`bind`函数绑定服务器设备的地址和端口号。RPi的MAC地址将存储在绑定函数内，如下所示：'
- en: '[PRE10]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this function, the first parameter refers to the socket, the second parameter
    refers to the address of the server device (Raspberry Pi), and the third parameter
    is used to find the size of the device address.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，第一个参数是指套接字，第二个参数是指服务器设备（树莓派）的地址，第三个参数用于查找设备地址的大小。
- en: '**Listen (server)**: With the `listen` function, the server socket waits for
    the client to approach it in order to make a connection:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监听（服务器）**：使用`listen`函数，服务器套接字等待客户端接近以建立连接：'
- en: '[PRE11]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first parameter refers to the socket. The backlog is generally set to `1`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是指套接字。等待队列通常设置为`1`。
- en: '**Accept (server)**: The `accept` function waits for an incoming connection
    request and creates a new socket:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接受（服务器）**：`accept`函数等待传入的连接请求并创建一个新的套接字：'
- en: '[PRE12]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this function, the second parameter refers to the address of the client,
    which is the Android smartphone.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，第二个参数是指客户端的地址，即Android智能手机。
- en: '**Send (client/server)**: The `send` function is used to send data from the
    client to the server and the other way around.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送（客户端/服务器）**：`send`函数用于从客户端向服务器发送数据，反之亦然。'
- en: '**Read (client/server)**: The `read` function is used to read data transferred
    from the client to the server and the other way around.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取（客户端/服务器）**：`read`函数用于从客户端向服务器读取数据，反之亦然。'
- en: '**Close (client/server)**: The `close` function shuts down the socket and frees
    the memory allocated to the socket.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭（客户端/服务器）**：`close`函数关闭套接字并释放分配给套接字的内存。'
- en: Now, since we have already created the `VoiceControlBot` Android application
    using App Inventor, there is no need to write a client program. All that's left
    is to write the server program for our RPi robot.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们已经使用App Inventor创建了`VoiceControlBot`安卓应用程序，因此无需编写客户端程序。剩下的就是为我们的RPi机器人编写服务器程序。
- en: VoiceBot server program
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VoiceBot服务器程序
- en: 'In this `VoiceBot` server program, we will first use a socket program to establish
    a socket connection between the devices. Next, we will receive the incoming data,
    which is sent from the Android smartphone. Finally, we will move the robot based
    on the data that is sent. The `VoiceBot.c` program can be downloaded from the `Chapter09`
    folder of the GitHub repository. Follow these steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`VoiceBot`服务器程序中，我们将首先使用套接字程序在设备之间建立套接字连接。接下来，我们将接收来自安卓智能手机发送的传入数据。最后，我们将根据发送的数据移动机器人。`VoiceBot.c`程序可以从GitHub存储库的`Chapter09`文件夹中下载。请按照以下步骤进行：
- en: 'First, all the necessary header files are declared as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明所有必要的头文件如下：
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, inside the `main()` function, the wiringPi pin numbers 0, 2, 3, and 4
    are declared as output pins as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`main()`函数内，声明wiringPi引脚编号0、2、3和4为输出引脚如下：
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To establish RFCOMM with the other device, `sockaddr_rc` is declared along
    with the `server_address` and `client_address`. The `data` variable will store
    and display the incoming data. The `s` and `clientsocket` are for storing the
    values of the server and client socket respectively. The `bytes` variable will
    read the incoming byte information. The `socklen_t opt` contains the size of `client_address`.
    This is shown in the following lines of code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他设备建立RFCOMM，声明`sockaddr_rc`以及`server_address`和`client_address`。`data`变量将存储和显示传入的数据。`s`和`clientsocket`分别用于存储服务器和客户端套接字的值。`bytes`变量将读取传入的字节信息。`socklen_t
    opt`包含`client_address`的大小。这在以下代码行中显示：
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, the `s` is created with the communication domain set to `AF_BLUETOOTH`,
    the communication type set to `SOCK_STREAM`, and the communication protocol set
    to `BTPROTO_RFCOMM`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`s`，通信域设置为`AF_BLUETOOTH`，通信类型设置为`SOCK_STREAM`，通信协议设置为`BTPROTO_RFCOMM`：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The RPi''s Bluetooth MAC address is then bound to the server socket using the
    bind function and the `s` (server socket) enters listening mode as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`bind`函数将RPi的蓝牙MAC地址绑定到服务器套接字，并使`s`（服务器套接字）进入监听模式如下：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the connection is accepted, a new client socket is created using the accept
    function as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接被接受，将使用`accept`函数创建一个新的客户端套接字如下：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The incoming byte data is then converted to a string using the `ba2str` function.
    After that, the MAC address of the connected Bluetooth is displayed as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`ba2str`函数将传入的字节数据转换为字符串。之后，显示连接的蓝牙的MAC地址如下：
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this, inside the `for` loop, the incoming data is read using the `read`
    function. If the value inside the byte variable is greater than `0`, we print
    the data as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`for`循环内，使用`read`函数读取传入的数据。如果字节变量中的值大于`0`，我们将按以下方式打印数据：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we will use five `if` conditions to check whether the incoming data contains
    the letters `F`, `B`, `L`, `R`, or `S`, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用五个`if`条件来检查传入的数据是否包含字母`F`、`B`、`L`、`R`或`S`，如下所示：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code can be explained as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以解释如下：
- en: '`*data == ''F''`: The robot will move forward'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data == ''F''`：机器人将向前移动'
- en: '`*data == ''S''`: The robot will move backward'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data == ''S''`：机器人将向后移动'
- en: '`*data == ''L''`: The robot will take an axial left turn'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data == ''L''`：机器人将进行轴向左转'
- en: '`*data == ''R''`: The robot will take an axial right turn'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data == ''R''`：机器人将进行轴向右转'
- en: '`*data == ''S''`: The robot will stop'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data == ''S''`：机器人将停止'
- en: 'Finally, to disconnect the devices, the `close` function is used to close the
    `clientsocket` and the `s` as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了断开设备的连接，使用`close`函数关闭`clientsocket`和`s`如下：
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, since this code contains a socket and a Bluetooth header file, to compile
    this code, you will need to add the `-lbluetooth` command inside the Build command. As
    this is a C program and not a C++ program, you will also have to add the -lwiringPi
    command to compile the wiringPi code as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，由于此代码包含套接字和蓝牙头文件，因此在编译此代码时，您需要在构建命令中添加`-lbluetooth`命令。由于这是一个C程序而不是C++程序，因此您还需要添加`-lwiringPi`命令来编译wiringPi代码，如下所示：
- en: '![](img/5c856383-3c63-40c2-a0a3-2fa497f76465.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c856383-3c63-40c2-a0a3-2fa497f76465.png)'
- en: Next let's test the code and check the final output.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们测试代码并检查最终输出。
- en: Testing the code
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: Now, before compiling and building the program, make sure that you have paired
    both the Android smartphone's Bluetooth and the RPi's Bluetooth. If they are not
    paired, then the RPi Bluetooth name (`raspberrypi`) will not appear in the Bluetooth
    list when you run the `VoiceControlBot` application. The steps for pairing the
    devices are listed in the *Pairing the Android smartphone and RPi via Bluetooth* section.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编译和构建程序之前，请确保您已经配对了安卓智能手机的蓝牙和RPi的蓝牙。如果它们没有配对，那么当您运行`VoiceControlBot`应用程序时，RPi蓝牙名称（`raspberrypi`）将不会出现在蓝牙列表中。配对设备的步骤在*通过蓝牙配对安卓智能手机和RPi*部分中列出。
- en: 'Once you have done this, you will need to execute and run the `bt_serial` script,
    which we created previously, inside the Terminal window. The commands for executing
    and running this script are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您需要在终端窗口内执行和运行我们之前创建的`bt_serial`脚本。执行和运行此脚本的命令如下：
- en: '[PRE23]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You do not need to execute this script each time you run the program but you
    will need to execute and run this script when you start a new RPi session and
    want to test the `VoiceBot.c` program. Next, compile and build the `VoiceBot.c`
    program. After this, open the `VoiceControlBot` Android app and press the **CONNECT**
    list picker. You will see the name of the raspberrypi along with its MAC address
    in the Bluetooth list. Select the raspberrypi option to connect the devices as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要每次运行程序都执行这个脚本，但是当你启动一个新的RPi会话并想要测试`VoiceBot.c`程序时，你需要执行和运行这个脚本。接下来，编译和构建`VoiceBot.c`程序。之后，打开`VoiceControlBot`
    Android应用程序并按下**CONNECT**列表选择器。你将在蓝牙列表中看到树莓派的名称以及其MAC地址。选择树莓派选项以连接设备，如下所示：
- en: '![](img/b7ae03f1-7a53-4aa7-9950-12cc879e9719.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7ae03f1-7a53-4aa7-9950-12cc879e9719.png)'
- en: 'Once they are connected, you will get a notification inside the Terminal window
    stating `Connected to:` and the Android Bluetooth MAC address, as shown in the
    following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们连接，你将在终端窗口内收到一个通知，显示`Connected to:`和Android蓝牙MAC地址，如下面的屏幕截图所示：
- en: '![](img/e44e66ce-cbb9-494f-928e-becfde6ca5e2.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e44e66ce-cbb9-494f-928e-becfde6ca5e2.png)'
- en: 'If you get the following **Error 507: Unable to Connect. Is the device turned
    on?** error, don''t worry. Click on the connect button and select the raspberrypi
    Bluetooth again:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到以下**错误507：无法连接。设备是否打开？**错误，请不要担心。点击连接按钮并再次选择树莓派蓝牙：
- en: '![](img/0bc55ecd-8e60-4c96-814b-b8ab9c5bcc90.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bc55ecd-8e60-4c96-814b-b8ab9c5bcc90.png)'
- en: 'Once the devices are connected, you can click on the speech recognizer button
    and start speaking. If you say the word *forward*, this should be displayed on
    the screen, as in the following screenshot, and the letter **F** will be sent
    to the RPi:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备连接，你可以点击语音识别器按钮并开始说话。如果你说单词*forward*，这应该显示在屏幕上，如下面的屏幕截图所示，并且字母**F**将被发送到RPi：
- en: '![](img/01b59e04-19ff-488e-a8bf-a15e264448d6.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01b59e04-19ff-488e-a8bf-a15e264448d6.png)'
- en: 'Similarly, when you say the words *back*, *left*, *right*, and *stop*, the
    letters **B**, **L**, **R**, and **S**, as shown in the following screenshot, will
    be sent to the RPi''s Bluetooth and the robot will move in the appropriate direction:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你说单词*back*、*left*、*right*和*stop*时，字母**B**、**L**、**R**和**S**，如下面的屏幕截图所示，将被发送到RPi的蓝牙，机器人将朝适当的方向移动：
- en: '![](img/ce63f3db-bbf8-4e6f-9eea-2555c5027665.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce63f3db-bbf8-4e6f-9eea-2555c5027665.png)'
- en: If you say any other word, the speech recognizer should recognize the word and
    display it on the screen, but it will not send any text data to the RPi.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说任何其他单词，语音识别器应该识别这个单词并在屏幕上显示出来，但不会发送任何文本数据到RPi。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by creating our first Android application called Talking
    Pi, in which text written inside the textbox was displayed in a label and also
    read out by the smartphone. We then developed a voice-controlled bot Android app,
    which recognized our voice and sent text to the RPi via Bluetooth. After this,
    using the Terminal window, we paired the Android smartphone's Bluetooth with the
    RPi's Bluetooth. Finally, we looked at socket programming and wrote the `VoiceBot`
    program to establish a connection with the Android smartphone's Bluetooth to control
    the robot.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建我们的第一个Android应用程序Talking Pi开始了这一章，其中文本框内的文本被显示在标签上，并由智能手机朗读出来。然后，我们开发了一个声控机器人Android应用程序，它可以识别我们的声音并通过蓝牙将文本发送到RPi。之后，使用终端窗口，我们将Android智能手机的蓝牙与RPi的蓝牙配对。最后，我们研究了套接字编程，并编写了`VoiceBot`程序，以与Android智能手机的蓝牙建立连接来控制机器人。
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which communication protocol did we use to send data over a Bluetooth connection?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪种通信协议通过蓝牙连接发送数据？
- en: What kind of address do Bluetooth devices have?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝牙设备有什么样的地址？
- en: What was the use of ListPicker inside the `VoiceControlBot` application?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VoiceControlBot`应用程序中ListPicker的用途是什么？
- en: On the client side, which function is used to connect the client socket to the
    server socket?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，用什么函数将客户端套接字连接到服务器套接字？
- en: What is the default Bluetooth name of your RPi?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的RPi的默认蓝牙名称是什么？
