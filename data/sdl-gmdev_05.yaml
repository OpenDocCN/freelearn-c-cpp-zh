- en: Chapter 5. Handling Game States
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：处理游戏状态
- en: When we first start up a game, we expect to see a splash screen showing any
    branding for publishers and developers, followed by a loading screen as the game
    does its initial setup. After this, we are usually faced with a menu screen; here,
    we can change settings and start the game. Starting the game leads us to another
    loading screen, possibly followed by a cut scene, and finally, we are in the game.
    When we are in the game, we can pause our play (allowing us to change any settings),
    exit the game, restart the level, and so on. If we fail the level, we are shown
    either an animation or a game over screen depending on how the game is set up.
    All of these different sections of a game are called *Game States*. It is very
    important that we make the transition between these states as easy as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动游戏时，我们期望看到显示出版商和开发者的任何品牌信息的启动画面，然后是加载画面，因为游戏正在进行初始设置。之后，我们通常会看到一个菜单屏幕；在这里，我们可以更改设置并开始游戏。开始游戏会带我们进入另一个加载画面，可能还会跟随一个剪辑场景，最终，我们就在游戏中了。当我们处于游戏状态时，我们可以暂停我们的游戏（允许我们更改任何设置），退出游戏，重新开始关卡，等等。如果我们未能通过关卡，我们会看到动画或游戏结束画面，具体取决于游戏的设置。所有这些不同的游戏部分都被称为*游戏状态*。我们使这些状态之间的转换尽可能容易是非常重要的。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Two different ways of handling states, starting with a really simple implementation
    and gradually building our framework implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理状态的两个不同方法，从一个非常简单的实现开始，逐步构建我们的框架实现
- en: Implementing **Finite State Machines** (**FSM**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现有限状态机（**FSM**）
- en: Adding states to the overall framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态添加到整体框架中
- en: A simple way for switching states
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换状态的一种简单方法
- en: 'One of the simplest ways to handle states is to load everything we want at
    the game''s initialization stage, but only draw and update the objects specific
    to each state. Let''s look at an example of how this could work. First, we can
    define a set of states we are going to use:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 处理状态的最简单方法之一是在游戏的初始化阶段加载我们想要的所有东西，但只绘制和更新每个状态特定的对象。让我们看看这如何工作。首先，我们可以定义我们将要使用的一组状态：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then use the `Game::init` function to create the objects:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`Game::init`函数来创建对象：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, set our initial state:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置我们的初始状态：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we can change our `update` function to only use the things we want when
    in a specific state:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将我们的`update`函数修改为仅在特定状态下使用我们想要的东西：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `render` function would do something similar. These functions could of course
    still loop through arrays and use polymorphism as we originally had done, but
    on a state-by-state basis. Changing states is as simple as changing the value
    of the `m_currentGameState` variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数会做类似的事情。当然，这些函数仍然可以循环遍历数组并使用多态，就像我们最初所做的那样，但基于状态。改变状态就像改变`m_currentGameState`变量的值一样简单。'
- en: If you can see issues with this method, then it is very encouraging that you
    are starting to think in an object-oriented way. This way of updating states would
    be a bit of a nightmare to maintain and the scope for error is quite large. There
    are too many areas that need to be updated and changed to make this a viable solution
    for any game larger than a simple arcade game.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现这个方法有问题，那么你开始以面向对象的方式思考是非常令人鼓舞的。这种更新状态的方式维护起来会相当困难，出错的可能性也相当大。有太多需要更新和更改的区域，这使得它成为任何比简单街机游戏更大的游戏的可行解决方案。
- en: Implementing finite state machines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现有限状态机
- en: What we really need is the ability to define our states outside the `game` class,
    and have the state itself take care of what it needs to load, render, and update.
    For this we can create what is known as an FSM. The definition of FSM, as we will
    use it, is a machine that can exist in a finite number of states, can exist in
    only one state at a time (known as the current state), and can change from one
    state to another (known as a transition).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是在`game`类之外定义我们的状态，并且让状态本身负责加载、渲染和更新所需的内容。为此，我们可以创建所谓的有限状态机（FSM）。我们将使用的FSM定义是一个可以存在于有限数量的状态中的机器，一次只能存在于一个状态（称为当前状态），并且可以从一个状态转换到另一个状态（称为转换）。
- en: A base class for game states
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏状态的基础类
- en: 'Let''s start our implementation by creating a base class for all of our states;
    create a header file called `GameState.h`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建所有状态的基类来开始我们的实现；创建一个名为`GameState.h`的头文件：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just like our `GameObject` class, this is an abstract base class; we aren't
    actually putting any functionality into it, we just want all of our derived classes
    to follow this blueprint. The `update` and `render` functions are self-explanatory,
    as they will function just like the functions we created in the `Game` class.
    We can think of the `onEnter` and `onExit` functions as similar to other `load`
    and `clean` functions; we call the `onEnter` function as soon as a state is created
    and `onExit` once it is removed. The last function is a getter for the state ID;
    each state will need to define this function and return its own `staticconst`
    ID. The ID is used to ensure that states don't get repeated. There should be no
    need to change to the same state, so we check this using the state ID.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `GameObject` 类一样，这是一个抽象基类；我们实际上并没有将其中的任何功能放入其中，我们只是希望所有派生类都遵循这个蓝图。`update`
    和 `render` 函数是自解释的，因为它们将像我们在 `Game` 类中创建的函数一样工作。我们可以将 `onEnter` 和 `onExit` 函数视为类似于其他
    `load` 和 `clean` 函数；一旦创建状态，我们就调用 `onEnter` 函数，一旦移除状态，就调用 `onExit`。最后一个函数是状态 ID
    的获取器；每个状态都需要定义这个函数并返回它自己的 `staticconst` ID。ID 用于确保状态不会重复。不应该需要更改到相同的状态，因此我们使用状态
    ID 来检查这一点。
- en: 'That''s it for our `GameState` base class; we can now create some test states
    that derive from this class. We will start with a state called `MenuState`. Go
    ahead and create `MenuState.h` and `MenuState.cpp` in our project, open up `MenuState.h`,
    and start coding:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `GameState` 基类的全部内容；我们现在可以创建一些从这个类派生的测试状态。我们将从一个名为 `MenuState` 的状态开始。继续在我们的项目中创建
    `MenuState.h` 和 `MenuState.cpp`，打开 `MenuState.h` 并开始编码：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now define these methods in our `MenuState.cpp` file. We will just display
    some text in the console window for now while we test our implementation; we will
    give this state an ID of `"MENU"`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的 `MenuState.cpp` 文件中定义这些方法。现在我们只是将在控制台窗口中显示一些文本来测试我们的实现；我们将给这个状态一个
    `"MENU"` 的 ID：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will now create another state called `PlayState`, create `PlayState.h` and
    `PlayState.cpp` in our project, and declare our methods in the header file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建另一个状态，称为 `PlayState`，在我们的项目中创建 `PlayState.h` 和 `PlayState.cpp`，并在头文件中声明我们的方法：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This header file is the same as `MenuState.h` with the only difference being
    `getStateID` returning this class'' specific ID (`"PLAY"`). Let''s define our
    functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件与 `MenuState.h` 相同，唯一的区别是 `getStateID` 返回这个类的特定 ID (`"PLAY"`)。让我们定义我们的函数：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have two states ready for testing; we must next create our FSM so that
    we can handle them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个状态准备测试；接下来，我们必须创建我们的有限状态机（FSM）以便我们可以处理它们。
- en: Implementing FSM
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现有限状态机（FSM）
- en: 'Our FSM is going to need to handle our states in a number of ways, which include:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态机（FSM）将需要以多种方式处理我们的状态，包括：
- en: '**Removing one state and adding another**: We will use this way to completely
    change states without leaving the option to return'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除一个状态并添加另一个状态**：我们将使用这种方法来完全改变状态而不留下返回的选项'
- en: '**Adding one state without removing the previous state**: This way is useful
    for pause menus and so on'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在不删除前一个状态的情况下添加一个状态**：这种方法对于暂停菜单等很有用'
- en: '**Removing one state without adding another**: This way will be used to remove
    pause states or any other state that had been pushed on top of another one'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在不添加另一个状态的情况下删除一个状态**：这种方法将用于删除暂停状态或任何其他被推到另一个状态之上的状态'
- en: 'Now that we have come up with the behavior we want our FSM to have, let''s
    start creating the class. Create the `GameStateMachine.h` and `GameStateMachine.cpp`
    files in our project. We will start by declaring our functions in the header file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经想出了我们希望有限状态机（FSM）具有的行为，让我们开始创建这个类。在我们的项目中创建 `GameStateMachine.h` 和 `GameStateMachine.cpp`
    文件。我们将在头文件中声明我们的函数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have declared the three functions we need. The `pushState` function will
    add a state without removing the previous state, the `changeState` function will
    remove the previous state before adding another, and finally, the `popState` function
    will remove whichever state is currently being used without adding another. We
    will need a place to store these states; we will use a vector:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了所需的三个函数。`pushState` 函数将在不删除前一个状态的情况下添加一个状态，`changeState` 函数将在添加另一个状态之前删除前一个状态，最后，`popState`
    函数将删除当前正在使用的任何状态而不添加另一个。我们需要一个地方来存储这些状态；我们将使用一个向量：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `GameStateMachine.cpp` file, we can define these functions and then
    go through them step-by-step:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameStateMachine.cpp` 文件中，我们可以定义这些函数，然后逐步进行：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very straightforward function; we simply push the passed-in `pState`
    parameter into the `m_gameStates` array and then call its `onEnter` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数；我们只是将传入的`pState`参数推入`m_gameStates`数组，然后调用它的`onEnter`函数：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another simple function is `popState`. We first check if there are actually
    any states available to remove, and if so, we call the `onExit` function of the
    current state and then remove it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的函数是`popState`。我们首先检查是否真的有可用的状态可以移除，如果有，我们调用当前状态的`onExit`函数然后移除它：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our third function is a little more complicated. First, we must check if there
    are already any states in the array, and if there are, we check whether their
    state ID is the same as the current one, and if it is, then we do nothing. If
    the state IDs do not match, then we remove the current state, add our new `pState`,
    and call its `onEnter` function. Next, we will add new `GameStateMachine` as a
    member of the `Game` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个功能稍微复杂一些。首先，我们必须检查数组中是否已经存在任何状态，如果存在，我们检查它们的州ID是否与当前的一个相同，如果是，那么我们就不做任何事情。如果州ID不匹配，那么我们就移除当前状态，添加我们的新`pState`，并调用它的`onEnter`函数。接下来，我们将添加新的`GameStateMachine`作为`Game`类的一个成员：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then use the `Game::init` function to create our state machine and add
    our first state:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`Game::init`函数来创建我们的状态机并添加我们的第一个状态：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Game::handleEvents` function will allow us to move between our states
    for now:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game::handleEvents`函数将允许我们暂时在状态之间移动：'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we press the *Enter* key, the state will change. Test the project and
    you should get the following output after changing states:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下*Enter*键时，状态将改变。测试项目后，你应该在改变状态后得到以下输出：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We now have the beginnings of our FSM and can next add `update` and `render`
    functions to our `GameStateMachine` header file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了FSM的初步形态，接下来可以在`GameStateMachine`头文件中添加`update`和`render`函数：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can define them in our `GameStateMachine.cpp` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`GameStateMachine.cpp`文件中定义它们：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These functions simply check if there are any states, and if so, they update
    and render the current state. You will notice that we use `back()` to get the
    current state; this is because we have designed our FSM to always use the state
    at the back of the array. We use `push_back()` when adding new states so that
    they get pushed to the back of the array and used immediately. Our `Game` class
    will now use the FSM functions in place of its own `update` and `render` functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只是检查是否有任何状态，如果有，它们就会更新并渲染当前状态。你会注意到我们使用`back()`来获取当前状态；这是因为我们设计我们的FSM总是使用数组后面的状态。我们在添加新状态时使用`push_back()`，这样它们就会被推到数组的后面并立即使用。我们的`Game`类现在将使用FSM函数来代替它自己的`update`和`render`函数：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our FSM is now in place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态机现在已经到位。
- en: Implementing menu states
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现菜单状态
- en: 'We will now move on to creating a simple menu state with visuals and mouse
    handling. We will use two new screenshots for our buttons, which are available
    with the source code downloads:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入创建一个带有视觉和鼠标处理的简单菜单状态。我们将使用两个新的截图来显示我们的按钮，这些截图可以在源代码下载中找到：
- en: '![Implementing menu states](img/6821OT_05_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![实现菜单状态](img/6821OT_05_01.jpg)'
- en: 'The following screenshot shows the exit feature:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了退出功能：
- en: '![Implementing menu states](img/6821OT_05_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![实现菜单状态](img/6821OT_05_02.jpg)'
- en: 'These are essentially sprite sheets with the three states of our button. Let''s
    create a new class for these buttons, which we will call `MenuButton`. Go ahead
    and create `MenuButton.h` and `MenuButton.cpp`. We will start with the header
    file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是包含我们按钮三个状态的原生精灵表。让我们为这些按钮创建一个新的类，我们将称之为`MenuButton`。现在创建`MenuButton.h`和`MenuButton.cpp`文件。我们将从头文件开始：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By now this should look very familiar and it should feel straightforward to
    create new types. We will also define our button states as an enumerated type
    so that our code becomes more readable; put this in the header file under `private`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该看起来非常熟悉，创建新类型应该感觉很简单。我们还将定义我们的按钮状态为一个枚举类型，这样我们的代码就更容易阅读；在头文件中的`private`部分放入以下内容：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open up the `MenuButton.cpp` file and we can start to flesh out our `MenuButton`
    class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MenuButton.cpp`文件，我们可以开始充实我们的`MenuButton`类：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only thing really new in this class is the `update` function. Next, we
    will go through each step of this function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中真正新的东西只有`update`函数。接下来，我们将逐步介绍这个函数的每个步骤：
- en: 'First, we get the coordinates of the mouse pointer and store them in a pointer
    to a `Vector2D` object:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们获取鼠标指针的坐标并将它们存储在一个指向`Vector2D`对象的指针中：
- en: '[PRE24]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, check whether the mouse is over the button or not. We do this by first
    checking whether the mouse position is less than the position of the right-hand
    side of the button (*x position + width*). We then check if the mouse position
    is greater than the position of the left-hand side of the button (*x position*).
    The y-position check is essentially the same with *y position + height* and *y
    position* for bottom and top respectively:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，检查鼠标是否在按钮上。我们首先检查鼠标位置是否小于按钮右侧的位置（*x位置 + 宽度*）。然后检查鼠标位置是否大于按钮左侧的位置（*x位置*）。y位置检查与*y位置
    + 高度*和*y位置*对于底部和顶部分别相同：
- en: '[PRE25]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the previous check is true, we know that the mouse is hovering over our
    button; we set its frame to `MOUSE_OVER (1)`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前一个检查为真，我们知道鼠标悬停在按钮上；我们将它的框架设置为`MOUSE_OVER (1)`：
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then check whether the mouse has been clicked; if it has, then we set
    the current frame to `CLICKED(2)`:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以检查鼠标是否被点击；如果是，则将当前框架设置为`CLICKED(2)`：
- en: '[PRE27]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the check is not true, then we know the mouse is outside the button and
    we set the frame to `MOUSE_OUT (0)`:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检查不为真，那么我们知道鼠标在按钮外，我们将框架设置为`MOUSE_OUT (0)`：
- en: '[PRE28]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now test out our reusable button class. Open up our previously created
    `MenuState.hand`, which we will implement for real. First, we are going to need
    a vector of `GameObject*` to store our menu items:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试我们的可重用按钮类。打开我们之前创建的`MenuState.hand`，我们将为其实际实现。首先，我们需要一个`GameObject*`的向量来存储我们的菜单项：
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the `MenuState.cpp` file, we can now start handling our menu items:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MenuState.cpp`文件中，我们现在可以开始处理我们的菜单项：
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `onExit` and `onEnter` functions can be defined as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`onExit`和`onEnter`函数可以定义如下：'
- en: '[PRE31]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We use `TextureManager` to load our new images and then assign these textures
    to two buttons. The `TextureManager` class also has a new function called `clearFromTextureMap`,
    which takes the ID of the texture we want to remove; it is defined as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TextureManager`来加载我们的新图像，然后将这些纹理分配给两个按钮。`TextureManager`类还有一个名为`clearFromTextureMap`的新函数，它接受我们想要删除的纹理的ID；它定义如下：
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function enables us to clear only the textures from the current state,
    not the entire texture map. This is essential when we push states and then pop
    them, as we do not want the popped state to clear the original state's textures.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使我们能够仅从当前状态中清除纹理，而不是整个纹理图。当我们推送状态然后弹出它们时，这是非常重要的，因为我们不希望弹出的状态清除原始状态的纹理。
- en: 'Everything else is essentially identical to how we handle objects in the `Game`
    class. Run the project and we will have buttons that react to mouse events. The
    window will look like the following screenshot (go ahead and test it out):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切都是本质上与我们在`Game`类中处理对象的方式相同。运行项目，我们将有对鼠标事件做出反应的按钮。窗口将看起来像以下截图（请继续测试它）：
- en: '![Implementing menu states](img/6821OT_05_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![实现菜单状态](img/6821OT_05_03.jpg)'
- en: Function pointers and callback functions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针和回调函数
- en: 'Our buttons react to rollovers and clicks but do not actually do anything yet.
    What we really want to achieve is the ability to create `MenuButton` and pass
    in the function we want it to call once it is clicked; we can achieve this through
    the use of function pointers. Function pointers do exactly as they say: they point
    to a function. We can use classic C style function pointers for the moment, as
    we are only going to use functions that do not take any parameters and always
    have a return type of `void` (therefore, we do not need to make them generic at
    this point).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮对悬停和点击做出反应，但实际上还没有做任何事情。我们真正想要实现的是创建`MenuButton`并传递我们想要它在点击时调用的函数的能力；我们可以通过使用函数指针来实现这一点。函数指针确实如其所言：它们指向一个函数。我们可以暂时使用经典的C风格函数指针，因为我们只将使用不接受任何参数且总是返回类型为`void`的函数（因此，我们目前不需要使它们泛型）。
- en: 'The syntax for a function pointer is like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针的语法如下：
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We declare our function pointer as a private member in `MenuButton.h` as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`MenuButton.h`中将我们的函数指针声明为私有成员，如下所示：
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also add a new member variable to handle clicking better:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新的成员变量来更好地处理点击：
- en: '[PRE35]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can alter the constructor to allow us to pass in our function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改构造函数，以便我们可以传递我们的函数：
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In our `MenuButton.cpp` file, we can now alter the constructor and initialize
    our pointer with the initialization list:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MenuButton.cpp`文件中，我们现在可以修改构造函数并使用初始化列表初始化我们的指针：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `update` function can now call this function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数现在可以调用此函数：'
- en: '[PRE38]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that this `update` function now uses the `m_bReleased` value to ensure
    we release the mouse button before doing the callback again; this is how we want
    our clicking to behave.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`update`函数现在使用`m_bReleased`值来确保我们在再次进行回调之前释放鼠标按钮；这是我们想要的点击行为。
- en: 'In our `MenuState.h` object, we can declare some functions that we will pass
    into the constructors of our `MenuButton` objects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MenuState.h`对象中，我们可以声明一些函数，这些函数将传递到我们的`MenuButton`对象的构造函数中：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have declared these functions as static; this is because our callback functionality
    will only support static functions. It is a little more complicated to handle
    regular member functions as function pointers, so we will avoid this and stick
    to static functions. We can define these functions in the `MenuState.cpp` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些函数声明为静态的；这是因为我们的回调功能只支持静态函数。将常规成员函数作为函数指针处理要复杂一些，因此我们将避免这样做，坚持使用静态函数。我们可以在`MenuState.cpp`文件中定义这些函数：
- en: '[PRE40]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can pass these functions into the constructors of our buttons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些函数传递到按钮的构造函数中：
- en: '[PRE41]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Test our project and you will see our functions printing to the console. We
    are now passing in the function we want our button to call once it is clicked;
    this functionality is great for our buttons. Let''s test the exit button with
    some real functionality:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的项目，你将看到我们的函数正在打印到控制台。我们现在正在传递我们想要在按钮点击时调用的函数；这对我们的按钮功能来说非常好。让我们用一些实际的功能测试退出按钮：
- en: '[PRE42]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now clicking on our exit button will exit the game. The next step is to allow
    the `s_menuToPlay` function to move to `PlayState`. We first need to add a getter
    to the `Game.h` file to allow us to access the state machine:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击我们的退出按钮将退出游戏。下一步是允许`s_menuToPlay`函数移动到`PlayState`。我们首先需要在`Game.h`文件中添加一个获取器，以便我们可以访问状态机：
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now use this to change states in `MenuState`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个来在`MenuState`中改变状态：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Go ahead and test; `PlayState` does not do anything yet, but our console output
    should show the movement between states.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，去测试一下；`PlayState`目前还没有做任何事情，但我们的控制台输出应该显示状态之间的移动。
- en: Implementing the temporary play state
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现临时播放状态
- en: 'We have created `MenuState`; next, we need to create `PlayState` so that we
    can visually see the change in our states. For `PlayState` we will create a player
    object that uses our `helicopter.png` image and follows the mouse around. We will
    start with the `Player.cpp` file and add the code to make the `Player` object
    follow the mouse position:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`MenuState`；接下来，我们需要创建`PlayState`以便我们可以直观地看到状态的变化。对于`PlayState`，我们将创建一个使用我们的`helicopter.png`图像并跟随鼠标移动的玩家对象。我们将从`Player.cpp`文件开始，并添加代码使`Player`对象跟随鼠标位置：
- en: '[PRE45]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we get the current mouse location; we can then get a vector that leads
    from the current position to the mouse position by subtracting the current position
    from the mouse position. We then divide the velocity by a scalar to slow us down
    a little and allow us to see our helicopter catch up to the mouse rather than
    stick to it. Our `PlayState.h` file will now need its own vector of `GameObject*`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取当前的鼠标位置；然后我们可以通过从鼠标位置减去当前位置来获取一个指向鼠标位置的向量。然后我们将速度除以一个标量以稍微减慢速度，并允许我们看到我们的直升机追上鼠标而不是粘附在它上面。现在我们的`PlayState.h`文件将需要它自己的`GameObject*`向量：
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we must update the `PlayState.cpp` implementation file to use our
    `Player` object:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新`PlayState.cpp`实现文件以使用我们的`Player`对象：
- en: '[PRE47]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This file is very similar to the `MenuState.cpp` file, but this time we are
    using a `Player` object rather than the two `MenuButton` objects. There is one
    adjustment to our `SDLGameObject.cpp` file that will make `PlayState` look even
    better; we are going to flip the image file depending on the velocity of the object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件与`MenuState.cpp`文件非常相似，但这次我们使用了一个`Player`对象而不是两个`MenuButton`对象。我们对`SDLGameObject.cpp`文件进行了一次调整，这将使`PlayState`看起来更加出色；我们将根据对象的速率翻转图像文件：
- en: '[PRE48]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We check whether the object''s velocity is more than `0` (moving to the right-hand
    side) and flip the image accordingly. Run our game and you will now have the ability
    to move between `MenuState` and `PlayState` each with their own functionality
    and objects. The following screenshot shows our project so far:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查对象的速率是否大于`0`（向右移动）并相应地翻转图像。运行我们的游戏，你现在将能够在这两个状态`MenuState`和`PlayState`之间移动，每个状态都有其自己的功能和对象。以下截图显示了我们的项目到目前为止的情况：
- en: '![Implementing the temporary play state](img/6821OT_05_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![实现临时播放状态](img/6821OT_05_04.jpg)'
- en: Pausing the game
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: 'Another very important state for our games is the pause state. Once paused,
    the game could have all kinds of options. Our `PauseState` class will be very
    similar to the `MenuState`, but with different button visuals and callbacks. Here
    are our two new screenshots (again available in the source code download):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏来说，另一个非常重要的状态是暂停状态。一旦暂停，游戏可以有多种选项。我们的 `PauseState` 类将与 `MenuState` 类非常相似，但具有不同的按钮视觉和回调。以下是我们的两个新截图（同样可在源代码下载中找到）：
- en: '![Pausing the game](img/6821OT_05_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![暂停游戏](img/6821OT_05_05.jpg)'
- en: 'The following screenshot shows the resume functionality:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了恢复功能：
- en: '![Pausing the game](img/6821OT_05_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![暂停游戏](img/6821OT_05_06.jpg)'
- en: 'Let''s start by creating our `PauseState.h` file in the project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目中创建我们的 `PauseState.h` 文件：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, create our `PauseState.cpp` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建我们的 `PauseState.cpp` 文件：
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In our `PlayState.cpp` file, we can now use our new `PauseState` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PlayState.cpp` 文件中，我们现在可以使用我们新的 `PauseState` 类：
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This function listens for the *Esc* key being pressed, and once it has been
    pressed, it then pushes a new `PauseState` class onto the state array in FSM.
    Remember that `pushState` does not remove the old state; it merely stops using
    it and uses the new state. Once we are done with the pushed state, we remove it
    from the state array and the game continues to use the previous state. We remove
    the pause state using the resume button''s callback:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数监听 *Esc* 键被按下，一旦按下，它就会将一个新的 `PauseState` 类推入 FSM 的状态数组。记住，`pushState` 不会移除旧状态；它只是停止使用它并使用新状态。一旦我们完成推入的状态，我们就从状态数组中移除它，游戏继续使用之前的状态。我们使用恢复按钮的回调来移除暂停状态：
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The main menu button takes us back to the main menu and completely removes
    any other states:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单按钮将带我们回到主菜单，并完全移除任何其他状态：
- en: '[PRE53]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating the game over state
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏结束状态
- en: 'We are going to create one final state, `GameOverState`. To get to this state,
    we will use collision detection and a new `Enemy` object in the `PlayState` class.
    We will check whether the `Player` object has hit the `Enemy` object, and if so,
    we will change to our `GameOverState` class. Our Enemy object will use a new image
    `helicopter2.png`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个最终的状态，`GameOverState`。要进入此状态，我们将在 `PlayState` 类中使用碰撞检测和新的 `Enemy` 对象。我们将检查
    `Player` 对象是否击中了 `Enemy` 对象，如果是，我们将切换到我们的 `GameOverState` 类。我们的敌人对象将使用一个新的图像 `helicopter2.png`：
- en: '![Creating the game over state](img/6821OT_05_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束状态](img/6821OT_05_07.jpg)'
- en: 'We will make our `Enemy` object''s helicopter move up and down the screen just
    to keep things interesting. In our `Enemy.cpp` file, we will add this functionality:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使 `Enemy` 对象的直升机在屏幕上下移动，以保持游戏的趣味性。在我们的 `Enemy.cpp` 文件中，我们将添加此功能：
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can now add an `Enemy` object to our `PlayState` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向我们的 `PlayState` 类添加一个 `Enemy` 对象：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the game will allow us to see our two helicopters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏将允许我们看到我们的两架直升机：
- en: '![Creating the game over state](img/6821OT_05_08.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束状态](img/6821OT_05_08.jpg)'
- en: 'Before we cover collision detection, we are going to create our `GameOverState`
    class. We will be using two new images for this state, one for new `MenuButton`
    and one for a new type, which we will call `AnimatedGraphic`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍碰撞检测之前，我们将创建我们的 `GameOverState` 类。我们将为此状态使用两个新的图像，一个用于新的 `MenuButton`，另一个用于一种新类型，我们将称之为
    `AnimatedGraphic`：
- en: '![Creating the game over state](img/6821OT_05_09.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束状态](img/6821OT_05_09.jpg)'
- en: 'The following screenshot shows the game over functionality:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了游戏结束功能：
- en: '![Creating the game over state](img/6821OT_05_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束状态](img/6821OT_05_10.jpg)'
- en: '`AnimatedGraphic` is very similar to other types, so I will not go into too
    much detail here; however, what is important is the added value in the constructor
    that controls the speed of the animation, which sets the private member variable
    `m_animSpeed`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimatedGraphic` 与其他类型非常相似，所以这里不会过多介绍；然而，重要的是构造函数中添加的值，它控制动画的速度，并设置私有成员变量
    `m_animSpeed`：'
- en: '[PRE56]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `update` function will use this value to set the speed of the animation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数将使用此值来设置动画的速度：'
- en: '[PRE57]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we have the `AnimatedGraphic` class, we can implement our `GameOverState`
    class. Create `GameOverState.h` and `GameOverState.cpp` in our project; the header
    file we will create should look very familiar, as given in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `AnimatedGraphic` 类，我们可以实现我们的 `GameOverState` 类。在我们的项目中创建 `GameOverState.h`
    和 `GameOverState.cpp`；我们将创建的头文件应该看起来非常熟悉，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our implementation file is also very similar to other files already covered,
    so again I will only cover the parts that are different. First, we define our
    static variables and functions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现文件也与已覆盖的其他文件非常相似，所以我又会只介绍不同的部分。首先，我们定义我们的静态变量和函数：
- en: '[PRE59]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `onEnter` function will create three new objects along with their textures:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEnter`函数将创建三个新对象及其纹理：'
- en: '[PRE60]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That is pretty much it for our `GameOverState` class, but we must now create
    a condition that creates this state. Move to our `PlayState.h` file and we will
    create a new function to allow us to check for collisions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`GameOverState`类，基本上就是这样，但我们现在必须创建一个条件来创建这个状态。移动到我们的`PlayState.h`文件，我们将创建一个新函数，允许我们检查碰撞：
- en: '[PRE61]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will define this function in `PlayState.cpp`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`PlayState.cpp`中定义这个函数：
- en: '[PRE62]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function checks for collisions between two `SDLGameObject` types. For
    the function to work, we need to add three new functions to our `SDLGameObject`
    class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查两个`SDLGameObject`类型之间的碰撞。为了让这个函数工作，我们需要向我们的`SDLGameObject`类添加三个新函数：
- en: '[PRE63]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The next chapter will deal with how this function works, but for now, it is
    enough to know that it does. Our `PlayState` class will now utilize this collision
    detection in its `update` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍这个函数是如何工作的，但到目前为止，知道它确实存在就足够了。我们的`PlayState`类现在将在其`update`函数中使用这种碰撞检测：
- en: '[PRE64]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We have to use a `dynamic_cast` object to cast our `GameObject*` class to an
    `SDLGameObject*` class. If `checkCollision` returns `true`, then we add the `GameOverState`
    class. The following screenshot shows the `GameOver` state:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用一个`dynamic_cast`对象将我们的`GameObject*`类转换为`SDLGameObject*`类。如果`checkCollision`返回`true`，则添加`GameOverState`类。以下截图显示了`GameOver`状态：
- en: '![Creating the game over state](img/6821OT_05_11.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束状态](img/6821OT_05_11.jpg)'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has left us with something a lot more like a game than in previous
    chapters. We have created states for menus, pause, play, and game over with each
    state having its own functionality and being handled using FSM. The `Game` class
    now uses FSM to render and update game objects and it does not now handle objects
    directly, as each individual state handles its own objects. We have also created
    simple callback functions for our buttons using function pointers and static functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章留给我们的东西比之前章节更像一个游戏。我们为菜单、暂停、播放和游戏结束创建了状态，每个状态都有其自己的功能，并且使用FSM进行处理。现在`Game`类使用FSM来渲染和更新游戏对象，它不再直接处理对象，因为每个单独的状态都处理其自己的对象。我们还使用函数指针和静态函数为我们的按钮创建了简单的回调函数。
