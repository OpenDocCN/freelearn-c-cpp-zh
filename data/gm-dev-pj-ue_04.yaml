- en: 4\. Player Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 玩家输入
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will tackle the subject of player input. We will learn how to associate
    a keypress or touch input from a touch-enabled device with an in-game action such
    as jumping or moving.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解决玩家输入的主题。我们将学习如何将玩家的按键或触摸输入与游戏中的动作（如跳跃或移动）关联起来。
- en: By the end of this chapter, you will know about `Action Mappings` and `Axis
    Mappings`, how to create and modify them, how to listen to each of those mappings,
    how to execute in-game actions when they're pressed and released, and how to preview
    your game as if you were playing on a mobile device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解“动作映射”和“轴映射”，如何创建和修改它们，如何监听每个映射，如何在按下和释放时执行游戏中的动作，以及如何预览您的游戏，就像您在移动设备上玩一样。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we created our C++ class that inherits from the `Character`
    class and added all the necessary `Actor` components to be able to see the game
    from that character's perspective, as well as being able to see the character
    itself. We then created a `Blueprint` class that inherits from that C++ class,
    in order to visually set up all its necessary components. We also learned briefly
    about Action and Axis Mappings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个从“Character”类继承的C++类，并添加了所有必要的“Actor”组件，以便能够从该角色的视角看到游戏，并且能够看到角色本身。然后，我们创建了一个从该C++类继承的“蓝图”类，以便可以直观地设置所有必要的组件。我们还简要了解了动作和轴映射。
- en: In this chapter, we will be going more in-depth on these topics, as well as
    covering their C++ usage. We will learn about how player input works in UE4, how
    the engine handles input events (*key presses and releases*), and how we can use
    them to control logic in our game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地讨论这些主题，并涵盖它们在C++中的使用。我们将了解玩家输入在UE4中的工作原理，引擎如何处理输入事件（按键按下和释放），以及我们如何利用它们来控制游戏中的逻辑。
- en: Let's start this chapter by getting to know how UE4 abstracts the keys pressed
    by the player to make it easier for you to be notified of those events.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解UE4如何将玩家按下的键抽象出来开始本章，以便更容易地通知您这些事件。
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will be using an alternative version of the `Character`
    blueprint we created, called `BP_MyTPC`, in the previous chapter. This chapter's
    version will have the default UE4 Mannequin mesh and not one from Mixamo.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们在上一章中创建的“Character”蓝图的另一个版本，称为“BP_MyTPC”。本章的版本将具有默认的UE4 Mannequin网格，而不是来自Mixamo的网格。
- en: Input Actions and Axes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入动作和轴
- en: 'Player input is the thing that distinguishes video games from other entertainment
    media: the fact that they''re interactive. For a video game to be interactive,
    it must take into account the player''s input. Many games do this by allowing
    the player to control a virtual character that acts upon the virtual world it''s
    in, depending on the keys and buttons that the player presses, which is exactly
    what we''ll be doing in this chapter.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家输入是区分视频游戏与其他娱乐媒体的因素：它们是互动的事实。要使视频游戏具有互动性，必须考虑玩家的输入。许多游戏通过允许玩家控制虚拟角色来实现这一点，该角色根据玩家按下的键和按钮在虚拟世界中行动，这正是我们将在本章中要做的事情。
- en: Most game development tools nowadays allow you to abstract keypresses into Actions
    and Axes, which allow you to associate a name (for example, *Jump*) with several
    different player inputs (pressing a button, flicking a thumbstick, and so on).
    The difference between Actions and Axes is that Actions are used for binary inputs
    (inputs that can either be pressed or released, like the keys on the keyboard),
    while Axes are used for inputs that are scalar or continuous (that is, that can
    have a range of values, like thumbsticks, which can go from `–1` to `1` on both
    the *x* and *y* axes).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数游戏开发工具都允许您将按键抽象为动作和轴，这使您可以将名称（例如“跳跃”）与多种不同的玩家输入（按下按钮，轻扫摇杆等）关联起来。动作和轴的区别在于，动作用于二进制输入（可以按下或释放的输入，如键盘上的键），而轴用于标量或连续输入（即可以具有一系列值的输入，如摇杆，可以在“x”和“y”轴上从“-1”到“1”）。
- en: For instance, if you're making a racing game where the further you pull down
    the gamepad's right trigger button, the more the car accelerates, that would be
    an `Axis`, because its value can range from `0` to `1`. However, if you wanted
    to allow the player to pause the game, that would be an Action, because it only
    requires knowing whether or not the player has pressed a certain key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在制作一款赛车游戏，在该游戏中，您越拉动游戏手柄的右扳机按钮，汽车就会加速得越快，那将是一个“轴”，因为它的值可以在0到1之间变化。但是，如果您希望玩家能够暂停游戏，那将是一个动作，因为它只需要知道玩家是否按下了某个特定的键。
- en: Usually, it's not a very good idea to have the player character jump when the
    player presses the *Spacebar* key explicitly, but instead to have the player jump
    when the *Jump* action is pressed. This *Jump* action can then have its associated
    keys edited elsewhere so that both developers and players can easily change which
    key causes the player character to jump. This is how UE4 allows you to specify
    player input events (although you can also listen to explicit keypresses as well,
    this is usually not the best way to go).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当玩家明确按下“空格键”时，使玩家角色跳跃并不是一个很好的主意，而是在按下“跳跃”动作时使玩家跳跃。然后，可以在其他地方编辑此“跳跃”动作的相关键，以便开发人员和玩家都可以轻松更改导致玩家角色跳跃的键。这就是UE4允许您指定玩家输入事件的方式（尽管您也可以监听明确的按键，但这通常不是最佳选择）。
- en: Open your UE4 project and go to the `Project Settings` window. You can do this
    by either clicking `Edit` in the top-left corner of the editor and then selecting
    `Project Settings…`, or by clicking `Settings` in the editor `Toolbar` and then
    selecting `Project Settings…`
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的UE4项目并转到“项目设置”窗口。您可以通过单击编辑器左上角的“编辑”，然后选择“项目设置…”，或者单击编辑器工具栏中的“设置”，然后选择“项目设置…”来执行此操作。
- en: This window will allow you to modify several settings related to your project,
    in a wide variety of categories. If you scroll down the left edge of `Project
    Settings`, you should find the `Input` option under the `Engine` category, which
    will take you to your project's input settings. Click this option.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口将允许您修改与项目相关的多个设置，涵盖各种类别。如果您在`Project Settings`的左边缘向下滚动，您应该会在`Engine`类别下找到`Input`选项，它将带您到项目的输入设置。点击此选项。
- en: 'When you do, you should see the input settings at the right edge of the window,
    where you''ll be able to access your project''s `Action Mappings` and `Axis Mappings`,
    among other things:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，您应该会看到窗口右边的输入设置，您将能够访问项目的`Action Mappings`和`Axis Mappings`等内容：
- en: '![Figure 4.1: The Action and Axis Mappings available in the Input settings
    window'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：输入设置窗口中可用的Action和Axis Mappings'
- en: '](img/B16183_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_01.jpg)'
- en: 'Figure 4.1: The Action and Axis Mappings available in the Input settings window'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：输入设置窗口中可用的Action和Axis Mappings
- en: The `Action Mappings` property allows you to specify a list of actions in your
    project (for example, the *Jump* action) and their corresponding keys (for example,
    the *Spacebar* key).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action Mappings`属性允许您在项目中指定动作列表（例如*跳跃*动作）及其对应的键（例如*空格键*）。'
- en: '`Axis Mappings` allows you to do the same thing, but for keys that do not have
    a binary value (either pressed or released) but instead have a continuous value,
    like the thumbsticks on a controller whose values can go from `–1` to `1` on the
    *x* and *y* axes, or the trigger buttons on a controller whose values can go from
    `0` to `1`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axis Mappings`允许您做同样的事情，但适用于没有二进制值（按下或释放）而是具有连续值的键，比如控制器上的摇杆，其值可以在*x*和*y*轴上从`–1`到`1`，或者控制器上的扳机按钮，其值可以在`0`到`1`之间。'
- en: 'For example, consider an Xbox One controller, which can be broken down into
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Xbox One控制器，可以分解为以下部分：
- en: '`Left analog stick`, usually used for controlling movement in games'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`左摇杆`，通常用于控制游戏中的移动'
- en: '`Dpad`, which can be used for controlling movement, as well as having a variety
    of other uses'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dpad`，可用于控制移动，以及具有各种其他用途'
- en: '`Right analog stick`, usually used for controlling the camera and view perspective'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`右摇杆`，通常用于控制相机和视角'
- en: '`Face buttons (X, Y, A, and B)`, which can have various uses depending on the
    game, but usually allow the player to perform actions in the game world'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Face buttons (X, Y, A, and B)`，根据游戏可以有各种用途，但通常允许玩家在游戏世界中执行动作'
- en: '`Bumpers and Triggers (LB, RB, LT, and RT)`, which can be used for actions
    such as aiming and shooting or accelerating and braking'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bumpers and Triggers (LB, RB, LT, and RT)`，可用于瞄准和射击或加速和刹车等动作'
- en: You can also set up binary keys as axes if you want to; for instance, set up
    the player character's movement for both a gamepad thumbstick (which is a continuous
    key whose value goes from `–1` to `1`) and two binary keys on the keyboard (*W*
    and *S*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，还可以将二进制键设置为轴；例如，为玩家角色的移动设置游戏手柄摇杆（连续键，其值从`–1`到`1`）和键盘上的两个二进制键（*W*和*S*）。
- en: We'll be taking a look at how to do this in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看看如何做到这一点。
- en: When we generated the `Third Person` template project back in *Chapter 1*, *Unreal
    Engine Introduction*, it came with some inputs already configured, which were
    *W*, *A*, *S*, and *D* keys, as well as the `left thumbstick` for movement and
    the `Space Bar` key and `gamepad bottom face` button for jumping.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第1章* *虚幻引擎介绍*中生成了`Third Person`模板项目时，它已经配置了一些输入，包括*W*、*A*、*S*和*D*键，以及用于移动的`左手柄摇杆`，以及用于跳跃的`空格键`和`游戏手柄底部面`按钮。
- en: Let's now add new `Action` and `Axis Mappings` in the next exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在下一个练习中添加新的`Action`和`Axis Mappings`。
- en: 'Exercise 4.01: Creating the Jump Action and Movement Axes'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：创建跳跃动作和移动轴
- en: In this exercise, we'll be adding a new `Action Mapping` for the *Jump* action
    and a couple of new `Axis Mappings` for the *Movement* action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为*跳跃*动作添加一个新的`Action Mapping`，以及为*移动*动作添加一对新的`Axis Mappings`。
- en: 'To achieve this, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请按照以下步骤进行：
- en: Open the `Input Settings` menu.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Input Settings`菜单。
- en: 'Press the `+` icon to the right of the `Action Mappings` property to create
    a new `Action Mapping`:![Figure 4.2: Adding a new Action Mapping'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Action Mappings`属性右侧的`+`图标以创建一个新的`Action Mapping`：![图4.2：添加新的Action Mapping
- en: '](img/B16183_04_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_02.jpg)'
- en: 'Figure 4.2: Adding a new Action Mapping'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：添加新的Action Mapping
- en: 'When you do so, you should see a new `Action Mapping` called `NewActionMapping_0`
    mapped to the `None` key (*meaning it''s not mapped to any key*):![Figure 4.3:
    The default settings of a new Action Mapping'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做时，您应该会看到一个名为`NewActionMapping_0`的新`Action Mapping`，映射到`None`键（*表示它未映射到任何键*）：![图4.3：新Action
    Mapping的默认设置
- en: '](img/B16183_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_03.jpg)'
- en: 'Figure 4.3: The default settings of a new Action Mapping'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：新Action Mapping的默认设置
- en: Change the name of this mapping to `Jump` and the key associated with it to
    the `Spacebar` key.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此映射的名称更改为`Jump`，并将与之关联的键更改为`空格键`。
- en: 'To change the key mapped to this action, you can click the drop-down property
    currently set to the `None` key, type `Space Bar`, and select the first option:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改与此动作映射的键，您可以点击当前设置为`None`键的下拉属性，输入`空格键`，并选择第一个选项：
- en: '![Figure 4.4: The key drop-down menu (top) where the Space'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：键下拉菜单（顶部），其中选择了空格键'
- en: Bar key is being selected (bottom)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正在选择Bar键（底部）
- en: '](img/B16183_04_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_04.jpg)'
- en: 'Figure 4.4: The key drop-down menu (top) where the Space Bar key is being selected
    (bottom)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：键下拉菜单（顶部），其中选择了空格键（底部）
- en: 'You can specify whether or not you want this action to be executed when the
    player presses the specified key while holding one of the modifier keys – `Shift`,
    `Ctrl`, `Alt`, or `Cmd`, by checking each of their appropriate checkboxes. You
    can also remove this key from this `Action Mapping` by clicking the `X` icon:![Figure
    4.5: The key drop-down menu and the options to specify modifier keys'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以指定当玩家按住修饰键`Shift`、`Ctrl`、`Alt`或`Cmd`时是否要执行此操作，通过勾选它们各自的适当复选框。您还可以通过单击`X`图标将此键从`Action
    Mapping`中移除：![图4.5：键下拉菜单和指定修饰键的选项
- en: and removing this key from this Action Mapping
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 并从这个`Action Mapping`中移除这个键
- en: '](img/B16183_04_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_05.jpg)'
- en: 'Figure 4.5: The key drop-down menu and the options to specify modifier keys
    and removing this key from this Action Mapping'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：键下拉菜单和指定修饰键的选项以及从这个Action Mapping中移除这个键
- en: 'To add a new key to an `Action Mapping`, you can simply click the `+` icon
    next to the name of that `Action Mapping`, and to remove an `Action Mapping` altogether,
    you can click the `x` icon next to it:![Figure 4.6: The name of the Action Mapping,
    with the + and x icons next to it'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向`Action Mapping`添加新的键，您可以简单地点击该`Action Mapping`名称旁边的`+`图标，要完全删除`Action Mapping`，您可以点击其旁边的`x`图标：![图4.6：Action
    Mapping的名称，旁边是+和x图标
- en: '](img/B16183_04_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_06.jpg)'
- en: 'Figure 4.6: The name of the Action Mapping, with the + and x icons next to
    it'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：Action Mapping的名称，旁边是+和x图标
- en: Let's now use a controller button to map to this `Action Mapping`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用控制器按钮来映射到这个`Action Mapping`。
- en: Because most gamepads have the same keys in very similar places, UE4 abstracts
    most of their keys to generic terms using the `Gamepad` prefix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数游戏手柄的键位非常相似，UE4使用`Gamepad`前缀将它们的大部分键抽象为通用术语。
- en: 'Add a new key to this `Action Mapping` and set that new key to be the `Gamepad
    Face Button Bottom` key. If you''re using an Xbox controller, this will be the
    `A` button, and if you''re using a PlayStation controller, this will be the `X` button:![Figure
    4.7: The Gamepad Face Button Bottom key added to the Jump Action Mapping'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向这个`Action Mapping`添加一个新的键，并将这个新的键设置为`Gamepad Face Button Bottom`键。如果您使用的是Xbox控制器，这将是`A`按钮，如果您使用的是PlayStation控制器，这将是`X`按钮：![图4.7：Gamepad
    Face Button Bottom键添加到Jump Action Mapping
- en: '](img/B16183_04_07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_07.jpg)'
- en: 'Figure 4.7: The Gamepad Face Button Bottom key added to the Jump Action Mapping'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：Gamepad Face Button Bottom键添加到Jump Action Mapping
- en: Now that we've set up our `Jump` `Action Mapping`, let's set up our `Movement
    Axis Mapping`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的`Jump` `Action Mapping`，让我们设置我们的`Movement Axis Mapping`。
- en: 'Click the `+` icon next to the `Axis Mappings` property to add a new `Axis
    Mapping`. This new `Axis Mapping` will be used to move the character left and
    right. Name it `MoveRight` and assign to it the `Gamepad Left Thumbstick X-Axis`
    key, so that the player can use the *x* axis of the left thumbstick to move the
    character left and right:![Figure 4.8: The MoveRight Axis Mapping with the Gamepad
    Left'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Axis Mappings`属性旁边的`+`图标，添加一个新的`Axis Mapping`。这个新的`Axis Mapping`将用于使角色左右移动。将其命名为`MoveRight`，并将其分配给`Gamepad
    Left Thumbstick X-Axis`键，以便玩家可以使用左手柄的*x*轴来使角色左右移动：![图4.8：MoveRight轴映射与Gamepad
    Left
- en: Thumbstick X-Axis key associated with it
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与之关联的Thumbstick X-Axis键
- en: '](img/B16183_04_08.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_08.jpg)'
- en: 'Figure 4.8: The MoveRight Axis Mapping with the Gamepad Left Thumbstick X-Axis
    key associated with it'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：MoveRight轴映射与与之关联的Gamepad Left Thumbstick X-Axis键
- en: If you look to the right of the key we assigned, instead of the modifier keys,
    you should see the `Scale` property of that key. This property will allow you
    to invert an axis so that the player moves left when the player tilts the thumbstick
    to the right and vice versa, as well as increasing or decreasing the sensitivity
    of an axis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到我们分配的键的右侧，您应该看到该键的`Scale`属性，该属性将允许您反转轴，使玩家在将拇指杆向右倾斜时向左移动，反之亦然，并增加或减少轴的灵敏度。
- en: To allow the player to move right and left using keyboard keys (which are either
    pressed or released and don't have a continuous value, unlike thumbsticks), we'll
    have to add two keys with inverted values on their scale.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许玩家使用键盘上的左右移动键（这些键要么按下要么释放，并不像拇指杆那样具有连续值），我们将不得不添加两个具有反向值的键。
- en: 'Add two more keys to this `Axis Mapping,` the first being the `D` key, with
    a `Scale` of `1`, and the second one being the `A` key, with a `Scale` of `–1`.
    This will cause the character to move right when the player presses the `D` key
    and to move left when the player presses the `A` key:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 向这个`Axis Mapping`添加两个新的键，第一个是`D`键，`Scale`为`1`，第二个是`A`键，`Scale`为`-1`。这将导致玩家按下`D`键时角色向右移动，按下`A`键时角色向左移动：
- en: '![Figure 4.9: The MoveRight Axis Mapping with both the Gamepad and keyboard
    keys'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：MoveRight轴映射，同时具有Gamepad和键盘键'
- en: '](img/B16183_04_09.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_09.jpg)'
- en: 'Figure 4.9: The MoveRight Axis Mapping with both the Gamepad and keyboard keys'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：MoveRight轴映射，同时具有Gamepad和键盘键
- en: 'After doing this, add another `Axis Mapping` with the name of `MoveForward`
    with the `Gamepad Left Thumbstick Y-Axis`, `W`, and `S` keys, the latter having
    a `Scale` of `–1`. This axis will be used to move the character forward and backward:![Figure
    4.10: The MoveForward Axis Mapping'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这样做之后，添加另一个名为`MoveForward`的`Axis Mapping`，使用`Gamepad Left Thumbstick Y-Axis`，`W`和`S`键，后者的`Scale`为`-1`。这个轴将用于使角色前后移动：![图4.10：MoveForward轴映射
- en: '](img/B16183_04_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_10.jpg)'
- en: 'Figure 4.10: The MoveForward Axis Mapping'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：MoveForward轴映射
- en: And with those steps completed, we've completed this chapter's first exercise,
    where you've learned how you can specify `Action` and `Axis` `Mappings` in UE4,
    allowing you to abstract which keys are responsible for which in-game actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这些步骤后，我们完成了本章的第一个练习，您已经学会了如何在UE4中指定`Action`和`Axis` `Mappings`，从而使您可以抽象出哪些键负责哪些游戏内操作。
- en: Let's now take a look at how UE4 handles player input and processes it within
    the game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看UE4如何处理玩家输入并在游戏中进行处理。
- en: Processing Player Input
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: Let's think about a situation where the player presses the *Jump* action, which
    is associated with the `Spacebar` key, to get the player character to jump. Between
    the moment the player presses the `Spacebar` key and the moment the game makes
    the player character jump, quite a few things have to connect those two events.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个情况，玩家按下与“空格键”相关联的*Jump*动作，使玩家角色跳跃。在玩家按下“空格键”和游戏使玩家角色跳跃之间，有很多事情要连接这两个事件。
- en: 'Let''s take a look at all the steps necessary that lead from one event to the
    other:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从一个事件到另一个事件所需的所有步骤：
- en: '`Hardware Input`: The player presses the `Spacebar` key. UE4 will be listening
    to this keypress event.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬件输入：玩家按下“空格键”。UE4将监听此按键事件。
- en: 'The `PlayerInput` class: After the key is pressed or released, this class will
    translate that key into an action or axis. If there is an action or axis associated
    with that key, it will notify all classes that are listening to the action that
    it was just pressed, released, or updated. In this case, it will know that the
    `Spacebar` key is associated with the *Jump* action.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “PlayerInput”类：在按键被按下或释放后，这个类将把该按键转换为一个动作或轴。如果有一个与该按键相关联的动作或轴，它将通知所有监听该动作的类，该按键刚刚被按下、释放或更新。在这种情况下，它将知道“空格键”与*Jump*动作相关联。
- en: 'The `Player Controller` class: This is the first class to receive these events,
    given that it''s used to represent a player in the game.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Player Controller”类：这是第一个接收这些事件的类，因为它用于代表游戏中的玩家。
- en: 'The `Pawn` class: This class (and consequently the `Character` class, which
    inherits from it) can also listen to those events, as long as they are possessed
    by a Player Controller. If so, it will receive these events after that class.
    In this chapter, we will be using our `Character` C++ class to listen to action
    and axis events.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Pawn”类：这个类（因此也是从它继承的“Character”类）也可以监听这些事件，只要它们被玩家控制器所控制。如果是这样，它将在该类之后接收这些事件。在本章中，我们将使用我们的“Character”C++类来监听动作和轴事件。
- en: Now that we know how UE4 handles player inputs, let's take a look at the `DefaultInput.ini`
    file and how it works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道UE4如何处理玩家输入，让我们来看看“DefaultInput.ini”文件以及它的工作原理。
- en: DefaultInput.ini
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefaultInput.ini
- en: If you go to your project's directory, using File Explorer, and then open its
    `Config` folder, you'll find some `.ini` files in it, one of which should be the
    `DefaultInput.ini` file. As the name suggests, this file holds the main settings
    and configuration for input-related properties.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入项目的目录，使用文件资源管理器，然后打开其“Config”文件夹，您会在其中找到一些“.ini”文件，其中之一应该是“DefaultInput.ini”文件。顾名思义，这个文件保存了与输入相关的主要设置和配置。
- en: In the first exercise of this chapter, where we edited the project's `Input`
    settings, what was happening, in reality, was that the editor was writing to and
    reading from the `DefaultInput.ini` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个练习中，我们编辑了项目的“输入”设置，实际上是编辑器在写入和读取“DefaultInput.ini”文件。
- en: 'Open this file in a text editor of your choice. It contains many properties,
    but the ones we want to take a look at now are the list of `Action Mappings` and
    `Axis Mappings`. Near the end of the file, you should see, for instance, the *Jump*
    action being specified in this file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的文本编辑器中打开此文件。它包含许多属性，但我们现在要查看的是“Action Mappings”和“Axis Mappings”列表。在文件末尾附近，您应该看到，例如，*Jump*动作在此文件中被指定为：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also see some axes being specified, such as the `MoveRight` axis:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到一些轴被指定，比如“MoveRight”轴：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of editing the project's `Input Settings`, you can directly edit this
    file to add, modify, and remove `Action Mappings` and `Axis Mappings`, although
    this isn't a very user-friendly way to do so. Keep in mind that this file will
    also be available when you package your project to an executable file, which means
    that the player will be able to edit this file to their liking.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接编辑此文件以添加、修改和删除“Action Mappings”和“Axis Mappings”，而不是编辑项目的“输入设置”，尽管这不是一个非常用户友好的方式。请记住，当您将项目打包到可执行文件时，此文件也将可用，这意味着玩家可以根据自己的喜好编辑此文件。
- en: Let's now see how we can listen to `Action Mappings` and `Axis Mappings` in
    C++ in the next exercise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何在C++中监听“Action Mappings”和“Axis Mappings”。
- en: 'Exercise 4.02: Listening to Movement Actions and Axes'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：监听移动动作和轴
- en: In this exercise, we will register the actions and axes we created in the previous
    section with our character class by binding those actions and axes to specific
    functions in our character class using C++.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用C++将我们在上一节中创建的动作和轴注册到我们的角色类中，通过将这些动作和轴绑定到我们角色类中的特定函数。
- en: 'For a `Player Controller` or `Character` to listen to Actions and Axes, the
    main way to do that is by registering the `Action` and `Axis` delegates using
    the `SetupPlayerInputComponent` function. The `MyThirdPersonChar` class should
    already have a declaration and an implementation for this function. Let''s have
    our character class listen to those events by following these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“Player Controller”或“Character”来监听动作和轴，主要的方法是使用“SetupPlayerInputComponent”函数注册“Action”和“Axis”委托。
    “MyThirdPersonChar”类应该已经有一个声明和实现这个函数。让我们的角色类通过以下步骤监听这些事件：
- en: 'Open the `MyThirdPersonChar` class header file in Visual Studio and make sure
    there''s a declaration for a `protected` function called `SetupPlayerInputComponent`
    that returns nothing and receives a `class UInputComponent* PlayerInputComponent`
    property as a parameter. This function should be marked as both `virtual` and
    `override`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开“MyThirdPersonChar”类头文件，并确保有一个名为“SetupPlayerInputComponent”的“protected”函数的声明，它返回空，并接收一个“class
    UInputComponent* PlayerInputComponent”属性作为参数。这个函数应该被标记为“virtual”和“override”：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open this class''s source file and make sure this function has an implementation:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个类的源文件，并确保这个函数有一个实现：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside its implementation, start by calling the `PlayerInputComponent` property''s
    `BindAction` function. This function will allow this class to listen to a specific
    action, in this case, the `Jump` action. It receives the following parameters:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其实现中，首先调用`PlayerInputComponent`属性的`BindAction`函数。这个函数允许这个类监听特定的动作，这种情况下是`Jump`动作。它接收以下参数：
- en: '`FName ActionName` – The name of the action we want to listen to; in our case,
    the `Jump` action.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FName ActionName` - 我们想要监听的动作的名称；在我们的情况下是`Jump`动作。'
- en: '`EInputEvent InputEvent` – The specific key event we want to listen to, which
    can be pressed, released, double-clicked, and so on. In our case, we want to listen
    to the pressed event, which we can specify by using the `IE_Pressed` value.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EInputEvent InputEvent` - 我们想要监听的特定按键事件，可以是按下、释放、双击等。在我们的情况下，我们想要监听按下事件，可以通过使用`IE_Pressed`值来指定。'
- en: '`UserClass* Object` – The object that the callback function will be called
    on; in our case, the `this` pointer.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserClass* Object` - 回调函数将在其上调用的对象；在我们的例子中是`this`指针。'
- en: '`FInputActionHandlerSignature::TUObjectMethodDelegate< UserClass >::FMethodPtr
    Func` – This property is a bit wordy, but is essentially a pointer to the function
    that will be called when this event happens, which we can specify by typing `&`
    followed by the class''s name, followed by `::`, followed by the function''s name.
    In our case, we want this to be the existing `Jump` function belonging to the
    `Character` class, so we''ll specify it with `&ACharacter::Jump`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FInputActionHandlerSignature::TUObjectMethodDelegate< UserClass >::FMethodPtr
    Func` - 这个属性有点啰嗦，但本质上是一个指向当事件发生时将被调用的函数的指针，我们可以通过输入`&`后跟类名，后跟`::`，后跟函数名来指定。在我们的情况下，我们希望这是属于`Character`类的现有`Jump`函数，所以我们将用`&ACharacter::Jump`来指定它。'
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All functions used to listen to actions must receive no parameters unless you
    use `Delegates`, which are outside the scope of this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于监听动作的函数都必须不接收任何参数，除非您使用`Delegates`，这超出了本书的范围。
- en: 'In order to tell our character to stop jumping, you''ll have to duplicate this
    line and then change the new line''s input event to `IE_Released` and the function
    that''s called to be the `Character` class''s `StopJumping` function instead:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让角色停止跳跃，您需要复制这一行，然后将新行的输入事件更改为`IE_Released`，被调用的函数更改为`Character`类的`StopJumping`函数。
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because we''ll be using the `InputComponent` class, we''ll need to include
    it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用`InputComponent`类，所以我们需要在源文件的顶部包含它：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we''re listening to the `Jump` action and having the character jump
    when that action is executed, let''s move on to its movement. Inside the class''s
    header file, add a declaration for a `protected` function called `MoveRight`,
    which returns nothing and receives a `float Value` parameter. This is the function
    that will be called when the value of the `MoveRight` axis is updated:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在监听`Jump`动作，并且在执行该动作时使角色跳跃，让我们继续进行其移动。在类的头文件中，添加一个名为`MoveRight`的`protected`函数的声明，它不返回任何内容，并接收一个`float
    Value`参数。这个函数将在`MoveRight`轴的值更新时被调用。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the class''s source file, add this function''s implementation, where we''ll
    start by checking whether the `Controller` property is valid (not a `nullptr`)
    and whether the `Value` property is different than `0`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加这个函数的实现，我们将首先检查`Controller`属性是否有效（不是`nullptr`），以及`Value`属性是否不等于`0`：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If both these conditions are true, we''ll want to move our character using
    the `AddMovementInput` function. One of the parameters of this function is the
    direction in which you want the character to move. To calculate this direction,
    we''ll need to do two things:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这两个条件都为真，我们将使用`AddMovementInput`函数来移动我们的角色。这个函数的一个参数是角色移动的方向。为了计算这个方向，我们需要做两件事：
- en: 'Get the camera''s rotation on the *z* axis (yaw), so that we move the character
    relative to where the camera is looking. To achieve this, we can create a new
    `FRotator` property with a value of `0` for pitch (rotation along the *y* axis)
    and roll (rotation along the *x* axis) and the value of the camera''s current
    yaw for the property''s yaw. To get the camera''s yaw value, we can call the Player
    Controller''s `GetControlRotation` function and then access its `Yaw` property:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取摄像机在*z*轴（偏航）上的旋转，以便我们根据摄像机的朝向移动角色。为了实现这一点，我们可以创建一个新的`FRotator`属性，俯仰（*y*轴上的旋转）和翻滚（*x*轴上的旋转）的值为`0`，属性的偏航值为摄像机当前的偏航值。要获取摄像机的偏航值，我们可以调用玩家控制器的`GetControlRotation`函数，然后访问它的`Yaw`属性。
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now call the `AddMovementInput` function, passing as parameters the
    `Direction` and `Value` properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用`AddMovementInput`函数，传递`Direction`和`Value`属性作为参数。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because we''ll be using both the `KismetMathLibrary` and `Controller` objects,
    we''ll need to include them at the top of this source file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将同时使用`KismetMathLibrary`和`Controller`对象，所以我们需要在这个源文件的顶部包含它们：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After listening to the `Jump` action, inside this class''s `SetupPlayerInputComponent`
    function, listen to the `MoveRight` axis by calling the `PlayerInputComponent`
    property''s `BindAxis` function. This function is used to listen to an Axis instead
    of an Action, and the only difference between its parameters and the `BindAction`
    function''s parameters is that it doesn''t need to receive an `EInputState` parameter.
    Pass as parameters to this function `"MoveRight"`, the `this` pointer, and this
    class''s `MoveRight` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类的`SetupPlayerInputComponent`函数中监听`MoveRight`轴，通过调用`PlayerInputComponent`属性的`BindAxis`函数。这个函数用于监听轴而不是动作，其参数与`BindAction`函数的参数之间唯一的区别是它不需要接收`EInputState`参数。将`"MoveRight"`、`this`指针和这个类的`MoveRight`函数作为参数传递给这个函数。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All functions used to listen to an axis must receive a `float` property as a
    parameter unless you use `Delegates`, which is outside the scope of this book.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于监听轴的函数都必须接收一个`float`属性作为参数，除非您使用`Delegates`，这超出了本书的范围。
- en: 'Let''s now listen to the `MoveForward` axis in this class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在这个类中监听`MoveForward`轴：
- en: 'In the class''s header file, add a similar declaration to that of the `MoveRight`
    function, but name it `MoveForward` instead:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的头文件中，添加一个类似于`MoveRight`函数的声明，但将其命名为`MoveForward`：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the class''s source file, add an implementation to this new `MoveForward`
    function. Copy the implementation of the `MoveRight` function into this new implementation,
    but replace the call to the `KismetMathLibrary` object''s `GetRightVector` function
    with the call to its `GetForwardVector` function. This will use the vector representing
    the direction the camera is facing instead of its Right Vector, which faces its
    right:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，为这个新的`MoveForward`函数添加一个实现。将`MoveRight`函数的实现复制到这个新的实现中，但用其`GetForwardVector`函数的调用替换`KismetMathLibrary`对象的`GetRightVector`函数的调用。这将使用表示摄像头面向方向的向量，而不是其右向量，其面向右侧：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `SetupPlayerInputComponent` function''s implementation, duplicate the
    line of code that listens to the `MoveRight` axis and replace the first parameter
    with `"MoveForward"` and the last parameter with a pointer to the `MoveForward`
    function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputComponent`函数的实现中，复制监听`MoveRight`轴的代码行，并将第一个参数替换为`"MoveForward"`，将最后一个参数替换为指向`MoveForward`函数的指针：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now compile your code, open the editor, and open your `BP_MyTPS` Blueprint asset.
    Delete the `InputAction Jump` event, as well as the nodes connected to it. Do
    the same for the `InputAxis MoveForward` and `InputAxis MoveRight` events. We
    will be replicating this logic in C++ and need to remove its Blueprint functionality,
    so that there are no conflicts when handling input.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译您的代码，打开编辑器，并打开您的`BP_MyTPS`蓝图资产。删除`InputAction Jump`事件，以及与之连接的节点。对于`InputAxis
    MoveForward`和`InputAxis MoveRight`事件也做同样的操作。我们将在C++中复制这个逻辑，并需要删除其蓝图功能，以便在处理输入时不会发生冲突。
- en: 'Now, play the level. You should be able to move the character using the keyboard''s
    `W,` `A`, `S`, and `D` keys or the controller''s left thumbstick, as well as jumping
    with the `Spacebar` key or `gamepad face button bottom`:![Figure 4.11: The player
    character moving'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，播放关卡。您应该能够使用键盘的`W`、`A`、`S`和`D`键或控制器的左摇杆来移动角色，以及使用`Spacebar`键或`游戏手柄底部按钮`来跳跃：![图4.11：玩家角色移动
- en: '](img/B16183_04_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_11.jpg)'
- en: 'Figure 4.11: The player character moving'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：玩家角色移动
- en: After following all these steps, you have concluded this exercise. You now know
    how to listen to `Action` and `Axis` events using C++ in UE4.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了所有这些步骤后，您已经完成了这个练习。现在您知道如何在UE4中使用C++监听`Action`和`Axis`事件。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of listening to a specific `Action` or `Axis`, you can listen to a specific
    key by using the `PlayerInputComponent` property's `BindKey` function. This function
    receives the same parameters as the `BindAction` function, except for the first
    parameter, which should be a key instead of an `FName`. You can specify keys by
    using the `EKeys` enum followed by `::`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`PlayerInputComponent`属性的`BindKey`函数来监听特定的按键，而不是监听特定的“Action”或“Axis”。该函数接收与`BindAction`函数相同的参数，除了第一个参数应该是一个键而不是`FName`。您可以使用`EKeys`枚举后跟`::`来指定键。
- en: Now that we've set up all the logic necessary to have our character move and
    jump, let's add the logic responsible for rotating the camera around our character.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了所有必要的逻辑，使我们的角色移动和跳跃，让我们添加负责围绕角色旋转摄像头的逻辑。
- en: Turning the camera around the character
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕角色转动摄像头
- en: Cameras are an extremely important part of games, as they dictate what and how
    the player will see your game throughout the play session. When it comes to third-person
    games, which is the case for this project, the camera allows you not only to see
    the world around them but also the character you're controlling. Whether the character
    is taking damage, falling, or something else, it's important for the player to
    always know the state of the character they are controlling and to be able to
    have the camera face the direction they choose.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头是游戏中非常重要的一部分，因为它决定了玩家在整个游戏过程中看到的内容和方式。对于本项目来说，摄像头允许您不仅看到周围的世界，还可以看到您正在控制的角色。无论角色是否受到伤害、跌落或其他情况，玩家始终知道他们正在控制的角色的状态，并且能够使摄像头面向他们选择的方向是非常重要的。
- en: Much like with every modern, third-person game, we will always have the camera
    rotate around our player character. To have our camera rotate around our character,
    after setting up the `Camera` and `Spring Arm` components in *Chapter 2*, *Working
    with Unreal Engine*, let's continue by adding two new `Axis Mappings`, the first
    one called `Turn`, which is associated with the `Gamepad Right Thumbstick X-Axis`
    and `MouseX` keys, and the second one called `LookUp`, which is associated with
    the `Gamepad Right Thumbstick Y-Axis` and `MouseY` keys, this latter key having
    a scale of `-1`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个现代的第三人称游戏一样，我们将始终使摄像头围绕我们的玩家角色旋转。在*第2章*“使用虚幻引擎”中设置了`Camera`和`Spring Arm`组件之后，让我们继续添加两个新的“轴映射”，第一个称为`Turn`，与`Gamepad
    Right Thumbstick X-Axis`和`MouseX`键相关联，第二个称为`LookUp`，与`Gamepad Right Thumbstick
    Y-Axis`和`MouseY`键相关联，后者的比例为`-1`。
- en: 'These `Axis Mappings` will be used to have the player look right and left as
    well as up and down, respectively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“轴映射”将用于使玩家向右和向左以及向上和向下查看：
- en: '![Figure 4.12: The Turn and LookUp Axis Mappings'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：转动和LookUp轴映射'
- en: '](img/B16183_04_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_12.jpg)'
- en: 'Figure 4.12: The Turn and LookUp Axis Mappings'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：转动和LookUp轴映射
- en: Let's now add the C++ logic responsible for turning the camera with the player's input.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加负责根据玩家输入旋转摄像头的C++逻辑。
- en: Go to the `MyThirdPersonChar` class's `SetupPlayerInputComponent` function implementation
    and duplicate either the line responsible for listening to the `MoveRight` axis
    or the `MoveForward` axis twice. In the first duplicated line, change the first
    parameter to `"Turn"` and the last parameter to the `Pawn` class's `AddControllerYawInput`
    function, while the second duplicated line should have the first parameter be
    `"LookUp"` and the last parameter be the `Pawn` class's `AddControllerPitchInput`
    function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`MyThirdPersonChar`类的`SetupPlayerInputComponent`函数实现，并将负责监听`MoveRight`轴或`MoveForward`轴的行重复两次。在第一行的副本中，将第一个参数更改为“Turn”，最后一个参数更改为`Pawn`类的`AddControllerYawInput`函数，而第二行的副本应该将第一个参数设置为“LookUp”，最后一个参数设置为`Pawn`类的`AddControllerPitchInput`函数。
- en: 'These two functions are responsible for adding rotation input around the *z*
    (turning left and right) and *y* (looking up and down) axes, respectively:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数分别负责围绕*z*（左右转向）和*y*（上下查看）轴添加旋转输入：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you compile the changes made in this section, open the editor, and play
    the level, you should now be able to move the camera by rotating the mouse or
    by tilting the controller''s right thumbstick:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编译了本节中所做的更改，打开编辑器并播放级别，现在您应该能够通过旋转鼠标或倾斜控制器的右摇杆来移动摄像机：
- en: '![Figure 4.13: The camera is rotated around the player'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13：摄像机围绕玩家旋转'
- en: '](img/B16183_04_13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_13.jpg)'
- en: 'Figure 4.13: The camera is rotated around the player'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：摄像机围绕玩家旋转
- en: And that concludes the logic to rotate the camera around the player character
    with the player's input. In the next exercise, we'll take a broad look at the
    topic of mobile platforms such as Android and iOS.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了使用玩家输入围绕玩家角色旋转摄像机的逻辑。在下一个练习中，我们将广泛地了解移动平台，如Android和iOS。
- en: Mobile platforms
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平台
- en: Thanks to recent advancements in technology, the majority of the population
    now has access to affordable mobile devices such as smartphones and tablets. These
    devices, although small, still have quite a bit of processing power and can now
    do many things that bigger devices such as laptops and desktop computers do. One
    of those things is playing video games.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术的最新进展，现在大多数人口都可以使用价格实惠的移动设备，如智能手机和平板电脑。这些设备虽然小，但仍具有相当大的处理能力，现在可以做许多像笔记本电脑和台式电脑这样大的设备可以做的事情之一就是玩视频游戏。
- en: Because mobile devices are much more affordable and versatile than other devices
    you can play video games on, you have a lot of people playing games on them. For
    this reason, it's worth considering developing video games for mobile platforms
    such as Android and iOS, the two biggest mobile app stores.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为移动设备比其他设备更实惠和多功能，您有很多人在上面玩游戏。因此，值得考虑为移动平台（如Android和iOS，两个最大的移动应用商店）开发视频游戏。
- en: Let's now take a look at how to preview our game on a virtual mobile device
    in the next exercise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看一下如何在下一个练习中在虚拟移动设备上预览我们的游戏。
- en: 'Exercise 4.03: Previewing on Mobile'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：在移动设备上预览
- en: In this exercise, we'll be playing our game using `Mobile Preview`, to see what
    it's like to play our game on a mobile device. Before we can do this, we have
    to go to the `Android Platform` settings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用“移动预览”来玩我们的游戏，以了解在移动设备上玩我们的游戏是什么感觉。在这之前，我们必须进入“Android平台”设置。
- en: 'Have a look at the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤：
- en: 'Open the `Project Settings` window and scroll down its left edge until you
    find the `Android` option beneath the `Platforms` category. Click that option.
    You should see the following to the right of the categories:![Figure 4.14: The
    Android Platform window warning that the project'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“项目设置”窗口，并在其左侧边滚动，直到在“平台”类别下找到“Android”选项。单击该选项。您应该会在类别右侧看到以下内容：![图4.14：Android平台窗口警告项目
- en: currently isn’t configured for that platform
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚未为该平台配置
- en: '](img/B16183_04_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_14.jpg)'
- en: 'Figure 4.14: The Android Platform window warning that the project currently
    isn''t configured for that platform'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：Android平台窗口警告项目当前尚未配置为该平台
- en: 'This warning is letting you know that the project has not yet been configured
    for Android. To change that, click the `Configure Now` button inside the *red
    warning*. When you do, it should be turned into a green warning, letting you know
    that the platform is configured:![Figure 4.15: The Android platform window notifying
    you that the project'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此警告是在告诉您项目尚未配置为Android。要更改此设置，请点击*红色警告*内的“立即配置”按钮。当您这样做时，它应该会变成绿色警告，告诉您平台已配置：![图4.15：Android平台窗口通知您项目
- en: is configured for this platform
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为此平台配置
- en: '](img/B16183_04_15.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_15.jpg)'
- en: 'Figure 4.15: The Android platform window notifying you that the project is
    configured for this platform'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：Android平台窗口通知您项目已为此平台配置
- en: 'After you''ve done this, you can close `Project Settings`, click the arrow
    next to the `Play` button in the editor''s toolbar, and select the `Mobile Preview`
    option you see available:![Figure 4.16: The Mobile Preview option under the Play
    button'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可以关闭“项目设置”，单击编辑器工具栏中“播放”按钮旁边的箭头，并选择您看到的“移动预览”选项：![图4.16：播放按钮下的移动预览选项
- en: '](img/B16183_04_16.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_16.jpg)'
- en: 'Figure 4.16: The Mobile Preview option under the Play button'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：播放按钮下的移动预览选项
- en: This will cause the engine to start loading this preview, as well as compiling
    all the necessary shaders, which should take a few minutes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致引擎开始加载此预览，并编译所有必要的着色器，这应该需要几分钟时间。
- en: 'When it''s done, you should see the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该会看到以下内容：
- en: '![Figure 4.17: The Mobile Preview window playing the game as if on an Android
    device'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17：移动预览窗口播放游戏，就像在Android设备上一样'
- en: '](img/B16183_04_17.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_17.jpg)'
- en: 'Figure 4.17: The Mobile Preview window playing the game as if on an Android
    device'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：移动预览窗口播放游戏，就像在Android设备上一样
- en: 'This preview should look similar to the normal preview inside the editor with
    a couple of notable differences:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个预览应该看起来与编辑器内的普通预览类似，但有一些显著的区别：
- en: The visual fidelity has been lowered. Because mobile platforms don't have the
    same type of computing power as PCs and consoles, the visual quality is lowered
    to take that into account. On top of that, some rendering features available in
    high-end platforms are simply not supported in mobile platforms.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉保真度已经降低。因为移动平台没有与PC和游戏机相同类型的计算能力，所以视觉质量会降低以考虑到这一点。此外，一些高端平台上可用的渲染功能在移动平台上根本不受支持。
- en: Two added virtual joysticks at the *lower-left* and *lower-right* corner of
    the screen, which work similarly to those of a controller, where the left joystick
    controls the character's movement and the right joystick controls the camera's
    rotation.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕的左下角和右下角添加了两个虚拟摇杆，它们的工作方式类似于控制器，左摇杆控制角色的移动，右摇杆控制摄像机的旋转。
- en: 'This window acts as a mobile screen where your mouse is your finger, so if
    you press and hold the left joystick using the left mouse button, and then drag
    it, that will cause the joystick to move on the screen and consequently make the
    character move, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口就像一个移动屏幕，你的鼠标就是你的手指，所以如果你按住左摇杆并拖动它，这将导致摇杆在屏幕上移动，从而使角色移动，就像下面的截图所示：
- en: '![Figure 4.18: The character is moved using the left virtual joystick'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18：使用左虚拟摇杆移动角色'
- en: '](img/B16183_04_18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_18.jpg)'
- en: 'Figure 4.18: The character is moved using the left virtual joystick'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：使用左虚拟摇杆移动角色
- en: And with that, we conclude this chapter by learning how to preview our game
    on the Android mobile platform and verify that its inputs are working.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们学会了如何在Android移动平台上预览我们的游戏，并验证其输入是否正常工作。
- en: Let's now jump into the next exercise, where we'll be adding touch input that
    causes the player character to jump.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入下一个练习，我们将添加触摸输入，使玩家角色跳跃。
- en: 'Exercise 4.04: Adding Touchscreen Input'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：添加触摸屏输入
- en: In this exercise, we'll be continuing from our previous exercise by making it
    so that the player character starts jumping when the player tabs the screen if
    they're playing on a touchscreen device.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续上一个练习，使玩家角色在玩家在触摸屏设备上点击屏幕时开始跳跃。
- en: 'To add touchscreen input to our game, follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的游戏添加触摸屏输入，请按照以下步骤进行：
- en: 'Go to the `MyThirdPersonChar` class''s header file and add two declarations
    for protected functions that return nothing and receive the `ETouchIndex::Type
    FingerIndex` and `FVector Location` parameters, the first one of which indicates
    the index of the finger that touched the screen (whether it was the first, second,
    or third finger to touch the screen) and the second one, which indicates the position
    that was touched on the screen. Name one of these functions `TouchBegin` and the
    other one `TouchEnd`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`MyThirdPersonChar`类的头文件，并添加两个声明受保护的函数，这两个函数返回空，并接收`ETouchIndex::Type FingerIndex`和`FVector
    Location`参数，第一个参数表示触摸屏幕的手指的索引（无论是第一个、第二个还是第三个手指），第二个参数表示触摸屏幕的位置。将其中一个函数命名为`TouchBegin`，另一个命名为`TouchEnd`：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `MyThirdPersonChar` class''s source file, add the implementation of
    both these functions, where the `TouchBegin` function will call the `Jump` function
    and the `TouchEnd` function will call the `StopJumping` function. This will cause
    our character to start jumping when the player touches the screen and to stop
    jumping when they stop touching the screen:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyThirdPersonChar`类的源文件中，添加这两个函数的实现，其中`TouchBegin`函数将调用`Jump`函数，而`TouchEnd`函数将调用`StopJumping`函数。这将导致我们的角色在玩家触摸屏幕时开始跳跃，并在他们停止触摸屏幕时停止跳跃：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Go to the `SetupPlayerInputComponent` function''s implementation and add two
    calls to the `BindTouch` function of `PlayerInputComponent`, which will bind the
    event of the screen being touched to a function. This function receives the same
    parameters as the `BindAction` function except for the first one, `ActionName`.
    In the first function call, pass as parameters the input event `IE_Pressed`, the
    `this` pointer, and this class''s `TouchBegin` function, and in the second call,
    pass the input event `IE_Released`, the `this` pointer, and this class''s `TouchEnd`
    function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`SetupPlayerInputComponent`函数的实现，并在`PlayerInputComponent`的`BindTouch`函数中添加两个调用，这将把屏幕被触摸的事件绑定到一个函数。这个函数接收与`BindAction`函数相同的参数，除了第一个参数`ActionName`。在第一个函数调用中，将输入事件`IE_Pressed`、`this`指针和这个类的`TouchBegin`函数作为参数传递，而在第二个调用中，将输入事件`IE_Released`、`this`指针和这个类的`TouchEnd`函数作为参数传递：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Preview the game using `Mobile Preview`, just like we did in the previous exercise.
    If you use the left mouse button to click the middle of the screen, the player
    character should jump:![Figure 4.19: The character jumping after clicking the
    middle of the screen'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Mobile Preview`预览游戏，就像我们在上一个练习中所做的那样。如果你用左鼠标按钮点击屏幕中间，玩家角色应该会跳跃：![图4.19：点击屏幕中间后角色跳跃
- en: '](img/B16183_04_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_19.jpg)'
- en: 'Figure 4.19: The character jumping after clicking the middle of the screen'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：点击屏幕中间后角色跳跃
- en: And with that, we conclude the logic that will make our character jump as long
    as the player is touching the screen if they're playing on a touchscreen device.
    Now that we've learned how to add inputs to our game and associate those inputs
    with in-game actions such as jumping and moving the player character, let's consolidate
    what we've learned in this chapter by adding a new `Walk` action to our game from
    start to finish in the next activity.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们完成了使我们的角色在玩家触摸屏幕时跳跃的逻辑。现在我们已经学会了如何向我们的游戏添加输入，并将这些输入与游戏内的动作（如跳跃和移动玩家角色）关联起来，让我们通过在下一个活动中从头到尾地向我们的游戏添加一个新的`Walk`动作来巩固我们在这一章中学到的知识。
- en: 'Activity 4.01: Adding Walking Logic to Our Character'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：为我们的角色添加行走逻辑
- en: In the current game, our character runs by default when we use the movement
    keys, but we need to reduce the character's speed and make it walk.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前游戏中，我们的角色在使用移动键时默认奔跑，但我们需要减少角色的速度并使其行走。
- en: So, in this activity, we'll be adding logic that will make our character walk
    when we move it while holding the `Shift` key on the keyboard or the `Gamepad
    Face Button Right` key (`B` for the Xbox controller and `O` for PlayStation controller).
    Further, we will preview it on a mobile platform as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个活动中，我们将添加逻辑，使我们的角色在按住键盘上的“Shift”键或“游戏手柄右侧按钮”键（Xbox控制器的“B”和PlayStation控制器的“O”）移动时行走。此外，我们还将在移动平台上进行预览。
- en: 'To do this, follow these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤：
- en: Open `Input Settings` through the `Project Settings` window.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过“项目设置”窗口打开“输入设置”。
- en: Add a new `Action Mapping` called `Walk` and associate it with the `Left Shift`
    and `Gamepad Face Button Right` keys.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“Walk”的新“Action Mapping”，并将其与“左Shift”和“游戏手柄右侧按钮”键关联。
- en: Open the `MyThirdPersonChar` class's header file and add declarations for two
    `protected` functions that return nothing and receive no parameters, called `BeginWalking`
    and `StopWalking`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MyThirdPersonChar”类的头文件，并添加两个返回空值并且不接收参数的“protected”函数的声明，分别称为“BeginWalking”和“StopWalking”。
- en: Add the implementations for both these functions in the class's source file.
    In the implementation of the `BeginWalking` function, change the character's speed
    to 40% of its value by modifying the `CharacterMovementComponent` property's `MaxWalkSpeed`
    property accordingly. To access the `CharacterMovementComponent` property, use
    the `GetCharacterMovement` function.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中为这两个函数添加实现。在“BeginWalking”函数的实现中，通过相应地修改“CharacterMovementComponent”属性的“MaxWalkSpeed”属性，将角色的速度改变为其值的40％。要访问“CharacterMovementComponent”属性，请使用“GetCharacterMovement”函数。
- en: The implementation for the `StopWalking` function will be the inverse of that
    of the `BeginWalking` function, which will increase the character's walk speed
    by 250%.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “StopWalking”函数的实现将是“BeginWalking”函数的相反，它将使角色的行走速度增加250％。
- en: Bind the `Walk` action to the `BeginWalking` function when that action is pressed,
    and to the `StopWalking` function when it is released.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下该动作时，将“行走”动作绑定到“BeginWalking”函数，并在释放时绑定到“StopWalking”函数。
- en: After following these steps, you should be able to have your character walk,
    which decreases its speed and slightly changes its animation, by holding either
    the keyboard's *Left Shift* key or the controller's *Face Button Right* button.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤后，您应该能够让您的角色行走，通过按住键盘的*左Shift*键或控制器的*右侧按钮*按钮来减慢速度并略微改变动画。
- en: '![Figure 4.20: The character running (left) and walking (right)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20：角色奔跑（左）和行走（右）'
- en: '](img/B16183_04_20.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_20.jpg)'
- en: 'Figure 4.20: The character running (left) and walking (right)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：角色奔跑（左）和行走（右）
- en: 'Let''s now preview our game on a mobile platform, as we did in *Exercise 4.03*,
    *Previewing on Mobile*, and drag the left analog stick just slightly to get our
    character to walk slowly. The result should look similar to the following screenshot:![Figure
    4.21: The character walking in the mobile preview'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在移动平台上预览我们的游戏，就像我们在*练习4.03*中所做的那样，在*移动预览*中轻轻拖动左摇杆，使我们的角色慢慢行走。结果应该类似于以下屏幕截图：![图4.21：移动预览中的角色行走
- en: '](img/B16183_04_21.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_04_21.jpg)'
- en: 'Figure 4.21: The character walking in the mobile preview'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：移动预览中的角色行走
- en: And that concludes our activity. Our character should now be able to walk slowly
    as long as the player is holding the `Walk` action.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的活动。 只要玩家按住“行走”动作，我们的角色现在应该能够慢慢地行走。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've learned how to add, remove, and modify `Action Mappings`
    and `Axis Mappings`, which give you some flexibility when determining which keys
    trigger a specific action or axis, how to listen to them, and how to execute in-game
    logic when they're pressed and released.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何添加、删除和修改“Action Mappings”和“Axis Mappings”，这在确定哪些键触发特定动作或轴，如何监听它们以及在按下和释放时如何执行游戏逻辑时，给您一些灵活性。
- en: Now that you know how to handle the player's input, you can allow the player
    to interact with your game and offer the agency that video games are so well known
    for.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何处理玩家的输入，您可以允许玩家与您的游戏进行交互，并提供视频游戏所广为人知的代理。
- en: In the next chapter, we'll start making our own game from scratch. It'll be
    called `Dodgeball` and will consist of the player controlling a character trying
    to run away from enemies that are throwing dodgeballs at it. In that chapter,
    we will have the opportunity to start learning about many important topics, with
    a heavy focus on collisions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始制作我们自己的游戏。 它将被称为“躲避球”，玩家将控制一个角色试图逃离向它投掷躲避球的敌人。 在那一章中，我们将有机会开始学习许多重要的主题，重点是碰撞。
