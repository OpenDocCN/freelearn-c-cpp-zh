["```cpp\n    int i = 42; \n    int *pi = &i;\n```", "```cpp\n    int *pi, i;\n```", "```cpp\n    int* pi, i;\n```", "```cpp\n    int *p1, *p2;\n```", "```cpp\n    int i = 42; \n    int *pi = &i; \n    int j = *pi;\n```", "```cpp\n    int i = 42; \n    cout << i << endl; \n    int *pi { &i }; \n    *pi = 99; \n    cout << i << endl;\n```", "```cpp\n    int *pi = nullptr; \n    // code \n    int i = 42; \n    pi = &i; \n    // code \n    if (nullptr != pi) cout << *pi << endl;\n```", "```cpp\n    char *p1 { \"hello\" }; \n    char *p2 { \"hello\" }; \n    cout << hex; \n    cout << reinterpret_cast<int>(p1) << endl; \n    cout << reinterpret_cast<int>(p2) << endl;\n```", "```cpp\n    int v[] { 1, 2, 3, 4, 5 };\n    int *pv = v;\n    *pv = 11;\n    v[1] = 12;\n    pv[2] = 13;\n    *(pv + 3) = 14;\n```", "```cpp\n    int v[] { 1, 2, 3, 4, 5 }; \n    int *pv = v; \n    for (int i = 0; i < 5; ++i) \n    { \n        *pv++ *= 3; \n    }\n```", "```cpp\n    pv += 1; // can do this \n    v += 1; // error\n```", "```cpp\n    int squares[4]; \n    for (int i = 0; i < 4; ++i)  \n    { \n        squares[i] = i * i; \n    }\n```", "```cpp\n    int squares[5]; \n    for (int i = 0; i < 4; ++i)  \n    { \n        squares[i] = i * i; \n    } \n    for(int i : squares) \n    { \n        cout << i << endl; \n    }\n```", "```cpp\n    constexpr int sq_size = 4; \n    int squares[sq_size]; \n    for (int i = 0; i < sq_size; ++i) \n    { \n        squares[i] = i * i; \n    }\n```", "```cpp\n    int squares[4]; \n    for (int i = 0; i < sizeof(squares)/sizeof(squares[0]); ++i) \n    { \n        squares[i] = i * i; \n    }\n```", "```cpp\n    // there are four tires on each car \n    bool safe_car(double tire_pressures[4]);\n```", "```cpp\n    double car[4] = get_car_tire_pressures(); \n    if (!safe_car(car)) cout << \"take off the road!\" << endl; \n    double truck[8] = get_truck_tire_pressures(); \n    if (!safe_car(truck)) cout << \"take off the road!\" << endl;\n```", "```cpp\n    bool safe_car(double tire_pressures[], int size);\n```", "```cpp\n    bool safe_car(double *tire_pressures, int size);\n```", "```cpp\n    int two[2]; \n    int four_by_three[4][3];\n```", "```cpp\n    int four_by_three[4][3] { 11,12,13,21,22,23,31,32,33,41,42,43 };\n```", "```cpp\n    int four_by_three[4][3] = { {11,12,13}, {21,22,23}, \n                                {31,32,33}, {41,42,43} };\n```", "```cpp\n    int four_by_three[4][3] = { {11,12,13}, {}, {31,32,33}, {41,42,43} };\n```", "```cpp\n    int four_by_three_by_two[4][3][2]  \n       = { { {111,112}, {121,122}, {131,132} }, \n           { {211,212}, {221,222}, {231,232} }, \n           { {311,312}, {321,322}, {331,332} }, \n           { {411,412}, {421,422}, {431,432} }  \n         };\n```", "```cpp\n    cout << four_by_three_by_two[3][2][0] << endl; // prints 431\n```", "```cpp\n    // pass the torque of the wheel nuts of all wheels \n    bool safe_torques(double nut_torques[4][5]);\n```", "```cpp\n    bool safe_torques(double nut_torques[][5], int num_wheels);\n```", "```cpp\n    bool safe_torques(double (*nut_torques)[5], int num_wheels);\n```", "```cpp\n    void main(int argc, char *argv[]);\n```", "```cpp\n    char p1[6]; \n    strcpy_s(p1, 6, \"hello\"); \n    char p2[6]; \n    strcpy_s(p2, 6, p1); \n    bool b = (p1 == p2);\n```", "```cpp\n    string s1(\"string\"); \n    string s2(\"string\"); \n    int result = s1.compare(s2);\n```", "```cpp\n    if (s1 == s2) \n    { \n        cout << \"strings are the same\" << endl; \n    }\n```", "```cpp\n    char pHello[5];          // enough space for 5 characters \n    strcpy(pHello, \"hello\");\n```", "```cpp\nerror C4996: 'strcpy': This function or variable may be unsafe. \nConsider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.\n```", "```cpp\n    #define _CRT_SECURE_NO_WARNINGS \n    #include <iostream>\n```", "```cpp\n    char pHello[5];             // enough space for 5 characters \n    strncpy(pHello, \"hello\", 5);\n```", "```cpp\n    size_t size = sizeof(pHello)/sizeof(pHello[0]); \n    strncpy_s(pHello, size, \"hello\", 5);\n```", "```cpp\n    strncpy_s(pHello, size, \"hello\", _TRUNCATE);\n```", "```cpp\n    int arr[] { 1, 2, 3, 4 }; \n    for (int i = 0; i < 4; ++i)  \n    { \n        arr[i] += arr[i + 1]; // oops, what happens when i == 3? \n    }\n```", "```cpp\n    char *get() \n    { \n        char c[] { \"hello\" };\n        return c;\n    }\n```", "```cpp\n    char c[] { \"hello\" }; // c can be used as a pointer \n    *c = 'H';             // OK, can write thru the pointer \n    const char *ptc {c};  // pointer to constant \n    cout << ptc << endl;  // OK, can read the memory pointed to \n    *ptc =  'Y';          // cannot write to the memory \n    char *const cp {c};   // constant pointer \n    *cp = 'y';            // can write thru the pointer \n    cp++;                 // cannot point to anything else\n```", "```cpp\n    char c[] { \"hello\" }; \n    char *const cp1 { c }; // cannot point to any other memory \n    *cp1 = 'H';            // can change the memory \n    const char *ptc = const_cast<const char*>(cp1); \n    ptc++;                 // change where the pointer points to \n    char *const cp2 = const_cast<char *const>(ptc); \n    *cp2 = 'a';            // now points to Hallo\n```", "```cpp\n    int *pi = static_cast<int*>(malloc(sizeof(int))); \n    *pi = 42; \n    cout << *pi << endl; \n    free(pi);\n```", "```cpp\n    wchar_t wc[] { L\"hello\" }; \n    wcout << wc << \" is stored in memory at \"; \n    wcout << hex; \n    wcout << reinterpret_cast<int>(wc) << endl;\n```", "```cpp\n    wcout << \"The characters are:\" << endl; \n    short* ps = reinterpret_cast<short*>(wc); \n    do  \n    {  \n        wcout << *ps << endl;  \n    } while (*ps++);\n```", "```cpp\n    int *p = new int; // allocate memory for one int\n```", "```cpp\n    delete p;\n```", "```cpp\n    int *p1 = new int (42); \n    int *p2 = new int {42};\n```", "```cpp\n    int *p = new int[2]; \n    p[0] = 1; \n    *(p + 1) = 2; \n    for (int i = 0; i < 2; ++i) cout << p[i] << endl; \n    delete [] p;\n```", "```cpp\n    // VERY_BIG_NUMER is a constant defined elsewhere \n    int *pi; \n    try \n    { \n        pi = new int[VERY_BIG_NUMBER]; \n        // other code \n    } \n    catch(const std::bad_alloc& e)  \n    {  \n        cout << \"cannot allocate\" << endl;  \n        return; \n    } \n    // use pointer \n    delete [] pi;\n```", "```cpp\n    int *pi = new (std::nothrow) int [VERY_BIG_NUMBER]; \n    if (nullptr == pi)  \n    { \n        cout << \"cannot allocate\" << endl; \n    } \n    else \n    { \n        // use pointer \n        delete [] pi; \n    }\n```", "```cpp\n    int *p1 = new int(42); \n    int *p2 = do_something(p1); \n    delete p1; \n    p1 = nullptr; \n    // what about p2?\n```", "```cpp\n    int *do_something(int *p) \n    { \n        *p *= 10; \n        return p; \n    }\n```", "```cpp\n    char * __stdcall GetCommandLine();\n```", "```cpp\n    //#include <windows.h>\n    cout << GetCommandLineA() << endl;\n```", "```cpp\n    char * __stdcall GetEnvironmentStrings();\n```", "```cpp\n    char *pBuf = GetEnvironmentStringsA(); \n    if (nullptr != pBuf) \n    { \n        char *pVar = pBuf; \n        while (*pVar) \n        { \n            cout << pVar << endl; \n            pVar += strlen(pVar) + 1; \n        } \n\n        FreeEnvironmentStringsA(pBuf); \n    }\n```", "```cpp\n    unsigned long __stdcall GetEnvironmentVariableA(const char *lpName,   \n        char *lpBuffer, unsigned long nSize);\n```", "```cpp\n    unsigned long size = GetEnvironmentVariableA(\"PATH\", nullptr, 0); \n    if (0 == size)  \n    { \n        cout << \"variable does not exist \" << endl; \n    } \n    else \n    { \n        char *val = new char[size]; \n        if (GetEnvironmentVariableA(\"PATH\", val, size) != 0) \n        { \n            cout << \"PATH = \";\n            cout << val << endl; \n        } \n        delete [] val; \n    }\n```", "```cpp\n    array<int, 4> arr { 1, 2, 3, 4 };\n```", "```cpp\n    for (int i : arr) cout << i << endl;\n```", "```cpp\n    for (int i = 0; i < arr.size(); ++i) cout << arr[i] << endl;\n```", "```cpp\n    void use_ten_ints(int*);\n```", "```cpp\n    int arr1[] { 1, 2, 3, 4 }; \n    use_ten_ints(arr1); // oops will read past the end of the buffer\n```", "```cpp\n    array<int, 4> arr2 { 1, 2, 3, 4 };  \n    use_ten_ints(arr2); // will not compile\n```", "```cpp\n    use_ten_ints(&arr2[0]);    // compiles, but on your head be it \n    use_ten_ints(arr2.data()); // ditto\n```", "```cpp\n    array<int, 4> arr3; \n    arr3.fill(42);   // put 42 in each item \n    arr2.swap(arr3); // swap items in arr2 with items in arr3\n```", "```cpp\n    int i = 42; \n    int *pi = &i;  // pointer to an integer \n    int& ri1 = i;  // reference to a variable \n    i = 99;        // change the integer thru the variable \n    *pi = 101;     // change the integer thru the pointer \n    ri1 = -1;      // change the integer thru the reference \n    int& ri2 {i};  // another reference to the variable \n    int j = 1000; \n    pi = &j;       // point to another integer\n```", "```cpp\n    int& r1;           // error, must refer to a variable \n    int& r2 = nullptr; // error, must refer to a variable\n```", "```cpp\n    int x = 1, y = 2;  \n    int& rx = x; // declaration, means rx is an alias for x \n    rx = y;      // assignment, changes value of x to the value of y\n```", "```cpp\n    int i = 42; \n    const int& ri = i; \n    ri = 99;           // error!\n```", "```cpp\n    cout << \"The value is \" << 42;\n```", "```cpp\n    ostream& operator<<(ostream& _Ostr, int _val);\n```", "```cpp\n    string& hello() \n    { \n        string str (\"hello\"); \n        return str; // don't do this! \n    }   // str no longer exists at this point\n```", "```cpp\n    const int& cri { 42 };\n```", "```cpp\n    void use_string(const string& csr);\n```", "```cpp\n    string str { \"hello\" }; \n    use_string(str);      // a std::string object \n    const char *cstr = \"hello\"; \n    use_string(cstr);     // a C string can be converted to a std::string \n    use_string(\"hello\");  // a literal can be converted to a std::string\n```", "```cpp\n    string global{ \"global\" }; \n\n    string& get_global() \n    { \n        return global; \n    } \n\n    string& get_static() \n    { \n        static string str { \"static\" }; \n        return str; \n    } \n\n    string get_temp() \n    { \n        return \"temp\"; \n    }\n```", "```cpp\n    cout << get_global() << endl; \n    cout << get_static() << endl; \n    cout << get_temp() << endl;\n```", "```cpp\n    void use_string(string& rs);\n```", "```cpp\n    void use_string(string& rs) \n    { \n        string s { rs }; \n        for (size_t i = 0; i < s.length(); ++i) \n        { \n            if ('a' == s[i] || 'b' == s[i] || 'o' == s[i])  \n            s[i] = '_'; \n        } \n        cout << s << endl; \n    }\n```", "```cpp\n    void use_string(string&& s) \n    { \n        for (size_t i = 0; i < s.length(); ++i) \n        { \n            if ('a' == s[i] || 'b' == s[i] || 'o' == s[i]) s[i] = '_'; \n        } \n        cout << s << endl; \n    }\n```", "```cpp\n    use_string(get_global()); // string&  version \n    use_string(get_static()); // string&  version \n    use_string(get_temp());   // string&& version \n    use_string(\"C string\");   // string&& version \n    string str{\"C++ string\"}; \n    use_string(str);          // string&  version\n```", "```cpp\n    constexpr int size = 4; \n    int squares[size]; \n\n    for (int i = 0; i < size; ++i) \n    { \n        squares[i] = i * i; \n    }\n```", "```cpp\n    for (int j : squares) \n    { \n        cout << J << endl; \n    }\n```", "```cpp\n    for (int& k : squares) \n    { \n        k *= 2; \n    }\n```", "```cpp\n    int arr[2][3] { { 2, 3, 4 }, { 5, 6, 7} };   \n    for (auto row : arr) \n    { \n        for (auto col : row) // will not compile\n        { \n            cout << col << \" \" << endl; \n        } \n    }\n```", "```cpp\n    for (auto& row : arr) \n    { \n        for (auto col : row) \n        { \n            cout << col << \" \" << endl; \n        } \n    }\n```", "```cpp\n    struct task \n    { \n        task* pNext; \n        string description; \n    };\n```", "```cpp\n    task item; \n    item.descrription = \"do something\";\n```", "```cpp\n    task* pTask = new task; \n    // use the object \n    delete pTask;\n```", "```cpp\n    task* pTask = new task; \n    pTask->descrription = \"do something\"; \n    // use the object \n    delete pTask;\n```", "```cpp\n    #include <iostream> \n    #include <string> \n    using namespace std; \n\n    int main() \n    {\n    }\n```", "```cpp\n    using namespace std;  \n struct task { task* pNext; string description; };\n```", "```cpp\n task* pHead = nullptr; task* pCurrent = nullptr;  \n    int main() \n    {\n    }\n```", "```cpp\ncl /EHsc tasks.cpp\n```", "```cpp\n    void queue_task(const string& name) \n    { \n        ...\n    }\n```", "```cpp\n    void queue_task(const string& name) \n    { \n task* pTask = new task; pTask->description = name; pTask->pNext = nullptr; \n    }\n```", "```cpp\n    if (nullptr == pHead) \n    { \n        pHead = pTask; \n        pCurrent = pTask; \n    } \n    else \n    { \n        pCurrent->pNext = pTask; \n        pCurrent = pTask; \n    }\n```", "```cpp\n    queue_task(\"remove old wallpaper\"); \n    queue_task(\"fill holes\"); \n    queue_task(\"size walls\"); \n    queue_task(\"hang new wallpaper\");\n```", "```cpp\n    bool remove_head() \n    { \n        if (nullptr == pHead) return false; \n        task* pTask = pHead; \n        pHead = pHead->pNext; \n        delete pTask; \n        return (pHead != nullptr); \n    }\n```", "```cpp\n    void destroy_list() \n    { \n        while (remove_head()); \n    }\n```", "```cpp\n destroy_list(); \n    }\n```", "```cpp\n    task *execute_task(const task* pTask) \n    { \n        if (nullptr == pTask) return nullptr; \n        cout << \"executing \" << pTask->description << endl; \n        return pTask->pNext; \n    }\n```", "```cpp\n    void execute_all() \n    { \n        task* pTask = pHead; \n        while (pTask != nullptr) \n        { \n            pTask = execute_task(pTask); \n        } \n    }\n```", "```cpp\n execute_all(); \n        destroy_list(); \n    }\n```", "```cpp\n    executing remove old wallpaper\nexecuting fill holes\n executing size walls executing hang new wallpaper\n```", "```cpp\n    task *find_task(const string& name) \n    { \n        task* pTask = pHead; \n\n        while (nullptr != pTask) \n        { \n            if (name == pTask->description) return pTask; \n            pTask = pTask->pNext; \n        }  \n        return nullptr; \n    }\n```", "```cpp\n    queue_task(\"hang new wallpaper\"); \n\n // oops, forgot to paint woodworktask\n    * pTask = find_task(\"fill holes\"); if (nullptr != pTask) { // insert new item after pTask } \n    execute_all();\n```", "```cpp\n    void insert_after(task* pTask, const string& name) \n    { \n        task* pNewTask = new task; \n        pNewTask->description = name; \n        if (nullptr != pTask) \n        { \n            pNewTask->pNext = pTask->pNext; \n            pTask->pNext = pNewTask; \n        } \n    }\n```", "```cpp\n    void insert_after(task* pTask, const string& name) \n    { \n        task* pNewTask = new task; \n        pNewTask->description = name; \n        if (nullptr != pTask) \n        { \n            pNewTask->pNext = pTask->pNext; \n            pTask->pNext = pNewTask; \n        } \n        else { pNewTask->pNext = pHead; pHead = pNewTask; } \n    }\n```", "```cpp\n    task* pTask = find_task(\"fill holes\"); \n    if (nullptr != pTask) \n    { \n insert_after(pTask, \"paint woodwork\"); \n    } \n insert_after(nullptr, \"cover furniture\");\n```", "```cpp\n executing cover furniture executing remove old wallpaper\nexecuting fill holes\nexecuting paint woodwork\nexecuting size walls\nexecuting hang new wallpaper\n```"]