["```cpp\n      #include <iostream>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          if (argc != 2) {\n              cout << \"Usage: \" << argv[0] << \" <path>n\";\n              return 1;\n          }\n\n          const path dir {argv[1]};\n```", "```cpp\n          if (!exists(dir)) {\n              cout << \"Path \" << dir << \" does not exist.n\";\n              return 1;\n          }\n```", "```cpp\n          cout << canonical(dir).c_str() << 'n';\n      }\n```", "```cpp\n      $ ./normalizer src\n      /Users/tfc/src\n```", "```cpp\n      $ ./normalizer Desktop/../Documents/../src\n      /Users/tfc/src\n```", "```cpp\npath canonical(const path& p, const path& base = current_path());\n```", "```cpp\npath canonical(const path& p, const path& base = current_path());\npath canonical(const path& p, error_code& ec);\npath canonical(const std::filesystem::path& p,\n               const std::filesystem::path& base,\n               std::error_code& ec );\n\n```", "```cpp\n      #include <iostream>\n      #include <filesystem>     \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      int main()\n      {\n          path p {\"testdir/foobar.txt\"};\n```", "```cpp\n          cout << \"current_path      : \" << current_path()\n               << \"nabsolute_path   : \" << absolute(p)\n               << \"nsystem_complete : \" << system_complete(p)\n               << \"ncanonical(p)    : \" << canonical(p)\n               << 'n';\n```", "```cpp\n          cout << path{\"testdir\"} / \"foobar.txt\" << 'n';\n```", "```cpp\n          cout << \"canonical testdir     : \"\n               << canonical(\"foobar.txt\", \n                            current_path() / \"testdir\")\n               << \"ncanonical testdir 2 : \"\n               << canonical(p, current_path() / \"testdir/..\") \n               << 'n';\n```", "```cpp\n          cout << \"equivalence: \"\n               << equivalent(\"testdir/foobar.txt\",\n                            \"testdir/../testdir/foobar.txt\") \n               << 'n';\n      }\n```", "```cpp\n      $ ./canonical_filepath\n      current_path    : \"/Users/tfc\"\n      absolute_path   : \"/Users/tfc/testdir/foobar.txt\"\n      system_complete : \"/Users/tfc/testdir/foobar.txt\"\n      canonical(p)    : \"/Users/tfc/testdir/foobar.txt\"\n      \"testdir/foobar.txt\"\n      canonical testdir   : \"/Users/tfc/testdir/foobar.txt\"\n      canonical testdir 2 : \"/Users/tfc/testdir/foobar.txt\"\n      equivalence: 1\n```", "```cpp\n      $ ./canonial_filepath \n      current_path    : \"/Users/tfc\"\n      absolute_path   : \"/Users/tfc/testdir/foobar.txt\"\n      system_complete : \"/Users/tfc/testdir/foobar.txt\"\n terminate called after throwing an instance of \n      'std::filesystem::v1::__cxx11::filesystem_error'\n        what():  filesystem error: cannot canonicalize: \n        No such file or directory [testdir/foobar.txt] [/Users/tfc]\n```", "```cpp\n      #include <iostream>\n      #include <sstream>\n      #include <iomanip>\n      #include <numeric>\n      #include <algorithm>\n      #include <vector>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\nstatic tuple<path, file_status, size_t> \n      file_info(const directory_entry &entry)\n      {\n          const auto fs (status(entry));\n          return {entry.path(),\n                  fs,\n                  is_regular_file(fs) ? file_size(entry.path()) : 0u};\n      }\n```", "```cpp\n      static char type_char(file_status fs)\n      {\n          if      (is_directory(fs))      { return 'd'; }\n          else if (is_symlink(fs))        { return 'l'; }\n          else if (is_character_file(fs)) { return 'c'; }\n          else if (is_block_file(fs))     { return 'b'; }\n          else if (is_fifo(fs))           { return 'p'; }\n          else if (is_socket(fs))         { return 's'; }\n          else if (is_other(fs))          { return 'o'; }\n          else if (is_regular_file(fs))   { return 'f'; }\n\n          return '?';\n      }\n```", "```cpp\n      static string rwx(perms p)\n      {\n          auto check ([p](perms bit, char c) {\n              return (p & bit) == perms::none ? '-' : c; \n          });\n\n          return {check(perms::owner_read,   'r'),\n                  check(perms::owner_write,  'w'),\n                  check(perms::owner_exec,   'x'),\n                  check(perms::group_read,   'r'),\n                  check(perms::group_write,  'w'),\n                  check(perms::group_exec,   'x'),\n                  check(perms::others_read,  'r'),\n                  check(perms::others_write, 'w'),\n                  check(perms::others_exec,  'x')};\n      }\n```", "```cpp\n      static string size_string(size_t size)\n      {\n          stringstream ss;\n          if        (size >= 1000000000) { \n              ss << (size / 1000000000) << 'G'; \n          } else if (size >= 1000000)    { \n              ss << (size / 1000000) << 'M';\n          } else if (size >= 1000)       { \n              ss << (size / 1000) << 'K'; \n          } else { ss << size << 'B'; }\n\n          return ss.str();\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          path dir {argc > 1 ? argv[1] : \".\"};\n\n          if (!exists(dir)) {\n              cout << \"Path \" << dir << \" does not exist.n\";\n              return 1;\n          }\n```", "```cpp\n          vector<tuple<path, file_status, size_t>> items;\n\n          transform(directory_iterator{dir}, {},\n              back_inserter(items), file_info);\n```", "```cpp\n          for (const auto &[path, status, size] : items) {\n              cout << type_char(status) \n                   << rwx(status.permissions()) << \" \"\n                   << setw(4) << right << size_string(size) \n                   << \" \" << path.filename().c_str() \n                   << 'n';\n          }\n      }\n```", "```cpp\n      $ ./list ~/Documents/cpp_reference/en/cpp\n      drwxrwxr-x    0B  algorithm\n      frw-r--r--   88K  algorithm.html\n      drwxrwxr-x    0B  atomic\n      frw-r--r--   35K  atomic.html\n      drwxrwxr-x    0B  chrono\n      frw-r--r--   34K  chrono.html\n      frw-r--r--   21K  comment.html\n      frw-r--r--   21K  comments.html\n      frw-r--r--  220K  compiler_support.html\n      drwxrwxr-x    0B  concept\n      frw-r--r--   67K  concept.html\n      drwxr-xr-x    0B  container\n      frw-r--r--  285K  container.html\n      drwxrwxr-x    0B  error\n      frw-r--r--   52K  error.html\n```", "```cpp\nfor (const directory_entry &e : directory_iterator{dir}) {\n    // do something\n}\n```", "```cpp\ntransform(directory_iterator{dir}, {},\n          back_inserter(items), file_info);\n```", "```cpp\n      #include <iostream>\n      #include <fstream>\n      #include <regex>\n      #include <vector>\n      #include <string>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      static vector<pair<size_t, string>> \n      matches(const path &p, const regex &re)\n      {\n          vector<pair<size_t, string>> d;\n          ifstream is {p.c_str()};\n```", "```cpp\n          string s;\n          for (size_t line {1}; getline(is, s); ++line) {\n              if (regex_search(begin(s), end(s), re)) {\n                  d.emplace_back(line, move(s));\n              }\n          }\n\n          return d;\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          if (argc != 2) {\n              cout << \"Usage: \" << argv[0] << \" <pattern>n\";\n              return 1;\n          }\n```", "```cpp\n          regex pattern;\n\n          try { pattern = regex{argv[1]}; }\n          catch (const regex_error &e) {\n              cout << \"Invalid regular expression provided.n\";\n              return 1;\n          }\n```", "```cpp\n          for (const auto &entry :\n                recursive_directory_iterator{current_path()}) {\n              auto ms (matches(entry.path(), pattern));\n```", "```cpp\n              for (const auto &[number, content] : ms) {\n                  cout << entry.path().c_str() << \":\" << number\n                       << \" - \" << content << 'n';\n              }\n          }\n      }\n```", "```cpp\n      foo\n      bar\n      baz\n```", "```cpp\n      $ ./grepper bar\n      /Users/tfc/testdir/dir1/text1.txt:1 - foo bar bla blubb\n      /Users/tfc/testdir/foobar.txt:2 - bar\n\n```", "```cpp\n      $ ./grepper baz\n      /Users/tfc/testdir/foobar.txt:3 - baz\n```", "```cpp\n$ renamer jpeg jpg JPEG jpg\n```", "```cpp\n      #include <iostream>\n      #include <regex>\n      #include <vector>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      template <typename T>\n      static string replace(string s, const T &replacements)\n      {\n          for (const auto &[pattern, repl] : replacements) {\n              s = regex_replace(s, pattern, repl);\n          }\n\n          return s;\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          if (argc < 3 || argc % 2 != 1) {\n              cout << \"Usage: \" << argv[0] \n                   << \" <pattern> <replacement> ...n\";\n              return 1;\n          }\n```", "```cpp\n          vector<pair<regex, string>> patterns;\n\n          for (int i {1}; i < argc; i += 2) {\n              patterns.emplace_back(argv[i], argv[i + 1]);\n          }\n```", "```cpp\n          for (const auto &entry :\n                recursive_directory_iterator{current_path()}) {\n              path opath {entry.path()};\n              string rname {replace(opath.filename().string(),\n                                    patterns)};\n\n              path rpath {opath};\n              rpath.replace_filename(rname);\n```", "```cpp\n              if (opath != rpath) {\n                  cout << opath.c_str() << \" --> \" \n                       << rpath.filename().c_str() << 'n';\n                  if (exists(rpath)) {\n                      cout << \"Error: Can't rename.\"\n                              \" Destination file exists.n\";\n                  } else {\n                      rename(opath, rpath);\n                  }\n              }\n          }\n      }\n```", "```cpp\n      $ ls\n      birthday_party.jpeg   holiday_in_dubai.jpg  holiday_in_spain.jpg \n      trip_to_new_york.JPEG\n      $ ../renamer jpeg jpg JPEG jpg\n      /Users/tfc/pictures/birthday_party.jpeg --> birthday_party.jpg\n      /Users/tfc/pictures/trip_to_new_york.JPEG --> trip_to_new_york.jpg\n      $ ls\n      birthday_party.jpg   holiday_in_dubai.jpg holiday_in_spain.jpg\n      trip_to_new_york.jpg\n```", "```cpp\n      #include <iostream>\n      #include <sstream>\n      #include <iomanip>\n      #include <numeric>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      static size_t entry_size(const directory_entry &entry)\n      {\n          if (!is_directory(entry)) { return file_size(entry); }\n```", "```cpp\n          return accumulate(directory_iterator{entry}, {}, 0u,\n              [](size_t accum, const directory_entry &e) {\n                  return accum + entry_size(e);\n              });\n      }\n```", "```cpp\n      static string size_string(size_t size)\n      {\n          stringstream ss;\n          if        (size >= 1000000000) { \n              ss << (size / 1000000000) << 'G'; \n          } else if (size >= 1000000)    { \n              ss << (size / 1000000) << 'M'; \n          } else if (size >= 1000)       { \n              ss << (size / 1000) << 'K'; \n          } else { ss << size << 'B'; }\n\n          return ss.str();\n      }  \n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          path dir {argc > 1 ? argv[1] : \".\"};\n\n          if (!exists(dir)) {\n              cout << \"Path \" << dir << \" does not exist.n\";\n              return 1;\n          }\n```", "```cpp\n          for (const auto &entry : directory_iterator{dir}) {\n              cout << setw(5) << right \n                   << size_string(entry_size(entry))\n                   << \" \" << entry.path().filename().c_str() \n                   << 'n';\n          }\n      }\n```", "```cpp\n      $ ./file_size ~/Documents/cpp_reference/en/\n        19M c\n        12K c.html\n       147M cpp\n        17K cpp.html\n        22K index.html\n        22K Main_Page.html\n```", "```cpp\n      #include <iostream>\n      #include <sstream>\n      #include <iomanip>\n      #include <map>\n      #include <filesystem>     \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      static string size_string(size_t size)\n      {\n          stringstream ss;\n          if        (size >= 1000000000) { \n              ss << (size / 1000000000) << 'G'; \n          } else if (size >= 1000000)    { \n              ss << (size / 1000000) << 'M'; \n          } else if (size >= 1000)       { \n              ss << (size / 1000) << 'K';\n          } else { ss << size << 'B'; }\n\n          return ss.str();\n      }\n```", "```cpp\n      static map<string, pair<size_t, size_t>> ext_stats(const path &dir)\n      {\n          map<string, pair<size_t, size_t>> m;\n\n          for (const auto &entry :\n                recursive_directory_iterator{dir}) {\n```", "```cpp\n              const path        p  {entry.path()};\n              const file_status fs {status(p)};\n\n              if (is_directory(fs)) { continue; }\n```", "```cpp\n              const string ext {p.extension().string()};\n\n              if (ext.length() == 0) { continue; }\n```", "```cpp\n              const size_t size {file_size(p)};\n\n              auto &[size_accum, count] = m[ext];\n\n              size_accum += size;\n              count      += 1;\n          }\n```", "```cpp\n          return m;\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          path dir {argc > 1 ? argv[1] : \".\"};\n\n          if (!exists(dir)) {\n              cout << \"Path \" << dir << \" does not exist.n\";\n              return 1;\n          }\n```", "```cpp\n          for (const auto &[ext, stats] : ext_stats(dir)) {\n              const auto &[accum_size, count] = stats;\n\n              cout << setw(15) << left << ext << \": \"\n                   << setw(4) << right << count \n                   << \" items, avg size \"\n                   << setw(4) << size_string(accum_size / count)\n                   << 'n';\n          }\n      }\n```", "```cpp\n      $ ./file_type ~/Documents/cpp_reference/\n      .css           :    2 items, avg size  41K\n      .gif           :    7 items, avg size 902B\n      .html          : 4355 items, avg size  38K\n      .js            :    3 items, avg size   4K\n      .php           :    1 items, avg size 739B\n      .png           :   34 items, avg size   2K\n      .svg           :   53 items, avg size   6K\n      .ttf           :    2 items, avg size 421K\n```", "```cpp\n      #include <iostream>\n      #include <fstream>\n      #include <unordered_map>\n      #include <filesystem>      \n\n      using namespace std;\n      using namespace filesystem;\n```", "```cpp\n      static size_t hash_from_path(const path &p)\n      {\n          ifstream is {p.c_str(), \n                       ios::in | ios::binary};\n          if (!is) { throw errno; }\n\n          string s;\n\n          is.seekg(0, ios::end);\n          s.reserve(is.tellg());\n          is.seekg(0, ios::beg);\n\n          s.assign(istreambuf_iterator<char>{is}, {});\n\n          return hash<string>{}(s);\n      }\n```", "```cpp\n      static size_t reduce_dupes(const path &dir)\n      {\n          unordered_map<size_t, path> m;\n          size_t count {0};\n\n          for (const auto &entry :\n                recursive_directory_iterator{dir}) {\n```", "```cpp\n              const path p {entry.path()};\n\n              if (is_directory(p)) { continue; }\n\n              const auto &[it, success] =\n                  m.try_emplace(hash_from_path(p), p);\n```", "```cpp\n              if (!success) {\n                  cout << \"Removed \" << p.c_str()\n                       << \" because it is a duplicate of \"\n                       << it->second.c_str() << 'n';\n\n                  remove(p);\n                  create_symlink(absolute(it->second), p);\n                  ++count;\n              }\n```", "```cpp\n          }\n\n          return count;\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          if (argc != 2) {\n              cout << \"Usage: \" << argv[0] << \" <path>n\";\n              return 1;\n          }\n\n          path dir {argv[1]};\n\n          if (!exists(dir)) {\n              cout << \"Path \" << dir << \" does not exist.n\";\n              return 1;\n          }\n```", "```cpp\n          const size_t dupes {reduce_dupes(dir)};\n\n          cout << \"Removed \" << dupes << \" duplicates.n\";\n      }\n```", "```cpp\n      $ du -sh dupe_dir\n      1.1M dupe_dir\n\n      $ ./dupe_compress dupe_dir\n      Removed dupe_dir/dir2/bar.jpg because it is a duplicate of \n      dupe_dir/dir1/bar.jpg\n      Removed dupe_dir/dir2/base10.png because it is a duplicate of \n      dupe_dir/dir1/base10.png\n      Removed dupe_dir/dir2/baz.jpeg because it is a duplicate of \n      dupe_dir/dir1/baz.jpeg\n      Removed dupe_dir/dir2/feed_fish.jpg because it is a duplicate of \n      dupe_dir/dir1/feed_fish.jpg\n      Removed dupe_dir/dir2/foo.jpg because it is a duplicate of \n      dupe_dir/dir1/foo.jpg\n      Removed dupe_dir/dir2/fox.jpg because it is a duplicate of \n      dupe_dir/dir1/fox.jpg\n      Removed 6 duplicates.\n\n      $ du -sh dupe_dir\n      584K dupe_dir\n```", "```cpp\npath a {\"some_dir/some_file.txt\"};\npath b {\"other_dir/other_file.txt\"};\nremove(b);\ncreate_symlink(a, b);\n```", "```cpp\ncreate_symlink(absolute(a), b);\n```"]