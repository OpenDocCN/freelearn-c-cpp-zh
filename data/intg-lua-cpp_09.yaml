- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Recapping Lua-C++ Communication Mechanisms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾 Lua-C++ 通信机制
- en: In *Part 2* of this book, we learned how to call Lua from C++. In *Part 3*,
    we learned how to call C++ from Lua. In the course of this book, we have explored
    many examples, some of which depend on advanced C++ techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 *第2部分* 中，我们学习了如何从 C++ 调用 Lua。在 *第3部分* 中，我们学习了如何从 Lua 调用 C++。在本书的学习过程中，我们探讨了众多示例，其中一些示例依赖于高级
    C++ 技术。
- en: This chapter will summarize all the communication mechanisms between Lua and
    C++, stripping away most of the C++ details. We will also dig deeper into some
    of the topics that we have not demonstrated in the examples yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将总结 Lua 和 C++ 之间的所有通信机制，去除大部分 C++ 的细节。我们还将深入探讨一些在示例中尚未展示的主题。
- en: You can use this chapter to recap what you have learned. For each topic, we
    will list some important Lua library functions. You can check the Lua reference
    manual for more related functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本章回顾您所学的内容。对于每个主题，我们将列出一些重要的 Lua 库函数。您可以在 Lua 参考手册中查找更多相关函数。
- en: In the future, as you progress in your programming journey, you might adopt
    different C++ techniques in your projects. In such cases, this chapter will be
    a useful source for quick reference.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的编程旅程中，随着您的进步，您可能会在项目中采用不同的 C++ 技术。在这种情况下，本章将是一个有用的快速参考来源。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Calling Lua from C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C++ 调用 Lua
- en: Calling C++ from Lua
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Lua 调用 C++
- en: Implementing standalone C++ modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现独立的 C++ 模块
- en: Storing state in Lua
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Lua 中存储状态
- en: Userdata
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问本章的源代码，网址为 [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09)。
- en: You can access the Lua reference manual and develop the habit of frequently
    checking for API details at [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问 Lua 参考手册，并养成在 [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)
    频繁检查 API 详细信息的习惯。
- en: The stack
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'The Lua stack can serve two purposes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 栈可以服务于两个目的：
- en: '*Exchange data between C++ and Lua.* Passing function arguments and retrieving
    function return values fit into this usage.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 C++ 和 Lua 之间交换数据**。传递函数参数和检索函数返回值适用于此用途。'
- en: '*Keep intermediate results.* For example, we can keep a table reference in
    the stack until we are done with the table; we can push some values onto the stack
    and then pop and use them as upvalues.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保留中间结果**。例如，我们可以在完成表格之前在栈上保留一个表格引用；我们可以将一些值推送到栈上，然后弹出并使用它们作为 upvalues。'
- en: 'The Lua stack comes in two forms:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 栈有两种形式：
- en: '*The public stack that comes with the Lua state.* Once a Lua state is created
    via `luaL_newstate` or `lua_newstate`, you can pass the state around and the same
    Lua stack is accessible to all functions that can access the Lua state.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Lua 状态附带的可公开访问的公共栈**。一旦通过 `luaL_newstate` 或 `lua_newstate` 创建了 Lua 状态，您就可以传递状态并在所有可以访问
    Lua 状态的函数中访问相同的 Lua 栈。'
- en: '*The private stack for each* `lua_CFunction` *call.* The stack is only accessible
    to a function call. Calling the same `lua_CFunction` multiple times will not share
    the same stack. So, the stack that is passed to a `lua_CFunction` call is private
    to the function call.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个* `lua_CFunction` 调用的**私有栈**。栈仅对函数调用可访问。多次调用相同的 `lua_CFunction` 不会共享相同的栈。因此，传递给
    `lua_CFunction` 调用的栈是函数调用的私有栈。'
- en: Pushing onto the stack
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到栈上
- en: You can use `lua_pushXXX` functions to push a value or an object reference onto
    the stack – for example, `lua_pushstring`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `lua_pushXXX` 函数将值或对象引用推送到栈上——例如，`lua_pushstring`。
- en: Check the Lua reference manual for a list of such functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Lua 参考手册以获取此类函数的列表。
- en: Querying the stack
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询栈
- en: You can use `lua_isXXX` functions to check if a given stack position holds an
    item of a certain type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `lua_isXXX` 函数检查给定栈位置是否包含特定类型的项。
- en: You can use `lua_toXXX` functions to convert a given stack position into a certain
    type. Those functions will always succeed, although the resulting values might
    be a surprise if the stack position is holding an item of a different type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `lua_toXXX` 函数将给定栈位置转换为特定类型。这些函数总是会成功，尽管如果栈位置包含不同类型的项，则结果值可能会令人惊讶。
- en: You can check the Lua reference manual for a list of such functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Lua 参考手册中查找此类函数的列表。
- en: Other stack operations
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他栈操作
- en: There are some other frequently used stack operations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他常用的栈操作。
- en: Ensuring stack size
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保栈大小
- en: 'The Lua stack is created with a predefined size that should be big enough for
    most operations. If you need to push a lot of items onto the stack, you can ensure
    that the stack size can meet your needs by calling the following function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 栈以预定义的大小创建，应该足够大，可以满足大多数操作。如果您需要将大量项推送到栈上，您可以通过调用以下函数来确保栈大小可以满足您的需求：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`n` is the required size.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` 是所需的大小。'
- en: Counting items
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数项
- en: To check the number of items in the stack, use `lua_gettop`. The return value
    is the count.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查栈中的项数，请使用 `lua_gettop`。返回值是计数。
- en: Resetting the stack top
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置栈顶
- en: 'To set the top of the stack to a certain index, use the `lua_settop` function,
    whose declaration is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将栈顶设置为特定索引，请使用 `lua_settop` 函数，其声明如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can either clear some items from the top of the stack or pad the stack
    with nils. We can use it to clear temporary items from the stack efficiently,
    as can be seen in `LuaModuleExporter::luaNew` from our examples:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以清除栈顶的一些项，或者用 nil 填充栈。我们可以使用它来有效地从栈中清除临时项，如我们示例中的 `LuaModuleExporter::luaNew`
    所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In `luaNew`, we passed the Lua state, thus the Lua stack, to an external factory
    method. Because we do not know how the factory method will use the Lua stack,
    we cleared the stack after the factory method returned to get rid of any possible
    side effects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `luaNew` 中，我们传递了 Lua 状态，即 Lua 栈，到一个外部工厂方法。因为我们不知道工厂方法将如何使用 Lua 栈，所以在工厂方法返回后我们清空了栈，以消除任何可能的副作用。
- en: Copying another item
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制另一个项
- en: 'If an item is already in the stack, you can push a copy of it onto the top
    of the stack quickly by calling this function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项已经在栈中，您可以通过调用此函数快速将其副本推送到栈顶：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This can save you some trouble if the value or object backing the item is hard
    to get.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持项的值或对象难以获取，这可以为您节省一些麻烦。
- en: Some other stack operations are supported by the Lua library, but they are used
    infrequently to achieve complex effects. You can check them out in the reference
    manual.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 库支持一些其他栈操作，但它们很少用来实现复杂效果。您可以在参考手册中查看它们。
- en: Calling Lua from C++
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C++ 调用 Lua
- en: 'To call Lua code from C++, we can use `lua_pcall`, which is declared as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 C++ 调用 Lua 代码，我们可以使用 `lua_pcall`，其声明如下：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will call a Lua callable, which can be a function or a chunk. You can push
    the Lua function to be called onto the stack, or compile a file or a string into
    a chunk and then place it onto the stack. `nargs` is the number of arguments for
    the callable. The arguments are pushed onto the stack above the callable. `nresults`
    is the count of return values the callable would return. Use `LUA_MULTRET` to
    indicate that you expect a variable count of return values. `msgh` is the stack
    index for an error message handler.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用一个 Lua 可调用项，它可以是一个函数或一个代码块。您可以将要调用的 Lua 函数推送到栈上，或者将文件或字符串编译成一个代码块并将其放置到栈上。`nargs`
    是可调用项的参数数量。参数被推送到可调用项之上的栈上。`nresults` 是可调用项将返回的返回值数量。使用 `LUA_MULTRET` 来表示您期望一个可变数量的返回值。`msgh`
    是错误消息处理器的栈索引。
- en: '`lua_pcall` calls the callable in *protected mode*, which means that any error
    that may have occurred in the call chain is not propagated. Instead, an error
    status code is returned from `lua_pcall`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`lua_pcall` 在 *保护模式* 下调用可调用项，这意味着调用链中可能发生的任何错误都不会传播。相反，`lua_pcall` 从中返回一个错误状态码。'
- en: In the `LuaExecutor` class that we have implemented, you can find many examples
    of calling Lua from C++.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现的 `LuaExecutor` 类中，您可以找到许多从 C++ 调用 Lua 的示例。
- en: In the Lua reference manual, you can find other library functions similar to
    `lua_pcall`, although `lua_pcall` is the most frequently used one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 参考手册中，您可以找到其他类似于 `lua_pcall` 的库函数，尽管 `lua_pcall` 是最常用的一个。
- en: Calling C++ from Lua
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Lua 调用 C++
- en: 'To call C++ code from Lua, the C++ code needs to be exported via a `lua_CFunction`
    implementation, which is defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Lua 调用 C++ 代码，C++ 代码需要通过 `lua_CFunction` 实现导出，其定义如下：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, in `LuaExecutor`, we implemented a function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `LuaExecutor` 中，我们实现了一个函数：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This returns a single integer value to the Lua code. A simple way to export
    this function to the global table can be implemented as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个整数给 Lua 代码。将此函数导出到全局表的一个简单方法可以如下实现：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can use `lua_pushcfunction` to push `lua_CFunction` onto the stack and then
    assign it to a variable of your choice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `lua_pushcfunction` 将 `lua_CFunction` 推送到栈上，然后将其分配给您选择的变量。
- en: However, more than likely, you should export a group of functions as a module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更有可能的是，您应该将一组函数作为一个模块导出。
- en: Exporting C++ modules
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出 C++ 模块
- en: 'To export a C++ module, you simply need to export a table of functions to Lua.
    In `LuaExecutor`, we have implemented it as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出 C++ 模块，您只需将函数表导出到 Lua。在 `LuaExecutor` 中，我们是这样实现的：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The process is to first create a table and push the reference onto the stack
    with `lua_createtable`. Then, you can push *shared upvalues* (we will recap upvalues
    later in this chapter), and finally add the list of functions to the table with
    `luaL_setfuncs`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程是首先创建一个表，然后使用 `lua_createtable` 将引用推送到栈上。然后，您可以推送 *共享 upvalues*（我们将在本章后面回顾
    upvalues），最后使用 `luaL_setfuncs` 将函数列表添加到表中。
- en: 'If you do not need upvalues, there is a shortcut that you can use:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要 upvalues，您可以使用一个快捷方式：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both `luaL_newlib` and `luaL_setfuncs` take a list of the following structure
    to describe the functions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaL_newlib` 和 `luaL_setfuncs` 都接受一个结构列表来描述函数：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The structure provides `lua_CFunction` with a `name` value, which is used as
    the table entry key.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构为 `lua_CFunction` 提供了一个 `name` 值，该值用作表条目的键。
- en: Implementing standalone C++ modules
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现独立 C++ 模块
- en: So far in this book, we have only explicitly registered C++ modules to Lua in
    C++ code. However, there is another way to provide a C++ module to Lua.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们只在 C++ 代码中显式将 C++ 模块注册到 Lua。然而，还有另一种方法向 Lua 提供一个 C++ 模块。
- en: You can produce a shared library for a module and place it in Lua’s search path.
    When the Lua code *requires* the module, Lua will load the shared library automatically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为模块生成共享库并将其放置在 Lua 的搜索路径中。当 Lua 代码 *require* 模块时，Lua 将自动加载共享库。
- en: 'By reusing our `Destinations` class, this is simple to implement. Create a
    file named `DestinationsModule.cpp` and fill it exactly as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用我们的 `Destinations` 类，这很简单实现。创建一个名为 `DestinationsModule.cpp` 的文件，并按照以下内容填充：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The module that’s been implemented is called `destinations`. The code-level
    contract Lua requires is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 已实现的模块称为 `destinations`。Lua 所需的代码级合约如下：
- en: You need to provide `lua_CFunction`, whose name must begin with `luaopen_`,
    and then have the module name appended
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要提供 `lua_CFunction`，其名称必须以 `luaopen_` 开头，然后附加模块名称。
- en: '`lua_CFunction` needs to leave what it creates in the stack'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lua_CFunction` 需要将它创建的内容留在栈上。'
- en: The code for `luaopen_destinations` is almost identical to that of `LuaExecutor::registerModule`,
    which we explained in the previous section. The only difference is that we have
    left the table reference in the stack because the Lua `require` function will
    pop it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaopen_destinations` 的代码几乎与我们在上一节中解释的 `LuaExecutor::registerModule` 相同。唯一的区别是我们将表引用留在了栈上，因为
    Lua 的 `require` 函数会弹出它。'
- en: extern “C”
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: extern “C”
- en: By default, the C++ compiler will mangle the C++ function name. This means that
    after the function is compiled, the function will have a symbol name more complex
    than what it declares to be in the source code. To prevent this from happening,
    you can place the function declaration inside an `extern "C"` block. Otherwise,
    Lua won’t be able to find the function as the contract is broken after compilation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C++ 编译器会对 C++ 函数名进行名称修饰。这意味着在函数编译后，函数将具有比源代码中声明的更复杂的符号名。为了防止这种情况发生，您可以将函数声明放在一个
    `extern "C"` 块中。否则，Lua 在编译后无法找到该函数，因为合约已被破坏。
- en: Compiling the standalone module
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译独立模块
- en: 'To compile the shared library, add the following lines to your `Makefile`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译共享库，请将以下行添加到您的 `Makefile` 中：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a Terminal, execute `make destinations` to create the shared library. You
    will get a file named `destinations.so`, which is the binary file Lua will load.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，执行 `make destinations` 命令以创建共享库。您将得到一个名为 `destinations.so` 的文件，这是 Lua 将加载的二进制文件。
- en: Testing the standalone module
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试独立模块
- en: 'To test the standalone module, in the folder where `destinations.so` resides,
    start a Lua interactive interpreter and execute the following statements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试独立模块，在 `destinations.so` 所在的文件夹中，启动 Lua 交互式解释器并执行以下语句：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The most important statement is the `require` statement. This loads `destinations.so`
    and assigns the module to the `Destinations` global variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的语句是 `require` 语句。它加载 `destinations.so` 并将模块分配给 `Destinations` 全局变量。
- en: We started the Lua interactive interpreter in the same folder where the module
    binary resides because `require` will search the current working directory for
    modules. Alternatively, you can put the library in a system search path. You can
    check the reference manual to learn more about `require` and its behaviors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块二进制文件所在的同一文件夹中启动了Lua交互式解释器，因为`require`将在当前工作目录中搜索模块。或者，你也可以将库放在系统搜索路径中。你可以查看参考手册了解更多关于`require`及其行为的信息。
- en: A standalone C++ module is useful when you need to reuse the module in the binary
    form across multiple projects or enforce code isolation on the C++ side, but this
    is just a design choice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要跨多个项目重用二进制形式的模块或在C++侧强制代码隔离时，一个独立的C++模块很有用，但这只是一个设计选择。
- en: Storing state in Lua
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Lua中存储状态
- en: 'There are two ways to store state in Lua for `lua_CFunction`: *upvalues* and
    *the registry*. Let’s recap them and dig deeper into upvalues.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lua中存储状态有两种方式为`lua_CFunction`：*upvalues*和*注册表*。让我们回顾一下它们，并更深入地了解upvalues。
- en: Upvalues
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Upvalues
- en: 'To introduce the complete definition for upvalues, we need to introduce **Lua
    C closures** at the same time. To quote the Lua reference manual:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入upvalue的完整定义，我们需要同时引入**Lua C闭包**。引用Lua参考手册：
- en: When a C function is created, it is possible to associate some values with it,
    thus creating a C closure; these values are called upvalues and are accessible
    to the function whenever it is called.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建C函数时，可以将其与一些值关联起来，从而创建一个C闭包；这些值被称为upvalue，并且每当函数被调用时都可以访问。
- en: To put it simply, the closure is still our old friend `lua_CFunction`. When
    you associate some values with it, it becomes a closure, and the values become
    upvalues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，闭包仍然是我们的老朋友`lua_CFunction`。当你将其与一些值关联时，它就变成了闭包，而这些值就变成了upvalue。
- en: It is important to note that Lua C closures and upvalues are inseparable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Lua C闭包和upvalue是不可分割的。
- en: 'To create a closure, use the following library function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个闭包，请使用以下库函数：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a closure from `lua_CFunction` and associates `n` values with it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这从`lua_CFunction`创建了一个闭包，并将`n`个值与它关联。
- en: 'To see it in action, let’s solve the design problem from the previous chapter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际效果，让我们解决前一章的设计问题：
- en: We are creating objects in `LuaModuleDef` but destroying them in `LuaModuleExporter`.
    For a better design, the same class should destroy the objects it creates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`LuaModuleDef`中创建对象，但在`LuaModuleExporter`中销毁它们。为了更好的设计，应该由创建对象的同一类销毁它们。
- en: Implementing a Lua C closure
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Lua C闭包
- en: The following feature is a continuation of the previous chapter. You can revisit
    the previous chapter to get a better understanding if you need to.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下特性是前一章的延续。如果你需要更好的理解，可以回顾前一章。
- en: 'To do this, we can implement a `destroyInstance` member variable for `LuaModuleDef`,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以为`LuaModuleDef`实现一个`destroyInstance`成员变量，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, objects will be created and destroyed in the same `LuaModuleDef` entity.
    To use `destroyInstance`, modify `LuaModuleExporter::luaDelete`, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对象将在同一个`LuaModuleDef`实体中创建和销毁。要使用`destroyInstance`，修改`LuaModuleExporter::luaDelete`，如下所示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Recall that `getExporter` is used to retrieve the first upvalue, which is a
    pointer to the exporter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`getExporter`用于检索第一个upvalue，它是指向导出器的指针：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This works for `luaNew` because `LuaModuleExporter` is inherited from `LuaModule`,
    which pushes `this` as an upvalue in its default implementation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`luaNew`有效，因为`LuaModuleExporter`是从`LuaModule`继承的，它在默认实现中将其`this`作为upvalue压入栈中：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, the pushed upvalue is used as shared upvalues for all exported functions
    in `LuaExecutor::registerModule`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，压入的upvalue被用作`LuaExecutor::registerModule`中所有导出函数的共享upvalue：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Shared upvalues are pushed onto the stack once and get associated with all the
    functions provided to `luaL_setfuncs`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的upvalue只被压入栈中一次，并且与提供给`luaL_setfuncs`的所有函数相关联。
- en: Shared upvalues are not really shared
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 共享upvalue并不是真正共享
- en: The so-called shared upvalues are copied for each function during setup. Afterward,
    the functions access their own copies of the upvalues. In the Lua reference manual,
    these are called shared upvalues because they are only pushed onto the stack once
    and used for all functions to be registered, which is only relevant to API invocations.
    I think this term is misleading. You should think of these as just plain upvalues.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所说的共享upvalues在设置期间为每个函数复制。之后，函数访问它们自己的upvalue副本。在Lua参考手册中，这些被称为共享upvalues，因为它们只被压入栈中一次，用于所有要注册的函数，这对于API调用来说只相关。我认为这个术语是误导性的。你应该把它们看作是普通的upvalue。
- en: 'However, `getExporter` will not work for `luaDelete` because `luaDelete` is
    not an exported function and is not passed to `luaL_setfuncs`. To support `luaDelete`,
    modify `luaNew`, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`getExporter` 对于 `luaDelete` 不会起作用，因为 `luaDelete` 不是一个导出函数，也没有传递给 `luaL_setfuncs`。为了支持
    `luaDelete`，修改 `luaNew`，如下所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We only need to push `exporter` as an upvalue for `luaDelete` and make `luaDelete`
    a closure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将 `exporter` 作为 upvalue 压入 `luaDelete`，并将 `luaDelete` 转换为闭包。
- en: Now, `LuaModuleExporter` has a better design as it delegates both object construction
    and object destruction to `LuaModuleDef`. Also, it utilizes both upvalues (for
    `luaDelete`) and shared upvalues (for `luaNew`) at the same time in the `getExporter`
    helper function. This shows that shared upvalues are no different from upvalues
    after they are set up.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`LuaModuleExporter` 有了一个更好的设计，因为它将对象构造和对象销毁都委托给了 `LuaModuleDef`。同时，它在 `getExporter`
    辅助函数中同时使用了 upvalues（用于 `luaDelete`）和共享 upvalues（用于 `luaNew`）。这表明设置后共享 upvalues
    和 upvalues 没有区别。
- en: The registry
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册表
- en: The registry is a predefined Lua table that is only accessible to C/C++ code.
    For a Lua state, the registry is shared for all C/C++ functions, so table key
    names should be selected carefully to avoid collision.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是一个预定义的 Lua 表，仅对 C/C++ 代码可访问。对于 Lua 状态，注册表对所有 C/C++ 函数是共享的，因此应仔细选择表键名以避免冲突。
- en: Notably, by convention, *full userdata* places its metatable in the registry
    via `luaL_newmetatable`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，按照惯例，*完整用户数据*通过 `luaL_newmetatable` 将其元表放置在注册表中。
- en: '*Put simply, the registry is a Lua table that the Lua language treats specially
    and provides a few helper* *functions for.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单来说，注册表是 Lua 语言特别对待的 Lua 表，并提供了一些辅助函数*。'
- en: Userdata
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户数据
- en: The Lua userdata can be categorized into *light userdata* and *full userdata*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 用户数据可以分为 *轻量级用户数据* 和 *完整用户数据*。
- en: It is important to note that they are different things. In the Lua library,
    conventionally, light userdata is named lightuserdata, while full userdata is
    named userdata.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，它们是不同的事物。在 Lua 库中，按照惯例，轻量级用户数据命名为 lightuserdata，而完整用户数据命名为 userdata。
- en: Light userdata
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级用户数据
- en: Light userdata represents a C/C++ pointer. It is a value type and the value
    is passed around. You push a pointer in C/C++ code onto the stack with `lua_pushlightuserdata`.
    You cannot create light userdata with the Lua library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级用户数据代表一个 C/C++ 指针。它是一个值类型，值在各个地方传递。你可以在 C/C++ 代码中使用 `lua_pushlightuserdata`
    将一个指针压入栈中。你不能使用 Lua 库创建轻量级用户数据。
- en: Full userdata
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整用户数据
- en: Full userdata is a raw memory area allocated by the Lua library with a call
    to `lua_newuserdatauv`. It is an object type and only its reference is passed
    around.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整用户数据是 Lua 库通过调用 `lua_newuserdatauv` 分配的原始内存区域。它是一个对象类型，只有其引用在各个地方传递。
- en: Because full userdata is created by Lua in the heap, Lua garbage collection
    comes into the picture. On the C++ side, you can provide a *finalizer* by providing
    the `__gc` metamethod.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为完整用户数据是由 Lua 在堆中创建的，所以 Lua 垃圾回收就变得重要了。在 C++ 方面，你可以通过提供 `__gc` 元方法来提供一个 *终结器*。
- en: For a complete example of how to utilize full userdata to access C++ objects
    in Lua, check `LuaModuleExporter`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何利用完整用户数据在 Lua 中访问 C++ 对象的完整示例，请查看 `LuaModuleExporter`。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we briefly recapped all communication mechanisms between Lua
    and C++. This should have sufficiently reinforced your learnings so far.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要回顾了 Lua 和 C++ 之间的所有通信机制。这应该已经充分巩固了您到目前为止的学习。
- en: We also learned how to produce a standalone C++ module as a shared library.
    This opens new ways for you to organize your projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何生成一个独立的 C++ 模块作为共享库。这为您组织项目开辟了新的途径。
- en: In the next chapter, we will talk more about resource management.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论资源管理。
