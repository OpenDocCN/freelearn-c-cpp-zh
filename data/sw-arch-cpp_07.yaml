- en: Leveraging C++ Language Features
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 利用C++语言特性
- en: The C++ language is a unique beast. It's used in a plethora of cases, varying
    from creating firmware and operating systems, desktop and mobile applications,
    to server software, frameworks, and services. C++ code runs on all kinds of hardware,
    is massively deployed on compute clouds, and can even be found in outer space.
    Such success wouldn't have been possible without the broad set of features this
    multi-paradigm language has.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言是一种独特的语言。它被用于各种情况，从创建固件和操作系统，桌面和移动应用程序，到服务器软件，框架和服务。C++代码在各种硬件上运行，在计算云上大规模部署，并且甚至可以在外太空中找到。如果没有这种多范式语言具有的广泛功能集，这样的成功是不可能的。
- en: This chapter describes how to leverage what the C++ language offers so that
    we can achieve safe and performant solutions. We will demonstrate the best industry
    practices for type safety, avoiding memory issues, and creating efficient code
    in an equally efficient manner. We will also teach you how to use certain language
    features when designing APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何利用C++语言提供的内容，以便我们可以实现安全和高性能的解决方案。我们将展示类型安全的最佳行业实践，避免内存问题，并以同样高效的方式创建高效的代码。我们还将教您在设计API时如何使用某些语言特性。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing resources and avoiding leaks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源和避免泄漏
- en: Moving computations from runtime to compile time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将计算从运行时移动到编译时
- en: Leveraging the power of safe types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用安全类型的能力
- en: Creating easy to read and performant code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建易于阅读和高性能的代码
- en: Dividing code into modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码分成模块
- en: During this journey, you'll learn about the features and techniques that are
    available in various standards of C++, ranging from C++98 all the way to C++20\.
    This will include declarative programming, RAII, `constexpr`, templates, concepts,
    and modules. Without further ado, let's begin this journey.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段旅程中，您将了解各种C++标准中可用的功能和技术，从C++98到C++20。这将包括声明式编程，RAII，`constexpr`，模板，概念和模块。话不多说，让我们开始这段旅程吧。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following tools to build the code in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下工具来构建本章中的代码：
- en: A compiler that supports C++20 (GCC 11+ is recommended)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持C++20的编译器（建议使用GCC 11+）
- en: CMake 3.15+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.15+
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05)找到。
- en: Designing great APIs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计出色的APIs
- en: Although C++ allows you to use the well-known object-oriented APIs that you
    may be familiar with if you write code in so-called coffee-based languages, it
    has some other tricks up its sleeves. We'll mention a few of them in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++允许您使用您可能熟悉的基于对象的API，但它还有一些其他技巧。我们将在本节中提到其中一些。
- en: Leveraging RAII
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用RAII
- en: What's the main difference between a C API and a C++ one? Usually, it's not
    about polymorphism or having classes per se, but about an idiom called RAII.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C API和C++ API之间的主要区别是什么？通常，这与多态性或具有类本身无关，而是与一种称为RAII的习惯有关。
- en: '**RAII** stands for **Resource Acquisition Is Initialization**, but it''s actually
    more about releasing resources than acquiring them. Let''s take a look at a similar
    API written in C and C++ to show this feature in action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAII**代表**资源获取即初始化**，但实际上更多的是关于释放资源而不是获取资源。让我们看一下在C和C++中编写的类似API，以展示这个特性的作用：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The C++ API is based on the C one, but this doesn't always need to be the case.
    What's important here is that in the C++ API, there's no need for a separate function
    to free our precious resource. Thanks to the RAII idiom, it's done automatically
    once a `ResourceRaii` object goes out of scope. This takes the burden of manual
    resource management away from the user, and the best part is that it comes at
    no extra cost.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C++ API基于C API，但这并不总是必须的。重要的是，在C++ API中，不需要单独的函数来释放我们宝贵的资源。由于RAII习惯，一旦`ResourceRaii`对象超出范围，它就会自动完成。这减轻了用户手动管理资源的负担，最重要的是，它不需要额外的成本。
- en: What's more, we didn't need to write any class of our own – we just reused the
    standard library's `unique_ptr`, which is a lightweight pointer. It ensures that
    the object it manages will always be freed, and it will always be freed exactly
    once.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，我们不需要编写任何我们自己的类 - 我们只是重用了标准库的`unique_ptr`，它是一个轻量级指针。它确保它管理的对象将始终被释放，并且将始终被精确释放一次。
- en: Since we're managing some special kinds of resources and not memory, we had
    to use a custom deleter type. Our `acquireResourceRaii` function would need to
    pass the actual pointer to the `releaseResource` function. The C API itself doesn't
    need to be exposed to the user if you only want to consume it from C++.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们管理一些特殊类型的资源而不是内存，我们必须使用自定义的删除器类型。我们的`acquireResourceRaii`函数需要将实际指针传递给`releaseResource`函数。如果您只想从C++中使用它，C
    API本身不需要暴露给用户。
- en: 'An important thing to note here is that RAII is not just for managing memory:
    you can use it to easily handle ownership of any resource, such as locks, file
    handles, database connections, and anything else that should be released once
    its RAII wrappers go out of scope.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，RAII不仅用于管理内存：您可以使用它轻松处理任何资源的所有权，例如锁，文件句柄，数据库连接，以及任何应该在其RAII包装器超出范围时释放的其他资源。
- en: Specifying the interfaces of containers in C++
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定C++中容器的接口
- en: Implementations of the standard library are great places to search for idiomatic
    and performant C++ code. For instance, if you want to read some really interesting
    template code, you should give `std::chrono` a shot, as it demonstrates some useful
    techniques and has a fresh approach to this. A link to libstdc++'s implementation
    can be found in the *Further reading* section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的实现是搜索惯用和高性能C++代码的好地方。例如，如果你想阅读一些非常有趣的模板代码，你应该尝试一下`std::chrono`，因为它演示了一些有用的技术，并对此有了新的方法。在*进一步阅读*部分可以找到libstdc++的实现链接。
- en: 'When it comes to other places of the library, even a quick peek at its containers
    shows that their interfaces tend to differ from their counterparts in other programming
    languages. To show this, let''s take a look at a pretty straightforward class
    from the standard library, `std::array`, and analyze it bit by bit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到库的其他地方时，即使快速查看其容器也会发现它们的接口往往与其他编程语言中的对应物不同。为了展示这一点，让我们来看一下标准库中一个非常直接的类`std::array`，并逐个分析它：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing you can see when you start reading the class definition is that
    it creates aliases for some types. This is common across the standard containers,
    and the names of those aliases are the same in many of them. This happens for
    a few reasons. One of them is the rule of least surprise – having it this way
    reduces the time developers spend scratching their heads and trying to understand
    what you meant and how a specific alias was named. Another reason is that the
    users of your class and library writers will often depend on such type traits
    when they're writing their own code. If your container won't provide such aliases,
    it will make using it with some standard utilities or type traits harder, so the
    users of your APIs will have to work around this or even use a completely different
    class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始阅读类定义时，你会看到的第一件事是它为一些类型创建了别名。这在标准容器中很常见，这些别名的名称在许多容器中都是相同的。这是由于几个原因。其中之一是最少惊讶原则
    - 以这种方式减少开发人员花在思考你的意思以及特定别名的命名方式上的时间。另一个原因是你的类的用户和库编写者在编写他们自己的代码时经常依赖这样的类型特征。如果你的容器不提供这样的别名，它将使得使用它与一些标准工具或类型特征更加困难，因此你的API的用户将不得不解决这个问题，甚至使用完全不同的类。
- en: Having such type aliases can be useful even if you're not using them in your
    templates. It's not uncommon to rely on those types for function parameters and
    class member fields, so always remember to provide them if you're writing a class
    that other people could use. For instance, if you're writing an allocator, many
    of its consumers will rely on specific type aliases being present.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在模板中没有使用这些类型别名，拥有这样的类型别名也是有用的。在函数参数和类成员字段中依赖于这些类型是很常见的，所以如果你正在编写一个其他人可能会使用的类，一定要记得提供它们。例如，如果你正在编写一个分配器，它的许多使用者将依赖于特定的类型别名存在。
- en: 'Let''s see what the array class will bring us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数组类将给我们带来什么：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, the next interesting thing about `std::array` is that it has no definition
    of a constructor, including copy/move constructors; assign operators; or destructors.
    It's simply because having those wouldn't add any value. Often, adding such members
    when it's not necessary is actually harmful to performance. With a non-defaulted
    constructor (and `T() {}` is already non-defaulted, as opposed to `T() = default;`),
    your class is no longer trivial nor trivially constructible, which prevents the
    compiler from making optimizations to it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于`std::array`的另一个有趣之处是它没有定义构造函数，包括复制/移动构造函数；赋值运算符；或析构函数。这仅仅是因为拥有这些成员不会增加任何价值。通常，在不必要的情况下添加这些成员实际上对性能有害。有了非默认构造函数（`T()
    {}`已经是非默认的，与`T() = default;`相反），你的类不再是平凡的，也不再是平凡可构造的，这将阻止编译器对其进行优化。
- en: 'Let''s see what other declarations our class has:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的类还有哪些其他声明：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can see two member functions, including a member swap. Often, it's profitable
    to not rely on the default behavior of `std::swap` and to provide our own. For
    instance, in the case of `std::vector`, the underlying storage is swapped as a
    whole instead of each element being swapped. When you're writing a member swap
    function, be sure to also introduce a free function named `swap` so that it can
    be detected via **argument-dependent lookup** (**ADL**). It could just call your
    member's `swap` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到两个成员函数，包括一个成员交换。通常，不依赖于`std::swap`的默认行为并提供我们自己的交换函数是有利的。例如，在`std::vector`的情况下，底层存储被整体交换，而不是每个元素被交换。当你编写一个成员交换函数时，一定要引入一个名为`swap`的自由函数，以便通过**参数相关查找**（**ADL**）来检测它。它可以调用你的成员`swap`函数。
- en: One more thing regarding the swap function that's worth mentioning is that it's
    conditionally `noexcept`. If the stored type can be swapped without throwing exceptions,
    the array's swap will be `noexcept` as well. Having a non-throwing swap can help
    you achieve strong exception safety guarantees in copy operations for classes
    that are storing our type as a member.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于值得一提的交换函数的另一件事是它是有条件的`noexcept`。如果存储的类型可以在不抛出异常的情况下交换，那么数组的交换也将是`noexcept`的。具有不抛出异常的交换可以帮助你在存储我们类型的成员的类的复制操作中实现强异常安全性保证。
- en: 'As shown in the following code block, now comes a big set of functions that
    show us another important aspect of many classes – their iterators:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码块所示，现在出现了一大堆函数，它们向我们展示了许多类的另一个重要方面 - 它们的迭代器：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Iterators are vital for every container. If you don't provide iterator access
    for your class, you won't be able to use it in range-based for loops and it won't
    be compatible with all the useful algorithms from the standard library. This doesn't
    mean that you need to write your own iterator types – you could just use a simple
    pointer if your storage is contiguous. Providing `const` iterators can help you
    use your class in an immutable manner, and providing reverse iterators can help
    with enabling more use cases for your container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器对于每个容器都是至关重要的。如果您的类没有提供迭代器访问权限，您将无法在基于范围的循环中使用它，并且它将与标准库中的所有有用算法不兼容。这并不意味着您需要编写自己的迭代器类型
    - 如果您的存储是连续的，您可以只使用简单的指针。提供`const`迭代器可以帮助您以不可变的方式使用类，并且提供反向迭代器可以帮助扩展容器的更多用例。
- en: 'Let''s see what comes next:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接下来会发生什么：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Following the iterators, we have a few ways to inspect and modify the container's
    data. In the case of `array`, all of them are `constexpr`. This means that if
    we were to write some compile-time code, we could use our array class. We'll look
    at this in more detail later in this chapter, in the *Moving computations at compile
    time* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代器之后，我们有一些检查和修改容器数据的方法。在`array`的情况下，所有这些方法都是`constexpr`的。这意味着如果我们要编写一些编译时代码，我们可以使用我们的数组类。我们将在本章的*在编译时移动计算*部分中更详细地讨论这一点。
- en: 'Finally, we made it through the whole definition of our `array`. Its interface
    doesn''t end there, however. Starting with C++17, after a type definition, you
    can spot lines similar to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了对`array`的整个定义。然而，它的接口并不仅限于此。从C++17开始，在类型定义之后，您可以看到类似以下的行：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Such statements are called **deduction guides**. They''re part of a feature
    called **Class Template Argument Deduction** (**CTAD**), which was introduced
    in C++17\. It allows you to omit the template parameters when you''re declaring
    a variable. It''s handy for `array` because now, you can just write the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句被称为**推导指南**。它们是**类模板参数推导**（**CTAD**）功能的一部分，该功能在C++17中引入。它允许您在声明变量时省略模板参数。对于`array`来说，这很方便，因为现在您可以只写以下内容：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, it could be even handier for more complex types, such as maps, as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于更复杂的类型，例如映射，它可能更方便，如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is, however, a catch here: we needed to specify that we''re passing the
    key-value pair when we passed the first argument (note that we also used a deduction
    guide for it).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个问题：当我们传递第一个参数时，我们需要指定我们正在传递键值对（请注意，我们还为其使用了推导指南）。
- en: Since we're on the topic of interfaces, let's point to some other aspects of
    them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们谈到了接口，让我们指出其中的一些其他方面。
- en: Using pointers in interfaces
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在接口中使用指针
- en: The types that you use in your interfaces matter a lot. Even if there's documentation,
    a good API should still be intuitive at a glance. Let's see how different approaches
    to passing resource parameters to a function can suggest different things to the
    API consumer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您在接口中使用的类型非常重要。即使有文档，一个良好的API在一瞥之间仍应该是直观的。让我们看看不同的传递资源参数给函数的方法如何向API使用者暗示不同的事情。
- en: 'Consider the following function declarations:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数声明：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When should you use which of those functions?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在何时使用这些函数？
- en: Since smart pointers are now the standard way to deal with resources, `A` and
    `B` should be left for simple parameter passing and shouldn't be used if you don't
    do anything with the ownership of the passed objects. `A` should only be used
    for a single resource. For example, if you want to pass multiple instances, you
    could use a container, such as `std::span`. If you know the object you want to
    pass is not null, it's best to pass it by using a reference, such as a const reference.
    You can also consider passing by value if the object is not too big.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能指针现在是处理资源的标准方式，`A`和`B`应该留给简单的参数传递，并且如果您不对传递的对象的所有权做任何操作，则不应使用它们。`A`应该仅用于单个资源。例如，如果您想要传递多个实例，可以使用容器，例如`std::span`。如果您知道要传递的对象不为空，最好通过引用传递，例如const引用。如果对象不太大，也可以考虑通过值传递。
- en: A good rule of thumb regarding functions `C` to `F` is that you should only
    pass smart pointers as arguments if you want to manipulate the pointers themselves;
    for example, for transferring ownership.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数`C`到`F`的一个很好的经验法则是，如果您想要操纵指针本身，那么只应传递智能指针作为参数；例如，用于所有权转移。
- en: The `C` function takes a `unique_ptr` by value. This means it's a resource sink.
    In other words, it consumes and then frees the resource. Note that just by selecting
    a specific type, the interface expresses its intent clearly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`C`通过值接受`unique_ptr`。这意味着它是一个资源接收器。换句话说，它会消耗然后释放资源。请注意，通过选择特定类型，接口清晰地表达了其意图。
- en: The `D` function should only be used if you want to pass in a `unique_ptr` containing
    one resource and receive another resource in the same `unique_ptr` as an out parameter.
    It's not a good idea to have such a function for simply passing a resource since
    it requires that the caller stores it specifically in a `unique_ptr`. In other
    words, if you think about passing a `const unique_ptr<Resource>&`, just pass a
    `Resource*` (or `Resource&`) instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`D`应该仅在您想要传递包含一个资源的`unique_ptr`并在同一个`unique_ptr`中作为输出参数接收另一个资源时使用。对于简单地传递资源来说，拥有这样的函数并不是一个好主意，因为调用者需要将其专门存储在`unique_ptr`中。换句话说，如果您考虑传递`const
    unique_ptr<Resource>&`，只需传递`Resource*`（或`Resource&`）即可。
- en: The `E` function is meant for sharing resource ownership with the callee. Passing
    a `shared_ptr` by value can be relatively costly, as it is required to increment
    its reference counters. However, in this case, passing `shared_ptr` by value is
    okay, since a copy must be made somewhere if the callee really wants to become
    a shared owner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`E`用于与调用方共享资源所有权。通过值传递`shared_ptr`可能相对昂贵，因为需要增加其引用计数。然而，在这种情况下，通过值传递`shared_ptr`是可以的，因为如果调用方真的想成为共享所有者，那么必须在某个地方进行复制。
- en: The `F` function is similar to `D` and should only be used when you want to
    manipulate the `shared_ptr` instance and propagate the change through this in/out
    parameter. If you're unsure if the function should take ownership or not, consider
    passing a `const shared_ptr&`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`F`函数类似于`D`，只有在你想要操作`shared_ptr`实例并通过这个输入/输出参数传播更改时才应该使用。如果你不确定函数是否应该拥有所有权，考虑传递一个`const
    shared_ptr&`。'
- en: Specifying preconditions and postconditions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定前置条件和后置条件
- en: It's not uncommon for a function to have some requirements regarding its parameters.
    Each requirement should be stated as a precondition. If a function guarantees
    that its result has some properties – for example, it is non-negative – the function
    should make that clear as well. Some developers resort to placing comments to
    inform others about this, but it doesn't really enforce the requirement in any
    way. Placing `if` statements is better, but hides the reason for the check. Currently,
    the C++ standard still doesn't offer a way to deal with this (contracts were first
    voted into the C++20 standard, just to be removed later on). Fortunately, libraries
    such as Microsoft's **Guideline Support Library** (**GSL**) provide their own
    checks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数通常会对其参数有一些要求是很常见的。每个要求都应该被陈述为一个前置条件。如果一个函数保证其结果具有某些属性——例如，它是非负的——那么函数也应该清楚地表明这一点。一些开发人员会使用注释来通知其他人，但这并不真正以任何方式强制要求。放置`if`语句会更好一些，但会隐藏检查的原因。目前，C++标准仍然没有提供处理这个问题的方法（合同最初被投票纳入C++20标准，后来被移除）。幸运的是，像微软的**指南支持库**（**GSL**）这样的库提供了它们自己的检查。
- en: 'Let''s assume that, for whatever reason, we''re writing our own queue implementation.
    The push member function could look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出于某种原因，我们正在编写自己的队列实现。push成员函数可能如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the user doesn't even need access to the implementation to be sure
    that some checks are in place. The code is also self-documenting as it's clear
    what the function requires and what the result will be.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用户甚至不需要访问实现就可以确保某些检查已经就位。代码也是自我描述的，因为清楚地表明了函数需要什么以及结果将是什么。
- en: Leveraging inline namespaces
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用内联命名空间
- en: In systems programming, oftentimes, you're not always just writing code against
    an API; often, you need to care about ABI compatibility as well. A famous ABI
    break happened when GCC released its fifth version, with one of the major changes
    being the change of the class layout of `std::string`. This meant that libraries
    working with older GCC versions (or still using the new ABI in newer versions,
    which is still a thing in recent GCC releases) would not work with code written
    using a later ABI. In the case of an ABI break, if you receive a linker error,
    you can consider yourself lucky. In some cases, such as mixing `NDEBUG` code with
    debug code, you'll likely get memory corruption if a class only has members available
    in one such configuration' for instance, special members being added for better
    debugging.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，通常情况下，你并不总是只是针对API编写代码；通常情况下，你还需要关心ABI兼容性。当GCC发布其第五个版本时，发生了一个著名的ABI破坏，其中一个主要变化是改变了`std::string`的类布局。这意味着使用旧版GCC版本的库（或者在较新的GCC版本中仍然使用新的ABI，这在最近的GCC版本中仍然存在）将无法与使用较新ABI编写的代码一起工作。在发生ABI破坏的情况下，如果收到链接器错误，你可以算自己幸运。在某些情况下，例如将`NDEBUG`代码与调试代码混合使用，如果一个类只有在一种配置中可用的成员，你可能会遇到内存损坏；例如，为了更好地进行调试而添加特殊成员。
- en: 'Some memory corruptions, which are often hard to debug, can easily be turned
    into linker errors with the use of C++11''s inline namespaces. Consider the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内存损坏，通常很难调试，可以很容易地通过使用C++11的内联命名空间转换为链接器错误。考虑以下代码：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the preceding code uses inline namespaces, the users won''t see a difference
    between the two build types when you''re declaring objects of this class: all
    declarations from an inline namespace are visible in the surrounding scope. The
    linker, however, will end up with different symbol names, which will cause the
    linker to fail if it tries to link incompatible libraries, giving us the ABI safety
    we''re looking for and a nice error message mentioning the inline namespace.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码使用了内联命名空间，当你声明这个类的对象时，用户在两种构建类型之间看不到任何区别：内联命名空间中的所有声明在周围范围内都是可见的。然而，链接器最终会得到不同的符号名称，这将导致链接器在尝试链接不兼容的库时失败，给我们提供了我们正在寻找的ABI安全性和一个提到内联命名空间的良好错误消息。
- en: For more tips on providing safe and elegant ABIs, please see *Arvid Norberg's*
    *The ABI Challenge* talk from *C++Now* 2019, which is linked in the *Further reading*
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有关提供安全和优雅的ABI的更多提示，请参阅*Arvid Norberg*在*C++Now* 2019年的*The ABI Challenge*演讲，链接在*进一步阅读*部分中。
- en: Leveraging std::optional
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用std::optional
- en: Going back from ABIs to APIs, let's mention one more type that we omitted when
    we were designing great APIs earlier in this book. The hero of this section can
    save the day when it comes to optional parameters for functions as it can help
    your types have components that may or may not hold value, and it can also be
    used for designing clean interfaces or as a replacement for pointers. This hero
    is called `std::optional` and was standardized in C++17\. If you can't use C++17,
    you can still find it in Abseil (`absl::optional`), or find a very similar version
    from Boost (`boost::optional`). A big plus of using those classes is that they
    express the intent very clearly, which helps with writing clean and self-documenting
    interfaces. Let's see it in action.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从ABI转回API，让我们提到在本书早期设计伟大的API时遗漏的另一种类型。本节的英雄可以在函数的可选参数方面挽救局面，因为它可以帮助你的类型具有可能包含值的组件，也可以用于设计清晰的接口或作为指针的替代。这个英雄被称为`std::optional`，并在C++17中标准化。如果你不能使用C++17，你仍然可以在Abseil（`absl::optional`）中找到它，或者在Boost（`boost::optional`）中找到一个非常相似的版本。使用这些类的一个重要优点是它们非常清晰地表达了意图，有助于编写清晰和自我描述的接口。让我们看看它的作用。
- en: Optional function parameters
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选函数参数
- en: We'll start by passing arguments to functions that can, but may not, hold value.
    Have you ever stumbled upon a function signature similar to the following?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向可能但不一定持有值的函数传递参数开始。你是否曾经遇到过类似以下的函数签名？
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sometimes, it's just too easy to pass a `-1` by mistake when you didn't want
    to if `param` was calculated somewhere else in code – perhaps where it was even
    a valid value. How about the following signature?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你不想在`param`在代码的其他地方计算时，却很容易错误地传递一个`-1`——也许在那里它甚至是一个有效的值。以下签名怎么样？
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time, it''s much clearer what to do if you don''t want to pass a `value`:
    just pass an empty optional. The intent is clear, and `-1` can still be used as
    a valid value instead of you having to give it any special meaning in a type-unsafe
    manner.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，如果你不想传递一个`value`，该怎么做就清楚多了：只需传递一个空的optional。意图明确，而且`-1`仍然可以作为一个有效的值，而不需要以一种类型不安全的方式赋予它任何特殊含义。
- en: That's just one usage of our optional template. Let's see some others.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们optional模板的一个用法。让我们看看其他一些用法。
- en: Optional function return values
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选的函数返回值
- en: Just like with accepting special values to signify the *no value* of a parameter,
    a function can sometimes return *no value*. Which of the following would you prefer?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像接受特殊值来表示参数的*无值*一样，有时函数可能返回*无值*。你更喜欢以下哪种？
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How can you tell what value the first function will return in case of errors?
    Or will it throw an exception instead of returning a magic value? Moving on to
    the second signature, it looks like `false` will be returned if there is an error,
    but it's still easy to just forget to check it and read `parsed_number` directly,
    potentially causing trouble. In the third case, while it's relatively safe to
    assume a `nullptr` will be returned on errors and an integer in case of success,
    it's now unclear if the returned `int` should be freed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么知道第一个函数在出现错误时会返回什么值？或者它会抛出异常而不是返回一个魔术值？接下来看第二个签名，看起来如果出现错误会返回`false`，但是很容易忘记检查它，直接读取`parsed_number`，可能会引起麻烦。在第三种情况下，虽然可以相对安全地假设在出现错误时会返回一个`nullptr`，在成功的情况下会返回一个整数，但现在不清楚返回的`int`是否应该被释放。
- en: With the last signature, it's clear by just looking at it that an empty value
    will be returned in case of errors and that there's nothing else that needs to
    be done. It's simple, understandable, and elegant.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最后一个签名，仅仅通过看它就清楚了，在出现错误的情况下将返回一个空值，而且没有其他需要做的事情。这简单、易懂、优雅。
- en: Optional return values can also be used to just mark a *no value* being returned,
    not necessarily that an error had occurred. Having said that, let's move on to
    our last use case for optionals.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的返回值也可以用来标记*无值*的返回，而不一定是发生了错误。说到这里，让我们继续讨论optionals的最后一个用例。
- en: Optional class members
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Optional类成员
- en: 'Achieving coherence in a class state is not always an easy task. For instance,
    sometimes, you want to have a member or two that can simply not be set. Instead
    of creating another class for such a case (which increases code complexity) or
    reserving a special value (which is easy to pass unnoticed), you can use an optional
    class member. Consider the following type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类状态中实现一致性并不总是一件容易的事情。例如，有时你希望有一个或两个成员可以简单地不设置。而不是为这种情况创建另一个类（增加代码复杂性）或保留一个特殊值（很容易被忽视），你可以使用一个optional类成员。考虑以下类型：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see which fields are necessary and which ones don't need to be
    filled. The same data could be stored using empty strings, but this wouldn't be
    clearly visible just from the struct's definition. Another alternative would be
    to use `std::unique_ptr's`, but then we would lose data locality, which is often
    essential for performance. For such cases, `std::optional` can be of great value.
    It should definitely be a part of your toolbox when you want to design clean and
    intuitive APIs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到哪些字段是必要的，哪些不需要填充。相同的数据可以使用空字符串存储，但这并不会清晰地从结构的定义中看出。另一种选择是使用`std::unique_ptr`，但这样我们会失去数据的局部性，这对性能通常是至关重要的。对于这种情况，`std::optional`可以有很大的价值。当你想要设计干净和直观的API时，它绝对应该是你的工具箱的一部分。
- en: This knowledge can help you provide high-quality and intuitive APIs. There's
    one more thing you can do to improve them further that will also help you write
    less buggy code by default. We will discuss this in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识可以帮助你提供高质量和直观的API。还有一件事可以进一步改进它们，这也将帮助你默认情况下编写更少的错误代码。我们将在下一节讨论这个问题。
- en: Writing declarative code
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写声明式代码
- en: Are you familiar with imperative versus declarative coding styles? The former
    is when your code tells the machine *how* to achieve what you want step by step.
    The latter is when you tell the machine just *what* you want to achieve. Certain
    programming languages favor one over the other. For instance, C is imperative,
    while SQL is declarative, just like many functional languages. Some languages
    allow you to mix the styles – think of LINQ in C#.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉命令式与声明式编码风格吗？前者是当你的代码一步一步地告诉机器*如何*实现你想要的。后者是当你只告诉机器*你*想要实现什么。某些编程语言更偏向于其中一种。例如，C是命令式的，而SQL是声明式的，就像许多函数式语言一样。有些语言允许你混合这些风格——想想C#中的LINQ。
- en: C++ is a flexible beast that allows you to write code in both ways. Is there
    one you should prefer? It turns out that when you're writing declarative code,
    usually a higher level of abstraction is kept, which leads to fewer bugs and easier-to-spot
    errors. So, how can we write C++ declaratively? There are two main tactics to
    apply.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一个灵活的语言，允许你以两种方式编写代码。你应该更倾向于哪一种呢？事实证明，当你编写声明式代码时，通常会保持更高的抽象级别，这会导致更少的错误和更容易发现的错误。那么，我们如何声明式地编写C++呢？有两种主要的策略可以应用。
- en: 'The first one is to write functional-style C++, which is where you prefer a
    pure-functional style (no side effects of functions) if possible. Instead of writing
    loops by hand, you should try using standard library algorithms. Consider the
    following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种是编写函数式风格的C++，这是你在可能的情况下更倾向于纯函数式风格（函数没有副作用）。你应该尝试使用标准库算法，而不是手动编写循环。考虑以下代码：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, compare the preceding code with the following snippet, which does the
    same:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将前面的代码与执行相同操作的以下片段进行比较：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both snippets return the last day that had a relatively stable temperature.
    Which one of those would you rather read? Which one is easier to understand? Even
    if you're not that familiar with C++ algorithms now, after encountering them a
    few times in code, they just feel simpler, safer, and cleaner than hand-crafted
    loops. That's because they often are.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个片段都返回了最后一个具有相对稳定温度的日子。你更愿意阅读哪一个？哪一个更容易理解？即使你现在对C++算法不太熟悉，但在代码中遇到几次后，它们就会感觉比手工编写的循环更简单、更安全、更清晰。因为它们通常就是这样。
- en: 'The second tactic for writing declarative code in C++ is already somewhat present
    in the previous snippet. You should prefer using declarative APIs, such as the
    one from the ranges library. And although no range views were used in our snippet,
    they can make a lot of difference. Consider the following snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中编写声明性代码的第二种策略在前面的片段中已经有所体现。您应该优先使用声明性API，比如来自ranges库的API。虽然我们的片段中没有使用范围视图，但它们可以产生很大的不同。考虑以下片段：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a great example of declarative coding: you just specify what should
    happen, not how. The preceding code takes the first two even numbers, reverses
    their order, and prints them as a string, thus printing the famous answer to life,
    the universe, and everything: 42\. All of this is done in an intuitive and easily
    modifiable way.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是声明性编码的一个很好的例子：你只需指定应该发生什么，而不是如何。前面的代码获取了前两个偶数，颠倒它们的顺序，并将它们打印为一个字符串，从而打印出了生活、宇宙和一切的著名答案：42。所有这些都是以一种直观和易于修改的方式完成的。
- en: Showcasing a featured items gallery
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示特色项目画廊
- en: Enough with the toy examples, though. Remember our Dominican Fair application
    from [Chapter 3](7f6118d3-ac40-4b40-9348-6ffabde7ef9b.xhtml), *Functional and
    Nonfunctional Requirements*? Let's write a component that will select and display
    a few featured items from the stores that a customer saved as their favorites.
    This can be pretty handy when we're writing a mobile app, for example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，玩具示例就到此为止。还记得我们在[第3章](7f6118d3-ac40-4b40-9348-6ffabde7ef9b.xhtml)中的多米尼加展会应用程序吗，*功能和非功能需求*？让我们编写一个组件，它将从客户保存为收藏夹的商店中选择并显示一些特色项目。例如，当我们编写移动应用程序时，这可能非常方便。
- en: Let's start with a mostly C++17 implementation, which we'll update to C++20
    throughout this chapter. This will include adding support for ranges.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个主要是C++17实现开始，然后在本章中将其更新为C++20。这将包括添加对范围的支持。
- en: 'First, let''s start with some code for obtaining information about the current
    user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从获取有关当前用户的信息的一些代码开始：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s add the store owners:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加商店所有者：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The stores also need to have items in them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 商店也需要有商品：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some items may not have photos or prices, which is why we used `std::optional`
    for those fields.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有些项目可能没有照片或价格，这就是为什么我们为这些字段使用了`std::optional`。
- en: 'Next, let''s add some code that describes our items:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一些描述我们商品的代码：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we created a helper lambda for converting our `optionals` into strings.
    Since we only want to use it in our `<<` operator, we defined it inside it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个帮助lambda，用于将我们的`optionals`转换为字符串。因为我们只想在我们的`<<`运算符中使用它，所以我们在其中定义了它。
- en: 'Note how we used C++14''s generic lambdas (the auto parameter), along with
    C++17''s `constexpr` and the `is_same_v` type trait, so that we have a different
    implementation when we''re dealing with an optional `<string>` versus other cases.
    Achieving the same pre-C++17 would require writing templates with overloads, resulting
    in more complicated code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了C++14的通用lambda（auto参数），以及C++17的`constexpr`和`is_same_v`类型特征，这样当我们处理可选的`<string>`时，我们就有了不同的实现。在C++17之前实现相同的功能需要编写带有重载的模板，导致代码更加复杂：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can define the store itself:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义存储本身：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What's worth noting here is the use of the `gsl::not_null` template from the
    Guidelines Support Library, which signals that the owner will always be set. Why
    not use just a plain old reference? That's because we may want our store to be
    moveable and copyable. Using a reference would hinder that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是使用了指南支持库中的`gsl::not_null`模板，这表明所有者将始终被设置。为什么不只使用一个普通的引用？因为我们可能希望我们的存储是可移动和可复制的。使用引用会妨碍这一点。
- en: Now that we have those building blocks, let's define how to get a customer's
    favorite stores. For simplicity, let's assume we're dealing with hardcoded stores
    and merchants instead of creating code to deal with external data stores.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些构建模块，让我们定义如何获取客户的收藏夹商店。为简单起见，让我们假设我们正在处理硬编码的商店和商家，而不是创建用于处理外部数据存储的代码。
- en: 'First, let''s define a type alias for the stores and begin our function definition:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为商店定义一个类型别名，并开始我们的函数定义：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, let''s hardcode some merchants, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们硬编码一些商家，如下所示：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s add a store with some items, as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个带有一些项目的商店，如下所示：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we introduced our first C++20 feature. You might not be familiar with
    the `.field = value;` syntax unless you've coded in C99 or newer. Starting from
    C++20, you can use this notation (officially called designated initializers) to
    initialize aggregate types. It's more constrained than in C99 because the order
    is important, although it has some other minor differences. Without those initializers,
    it can be hard to understand which value initializes which field. With them, the
    code is more verbose but easier to comprehend, even for people unfamiliar with
    programming.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了我们的第一个C++20特性。你可能不熟悉`.field = value;`的语法，除非你在C99或更新的版本中编码过。从C++20开始，您可以使用这种表示法（官方称为指定初始化器）来初始化聚合类型。它比C99更受限制，因为顺序很重要，尽管它还有一些其他较小的差异。没有这些初始化器，很难理解哪个值初始化了哪个字段。有了它们，代码更冗长，但即使对于不熟悉编程的人来说，更容易理解。
- en: 'Once we''ve defined our stores, we can write the last part of our function,
    which will do the actual lookup:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的商店，我们就可以编写函数的最后部分，这部分将执行实际的查找：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have our stores, let''s write some code to obtain the featured
    items for those stores:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的商店，让我们编写一些代码来获取这些商店的特色物品：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code was for obtaining items from one store. Let''s also write
    a function that will obtain items from all the given stores:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是为了从一个商店获取物品。让我们还编写一个函数，从所有给定的商店获取物品：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code uses `std::copy` to insert elements into a vector, with memory
    preallocated by the reserve call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`std::copy`将元素插入向量，预先分配内存由保留调用。
- en: 'Now that we have a way to obtain interesting items, let''s sort them by "freshness"
    so that the most recently added ones will appear first:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种获取有趣物品的方法，让我们按“新鲜度”对它们进行排序，以便最近添加的物品将首先显示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, we leveraged `std::sort` with a custom comparator. If you like,
    you could also force the same type for both `left` and `right`. To do so in a
    generic manner, let''s use another C++20 feature: template lambdas. Let''s apply
    them to the preceding code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们利用了带有自定义比较器的`std::sort`。如果愿意，您也可以强制`left`和`right`的类型相同。为了以通用方式执行此操作，让我们使用另一个C++20特性：模板lambda。让我们将它们应用于前面的代码：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `T` type for the lambda will be deduced just like it would for any other
    template.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: lambda的`T`类型将被推断，就像对于任何其他模板一样。
- en: 'The last two parts that are missing are the actual rendering code and the main
    function to glue it all together. In our example case, rendering will be as simple
    as printing to an `ostream`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还缺少的最后两部分是实际的渲染代码和将所有内容粘合在一起的主函数。在我们的示例中，渲染将简单地打印到一个`ostream`：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our case, we just copy each element to the standard output and insert a newline
    between the elements. Using `copy` and an `ostream_iterator` allows you to handle
    the element's separators for yourself. This can be handy in some cases; for instance,
    if you don't want a comma (or a newline, in our case) after the last element.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只是将每个元素复制到标准输出，并在元素之间插入一个换行符。使用`copy`和`ostream_iterator`允许您自己处理元素的分隔符。在某些情况下，这可能很方便；例如，如果您不希望在最后一个元素之后有逗号（或者在我们的情况下是换行符）。
- en: 'Finally, our main function will look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的主要函数将如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Voila! Feel free to run the code to see how it prints our featured items:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧！随时运行代码，看看它如何打印我们的特色物品：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we're done with our base implementation, let's see how we can improve
    it by using some new language features from C++20.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的基本实现，让我们看看如何通过使用C++20的一些新语言特性来改进它。
- en: Introducing standard ranges
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍标准范围
- en: 'Our first addition will be the ranges library. As you may recall, it can help
    us achieve elegant, simple, and declarative code. For brevity, first, we will
    pull in the `ranges` namespace:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个添加将是范围库。您可能还记得，它可以帮助我们实现优雅、简单和声明性的代码。为了简洁起见，首先，我们将引入`ranges`命名空间：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll leave the code-defining merchants, items, and stores as-is. Let''s start
    our modifications by using the `get_featured_items_for_store` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留定义商家、物品和商店的代码不变。让我们通过使用`get_featured_items_for_store`函数开始我们的修改：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, making a range out of a container is straightforward: just
    pass it to a pipe operator. Instead of our hand-crafted loop to filter featured
    elements, we can use the `views::filter` expression, passing it a member pointer
    as the predicate. Due to the magic of `std::invoke` under the hood, this will
    correctly filter out all items that have our Boolean data member set to `false`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将容器转换为范围很简单：只需将其传递给管道运算符。我们可以使用`views::filter`表达式而不是手工筛选特色元素的循环，将成员指针作为谓词传递。由于底层的`std::invoke`的魔法，这将正确地过滤掉所有具有我们的布尔数据成员设置为`false`的项目。
- en: Next, we need to convert each item into a `gsl::not_null` pointer so that we
    can avoid unnecessary item copies. Finally, we return a vector of such pointers,
    the same as in our base code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将每个项目转换为`gsl::not_null`指针，以便我们可以避免不必要的项目复制。最后，我们返回一个这样的指针向量，与我们的基本代码相同。
- en: 'Now, let''s see how we can use the preceding function to obtain all the featured
    items from all our stores:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用前面的函数来获取所有商店的特色物品：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we created a range from all the stores and transformed them using the
    function we created in the previous step. Because we needed to dereference each
    element first, we used a helper lambda. Views are lazily evaluated, so each transform
    will be done only when it is about to be consumed. This can sometimes save you
    lots of time and computations: assuming you would only want the first N items,
    you can skip the unnecessary calls to `get_featured_items_for_store`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从所有商店创建了一个范围，并使用我们在上一步中创建的函数进行了转换。因为我们需要先解引用每个元素，所以我们使用了一个辅助lambda。视图是惰性评估的，因此每次转换只有在即将被消耗时才会执行。这有时可以节省大量的时间和计算：假设您只想要前N个项目，您可以跳过对`get_featured_items_for_store`的不必要调用。
- en: Once we have our lazy view, similar to our base implementation, we can reserve
    space in the vector and copy items there from each nested vector in the `all_featured`
    view. Range algorithms are more concise to use if you take the whole container.
    Look how copy doesn't require us to write `std::begin(elem)` and `std::end(elem)`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了惰性视图，类似于我们的基本实现，我们可以在向量中保留空间，并从`all_featured`视图中的每个嵌套向量中将项目复制到那里。如果您使用整个容器，范围算法更简洁。看看`copy`不需要我们编写`std::begin(elem)`和`std::end(elem)`。
- en: 'Now that we have our items, let''s simplify our sorting code by using ranges
    to process them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的物品，让我们通过使用范围来简化我们的排序代码来处理它们：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, you can see how ranges can help you write more concise code. The preceding
    copy and the sort here are both range *algorithms*, as opposed to *views*. They
    are eager and allow you to use projections. In our case, we just passed another
    member of our item class so that it can be used for comparison when sorting. Effectively,
    each item will be projected as just its `date_added`, which will then be compared
    using `greater{}`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以看到范围如何帮助您编写更简洁的代码。前面的复制和排序都是范围*算法*，而不是*视图*。它们是急切的，并允许您使用投影。在我们的情况下，我们只是传递了我们物品类的另一个成员，以便在排序时可以使用它进行比较。实际上，每个项目将被投影为其`date_added`，然后使用`greater{}`进行比较。
- en: But wait – our items are actually `gsl::not_null` pointers to `Item`. How does
    this work? It turns out that our projection will dereference the `gsl::not_null`
    pointer first because of the cleverness of `std::invoke`. Neat!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等 - 我们的items实际上是指向`Item`的`gsl::not_null`指针。这是如何工作的？事实证明，由于`std::invoke`的巧妙之处，我们的投影将首先解引用`gsl::not_null`指针。很巧妙！
- en: 'The last change that we can make is in our "rendering" code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行的最后一个更改是在我们的“渲染”代码中：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, ranges just help us remove some boilerplate code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，范围只是帮助我们删除一些样板代码。
- en: When you run our updated version of the code, you should get the same output
    as in the base case.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行我们更新版本的代码时，您应该得到与基本情况相同的输出。
- en: 'If you were expecting more from ranges than just concise code, there''s good
    news: they can be used even more efficiently in our case.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您期望范围比简洁的代码更多，那么有好消息：它们在我们的情况下甚至可以更有效地使用。
- en: Reducing memory overhead and increasing performance using ranges
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用范围减少内存开销并提高性能
- en: 'You already know that using lazy evaluation in `std::ranges::views` can help
    with performance by eliminating unnecessary compute. It turns out we can also
    use ranges to reduce the memory overhead in our example. Let''s revisit our code
    for obtaining featured items from a store. It can be shortened down to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道，在`std::ranges::views`中使用惰性求值可以通过消除不必要的计算来提高性能。事实证明，我们还可以使用范围来减少我们示例中的内存开销。让我们重新审视一下从商店获取特色商品的代码。它可以缩短为以下内容：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that our function no longer returns items, instead relying on C++14's auto
    return type deduction. In our case, instead of returning a vector, our code will
    return a lazy view.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的函数不再返回items，而是依赖于C++14的自动返回类型推导。在我们的情况下，我们的代码将返回一个惰性视图，而不是返回一个向量。
- en: 'Let''s learn how to consume this for all stores:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何为所有商店使用这个：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, because our preceding function returns a view instead of the vector, we
    end up with a view of views after calling `transform`. This means we can use yet
    another standard view called join to join our nested views into just one that's
    unified.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们之前的函数返回的是一个视图而不是向量，在调用`transform`之后，我们得到了一个视图的视图。这意味着我们可以使用另一个标准视图，称为join，将我们的嵌套视图合并成一个统一的视图。
- en: Next, we use `std::ranges::distance` to preallocate space in our destination
    vector, after which we make our copy. Some ranges are sized, in which case you
    could call `std::ranges::size` instead. The resulting code has just one call to
    `reserve`, which should give us a nice performance boost.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`std::ranges::distance`在目标向量中预先分配空间，然后进行复制。有些范围是有大小的，这种情况下您可以调用`std::ranges::size`。最终的代码只调用了一次`reserve`，这应该给我们带来良好的性能提升。
- en: This concludes introducing ranges to our code. Since we ended this section on
    a performance-related note, let's talk about one more topic that's important for
    this aspect of C++ programming.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对代码引入范围的介绍。由于我们在这一部分结束时提到了与性能相关的内容，让我们谈谈C++编程这一方面的另一个重要主题。
- en: Moving computations at compile time
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将计算移动到编译时
- en: Starting with the advent of modern C++ in the early 2000s, C++ programming became
    more about computing things during compilation instead of deferring them to runtime.
    It's much cheaper to detect errors during compilation than to debug them later
    on. Similarly, it's much faster to have the result ready before the program is
    started instead of calculating it later on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从21世纪初现代C++的出现开始，C++编程变得更多地关于在编译期间计算事物，而不是将它们推迟到运行时。在编译期间检测错误要比以后调试错误要便宜得多。同样，在程序启动之前准备好结果要比以后计算结果要快得多。
- en: 'At first, there was template metaprogramming, but with C++11 onward, each new
    standard brought additional features for compile-time compute: be it type traits,
    constructs such as `std::enable_if` or `std::void_t`, or C++20''s `consteval`
    for computing stuff only at compile time.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，有模板元编程，但是从C++11开始，每个新标准都为编译时计算带来了额外的功能：无论是类型特征、诸如`std::enable_if`或`std::void_t`的构造，还是C++20的`consteval`用于仅在编译时计算的内容。
- en: One feature that improved over the years was the `constexpr` keyword and its
    related code. C++20 really improved and extended `constexpr`. Now, you can not
    only write regular simple `constexpr` functions thanks to the previous standards
    (quite an improvement from C++11's single-expression ones), but you can also use
    dynamic allocations and exceptions inside them, not to mention `std::vector and
    std::string`!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来改进的一个功能是`constexpr`关键字及其相关代码。C++20真正改进并扩展了`constexpr`。现在，您不仅可以编写常规的简单`constexpr`函数，还可以在其中使用动态分配和异常，更不用说`std::vector`和`std::string`了！
- en: 'There''s more: even virtual functions can now be `constexpr`: overload resolution
    happens as usual, but if a given one is `constexpr`, it can get called at compile
    time.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多：甚至虚函数现在也可以是`constexpr`：重载分辨率照常进行，但如果给定的函数是`constexpr`，它可以在编译时调用。
- en: 'Yet another improvement was made to standard algorithms. Their non-parallel
    versions are all ready for you to use in your compile-time code. Consider the
    following example, which can be used to check if a given merchant is present in
    a container:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 标准算法也进行了另一个改进。它们的非并行版本都已准备好供您在编译时代码中使用。考虑以下示例，它可以用于检查容器中是否存在给定的商家：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, we're doing a binary search for an array of merchants, sorted
    by their IDs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在对商家数组进行二进制搜索，按其ID排序。
- en: To gain insight into the code and its performance, we recommend that you take
    a quick look at the assembly that this code generates. Along with the advent of
    compile-time computations and chasing performance, one of the invaluable tools
    that was developed was the [https://godbolt.org](https://godbolt.org) site. It
    can be used to quickly play with code to see how different architectures, compilers,
    flags, library versions, and implementations influence the generated assembly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解代码及其性能，我们建议您快速查看此代码生成的汇编代码。随着编译时计算和性能追求的到来，开发的一个无价的工具之一是[https://godbolt.org](https://godbolt.org)网站。它可以用于快速测试代码，以查看不同架构、编译器、标志、库版本和实现如何影响生成的汇编代码。
- en: 'We tested the preceding code using GCC trunk (before GCC 11 was officially
    released) with `-O3` and `--std=c++2a`. In our case, we checked the generated
    assembly with the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GCC trunk（在GCC 11正式发布之前）进行了上述代码的测试，使用了`-O3`和`--std=c++2a`。在我们的情况下，我们使用以下代码检查了生成的汇编代码：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can see the few dozens of assembly lines using the following Godbolt: [https://godbolt.org/z/PYMTYx](https://godbolt.org/z/PYMTYx).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下Godbolt查看几十行汇编代码：[https://godbolt.org/z/PYMTYx](https://godbolt.org/z/PYMTYx)。
- en: '*But wait* – you could say that *there''s a function call in the assembly,
    so maybe we could inline it so it can be optimized better?* That would be a valid
    point. Often, this helps a lot, although now, we just get the assembly inlined
    (see: [https://godbolt.org/z/hPadxd](https://godbolt.org/z/hPadxd)).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是* - 您可能会说*汇编中有一个函数调用，所以也许我们可以内联它，这样它可以更好地优化？* 这是一个有效的观点。通常，这会有很大帮助，尽管现在，我们只是将汇编内联（参见：[https://godbolt.org/z/hPadxd](https://godbolt.org/z/hPadxd)）。'
- en: 'So, now, try changing the signature to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试将签名更改为以下内容：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`constexpr` functions are implicitly inline, so we removed that keyword. If
    we look into the assembly, we will see that some magic happened: the search was
    optimized away! As you can see at [https://godbolt.org/z/v3hj3E](https://godbolt.org/z/v3hj3E),
    all the assembly that was left was as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数隐式地是内联的，因此我们删除了该关键字。如果我们查看汇编代码，我们会发现发生了一些魔法：搜索被优化掉了！正如您在[https://godbolt.org/z/v3hj3E](https://godbolt.org/z/v3hj3E)中所看到的，剩下的所有汇编代码如下：'
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The compiler optimized our code so that the only thing left is our pre-computed
    result being returned. That's pretty impressive, isn't it?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器优化了我们的代码，以便只剩下我们预先计算的结果被返回。这相当令人印象深刻，不是吗？
- en: Helping the compiler help you by using const
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用const来帮助编译器帮助您
- en: Compilers can optimize pretty well, even if you don't give them `inline` or
    `constexpr` keywords, as in the preceding example. One thing that helps them achieve
    performance for you is marking variables and functions as `const`. Perhaps even
    more importantly, it also helps you avoid making mistakes in your code. Many languages
    have immutable variables by default, which can lead to fewer bugs, code that's
    easier to reason about, and often faster multi-threaded performance.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以进行相当好的优化，即使您没有给它们`inline`或`constexpr`关键字，就像前面的例子一样。帮助它们为您实现性能的一件事是将变量和函数标记为`const`。也许更重要的是，它还可以帮助您避免在代码中犯错误。许多语言默认具有不可变变量，这可以减少错误，使代码更易于理解，并且通常可以获得更快的多线程性能。
- en: Even though C++ has mutable variables by default and you need to explicitly
    type `const`, we encourage you to do so. It can really help you stop making tricky
    typos related to modifying a variable that you shouldn't.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++默认具有可变变量，并且您需要明确地输入`const`，但我们鼓励您这样做。它确实可以帮助您停止犯与修改变量有关的棘手拼写错误。
- en: Using `const` (or `constexpr`) code is part of a bigger philosophy called type
    safety. Let's say a few words about it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`（或`constexpr`）代码是类型安全哲学的一部分。让我们谈谈它。
- en: Leveraging the power of safe types
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用安全类型的力量
- en: C++ relies heavily on mechanisms that help you write type-safe code. Language
    constructs such as explicit constructors and conversion operators have been baked
    into the language for a long time. More and more safe types are being introduced
    to the standard library. There's `optional` to help you avoid referencing empty
    values, `string_view` to help you avoid going out of a range, and `any` as a safe
    wrapper for any type, just to name a few. Moreover, with its zero-cost abstractions,
    it's recommended that you create your own types that are useful and hard or impossible
    to misuse.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C++在很大程度上依赖于帮助您编写类型安全代码的机制。诸如显式构造函数和转换运算符之类的语言构造已经被内置到语言中很长时间了。越来越多的安全类型被引入到标准库中。有`optional`可以帮助您避免引用空值，`string_view`可以帮助您避免超出范围，`any`作为任何类型的安全包装器，只是其中之一。此外，通过其零成本抽象，建议您创建自己的类型，这些类型既有用又难以被误用。
- en: Often, using C-style constructs can lead to type-unsafe code. One example would
    be C-style casts. They can resolve to a `const_cast, static_cast`, `reinterpret_cast`,
    or one of these two combined with a `const_cast`. Accidentally writing to a `const`
    object that was `const_cast` is undefined behavior. So is reading memory returned
    from a `reinterpret_cast<T>`, if T was not the original type of the object (C++20's
    `std::bit_cast` can help here). Both of those cases are much easier avoided if
    C++ casts are used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用C风格的结构可能会导致不安全的代码。一个例子是C风格的转换。它们可以解析为`const_cast, static_cast`, `reinterpret_cast`，或者这两者之一与`const_cast`的组合。意外写入`const`对象，这是`const_cast`是未定义行为。如果从`reinterpret_cast<T>`返回的内存读取，如果T不是对象的原始类型（C++20的`std::bit_cast`可以在这里帮助），也是如此。如果使用C++转换，这两种情况都更容易避免。
- en: C was perhaps too permissive when it came to types. Fortunately, C++ introduces
    many type-safe alternatives to problematic C constructs. There are streams and
    `std::format` instead of `printf` et al., and there's `std::copy` and other similar
    algorithms instead of the unsafe `memcpy`. Finally, there are templates instead
    of functions taking a void `*` (and paying a price in terms of performance). With
    C++, templates get even more type safety through a feature called concepts. Let's
    see how we can improve our code by using them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及类型时，C可能过于宽松。幸运的是，C++引入了许多类型安全的替代方案来解决问题C构造。有流和`std::format`代替`printf`等，有`std::copy`和其他类似的算法代替不安全的`memcpy`。最后，有模板代替接受`void
    *`的函数（并在性能方面付出代价）。在C++中，通过一种叫做概念的特性，模板甚至可以获得更多的类型安全。让我们看看如何通过使用它们来改进我们的代码。
- en: Constraining template parameters
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束模板参数
- en: The first way concepts can improve your code is by making it more generic. Do
    you remember the cases where you needed to change the container type in one place,
    which caused a cascade of changes in other places too? If you weren't changing
    the container to one with totally different semantics and that you had to use
    in a different way, that means your code may not have been generic enough.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 概念可以改进代码的第一种方式是使其更加通用。你还记得那些需要在一个地方改变容器类型，导致其他地方也需要改变的情况吗？如果你没有改变容器到一个完全不同语义的容器，并且你需要以不同的方式使用它，那么你的代码可能不够通用。
- en: On the other hand, have you ever written a template or sprinkled `auto` over
    your code and later wondered if your code would break if someone changed the underlying
    type?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你是否曾经写过一个模板或在代码中使用`auto`，然后想知道如果有人改变了底层类型，你的代码是否会出错？
- en: 'Concepts are all about putting the right level of constraints onto the types
    you''re operating on. They constrain what types your template can match, and are
    checked at compile time. For instance, let''s say you write the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 概念的关键在于对你正在操作的类型施加正确级别的约束。它们约束了你的模板可以匹配的类型，并且在编译时进行检查。例如，假设你写了以下代码：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, you can write the following instead:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样写：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, `foo()` must be passed a type that supports `std::swap` to work.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foo()`必须传递一个支持`std::swap`的类型才能工作。
- en: Do you recall some templates that matched just too many types? Previously, you
    could use `std::enable_if`, `std::void_t`, or `if constexpr` to constrain them.
    However, writing `enable_if` statements was a bit cumbersome and could slow down
    your compilation times. Here, concepts come to the rescue once more due to their
    conciseness and how they express their intent clearly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得有些模板匹配了太多类型的情况吗？以前，你可以使用`std::enable_if`、`std::void_t`或`if constexpr`来约束它们。然而，编写`enable_if`语句有点麻烦，可能会减慢编译时间。在这里，概念再次拯救了我们，因为它们的简洁性和清晰表达了它们的意图。
- en: 'There are a few dozen standard concepts in C++20\. Most of them live in the
    `<concepts>` header and can be divided into four categories:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中有几十个标准概念。其中大部分位于`<concepts>`头文件中，可以分为四类：
- en: Core language concepts, such as `derived_from`, `integral`, `swappable`, and
    `move_constructible`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心语言概念，比如`derived_from`、`integral`、`swappable`和`move_constructible`
- en: Comparison concepts, such as `boolean-testable`, `equality_comparable_with`,
    and `totally_ordered`
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较概念，比如`boolean-testable`、`equality_comparable_with`和`totally_ordered`
- en: Object concepts, such as `movable`, `copyable`, `semiregular`, and `regular`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象概念，比如`movable`、`copyable`、`semiregular`和`regular`
- en: Callable concepts, such as `invokable`, `predicate`, and `strict_weak_order`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用的概念，比如`invokable`、`predicate`和`strict_weak_order`
- en: 'Additional ones are defined in the `<iterator>` header. These can be divided
    into the following categories:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的概念在`<iterator>`头文件中定义。这些可以分为以下几类：
- en: Indirect callable concepts, such as `indirect_binary_predicate` and `indirectly_unary_invocable`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接可调用的概念，比如`indirect_binary_predicate`和`indirectly_unary_invocable`
- en: Common algorithm requirements, such as `indirectly_swappable`, `permutable`,
    `mergeable`, and `sortable`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见算法要求，比如`indirectly_swappable`、`permutable`、`mergeable`和`sortable`
- en: Finally, a dozen can be found in the `<ranges>` header. Examples include `range`
    (duh), `contiguous_range`, and `view`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些在`<ranges>`头文件中可以找到。例如`range`（duh）、`contiguous_range`和`view`。
- en: 'If that''s not enough for your needs, you can declare your own concepts similarly
    to how the standard defines the ones we just covered. For instance, the `movable`
    concept is implemented like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你的需求还不够，你可以像标准定义我们刚刚涵盖的那些概念一样声明自己的概念。例如，`movable`概念的实现如下：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Furthermore, if you look at `std::swappable`, you''ll see the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你查看`std::swappable`，你会看到以下内容：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This means a type, `T`, will be `swappable` if `ranges::swap(a, b)` compiles
    for two references of this type.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类型`T`如果`ranges::swap(a, b)`对这种类型的两个引用进行编译，则类型`T`将是`swappable`。
- en: When defining your own concepts, be sure that you cover the semantic requirements
    for them. Specifying and using a concept when defining an interface is a promise
    that's made to the consumers of that interface.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义自己的概念时，一定要确保你满足了它们的语义要求。在定义接口时指定和使用概念是对接口的消费者做出的承诺。
- en: 'Often, you can go with the so-called shorthand notation in declarations for
    brevity:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以在声明中使用所谓的简写符号以缩短代码：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: For readability and type safety, it's recommended that you use `auto` together
    with a concept to constrain the type and let your readers know the kind of object
    they're dealing with. Code written in this manner will retain the perks of auto-like
    genericity. You can use this in both regular functions and lambdas.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性和类型安全，建议你在约束类型时使用`auto`和概念一起使用，让你的读者知道他们正在处理的对象的类型。以这种方式编写的代码将保留类似于auto的通用性。你可以在常规函数和lambda中都使用这种方式。
- en: A great bonus of using concepts is shorter error messages. It's not uncommon
    to cut a few dozens and dozens of lines about one compilation error down to just
    a few lines. Yet another bonus is that you can overload on concepts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用概念的一个巨大优势是更短的错误消息。将几十行关于一个编译错误的代码减少到几行并不罕见。另一个好处是你可以在概念上进行重载。
- en: Now, let's go back to our Dominican Fair example. This time, we'll add some
    concepts to see how they can improve our implementation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的多米尼加展示的例子。这一次，我们将添加一些概念，看看它们如何改进我们的实现。
- en: 'First, let''s make `get_all_featured_items` return just a range of items. We
    can do so by adding the concept to the return type, like so:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们让`get_all_featured_items`只返回一系列项目。我们可以通过将概念添加到返回类型中来实现这一点，如下所示：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So far, so good. Now, let''s add yet another requirement to this type that
    will be enforced when we call `order_items_by_date_added`: our range must be sortable.
    `std::sortable` has already been defined for a range iterator, but for our convenience,
    let''s define a new concept called `sortable_range`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利。现在，让我们为这种类型添加另一个要求，这个要求将在调用`order_items_by_date_added`时得到执行：我们的范围必须是可排序的。`std::sortable`已经为范围迭代器定义了，但为了方便起见，让我们定义一个名为`sortable_range`的新概念：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Similar to its standard library counterpart, we can accept a comparator and
    a projection (which we introduced with ranges). Our concept is satisfied by (will
    be matched by) types that satisfy the `random_access_range` concept, as well as
    having an iterator that satisfies the aforementioned sortable concept. It's as
    simple as that.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与其标准库对应的是，我们可以接受一个比较器和一个投影（我们在范围中引入了它）。我们的概念由满足`random_access_range`概念的类型满足，以及具有满足前述可排序概念的迭代器。就是这么简单。
- en: 'When defining concepts, you can also use the `requires` clause to specify additional
    constraints. For instance, if you want our range to store elements with a `date_added`
    member only, you could write the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义概念时，您还可以使用`requires`子句来指定额外的约束。例如，如果您希望我们的范围仅存储具有`date_added`成员的元素，您可以编写以下内容：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, in our case, we don't need to constrain the type that much, as you
    should leave some flexibility when you're using concepts and define them so that
    it will make sense to reuse them.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，我们不需要那么多地约束类型，因为当您使用概念并定义它们时，应该留下一些灵活性，这样重用它们才有意义。
- en: 'What''s important here is that you can use the `requires` clause to specify
    what code should be valid to call on your type when it meets the requirements
    for a concept. If you want, you can specify constraints on the type that''s returned
    by each subexpression; for instance, to define something incrementable, you could
    use the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，您可以使用`requires`子句来指定满足概念要求的类型上应该有效调用的代码。如果您愿意，您可以指定对每个子表达式返回的类型的约束；例如，要定义可递增的内容，您可以使用以下内容：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have our concept, let''s redefine the `order_items_by_date_added`
    function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了概念，让我们重新定义`order_items_by_date_added`函数：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, our compiler will check if any range we pass to it is a sortable one and
    contains a `date_added` member that can be sorted using `std::ranges::greater{}`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的编译器将检查我们传递给它的任何范围是否是可排序的，并且包含一个可以使用`std::ranges::greater{}`进行排序的`date_added`成员。
- en: 'If we were to use the more constrained concept here, the function would look
    like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用更受限制的概念，函数将如下所示：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, let''s redo our rendering function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们重新设计我们的渲染函数：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, you can see that a concept name can be used instead of the `typename`
    keyword in a template declaration. One line below this, you can see that the `requires`
    keyword can also be used to further constrain the appropriate types based on their
    traits. This can be handy if you don't want to specify a new concept.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到概念名称可以在模板声明中使用，而不是`typename`关键字。在这一行的下面，您可以看到`requires`关键字也可以用来根据其特征进一步约束适当的类型。如果您不想指定一个新的概念，这可能会很方便。
- en: That's it for concepts. Now, let's write some modular C++ code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 概念就是这样。现在，让我们写一些模块化的C++代码。
- en: Writing modular C++
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块化的C++
- en: The last big feature of C++ we'll discuss in this chapter is modules. They are
    yet one more addition to C++20 that has a great impact on building and partitioning
    code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论的C++的最后一个重要特性是模块。它们是C++20的又一个重要补充，对构建和分区代码有很大影响。
- en: 'C++ has used `#include` for a really long time now. However, this textual form
    of dependency inclusion has its flaws, as listed here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: C++现在已经使用`#include`很长时间了。然而，这种文本形式的依赖包含有其缺陷，如下所列：
- en: Due to the need to process lots of text (even a `Hello World` after preprocessing
    is around half a million lines of code), it's slow. This leads to **one-definition
    rule** (**ODR**) violations.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需要处理大量文本（即使在预处理后，“Hello World”也有大约50万行代码），这很慢。这导致**一次定义规则**（**ODR**）的违反。
- en: The order of your `includes` matters, but it shouldn't. This one is twice as
    bad as the preceding one as it also leads to cyclic dependencies.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的`includes`的顺序很重要，但不应该重要。这个问题比前一个问题严重了一倍，因为它还会导致循环依赖。
- en: Finally, it's hard to encapsulate stuff that just needs to be in header files.
    Even if you put some stuff in a detailed namespace, someone will use it, as Hyrum's
    law predicts.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，很难封装那些只需要在头文件中的东西。即使您将一些东西放在一个详细的命名空间中，也会有人使用它，正如海伦姆定律所预测的那样。
- en: Fortunately, this is when modules enter the game. They should solve the aforementioned
    flaws, bringing a great speedup to build times and better C++ scalability when
    it comes to building. With modules, you only export what you want to export, which
    results in good encapsulation. Having a specific order of dependency inclusion
    is no longer an issue too, as the order of imports doesn't matter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这就是模块进入游戏的时候。它们应该解决前面提到的缺陷，为构建时间带来巨大的加速，并在构建时提高C++的可扩展性。使用模块，您只导出您想要导出的内容，这会带来良好的封装。依赖包含的特定顺序也不再是问题，因为导入的顺序不重要。
- en: Unfortunately, at the time of writing, compiler support for modules is still
    only partially done. This is why we decided to just showcase what was already
    available in GCC 11\. Sadly, this means that stuff such as module partitions won't
    be covered here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，模块的编译器支持仍然只是部分完成。这就是为什么我们决定只展示GCC 11中已经可用的内容。遗憾的是，这意味着诸如模块分区之类的内容在这里不会涉及。
- en: 'Each module, after compilation, will be compiled to not only the object file
    but also a module interface file. This means that instead of parsing a file with
    all of its dependencies, compilers can quickly know what types and functions a
    given module contains. All you need to do is to type the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块在编译后都将被编译成对象文件和模块接口文件。这意味着编译器不需要解析所有依赖项的文件，就可以快速知道给定模块包含的类型和函数。您只需要输入以下内容：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can use it once `my_module` has been compiled and available. The module
    itself should be defined in a `.cppm` file, but those are still not supported
    by CMake. You might be better off just naming them `.cpp` for the time being.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`my_module`被编译并可用，您就可以使用它。模块本身应该在一个`.cppm`文件中定义，但目前CMake还不支持这一点。您最好暂时将它们命名为`.cpp`。
- en: Without further ado, let's return to our Dominican Fair example and show how
    to use them in practice.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们回到我们多米尼加展会的例子，展示如何在实践中使用它们。
- en: 'First, let''s create our first module for the customer code, starting with
    the following directive:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为客户代码创建我们的第一个模块，从以下指令开始：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This statement marks that from this point on, everything will be private in
    this module. This marks a good place to put your includes and other content that
    won't be exported.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句表示从这一点开始，这个模块中的所有内容都将是私有的。这是一个很好的放置包含和其他不会被导出的内容的地方。
- en: 'Next, we must specify the name of the exported module:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须指定导出模块的名称：
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will be the name we''ll use to import the module later. This line must
    come before the exported contents. Now, let''s specify what our module will actually
    export, prefixing the definitions with the `export` keyword:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们稍后导入模块时要使用的名称。这行必须出现在导出的内容之前。现在，让我们指定我们的模块实际上将导出什么，使用`export`关键字给定义加上前缀：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And done! Our first module is ready to be used. Let''s create another one for
    the merchant:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了！我们的第一个模块已经准备好可以使用了。让我们为商家创建另一个模块：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Pretty similar to our first module, here, we specified the name and the type
    to be exported (as opposed to a type alias and a function for the first one).
    You can export other definitions, such as templates, too. It gets tricky with
    macros, though, as you need to import `<header_file>` for them to be visible.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的第一个模块非常相似，这里我们指定了要导出的名称和类型（与第一个模块的类型别名和函数相反）。您也可以导出其他定义，比如模板。不过，对于宏来说会有些棘手，因为您需要导入`<header_file>`才能看到它们。
- en: 'By the way, a good advantage of modules is that they don''t allow macros to
    propagate to imported modules. This means that when you write code such as the
    following, the module won''t have `MY_MACRO` defined:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，模块的一个很大优势是它们不允许宏传播到导入的模块。这意味着当您编写以下代码时，模块不会定义`MY_MACRO`：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It helps to have determinism in modules as it protects you from breaking code
    in other modules.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的确定性有助于保护您免受其他模块中代码的破坏。
- en: 'Now, let''s define a third module for our stores and items. We won''t discuss
    exporting other functions, enums, and other types as it won''t differ from the
    previous two modules. What''s interesting is how the module file starts. First,
    let''s include what we need in our private module section:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的商店和商品定义第三个模块。我们不会讨论导出其他函数、枚举和其他类型，因为这与前两个模块没有区别。有趣的是模块文件的开始方式。首先，让我们在私有模块部分包含我们需要的内容：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In C++20, standard library headers are not modules yet, but this will likely
    change in the near future.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，标准库头文件还不是模块，但这很可能会在不久的将来发生改变。
- en: 'Now, let''s see what happens next:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看接下来会发生什么：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is the interesting part. Our store module imports the merchant module
    we defined previously and then reexports it as part of the store''s interface.
    This can be handy if your module is a facade for other ones, such as in module
    partitions in the near future (also part of C++20). When available, you will be
    able to split your module across multiple files. One of them could contain the
    following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有趣的部分。我们的商店模块导入了我们之前定义的商家模块，然后将其重新导出为商店的接口的一部分。如果您的模块是其他模块的外观，这可能会很方便，比如在不久的将来的模块分区中（也是C++20的一部分）。一旦可用，您将能够将模块分割成多个文件。其中一个文件可以包含以下内容：
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As we discussed previously, it would then be exported by the main file of your
    module as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，然后它将由您的模块的主文件导出如下：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This concludes modules and the big C++ features that we planned for this chapter.
    Let's summarize what we've learned.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了模块和我们在本章计划的C++的重要特性。让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about many C++ features and their impact on writing
    concise, expressive, and performant C++ code. We learned about providing proper
    C++ component interfaces. You're now able to apply principles such as RAII to
    write elegant code that's free from resource leaks. You also know how to leverage
    types such as `std::optional` to express your intent better in your interfaces.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了许多C++特性及其对编写简洁、表达力强和高性能的C++代码的影响。我们学习了如何提供适当的C++组件接口。您现在可以应用诸如RAII之类的原则，编写优雅的、没有资源泄漏的代码。您还知道如何利用`std::optional`等类型在接口中更好地表达您的意图。
- en: Next, we demonstrated how to use features such as generic and template lambdas,
    as well as `if constexpr` for writing less code that will work with many types.
    You're now also able to define objects in a clear manner using designated initializers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们演示了如何使用通用和模板lambda，以及`if constexpr`来编写能够适用于许多类型的少量代码。现在，您还可以使用指定的初始化程序以清晰的方式定义对象。
- en: Afterward, you learned how to write simple code in a declarative style using
    standard ranges, how to write code that can be executed at both compile time and
    runtime using `constexpr`, and how to write more constrained templated code using
    concepts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您学会了如何使用标准范围以声明式风格编写简单的代码，如何编写可以在编译时和运行时执行的代码，以及如何使用概念编写更受限制的模板代码。
- en: Finally, we demoed how to write modular code with C++ modules. In the next chapter,
    we'll discuss how to design C++ code so that we can build upon the available idioms
    and patterns.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们演示了如何使用C++模块编写模块化代码。在下一章中，我们将讨论如何设计C++代码，以便我们可以建立在可用的习惯用法和模式之上。
- en: Questions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we ensure that each file that our code will open will be closed when
    it's not being used anymore?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确保我们的代码将打开的每个文件在不再使用时都会关闭？
- en: When should you use "naked" pointers in C++ code?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++代码中何时应该使用“裸”指针？
- en: What is a deduction guide?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是推导指南？
- en: When should you use `std::optional` and `gsl::not_null`?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`std::optional`和`gsl::not_null`？
- en: How are range algorithms different than views?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围算法与视图有何不同？
- en: How can you constrain your type by doing more than just specifying the concept's
    name when you're defining a function?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义函数时，除了指定概念的名称之外，如何通过其他方式约束类型？
- en: How is `import X` different than `import <X>`?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import X`与`import <X>`有何不同？'
- en: Further reading
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++ Core Guidelines*, the section on *Concepts*: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++核心指南*，*概念*部分：[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts)'
- en: 'libstdc++''s implementation of `std::chrono`: [https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html](https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libstdc++对`std::chrono`的实现：[https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html](https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html)
