- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating Reproducible Build Environments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重现的构建环境
- en: Building software can be complex, especially when dependencies or special tools
    are involved. What compiles on one machine might not work on another because a
    crucial piece of software is missing. Relying on the correctness of the documentation
    of a software project to figure out all the build requirements is often not enough,
    and consequently, programmers spend a significant amount of time combing through
    various error messages to figure out why a build fails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件可能会很复杂，尤其是涉及依赖项或特殊工具时。在一台机器上编译通过的软件，在另一台机器上可能无法正常工作，因为缺少某个关键的软件。单单依赖软件项目文档的正确性来搞清楚所有构建要求通常是不够的，因此，程序员往往需要花费大量时间梳理各种错误信息，以找出构建失败的原因。
- en: There are countless stories out there of people avoiding upgrading anything
    in a build or **Continuous Integration** (**CI**) environment because they fear
    that every change might break the ability to build the software. This goes as
    far as companies refusing to upgrade the compiler toolchains they are using for
    fear of no longer being able to ship products. Creating robust and portable information
    about build environments is an absolute game-changer. With presets, CMake provides
    the possibility to define common ways to configure a project. When combined with
    toolchain files, Docker containers, and **System Roots** (**sysroots**), creating
    a build environment that is recreated on different machines becomes much easier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建或 **持续集成** (**CI**) 环境中，许多人因为害怕任何更改都可能破坏软件的构建能力，而避免升级任何东西。情况甚至严重到公司因为担心无法再发布产品，而拒绝升级其使用的编译器工具链。创建关于构建环境的稳健且可移植的信息是彻底改变游戏规则的举措。通过预设，CMake
    提供了定义配置项目的常见方式的可能性。当与工具链文件、Docker 容器和 **系统根目录** (**sysroots**) 结合使用时，创建一个可在不同机器上重建的构建环境变得更加容易。
- en: 'In this chapter, you will learn how to define CMake presets for configuring,
    building, and testing a CMake project, as well as how to define and use a toolchain
    file. We will briefly describe how to use a container to build your software and
    learn how to use a sysroot toolchain file to create an isolated build environment.
    The main topics of this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何定义 CMake 预设以配置、构建和测试 CMake 项目，以及如何定义和使用工具链文件。我们将简要介绍如何使用容器构建软件，并学习如何使用
    sysroot 工具链文件创建隔离的构建环境。本章的主要内容如下：
- en: Using CMake presets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 预设
- en: Best practices for organizing presets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织预设的最佳实践
- en: Using build containers with CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 构建容器
- en: Using sysroots to isolate build environments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sysroot 隔离构建环境
- en: So, let’s buckle down and get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们系好安全带，开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As in the previous chapters, the examples are tested with CMake 3.25 and are
    run on any of the following compilers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 和前几章一样，示例已在 CMake 3.25 版本下测试，并可在以下任一编译器上运行：
- en: GCC 9 or newer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更新版本
- en: Clang 12 or newer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更新版本
- en: MSVC 19 or newer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更新版本
- en: For the examples that use build containers, Docker is needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用构建容器的示例，需要 Docker。
- en: 'All examples and source code are available on the GitHub repository for this
    book. For this chapter, the examples for the CMake presets and build container
    are in the root folder of the repository. If any of the software is missing, the
    corresponding examples will be excluded from the build. The repository can be
    found here: [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例和源代码都可以在本书的 GitHub 仓库中找到。对于本章，CMake 预设和构建容器的示例位于仓库的根文件夹中。如果缺少任何软件，相应的示例将从构建中排除。仓库地址：[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)
- en: Using CMake presets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 预设
- en: 'While building software on a multitude of configurations, compilers, and platforms
    is CMake’s greatest strength, it is also one of its greatest weaknesses as this
    often makes it hard for a programmer to figure out the build setups that are actually
    tested and working for a given piece of software. Since version 3.19, CMake has
    had a feature called **presets**. This feature is a great tool to handle these
    scenarios in a reliable and convenient way. Before presets, developers had to
    rely on documentation and fuzzy conventions to figure out the preferred configuration
    of a CMake project. Presets can specify the build directory, generators, target
    architecture, host toolchain, cache variables, and environment variables to use
    with a project. Since CMake 3.19, presets have evolved quite a bit with the addition
    of build, test, and package presets, as well as the latest addition: workflow
    presets.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个配置、编译器和平台上构建软件是 CMake 的最大优点，但这也是其最大的弱点之一，因为这通常让程序员难以弄清楚哪些构建设置实际上经过测试并能在特定软件上工作。自
    3.19 版本以来，CMake 引入了一个叫做 **预设（presets）** 的功能。这个功能是处理这些场景的一个非常可靠且方便的工具。在引入预设之前，开发者需要依赖文档和模糊的约定来搞清楚
    CMake 项目的首选配置。预设可以指定构建目录、生成器、目标架构、主机工具链、缓存变量和用于项目的环境变量。从 CMake 3.19 版本开始，预设经历了很大的发展，增加了构建、测试和打包预设，以及最新加入的：工作流预设。
- en: 'For using presets, the top directory of a project must contain a file named
    either `CMakePresets.json` or `CMakeUserPresets.json`. If both files are present,
    they will be internally combined by parsing `CMakePresets.json` first and then
    `CMakeUserPresets.json`. Both files have the same format but serve slightly different
    use cases:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预设，项目的顶级目录必须包含一个名为 `CMakePresets.json` 或 `CMakeUserPresets.json` 的文件。如果两个文件都存在，它们会通过先解析
    `CMakePresets.json`，然后再解析 `CMakeUserPresets.json` 来内部合并。两个文件的格式相同，但用途略有不同：
- en: '`CMakePresets.json` should be provided by the project itself and handle project-specific
    tasks, such as running CI builds or knowing which toolchains to use for cross-compilation
    if they are provided with the project itself. As `CMakePresets.json` is project-specific,
    it should not refer to any files or paths outside the project structure. Since
    these presets are closely tied to the project, they are usually also kept under
    version control.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakePresets.json` 应由项目本身提供，并处理项目特定的任务，比如运行 CI 构建，或者在项目中提供的情况下，知道使用哪些工具链进行交叉编译。由于
    `CMakePresets.json` 是项目特定的，它不应该引用项目结构外的任何文件或路径。由于这些预设与项目紧密相关，通常也会将其保存在版本控制中。'
- en: '`CMakeUserPresets.json`, on the other hand, is usually defined by the developer
    for use on their own machine or build environment. `CMakeUserPresets.json` can
    be as specific as needed and may contain paths outside the project or ones that
    are unique to a particular system setup. As such, projects should not provide
    this file and also not put it under version control.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`CMakeUserPresets.json` 通常由开发者为自己的机器或构建环境定义。`CMakeUserPresets.json` 可以根据需要非常具体，可能包含项目外的路径或特定系统设置的路径。因此，项目不应该提供此文件，也不应该将其放入版本控制中。
- en: 'Presets are a great way of moving cache variables, compiler flags, and so on
    out of `CMakeLists.txt` files while still keeping the information available in
    a way that can be used with CMake and thus improve the portability of projects.
    If presets are available, they can be listed from the source directory by calling
    the following `cmake --list-presets`, which will produce an output like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 预设是将缓存变量、编译器标志等从 `CMakeLists.txt` 文件中移出的好方法，同时还能以可以与 CMake 一起使用的方式保留这些信息，从而提高项目的可移植性。如果有预设，可以通过调用以下命令
    `cmake --list-presets` 从源目录列出预设，这将生成如下输出：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will list the name of the preset in quotes, as well as the `displayName`
    property if set. To use properties from the command line, the name in quotes is
    used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出带引号的预设名称，如果设置了 `displayName` 属性，也会显示该属性。要从命令行使用属性时，使用带引号的名称。
- en: 'The CMake GUI will show all available presets in a source directory like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI 将在源目录中显示所有可用的预设，类似如下：
- en: '![Figure 9.1 – Listing available presets in the CMake GUI](img/B30947_09_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 在 CMake GUI 中列出可用的预设](img/B30947_09_01.jpg)'
- en: Figure 9.1 – Listing available presets in the CMake GUI
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 在 CMake GUI 中列出可用的预设
- en: 'As of version 3.21 of CMake, the `ccmake` command-line configuration tool does
    not support presets. **Configure** presets can be selected from the top-level
    directory by calling the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CMake 3.21 版本开始，`ccmake` 命令行配置工具不支持预设。可以通过以下方式从顶级目录选择**配置**预设：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The overall structure of `CMakePresets.json` and `CMakeUserPresets.json` is
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakePresets.json` 和 `CMakeUserPresets.json` 的整体结构如下：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `version` field specifies the JSON schema to use. Version 1 was the first
    release from CMake 3.19 and only supported `configurePresets`. Subsequent releases
    added `buildPresets`, `testPresets`, `packagePresets`, and `workflowPresets`.
    At the time of writing this book, the latest version is version 9, which was released
    with CMake 3.30.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`version` 字段指定要使用的 JSON 架构。版本 1 是 CMake 3.19 的首次发布，仅支持 `configurePresets`。随后的版本添加了
    `buildPresets`、`testPresets`、`packagePresets` 和 `workflowPresets`。在编写本书时，最新版本是版本
    9，该版本随 CMake 3.30 发布。'
- en: The optional `cmakeMinimumRequired` field may be used to define the minimum
    version of CMake needed to build this project. As the minimum requirement is usually
    also stated in the `CMakeLists.txt` files, this is often omitted.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `cmakeMinimumRequired` 字段可以用来定义构建此项目所需的最低 CMake 版本。由于最低要求通常也会在 `CMakeLists.txt`
    文件中声明，因此此字段通常会被省略。
- en: The four lists, `configurePresets`, `buildPresets`, `testPresets`, and `packagePresets`,
    each contain a list of configurations for configuring, building, testing, and
    packaging the project. The presets for building, testing, and packaging require
    the presence of at least one configuration preset, as we will see later in this
    section. The `workflowPresets` are a special case as they describe a typical workflow
    consisting of the other presets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 四个列表：`configurePresets`、`buildPresets`、`testPresets` 和 `packagePresets`，分别包含用于配置、构建、测试和打包项目的配置列表。构建、测试和打包的预设要求至少有一个配置预设，如我们将在本节后面看到的那样。`workflowPresets`
    是一个特殊情况，它描述了由其他预设组成的典型工作流。
- en: The `vendor` field contains an optional map of vendor- or IDE-specific information.
    CMake does not interpret the contents of this field except to verify the JSON
    format. The keys for the map should be the vendor-specific domain separated by
    slashes. In the previous example, the key for the vendor presets is `microsoft.com/VisualStudioSettings/CMake/1.9`.
    The values inside the vendor fields can be of any valid JSON format. All preset
    files have to contain at least one configure preset, so let’s have a closer look
    there.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`vendor` 字段包含一个可选的映射，用于存储供应商或 IDE 特定的信息。CMake 不会解释此字段的内容，除非验证 JSON 格式。映射的键应该是由斜杠分隔的供应商特定域。在前面的示例中，供应商预设的键是
    `microsoft.com/VisualStudioSettings/CMake/1.9`。供应商字段中的值可以是任何有效的 JSON 格式。所有预设文件必须至少包含一个配置预设，因此让我们更仔细地看一下。'
- en: Configure presets
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置预设
- en: 'To use presets, at least one configure preset that defines an environment for
    CMake to configure the build system has to be present. They should at least specify
    the build path and the generator to use when configuring. Often, a configure preset
    also sets common cache variables such as `CMAKE_BUILD_TYPE` for single-configuration
    generators. A preset containing a configure preset to build a project with the
    Ninja generator in debug mode might look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预设，必须至少存在一个配置预设，用于为 CMake 配置构建系统的环境。它们至少应该指定构建路径以及配置时使用的生成器。通常，配置预设还会设置一些常见的缓存变量，比如用于单配置生成器的
    `CMAKE_BUILD_TYPE`。一个包含配置预设的预设，用于在调试模式下使用 Ninja 生成器构建项目，可能像这样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All presets must have a name that is unique within the preset block. As some
    GUI applications only show presets that have a `displayName` field assigned, setting
    this field is highly recommended.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有预设必须具有在预设块中唯一的名称。由于某些 GUI 应用程序仅显示已分配 `displayName` 字段的预设，因此强烈建议设置此字段。
- en: Naming conventions for presets
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 预设命名约定
- en: It is good practice to name presets that are defined by the project in a `CMakePresets.json`
    file such that they do not clash with names the developer might define in `CMakeUserPresets.json`.
    A common convention is to prefix project-defined presets with `ci-` to mark them
    as being used by the CI environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的实践是，在 `CMakePresets.json` 文件中定义的预设名称应避免与开发者可能在 `CMakeUserPresets.json` 中定义的名称冲突。一个常见的约定是，将项目定义的预设以
    `ci-` 为前缀，以标记它们用于 CI 环境。
- en: In versions 1 and 2 of the presets, the `binaryDir` and `generator` fields were
    mandatory; with version 3, they became optional. If either of the fields is not
    set, the behavior in this regard is the same as when CMake is used without presets.
    The command-line options for the CMake command will override the values specified
    in the presets where relevant. So, if `binaryDir` is set, it is automatically
    created when `cmake --preset=` is called, although its value will be overridden
    if the `-B` option is passed to CMake.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1和2的预设中，`binaryDir`和`generator`字段是必需的；在版本3中，它们变为可选。如果未设置任一字段，其行为与未使用预设的CMake相同。CMake命令的命令行选项将在相关情况下覆盖预设中指定的值。因此，如果设置了`binaryDir`，在调用`cmake
    --preset=`时，它会自动创建，但如果传递了`-B`选项，则其值会被CMake覆盖。
- en: 'Cache variables can either be defined as `key:value` pairs, as shown in the
    preceding example, or as a JSON object, which allows specifying the variable type.
    A file path could be specified like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量可以通过`key:value`对来定义，如前面的示例所示，或者作为JSON对象，这样可以指定变量类型。文件路径可以像这样指定：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If used in the `key:value` form, the type is treated as `STRING` unless it is
    `true` or `false` (without quotes), in which case it is interpreted as `BOOL`.
    Note `${sourceDir}` in the example, which is a macro that is expanded when the
    preset is used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以`key:value`的形式使用，则类型将被视为`STRING`，除非它是`true`或`false`（没有引号），在这种情况下将被解释为`BOOL`。例如，`$
    {sourceDir}`是一个宏，当使用预设时会展开。
- en: 'The following macros are known:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 已知的宏如下：
- en: '`${sourceDir}`: This points to the project source directory and `${sourceParentDir}`
    points to the parent directory of the source directory. The directory name without
    the path of the source directory can be obtained with `${sourceDirName}`. For
    example, if `${sourceDir}` is `/home/sandy/MyProject`, then `${sourceDirName}`
    would be `MyProject` and `${sourceParentDir}` would be `/home/sandy/`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${sourceDir}`：这指向项目的源目录，`${sourceParentDir}`指向源目录的父目录。可以通过`${sourceDirName}`获取源目录的目录名，不包括路径。例如，如果`${sourceDir}`是`/home/sandy/MyProject`，那么`${sourceDirName}`将是`MyProject`，而`${sourceParentDir}`将是`/home/sandy/`。'
- en: '`${generator}`: This contains the generator as specified by the current preset
    used. For build and test presets, this contains the generator of the configure
    preset used.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${generator}`：这是当前使用的预设指定的生成器。对于构建和测试预设，它包含配置预设使用的生成器。'
- en: '`${hostSystemName}`: This is the system name of the host operating system,
    which is the same as the `CMAKE_HOST_SYSTEM` variable. The value is either the
    result of `uname -s` or Linux, Windows, or Darwin (for macOS).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${hostSystemName}`：这是主机操作系统的系统名称，与`CMAKE_HOST_SYSTEM`变量相同。该值要么是`uname -s`的结果，要么是Linux、Windows或Darwin（用于macOS）。'
- en: '`$env{<variable-name>}`: This contains the environment variable with the `<variable-name>`
    name. If the variable is defined in the preset with the environment field, this
    value is used instead of the value from the parent or system environment. Using
    `$penv{<variable-name>}` works similarly, but the value is always taken from the
    parent environment and not from the environment field, even if it is defined.
    This allows prepending or appending values to existing environment variables.
    Appending or prepending variables is not possible with `$env{...}` because it
    does not allow circular references. Note that while in a Windows environment,
    variables are case-insensitive, variables used in the presets are still case-sensitive.
    Because of this, it is recommended to keep the casing of environment variables
    consistent.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$env{<variable-name>}`：这包含名为`<variable-name>`的环境变量。如果该变量在预设的环境字段中定义，则使用此值，而不是从父环境或系统环境中获取的值。使用`$penv{<variable-name>}`的作用类似，但值始终从父环境中获取，而不是从环境字段中获取，即使该变量已定义。这允许向现有环境变量添加前缀或后缀。由于`$env{...}`不允许循环引用，因此不能向变量添加前缀或后缀。需要注意的是，在
    Windows 环境中，变量是不区分大小写的，但在预设中使用的变量仍然区分大小写。因此，建议保持环境变量的大小写一致。'
- en: '`$vendor{<macro-name>}`: This is an extension point for vendors of IDEs to
    insert their own macros. Since CMake is not able to interpret these macros, presets
    using `$vendor{…}` macros will be ignored.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$vendor{<macro-name>}`：这是供IDE供应商插入其自定义宏的扩展点。由于CMake无法解释这些宏，使用`$vendor{…}`宏的预设将被忽略。'
- en: '`${dollar}`: This is a placeholder for the literal dollar sign, `$`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${dollar}`：这是一个占位符，代表字面上的美元符号`$`。'
- en: 'Modifying the environment for a preset works similarly to setting cache variables:
    by setting the `environment` field, which contains a map of `key:value` pairs.
    Environment variables are always set, even when the value is empty or `null`.
    Environment variables may reference each other as long as they do not contain
    circular references. Consider the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 修改预设的环境与设置缓存变量类似：通过设置包含`key:value`对的映射的`environment`字段。即使值为空或为`null`，环境变量始终会被设置。环境变量可以互相引用，只要不包含循环引用。考虑以下示例：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `PATH` environment variable is modified by prepending a
    path from inside the project structure. Using the `$penv{PATH}` macro ensures
    that the value is taken from outside the preset. The `LOCAL_PATH` variable then
    references the modified `PATH` environment variable by using the `$env{PATH}`
    macro. This reference is fine as long as the `PATH` environment variable does
    not contain `$env{LOCAL_PATH}`, which would create a circular reference. The `EMPTY`
    environment variable is unset by passing `null`. Note that `null` is not in quote
    marks. Unless a build preset or a test preset is used, the environment is *not*
    forwarded to the respective steps. If a build preset or a test preset is used,
    but the environment from the configure preset should not be applied, this can
    be explicitly stated when the `inheritConfigureEnvironment` field is set to `false`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`PATH`环境变量通过在项目结构内部预先添加路径进行修改。使用`$penv{PATH}`宏确保值来自预设之外。然后，`LOCAL_PATH`变量通过使用`$env{PATH}`宏引用修改后的`PATH`环境变量。只要`PATH`环境变量不包含`$env{LOCAL_PATH}`（这将产生循环引用），这种引用是允许的。通过传递`null`，`EMPTY`环境变量被取消设置。注意，`null`不需要加引号。除非使用构建预设或测试预设，否则环境*不会*传递到相应的步骤。如果使用了构建预设或测试预设，但不希望应用来自配置预设的环境，可以通过将`inheritConfigureEnvironment`字段设置为`false`来明确声明。
- en: Inheriting from presets
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从预设中继承
- en: 'Presets may inherit from other presets of the same type with the `inherits`
    field, which may contain either a single preset or a list of presets. When inheriting
    fields from the parent, a preset can be overridden or additional fields added.
    This is useful to avoid duplicating code for common building blocks. In combination
    with the `hidden` field, this can make a `CMakePreset.json` file smaller. Consider
    the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 预设可以通过`inherits`字段继承其他相同类型的预设，该字段可以包含单个预设或预设列表。在继承父级字段时，预设可以被覆盖或添加额外的字段。这对于避免为常见构建块重复代码非常有用。结合`hidden`字段使用时，可以使`CMakePreset.json`文件更小。考虑以下示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the example, the `ci-ninja-debug` and `ci-ninja-release` presets both inherit
    from the hidden `ci-ninja` `build` preset and additionally set the `CMAKE_BUILD_TYPE`
    cache variable to the respective configuration. Hidden presets can still be used
    but will not show up when `cmake --list-presets` is invoked. Presets defined in
    `CMakeUserPreset.json` may inherit from `CMakePreset.json` but not the other way
    around.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`ci-ninja-debug`和`ci-ninja-release`预设都从隐藏的`ci-ninja` `build`预设继承，并额外设置了`CMAKE_BUILD_TYPE`缓存变量，以对应的配置进行构建。隐藏预设仍然可以使用，但在执行`cmake
    --list-presets`时不会显示。`CMakeUserPreset.json`中定义的预设可以从`CMakePreset.json`继承，但反过来不行。
- en: 'In the preceding example, the preset inherits from a single parent, but presets
    can also inherit from multiple parents. The following example shows how `CMakeUserPreset.json`
    working with `CMakePreset.json` from the previous example might look:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，预设继承自单一父预设，但预设也可以从多个父预设继承。以下示例展示了`CMakeUserPreset.json`与前面示例中的`CMakePreset.json`如何协同工作：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the user supplies a preset that explicitly selects GCC 11 as a compiler
    named `gcc-11`. Later, the `ninja-debug-gcc` preset inherits the values from the
    `ci-ninja-debug` preset that is defined in `CMakePreset.json` supplied by the
    project and combines it with the user-supplied `gcc-11` preset. If two parent
    presets define different values for the same field, the value from the one that
    appears first in the `inherits` list takes precedence.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户提供了一个预设，明确选择了GCC 11作为名为`gcc-11`的编译器。之后，`ninja-debug-gcc`预设从项目提供的`CMakePreset.json`中定义的`ci-ninja-debug`预设继承值，并与用户提供的`gcc-11`预设结合。如果两个父预设为相同字段定义了不同的值，则`inherits`列表中首先出现的那个预设的值优先。
- en: Conditions for presets
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预设条件
- en: 'Sometimes, presets only make sense under certain conditions, such as for a
    certain build platform. For instance, a configure preset that uses the Visual
    Studio generator would only be useful in a Windows environment. For these cases,
    presets can be disabled if the conditions are not met with the `condition` option.
    Any conditions defined in a parent preset are inherited. Conditions can be constants,
    string comparisons, or a check of whether a list contains a value. They are available
    from version 3 of the presets onward. The following configure preset would only
    be enabled if you are working on Windows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，预设仅在某些条件下才有意义，例如针对特定的构建平台。例如，使用Visual Studio生成器的配置预设仅在Windows环境中才有用。对于这些情况，如果条件不满足，可以使用`condition`选项禁用预设。任何在父预设中定义的条件都会被继承。条件可以是常量、字符串比较，或检查列表是否包含某个值。从预设版本3开始提供这些功能。以下配置预设仅在你在Windows环境下工作时启用：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, the build preset is enabled if the name of the host
    system is retrieved using the `${hostSystemName}` macro and then compared to the
    `Windows` string. If `${hostSystemName}` matches, then the preset is enabled;
    otherwise, it is disabled and trying to use it will result in an error. When comparing
    strings, casing matters: for case-insensitive tests, the `matches` or `notMatches`
    type, which takes a regex, could be used.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，构建预设会在使用`${hostSystemName}`宏获取主机系统的名称并与`Windows`字符串进行比较后启用。如果`${hostSystemName}`匹配，则启用预设；否则，禁用该预设，尝试使用它会导致错误。在比较字符串时，大小写是重要的：对于不区分大小写的测试，可以使用`matches`或`notMatches`类型，它们接受正则表达式。
- en: 'For more complex conditions, support nesting with Boolean logic with the `allOf`,
    `anyOf`, and `not` operators. For example, if a configure preset should only be
    enabled for Windows and Linux but not for macOS, the preset and the condition
    could look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的条件，支持使用`allOf`、`anyOf`和`not`运算符进行布尔逻辑嵌套。例如，如果一个配置预设只应在Windows和Linux下启用，而在macOS下不启用，则预设和条件可以如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of the conditions could also contain further nested conditions if needed,
    although doing so will quickly increase the complexity of the presets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件也可以包含进一步的嵌套条件（如果需要的话），尽管这样做会迅速增加预设的复杂性。
- en: So far, we have only seen configure presets in the examples, but as mentioned
    at the beginning of the chapter, there are also build presets and test presets.
    The syntax for build and test presets is very similar to configure presets and
    a lot of fields, such as `name`, `displayName`, and `inherit`, and conditions
    work the same as with configure presets. Once the configure preset has been specified,
    we can start specifying build-, test- and packaging presets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在示例中只见过配置预设，但正如本章开头所提到的，还有构建预设和测试预设。构建和测试预设的语法与配置预设非常相似，许多字段，如`name`、`displayName`和`inherit`，以及条件的工作方式与配置预设相同。一旦指定了配置预设，我们就可以开始指定构建、测试和打包预设。
- en: Build-, test- and package presets
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建、测试和打包预设
- en: 'Build presets have to specify a configure preset in the `configurePreset` field
    or inherit from another build preset that specifies the configure preset. The
    build directory is determined by the configure preset and the environment from
    the configure preset is inherited unless the `inheritConfigureEnvironment` field
    is set to `false`. Build presets are mostly used for multi-config generators,
    but they can also be used for single-configuration generators if needed. Optionally,
    build presets can specify a list of targets to build. An example of a build preset
    could look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建预设必须在`configurePreset`字段中指定一个配置预设，或从另一个指定了配置预设的构建预设中继承。构建目录由配置预设决定，除非`inheritConfigureEnvironment`字段设置为`false`，否则会继承配置预设的环境。构建预设主要用于多配置生成器，但如果需要，也可以用于单配置生成器。可选地，构建预设可以指定一个要构建的目标列表。一个构建预设的示例如下：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, three build presets are defined. The first two, called
    `ci-msvc-debug` and `ci-msvc-release` respectively, are used to specify the build
    configuration for Visual Studio and do not specify any targets. The third build
    preset is called `ci-documentation` and lists the `api-doc` and `doc` targets
    as part of the documentation build. Invoking any of the `ci-msvc` build presets
    will build the `"all"` target, while the `ci-documentation` will only build the
    listed targets. The list of available build presets can be retrieved with `cmake
    --``build --list-presets`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，定义了三个构建预设。前两个分别叫做`ci-msvc-debug`和`ci-msvc-release`，用于指定Visual Studio的构建配置，并且不指定任何目标。第三个构建预设叫做`ci-documentation`，并将`api-doc`和`doc`目标列为文档构建的一部分。调用任何`ci-msvc`构建预设都会构建`"all"`目标，而`ci-documentation`则只会构建列出的目标。可用的构建预设列表可以通过`cmake
    --build --list-presets`命令获取。
- en: 'Test presets work very similarly to build presets, except that they are used
    with CTest. Similarly, a call to `ctest --list-presets` on the project root will
    list the available test presets. Test presets are a very handy tool to select
    or exclude certain tests, specify fixture options, or control the output of the
    tests. Most of the options for tests described in [*Chapter 7*](B30947_07.xhtml#_idTextAnchor113),
    *Seamlessly Integrating Code Quality Tools with CMake*, can be controlled from
    the test presets. An example of test presets could look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 测试预设与构建预设非常相似，不同之处在于它们与CTest一起使用。类似地，在项目根目录下运行`ctest --list-presets`命令将列出可用的测试预设。测试预设是一个非常有用的工具，可以用来选择或排除特定的测试、指定固定选项，或者控制测试的输出。大部分在[*第7章*](B30947_07.xhtml#_idTextAnchor113)中描述的测试选项，*无缝集成代码质量工具与CMake*，都可以通过测试预设来控制。一个测试预设的示例如下：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, a test preset is added that filters the tests for
    any that include `feature-X` but excludes any tests that were labeled as `integration`.
    This is equivalent to invoking the following command from the build directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，添加了一个测试预设，用于过滤包含`feature-X`的测试，但排除了标记为`integration`的任何测试。这等同于从构建目录调用以下命令：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Package presets again work very similarly to the build and test presets, and
    they also require a configuration preset to be set. An example package preset
    might look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 包预设与构建和测试预设非常相似，也需要设置一个配置预设。一个包预设的示例如下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This package preset will build a package using the TGZ generator and place the
    resulting package into the `dist` directory. As packaging depends on the generators,
    and CPack requires quite extensive configuration, the presets are mostly used
    to place packages at a predefined location and together with workflow presets,
    as we will see in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包预设将使用TGZ生成器构建一个包，并将结果包放入`dist`目录中。由于打包依赖于生成器，并且CPack需要相当复杂的配置，因此预设通常用于将包放置在预定义位置，并与工作流预设一起使用，正如我们将在下一节看到的那样。
- en: Workflow presets
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流预设
- en: Workflow presets are – as the name suggests – a way to define full workflows
    from configuration to build, test, and package. If any of the steps in between
    fail, the workflow is interrupted, and the subsequent steps are not executed.
    Workflow presets are primarily intended to be used in automated build systems,
    but they can, of course, also be used locally.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流预设顾名思义，是一种从配置到构建、测试和打包的完整工作流定义方式。如果其中的任何一步失败，工作流将中断，后续步骤不会被执行。工作流预设主要用于自动化构建系统，但当然也可以在本地使用。
- en: 'The syntax to list workflow presets is like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列出工作流预设的语法如下：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To invoke a workflow preset, the following command is used:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用工作流预设，使用以下命令：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will execute the full `ci-ninja-debug-workflow` workflow. Workflows are
    defined as a series of steps like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行完整的`ci-ninja-debug-workflow`工作流。工作流定义为一系列的步骤，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command defines a workflow that configures, builds, tests, and packages
    the project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令定义了一个工作流，配置、构建、测试并打包项目。
- en: All workflow steps must use the same configuration preset
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作流步骤必须使用相同的配置预设
- en: One noteworthy thing is that all steps have to define the same configuration
    step, or else the workflow will not be correct and CMake will fail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点值得注意的是，所有步骤必须定义相同的配置步骤，否则工作流将不正确，CMake会失败。
- en: While they lack the sophistication to define full build pipelines like GitHub
    Actions, Jenkins, and Azure DevOps do, they offer the advantage of making it very
    easy for developers to follow a defined workflow. Workflow presets are an attempt
    to handle the “combinatorial explosion” problem of CMake if there are a lot of
    presets used. While they can help with the problem to some extent, they also require
    that all intermediate steps are explicitly defined and explicitly use the same
    configuration presets. This in turn might force developers to add even more presets
    that are somewhat “same-same-but-different” in flavor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们缺乏像GitHub Actions、Jenkins和Azure DevOps那样定义完整构建流水线的复杂性，但它们的优势在于能够让开发人员轻松遵循定义好的工作流。工作流预设是应对CMake预设“组合爆炸”问题的一种尝试，尤其是当有很多预设时。虽然它们在一定程度上有助于解决这个问题，但它们也要求所有中间步骤都明确地定义，并显式使用相同的配置预设。这样一来，可能迫使开发人员添加更多的预设，这些预设在某种程度上是“差不多但不完全相同”的。
- en: There is no silver bullet for the problem yet, but if presets are well organized
    and set up with some discipline, a lot can be gained.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有一劳永逸的解决方案，但如果预设组织得当，并且遵循一定的纪律，仍然可以获得很多好处。
- en: Best practices for organizing presets
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组织预设的最佳实践
- en: As projects grow – especially when they are targeted at multiple platforms –
    the number of CMake presets can grow quickly as well. This can make it hard to
    keep track of them and find the right one. Setting up workflow presets can help
    but it is only half of the game, and the downside is often that using workflow
    presets creates even more presets for all the intermediate steps.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长——特别是当它们面向多个平台时——CMake预设的数量也可能迅速增加。这会使得跟踪预设并找到正确的预设变得困难。设置工作流预设可以有所帮助，但这仅仅是解决问题的一半，缺点往往是，使用工作流预设会为所有中间步骤创建更多的预设。
- en: The first part of organizing the presets is finding a good naming scheme. This
    makes it easy to figure out what a preset does and also has the benefit of letting
    devs guess what a desired preset might be named if it exists.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 组织预设的第一步是找到一个好的命名方案。这样可以轻松地弄清楚某个预设的作用，也有助于让开发人员猜测所需的预设名称（如果它存在的话）。
- en: 'A good scheme is one that contains the following information for building:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的方案应该包含以下构建信息：
- en: The `ci` or `dev`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ci` 或 `dev`'
- en: The **generator** to be used
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的**生成器**
- en: The **toolchain** such as the compiler and the target platform to be used
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具链**，例如要使用的编译器和目标平台'
- en: The **build type** such as debug or release
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建类型**，例如调试版或发布版'
- en: By using this, we end up with a scheme such as `<env>-<generator>-<toolchain>-<buildType>`,
    so a preset to build for Linux x86_64 might be named `ci-ninja-linux-x86_64-clang-debug`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，我们最终得到一个类似于`<env>-<generator>-<toolchain>-<buildType>`的方案，因此用于构建Linux
    x86_64的预设可能被命名为`ci-ninja-linux-x86_64-clang-debug`。
- en: The naming scheme fits all kinds of presets, but is most useful for configure
    presets. The `env` here is either `ci` or `dev`, depending on whether the preset
    is used in CI or locally. A good rule of thumb is to put all `ci` presets into
    the `CMakePresets.json` and to put them under version control, while the `dev`
    presets are placed in the `CMakeUserPresets.json` and are not checked in. The
    generator part can be any of the generators that are supported by CMake such as
    Makefiles, Ninja, or MSVC for Microsoft Visual Studio. The toolchain is a combination
    of the target platform, compiler, and operating system to be used, often called
    a target triplet or target quadruplet, such as `linux-armv7-clang12`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 命名方案适用于各种预设，但对于配置预设最为有用。这里的`env`可以是`ci`或`dev`，取决于预设是用于CI还是本地使用。一个好的经验法则是将所有`ci`预设放入`CMakePresets.json`并进行版本控制，而将`dev`预设放入`CMakeUserPresets.json`并且不进行检查。生成器部分可以是CMake支持的任何生成器，例如Makefiles、Ninja或MSVC（用于Microsoft
    Visual Studio）。工具链是一个由目标平台、编译器和操作系统组合而成的部分，通常称为目标三元组或目标四元组，例如`linux-armv7-clang12`。
- en: The build type is one of the common build types such as debug, release, relWithDebInfo,
    or minSizeRel but it can also be a custom build type if the projects configure
    any of them. For multi-config generators such as ninja-multi, the build type can
    be omitted in the configure preset and used in the build preset. To aggregate
    the presets, use inheritance and hidden presets. So, which preset goes into which
    part?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类型是常见的构建类型之一，如调试版、发布版、带调试信息的发布版（relWithDebInfo）或最小大小发布版（minSizeRel），但如果项目配置了自定义构建类型，也可以使用它。对于像ninja-multi这样的多配置生成器，构建类型可以在配置预设中省略，并在构建预设中使用。为了聚合预设，可以使用继承和隐藏的预设。那么，哪个预设应该放入哪个部分呢？
- en: '![Figure 9.2 – Grouping  presets by types to assemble usable presets](img/B30947_09_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 按类型分组预设以组合可用预设](img/B30947_09_02.jpg)'
- en: Figure 9.2 – Grouping presets by types to assemble usable presets
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 按类型分组预设以组合可用预设
- en: 'Let’s have a closer look at the different types of presets used to assemble
    a usable preset:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看用于组合可用预设的不同类型的预设：
- en: '`ci` presets should use the same or at least a similar set of these presets.
    Typically, this category contains multiple presets for the different aspects,
    such as one preset to set up Ccache, and one to point to the clang-tidy.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ci` 预设应使用相同或至少相似的一组预设。通常，此类别包含多个预设，针对不同方面，例如一个用于设置 Ccache，另一个用于指向 clang-tidy。'
- en: '**Generator presets**: They define the CMake generator to be used. For package
    presets, this can also be the package generator. They are hidden by default. Typically,
    only the generators actually used in either CI or locally should be present.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器预设**：它们定义要使用的 CMake 生成器。对于包预设，这也可以是包生成器。默认情况下，它们是隐藏的。通常，只有在 CI 或本地实际使用的生成器应该存在。'
- en: '`hidden`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden`。'
- en: '**Build type presets**: These define the build type such as release, debug,
    RelWithDebInfo, or MinSizeRel.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建类型预设**：这些定义构建类型，例如 release、debug、RelWithDebInfo 或 MinSizeRel。'
- en: '**Combining the presets**: These are the presets that combine all the previous
    presets into usable presets through the inherit keyword. They are set to visible
    and have a build directory specified either directly or through one of the previous
    presets.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合预设**：这些预设通过 inherit 关键字将所有先前的预设组合成可用预设。它们是可见的，并且指定了构建目录，通常是直接指定或通过其中一个先前的预设指定。'
- en: Setting up the presets in such a way helps keep them organized. CMake presets
    support including different files, so placing the categories into different files
    might help keep them organized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置预设有助于保持它们的组织性。CMake 预设支持包含不同的文件，因此将类别放入不同的文件中可能有助于保持它们的组织性。
- en: CMake presets are arguably one of the few features that have changed how CMake
    is used the most since the introduction of targets. They are a good compromise
    to deliver common configuration and build options together with the projects while
    keeping the `CMakeLists.txt` file platform-agnostic. In the end, there is no way
    around the problem that CMake supports a vast number of tools and platforms, or
    that C++ software can be built in various ways. Accommodating for this flexibility
    comes at the price of needing to maintain all of these configurations; presets
    are definitively a good option. However, sometimes, providing the necessary settings
    is not enough and you also want to share a build environment in which you are
    sure that the software compiles. One option to do this is by defining a build
    container that contains CMake and the necessary libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 预设可以说是自从引入目标以来，改变了 CMake 使用方式的少数几个特性之一。它们是一个很好的折衷方案，可以将常见的配置和构建选项与项目一起提供，同时保持
    `CMakeLists.txt` 文件与平台无关。最终，无法避免 CMake 支持大量工具和平台，或者 C++ 软件可以通过多种方式构建这一问题。适应这种灵活性需要维护所有这些配置；预设显然是一个不错的选择。然而，有时候，提供必要的设置还不够，你还希望共享一个构建环境，确保软件能够编译。一种实现方法是通过定义一个包含
    CMake 和必要库的构建容器。
- en: Using build containers with CMake
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 的构建容器
- en: Containerization brings the benefit that developers can control the build environment
    to some extent. Containerized build environments are also a tremendous help for
    setting up CI environments. There are quite a few container runtimes out there,
    with Docker being the most popular. It would exceed the scope of this book to
    look at containerization in depth, so we will use Docker for the examples in this
    book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化带来的好处是开发人员可以在一定程度上控制构建环境。容器化的构建环境对于设置 CI 环境也非常有帮助。目前有许多容器运行时，其中 Docker 是最流行的。深入探讨容器化超出了本书的范围，因此我们将在本书的示例中使用
    Docker。
- en: A build container contains a fully defined build system including CMake and
    any tools and libraries needed to build a certain software. By providing the container
    definition (for example, the Dockerfile), along with the project, or over a publicly
    accessible container registry, anyone can use the container to build the software.
    The huge advantage is that developers do not need to install and possibly pollute
    their host machine by installing additional libraries or tools except the software
    needed to run the containers. The downside is that building might take longer
    and not all IDEs and tools support working with containers in a convenient way.
    Notably, Visual Studio Code has very good support for working in containers. You
    can visit [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
    for more details.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器包含一个完全定义的构建系统，包括 CMake 和构建某个软件所需的任何工具和库。通过提供容器定义（例如 Dockerfile），以及项目文件，或者通过公开可访问的容器注册表，任何人都可以使用该容器来构建软件。巨大的优势是开发者不需要安装额外的库或工具，从而避免污染主机机器，除了运行容器所需的软件。缺点是构建可能需要更长的时间，并且并非所有
    IDE 和工具都支持以便捷的方式与容器协作。值得注意的是，Visual Studio Code 对在容器中工作提供了很好的支持。您可以访问[https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)了解更多细节。
- en: 'At a very high level, the workflow for using a build container is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从很高的层次来看，使用构建容器的工作流程如下：
- en: Define the container and build it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义容器并构建它。
- en: Mount a local copy of the source code into the build container.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地代码的副本挂载到构建容器中。
- en: Run any commands for building inside the container.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行任何构建命令。
- en: 'A very simple Docker definition for building a simple C++ application could
    look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建一个简单 C++ 应用程序的非常简单的 Docker 定义可能如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will define a small container based on the Alpine Linux 3.15 and install
    `cmake`, `ninja`, `bash`, `make`, and `git`. Any real-life container will probably
    have additional tools and libraries installed inside to work conveniently; however,
    just to illustrate how building software with a container works, having such a
    minimal container is enough. The following Docker command builds the container
    image and tags it with the `builder_minimal` name:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于 Alpine Linux 3.15 定义一个小型容器，并安装`cmake`、`ninja`、`bash`、`make`和`git`。任何实际使用的容器可能会安装额外的工具和库以方便工作；然而，仅为了说明如何使用容器构建软件，拥有这样一个最小的容器就足够了。以下
    Docker 命令将构建容器镜像，并使用`builder_minimal`名称进行标签：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the container is a clone of the local, the source is mounted inside the
    container and all CMake commands are executed inside the container. Assuming that
    the user is executing the Docker command from the `source` directory, the commands
    to configure a CMake build project might look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器是本地的克隆，源代码被挂载到容器中，所有的 CMake 命令都在容器内部执行。假设用户从`source`目录执行 Docker 命令，配置 CMake
    构建项目的命令可能看起来像这样：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will start up the container we created and execute the CMake commands within.
    The local directory is mounted inside the container as `/workspace` with the `-v`
    option. Since our Docker containers use *root* as the default user, the user ID
    and group to use are passed with the `--user` option. On Unix-like operating systems,
    this should match the user ID of the host, so any files created can also be edited
    from outside the container. The `--rm` flag tells Docker to remove the image once
    it is done with it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动我们创建的容器并执行其中的 CMake 命令。通过`-v`选项，本地目录会挂载到容器中的`/workspace`。由于我们的 Docker 容器默认使用*root*作为用户，因此需要通过`--user`选项传递用户
    ID 和组 ID。对于类 Unix 操作系统，用户 ID 应与主机上的用户 ID 匹配，这样创建的任何文件也可以在容器外部编辑。`--rm`标志告诉 Docker
    在完成后删除镜像。
- en: 'An alternative way to work with the container is to run it in interactive mode
    by passing the `-ti` flag to the `docker` `run` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器交互的另一种方式是通过向`docker` `run`命令传递`-ti`标志来以交互模式运行它：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will start a shell inside the container where the `build` command can be
    invoked without the need to restart the container every time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在容器内启动一个 shell，可以在其中调用`build`命令，而无需每次都重新启动容器。
- en: There are several strategies for how editors or IDEs and build containers can
    work together. The most convenient way is, of course, if the IDE supports it natively
    or through a convenient extension like Visual Studio Code does. If this is not
    the case, packing a suitable editor inside the container and executing it from
    within can be a viable strategy to develop software conveniently. Another way
    is to run the editor on the host system and reconfigure it so it doesn’t invoke
    CMake directly but starts the container and executes CMake within.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器或 IDE 和构建容器如何协同工作有几种策略。最便捷的方式当然是 IDE 本身原生支持，或者通过像 Visual Studio Code 这样的方便扩展支持。如果没有这种支持，将合适的编辑器打包进容器并从容器内启动也是一个可行的策略来方便地开发软件。另一种方法是在宿主系统上运行编辑器，并重新配置它，使其不直接调用
    CMake，而是启动容器并在其中执行 CMake。
- en: What we have shown here is the bare minimum for working with containers as build
    environments, but we hope it serves as a very first stepping stone to working
    with containers. As more and more IDEs start to support working with containerized
    build environments, using them will become much easier. Containers make build
    environments very portable between various machines and can help to ensure that
    all developers of a project are using the same build environment. It is also a
    good idea to put container definition files under version control so that necessary
    changes to the build environment are tracked together with the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的只是使用容器作为构建环境的最低要求，但我们希望它能作为使用容器的第一步。随着越来越多的集成开发环境（IDE）开始支持容器化构建环境，使用它们将变得更加容易。容器使得构建环境在不同机器之间变得非常可移植，并有助于确保项目中的所有开发者都使用相同的构建环境。将容器定义文件放在版本控制下也是一个好主意，这样对构建环境的必要更改就能与代码一起进行跟踪。
- en: Containers are a good and portable way of creating isolated build environments.
    However, if this is not an option for any reason, another way to create an isolated
    and portable build environment is using sysroots.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是创建隔离构建环境的一种好且可移植的方式。然而，如果出于某种原因无法使用容器，另一种创建隔离和可移植构建环境的方法是使用 sysroot。
- en: Using sysroots to isolate build environments
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sysroot 来隔离构建环境
- en: In a nutshell, a sysroot is a directory that a build system considers to be
    the root directory from which to locate headers and libraries. In brief, they
    contain a stripped-down version of the root filesystem for the platform for which
    software is being compiled. They are often used when cross-compiling software
    for other platforms, as described in [*Chapter 12*](B30947_12.xhtml#_idTextAnchor182),
    *Cross-Platform Compiling and Custom Toolchains*. If containers for shipping whole
    build environments are not an option, sysroots can be an alternative to provide
    a defined build environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，sysroot 是构建系统认为的根目录，用来定位头文件和库文件。简而言之，它们包含为目标平台编译软件时所需的简化版根文件系统。它们通常在交叉编译软件到其他平台时使用，如
    [*第 12 章*](B30947_12.xhtml#_idTextAnchor182) 中所述，*跨平台编译与自定义工具链*。如果容器无法用于传递整个构建环境，sysroot
    可以作为提供已定义构建环境的替代方案。
- en: 'To use a sysroot with CMake, a toolchain file is needed. As the name suggests,
    these files define the tools to use to compile and link the software as well as
    indicating where to find any libraries. In a normal build, CMake automatically
    detects the toolchain by introspecting the system. Toolchain files are passed
    to CMake with the `CMAKE_TOOLCHAIN_FILE` variable like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 CMake 中使用 sysroot，需使用工具链文件。顾名思义，这些文件定义了编译和链接软件所使用的工具，并指明了查找任何库的路径。在正常的构建过程中，CMake
    会通过系统自检自动检测工具链。工具链文件通过 `CMAKE_TOOLCHAIN_FILE` 变量传递给 CMake，方法如下：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since version 3.21, CMake additionally supports the `--toolchain` option to
    pass toolchain files, which is equivalent to passing the `CMAKE_TOOLCHAIN_FILE`
    cache variable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.21 开始，CMake 额外支持 `--toolchain` 选项来传递工具链文件，这相当于传递 `CMAKE_TOOLCHAIN_FILE`
    缓存变量。
- en: 'Alternatively, the toolchain file can be passed as a cache variable with a
    CMake preset. At a minimum, a toolchain file to use with a sysroot will define
    the `CMAKE_SYSROOT` variable to point to the sysroot and the `CMAKE_<LANG>_COMPILER`
    variable to point to a compiler that is compatible with the libraries in the sysroot.
    To avoid mixing dependencies from outside the sysroot with the files installed
    on the host system, the variables for controlling where the `find_` commands look
    for stuff are usually also set. A minimal toolchain file might look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，工具链文件可以作为缓存变量通过CMake预设传递。最基本的情况下，使用sysroot的工具链文件会定义`CMAKE_SYSROOT`变量来指向sysroot，`CMAKE_<LANG>_COMPILER`变量来指向与sysroot中的库兼容的编译器。为了避免混淆来自sysroot之外的依赖与安装在主机系统上的文件，通常还会设置控制`find_`命令查找位置的变量。一个最小的工具链文件可能如下所示：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s see what happens here in detail:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这里发生了什么：
- en: First, the system name of the target system is set by setting the `CMAKE_SYSTEM_NAME`
    variable. This is the system for which the files are compiled inside the sysroot.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过设置`CMAKE_SYSTEM_NAME`变量，设置目标系统的系统名称。这是为其在sysroot内部编译文件的系统。
- en: Then, the path to the sysroot itself is set by setting the `CMAKE_SYSROOT` variable.
    `CMAKE_STAGING_PREFIX` is optional and is used to specify a location on the host
    machine to install any artifacts of the project. Specifying a staging prefix helps
    keep the sysroot and the host filesystem clean, as without it, any installation
    of the artifacts will happen on the host filesystem.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过设置`CMAKE_SYSROOT`变量，设置sysroot本身的路径。`CMAKE_STAGING_PREFIX`是可选的，用于指定一个位置来安装项目的任何产物。指定一个暂存前缀有助于保持sysroot和主机文件系统的清洁，因为如果没有它，所有产物的安装都会发生在主机文件系统上。
- en: Next, the compilers are set to the compilers binaries delivered with the sysroot
    by setting the `CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` variables.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过设置`CMAKE_C_COMPILER`和`CMAKE_CXX_COMPILER`变量，编译器会设置为与sysroot一起提供的编译器二进制文件。
- en: Lastly, the search behavior of any `find_` command in CMake is set. The `CMAKE_FIND_ROOT_PATH_MODE_*`
    variables take any of the values of `ONLY`, `NEVER`, and `BOTH`. If they are set
    to `ONLY`, CMake will only search the type of file inside the sysroot; if they
    are set to `NEVER`, searches will only consider the host file structure. If they
    are set to `BOTH`, then the host system path and the sysroot path will be searched.
    Note that `CMAKE_STAGING_PREFIX` is considered a system path, so in order to search
    the sysroot and the staging directory, `BOTH` must be selected. In the example,
    this is configured such that all header files and libraries are restricted to
    the sysroot, while any call for `find_program` will look only on the host system
    and `find_package` will look in both places.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置任何`find_`命令在CMake中的搜索行为。`CMAKE_FIND_ROOT_PATH_MODE_*`变量可以取`ONLY`、`NEVER`和`BOTH`中的任何一个值。如果设置为`ONLY`，CMake只会在sysroot内搜索该类型的文件；如果设置为`NEVER`，搜索将仅考虑主机文件结构。如果设置为`BOTH`，则会同时搜索主机系统路径和sysroot路径。需要注意的是，`CMAKE_STAGING_PREFIX`被视为系统路径，因此为了同时搜索sysroot和暂存目录，必须选择`BOTH`。在这个例子中，配置的方式是将所有头文件和库限制在sysroot中，而任何`find_program`的调用只会在主机系统中查找，`find_package`则会在两个地方查找。
- en: 'Setting the `CMAKE_SYSROOT` variable will not automatically set the place where
    build artifacts are installed. For situations where the resulting binaries are
    compatible with the host system, this might be the intended behavior. In a lot
    of cases, such as when cross-compiling, this is not what is wanted, so setting
    `CMAKE_STAGING_PREFIX` is often recommended. Setting the staging directory has
    two effects: first, it will cause any artifacts to be installed in the staging
    directory, and second, the staging directory will be added to the search prefix
    for the `find_` commands. One caveat is that the staging directory will be added
    to `CMAKE_SYSTEM_PREFIX_PATH`, which has the downside that the `CMAKE_FIND_ROOT_PATH_MODE_XXX`
    variables from the preceding example have to be set to `BOTH` so the packages,
    libraries, and programs installed in the staging area are found.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`CMAKE_SYSROOT`变量不会自动设置构建产物的安装位置。在生成的二进制文件与主机系统兼容的情况下，这可能是预期的行为。在许多情况下，比如交叉编译时，这不是我们想要的行为，因此通常推荐设置`CMAKE_STAGING_PREFIX`。设置暂存目录有两个效果：首先，它会导致所有产物安装到暂存目录中；其次，暂存目录会被添加到`find_`命令的搜索前缀中。需要注意的是，暂存目录会被添加到`CMAKE_SYSTEM_PREFIX_PATH`，这带来的一个问题是，前面例子中的`CMAKE_FIND_ROOT_PATH_MODE_XXX`变量必须设置为`BOTH`，这样才能找到安装在暂存区域中的软件包、库和程序。
- en: CMAKE_STAGING_PREFIX and CMAKE_INSTALL_PREFIX
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CMAKE_STAGING_PREFIX 和 CMAKE_INSTALL_PREFIX
- en: If both `CMAKE_STAGING_PREFIX` and `CMAKE_INSTALL_PREFIX` are set, the staging
    prefix will take precedence. So, as a rule of thumb, whenever the toolchain is
    compatible with the host system, the staging might be omitted, or it tends to
    be defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时设置了 `CMAKE_STAGING_PREFIX` 和 `CMAKE_INSTALL_PREFIX`，则 staging 前缀将具有优先权。因此，作为经验法则，只要工具链与主机系统兼容，通常可以省略
    staging，或者倾向于定义它。
- en: One downside of sysroots compared to containers is that they cannot be started
    and used to execute commands within just like that. So, if the toolchain and the
    sysroot are not compatible with the host platform, any files produced will not
    be executable without either moving to the target platform or using an emulator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器相比，sysroots 的一个缺点是它们不能像容器那样启动并直接执行命令。因此，如果工具链和 sysroot 与主机平台不兼容，则生成的任何文件都无法执行，除非移至目标平台或使用仿真器。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that one of the main strengths of CMake is its versatility
    for building software using a variety of toolchains for a large number of platforms.
    The downside of this is that it sometimes can be hard for developers to find a
    working configuration for software. However, by supplying CMake presets, containers,
    and sysroots, it often gets easier to get started with a CMake project.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们学习到 CMake 的主要优势之一是它在使用多种工具链为大量平台构建软件方面的多功能性。其缺点是，有时开发者难以找到适合的软件配置。不过，通过提供
    CMake 预设、容器和 sysroots，通常可以更容易地开始 CMake 项目。
- en: In this chapter, we looked in detail into how to define CMake presets to define
    working configuration setups, along with creating build and test definitions.
    Then, we briefly covered how to create a Docker container and how to invoke CMake
    commands within before closing the chapter with a brief look into sysroots and
    toolchain files. More about toolchains and sysroots will be covered in [*Chapter
    12*](B30947_12.xhtml#_idTextAnchor182), *Cross-Platform Compiling and* *Custom
    Toolchains*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讲解了如何定义 CMake 预设来定义工作配置设置，并创建构建和测试定义。然后，我们简要介绍了如何创建 Docker 容器以及如何在容器内调用
    CMake 命令，最后简要回顾了 sysroots 和工具链文件。有关工具链和 sysroots 的更多内容将在 [*第12章*](B30947_12.xhtml#_idTextAnchor182)
    中讲解，*跨平台编译和* *自定义工具链*。
- en: In the next chapter, you will learn how to work with big, distributed projects
    as super builds. There, you will learn how to handle different versions and how
    to assemble projects from multiple repositories in a manageable way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何将大型分布式项目作为超级构建进行处理。在那里，您将学习如何处理不同版本以及如何以可管理的方式从多个仓库组装项目。
- en: Questions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between `CMakePresets.json` and `CMakeUserPresets.json`?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakePresets.json` 和 `CMakeUserPresets.json` 有何区别？'
- en: How are presets used on the command line?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预设如何在命令行中使用？
- en: Which three types of presets exist and how do they depend on each other?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在哪三种类型的预设，它们之间如何相互依赖？
- en: What is the minimum a configure preset should define?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置预设应至少定义什么内容？
- en: When inheriting from multiple presets, which one takes precedence if a value
    is specified multiple times?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从多个预设继承时，如果某个值被多次指定，哪个预设优先？
- en: Which strategies for working with build containers are common?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常见的构建容器工作策略有哪些？
- en: What do toolchain files that are to be used with sysroots usually define?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于与 sysroots 一起使用的工具链文件通常定义了什么？
- en: Answers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`CMakePresets.json` is usually maintained and delivered together with the project,
    while `CMakeUserPresets.json` is maintained by the user. Regarding the syntax
    and the contents, there is no difference.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakePresets.json` 通常与项目一起维护和交付，而 `CMakeUserPresets.json` 则由用户维护。在语法和内容上，它们没有区别。'
- en: This can be done by calling `cmake --preset=presetName`, `cmake --build --preset=presetName`,
    or `ctest --preset=presetName`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过调用 `cmake --preset=presetName`、`cmake --build --preset=presetName` 或 `ctest
    --preset=presetName` 来完成。
- en: There are configure, build, package, test, and workflow presets. Build, test,
    and package presets depend on a configure preset to determine the `build` directory.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在配置、构建、打包、测试和工作流预设。构建、测试和打包预设依赖于配置预设来确定 `build` 目录。
- en: A configure preset should define a name, the generator, and the build directory
    to be used.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置预设应定义名称、生成器和要使用的构建目录。
- en: The first preset to set a value takes precedence.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个设置值的预设具有优先权。
- en: This can be done by either using the native support of an editor for build containers,
    running the editor from within the container, or starting the container each time
    to invoke single commands inside.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过使用编辑器对构建容器的本地支持、从容器内运行编辑器，或者每次启动容器以在其中调用单个命令来完成。
- en: They define the system name, the location of the sysroot, the compilers to use,
    and how the `find_` commands behave.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们定义了系统名称、sysroot的位置、要使用的编译器以及`find_`命令的行为方式。
