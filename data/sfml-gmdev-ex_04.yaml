- en: Chapter 4. Grab That Joystick – Input and Event Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 捕获摇杆 – 输入和事件管理
- en: 'Arguably, the most important aspect of any game ever made is actually being
    able to play it. Regardless of the purpose of input, ranging from simply hitting
    keys to navigating through menus to controlling when your character jumps and
    which direction he or she walks to, the lack of an application presenting a way
    for you to interact with it might as well leave you with a very fancy screensaver.
    We have very briefly looked at the primitive way of grabbing and using the keyboard
    input, however our motivation for this chapter is quite different than simply
    being content with a large nest of if/else statements that handle every single
    key being pressed. Instead, we want to look at a more robust way of handling not
    just the keyboard, but also the mouse and any events that happen between the frames,
    along with adding potential for processing input of additional peripherals, such
    as joysticks. With that in mind, let''s take a look at what we will be covering
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，任何游戏最重要的方面实际上就是能够玩它。无论输入的目的如何，从简单地按键到浏览菜单，再到控制角色何时跳跃以及他或她走向哪个方向，如果没有一个应用程序提供一种让你与之交互的方式，那么你可能会得到一个非常花哨的屏保。我们非常简要地查看了一下获取和使用键盘输入的原始方法，然而我们本章的动机与仅仅满足于处理每个按键的庞大
    if/else 语句集合是截然不同的。相反，我们想要查看一种更健壮的方法来处理不仅仅是键盘，还包括鼠标和帧之间发生的事件，以及添加处理其他外围设备输入的可能性，例如摇杆。考虑到这一点，让我们看看本章我们将要涵盖的内容：
- en: Basic means of checking the states of keyboard and mouse buttons
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查键盘和鼠标按钮状态的基本方法
- en: Understanding and processing different types of events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和处理不同类型的事件
- en: Understanding and utilizing callbacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和利用回调
- en: Designing and implementing an event manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现事件管理器
- en: Let's not sit still like the character of your game without input and get on
    coding!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要像你的游戏角色在没有输入的情况下一样静止不动，开始编码吧！
- en: Retrieving peripheral input
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取外围输入
- en: 'A few of the previous chapters have already touched on this subject of retrieving
    peripheral output a little bit, and, ironically enough, the entire scope of the
    class was covered. Just to recap, `sf::Keyboard` is a class that provides a single
    static method `isKeyPressed(sf::Keyboard::Key)` to determine the real-time state
    of a certain keyboard key, which gets passed in as an argument to the method,
    represented by the `sf::Keyboard::Key` enumeration table. Because this method
    is static, `sf::Keyboard` doesn''t need to be instantiated and can be used as
    follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 几个之前的章节已经稍微触及了检索外围输出的主题，并且讽刺的是，整个类的范围都被涵盖了。只是为了回顾一下，`sf::Keyboard` 是一个提供单个静态方法
    `isKeyPressed(sf::Keyboard::Key)` 的类，用于确定某个键盘键的实时状态，该方法通过 `sf::Keyboard::Key`
    枚举表传递作为参数。因为这个方法是静态的，所以 `sf::Keyboard` 不需要实例化，可以使用如下方式：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the way we checked for input in the previous chapters, however, it does
    lend itself to quite a bit of a mess of `if`/`else` statements if we want to check
    for more keystrokes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前章节中检查输入的方法，然而，如果我们想要检查更多的按键，这会导致大量的 `if`/`else` 语句。
- en: Checking for mouse input
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查鼠标输入
- en: 'Predictably enough, SFML also provides a class similar to `sf::Keyboard` with
    the same idea of obtaining real-time status of a mouse: `sf::Mouse`. Much like
    its partner in crime, the keyboard, it provides a way to check for the mouse buttons
    being pressed, as shown next:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预计之下，SFML 也提供了一个类似于 `sf::Keyboard` 的类，具有获取鼠标实时状态的同一种想法：`sf::Mouse`。与它的犯罪伙伴键盘类似，它提供了一种检查鼠标按钮是否被按下的方法，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `sf::Mouse` class provides its own enumeration of possible buttons on any
    given mice, of which we have a grand total of five:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Mouse` 类提供了任何给定鼠标上可能按钮的枚举，其中我们总共有五个：'
- en: '| `sf::Mouse::Left` | The left mouse button |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `sf::Mouse::Left` | 左键鼠标按钮 |'
- en: '| `sf::Mouse::Right` | The right mouse button |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `sf::Mouse::Right` | 右键鼠标按钮 |'
- en: '| `sf::Mouse::Middle` | Mouse wheel being clicked |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `sf::Mouse::Middle` | 鼠标滚轮被点击 |'
- en: '| `sf::Mouse::XButton1` | First extra mouse button |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `sf::Mouse::XButton1` | 第一个额外鼠标按钮 |'
- en: '| `sf::Mouse::XButton2` | Second extra mouse button |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `sf::Mouse::XButton2` | 第二个额外鼠标按钮 |'
- en: 'In addition to that, the `sf::Mouse` class provides a way to get and set the
    current mouse position:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`sf::Mouse` 类提供了一种获取和设置当前鼠标位置的方法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Both these methods have an overloaded version that takes in a reference to
    a window in order to determine whether to look at the mouse coordinates relative
    to the window or relative to the desktop. Consider the following illustration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有一个重载版本，它接受一个窗口的引用，以确定是查看相对于窗口的鼠标坐标还是相对于桌面的鼠标坐标。考虑以下插图：
- en: '![Checking for mouse input](img/4284_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![检查鼠标输入](img/4284_04_01.jpg)'
- en: 'If the reference to a window isn''t provided, like on line #1 of the previous
    example, the mouse position that gets returned is the distance from the desktop
    origin to the point the mouse is at. If, however, the reference to a window is
    provided, the position is simply the distance between the window origin and the
    mouse location. In other words, the mouse position in the example #2 is relative
    to the window. The same logic is true for lines #3 and #4, except the position
    of the mouse gets set to the provided int vector argument.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供窗口的引用，就像上一个示例中的第1行，返回的鼠标位置是桌面原点到鼠标所在点的距离。然而，如果提供了窗口的引用，位置就是窗口原点到鼠标位置的距离。换句话说，示例#2中的鼠标位置是相对于窗口的。同样的逻辑也适用于第3行和第4行，除了鼠标位置被设置为提供的int向量参数。
- en: Plug in your controller
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入你的控制器
- en: Yes, as the title states, SFML supports input not only from your keyboard and
    mouse, but also from additional peripherals that you may have hooked up to your
    computer. By utilizing the class `sf::Joystick`, which only contains static methods,
    just like the previous two classes, it is possible to check if a controller is
    connected, check for its button states, and even determine the positions along
    certain axes, if the controller supports that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，正如标题所述，SFML不仅支持来自键盘和鼠标的输入，还支持来自连接到计算机的附加外设的输入。通过利用类`sf::Joystick`，它只包含静态方法，就像前两个类一样，可以检查控制器是否连接，检查其按钮状态，甚至确定控制器是否支持某些轴的位置。
- en: 'SFML supports up to eight different controllers being connected at the same
    time, which are identified by a numerical index in the range of [0;7]. Because
    of that, every method that `sf::Joystick` provides has to have at least one argument,
    which is the controller ID. First, let''s take a look at a way to determine if
    a controller is connected:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SFML支持同时连接多达八个不同的控制器，这些控制器通过[0;7]范围内的数值索引来识别。因此，`sf::Joystick`提供的每个方法都必须至少有一个参数，即控制器ID。首先，让我们看看确定控制器是否连接的方法：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we have a controller with an ID of 0, we can check how many buttons it actually
    supports, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个ID为0的控制器，我们可以检查它实际支持多少个按钮，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because there is no other way to abstractly define the buttons for every controller
    on the planet, they''re simply referred to by numeric indices between 0 and 31\.
    Checking for a button push can be done by calling the `isButtonPressed()` method,
    as shown next:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有其他方法可以抽象地定义地球上每个控制器的按钮，所以它们简单地通过0到31之间的数字索引来引用。可以通过调用`isButtonPressed()`方法来检查按钮是否被按下，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to check if a controller supports a specific axis, we can use the
    `hasAxis()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一个控制器是否支持特定的轴，我们可以使用`hasAxis()`方法：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `sf::Joystick::Axis` enumeration encapsulates all the possible axes that
    a controller could support, so one can check for that as shown in the preceding
    code. Assuming the controller supports it, obtaining its current position along
    an axis can be done as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Joystick::Axis`枚举封装了一个控制器可能支持的所有可能的轴，因此可以像前面代码中那样进行检查。假设控制器支持它，可以通过以下方式获取其沿轴的当前位置：'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding methods will return the current position of the X and Y axes on
    the controller 0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法将返回控制器0上X和Y轴的当前位置。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the `sf::Joystick` states are updated when checking for events, it might
    present some problems when using any of these methods before the events have had
    a chance to be polled. If that's the case, it is best to manually call the `sf::Joystick:Update()`
    method in order to make sure you have the latest state of your peripherals.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在检查事件时`sf::Joystick`状态会被更新，所以在事件被轮询之前使用这些方法可能会出现一些问题。如果出现这种情况，最好手动调用`sf::Joystick:Update()`方法，以确保你拥有最新的外设状态。
- en: Understanding the sf::Event
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`sf::Event`
- en: Once again, `sf::Event` is something we briefly touched on, however, it's imperative
    to expand on it and understand it better before proceeding, if we want to build
    a system that can seamlessly handle all types of events without any hiccups. First,
    let's reiterate what an event is. `sf::Event` is a union, which in C++ terms means
    that it's a special class which can hold only one of its non-static data members
    at a time, of which it has several, such as `KeyEvent`, which holds the information
    about a keyboard event, `SizeEvent`, which holds information about the size of
    our window that got resized, and many others. Because of this nature of `sf::Event`,
    it can be a trap for newcomers if they handle the event in a wrong way, such as
    accessing the `KeyEvent` struct inside `sf::Event`, when that is not the active
    data member. Since all the members of a union share the *same memory space*, this
    results in undefined behavior and will crash your application, unless you know
    what you're doing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`sf::Event` 是我们简要提到过的东西，然而，如果我们想要构建一个可以无缝处理所有类型事件而没有任何问题的系统，那么在继续之前，我们必须扩展并更好地理解它。首先，让我们重申一下什么是事件。`sf::Event`
    是一个联合体，在 C++ 术语中意味着它是一个特殊的类，它一次只能持有其非静态数据成员中的一个，它有几个这样的成员，例如 `KeyEvent`，它包含有关键盘事件的信息，`SizeEvent`，它包含有关我们窗口大小的信息，以及其他许多事件。由于
    `sf::Event` 的这种性质，如果新手以错误的方式处理事件，例如在 `sf::Event` 中访问 `KeyEvent` 结构，而此时它不是活动的数据成员，那么这可能会成为一个陷阱。由于联合体的所有成员共享相同的内存空间，这会导致未定义的行为，并可能导致你的应用程序崩溃，除非你知道你在做什么。
- en: 'Let''s take a look at the most basic way of processing events:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理事件最基本的方法：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nothing we haven't seen before, although it's important we fill in the blanks
    of what exactly is going on. First, the `sf::Event` instance named `event` gets
    filled out by the `pollEvent()` method. Based on its type, it will choose one
    of the structures in the union to be the active one to carry the data relevant
    to the event. Afterwards, we can check for the type of the event, which is defined
    by the `sf::Event::Type` enumeration table and make sure we're using the correct
    data member to obtain the information we need. As mentioned before, trying to
    access `event.key.code` if the event type is `sf::Event::Closed`, for example,
    would result in an undefined behavior.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到过的新东西，尽管了解确切发生的事情是很重要的。首先，名为 `event` 的 `sf::Event` 实例是通过 `pollEvent()`
    方法填充的。根据其类型，它将选择联合体中的一个结构作为活动结构来携带与事件相关的数据。之后，我们可以检查事件的类型，这是由 `sf::Event::Type`
    枚举表定义的，并确保我们使用正确的数据成员来获取所需的信息。如前所述，如果事件类型是 `sf::Event::Closed`，尝试访问 `event.key.code`
    将会导致未定义的行为。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, using the `sf::Event::KeyPressed` event for something like real-time
    character movement is a bad idea. This event gets dispatched only once before
    a small delay is applied and then it gets dispatched again. Think of a document
    editor here. When you press down on a key and hold it, at first it only shows
    a single character before it writes more. This is exactly the same way this event
    works. Using it for any action that needs to be continuous as long as the key
    is being held down is not even close to optimal and should be replaced with `sf::Keyboard::isKeyPressed()`
    in order to check the actual state of the key. The same idea applies to the mouse
    and controller input. Using these events is ideal for things that only need to
    happen once per keystroke, but not much else.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用 `sf::Event::KeyPressed` 事件来处理类似实时角色移动的操作是一个糟糕的想法。这个事件在应用一小段时间延迟之前只会被分发一次，然后再次分发。想象一下文档编辑器。当你按下并保持一个键时，最初它只会显示一个字符，然后才会写入更多内容。这个事件的工作方式与此完全相同。将其用于任何需要持续按下键的动作，甚至都不接近最佳方案，并且应该用
    `sf::Keyboard::isKeyPressed()` 来替换，以便检查键的实际状态。同样的想法也适用于鼠标和控制器输入。使用这些事件对于只需要在每次按键时发生一次的事情是理想的，但除此之外并不多。
- en: While this approach is manageable in cases of small projects, pretty much the
    same as the input example was before, it can get out of hand quickly on a larger
    scale. Let's face it, handling all the events, keystrokes, and states of every
    input device the way we did in the previous project is a nightmare. Still not
    convinced? Imagine having an application where you want to check for multiple
    keys being pressed at the same time and call some function when they are. Not
    too bad? Well, let's include events in that scenario. You want to check for two
    keys being pressed and a certain event taking place at the same time, in order
    to call a function. That adds another layer of complexity, but nothing you can't
    handle, right? Throwing in some Boolean flags in there to keep track of the event
    states or maybe the keystrokes shouldn't be too hard.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在小项目中是可管理的，与之前的输入示例几乎相同，但在更大规模上可能会迅速失控。让我们面对现实，以我们之前项目中的方式处理所有事件、按键和每个输入设备的所有状态，那是一个噩梦。仍然不相信？想象一下，有一个应用程序，你想要检查同时按下多个键，并在它们同时按下时调用某个函数。这不好吗？好吧，让我们将事件纳入这个场景。你想要检查同时按下两个键和同时发生某个事件，以便调用一个函数。这增加了另一层复杂性，但你完全能够处理，对吧？在其中加入一些布尔标志来跟踪事件状态或按键状态可能不会太难。
- en: Some time passes and the application now needs support for loading key combinations
    from a file in order to make your approach more dynamic and customizable. You
    have a mess on your hands. You can build it, but it's going to be so awkward to
    add new functionality or expand that mountain of nonsense that you are likely
    to just throw your arms in the air and give up. Why put yourself through all of
    that when with just some effort and white-boarding you can come up with an automated
    approach that will need no flags, is flexible, can load any combination of keys
    and events from a file, and still keep your code just as neat and clean as it
    was before, if not more so? Let's solve this problem intelligently by working
    on a system that will handle all of these headaches for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间过去了，现在应用程序需要支持从文件中加载键组合，以便使你的方法更加动态和可定制。你现在手头一团糟。你可以构建它，但添加新功能或扩展那堆废话将会非常尴尬，你可能会举手放弃。为什么让自己经历所有这些，而只需一些努力和白板，你就可以想出一个自动化的方法，它不需要任何标志，是灵活的，可以从文件中加载任何键和事件的组合，并且仍然保持你的代码像以前一样整洁和干净，甚至更好？让我们通过开发一个将为我们处理所有这些烦恼的系统来智能地解决这个问题。
- en: Introducing the event manager
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍事件管理器
- en: 'Figuring out what we want from our application is the first and the most crucial
    part of the design process. Sometimes it''s difficult to cover all your bases,
    but forgetting about a feature that might alter the way all the code is structured
    and trying to implement it later can wreak some serious havoc on all the work
    you put into your software. Having said that, let''s make a list of what features
    we want our event manager to have:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们想要从我们的应用程序中获得什么，是设计过程中的第一步也是最关键的部分。有时很难覆盖所有的基础，但忘记一个可能改变所有代码结构的功能，然后在以后尝试实现它，可能会对你的软件投入的所有工作造成严重破坏。话虽如此，让我们列出一个我们希望事件管理器拥有的功能列表：
- en: The ability to couple any mix of keys, buttons, or events (from now on referred
    to as bindings) with desired functionality identified by a string
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将任何组合的键、按钮或事件（从现在起称为绑定）与通过字符串标识的所需功能相耦合
- en: Binding of the said functionalities to methods that get called if all the conditions
    (such as a key being pressed, the left mouse button being clicked, or the window
    losing focus, for example) for the binding are satisfied
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些功能绑定到当所有条件（例如按键被按下、左鼠标按钮被点击或窗口失去焦点等）满足时会被调用的方法
- en: A way through which the event manager can deal with actual SFML events being
    polled
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件管理器处理实际被轮询的SFML事件的方式
- en: Loading the bindings from a configuration file
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置文件中加载绑定
- en: 'We have our specifications, now let''s start designing! We''ll be using the
    `EventManager.h` file to include all the little bits and pieces that make this
    possible on top of having the definition of the class. The first thing that we
    need to define is all the types of events we''ll be dealing with. This can be
    extended later on, but as this will more than suit our purposes for now, we don''t
    need to worry about that just yet. Let''s write the enumeration table:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了规格说明，现在让我们开始设计！我们将使用`EventManager.h`文件来包含所有使这成为可能的小部件，同时还有类的定义。我们需要定义的第一件事是我们将要处理的所有事件类型。这可以在以后扩展，但鉴于这现在将完全满足我们的目的，我们暂时不必担心这一点。让我们编写枚举表：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The majority of these are actual events; however, note the last row before the
    enumeration is terminated. We're setting up our own event, called `Keyboard` to
    the value of `sf::Event::Count + 1`. Because all the enumerations are essentially
    keywords pointing to integer values, the last row prevents any kind of identifier
    clashing and makes sure that anything added past this point is higher than the
    absolute maximum `sf::Event::EventType` enumeration value. As long as anything
    added before the last row is a valid event type, there should be no clashes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些都是实际事件；然而，请注意在列举结束前的最后一行。我们正在设置自己的事件，称为`Keyboard`，其值为`sf::Event::Count
    + 1`。因为所有的枚举本质上都是指向整数值的关键字，所以最后一行防止了任何类型的标识符冲突，并确保在此之后添加的任何内容都高于绝对最大`sf::Event::EventType`枚举值。只要在最后一行之前添加的内容是有效的事件类型，就不应该有冲突。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sf::Event` enumeration values can be different, depending on which version
    of SFML you are using!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Event`枚举值可能因你使用的SFML版本不同而不同！'
- en: 'Next, let''s make it possible to store these groups of events for each binding.
    We know that in order to bind to a key, we need both the event type and the code
    for the key that we''re interested in. Some events we''ll be working with only
    need to have a type stored, in which cases we can simply store an integer value
    of 0 with the type. Knowing that, let''s define a new structure that will help
    us store this information:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使能够为每个绑定存储这些事件组成为可能。我们知道，为了绑定到一个键，我们需要事件类型和我们感兴趣的键的代码。我们将处理的一些事件只需要存储类型，在这种情况下，我们可以简单地存储一个与类型相关的0整数值。了解这一点后，让我们定义一个新的结构，它将帮助我们存储这些信息：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to leave room for expansions, we''re already using a **union** to
    store the event code. Next, we can set up the data type that we''re going to be
    using to hold the event information:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了留出扩展的空间，我们已经在使用**联合体**来存储事件代码。接下来，我们可以设置我们将要使用来保存事件信息的数据类型：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we''re going to need to share the event information with the code that
    uses this class, now is as good a time as any to set up a data type that will
    help us do that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要与使用此类的代码共享事件信息，现在是设置一个有助于我们做到这一点的数据类型的好时机：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it''s time to design the binding structure, which is going to hold all
    the event information. Seems quite simple, so let''s implement it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候设计绑定结构了，它将保存所有的事件信息。看起来相当简单，所以让我们来实现它：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The constructor takes the name of the action we want to bind the events to and
    uses the initializer list to set up the class data members. We also have a `BindEvent()`
    method, which simply takes in an event type and an event information structure
    in order to add it to the event vector. One additional data member that we haven't
    mentioned before is the integer with the name `c`. As the comment suggests, this
    keeps track of how many events are actually taking place, which will be useful
    later on in order to determine if all the keys and events in the binding are "on".
    Lastly, this is the structure where the event detail data member that gets shared
    around resides.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受我们想要绑定事件的动作名称，并使用初始化列表来设置类的数据成员。我们还有一个`BindEvent()`方法，它简单地接受一个事件类型和一个事件信息结构，以便将其添加到事件向量中。我们之前还没有提到的一个额外数据成员是名为`c`的整数。正如注释所暗示的，它跟踪实际发生的事件数量，这将在稍后确定绑定中的所有键和事件是否“开启”时很有用。最后，这是事件详细数据成员共享的结构。
- en: 'These bindings will also have to be stored somehow, so let''s define the data
    type for the container that will take care of it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定也必须以某种方式存储，所以让我们定义一个数据类型，用于容纳负责这一点的容器：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `std::unordered_map` for our bindings guarantees that there will only
    be one binding per action, since it's an associative container and the action
    name string is the key for that container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`作为我们的绑定保证了每个动作只有一个绑定，因为它是一个关联容器，动作名称字符串是该容器的键。
- en: We're doing great so far, however, without a way to actually tie these actions
    to valid methods that will get called, this system is fairly useless. Let's talk
    about how we could implement this. In the world of computer science, every now
    and then you've probably heard the term "callback" being thrown around. In simplest
    terms, a callback is some chunk of code that gets passed as an argument to another
    piece of code, which *will* execute it at a convenient time. In the case of our
    event manager, the convenient time is whenever all the events that are bound to
    a specific action are happening, and the callback is a method that represents
    the action being performed. Let's say, we want the character to jump when the
    spacebar is hit. We would create a binding with a name "`Jump`", which is our
    action name, and add a single event of type `KeyDown` and code `sf::Keyboard::Space`
    to it. For argument sake, let's say the character has a method called `Jump()`.
    That's our callback. We want to bind that method to the name "`Jump`" and have
    the event manager call the character's `Jump()` method when the space key is pressed.
    That, in a nutshell, is how we're going to be handling input with this new system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们进展顺利，然而，如果没有一种方法将这些操作与将被调用的有效方法实际联系起来，这个系统就相当无用。让我们来谈谈如何实现这一点。在计算机科学的世界里，你可能时不时地会听到“回调”这个术语被提及。简单来说，回调就是一些代码块，作为参数传递给其他代码，它将在一个方便的时间执行。在我们的事件管理器中，方便的时间是所有绑定到特定动作的事件发生时，而回调是一个表示正在执行的动作的方法。比如说，我们希望在按下空格键时让角色跳跃。我们会创建一个名为"`Jump`"的绑定，这是我们的动作名称，并向它添加一个类型为`KeyDown`和代码`sf::Keyboard::Space`的单个事件。为了举例，假设角色有一个名为`Jump()`的方法。这就是我们的回调。我们希望将这个方法绑定到名称"`Jump`"上，并让事件管理器在按下空格键时调用角色的`Jump()`方法。简而言之，这就是我们将如何使用这个新系统处理输入的。
- en: 'By now, your C++ background is probably driving you towards the term "function
    pointers". While that''s not necessarily a bad option, it can get a little messy
    if you''re quite new to the scene. The main problem with that approach is the
    scenario of adding a method of a class as a callback. Pointers to the class members
    aren''t exactly the same as regular functions, unless it''s a static method. Following
    is a basic definition of a member function pointer:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你的C++背景可能让你想到了“函数指针”这个术语。虽然这并不一定是一个坏选择，但如果你对这个领域不是很熟悉，可能会有些混乱。那种方法的主要问题是添加一个类的方法作为回调的场景。指向类成员的指针并不完全等同于常规函数，除非它是静态方法。以下是一个成员函数指针的基本定义：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Already this shows a few major limitations. For one, we can only have pointers
    to methods of the class "SomeClass". Secondly, without having an instance to the
    class that has the method we''re pointing to, it''s quite useless. A thought has
    probably popped into your mind of just storing the instance together with the
    function pointer in some callback structure. Let''s take a look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 已经显示出了一些主要限制。首先，我们只能有指向“SomeClass”类的方法的指针。其次，如果没有指向我们想要指向的方法的类的实例，这相当无用。你可能已经想到了一个想法，就是将实例和函数指针一起存储在某种回调结构中。让我们看看：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s a little better. At least we can call the method now, although we''re
    still limited to only one class. We could just wrap every other class method call
    in the methods of the "SomeClass" class, but that''s tedious and more importantly,
    it''s a bad practice. Maybe now you''re thinking that some template magic might
    solve this problem. While it is possible, you have to also take into account the
    compatibility and the mess that it might create. Consider the most minimum amount
    of effort this could possibly take:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点好。至少我们现在可以调用方法了，尽管我们仍然只限于一个类。我们可以在“SomeClass”类的方法中包装其他类的每个方法调用，但这很繁琐，更重要的是，这是一种不好的做法。现在你可能正在想，一些模板魔法可能可以解决这个问题。虽然这是可能的，但你还得考虑兼容性和它可能造成的混乱。考虑一下这需要的最小工作量：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This by itself doesn''t solve anything, but instead it only brings more problems.
    For one, you now have to define that template in your event manager class, which
    is problematic because we need a container for all these callbacks and that means
    having to template the entire event manager class, which locks it down to one
    class type. We''re right back to where we started. Using typedef would be a clever
    idea, except that it''s not supported in most of the Visual Studio compilers in
    this form:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身并不能解决问题，反而只会带来更多的问题。首先，你现在必须在事件管理器类中定义这个模板，这很成问题，因为我们需要一个容器来存放所有这些回调函数，这意味着我们必须模板化整个事件管理器类，这将其锁定为一种类类型。我们又回到了起点。使用typedef可能是一个聪明的想法，但是大多数Visual
    Studio编译器不支持这种形式的typedef：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are some hackish workarounds for non C++11 compilers, like wrapping `typedef`
    in `struct` after defining the template. However, that doesn't solve our problem
    either. There have been instances of the Visual Studio 2010 compiler even crashing
    when using "templated" member function pointer type definitions. This is quite
    a mess, and at this point you're probably thinking about simply going back to
    regular function pointers and wrapping every single member function call in a
    different function. Fear not, C++11 introduces a much better approach than that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非C++11编译器，有一些非常规的解决方案，比如在定义模板后，将`typedef`包裹在`struct`中。然而，这并不能解决问题。甚至有Visual
    Studio 2010编译器在使用“模板化”成员函数指针类型定义时崩溃的实例。这相当混乱，到这一点你可能正在考虑简单地回到常规函数指针，并将每个成员函数调用包裹在不同的函数中。不用担心，C++11引入了一个比那更好的方法。
- en: Standard function wrapper
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准函数包装器
- en: 'The C++ utilities library provides us with just what we need in order to solve
    this pickle elegantly: `std::function` and `std::bind`. The `std::function` type
    is a general purpose polymorphic function wrapper. Amongst many other things it
    supports, it can store the member function pointers and call them. Let''s take
    a look at a minimal example of using it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: C++工具库为我们提供了解决这个难题所需的一切：`std::function`和`std::bind`。`std::function`类型是一个通用多态函数包装器。在它支持的许多其他功能中，它可以存储成员函数指针并调用它们。让我们看看使用它的最小示例：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, we''re instantiating a function wrapper called "`foo`", which
    holds a function with the signature `void(void)`. On the right side of the equals
    sign, we use `std::bind` to bind the member function "`method1`" of the class
    "`Bar`" to the `foo` object. The second argument, because this is a member function
    pointer, is the instance of the class that is having its method registered as
    a callback. In this case, it has to be an instance of the `Bar` class, so let''s
    imagine this line of code is written somewhere in the implementation of it and
    just pass in "`this`". Now our `foo` object is bound to the method `method1` of
    class `Bar`. Because `std::function` overloads the parenthesis operator, calling
    it is as easy as this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实例化了一个名为"`foo`"的函数包装器，它包含一个签名为`void(void)`的函数。在等号的右侧，我们使用`std::bind`将类"`Bar`"的成员函数"`method1`"绑定到`foo`对象上。第二个参数，因为这是一个成员函数指针，是具有其方法注册为回调的类的实例。在这种情况下，它必须是`Bar`类的实例，所以让我们想象这一行代码是在它的实现中写下的，并且只传入"`this`"。现在我们的`foo`对象被绑定到了`Bar`类的`method1`方法上。因为`std::function`重载了括号操作符，所以调用它就像这样：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can finally define the type of the callback container:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以最终定义回调容器类型：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once again, using `std::unordered_map` ensures that there's only one callback
    per action. This can be changed later if needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用`std::unordered_map`确保每个动作只有一个回调。如果需要，以后可以更改。
- en: Building the event manager
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建事件管理器
- en: 'At this time, we have everything we need to actually write the header of our
    event manager class. Given all the design decisions we made previously, it should
    come out looking something like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了编写事件管理器类头文件所需的一切。考虑到我们之前做出的所有设计决策，它应该看起来像以下这样：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can gather from looking at the class definition, we still needed to use
    a templated member function pointer argument for the `AddCallback()` method. The
    use of `std::function`, however, isolates this to a single method, meaning we
    don't have to template the entire class, and that is an improvement. After the
    pointers to the method and the instance of the class, as well as a single placeholder
    that will be replaced by an argument in the future, are bound to a temporary function,
    we insert it into the callback container. Because of the way the compiler deals
    with the templated classes, we need to implement our template `AddCallback()`
    method in the header file, instead of the .cpp file. Just for the sake of consistency,
    and because it's a really simple method, we define `RemoveCallback()` in the header
    file too.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看类定义中可以看出，我们仍然需要为`AddCallback()`方法使用模板成员函数指针参数。然而，`std::function`的使用将此隔离到单个方法中，这意味着我们不需要对整个类进行模板化，这是一个改进。在将方法指针和类的实例以及一个将来将被参数替换的单个占位符绑定到一个临时函数后，我们将其插入到回调容器中。由于编译器处理模板类的方式，我们需要在头文件中实现我们的模板`AddCallback()`方法，而不是在.cpp文件中。只是为了保持一致性，并且因为这个方法非常简单，我们在头文件中也定义了`RemoveCallback()`。
- en: 'The other thing worthy of pointing out about the header is the implementation
    of the method that will be used to obtain the position of the mouse: `GetMousePos()`.
    It takes a pointer to a type of `sf::RenderWindow`, in case we want the coordinates
    returned to be relative to a specific window. The same window can also have or
    lose focus, so a flag `m_hasFocus` is kept around to keep track of that.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标题的另一件值得指出的事情是用于获取鼠标位置的方法实现：`GetMousePos()`。它接受一个指向`sf::RenderWindow`类型的指针，以防我们希望返回的坐标相对于特定窗口。同一个窗口也可以获得或失去焦点，因此有一个标志`m_hasFocus`被保留以跟踪这一点。
- en: Implementing the event manager
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现事件管理器
- en: 'Let''s get started with actually implementing all the event manager class methods,
    starting, as always, with the constructor and destructor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实际实现所有事件管理器类方法，从构造函数和析构函数开始：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The constructor's job in this case is really simple. All it has to do is call
    a private method `LoadBindings()`, which is used to load the information about
    our bindings from a file. We will cover that shortly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构造函数的工作非常简单。它只需要调用一个私有方法`LoadBindings()`，该方法用于从文件中加载有关我们绑定的信息。我们将在稍后介绍这一点。
- en: The destructor's job is also fairly run-of-the-mill for this type of class.
    If you recall, we store the bindings on the heap, so this dynamic memory has to
    be de-allocated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类，析构函数的工作也相当普通。如果你还记得，我们在堆上存储绑定，因此必须释放这块动态内存。
- en: 'Let''s take a gander at the `AddBinding` method implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AddBinding`方法实现：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, it takes in a pointer to a binding. It then checks if the binding
    container already has a binding with the same name. If it does, the method returns
    `false`, which is useful for error-checking. If there are no name clashes, the
    new binding gets inserted into the container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它接受一个指向绑定的指针。然后它检查绑定容器是否已经有一个具有相同名称的绑定。如果有，该方法返回`false`，这对于错误检查很有用。如果没有名称冲突，新的绑定将被插入到容器中。
- en: 'We have a way to add the bindings, but what about removing them? That''s where
    the `RemoveBinding` method comes in:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有添加绑定的一种方法，但关于移除它们怎么办？这就是`RemoveBinding`方法的作用所在：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes in a string argument and searches the container for a match to store
    into an iterator. If a match is found, it first frees up the memory by deleting
    the second element in the key-value pair, which is the dynamic memory allocated
    for the binding object, and then erases the entry from the container shortly before
    returning `true` for success. Easy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个字符串参数，并在容器中搜索匹配项以存储到迭代器中。如果找到匹配项，它首先通过删除键值对中的第二个元素（即为绑定对象分配的动态内存）来释放内存，然后在实际返回`true`表示成功之前从容器中删除条目。很简单。
- en: 'As mentioned in the specifications for designing this class, we need a way
    to process the SFML events that are being polled in each iteration in order to
    look at them and see if there''s anything in there we''re interested in. This
    is where `HandleEvent` comes in:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如在设计此类规格说明中提到的，我们需要一种方法来处理在每次迭代中轮询的SFML事件，以便查看它们并确定是否有我们感兴趣的内容。这就是`HandleEvent`的作用所在：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It takes in, appropriately enough, an argument of type `sf::Event`. This method
    then has to iterate over all the bindings and through each event inside the binding
    to check if the type of the `l_event` argument matches the type of the binding
    event that's currently being processed. If it does, we check if it's a keyboard
    event or a mouse event, because that involves further checking for the keyboard
    keys or the mouse buttons matching our desired bindings. If it is either one of
    them, the last step is to check if either the keyboard key code or the mouse button
    code, which are respectively stored in the `l_event.key` and `l_event.mouseButton`
    structs, match the code of our binding event. With that being the case, or if
    it's a different type of event that doesn't require further processing, as demonstrated
    a few lines down, we increment the member `c` of the binding instance to signify
    a match shortly after relevant event information is stored in the event details
    structure of the binding.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个类型为 `sf::Event` 的参数，这是相当合适的。然后这个方法必须遍历所有的绑定以及绑定内的每个事件，检查 `l_event` 参数的类型是否与当前正在处理的事件绑定类型匹配。如果匹配，我们检查它是否是键盘事件或鼠标事件，因为这涉及到进一步检查键盘键或鼠标按钮是否与我们的绑定匹配。如果是其中之一，最后一步是检查键盘键码或鼠标按钮码，分别存储在
    `l_event.key` 和 `l_event.mouseButton` 结构体中，是否与我们的绑定事件码匹配。如果是这种情况，或者如果它是一种不需要进一步处理的不同类型的事件，如几行代码所示，我们就在将相关事件信息存储在绑定的事件详情结构体后不久，增加绑定实例的成员
    `c` 以表示匹配。
- en: 'Lastly, for input processing, we need to have an update method, which can handle
    real-time input checking as well as the validating and resetting of the states
    of the bindings. Let''s write it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于输入处理，我们需要有一个更新方法，这个方法可以处理实时输入检查以及验证和重置绑定状态。让我们来写一下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, we iterate over all the bindings and their events. In this case,
    however, we're only interested in `Keyboard`, `Mouse,` and `Joystick`, as those
    are the only devices we can check the real-time input of. Much like before, we
    check for the type of event we're dealing with, and use the appropriate class
    to check for the input. Incrementing the `c` member of the binding class, as usual,
    is our way of registering a match.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次遍历所有的绑定及其事件。然而，在这种情况下，我们只对 `Keyboard`、`Mouse` 和 `Joystick` 感兴趣，因为这是我们唯一可以检查实时输入的设备。就像之前一样，我们检查我们处理的事件类型，并使用适当的类来检查输入。像往常一样，增加绑定类的
    `c` 成员是我们注册匹配的方式。
- en: The final step is checking if the number of events in the event container matches
    the number of events that are "on". If that's the case, we locate our callback
    in the `m_callbacks` container and invoke the `second` data member with the parenthesis
    operator, because it is an `std::function` method wrapper, in turn officially
    implementing the callbacks. To it, we pass the address of the `EventDetails` structure
    that contains all the event information. Afterwards, it's important to reset the
    active event counter `c` to `0` for the next iteration because the state of any
    of the events checked previously could've changed and they all need to be re-evaluated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是检查事件容器中的事件数量是否与“开启”的事件数量匹配。如果是这样，我们在 `m_callbacks` 容器中定位我们的回调，并使用括号操作符调用
    `second` 数据成员，因为它是一个 `std::function` 方法包装器，从而正式实现回调。我们向它传递包含所有事件信息的 `EventDetails`
    结构体的地址。之后，重要的是将活动事件计数器 `c` 重置为 `0` 以进行下一次迭代，因为之前检查的任何事件的状态都可能已经改变，它们都需要重新评估。
- en: Lastly, if you looked at the code top to bottom, you probably noticed that the
    case for controller input isn't doing anything. As a matter of fact, we don't
    even handle any events related to the controller. This is something that can be
    expanded later on and isn't vital to any of our projects. If you are eager to
    add support for joysticks and have access to one, consider it to be homework after
    this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你从头到尾看了代码，你可能已经注意到控制器输入的情况并没有做任何事情。事实上，我们甚至没有处理任何与控制器相关的事件。这是可以稍后扩展的内容，并且对我们任何项目都不是至关重要的。如果你渴望添加对游戏手柄的支持并且有机会使用一个，那么在完成本章后，将其视为作业。
- en: 'Now that we have all this functionality, why not actually read in some binding
    information from a file? Let''s take a look at the example configuration, named
    `keys.cfg`, that we will be loading in:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些功能，为什么不实际从文件中读取一些绑定信息呢？让我们看看我们将要加载的示例配置文件，名为 `keys.cfg`：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This can be formatted in any way you want, however, for the sake of simplicity,
    the layout for it will remain pretty basic here. Each line is a new binding. It
    starts with the binding name, which is followed by the numerical representation
    of the event type enumeration and the code for the event separated by a colon.
    Every different event key:value pair is separated by spaces, as well as the binding
    name and the beginning of the events. Let''s read this in:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以按照您想要的任何方式格式化，然而，为了简单起见，这里的布局将保持相当基础。每一行都是一个新绑定。它以绑定名称开始，后面跟着事件类型的数值表示和事件代码，由冒号分隔。每个不同的事件键：值对由空格分隔，以及绑定名称和事件的开始。让我们读取这个：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start by attempting to open the `keys.cfg` file. If it fails, this method
    spits out a console message notifying us about it. Next, we proceed into a `while`
    loop in order to read every single line in the file. We define an `std::stringstream`
    object, which allows us to nicely "stream" our string piece by piece, using the
    `>>` operator. It uses the default delimiter of a space, which is why we made
    that decision for the configuration file. After obtaining the name of our binding,
    we create a new `Binding` instance and pass the name in the constructor. Afterwards,
    by proceeding into a `while` loop and using `!keystream.eof()` as an argument,
    we make sure that it loops until the `std::stringstream` object reaches the end
    of the line it was reading. This loop runs once for each key:value pair, once
    again thanks to `std::stringstream` and its overloaded `>>` operator using whitespaces
    as delimiters by default.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试打开`keys.cfg`文件。如果失败，此方法会输出一个控制台消息通知我们。接下来，我们进入一个`while`循环，以便读取文件中的每一行。我们定义一个`std::stringstream`对象，它允许我们使用`>>`运算符逐个“流”我们的字符串。它使用默认的分隔符，即空格，这就是我们为配置文件做出那个决定的原因。在获取我们的绑定名称后，我们创建一个新的`Binding`实例，并在构造函数中传递该名称。之后，通过进入`while`循环并使用`!keystream.eof()`作为参数，我们确保它循环直到`std::stringstream`对象达到它正在读取的行的末尾。这个循环对每个键：值对运行一次，再次感谢`std::stringstream`及其默认使用空格作为分隔符的重载`>>`运算符。
- en: After streaming in the type and code of an event, we have to make sure that
    we convert it from a string into two integer values, which are then stored in
    their respective local variables. It takes in parts of the string that got read
    in earlier in order to separate the key:value pair by splitting it at the delimiter
    character, which in this case was defined at the very top of this method as "`:`".
    If that character is not found within the string, the binding instance gets deleted
    and the line gets skipped, because it is most likely not formatted properly. If
    that's not the case, then the event gets successfully bound and the code moves
    on to the next pair.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在流式传输事件类型和代码后，我们必须确保将其从字符串转换为两个整数值，然后分别存储在各自的局部变量中。它读取之前读取的字符串的一部分，以便通过分隔符字符将键：值对分开，在这个例子中，该分隔符字符是在此方法的顶部定义的，即"`:`"。如果该字符在字符串中未找到，则绑定实例将被删除，该行将被跳过，因为它很可能格式不正确。如果不是这种情况，则事件将成功绑定，代码继续到下一对。
- en: Once all the values are read in and the end of the line is reached, we attempt
    to add the binding to the event manager. It is done in the if-statement in order
    to catch the error we talked about earlier relating to binding name clashes. If
    there is a clash, the binding instance gets deleted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了所有值并达到行尾，我们尝试将绑定添加到事件管理器中。这是在if语句中完成的，以便捕获我们之前提到的与绑定名称冲突的错误。如果有冲突，绑定实例将被删除。
- en: As you probably already know, it's also important to close the file after using
    it, so that's the last thing we do before this method concludes. With that done,
    our event manager is finally complete and it's time to actually put it to work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，在使用文件后关闭它也同样重要，因此这是此方法结束前我们做的最后一件事。完成这些后，我们的事件管理器终于完成了，现在是时候真正投入使用。
- en: Integrating the Event Manager class
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成事件管理器类
- en: 'Because the event manager needs to check all the events that get processed,
    it makes sense to keep it in our `Window` class, where we actually do the event
    polling. After all, the events that we''re processing all originate from the window
    that''s open, so it only makes sense to keep an instance of the event manager
    here. Let''s make a slight adjustment to the `Window` class by adding a data member
    to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件管理器需要检查所有被处理的事件，所以将其保留在我们的`Window`类中是有意义的，因为我们实际上在这里进行事件轮询。毕竟，我们处理的所有事件都源自打开的窗口，所以在这里保留事件管理器的一个实例是合理的。让我们通过向`Window`类中添加一个数据成员来对其进行轻微调整：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition to adding an extra method for obtaining the event manager, the
    full screen toggle method has been modified to take in the `EventDetails` structure
    as an argument. A `Close` method is also added to our `Window` class, as well
    as a flag to keep track of whether the window is in focus or not. The method for
    closing the window itself is as simple as setting a single flag to `true`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加一个额外的获取事件管理器的方法外，全屏切换方法已经被修改为接受`EventDetails`结构作为参数。我们还为我们的`Window`类添加了一个`Close`方法，以及一个标志来跟踪窗口是否处于焦点状态。关闭窗口的方法本身非常简单，只需将一个标志设置为`true`：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it''s time to adjust the `Window::Update` method and pass in all the events
    being polled to the event manager:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调整`Window::Update`方法并将所有被轮询的事件传递给事件管理器：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This ensures that every single event that ever gets dispatched in the window
    will be properly handled. It also notifies the event manager if the focus of the
    window changes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了窗口中发出的每个事件都将得到适当的处理。它还通知事件管理器窗口的焦点是否发生变化。
- en: 'Time to actually use the event manager! Let''s do that in `Window::Setup` by
    registering two callbacks to some member functions, right after creating a new
    instance of the event manager:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正使用事件管理器的时候了！让我们在`Window::Setup`中通过注册两个回调到一些成员函数来实现，在创建事件管理器的新实例之后：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's refer back to the `keys.cfg` file. We define the `Fullscreen_toggle` action
    and set up a key:value pair of 5:89, which essentially gets broken down to the
    event type of `KeyDown` (the number 5) and the code for the *F5* key on the keyboard
    (number 89). Both of these values are integer representations of the enumerations
    that we used.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`keys.cfg`文件。我们定义了`Fullscreen_toggle`操作，并设置了一个键值对5:89，这实际上被分解为事件类型`KeyDown`（数字5）和键盘上*F5*键的代码（数字89）。这两个值都是我们使用的枚举的整数表示。
- en: The other callback that gets set up is for the action `Window_close`, which
    in the configuration file is bound to 0:0\. The event type 0 corresponds to `Closed`
    in the enumeration table, and the code is irrelevant, so we just set that to 0
    as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个被设置的回调是针对`Window_close`操作的，在配置文件中它被绑定到0:0。事件类型0对应枚举表中的`Closed`，代码无关紧要，所以我们也将它设置为0。
- en: Both these actions get bound to methods of the `Window` class. Note the last
    argument in the `AddCallback` method, which is a `this` pointer referring to the
    current instance of the window. After successful compilation and launch, you should
    discover that hitting the *F5* key on your keyboard toggles the full screen mode
    of the window and clicking on the close button actually closes it. It works! Let's
    do something a little bit more fun with this now.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作都被绑定到`Window`类的函数上。注意`AddCallback`方法中的最后一个参数，它是一个指向当前窗口实例的`this`指针。在成功编译和启动后，你应该会发现按下键盘上的*F5*键可以切换窗口的全屏模式，而点击关闭按钮实际上会关闭窗口。它真的工作了！现在让我们用这个来做点更有趣的事情。
- en: Moving a sprite revisited
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视移动精灵
- en: 'Now that we have a fancy event manager, let''s test it fully by moving a sprite
    to the location of the mouse when the left shift key is held down and the left
    mouse button is pressed. Add two new data members to your `Game` class: `m_texture`
    and `m_sprite`. Set them up as discussed in the previous chapters. For our purposes,
    we''ll just be re-using the mushroom graphic from the first few chapters. Now
    add and implement a new method in your game class called `MoveSprite`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个花哨的事件管理器，让我们通过在按下左shift键并按下左鼠标按钮时将精灵移动到鼠标位置来完全测试它。在你的`Game`类中添加两个新的数据成员：`m_texture`和`m_sprite`。按照前几章的讨论来设置它们。对于我们的目的，我们只需重新使用第一、二章节中的蘑菇图形。现在在你的游戏类中添加并实现一个新的方法`MoveSprite`：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What we do here is grab the mouse position relative to the current window from
    the event manager and store it in a local integer vector called `mousepos`. We
    then set the position of our sprite to the current mouse position and print out
    a little sentence in the console window. Very basic, but it will serve nicely
    as a test. Let''s set up our callback:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是从事件管理器获取相对于当前窗口的鼠标位置，并将其存储在一个名为 `mousepos` 的局部整数向量中。然后我们将精灵的位置设置为当前鼠标位置，并在控制台窗口中打印出一个小句子。这非常基础，但将很好地作为测试。让我们设置我们的回调：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We tie the action name `Move` to the `MoveSprite` method of the `Game` class
    and pass in a pointer to the current instance, just like before. Before running
    this, let''s take a peek at the way the move action is defined in the `keys.cfg`
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动作名称 `Move` 绑定到 `Game` 类的 `MoveSprite` 方法，并传入当前实例的指针，就像之前一样。在运行之前，让我们看看 `keys.cfg`
    文件中定义的移动动作的方式：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first event type corresponds to `MButtonDown`, which is the event of the
    left mouse button being pressed down. The second event type corresponds to the
    `Keyboard` event, which checks for real-time input through the `sf::Keyboard`
    class. The number 38 is the left shift key code, corresponding to `sf::Keyboard::LShift`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事件类型对应于 `MButtonDown`，这是左鼠标按钮被按下的事件。第二个事件类型对应于 `Keyboard` 事件，它通过 `sf::Keyboard`
    类检查实时输入。数字 38 是左移位键码，对应于 `sf::Keyboard::LShift`。
- en: Upon compilation and execution of our application, we should end up with a sprite
    being rendered on the screen. If we hold the left shift key and left click anywhere
    on the screen, it will magically move to that position!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译和执行我们的应用程序后，我们应该在屏幕上渲染一个精灵。如果我们按住左移位键并在屏幕上的任何位置左击，它将神奇地移动到那个位置！
- en: '![Moving a sprite revisited](img/4284_04_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视移动精灵](img/4284_04_02.jpg)'
- en: Principles of use
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原则
- en: Knowing when to use which types of events is important even in this design.
    Let's say, for example, that you only want a callback to be called once for a
    binding that involves the left shift and the *R* key. You wouldn't define both
    the event types as `Keyboard`, because that would keep invoking the callback method
    as long as these keys are down. You also don't want to define both of them as
    `KeyDown` events, because that would mean that both of these events would have
    to be registered at the same time, which, when holding down multiple keys, is
    likely not going to happen because of the screen refresh rate. The correct way
    to use this is mixing the `Keyboard` and `KeyDown` events so that the very last
    key to be pressed is the `KeyDown` type and the rest of the keys will be `Keyboard`
    types. In our example, it means that we would have the left shift key being checked
    through the `sf::Keyboard` class, while the *R* key would default to an event
    being dispatched. That might sound odd at first, however, consider the famous
    example of the key combination *Ctrl* + *Alt* + *Del* on your computer. It works
    that way, but if you hold the keys in reverse order, it would do nothing. If we
    were implementing this functionality, we'd most likely make sure that the *Ctrl*
    and *Alt* keys are always checked through the `sf::Keyboard` class, while the
    *Del* key is registered through the event polling.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，知道何时使用哪种类型的事件同样重要。比如说，如果你只想在涉及左移位和 *R* 键的绑定中调用一次回调，你不会将这两个事件类型都定义为 `Keyboard`，因为这样只要这些键被按下，回调方法就会一直被调用。你也不想将它们都定义为
    `KeyDown` 事件，因为这意味着这两个事件必须同时注册，而在同时按下多个键的情况下，由于屏幕刷新率的原因，这种情况不太可能发生。正确使用的方法是混合使用
    `Keyboard` 和 `KeyDown` 事件，使得最后一个被按下的键是 `KeyDown` 类型，其余的键将是 `Keyboard` 类型。在我们的例子中，这意味着我们将左移位键通过
    `sf::Keyboard` 类进行检查，而 *R* 键将默认为事件分发。这听起来可能有些奇怪，然而，考虑一下你电脑上著名的 *Ctrl* + *Alt*
    + *Del* 键组合。它就是这样工作的，但如果以相反的顺序按这些键，它将不会做任何事情。如果我们正在实现这个功能，我们很可能会确保 *Ctrl* 和 *Alt*
    键总是通过 `sf::Keyboard` 类进行检查，而 *Del* 键将通过事件轮询进行注册。
- en: One last thing to note as far as the use of this class goes, is that some events
    aren't yet supported, such as the `sf::Event::TextEntered` event because additional
    information is required in order to fully utilize them, which is obtained from
    the `sf::Event` class. Proper expansion of the event manager to support these
    features will be covered in the later chapters, once we're dealing with problems
    that require the said events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个类使用的一个需要注意的最后一点是，一些事件尚未得到支持，例如`sf::Event::TextEntered`事件，因为为了完全利用它们，需要额外的信息，这些信息来自`sf::Event`类。在处理需要这些事件的问题时，将在后面的章节中介绍如何正确扩展事件管理器以支持这些功能。
- en: Common mistakes
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: One of the most common mistakes the newcomers make when it comes to SFML input
    is using certain methods of checking the user input for the wrong tasks, such
    as using the window events for real time character movement or capturing text
    input. Understanding the limitations of anything you use is the key to cultivating
    any kind of decent performance. Make sure to stick to the intended uses of all
    the different mechanisms we've discussed in order to achieve optimal results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到SFML输入时，新用户犯的最常见的错误之一是使用某些方法来检查用户输入，但这些方法并不适用于正确的任务，例如使用窗口事件进行实时字符移动或捕获文本输入。了解你所使用的一切的限制是培养任何良好性能的关键。确保坚持我们讨论过的所有不同机制的本意用途，以实现最佳结果。
- en: Another fairly common mistake people make is defining templates in the .cpp
    file instead of the header. If you are getting linking errors pertaining to a
    method that just so happens to utilize templates, such as the `EventManager::AddCallback()`
    method, make sure to move the implementation of the method and the definition
    of the template right to the header of your class, otherwise the compiler cannot
    instantiate the template and the method becomes inaccessible during the linking
    process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当常见的错误是，人们在.cpp文件中定义模板而不是在头文件中。如果你遇到了与使用模板的方法（例如`EventManager::AddCallback()`方法）相关的链接错误，确保将方法的实现和模板的定义直接移动到你的类头文件中，否则编译器无法实例化模板，方法在链接过程中将不可访问。
- en: Lastly, a rather simple yet extremely popular mistake lots of new users of SFML
    are guilty of is not knowing how to correctly obtain the mouse coordinates that
    are relative to the window. It ranges from simply using the wrong coordinates
    and experiencing weird behavior to grabbing the coordinates relative to the desktop
    as well as the position of the window and subtracting one from another to obtain
    the local mouse position. While the latter works, it's a bit excessive, especially
    since SFML already provides you with a way to do it without reinventing the wheel.
    Simply pass in a reference of your window to the `sf::Mouse::getPosition()` method.
    That's all you need.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多新用户在使用SFML时犯的一个相当简单但极其普遍的错误是不知道如何正确获取相对于窗口的鼠标坐标。这从简单地使用错误的坐标并经历奇怪的行为，到获取相对于桌面的坐标以及窗口的位置，然后从另一个坐标中减去以获得局部鼠标位置。虽然后者可行，但有点过度，尤其是考虑到SFML已经为你提供了一种无需重新发明轮子的方法。只需将你的窗口引用传递给`sf::Mouse::getPosition()`方法即可。这就是你所需要的一切。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Much like proper code organization, robust input management is one of the many
    things that can mean the difference between you happily developing an application
    and the same application drowning in the sea of other failed projects. With proper
    and flexible design comes great code reusability, so congratulations on taking
    yet another step towards building an application that will not bite the dust simply
    because it was painful to work with due to its myopic construction.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如良好的代码组织一样，健壮的输入管理是许多可以意味着你快乐地开发应用程序和应用程序在众多失败项目中淹没之间的区别之一。随着适当和灵活的设计，代码的可重用性得到了极大的提高，所以恭喜你，又迈出了构建一个不会因为其狭隘的结构而难以工作而变得一文不值的应用程序的一步。
- en: There is no design in this world that's inarguably perfect, however, with this
    chapter coming to fruition we are now yet another step closer to the goal that
    we set for ourselves at the very beginning of this experience. This goal varies
    between individuals. Maybe it has grown since we started; it may have even manifested
    itself into something completely different than it was before. None of that is
    certain to the rest of us, but it doesn't really matter. What matters is that
    we are in full control of where we take those goals, even if we have no control
    of where they take us. And while this journey towards our goals continues, and
    even as the new ones begin to emerge, we can now say that we have stronger means
    of taking control over the entire process, much like we built our own stronger
    means of taking control of our applications. So, move yourself forward to the
    next chapter and resume your journey, by learning about application states. We'll
    see you there!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个世界上没有绝对完美的设计，然而，随着本章的完成，我们现在又向我们在这次体验一开始就为自己设定的目标迈进了一步。这个目标因人而异。也许自从我们开始以来它已经有所增长；甚至可能已经变成了与之前完全不同的东西。对我们其他人来说，这些都并不确定，但这并不重要。重要的是，我们完全掌控着我们将这些目标引向何方，即使我们无法控制它们将我们带向何方。而且，随着我们朝着目标前进的旅程持续进行，甚至当新的目标开始出现时，我们现在可以说，我们有了更强的手段来掌控整个过程，就像我们建立了自己更强的手段来掌控我们的应用程序一样。所以，请继续前进到下一章，并继续你的旅程，通过了解应用程序状态。我们那里见！
