- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Making C++ Safer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 C++ 更加安全
- en: This bonus chapter will add insight into what we can do as C++ programmers to
    make the language as safe as possible in our everyday usage. We have progressed
    from basic language features to our core interest of OO programming with C++,
    to additional useful language features and libraries (exceptions, operator overloading,
    templates, and STL), to design patterns to give us a knowledge base to solve recurring
    types of OO programming problems. At every point along the way, we’ve seen that
    C++ requires extra care on our part to avoid tricky and potentially problematic
    programming situations. C++ is a language that will allow us to do anything, but
    with this power comes the need for guidelines to ensure our programming follows
    safe practices. After all, our goal is to create programs that will run successfully
    without errors and, additionally, be easy to maintain. The ability of C++ to do
    anything needs to be paired with sound practices to simply make C++ safer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录章节将深入探讨作为 C++ 程序员，我们可以如何使语言在日常使用中尽可能安全。我们已经从基本语言特性进步到我们的核心兴趣——使用 C++ 进行面向对象编程，再到额外的有用语言特性库（异常、运算符重载、模板和
    STL），以及设计模式，以提供解决重复出现的面向对象编程问题的知识库。在旅途中，我们始终看到 C++ 需要我们额外的关注，以避免棘手和可能存在问题的编程情况。C++
    是一种允许我们做任何事情的语言，但随之而来的是需要指导方针来确保我们的编程遵循安全实践。毕竟，我们的目标是创建能够成功运行且无错误的程序，并且易于维护。C++
    能够做任何事情的能力需要与良好的实践相结合，以使 C++ 更加安全。
- en: The goal of this chapter is to revisit topics that we have covered in previous
    chapters, reviewing them with an eye toward safety. We will also incorporate topics
    strongly related to ones we have seen previously. This chapter is not meant to
    cover wholly new topics or previous topics in great depth, but to provide a grouping
    of safer programming practices and the encouragement to seek further information
    on each topic as needed. Some of these topics can encompass entire chapters (or
    books) themselves!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是回顾我们在前几章中介绍过的主题，并从安全的角度进行审查。我们还将结合与之前内容紧密相关的话题。本章的目的不是全面覆盖全新的主题或深入探讨之前的话题，而是提供一组更安全的编程实践，并鼓励在需要时进一步了解每个主题。其中一些主题本身可以涵盖整个章节（或书籍）！
- en: 'In this bonus chapter, we will cover selected popular programming conventions
    to meet our safety challenge:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录章节中，我们将介绍一些流行的编程约定，以满足我们的安全挑战：
- en: Revisiting smart pointers (unique, shared, and weak), as well as a complementary
    idiom (RAII)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视智能指针（唯一、共享和弱引用），以及补充的惯用法（RAII）
- en: Using modern `for` loops (range-based, for-each) to avoid common errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现代`for`循环（基于范围的、for-each）以避免常见错误
- en: 'Adding type safety: usage of `auto` instead of explicit typing'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加类型安全：使用`auto`代替显式类型声明
- en: Preferring usage of STL types for simple containers (`std::vector`, and so on)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用 STL 类型作为简单容器（如`std::vector`等）
- en: Utilizing `const` appropriately to ensure non-modification of select items
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地使用`const`以确保某些项不被修改
- en: Understanding thread safety issues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程安全问题
- en: Considering core programming guideline essentials, such as preferring initialization
    to assignment, or choosing only one of `virtual`, `override`, or `final`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑核心编程指导原则的基本要素，例如优先初始化而不是赋值，或者只选择`virtual`、`override`或`final`中的一个
- en: Adopting C++ core programming guidelines for safety (build and assemble one,
    if necessary)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用 C++ 核心编程指南进行安全编程（如果需要，构建和组装一个）
- en: Understanding resources for programming safety in C++
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 C++ 编程中的资源安全
- en: By the end of this chapter, you will understand some of the current industry
    standards and concerns for programming safely in C++. This chapter is not meant
    to be a comprehensive list of all safety concerns and practices in C++, but to
    showcase the types of issues you will need to become mindful of as a successful
    C++ programmer. In some cases, you may desire to investigate a topic more deeply
    to gain a more thorough level of competence and proficiency. Adding safety to
    your C++ programming will make you a more valuable programmer, as your code will
    be more reliable and have more longevity and success.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解一些当前行业在 C++ 中安全编程的标准和关注点。本章的目的不是列出 C++ 中所有安全问题和实践的综合列表，而是展示作为成功的
    C++ 程序员，您需要关注的问题类型。在某些情况下，您可能希望更深入地研究一个主题，以获得更全面的能力和熟练度。将安全性添加到您的 C++ 编程中会使您成为一个更有价值的程序员，因为您的代码将更加可靠，具有更长的生命周期和更高的成功率。
- en: Let’s round out our programming skillset by considering how we can make C++
    safer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑如何使 C++ 更安全来完善我们的编程技能集。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter21` in a file named `Chp21-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21)。每个完整程序示例都可以在
    GitHub 仓库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述
    GitHub 目录下的 `Chapter21` 子目录中找到，文件名为 `Chp21-Ex1.cpp`。一些程序位于示例中指示的可应用子目录中。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3wpOG6b](https://bit.ly/3wpOG6b).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址观看：[https://bit.ly/3wpOG6b](https://bit.ly/3wpOG6b)。
- en: Revisiting smart pointers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视智能指针
- en: Throughout the book, we have developed a reasonable understanding of how to
    use raw or native C++ pointers, including the associated memory allocation and
    deallocation for heap instances. We have persevered through native C++ pointers
    because they are pervasive in existing C++ code. Having knowledge of how to properly
    utilize native pointers is essential in working with the volume of existing C++
    code currently in use. But, for newly created code, there is a safer way to manipulate
    heap memory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经对如何使用原生或本地 C++ 指针有了合理的理解，包括与堆实例相关的内存分配和释放。我们坚持使用原生 C++ 指针，因为它们在现有的
    C++ 代码中无处不在。了解如何正确利用原生指针对于处理目前广泛使用的现有 C++ 代码量至关重要。但是，对于新创建的代码，有一种更安全的方式来操作堆内存。
- en: We have seen that dynamic memory management with native pointers is a lot of
    work! Especially when there may be multiple pointers to the same chunk of memory.
    We’ve talked about reference counting to shared resources (such as heap memory)
    and mechanisms for deleting memory when all instances are done with the shared
    memory. We also know that memory deallocation can easily be overlooked, leading
    to memory leakage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，使用原生指针进行动态内存管理是一项繁重的工作！特别是当可能有多个指针指向同一块内存时。我们讨论了引用计数到共享资源（如堆内存）以及当所有实例都完成对共享内存的操作时删除内存的机制。我们还知道，内存释放很容易被忽视，从而导致内存泄漏。
- en: We have also seen, firsthand, that errors with native pointers can be costly.
    Our programs can end abruptly when we dereference memory we don’t intend to access,
    or when we dereference uninitialized native pointers (interpreting the memory
    to contain a valid address and meaningful data at that address—neither of which
    are actually valid). Pointer arithmetic to walk through memory can be laden with
    errors by an otherwise adept programmer. When a memory error is made, pointer
    or heap memory misuse are often the culprits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还亲身体验到，原生指针的错误可能代价高昂。当我们解引用我们不想访问的内存，或者解引用未初始化的原生指针（解释内存包含有效的地址和该地址上的有意义数据——这两者实际上都不有效）时，我们的程序可能会突然结束。通过指针算术遍历内存可能会被一个本应熟练的程序员的错误所困扰。当出现内存错误时，指针或堆内存误用往往是罪魁祸首。
- en: Certainly, using references can ease the burden of many errors with native pointers.
    But references can still point to dereferenced heap memory that someone forgets
    to deallocate. For these and many other reasons, smart pointers have become popular
    in C++ with the primary purpose of making C++ safer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用引用可以减轻许多原生指针错误带来的负担。但引用仍然可以指向某人忘记释放的已解引用堆内存。出于这些以及其他许多原因，智能指针在 C++ 中变得流行，其主要目的是使
    C++ 更安全。
- en: 'We’ve talked about smart pointers in previous chapters and have seen them in
    action with our pImpl pattern (using `unique_ptr`). But there are more types of
    smart pointers for us to review in addition to unique: shared and weak. Let’s
    also make a programming premise (a future style guide addition) to prefer smart
    pointers in our newly created code to native pointers for the purpose and value
    of pointer safety.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中讨论了智能指针，并看到了它们在我们使用pImpl模式（使用`unique_ptr`）时的实际应用。但除了唯一指针之外，还有更多类型的智能指针需要我们回顾：共享和弱指针。让我们还设定一个编程前提（未来风格指南的补充），即在我们的新代码中优先使用智能指针而不是原生指针，以实现指针安全的目的和价值。
- en: Recall that a **smart pointer** is a small wrapper class that encapsulates a
    raw or native pointer, ensuring that the pointer it contains is automatically
    deleted when the wrapper object goes out of scope. The Standard C++ Library implementations
    of *unique*, *shared*, and *weak* smart pointers use templates to create a specific
    category of smart pointer for any data type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，**智能指针**是一个小的包装类，它封装了一个原始指针或原生指针，确保当包装对象超出作用域时，它所包含的指针会自动删除。标准C++库中实现的*唯一*、*共享*和*弱*智能指针使用模板来为任何数据类型创建特定的智能指针类别。
- en: Though we could devote an entire chapter to each type of smart pointer in depth,
    we will review each type briefly as a starting point to encourage their usage
    in newly created code to support our goal of making C++ safer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以为每种智能指针类型深入探讨整整一章，但我们将简要回顾每种类型，作为起点，鼓励在新创建的代码中使用它们，以支持我们使C++更安全的目标。
- en: Now, let’s revisit each type of smart pointer, one by one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一回顾每种智能指针类型。
- en: Using smart pointers – unique
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用智能指针 - 唯一
- en: Recall that a `unique_ptr` in the Standard C++ Library, is a type of smart pointer
    that encapsulates exclusive ownership and access to a given heap memory resource.
    A `unique_ptr` cannot be duplicated; the owner of a `unique_ptr` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain `unique_ptr`. Recall that we must use `#include <memory>` to
    include the definition for `unique_ptr`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在标准C++库中，`unique_ptr`是一种智能指针类型，它封装了对给定堆内存资源的独占所有权和访问。`unique_ptr`不能被复制；`unique_ptr`的所有者将独占使用该指针。唯一指针的所有者可以选择将这些指针移动到其他资源，但后果是原始资源将不再包含`unique_ptr`。回想一下，我们必须使用`#include
    <memory>`来包含`unique_ptr`的定义。
- en: 'Here is a very simple example illustrating how to create unique pointers. This
    example can be found in our GitHub repository:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的例子，说明了如何创建唯一指针。这个例子可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, notice that because we included `using std::unique_ptr;`, we did not
    need to qualify `unique_ptr` or `make_unique` with `std::` in the unique pointer
    declarations. In this small program, we create several unique pointers, starting
    with one to point to an integer, `p1`, and one to point to an instance of a `Person`,
    `pers1`. Each of these variables has exclusive use of the heap memory each points
    to because we are using unique pointers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，因为我们包含了`using std::unique_ptr;`，所以我们不需要在唯一指针声明中对`unique_ptr`或`make_unique`进行`std::`限定。在这个小程序中，我们创建了几个唯一指针，从指向一个整数的一个指针`p1`和一个指向`Person`实例的指针`pers1`开始。由于我们使用了唯一指针，因此每个变量都独占使用它所指向的堆内存。
- en: Next, we introduce a unique pointer, `pers2`, that takes over the memory originally
    allocated and linked to `pers1` using `pers2 = move(pers1);`. The original variable
    no longer has access to this memory. Note that though we could have allocated
    `pers2` to have its own, unique heap memory, we instead chose to demonstrate how
    to allow one unique pointer to relinquish its memory to another unique pointer
    using `move()`. Changing the ownership of unique pointers with `move()` is typical,
    as unique pointers cannot be copied (because that would allow two or more pointers
    to share the same memory and, therefore, not be unique!)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍一个唯一指针`pers2`，它通过`pers2 = move(pers1);`接管了原本分配并链接到`pers1`的内存。原始变量不再能访问这块内存。请注意，尽管我们可以为`pers2`分配它自己的唯一堆内存，但我们选择展示如何使用`move()`允许一个唯一指针将其内存释放给另一个唯一指针。使用`move()`来改变唯一指针的所有权是典型的，因为唯一指针不能被复制（因为这会导致两个或更多指针共享相同的内存，因此它们不是唯一的！）
- en: Finally, we create another unique pointer, `pers3`, that utilizes `make_unique`
    as a wrapper to allocate the heap memory for the unique pointer that `pers3` will
    represent. The preference for using `make_unique` is that the call to `new()`
    will be made internally, on our behalf. Additionally, any exceptions thrown during
    the construction of the object will be handled for us, as will any call to `delete()`,
    should the underlying `new()` not complete successfully and a call to `delete()`
    is then warranted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建另一个唯一指针`pers3`，它使用`make_unique`作为包装器来为`pers3`将表示的唯一指针分配堆内存。使用`make_unique`的偏好是，`new()`的调用将内部为我们执行。此外，在对象构造期间抛出的任何异常也将由我们处理，如果底层的`new()`没有成功完成并且需要调用`delete()`，也是如此。
- en: The heap memory will be managed for us automatically; this is one of the benefits
    of using a smart pointer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存将由系统自动管理；这是使用智能指针的一个好处。
- en: 'Here is the output for our `unique_ptr` example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`unique_ptr`示例的输出：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Under the hood, the destructor will automatically be called for each object
    pointed to by a smart pointer, when the memory is no longer utilized. In the case
    of this example, the destructor for each `Person` object is called on our behalf
    when the local objects in `main()` go out of scope and are popped off the stack.
    Note that our `Person` destructor contains a `cout` statement so that we can visualize
    that there are only two `Person` objects destructed. Here, the destructed `Person`
    objects represent the instance taken over by `pers2` (from `pers1`) via the `move()`
    statement, and the `pers3` object that was created using the `make_unique` wrapper.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，当内存不再被利用时，智能指针所指向的每个对象都将自动调用析构函数。在本例中，当`main()`中的局部对象超出作用域并被从栈中弹出时，代表每个`Person`对象的析构函数将代表我们被调用。请注意，我们的`Person`析构函数包含一个`cout`语句，这样我们就可以可视化地看到只有两个`Person`对象被销毁。在这里，被销毁的`Person`对象代表通过`move()`语句从`pers1`接管实例的`pers2`，以及使用`make_unique`包装器创建的`pers3`对象。
- en: Next, let’s add examples using shared and weak smart pointers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加使用共享和弱智能指针的示例。
- en: Using smart pointers – shared
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用智能指针 – 共享
- en: A `shared_ptr` in the Standard C++ Library, is a type of smart pointer that
    permits shared ownership of and access to a given resource. The last shared pointer
    to the resource in question will trigger the destruction and memory deallocation
    of the resource. Shared pointers can be used in multithreaded applications; however,
    race conditions may occur if non-constant member functions are used to modify
    the shared resource. Since shared pointers only provide reference counting, we
    will need to enlist additional library methods to solve these issues (alleviating
    race conditions, synchronizing access to critical regions of code, and so on).
    The Standard C++ Library, for example, provides overloaded atomic methods to lock,
    store, and compare the underlying data pointed to by a shared pointer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++库中的`shared_ptr`是一种智能指针类型，允许共享对给定资源的所有权和访问。对于该资源的最后一个共享指针将触发资源的销毁和内存释放。共享指针可用于多线程应用程序；然而，如果使用非常量成员函数来修改共享资源，则可能会发生竞争条件。由于共享指针仅提供引用计数，我们需要使用额外的库方法来解决这些问题（缓解竞争条件、同步对代码关键区域的访问等）。例如，标准C++库提供了重载的原子方法来锁定、存储和比较共享指针所指向的底层数据。
- en: We have seen many example programs that could take advantage of shared pointers.
    For example, we utilized associations between the `Course` and `Student` classes
    – a given student is associated with many courses and a given course is associated
    with many students. Clearly, multiple `Student` instances may point to the same
    `Course` instance, and vice versa.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多可以利用共享指针的示例程序。例如，我们利用了`Course`和`Student`类之间的关联——一个学生可以关联多个课程，一个课程也可以关联多个学生。显然，多个`Student`实例可以指向同一个`Course`实例，反之亦然。
- en: Previously, with raw pointers, it was the programmer’s responsibility to employ
    reference counting. In contrast, using shared pointers, the internal reference
    counter is atomically incremented and decremented in support of both pointer and
    thread safety.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前，使用原始指针时，程序员有责任使用引用计数。相比之下，使用共享指针时，内部引用计数器会原子性地增加和减少，以支持指针和线程安全。
- en: Dereferencing a shared pointer is nearly as fast as dereferencing a raw pointer;
    however, because a shared pointer represents a wrapped pointer in a class, constructing
    and copying a shared pointer is more expensive. However, we are interested in
    making C++ safer, so we will simply note this very minor performance expense and
    move forward.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用共享指针几乎与解引用原始指针一样快；然而，由于共享指针在类中代表了一个包装指针，因此构造和复制共享指针的成本更高。然而，我们感兴趣的是使C++更安全，所以我们将简单地注意这个非常小的性能开销并继续前进。
- en: 'Let’s take a look at a very simple example using `shared_ptr`. This example
    can be found in our GitHub repository:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的使用`shared_ptr`的例子。这个例子可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned program, we create four shared pointers – two to point
    to the same integer (`p1` and `p2`) and two to point to the same instance of `Person`
    (`pers1` and `pers2`). Each of these variables may change the specific shared
    memory they point to because we are using shared pointers (which allow such a
    reassignment). A change to the shared memory through `pers1`, for example, will
    be reflected should we then review the (shared) memory through pointer `pers2`;
    both variables point to the same memory location.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，我们创建了四个共享指针——两个指向相同的整数（`p1`和`p2`）和两个指向相同的`Person`实例（`pers1`和`pers2`）。由于我们使用的是共享指针（允许这种重新赋值），这些变量中的每一个都可能改变它们所指向的特定共享内存。例如，通过`pers1`对共享内存的更改，如果随后我们通过指针`pers2`查看（共享）内存，将会反映出来；这两个变量都指向相同的内存位置。
- en: The heap memory will again be managed for us automatically as a benefit of using
    smart pointers. In this example, the memory will be destructed and deleted when
    the last reference to the memory is removed. Notice that reference counting is
    done on our behalf and that we can access this information using `use_count()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存将再次由智能指针的使用自动管理。在这个例子中，当移除对内存的最后一个引用时，内存将被销毁和删除。请注意，引用计数是由我们代为进行的，并且我们可以使用`use_count()`来访问此信息。
- en: Let us notice something interesting about the previous example. Notice the mixed
    use of `->` and `.` notation with shared pointer variables `pers1` and `pers2`.
    For example, we utilize `pers1->Print();` and yet we also utilize `pers1.use_count()`.
    This is no mistake and reveals the wrapper implementation of the smart pointer.
    With that in mind, we know that `use_count()` is a method of `shared_ptr`. Our
    shared pointers `pers1` and `pers2` are each declared as instances of `shared_ptr`
    (definitely not using raw C++ pointers with the symbol `*`). Hence, dot notation
    is appropriate to access method `use_count()`. Yet, we are using `->` notation
    to access `pers1->Print();`. Here, recall that this notation is equivalent to
    `(*pers1).Print();`. Both `operator*` and `operator->` in the `shared_ptr` class
    are overloaded to delegate to the wrapped, raw pointer contained within the smart
    pointer. Hence, we may utilize standard pointer notation to access `Person` methods
    (through the safely wrapped raw pointer).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注意前一个示例中的一些有趣之处。注意 `shared_ptr` 变量 `pers1` 和 `pers2` 中 `->` 和 `.` 符号的混合使用。例如，我们使用
    `pers1->Print();`，同时也使用 `pers1.use_count()`。这并非错误，而是揭示了智能指针的包装实现。考虑到这一点，我们知道 `use_count()`
    是 `shared_ptr` 的一个方法。我们的共享指针 `pers1` 和 `pers2` 都被声明为 `shared_ptr` 的实例（绝对不是使用带有符号
    `*` 的原始 C++ 指针）。因此，点符号是访问 `use_count()` 方法是合适的。然而，我们使用 `->` 符号来访问 `pers1->Print();`。在这里，回忆一下这个符号等同于
    `(*pers1).Print();`。`shared_ptr` 类中的 `operator*` 和 `operator->` 都被重载，以便将智能指针中包含的包装原始指针委托出去。因此，我们可以使用标准指针符号来访问
    `Person` 方法（通过安全包装的原始指针）。
- en: 'Here is the output for our `shared_ptr` pointer example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于我们的 `shared_ptr` 指针示例的输出：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Shared pointers seem like a wonderful way to ensure that memory resources pointed
    to by multiple pointers are properly managed. Overall, this is true. However,
    there are situations with circular dependencies such that shared pointers simply
    cannot release their memory – another pointer is always pointing to the memory
    in question. This happens when a cycle of memory is orphaned; that is, when no
    outside shared pointers point *into* the circular connection. In such unique cases,
    we might actually (and counterintuitively) mismanage memory with shared pointers.
    In these situations, we can elicit help from a weak pointer to help us break the
    cycle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针似乎是一种确保多个指针指向的内存资源得到适当管理的好方法。总体来说，这是真的。然而，存在循环依赖的情况，共享指针根本无法释放其内存 – 另一个指针始终指向相关的内存。这发生在内存循环被遗弃时；也就是说，当没有外部共享指针指向循环连接时。在这些独特的情况下，我们实际上（并且反直觉地）可能会用共享指针管理内存。在这些情况下，我们可以从弱指针那里寻求帮助，以帮助我们打破循环。
- en: With that in mind, let’s next take a look at weak smart pointers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，接下来让我们看看弱智能指针。
- en: Using smart pointers – weak
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用智能指针 – 弱指针
- en: A `weak_ptr` in the Standard C++ Library, is a type of smart pointer that does
    not take ownership of a given resource; instead, the weak pointer acts as an observer.
    Weak pointers can be used to help break a circular connection that may exist between
    shared pointers; that is, situations where the destruction of a shared resource
    would otherwise never occur. Here, a weak pointer is inserted into the chain to
    break the circular dependency that shared pointers alone might otherwise create.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 C++ 库中，`weak_ptr` 是一种不拥有给定资源的智能指针类型；相反，弱指针充当观察者。弱指针可以用来帮助打破共享指针之间可能存在的循环连接；也就是说，在共享资源的销毁本应永远不会发生的情况下。在这里，一个弱指针被插入到链中，以打破共享指针单独可能创建的循环依赖。
- en: As an example, imagine our `Student` and `Course` dependencies from our initial
    programming examples utilizing association, or from our more complex program illustrating
    the Observer pattern. Each contains pointer data members of the associated object
    types, effectively creating a potential circular dependency. Now, should an outside
    (from the circle) shared pointer exist, such as an external list of courses or
    an external list of students, the exclusive circular dependency scenario may not
    arise. In this case, for example, the master list of courses (the external pointer,
    separate from any circular dependency existing between the associated objects)
    will provide the means to cancel a course, leading to its eventual destruction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们最初的编程示例中的 `Student` 和 `Course` 依赖关系，利用关联，或者从我们的更复杂的程序中，该程序展示了观察者模式。每个都包含关联对象类型的指针数据成员，从而有效地创建了一个潜在的循环依赖。现在，如果存在外部（来自圆圈外的）共享指针，例如外部课程列表或外部学生列表，那么可能不会出现排他性的循环依赖场景。在这种情况下，例如，课程的主列表（外部指针，与关联对象之间存在的任何循环依赖无关）将提供取消课程的方法，从而导致其最终被销毁。
- en: Likewise in our example, an external set of students comprising the university’s
    student body can provide an external pointer to the potentially circular shared
    pointer scenario resulting from the association between `Student` and `Course`.
    Yet in both of these cases, work will need to be done to remove a canceled course
    from a student’s course list (or remove a dropped student from a course’s student
    list). The removal of the associations in this scenario reflects accurately managing
    a student’s schedule or a course’s attendance list. Nonetheless, we can imagine
    scenarios where a circular connection may exist without an outside handle to the
    links (unlike the aforementioned scenario, which has outside links into the circle).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在我们的例子中，由大学学生群体组成的校外学生集合可以提供一个指向由 `Student` 和 `Course` 之间的关联产生的潜在循环共享指针场景的外部指针。然而，在这两种情况下，都需要做工作来从学生的课程列表中删除已取消的课程（或从课程的学生的列表中删除已退出的学生）。在这种情况下，删除关联反映了准确管理学生的日程安排或课程的出勤名单。尽管如此，我们可以想象存在循环连接的情景，但没有外部对链接的访问（与上述具有外部链接到圆圈中的情景不同）。
- en: In the case where a circular dependency exists (with no outside influences),
    we will need to downgrade one of the shared pointers to a weak pointer. A weak
    pointer will not control the lifetime of the resource that it points to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在循环依赖（没有外部影响）的情况下，我们需要将一个共享指针降级为弱指针。弱指针不会控制其所指向的资源的生命周期。
- en: A weak pointer to a resource cannot access the resource directly. This is because
    operators `*` and `->` are not overloaded in the `weak_ptr` class. You will need
    to convert the weak pointer to a shared pointer in order to access methods of
    the (wrapped) pointer type. One way to do this is to apply the `lock()` method
    to a weak pointer, as the return value is a shared pointer whose contents are
    locked with a semaphore to ensure mutual exclusivity to the shared resource.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指向资源的弱指针不能直接访问该资源。这是因为 `weak_ptr` 类中没有重载操作符 `*` 和 `->`。您需要将弱指针转换为共享指针才能访问（包装的）指针类型的方法。一种方法是将
    `lock()` 方法应用于弱指针，因为返回值是一个共享指针，其内容通过信号量锁定以确保对共享资源的互斥访问。
- en: 'Let’s take a look at a very simple example using `weak_ptr`. This example can
    be found on our GitHub:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个使用 `weak_ptr` 的非常简单的例子来看看。这个例子可以在我们的 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned program, we allocate our resource using a shared pointer
    in `pers1`. Now, let us imagine we had a reason in our program to downgrade our
    resource to a weak pointer – perhaps we would like to insert a weak pointer to
    break an otherwise cycle of shared pointers. Using `weak_ptr<Person> wpers1(pers1);`,
    we establish a weak pointer to this resource. Notice that we cannot use `wpers1`
    to call `Print();`. This is because `operator->` and `operator*` have not been
    overloaded in the `weak_ptr` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，我们使用 `pers1` 中的共享指针来分配我们的资源。现在，让我们假设在我们的程序中有理由将我们的资源降级为弱指针——也许我们想要插入一个弱指针来打破共享指针的循环。使用
    `weak_ptr<Person> wpers1(pers1);`，我们为这个资源建立了一个弱指针。请注意，我们无法使用 `wpers1` 来调用 `Print();`。这是因为
    `weak_ptr` 类中没有重载 `operator->` 和 `operator*`。
- en: We print out `use_count()` for each of `pers1` and `wpers1` to notice that each
    shows a value of `1`. That is, there is only one non-weak pointer controlling
    the resource in question (the weak pointer may temporarily hold the resource,
    but cannot modify it).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `pers1` 和 `wpers1` 打印出 `use_count()`，以注意到每个都显示了一个值为 `1`。这意味着只有一个非弱指针控制着相关的资源（弱指针可能暂时持有资源，但不能修改它）。
- en: Now, imagine that we would like to convert the resource pointed to by `wpers1`
    on-demand to another shared pointer, so that we may access the resource. We can
    do so by first gaining a lock on the weak pointer; `lock()` will return a shared
    pointer whose contents are protected by a semaphore. We assign this value to `pers2`.
    We then call `pers2->ModifyTitle("Dr.");` on the resource using the shared pointer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要按需将 `wpers1` 指向的资源转换为另一个共享指针，以便我们可以访问该资源。我们可以通过首先锁定弱指针来实现这一点；`lock()`
    将返回一个共享指针，其内容由信号量保护。我们将这个值赋给 `pers2`。然后我们使用共享指针调用 `pers2->ModifyTitle("Dr.");`
    来修改资源。
- en: Finally, we print out `use_count()` from the perspective of each of `pers1`,
    `wpers1`, and `pers2`. In each case, the reference count will be `2`, as there
    are two non-weak pointers referencing the shared resource. The weak pointer does
    not contribute to the reference count of that resource, which is exactly how weak
    pointers can help break a chain of circular dependencies. By inserting a weak
    pointer into the dependency loop, the reference count to the shared resource will
    not be affected by the weak pointer’s presence. This strategy allows the resource
    to be deleted when only the weak pointer to the resource remains (and the reference
    count is `0`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从 `pers1`、`wpers1` 和 `pers2` 的角度打印出 `use_count()`。在每种情况下，引用计数都将为 `2`，因为有两个非弱指针引用了共享资源。弱指针不会对该资源的引用计数做出贡献，这正是弱指针可以帮助打破循环依赖的方式。通过在依赖循环中插入弱指针，共享资源的引用计数不会受到弱指针存在的影响。这种策略允许当只有对资源的弱指针剩余（且引用计数为
    `0`）时删除资源。
- en: The heap memory will again be managed for us automatically as a benefit of using
    smart pointers. In this example, the memory will be destructed and deleted when
    the last reference to the memory is removed. Again, note that the weak pointer
    did not contribute a reference to this count. We can see from the `cout` statement
    in the `Person` destructor that only one instance was destructed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存将再次由智能指针的使用自动管理。在本例中，当移除对内存的最后一个引用时，内存将被销毁和删除。再次注意，弱指针没有对这个计数做出贡献。我们可以从 `Person`
    析构函数中的 `cout` 语句中看到，只有一个实例被析构。
- en: 'Here is the output for our `weak_ptr` pointer example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于我们的 `weak_ptr` 指针示例的输出：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this section, we’ve reviewed and added to the basics regarding smart pointers.
    However, there could be a chapter easily spent on each type of smart pointer.
    Nonetheless, hopefully, you have enough comfort with the essentials to begin to
    include a variety of smart pointers in your code and investigate each type further
    as your need arises.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾并补充了有关智能指针的基本知识。然而，每个类型的智能指针都可能单独占用一章内容。尽管如此，希望您对基本知识已经足够熟悉，可以开始在代码中包含各种智能指针，并在需要时进一步研究每种类型。
- en: Exploring a complementary idea – RAII
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索一个互补的想法——RAII
- en: A programming idiom that complements smart pointers (as well as other concepts)
    is `move()` operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种与智能指针（以及其他概念）相辅相成的编程惯用方法是 `move()` 操作。
- en: Many C++ class libraries follow RAII for resource management, such as `std::string`
    and `std::vector`. These classes follow the idiom in that their constructors acquire
    the necessary resources (heap memory), and release the resources automatically
    in their destructors. The user of these classes is not required to explicitly
    release any memory for the container itself. In these class libraries, RAII as
    a technique is used to manage these resources, even though the heap memory is
    not managed using smart pointers. Instead, the concepts of RAII are encapsulated
    and hidden within the class implementations themselves.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C++ 类库遵循 RAII（资源获取即初始化）进行资源管理，例如 `std::string` 和 `std::vector`。这些类遵循该惯用法，即它们的构造函数获取必要的资源（堆内存），并在析构函数中自动释放资源。使用这些类的用户不需要显式释放容器本身的任何内存。在这些类库中，即使不使用智能指针来管理堆内存，RAII
    作为一种技术也被用来管理这些资源，其概念被封装并隐藏在类实现本身之中。
- en: When we implemented our own smart pointers in [*Chapter 20*](B19087_20.xhtml#_idTextAnchor876),
    *Removing Implementation Details Using the pImpl Pattern*, we used RAII, without
    knowing it, to ensure the allocation of the heap resource within our constructor
    and the release of the resource in our destructor. The smart pointers implemented
    in the Standard C++ Library (`std::unique_ptr`, `std::shared_ptr`, and `std::weak_ptr`)
    embrace this idiom as well. Embracing RAII by using classes employing this idiom
    (or by adding it yourself to classes when this is not possible), can help ensure
    code is safer and easier to maintain. Because of the safety and robustness that
    this idiom adds to code, savvy developers urge us to embrace RAII as one of the
    most important practices and features available in C++.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第 20 章*](B19087_20.xhtml#_idTextAnchor876) 中实现自己的智能指针时，即 *使用 pImpl 模式去除实现细节*，我们无意中使用了
    RAII 来确保在构造函数中分配堆资源，并在析构函数中释放资源。标准 C++ 库中实现的智能指针（`std::unique_ptr`、`std::shared_ptr`
    和 `std::weak_ptr`）也采用了这种惯用法。通过使用采用这种惯用法的类（或者在自己无法做到时将其添加到类中），可以有助于确保代码更安全且易于维护。由于这种惯用法为代码增加了安全性和健壮性，熟练的开发者强烈建议我们将
    RAII 作为 C++ 中最重要的实践和功能之一。
- en: Next in our effort to make C++ safer, let’s consider several easy C++ features
    we can easily embrace to ensure our coding is more robust.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力使 C++ 更安全的努力中，接下来让我们考虑几个我们可以轻松采用的简单 C++ 功能，以确保我们的编码更加健壮。
- en: Embracing additional C++ features promoting safety
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用促进安全性的额外 C++ 功能
- en: As we have seen through 20 previous chapters of programming, C++ is an extensive
    language. We know that C++ has great power and that we can do nearly anything
    in C++. As object-oriented C++ programmers, we have seen how to adopt OO designs,
    with the goal of making our code more easily maintainable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们通过前 20 章编程所见，C++ 是一种广泛的语言。我们知道 C++ 有很大的能力，我们几乎可以在 C++ 中做任何事情。作为面向对象的 C++
    程序员，我们已经看到了如何采用 OO 设计，目标是使我们的代码更容易维护。
- en: We have also gained a lot of experience utilizing raw (native) pointers in C++,
    primarily because raw pointers are very pervasive in existing code. You truly
    need experience and facility in using native pointers for when the need arises.
    In gaining this experience, we have seen firsthand the pitfalls we may encounter
    with mismanagement of heap memory – our programs may have crashed, we may have
    leaked memory, overwritten memory accidentally, left dangling pointers, and so
    on. Our first order of business in this chapter was to prefer using smart pointers
    in newly created code – to promote safety in C++.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还积累了大量使用 C++ 中的原始（本地）指针的经验，主要是因为原始指针在现有代码中非常普遍。当需要时，你确实需要经验和熟练使用本地指针。在获得这种经验的过程中，我们亲眼目睹了可能遇到的堆内存管理陷阱——我们的程序可能崩溃，我们可能泄漏了内存，意外覆盖了内存，留下了悬垂指针，等等。在本章中，我们的首要任务是优先使用智能指针来创建新代码——以促进
    C++ 的安全性。
- en: Now, we will explore other areas of C++ that we can similarly employ safer features.
    We have seen these various features throughout the book; it is important to establish
    a guideline that select language features promote safety in C++. Just because
    we can do anything in C++ doesn’t mean that we should routinely include features
    in our repertoire that have a high level of misuse associated with them. Applications
    that continually crash (or crash even once) are unacceptable. Certainly, we have
    noted no-nos throughout the book. Here, let’s point out language features that
    are worth embracing to further our goal of making C++ safer, leaving our applications
    more robust and more easily maintainable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探索C++的其他领域，我们可以同样使用更安全的特性。我们在整本书中看到了这些不同的特性；建立一条指导原则，选择那些能促进C++安全性的语言特性是很重要的。仅仅因为我们可以在C++中做任何事情，并不意味着我们应该例行公事地将那些与高度误用相关的特性纳入我们的技能库。那些不断崩溃（或者甚至只崩溃一次）的应用程序是不可接受的。当然，我们在整本书中都提到了禁忌。在这里，让我们指出那些值得拥抱的语言特性，以进一步实现使C++更安全的目标，使我们的应用程序更加健壮和易于维护。
- en: Let’s start by reviewing simple items we can incorporate into our everyday code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾我们可以将其纳入日常代码中的简单项目开始。
- en: Revisiting range for loops
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重温范围for循环
- en: C++ has a variety of looping constructs that we have seen throughout the book.
    One common error that occurs when processing a complete set of items is correctly
    keeping track of how many items are in the set, especially when this counter is
    used as a basis to loop through all items in the set. Processing too many elements
    when our set is stored as an array, for example, could lead our code to raise
    an exception unnecessarily (or worse, could lead our program to crash).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: C++有各种各样的循环结构，我们在整本书中都看到了。在处理一个完整的元素集合时，一个常见的错误是正确跟踪集合中有多少个项目，尤其是在这个计数器被用作遍历集合中所有项目的依据时。例如，当我们的集合以数组形式存储时，处理过多的元素可能会导致我们的代码不必要地抛出异常（或者更糟，可能导致程序崩溃）。
- en: Rather than relying on a `MAX` value to conduct our looping for all elements
    in a set, it is more desirable to loop through every item in the set in a way
    that doesn’t count on the programmer correctly remembering this upper loop value.
    Instead, for each item in the set, let’s do some sort of processing. A for-each
    loop answers this need quite nicely.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与其依赖于一个`MAX`值来遍历集合中的所有元素，不如以一种不依赖于程序员正确记住这个上限循环值的方式遍历集合中的每一个项目。相反，对于集合中的每一个项目，让我们进行某种处理。for-each循环很好地满足了这一需求。
- en: One common error that occurs when processing a non-complete set of items is
    correctly keeping track of how many items are currently in the set. For example,
    a `Course` may have a maximum number of students permitted. Yet, as of today,
    only half of the potential `Student` slots are filled. When we peruse the list
    of students enrolled in the course, we need to ensure we are processing only the
    filled student spots (that is, the current number of students). Processing all
    maximum student spots would clearly be an error and could lead our program to
    crash. In this scenario, we must use care to iterate only over the currently utilized
    `Student` spots in the `Course`, either through using logic to exit a loop when
    appropriate or by selecting a container type whose current size represents the
    complete size of the set to be iterated upon (with no empty *to be filled* spots);
    the latter scenario making a for-each loop an ideal choice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理一个不完整的元素集合时，一个常见的错误是正确跟踪当前集合中有多少个项目。例如，一门课程可能允许的最大学生人数是有限的。然而，截至今天，只有一半的潜在`Student`位置被填满。当我们查看课程中注册的学生名单时，我们需要确保我们只处理已填满的学生位置（即当前的学生人数）。处理所有最大学生位置显然是错误的，可能会导致我们的程序崩溃。在这种情况下，我们必须小心地只遍历`Course`中当前使用的`Student`位置，无论是通过在适当的时候退出循环的逻辑，还是通过选择一个当前大小代表要遍历的集合完整大小的容器类型（没有空白的*待填充*位置）；后一种情况使得for-each循环成为理想的选择。
- en: Also, what if we rely on looping based upon a `currentNumStudents` counter?
    This may be better than a `MAX` value in cases as previously illustrated, but
    what if we’ve not kept that counter correctly updated? We’re subject to an error
    on this as well. Again, combining a container class where the number of entries
    represents the current number of entries with a for-each type of loop can ensure
    that we process the complete, current grouping in a less error-prone manner.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们依赖于基于 `currentNumStudents` 计数器的循环呢？在之前示例中提到的情况下，这可能比 `MAX` 值更好，但如果我们没有正确更新那个计数器呢？我们也会在这个问题上出错。再次强调，将表示当前条目数量的容器类与
    foreach 类型的循环结合起来，可以确保我们以更不易出错的方式处理完整的当前分组。
- en: Now that we have revisited modern and more safe looping styles, let’s embrace
    `auto` to ensure type safety. We will then see an example incorporating these
    collective features.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经回顾了现代和更安全的循环风格，让我们拥抱 `auto` 以确保类型安全。然后我们将看到一个结合这些共同特性的示例。
- en: Using auto for type safety
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `auto` 进行类型安全
- en: Many situations arise in which using `auto` makes coding easier with respect
    to variable declarations, including loop iterators. Additionally, using `auto`
    instead of explicit typing can ensure type safety.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用 `auto` 可以使变量声明（包括循环迭代器）的编码更加容易，并且使用 `auto` 而不是显式类型化可以确保类型安全。
- en: Choosing to use `auto` is a simple way to declare a variable that has a complicated
    type. Using `auto` can also ensure that the best type is chosen for a given variable
    and that implicit conversion will not occur.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用 `auto` 是声明具有复杂类型的变量的简单方法。使用 `auto` 还可以确保为给定变量选择最佳类型，并且不会发生隐式转换。
- en: We can use `auto` as a placeholder for types in a variety of situations, allowing
    the compiler to deduce what is needed in a particular situation. We can even use
    `auto` as a return type for a function in many cases. Using `auto` allows our
    code to appear more generic and can complement templates as an alternative to
    genericizing a type. We can pair `auto` with `const`, and also pair these qualifiers
    with references; note that these qualifiers *combined* cannot be extrapolated
    with `auto` and must be specified individually by the programmer. Additionally,
    `auto` cannot also be used with qualifiers augmenting a type, such as `long` or
    `short`, nor can it be used with `volatile`. Though outside the scope of our book,
    `auto` can be utilized with lambda expressions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在各种情况下使用 `auto` 作为类型的占位符，让编译器推导出特定情况下的需求。我们甚至可以在许多情况下将 `auto` 用作函数的返回类型。使用
    `auto` 可以使我们的代码看起来更通用，并且可以作为泛化的替代方案来补充模板。我们还可以将 `auto` 与 `const` 配对，并将这些限定符与引用配对；请注意，这些限定符
    *结合* 不能与 `auto` 外推，必须由程序员单独指定。此外，`auto` 不能与增强类型的限定符一起使用，例如 `long` 或 `short`，也不能与
    `volatile` 一起使用。虽然这超出了我们书籍的范围，但 `auto` 可以与 lambda 表达式一起使用。
- en: Of course, using `auto` has a few drawbacks. For example, if the programmer
    doesn’t understand the type of object being created, the programmer may anticipate
    the compiler to select a certain type, and yet another (unexpected) type is deduced.
    This may create subtle errors in your code. For example, if you have overloaded
    functions for both the type you think `auto` will select and for the type the
    compiler actually deduces the `auto` declaration to be, you may call a different
    function than anticipated! Certainly, this may mostly be due to the programmer
    not fully understanding the context of usage at hand when inserting the `auto`
    keyword. Another drawback is when the programmer uses `auto` just to force the
    code to compile, without truly working through the syntax at hand and thinking
    about how the code should be written.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用 `auto` 有一些缺点。例如，如果程序员不理解正在创建的对象的类型，程序员可能会期望编译器选择某种类型，然而却推导出另一种（意外的）类型。这可能会在您的代码中产生微妙的错误。例如，如果您为
    `auto` 将选择和编译器实际推导出的 `auto` 声明类型都重载了函数，您可能会调用一个与预期不同的函数！当然，这大多可能是由于程序员在插入 `auto`
    关键字时没有完全理解当前使用上下文的结果。另一个缺点是，当程序员仅仅为了强制代码编译而使用 `auto`，而没有真正地处理手头的语法并思考代码应该如何编写时。
- en: Now that we have revisited adding `auto` to our code, let’s revisit embracing
    STL in our everyday code. We will then see an example incorporating these collective
    features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经回顾了在我们的代码中添加 `auto`，那么让我们回顾一下在日常代码中拥抱 STL。然后我们将看到一个结合这些共同特性的示例。
- en: Preferring STL for simple containers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先使用 STL 进行简单容器
- en: The Standard Template Library, as we’ve seen in [*Chapter 14*](B19087_14.xhtml#_idTextAnchor595),
    *Understanding STL Basics*, includes a very complete and robust set of container
    classes that are widely utilized in C++ code. Using these well-tested components
    instead of native C++ mechanisms (such as an array of pointers) to collect like
    items can add robustness and reliability to our code. The memory management is
    eased on our behalf (eliminating many potential errors).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第14章*](B19087_14.xhtml#_idTextAnchor595)“理解STL基础”所见，标准模板库（STL）包含了一套非常完整且健壮的容器类，这些类在C++代码中被广泛使用。使用这些经过良好测试的组件（而不是原生C++机制，如指针数组）来收集类似项，可以为我们的代码增加鲁棒性和可靠性。内存管理变得更容易（消除了许多潜在的错误）。
- en: The STL, by using templates to implement its large variety of container classes,
    allows its containers to be used generically for any data type our programs may
    encounter. By comparison, had we utilized native C++ mechanisms, it is likely
    that we may have tied our implementation to a specific class type, such as an
    array of pointers to `Student`. Certainly, we could have implemented an array
    of pointers to a templatized type, but why do so when such a nice variety of well-tested
    containers are readily available for our use?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模板实现其大量的容器类，STL允许其容器以通用方式用于程序可能遇到的任何数据类型。相比之下，如果我们使用了原生C++机制，我们可能会将我们的实现绑定到特定的类类型，例如指向`Student`的指针数组。当然，我们可以实现一个指向模板化类型的指针数组，但为什么要在有这么多经过良好测试且易于使用的容器可供我们使用时这样做呢？
- en: STL containers also avoid using `new()` and `delete()` for memory management,
    choosing to use allocators to improve efficiency for STL’s underlying memory management.
    For example, a vector, stack, or queue may grow and shrink in size. Rather than
    allocating the maximum number of elements you may anticipate (which may be both
    difficult to estimate or inefficient to over-allocate for typical usage that does
    not reach the maximum), a certain buffer size or a number of elements may be allocated
    under the hood up front. This initial allocation allows multiple additions to
    the container without a resize necessary for each new addition to the set (as
    might otherwise be done to avoid over-allocation). Only when the underlying container’s
    internal allocation (or buffer) size exceeds the pre-allocated amount will an
    internal reallocation be necessary (unknown to the user of the container). The
    expense of an internal reallocation, or a *move*, is the allocation of a larger
    piece of memory, copying from the original memory to the larger piece, and then
    the release of the original memory. The STL works to fine-tune, under the hood,
    the internal allocations to balance typical usage needs versus costly reallocation
    that might otherwise be performed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器还避免了使用`new()`和`delete()`进行内存管理，而是选择使用分配器来提高STL底层内存管理的效率。例如，一个向量、栈或队列可能会增长或缩小。而不是分配你可能预期的最大元素数量（这可能既难以估计，又可能对典型使用（通常不会达到最大值）来说既困难又低效），在幕后可能会预先分配一定大小的缓冲区或元素数量。这种初始分配允许在不需要为集合中的每个新添加项进行大小调整的情况下多次向容器中添加元素（否则可能会这样做以避免过度分配）。只有当底层容器的内部分配（或缓冲区）大小超过预先分配的量时，才需要进行内部重新分配（对容器用户来说是未知的）。内部重新分配或*移动*的代价是分配更大的内存块，从原始内存复制到更大的内存块，然后释放原始内存。STL在幕后努力微调内部分配，以平衡典型使用需求与可能进行的昂贵重新分配。
- en: Now that we have revisited preferring STL in our code, let’s revisit applying
    `const` when necessary to ensure code isn’t modified unless we so intend it to
    be. We will wrap up this section with an example illustrating all of the key safety
    points featured in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经重新审视了在代码中优先使用STL，那么现在让我们重新审视在必要时使用`const`，以确保代码不会被修改，除非我们有意使其如此。我们将通过一个示例结束本节，该示例展示了本节中所有关键的安全点。
- en: Applying const as needed
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据需要使用const
- en: Applying the `const` qualifier to objects is an easy way to indicate that instances
    that should not be modified are not, in fact, modified. We may recall that `const`
    instances may only call `const` member functions. And that `const` member functions
    may not modify any part of the object calling the method (`this`). Remembering
    to utilize this simple qualifier can ensure that this chain of checkpoints occurs
    for objects that we truly do not intend to modify.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将`const`限定符应用于对象是一种简单的方法，可以表明不应修改的实例实际上没有被修改。我们可能会记得，`const`实例只能调用`const`成员函数。而且，`const`成员函数不能修改调用该方法的任何对象的部分（`this`）。记住利用这个简单的限定符可以确保这个检查点链对于我们不打算修改的对象发生作用。
- en: With that in mind, remember that `const` can be utilized in parameter lists,
    to qualify objects and methods. Using `const` adds readability to the objects
    and methods it qualifies as well as adding the valuable enforcement of read-only
    objects and methods. Let’s remember to use `const` as needed!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，请记住，`const`可以在参数列表中使用，以指定对象和方法。使用`const`不仅增加了它所指定的对象和方法的可读性，还增加了宝贵的只读对象和方法强制执行。让我们记住在需要时使用`const`！
- en: 'Now, let’s take a look at how we can use each of these easily added C++ features
    that contribute to safer programming. This example revisits preferred looping
    styles, using `auto` for type safety, using the STL for simple containers, and
    applying `const` as appropriate. This example can be found in our GitHub repository:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用这些易于添加的C++特性，这些特性有助于更安全的编程。这个例子重新审视了首选的循环风格，使用`auto`进行类型安全，使用STL进行简单的容器，以及适当地应用`const`。这个例子可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the aforementioned program, we initially notice that we have included the
    use of `std::vector` from C++’s STL. Further in `main()`, we notice the instantiation
    of a vector using `vector<Student> studentBody;`. Utilizing this well-tested container
    class certainly adds robustness to our code versus managing a dynamically sized
    array ourselves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，我们最初注意到我们使用了C++ STL中的`std::vector`。在`main()`函数中，我们注意到使用`vector<Student>
    studentBody;`实例化了一个向量。利用这个经过良好测试的容器类无疑增加了我们代码的健壮性，相对于我们自行管理动态大小的数组。
- en: Next, notice the specification of a constant member function `void Student::Print()
    const;`. Here, the `const` qualification ensures that no part of the object invoking
    this method (`this`) will be able to be modified. Furthermore, should any `const`
    instances exist, they will be able to invoke `Student::Print()` as the `const`
    qualification guarantees this method to be safe (that is, read-only) for `const`
    instances to utilize.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意指定了一个常量成员函数`void Student::Print() const;`。在这里，`const`指定确保调用此方法的对象（`this`）的任何部分都不能被修改。此外，如果存在任何`const`实例，它们将能够调用`Student::Print()`，因为`const`指定保证了此方法对`const`实例来说是安全的（即只读）。
- en: Next, we notice three looping styles and mechanisms, progressing from least
    to most safe in style. The first loop cycles through each element in the loop
    with a traditional style `for` loop. What if we had used `MAX` for the looping
    condition instead of `studentBody.size()`? We might have tried to process more
    elements than are currently in the container; this type of oversight can be error-prone.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们注意到三种循环风格和机制，从最不安全到最安全的风格进行排序。第一个循环使用传统的`for`循环遍历循环中的每个元素。如果我们用`MAX`代替`studentBody.size()`作为循环条件会怎样？我们可能会尝试处理比容器中当前元素更多的元素；这种疏忽可能导致错误。
- en: The second loop utilizes an iterator and the `auto` keyword to make the type
    specification easier (and hence safer) for the iterator itself. Iterators, though
    well defined, are still not the preferred looping mechanism. A subtlety from the
    increment in the second statement in the `for` statement can also lead to inefficiency.
    Consider, for example, the pre versus post increment in the statement that is
    executed before the loop condition is retested (that is, `++iter`). Had this been
    `iter++`, the code would be less efficient. This is because `iter` is an object
    and the pre-increment returns a reference to the object, whereas the post-increment
    returns a temporary object (what is created and destroyed with each loop iteration).
    The post-increment also utilizes an overloaded function, so the compiler cannot
    optimize its usage.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环使用迭代器和 `auto` 关键字来简化类型指定（从而对迭代器本身来说更容易且更安全）。虽然迭代器定义良好，但它们仍然不是首选的循环机制。`for`
    语句中第二个语句的增量中的一个细微差别也可能导致效率低下。例如，考虑在循环条件重新测试之前执行的语句中的预增量与后增量。如果这是 `iter++`，则代码效率会较低。这是因为
    `iter` 是一个对象，预增量返回对象的引用，而后增量返回一个临时对象（在每个循环迭代中创建和销毁）。后增量还使用了一个重载函数，因此编译器无法优化其使用。
- en: Finally, we see the preferred and safest looping mechanism, featuring a range-for
    loop combined with `auto` for the iterator specification (to simplify the type
    declaration). The use of `auto` replaces `vector<Student>::iterator` as the type
    for `iter`. Any time there is an ease in notation, there is also less room for
    error. Also, notice the use of `const` added to the iterator declaration to ensure
    that the loop will only call non-modifiable methods on each instance iterated
    upon; this is an example of an additional, appropriate safety feature we can employ
    in our code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到首选且最安全的循环机制，它结合了范围-for 循环和 `auto` 用于迭代器指定（以简化类型声明）。使用 `auto` 替换了 `vector<Student>::iterator`
    作为 `iter` 的类型。任何简化符号的地方，都有更少的错误空间。此外，请注意迭代器声明中添加了 `const`，以确保循环将只调用每个迭代实例上的不可修改方法；这是一个我们可以在我们代码中采用的额外、适当的特性示例。
- en: 'Here is the output for our aforementioned program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述程序的输出：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have now revisited several straightforward C++ language features that can
    easily be embraced to promote safety in our everyday coding practices. Using range-for
    loops provides code simplification and removes dependencies from often incorrect
    upper limits of loop iteration. Embracing `auto` simplifies variable declarations,
    including within loop iterators, and can help ensure type safety versus explicit
    typing. Using well-tested STL components can add robustness, reliability, and
    familiarity to our code. Finally, applying `const` to data and methods is an easy
    way to ensure data is not modified unintentionally. Each of these principles is
    easy to employ and adds value to our code by adding to its overall safety.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回顾了几个简单的 C++ 语言特性，这些特性可以轻松地被采用以促进我们日常编码实践中的安全性。使用范围-for 循环提供了代码简化并消除了对循环迭代中经常错误的上限的依赖。采用
    `auto` 简化了变量声明，包括循环迭代器内的声明，并有助于确保类型安全与显式类型。使用经过良好测试的 STL 组件可以为我们的代码增加鲁棒性、可靠性和熟悉感。最后，将
    `const` 应用于数据和方法是确保数据不会被意外修改的一种简单方法。这些原则都很容易应用，并通过增加整体安全性为我们的代码增加价值。
- en: Next, let’s consider how understanding thread safety can contribute to making
    C++ safer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑理解线程安全性如何有助于使 C++ 更加安全。
- en: Considering thread safety
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑线程安全性
- en: Multithreaded programming in C++ is an entire book unto itself. Nonetheless,
    we have mentioned several situations throughout the book that potentially require
    the consideration of thread safety. It is worth re-iterating these topics to provide
    an overview of the issues you may encounter in various niches of C++ programming.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的多线程编程本身就是一个完整的书籍。尽管如此，我们在本书中提到了几个可能需要考虑线程安全性的情况。值得重申这些主题，以提供一个概述，说明您可能在
    C++ 编程的各个细分领域中遇到的问题。
- en: A program may be comprised of multiple threads, each of which may potentially
    compete against one another to access a shared resource. For example, a shared
    resource could be a file, socket, region of shared memory, or output buffer. Each
    thread accessing the shared resource needs to have carefully coordinated (known
    as mutually exclusive) access to the resource.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可能由多个线程组成，每个线程可能都可能会相互竞争以访问共享资源。例如，共享资源可能是一个文件、套接字、共享内存区域或输出缓冲区。每个访问共享资源的线程都需要对资源进行仔细协调（称为互斥）的访问。
- en: Imagine, for example, if two threads wanted to write output to your screen.
    If each thread could access the output buffer associated with `cout` without waiting
    for the other to complete a cohesive statement, the output would be a garbled
    mess of random letters and symbols. Clearly, synchronized access to a shared resource
    is important!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象如果有两个线程想要向你的屏幕写入输出。如果每个线程都可以访问与`cout`关联的输出缓冲区，而不必等待另一个线程完成一个连贯的语句，输出将是一团糟的随机字母和符号。显然，对共享资源的同步访问是非常重要的！
- en: Thread safety involves understanding atomic actions, mutual exclusion, locks,
    synchronization, and so on—all of which are aspects of multithreaded programming.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全涉及理解原子操作、互斥、锁、同步等——这些都是多线程编程的方面。
- en: Let’s begin with an overview of threads and multithreaded programming.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从线程和多线程编程的概述开始。
- en: Multithreaded programming overview
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程编程概述
- en: A **thread** is a separate flow of control within a process, conceptually working
    like a subprocess (or further subdivision of a process) within a given process.
    Threads are sometimes referred to as *threads of control*. Applications that have
    many threads of control are known as **multithreaded applications**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是在一个进程内部的一个独立的控制流，从概念上讲，它就像是在给定进程内部的一个子进程（或进程的进一步细分）。线程有时被称为**控制线程**。拥有许多控制线程的应用程序被称为**多线程应用程序**。'
- en: In uniprocessor environments, threads give the appearance that multiple tasks
    are running concurrently. Just as with processes, threads are swapped in and out
    of the CPU quickly to appear to the user that they are being processed simultaneously
    (though they aren’t). In a shared, multiprocessor environment, the use of threads
    within an application can significantly speed up processing and allow parallel
    computing to be realized. Even in a uniprocessor system, threads can actually
    (and perhaps counterintuitively) speed up a process, in that one thread may run
    while waiting for the I/O of another thread to complete.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在单处理器环境中，线程给人一种多个任务同时运行的感觉。就像进程一样，线程在CPU之间快速切换，以便用户看起来它们正在被同时处理（尽管实际上不是）。在共享的多处理器环境中，应用程序中使用线程可以显著加快处理速度，并允许实现并行计算。即使在单处理器系统中，线程实际上（也许出人意料地）可以加快一个进程的速度，因为在等待另一个线程的I/O完成时，一个线程可以运行。
- en: Threads related by the tasks they are performing may find themselves in similar
    methods of a class simultaneously. If each thread is working on a distinct dataset
    (such as a distinct `this` pointer, even if working within the same method), there
    is generally no need to synchronize access to those methods. For example, imagine
    `s1.EarnPhd();` and `s2.EarnPhD();`. Here, two separate instances are in the same
    method (possibly concurrently). However, the datasets worked upon in each method
    differ – in the first scenario, `s1` will bind to `this`; in the second scenario,
    `s2` will bind to `this`. There is most likely no overlap in shared data between
    the two instances. However, if these methods are accessing static data (that is
    shared by all instances of a given class, such as a `numStudents` data member),
    synchronization to the critical pieces of code accessing the shared memory regions
    will be required. Traditionally, system-dependent locks or semaphores are added
    around data or functions that require mutual exclusivity to critical regions of
    code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行相同任务的线程可能会同时处于类的类似方法中。如果每个线程都在处理一个不同的数据集（例如，一个不同的`this`指针，即使是在同一个方法中工作），通常没有必要同步对这些方法的访问。例如，想象`s1.EarnPhd();`和`s2.EarnPhD();`。在这里，两个独立的实例处于同一个方法中（可能是并发地）。然而，每个方法中处理的数据集是不同的——在第一种情况下，`s1`将绑定到`this`；在第二种情况下，`s2`将绑定到`this`。这两个实例之间共享的数据很可能没有重叠。然而，如果这些方法正在访问静态数据（即给定类所有实例共享的数据，例如`numStudents`数据成员），那么对访问共享内存区域的代码的关键部分进行同步将是必需的。传统上，在需要互斥访问代码关键区域的
    数据或函数周围添加系统依赖的锁或信号量。
- en: Multithreaded programming in C++ is available through a variety of commercial
    or public domain multithreading libraries. Additionally, the Standard C++ Library
    features thread support in a variety of capacities including using `std::condition_variable`
    for thread synchronization, `std::mutex` to ensure mutual exclusivity of critical
    resources (by avoiding race conditions), and `std::semaphore` to model resource
    counting. By instantiating a `std::thread` object and becoming proficient with
    the aforementioned features, we can add multithreaded programming using an established
    C++ library. Additionally, the `std::atomic` template can be added to a type to
    establish it as an atomic type and ensure type-safe synchronization. The `std::exception_ptr`
    type allows the transport of exceptions between coordinating threads. Overall,
    there are many thread library features to consider; this is a vast topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的多线程编程可以通过各种商业或公共领域的多线程库来实现。此外，标准C++库在多种能力上提供了线程支持，包括使用 `std::condition_variable`
    进行线程同步，`std::mutex` 确保关键资源的互斥性（通过避免竞争条件），以及 `std::semaphore` 来模拟资源计数。通过实例化 `std::thread`
    对象并熟练掌握上述功能，我们可以使用已建立的C++库添加多线程编程。此外，可以将 `std::atomic` 模板添加到类型中，将其建立为原子类型并确保类型安全的同步。`std::exception_ptr`
    类型允许在协调线程之间传输异常。总的来说，有许多线程库功能需要考虑；这是一个广泛的话题。
- en: The details for multithreaded programming are beyond the scope of this book;
    however, we can discuss scenarios within this book that may be augmented to require
    the knowledge of using threads. Let’s revisit some of those situations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程编程的细节超出了本书的范围；然而，我们可以讨论本书中可能需要增加以要求使用线程知识的场景。让我们回顾一些那些情况。
- en: Multithreaded programming scenarios
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程编程场景
- en: There are many programming scenarios that can benefit from the use of multithreaded
    programming. We will just mention a few that extend the ideas we have covered
    in this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编程场景可以从使用多线程编程中受益。我们只提及一些扩展了本书中涵盖的思想的例子。
- en: The Observer pattern may certainly be employed in multithreaded programming
    scenarios! In these instances, care must be used in the `Update()` and `Notify()`
    methods of `Observer` and `Subject`, respectively, to add synchronization and
    locking mechanisms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式当然可以在多线程编程场景中使用！在这些情况下，必须小心处理 `Observer` 和 `Subject` 的 `Update()` 和 `Notify()`
    方法，以添加同步和锁定机制。
- en: Smart pointers, such as `shared_ptr` and `weak_ptr`, can be used in multithreaded
    applications and already include the means to lock and synchronize access to shared
    resources via reference counting (and with the use of atomic library methods).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针，例如 `shared_ptr` 和 `weak_ptr`，可以在多线程应用程序中使用，并且已经包含了通过引用计数（以及使用原子库方法）来锁定和同步访问共享资源的手段。
- en: Objects related through association may arise with multithreaded programming
    or through shared memory regions. Any time access is conducted through a shared
    resource using multithreaded programming, mutexes (locks) should be employed to
    ensure mutual exclusivity to those shared resources.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联相关的对象可能会在多线程编程或通过共享内存区域中出现。任何通过多线程编程使用共享资源进行访问的时候，都应该使用互斥锁（锁）来确保对这些共享资源的互斥访问。
- en: Objects throwing exceptions that need to communicate with one another will need
    to include synchronization within catcher blocks or delegate exceptions to the
    `main()` program thread. Employing worker threads to communicate with the `main()`
    program thread is a typical design model. Utilizing shared memory is a means to
    store the data that will need to be shared between threads coordinating with a
    `throw` and `catch` of the exception itself. An instance of `std::exception_ptr`
    can be utilized with `std::current_exception()` to store an instance needing to
    be shared. This shared instance (between threads) can be rethrown to a participating
    thread using `std::rethrow_exception()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常的对象需要相互通信，将需要在捕获块中包含同步或将异常委派给 `main()` 程序线程。使用工作线程与 `main()` 程序线程通信是典型设计模式。利用共享内存是存储需要在抛出和捕获异常本身之间协调的线程之间共享的数据的手段。可以使用
    `std::exception_ptr` 实例与 `std::current_exception()` 一起使用来存储需要共享的实例。这个共享实例（在线程之间）可以使用
    `std::rethrow_exception()` 重新抛给参与线程。
- en: Multithreaded programming is a fascinating topic unto itself and requires in-depth
    understanding to utilize safely in C++. We’ve revisited a few areas in which thread
    safety considerations may complement areas we have covered in this book. It is
    highly recommended to delve deeply into thread safety in C++ before embarking
    on adding multithreaded programming to your code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程编程本身就是一个迷人的主题，并且需要在 C++ 中安全地使用它之前进行深入理解。我们已经回顾了一些可能补充本书所涵盖内容的线程安全性考虑的区域。强烈建议在向代码中添加多线程编程之前，深入探讨
    C++ 中的线程安全性。
- en: Next, let’s move forward to investigate how programming guidelines can add a
    necessary level of safety to C++ programming.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进一步探讨编程指南如何为 C++ 编程增加必要的安全性级别。
- en: Utilizing core programming guidelines
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用核心编程指南
- en: Programming guidelines are much more than a set of conventions to indicate how
    many spaces to indent or naming conventions for variables, functions, classes,
    data members, and member functions. A modern programming guideline is a covenant
    between programmers within an organization to create code adhering to specific
    standards, with the largest goal to provide robust and easily extensible code
    by following these common standards. The bottom line is that most of the conventions
    contained within a programming guideline are simply to make programming in C++
    safer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编程指南远不止是一套约定，比如指示缩进多少空格或变量的命名规范，函数、类、数据成员和成员函数的命名约定。现代编程指南是组织内部程序员之间的一种契约，旨在创建遵循特定标准的代码，其最大目标是通过对这些共同标准的遵循，提供健壮且易于扩展的代码。简而言之，编程指南中包含的大多数约定都是为了使
    C++ 编程更安全。
- en: The consensus of what comprises a C++ programming guideline may vary from organization
    to organization, but there are many resources available (including from standards
    committees) to provide examples and direction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构成 C++ 编程指南的内容，各组织之间可能存在共识差异，但有许多资源可用（包括来自标准委员会的资源）来提供示例和指导。
- en: Let’s move forward to examine a sampling of programming guide essentials and
    then discuss adopting a core set of guidelines, as well as understanding resources
    widely available for programming safely in C++.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨编程指南的基本要素的抽样，然后讨论采用核心指南集，以及理解广泛可用的在 C++ 中安全编程的资源。
- en: Examining guideline essentials
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查指南要素
- en: Let’s start by examining a sampling of meaningful conventions to follow from
    a typical C++ programming guideline. We have examined many of these programming
    issues throughout the book, yet it is useful to review a few items to provide
    a starting point for choosing conventions to promote C++ safety.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查一个典型的 C++ 编程指南中可以遵循的有意义的约定开始。我们在整本书中已经探讨了这些编程问题中的许多，但回顾一些项目对于选择促进 C++
    安全性的约定是有用的。
- en: Preferring initialization over assignment
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先初始化而非赋值
- en: Always choose initialization, whenever possible, over assignment. It’s simply
    more efficient and safer! Use in-class initialization or the member initialization
    list. When assignment is used after initialization, it can be less efficient.
    Imagine, for example, a member object that is default constructed, only to quickly
    overwrite its values with more suitable values via assignment in the body of the
    constructor. It would have been more efficient to utilize the member initialization
    list to initialize this member object via an alternate constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，始终选择初始化而非赋值。这既更高效也更安全！使用类内初始化或成员初始化列表。在初始化之后使用赋值可能效率较低。例如，想象一个默认构造的成员对象，它只是快速通过构造函数体内的赋值来覆盖其值。利用成员初始化列表通过另一个构造函数初始化这个成员对象会更有效率。
- en: Also, neglecting to give each piece of memory an initial value can cost us dearly
    in terms of safety – memory in C++ is not clean, so it is truly inappropriate
    to interpret whatever is in an uninitialized variable (or data member) as valid.
    Accessing an uninitialized value is an undefined behavior. We truly never know
    what is lurking in uninitialized memory, but we know it is never the correct value
    to be used as an initializer!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，未能为每一块内存赋予初始值可能会在安全性方面给我们带来巨大的代价——在 C++ 中，内存不是干净的，因此将未初始化变量（或数据成员）中的任何内容解释为有效内容是完全不恰当的。访问未初始化的值是未定义的行为。我们真的不知道未初始化的内存中隐藏着什么，但我们知道它绝不是用作初始化器的正确值！
- en: 'Let’s review preferred initialization with a small program. This example can
    be found in our GitHub:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小程序来回顾首选的初始化。这个例子可以在我们的 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp)'
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Examining the preceding code, we notice that the `Person` class uses in-class
    initialization to set the `middleInitial` data member to the null character (`'\0'`).
    For each instance of `Person`, `middleInitial` will be set to the null character
    prior to any constructor call that further initializes the instance in question.
    Notice that the other data members in the class are all of type `string`. Because
    `string` is a class itself, these data members are actually member objects of
    type `string` and will be default constructed, appropriately initializing each
    of these string members.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的代码，我们发现`Person`类使用类内初始化将`middleInitial`数据成员设置为空字符（`'\0'`）。对于`Person`的每个实例，`middleInitial`将在调用任何进一步初始化该实例的构造函数之前被设置为空字符。请注意，类中的其他数据成员都是`string`类型。因为`string`本身就是一个类，这些数据成员实际上是`string`类型的成员对象，并将被默认构造，适当地初始化这些字符串成员。
- en: Next, notice that we opted not to provide a default (no argument) constructor,
    allowing the system-supplied default constructor to be linked in for us. In-class
    initialization, coupled with the appropriate member object initialization of the
    `string` members, left no additional initialization necessary for new `Person`
    instances, and hence no need for a programmer-specified default constructor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意我们没有提供默认（无参数）构造函数，允许系统提供的默认构造函数为我们链接。类内初始化，加上适当的`string`成员对象初始化，使得对于新的`Person`实例没有额外的初始化工作，因此不需要程序员指定的默认构造函数。
- en: Finally, notice our use of the member initialization list in the alternate constructor
    for `Person`. Here, each data member is set with an appropriate value from the
    parameter list of this method. Notice that every data member is set via initialization,
    leaving no assignments necessary in the body of the alternate constructor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意我们在`Person`类的替代构造函数中使用了成员初始化列表。在这里，每个数据成员都使用此方法参数列表中的适当值进行设置。请注意，每个数据成员都是通过初始化设置的，这样在替代构造函数的主体中就不需要任何赋值操作了。
- en: 'Our preceding code follows the popular code guideline: whenever possible, always
    opt to set values via initialization versus assignment. Knowing that each data
    member has an appropriate value during construction leads us to provide a safer
    code. Initialization is also more efficient than assignment.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前面的代码遵循了流行的代码规范：在可能的情况下，始终选择通过初始化而不是赋值来设置值。知道每个数据成员在构造过程中都有适当的值，这使我们能够提供更安全的代码。初始化也比赋值更高效。
- en: Now, let’s consider another core C++ guideline relating to virtual functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个与虚函数相关的核心C++指南。
- en: Choosing one of virtual, override, or final
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择`virtual`、`override`或`final`中的一个
- en: Polymorphism is a wonderful concept that C++ easily supports with the use of
    virtual functions. We learned in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366),
    *Utilizing Dynamic Binding through Polymorphism*, that the keyword `virtual` is
    used to indicate a polymorphic operation – an operation that may be overridden
    by derived classes with a preferred method. Derived classes are not obligated
    to override a polymorphic operation (virtual function) by providing a new method,
    but may find it meaningful to do so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一个美妙的概念，C++通过使用虚函数轻松支持。我们在[*第7章*](B19087_07.xhtml#_idTextAnchor366)，*通过多态利用动态绑定*中了解到，关键字`virtual`用于指示多态操作——一个可能被派生类用首选方法覆盖的操作。派生类没有义务通过提供新方法来覆盖多态操作（虚函数），但可能会发现这样做是有意义的。
- en: When a derived class chooses to override a virtual function introduced by a
    base class with a new method, the overridden method may use both the keywords
    `virtual` and `override` in the signature of the method. However, it is a convention
    to use only `override` at this overridden (derived class) level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当派生类选择用新方法覆盖基类引入的虚函数时，被覆盖的方法可以在方法的签名中使用`virtual`和`override`关键字。然而，在这个被覆盖的（派生类）级别，只使用`override`是一个约定。
- en: When a virtual function is introduced in the hierarchy, it may be desirable
    at some point to indicate that a certain method is the *final* implementation
    of this operation. That is, the operation in question may no longer be overridden.
    We know that it is appropriate to apply the `final` specifier to the virtual function
    at this level of the hierarchy to indicate that a given method may no longer be
    overridden. Though we may also include the keyword `virtual` at this level as
    well, it is recommended to only utilize `final`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当在层次结构中引入虚函数时，在某个时候可能希望表明某个方法是此操作的*最终*实现。也就是说，所涉及的操作可能不再被覆盖。我们知道，在层次结构的这个级别上应用`final`说明符是合适的，以表明给定的方法可能不再被覆盖。尽管我们也可以在这个级别包含关键字`virtual`，但建议只使用`final`。
- en: 'To sum up, when specifying a virtual function, only choose one label at each
    level: `virtual`, `override`, or `final` – even though the keyword `virtual` can
    be added to complement `override` and `final`. By doing so, it will be much clearer
    if the virtual function at hand is newly introduced (`virtual`), an overridden
    method of a virtual function (`override`), or the final method of a virtual function
    (`final`). Clarity causes fewer errors to occur and that helps make C++ safer.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在指定虚函数时，每个级别只选择一个标签：`virtual`、`override`或`final`——即使关键字`virtual`可以添加以补充`override`和`final`。这样做可以使当前虚函数是新生成的（`virtual`）、是虚函数的覆盖方法（`override`），还是虚函数的最终方法（`final`）更加清晰。清晰性导致错误发生得少，这有助于使C++更安全。
- en: 'Let’s review the preferred keyword usage with virtual functions with a program
    segment. The complete example can be found in our GitHub repository:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个程序段来回顾使用虚函数时的首选关键字用法。完整的示例可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp)'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we see our `Person` class that we have carried forward
    throughout the book. As a base class, notice that `Person` specifies polymorphic
    operations of `Print()`, `IsA()`, and `Greeting()`, as well as the destructor
    using the `virtual` keyword. These operations are intended to be overridden by
    a derived class with more suitable methods (not including the destructor), but
    are not required to be overridden should the derived class find the base class
    implementation suitable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到我们一直在书中使用的`Person`类。作为一个基类，请注意，`Person`指定了多态操作`Print()`、`IsA()`和`Greeting()`，以及使用`virtual`关键字的析构函数。这些操作旨在由派生类使用更合适的方法覆盖（不包括析构函数），但如果派生类认为基类的实现是合适的，则不需要覆盖。
- en: In the derived class, `Student`, we override `IsA()` with a more suitable method.
    Notice that we use `override` in the signature of this function, though we could
    have also included `virtual`. Next, notice that we have chosen not to override
    `Greeting()` at the `Student` level; we can assume that `Student` finds the implementation
    in `Person` acceptable. Also notice that the destructor is overridden to provide
    the entry point to the destruction chain. Recall with a destructor that not only
    is the derived class destructor called, but the base class destructor will also
    be called (implicitly as the last line of code in the derived class destructor),
    allowing the object’s full destruction sequence to properly commence.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类`Student`中，我们使用更合适的方法覆盖了`IsA()`。请注意，我们在该函数的签名中使用了`override`，尽管我们也可以包含`virtual`。接下来，请注意，我们没有在`Student`级别覆盖`Greeting()`；我们可以假设`Student`认为`Person`中的实现是可以接受的。另外，请注意，析构函数被覆盖以提供销毁链的入口点。回想一下，析构函数不仅会调用派生类的析构函数，还会调用基类的析构函数（隐式地作为派生类析构函数中的最后一行代码），从而确保对象的完整销毁序列能够正确开始。
- en: Finally, notice that `Print()` has been overridden as `final` in `Student`.
    Though we could have added `override` to the signature of this function as well,
    we choose to only utilize `final` per the recommended coding convention.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，在`Student`类中，`Print()`函数已被重写为`final`。尽管我们也可以将`override`关键字添加到这个函数的签名中，但我们选择根据推荐的编码规范仅使用`final`。
- en: Now, let’s look at another typical element in a typical C++ programming set
    of guidelines, relating to smart pointers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看典型C++编程指南中的另一个典型元素，与智能指针相关。
- en: Preferring smart pointers in new code
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在新代码中优先使用智能指针
- en: We have utilized many native (raw) C++ pointers in this book, as you will undoubtedly
    be asked to immerse yourself in existing code in which they are plentiful. Having
    native pointer experience and facility will make you a safer programmer when asked
    to step into situations that use native pointers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用了许多本地的（原始的）C++指针，因为你无疑会被要求沉浸到包含大量指针的现有代码中。拥有本地指针的经验和能力，将使你在被要求进入使用本地指针的情况时成为一个更安全的程序员。
- en: However, for safety’s sake, most programming guides will recommend using smart
    pointers exclusively in newly created code. After all, their use adds little overhead
    and can help eliminate many of the potential pitfalls of managing heap memory
    by the programmer. Smart pointers also aid in exception safety. For example, exception
    handling implies that the expected flow of code may be interrupted at nearly any
    time, leading to potential memory leaks with traditional pointer usage. Smart
    pointers can alleviate some of this burden and provide for exception safety.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于安全考虑，大多数编程指南都会建议在新建代码中仅使用智能指针。毕竟，它们的使用开销很小，可以帮助消除程序员管理堆内存的许多潜在陷阱。智能指针还有助于异常安全性。例如，异常处理意味着代码的预期流程可能在几乎任何时间被中断，导致使用传统指针时可能发生内存泄漏。智能指针可以减轻一些这种负担，并提供异常安全性。
- en: 'Using smart pointers is so important in original code that this point is worth
    repeating: choosing smart pointers over native pointers leads to safer and far
    easier to maintain code in C++. The code will also be easier to write, eliminating
    the need for many destructors, automatically blocking undesired copies and assignment
    (`unique_ptr`), and so on. With that in mind, whenever possible, choose smart
    pointers in newly created code.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始代码中使用智能指针非常重要，这一点值得重复：在C++中选择智能指针而不是本地指针，将导致更安全且更容易维护的代码。代码也将更容易编写，消除了许多析构函数的需求，自动阻止不希望的复制和赋值（`unique_ptr`）等。考虑到这一点，在可能的情况下，始终选择智能指针在新创建的代码中。
- en: We’ve seen smart pointers in this book as well as native pointers. Now, you
    can choose to use smart pointers in the new code that you create – this is highly
    recommended. Certainly, there may be some scenarios when this is not possible;
    perhaps you are creating new code that interfaces heavily with existing native
    pointer code and need to utilize the same data structures. Nonetheless, you can
    strive to use smart pointers, when possible, yet you have the flexibility and
    experience to understand the vast amounts of existing code, libraries, and online
    examples that exist utilizing native pointers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中也看到了智能指针和本地指针。现在，你可以选择在你创建的新代码中使用智能指针——这强烈推荐。当然，可能有一些情况下这是不可能的；也许你正在创建与现有本地指针代码高度交互的新代码，需要利用相同的数据结构。尽管如此，在可能的情况下，你可以努力使用智能指针，同时你拥有灵活性和经验来理解大量使用本地指针的现有代码、库和在线示例。
- en: What could be better for safety than to have the facility of smart pointers
    for your original code, paired with the knowledge of native pointers to use only
    when necessary?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全性来说，还有什么比在你的原始代码中拥有智能指针的能力，并辅以本地指针的知识，只在必要时使用更好呢？
- en: There are many examples of programming guidelines that can be easily followed
    to make your code safer. The aforementioned examples are just a few of many to
    illustrate the types of practices you will expect to see in a set of essential
    C++ programming guidelines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编程指南的例子可以轻松遵循，以使你的代码更安全。上述例子只是许多例子中的一部分，用以说明你将在一组基本C++编程指南中看到的各种实践。
- en: Now, let’s consider how we can assemble or adopt core programming guidelines
    to help make our code safer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何组装或采用核心编程指南，以帮助使我们的代码更安全。
- en: Adopting a programming guideline
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用编程指南
- en: Whether you build or assemble a set of programming guidelines yourself or adhere
    to a set governed by an organization you are a member of, adopting a core set
    of C++ programming guidelines is crucial to ensure your code is as safe and robust
    as possible, translating to more easily maintainable code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是自己构建或组装一套编程指南，还是遵循你所在组织管理的一套指南，采用一组核心C++编程指南对于确保你的代码尽可能安全、健壮至关重要，这转化为更容易维护的代码。
- en: Guidelines should always remain fluid as the language evolves. Let’s next consider
    resources for finding core C++ programming guidelines to either follow directly
    or to revisit incrementally to improve the accepted guidelines within your organization.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 指南应始终随着语言的发展而保持灵活。接下来，让我们考虑寻找核心 C++ 编程指南的资源，以便直接遵循或逐步回顾，以改进你所在组织接受的指南。
- en: Understanding resources for programming safely in C++
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++ 中安全编程的资源
- en: 'There are many online resources for programming guidelines in C++. The essential
    resource, however, is the *ISO C++ Core Guidelines*, assembled primarily by Bjarne
    Stroustrup and Herb Sutter, which can be found at the following GitHub URL: [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md).
    Their collective goal is to help programmers use modern C++ safely and more effectively.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有许多关于 C++ 编程指南的资源。然而，最重要的资源是 *ISO C++ 核心指南*，主要由 Bjarne Stroustrup 和 Herb Sutter
    组装，可以在以下 GitHub 网址找到：[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)。他们的共同目标是帮助程序员安全且更有效地使用现代
    C++。
- en: Selected market sectors may have guidelines imposed upon them to obtain or ensure
    certification within an industry. For example, **MISRA** is a set of C++ coding
    standards for the **Motor Industry Software Reliability Association**; MISRA has
    also been adopted as a standard across other industries, such as for medical systems.
    Another coding standard, developed for embedded systems, is **CERT**, developed
    at **Carnegie Mellon University** (**CMU**). Once an acronym for **Computer Emergency
    Response Team**, CERT is now a registered trademark of CMU. CERT has been adopted
    in many financial sectors as well. **JSF AV C++** (**Joint Strike Fighter Air
    Vehicle C++**) is a C++ coding standard used in the aerospace engineering domain,
    developed by Lockheed Martin, to ensure error-free code for safety-critical systems.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 选取的市场领域可能需要遵循一定的指南来获得或确保行业内的认证。例如，**MISRA** 是一套针对 **汽车工业软件可靠性协会**（Motor Industry
    Software Reliability Association）的 C++ 编码标准；MISRA 也已被其他行业采纳为标准，例如医疗系统。另一个为嵌入式系统开发的编码标准是
    **CERT**，由 **卡内基梅隆大学**（Carnegie Mellon University，简称 **CMU**）开发。CERT 最初是 **计算机紧急响应团队**（Computer
    Emergency Response Team）的缩写，现在已成为 CMU 的注册商标。CERT 也被许多金融行业采纳。**JSF AV C++**（Joint
    Strike Fighter Air Vehicle C++）是洛克希德·马丁公司（Lockheed Martin）开发的一种 C++ 编码标准，用于航空航天工程领域，以确保安全关键系统的代码无错误。
- en: Undoubtedly, each organization you join as a contributor will have a base set
    of programming guidelines for all programmers in the group to follow. If not,
    a wise move will be to suggest employing a core set of C++ programming guidelines.
    After all, you will need to help maintain your own code as well as the code of
    your colleagues; a uniform and expected set of standards will make this endeavor
    manageable for everyone involved.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你加入的每个组织作为贡献者都将有一套编程指南，供组内所有程序员遵循。如果没有，明智的做法是建议采用一套核心的 C++ 编程指南。毕竟，你需要帮助维护自己的代码以及同事的代码；一套统一和预期的标准将使所有相关人员都能管理这项工作。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this bonus chapter, we have added to our objective of becoming indispensable
    C++ programmers by understanding the importance of programming safely in C++.
    After all, our primary goal is to create robust and easily maintainable code.
    Incorporating safe programming practices will help us achieve this goal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们通过理解在 C++ 中安全编程的重要性，增加了成为不可或缺的 C++ 程序员的目标。毕竟，我们的主要目标是创建健壮且易于维护的代码。采用安全的编程实践将帮助我们实现这一目标。
- en: We have reviewed concepts seen throughout the book, as well as related ideas
    that culminate in adopting a set of core programming guidelines to ensure safer
    coding practices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了书中提到的概念，以及相关思想，最终形成了一套核心编程指南，以确保更安全的编码实践。
- en: 'First, we reviewed smart pointers, examining three types from the Standard
    C++ Library, namely `unique_ptr`, `shared_ptr`, and `weak_ptr`. We understand
    that these classes employ the RAII idiom by providing wrappers to allocate and
    deallocate heap memory safely on our behavior in well-tested standard library
    classes. We put forth a guideline: always prefer smart pointers in newly created
    code.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们回顾了智能指针，检查了来自标准 C++ 库的三种类型，即 `unique_ptr`、`shared_ptr` 和 `weak_ptr`。我们了解到，这些类通过提供封装来分配和释放堆内存，从而通过我们在经过充分测试的标准库类中的行为来安全地实现
    RAII 习语。我们提出了一个指南：在新建代码中始终优先考虑智能指针。
- en: Next, we reiterated a variety of programming practices that we have seen throughout
    the book that we can employ to make our coding safer overall. For example, preferring
    for-each style loops and using `auto` for type safety. Also, using STL containers
    versus less robust native mechanisms, and also adding the `const` qualifier for
    data and methods to ensure read-only access when so needed. These practices are
    examples (among many) that can help ensure our code is as safe as possible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重申了在本书中看到的多种编程实践，我们可以利用这些实践来使我们的编码更加安全。例如，优先使用 for-each 风格的循环和 `auto`
    关键字来保证类型安全。此外，使用 STL 容器而非较脆弱的本地机制，并在需要时为数据和方法添加 `const` 限定符以确保只读访问。这些实践（在许多实践中）可以帮助确保我们的代码尽可能安全。
- en: Next, we introduced multithreaded programming in C++ and reviewed programming
    scenarios we have seen previously that may benefit from the use of threads. We
    also took a look ahead at the classes available in the Standard C++ Library in
    support of multithreaded programming, including those that provide synchronization,
    mutex locks, semaphores, and creating atomic types.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了 C++ 的多线程编程，并回顾了之前我们看到的可能从使用线程中受益的编程场景。我们还前瞻性地查看了一下标准 C++ 库中支持多线程编程的类，包括那些提供同步、互斥锁、信号量和创建原子类型的类。
- en: Finally, we examined programming guideline essentials to better understand rules
    that may be beneficial in a C++ core programming guide. For example, we reviewed
    preferring initialization over the assignment, virtual function usage with regard
    to the keywords `virtual`, `override`, and `final`, as well as previously examined
    topics from this chapter. We talked about the importance of adopting a comprehensive
    set of core programming guidelines for C++ as well as resources to find sample
    guidelines used as industry standards.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了编程指南的要点，以便更好地理解在 C++ 核心编程指南中可能有益的规则。例如，我们回顾了优先初始化而非赋值，关于 `virtual`、`override`
    和 `final` 关键字的虚拟函数使用，以及本章之前探讨的主题。我们讨论了采用一套全面的 C++ 核心编程指南的重要性，以及查找作为行业标准使用的示例指南的资源。
- en: Understanding how to make C++ safer as you apply the many features covered in
    the book will undoubtedly make you a more valuable programmer. You now have core
    language skills plus a very solid understanding of OOP in C++ (essential concepts
    and how to implement them in C++ with either direct language support or using
    programming techniques). We have augmented your skills with knowledge of exception
    handling, friends, operator overloading, templates, STL basics, and testing OO
    classes and components. We have also embraced core design patterns, delving into
    each pattern with comprehensive programming examples. Finally in this chapter,
    we have reviewed how to safely put together the knowledge you have learned by
    choosing to employ safer programming practices at each available opportunity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用本书中涵盖的许多特性时，了解如何使 C++ 更加安全无疑会使你成为一个更有价值的程序员。你现在拥有了核心语言技能，并且对 C++ 中的面向对象编程（基本概念及其在
    C++ 中的实现方式，无论是直接语言支持还是使用编程技术）有了非常坚实的理解。我们通过异常处理、友元、运算符重载、模板、STL 基础和测试 OO 类和组件等知识丰富了你的技能。我们还接受了核心设计模式，通过综合编程示例深入研究每个模式。最后在本章中，我们回顾了如何通过在每个可用的机会选择采用更安全的编程实践来安全地组合你所学的知识。
- en: As we wrap up our bonus chapter together, you are now ready to journey further
    on your own, applying C++ to many new and existing applications. You are ready
    to create safe, robust, and easy to maintain code. I am sincerely hopeful that
    you are as intrigued by C++ as I am. Once again, let’s get programming!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们一起结束我们的附加章节时，你现在准备好独自踏上旅程，将 C++ 应用于许多新的和现有的应用。你准备好创建安全、健壮且易于维护的代码。我真诚地希望你对
    C++ 的兴趣和我一样浓厚。再次，让我们开始编程吧！
- en: Assessments
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: 'The programming solution for each chapter’s questions can be found in our GitHub
    repository at the following URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main).
    Each full program solution can be found in our GitHub repository in the subdirectory
    Assessments , and then under the appropriate chapter heading (subdirectory, such
    as `Chapter01`), in a file that corresponds to the chapter number, followed by
    a dash, followed by the solution number in the chapter at hand. For example, the
    solution for *Question 3* in [*Chapter 1*](B19087_01.xhtml#_idTextAnchor016),
    *Understanding Basic C++ Assumptions*, can be found in the subdirectory `Assessments/Chapter01`
    in a file named `Chp1-Q3.cpp` under the aforementioned GitHub directory.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每章问题的编程解决方案可以在我们的GitHub仓库中找到，网址如下：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main)。每个完整的程序解决方案都可以在我们的GitHub仓库的“评估”子目录中找到，然后在适当的章节标题（子目录，例如`Chapter01`）下，在一个与章节编号相对应的文件中，后面跟着一个连字符，然后是当前章节中的解决方案编号。例如，[*第一章*](B19087_01.xhtml#_idTextAnchor016)，“理解基本的C++假设”中的*问题3*的解决方案可以在上述GitHub目录下的`Assessments/Chapter01`子目录中的`Chp1-Q3.cpp`文件中找到。
- en: The written responses for non-programming questions can be found in the following
    sections, organized by chapter, as well as in the aforementioned GitHub in the
    appropriate Assessments subdirectory for a given chapter. For example, `Assessments/Chapter01/Chp1-WrittenQs.pdf`
    will contain the answers to the non-programming solutions for [*Chapter 1*](B19087_01.xhtml#_idTextAnchor016),
    *Understanding Basic C++ Assumptions*. Should an exercise have a programming portion
    and a follow-up question to the program, the answer to the follow-up question
    may be found both in the next sections (as well as in the aforementioned `.pdf`
    file) and in a comment at the top of the programming solution in GitHub (as it
    may be appropriate to review the solution in order to fully understand the answer
    to the follow-up question).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 非编程问题的书面回答可以在以下章节中找到，按章节组织，以及在上文提到的GitHub中相应章节的“评估”子目录中。例如，`Assessments/Chapter01/Chp1-WrittenQs.pdf`将包含对[*第一章*](B19087_01.xhtml#_idTextAnchor016)，“理解基本的C++假设”的非编程解决方案的答案。如果一个练习既有编程部分又有对程序的后续问题，那么后续问题的答案可以在下一节（以及上文提到的`.pdf`文件）中找到，也可以在GitHub中编程解决方案顶部的注释中找到（因为可能需要审查解决方案以完全理解后续问题的答案）。
- en: Chapter 1, Understanding Basic C++ Assumptions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章，理解基本的C++假设
- en: A `flush` may be useful, rather than and `endl`, for clearing the contents of
    a buffer associated with `cout` for the situations where you do not wish the cursor
    to be advanced to the next line for output. Recall, an `endl` manipulator is merely
    a newline character plus a buffer flush.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不希望光标移动到下一行进行输出的情况下，`flush`可能比`endl`更有用，用于清除与`cout`关联的缓冲区的内容。回想一下，`endl`操作符只是一个换行符加上缓冲区刷新。
- en: Choosing a pre versus a post increment for a variable, such as `++i` (versus
    `i++`) will have an impact on the code when used in conjunction with a compound
    expression. A typical example would be `result = array[i++];` versus `result =
    array[++i];`. With the post-increment (`i++`) the contents of `array[i]` will
    be assigned to `result` and then `i` is incremented. With the pre-increment, `i`
    is first incremented and then `result` will have the value of `array[i]` (that
    is, using the new value of `i` as an index).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于变量选择前置递增（`++i`）还是后置递增（`i++`），当与复合表达式一起使用时，会对代码产生影响。一个典型的例子是`result = array[i++];`与`result
    = array[++i];`。在后置递增（`i++`）的情况下，`array[i]`的内容将被分配给`result`，然后`i`递增。在前置递增的情况下，`i`首先递增，然后`result`将具有`array[i]`的值（即使用`i`的新值作为索引）。
- en: Please see `Assessments/Chapter01/Chp1-Q3.cpp` in the GitHub repository.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter01/Chp1-Q3.cpp`。
- en: Chapter 2, Adding Language Necessities
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，添加语言必要性
- en: The signature of a function is the function’s name plus its type and number
    of arguments (no return type). This relates to name mangling as the signature
    helps the compiler provide a unique, internal name for each function. For example,
    `void Print(int, float);` may have mangled name of `Print_int_float();`. This
    facilitates overloaded functions by giving each function a unique name so that
    when a call is made, it is evident by the internal function name as to which function
    is being invoked.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的签名是函数名加上其类型和参数数量（没有返回类型）。这与名称混淆有关，因为签名帮助编译器为每个函数提供一个唯一的内部名称。例如，`void Print(int,
    float);` 可能具有混淆后的名称 `Print_int_float();`。这通过为每个函数提供一个唯一的名称来简化重载函数，使得在调用时，可以通过内部函数名称明显地知道正在调用哪个函数。
- en: a – d. Please see `Assessments/Chapter02/Chp2-Q2.cpp` in the GitHub repository.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – d. 请参阅 GitHub 仓库中的 `Assessments/Chapter02/Chp2-Q2.cpp`。
- en: 'Chapter 3, Indirect Addressing: Pointers'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章，间接寻址：指针
- en: a – f. Please see `Assessments/Chapter03/Chp3-Q1.cpp` in the GitHub repository.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – f. 请参阅 GitHub 仓库中的 `Assessments/Chapter03/Chp3-Q1.cpp`。
- en: d. (follow-up question) `Print(Student)` is less efficient than `Print(const
    Student *)` as the initial version of this function passes an entire object on
    the stack, whereas the overloaded version passes only a pointer on the stack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: d. （后续问题）`Print(Student)` 比重载版本 `Print(const Student *)` 效率低，因为该函数的初始版本在栈上传递整个对象，而重载版本只在栈上传递指针。
- en: 'Assuming we have an existing pointer to an object of type `Student`, such as:
    `Student *s0 = new Student`; (this `Student` is not yet initialized with data)'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个指向类型为 `Student` 的对象的现有指针，例如：`Student *s0 = new Student`; （这个 `Student`
    尚未用数据初始化）
- en: a. `const Student *s1;` (does not require initialization)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: a. `const Student *s1;` （不需要初始化）
- en: b. `Student *const s2 = s0;` (requires initialization)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: b. `Student *const s2 = s0;` （需要初始化）
- en: c. `const Student *const s3 = s0;` (also requires initialization)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: c. `const Student *const s3 = s0;` （也需要初始化）
- en: Passing an argument of type `const Student *` to `Print()` would allow a pointer
    to a `Student` to be passed into `Print()` for speed, yet the object pointed to
    could not be dereferenced and modified. Yet passing a `Student * const` as a parameter
    to `Print()` would not make sense because a copy of the pointer would be passed
    to `Print()`. Marking that copy additionally as `const` (meaning not allowing
    changing where the pointer points) would then be meaningless, as disallowing a
    *copy* of a pointer to be changed has no effect on the original pointer itself.
    The original pointer was never in jeopardy of its address being changed within
    the function.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型为 `const Student *` 的参数传递给 `Print()` 允许将指向 `Student` 的指针传递给 `Print()` 以提高速度，但指向的对象不能被解引用和修改。然而，将
    `Student * const` 作为 `Print()` 的参数传递是没有意义的，因为指针的副本将被传递给 `Print()`。将这个副本标记为 `const`（意味着不允许改变指针指向）将没有意义，因为不允许改变指针副本对原始指针本身没有影响。原始指针在函数内部地址被改变的风险中从未处于危险之中。
- en: There are many programming situations that might use a dynamically allocated
    3-D array. For example, if an image is stored in a 2-D array, a collection of
    images might be stored in a 3-D array. Having a dynamically allocated 3-D array
    allows for any number of images to be read in from a filesystem and stored internally.
    Of course, you’d need to know how many images you’ll be reading in before making
    the 3-D array allocation. For example, a 3-D array might hold 30 images, where
    30 is the third dimension to collect the images in a set. To conceptualize a 4-D
    array, perhaps you would like to organize sets of the aforementioned 3-D arrays.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在许多编程场景中可能会使用动态分配的 3-D 数组。例如，如果图像存储在 2-D 数组中，一组图像可能存储在 3-D 数组中。拥有动态分配的 3-D 数组允许从文件系统中读取任意数量的图像并将其存储在内部。当然，在分配
    3-D 数组之前，你需要知道将要读取多少图像。例如，一个 3-D 数组可能包含 30 张图像，其中 30 是第三维，用于收集一组图像。为了概念化一个 4-D
    数组，你可能希望组织上述 3-D 数组的集合。
- en: For example, perhaps you have a set of 31 images for the month of January. That
    set of January images is a 3-D array (2-D for the image and the third dimension
    for the set of 31 images comprising January). You may wish to do the same for
    every month. Rather than having separate 3-D array variables for each month’s
    image set, we can create a fourth dimension to collect the years’ worth of data
    into one set. The fourth dimension would have an element for each of the 12 months
    of the year. How about a 5-D array? You can extend this image idea by making the
    fifth dimension a way to collect various years of data, such as collecting images
    for a century (fifth dimension). Now we have images organized by century, then
    organized by year, then month, then by image (the image requiring the first two
    dimensions).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许你有一组31张1月份的图片。这组1月份的图片是一个三维数组（二维用于图片，第三维用于组成1月份的31张图片的集合）。你可能希望对每个月都做同样的事情。而不是为每个月的图片集合分别设置单独的三维数组变量，我们可以创建一个第四维来收集一年的数据到一个集合中。第四维将包含一年的12个月份中的一个元素。那么五维数组呢？你可以通过将第五维作为收集不同年份数据的方式扩展这个图像概念，例如收集一个世纪的图片（第五维）。现在我们有按世纪组织的图片，然后按年、按月、按图片（需要前两个维度）组织。
- en: 'Chapter 4, Indirect Addressing: References'
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章，间接寻址：引用
- en: a – c. Please see `Assessments/Chapter04/Chp4-Q1.cpp` in the GitHub repository.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – c. 请参阅GitHub仓库中的`Assessments/Chapter04/Chp4-Q1.cpp`。
- en: c. (follow-up question) Pointer variables need not only call the version of
    `ReadData(Student *)` that accepts a pointer to a `Student` and reference variables
    need not only call the version of `ReadData(Student &)` that accepts a reference
    to a `Student`. For example, a pointer variable may be dereferenced with `*` and
    then call the version that accepts a reference. Likewise, a reference variable
    may have its address taken using `&` and then call the version that accepts a
    pointer (though this is less commonly done). You simply need to make the data
    types match with respect to what you are passing and what the function expects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: c. （后续问题）指针变量不仅需要调用接受`Student`指针的`ReadData(Student *)`版本，引用变量也不需要仅调用接受`Student`引用的`ReadData(Student
    &)`版本。例如，指针变量可以用`*`解引用然后调用接受引用的版本。同样，引用变量可以用`&`取其地址然后调用接受指针的版本（尽管这不太常见）。你只需确保数据类型与你要传递的和函数期望的类型相匹配。
- en: Chapter 5, Exploring Classes in Detail
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章，详细探索类
- en: a – e. Please see `Assessments/Chapter05/Chp5-Q1.cpp` in the GitHub repository.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – e. 请参阅GitHub仓库中的`Assessments/Chapter05/Chp5-Q1.cpp`。
- en: Chapter 6, Implementing Hierarchies with Single Inheritance
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，使用单继承实现层次结构
- en: a – d. Please see `Assessments/Chapter06/Chp6-Q1.cpp` in the GitHub repository.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – d. 请参阅GitHub仓库中的`Assessments/Chapter06/Chp6-Q1.cpp`。
- en: a – c. (Optional) Please see `Chapter06/Assessments/Chp6-Q2.cpp` in the GitHub
    repository.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – c. （可选）请参阅GitHub仓库中的`Chapter06/Assessments/Chp6-Q2.cpp`。
- en: Chapter 7, Utilizing Dynamic Binding through Polymorphism
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，利用多态实现动态绑定
- en: a – e. Please see `Assessments/Chapter07/Chp7-Q1.cpp` in the GitHub repository.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – e. 请参阅GitHub仓库中的`Assessments/Chapter07/Chp7-Q1.cpp`。
- en: Chapter 8, Mastering Abstract Classes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，精通抽象类
- en: a – d. Please see `Assessments/Chapter08/Chp8-Q1.cpp` in the GitHub repository.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – d. 请参阅GitHub仓库中的`Assessments/Chapter08/Chp8-Q1.cpp`。
- en: e. Depending on your implementation, your `Shape` class may or may not be considered
    an interface class. If your implementation is an abstract class that contains
    no data members and only abstract methods (pure virtual functions), your `Shape`
    implementation is considered an interface class. If your `Shape` class, however,
    stores `area` as a data member once it has been calculated by the overridden `Area()`
    method in the derived classes, it is then just an abstract base class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: e. 根据你的实现，你的`Shape`类可能被视为接口类，也可能不是。如果你的实现是一个不包含数据成员且只包含抽象方法（纯虚函数）的抽象类，那么你的`Shape`实现被视为接口类。然而，如果你的`Shape`类在派生类中通过重写的`Area()`方法计算了`area`后将其作为数据成员存储，那么它就只是一个抽象基类。
- en: Chapter 9, Exploring Multiple Inheritance
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，探索多重继承
- en: Please see `Assessments/Chapter09/Chp9-Q1.cpp` in the GitHub repository.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter09/Chp9-Q1.cpp`。
- en: a. There is one `LifeForm` subobject.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: a. 有一个`LifeForm`子对象。
- en: b. The `LifeForm` constructor and destructor are each invoked once.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: b. `LifeForm`构造函数和析构函数各被调用一次。
- en: c. The default constructor for `LifeForm` would be invoked if the specification
    of an alternate constructor of `LifeForm(1000)` was removed from the member initialization
    list of the `Centaur` constructor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果从`Centaur`构造函数的成员初始化列表中移除了对`LifeForm(1000)`的替代构造函数的指定，则将调用`LifeForm`的默认构造函数。
- en: Please see the `Assessments/Chapter09/Chp9-Q2.cpp` in the GitHub repository.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter09/Chp9-Q2.cpp`。
- en: a. There are two `LifeForm` sub-objects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a. 有两个`LifeForm`子对象。
- en: b. The `LifeForm` constructor and destructor are each invoked twice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: b. `LifeForm`构造函数和析构函数各自被调用两次。
- en: Chapter 10, Implementing Association, Aggregation, and Composition
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章，实现关联、聚合和组合
- en: Please see `Assessments/Chapter10/Chp10-Q1.cpp` in the GitHub repository.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter10/Chp10-Q1.cpp`。
- en: (follow-up question) Once you have overloaded a constructor that accepts a `University
    &` as a parameter, this version may be invoked using a `University *` by first
    dereferencing the pointer to the `University` within the constructor call (to
    make a referenceable object).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: （后续问题）一旦您重载了一个接受`University &`作为参数的构造函数，这个版本可以通过首先在构造函数调用中对`University`指针进行解引用（以创建一个可引用的对象）来使用`University
    *`调用。
- en: a – f. Please see `Assessments/Chapter10/Chp10-Q2.cpp` in the GitHub repository.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – f. 请参阅GitHub仓库中的`Assessments/Chapter10/Chp10-Q2.cpp`。
- en: a – b. (optional) Please see `Assessments/Chapter10/Chp10-Q3.cpp` in the GitHub
    repository.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. （可选）请参阅GitHub仓库中的`Assessments/Chapter10/Chp10-Q3.cpp`。
- en: Chapter 11, Handling Exceptions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，处理异常
- en: a – c. Please see `Assessments/Chapter11/Chp11-Q1.cpp` in the GitHub repository.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – c. 请参阅GitHub仓库中的`Assessments/Chapter11/Chp11-Q1.cpp`。
- en: Chapter 12, Friends and Operator Overloading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章，友元和运算符重载
- en: Please see `Assessments/Chapter12/Chp12-Q1.cpp` in the GitHub repository.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter12/Chp12-Q1.cpp`。
- en: Please see `Assessments/Chapter12/Chp12-Q2.cpp` in the GitHub repository.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter12/Chp12-Q2.cpp`。
- en: Please see `Assessments/Chapter12/Chp12-Q3.cpp` in the GitHub repository.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter12/Chp12-Q3.cpp`。
- en: Chapter 13, Working with Templates
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章，使用模板
- en: a – b. Please see `Assessments/Chapter13/Chp13-Q1.cpp` in the GitHub repository.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. 请参阅GitHub仓库中的`Assessments/Chapter13/Chp13-Q1.cpp`。
- en: Please see `Assessments/Chapter13/Chp13-Q2.cpp` in the GitHub repository.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter13/Chp13-Q2.cpp`。
- en: Chapter 14, Understanding STL Basics
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章，理解STL基础
- en: a – b. Please see `Assessments/Chapter14/Chp14-Q1.cpp` in the GitHub repository.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. 请参阅GitHub仓库中的`Assessments/Chapter14/Chp14-Q1.cpp`。
- en: Please see `Assessments/Chapter14/Chp14-Q2.cpp` in the GitHub repository.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter14/Chp14-Q2.cpp`。
- en: Please see `Assessments/Chapter14/Chp14-Q3.cpp` in the GitHub repository.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter14/Chp14-Q3.cpp`。
- en: Please see `Assessments/Chapter14/Chp14-Q4.cpp` in the GitHub repository.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter14/Chp14-Q4.cpp`。
- en: Chapter 15, Testing Classes and Components
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章，测试类和组件
- en: a. Your classes follow orthodox canonical class form if they each include a
    (user-specified) default constructor, copy constructor, overloaded assignment
    operator, and a virtual destructor. Your classes additionally follow extended
    canonical class form if they also include a move copy constructor and an overloaded
    move assignment operator.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 如果您的类包含一个（用户指定的）默认构造函数、拷贝构造函数、重载的赋值运算符和一个虚析构函数，则您的类遵循正交规范类形式。如果它们还包括移动拷贝构造函数和重载的移动赋值运算符，则您的类还遵循扩展规范类形式。
- en: b. Your class will be considered robust if it follows canonical class form and
    ensures that all instances of a class have the means to be fully constructed.
    Testing a class can ensure robustness.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果您的类遵循规范类形式并确保类的所有实例都有完全构造的手段，则您的类将被认为是健壮的。测试一个类可以确保其健壮性。
- en: a – c. Please see `Assessments/Chapter15/Chp15-Q2.cpp` in the GitHub repository.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – c. 请参阅GitHub仓库中的`Assessments/Chapter15/Chp15-Q2.cpp`。
- en: Please see `Assessments/Chapter15/Chp15-Q3.cpp` in the GitHub repository.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter15/Chp15-Q3.cpp`。
- en: Chapter 16, Using the Observer Pattern
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章，使用观察者模式
- en: a – b. Please see `Assessments/Chapter16/Chp16-Q1.cpp` in the GitHub repository.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. 请参阅GitHub仓库中的`Assessments/Chapter16/Chp16-Q1.cpp`。
- en: Other examples which may easily incorporate the Observer pattern include any
    application requiring customers to receive notification of backordered products
    that they desire. For example, many people may wish to receive the Covid-19 vaccine
    and wish to be on a waiting list at a vaccine distribution site. Here, a `VaccineDistributionSite`
    (the subject of interest) can be inherited from `Subject` and contain a list of
    `Person` objects, where `Person` inherits from `Observer`. The `Person` objects
    will contain a pointer to the `VaccineDistributionSite`. Once enough supply for
    the vaccine exists at a given `VaccineDistributionSite` (that is, a distribution
    event has occurred), `Notify()` can be called to update the `Observer` instances
    (people on the waitlist). Each `Observer` will be sent an `Update()`, which will
    be the means to allow that person to schedule an appointment. If the `Update()`
    returns success and the `Person` has been scheduled for an appointment, the `Observer`
    can release itself from the waiting list with the `Subject`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能容易融入观察者模式的例子包括任何需要客户接收他们所希望的后备产品通知的应用程序。例如，许多人可能希望接种新冠疫苗，并希望在疫苗分发点的等待名单上。在这里，一个`VaccineDistributionSite`（感兴趣的主体）可以继承自`Subject`并包含一个`Person`对象列表，其中`Person`继承自`Observer`。`Person`对象将包含一个指向`VaccineDistributionSite`的指针。一旦在某个`VaccineDistributionSite`（即，发生了分发事件）有足够的疫苗供应，就可以调用`Notify()`来更新`Observer`实例（等待名单上的人）。每个`Observer`都将收到一个`Update()`，这将允许那个人安排预约。如果`Update()`返回成功并且`Person`已经安排了预约，`Observer`可以使用`Subject`从等待名单中释放自己。
- en: Chapter 17, Applying the Factory Pattern
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章，应用工厂模式
- en: a – b. Please see `Assessments/Chapter17/Chp17-Q1.cpp` in the GitHub repository.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. 请参阅GitHub仓库中的`Assessments/Chapter17/Chp17-Q1.cpp`。
- en: Other examples which may easily incorporate the Factory Method pattern include
    many types of applications in which various derived classes may need to be instantiated
    based upon the specific values provided at construction. For example, a payroll
    application may require various types of `Employee` instances, such as `Manager`,
    `Engineer`, `Vice-President`, and so on. A factory method can provide a way to
    instantiate the various types of `Employee` based on the information provided
    when the `Employee` is hired. The Factory Method pattern is a pattern that can
    be applied to many types of applications.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能容易融入工厂方法模式的例子包括许多类型的应用程序，这些应用程序可能需要根据构造时提供的特定值实例化各种派生类。例如，一个工资单应用程序可能需要各种类型的`Employee`实例，如`Manager`、`Engineer`、`Vice-President`等。工厂方法可以提供一种根据在雇佣`Employee`时提供的信息实例化各种类型`Employee`的方法。工厂方法模式是一种可以应用于许多类型应用程序的模式。
- en: Chapter 18, Applying the Adapter Pattern
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章，应用适配器模式
- en: a – b. Please see `Assessments/Chapter18/Chp18-Q1.cpp` in the GitHub repository.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – b. 请参阅GitHub仓库中的`Assessments/Chapter18/Chp18-Q1.cpp`。
- en: Other examples which may easily incorporate the Adapter pattern include many
    examples of repurposing existing, well tested non-OO code to provide an OO interface
    (that is, a wrapper type of Adapter). Other examples include creating an Adapter
    to convert a formerly used class into a currently needed class (again with the
    idea of reusing previously created and well-tested components). An example is
    to adapt a `Car` class that has been previously used to represent gasoline engine
    cars into a class that models an `ElectricCar`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能容易融入适配器模式的例子包括许多将现有经过良好测试的非OO代码重新用于提供OO接口（即，适配器类型的包装器）的例子。其他例子包括创建一个适配器将以前使用的类转换为当前所需的类（再次使用重用先前创建和经过良好测试的组件的想法）。一个例子是将以前用于表示汽油发动机汽车的`Car`类适配为一个表示`ElectricCar`的类。
- en: Chapter 19, Using the Singleton Pattern
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章，使用单例模式
- en: a – c. Please see `Assessments/Chapter19/Chp19-Q1.cpp` in the GitHub repository.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – c. 请参阅GitHub仓库中的`Assessments/Chapter19/Chp19-Q1.cpp`。
- en: We cannot label the `static instance()` method as virtual in `Singleton` and
    override it in `President`, simply because static methods can never be virtual.
    They are statically bound, and never receive a `this` pointer. Also, the signature
    may need to be different (and no one likes an un-intentional function hiding situation).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能将`Singleton`中的`static instance()`方法标记为虚拟并在`President`中重写它，仅仅是因为静态方法永远不能是虚拟的。它们是静态绑定的，并且永远不会接收一个`this`指针。此外，签名可能需要不同（没有人喜欢意外隐藏函数的情况）。
- en: Other examples which may easily incorporate the Singleton pattern include creating
    a Singleton `CEO` of a company, a Singleton `TreasuryDepartment` for a country,
    or a Singleton `Queen` of a nation. Each of these Singleton instances offers the
    opportunity to establish a registry to keep track of multiple Singleton objects.
    That is, many countries may have a single `Queen`. In this case, the registry
    would allow not just one Singleton per object type, but one Singleton per other
    qualifiers, such as *nation*. This is an example of the rare case in which more
    than one Singleton object of a given type can occur (but always a controlled number
    of such objects).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能容易融入单例模式的例子包括创建一个公司的单例`CEO`、一个国家的单例`TreasuryDepartment`，或者一个国家的单例`Queen`。这些单例实例都提供了建立注册表以跟踪多个单例对象的机会。也就是说，许多国家可能只有一个`Queen`。在这种情况下，注册表不仅允许每个对象类型只有一个单例，而且允许每个其他限定符（如*国家*）只有一个单例。这是一个罕见的情况，其中给定类型的多个单例对象可以出现（但总是受控数量的对象）。
- en: Chapter 20, Removing Implementation Details Using the pImpl Pattern
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章，使用pImpl模式去除实现细节
- en: Please see `Assessments/Chapter20/Chp20-Q1.cpp` in the GitHub repository.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter20/Chp20-Q1.cpp`。
- en: Please see `Assessments/Chapter20/Chp20-Q2.cpp` in the GitHub repository.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的`Assessments/Chapter20/Chp20-Q2.cpp`。
- en: (follow-up question) In this chapter, simply inheriting `Student` from the `Person`
    class that embraces the pImpl pattern presents no logistical difficulties. Additionally,
    modifying the `Student` class to also employ the pImpl pattern and utilize a unique
    pointer is more challenging. Various approaches may run across various difficulties,
    including dealing with inline functions, down-casting, avoiding explicit calls
    to the underlying implementation, or requiring back pointers to help invoke virtual
    functions. Please see the online solution for details.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: （后续问题）在本章中，简单地从采用pImpl模式的`Person`类继承`Student`类不会带来任何物流困难。此外，修改`Student`类以也采用pImpl模式并使用唯一指针更具挑战性。可能遇到各种困难，包括处理内联函数、向下转型、避免显式调用底层实现，或者需要回指针来帮助调用虚函数。请参阅在线解决方案以获取详细信息。
- en: Other examples which may easily incorporate the pImpl pattern for relative implementation
    independence include creating generic GUI components, such as for `Window`, `Scrollbar`,
    `Textbox`, and so on, for various platforms (derived classes). The implementation
    details can easily be hidden. Another example could be proprietary commercial
    classes in which the developer wishes to hide the implementation details that
    might otherwise be seen in a header file.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能容易融入pImpl模式以实现相对独立实现的例子包括创建通用的GUI组件，例如`Window`、`Scrollbar`、`Textbox`等，用于各种平台（派生类）。实现细节可以轻松隐藏。另一个例子可能是开发者希望隐藏在头文件中可能看到的实现细节的专有商业类。
