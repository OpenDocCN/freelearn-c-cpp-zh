["```cpp\n//---- SmartFloat.cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass SmartFloat {\n     double _value; // underlying store\n   public:\n      SmartFloat(double value) : _value(value) {}\n      SmartFloat() : _value(0) {}\n      SmartFloat( const SmartFloat& other ) { _value = other._value; }\n      SmartFloat& operator = ( const SmartFloat& other ) {\n          if ( this != &other ) { _value = other._value;}\n          return *this;\n      }\n      SmartFloat& operator = (double value )\n       { _value = value; return *this;}\n      ~SmartFloat(){ }\n```", "```cpp\n      SmartFloat& operator ++ () { _value++; return *this; }\n      SmartFloat operator ++ (int) { // postfix operator\n             SmartFloat nu(*this); ++_value; return nu;\n      }\n      SmartFloat& operator -- () { _value--; return *this; }\n      SmartFloat operator -- (int) {\n           SmartFloat nu(*this); --_value; return nu;\n      }\n```", "```cpp\n     SmartFloat& operator += ( double x ) { _value += x; return *this;}\n     SmartFloat& operator -= ( double x ) { _value -= x;return *this; }\n     SmartFloat& operator *= ( double x ) { _value *= x; return *this;}\n     SmartFloat& operator /= ( double x ) { _value /= x; return *this;}\n```", "```cpp\n      bool operator > ( const SmartFloat& other )\n        { return _value > other._value; }\n      bool operator < ( const SmartFloat& other )\n       {return _value < other._value;}\n      bool operator == ( const SmartFloat& other )\n        { return _value == other._value;}\n      bool operator != ( const SmartFloat& other )\n        { return _value != other._value;}\n      bool operator >= ( const SmartFloat& other )\n        { return _value >= other._value;}\n      bool operator <= ( const SmartFloat& other )\n        { return _value <= other._value;}\n```", "```cpp\n      operator int () { return _value; }\n      operator double () { return _value;}\n};\n```", "```cpp\ndouble Accumulate( double a[] , int count ){\n    double value = 0;\n    for( int i=0; i<count; ++i) { value += a[i]; }\n    return value;\n}\ndouble Accumulate( SmartFloat a[] , int count ){\n    SmartFloat value = 0;\n    for( int i=0; i<count; ++i) { value += a[i]; }\n    return value;\n}\nint main() {\n    // using C++ 1z's initializer list\n    double x[] = { 10.0,20.0,30,40 };\n    SmartFloat y[] = { 10,20.0,30,40 };\n    double res = Accumulate(x,4); // will call the double version\n    cout << res << endl;\n    res = Accumulate(y,4); // will call the SmartFloat version\n    cout << res << endl;\n}\n```", "```cpp\n//------------- from SmartValue.cpp\ntemplate <class T>\nT Accumulate( T a[] , int count ) {\n    T value = 0;\n    for( int i=0; i<count; ++i) { value += a[i]; }\n    return value;\n}\nint main(){\n    //----- Templated version of SmartFloat\n    SmartValue<double> y[] = { 10,20.0,30,40 };\n    double res = Accumulate(y,4);\n    cout << res << endl;\n}\n```", "```cpp\n//----- AutoFirst.cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n    vector<string> vt = {\"first\", \"second\", \"third\", \"fourth\"};\n    //--- Explicitly specify the Type ( makes it verbose)\n    for (vector<string>::iterator it = vt.begin();\n        it != vt.end(); ++it)\n    cout << *it << \" \";\n    //--- Let the compiler infer the type for us\n    for (auto it2 = vt.begin(); it2 != vt.end(); ++it2)\n        cout << *it2 << \" \";\n    return 0;\n}\n```", "```cpp\n//----- AutoSecond.cpp\n#include <iostream>\n#include <vector>\n#include <initializer_list>\nusing namespace std;\nint main() {\n    vector<double> vtdbl = {0, 3.14, 2.718, 10.00};\n    auto vt_dbl2 = vtdbl; // type will be deduced\n    auto size = vt_dbl2.size(); // size_t\n    auto &rvec = vtdbl; // specify a auto reference\n    cout << size << endl;\n    // Iterate - Compiler infers the type\n    for ( auto it = vtdbl.begin(); it != vtdbl.end(); ++it)\n        cout << *it << \" \";\n    // 'it2' evaluates to iterator to vector of double\n    for (auto it2 = vt_dbl2.begin(); it2 != vt_dbl2.end(); ++it2)\n        cout << *it2 << \" \";\n    // This will change the first element of vtdbl vector\n    rvec[0] = 100;\n    // Now Iterate to reflect the type\n    for ( auto it3 = vtdbl.begin(); it3 != vtdbl.end(); ++it3)\n        cout << *it3 << \" \";\n    return 0;\n}\n```", "```cpp\n//---- Decltype.cpp\n#include <iostream>\nusing namespace std;\nint foo() { return 10; }\nchar bar() { return 'g'; }\nauto fancy() -> decltype(1.0f) { return 1;} //return type is float\nint main() {\n    // Data type of x is same as return type of foo()\n    // and type of y is same as return type of bar()\n    decltype(foo()) x;\n    decltype(bar()) y;\n    //--- in g++, Should print i => int\n    cout << typeid(x).name() << endl;\n    //--- in g++, Should print c => char \n    cout << typeid(y).name() << endl;\n    struct A { double x; };\n    const A* a = new A();\n    decltype(a->x) z; // type is double\n    decltype((a->x)) t= z; // type is const double&\n    //--- in g++, Should print  d => double\n    cout << typeid(z).name() << endl;\n    cout << typeid(t).name() << endl;\n    //--- in g++, Should print  f => float\n    cout << typeid(decltype(fancy())).name() << endl;\n    return 0;\n}\n```", "```cpp\n//----------------Initialization.cpp\n#include <iostream>\n#include <vector>\n#include <initializer_list>\nusing namespace std;\ntemplate <class T>\nstruct Vector_Wrapper {\n    std::vector<T> vctr;\n    Vector_Wrapper(std::initializer_list<T> l) : vctr(l) {}\n    void Append(std::initializer_list<T> l)\n    { vctr.insert(vctr.end(), l.begin(), l.end());}\n};\nint main() {\n    Vector_Wrapper<int> vcw = {1, 2, 3, 4, 5}; // list-initialization\n    vcw.Append({6, 7, 8}); // list-initialization in function call\n    for (auto n : vcw.vctr) { std::cout << n << ' '; }\n    std::cout << '\\n';\n}\n```", "```cpp\n//Variadic.cpp\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n//--- add given below is a base case for ending compile time\n//--- recursion\nint add() { return 0; } // end condition\n//---- Declare a Variadic function Template\n//---- ... is called parameter pack. The compiler\n//--- synthesize a function based on the number of arguments\n//------ given by the programmer.\n//----- decltype(auto) => Compiler will do Type Inference\ntemplate<class T0, class ... Ts>\ndecltype(auto) add(T0 first, Ts ... rest) {\n    return first + add(rest ...);\n}\nint main() { int n = add(0,2,3,4); cout << n << endl; }\n```", "```cpp\n//Variadic2.cpp\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n//--------- Print values to the console for basic types\n//-------- These are base case versions\nvoid EmitConsole(int value) { cout << \"Integer: \" << value << endl; }\nvoid EmitConsole(double value) { cout << \"Double: \" << value << endl; }\nvoid EmitConsole(const string& value){cout << \"String: \"<<value<< endl; }\n```", "```cpp\ntemplate<typename T>\nvoid EmitValues(T&& arg) { EmitConsole(std::forward<T>(arg)); }\n\ntemplate<typename T1, typename... Tn>\nvoid EmitValues(T1&& arg1, Tn&&... args){\n    EmitConsole(std::forward<T1>(arg1));\n    EmitValues(std::forward<Tn>(args)...);\n}\n\nint main() { EmitValues(0,2.0,\"Hello World\",4); }\n```", "```cpp\n//---- Lvalue.cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int i=0;\n  cout << i << endl; //prints 0\n  int& ri = i;\n  ri = 20;\n  cout << i << endl; // prints 20\n}\n```", "```cpp\n///---- Rvaluref.cpp\n#include <iostream>using namespace std;\nint main() {\n    int&& j = 42;int x = 3,y=5; int&& z = x + y; cout << z << endl;\n    z = 10; cout << z << endl;j=20;cout << j << endl;\n}\n```", "```cpp\n//------- RvaluerefCall.cpp\n#include <iostream>\nusing namespace std;\nvoid TestFunction( int & a ) {cout << a << endl;}\nvoid TestFunction( int && a ){\n    cout << \"rvalue references\" << endl;\n    cout << a << endl;\n}\nint main() {\nint&& j = 42;\nint x = 3,y=5;\nint&& z = x + y;\n    TestFunction(x + y ); // Should call rvalue reference function\n    TestFunction(j); // Calls Lvalue Refreence function\n}\n```", "```cpp\n//----- FloatBuffer.cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass FloatBuffer {\n    double *bfr; int count;\npublic:\n    FloatBuffer():bfr(nullptr),count(0){}\n    FloatBuffer(int pcount):bfr(new double[pcount]),count(pcount){}\n        // Copy constructor.\n    FloatBuffer(const FloatBuffer& other) : count(other.count)\n        , bfr(new double[other.count])\n    { std::copy(other.bfr, other.bfr + count, bfr); }\n    // Copy assignment operator - source code is obvious\n    FloatBuffer& operator=(const FloatBuffer& other) {\n        if (this != &other) {\n          if ( bfr != nullptr) \n            delete[] bfr; // free memory of the current object\n            count = other.count;\n            bfr = new double[count]; //re-allocate\n            std::copy(other.bfr, other.bfr + count, bfr);\n        }\n        return *this;\n    }\n    // Move constructor to enable move semantics\n    // The Modern STL containers supports move sementcis\n    FloatBuffer(FloatBuffer&& other) : bfr(nullptr) , count(0) {\n    cout << \"in move constructor\" << endl;\n    // since it is a move constructor, we are not copying elements from\n    // the source object. We just assign the pointers to steal memory\n    bfr = other.bfr;\n    count = other.count;\n    // Now that we have grabbed our memory, we just assign null to\n    // source pointer\n    other.bfr = nullptr;\n    other.count = 0;\n    }\n// Move assignment operator.\nFloatBuffer& operator=(FloatBuffer&& other) {\n    if (this != &other)\n    {\n        // Free the existing resource.\n        delete[] bfr;\n       // Copy the data pointer and its length from the\n       // source object.\n       bfr = other.bfr;\n       count = other.count;\n       // We have stolen the memory, now set the pinter to null\n       other.bfr = nullptr;\n       other.count = 0;\n    }\n    return *this;\n}\n\n};\nint main() {\n    // Create a vector object and add a few elements to it.\n    // Since STL supports move semantics move methods will be called.\n    // in this particular case (Modern Compilers are smart)\n    vector<FloatBuffer> v;\n    v.push_back(FloatBuffer(25));\n    v.push_back(FloatBuffer(75));\n}\n```", "```cpp\n//---- Unique_Ptr.cpp\n#include <iostream>\n#include <deque>#include <memory>\nusing namespace std;\nint main( int argc , char **argv ) {\n    // Define a Smart Pointer for STL deque container...\n    unique_ptr< deque<int> > dq(new deque<int>() );\n    //------ populate values , leverages -> operator\n    dq->push_front(10); dq->push_front(20);\n    dq->push_back(23); dq->push_front(16);\n    dq->push_back(41);\n    auto dqiter = dq->begin();\n    while ( dqiter != dq->end())\n    { cout << *dqiter << \"\\n\"; dqiter++; }\n    //------ SmartPointer will free reference\n    //------ and it's dtor will be called here\n    return 0;\n}\n```", "```cpp\n//----- Shared_Ptr.cpp\n#include <iostream>\n#include <memory>\n#include <stdio.h>\nusing namespace std;\n////////////////////////////////////////\n// Even If you pass shared_ptr<T> instance\n// by value, the update is visible to callee\n// as shared_ptr<T>'s copy constructor reference\n// counts to the orgininal instance\n//\n\nvoid foo_byvalue(std::shared_ptr<int> i) { (*i)++;}\n\n///////////////////////////////////////\n// passed by reference,we have not\n// created a copy.\n//\nvoid foo_byreference(std::shared_ptr<int>& i) { (*i)++; }\nint main(int argc, char **argv )\n{\n    auto sp = std::make_shared<int>(10);\n    foo_byvalue(sp);\n    foo_byreference(sp);\n    //--------- The output should be 12\n    std::cout << *sp << std::endl;\n}\n```", "```cpp\n//------- Weak_Ptr.cpp\n#include <iostream>\n#include <deque>\n#include <memory>\n\nusing namespace std;\nint main( int argc , char **argv )\n{\n    std::shared_ptr<int> ptr_1(new int(500));\n    std::weak_ptr<int> wptr_1 = ptr_1;\n    {\n        std::shared_ptr<int> ptr_2 = wptr_1.lock();\n        if(ptr_2)\n        {\n            cout << *ptr_2 << endl; // this will be exeucted\n        }\n    //---- ptr_2 will go out of the scope\n    }\n\n    ptr_1.reset(); //Memory is deleted.\n\n    std::shared_ptr<int> ptr_3= wptr_1.lock();\n    //-------- Always else part will be executed\n    //-------- as ptr_3 is nullptr now \n    if(ptr_3)\n        cout << *ptr_3 << endl;\n    else\n        cout << \"Defunct Pointer\" << endl;\n    return 0;\n}\n```", "```cpp\n//LambdaFirst.cpp\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\n    auto num_vect =\n        vector<int>{ 10, 23, -33, 15, -7, 60, 80};\n    //---- Define a Lambda Function to Filter out negatives\n    auto filter = [](int const value) {return value > 0; };\n    auto cnt= count_if(\n        begin(num_vect), end(num_vect),filter);\n    cout << cnt << endl;\n}\n```", "```cpp\n//-------------- LambdaSecond.cpp\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\nint main() {\n    auto num_vect =\n        vector<int>{ 10, 23, -33, 15, -7, 60, 80};\n    //-- Define a BinaryOperation Lambda at the call site\n    auto accum = std::accumulate(\n        std::begin(num_vect), std::end(num_vect), 0,\n        [](auto const s, auto const n) {return s + n;});\n    cout << accum << endl;\n}\n```", "```cpp\n//----- LambdaThird.cpp\n#include <iostream>\n#include <numeric>\nusing namespace std;\n//////////////////////////\n// Functors to add and multiply two numbers\ntemplate <typename T>\nstruct addition{\n    T operator () (const T& init, const T& a ) { return init + a; }\n};\ntemplate <typename T>\nstruct multiply {\n    T operator () (const T& init, const T& a ) { return init * a; }\n};\nint main()\n{\n    double v1[3] = {1.0, 2.0, 4.0}, sum;\n    sum = accumulate(v1, v1 + 3, 0.0, addition<double>());\n    cout << \"sum = \" << sum << endl;\n    sum = accumulate(v1,v1+3,0.0, [] (const double& a ,const double& b   ) {\n        return a +b;\n    });\n    cout << \"sum = \" << sum << endl;\n    double mul_pi = accumulate(v1, v1 + 3, 1.0, multiply<double>());\n    cout << \"mul_pi = \" << mul_pi << endl;\n    mul_pi= accumulate(v1,v1+3,1, [] (const double& a , const double& b ){\n        return a *b;\n    });\n    cout << \"mul_pi = \" << mul_pi << endl;\n}\n```", "```cpp\n/////////////////\n//-------- LambdaFourth.cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n//--- Generic functions for Comparison and Swap\ntemplate <typename T>\nbool Cmp( T& a , T&b ) {return ( a > b ) ? true: false;}\ntemplate <typename T>\nvoid Swap( T& a , T&b ) { T c = a;a = b;b = c;}\n```", "```cpp\ntemplate <typename T>\nvoid BubbleSortFunctor( T *arr , int length ) {\n    for( int i=0; i< length-1; ++i )\n        for(int j=i+1; j< length; ++j )\n            if ( Cmp( arr[i] , arr[j] ) )\n                Swap(arr[i],arr[j] );\n}\n```", "```cpp\ntemplate <typename T>\nvoid BubbleSortLambda( T *arr , int length ) {\n    auto CmpLambda = [] (const auto& a , const auto& b )\n    { return ( a > b ) ? true: false; };\n    auto SwapLambda = [] ( auto& a , auto& b )\n    { auto c = a;a = b;b = c;};\n    for( int i=0; i< length-1; ++i )\n        for(int j=i+1; j< length; ++j )\n            if ( CmpLambda( arr[i] , arr[j] ) )\n                SwapLambda (arr[i],arr[j] );\n}\n```", "```cpp\ntemplate <typename T>\nvoid Print( const T& container){\n    for(auto i = container.begin() ; i != container.end(); ++i )\n        cout << *i << \"\\n\" ;\n}\n```", "```cpp\nint main( int argc , char **argv ){\n    double ar[4] = {20,10,15,-41};\n    BubbleSortFunctor(ar,4);\n    vector<double> a(ar,ar+4);\n    Print(a);\n    cout << \"=========================================\" << endl;\n    ar[0] = 20;ar[1] = 10;ar[2] = 15;ar[3] = -41;\n    BubbleSortLambda(ar,4);\n    vector<double> a1(ar,ar+4);\n    Print(a1);\n    cout << \"=========================================\" << endl;\n}\n```", "```cpp\n//------------ Compose.cpp\n//----- g++ -std=c++1z Compose.cpp\n#include <iostream>\nusing namespace std;\n//---------- base case compile time recursion\n//---------- stops here\ntemplate <typename F, typename G>\nauto Compose(F&& f, G&& g)\n{ return [=](auto x) { return f(g(x)); };}\n//----- Performs compile time recursion based\n//----- on number of parameters\ntemplate <typename F, typename... R>\nauto Compose(F&& f, R&&... r){\n    return [=](auto x) { return f(Compose(r...)(x)); };\n}\n```", "```cpp\nauto CurriedAdd3(int x) {\n    return [x](int y) { //capture x\n        return [x, y](int z){ return x + y + z; };\n    };\n};\n```", "```cpp\ntemplate <typename... Ts>\nauto PartialFunctionAdd3(Ts... xs) {\n    //---- http://en.cppreference.com/w/cpp/language/parameter_pack\n    //---- http://en.cppreference.com/w/cpp/language/sizeof...\n    static_assert(sizeof...(xs) <= 3);\n    if constexpr (sizeof...(xs) == 3){\n        // Base case: evaluate and return the sum.\n        return (0 + ... + xs);\n    }\n    else{\n        // Recursive case: bind `xs...` and return another\n        return [xs...](auto... ys){\n            return PartialFunctionAdd3(xs..., ys...);\n        };\n    }\n}\nint main() {\n    // ------------- Compose two functions together\n    //----https://en.wikipedia.org/wiki/Function_composition\n    auto val = Compose(\n        [](int const a) {return std::to_string(a); },\n        [](int const a) {return a * a; })(4); // val = \"16\"\n    cout << val << std::endl; //should print 16\n    // ----------------- Invoke the Curried function\n    auto p = CurriedAdd3(4)(5)(6);\n    cout << p << endl;\n    //-------------- Compose a set of function together\n    auto func = Compose(\n        [](int const n) {return std::to_string(n); },\n        [](int const n) {return n * n; },\n        [](int const n) {return n + n; },\n        [](int const n) {return std::abs(n); });\n    cout << func(5) << endl;\n    //----------- Invoke Partial Functions giving different arguments\n    PartialFunctionAdd3(1, 2, 3);\n    PartialFunctionAdd3(1, 2)(3);\n    PartialFunctionAdd3(1)(2)(3);\n}\n```", "```cpp\n//---------------- FuncWrapper.cpp Requires C++ 17 (-std=c++1z )\n#include <functional>\n#include <iostream>\nusing namespace std;\n//-------------- Simple Function call\nvoid PrintNumber(int val){ cout << val << endl; }\n// ------------------ A class which overloads function operator\nstruct PrintNumber {\n    void operator()(int i) const { std::cout << i << '\\n';}\n};\n//------------ To demonstrate the usage of method call\nstruct FooClass {\n    int number;\n    FooClass(int pnum) : number(pnum){}\n    void PrintNumber(int val) const { std::cout << number + val<< endl; }\n};\nint main() {\n    // ----------------- Ordinary Function Wrapped\n    std::function<void(int)> \n    displaynum = PrintNumber;\n    displaynum(0xF000);\n    std::invoke(displaynum,0xFF00); //call through std::invoke\n    //-------------- Lambda Functions Wrapped\n    std::function<void()> lambdaprint = []() { PrintNumber(786); };\n        lambdaprint();\n        std::invoke(lambdaprint);\n        // Wrapping member functions of a class\n        std::function<void(const FooClass&, int)>\n        class display = &FooClass::PrintNumber;\n        // creating an instance\n        const FooClass fooinstance(100);\n        class display (fooinstance,100);\n}\n```", "```cpp\n//---- PipeFunc2.cpp\n//-------- g++ -std=c++1z PipeFunc2.cpp\n#include <iostream>\nusing namespace std;\n\nstruct AddOne {\n    template<class T>\n    auto operator()(T x) const { return x + 1; }\n};\nstruct SumFunction {\n    template<class T>\n    auto operator()(T x,T y) const { return x + y;} // Binary Operator\n};\n```", "```cpp\n//-------------- Create a Pipable Closure Function (Unary)\n//-------------- Uses Variadic Templates Paramter pack\ntemplate<class F>\nstruct PipableClosure : F{\n    template<class... Xs>\n    PipableClosure(Xs&&... xs) : // Xs is a universal reference\n    F(std::forward<Xs>(xs)...) // perfect forwarding\n    {}\n};\n//---------- A helper function which converts a Function to a Closure\ntemplate<class F>\nauto MakePipeClosure(F f)\n{ return PipableClosure<F>(std::move(f)); }\n// ------------ Declare a Closure for Binary\n//------------- Functions\n//\ntemplate<class F>\nstruct PipableClosureBinary {\n    template<class... Ts>\n    auto operator()(Ts... xs) const {\n        return MakePipeClosure([=](auto x) -> decltype(auto)\n        { return F()(x, xs...);}); }\n};\n//------- Declare a pipe operator\n//------- uses perfect forwarding to invoke the function\ntemplate<class T, class F> //---- Declare a pipe operator\ndecltype(auto) operator|(T&& x, const PipableClosure<F>& pfn)\n{ return pfn(std::forward<T>(x)); }\n\nint main() {\n    //-------- Declare a Unary Function Closure\n    const PipableClosure<AddOne> fnclosure = {};\n    int value = 1 | fnclosure| fnclosure;\n    std::cout << value << std::endl;\n    //--------- Decalre a Binary function closure\n    const PipableClosureBinary<SumFunction> sumfunction = {};\n    int value1 = 1 | sumfunction(2) | sumfunction(5) | fnclosure;\n    std::cout << value1 << std::endl;\n}\n```", "```cpp\n//---------------- Folds.cpp\n//--------------- Requires C++ 17 (-std=c++1z )\n//--------------- http://en.cppreference.com/w/cpp/language/fold\n#include <functional>\n#include <iostream>\n\nusing namespace std;\ntemplate <typename... Ts>\nauto AddFoldLeftUn(Ts... args) { return (... + args); }\ntemplate <typename... Ts>\nauto AddFoldLeftBin(int n,Ts... args){ return (n + ... + args);}\ntemplate <typename... Ts>\nauto AddFoldRightUn(Ts... args) { return (args + ...); }\ntemplate <typename... Ts>\nauto AddFoldRightBin(int n,Ts... args) { return (args + ... + n); }\ntemplate <typename T,typename... Ts>\nauto AddFoldRightBinPoly(T n,Ts... args) { return (args + ... + n); }\ntemplate <typename T,typename... Ts>\nauto AddFoldLeftBinPoly(T n,Ts... args) { return (n + ... + args); }\n\nint main() {\n    auto a = AddFoldLeftUn(1,2,3,4);\n    cout << a << endl;\n    cout << AddFoldRightBin(a,4,5,6) << endl;\n    //---------- Folds from Right\n    //---------- should produce \"Hello  World C++\"\n    auto b = AddFoldRightBinPoly(\"C++ \"s,\"Hello \"s,\"World \"s );\n    cout << b << endl;\n    //---------- Folds (Reduce) from Left\n    //---------- should produce \"Hello World C++\"\n    auto c = AddFoldLeftBinPoly(\"Hello \"s,\"World \"s,\"C++ \"s );\n    cout << c << endl;\n}\n```", "```cpp\n10\n 25\n Hello World C++\n Hello World C++\n```", "```cpp\n//------------ Variant.cpp\n//------------- g++ -std=c++1z Variant.cpp\n#include <variant>\n#include <string>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nint main(){\n    std::variant<int, float,string> v, w;\n    v = 12.0f; // v contains now contains float\n    cout << std::get<1>(v) << endl;\n    w = 20; // assign to int\n    cout << std::get<0>(w) << endl;\n    w = \"hello\"s; //assign to string\n    cout << std::get<2>(w) << endl;\n}\n```", "```cpp\n// Iterobservable.cpp\n// we can use Range Based For loop as given below (see the main below)\n// for (auto l : EnumerableRange<5, 25>()) { std::cout << l << ' '; }\n// std::cout << endl;\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntemplate<long START, long END>\nclass EnumerableRange {\npublic:\n\n    class iterable : public std::iterator<\n        std::input_iterator_tag, // category\n        long, // value_type\n        long, // difference_type\n        const long*, // pointer type\n        long> // reference type\n        {\n            long current_num = START;\n            public:\n                reference operator*() const { return current_num; }\n                explicit iterable(long val = 0) : current_num(val) {}\n                iterable& operator++() {\n                    current_num = ( END >= START) ? current_num + 1 :\n                        current_num - 1;\n                return *this;\n            }\n            iterable operator++(int) {\n                iterable retval = *this; ++(*this); return retval;\n            }\n            bool operator==(iterable other) const\n                { return current_num == other.current_num; }\n            bool operator!=(iterable other) const\n                { return !(*this == other); }\n    };\n```", "```cpp\niterable begin() { return iterable(START); }\n    iterable end() { return iterable(END >= START ? END + 1 :\n        END - 1); }\n};\n```", "```cpp\nfor (long l : EnumerableRange<5, 25>())\n    { std::cout << l << ' '; }\n```", "```cpp\nstruct OBSERVER {\n    std::function<void(const long&)> ondata;\n    std::function<void()> oncompleted;\n    std::function<void(const std::exception &)> onexception;\n};\n```", "```cpp\ntemplate<long START, long END>\nclass ObservableRange {\n    private:\n        //---------- Container to store observers\n        std::vector<\n            std::pair<const OBSERVER&,int>> _observers;\n        int _id = 0;\n```", "```cpp\n//---- The following implementation of iterable does\n//---- not allow to take address of the pointed value [ &(*it)\n//---- Eg- &(*iterable.begin()) will be ill-formed\n//---- Code is just for demonstrate Obervable/Observer\nclass iterable : public std::iterator<\n    std::input_iterator_tag, // category\n    long, // value_type\n    long, // difference_type\n    const long*, // pointer type\n    long> // reference type\n    {\n        long current_num = START;\n    public:\n        reference operator*() const { return current_num; }\n        explicit iterable(long val = 0) : current_num(val) {}\n        iterable& operator++() {\n            current_num = ( END >= START) ? current_num + 1 :\n                current_num - 1;\n            return *this;\n        }\n        iterable operator++(int) {\n            iterable retval = *this; ++(*this); return retval;\n        }\n        bool operator==(iterable other) const\n            { return current_num == other.current_num; }\n        bool operator!=(iterable other) const\n            { return !(*this == other); }\n        };\n    iterable begin() { return iterable(START); }\n    iterable end() { return iterable(END >= START ? END + 1 : END - 1); }\n// generate values between the range\n// This is a private method and will be invoked from the generate\n// ideally speaking, we should invoke this method with std::asnyc\nvoid generate_async()\n{\n    auto& subscribers = _observers;\n    for( auto l : *this )\n        for (const auto& obs : subscribers) {\n            const OBSERVER& ob = obs.first;\n            ob.ondata(l);\n    }\n}\n\n//----- The public interface of the call include generate which triggers\n//----- the generation of the sequence, subscribe/unsubscribe pair\npublic:\n    //-------- the public interface to trigger generation\n    //-------- of thevalues. The generate_async can be executed\n    //--------- via std::async to return to the caller\n    void generate() { generate_async(); }\n    //---------- subscribe method. The clients which\n    //----------- expects notification can register here\n    int subscribe(const OBSERVER& call) {\n        // https://en.cppreference.com/w/cpp/container/vector/emplace_back\n        _observers.emplace_back(call, ++_id);\n        return _id;\n    }\n    //------------ has just stubbed unsubscribe to keep\n    //------------- the listing small\n    void unsubscribe(const int subscription) {}\n\n};\n\nint main() {\n    //------ Call the Range based enumerable\n    for (long l : EnumerableRange<5, 25>())\n        { std::cout << l << ' '; }\n    std::cout << endl;\n    // instantiate an instance of ObservableRange\n    auto j = ObservableRange<10,20>();\n    OBSERVER test_handler;\n    test_handler.ondata = [=](const long & r)\n    {cout << r << endl; };\n    //---- subscribe to the notifiactions\n    int cnt = j.subscribe(test_handler);\n    j.generate(); //trigget events to generate notifications\n    return 0;\n}\n```"]