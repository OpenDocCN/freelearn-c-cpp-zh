- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Advanced Animation Blending
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级动画混合
- en: Welcome to *Chapter 10*! In the previous chapter, we added a bit more *real-life
    behavior* to the instances. After a brief overview of behavior trees, we added
    a visual node editor to visually draw the behavior of the instances by using a
    simple finite state machine. At the end of the chapter, we extended the code and
    implemented interaction as an additional form of behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*第10章*！在前一章中，我们为实例添加了一些更多的*现实生活行为*。在简要概述了行为树之后，我们通过使用简单的有限状态机，以可视化的方式绘制实例的行为。在章节末尾，我们扩展了代码并实现了交互作为行为的一种附加形式。
- en: In this chapter, the instances will come even more to life. We start with a
    short exploration of the world of face animations made by morph target animations.
    Then we will add extra functionality to load morph meshes into the application
    and enable control over the face animations of the instances. Next, we add a graph
    node to be able to use face animations in the node trees as well. At the end of
    the chapter, additive blending will be implemented, allowing us to move the head
    of the instances independently of the skeletal and face animations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，实例将更加栩栩如生。我们首先简要探索由形态目标动画制作的面部动画世界。然后我们将添加额外的功能，将形态网格加载到应用程序中，并能够控制实例的面部动画。接下来，我们将添加一个图节点，以便能够在节点树中使用面部动画。在章节末尾，我们将实现加法混合，使我们能够独立于骨骼和面部动画移动实例的头部。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to animate facial expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何动画面部表情
- en: Adding face animations to code and GPU shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将面部动画添加到代码和GPU着色器中
- en: Using face animations in node trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在节点树中使用面部动画
- en: Implementing additive blending
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现加法混合
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code is in the `chapter10` folder, in the `01_opengl_morphanim`
    subfolder for OpenGL and `02_vulkan_morphanim` subfolder for Vulkan.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码位于`chapter10`文件夹中，在`01_opengl_morphanim`子文件夹中用于OpenGL，在`02_vulkan_morphanim`子文件夹中用于Vulkan。
- en: How to animate facial expressions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何动画面部表情
- en: After implementing behavior in [*Chapter 9*](Chapter_9.xhtml), life in our virtual
    world has become a lot more vivid. The instances can walk or run around by themselves,
    do simple tasks at random times, react to a collision with another instance, and
    won’t leave the virtual world beyond the invisible borders.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](Chapter_9.xhtml)中实现行为后，我们虚拟世界中的生活变得更加生动。实例可以自己行走或奔跑，在随机时间执行简单任务，对与其他实例的碰撞做出反应，并且不会离开虚拟世界的无形边界。
- en: But the instances still appear a bit sterile and lifeless. They roam around
    like robots, always looking forward, keeping a straight face. No emotions are
    visible, and there are no reactions to interactions other than playing a waving
    animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，实例仍然显得有些单调和无生气。它们像机器人一样四处游荡，总是向前看，保持直面的表情。没有可见的情感，也没有对其他交互的反应，除了播放挥手动画。
- en: So, let’s give the instances the ability to show emotions by adding facial expressions.
    The most common way to add face animations to any kind of *living* virtual object
    is **morph target animations**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过添加面部表情来赋予实例展示情感的能力。为任何类型的*活生生*虚拟对象添加面部动画最常见的方式是**形态目标动画**。
- en: 'To get the idea of morph target animations, here’s a simple example. In *Figure
    10.1*, three different weights of a morph target animation are shown:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解形态目标动画的概念，这里有一个简单的例子。在*图10.1*中，显示了形态目标动画的三个不同权重：
- en: '![](img/Figure_10.01_B22428.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_10.01_B22428.png)'
- en: 'Figure 10.1: Three different weights during an angry morph target animation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：愤怒形态目标动画过程中的三个不同权重
- en: The left face has an *angry* morph target animation applied to 0%, showing only
    the original face. The middle face has the morph target applied to 50%, blending
    halfway between the original face and the full morph, and for the right face,
    the full morph target animation has been applied.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的面部应用了0%的*愤怒*形态目标动画，只显示原始面部。中间的面部将形态目标应用于50%，在原始面部和完整形态之间进行半混合，而对于右侧的面部，已经应用了完整的形态目标动画。
- en: As you can see, the eyebrows have been rotated, the mouth vertex has been moved
    a bit upward in the final state, and the vertex positions are only interpolated
    between the original and the final mesh. But these small vertex position changes
    create an entirely different facial expression for the model.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，眉毛已经旋转，嘴巴顶点在最终状态中略微向上移动，顶点位置仅在原始网格和最终网格之间进行插值。但这些微小的顶点位置变化为模型创造了一个完全不同的面部表情。
- en: 'Morph target animations may have a different name in your tool, such as **per-vertex
    animation**, **shape interpolation**, **shape keys**, or **blend shapes**. All
    these names describe the same technique: multiple deformed versions of a mesh
    are stored in keyframes, and the animation of the mesh is done by interpolating
    the vertex positions between the positions in the keyframes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 变形目标动画在你的工具中可能有不同的名称，例如**顶点动画**、**形状插值**、**形状键**或**混合形状**。所有这些名称都描述了相同的技巧：将多个变形版本的网格存储在关键帧中，而网格的动画是通过在关键帧的位置之间插值顶点位置来完成的。
- en: 'There’s an important difference between skeletal animals and morph target animations
    when it comes to cost: a skeletal animation only affects the properties of the
    model’s nodes, while morph animations replace an entire mesh of the model’s virtual
    skin, and the mesh needs to be duplicated for every morph animation the model
    should play, raising the overall size of the model as a file on disk and in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到成本时，骨骼动画和变形目标动画之间存在一个重要的区别：骨骼动画仅影响模型节点的属性，而变形动画则替换了模型虚拟皮肤的整个网格，并且需要为模型应播放的每个变形动画复制网格，从而增加了模型在磁盘和内存中的整体大小。
- en: Models have quite a small number of bones but many vertices for the skin, so
    recalculating the positions for a large number of vertices in every frame adds
    extra computation costs to morph animations. Luckily, the morph animations happen
    entirely in the vertex shader and are only linear interpolations between two positions
    saved as vectors. Thus, the additional computational burden of a morph animation
    remains negligible in our example code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模型有相当少的骨骼但有很多顶点用于皮肤，所以每帧重新计算大量顶点的位置会增加变形动画的计算成本。幸运的是，变形动画完全发生在顶点着色器中，并且只是两个保存为向量的位置之间的线性插值。因此，变形动画的额外计算负担在我们的示例代码中仍然是微不足道的。
- en: 'In Blender, morph target animations can be controlled by the **Shape Keys**
    options on the **Data** tab. *Figure 10.2* shows the setting used for the right
    face of *Figure 10.1*, with the **Value** set to `1.000` to apply 100% of the
    **Angry** morph:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，可以通过**形状键**选项在**数据**标签页上控制变形目标动画。*图10.2*显示了用于*图10.1*右侧面的设置，**值**设置为`1.000`以应用100%的**愤怒**变形：
- en: '![](img/Figure_10.02_B22428.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_10.02_B22428.png)'
- en: 'Figure 10.2: Shape keys in Blender controlling morph target animations'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：Blender中控制变形目标动画的形状键
- en: Creating and modifying shape key-based morph target animations in Blender is
    beyond the scope of this book. Blender has some basic documentation about shape
    keys, a link is included in the *Additional resources* section, and there are
    plenty of videos around showing how to work with shape keys in Blender.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中创建和修改基于形状键的变形目标动画超出了本书的范围。Blender有一些关于形状键的基本文档，链接包含在*附加资源*部分，并且有很多视频展示了如何在Blender中使用形状键。
- en: 'If you have a model file containing morph target animations available, like
    the two models in the `assets` folder of *Chapter 10*, or if you have created
    your own set of morph animations in any other existing model, you are ready to
    go for the next step: using the Open Asset Importer Library to import these extra
    animations.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含变形目标动画的模型文件可用，比如*第10章*中`assets`文件夹中的两个模型，或者如果你在任何一个现有的模型中创建了你自己的一套变形动画，你就可以进行下一步：使用Open
    Asset Importer库导入这些额外的动画。
- en: Let’s now learn how to add morph target animations to our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来学习如何将变形目标动画添加到我们的应用程序中。
- en: Adding face animations to code and GPU shaders
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将面部动画添加到代码和GPU着色器中
- en: Morph target animation data is stored in two places in an Assimp model file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变形目标动画数据在Assimp模型文件中存储在两个地方。
- en: The first part of the morph animation data, the meshes, reside in the `mAnimMeshes`
    array of an `aiMesh` node, and the number of meshes is stored in the `mNumAnimMeshes`
    variable of the `aiMesh`. Every element of the `mAnimMeshes` array contains the
    exact same number of vertices as the original mesh, allowing us to interpolate
    the vertex positions between different versions of the mesh.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变形动画数据的第一部分，即网格，位于`aiMesh`节点的`mAnimMeshes`数组中，网格的数量存储在`aiMesh`的`mNumAnimMeshes`变量中。`mAnimMeshes`数组的每个元素都包含与原始网格完全相同的顶点数，这使得我们能够在不同版本的网格之间插值顶点位置。
- en: This interpolation is not limited to blending between the original mesh and
    one of the morph target meshes. Also, blending between two morph target meshes
    is possible, or mixing positions of more than two meshes. Be aware that the outcome
    of mixing meshes may not always be as expected as the effect of the morph target
    animations heavily depends on the intention of the animator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种插值不仅限于在原始网格和形态目标网格之一之间混合。还可能混合两个形态目标网格，或者混合超过两个网格的位置。请注意，混合网格的结果可能并不总是像预期的那么好，因为形态目标动画的效果很大程度上取决于动画师的意图。
- en: The second part of the morph animation data, the keyframe data, is in the `mMorphMeshChannels`
    array of an `aiAnimation` node, which has the number of keyframes stored in a
    variable called `mNumMorphMeshChannels`. The keys in every keyframe contain the
    points in time for the specific key, plus the numbers of the morph mesh to use
    and the weight of the morph mesh in a linear interpolation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 形态动画数据的第二部分，关键帧数据，位于`aiAnimation`节点的`mMorphMeshChannels`数组中，该数组中存储了关键帧的数量，在变量`mNumMorphMeshChannels`中。每个关键帧中的键包含特定关键的时间点，以及要使用的形态网格编号和线性插值中的形态网格权重。
- en: We will only use the mesh data to interpolate between different facial expressions,
    so we ignore the animation data for the morph meshes. But it is easy to add support
    for the morph target animations on top of the code of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用网格数据在不同的面部表情之间进行插值，因此我们忽略了形态网格的动画数据。但很容易在本书的代码之上添加对形态目标动画的支持。
- en: As the first step on the way to morph animations, we will learn how to load
    the additional mesh data and extract the vertices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为走向形态动画的第一步，我们将学习如何加载额外的网格数据并提取顶点。
- en: Loading morph meshes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载形态网格
- en: 'Since every vertex in a morph mesh replaces the position and the normal of
    the same vertex in the original mesh, only a subset of vertex data is needed for
    the replacement vertices. We will create a *lightweight* version of a vertex named
    `OGLMorphVertex` in the `OGLRenderData.h` file in the `opengl` folder, containing
    only the position and normal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于形态网格中的每个顶点都替换了原始网格中相同顶点的位置和法线，因此只需要替换顶点的子集数据。我们将在`opengl`文件夹中的`OGLRenderData.h`文件中创建一个名为`OGLMorphVertex`的轻量级顶点版本，只包含位置和法线：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To collect the replacement morph vertices into a mesh, we also create a new
    `struct` called `OGLMorphMesh` that contains all the vertices in a `std::vector`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将替换的形态顶点收集到一个网格中，我们还创建了一个新的`struct`，名为`OGLMorphMesh`，它包含一个`std::vector`中的所有顶点：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As all the morph meshes depend on the original meshes, we add a `OGLMorphMesh`
    vector to the default mesh, `struct` `OGLMesh`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有形态网格都依赖于原始网格，我们在默认网格`struct` `OGLMesh`中添加了一个`OGLMorphMesh`向量：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For Vulkan, the two new structs are named `VkMorphVertex` and `VkMorphMesh`,
    residing in the `VkRenderData.h` file in the `vulkan` folder. The `VkMorphMesh`
    vector is added to the `VkMesh` `struct`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，这两个新的`struct`分别命名为`VkMorphVertex`和`VkMorphMesh`，位于`vulkan`文件夹中的`VkRenderData.h`文件中。`VkMorphMesh`向量被添加到`VkMesh`
    `struct`中。
- en: 'Right before the end of the `processMesh()` method in the `AssimpMesh` class,
    we add a new code block to extract the morph mesh data from the model file. First,
    we check if we have any morph meshes attached to the current mesh:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssimpMesh`类的`processMesh()`方法结束前，我们添加了一个新的代码块来从模型文件中提取形态网格数据。首先，我们检查当前网格是否附加了任何形态网格：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we find morph meshes, we iterate over all morph meshes, extracting the mesh
    data and the number of vertices:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了形态网格，我们将遍历所有形态网格，提取网格数据和顶点数：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Per definition, the number of vertices in the morph mesh must match the number
    of vertices in the original mesh. It does not hurt to do an addition check here,
    skipping the entire morph mesh and printing an error when a vertex count mismatch
    is detected:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，形态网格中的顶点数必须与原始网格中的顶点数相匹配。在这里进行额外的检查并不会造成伤害，如果在检测到顶点数不匹配时跳过整个形态网格并打印错误信息：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we check whether the morph mesh contains position data and create a temporary
    `OGLMorphMesh` if the check succeeds:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查形态网格是否包含位置数据，如果检查成功，则创建一个临时的`OGLMorphMesh`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It may sound silly to check whether the morph mesh has vertex positions, but
    morph meshes can also override other data, such as normals, colors, or texture
    positions. It is possible to encounter a morph mesh without position data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查形态网格是否有顶点位置可能听起来很愚蠢，但形态网格也可以覆盖其他数据，例如法线、颜色或纹理位置。可能会遇到没有位置数据的形态网格。
- en: 'Then, we loop over all vertices and extract the vertex positions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有顶点并提取顶点位置：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If normal data is stored in the morph mesh too, we extract the normals. Without
    normal data, we set the vertex normal to zero:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果形态网格中也存储了法线数据，我们提取法线。如果没有法线数据，我们将顶点法线设置为零：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we place the vertex into the temporary `OGLMorphMesh`, and after all
    the vertices are processed, the `OGLMorphMesh` is added to the `morphMeshes` vector
    of the `OGLMesh` for this `AssimpMesh` object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将顶点放入临时的`OGLMorphMesh`中，处理完所有顶点后，将`OGLMorphMesh`添加到`OGLMesh`对象的`morphMeshes`向量中，对于这个`AssimpMesh`对象：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Accessing any alternative morph meshes is now as simple as checking the `morphMeshes`
    vector for a size greater than zero, and if we have any morph meshes, extracting
    the vertex data and interpolating between the positions and normals of the original
    vertices and the vertices of the selected morph mesh.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问任何替代形态网格就像检查`morphMeshes`向量的大小是否大于零一样简单，如果我们有任何形态网格，我们可以提取顶点数据并在原始顶点的位置和法线与所选形态网格的顶点之间进行插值。
- en: At this point, all valid morph meshes found in the model file are available
    as part of the `AssimpMesh` mesh data. To use these morph meshes for face animations,
    we must add some code and logic to the application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在模型文件中找到的所有有效形态网格都作为`AssimpMesh`网格数据的一部分可用。为了使用这些形态网格进行面部动画，我们必须在应用程序中添加一些代码和逻辑。
- en: Storing all morph meshes in a single buffer
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有形态网格存储在单个缓冲区中
- en: To use the vertices of the morph meshes in a shader, we store the vertex data
    of all morph meshes into a single SSBO. Using a single SSBO is needed due to the
    instanced rendering of the model instances on the screen – we need the vertex
    data of all meshes available at all times during the rendering since we cannot
    tell when a specific model instance will be drawn to the screen. Splitting the
    rendering depending on the selected morph mesh would also be possible, but that
    would be quite a costly alternative as we must filter the instances on every draw
    call.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在着色器中使用形态网格的顶点，我们将所有形态网格的顶点数据存储到一个单独的SSBO中。使用单个SSBO是必要的，因为模型实例在屏幕上的实例化渲染需要我们始终能够访问所有网格的顶点数据——因为我们无法确定何时特定的模型实例会被绘制到屏幕上。根据选定的形态网格分割渲染也是可能的，但这将是一个相当昂贵的替代方案，因为我们必须在每次绘制调用中过滤实例。
- en: 'The morph mesh SSBO plus some related variables are added to the `AssimpModel`
    class. First, three new `private` variables are added to the `AssimpModel.h` header
    file: `mNumAnimatedMeshes`, `mAnimatedMeshVertexSize`, and `mAnimMeshVerticesBuffer`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 形态网格SSBO和一些相关变量被添加到`AssimpModel`类中。首先，在`AssimpModel.h`头文件中添加了三个新的`private`变量：`mNumAnimatedMeshes`、`mAnimatedMeshVertexSize`和`mAnimMeshVerticesBuffer`：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In `mNumAnimatedMeshes`, we store the number of morph meshes for this model.
    Right now, the code supports only a single mesh containing morph meshes, so the
    number in `mNumAnimatedMeshes` is equal to the number of morph meshes in this
    specific mesh.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mNumAnimatedMeshes`中，我们存储该模型形态网格的数量。目前，代码只支持包含形态网格的单个网格，所以`mNumAnimatedMeshes`中的数字等于这个特定网格中形态网格的数量。
- en: But since we are doing only face animations, the limit of a single mesh with
    morph meshes is no problem. Also, a task in the *Practical sessions* section is
    available to extend the code accordingly and add support for multiple meshes containing
    morph meshes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们只进行面部动画，单个网格的形态网格限制并不成问题。此外，在*实践课程*部分有一个任务，可以相应地扩展代码并添加对包含形态网格的多网格的支持。
- en: The value in `mAnimatedMeshVertexSize` is used to find the start of vertex data
    for the selected morph clip in the SSBO. By multiplying the mesh vertex size and
    the index of the morph clip, we can jump directly to the first vertex of the morph
    clip.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mAnimatedMeshVertexSize`中的值用于在SSBO中找到所选形态剪辑的顶点数据的起始位置。通过乘以网格顶点大小和形态剪辑的索引，我们可以直接跳转到形态剪辑的第一个顶点。'
- en: Finally, all vertex data is stored in the `mAnimMeshVerticesBuffer` SSBO.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有顶点数据都存储在`mAnimMeshVerticesBuffer` SSBO中。
- en: We also add two `public` methods called `hasAnimMeshes()` and `getAnimMeshVertexSize()`
    to the `AssimpModel.cpp` class implementation file. Thanks to the *descriptive*
    method names, no further explanation should be required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`AssimpModel.cpp`类的实现文件中添加了两个名为`hasAnimMeshes()`和`getAnimMeshVertexSize()`的`public`方法。多亏了*描述性*的方法名称，不需要进一步解释。
- en: 'Filling the SSBO is done in the `loadModel()` method of the `AssimpModel` class.
    When all meshes are collected into the `mModelMeshes` vector, we can iterate over
    all meshes to add the vertex data to the new buffer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssimpModel`类的`loadModel()`方法中完成填充SSBO。当所有网格都收集到`mModelMeshes`向量中时，我们可以遍历所有网格，将顶点数据添加到新的缓冲区：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As the first step of collecting the vertices in the `mAnimMeshVerticesBuffer`
    SSBO, we check if we have any morph meshes in this mesh. If we have a mesh without
    additional morph meshes, we simply continue with the next mesh.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mAnimMeshVerticesBuffer` SSBO中收集顶点的第一步是检查这个网格中是否有任何形态网格。如果没有额外的形态网格的网格，我们就简单地继续到下一个网格。
- en: 'Then, we create a temporary `OGLMorphMesh` called `animMesh` to collect all
    vertices and resize the `morphVertices` vector in the `animMesh`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个临时的`OGLMorphMesh`，名为`animMesh`，以收集所有顶点并调整`animMesh`中的`morphVertices`向量的大小：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can copy all vertices of the morph mesh into `animMesh`, using the number
    of vertices to calculate the correct position:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将形态网格的所有顶点复制到`animMesh`中，使用顶点数来计算正确的位置：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we upload the collected vertices to the SSBO:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将收集到的顶点上传到SSBO：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Whenever we need the morph animations of this model now, we can bind the buffer
    to a specified shader binding point. This binding can be achieved by using the
    new `public` method, `bindMorphAnimBuffer()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要这个模型的形态动画时，我们可以将缓冲区绑定到指定的着色器绑定点。这种绑定可以通过使用新的`public`方法`bindMorphAnimBuffer()`来实现：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To use face animations on a per-instance basis, we must add a couple of variables
    and methods and extend some data structures.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在实例级别上使用面部动画，我们必须添加一些变量和方法，并扩展一些数据结构。
- en: Adding face morph settings to the code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将面部形态设置添加到代码中
- en: 'The most important change to enable face animations is a new `enum` `class`
    called `faceAnimation`, which resides in the `Enums.h` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启用面部动画最重要的更改是名为`faceAnimation`的新`enum` `class`，它位于`Enums.h`文件中：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All supported morph animations are stored in the `faceAnimation` `enum` the
    same way as actions or node types. Instead of using the morph animation from the
    model files, we will use only a fixed set of face animations in the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持的形态动画都存储在`faceAnimation` `enum`中，与动作或节点类型相同。我们不会使用模型文件中的形态动画，而只会在代码中使用一组固定的面部动画。
- en: 'Similar to other data types, we add a mapping from the `enum` values to strings.
    It is a lot easier to use the `enum` value in code and show the user-friendly
    string in the UI. The new map named `micFaceAnimationNameMap` will be added to
    the `ModelInstanceCamData` `struct` in the `ModelInstanceCamData.h` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据类型类似，我们添加了一个从`enum`值到字符串的映射。在代码中使用`enum`值并显示用户友好的字符串在UI中要容易得多。新的映射名为`micFaceAnimationNameMap`，将被添加到`ModelInstanceCamData.h`文件中的`ModelInstanceCamData`
    `struct`：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Filling the map with strings happens in the `init()` method of the renderer
    class files, `OGLRenderer.cpp` or `VkRenderer.cpp`, the best place is next to
    the existing mapping code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器类文件`OGLRenderer.cpp`或`VkRenderer.cpp`的`init()`方法中填充映射，最佳位置是现有映射代码旁边。
- en: Fixed morph mapping vs. dynamic loading from the model
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 固定形态映射与从模型动态加载
- en: The reason to hard code all morph target animation clips in the `faceAnimation`
    `enum` and `micFaceAnimationNameMap` is to keep the code simple.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`faceAnimation` `enum`和`micFaceAnimationNameMap`中硬编码所有形态目标动画剪辑的原因是为了保持代码简单。
- en: While populating the list of morph target clips from the model file is easy,
    maintaining a dynamic list in the UI becomes quite complex. For instance, adding
    code to choose a morph clip in a node tree would create a hard dependency between
    the tree and a single model – using the same tree for other models will become
    impossible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从模型文件中填充形态目标剪辑列表很容易，但在UI中维护动态列表变得相当复杂。例如，向节点树中添加选择形态剪辑的代码将创建树与单个模型之间的硬依赖 - 使用相同的树为其他模型将变得不可能。
- en: To avoid a model-tree dependency, only a predefined set of morph animations
    will be used. Any model can support all morph animations, none of them, or a partial
    number of clips with matching indices, filling any gaps with empty morph animations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免模型树依赖，将只使用预定义的形态动画集。任何模型都可以支持所有形态动画，没有任何动画，或者部分剪辑与匹配的索引，用空形态动画填充任何空白。
- en: 'For the instance part, two new variables named `isFaceAnimType` and `isFaceAnimWeight`
    are added to the `InstanceSettings` `struct`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例部分，我们向`InstanceSettings` `struct`中添加了两个新变量，名为`isFaceAnimType`和`isFaceAnimWeight`：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `isFaceAnimType`, we store the current face animation clip. Due to the extra
    `none` value in the `faceAnimation` `enum`, we do not need another Boolean to
    switch the face animations on or off. The interpolation weight between the default
    face mesh and the face animation can be controlled by `isFaceAnimWeight`, with
    `0.0f` showing only the default mesh and `1.0f` the morph mesh.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `isFaceAnimType` 中，我们存储当前的 facial animation 裁剪。由于 `faceAnimation` 枚举中存在额外的
    `none` 值，我们不需要另一个布尔值来切换 facial animations 的开关。默认 facial 网格和 facial animation 之间的插值权重可以通过
    `isFaceAnimWeight` 控制，其中 `0.0f` 表示仅显示默认网格，而 `1.0f` 表示变形网格。
- en: '`is` stands for “InstanceSettings”, not for “it is”'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 代表 “InstanceSettings”，而不是 “it is”'
- en: 'To bring up the sidenote again, and to avoid confusion: The `is` in the `InstanceSettings`
    variable names is just the abbreviation of the `struct` name, not something to
    define a state. So, `isFaceAnimType` stands for “Instance Settings Face Animation
    Type”, not a Boolean controlling whether the face animation is enabled.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提出旁注，并避免混淆：`InstanceSettings` 变量名中的 `is` 只是 `struct` 名称的缩写，而不是定义状态的东西。因此，`isFaceAnimType`
    代表 “Instance Settings Face Animation Type”，而不是控制 facial animation 是否启用的布尔值。
- en: We also need to give the renderer the information about the face animations
    for every instance. Let’s extend the renderer as the next step.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为每个实例的渲染器提供有关 facial animations 的信息。让我们在下一步扩展渲染器。
- en: Filling the per-instance buffer data in the renderer
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渲染器中填充每个实例的缓冲区数据
- en: 'As for all other shader-related data, we need an SSBO to hand the data over
    to the GPU. To fill the SSBO, a `std::vector` of some data type is needed. So,
    the renderer class header file `OGLRenderer.h` will get two new `private` variables
    called `mFaceAnimPerInstanceData` and `mFaceAnimPerInstanceDataBuffer`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 至于所有其他与着色器相关的数据，我们需要一个 SSBO 来将数据传递给 GPU。要填充 SSBO，需要一个某种数据类型的 `std::vector`。因此，渲染器类头文件
    `OGLRenderer.h` 将获得两个新的 `private` 变量，分别称为 `mFaceAnimPerInstanceData` 和 `mFaceAnimPerInstanceDataBuffer`：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the Vulkan renderer, the data type of the buffer differs. We need to add
    the following lines to the `VkRenderer.h` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan 渲染器，缓冲区的数据类型不同。我们需要在 `VkRenderer.h` 文件中添加以下行：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though we need only three values, we will use a `glm::vec4` here to tackle
    possible data-alignment problems. You should try to avoid the three-element vector
    (`glm::vec3`) to transport data via an SSBO to the GPU since you may get a mismatch
    between the vector or struct on the CPU side and the buffer on the GPU side.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们需要仅三个值，我们也会在这里使用 `glm::vec4` 来处理可能的数据对齐问题。你应该尽量避免使用三元素向量 (`glm::vec3`) 通过
    SSBO 将数据传输到 GPU，因为您可能会在 CPU 侧的向量或结构体和 GPU 侧的缓冲区之间得到不匹配。
- en: 'The per-instance face animation SSBO will be added to the `draw()` call of
    the renderer class file, `OGLRenderer.cpp` or `VkRenderer.cpp`, more specifically
    in the loop over the instances of the model:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例的 facial animation SSBO 将添加到渲染器类文件 `OGLRenderer.cpp` 或 `VkRenderer.cpp`
    中的 `draw()` 调用，更具体地说是在遍历模型实例的循环中：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We also add the resizing of the vector containing the morphing data before the
    loop; see the highlighted part in the previous code snippet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在循环之前添加了包含变形数据的向量的调整大小；请参阅前一个代码片段中的高亮部分。
- en: And since we have already extracted the `InstanceSettings` `struct` of the current
    instance in the loop, adding the face animation is done in just a couple of lines.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在循环中提取了当前实例的 `InstanceSettings` 结构体，因此添加 facial animation 只需要几行代码。
- en: 'First, we add an empty `glm::vec4` named `morphData`, plus we check whether
    the instance has a face animation set:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个名为 `morphData` 的空 `glm::vec4`，并检查实例是否设置了 facial animation：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we should animate the face of the instance, we fill three elements of `morphData`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应该对实例的 facial 进行动画处理，我们填充 `morphData` 的三个元素：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we set the weight of the face animation, the clip number decreased by one
    to honor the `none` element of the `faceAnimation` `enum`, and the number of vertices
    to skip between two morph meshes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们设置 facial animation 的权重，clip 数量减一以尊重 `faceAnimation` 枚举中的 `none` 元素，以及两个变形网格之间跳过的顶点数。
- en: The current shader code uses the number of vertices and the clip number to calculate
    the first vertex of the desired morph animation, but it is possible to an absolute
    value here. An absolute value could become handy if we plan to extend the code
    to support multiple meshes with morph target animations (see the *Practical sessions*
    section).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当前着色器代码使用顶点数和 clip 数来计算所需变形动画的第一个顶点，但这里也可以使用绝对值。如果计划扩展代码以支持具有变形目标动画的多个网格，绝对值可能会很有用（参见
    *实践课程* 部分）。
- en: 'Finally, we store the `morphData` in the vector used to fill the SSBO:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`morphData`存储在用于填充SSBO的向量中：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As a last step for the face animations, the vertex shaders must be made aware
    of the new buffers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为面部动画的最后一步，顶点着色器必须知道新的缓冲区。
- en: Extending the shader to draw face animations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展着色器以绘制面部动画
- en: As morph target animations only change vertex data, we need to add the new SSBOs
    and a bit of logic to the vertex shader. There is no need to touch a compute or
    fragment shader, a fact that simplifies the face animation implementation a lot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变形目标动画仅更改顶点数据，我们需要在顶点着色器中添加新的SSBO和一些逻辑。不需要触摸计算或片段着色器，这大大简化了面部动画的实现。
- en: 'To prevent distortions for models without face animations, we will use a separate
    set of shaders to draw the meshes containing morph animations. First, we add two
    new `private` shader variables to the renderer header file `OGLRenderer.h`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止没有面部动画的模型出现扭曲，我们将使用一组单独的着色器来绘制包含变形动画的网格。首先，我们在渲染器头文件`OGLRenderer.h`中添加两个新的`private`着色器变量：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the Vulkan renderer, more work is needed here since the shaders are part
    of the pipelines. We need to add two `VkPipelineLayout` handles, two `VkPipeline`
    handles, two `VkDescriptorSetLayout` handles, and two `VkDescriptorSet` handles
    in the `VkRenderData.h` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan渲染器，这里需要做更多的工作，因为着色器是管线的一部分。我们需要在`VkRenderData.h`文件中添加两个`VkPipelineLayout`句柄、两个`VkPipeline`句柄、两个`VkDescriptorSetLayout`句柄和两个`VkDescriptorSet`句柄：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With these handles, two new Vulkan pipelines are created to draw the models
    with and without the special selection handling. For further Vulkan implementation
    details, check out the `VkRenderer.cpp` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些句柄，创建了两个新的Vulkan管线，用于绘制带有和没有特殊选择处理的模型。有关进一步的Vulkan实现细节，请查看`VkRenderer.cpp`文件。
- en: We need to adjust the selection vertex shader to draw the morphed face meshes
    in the selection buffer. Without the selection shader, the head of the instances
    would no longer be selectable by clicking the mouse button.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整选择顶点着色器以在选择缓冲区中绘制变形的面部网格。如果没有选择着色器，实例的头部将无法通过点击鼠标按钮进行选择。
- en: 'For the shader code itself, we can reuse and extend the existing files. Copy
    the following four files to the new file names:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于着色器代码本身，我们可以重用和扩展现有的文件。将以下四个文件复制到新的文件名中：
- en: '`assimp_skinning.vert` to `assimp_skinning_morph.vert`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`assimp_skinning.vert`重命名为`assimp_skinning_morph.vert`
- en: '`assimp_skinning.frag` to `assimp_skinning_morph.frag`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`assimp_skinning.frag`重命名为`assimp_skinning_morph.frag`
- en: '`assimp_skinning_selection.vert` to `assimp_skinning_morph_selection.vert`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`assimp_skinning_selection.vert`重命名为`assimp_skinning_morph_selection.vert`
- en: '`assimp_skinning_selection.frag` to `assimp_skinning_morph_selection.frag`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`assimp_skinning_selection.frag`重命名为`assimp_skinning_morph_selection.frag`
- en: The fragment shaders with the `.frag` extension will not be changed, but for
    further changes or debugging it is always better to use separate files for the
    new shaders.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`.frag`扩展名的片段着色器将不会更改，但为了进一步的更改或调试，始终最好为新的着色器使用单独的文件。
- en: 'In both vertex shader files ending with `.vert`, add the following lines to
    define the new `MorphVertex` `struct`, matching the `OGLMorphVertex` struct defined
    in the `OGLRenderData.h` file in the `opengl` folder:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以`.vert`结尾的两个顶点着色器文件中，添加以下行以定义新的`MorphVertex` `struct`，与在`opengl`文件夹中的`OGLRenderData.h`文件中定义的`OGLMorphVertex`
    `struct`相匹配：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For Vulkan, the name of the original `struct` is `VkMorphVertex`, defined in
    `VkRenderData.h` in the `vulkan` folder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，原始`struct`的名称是`VkMorphVertex`，在`vulkan`文件夹中的`VkRenderData.h`文件中定义。
- en: 'Then, add two new SSBOs named `AnimMorphBuffer` and `AnimMorphData` on binding
    points four and five:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在绑定点四和五上添加两个新的SSBO（Shader Storage Buffer Objects），分别命名为`AnimMorphBuffer`和`AnimMorphData`：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first buffer, `AnimMorphBuffer`, contains the vertices of all morph available
    animations. In the second buffer, `AnimMorphData`, all instance settings are handed
    over from the CPU to the GPU.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缓冲区`AnimMorphBuffer`包含所有可用的变形动画的顶点。在第二个缓冲区`AnimMorphData`中，所有实例设置从CPU传递到GPU。
- en: 'Inside the `main()` method of the vertex shader, we calculate the offset to
    the vertices for the desired face animation by multiplying the vertex count and
    the index of the face animation clip for every instance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器的`main()`方法内部，我们通过乘以每个实例的顶点数和面部动画剪辑的索引来计算所需面部动画的顶点偏移量：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is no problem to cast the `float` values to `int` here to avoid another struct
    with separate integer and floating-point values and to use `glm::vec4` as a “transportation
    object.” The first inaccurate integer represented by a float would be 2^(24)+1,
    and that value is large enough even for bigger meshes with many face animations
    (2^(24)+1 would be ~16 MiB of vertex data).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将 `float` 类型的值转换为 `int` 没有问题，这样可以避免使用一个包含单独整数和浮点值的不同结构体，并使用 `glm::vec4` 作为“传输对象”。第一个由浮点数表示的不准确整数将是
    2^(24)+1，这个值足够大，即使是带有许多面动画的大网格（2^(24)+1 将是 ~16 MiB 的顶点数据）。
- en: 'Then we extract the vertices from the morph mesh by using the `gl_VertexID`
    internal shader variable (`gl_VertexIndex` for Vulkan):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过使用 `gl_VertexID` 内部着色器变量（对于 Vulkan 是 `gl_VertexIndex`）从变形网格中提取顶点：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can mix the positions of the original vertex and the replacement vertex
    from the morph mesh according to the weight factor:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据权重因子混合原始顶点和从变形网格中替换的顶点的位置：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We do the same extraction and calculation work for the vertex normals since
    a position change of a vertex may also affect the normal of the triangle the vertex
    is part of:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶点的位置变化也可能影响顶点所在的三角形的法线，因此我们对顶点法线也进行相同的提取和计算工作：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For a better selection of meshes with and without morph animations, we also
    need some small changes in the `AssimpModel` class and the renderer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地选择带有和没有变形动画的网格，我们还需要在 `AssimpModel` 类和渲染器中进行一些小的更改。
- en: Finalizing the face animation code
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成面部动画代码
- en: 'In the `AssimpModel` class, two new drawing methods are added:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AssimpModel` 类中，添加了两个新的绘制方法：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The names say what the methods are doing: `drawInstancedNoMorphAnims()` draws
    all meshes without morph animations, and `drawInstancedMorphAnims()` draws only
    the meshes with morph animations.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名说明了它们的功能：`drawInstancedNoMorphAnims()` 绘制所有没有变形动画的网格，而 `drawInstancedMorphAnims()`
    仅绘制带有变形动画的网格。
- en: 'To filter the meshes in both methods, a quite simple check is used – we loop
    over all the meshes and look at the size of the `morphMeshes` vector inside the
    mesh. For the `drawInstancedNoMorphAnims()` method that draws only non-morph meshes,
    we simply skip the meshes without extra morph meshes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两种方法中过滤网格，我们使用了一个相当简单的检查 - 我们遍历所有网格，查看网格内部 `morphMeshes` 向量的大小。对于仅绘制非变形网格的
    `drawInstancedNoMorphAnims()` 方法，我们简单地跳过没有额外变形网格的网格：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And for the morph-mesh-only version, we reverse the check:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅变形网格的版本，我们反转检查：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reason for using two separate methods lies in the `draw()` method of the
    renderer class files, `OGLRenderer.cpp` or `VkRenderer.cpp`. There, we replace
    the normal instanced draw call for the animated models with the no-morph version:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个单独的方法的原因在于渲染器类文件 `OGLRenderer.cpp` 或 `VkRenderer.cpp` 中的 `draw()` 方法。在那里，我们将动画模型的正常实例绘制调用替换为无变形版本：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Drawing the meshes with morph animations is done after checking whether the
    model contains any morph meshes, as shown in the following code of the OpenGL
    renderer:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查模型是否包含任何变形网格后，绘制带有变形动画的网格，如下面的 OpenGL 渲染器的代码所示：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, we use the new morphing shader, bind the two SSBOs containing
    the vertex data and the per-instance settings, and use the draw call that only
    draws meshes with morph animations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用新的变形着色器，绑定包含顶点数据和实例设置的 SSBO，并使用仅绘制带有变形动画的网格的绘制调用。
- en: For a simple test, you can set the `morphData` values in the renderer to some
    fixed values and check whether the instances run around angry or smiling. But
    to have full control of the new settings, we will also add a combo box and a slider
    to the UI.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的测试，你可以在渲染器中将 `morphData` 值设置为一些固定值，并检查实例是否在愤怒或微笑地四处移动。但要完全控制新的设置，我们还将添加一个组合框和滑块到
    UI 中。
- en: Adding UI elements to control face animations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 UI 元素以控制面部动画
- en: For the UI, the amount of code is small. We just need a combo box, mapping the
    `isFaceAnimType` value of `InstanceSettings` to the string from `micFaceAnimationNameMap`,
    and a float slider linked to `isFaceAnimWeight`. With a model without a face animation,
    we simply disable the combo box and the slider.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 UI，代码量很小。我们只需要一个组合框，将 `InstanceSettings` 的 `isFaceAnimType` 值映射到 `micFaceAnimationNameMap`
    中的字符串，以及一个与 `isFaceAnimWeight` 链接的浮点滑块。对于没有面部动画的模型，我们简单地禁用组合框和滑块。
- en: '*Figure 10.3* shows the expanded combo box with the four face animations plus
    the `None` setting to disable face animations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.3* 显示了扩展的组合框，包含四个面部动画以及禁用面部动画的 `None` 设置：'
- en: '![](img/Figure_10.03_B22428.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_10.03_B22428.png)'
- en: 'Figure 10.3: UI settings to control the face animations of an instance'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：控制实例面部动画的UI设置
- en: We can choose the face animation clip now, and by using the weight slider, we
    can control how much of the face animation morph will be used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以选择面部动画剪辑，并通过使用权重滑块来控制面部动画形态的使用量。
- en: As the last step for the face animations implementation, we will cover how to
    add the new settings to the YAML configuration file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为面部动画实现的最后一步，我们将介绍如何将新设置添加到YAML配置文件中。
- en: Saving and loading the new instance settings
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载新的实例设置
- en: Luckily, the current state of the YAML parser and emitter code allows us to
    add face animations with truly little effort. Since the face animation settings
    are set per instance, we need to extend the YAML emitter output operator for `InstanceSettings`
    in the `YamlParser.cpp` file in the `tools` folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当前YAML解析器和发射器代码的状态允许我们几乎不费吹灰之力地添加面部动画。由于面部动画设置是按实例设置的，我们需要扩展`tools`文件夹中`YamlParser.cpp`文件中的`InstanceSettings`的YAML发射器输出操作符。
- en: 'Right after the output of the optional node tree setting, we check whether
    a face animation is configured and output the instance settings if a clip was
    set:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选节点树设置输出之后，我们检查是否配置了面部动画，如果设置了剪辑，则输出实例设置：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To output the `faceAnimation` `enum`, we also need a definition of the output
    operator for the new data type:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输出`faceAnimation` `enum`，我们还需要为新数据类型定义输出操作符：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `YamlParserTypes.h` file, we also need a simple `decode()` method for
    the new `faceAnimation` data type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`YamlParserTypes.h`文件中，我们还需要为新的`faceAnimation`数据类型提供一个简单的`decode()`方法：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `encode()` method is not shown here, it essentially does the same as all
    other `enum` `encode()` methods do: it casts the node data to an `int`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode()`方法在这里没有展示，它本质上与所有其他`enum` `encode()`方法做的是一样的事情：将节点数据转换为`int`。'
- en: 'Finally, we just must extend the `decode()` method for the `ExtendedInstanceSettings`,
    adding the two new values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需扩展`ExtendedInstanceSettings`的`decode()`方法，添加两个新值：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `encode()` method extension is also super simple:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode()`方法扩展也非常简单：'
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Make sure to bump the version of the configuration file since we added new data
    to it. In this case, changing the file version is less crucial since parser versions
    from previous chapters simply do not know the new settings.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确保提高配置文件的版本，因为我们向其中添加了新数据。在这种情况下，更改文件版本不太关键，因为前几章的解析器版本根本不知道新的设置。
- en: 'And that’s it! When you select an instance now, you can change the type and
    strength of the facial expression, as shown in *Figure 10.4*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在当你选择一个实例时，你可以改变面部表情的类型和强度，如图10.4所示：
- en: '![](img/Figure_10.04_B22428.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图10.04_B22428](img/Figure_10.04_B22428.png)'
- en: 'Figure 10.4: A “worried” instance next to the default face mesh'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：一个“担忧”的实例在默认面部网格旁边
- en: The face animations can be controlled for every instance, and changes to one
    instance do not affect other instances. It is up to you if you want the instances
    to be angry, worried, happy, or even surprised, and how much of that expression
    will be shown.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 面部动画可以控制每个实例，一个实例的变化不会影响其他实例。是否想让实例显得愤怒、担忧、快乐，甚至惊讶，以及这种表情显示的程度，完全取决于你。
- en: Adding more morph clips to the application is also easy. The most complex thing
    for new clips will be most probably the vertex animation in a tool such as Blender.
    In the code, it is just adding a new value to the `faceAnimation` `enum` `class`
    and a new string to the name mapping in the `micFaceAnimationNameMap` variable
    of the `ModelInstanceCamData` `struct`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 向应用程序添加更多形态剪辑也很容易。对于新剪辑来说，最复杂的事情可能是使用Blender等工具中的顶点动画。在代码中，只需向`faceAnimation`
    `enum` `class`添加一个新值，并在`ModelInstanceCamData` `struct`的`micFaceAnimationNameMap`变量中添加一个新的字符串映射即可。
- en: To be able to use the new face animations in a node tree too, we need to create
    a new node type, allowing us to control both the animation clip and the weight
    of the desired morph target animation. So, let’s add the all-new **FaceAnim**
    node.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在节点树中使用新的面部动画，我们需要创建一个新的节点类型，允许我们控制所需的形态目标动画的动画剪辑和权重。所以，让我们添加全新的**FaceAnim**节点。
- en: Using face animations in node trees
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在节点树中使用面部动画
- en: 'Creating a new node type is easy. First, we add a new class, `FaceAnimNode`,
    consisting of the `FaceAnimNode.h` header and the implementation file, `FaceAnimNode.cpp`,
    both placed in the `graphnodes` folder. We can borrow most of the implementation
    from the WaitNode, adding ImGui elements and a bit of logic to control the face
    animation during the execution time. *Figure 10.5* shows the final layout of the
    FaceAnim node:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的节点类型很简单。首先，我们在 `graphnodes` 文件夹中添加一个新的类，`FaceAnimNode`，由 `FaceAnimNode.h`
    头文件和实现文件 `FaceAnimNode.cpp` 组成。我们可以从 WaitNode 中借用大部分实现，添加 ImGui 元素和一些逻辑来控制执行时间内的面部动画。*图
    10.5* 显示了 FaceAnim 节点的最终布局：
- en: '![](img/Figure_10.05_B22428.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.05_B22428](img/Figure_10.05_B22428.png)'
- en: 'Figure 10.5: The new FaceAnim node'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：新的 FaceAnim 节点
- en: The node allows us to choose one of the face animation clips, including the
    `None` setting to disable face animations on an instance, starting and ending
    weights for the animation in both play directions, and a timer to control how
    long the animation replay will take.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该节点允许我们选择一个面部动画剪辑，包括 `None` 设置以禁用实例上的面部动画，动画在两个播放方向上的起始和结束权重，以及一个计时器来控制动画重放将持续多长时间。
- en: Before we can add the new `FaceAnim` node, we must extend the `enum` containing
    the node types and the graph node factory class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够添加新的 `FaceAnim` 节点之前，我们必须扩展包含节点类型和图节点工厂类的 `enum`：
- en: Adjusting the code for the new FaceAnim node
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整新 FaceAnim 节点的代码
- en: Similar to WaitNode, the `FaceAnim` node delays the control flow until the timer
    reaches zero and informs the parent node about it once the animation replay has
    ended.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WaitNode 类似，`FaceAnim` 节点延迟控制流，直到计时器达到零，并在动画重放结束后通知父节点。
- en: Next to adding the two new files, creating the new node type needs two extra
    steps.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加两个新文件之后，创建新的节点类型需要额外两个步骤。
- en: 'First, we must extend the `graphNodeType` `enum` in the `Enums.h` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在 `Enums.h` 文件中扩展 `graphNodeType` `enum`：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, the constructor and the `makeNode()` method of the `GraphNodeFactory`
    class must be made aware of the new node. In the constructor, we add the node
    title string to `mGraphNodeTypeMap`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`GraphNodeFactory` 类的构造函数和 `makeNode()` 方法必须知道新的节点。在构造函数中，我们将节点标题字符串添加到
    `mGraphNodeTypeMap`：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `makeNode()`, we add a case block for the new node type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `makeNode()` 中，我们为新的节点类型添加一个情况块：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we can adjust the implementation of the new `FaceAnimNode` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调整新 `FaceAnimNode` 类的实现。
- en: Adding the FaceAnim node
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 FaceAnim 节点
- en: 'As we will blend manually between the two weight values, we will map the blend
    time to a range between zero and one in the `update()` method once the node is
    active:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将手动在两个权重值之间混合，一旦节点激活，我们将在 `update()` 方法中将混合时间映射到零到一的范围：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By doing a simple division, surrounded by a check to avoid a division by zero,
    the time difference in `morphTimeDiff` will go from one to zero.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的除法，周围带有避免除以零的检查，`morphTimeDiff` 中的时间差将从一变为零。
- en: 'Then we interpolate the final weight by using the product of the time difference
    and weight difference:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过时间差和权重差的乘积来插值最终的权重：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On every run of the `update()` method, we continuously sent the new weight
    via the `fireNodeOutputCallback` to the renderer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 `update()` 方法的运行中，我们通过 `fireNodeOutputCallback` 持续发送新的权重到渲染器：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Before doing the weight update, we send the desired animation clip index in
    the `activate()` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行权重更新之前，我们在 `activate()` 方法中发送所需的动画剪辑索引：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To signal the face animation values to the renderer, the `instanceUpdateType`
    `enum` needs to be extended by two new values, `faceAnimIndex` and `faceAnimWeight`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将面部动画值信号传递给渲染器，需要通过两个新值 `faceAnimIndex` 和 `faceAnimWeight` 扩展 `instanceUpdateType`
    `enum`：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also need the `faceAnimation` type in the `nodeCallbackVariant` variant
    to use the new data type in the callbacks between the classes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `nodeCallbackVariant` 变体中添加 `faceAnimation` 类型，以便在类之间的回调中使用新的数据类型：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we use the `fireNodeOutputCallback` in the node, both the `GraphEditor`
    and the `SingleInstanceBehavior` classes need to be extended.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在节点中使用了 `fireNodeOutputCallback`，因此需要扩展 `GraphEditor` 和 `SingleInstanceBehavior`
    类：
- en: 'In the `GraphEditor.cpp` file in the `graphnodes` folder, the `faceAnim` node
    type must be added to the `createNodeEditorWindow()` method to bind the node action
    callback to the newly created `faceAnim` nodes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `graphnodes` 文件夹中的 `GraphEditor.cpp` 文件中，必须在 `createNodeEditorWindow()` 方法中添加
    `faceAnim` 节点类型，以将节点动作回调绑定到新创建的 `faceAnim` 节点：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A similar check exists in the `SingleInstanceBehavior` copy constructor; we
    also have to add the `faceAnim` node type here to bind the node action callback:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SingleInstanceBehavior`复制构造函数中存在类似的检查；我们还需要在这里添加`faceAnim`节点类型以绑定节点动作回调：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In addition to a manipulation of the `InstanceSettings` variables when changing
    the face animation settings, we add two new setters to the `AssimpInstance` class
    for simplified access to the new `InstanceSettings` variables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在更改面部动画设置时操作`InstanceSettings`变量之外，我们还向`AssimpInstance`类添加了两个新的设置器，以简化对新的`InstanceSettings`变量的访问。
- en: Enabling instance and renderer to react to face animation changes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用实例和渲染器对面部动画更改做出反应
- en: 'Updating the `InstanceSettings` by reading all data first plus writing all
    data back at the end is good if we need to adjust more than multiple values. For
    a single change, separate setters are easier to use. We add the two new `public`
    methods `setFaceAnim()` and `setFaceAnimWeight()` to the `AssimpInstance` class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要调整多个值，通过先读取所有数据然后在最后写回所有数据来更新`InstanceSettings`是好的。对于单个更改，单独的设置器更容易使用。我们向`AssimpInstance`类添加了两个新的`public`方法`setFaceAnim()`和`setFaceAnimWeight()`：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both methods update the two values in the `InstanceSettings` data of the instance,
    plus a bit of extra logic to handle the `none` value of the `faceAnimation` `enum`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都会更新实例的`InstanceSettings`数据中的两个值，以及一些额外的逻辑来处理`faceAnimation` `enum`的`none`值。
- en: As the last step for the new node, the `updateInstanceSettings()` method of
    the renderer class, `OGLRenderer.cpp` or `VkRenderer.cpp`, needs to know what
    to do when an instance wants to change the face animation settings.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新节点的最后一步，渲染器类的`updateInstanceSettings()`方法（`OGLRenderer.cpp`或`VkRenderer.cpp`）需要知道当实例想要更改面部动画设置时应该做什么。
- en: 'To do that, in the `switch` block for the node type, a new `case` block for
    the new `faceAnim` node type must be added:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，在节点类型的`switch`块中，必须添加一个新的`case`块来处理新的`faceAnim`节点类型：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we check for the type of face animation update we have received. Since
    we need to react to a change to the face animation clip index and the clip weight,
    a new `switch`/`case` statement with the two update types is added:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查收到的面部动画更新类型。由于我们需要对面部动画剪辑索引和剪辑权重的变化做出反应，因此添加了一个新的`switch`/`case`语句，包含两种更新类型：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also need to close the case block for the `faceAnim` node type:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要关闭`faceAnim`节点类型的`case`块：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For the two new update types, `faceAnimIndex` and `faceAnimWeight`, the newly
    added methods in the `AssimpInstance` class will be called, using the data from
    the `nodeCallbackVariant` variant as parameters.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两种新的更新类型`faceAnimIndex`和`faceAnimWeight`，`AssimpInstance`类中新增的方法将使用`nodeCallbackVariant`变体中的数据作为参数被调用。
- en: 'This last step completes the chain from the new node to the renderer, allowing
    us to use the face animations in the node editor. The FaceAnim node to the node
    tree of the man’s model can be used to change the wave animations of all instances
    to let the instance wave with a smiling face, as shown in *Figure 10.6*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步完成了从新节点到渲染器的链路，使我们能够在节点编辑器中使用面部动画。可以将FaceAnim节点添加到男人的模型节点树中，以将所有实例的波浪动画更改为带有微笑的面部波浪，如图*图
    10.6*所示：
- en: '![](img/Figure_10.06_B22428.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.06_B22428](img/Figure_10.06_B22428.png)'
- en: 'Figure 10.6: Combined “Wave” action and “Happy” face animation in a node tree'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：节点树中结合“波浪”动作和“笑脸”动画
- en: More additions to the node tree are possible. You can make the models angry
    before punching or kicking, or surprised before playing the picking animation
    to simulate that the instance has seen something on the ground. And with more
    skeletal and face animation clips, even more funny and crazy combinations can
    be created.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 节点树中还可以添加更多内容。你可以在打或踢之前让模型生气，或者在播放拾取动画之前惊讶，以模拟实例在地面上看到了某物。而且，随着骨骼和面部动画剪辑的增多，可以创造出更多有趣和疯狂的组合。
- en: Being able to see someone’s mood in their face helps us as humans to evaluate
    possible next steps, and bringing facial expressions into the application enables
    a much broader way to interact with the instances. By using morph target animations,
    even our basic low-poly models take on much more personality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从一个人的面部表情中看到他们的情绪有助于我们人类评估可能的下一步行动，将面部表情引入应用程序使得与实例的交互方式更加广泛。通过使用形变目标动画，即使是我们的基本低多边形模型也展现出更多的个性。
- en: But morph target animations have three severe limitations, which we’ll discuss
    next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，形变目标动画有三个严重的限制，我们将在下一节讨论。
- en: Limitations of morph target animations
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形变目标动画的限制
- en: 'When using morph target animations, we must take care of these three limits:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变形目标动画时，我们必须注意这三个限制：
- en: The number of vertices in the mesh must be identical in all animations and frames.
    It is not possible to add or remove vertices within a frame or during an animation,
    or to change the vertex assignment to triangles. You can only move the vertices
    around.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格中的顶点数必须在所有动画和帧中相同。在帧内或动画过程中无法添加或删除顶点，也不能更改顶点分配到三角形的分配。你只能移动顶点。
- en: The entire mesh of the morphing part of the model must be replicated for every
    morph key in an animation. For smaller parts of the model’s body, this may be
    okay, but having a high-detail part of the body several times in memory may create
    a noticeable overhead.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的变形部分整个网格必须在动画中的每个变形键中复制。对于模型身体的小部分，这可能没问题，但身体的高细节部分在内存中多次出现可能会造成明显的开销。
- en: Only vertex position changes are supported, the morphing is usually done by
    a simple linear interpolation. Small rotations can be simulated by position changes
    but moving vertices by a large rotation or scaling, like for turning the head
    or moving the hands around, will result in visual distortions during the interpolation.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只支持顶点位置的变化，变形通常通过简单的线性插值来完成。小旋转可以通过位置变化来模拟，但通过大旋转或缩放移动顶点，例如转动头部或移动手部，将在插值过程中产生视觉扭曲。
- en: You can test the third limit by yourself in Blender. To do that, add a morph
    target-based rotation of the head, and you will see the rotation also affects
    the volume of the head. The larger the rotation angle gets, the bigger the distortion
    during the animation becomes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Blender中自己测试第三个限制。为此，添加一个基于变形目标的头部旋转，你将看到旋转也影响了头部的体积。旋转角度越大，动画中的扭曲就越大。
- en: '*Figure 10.7* shows the result of around 50% of a head rotation by 180 degrees:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.7* 展示了大约50%的头部旋转180度的结果：'
- en: '![](img/Figure_10.07_B22428.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_10.07_B22428.png)'
- en: 'Figure 10.7: Distorted volume while rotating the head with a morph target animation'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：使用变形目标动画旋转头部时的扭曲体积
- en: Morph target animations must be created and tested carefully while animating
    a model. They are a valuable addition to animations, but they still have some
    drawbacks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在对模型进行动画时，必须仔细创建和测试变形目标动画。它们是动画的有价值补充，但仍然存在一些缺点。
- en: How do we create advanced animations that may need rotations without using morph
    target animations, such as a fancy head movement animation to let the model look
    around in the virtual world?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建可能需要旋转的高级动画，而不使用变形目标动画，例如一个复杂的头部运动动画，让模型在虚拟世界中四处张望？
- en: That’s what we’ll learn next as we dive into additive blending.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入探讨加法混合，这就是我们将要学习的内容。
- en: Implementing additive blending
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现加法混合
- en: Additive blending is an alternative method of animation blending. While *normal*
    animation blending is used to interpolate between two skeletal animation clips
    and morph target animations are changing vertex positions of a mesh, additive
    blending *stacks* two different skeletal animations on top of each other.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合是动画混合的另一种方法。虽然 *正常* 动画混合用于在两个骨骼动画剪辑之间进行插值，而变形目标动画则是改变网格的顶点位置，但加法混合 *堆叠*
    两种不同的骨骼动画。
- en: The technical part of additive blending is astonishingly simple, but the effect
    achieved by the combination of two different skeletal animations leads to a much
    more natural appearance of a 3D model.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合的技术部分惊人地简单，但通过组合两种不同的骨骼动画所达到的效果，使得3D模型的外观更加自然。
- en: Let’s explore the similarities and differences between additive blending and
    the animation blending methods we already know.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨加法混合和我们已经知道的动画混合方法之间的相似之处和不同之处。
- en: How additive blending works
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法混合是如何工作的
- en: The basic idea of additive blending comes from the desire to split up model
    animations into multiple and especially independent parts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合的基本思想源于将模型动画分割成多个，尤其是独立部分的需求。
- en: 'A skeletal animation usually delivers an animation for the entire model, allowing
    the model to either run, walk, punch, or jump. Blending between skeletal animations
    will smooth the transition between these two clips but won’t add new movements.
    So, there are two different approaches: splitting the skeleton or stacking animations.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼动画通常为整个模型提供动画，使模型能够奔跑、行走、出拳或跳跃。在骨骼动画之间进行混合将平滑这两个剪辑之间的过渡，但不会添加新的动作。因此，有两种不同的方法：分割骨骼或堆叠动画。
- en: Splitting the skeleton into two or even more animation domains and playing a
    different clip for each part of the skeleton is called **layered blending**. Layered
    blending is a simple and cost-effective way to mix animations since every node
    of the skeleton is affected only by the transforms of a single animation clip,
    just the animation clips are different for the nodes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将骨骼分割成两个或更多动画域，并为骨骼的每个部分播放不同的剪辑，这被称为**分层混合**。分层混合是一种简单且成本效益高的混合动画方法，因为骨骼的每个节点只受单个动画剪辑的变换影响，只是对于节点来说，动画剪辑是不同的。
- en: But splitting the model skeleton into multiple parts with each part playing
    a different skeletal animation may lead to extra effort to synchronize clips across
    the body. Failures in a synchronous replay on a split-skeleton animation may lead
    to visual artifacts, just think of different replay speeds for the clips.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将模型骨骼分割成多个部分，每个部分播放不同的骨骼动画，可能会导致在全身同步剪辑时需要额外的努力。在分割骨骼动画上的同步回放失败可能会导致视觉伪影，想想不同回放速度的剪辑。
- en: We don’t handle layered blending in the book, but a task in the *Practical sessions*
    section is available to implement layered animation blending for the models. In
    contrast, additive blending allows *adding up* skeletal animations on top of other
    skeletal animations. While the basic movement created by the basic skeletal animation
    is applied normally, property changes of one or even more other skeletal animations
    are added to the nodes of the model, creating a concatenated motion with what’s
    provided by the basic animation. Additive blending is more expensive to calculate
    than layered blending because we need to calculate multiple animations, and we
    also have to mix all the animations together. As an example, this simple addition
    of property changes allows us to add a head movement to the normal skeletal animations.
    The model will be able to run, walk, punch, or jump from a skeletal animation
    *and* move the head around at the same time. As a bonus, facial animations are
    not affected by additive blending, so a model can walk, look to the right, and
    smile, and all three animations are running in parallel.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中没有处理分层混合，但在*实践环节*部分有一个任务可以实现模型的分层动画混合。相比之下，加性混合允许在另一个骨骼动画之上*叠加*骨骼动画。当基本骨骼动画创建的基本动作正常应用时，一个或更多其他骨骼动画的属性变化被添加到模型的节点上，从而创建一个与基本动画提供的动作连接的运动。与分层混合相比，加性混合的计算成本更高，因为我们需要计算多个动画，并且我们还需要混合所有动画。例如，这种简单的属性变化添加允许我们向正常骨骼动画中添加头部运动。模型将能够从骨骼动画中跑步、行走、出拳或跳跃，并且同时移动头部。作为额外的好处，面部动画不受加性混合的影响，因此模型可以行走、向右看并微笑，所有三个动画都在并行运行。
- en: For the technical implementation part, an additive animation is done by adding
    the differences in the node transformations between the current pose and a reference
    pose to another skeletal animation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术实现部分，通过将当前姿态与参考姿态之间的节点变换差异添加到另一个骨骼动画中，来完成加性动画。
- en: 'Let’s use another example to explain the technical side. *Figure 10.8* shows
    the first and the last keyframe for an animation that only rotates the head node
    of the model to the right (from the model’s perspective), while all other nodes
    remain in the T-pose:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用另一个例子来解释技术方面。*图10.8*显示了仅将模型头部节点向右旋转（从模型的角度看），而所有其他节点保持T形姿态的动画的第一个和最后一个关键帧：
- en: '![](img/Figure_10.08_B22428.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8](img/Figure_10.08_B22428.png)'
- en: 'Figure 10.8: Start and end pose for the additive animation “head look right”'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：加性动画“头部向右看”的起始和结束姿态
- en: As the reference pose, we use the first keyframe, with the entire model in the
    T-pose. To calculate the values for an additive animation, we take the desired
    keyframe and simply subtract the translation, rotation, and scale values of the
    reference pose from the destination pose.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考姿态，我们使用第一个关键帧，整个模型处于T形姿态。为了计算加性动画的值，我们取所需的关键帧，并简单地从目标姿态中减去参考姿态的平移、旋转和缩放值。
- en: If the model remains in the T-pose, all values for the additive animation will
    be zero. And nothing is added to the running skeletal animation, for instance,
    the walking cycle.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型保持T形姿态，加性动画的所有值都将为零。并且不会向正在运行的骨骼动画中添加任何内容，例如，行走周期。
- en: When we advance further in the animation clip in *Figure 10.8*, the rotation
    of the head will lead to a bigger difference in the rotation value of the head
    node between the current pose and the reference pose. But we will get only a difference
    for the head node, all other node transformations are still identical to the reference
    pose.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*图10.8*的动画片段中进一步前进时，头部的旋转会导致当前姿态和参考姿态之间头部节点旋转值的差异更大。但我们将只得到头部节点的差异，所有其他节点的变换仍然与参考姿态相同。
- en: Adding the difference of the head node rotation to the currently running skeletal
    animation clip is easy. Since we collect the transformation properties for all
    nodes, a combination of two skeletal animations is just a simple per-node addition
    of the values for translation and scale, and a quaternion multiplication for the
    rotation value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将头部节点旋转的差异添加到当前正在运行的骨骼动画剪辑中很容易。由于我们收集了所有节点的变换属性，两个骨骼动画的组合只是简单地按节点添加平移和缩放值，以及旋转值的四元数乘法。
- en: This addition only changes the values for nodes that have changed in the animation
    clip of the additive animation clip compared to the reference pose. All nodes
    without changes in the additive animation will remain unaltered in the skeletal
    animation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种添加只更改了与参考姿态相比在添加动画剪辑的动画剪辑中发生变化的节点值。在添加动画中没有变化的节点将在骨骼动画中保持不变。
- en: How to create suitable animations
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建合适的动画
- en: Creating animations to use in additive blending is out of the scope of this
    book, similar to creating face animations. You can use a tool like Blender, or
    use the man’s model from *Chapter 10*, which already contains four extra animations
    altering only the head.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于添加混合的动画超出了本书的范围，类似于创建面部动画。您可以使用像Blender这样的工具，或者使用*第10章*中的人模型，该模型已经包含四个额外的动画，仅改变头部。
- en: If you create extra animations by yourself, make sure to prefix the clip names
    with something common, like an underscore, or the letters *ZZZ_* to keep them
    grouped together. At least Blender tends to sort the clips by name during the
    export and since we store several clip mappings based on the index number of the
    clip in the YAML configuration file, adding the new clips at the start or somewhere
    in-between the existing clips would lead to broken config files.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己创建额外的动画，请确保在剪辑名称前加上一些常见的标识，例如下划线，或者字母*ZZZ_*，以将它们分组在一起。至少Blender在导出时会按名称排序剪辑，而且我们根据剪辑在YAML配置文件中的索引号存储了多个剪辑映射，将新剪辑添加到现有剪辑的开始或中间会导致配置文件损坏。
- en: Implementing additive animations in our application is also surprisingly simple.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中实现添加动画也非常简单。
- en: Extending the code to support additive animations
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展代码以支持添加动画
- en: 'To bring the additional data to the GPU, we add four new variables to the `struct`
    `PerInstanceAnimData` in the `OGLRenderData.h` file in the `opengl` folder:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将附加数据带到GPU上，我们在`opengl`文件夹中的`OGLRenderData.h`文件中为`struct` `PerInstanceAnimData`添加了四个新变量：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As always for Vulkan, the file is called `VkRenderData.h` and resides in the
    `vulkan` folder.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，文件名为`VkRenderData.h`，位于`vulkan`文件夹中。
- en: We split the head animation into two parts and use separate variables to control
    both the left/right animation and the up/down animation of the head. It’s impossible
    to move the head to the left and right at the same time, so we can combine those
    two directions into a single control variable. The same holds true for moving
    the head up and down.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将头部动画分为两部分，并使用单独的变量来控制头部的左右动画和上下动画。同时向左和向右移动头部是不可能的，因此我们可以将这两个方向组合成一个控制变量。对于向上和向下移动头部也是如此。
- en: 'Then, we create a new `private` compute shader called `mAssimpTransformHeadMoveComputeShader`
    in the renderer class file, `OGLRanderer.cpp`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在渲染器类文件`OGLRanderer.cpp`中创建了一个新的`private`计算着色器，名为`mAssimpTransformHeadMoveComputeShader`：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For Vulkan, we add a new `VkPipeline` handle named `rdAssimpComputeHeadMoveTransformPipeline`
    to the `VkRenderData.h` file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，我们在`VkRenderData.h`文件中添加了一个新的`VkPipeline`句柄，名为`rdAssimpComputeHeadMoveTransformPipeline`：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Since not all models may have additive head animations, we could skip the extra
    calculations if no head animations were set. We also add the new variables in
    the `PerInstanceAnimData` `struct` to the compute shader file, `assimp_instance_transform.comp.`
    The new head animation variables will be ignored, but we need to expand the struct
    to the same size in both shaders.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有模型都可能具有加法头部动画，如果没有设置头部动画，我们可以跳过额外的计算。我们还将在`PerInstanceAnimData` `struct`中添加新变量到计算着色器文件`assimp_instance_transform.comp`。新的头部动画变量将被忽略，但我们需要在两个着色器中将结构体扩展到相同的大小。
- en: Next, we copy the `assimp_instance_transform.comp` file to `assimp_instance_headmove_transform.comp`
    and load the new file into the new `mAssimpTransformHeadMoveComputeShader` compute
    shader during the `init()` method of the `OGLRenderer.cpp`. For Vulkan, we create
    the new rendering pipeline loading the head transform compute shader in the `createPipelines()`
    method of `VkRenderer.cpp`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`assimp_instance_transform.comp`文件复制到`assimp_instance_headmove_transform.comp`，并在`OGLRenderer.cpp`的`init()`方法中加载新文件到新的`mAssimpTransformHeadMoveComputeShader`计算着色器。对于Vulkan，我们在`VkRenderer.cpp`的`createPipelines()`方法中创建新的渲染管线，加载头部变换计算着色器。
- en: 'In the new shader file, most of the additions are just copy and paste work.
    We must do the following steps in the extended compute shader, using the code
    for the rotational part of the left/right head movement as examples:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的着色器文件中，大部分新增内容只是复制粘贴的工作。我们必须在扩展的计算着色器中执行以下步骤，以左侧/右侧头部运动的旋转部分的代码为例：
- en: 'Extract the animation clip numbers for both head animations:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取两个头部动画的动画剪辑编号：
- en: '[PRE61]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Extract the inverse scale factors for both head animations:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取两个头部动画的逆缩放因子：
- en: '[PRE62]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Calculate the index values for accessing the lookup data of the head animations:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算访问头部动画查找数据的索引值：
- en: '[PRE63]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Get translation, rotation, and scale values for both the reference pose at
    the first lookup positions and the desired head animation clip timestamps:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取参考姿态在第一个查找位置和所需头部动画剪辑时间戳的平移、旋转和缩放值：
- en: '[PRE64]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Calculate the difference between the transform values of the current pose and
    the references pose, using a quaternion multiplication for the rotation:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四元数乘法计算当前姿态变换值与参考姿态变换值之间的差异：
- en: '[PRE65]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add up the differences for translation, rotation, and scale for both head animations
    to a single value for each transform:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个头部动画的平移、旋转和缩放差异累加到每个变换的单个值中：
- en: '[PRE66]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the summed-up differences to the first and second clip transforms, again
    using a quaternion multiplication for the rotation:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将累加的差异添加到第一个和第二个剪辑变换中，再次使用四元数乘法进行旋转：
- en: '[PRE67]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The instances also need to carry information about the head movements, so we
    add the two new variables, `isHeadLeftRightMove` and `isHeadUpDownMove`, to the
    `InstanceSettings` `struct` in the `InstanceSettings.h` file:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实例还需要携带有关头部运动的信息，因此我们在`InstanceSettings.h`文件中的`InstanceSettings` `struct`中添加了两个新变量`isHeadLeftRightMove`和`isHeadUpDownMove`：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We map the positive ranges between `0.0f` and `1.0f` to a head movement to the
    left and upwards, and the negative range from `0.0f` to `-1.0f` to move the head
    to the right or down. A movement value of zero will use the values of the reference
    pose for both animations, resulting in no head movement at all.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`0.0f`到`1.0f`之间的正范围映射到向左和向上的头部运动，将`0.0f`到`-1.0f`的负范围映射到向右或向下的头部运动。移动值为零时将使用两个动画的参考姿态的值，导致没有任何头部运动。
- en: 'Filling the new data in the `PerInstanceAnimData` `struct` is done in the `draw()`
    call of the `OGLRenderer` or `VKRenderer` class, in the same part of the code
    as the facial animations. Following the mapping explained before, selecting the
    clip number is done as shown here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OGLRenderer`或`VKRenderer`类的`draw()`调用中填充`PerInstanceAnimData` `struct`中的新数据，这部分代码与面部动画相同。按照之前解释的映射方法，选择剪辑编号的操作如下所示：
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For head movement, we use the absolute value of the timestamp:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于头部运动，我们使用时间戳的绝对值：
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Hard coding the clip numbers in the code is a bad idea, different models have
    these new animations on other clip indices, or not at all. Let’s add another mapping,
    this time between the additive blending clip numbers and the four possible directions
    of the head movement.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中硬编码剪辑编号是一个坏主意，因为不同的模型在这些新的动画上可能有不同的剪辑索引，或者根本没有。让我们添加另一个映射，这次是在加法混合剪辑编号和头部可能移动的四个方向之间。
- en: Creating mappings for the new head animations
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为新的头部动画创建映射
- en: 'For a mapping between clips and head animations, a new `enum` `class` called
    `headMoveDirection` is created in the `Enums.h` file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剪辑和头部动画之间的映射，在 `Enums.h` 文件中创建了一个新的 `enum` `class` 叫做 `headMoveDirection`：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The corresponding string map `micHeadMoveAnimationNameMap` to show the names
    in the UI is added to the `ModelInstanceCamData` `struct`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的字符串映射 `micHeadMoveAnimationNameMap` 用于在 UI 中显示名称，被添加到 `ModelInstanceCamData`
    `结构体`：
- en: '[PRE72]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And since the mapping is model-related, the new `msHeadMoveClipMappings` mapping
    is added to the `ModelSettings` `struct` in the `ModelSettings.h` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射与模型相关，新的 `msHeadMoveClipMappings` 映射被添加到 `ModelSettings.h` 文件中的 `ModelSettings`
    `结构体`：
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `AssimpModel` class also gets a new `public` method to check whether all
    the mappings in `msHeadMoveClipMappings` are active:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpModel` 类也获得了一个新的 `public` 方法来检查 `msHeadMoveClipMappings` 中的所有映射是否都处于活动状态：'
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Failing to find at least one of the head animations leads to a disabled additive
    head animation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到至少一个头部动画，会导致添加式头部动画被禁用。
- en: 'In the `draw()` call of the `OGLRenderer.cpp` files, we switch the compute
    shader based on the availability of all head animation mappings:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OGLRenderer.cpp` 文件的 `draw()` 调用中，我们根据所有头部动画映射的可用性切换计算着色器：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For Vulkan, we use the availability of head move animations to choose the pipeline
    to bind for the compute shader in the `runComputeShaders()` method of the `VkRenderr.cpp`
    file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan，我们在 `VkRenderr.cpp` 文件的 `runComputeShaders()` 方法中使用头部移动动画的可用性来选择绑定到计算着色器的管道：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The UI part for the head animations can be copied mostly from other parts of
    the code in the `UserInterface` class. A combo box to select the clip, a loop
    over all four values in the `headMoveDirection` `enum`, two buttons, and two sliders
    to test the animations are all we need to create a new UI section, as shown in
    *Figure 10.9*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 头部动画的 UI 部分可以主要从 `UserInterface` 类中的其他部分复制代码。一个用于选择剪辑的组合框，一个遍历 `headMoveDirection`
    `enum` 中所有四个值的循环，两个按钮和两个滑块来测试动画，这些都是我们创建一个新 UI 部分（如图 10.9 所示）所需的所有内容：
- en: '![](img/Figure_10.09_B22428.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_10.09_B22428.png)'
- en: 'Figure 10.9: UI control for the head movement/animation clip mapping'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：头部运动/动画剪辑映射的 UI 控制
- en: Clip mapping and clips are taken from the model of the currently selected instance,
    making it easy to configure the additive head animations for all models.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪映射和裁剪来自当前选定实例的模型，这使得为所有模型配置添加式头部动画变得容易。
- en: To use the head animation in node trees, another new node type is needed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要在节点树中使用头部动画，还需要另一个新的节点类型。
- en: Adding a head animation node
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加头部动画节点
- en: Thanks to the previous `FaceAnimNode` node, adding a new `HeadAnimNode` is done
    in minutes. You can follow the steps in the *Using face animations in node trees*
    section to create the new node as you have to do the same actions as with the
    `FaceAnimNode`. Only a couple of minor changes are needed, like the names of the
    `enum` `class` entries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了之前的 `FaceAnimNode` 节点，添加新的 `HeadAnimNode` 只需几分钟。你可以按照 *使用节点树中的面部动画* 部分的步骤创建新节点，因为你必须执行与
    `FaceAnimNode` 相同的操作。只需要进行一些小的更改，比如 `enum` `class` 条目的名称。
- en: For the UI part of the new node, you can reuse the `FaceAnimNode` class code
    for the controls and copy the code to switch the two sections on or off from the
    `InstanceNode` class code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新节点的 UI 部分，你可以重用 `FaceAnimNode` 类代码进行控制，并将代码从 `InstanceNode` 类代码复制到切换两个部分的开或关。
- en: 'The final **HeadAnim** node to be used in a node tree looks like in *Figure
    10.10*:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点树中使用的最终 **头部动画** 节点看起来像 *图 10.10*：
- en: '![](img/Figure_10.10_B22428.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_10.10_B22428.png)'
- en: 'Figure 10.10: The HeadAnim node'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：头部动画节点
- en: Like the Instance node, we can control which head animation values we want to
    change, and for each animation, we can adjust the starting and ending weight plus
    the time it takes to blend between the two weight values. And like the FaceAnim
    node, the HeadAnim node delays the control flow until both timers are expired
    and signals the end of the execution to the parent node.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例节点一样，我们可以控制我们想要更改的头部动画值，并且对于每个动画，我们可以调整起始和结束权重以及两个权重值之间混合所需的时间。并且像 `FaceAnimNode`
    节点一样，`HeadAnim` 节点延迟控制流直到两个计时器都过期，并向父节点发出执行结束的信号。
- en: We close the chapter with the changes needed to save and load the settings for
    the additive head animations.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以保存和加载添加式头部动画设置所需的变化来结束本章。
- en: Saving and loading the head animation settings
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载头部动画设置
- en: Similar to the new tree node, implementing the YAML configuration file changes
    to save and load head animation settings is a matter of minutes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与新的树节点类似，实现YAML配置文件更改以保存和加载头部动画设置只需几分钟。
- en: 'For the `ModelSettings` YAML emitter output in the `YamlParser.cpp` file, we
    add the clip mappings directly from the map if all four clips are configured.
    We also need a new emitter output for the `headMoveDirection` `enum`, casting
    the value to an `int`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`YamlParser.cpp`文件中的`ModelSettings` YAML发射器输出，如果所有四个剪辑都配置了，我们直接从映射中添加剪辑映射。我们还需要为`headMoveDirection`
    `enum`添加一个新的发射器输出，将值转换为`int`：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To load the mapping back, we add a section to the `decode()` method for the
    `ModelSettings` in the `YamlParserTypes.h` file, reading back the map values one
    by one. A new `decode()` method for the `headMoveDirection` `enum` is needed here
    too:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载映射回，我们在`YamlParserTypes.h`文件中的`ModelSettings`的`decode()`方法中添加了一个部分，逐个读取映射值。这里还需要一个新的`decode()`方法用于`headMoveDirection`
    `enum`：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And for the instance settings, the two `float` values stored in the `isHeadLeftRightMove`
    and `isHeadUpDownMove` of the `InstanceSettings` are added to the emitter in `YamlParser.cpp`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例设置，`InstanceSettings`中的`isHeadLeftRightMove`和`isHeadUpDownMove`存储的两个`float`值被添加到`YamlParser.cpp`中的发射器中：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And the two values are also to the `decode()` method for the `ExtendedInstanceSettings`
    data type in `YamlParserTypes.h`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值也被添加到`YamlParserTypes.h`文件中`ExtendedInstanceSettings`数据类型的`decode()`方法中：
- en: '[PRE80]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After all these additions, you can add some HeadAnim nodes to the node tree
    of the man’s model, creating animations like the one shown in *Figure 10.11*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些添加之后，你可以在男人的模型节点树中添加一些HeadAnim节点，创建如图*图10.11*所示的动画：
- en: '![](img/Figure_10.11_B22428.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_10.11_B22428.png)'
- en: 'Figure 10.11: The instance looks up while waving and smiling'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：实例在挥手和微笑时抬头
- en: The instance can now turn the head at any time in a natural manner, we just
    need to add the new HeadAnim node to the control flow. If you go back to *Figure
    10.6*, you will see that a small addition like the head movement makes an enormous
    difference in the appearance of the instance.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实例可以以自然的方式在任何时候转动头部，我们只需要将新的HeadAnim节点添加到控制流程中。如果你回到*图10.6*，你会看到像头部运动这样的小添加对实例外观的影响是巨大的。
- en: You can let your imagination flow about other possibilities for the new head
    movement. Do you want the head to follow the camera or any other nearby instance?
    Do you want to nod the head to signal *yes* and shake the head slightly if the
    answer to a question is *no*? Do you want to make the player look up or down to
    move the player’s point of interest toward the sky or the floor? Some ideas are
    listed in the *Practical sessions* section if you want to extend the code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让你的想象力在新的头部运动上自由发挥。你希望头部跟随相机或任何其他附近的实例吗？你希望点头表示*是*，如果问题的答案是*否*，则轻微摇动头部吗？你希望让玩家向上或向下看，以将玩家的兴趣点移动到天空或地板吗？如果你想要扩展代码，*实践课程*部分中列出了一些想法。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added both facial expressions and separate head animations
    to the instances. We started with a brief exploration of face animations. Then
    we implemented face animations in the form of morph target animations to code
    and shaders, enabling the instances to smile or be angry. Next, we added a tree
    node for the face animations, enabling us to use the new facial expressions in
    the node trees. Finally, we looked at additive animation blending and added head
    movement by using additive blending, including a new tree node and UI controls.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将面部表情和单独的头部动画添加到实例中。我们首先对面部动画进行了简要探索。然后，我们将面部动画以形态目标动画的形式实现到代码和着色器中，使实例能够微笑或愤怒。接下来，我们为面部动画添加了一个树节点，使我们能够在节点树中使用新的面部表情。最后，我们研究了加法动画混合，并使用加法混合添加了头部运动，包括一个新的树节点和UI控件。
- en: In the next chapter, we will leave the animation controls for a while and give
    the instances literally a room to live in by adding level data to the virtual
    world, like a game level. We start by checking the formats supported by the Open
    Assimp Importer Library and search for available level files. Then, we explore
    reasons why we should separate level data from models and instances. Finally,
    we load the level data from a file and add the level-related data to the application
    and renderer.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时放下动画控制，通过向虚拟世界添加关卡数据（如游戏关卡）来让实例真正有一个生活空间。我们首先检查Open Assimp导入库支持的格式，并搜索可用的关卡文件。然后，我们探讨为什么我们应该将关卡数据从模型和实例中分离出来。最后，我们从文件中加载关卡数据，并将与关卡相关的数据添加到应用程序和渲染器中。
- en: Practical sessions
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践环节
- en: 'Here are some additions you could make to the code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的内容：
- en: Add support for multiple meshes containing morph target animations.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对包含形态目标动画的多个网格的支持。
- en: Currently, only one mesh of a model can have morph target animations. For a
    simple head animation, this limit is fine. But if you want to control more than
    one part of the face, using multiple morph targets may be helpful.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，一个模型只能有一个网格具有形态目标动画。对于简单的头部动画，这个限制是可以的。但如果你想要控制脸部超过一个部分，使用多个形态目标可能会有所帮助。
- en: Add blending between two morph targets. For even better and more natural facial
    expressions, a direct blending between two morph targets would be nice. A detour
    via the neutral position is no longer needed, then, but a direct path between
    anger and worry is available.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个形态目标之间添加混合。为了更好的自然面部表情，两个形态目标之间的直接混合会很棒。不再需要通过中性位置绕道，愤怒和担忧之间的直接路径现在可用。
- en: Add more morph targets.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多的形态目标。
- en: You may try to let the models *speak*. You could add expressions for different
    vowels and consonants, including the direct blending from the previous task. With
    such animations, you could mimic instances speaking to you during interactions.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试让模型*说话*。你可以为不同的元音和辅音添加表情，包括从上一个任务中直接混合。有了这样的动画，你可以在交互时模仿实例对你说话。
- en: Add layered/masked animations.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加分层/遮罩动画。
- en: In contrast to additive animation blending, layered blending uses different
    skeletal animation clips for distinct parts of the model’s virtual body. For instance,
    all but the right arm uses the running animation and only the right arm plays
    the waving animation. As noted in the *How additive blending works* section, layered
    animations may need additional effort to synchronize the two animation clips.
    You need to add some logic to mask out parts of the model’s skeleton.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与附加动画混合不同，分层混合使用不同的骨骼动画剪辑来处理模型虚拟身体的各个部分。例如，除了右臂之外的所有部分都使用跑步动画，只有右臂播放挥动手臂的动画。正如在*如何实现附加混合*部分中提到的，分层动画可能需要额外的努力来同步两个动画剪辑。你需要添加一些逻辑来遮罩模型骨骼的某些部分。
- en: 'Let the instance turn their head toward you on interaction. This is a feature
    of many games: if you start interacting with an instance, they turn their head
    around to look directly toward you.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让实例在交互时将头转向你。这是许多游戏的一个特性：如果你开始与一个实例交互，它们会转身直接朝向你。
- en: 'Let nearby instances *judge* you. This is like the previous task: you could
    also add the additive head-turning animation to instances walking near you. Add
    a random facial expression too, enabling the instances to show some sort of emotion
    when they pass near you.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让附近的实例*评判*你。这就像之前的任务：你也可以为靠近你的实例添加附加的头部转向动画。还要添加一个随机的面部表情，让实例在经过你附近时表现出某种情绪。
- en: Let the instances smile and wave at the nearest instance passing by.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让实例对经过的最近实例微笑和挥手。
- en: 'This is a combination and extension of the two previous tasks: use the interaction
    logic to find the nearest instance for every instance in the virtual world, then
    move the head towards that instance. Play the smiling morph animation and a new
    additive animation with only the right arm waving. You might want to use a layered
    animation for the arm here.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前两个任务的组合和扩展：使用交互逻辑找到虚拟世界中每个实例的最近实例，然后将头部移动向那个实例。播放微笑的形态动画和只有右臂挥动的新的附加动画。你可能想在这里为手臂使用分层动画。
- en: Add more additive blending animations.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多的附加混合动画。
- en: Turning the head around is a good start, but what about doing an entire animation
    of someone looking around? Try to add more layers of additive blending animations
    to make instances make gestures in interaction.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 转动头部是一个好的开始，但如果是制作一个人四处张望的整个动画呢？尝试添加更多层的叠加混合动画，使实例在交互中做出手势。
- en: Optimize C++ and shader code for better performance.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化C++和着色器代码以获得更好的性能。
- en: The current C++ and GLSL shader code and the data structures on the CPU and
    GPU were created to explain and explore the features we added here, like morph
    target animations and facial expressions. There is a lot of room left for optimization,
    both on the CPU and the GPU. You could try to squeeze more frames per second out
    of the application, for instance, by optimizing the data types sent to the GPU,
    by moving more work to compute shaders, or by removing the busy-waits for the
    shader results on Vulkan. You could also check if data compression has a positive
    or negative outcome on the frame times. For an easy comparison, add a checkbox
    to the UI to switch between the default code and the optimized version.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当前在CPU和GPU上的C++和GLSL着色器代码以及数据结构是为了解释和探索我们在这里添加的功能，如形变目标动画和面部表情。在CPU和GPU上都有很大的优化空间。例如，你可以尝试从应用程序中挤出更多的每秒帧数，通过优化发送到GPU的数据类型，将更多的工作转移到计算着色器，或者通过在Vulkan上移除对着色器结果的忙碌等待。你也可以检查数据压缩对帧时间是否有积极或消极的影响。为了便于比较，可以在UI中添加一个复选框来在默认代码和优化版本之间切换。
- en: Additional resources
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Layered animations in Unreal Engine: [https://dev.epicgames.com/documentation/en-us/unreal-engine/using-layered-animations-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/using-layered-animations-in-unreal-engine)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻引擎中的分层动画：[https://dev.epicgames.com/documentation/en-us/unreal-engine/using-layered-animations-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/using-layered-animations-in-unreal-engine)
- en: 'Additive animations in Unreal Engine: [https://dev.epicgames.com/documentation/en-us/unreal-engine/additive-vs.-full-body?application_version=4.27](https://dev.epicgames.com/documentation/en-us/unreal-engine/additive-vs.-full-body?application_version=4.27)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚幻引擎中的叠加动画：[https://dev.epicgames.com/documentation/en-us/unreal-engine/additive-vs.-full-body?application_version=4.27](https://dev.epicgames.com/documentation/en-us/unreal-engine/additive-vs.-full-body?application_version=4.27)
- en: 'Unity Animation Layers: [https://docs.unity3d.com/Manual/AnimationLayers.html](https://docs.unity3d.com/Manual/AnimationLayers.html)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity动画层：[https://docs.unity3d.com/Manual/AnimationLayers.html](https://docs.unity3d.com/Manual/AnimationLayers.html)
- en: 'Godot Animation Trees: [https://docs.godotengine.org/en/latest/tutorials/animation/animation_tree.html](https://docs.godotengine.org/en/latest/tutorials/animation/animation_tree.html)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Godot动画树：[https://docs.godotengine.org/en/latest/tutorials/animation/animation_tree.html](https://docs.godotengine.org/en/latest/tutorials/animation/animation_tree.html)
- en: 'Blender: [https://www.blender.org](https://www.blender.org)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Blender: [https://www.blender.org](https://www.blender.org)'
- en: 'Blender Shape Keys: [https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html](https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender形状键：[https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html](https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html)
