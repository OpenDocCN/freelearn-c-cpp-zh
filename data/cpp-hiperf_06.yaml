- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Ranges and Views
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围和视图
- en: This chapter will pick up right where we left off in the previous chapter about
    algorithms and their limitations. Views from the Ranges library are a powerful
    complement to the Algorithm library, which allows us to compose multiple transformations
    into a lazy evaluated view over a sequence of elements. After reading this chapter,
    you will understand what range views are and how to use them in combination with
    containers, iterators, and algorithms from the standard library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续上一章关于算法及其局限性的内容。Ranges库中的视图是Algorithm库的强大补充，它允许我们将多个转换组合成一个惰性评估的视图，覆盖元素序列。阅读完本章后，您将了解什么是范围视图，以及如何将它们与标准库中的容器、迭代器和算法结合使用。
- en: 'Specifically, we''ll cover the following major topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主要主题：
- en: The composability of algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的可组合性
- en: Range adaptors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围适配器
- en: Materializing views into containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视图实例化为容器
- en: Generating, transforming, and sampling elements in a range
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围内生成、转换和抽样元素
- en: Before we get into the Ranges library itself, let's discuss why it's been added
    to C++20, and why we'd want to use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论Ranges库本身之前，让我们讨论一下为什么它被添加到C++20中，以及为什么我们想要使用它。
- en: The motivation for the Ranges library
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ranges库的动机
- en: 'With the introduction of the Ranges library to C++20 came some major improvements
    to how we benefit from the standard library when implementing algorithms. The
    following list shows the new features:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Ranges库引入到C++20中，我们在实现算法时从标准库中获益的方式得到了一些重大改进。以下列表显示了新功能：
- en: Concepts that define requirements on iterators and ranges can now be better
    checked by the compiler and provide more help during development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义迭代器和范围要求的概念现在可以由编译器更好地检查，并在开发过程中提供更多帮助
- en: New overloads of all functions in the `<algorithm>` header are constrained with
    the concepts just mentioned and accept ranges as arguments rather than iterator
    pairs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<algorithm>`头文件中所有函数的新重载都受到了刚才提到的概念的约束，并接受范围作为参数，而不是迭代器对'
- en: Constrained iterators in the iterator header
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器头文件中的约束迭代器
- en: Range views, which make it possible to compose algorithms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围视图，使得可以组合算法
- en: 'This chapter will focus on the last item: the concept of views, which allow
    us to compose algorithms to avoid the unnecessary copying of data to owning containers.
    To fully understand the importance of this, let''s begin by demonstrating the
    lack of composability within the algorithm library.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点放在最后一项上：视图的概念，它允许我们组合算法以避免将数据不必要地复制到拥有的容器中。为了充分理解这一点，让我们从算法库中的可组合性不足开始。
- en: Limitations of the Algorithm library
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法库的局限性
- en: 'standard library algorithms are lacking in one fundamental aspect: composability.
    Let''s examine what is meant by that by looking at the last example from *Chapter
    5*, *Algorithms*, where we discussed this briefly. If you remember, we had a class
    to represent a `Student` in a particular year and with a particular exam score:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库算法在一个基本方面存在局限性：可组合性。让我们通过查看*第5章*，*算法*中的最后一个示例来了解这一点，我们在那里简要讨论了这个问题。如果您还记得，我们有一个类来表示特定年份和特定考试分数的`Student`。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we wanted to find the highest score from a big collection of students in
    their second year, we would probably use `max_element()` on `score_`, but as we
    only want to take the students in a specific year into account, it gets tricky.
    By using the new algorithms that accept both ranges and projections (refer to
    *Chapter 5*, *Algorithms*), we might end up with something like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从一个大量学生的集合中找到他们第二年的最高分，我们可能会在`score_`上使用`max_element()`，但由于我们只想考虑特定年份的学生，这就变得棘手了。通过使用接受范围和投影的新算法（参见*第5章*，*算法*），我们可能会得到类似这样的结果：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of how it can be used:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明了它的使用方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This implementation of `get_max_score()` is easy to understand, but it creates
    unnecessary copies of `Student` objects when using `copy_if()` and `std::back_inserter()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`get_max_score()`的实现很容易理解，但在使用`copy_if()`和`std::back_inserter()`时会创建不必要的`Student`对象的副本。
- en: 'You may now be thinking that `get_max_score()` could be written as a simple
    `for-`loop, which relieves us of extra allocation(s) due to `copy_if()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能会认为`get_max_score()`可以写成一个简单的`for-`循环，这样就可以避免由于`copy_if()`而产生额外的分配。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although this is easily achievable in this small example, we would like to be
    able to implement this algorithm by composing small algorithmic building blocks,
    rather than implementing it from scratch using a single `for`-loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个小例子中很容易实现，但我们希望能够通过组合小的算法构建块来实现这个算法，而不是使用单个`for`-循环从头开始实现它。
- en: What we would like is a syntax that is as readable as using algorithms, but
    with the ability to avoid constructing new containers for every step in the algorithm.
    This is where the views from the Ranges library come into play. Although the Ranges
    library contains a lot more than views, the major difference from the Algorithm
    library is the ability to compose what is essentially a different kind of iterator
    into a lazy evaluated range.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一种语法，它与使用算法一样易读，但又能够避免在算法的每一步中构造新的容器。这就是Ranges库中的视图发挥作用的地方。虽然Ranges库包含的不仅仅是视图，但与Algorithm库的主要区别在于能够将本质上不同类型的迭代器组合成惰性评估的范围。
- en: 'This is what the previous example would look if it was written using views
    from the Ranges library:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Ranges库中的视图编写前面的示例，它将如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we are back to using algorithms and can, therefore, avoid mutable variables,
    `for`-loops, and `if`-statements. The extra vector that held students in a specific
    year in our initial example has now been eliminated. Instead, we have composed
    a range view, which represents all of the students filtered by the `by_year` predicate,
    and then transformed to only expose the score. The view is then passed to a small
    utility function `max_value()`, which uses the `max_element()` algorithm to compare
    the scores of the selected students in order to find the maximum value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们又开始使用算法，因此可以避免可变变量、`for`循环和`if`语句。在我们的初始示例中，保存特定年份学生的额外向量现在已经被消除。相反，我们已经组成了一个范围视图，它代表了所有通过`by_year`谓词过滤的学生，然后转换为只暴露分数。然后将视图传递给一个小型实用程序函数`max_value()`，该函数使用`max_element()`算法来比较所选学生的分数，以找到最大值。
- en: This way of composing algorithms by chaining them together and, at the same
    time, avoiding unnecessary copying is what motivates us to start using views from
    the Ranges library.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将算法链接在一起来组成算法，并同时避免不必要的复制，这就是我们开始使用Ranges库中的视图的动机。
- en: Understanding views from the Ranges library
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Ranges库中理解视图
- en: Views in the Ranges library are lazy evaluated iterations over a range. Technically,
    they are only iterators with built-in logic, but syntactically, they provide a
    very pleasant syntax for many common operations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges库中的视图是对范围的惰性评估迭代。从技术上讲，它们只是具有内置逻辑的迭代器，但从语法上讲，它们为许多常见操作提供了非常愉快的语法。
- en: 'The following is an example of how to use a view to square each number in a
    vector (via iteration):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用视图来对向量中的每个数字进行平方的示例（通过迭代）：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The variable `squared_view` is not a copy of the `numbers` vector with the values
    squared; it is a proxy object for numbers with one slight difference—every time
    you access an element, the `std::transform()` function is invoked. This is why
    we say that a view is lazy evaluated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`squared_view`不是`numbers`向量的值平方的副本；它是一个代理对象，有一个细微的区别——每次访问一个元素时，都会调用`std::transform()`函数。这就是为什么我们说视图是惰性评估的。
- en: From the outside, you can still iterate over `squared_view` in the same way
    as any regular container and, therefore, you can perform regular algorithms such
    as `find()` or `count()`, but, internally, you haven't created another container.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部来看，你仍然可以像任何常规容器一样迭代`squared_view`，因此你可以执行常规算法，比如`find()`或`count()`，但在内部，你没有创建另一个容器。
- en: If you want to store the range, the view can be materialized to a container
    using `std::ranges::copy()`. (This will be demonstrated later on in this chapter.)
    Once the view has been copied back to a container, there is no longer any dependency
    between the original and the transformed container.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要存储范围，可以使用`std::ranges::copy()`将视图实现为容器。（这将在本章后面进行演示。）一旦视图被复制回容器，原始容器和转换后的容器之间就不再有任何依赖关系。
- en: 'With ranges, it is also possible to create a filtered view where only a part
    of the range is visible. In this case, only the elements that satisfy the condition
    are visible when iterating the view:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围，还可以创建一个过滤视图，其中只有范围的一部分是可见的。在这种情况下，只有满足条件的元素在迭代视图时是可见的：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another example of the versatility of the Ranges library is the possibility
    it offers to create a view that can iterate over several containers as if they
    were a single list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges库的多功能性的另一个例子是它提供了创建一个视图的可能性，该视图可以迭代多个容器，就好像它们是一个单一的列表一样：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have looked briefly at some examples using views, let's examine
    the requirements and properties that are common for all views
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要地看了一些使用视图的例子，让我们来检查所有视图的共同要求和属性
- en: Views are composable
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图是可组合的
- en: 'The full power of views comes from the ability to combine them. As they don''t
    copy the actual data, you can express multiple operations on a dataset while,
    internally, only iterating over it once. To understand how views are composed,
    let''s look at our initial example, but without using the pipe operator for composing
    the views; instead, let''s construct the actual view classes directly. Here is
    how this looks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的全部功能来自于能够将它们组合在一起。由于它们不复制实际数据，因此可以在数据集上表达多个操作，而在内部只迭代一次。为了理解视图是如何组成的，让我们看一下我们的初始示例，但是不使用管道运算符来组合视图；相反，让我们直接构造实际的视图类。这是它的样子：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We begin by creating a `std::ranges::ref_view`, which is a thin wrapper around
    a container. In our case, it turns the vector `s` into a view that is cheap to
    copy. We need this because our next view, `std::ranges::filter_view`, requires
    a view as its first parameter. As you can see, we compose our next view by referring
    to the previous view in the chain.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`std::ranges::ref_view`，它是一个围绕容器的薄包装。在我们的情况下，它将向量`s`转换为一个便宜的视图。我们需要这个，因为我们的下一个视图`std::ranges::filter_view`需要一个视图作为它的第一个参数。正如你所看到的，我们通过引用链中的前一个视图来组成我们的下一个视图。
- en: This chain of composable views can, of course, be made arbitrarily long. The
    algorithm `max_element()` doesn't need to know anything about the complete chain;
    it only needs to iterate the range `v3`, as it was an ordinary container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可组合视图的链当然可以任意延长。算法`max_element()`不需要知道完整链的任何信息；它只需要迭代范围`v3`，就像它是一个普通的容器一样。
- en: 'The following diagram is a simplified view of the relationships between the
    `max_element()` algorithm, the views, and the input container:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是`max_element()`算法、视图和输入容器之间关系的简化视图：
- en: '![](img/B15619_06_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_06_01.png)'
- en: 'Figure 6.1: The top level algorithm, std::ranges::max_element(), pulls values
    from the views which lazyily process elements from the underlying container (std::vector)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：顶层算法std::ranges::max_element()从视图中提取值，这些视图惰性地处理来自底层容器（std::vector）的元素
- en: 'Now, this style of composing views is a bit verbose, and if we were to try
    to remove the intermediate variables `v1` and `v2`, we would end up with something
    like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种组合视图的方式有点冗长，如果我们试图去除中间变量`v1`和`v2`，我们最终会得到这样的东西：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, this might not look syntactically elegant. By getting rid of the intermediate
    variables, we have something that is hard to read even to a trained eye. We are
    also forced to read the code from the inside out to understand the dependencies.
    Fortunately, the Ranges library provides us with range adaptors, which is the
    preferred way of composing views.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能看起来不太语法优雅。通过摆脱中间变量，我们得到了一些即使对训练有素的人来说也很难阅读的东西。我们还被迫从内到外阅读代码以理解依赖关系。幸运的是，Ranges库为我们提供了范围适配器，这是组合视图的首选方式。
- en: Range views come with range adaptors
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围视图配有范围适配器
- en: 'As you have seen earlier, the Ranges library also allows us to compose views
    using range adaptors and pipe operators for a much more elegant syntax (you will
    learn more about using the pipe operator in your own code in *Chapter 10*, *Proxy
    Objects and Lazy Evaluation*). The previous code example could be rewritten by
    using range adaptor objects, and we would have something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，Ranges库还允许我们使用范围适配器和管道运算符来组合视图，从而获得更加优雅的语法（你将在*第10章*，*代理对象和延迟评估*中学习如何在自己的代码中使用管道运算符）。前面的代码示例可以通过使用范围适配器对象进行重写，我们会得到类似这样的东西：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The ability to read a statement from left to right, rather than inside out,
    makes the code much easier to read. If you have used a Unix shell, you are probably
    familiar with this notation for chaining commands.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右阅读语句的能力，而不是从内到外，使得代码更容易阅读。如果你使用过Unix shell，你可能熟悉这种用于链接命令的表示法。
- en: Each view in the Ranges library has a corresponding range adaptor object that
    can be used together with the pipe operator. When using the range adaptors, we
    can also skip the extra `std::ranges::ref_view` since the range adaptors work
    directly with `viewable_ranges`, namely, a range that can be safely converted
    into a `view`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges库中的每个视图都有一个相应的范围适配器对象，可以与管道运算符一起使用。在使用范围适配器时，我们还可以跳过额外的`std::ranges::ref_view`，因为范围适配器直接与`viewable_ranges`一起工作，即可以安全转换为`view`的范围。
- en: 'You can think of a range adaptor as a global stateless object that has two
    functions implemented: `operator()()` and `operator|()`. Both functions construct
    and return view objects. The pipe operator is what is being used in the preceding
    example. But it is also possible to use the call operator to form a view using
    a nested syntax with parentheses, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将范围适配器视为一个全局无状态对象，它实现了两个函数：`operator()()`和`operator|()`。这两个函数都构造并返回视图对象。管道运算符是在前面的示例中使用的。但也可以使用调用运算符使用嵌套语法来形成视图，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, when using range adaptors, there is no need to wrap the input container
    in a `ref_view`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在使用范围适配器时，无需将输入容器包装在`ref_view`中。
- en: 'To summarize, each view in the Ranges library consists of:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Ranges库中的每个视图包括：
- en: A class template (the actual view type) that operates on view objects, for example,
    `std::ranges::transform_view`. These view types can be found under the namespace
    `std::ranges`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类模板（实际视图类型），它操作视图对象，例如`std::ranges::transform_view`。这些视图类型可以在命名空间`std::ranges`下找到。
- en: A range adaptor object that creates instances of the view class from ranges,
    for example, `std::views::transform`. All range adaptors implement `operator()()`
    and `operator|()`, which makes it possible to compose transformations using the
    pipe operator or by nesting. The range adaptor objects live under the namespace
    `std::views`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个范围适配器对象，它从范围创建视图类的实例，例如`std::views::transform`。所有范围适配器都实现了`operator()()`和`operator|()`，这使得可以使用管道运算符或嵌套来组合转换。范围适配器对象位于命名空间`std::views`下。
- en: Views are non-owning ranges with complexity guarantees
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图是具有复杂性保证的非拥有范围
- en: In the previous chapter, the concept of a range was introduced. Any type that
    provides the functions `begin()` and `end()`, where `begin()` returns an iterator
    and `end()` returns a sentinel, qualifies as a range. We concluded that all standard
    containers are ranges. Containers own their elements, so we can, therefore, call
    them owning ranges.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，介绍了范围的概念。任何提供`begin()`和`end()`函数的类型，其中`begin()`返回一个迭代器，`end()`返回一个哨兵，都可以作为范围。我们得出结论，所有标准容器都是范围。容器拥有它们的元素，因此我们可以称它们为拥有范围。
- en: A view is also a range, that is, it provides `begin()` and `end()` functions.
    However, unlike containers, a view does not own the elements in the range that
    the view spans over.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 视图也是一个范围，它提供`begin()`和`end()`函数。然而，与容器不同，视图不拥有它们所覆盖的范围中的元素。
- en: The construction of a view is required to be a constant-time operation, *O(1)*.
    It cannot perform any work that depends on the size of the underlying container.
    The same goes for assigning, copying, moving, and destructing a view. This makes
    it easy to reason about performance when using views to combine multiple algorithms.
    It also makes it impossible for views to own elements, since that would require
    linear time complexity upon construction and destruction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的构造必须是一个常量时间操作，*O(1)*。它不能执行任何依赖于底层容器大小的工作。对于视图的赋值、复制、移动和销毁也是如此。这使得在使用视图来组合多个算法时，很容易推断性能。它还使得视图无法拥有元素，因为这将需要在构造和销毁时具有线性时间复杂度。
- en: Views don't mutate the underlying container
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图不会改变底层容器
- en: 'At first glance, a view might look like a mutated version of the input container.
    However, the container is not mutated at all: all the processing is performed
    in the iterators. A view is simply a proxy object that, when iterated, *looks*
    like a mutated container.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，视图可能看起来像是输入容器的变异版本。然而，容器根本没有发生变异：所有处理都是在迭代器中进行的。视图只是一个代理对象，当迭代时，*看起来*像是一个变异的容器。
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Perhaps we have a function that operates on a container that we want to transform
    using range algorithms, and then we want to return and store it back in a container.
    For example, in the example above, we might want to actually store the strings
    in a separate container. You will learn how to do that in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们有一个在容器上操作的函数，我们想要使用范围算法进行转换，然后我们想要返回并将其存储回容器。例如，在上面的例子中，我们可能确实想要将字符串存储在一个单独的容器中。您将在下一节中学习如何做到这一点。
- en: Views can be materialized into containers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图可以实体化为容器
- en: Sometimes, we want to store the view in a container, that is, **materialize**
    the view. All views can be materialized into containers, but it is not as easy
    as you would have hoped. A function template called `std::ranges::to<T>()`, which
    could turn a view into an arbitrary container type `T`, was proposed for C++20
    but didn't quite make it. Hopefully we will get something similar in a future
    version of C++. Until then, we need to do a little more work ourselves in order
    to materialize views.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要将视图存储在容器中，即**实体化**视图。所有视图都可以实体化为容器，但这并不像您希望的那样容易。C++20提出了一个名为`std::ranges::to<T>()`的函数模板，它可以将视图转换为任意容器类型`T`，但并没有完全实现。希望我们在将来的C++版本中能够得到类似的东西。在那之前，我们需要做更多的工作来实体化视图。
- en: 'In the previous example, we converted `ints` into `std::strings`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`ints`转换为`std::strings`，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if we want to materialize the range `r` to a vector, we could use `std::ranges::copy()`
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要将范围`r`实体化为一个向量，我们可以像这样使用`std::ranges::copy（）`：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Materializing views is a common operation, so it would be handy if we had a
    generic utility for this case. Say that we want to materialize some arbitrary
    view into a `std::vector`; we could use some generic programming to come up with
    the following convenient utility function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实体化视图是一个常见的操作，所以如果我们有一个通用的实用程序来处理这种情况会很方便。假设我们想要将一些任意视图实体化为`std::vector`；我们可以使用一些通用编程来得到以下方便的实用函数：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We haven't talked much about generic programming yet in this book, but the next
    few chapters will explain the use of `auto` argument types and `if constexpr`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们还没有讨论过泛型编程，但接下来的几章将解释使用`auto`参数类型和`if constexpr`。
- en: We are using `reserve()` to optimize the performance of this function. It will
    preallocate enough room for all of the elements in the range to avoid further
    allocations. However, we can only call `reserve()` if we know the size of the
    range, and therefore we have to use the `if constexpr` statement to check whether
    the range is a `size_range` at compile time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`reserve（）`来优化此函数的性能。它将为范围中的所有元素预先分配足够的空间，以避免进一步的分配。但是，我们只能在知道范围的大小时调用`reserve（）`，因此我们必须使用`if
    constexpr`语句在编译时检查范围是否为`size_range`。
- en: 'With this utility in place, we can transform a container of some type into
    a vector holding elements of another arbitrary type. Let''s see how to convert
    a list of integers to a vector of `std::strings` using `to_vector()`. Here is
    an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个实用程序，我们可以将某种类型的容器转换为持有另一种任意类型元素的向量。让我们看看如何使用`to_vector（）`将整数列表转换为`std::strings`的向量。这是一个例子：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that once the view has been copied back to a container, there is no
    longer any dependency between the original and the transformed container. This
    also means that the materialization is an eager operation, whereas all view operations
    are lazy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一旦视图被复制回容器，原始容器和转换后的容器之间就不再有任何依赖关系。这也意味着实体化是一种急切的操作，而所有视图操作都是惰性的。
- en: Views are lazy evaluated
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图是惰性评估的
- en: All of the work that is performed by a view happens lazily. This is the opposite
    of the functions found in the `<algorithm>` header, which perform their work immediately
    on all elements when they are called.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 视图执行的所有工作都是惰性的。这与`<algorithm>`头文件中的函数相反，后者在调用时立即对所有元素执行其工作。
- en: You have seen that the `std::views::filter` view can replace the algorithm `std::copy_if()`,
    and that the `std::views::transform` view can replace the `std::transform()` algorithm.
    When we use the views as building blocks and chain them together, we benefit from
    lazy evaluation by avoiding unnecessary copies of the container elements required
    by the eager algorithms.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到`std::views::filter`视图可以替换算法`std::copy_if（）`，而`std::views::transform`视图可以替换`std::transform（）`算法。当我们将视图用作构建块并将它们链接在一起时，我们通过避免急切算法所需的容器元素的不必要复制而受益于惰性评估。
- en: 'But what about `std::sort()`? Is there a corresponding sorting view? The answer
    is no because it would require the view to first collect all the elements eagerly
    in order to find the first element to return. Instead, we have to do that ourselves
    by explicitly calling sort on our view. In most cases, we also need to materialize
    the view before sorting. We can clarify this with an example. Assume that we have
    a vector of numbers that we have filtered by some predicate, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`std::sort（）`呢？有对应的排序视图吗？答案是否定的，因为它需要视图首先急切地收集所有元素以找到要返回的第一个元素。相反，我们必须自己显式调用视图上的排序来做到这一点。在大多数情况下，我们还需要在排序之前实体化视图。我们可以通过一个例子来澄清这一点。假设我们有一个通过某个谓词过滤的数字向量，如下所示：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we try to sort our view `odd_numbers` using `std::ranges::sort()` or `std::sort()`,
    we will get a compilation error:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`std::ranges::sort（）`或`std::sort（）`对我们的视图`odd_numbers`进行排序，我们将收到编译错误：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The compiler complains about the types of iterators provided by the `odd_numbers`
    range. The sorting algorithm requires random access iterators, but that''s not
    the type of iterators that our view provides, even though the underlying input
    container is a `std::vector`. What we need to do is to materialize the view before
    sorting:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨`odd_numbers`范围提供的迭代器类型。排序算法需要随机访问迭代器，但这不是我们的视图提供的迭代器类型，即使底层输入容器是`std::vector`。我们需要在排序之前实体化视图：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But why is this necessary? The answer is that this is a consequence of lazy
    evaluation. The filter view (and many other views) cannot preserve the iterator
    types of the underlying range (in this case, the `std::vector`) when evaluation
    needs to be lazy by reading one element at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么这是必要的呢？答案是这是惰性评估的结果。过滤视图（以及许多其他视图）在需要延迟读取一个元素时无法保留底层范围（在本例中为`std::vector`）的迭代器类型。
- en: 'So, are there any views that can be sorted? Yes, an example would be `std::views::take`,
    which returns the first *n* elements in a range. The following example compiles
    and runs fine without the need for materializing the view before sorting:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有可以排序的视图？是的，一个例子是`std::views::take`，它返回范围中的前*n*个元素。以下示例在排序之前编译和运行良好，无需在排序之前实现视图：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The quality of the iterators has been preserved and it's therefore possible
    to sort the `first_half` view. The end result is that the first half of the elements
    in the underlying vector `vec` have been sorted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的质量已经得到保留，因此可以对`first_half`视图进行排序。最终结果是底层向量`vec`中前一半的元素已经被排序。
- en: You now have a good understanding of what views from the Ranges library are
    and how they work. In the next section, we will explore how to use the views that
    are included in the standard library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对来自Ranges库的视图以及它们的工作原理有了很好的理解。在下一节中，我们将探讨如何使用标准库中包含的视图。
- en: Views in the standard library
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的视图
- en: So far in this chapter, we have been talking about views from the Ranges library.
    As was described earlier, these view types need to be constructed in constant
    time and also have constant-time copy, move, and assignment operators. However,
    in C++, we have talked about view classes before the Ranges library was added
    to C++20\. These view classes are non-owning types, just like `std::ranges::view`,
    but without the complexity guarantees.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直在谈论来自Ranges库的视图。正如前面所述，这些视图类型需要在常数时间内构造，并且还具有常数时间的复制、移动和赋值运算符。然而，在C++中，我们在C++20添加Ranges库之前就已经谈论过视图类。这些视图类是非拥有类型，就像`std::ranges::view`一样，但没有复杂性保证。
- en: In this section, we will begin by exploring the views from the Ranges library
    that are associated with the `std::ranges::view` concept, and then move on to
    `std::string_view` and `std::span`, which are not associated with `std::ranges::view`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探索与`std::ranges::view`概念相关联的Ranges库中的视图，然后转到与`std::ranges::view`不相关联的`std::string_view`和`std::span`。
- en: Range views
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围视图
- en: There are already many views in the Ranges library, and I think we will see
    even more of them in future versions of C++. This section will provide a quick
    overview of some of the available views and also put them in different categories
    based on what they do.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges库中已经有许多视图，我认为我们将在未来的C++版本中看到更多这样的视图。本节将快速概述一些可用视图，并根据其功能将它们放入不同的类别中。
- en: Generating views
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成视图
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By omitting the second argument, `std::views::iota` will produce an infinite
    number of values on request.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过省略第二个参数，`std::views::iota`将在请求时产生无限数量的值。
- en: Transforming views
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换视图
- en: 'Transforming views are views that transform the elements of a range or the
    structure of the range itself. Some examples include:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 转换视图是转换范围的元素或范围结构的视图。一些示例包括：
- en: '`std::views::transform`: Transforms the value and/or the type of each element'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::transform`：转换每个元素的值和/或类型'
- en: '`std::views::reverse`: Returns a reversed version of the input range'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::reverse`：返回输入范围的反转版本'
- en: '`std::views::split`: Takes an element apart and splits each element into a
    subrange. The resulting range is a range of ranges'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::split`：拆分每个元素并将每个元素拆分为子范围。结果范围是范围的范围'
- en: '`std::views::join`: The opposite of split; flattens out all subranges'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::join`：split的相反操作；展平所有子范围'
- en: 'The following example uses `split` and `join` to extract all digits from a
    string of comma-separated values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`split`和`join`从逗号分隔的值字符串中提取所有数字：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sampling views
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采样视图
- en: 'Sampling views are views that select a subset of elements in a range, for example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 采样视图是选择范围中的元素子集的视图，例如：
- en: '`std::views::filter`: Returns only the elements that fulfill a provided predicate'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::filter`：仅返回满足提供的谓词的元素'
- en: '`std::views::take`: Returns the *n* first elements of a range'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::take`：返回范围中的*n*个第一个元素'
- en: '`std::views::drop`: Returns all the remaining elements in a range after dropping
    the first *n* elements'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::drop`：在丢弃前*n*个元素后返回范围中的所有剩余元素'
- en: 'You have seen plenty of examples using `std::views::filter` in this chapter;
    it''s an extremely useful view. Both `std::views::take` and `std::views::drop`
    have a `_while` version, which accepts a predicate instead of a number. Here is
    an example using `take` and `drop_while`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了许多使用`std::views::filter`的示例；这是一个非常有用的视图。`std::views::take`和`std::views::drop`都有一个`_while`版本，它接受一个谓词而不是一个数字。以下是使用`take`和`drop_while`的示例：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example uses `drop_while` to discard values from the front that are less
    than 5\. The remaining elements are passed to `take`, which returns the first
    three elements. Now to our last category of range views.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`drop_while`从前面丢弃小于5的值。剩下的元素传递给`take`，它返回前三个元素。现在到我们最后一类范围视图。
- en: Utility views
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用视图
- en: You have already seen some of the utility views in action in this chapter. They
    come in handy when you have something that you want to convert or treat as a view.
    Some examples in this category of views are `ref_view`, `all_view`, `subrange`,
    `counted`, and `istream_view`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了一些实用视图的用法。当您有想要转换或视为视图的东西时，它们非常方便。在这些视图类别中的一些示例是`ref_view`、`all_view`、`subrange`、`counted`和`istream_view`。
- en: The following example shows you how to read a text file with floating-point
    numbers and then print them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例向您展示了如何读取一个包含浮点数的文本文件，然后打印它们。
- en: 'Assume that we have a text file called `numbers.txt` full of important floating-point
    numbers, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`numbers.txt`的文本文件，其中包含重要的浮点数，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could then create a view of `floats` by using `std::ranges::istream_view`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过使用`std::ranges::istream_view`来创建一个`floats`的视图：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By creating a `std::ranges::istream_view` and passing it an `istream` object,
    we have a succinct way of processing data from files or any other input stream.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`std::ranges::istream_view`并将其传递给一个`istream`对象，我们可以简洁地处理来自文件或任何其他输入流的数据。
- en: The views in the Ranges library have been carefully chosen and designed. There
    will most likely be more of them in upcoming versions of the standard. Being aware
    of the different categories of views helps us to keep them apart and make them
    easy to find when we need them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges库中的视图已经经过精心选择和设计。在未来的标准版本中很可能会有更多的视图。了解不同类别的视图有助于我们将它们区分开，并在需要时更容易找到它们。
- en: Revisiting std::string_view and std::span
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视std::string_view和std::span
- en: It's worth noting that the standard library provides us with other views outside
    of the Ranges library. Both `std::string_view` and `std::span` introduced in *Chapter
    4*, *Data Structures* are non-owning ranges that are perfect to use in combination
    with the Ranges view.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，标准库在Ranges库之外还提供了其他视图。在*第4章*，*数据结构*中引入的`std::string_view`和`std::span`都是非拥有范围，非常适合与Ranges视图结合使用。
- en: There is no guarantee that these views can be constructed in constant time,
    as is the case with the views from the Ranges library. For example, constructing
    a `std::string_view` from a null-terminated C-style string could invoke a call
    to `strlen()`, which is an *O(n)* operation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ranges库中的视图不同，不能保证这些视图可以在常数时间内构造。例如，从以null结尾的C风格字符串构造`std::string_view`可能会调用`strlen()`，这是一个*O(n)*操作。
- en: 'Suppose, for some reason, we have a function that resets the first `n` values
    in a range:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出于某种原因，我们有一个重置范围中前`n`个值的函数：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is no need to use a range adaptor with `values` in this case because
    `values` is already a view. By using `std::span`, we can pass both built-in arrays
    or a container such as `std::vector`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不需要使用范围适配器来处理`values`，因为`values`已经是一个视图。通过使用`std::span`，我们可以传递内置数组或容器，如`std::vector`：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In a similar way, we can use `std::string_view` together with the Ranges library.
    The following function splits the content of a `std::string_view` into a `std::vector`
    of `std::string` elements:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以将`std::string_view`与Ranges库一起使用。以下函数将`std::string_view`的内容拆分为`std::vector`的`std::string`元素：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The lambda `to_string` transforms a range of `char`s into a `std::string`. The
    `std::string` constructor requires identical iterator and sentinel types, therefore,
    the range is wrapped in a `std::ranges::common_view`. The utility `to_vector()`
    materializes the view and returns a `std::vector<std::string>`. `to_vector()`
    was defined earlier in this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: lambda `to_string`将一系列`char`转换为`std::string`。`std::string`构造函数需要相同的迭代器和sentinel类型，因此范围被包装在`std::ranges::common_view`中。实用程序`to_vector()`将视图实现并返回`std::vector<std::string>`。`to_vector()`在本章前面已经定义过。
- en: 'Our `split()` function can now be used with both `const char*` strings and
    `std::string` objects, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`split()`函数现在可以用于`const char*`字符串和`std::string`对象，如下所示：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now wrap this chapter up by talking a little bit about what we expect
    to see in the Ranges library in future versions of C++.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过谈论我们期望在未来版本的C++中看到的Ranges库来结束这一章。
- en: The future of the Ranges library
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ranges库的未来
- en: The Ranges library that got accepted in C++20 was based on a library authored
    by Eric Niebler, and is available at [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3).
    Only a small subset of the components of this library have made their way into
    the standard at present, but more things are likely to be added soon.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中被接受的Ranges库是基于Eric Niebler编写的库，可以在[https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3)上找到。目前，这个库中只有一小部分组件已经成为标准的一部分，但更多的东西可能很快就会被添加进来。
- en: In addition to many useful views that haven't been accepted yet, such as `group_by`,
    `zip`, `slice`, and `unique`, there is the concept of **actions** that can be
    piped in the same way that views can. However, instead of being lazy evaluated
    like views, actions perform eager mutations of ranges. Sorting is an example of
    a typical action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了许多有用的视图尚未被接受，例如`group_by`、`zip`、`slice`和`unique`之外，还有**actions**的概念，可以像视图一样进行管道传递。但是，与视图一样，操作执行范围的急切变异，而不是像视图那样进行惰性求值。排序是典型操作的一个例子。
- en: If you cannot wait for these features to be added to the standard library, I
    recommend that you take a look at the range-v3 library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您等不及这些功能被添加到标准库中，我建议您看一下range-v3库。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented a number of motivations behind using Range views to construct
    algorithms. By using views, we can compose algorithms efficiently, and with a
    succinct syntax, using the pipe operator. You also learned what it means for a
    class to be a view and how to use range adaptors that turn ranges into views.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章介绍了使用范围视图构建算法背后的许多动机。通过使用视图，我们可以高效地组合算法，并使用管道操作符简洁的语法。您还学会了一个类成为视图意味着什么，以及如何使用将范围转换为视图的范围适配器。
- en: A view does not own its elements. Constructing a range view is required to be
    a constant time operation and all views are evaluated lazily. You have seen examples
    of how we can convert a container into a view, and how to materialize a view back
    into an owning container.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 视图不拥有其元素。构造范围视图需要是一个常数时间操作，所有视图都是惰性求值的。您已经看到了如何将容器转换为视图的示例，以及如何将视图实现为拥有容器。
- en: Finally, we covered a brief overview of the views that come with the standard
    library, and the likely future of ranges in C++.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要概述了标准库中提供的视图，以及C++中范围的可能未来。
- en: This chapter is the last in the series about containers, iterators, algorithms,
    and ranges. We will now move on to memory management in C++.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于容器、迭代器、算法和范围的系列的最后一章。我们现在将转向C++中的内存管理。
