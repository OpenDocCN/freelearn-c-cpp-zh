["```cpp\n07555 123456    => +447555123456\n07555123456     => +447555123456\n+44 7555 123456 => +447555123456\n44 7555 123456  => +447555123456\n7555 123456     => +447555123456\n```", "```cpp\nstruct book\n{\n   int         id;\n   std::string title;\n   std::string author;\n};\n\nstd::vector<book> books{\n   {101, \"The C++ Programming Language\", \"Bjarne Stroustrup\"},\n   {203, \"Effective Modern C++\", \"Scott Meyers\"},\n   {404, \"The Modern C++ Programming Cookbook\", \"Marius Bancila\"}};\n\nauto titles = select(books, [](book const & b) {return b.title; });\n```", "```cpp\nA -> A : 0     A\nA -> B : 7     A -> B\nA -> C : 9     A -> C\nA -> D : 20    A -> C -> D\nA -> E : 20    A -> C -> F -> E\nA -> F : 11    A -> C -> F\n```", "```cpp\ntemplate <class T,\n   class Compare = std::less<typename std::vector<T>::value_type>>\nclass priority_queue\n{\n   typedef typename std::vector<T>::value_type value_type;\n   typedef typename std::vector<T>::size_type size_type;\n   typedef typename std::vector<T>::reference reference;\n   typedef typename std::vector<T>::const_reference const_reference;\npublic:\n   bool empty() const noexcept { return data.empty(); }\n   size_type size() const noexcept { return data.size(); }\n\n   void push(value_type const & value)\n   {\n      data.push_back(value);\n      std::push_heap(std::begin(data), std::end(data), comparer);\n   }\n\n   void pop()\n   {\n      std::pop_heap(std::begin(data), std::end(data), comparer);\n      data.pop_back();\n   }\n\n   const_reference top() const { return data.front(); }\n\n   void swap(priority_queue& other) noexcept\n   {\n      swap(data, other.data);\n      swap(comparer, other.comparer);\n   }\nprivate:\n   std::vector<T> data;\n   Compare comparer;\n};\n\ntemplate<class T, class Compare>\nvoid swap(priority_queue<T, Compare>& lhs,\n          priority_queue<T, Compare>& rhs) \nnoexcept(noexcept(lhs.swap(rhs)))\n{\n   lhs.swap(rhs);\n}\n```", "```cpp\nint main()\n{\n   priority_queue<int> q;\n   for (int i : {1, 5, 3, 1, 13, 21, 8})\n   {\n      q.push(i);\n   }\n\n   assert(!q.empty());\n   assert(q.size() == 7);\n\n   while (!q.empty())\n   {\n      std::cout << q.top() << ' ';\n      q.pop();\n   }\n}\n```", "```cpp\ntemplate <class T>\nclass circular_buffer\n{\n   typedef circular_buffer_iterator<T> const_iterator;\n\n   circular_buffer() = delete;\npublic:\n   explicit circular_buffer(size_t const size) :data_(size)\n   {}\n\n   bool clear() noexcept { head_ = -1; size_ = 0; }\n   bool empty() const noexcept { return size_ == 0; }\n   bool full() const noexcept { return size_ == data_.size(); }\n   size_t capacity() const noexcept { return data_.size(); }\n   size_t size() const noexcept { return size_; }\n\n   void push(T const item)\n   {\n      head_ = next_pos();\n      data_[head_] = item;\n      if (size_ < data_.size()) size_++;\n   }\n\n   T pop()\n   {\n      if (empty()) throw std::runtime_error(\"empty buffer\");\n      auto pos = first_pos();\n      size_--;\n      return data_[pos];\n   }\n\n   const_iterator begin() const\n   {\n      return const_iterator(*this, first_pos(), empty());\n   }\n\n   const_iterator end() const\n   {\n      return const_iterator(*this, next_pos(), true);\n   }\n\nprivate:\n   std::vector<T> data_;\n   size_t head_ = -1;\n   size_t size_ = 0;\n\n   size_t next_pos() const noexcept \n   { return size_ == 0 ? 0 : (head_ + 1) % data_.size(); }\n   size_t first_pos() const noexcept \n   { return size_ == 0 ? 0 : (head_ + data_.size() - size_ + 1) % \n                             data_.size(); }\n\n   friend class circular_buffer_iterator<T>;\n};\n```", "```cpp\ntemplate <class T>\nclass circular_buffer_iterator\n{\n   typedef circular_buffer_iterator        self_type;\n   typedef T                               value_type;\n   typedef T&                              reference;\n   typedef T const&                        const_reference;\n   typedef T*                              pointer;\n   typedef std::random_access_iterator_tag iterator_category;\n   typedef ptrdiff_t                       difference_type;\npublic:\n   circular_buffer_iterator(circular_buffer<T> const & buf, \n                            size_t const pos, bool const last) :\n   buffer_(buf), index_(pos), last_(last)\n   {}\n\n   self_type & operator++ ()\n   {\n      if (last_)\n         throw std::out_of_range(\"Iterator cannot be incremented past the end of range.\");\n      index_ = (index_ + 1) % buffer_.data_.size();\n      last_ = index_ == buffer_.next_pos();\n      return *this;\n   }\n\n   self_type operator++ (int)\n   {\n      self_type tmp = *this;\n      ++*this;\n      return tmp;\n   }\n\n   bool operator== (self_type const & other) const\n   {\n      assert(compatible(other));\n      return index_ == other.index_ && last_ == other.last_;\n   }\n\n   bool operator!= (self_type const & other) const\n   {\n      return !(*this == other);\n   }\n\n   const_reference operator* () const\n   {\n      return buffer_.data_[index_];\n   }\n\n   const_reference operator-> () const\n   {\n      return buffer_.data_[index_];\n   }\nprivate:\n   bool compatible(self_type const & other) const\n   {\n      return &buffer_ == &other.buffer_;\n   }\n\n   circular_buffer<T> const & buffer_;\n   size_t index_;\n   bool last_;\n};\n```", "```cpp\nint main()\n{\n   circular_buffer<int> cbuf(5); // {0, 0, 0, 0, 0} -> {}\n\n   cbuf.push(1);                 // {1, 0, 0, 0, 0} -> {1}\n   cbuf.push(2);                 // {1, 2, 0, 0, 0} -> {1, 2}\n   cbuf.push(3);                 // {1, 2, 3, 0, 0} -> {1, 2, 3}\n\n   auto item = cbuf.pop();       // {1, 2, 3, 0, 0} -> {2, 3}\n   cbuf.push(4);                 // {1, 2, 3, 4, 0} -> {2, 3, 4}\n   cbuf.push(5);                 // {1, 2, 3, 4, 5} -> {2, 3, 4, 5}\n   cbuf.push(6);                 // {6, 2, 3, 4, 5} -> {2, 3, 4, 5, 6}\n\n   cbuf.push(7);                 // {6, 7, 3, 4, 5} -> {3, 4, 5, 6, 7}\n   cbuf.push(8);                 // {6, 7, 8, 4, 5} -> {4, 5, 6, 7, 8}\n\n   item = cbuf.pop();            // {6, 7, 8, 4, 5} -> {5, 6, 7, 8}\n   item = cbuf.pop();            // {6, 7, 8, 4, 5} -> {6, 7, 8}\n   item = cbuf.pop();            // {6, 7, 8, 4, 5} -> {7, 8}\n\n   item = cbuf.pop();            // {6, 7, 8, 4, 5} -> {8}\n   item = cbuf.pop();            // {6, 7, 8, 4, 5} -> {}\n\n   cbuf.push(9);                 // {6, 7, 8, 9, 5} -> {9}\n}\n```", "```cpp\ntemplate <typename T>\nclass double_buffer\n{\n   typedef T           value_type;\n   typedef T&          reference;\n   typedef T const &   const_reference;\n   typedef T*          pointer;\npublic:\n   explicit double_buffer(size_t const size) :\n      rdbuf(size), wrbuf(size)\n   {}\n\n   size_t size() const noexcept { return rdbuf.size(); }\n\n   void write(T const * const ptr, size_t const size)\n   {\n      std::unique_lock<std::mutex> lock(mt);\n      auto length = std::min(size, wrbuf.size());\n      std::copy(ptr, ptr + length, std::begin(wrbuf));\n      wrbuf.swap(rdbuf);\n   }\n\n   template <class Output>\n   void read(Output it) const\n   {\n      std::unique_lock<std::mutex> lock(mt);\n      std::copy(std::cbegin(rdbuf), std::cend(rdbuf), it);\n   }\n\n   pointer data() const\n   {\n       std::unique_lock<std::mutex> lock(mt);\n       return rdbuf.data();\n   }\n\n   reference operator[](size_t const pos)\n   {\n      std::unique_lock<std::mutex> lock(mt);\n      return rdbuf[pos];\n   }\n\n   const_reference operator[](size_t const pos) const\n   {\n      std::unique_lock<std::mutex> lock(mt);\n      return rdbuf[pos];\n   }\n\n   void swap(double_buffer other)\n   {\n      std::swap(rdbuf, other.rdbuf);\n      std::swap(wrbuf, other.wrbuf);\n   }\n\nprivate:\n   std::vector<T>     rdbuf;\n   std::vector<T>     wrbuf;\n   mutable std::mutex mt;\n};\n```", "```cpp\ntemplate <typename T>\nvoid print_buffer(double_buffer<T> const & buf)\n{\n   buf.read(std::ostream_iterator<T>(std::cout, \" \"));\n   std::cout << std::endl;\n}\n\nint main()\n{\n   double_buffer<int> buf(10);\n\n   std::thread t([&buf]() {\n      for (int i = 1; i < 1000; i += 10)\n      {\n         int data[] = { i, i + 1, i + 2, i + 3, i + 4, \n                        i + 5, i + 6,i + 7,i + 8,i + 9 };\n         buf.write(data, 10);\n\n         using namespace std::chrono_literals;\n         std::this_thread::sleep_for(100ms);\n       }\n   });\n\n   auto start = std::chrono::system_clock::now();\n   do\n   {\n      print_buffer(buf);\n\n      using namespace std::chrono_literals;\n      std::this_thread::sleep_for(150ms);\n   } while (std::chrono::duration_cast<std::chrono::seconds>(\n            std::chrono::system_clock::now() - start).count() < 12);\n\n   t.join();\n}\n```", "```cpp\ntemplate <typename T>\nstd::vector<std::pair<T, size_t>> find_most_frequent(\n   std::vector<T> const & range)\n{\n   std::map<T, size_t> counts;\n   for (auto const & e : range) counts[e]++;\n\n   auto maxelem = std::max_element(\n      std::cbegin(counts), std::cend(counts),\n      [](auto const & e1, auto const & e2) {\n         return e1.second < e2.second;\n   });\n\n   std::vector<std::pair<T, size_t>> result;\n\n   std::copy_if(\n      std::begin(counts), std::end(counts),\n      std::back_inserter(result),\n      [maxelem](auto const & kvp) {\n         return kvp.second == maxelem->second;\n   });\n\n   return result;\n}\n```", "```cpp\nint main()\n{\n   auto range = std::vector<int>{1,1,3,5,8,13,3,5,8,8,5};\n   auto result = find_most_frequent(range);\n\n   for (auto const & e : result)\n   {\n      std::cout << e.first << \" : \" << e.second << std::endl;\n   }\n}\n```", "```cpp\nstd::map<char, double> analyze_text(std::string_view text)\n{\n   std::map<char, double> frequencies;\n   for (char ch = 'a'; ch <= 'z'; ch++)\n      frequencies[ch] = 0;\n\n   for (auto ch : text)\n   {\n      if (isalpha(ch))\n         frequencies[tolower(ch)]++;\n   }\n\n   auto total = std::accumulate(\n      std::cbegin(frequencies), std::cend(frequencies),\n      0ull,\n      [](auto sum, auto const & kvp) {\n         return sum + static_cast<unsigned long long>(kvp.second);\n   });\n\n   std::for_each(\n      std::begin(frequencies), std::end(frequencies),\n      [total](auto & kvp) {\n         kvp.second = (100.0 * kvp.second) / total;\n   });\n\n   return frequencies;\n}\n```", "```cpp\nint main()\n{\n   auto result = analyze_text(R\"(Lorem ipsum dolor sit amet, consectetur \n      adipiscing elit, sed do eiusmod tempor incididunt ut labore et \n      dolore magna aliqua.)\");\n\n   for (auto const & kvp : result)\n   {\n      std::cout << kvp.first << \" : \"\n                << std::fixed\n                << std::setw(5) << std::setfill(' ')\n                << std::setprecision(2) << kvp.second << std::endl;\n   }\n}\n```", "```cpp\nbool starts_with(std::string_view str, std::string_view prefix)\n{\n   return str.find(prefix) == 0;\n}\n\ntemplate <typename InputIt>\nstd::vector<std::string> filter_numbers(InputIt begin, InputIt end,\n                                        std::string const & countryCode)\n{\n   std::vector<std::string> result;\n   std::copy_if(\n      begin, end,\n      std::back_inserter(result),\n      [countryCode](auto const & number) {\n         return starts_with(number, countryCode) ||\n                starts_with(number, \"+\" + countryCode);\n   });\n   return result;\n}\n\nstd::vector<std::string> filter_numbers(\n   std::vector<std::string> const & numbers,\n   std::string const & countryCode)\n{\n   return filter_numbers(std::cbegin(numbers), std::cend(numbers), \n                         countryCode);\n}\n```", "```cpp\nint main()\n{\n   std::vector<std::string> numbers{\n      \"+40744909080\",\n      \"44 7520 112233\",\n      \"+44 7555 123456\",\n      \"40 7200 123456\",\n      \"7555 123456\"\n   };\n\n   auto result = filter_numbers(numbers, \"44\");\n\n   for (auto const & number : result)\n   {\n      std::cout << number << std::endl;\n   }\n}\n```", "```cpp\nbool starts_with(std::string_view str, std::string_view prefix)\n{\n   return str.find(prefix) == 0;\n}\n\nvoid normalize_phone_numbers(std::vector<std::string>& numbers,\n                             std::string const & countryCode)\n{\n   std::transform(\n      std::cbegin(numbers), std::cend(numbers),\n      std::begin(numbers),\n      [countryCode](std::string const & number) {\n         std::string result;\n         if (number.size() > 0)\n         {\n            if (number[0] == '0')\n               result = \"+\" + countryCode + \n                        number.substr(1);\n            else if (starts_with(number, countryCode))\n               result = \"+\" + number;\n            else if (starts_with(number, \"+\" + countryCode))\n               result = number;\n            else\n               result = \"+\" + countryCode + number;\n      }\n\n      result.erase(\n         std::remove_if(std::begin(result), std::end(result),\n            [](const char ch) {return isspace(ch); }),\n         std::end(result));\n\n      return result;\n   });\n}\n```", "```cpp\nint main()\n{\n   std::vector<std::string> numbers{\n      \"07555 123456\",\n      \"07555123456\",\n      \"+44 7555 123456\",\n      \"44 7555 123456\",\n      \"7555 123456\"\n   };\n\n   normalize_phone_numbers(numbers, \"44\");\n\n   for (auto const & number : numbers)\n   {\n      std::cout << number << std::endl;\n   }\n}\n```", "```cpp\nvoid print_permutations(std::string str)\n{\n   std::sort(std::begin(str), std::end(str));\n\n   do\n   {\n      std::cout << str << std::endl;\n   } while (std::next_permutation(std::begin(str), std::end(str)));\n}\n```", "```cpp\nvoid next_permutation(std::string str, std::string perm)\n{\n   if (str.empty()) std::cout << perm << std::endl;\n   else\n   {\n      for (size_t i = 0; i < str.size(); ++i)\n      {\n         next_permutation(str.substr(1), perm + str[0]);\n\n         std::rotate(std::begin(str), std::begin(str) + 1, std::end(str));\n      }\n   }\n}\n\nvoid print_permutations_recursive(std::string str)\n{\n   next_permutation(str, \"\");\n}\n```", "```cpp\nint main()\n{\n   std::cout << \"non-recursive version\" << std::endl;\n   print_permutations(\"main\");\n\n   std::cout << \"recursive version\" << std::endl;\n   print_permutations_recursive(\"main\");\n}\n```", "```cpp\ndouble truncated_mean(std::vector<int> values, double const percentage)\n{\n   std::sort(std::begin(values), std::end(values));\n   auto remove_count = static_cast<size_t>(\n                          values.size() * percentage + 0.5);\n\n   values.erase(std::begin(values), std::begin(values) + remove_count);\n   values.erase(std::end(values) - remove_count, std::end(values));\n\n   auto total = std::accumulate(\n      std::cbegin(values), std::cend(values),\n      0ull,\n      [](auto const sum, auto const e) {\n         return sum + e; });\n   return static_cast<double>(total) / values.size();\n}\n```", "```cpp\nstruct movie\n{\n   int              id;\n   std::string      title;\n   std::vector<int> ratings;\n};\n\nvoid print_movie_ratings(std::vector<movie> const & movies)\n{\n   for (auto const & m : movies)\n   {\n      std::cout << m.title << \" : \" \n                << std::fixed << std::setprecision(1)\n                << truncated_mean(m.ratings, 0.05) << std::endl;\n   }\n}\n\nint main()\n{\n   std::vector<movie> movies\n   {\n      { 101, \"The Matrix\", {10, 9, 10, 9, 9, 8, 7, 10, 5, 9, 9, 8} },\n      { 102, \"Gladiator\", {10, 5, 7, 8, 9, 8, 9, 10, 10, 5, 9, 8, 10} },\n      { 103, \"Interstellar\", {10, 10, 10, 9, 3, 8, 8, 9, 6, 4, 7, 10} }\n   };\n\n   print_movie_ratings(movies);\n}\n```", "```cpp\ntemplate <typename Input, typename Output>\nvoid pairwise(Input begin, Input end, Output result)\n{\n   auto it = begin;\n   while (it != end)\n   {\n      auto v1 = *it++; if (it == end) break;\n      auto v2 = *it++;\n      result++ = std::make_pair(v1, v2);\n   }\n}\ntemplate <typename T>\nstd::vector<std::pair<T, T>> pairwise(std::vector<T> const & range)\n{\n   std::vector<std::pair<T, T>> result;\n   pairwise(std::begin(range), std::end(range),\n            std::back_inserter(result));\n   return result;\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v{ 1, 1, 3, 5, 8, 13, 21 };\n   auto result = pairwise(v);\n\n   for (auto const & p : result)\n   {\n      std::cout << '{' << p.first << ',' << p.second << '}' << std::endl;\n   }\n}\n```", "```cpp\ntemplate <typename Input1, typename Input2, typename Output>\nvoid zip(Input1 begin1, Input1 end1, \n         Input2 begin2, Input1 end2, \n         Output result)\n{\n   auto it1 = begin1;\n   auto it2 = begin2;\n   while (it1 != end1 && it2 != end2)\n   {\n      result++ = std::make_pair(*it1++, *it2++);\n   }\n}\n\ntemplate <typename T, typename U>\nstd::vector<std::pair<T, U>> zip(\n   std::vector<T> const & range1, \n   std::vector<U> const & range2)\n{\n   std::vector<std::pair<T, U>> result;\n\n   zip(std::begin(range1), std::end(range1),\n       std::begin(range2), std::end(range2),\n       std::back_inserter(result));\n\n   return result;\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v1{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n   std::vector<int> v2{ 1, 1, 3, 5, 8, 13, 21 };\n\n   auto result = zip(v1, v2);\n   for (auto const & p : result)\n   {\n      std::cout << '{' << p.first << ',' << p.second << '}' << std::endl;\n   }\n}\n```", "```cpp\ntemplate <\n   typename T, typename A, typename F,\n   typename R = typename std::decay<typename std::result_of<\n                typename std::decay<F>::type&(\n                typename std::vector<T, A>::const_reference)>::type>::type>\nstd::vector<R> select(std::vector<T, A> const & c, F&& f)\n{\n   std::vector<R> v;\n   std::transform(std::cbegin(c), std::cend(c),\n                  std::back_inserter(v),\n                  std::forward<F>(f));\n   return v;\n}\n```", "```cpp\nint main()\n{\n   std::vector<book> books{\n      {101, \"The C++ Programming Language\", \"Bjarne Stroustrup\"},\n      {203, \"Effective Modern C++\", \"Scott Meyers\"},\n      {404, \"The Modern C++ Programming Cookbook\", \"Marius Bancila\"}};\n\n   auto titles = select(books, [](book const & b) {return b.title; });\n   for (auto const & title : titles)\n   {\n      std::cout << title << std::endl;\n   }\n}\n```", "```cpp\nalgorithm quicksort(A, lo, hi) is\n   if lo < hi then\n      p := partition(A, lo, hi)\n      quicksort(A, lo, p)\n      quicksort(A, p + 1, hi)\n\nalgorithm partition(A, lo, hi) is\n   pivot := A[lo]\n   i := lo - 1\n   j := hi + 1\n   loop forever\n      do\n         i := i + 1\n      while A[i] < pivot\n\n      do\n         j := j - 1\n      while A[j] > pivot\n\n      if i >= j then\n         return j\n\n      swap A[i] with A[j]\n```", "```cpp\ntemplate <class RandomIt>\nRandomIt partition(RandomIt first, RandomIt last)\n{\n   auto pivot = *first;\n   auto i = first + 1;\n   auto j = last - 1;\n   while (i <= j)\n   {\n      while (i <= j && *i <= pivot) i++;\n      while (i <= j && *j > pivot) j--;\n      if (i < j) std::iter_swap(i, j);\n   }\n\n   std::iter_swap(i - 1, first);\n\n   return i - 1;\n}\n\ntemplate <class RandomIt>\nvoid quicksort(RandomIt first, RandomIt last)\n{\n   if (first < last)\n   {\n      auto p = partition(first, last);\n      quicksort(first, p);\n      quicksort(p + 1, last);\n   }\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v{ 1,5,3,8,6,2,9,7,4 };\n   quicksort(std::begin(v), std::end(v));\n\n   std::array<int, 9> a{ 1,2,3,4,5,6,7,8,9 };\n   quicksort(std::begin(a), std::end(a));\n\n   int a[]{ 9,8,7,6,5,4,3,2,1 };\n   quicksort(std::begin(a), std::end(a));\n}\n```", "```cpp\ntemplate <class RandomIt, class Compare>\nRandomIt partitionc(RandomIt first, RandomIt last, Compare comp)\n{\n   auto pivot = *first;\n   auto i = first + 1;\n   auto j = last - 1;\n   while (i <= j)\n   {\n      while (i <= j && comp(*i, pivot)) i++;\n      while (i <= j && !comp(*j, pivot)) j--;\n      if (i < j) std::iter_swap(i, j);\n   }\n\n   std::iter_swap(i - 1, first);\n\n   return i - 1;\n}\n\ntemplate <class RandomIt, class Compare>\nvoid quicksort(RandomIt first, RandomIt last, Compare comp)\n{\n   if (first < last)\n   {\n      auto p = partitionc(first, last, comp);\n      quicksort(first, p, comp);\n      quicksort(p + 1, last, comp);\n   }\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v{ 1,5,3,8,6,2,9,7,4 };\n   quicksort(std::begin(v), std::end(v), std::greater<>());\n}\n```", "```cpp\ntemplate <class RandomIt>\nvoid quicksorti(RandomIt first, RandomIt last)\n{\n   std::stack<std::pair<RandomIt, RandomIt>> st;\n   st.push(std::make_pair(first, last));\n   while (!st.empty())\n   {\n      auto iters = st.top();\n      st.pop();\n\n      if (iters.second - iters.first < 2) continue;\n\n      auto p = partition(iters.first, iters.second);\n\n      st.push(std::make_pair(iters.first, p));\n      st.push(std::make_pair(p+1, iters.second));\n   }\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v{ 1,5,3,8,6,2,9,7,4 };\n   quicksorti(std::begin(v), std::end(v));\n}\n```", "```cpp\nfunction Dijkstra(Graph, source):\n   dist[source] \u2190 0                 // Initialization\n\n   create vertex set Q\n   for each vertex v in Graph: \n      if v \u2260 source\n         dist[v] \u2190 INFINITY         // Unknown distance from source to v\n         prev[v] \u2190 UNDEFINED        // Predecessor of v\n\n      Q.add_with_priority(v, dist[v])\n\n   while Q is not empty:            // The main loop\n      u \u2190 Q.extract_min()           // Remove and return best vertex\n      for each neighbor v of u:     // only v that is still in Q\n         alt \u2190 dist[u] + length(u, v) \n         if alt < dist[v]\n            dist[v] \u2190 alt\n            prev[v] \u2190 u\n            Q.decrease_priority(v, alt)\n\n   return dist[], prev[]\n```", "```cpp\ntemplate <typename Vertex = int, typename Weight = double>\nclass graph\n{\npublic:\n   typedef Vertex                     vertex_type;\n   typedef Weight                     weight_type;\n   typedef std::pair<Vertex, Weight>  neighbor_type;\n   typedef std::vector<neighbor_type> neighbor_list_type;\npublic:\n   void add_edge(Vertex const source, Vertex const target, \n                 Weight const weight, bool const bidirectional = true)\n   {\n      adjacency_list[source].push_back(std::make_pair(target, weight));\n      adjacency_list[target].push_back(std::make_pair(source, weight));\n   }\n\n   size_t vertex_count() const { return adjacency_list.size(); }\n   std::vector<Vertex> verteces() const\n   {\n      std::vector<Vertex> keys;\n      for (auto const & kvp : adjacency_list)\n         keys.push_back(kvp.first);\n      return keys;\n   }\n\n   neighbor_list_type const & neighbors(Vertex const & v) const\n   {\n      auto pos = adjacency_list.find(v);\n      if (pos == adjacency_list.end())\n         throw std::runtime_error(\"vertex not found\");\n      return pos->second;\n   }\n\n   constexpr static Weight Infinity = \n             std::numeric_limits<Weight>::infinity();\nprivate:\n   std::map<vertex_type, neighbor_list_type> adjacency_list;\n};\n```", "```cpp\ntemplate <typename Vertex, typename Weight>\nvoid shortest_path(\n   graph<Vertex, Weight> const & g,\n   Vertex const source,\n   std::map<Vertex, Weight>& min_distance,\n   std::map<Vertex, Vertex>& previous)\n{\n   auto const n = g.vertex_count();\n   auto const verteces = g.verteces();\n\n   min_distance.clear();\n   for (auto const & v : verteces)\n      min_distance[v] = graph<Vertex, Weight>::Infinity;\n   min_distance[source] = 0;\n\n   previous.clear();\n\n   std::set<std::pair<Weight, Vertex> > vertex_queue;\n   vertex_queue.insert(std::make_pair(min_distance[source], source));\n\n   while (!vertex_queue.empty())\n   {\n      auto dist = vertex_queue.begin()->first;\n      auto u = vertex_queue.begin()->second;\n\n      vertex_queue.erase(std::begin(vertex_queue));\n\n      auto const & neighbors = g.neighbors(u);\n      for (auto const & neighbor : neighbors)\n      {\n         auto v = neighbor.first;\n         auto w = neighbor.second;\n         auto dist_via_u = dist + w;\n         if (dist_via_u < min_distance[v])\n         {\n            vertex_queue.erase(std::make_pair(min_distance[v], v));\n\n            min_distance[v] = dist_via_u;\n            previous[v] = u;\n            vertex_queue.insert(std::make_pair(min_distance[v], v));\n         }\n      }\n   }\n}\n```", "```cpp\ntemplate <typename Vertex>\nvoid build_path(\n   std::map<Vertex, Vertex> const & prev, Vertex const v,\n   std::vector<Vertex> & result)\n{\n   result.push_back(v);\n\n   auto pos = prev.find(v);\n   if (pos == std::end(prev)) return;\n\n   build_path(prev, pos->second, result);\n}\n\ntemplate <typename Vertex>\nstd::vector<Vertex> build_path(std::map<Vertex, Vertex> const & prev, \n                               Vertex const v)\n{\n   std::vector<Vertex> result;\n   build_path(prev, v, result);\n   std::reverse(std::begin(result), std::end(result));\n   return result;\n}\n\ntemplate <typename Vertex>\nvoid print_path(std::vector<Vertex> const & path)\n{\n   for (size_t i = 0; i < path.size(); ++i)\n   {\n      std::cout << path[i];\n      if (i < path.size() - 1) std::cout << \" -> \";\n   }\n}\n```", "```cpp\nint main()\n{\n   graph<char, double> g;\n   g.add_edge('A', 'B', 7);\n   g.add_edge('A', 'C', 9);\n   g.add_edge('A', 'F', 14);\n   g.add_edge('B', 'C', 10);\n   g.add_edge('B', 'D', 15);\n   g.add_edge('C', 'D', 11);\n   g.add_edge('C', 'F', 2);\n   g.add_edge('D', 'E', 6);\n   g.add_edge('E', 'F', 9);\n\n   char source = 'A';\n   std::map<char, double> min_distance;\n   std::map<char, char> previous;\n   shortest_path(g, source, min_distance, previous);\n\n   for (auto const & kvp : min_distance)\n   {\n      std::cout << source << \" -> \" << kvp.first << \" : \"\n                << kvp.second << '\\t';\n\n      print_path(build_path(previous, kvp.first));\n\n      std::cout << std::endl;\n   }\n}\n```", "```cpp\nclass weasel\n{\n   std::string target;\n   std::uniform_int_distribution<> chardist;\n   std::uniform_real_distribution<> ratedist;\n   std::mt19937 mt;\n   std::string const allowed_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \";\npublic:\n   weasel(std::string_view t) :\n      target(t), chardist(0, 26), ratedist(0, 100)\n   {\n      std::random_device rd;\n      auto seed_data = std::array<int, std::mt19937::state_size> {};\n      std::generate(std::begin(seed_data), std::end(seed_data), \n      std::ref(rd));\n      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n      mt.seed(seq);\n   }\n   void run(int const copies)\n   {\n      auto parent = make_random();\n      int step = 1;\n      std::cout << std::left << std::setw(5) << std::setfill(' ') \n                << step << parent << std::endl;\n\n      do\n      {\n         std::vector<std::string> children;\n         std::generate_n(std::back_inserter(children), copies, \n            [parent, this]() {return mutate(parent, 5); });\n\n         parent = *std::max_element(\n            std::begin(children), std::end(children),\n            [this](std::string_view c1, std::string_view c2) {\n               return fitness(c1) < fitness(c2); });\n\n         std::cout << std::setw(5) << std::setfill(' ') << step \n                << parent << std::endl;\n\n         step++;\n      } while (parent != target);\n   }\nprivate:\n   weasel() = delete;\n\n   double fitness(std::string_view candidate) const\n   {\n      int score = 0;\n      for (size_t i = 0; i < candidate.size(); ++i)\n      {\n         if (candidate[i] == target[i])\n            score++;\n      }\n      return score;\n   }\n\n   std::string mutate(std::string_view parent, double const rate)\n   {\n      std::stringstream sstr;\n      for (auto const c : parent)\n      {\n         auto nc = ratedist(mt) > rate ? c : allowed_chars[chardist(mt)];\n         sstr << nc;\n      }\n      return sstr.str();\n    }\n\n   std::string make_random()\n   {\n      std::stringstream sstr;\n      for (size_t i = 0; i < target.size(); ++i)\n      {\n         sstr << allowed_chars[chardist(mt)];\n      }\n      return sstr.str();\n   }\n};\n```", "```cpp\nint main()\n{\n   weasel w(\"METHINKS IT IS LIKE A WEASEL\");\n   w.run(100);\n}\n```", "```cpp\nclass universe\n{\nprivate:\n   universe() = delete;\npublic:\n   enum class seed\n   {\n      random, ten_cell_row\n   };\npublic:\n   universe(size_t const width, size_t const height):\n      rows(height), columns(width),grid(width * height), dist(0, 4)\n   {\n      std::random_device rd;\n      auto seed_data = std::array<int, std::mt19937::state_size> {};\n      std::generate(std::begin(seed_data), std::end(seed_data), \n      std::ref(rd));\n      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n      mt.seed(seq);\n   }\n\n   void run(seed const s, int const generations, \n            std::chrono::milliseconds const ms = \n               std::chrono::milliseconds(100))\n   {\n      reset();\n      initialize(s);\n      display();\n\n      int i = 0;\n      do \n      {\n         next_generation();\n         display();\n\n         using namespace std::chrono_literals;\n         std::this_thread::sleep_for(ms);\n      } while (i++ < generations || generations == 0);\n   }\n\nprivate:\n   void next_generation()\n   {\n      std::vector<unsigned char> newgrid(grid.size());\n\n      for (size_t r = 0; r < rows; ++r)\n      {\n         for (size_t c = 0; c < columns; ++c)\n         {\n            auto count = count_neighbors(r, c);\n\n            if (cell(c, r) == alive)\n            {\n               newgrid[r * columns + c] = \n                  (count == 2 || count == 3) ? alive : dead;\n            }\n            else \n            {\n               newgrid[r * columns + c] = (count == 3) ? alive : dead;\n            }\n         }\n      }\n\n      grid.swap(newgrid);\n   }\n\n   void reset_display()\n   {\n#ifdef WIN32\n      system(\"cls\");\n#endif\n   }\n\n   void display()\n   {\n      reset_display();\n\n      for (size_t r = 0; r < rows; ++r)\n      {\n         for (size_t c = 0; c < columns; ++c)\n         {\n            std::cout << (cell(c, r) ? '*' : ' ');\n         }\n         std::cout << std::endl;\n      }\n   }\n\n   void initialize(seed const s)\n   {\n      if (s == seed::ten_cell_row)\n      {\n         for (size_t c = columns / 2 - 5; c < columns / 2 + 5; c++)\n            cell(c, rows / 2) = alive;\n      }\n      else\n      {\n         for (size_t r = 0; r < rows; ++r)\n         {\n            for (size_t c = 0; c < columns; ++c)\n            {\n               cell(c, r) = dist(mt) == 0 ? alive : dead;\n            }\n         }\n      }\n   }\n\n   void reset()\n   {\n      for (size_t r = 0; r < rows; ++r)\n      {\n         for (size_t c = 0; c < columns; ++c)\n         {\n            cell(c, r) = dead;\n         }\n      }\n   }\n\n   int count_alive() { return 0; }\n\n   template<typename T1, typename... T>\n   auto count_alive(T1 s, T... ts) { return s + count_alive(ts...); }\n\n   int count_neighbors(size_t const row, size_t const col)\n   {\n      if (row == 0 && col == 0) \n         return count_alive(cell(1, 0), cell(1,1), cell(0, 1));\n      if (row == 0 && col == columns - 1)\n         return count_alive(cell(columns - 2, 0), cell(columns - 2, 1), \n                            cell(columns - 1, 1));\n      if (row == rows - 1 && col == 0)\n         return count_alive(cell(0, rows - 2), cell(1, rows - 2), \n                            cell(1, rows - 1));\n      if (row == rows - 1 && col == columns - 1)\n         return count_alive(cell(columns - 1, rows - 2), \n                            cell(columns - 2, rows - 2), \n                            cell(columns - 2, rows - 1));\n      if (row == 0 && col > 0 && col < columns - 1)\n         return count_alive(cell(col - 1, 0), cell(col - 1, 1), \n                            cell(col, 1), cell(col + 1, 1), \n                            cell(col + 1, 0));\n      if (row == rows - 1 && col > 0 && col < columns - 1)\n         return count_alive(cell(col - 1, row), cell(col - 1, row - 1), \n                            cell(col, row - 1), cell(col + 1, row - 1), \n                            cell(col + 1, row));\n      if (col == 0 && row > 0 && row < rows - 1)\n         return count_alive(cell(0, row - 1), cell(1, row - 1), \n                            cell(1, row), cell(1, row + 1), \n                            cell(0, row + 1));\n      if (col == columns - 1 && row > 0 && row < rows - 1)\n         return count_alive(cell(col, row - 1), cell(col - 1, row - 1), \n                            cell(col - 1, row), cell(col - 1, row + 1), \n                            cell(col, row + 1));\n\n      return count_alive(cell(col - 1, row - 1), cell(col, row - 1), \n                         cell(col + 1, row - 1), cell(col + 1, row), \n                         cell(col + 1, row + 1), cell(col, row + 1), \n                         cell(col - 1, row + 1), cell(col - 1, row));\n   }\n\n   unsigned char& cell(size_t const col, size_t const row)\n   {\n      return grid[row * columns + col];\n   }\n\nprivate:\n   size_t rows;\n   size_t columns;\n\n   std::vector<unsigned char> grid;\n   const unsigned char alive = 1;\n   const unsigned char dead = 0;\n\n   std::uniform_int_distribution<> dist;\n   std::mt19937 mt;\n};\n```", "```cpp\nint main()\n{\n   using namespace std::chrono_literals;\n   universe u(50, 20);\n   u.run(universe::seed::random, 100, 100ms);\n}\n```"]