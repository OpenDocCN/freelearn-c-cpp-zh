["```cpp\n$ cp --help\nUsage: cp [OPTION]... [-T] SOURCE DEST\n  -a, --archive           same as -dR --preserve=all\n  -b                      like --backup but does not accept an argument \n```", "```cpp\n $ ./our_program.exe --apples=10 --oranges=20 Fruits count: 30\n```", "```cpp\n#include <boost/program_options.hpp> \n#include <iostream> \n\nnamespace opt = boost::program_options; \n```", "```cpp\nint main(int argc, char *argv[])\n{\n    // Constructing an options describing variable and giving \n    // it a textual description \"All options\". \n    opt::options_description desc(\"All options\"); \n\n    // When we are adding options, first parameter is a name\n    // to be used in command line. Second parameter is a type\n    // of that option, wrapped in value<> class. Third parameter\n    // must be a short description of that option.\n    desc.add_options()\n        (\"apples\", opt::value<int>(), \"how many apples do \n                                       you have\")\n        (\"oranges\", opt::value<int>(), \"how many oranges do you \n                                        have\")\n        (\"help\", \"produce help message\")\n    ;\n```", "```cpp\n    // Variable to store our command line arguments.\n    opt::variables_map vm; \n\n    // Parsing and storing arguments.\n    opt::store(opt::parse_command_line(argc, argv, desc), vm); \n\n    // Must be called after all the parsing and storing.\n    opt::notify(vm);\n```", "```cpp\n    if (vm.count(\"help\")) {\n        std::cout << desc << \"\\n\";\n        return 1;\n    }\n```", "```cpp\n    std::cout << \"Fruits count: \"\n        << vm[\"apples\"].as<int>() + vm[\"oranges\"].as<int>()\n        << std::endl;\n\n} // end of `main`\n```", "```cpp\nAll options: \n    --apples arg          how many apples do you have\n    --oranges arg        how many oranges do you have \n    --help                    produce help message \n```", "```cpp\n $ ./our_program.exe --apples=100 --oranges=20 Fruits count: 120\n```", "```cpp\n    int oranges_var = 0;\n    desc.add_options()\n        // ProgramOptions stores the option value into \n        // the variable that is passed by pointer. Here value of \n        // \"--oranges\" option will be stored into 'oranges_var'.\n        (\"oranges,o\", opt::value<int>(&oranges_var)->required(), \n                                                \"oranges you have\")\n```", "```cpp\n        // 'name' option is not marked with 'required()',\n        // so user may not provide it.\n        (\"name\", opt::value<std::string>(), \"your name\")\n```", "```cpp\n        // 'a' is a short option name for apples. Use as '-a 10'.\n        // If no value provided, then the default value is used.\n        (\"apples,a\", opt::value<int>()->default_value(10),\n                                   \"apples that you have\");\n```", "```cpp\n    opt::variables_map vm;\n\n    // Parsing command line options and storing values to 'vm'.\n    opt::store(opt::parse_command_line(argc, argv, desc), vm);\n\n    // We can also parse environment variables. Just use\n    // 'opt::store with' 'opt::parse_environment' function.\n\n    // Adding missing options from \"apples_oranges.cfg\" config file.\n    try {\n        opt::store(\n            opt::parse_config_file<char>(\"apples_oranges.cfg\", desc),\n            vm\n        );\n    } catch (const opt::reading_file& e) {\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n```", "```cpp\n    try {\n        // `opt::required_option` exception is thrown if\n        // one of the required options was not set.\n        opt::notify(vm);\n\n    } catch (const opt::required_option& e) {\n        std::cout << \"Error: \" << e.what() << std::endl;\n        return 2;\n    }\n```", "```cpp\n$ ./our_program.exe --help\n All options:\n   -o [ --oranges ] arg          oranges that you have\n   --name arg                       your name\n   -a [ --apples ] arg (=10)  apples that you have\n   --help                              produce help message\n\n```", "```cpp\n$ ./our_program.exe\n Error: can not read options configuration file 'apples_oranges.cfg'\n Error: the option '--oranges' is required but missing \n```", "```cpp\n$ ./our_program.exe\n Fruits count: 30\n```", "```cpp\ntypedef std::unique_ptr<Object> object_ptr; \n\nstd::vector<object_ptr> some_values; \nsome_values.push_back(new Object(10)); \nsome_values.push_back(new Object(\"Hello there\")); \nsome_values.push_back(new Object(std::string(\"Wow!\"))); \n\nstd::string* p = dynamic_cast<std::string*>(some_values.back().get()); \nassert(p); \n(*p) += \" That is great!\\n\"; \nstd::cout << *p; \n```", "```cpp\n#include <boost/any.hpp> \n#include <iostream> \n#include <vector> \n#include <string> \n\nint main() { \n    std::vector<boost::any> some_values; \n    some_values.push_back(10); \n    some_values.push_back(\"Hello there!\"); \n    some_values.push_back(std::string(\"Wow!\"));\n\n    std::string& s = boost::any_cast<std::string&>(some_values.back()); \n    s += \" That is great!\"; \n    std::cout << s; \n} \n```", "```cpp\nvoid example() {\n    boost::any variable(std::string(\"Hello world!\"));\n\n    // Following method may throw a boost::bad_any_cast exception\n    // if actual value in variable is not a std::string.\n    std::string s1 = boost::any_cast<std::string>(variable);\n\n    // Never throws. If actual value in variable is not a std::string\n    // will return an NULL pointer.\n    std::string* s2 = boost::any_cast<std::string>(&variable);\n}\n```", "```cpp\ntemplate<typename ValueType>\nstruct holder : public placeholder {\n    virtual const std::type_info& type() const {\n         return typeid(ValueType);\n    }\n     ValueType held;\n};\n```", "```cpp\nstruct placeholder {\n    virtual ~placeholder() {}\n    virtual const std::type_info& type() const = 0;\n};\n```", "```cpp\n#include <boost/variant.hpp>\n#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    typedef boost::variant<int, const char*, std::string> my_var_t;\n    std::vector<my_var_t> some_values;\n    some_values.push_back(10);\n    some_values.push_back(\"Hello there!\");\n    some_values.push_back(std::string(\"Wow!\"));\n\n    std::string& s = boost::get<std::string>(some_values.back());\n    s += \" That is great!\\n\";\n    std::cout << s;\n} \n```", "```cpp\nvoid example1() {\n    // Default constructor constructs an instance of boost::blank.\n    boost::variant<\n        boost::blank, int, const char*, std::string\n    > var;\n\n    // 'which()' method returns an index of a type\n    // currently held by variant.\n    assert(var.which() == 0); // boost::blank\n\n    var = \"Hello, dear reader\";\n    assert(var.which() != 0);\n}\n```", "```cpp\nvoid example2() {\n    boost::variant<int, std::string> variable(0);\n\n    // Following method may throw a boost::bad_get\n    // exception if actual value in variable is not an int.\n    int s1 = boost::get<int>(variable);\n\n    // If actual value in variable is not an int will return NULL.\n    int* s2 = boost::get<int>(&variable);\n}\n```", "```cpp\n#include <boost/any.hpp> \n#include <vector> \n#include <string> \n#include <typeinfo> \n#include <algorithm> \n#include <iostream> \n\n// This typedefs and methods will be in our header, \n// that wraps around native SQL interface.\ntypedef boost::any cell_t; \ntypedef std::vector<cell_t> db_row_t; \n\n// This is just an example, no actual work with database. \ndb_row_t get_row(const char* /*query*/) { \n    // In real application 'query' parameter shall have a 'const \n    // char*' or 'const std::string&' type? See recipe \"Type  \n    // 'reference to string'\" for an answer. \n    db_row_t row; \n    row.push_back(10); \n    row.push_back(10.1f); \n    row.push_back(std::string(\"hello again\")); \n    return row; \n} \n\n// This is how a user will use your classes \nstruct db_sum { \nprivate: \n    double& sum_; \npublic: \n    explicit db_sum(double& sum) \n        : sum_(sum) \n    {} \n\n    void operator()(const cell_t& value) { \n        const std::type_info& ti = value.type(); \n        if (ti == typeid(int)) { \n            sum_ += boost::any_cast<int>(value); \n        } else if (ti == typeid(float)) { \n            sum_ += boost::any_cast<float>(value); \n        } \n    } \n}; \n\nint main() { \n    db_row_t row = get_row(\"Query: Give me some row, please.\"); \n    double res = 0.0; \n    std::for_each(row.begin(), row.end(), db_sum(res)); \n    std::cout << \"Sum of arithmetic types in database row is: \"\n              << res << std::endl; \n} \n```", "```cpp\nSum of arithmetic types in database row is: 20.1\n```", "```cpp\n#include <boost/variant.hpp> \n#include <vector> \n#include <string> \n#include <iostream> \n\n// This typedefs and methods will be in header, \n// that wraps around native SQL interface. \ntypedef boost::variant<int, float, std::string> cell_t; \ntypedef std::vector<cell_t> db_row_t; \n\n// This is just an example, no actual work with database. \ndb_row_t get_row(const char* /*query*/) { \n    // See recipe \"Type 'reference to string'\" \n    // for a better type for 'query' parameter. \n    db_row_t row; \n    row.push_back(10); \n    row.push_back(10.1f); \n    row.push_back(\"hello again\"); \n    return row; \n} \n\n// This is a code required to sum values. \n// We can provide no template parameter \n// to boost::static_visitor<> if our visitor returns nothing. \nstruct db_sum_visitor: public boost::static_visitor<double> { \n    double operator()(int value) const { \n        return value; \n    } \n    double operator()(float value) const { \n        return value; \n    } \n    double operator()(const std::string& /*value*/) const { \n        return 0.0; \n    } \n}; \n\nint main() { \n    db_row_t row = get_row(\"Query: Give me some row, please.\"); \n    double res = 0.0; \n    for (auto it = row.begin(), end = row.end(); it != end; ++it) { \n        res += boost::apply_visitor(db_sum_visitor(), *it); \n    } \n\n    std::cout << \"Sum of arithmetic types in database row is: \"\n              << res << std::endl;\n}\n```", "```cpp\nswitch (which()) \n{ \ncase 0 /*int*/: \n    return visitor(*reinterpret_cast<int*>(address())); \ncase 1 /*float*/: \n    return visitor(*reinterpret_cast<float*>(address())); \ncase 2 /*std::string*/: \n    return visitor(*reinterpret_cast<std::string*>(address())); \ndefault: assert(false); \n} \n```", "```cpp\n#include <boost/optional.hpp>\n#include <iostream>\n\nclass locked_device {\n    explicit locked_device(const char* /*param*/) {\n        // We have unique access to device.\n        std::cout << \"Device is locked\\n\";\n    }\n\n    static bool try_lock_device_impl();\n\npublic:\n    void use() {\n        std::cout << \"Success!\\n\";\n    }\n\n    static boost::optional<locked_device> try_lock_device() {\n        if (!try_lock_device_impl()) {\n            // Failed to lock device.\n            return boost::none;\n        }\n\n        // Success!\n        return locked_device(\"device name\");\n    }\n\n    ~locked_device(); // Releases device lock.\n};\n```", "```cpp\nint main() { \n    for (unsigned i = 0; i < 10; ++i) { \n        boost::optional<locked_device> t\n            = locked_device::try_lock_device(); \n\n        // optional is convertible to bool.\n        if (t) { \n            t->use(); \n            return 0; \n        } else { \n            std::cout << \"...trying again\\n\"; \n        } \n    } \n\n    std::cout << \"Failure!\\n\"; \n    return -1; \n} \n```", "```cpp\n...trying again\n...trying again\nDevice is locked\nSuccess!\n```", "```cpp\nchar* vector_advance(char* val); \n```", "```cpp\nchar ( &vector_advance( char (&val)[4] ) )[4];\n```", "```cpp\n#include <boost/array.hpp>\n\ntypedef boost::array<char, 4> array4_t;\narray4_t& vector_advance(array4_t& val);\n```", "```cpp\n#include <boost/array.hpp> \n#include <algorithm> \n\ntypedef boost::array<char, 4> array4_t; \n\narray4_t& vector_advance(array4_t& val) {\n    // C++11 lambda function\n    const auto inc = [](char& c){ ++c; };\n\n    // boost::array has begin(), cbegin(), end(), cend(),\n    // rbegin(), size(), empty() and other functions that are\n    // common for standard library containers.\n    std::for_each(val.begin(), val.end(), inc);\n    return val;\n}\n\nint main() { \n    // We can initialize boost::array just like an array in C++11: \n    // array4_t val = {0, 1, 2, 3}; \n    // but in C++03 additional pair of curly brackets is required. \n    array4_t val = {{0, 1, 2, 3}}; \n\n    array4_t val_res;               // it is default constructible\n    val_res = vector_advance(val);  // it is assignable\n\n    assert(val.size() == 4); \n    assert(val[0] == 1); \n    /*val[4];*/ // Will trigger an assert because max index is 3 \n\n    // We can make this assert work at compile-time. \n    // Interested? See recipe 'Check sizes at compile-time' \n    assert(sizeof(val) == sizeof(char) * array4_t::static_size); \n} \n```", "```cpp\n#include <boost/tuple/tuple.hpp> \n#include <string> \n\nboost::tuple<int, std::string> almost_a_pair(10, \"Hello\");\nboost::tuple<int, float, double, int> quad(10, 1.0f, 10.0, 1);\n```", "```cpp\n#include <boost/tuple/tuple.hpp>\n\nvoid sample1() {\n    const int i = boost::get<0>(almost_a_pair); \n    const std::string& str = boost::get<1>(almost_a_pair); \n    const double d = boost::get<2>(quad);\n}\n```", "```cpp\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include <set>\n\nvoid sample2() {\n    // Tuple comparison operators are\n    // defined in header \"boost/tuple/tuple_comparison.hpp\"\n    // Don't forget to include it!\n    std::set<boost::tuple<int, double, int> > s;\n    s.insert(boost::make_tuple(1, 1.0, 2));\n    s.insert(boost::make_tuple(2, 10.0, 2));\n    s.insert(boost::make_tuple(3, 100.0, 2));\n\n    // Requires C++11\n    const auto t = boost::make_tuple(0, -1.0, 2);\n    assert(2 == boost::get<2>(t));\n    // We can make a compile time assert for type\n    // of t. Interested? See chapter 'Compile time tricks'\n}\n```", "```cpp\n#include <boost/tuple/tuple.hpp>\n#include <cassert>\n\nvoid sample3() {\n    boost::tuple<int, float, double, int> quad(10, 1.0f, 10.0, 1); \n    int i; \n    float f; \n    double d; \n    int i2; \n\n    // Passing values from 'quad' variables \n    // to variables 'i', 'f', 'd', 'i2'.\n    boost::tie(i, f, d, i2) = quad; \n    assert(i == 10); \n    assert(i2 == 1); \n}\n```", "```cpp\nstruct id_name_pair { \n    int id; \n    std::string name; \n}; \n```", "```cpp\n#include <boost/tuple/tuple.hpp>\n#include <iostream>\n\ntemplate <int I>\nstruct printer {\n    printer() { std::cout << I; }\n};\n\nint main() {\n    // Outputs 012\n    boost::tuple<printer<0>, printer<1>, printer<2> > t;\n}\n```", "```cpp\n// Contains boost::bind and placeholders.\n#include <boost/bind.hpp>\n\n// Utility stuff required by samples.\n#include <boost/array.hpp>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <cassert>\n```", "```cpp\nvoid sample1() {\n    const boost::array<int, 12> v = {{\n        1, 2, 3, 4, 5, 6, 7, 100, 99, 98, 97, 96\n    }};\n\n    const std::size_t count0 = std::count_if(v.begin(), v.end(),\n        [](int x) { return 5 < x; }\n    );\n    const std::size_t count1 = std::count_if(v.begin(), v.end(), \n        boost::bind(std::less<int>(), 5, _1)\n    ); \n    assert(count0 == count1); \n}\n```", "```cpp\nvoid sample2() {\n    const boost::array<std::string, 3> v = {{\n        \"We \", \"are\", \" the champions!\"\n    }}; \n\n    const std::size_t count0 = std::count_if(v.begin(), v.end(),\n        [](const std::string& s) { return s.empty(); }\n    );\n    const std::size_t count1 = std::count_if(v.begin(), v.end(), \n        boost::bind(&std::string::empty, _1)\n    ); \n    assert(count0 == count1); \n} \n```", "```cpp\nvoid sample3() {\n    const boost::array<std::string, 3> v = {{\n        \"We \", \"are\", \" the champions!\"\n    }};\n\n    const std::size_t count0 = std::count_if(v.begin(), v.end(), \n        [](const std::string& s) {  return s.size() < 5; }\n    ); \n    const std::size_t count1 = std::count_if(v.begin(), v.end(), \n        boost::bind(\n            std::less<std::size_t>(),\n            boost::bind(&std::string::size, _1),\n            5\n        )\n    ); \n    assert(count0 == count1);  \n} \n```", "```cpp\nvoid sample4() {\n    const boost::array<std::string, 3> v = {{\n        \"We \", \"are\", \" the champions!\"\n    }}; \n    std::string s(\n        \"Expensive copy constructor is called when binding\"\n    );\n\n    const std::size_t count0 = std::count_if(v.begin(), v.end(),\n        [&s](const std::string& x) {  return x < s; }\n    ); \n    const std::size_t count1 = std::count_if(v.begin(), v.end(), \n        boost::bind(std::less<std::string>(), _1, s)\n    ); \n    assert(count0 == count1); \n} \n```", "```cpp\n#include <boost/ref.hpp> \n\nvoid sample5() {\n    const boost::array<std::string, 3> v = {{\n        \"We \", \"are\", \" the champions!\"\n    }}; \n    std::string s(\n        \"Expensive copy constructor is NOT called when binding\"\n    );  \n\n    const std::size_t count1 = std::count_if(v.begin(), v.end(), \n        boost::bind(std::less<std::string>(), _1, boost::cref(s))\n    ); \n    // ...\n} \n```", "```cpp\nvoid sample6() {\n    const auto twice = boost::bind(std::plus<int>(), _1, _1);\n    assert(twice(2) == 4);\n\n    const auto minus_from_second = boost::bind(std::minus<int>(), _2, _1);\n    assert(minus_from_second(2, 4) == 2);\n\n    const auto sum_second_and_third = boost::bind(\n        std::plus<int>(), _2, _3\n    );\n    assert(sum_second_and_third(10, 20, 30) == 50);\n}\n```", "```cpp\n#include <iostream>\n#include <typeinfo>\n\ntemplate <class T>\nvoid do_something(const T& x) {\n    if (x == 0) {\n        std::cout << \"Error: x == 0\\. T is \" << typeid(T).name() \n        << std::endl;\n    }\n    // ...\n}\n```", "```cpp\nvoid sample1() {\n    auto&& x = 42;\n    std::cout << \"x is \"\n              << typeid(decltype(x)).name()\n              << std::endl;\n}\n```", "```cpp\n#include <iostream>\n#include <boost/type_index.hpp>\n\ntemplate <class T>\nvoid do_something_again(const T& x) {\n    if (x == 0) {\n        std::cout << \"x == 0\\. T is \" << boost::typeindex::type_id<T>()\n                  << std::endl;\n    }\n    // ...\n}\n```", "```cpp\n#include <boost/type_index.hpp>\n\nvoid sample2() {\n    auto&& x = 42;\n    std::cout << \"x is \"\n              << boost::typeindex::type_id_with_cvr<decltype(x)>()\n              << std::endl;\n}\n```", "```cpp\nnamespace other { \n    class characteristics{}; \n} \n\nstruct person_info {\n    std::string name_; \n    std::string second_name_; \n    other::characteristics characteristic_; \n    // ...\n}; \n```", "```cpp\n#include <boost/swap.hpp> \n\nvoid person_info::swap(person_info& rhs) {\n    name_.swap(rhs.name_);\n    second_name_.swap(rhs.second_name_);\n    boost::swap(characteristic_, rhs.characteristic_);\n} \n```", "```cpp\n    BOOST_COPYABLE_AND_MOVABLE(person_info) \n```", "```cpp\nstruct person_info {\n    // Fields declared here\n    // ...\nprivate:\n    BOOST_COPYABLE_AND_MOVABLE(person_info)\npublic:\n    // For the simplicity of example we will assume that\n    // person_info default constructor and swap are very\n    // fast/cheap to call.\n    person_info();\n\n    person_info(const person_info& p)\n        : name_(p.name_)\n        , second_name_(p.second_name_)\n        , characteristic_(p.characteristic_)\n    {}\n\n    person_info(BOOST_RV_REF(person_info) person) {\n        swap(person);\n    }\n\n    person_info& operator=(BOOST_COPY_ASSIGN_REF(person_info) person) {\n        person_info tmp(person);\n        swap(tmp);\n        return *this;\n    }\n\n    person_info& operator=(BOOST_RV_REF(person_info) person) {\n        person_info tmp(boost::move(person));\n        swap(tmp);\n        return *this;\n    }\n\n    void swap(person_info& rhs);\n};\n```", "```cpp\nint main() {\n    person_info vasya;\n    vasya.name_ = \"Vasya\";\n    vasya.second_name_ = \"Snow\"; \n\n    person_info new_vasya(boost::move(vasya)); \n    assert(new_vasya.name_ == \"Vasya\"); \n    assert(new_vasya.second_name_ == \"Snow\"); \n    assert(vasya.name_.empty()); \n    assert(vasya.second_name_.empty()); \n\n    vasya = boost::move(new_vasya); \n    assert(vasya.name_ == \"Vasya\"); \n    assert(vasya.second_name_ == \"Snow\"); \n    assert(new_vasya.name_.empty()); \n    assert(new_vasya.second_name_.empty()); \n}\n```", "```cpp\nclass descriptor_owner { \n    void* descriptor_; \n\npublic: \n    explicit descriptor_owner(const char* params); \n\n    ~descriptor_owner() { \n        system_api_free_descriptor(descriptor_); \n    } \n}; \n```", "```cpp\nvoid i_am_bad() {\n    descriptor_owner d1(\"O_o\");   \n    descriptor_owner d2(\"^_^\"); \n\n    // Descriptor of d2 was not correctly freed \n    d2 = d1; \n\n    // destructor of d2 will free the descriptor \n    // destructor of d1 will try to free already freed descriptor \n}\n```", "```cpp\n#include <boost/noncopyable.hpp> \n\nclass descriptor_owner_fixed : private boost::noncopyable { \n    // ... \n```", "```cpp\nvoid i_am_good() {\n    descriptor_owner_fixed d1(\"O_o\"); \n    descriptor_owner_fixed d2(\"^_^\"); \n\n    // Won't compile \n    d2 = d1; \n\n    // Won't compile either \n    descriptor_owner_fixed d3(d1); \n}\n```", "```cpp\ndescriptor_owner construct_descriptor() \n{ \n    return descriptor_owner(\"Construct using this string\"); \n} \n```", "```cpp\nvoid construct_descriptor1(descriptor_owner& ret) \n{ \n    descriptor_owner(\"Construct using this string\").swap(ret); \n} \n```", "```cpp\nclass descriptor_owner1 {\n    void* descriptor_;\n\npublic:\n    descriptor_owner1()\n        : descriptor_(nullptr)\n    {}\n\n    explicit descriptor_owner1(const char* param);\n\n    descriptor_owner1(descriptor_owner1&& param)\n        : descriptor_(param.descriptor_)\n    {\n        param.descriptor_ = nullptr;\n    }\n\n    descriptor_owner1& operator=(descriptor_owner1&& param) {\n        descriptor_owner1 tmp(std::move(param));\n        std::swap(descriptor_, tmp.descriptor_);\n        return *this;\n    }\n\n    void clear() {\n        free(descriptor_);\n        descriptor_ = nullptr;\n    }\n\n    bool empty() const {\n        return !descriptor_;\n    }\n\n    ~descriptor_owner1() {\n        clear();\n    }\n};\n\n// GCC compiles the following in C++11 and later modes.\ndescriptor_owner1 construct_descriptor2() {\n    return descriptor_owner1(\"Construct using this string\");\n}\n\nvoid foo_rv() {\n    std::cout << \"C++11n\";\n    descriptor_owner1 desc;\n    desc = construct_descriptor2();\n    assert(!desc.empty());\n} \n```", "```cpp\n#include <boost/move/move.hpp>\n\nclass descriptor_owner_movable {\n    void* descriptor_;\n\n    BOOST_MOVABLE_BUT_NOT_COPYABLE(descriptor_owner_movable\n```", "```cpp\npublic:\n    descriptor_owner_movable()\n        : descriptor_(NULL)\n    {}\n\n    explicit descriptor_owner_movable(const char* param)\n        : descriptor_(strdup(param))\n    {}\n\n    descriptor_owner_movable(\n        BOOST_RV_REF(descriptor_owner_movable) param\n    ) BOOST_NOEXCEPT\n        : descriptor_(param.descriptor_)\n    {\n        param.descriptor_ = NULL;\n    }\n\n    descriptor_owner_movable& operator=(\n        BOOST_RV_REF(descriptor_owner_movable) param) BOOST_NOEXCEPT\n    {\n        descriptor_owner_movable tmp(boost::move(param));\n        std::swap(descriptor_, tmp.descriptor_);\n        return *this;\n    }\n\n    // ...\n};\n\ndescriptor_owner_movable construct_descriptor3() {\n    return descriptor_owner_movable(\"Construct using this string\");\n} \n```", "```cpp\n#include <boost/container/vector.hpp> \n#include <your_project/descriptor_owner_movable.h>\n\nint main() {\n    // Following code will work on C++11 and C++03 compilers \n    descriptor_owner_movable movable; \n    movable = construct_descriptor3(); \n    boost::container::vector<descriptor_owner_movable> vec; \n    vec.resize(10); \n    vec.push_back(construct_descriptor3()); \n\n    vec.back() = boost::move(vec.front()); \n}\n```", "```cpp\n// your_project/vector.hpp \n// Copyright and other stuff goes here \n\n// include guards \n#ifndef YOUR_PROJECT_VECTOR_HPP \n#define YOUR_PROJECT_VECTOR_HPP \n\n// Contains BOOST_NO_CXX11_RVALUE_REFERENCES macro.\n#include <boost/config.hpp>\n\n#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES) \n// We do have rvalues \n#include <vector> \n\nnamespace your_project_namespace { \n  using std::vector; \n} // your_project_namespace \n\n#else \n// We do NOT have rvalues \n#include <boost/container/vector.hpp> \n\nnamespace your_project_namespace { \n  using boost::container::vector; \n} // your_project_namespace \n\n#endif // !defined(BOOST_NO_CXX11_RVALUE_REFERENCES) \n#endif // YOUR_PROJECT_VECTOR_HPP \n```", "```cpp\nint main() {\n    your_project_namespace::vector<descriptor_owner_movable> v; \n    v.resize(10); \n    v.push_back(construct_descriptor3()); \n    v.back() = boost::move(v.front()); \n}\n```", "```cpp\n#include <boost/array.hpp>\n\nboost::array<unsigned char, 60> chars_65_125_pre11() {\n    boost::array<unsigned char, 60> res;\n\n    const unsigned char offset = 65;\n    for (std::size_t i = 0; i < res.size(); ++i) {\n        res[i] = i + offset;\n    }\n\n    return res;\n}\n```", "```cpp\n#include <boost/algorithm/cxx11/iota.hpp>\n#include <boost/array.hpp>\n\nboost::array<unsigned char, 60> chars_65_125() {\n    boost::array<unsigned char, 60> res;\n    boost::algorithm::iota(res.begin(), res.end(), 65);\n    return res;\n}\n```", "```cpp\n#include <boost/algorithm/hex.hpp>\n#include <iterator>\n#include <iostream>\n\nvoid to_hex_test1() {\n    const std::string data = \"Hello word\";\n    boost::algorithm::hex(\n        data.begin(), data.end(),\n        std::ostream_iterator<char>(std::cout)\n    );\n}\n```", "```cpp\n48656C6C6F20776F7264\n```", "```cpp\n#include <boost/algorithm/hex.hpp>\n#include <iterator>\n#include <iostream>\n\nvoid to_hex_test2() {\n    const std::string data = \"Hello word\";\n    boost::algorithm::hex(\n        data,\n        std::ostream_iterator<char>(std::cout)\n    );\n}\n```"]