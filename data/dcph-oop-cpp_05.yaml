- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Exploring Classes in Detail
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细探索类
- en: This chapter will begin our pursuit of **object-oriented programming** (**OOP**)
    in C++. We will begin by introducing **object-oriented** (**OO**) concepts and
    then progress to understanding how these concepts can be implemented in C++. Many
    times, implementing OOP ideas will be through *direct language support*, such
    as the features in this chapter. Sometimes, however, we will utilize various programming
    techniques to implement object-oriented concepts. These techniques will be seen
    in later chapters. In all cases, it is important to understand the object-oriented
    concepts and how these concepts relate to well-thought-out designs, and then have
    a clear understanding of how to implement these designs with robust code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们的C++面向对象编程（OOP）之旅。我们将首先介绍面向对象（OO）概念，然后进一步理解这些概念如何在C++中实现。很多时候，实现OOP理念将通过直接语言支持，如本章中的特性。有时，我们还将利用各种编程技术来实现面向对象的概念。这些技术将在后续章节中介绍。在所有情况下，理解面向对象的概念以及这些概念如何与精心设计的理念相关联，然后清楚地理解如何用健壮的代码实现这些设计，这一点非常重要。
- en: This chapter will detail C++ class usage in extreme detail. Subtle features
    and nuances are detailed beyond the basics. The goal of this chapter will be to
    allow you to understand OO concepts, and for you to begin to think in terms of
    object-oriented programming. Embracing core OO ideals, such as encapsulation and
    information hiding, will allow you to write code that is easier to maintain, and
    will allow you to modify others’ code more easily.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细阐述C++类的高级使用。除了基础知识之外，还将详细说明细微特性和细微差别。本章的目标是让你理解面向对象的概念，并开始从面向对象编程的角度思考。拥抱核心面向对象理念，如封装和信息隐藏，将使你编写的代码更容易维护，并使你更容易修改他人的代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining object-oriented terminology and concepts – object, class, instance,
    encapsulation and information hiding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义面向对象术语和概念 - 对象、类、实例、封装和信息隐藏
- en: Applying class and member function basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用类和成员函数的基本知识
- en: Examining member function internals; the `this` pointer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查成员函数内部结构；`this`指针
- en: Using access labels and access regions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问标签和访问区域
- en: Understanding constructors – default, overloaded, copy, conversion constructors,
    and in-class initializers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构造函数 - 默认构造函数、重载构造函数、拷贝构造函数、转换构造函数和类内初始化器
- en: Understanding destructors and their proper usage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解析构函数及其正确使用
- en: Applying qualifiers to data members and member functions – `inline`, `const`,
    and `static`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将限定符应用于数据成员和成员函数 - `inline`、`const`和`static`
- en: By the end of this chapter, you will understand core object-oriented terminology
    applicable to classes, and how key OO ideas such as encapsulation and information
    hiding will lead to software that is easier to maintain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解适用于类的核心面向对象术语，以及关键OO理念如封装和信息隐藏如何导致软件更容易维护。
- en: You will also appreciate how C++ provides built-in language features to support
    object-oriented programming. You will become well versed in the use of member
    functions and will understand their underlying implementation through the `this`
    pointer. You will understand how to correctly use access labels and access regions
    to promote encapsulation and information hiding.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将欣赏C++如何提供内置语言特性来支持面向对象编程。你将精通成员函数的使用，并通过`this`指针理解其底层实现。你将了解如何正确使用访问标签和访问区域来促进封装和信息隐藏。
- en: You will understand how constructors can be used to initialize objects, and
    the many varieties of constructors from basic to typical (overloaded) to the copy
    constructor, and even conversion constructors. Similarly, you will understand
    how to make proper use of the destructor prior to an object’s end of existence.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解构造函数如何用于初始化对象，以及从基本到典型（重载）再到拷贝构造函数，甚至转换构造函数的多种构造函数类型。同样，你将了解如何在对象存在结束时之前正确使用析构函数。
- en: You will also understand how qualifiers, such as `const`, `static`, and `inline`,
    may be applied to member functions to support either object-oriented concepts
    or efficiency. Likewise, you will understand how to apply qualifiers, such as
    `const` and `static`, to data members to additionally support OO ideals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解如何将限定符，如`const`、`static`和`inline`应用于成员函数以支持面向对象概念或效率。同样，你将了解如何将限定符，如`const`和`static`应用于数据成员以进一步支持OO理念。
- en: C++ can be used as an object-oriented programming language, but it is not automatic.
    To do so, you must understand OO concepts, ideology, and language features that
    will allow you to support this endeavor. Let us begin our pursuit of writing code
    that is easier to modify and maintain by understanding the core and essential
    building block found in object-oriented C++ programs, the C++ class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++可以用作面向对象编程语言，但这不是自动的。要做到这一点，你必须理解OO概念、意识形态和语言特性，这将使你能够支持这一努力。让我们通过理解面向对象C++程序中的核心和基本构建块开始我们的追求，即C++类。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter05`
    in a file named `Chp5-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05)。每个完整程序示例都可以在GitHub中找到，位于适当的章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter05`子目录中找到，文件名为`Chp5-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3KaiQ39](https://bit.ly/3KaiQ39).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接查看：[https://bit.ly/3KaiQ39](https://bit.ly/3KaiQ39)。
- en: Introducing object-oriented terminology and concepts
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍面向对象术语和概念
- en: In this section, we will introduce core object-oriented concepts as well as
    applicable terminology that will accompany these key ideas. Though new terms will
    come up throughout this chapter, we will begin with essential terms necessary
    to begin our journey in this section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍核心的面向对象概念以及伴随这些关键思想的适用术语。尽管在本章中会出现新术语，但我们将从本节开始旅程所必需的基本术语开始。
- en: Let’s get started with basic object-oriented terminology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的面向对象术语开始。
- en: Understanding object-oriented terminology
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面向对象术语
- en: We will begin with basic object-oriented terminology, and then as we introduce
    new concepts, we will extend the terminology to include C++ specific terminology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍基本的面向对象术语，然后随着我们引入新的概念，我们将扩展术语以包括C++特定的术语。
- en: The terms object, class, and instance are all important and related terms with
    which we can start our definitions. An **object** embodies a meaningful grouping
    of characteristics and behaviors. An object can be manipulated and can receive
    the action or consequences of a behavior. Objects may undergo transformations
    and can change repeatedly over time. Objects can interact with other objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“对象”、“类”和“实例”都是重要且相关的术语，我们可以从这些定义开始。一个**对象**体现了一组有意义的特性和行为。对象可以被操作，可以接收行为的动作或后果。对象可能经历变换，并且可以随时间重复改变。对象可以与其他对象交互。
- en: The term object, at times, may be used to describe the blueprint for groupings
    of like items. The term **class** may be used interchangeably with this usage
    of an object. The term object may also (and more often) be used to describe a
    specific item in such a grouping. The term **instance** may be used interchangeably
    with this meaning of an object. The context of usage will often make clear which
    meaning of the term *object* is being applied. To avoid potential confusion, the
    terms *class* and *instance* can preferably be used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“对象”有时用来描述类似项目的分组蓝图。术语**类**可以与这种对象的使用方式互换。术语“对象”也可能（更常见的是）用来描述这种分组中的特定项目。术语**实例**可以与这种对象的意义互换。使用的上下文通常会使清楚哪种“对象”的含义正在应用。为了避免潜在的混淆，建议优先使用术语“类”和“实例”。
- en: 'Let’s consider some examples, using the aforementioned terms:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些示例，使用上述术语：
- en: '![](img/Table_5.1_B19087.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_5.1_B19087.jpg)'
- en: Objects also have components. The characteristics of a class are referred to
    as **attributes**. Behaviors of a class are referred to as **operations**. The
    specific implementation of a behavior or operation is referred to as its **method**.
    In other words, the method is how an operation is implemented, or the body of
    code defining the function, whereas the operation is the function’s prototype
    or protocol for usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也有组件。类的特性被称为**属性**。类的行为被称为**操作**。行为或操作的特定实现被称为其**方法**。换句话说，方法就是操作的实施方式，或者定义功能的代码主体，而操作是函数的原型或使用协议。
- en: 'Let’s consider some high-level examples, using the aforementioned terms:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些使用上述术语的高级示例：
- en: '![](img/Table_5.2_B19087.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_5.2_B19087.jpg)'
- en: 'Each instance of a class will most likely have distinct values for its attributes.
    For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类的每个实例可能都有其属性的不同值。例如：
- en: '![](img/Table_5.3_B19087.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_5.3_B19087.jpg)'
- en: Now that we have the basic OO terms under our belt, let’s move on to important
    object-oriented concepts that are relevant to this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基本的OO术语，让我们继续探讨与本章相关的其他重要面向对象概念。
- en: Understanding object-oriented concepts
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面向对象概念
- en: The key object-oriented concepts relating to this chapter are *encapsulation*
    and *information hiding*. Incorporating these interrelated ideals into your design
    will provide the basis for writing more easily modifiable and maintainable programs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章相关的关键面向对象概念是**封装**和**信息隐藏**。将这些相互关联的理念纳入你的设计中，将为编写易于修改和维护的程序奠定基础。
- en: The grouping of meaningful characteristics (attributes) and behaviors (operations)
    that operate on those attributes, bundled together in a single unit, is known
    as **encapsulation**. In C++, we typically group these items together in a class.
    The interface to each class instance is made through operations that model the
    behaviors relevant to each class. These operations may additionally modify the
    internal state of the object by changing the values of its attributes. Concealing
    attributes within a class and providing an interface for operating on those details
    leads us to explore the supportive concept of information hiding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将有意义的特性（属性）和行为（操作）分组在一起，这些行为操作这些属性，并捆绑成一个单一单元，这被称为**封装**。在C++中，我们通常将这些项目组合成一个类。每个类实例的接口是通过模拟与每个类相关的行为的操作来实现的。这些操作还可以通过改变其属性的值来修改对象的内部状态。在类中将属性隐藏起来，并提供操作这些细节的接口，使我们探索支持性的概念**信息隐藏**。
- en: '**Information hiding** refers to the process of *abstracting* the details of
    performing an operation into a class method. That is, the user needs only to understand
    which operation to utilize and its overall purpose; the implementation details
    are hidden within the method (function’s body). In this fashion, changing the
    underlying implementation (method) will not change the operation’s interface.
    Information hiding can additionally refer to keeping the underlying implementation
    of a class’ attributes hidden. We will explore this further when we introduce
    access regions. Information hiding is a means to achieve proper encapsulation
    of a class. A properly encapsulated class will enable proper class abstraction
    and thus the support of OO designs.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息隐藏**指的是将执行操作的具体细节抽象成一个类方法的过程。也就是说，用户只需要了解要利用的操作及其整体目的；实现细节隐藏在方法（函数的主体）中。以这种方式，改变底层实现（方法）不会改变操作的接口。信息隐藏还可以指隐藏类的属性的底层实现。当我们介绍访问区域时，我们将进一步探讨这一点。信息隐藏是实现类适当封装的一种手段。一个适当封装的类将能够实现适当的类抽象，从而支持面向对象的设计。'
- en: Object-oriented systems are inherently more easily maintained because classes
    allow upgrades and modifications to be made quickly and without impact to the
    entire system due to encapsulation and information hiding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象系统天生更容易维护，因为类允许快速进行升级和修改，而不会因为封装和信息隐藏而对整个系统产生影响。
- en: Understanding class and member function basics
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和成员函数的基本知识
- en: A C++ **class** is a fundamental building block in C++ that allows a programmer
    to specify a user defined type, encapsulating related data and behaviors. A C++
    class definition will contain attributes, operations, and sometimes methods. C++
    classes support encapsulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++的**类**是C++中的基本构建块，允许程序员指定用户定义的类型，封装相关的数据和行为。C++类的定义将包含属性、操作，有时还有方法。C++类支持封装。
- en: Creating a variable of a class type is known as **instantiation**. The attributes
    in a class are known as **data members** in C++. Operations in a class are known
    as **member functions** in C++ and are used to model behaviors. In OO terms, an
    operation implies the signature of a function, or its prototype (declaration),
    and the method implies its underlying implementation or the body of the function
    (definition). In some OO languages, the term *method* is used more loosely to
    imply either the operation or its method, based on the context of usage. In C++,
    the terms *data member* and *member function* are most often used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类类型的变量被称为**实例化**。在C++中，类中的属性被称为**数据成员**。类中的操作被称为C++中的**成员函数**，并用于建模行为。在面向对象术语中，一个操作意味着一个函数的签名，或其原型（声明），而方法意味着其底层实现或函数体（定义）。在某些面向对象的语言中，术语*方法*被更宽松地使用，根据使用上下文来表示操作或其方法。在C++中，术语*数据成员*和*成员函数*最常被使用。
- en: The prototype for a member function must be placed in a class definition. Most
    often, the member function definition is placed outside of the class definition.
    The scope resolution operator `::` is then used to associate a given member function
    definition to the class in which it is a member. Dot `.` or arrow `->` notation
    is used to access all class members, including member functions, depending on
    whether we are accessing members through an instance or through a pointer to an
    instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数的原型必须放在类定义中。通常，成员函数的定义放在类定义之外。然后使用作用域解析运算符`::`将给定的成员函数定义与它是其成员的类关联起来。点`.`或箭头`->`表示法用于访问所有类成员，包括成员函数，具体取决于我们是通过实例还是通过实例的指针来访问成员。
- en: C++ structures may also be used to encapsulate data and their related behaviors.
    A C++ `struct` can do anything a C++ `class` can do; in fact, `class` is implemented
    in terms of `struct` in C++. Though structures and classes may behave identically
    (other than default visibility), classes are more often used to model objects,
    relationships between object types, and implement object-oriented systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++结构也可以用来封装数据和它们相关的行为。C++的`struct`可以做C++的`class`能做的任何事情；事实上，在C++中，`class`是用`struct`实现的。尽管结构和类可能表现相同（除了默认可见性之外），但类更常用于建模对象、对象类型之间的关系以及实现面向对象系统。
- en: 'Let’s take a look at a simple example in which we instantiate a `class` and
    a `struct`, each with member functions, for comparison with one another. We will
    break this example into several segments. The full program example can be found
    in the GitHub repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，其中我们实例化一个`class`和一个`struct`，每个都有成员函数，以便进行比较。我们将把这个例子分成几个部分。完整的程序示例可以在GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we first define a `student` type using a `struct`,
    and a `University` type using a `class`. Notice, by convention, that user defined
    types created using structures are not capitalized, yet user defined types created
    using classes begin with a capital letter. Also notice that the `class` definition
    requires the label `public:` toward the beginning of its definition. We will explore
    the use of this label later in this chapter; however, for now, the `public` label
    is present so that this `class` will have the same default visibility of its members
    as does the `struct`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先使用`struct`定义了一个`student`类型，使用`class`定义了一个`University`类型。请注意，按照惯例，使用结构创建的用户定义类型不使用大写字母，而使用类创建的用户定义类型以大写字母开头。此外，请注意，`class`定义在其定义的开始处需要标签`public:`。我们将在本章后面探讨这个标签的使用；然而，目前，`public`标签存在是为了使这个`class`具有与`struct`相同的成员默认可见性。
- en: In both the `class` and `struct` definitions, notice the function prototypes
    for `Initialize()` and `Print()`. We will tie these prototypes to member function
    definitions in the next program segment using `::`, the scope resolution operator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`和`struct`定义中，注意`Initialize()`和`Print()`函数的原型。我们将在下一个程序段中使用作用域解析运算符`::`将这些原型与成员函数定义联系起来。
- en: 'Let’s examine the various member function definitions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查各种成员函数的定义：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s review the various member function definitions for each user defined
    type. The definitions for `void student::Initialize(string, float)`, `void student::Print()`,
    `void University::Initialize(string, int)`, and `void University::Print()` appear
    consecutively in the preceding fragment. Notice how the scope resolution operator
    `::` allows us to tie the relevant function definition back to the `class` or
    `struct` in which it is a member.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾每个用户定义类型的各种成员函数定义。`void student::Initialize(string, float)`、`void student::Print()`、`void
    University::Initialize(string, int)` 和 `void University::Print()` 的定义在前面片段中依次出现。注意解析域运算符
    `::` 如何使我们能够将相关的函数定义与它是成员的 `class` 或 `struct` 关联起来。
- en: Additionally, notice that in each `Initialize()` member function, the input
    parameters are used as values to load the relevant data members for a specific
    instance of a specific class or struct type. For example, in the function definition
    of `void University::Initialize(string n, int num)`, the input parameter `num`
    is used to initialize `numStudents` for a particular `University` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在每一个 `Initialize()` 成员函数中，输入参数被用作值来加载特定类或结构类型特定实例的相关数据成员。例如，在 `void University::Initialize(string
    n, int num)` 函数定义中，输入参数 `num` 被用来初始化特定 `University` 实例的 `numStudents`。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The scope resolution operator `::` associates member function definitions with
    the class (or struct) in which they are a member.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 解析域运算符 `::` 将成员函数定义与它们所属的类（或结构）关联起来。
- en: 'Let’s see how member functions are called by considering `main()` in this example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑这个例子中的 `main()` 来看看成员函数是如何被调用的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, in `main()`, we simply define a variable, `s1`, of type `student`, and
    a variable, `u1`, of type `University`. In object-oriented terms, it is preferable
    to say that `s1` is an instance of `student`, and `u1` is an instance of `University`.
    The instantiation occurs when the memory for an object is made available. For
    this reason, declaring pointer variable `u2` using: `University *u2;` does not
    instantiate a `University`; it merely declares a pointer to a possible future
    instance. Rather, on the following line, `u2 = new University();`, we instantiate
    a `University` when the memory is allocated.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `main()` 中，我们简单地定义了一个 `student` 类型的变量 `s1` 和一个 `University` 类型的变量 `u1`。在面向对象术语中，更倾向于说
    `s1` 是 `student` 的一个实例，而 `u1` 是 `University` 的一个实例。实例化发生在为对象分配内存时。因此，使用以下方式声明指针变量
    `u2`：`University *u2;` 并不会实例化一个 `University`；它仅仅声明了一个指向可能未来实例的指针。相反，在下一行，`u2 =
    new University();`，我们通过分配内存来实例化一个 `University`。
- en: For each of the instances, we initialize their data members by calling their
    respective `Initialize()` member functions, such as `s1.Initialize("Gabby Doone",
    4.0);` or `u1.Initialize("UMD", 4500);`. We then call `Print()` through each respective
    instance, such as `u2->Print();`. Recall that `u2->Print();` may also be written
    as `(*u2).Print();`, which more easily allows us to remember that the instance
    here is `*u2`, whereas `u2` is a pointer to that instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个实例，我们通过调用它们各自的 `Initialize()` 成员函数来初始化它们的数据成员，例如 `s1.Initialize("Gabby Doone",
    4.0);` 或 `u1.Initialize("UMD", 4500);`。然后我们通过每个相应的实例调用 `Print()`，例如 `u2->Print();`。回想一下，`u2->Print();`
    也可以写成 `(*u2).Print();`，这更容易让我们记住这里的实例是 `*u2`，而 `u2` 是对该实例的指针。
- en: Notice that when we call `Initialize()` through `s1`, we call `student::Initialize()`
    because `s1` is of type `student`, and we initialize `s1`’s data members in the
    body of this function. Similarly, when we call `Print()` through `u1` or `*u2`,
    we call `University::Print()` because `u1` and `*u2` are of type `University`
    and we subsequently print out a particular university’s data members.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们通过 `s1` 调用 `Initialize()` 时，我们调用 `student::Initialize()`，因为 `s1` 是 `student`
    类型，并且我们在该函数体内初始化 `s1` 的数据成员。同样，当我们通过 `u1` 或 `*u2` 调用 `Print()` 时，我们调用 `University::Print()`，因为
    `u1` 和 `*u2` 是 `University` 类型，并且随后我们打印出特定大学的成员数据。
- en: Since instance `u1` was dynamically allocated on the heap, we are responsible
    for releasing its memory using `delete()` toward the end of `main()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实例 `u1` 是在堆上动态分配的，我们负责在 `main()` 函数的末尾使用 `delete()` 释放其内存。
- en: 'The output to accompany this program is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随此程序的输出如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we are creating class definitions with their associated member function
    definitions, it is important to know how developers typically organize their code
    in files. Most often, a class will be broken into a header (`.h`) file, which
    will contain the class definition, and a source code (`.cpp`) file, which will
    `#include` the header file, and then follow with the member function definitions
    themselves. For example, a class named `University` would have a `University.h`
    header file and a `University.cpp` source code file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在创建带有其相关成员函数定义的类定义，了解开发者通常如何在文件中组织代码是很重要的。通常，一个类会被分成一个头文件（`.h`），其中包含类定义，和一个源代码文件（`.cpp`），该文件包含头文件，然后跟随成员函数的定义。例如，名为
    `University` 的类将有一个 `University.h` 头文件和一个 `University.cpp` 源代码文件。
- en: Now, let’s move forward with our understanding of the details of how member
    functions work by examining the `this` pointer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查 "this" 指针来进一步了解成员函数的工作细节。
- en: Examining member function internals; the “this” pointer
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查成员函数内部；"this" 指针
- en: So far, we have noticed that member functions are invoked through objects. We
    have noticed that in the scope of a member function, it is the data members (and
    other member functions) of the particular object that invoked the function that
    may be utilized (in addition to any input parameters). Alas, how, and why does
    this work?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经注意到成员函数是通过对象调用的。我们注意到，在成员函数的作用域内，可能被使用的是调用该函数的特定对象的数据成员（以及其他成员函数）（除了任何输入参数）。唉，这是如何以及为什么这样工作的呢？
- en: It turns out that most often, member functions are invoked through objects.
    Whenever a member function is invoked in this fashion, that member function receives
    a pointer to the instance that invoked the function. A pointer to the object calling
    the function is then passed as an implicit first argument to the function. The
    name of this pointer is **this**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，大多数情况下，成员函数是通过对象调用的。每当以这种方式调用成员函数时，该成员函数都会接收到一个指向调用该函数的实例的指针。然后，调用该函数的对象的指针作为隐式第一个参数传递给函数。这个指针的名称是
    **this**。
- en: Though the `this` pointer may be referred to explicitly in the definition of
    each such member function, it usually is not. Even without its explicit use, the
    data members utilized in the scope of the function belong to `this`, a pointer
    to the object that invoked the function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在各个成员函数的定义中可能会明确地引用 "this" 指针，但通常并不这样做。即使没有明确使用，函数作用域内使用的数据成员属于 `this`，即指向调用该函数的对象的指针。
- en: 'Let us take a look at a full program example. Though the example is broken
    into segments, the full program can be found in the following GitHub location:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个完整的程序示例。尽管示例被分成了几个部分，但完整的程序可以在以下 GitHub 位置找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp)'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first segment of the program, we define class `Student` with a variety
    of data members, and two member function prototypes. For now, we will place everything
    in the `public` access region.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一个部分，我们定义了一个名为 `Student` 的类，它包含多种数据成员和两个成员函数原型。目前，我们将所有内容放置在 `public` 访问区域。
- en: 'Now, let’s examine the member function definitions for `void Student::Initialize()`
    and `void Student::Print()`. We will also examine how each of these functions
    looks internally to C++:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `void Student::Initialize()` 和 `void Student::Print()` 这两个成员函数的定义。我们还将检查这些函数在
    C++ 中的内部结构：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we see the member function definition for `void Student::Initialize()`,
    which takes a variety of parameters. Notice that in the body of this function,
    we first assign input parameter `fn` to data member `firstName`. We proceed similarly,
    using the various input parameters, to initialize the various data members for
    the specific object that will invoke this function. Also notice that we allocate
    memory for pointer data member `currentCourse` to be enough characters to hold
    what input parameter `course` requires (plus one for the terminating null character).
    We then `strcpy()` the string from the input parameter, `course`, to data member
    `currentCourse`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到`void Student::Initialize()`成员函数的定义，它接受各种参数。请注意，在这个函数体中，我们首先将输入参数`fn`赋值给数据成员`firstName`。我们以类似的方式，使用各种输入参数，初始化将要调用此函数的特定对象的各种数据成员。同时请注意，我们为指针数据成员`currentCourse`分配足够的内存，以容纳输入参数`course`所需的字符数（加上一个终止空字符）。然后，我们使用`strcpy()`函数将输入参数`course`中的字符串复制到数据成员`currentCourse`。
- en: Also, notice in `void Student::Initialize()`, the assignment `this->middleInitial
    = mi;`. Here, we have an optional, explicit use of the `this` pointer. It is not
    necessary or customary in this situation to qualify `middleInitial` with `this`,
    but we may choose to do so. However, in the assignment `this->gpa = gpa;`, the
    use of `this` is required. Why? Notice that the input parameter is named `gpa`
    and the data member is also `gpa`. Simply assigning `gpa = gpa;` would set the
    most local version of `gpa` (the input parameter) to itself and would not affect
    the data member. Here, disambiguating `gpa` with `this` on the left-hand side
    of the assignment indicates to set the data member, `gpa`, which is pointed to
    by `this`, to the value of the input parameter, `gpa`. Another solution is to
    use distinct names for data members versus input parameters, such as renaming
    `gpa` in the formal parameter list to `avg` (which we will do in later versions
    of this code).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意在`void Student::Initialize()`中，赋值`this->middleInitial = mi;`。在这里，我们有一个可选的显式使用`this`指针。在这种情况下，用`this`来限定`middleInitial`不是必需的或习惯性的，但我们可以选择这样做。然而，在赋值`this->gpa
    = gpa;`中，使用`this`是必需的。为什么？请注意，输入参数被命名为`gpa`，数据成员也是`gpa`。简单地赋值`gpa = gpa;`会将最局部版本的`gpa`（输入参数）设置为自身，并且不会影响数据成员。在这里，通过在赋值表达式的左侧使用`this`来区分`gpa`，表示将`this`指向的数据成员`gpa`设置为输入参数`gpa`的值。另一个解决方案是使用与输入参数不同的数据成员名称，例如将形式参数列表中的`gpa`重命名为`avg`（我们将在代码的后续版本中这样做）。
- en: Now, notice the commented-out version of `void Student::Initialize()`, which
    is below the utilized version of `void Student::Initialize()`. Here, we can see
    how most member functions are internally represented. First, notice that the name
    of the function is *name mangled* to include the data types of its parameters.
    This is internally how functions are represented, and consequentially, allows
    function overloading (that is, two functions with seemingly the same name; internally,
    each has a unique name). Next, notice that among the input parameters, there is
    an additional, first, input parameter. The name of this additional (hidden) input
    parameter is `this`, and it is defined as `Student *const this`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意`void Student::Initialize()`的注释版本，它位于已使用的`void Student::Initialize()`版本下方。在这里，我们可以看到大多数成员函数是如何在内部表示的。首先，请注意，函数的名称被*名称混淆*以包含其参数的数据类型。这是函数在内部表示的方式，并且因此允许函数重载（即具有看似相同名称的两个函数；在内部，每个都有唯一的名称）。接下来，请注意，在输入参数中，还有一个额外的第一个输入参数。这个额外（隐藏）输入参数的名称是`this`，它被定义为`Student
    *const this`。
- en: Now, in the body of the internalized function view of `void Student::Initialize()`,
    notice that each data member’s name is preceded with `this`. We are, in fact,
    accessing the data member of an object that is pointed to by `this`. Where is
    `this` defined? Recall that `this` is the implicit first input parameter to this
    function, and is a constant pointer to the object that invoked this function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在内部函数视图的`void Student::Initialize()`函数体中，请注意，每个数据成员的名称前都跟着`this`。实际上，我们是在访问由`this`指向的对象的数据成员。`this`在哪里定义的？回想一下，`this`是这个函数的隐式第一个输入参数，并且是一个指向调用此函数的对象的常量指针。
- en: Similarly, we can review the member function definition for `void Student::Print()`.
    In this function, each data member is neatly printed out using `cout` and the
    insertion operator `<<`. However, notice below this function definition, the commented-out
    internal version of `void Student::Print()`. Again, `this` is actually an implicit
    input parameter of type `Student *const`. Also, each data member usage is preceded
    with access through the `this` pointer, such as `this->gpa`. Again, we can clearly
    see that a specific instance’s members are accessed in the scope of a member function;
    these members are implicitly accessed through the `this` pointer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以回顾`void Student::Print()`的成员函数定义。在这个函数中，每个数据成员都使用`cout`和插入运算符`<<`整洁地打印出来。然而，请注意在这个函数定义下面的注释掉的内部版本`void
    Student::Print()`。同样，`this`实际上是类型为`Student *const`的隐式输入参数。此外，每个数据成员的使用都通过`this`指针进行访问，例如`this->gpa`。再次明显地看到，在成员函数的作用域内访问了特定实例的成员；这些成员是通过`this`指针隐式访问的。
- en: Lastly, note that explicit use of `this` is permitted in the body of a member
    function. We can almost always precede usage of a data member or member function,
    accessed in the body of a member function, with explicit use of `this`. Later
    in this chapter, we will see the one contrary case (using a static method). Also,
    later in this book, we will see situations in which explicit usage of `this` will
    be necessary to implement more intermediate-level OO concepts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，在成员函数的体内可以使用`this`。我们几乎总是可以在成员函数体内访问的数据成员或成员函数之前使用显式的`this`。在本章的后面，我们将看到一种相反的情况（使用静态方法）。此外，在本书的后面，我们将看到需要显式使用`this`来实现更高级的OO概念的情况。
- en: 'Nonetheless, let’s move forward by examining `main()` to complete this program
    example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们通过检查`main()`来完成这个程序示例：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the last segment of this program, we instantiate `Student` twice in `main()`.
    `Student` `s1` is an instance, whereas `s2` is a pointer to a `Student`. Next,
    we utilize either `.` or `->` notation to invoke the various member functions
    through each relevant instance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的最后一部分，我们在`main()`中两次实例化`Student`。`Student` `s1`是一个实例，而`s2`是一个指向`Student`的指针。接下来，我们使用`.`或`->`运算符通过每个相关实例调用各种成员函数。
- en: Note, when `s1` invokes `Initialize()`, the `this` pointer (in the scope of
    the member function) will point to `s1`. It will be as if `&s1` is passed as a
    first argument to this function. Likewise, when `*s2` invokes `Initialize()`,
    the `this` pointer will point to `s2`; it will be as if `s2` (which is already
    a pointer) is passed as an implicit first argument to this function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`s1`调用`Initialize()`时，`this`指针（在成员函数的作用域内）将指向`s1`。这就像将`&s1`作为第一个参数传递给这个函数一样。同样，当`*s2`调用`Initialize()`时，`this`指针将指向`s2`；这就像将`s2`（它已经是一个指针）作为隐式第一个参数传递给这个函数一样。
- en: After each instance invokes `Print()` to display the data members for each `Student`,
    notice that we release various levels of dynamically allocated memory. We start
    with the dynamically allocated data members for each instance, releasing each
    such member using `delete()`. Then, because `s2` is a pointer to an instance that
    we have dynamically allocated, we must also remember to release the heap memory
    comprising the instance itself. We again do so with `delete s2;`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个实例调用`Print()`以显示每个`Student`的数据成员之后，请注意我们释放了不同级别的动态分配的内存。我们首先释放每个实例的动态分配的数据成员，使用`delete()`释放每个这样的成员。然后，因为`s2`是指向我们动态分配的实例的指针，我们必须记住也要释放包含实例本身的堆内存。我们再次使用`delete
    s2;`来这样做。
- en: 'Here is the output for the full program example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整程序示例的输出：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let’s add to our understanding of classes and information hiding by examining
    access labels and regions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查访问标签和访问区域来加深我们对类和信息隐藏的理解。
- en: Using access labels and access regions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问标签和访问区域
- en: Labels may be introduced into a class (or structure) definition to control the
    access or visibility of class (or structure) members. By controlling the direct
    access of members from various scopes in our application, we can support encapsulation
    and information hiding. That is, we can insist that users of our classes use the
    functions that we select, with the protocols we select, to manipulate data and
    other member functions within the class in ways we, the programmers, find reasonable
    and acceptable. Furthermore, we can hide the implementation details of the class
    by advertising to the user only the desired public interface for a given class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以引入到类（或结构）定义中，以控制类（或结构）成员的访问或可见性。通过控制我们应用程序中从各个范围直接访问成员，我们可以支持封装和信息隐藏。也就是说，我们可以坚持让我们的类用户使用我们选择的函数，使用我们选择的协议来操作类内部的数据和其他成员函数，这些是我们程序员认为合理和可接受的。此外，我们可以通过仅向用户宣传给定类的所需公共接口来隐藏类的实现细节。
- en: 'Data members or member functions, collectively referred to as **members**,
    can be individually labeled, or grouped together into access regions. The three
    labels or **access regions** that may be specified are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员或成员函数，统称为**成员**，可以单独标记，或分组到访问区域中。可能指定的三个标签或**访问区域**如下：
- en: '**private**: Data members and member functions in this access region are only
    accessible within the scope of the class. The scope of a class includes member
    functions of that class.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：在此访问区域内的数据成员和成员函数仅可在类的范围内访问。类的范围包括该类的成员函数。'
- en: '`private` until we introduce inheritance. When inheritance is introduced, `protected`
    will provide a mechanism for allowing access within the derived class scope.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`私有`直到我们介绍继承。当介绍继承时，`保护`将提供一个机制，允许在派生类范围内进行访问。'
- en: '**public**: Data members and member functions in this access region are accessible
    from any scope in the program.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：在此访问区域内的数据成员和成员函数可以从程序的任何范围访问。'
- en: Reminder
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Data members and member functions are most always accessed via instances. You
    will ask, *in what scope is my instance?*, and *may I access a particular member
    from this particular scope?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员和成员函数通常通过实例进行访问。你可能会问，“我的实例在什么范围内？”，以及“我能否从这个特定范围访问特定的成员？”
- en: As many members as required by the programmer may be grouped under a given label
    or `private`. If access labels are omitted in a structure definition, default
    member access is `public`. When access labels are explicitly introduced, rather
    than relying on default visibility, a `class` and a `struct` are identical. Nonetheless,
    in object-oriented programming, we tend to utilize classes for user defined types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能需要的成员可以分组在给定的标签或`私有`下。如果在结构定义中省略了访问标签，则默认成员访问为`公共`。当显式引入访问标签时，而不是依赖于默认可见性，`类`和`结构`是相同的。尽管如此，在面向对象编程中，我们倾向于使用类来定义用户定义的类型。
- en: It is interesting to note that data members, when grouped into an access region
    collectively under the same access label, are guaranteed to be laid out in memory
    in the order specified. However, if multiple access regions exist containing data
    members within a given class, the compiler is free to reorder those respective
    groupings for efficient memory layout.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意，当数据成员在具有相同访问标签的访问区域中分组时，它们在内存中的布局顺序是保证的。然而，如果存在包含给定类中数据成员的多个访问区域，编译器可以自由地重新排序这些相应的分组以实现高效的内存布局。
- en: 'Let’s examine an example to illustrate access regions. Though this example
    will be broken into several segments, the full example will be shown and can also
    be found in the GitHub repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来检查访问区域。尽管这个例子将被分成几个部分，但完整的例子将展示出来，也可以在GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we first define the `Student` class. Notice that we add a `private`
    access region near the top of the class definition and place all of the data members
    within this region. This placement will ensure that these data members will only
    be able to be directly accessed and modified within the scope of this class, which
    means by member functions of this class (and friends, which we will much later
    see). By limiting the access of data members only to member functions of their
    own class, safe handling of those data members is ensured; only access through
    intended and safe functions that the class designer has introduced themself will
    be allowed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了`Student`类。注意，我们在类定义的顶部附近添加了一个`private`访问区域，并将所有数据成员放置在这个区域中。这种放置方式将确保这些数据成员只能在类的范围内直接访问和修改，这意味着通过这个类的成员函数（以及我们稍后将要看到的友元函数）。通过限制数据成员的访问仅限于它们自己类的成员函数，确保了这些数据成员的安全处理；只有通过类设计者自己引入的预期和安全函数才能允许访问。
- en: Next, notice that the label `public` has been added in the class definition
    prior to the prototypes of the member functions. The implication is that these
    functions will be accessible in any scope of our program. Of course, we will generally
    need to access these functions each via an instance. But the instance can be in
    the scope of `main()` or any other function (even in the scope of another class’
    member functions) when the instance accesses these public member functions. This
    is known as a class’ `public` interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意在成员函数原型之前在类定义中添加了标签`public`。这意味着这些函数将在我们程序的任何范围内可访问。当然，我们通常需要通过实例来访问这些函数。但是，实例可以在`main()`函数的作用域内，或者任何其他函数的作用域内（甚至在其他类的成员函数的作用域内），当实例访问这些公共成员函数时。这被称为类的`public`接口。
- en: Access regions support encapsulation and information hiding
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 访问区域支持封装和信息隐藏
- en: A good rule of thumb is to place your data members in the `private` access region
    and then specify a safe, appropriate `public` interface to access them using `public`
    member functions. By doing so, the only access to data members is in manners that
    the class designer has intended, through member functions the class designer has
    written, which have been well tested. With this strategy, the underlying implementation
    of the class may also be changed without causing any calls to the public interface
    to change. This practice supports encapsulation and information hiding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是将数据成员放置在`private`访问区域，然后指定一个安全、适当的`public`接口，通过`public`成员函数来访问它们。这样做，数据成员的唯一访问方式就是通过类设计者有意设计的、经过良好测试的成员函数。采用这种策略，类的底层实现也可以更改，而不会导致对公共接口的任何调用发生变化。这种做法支持封装和信息隐藏。
- en: 'Let’s continue by taking a look at the various member function definitions
    in our program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看我们程序中的各种成员函数定义：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have defined the various member functions that were prototyped in our
    class definition. Notice the use of the scope resolution operator `::` to tie
    the class name to the member function name. Internally, these two identifiers
    are *name mangled* together to provide a unique, internal function name. Notice
    that the `void Student::Initialize()` function has been overloaded; one version
    simply initializes all data members to some form of null or zero, whereas the
    overloaded version uses input parameters to initialize the various data members.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经定义了在类定义中原型化的各种成员函数。注意使用作用域解析运算符`::`将类名与成员函数名关联起来。内部，这两个标识符被*名称混淆*在一起，以提供唯一的内部函数名。注意，`void
    Student::Initialize()`函数被重载了；一个版本只是将所有数据成员初始化为某种形式的空或零，而重载版本使用输入参数来初始化各种数据成员。
- en: 'Now, let’s continue by examining our `main()` function in the following segment
    of code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续，检查以下代码段中的`main()`函数：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the aforementioned `main()` function, we first instantiate a `Student` with
    the declaration `Student s1;`. Next, `s1` invokes the `Initialize()` function
    with the signature matching the parameters provided. Since this member function
    is in the `public` access region, it can be accessed in any scope of our program,
    including `main()`. Similarly, `s1` invokes `Print()`, which is also `public`.
    These functions are in the `Student` class’ public interface, and represent some
    of the core functionality for manipulating any given `Student` instance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`main()`函数中，我们首先使用声明`Student s1;`实例化一个`Student`对象。接下来，`s1`调用与提供的参数签名匹配的`Initialize()`函数。由于这个成员函数在`public`访问区域，它可以在我们程序的任何作用域中访问，包括`main()`。同样，`s1`调用了`Print()`，这也是`public`的。这些函数是`Student`类的公共接口的一部分，代表了操作任何给定`Student`实例的核心功能。
- en: Next, in the commented-out line of code, notice that `s1` tries to access `firstName`
    directly using `s1.firstName`. Because `firstName` is `private`, this data member
    can only be accessed in the scope of its own class, which means member functions
    (and later friends) of its class. The `main()` function is not a member function
    of `Student`, hence `s1` may not access `firstName` in the scope of `main()`,
    that is, a scope outside its own class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在注释掉的代码行中，注意` s1`尝试直接使用` s1.firstName`来访问`firstName`。因为`firstName`是`private`的，这个数据成员只能在它自己类的范围内访问，这意味着它的成员函数（以及后来的朋友）可以访问。`main()`函数不是`Student`类的成员函数，因此`
    s1`不能在`main()`的作用域内访问`firstName`，也就是说，在它自己类的作用域之外。
- en: Lastly, we invoke `s1.CleanUp();`, which also works because `CleanUp()` is `public`
    and is hence accessible from any scope (including `main()`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了`s1.CleanUp();`，这也同样有效，因为`CleanUp()`是`public`的，因此可以从任何作用域（包括`main()`）访问。
- en: 'The output for this complete example is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整示例的输出如下：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we understand how access regions work, let’s move forward by examining
    a concept known as a constructor, and the various types of constructors available
    within C++.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了访问区域是如何工作的，让我们继续前进，通过考察一个称为构造函数的概念，以及C++中可用的各种类型的构造函数。
- en: Understanding constructors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构造函数
- en: Did you notice how convenient it has been for the program examples in this chapter
    to have an `Initialize()` member function for each `class` or `struct`? Certainly,
    it is desirable to initialize all data members for a given instance. More so,
    it is crucial to ensure that data members for any instance have bonafide values,
    as we know that memory is not provided *clean* or *zeroed-out* by C++. Accessing
    an uninitialized data member, and utilizing its value as if it were bonafide,
    is a potential pitfall awaiting the careless programmer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在本章的程序示例中，每个`class`或`struct`都有一个`Initialize()`成员函数是多么方便？当然，初始化给定实例的所有数据成员是可取的。更重要的是，确保任何实例的数据成员都有真实值至关重要，因为我们知道C++不会提供*干净*或*零初始化*的内存。访问未初始化的数据成员，并像使用真实值一样使用它的值，是粗心大意的程序员可能遇到的潜在陷阱。
- en: Initializing each data member individually each time a class is instantiated
    can be tedious work. What if we simply overlook setting a value? What if the values
    are `private`, and are therefore not directly accessible? We have seen that an
    `Initialize()` function is beneficial because once written, it provides a means
    to set all data members for a given instance. The only drawback is that the programmer
    must now remember to call `Initialize()` on each instance in the application.
    Instead, what if there is a way to ensure that an `Initialize()` function is called
    every time a class is instantiated? What if we could overload a variety of versions
    to initialize an instance, and the appropriate version could be called based on
    data available at the time? This premise is the basis for a constructor in C++.
    The language provides for an overloaded series of initialization functions, which
    will be automatically called once the memory for an instance becomes available.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实例化类时单独初始化每个数据成员可能是一项繁琐的工作。如果我们简单地忽略设置值怎么办？如果这些值是`private`的，因此不能直接访问怎么办？我们已经看到，`Initialize()`函数是有益的，因为它一旦编写，就提供了一种为给定实例设置所有数据成员的方法。唯一的缺点是程序员现在必须记住在应用程序的每个实例上调用`Initialize()`。那么，如果有一种方法可以确保每次实例化类时都调用`Initialize()`函数怎么办？如果我们能够重载多种版本来初始化实例，并且可以根据当时可用的数据调用适当的版本怎么办？这个前提是C++中构造函数的基础。该语言提供了一系列重载的初始化函数，一旦实例的内存变得可用，它们将自动被调用。
- en: Let’s take a look at this family of initialization member functions by examining
    the C++ constructor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查 C++ 构造函数来查看这个初始化成员函数家族。
- en: Applying constructor basics and overloading constructors
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用构造函数基础和重载构造函数
- en: A `class` (or `struct`) to define multiple means by which to initialize an object.
    The return type of a constructor may not be specified.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `class`（或 `struct`）以提供初始化对象的多种方式。构造函数的返回类型不能指定。
- en: Should your `class` or `struct` not contain a constructor, one will be made
    for you in the `public` access region, with no arguments. This is known as a default
    constructor. Behind the scenes, every time an object is instantiated, a constructor
    call is patched in by the compiler. When a class without a constructor is instantiated,
    the default constructor is patched in as a function call immediately following
    the instantiation. This system-supplied member function will have an empty body
    (method) and it will be linked into your program so that any compiler-added, implicit
    calls to this function upon instantiation can occur without a linker error. As
    needed per the design, a programmer may often write their own default (no-argument)
    constructor; that is, one that is used for the default means of instantiation
    with no arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 `class` 或 `struct` 不包含构造函数，将在 `public` 访问区域为您创建一个，不带参数。这被称为默认构造函数。在幕后，每次实例化对象时，编译器都会插入一个构造函数调用。当实例化没有构造函数的类时，默认构造函数会作为函数调用立即跟在实例化之后插入。这个系统提供的成员函数将有一个空体（方法），它将被链接到您的程序中，以便在实例化时，任何编译器添加的、隐式的对此函数的调用都可以发生，而不会出现链接器错误。根据设计需要，程序员经常可以编写自己的默认（无参数）构造函数；即，用于无参数默认实例化的构造函数。
- en: Most programmers provide at least one constructor, in addition to their own
    no-argument, default constructor. Recall that constructors can be overloaded.
    It is important to note that if you provide any constructor yourself, you will
    not then receive the system supplied no-argument default constructor, and that
    subsequently using such an interface for instantiation will cause a compiler error.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员除了自己的无参数默认构造函数外，至少还提供一个构造函数。回想一下，构造函数可以重载。重要的是要注意，如果您自己提供了任何构造函数，您将不会收到系统提供的无参数默认构造函数，并且随后使用该接口进行实例化将导致编译器错误。
- en: Reminder
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Constructors have the same name as the class. You may not specify their return
    type. They can be overloaded. The compiler only creates a public, default (no-argument)
    constructor if you have not provided any constructors (that is, means for instantiation)
    in your class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与类的名称相同。您不能指定它们的返回类型。它们可以重载。如果您在类中没有提供任何构造函数（即实例化的方法），编译器只会创建一个公共的默认（无参数）构造函数。
- en: 'Let’s introduce a simple example to understand constructor basics:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来了解构造函数的基础：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp)'
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous program segment, we first define `class University`; the data
    members are `private`, and the three member functions are `public`. Notice that
    the first two member functions prototyped are constructors. Both have the same
    name as the class; neither has its return type specified. The two constructors
    are overloaded, in that each has a different signature.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序段中，我们首先定义了 `class University`；数据成员是 `private` 的，三个成员函数是 `public` 的。注意，前两个成员函数是构造函数的原型。它们都与类的名称相同；都没有指定它们的返回类型。这两个构造函数是重载的，因为每个都有不同的签名。
- en: Next, notice that the three member functions are defined. Notice the use of
    the scope resolution operator `::` preceding each member function name, in each
    of their definitions. Each constructor provides a different means for initializing
    an instance. The `void University::Print()` member function merely provides a
    means to provide simple output for our example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意定义了三个成员函数。注意在每个定义中，每个成员函数名称之前都使用了作用域解析运算符 `::`。每个构造函数提供了一种初始化实例的不同方法。`void
    University::Print()` 成员函数仅为我们提供的示例提供了一种简单的输出方式。
- en: Now, in `main()`, let’s create three instances of `University`. The first line
    of code, `University u1;`, instantiates a `University` and then implicitly invokes
    the default constructor to initialize the data members. On the next line of code,
    `University u2("University of Delaware", 23800);`, we instantiate a second `University`.
    Once the memory for that instance has been made available on the stack in `main()`,
    the constructor matching the signature of the arguments provided, namely `University::University(const
    string &, int)`, will be implicitly invoked to initialize the instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `main()` 中，让我们创建三个 `University` 实例。第一行代码 `University u1;` 实例化一个 `University`
    对象，然后隐式调用默认构造函数来初始化数据成员。在下一行代码 `University u2("University of Delaware", 23800);`
    中，我们实例化第二个 `University`。一旦在 `main()` 中为该实例分配了内存，与提供的参数签名匹配的构造函数（即 `University::University(const
    string &, int)`）将隐式调用以初始化该实例。
- en: Finally, we instantiate a third `University` using `University u3{"Temple University",
    20500};`, which also makes use of the alternate constructor. Notice the use of
    `{}`’s versus `()`’s in the instantiation and construction of `u3`. Either style
    may be utilized. The latter style was introduced in an effort to create uniformity;
    neither construct results in a performance advantage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `University u3{"Temple University", 20500};` 实例化第三个 `University` 对象，这也使用了备用构造函数。注意在实例化和构造
    `u3` 时 `{}` 与 `()` 的使用。两种风格都可以使用。后一种风格是为了创建一致性；两种构造方式都不会带来性能优势。
- en: We can see that based upon how we instantiate an object, we can specify which
    constructor we would like to be called on our behalf to perform the initialization.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，根据我们如何实例化对象，我们可以指定我们希望为我们调用哪个构造函数来执行初始化。
- en: 'The output for this example is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出如下：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Parameter comparison
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 参数比较
- en: Did you notice the signature to the alternate `University` constructor is `University(const
    string &, int);`? That is, the first parameter is a `const string &` rather than
    a `string`, as used in previous examples for our `Initialize()` member function?
    Both are acceptable. A `string` parameter will pass a copy of the formal parameter
    on the stack to the member function. If the formal parameter is a string literal
    in quotes (such as `"University of Delaware"`), a `string` instance will first
    be made to house this literal string of characters. In comparison, if the parameter
    to the constructor is a `const string &`, then a reference to the formal parameter
    will be passed to this function and the object referenced will be treated as `const`.
    In the body of the constructor, we use assignment to copy the value of the input
    parameter to the data member. Not to worry, the implementation of the assignment
    operator for the `string` class performs a deep assignment from the source to
    the destination string. The implication is that we do not have to worry about
    the data member sharing memory (that is, not having its own copy) with the initialization
    data (string). Therefore, either use of a `string` or `const string &` as a parameter
    for the constructor is acceptable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到备用 `University` 构造函数的签名是 `University(const string &, int);` 吗？这意味着第一个参数是一个
    `const string &` 而不是 `string`，就像之前示例中我们 `Initialize()` 成员函数所使用的？两者都是可接受的。一个 `string`
    参数会将形式参数的副本传递到成员函数的栈上。如果形式参数是一个引号中的字符串字面量（例如 `"University of Delaware"`），则会首先创建一个
    `string` 实例来容纳这个字符序列。相比之下，如果构造函数的参数是一个 `const string &`，则将传递形式参数的引用到该函数，并且引用的对象将被视为
    `const`。在构造函数体中，我们使用赋值操作将输入参数的值复制到数据成员。不用担心，`string` 类的赋值操作员会执行从源到目标字符串的深度复制。这意味着我们不必担心数据成员与初始化数据（即字符串）共享内存（也就是说，没有自己的副本）。因此，将
    `string` 或 `const string &` 作为构造函数的参数都是可接受的。
- en: Now, let’s complement our use of constructors with in-class initializers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用类内初始化器来补充我们对构造函数的使用。
- en: Constructors and in-class initializers
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和类内初始化器
- en: In addition to initializing data members within a constructor, a class may optionally
    contain **in-class initializers**. That is, default values that can be specified
    in a class definition as a means to initialize data members in the absence of
    specific constructor initialization (or assignment) of those data members.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在构造函数中初始化数据成员外，一个类还可以选择性地包含**类内初始化器**。也就是说，可以在类定义中指定默认值，作为初始化数据成员的手段，在没有为这些数据成员提供特定的构造函数初始化（或赋值）的情况下。
- en: 'Let’s consider a revision of our previous example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们之前示例的一个修订版：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code fragment, notice that our class definition for `University`
    contains two in-class initializers for data members `name` and `numStudents`.
    These values will be used to initialize data members for a `University` instance
    when a `University` constructor does not otherwise set these values. More specifically,
    if a `University` constructor uses initialization to set these values, the in-class
    initializers will be ignored (we will see formal constructor initialization with
    the member initialization list shortly in this chapter).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，请注意，我们的`University`类定义包含两个数据成员`name`和`numStudents`的类内初始化器。当`University`构造函数没有设置这些值时，这些值将用于初始化`University`实例的数据成员。更具体地说，如果`University`构造函数使用初始化来设置这些值，则类内初始化器将被忽略（我们将在本章稍后看到正式的构造函数初始化与成员初始化列表）。
- en: Additionally, if a constructor sets these data members through assignment within
    the body of a constructor (as we have seen in the previous constructor example),
    the assignments will overwrite any in-class initialization that was otherwise
    done on our behalf. However, if we do not set data members in a constructor (as
    shown in the current code fragment), the in-class initializers will be utilized.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一个构造函数在构造函数体内部通过赋值来设置这些数据成员（正如我们在之前的构造函数示例中所见），这些赋值将覆盖任何原本为我们进行的类内初始化。然而，如果我们没有在构造函数中设置数据成员（如当前代码片段所示），则将使用类内初始化器。
- en: In-class initializers can be used to simplify default constructors or to alleviate
    default values specified within a constructor’s prototype (a style that is becoming
    less popular).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类内初始化器可以用作简化默认构造函数或减轻构造函数原型中指定的默认值（这种风格变得越来越不受欢迎）。
- en: As we have seen in this example, in-class initializers can lead to a default
    constructor having no work (that is, initialization) remaining to be conducted
    in the method body itself. Yet, we can see that in some cases, a default constructor
    is necessary if we would like to use the default interface for instantiation.
    In cases such as these, `=default` may be added to the prototype of the default
    constructor to indicate that the system-supplied default constructor (with an
    empty body) should be linked in on our behalf, alleviating our need to provide
    an empty, default constructor ourselves (as in our previous example).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本例中所见，类内初始化器可能导致默认构造函数在方法体本身中不再有工作（即初始化）要做。然而，我们可以看到在某些情况下，如果我们想使用默认接口进行实例化，则默认构造函数是必要的。在这些情况下，可以将`=default`添加到默认构造函数的原型中，以指示系统提供的默认构造函数（具有空体）应该为我们链接，从而减轻我们提供空默认构造函数的需要（如我们之前的示例所示）。
- en: 'With this improvement, our class definition will become the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次改进，我们的类定义将变为以下内容：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous class definition, we have now requested the system-supplied
    default constructor (with an empty body) in a situation where we would not have
    otherwise gotten one automatically (because we have provided a constructor with
    another signature). We have saved specifying an empty-bodied default constructor
    ourselves, as in our original example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的类定义中，我们现在请求系统提供的默认构造函数（具有空体），在这种情况下我们本来不会自动获得（因为我们已经提供了一个具有不同签名的构造函数）。我们已经节省了指定一个空体的默认构造函数，正如我们的原始示例所示。
- en: Next, let’s add to our knowledge of constructors by examining a copy constructor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过检查拷贝构造函数来增加我们对构造函数的知识。
- en: Creating copy constructors
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建拷贝构造函数
- en: A **copy constructor** is a specialized constructor that is invoked whenever
    a copy of an object may need to be made. Copy constructors may be invoked during
    the construction of another object. They may also be invoked when an object is
    passed by value to a function via an input parameter or returned by value from
    a function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**拷贝构造函数**是一种特殊构造函数，当可能需要创建对象的副本时会被调用。拷贝构造函数可能在另一个对象的构造过程中被调用。它们也可能在对象通过值传递给函数作为输入参数或从函数返回值时被调用。'
- en: Often, it is easier to make a copy of an object and modify the copy slightly
    than to construct a new object with its individual attributes from scratch. This
    is especially true if a programmer requires a copy of an object that has undergone
    many changes during the life of the application. It may be impossible to recall
    the order of various transformations that may have been applied to the object
    in question in order to create a duplicate. Instead, having the means to copy
    an object is desirable, and possibly crucial.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，复制一个对象并稍作修改比从头开始构造一个具有其各自属性的新对象要容易。这在程序员需要应用程序生命周期中经过多次更改的对象的副本时尤其正确。可能无法回忆起对特定对象应用的各种转换的顺序，以创建一个副本。相反，拥有复制对象的方法是可取的，可能是至关重要的。
- en: The signature of a copy constructor is `ClassName::ClassName(const ClassName
    &);`. Notice that a single object is explicitly passed as a parameter, and that
    parameter will be a reference to a constant object. The copy constructor, as do
    most member functions, will receive an implicit argument to the function, the
    `this` pointer. The purpose of the copy constructor’s definition will be to make
    a copy of the explicit parameter to initialize the object pointed to by `this`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数的签名是 `ClassName::ClassName(const ClassName &);`。注意，一个对象被明确地作为参数传递，并且该参数将是一个指向常量对象的引用。复制构造函数，就像大多数成员函数一样，将接收一个隐式参数到函数中，即
    `this` 指针。复制构造函数定义的目的是为了复制显式参数以初始化 `this` 指向的对象。
- en: If no copy constructor is implemented by the `class` (or `struct`) designer,
    one will be provided for you (in the `public` access region) that performs a shallow,
    member-wise copy. This is unlikely not what you want if you have data members
    in your class that are pointers. Instead, the best thing to do is to write a copy
    constructor yourself, and write it to perform a deep copy (allocating memory as
    necessary) for data members that are pointers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类（或 `struct`）的设计者没有实现复制构造函数，将为你提供一个（在 `public` 访问区域），它执行浅拷贝。如果你在类中有指针类型的成员变量，这很可能不是你想要的。相反，最好的做法是自己编写一个复制构造函数，并编写它以执行深拷贝（根据需要分配内存）。
- en: 'Should the programmer wish to disallow copying during construction, `=delete`
    can be used in the prototype of the copy constructor as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员希望在构造过程中禁止复制，可以在复制构造函数的原型中使用 `=delete`，如下所示：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Alternatively, if the programmer wishes to prohibit object copying, a copy constructor
    may be prototyped in the `private` access region. In this case, the compiler will
    link in the default copy constructor (which performs a shallow copy), but it will
    be considered private. Therefore, instantiations that would utilize the copy constructor
    outside the scope of the class will be prohibited. This technique is used less
    frequently since the advent of `=delete`; however, it may be seen in existing
    code, so it is useful to understand.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果程序员希望禁止对象复制，可以在 `private` 访问区域中声明一个复制构造函数。在这种情况下，编译器将链接默认的复制构造函数（执行浅拷贝），但它将被视为私有。因此，在类的作用域之外使用复制构造函数的实例将被禁止。自从
    `=delete` 出现以来，这种技术使用得较少，但它可能存在于现有代码中，因此了解它是有用的。
- en: 'Let’s examine a copy constructor, starting with the class definition. Though
    the program is presented in several fragments, the full program example may be
    found in the GitHub repository:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个复制构造函数，从类定义开始。尽管程序以几个片段的形式呈现，但完整的程序示例可以在 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp)'
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this program segment, we start by defining `class Student`. Notice the usual
    assortment of `private` data members and `public` member function prototypes,
    including the default constructor and an overloaded constructor. Also notice the
    prototype for the copy constructor `Student(const Student &);`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序段中，我们首先定义 `class Student`。注意通常的 `private` 数据成员和 `public` 成员函数原型，包括默认构造函数和一个重载构造函数。还要注意复制构造函数的原型
    `Student(const Student &);`。
- en: 'Next, let’s take a look at the member function definitions with the following
    continuation of our program:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们程序接下来的部分中成员函数的定义：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the aforementioned code fragment, we have various member function definitions.
    Most notably, let’s consider the copy constructor definition, which is the member
    function with the signature of `Student::Student(const Student &s)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们定义了各种成员函数。最值得注意的是，让我们考虑复制构造函数的定义，它是一个具有签名 `Student::Student(const
    Student &s)` 的成员函数。
- en: Notice that the input parameter, `s`, is a reference to a `Student` that is
    `const`. This means that the source object, which we will be copying from, may
    not be modified. The destination object, which we will be copying into, will be
    the object pointed to by the `this` pointer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到输入参数 `s` 是一个指向 `Student` 的 `const` 引用。这意味着我们将要复制的源对象可能不会被修改。我们将要复制的目标对象将是
    `this` 指针指向的对象。
- en: As we carefully navigate the copy constructor, notice that we successively allocate
    space, as necessary, for any pointer data members that belong to the object pointed
    to by `this`. The space allocated is the same size as required by the data members
    referred to by `s`. We then carefully copy from source data member to destination
    data member. We meticulously ensure that we make an exact copy in the destination
    object of the source object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仔细导航复制构造函数时，注意我们依次为属于 `this` 指向的对象的任何指针数据成员分配必要的空间。分配的空间与 `s` 所引用的数据成员所需的大小相同。然后我们仔细地从源数据成员复制到目标数据成员。我们细致地确保在目标对象中精确地复制源对象。
- en: Notice that we are making a *deep copy* in the destination object. That is,
    rather than simply copying the pointers contained in `s.currentCourse` to `this->currentCourse`,
    for example, we instead allocate space for `this->currentCourse` and then copy
    over the source data. The result of a shallow copy would instead be that the pointer
    data members in each object would share the same dereferenced memory (that is,
    the memory to which each pointer points). This is most likely not what you would
    want in a copy. Also recall that the default behavior of a system-supplied copy
    constructor would be to provide a shallow copy from the source to the destination
    object. It is also worthy to note that the assignment between two strings such
    as `firstName = s.firstName;` in the copy constructor will perform a deep assignment
    from source to destination string because that is the behavior of the assignment
    operator defined by the string class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们在目标对象中进行了*深拷贝*。也就是说，我们不是简单地复制 `s.currentCourse` 中的指针到 `this->currentCourse`，例如，我们而是为
    `this->currentCourse` 分配空间，然后复制源数据。浅拷贝的结果将是每个对象的指针数据成员共享相同的解引用内存（即每个指针指向的内存）。这很可能不是你想要的拷贝方式。此外，回想一下，系统提供的复制构造函数的默认行为将是从源对象到目标对象的浅拷贝。也值得注意，在复制构造函数中，两个字符串如
    `firstName = s.firstName;` 之间的赋值将执行从源到目标字符串的深拷贝，因为这是字符串类定义的赋值运算符的行为。
- en: 'Now, let’s take a look at our `main()` function to see the various ways in
    which the copy constructor could be invoked:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `main()` 函数，看看复制构造函数可以以哪些方式被调用：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In `main()`, we declare two instances of `Student`, `s1` and `s2`, and each
    is initialized with the constructor that matches the signature of `Student::Student(const
    string &, const string &, char, float, const char *);`. Notice that the signature
    used in instantiation is how we select which constructor should be implicitly
    called.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们声明了两个 `Student` 实例，`s1` 和 `s2`，并且每个都是使用与 `Student::Student(const
    string &, const string &, char, float, const char *);` 签名匹配的构造函数进行初始化。注意，在实例化中使用的签名是我们选择应该隐式调用哪个构造函数的方式。
- en: Next, we instantiate `s3` and pass as an argument to its constructor the object
    `s1` with `Student s3(s1);`. Here, `s1` is of type `Student`, so this instantiation
    will match the constructor that accepts a reference to a `Student`, the copy constructor.
    Once in the copy constructor, we know that we will make a deep copy of `s1` to
    initialize the newly instantiated object, `s3`, which will be pointed to by the
    `this` pointer in the scope of the copy constructor method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化 `s3` 并将其构造函数的参数传递为对象 `s1`，即 `Student s3(s1);`。在这里，`s1` 是 `Student`
    类型，因此这种实例化将匹配接受 `Student` 引用的构造函数，即复制构造函数。一旦进入复制构造函数，我们就知道我们将对 `s1` 进行深拷贝以初始化新实例化的对象
    `s3`，该对象将由复制构造函数方法作用域内的 `this` 指针指向。
- en: 'Additionally, we instantiate `s4` with the following line of code: `Student
    s4 = s2;`. Here, because this line of code is an initialization (that is, `s4`
    is both declared and given a value in the same statement), the copy constructor
    will also be invoked. The source object of the copy will be `s2` and the destination
    object will be `s4`. Notice that we then modify each of the copies (`s3` and `s4`)
    slightly by modifying their `firstName` data members.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用以下代码行实例化`s4`：`Student s4 = s2;`。在这里，因为这一行代码是一个初始化（即`s4`在同一语句中既被声明又被赋予了一个值），所以也会调用复制构造函数。复制的源对象将是`s2`，目标对象将是`s4`。请注意，我们随后稍微修改了每个副本（`s3`和`s4`）的`firstName`数据成员。
- en: Next, in the commented-out section of code, we instantiate two objects of type
    `Student`, `s5` and `s6`. We then try to assign one to the other with `s5 = s6;`.
    Though this looks similar to the initialization between `s4` and `s2`, it is not.
    The line `s5 = s6;` is an assignment. Each of the objects existed previously.
    As such, the copy constructor is not called for this segment of code. Nonetheless,
    this code is legal and has similar implications as with the assignment operator.
    We will examine these details later in the book when we discuss operator overloading
    in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在代码的注释部分，我们实例化了两个`Student`类型的对象，`s5`和`s6`。然后我们尝试使用`s5 = s6;`将一个赋值给另一个。尽管这看起来与`s4`和`s2`之间的初始化相似，但它并不是。`s5
    = s6;`这一行是一个赋值操作。每个对象都之前已经存在。因此，这段代码没有调用复制构造函数。尽管如此，这段代码是合法的，并且具有与赋值运算符类似的含义。我们将在[*第12章*](B19087_12.xhtml#_idTextAnchor526)“朋友和运算符重载”中稍后讨论这些细节。
- en: We then print out objects `s1`, `s2`, `s3`, and `s4`. Then, we call `Cleanup()`
    on each of these four objects. Why? Each object contained data members that were
    pointers, so it is appropriate to delete the heap memory contained within each
    instance (that is, selected pointer data members) prior to these outer stack objects
    going out of scope.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后打印出对象`s1`、`s2`、`s3`和`s4`。然后，我们对这四个对象中的每一个调用`Cleanup()`。为什么？每个对象都包含指针数据成员，因此在这些外部栈对象超出作用域之前，删除每个实例（即选定的指针数据成员）中包含的堆内存是合适的。
- en: 'Here is the output to accompany the full program example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是伴随完整程序示例的输出：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output for this example shows each original `Student` instance, paired with
    its copy. Notice that each copy has been modified slightly from the original (`firstName`
    differs).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出显示了每个原始`Student`实例及其副本的配对。请注意，每个副本都略微修改了原始副本（`firstName`不同）。
- en: Related topic
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相关主题
- en: It is interesting to note that the assignment operator shares many similarities
    with the copy constructor, in that it can allow data to be copied from a source
    to destination instance. However, the copy constructor is implicitly invoked for
    the initialization of a new object, whereas the assignment operator will be invoked
    when performing an assignment between two existing objects. Nonetheless, the methods
    of each will look strikingly similar! We will examine overloading the assignment
    operator to customize its behavior to perform a deep assignment (much like a deep
    copy) in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator
    Overloading*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值运算符与复制构造函数有很多相似之处，因为它可以允许数据从源复制到目标实例。然而，复制构造函数在初始化新对象时隐式调用，而赋值运算符将在两个现有对象之间执行赋值时调用。尽管如此，每种方法看起来都非常相似！我们将在[*第12章*](B19087_12.xhtml#_idTextAnchor526)“朋友和运算符重载”中检查重载赋值运算符以自定义其行为以执行深度赋值（类似于深度复制）。
- en: Now that we have a deep understanding of copy constructors, let’s look at one
    last variety of constructor, the conversion constructor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对复制构造函数有了深入的理解，让我们来看最后一种构造函数，即转换构造函数。
- en: Creating conversion constructors
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换构造函数
- en: Type conversions can be performed from one user defined type to another, or
    from a standard type to a user defined type. A conversion constructor is a language
    mechanism that allows such conversions to occur.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换可以从一个用户定义类型转换到另一个用户定义类型，或者从标准类型转换到用户定义类型。转换构造函数是一种语言机制，允许这种转换发生。
- en: A **conversion constructor** is a constructor that accepts one explicit argument
    of a standard or user defined type and applies a reasonable conversion or transformation
    on that object to initialize the object being instantiated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换构造函数**是一种接受一个标准或用户定义类型的显式参数的构造函数，并应用合理的转换或变换来初始化正在实例化的对象。'
- en: 'Let’s take a look at an example illustrating this idea. Though the example
    will be broken into several segments and also abbreviated, the full program can
    be found in the GitHub repository:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示这个想法。虽然这个示例将被分成几个部分，并且也会进行缩写，但完整的程序可以在GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp)'
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous program segment, we first include a forward declaration to `class
    Student;` – this declaration allows us to refer to the `Student` type prior to
    its definition. We then define `class Employee`. Notice that this class includes
    several `private` data members and three constructor prototypes – a default, alternative,
    and conversion constructor. As a side note, notice that a copy constructor has
    not been programmer-specified. This means that a default (shallow) copy constructor
    will be provided by the compiler. In this case, since there are no pointer data
    members, the shallow copy is acceptable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的程序段中，我们首先包含了一个对`class Student;`的前向声明——这个声明允许我们在定义之前引用`Student`类型。然后我们定义了`class
    Employee`。注意，这个类包含几个`private`数据成员和三个构造函数原型——一个默认构造函数、一个替代构造函数和一个转换构造函数。作为旁注，请注意，没有程序员指定复制构造函数。这意味着编译器将提供一个默认（浅拷贝）复制构造函数。在这种情况下，由于没有指针数据成员，浅拷贝是可以接受的。
- en: Nonetheless, let us continue by examining the `Employee` conversion constructor
    prototype. Notice that in the prototype, this constructor takes a single argument.
    The argument is a `Student &`, which is why we needed the forward declaration
    for `Student`. Preferably, we might use a `const Student &` as the parameter type,
    but we will need to understand const member functions (later in this chapter)
    in order to do so. The type conversion that will take place will be to convert
    a `Student` into a newly constructed `Employee`. It will be our job to provide
    a meaningful conversion to accomplish this in the definition for the conversion
    constructor, which we will see shortly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们继续通过检查`Employee`转换构造函数原型。注意，在这个原型中，这个构造函数接受一个单一参数。参数是一个`Student &`，这就是为什么我们需要对`Student`进行前向声明。最好，我们可能使用`const
    Student &`作为参数类型，但我们需要理解const成员函数（在本章的后面部分）才能做到这一点。将要发生的类型转换是将`Student`转换成一个新的`Employee`。这将是我们提供有意义的转换以在转换构造函数的定义中实现这一点的任务，我们将在稍后看到。
- en: Next, we define our `Student` class, which is much the same as we have seen
    in previous examples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的`Student`类，它与我们在之前的示例中看到的大致相同。
- en: Now, let us continue with the example to see the member function definitions
    for `Employee` and `Student`, and our `main()` function, in the following code
    segment. To conserve space, selected member function definitions will be omitted,
    however, the online code will show the program in its entirety.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续这个示例，看看`Employee`和`Student`的成员函数定义，以及我们的`main()`函数，在下面的代码段中。为了节省空间，将省略选定的成员函数定义，然而，在线代码将展示整个程序。
- en: 'Moving onward, our member functions for `Employee` and `Student` are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们的`Employee`和`Student`的成员函数如下：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous segment of code, we notice several constructor definitions for
    `Employee`. We have a default, alternate, and conversion constructor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们注意到为`Employee`定义了几个构造函数。我们有一个默认构造函数、一个替代构造函数和一个转换构造函数。
- en: Examining the definition of the `Employee` conversion constructor, notice that
    the formal parameter for the source object is `s`, which is of type `Student`.
    The destination object will be the `Employee` that is being constructed, which
    will be pointed to by the `this` pointer. In the body of this function, we carefully
    copy the `firstName` and `lastName` from `Student &s` to the newly instantiated
    `Employee`. Note that we use access functions `const string &Student::GetFirstName()`
    and `const string &Student::GetLastName()` to do so (via an instance of `Student`),
    as these data members are `private`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`Employee`转换构造函数的定义，注意源对象的正式参数是`s`，其类型为`Student`。目标对象将是正在构造的`Employee`，它将由`this`指针指向。在这个函数的主体中，我们仔细地将`firstName`和`lastName`从`Student
    &s`复制到新实例化的`Employee`。注意，我们使用访问函数`const string &Student::GetFirstName()`和`const
    string &Student::GetLastName()`来完成此操作（通过一个`Student`实例），因为这些数据成员是`private`的。
- en: Let’s continue with the conversion constructor. It is our job to provide a meaningful
    conversion from one type to another. In that endeavor, we try to establish an
    initial salary for the `Employee` based on the `gpa` of the source `Student` object.
    Because `gpa` is `private`, an access function, `Student::GetGpa()`, is used to
    retrieve this value (via the source `Student`). Notice that because `Employee`
    did not have any dynamically allocated data members, we did not need to allocate
    memory to assist in a deep copy in the body of this function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论转换构造函数。我们的任务是提供一个有意义的类型之间的转换。在这个过程中，我们尝试根据源`Student`对象的`gpa`来为`Employee`设置一个初始工资。因为`gpa`是私有的，所以使用访问函数`Student::GetGpa()`来检索这个值（通过源`Student`）。请注意，由于`Employee`没有动态分配的数据成员，我们不需要在这个函数体中分配内存来辅助深度复制。
- en: To conserve space, the member function definitions for the `Student` default,
    alternate, and copy constructor have been omitted, as have the definition for
    the `void Student::Print()` and `void Student::CleanUp()` member functions. However,
    they are the same as in the previous full program example illustrating the `Student`
    class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，省略了`Student`类的默认、替代和复制构造函数的成员函数定义，以及`void Student::Print()`和`void Student::CleanUp()`成员函数的定义。然而，它们与之前完整程序示例中说明的`Student`类中的定义相同。
- en: Notice that access functions for `private` data members in `Student`, such as
    `float Student::GetGpa()`, have been added to provide safe access to those data
    members. Note that the value returned from `float Student::GetGpa()` on the stack
    is a copy of the `gpa` data member. The original `gpa` is in no worry of being
    breached by the use of this function. The same applies for member functions `const
    string &Student::GetFirstName()` and `const string &Student::GetLastName()`, which
    each returns a `const string &`, ensuring that the data that will be returned
    will not be breached.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已经添加了对`Student`中`private`数据成员的访问函数，例如`float Student::GetGpa()`，以提供对这些数据成员的安全访问。请注意，从`float
    Student::GetGpa()`返回的值是`gpa`数据成员的副本。原始的`gpa`不会因为使用这个函数而受到威胁。同样的情况适用于成员函数`const
    string &Student::GetFirstName()`和`const string &Student::GetLastName()`，它们各自返回一个`const
    string &`，确保返回的数据不会被破坏。
- en: 'Let’s complete our program by examining our `main()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查我们的`main()`函数来完成我们的程序：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our `main()` function, we instantiate a `Student`, namely `s1`, which is
    implicitly initialized with the matching constructor. Then we instantiate an `Employee`,
    `e1`, using the conversion constructor in the call `Employee e1(s1);`. At a quick
    glance, it may seem that we are utilizing the `Employee` copy constructor. But
    at a closer look, we notice that the actual parameter `s1` is of type `Student`,
    not `Employee`. Hence, we are using `Student s1` as a basis to initialize `Employee
    e1`. Note that in no manner is the `Student,` `s1`, harmed or altered in this
    conversion. For this reason, it would be preferable to define the source object
    as a `const Student &` in the formal parameter list; once we understand const
    member functions, which will then be required for usage in the body of the conversion
    constructor, we can do so.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们实例化了一个`Student`对象，即`s1`，它隐式地使用匹配的构造函数进行初始化。然后我们使用转换构造函数在调用`Employee
    e1(s1);`中实例化了一个`Employee`对象`e1`。乍一看，我们可能认为我们正在使用`Employee`的复制构造函数。但仔细观察后，我们发现实际参数`s1`的类型是`Student`，而不是`Employee`。因此，我们正在使用`Student
    s1`作为基础来初始化`Employee e1`。请注意，在这个转换过程中，`Student`对象`s1`在没有任何方式受到损害或改变。因此，最好在形式参数列表中将源对象定义为`const
    Student &`；一旦我们理解了const成员函数，这在转换构造函数体中将是必需的，我们就可以这样做。
- en: To conclude this program, we print out the `Employee` using `Employee::Print()`,
    which enables us to visualize the conversion we applied for a `Student` to an
    `Employee`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这个程序，我们使用`Employee::Print()`打印出`Employee`，这样我们就可以可视化我们对`Student`到`Employee`的转换所应用的转换。
- en: 'Here is the output to accompany our example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是伴随我们示例的输出：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we move forward, there’s one final, subtle detail about conversion constructors
    that is very important to understand.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，有一个关于转换构造函数的细微细节需要我们特别注意。
- en: Important note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Any constructor that takes a single argument is considered a conversion constructor,
    which can potentially be used to convert the parameter type to the object type
    of the class to which it belongs. For example, if you have a constructor in the
    `Student` class that takes only a `float`, this constructor could be employed
    not only in the manner shown in the preceding example but also in places where
    an argument of type `Student` is expected (such as a function call), when an argument
    of type `float` is instead supplied. This may not be what you intend, which is
    why this interesting feature is being called out. If you don’t want implicit conversions
    to take place, you can disable this behavior by declaring the constructor with
    the `explicit` keyword at the beginning of its prototype.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 任何只接受单个参数的构造函数都被认为是转换构造函数，它可以潜在地用来将参数类型转换为它所属的类的对象类型。例如，如果你在`Student`类中有一个只接受`float`的构造函数，这个构造函数不仅可以用于前面示例中所示的方式，还可以用于期望`Student`类型参数的地方（如函数调用），当提供的参数类型是`float`时。这可能不是你想要的，这就是为什么这个有趣的功能被特别指出。如果你不希望发生隐式转换，你可以在构造函数原型开始处使用`explicit`关键字来禁用此行为。
- en: Now that we understand basic, alternative, copy and conversion constructors
    in C++, let’s move forward and explore the constructor’s complementary member
    function, the C++ destructor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了C++中的基本、替代、拷贝和转换构造函数，让我们继续前进，探索构造函数的互补成员函数，即C++的析构函数。
- en: Understanding destructors
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解析构函数
- en: Recall how conveniently a class constructor provides us with a way to initialize
    a newly instantiated object? Rather than having to remember to call an `Initialize()`
    method for each instance of a given type, the constructor allows initialization
    automatically. The signature used in construction helps specify which of a series
    of constructors should be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下类构造函数是如何方便地为我们提供一个初始化新创建对象的方法？我们不需要为给定类型的每个实例记住调用一个`Initialize()`方法，构造函数允许自动初始化。在构造过程中使用的签名有助于指定应该使用一系列构造函数中的哪一个。
- en: What about object clean-up? Many classes contain dynamically allocated data
    members, which are often allocated in a constructor. Shouldn’t the memory comprising
    these data members be released when the programmer is done with an instance? Certainly.
    We have written a `CleanUp()` member function for several of our example programs.
    And we have remembered to call `CleanUp()`. Conveniently, similar to a constructor,
    C++ has an automatically built-in feature to serve as a clean-up function. This
    function is known as the destructor.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对象清理呢？许多类包含动态分配的数据成员，这些数据成员通常在构造函数中分配。当程序员完成一个实例后，这些数据成员所占用的内存不应该被释放吗？当然应该。我们已经在几个示例程序中编写了一个`CleanUp()`成员函数。并且我们已经记得调用`CleanUp()`。方便的是，类似于构造函数，C++有一个自动构建的功能作为清理函数。这个函数被称为析构函数。
- en: Let’s look at the destructor to understand its proper usage.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看析构函数，以了解其正确使用方法。
- en: Applying destructor basics and proper usage
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用析构函数的基本知识和正确使用
- en: 'A **destructor** is a member function whose purpose is to relinquish the resources
    an object may have acquired during its existence. A destructor is automatically
    invoked when a class or struct instance has either of the following occur:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**析构函数**是一个成员函数，其目的是释放对象在其存在期间可能获取的资源。当一个类或结构实例发生以下任一情况时，析构函数会自动调用：'
- en: Goes out of scope (this applies to non-pointer variables)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出作用域（这适用于非指针变量）
- en: Is explicitly deallocated using `delete` (for pointers to objects)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式地使用`delete`（用于指向对象的指针）
- en: A destructor should (most often) clean up any memory that may have been allocated
    by the constructor. The destructor’s name is a `~` character followed by the `class`
    name. A destructor will have no arguments; therefore, it cannot be overloaded.
    Lastly, the return type for a destructor may not be specified. Both classes and
    structures may have destructors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数应该（通常）清理构造函数可能分配的任何内存。析构函数的名称是一个`~`字符后跟类名。析构函数将没有参数；因此，它不能被重载。最后，析构函数的返回类型不能指定。类和结构都可以有析构函数。
- en: In addition to deallocating memory that a constructor may have allocated, a
    destructor may be used to perform other end-of-life tasks for an instance, such
    as logging a value to a database. More complex tasks may include informing objects
    pointed to by class data members (whose memory is not being released) that the
    object at hand will be concluding. This may be important if the linked object
    contains a pointer back to the terminating object. We will see examples of this
    later in the book, in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing
    Association, Aggregation, and Composition*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了释放构造函数可能分配的内存外，析构函数还可以用于执行实例的生命周期结束任务，例如将值记录到数据库中。更复杂的任务可能包括通知由类数据成员指向的对象（其内存不会被释放），当前对象将结束。如果链接的对象包含指向终止对象的指针，这可能很重要。我们将在本书后面的章节中看到这个例子，在[*第10章*](B19087_10.xhtml#_idTextAnchor454)，*实现关联、聚合和组合*。
- en: If you have not provided a destructor, the compiler will create and link in
    a `public` destructor with an empty body. This is necessary because a destructor
    call is automatically patched in just prior to the point when local instances
    are popped off the stack, and with `delete()`, just prior to the memory release
    of dynamically allocated instances. It is easier for the compiler to always patch
    in this call, rather than constantly looking to see whether your class has a destructor
    or not. Be sure to provide a class destructor yourself when there are resources
    to clean up or dynamically allocated memory requiring release. If the destructor
    will be empty, consider using `=default` in its prototype to acknowledge its automatic
    inclusion (and to forego providing a definition yourself); this practice, however,
    adds unnecessary code and therefore is becoming less popular.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有提供析构函数，编译器将创建并链接一个空的`public`析构函数。这是必要的，因为析构函数的调用会在局部实例从栈中弹出之前自动修补，以及在使用`delete()`之前，动态分配的实例释放内存之前。对于编译器来说，始终修补这个调用比不断检查你的类是否有析构函数要容易得多。当有资源需要清理或需要释放的动态分配的内存时，请务必自己提供一个类析构函数。如果析构函数将是空的，考虑在其原型中使用`=default`来承认其自动包含（并且放弃自己提供定义）；然而，这种做法增加了不必要的代码，因此变得越来越不受欢迎。
- en: There are some potential pitfalls. For example, if you forget to delete a dynamically
    allocated instance, the destructor call will not be patched in for you. C++ is
    a language that gives you the flexibility and power to do (or not do) anything.
    If you do not delete memory using a given identifier (perhaps two pointers refer
    to the same memory), please remember to delete it through the other identifier
    at a later date.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些潜在的陷阱。例如，如果你忘记删除一个动态分配的实例，析构函数调用将不会为你修补。C++是一种给你灵活性和强大功能去做（或不做）任何事情的语言。如果你不使用给定的标识符（可能两个指针指向相同的内存）删除内存，请记住稍后通过其他标识符删除它。
- en: There’s one last item worth mentioning. Though you may call a destructor explicitly,
    you will rarely ever need to do so. Destructor calls are implicitly patched in
    by the compiler on your behalf in the aforementioned scenarios. Only in very few
    advanced programming situations will you need to explicitly call a destructor
    yourself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是最后一项。尽管你可以显式调用析构函数，但你很少需要这样做。在上述情况下，编译器会代表你隐式地修补析构函数调用。只有在非常少数的高级编程情况下，你才需要自己显式调用析构函数。
- en: 'Let’s take a look at a simple example illustrating a class destructor, which
    will be broken into three segments. Its full example can be seen in the GitHub
    repository listed here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，说明类析构函数，它将被分为三个部分。其完整示例可以在以下GitHub仓库中看到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp)'
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous segment of code, we first define `class University`. Notice
    the `private` access region filled with data members, and the `public` interface,
    which includes prototypes for a default, alternate, and copy constructor, as well
    as for the destructor and a `Print()` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们首先定义了`class University`。注意填充数据成员的`private`访问区域和包含默认构造函数、替代构造函数、复制构造函数、析构函数和`Print()`方法原型的`public`接口。
- en: 'Next, let’s take a look at the various member function definitions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看各种成员函数的定义：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the aforementioned code fragment, we see the various overloaded constructors
    we are now accustomed to seeing, plus `void University::Print()`. The new addition
    is the destructor definition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们看到我们现在习惯看到的各种重载构造函数，以及`void University::Print()`。新增的是析构函数的定义。
- en: Notice the destructor `University::~University()` takes no arguments; it may
    not be overloaded. The destructor simply deallocates memory that may have been
    allocated in any of the constructors. Note that we simply `delete [] name;`, which
    will work whether `name` points to a valid address or contains a null pointer
    (yes, applying `delete` to a null pointer is OK). We additionally print the `this`
    pointer in the destructor, just for fun, so that we can see the address of the
    instance that is approaching non-existence.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到析构函数`University::~University()`不接受任何参数；它可能不能被重载。析构函数简单地释放可能在任何构造函数中分配的内存。注意我们简单地`delete
    [] name;`，这将无论`name`指向一个有效地址还是包含一个空指针（是的，将`delete`应用于空指针是允许的）。此外，我们在析构函数中打印`this`指针，只是为了好玩，这样我们就可以看到即将消失的实例的地址。
- en: 'Next, let’s take a look at `main()` to see when the destructor may be called:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`main()`函数，看看析构函数可能在何时被调用：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we instantiate two `University` instances; `u1` is an instance, and `u2`
    points to an instance. We know that `u2` is instantiated when its memory becomes
    available with `new()` and that once the memory has become available, the applicable
    constructor is called. Next, we call `University::Print()` for both instances
    to have some output.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个`University`实例；`u1`是一个实例，而`u2`指向一个实例。我们知道`u2`是在其内存可用时通过`new()`实例化的，一旦内存可用，就会调用相应的构造函数。接下来，我们调用`University::Print()`为两个实例生成输出。
- en: Finally, toward the end of `main()`, we delete `u2` to return this memory to
    the heap management facility. Just prior to memory release, with the call to `delete()`,
    C++ will patch in a call to the destructor for the object pointed to by `u2`.
    It is as if a secret function call `u2->~University();` has been patched in prior
    to `delete u2;` (note, this is done automatically, no need for you to do so as
    well). The implicit call to the destructor will delete the memory that may have
    been allocated for any data members within the class. The memory release is now
    complete for `u2`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`函数的末尾，我们删除`u2`以将内存返回给堆管理设施。在内存释放之前，在调用`delete()`时，C++将插入对`u2`指向的对象的析构函数的调用。这就像在`delete
    u2;`之前插入了一个秘密的函数调用`u2->~University();`（注意，这是自动完成的，不需要你自己这样做）。对析构函数的隐式调用将删除类内部可能分配的任何数据成员的内存。`u2`的内存释放现在已完成。
- en: What about instance `u1`? Will its destructor be called? Yes; `u1` is a stack
    instance. Just prior to its memory being popped off the stack in `main()`, the
    compiler will have patched in a call to its destructor, as if the call `u1.~University();`
    was added on your behalf (again, no need to do so yourself). For the instance
    `u1`, the destructor will also deallocate any memory for data members that may
    have been allocated. Likewise, the memory release is now complete for `u1`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`u1`实例呢？它的析构函数会被调用吗？是的；`u1`是一个栈实例。在`main()`中将它的内存从栈上弹出之前，编译器将插入对其析构函数的调用，就像代表你添加了`u1.~University();`这样的调用（再次强调，不需要你自己这样做）。对于`u1`实例，析构函数也会释放可能分配给数据成员的任何内存。同样，`u1`的内存释放现在已完成。
- en: Notice that in each destructor call, we have printed a message to illustrate
    when the destructor is called, and have also printed out the memory address for
    `this` to allow you to visualize each specific instance as it is destructed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在每次析构函数调用中，我们都打印了一条消息来展示析构函数被调用的时刻，并且也打印出了`this`的内存地址，以便你可以可视化每个特定的实例在析构时的状态。
- en: 'Here is the output to accompany our full program example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与我们的完整程序示例一起的输出：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this example, we have now examined the destructor, the complement to the
    series of class constructors. Let us move on to another set of useful topics relating
    to classes: various keyword qualifications of data members and member functions.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们现在已经检查了析构函数，这是与一系列类构造函数相对应的。让我们继续探讨与类相关的一系列有用的主题：数据成员和成员函数的各种关键字限定符。
- en: Applying qualifiers to data members and member functions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数据成员和成员函数应用限定符
- en: In this section, we will investigate qualifiers that can be added to both data
    members and member functions. The various qualifiers – `inline`, `const`, and
    `static` – can support program efficiency, aid in keeping private data members
    safe, support encapsulation and information hiding, and additionally be used to
    implement various object-oriented concepts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究可以添加到数据成员和成员函数中的修饰符。各种修饰符——`inline`、`const`和`static`——可以支持程序效率，有助于保持私有数据成员的安全，支持封装和信息隐藏，并且还可以用来实现各种面向对象的概念。
- en: Let’s get started with the various types of member qualifications.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探讨各种成员资格类型。
- en: Adding inline functions for potential efficiency
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加内联函数以提升潜在效率
- en: Imagine a set of short member functions in your program that are repeatedly
    called by various instances. As an object-oriented programmer, you appreciate
    using a `public` member function to provide safe and controlled access to `private`
    data. However, for very short functions, you worry about efficiency. That is,
    the overhead of calling a small function repeatedly. Certainly, it would be more
    efficient to just paste in the two or three lines of code comprising the function.
    Yet, you resist because that may mean providing `public` access to otherwise hidden
    class information, such as data members, which you are hesitant to do. An `inline`
    function can solve this dilemma, allowing you to have the safety of a member function
    to access and manipulate your private data, yet the efficiency of executing several
    lines of code without the overhead of a function call.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在你的程序中有一组短成员函数，它们被各种实例反复调用。作为一个面向对象的程序员，你欣赏使用`public`成员函数来提供对`private`数据的安全和受控访问。然而，对于非常短的函数，你担心效率问题。也就是说，反复调用小函数的开销。当然，直接粘贴函数的两三行代码会更有效率。然而，你却犹豫不决，因为这可能意味着提供对其他隐藏类信息的`public`访问，例如数据成员，而你对此犹豫不决。内联函数可以解决这个困境，让你既能拥有成员函数访问和操作私有数据的安全性，又能执行多行代码而不受函数调用开销的影响。
- en: An **inline** function is a function whose invocation is substituted with the
    body of the function itself. Inline functions can help eliminate the overhead
    associated with calling very small functions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联**函数是指其调用被替换为函数本身的函数体。内联函数可以帮助消除调用非常小的函数所关联的开销。'
- en: Why would calling a function have overhead? When a function is called, input
    parameters (including `this`) are pushed onto the stack, space is reserved for
    a return value of the function (though sometimes registers are used), and moving
    to another section of code requires storing information in registers to jump to
    that section of code, and so on. Replacing very small function bodies with inline
    functions can add to program efficiency.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么调用函数会有开销？当调用函数时，输入参数（包括`this`）会被推入栈中，为函数的返回值预留空间（尽管有时使用寄存器），移动到代码的另一部分需要将信息存储在寄存器中以跳转到该部分，等等。用内联函数替换非常小的函数体可以提高程序效率。
- en: 'An inline function may be specified using either of the following mechanisms:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下任一机制指定内联函数：
- en: Placing the function definition inside the class definition
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类定义内放置函数定义
- en: Placing the keyword `inline` prior to the return type in the (typical) function
    definition, found outside the class definition
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在（典型的）函数定义中，将关键字`inline`放置在返回类型之前，该定义位于类定义之外
- en: Specifying a function as `inline` in one of the aforementioned two fashions
    is merely a request to the compiler to consider the substitution of the function
    body for its function call. This substitution is not guaranteed. When might the
    compiler not actually inline a given function? If a function is recursive, it
    cannot be made `inline`. Likewise, if a function is lengthy, the compiler will
    not inline the function. Also, if the function call is dynamically bound with
    the specific implementation determined at run time (virtual functions), it cannot
    be made `inline`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数指定为上述两种方式之一中的`inline`，仅仅是向编译器提出一个请求，让其考虑用函数体替换其函数调用。这种替换并不保证。编译器在什么情况下可能不会实际内联一个给定的函数？如果一个函数是递归的，它就不能被指定为`inline`。同样，如果一个函数很长，编译器也不会内联该函数。此外，如果函数调用是动态绑定的（即在运行时确定具体实现，如虚函数），它也不能被指定为`inline`。
- en: An `inline` function definition should be declared in the header file with the
    corresponding class definition. This will allow for any revisions to the function
    to be re-expanded correctly should the need arise.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在包含相应类定义的头文件中声明`inline`函数定义。这样，如果需要，任何对函数的修订都可以正确地重新展开。
- en: 'Let’s see an example using `inline` functions. The program will be broken into
    two segments, with some well-known functions removed. However, the full program
    may be seen in the GitHub repository:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`内联`函数的例子来看看。程序将被分成两个部分，其中一些已知的函数被移除。然而，完整的程序可以在GitHub仓库中查看：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp)'
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous program fragment, let’s start with the class definition. Notice
    that several access function definitions have been added in the class definition
    itself, namely, functions such as `GetFirstName()`, `GetLastName()`, and so on.
    Look closely; these functions are actually defined within the class definition.
    For example, `float GetGpa() { return gpa; }` is not just the prototype, but the
    full function definition. By virtue of the function placement within the class
    definition, functions such as these are considered `inline`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序片段中，让我们从类定义开始。注意，在类定义本身中添加了几个访问函数定义，例如`GetFirstName()`、`GetLastName()`等。仔细观察；这些函数实际上是在类定义内部定义的。例如，`float
    GetGpa() { return gpa; }`不仅是一个原型，而且是完整的函数定义。由于这些函数是在类定义内部放置的，因此这些函数被认为是`内联`的。
- en: These small functions provide safe access to private data members. Notice `const
    char *GetCurrentCourse()`, for example. This function returns a pointer to `currentCourse`,
    which is stored in the class as a `char *`. But because the return value of this
    function is a `const char *`, this means that anyone calling this function must
    treat the return value as a `const char *`, which means treating it as unmodifiable.
    Should this function’s return value be stored in a variable, that variable must
    also be defined as `const char *`. By upcasting this pointer to an unmodifiable
    version of itself with the return value, we are adding the provision that no one
    can get their hands on a `private` data member (which is a pointer) and then change
    its value.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小函数提供了对私有数据成员的安全访问。例如，注意`const char *GetCurrentCourse()`。这个函数返回一个指向`currentCourse`的指针，它在类中以`char
    *`的形式存储。但是，因为这个函数的返回值是`const char *`，这意味着调用这个函数的人必须将返回值视为`const char *`，这意味着将其视为不可修改的。如果这个函数的返回值被存储在一个变量中，那么这个变量也必须定义为`const
    char *`。通过将这个指针向上转换为具有返回值的不可修改版本，我们添加了这样一个规定：没有人可以接触到`private`数据成员（这是一个指针）并更改其值。
- en: Now, notice toward the end of the class definition, we have a prototype for
    `void SetCurrentCourse(const char *);`. Then, outside of this class definition,
    we will see the definition for this member function. Notice the keyword `inline`
    prior to the `void` return type of this function definition. The keyword must
    be explicitly used here since the function is defined outside of the class definition.
    Remember, with either style of `inline` designation for a method, the `inline`
    specification is merely a request to the compiler to make the substitution of
    function body for function call. As with any function, if you provide a prototype
    (without `=default`), be sure to provide a function definition (or else the linker
    will definitely complain).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意在类定义的末尾，我们有一个`void SetCurrentCourse(const char *);`的原型。然后，在这个类定义之外，我们将看到这个成员函数的定义。注意这个函数定义的`void`返回类型之前的`inline`关键字。必须在这里显式使用这个关键字，因为函数是在类定义之外定义的。记住，对于任何一种`inline`方法的样式，`inline`指定仅是向编译器发出替换函数体为函数调用的请求。就像任何函数一样，如果你提供了一个原型（没有`=default`），务必提供函数定义（否则链接器肯定会抱怨）。
- en: 'Let’s continue this example by examining the remainder of our program:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查我们程序的其余部分来继续这个例子：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that in the remainder of our program example, several member function
    definitions have been omitted. The bodies of these functions are identical to
    the previous example illustrating a `Student` class in full, and can also be viewed
    online.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的程序示例的其余部分，省略了几个成员函数的定义。这些函数体的代码与之前完整展示`Student`类的示例相同，也可以在线查看。
- en: Let’s focus instead on our `main()` function. Here, we instantiate a `Student`,
    namely `s1`. We then invoke several `inline` function calls via `s1`, such as
    `s1.GetFirstName();`. Because `Student::GetFirstName()` is inline, it is as if
    we are accessing data member `firstName` directly, as the body of this function
    merely has a `return firstName;` statement. We have the safety of using a function
    to access a `private` data member (meaning that no one can modify this data member
    outside the scope of the class), but the speed of an inline function’s code expansion
    to eliminate the overhead of a function call.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于我们的`main()`函数。在这里，我们实例化了一个`Student`对象，命名为`s1`。然后，我们通过`s1`调用几个`inline`函数调用，例如`s1.GetFirstName();`。因为`Student::GetFirstName()`是内联的，所以它就像我们直接访问数据成员`firstName`一样，因为这个函数体的代码仅仅是`return
    firstName;`语句。我们使用函数访问`private`数据成员（意味着没有人可以在类的范围之外修改这个数据成员），但内联函数代码的展开速度可以消除函数调用的开销。
- en: Throughout `main()`, we make several other calls to `inline` functions in this
    same manner, including `s1.SetCurrentCourse();`. We now have the safety of encapsulated
    access with the speed of direct access to data members using small `inline` functions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们以这种方式调用其他几个`inline`函数，包括`s1.SetCurrentCourse();`。现在，我们有了封装访问的安全性和使用小型`inline`函数直接访问数据成员的速度。
- en: 'Here is the output to accompany our full program example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是伴随我们完整程序示例的输出：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s now move onward by investigating another qualifier we can add to class
    members, the `const` qualifier.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续前进，研究我们可以添加到类成员中的另一个限定符，即`const`限定符。
- en: Adding const data members and the member initialization list
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`const`数据成员和成员初始化列表
- en: We have already seen earlier in this book how to constant-qualify variables
    and the implications of doing so. To briefly recap, the implication of adding
    a `const` qualifier to a variable is that the variable must be initialized when
    it is declared and that its value may never again be modified. We previously also
    saw how to add `const` qualification to pointers, such that we could qualify the
    data being pointed to, the pointer itself, or both. Let us now examine what it
    means to add a `const` qualifier to data members within a class, and learn about
    specific language mechanisms that must be employed to initialize those data members.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的早期部分看到了如何对变量进行常量限定以及这样做的影响。为了简要回顾，添加`const`限定符到变量的影响是，变量在声明时必须初始化，并且其值可能永远不再被修改。我们之前还看到了如何对指针添加`const`限定，这样我们就可以限定被指向的数据、指针本身，或者两者。现在，让我们看看在类中添加`const`限定符到数据成员意味着什么，以及必须使用特定的语言机制来初始化这些数据成员。
- en: Data members that should never be modified should be qualified as `const`. A
    `const` variables, *never modified* means that the data member may not be modified
    using its own identifier. It will then be our job to ensure that we do not initialize
    our data members that are pointers to `const` objects with objects that are not
    labeled as `const` (lest we provide a back door to change our private data).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 应该永远不会修改的数据成员应该被标记为`const`。一个`const`变量，*永不修改*意味着该数据成员不能使用其自己的标识符进行修改。那么，我们的任务就是确保我们不会用非`const`标记的对象初始化指向`const`对象的指针数据成员（以免我们提供了一个改变私有数据的后门）。
- en: Keep in mind that in C++, a programmer can always cast the const-ness away from
    a pointer variable. Not that they should. Nonetheless, we will employ safety measures
    to ensure that by using access regions and appropriate return values from access
    functions, we do not easily provide modifiable access to our `private` data members.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在C++中，程序员总是可以从指针变量中移除const属性。虽然他们不应该这样做。不过，我们将采取安全措施，通过使用访问区域和适当的访问函数返回值，确保我们不会轻易提供对`private`数据成员的可修改访问。
- en: The **member initialization list** must be used in a constructor to initialize
    any data members that are constant, or that are references. A member initialization
    list offers a mechanism to initialize data members that may never be l-values
    in an assignment. A member initialization list may also be used to initialize
    non-const data members. For performance reasons, the member initialization list
    is most often the preferred way to initialize any data member (const or non-const).
    The member initialization list also provides a manner to specify preferred construction
    for any data members that are of class types themselves (that is, member objects).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员初始化列表**必须在构造函数中使用来初始化任何常量数据成员或引用数据成员。成员初始化列表提供了一种初始化可能永远不会作为赋值中的左值的成员的机制。成员初始化列表也可以用来初始化非`const`数据成员。出于性能考虑，成员初始化列表通常是初始化任何数据成员（常量或非常量）的首选方式。成员初始化列表还提供了一种指定任何自身为类类型的数据成员的首选构造方式（即，成员对象）。'
- en: 'A member initialization list may appear in any constructor, and to indicate
    this list, simply place a `:` after the formal parameter list, followed by a comma-separated
    list of data members, paired with the initial value for each data member in parentheses.
    For example, here we use the member initialization list to set two data members,
    `gpa` and `middleInitial`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 成员初始化列表可以出现在任何构造函数中，为了表示这个列表，只需在形式参数列表之后放置一个冒号`:`，然后是一个以逗号分隔的数据成员列表，每个数据成员后面跟着括号中的初始值。例如，这里我们使用成员初始化列表来设置两个数据成员，`gpa`和`middleInitial`：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Though we have used the member initialization list to initialize two data members
    in the previous constructor, we could have used it to set all of the data members!
    We’ll see this proposition (and preferred usage) momentarily.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在之前的构造函数中已经使用成员初始化列表初始化了两个数据成员，但我们本可以用它来设置所有数据成员！我们很快就会看到这个命题（以及首选用法）。
- en: Data members in the member initialization list are initialized in the order
    in which they appear (that is, declared) in the class definition (except static
    data members, which we will see shortly). Next, the body of the constructor is
    executed. It is a nice convention to order the data members in the member initialization
    list to appear in the same order as the class definition. But remember, the order
    of actual initialization matches the order that the data members are specified
    in the class definition, irrespective of member initialization list ordering.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 成员初始化列表中的数据成员将按照它们在类定义中（即，声明）出现的顺序进行初始化（除了静态数据成员，我们很快就会看到）。接下来，执行构造函数的主体。将数据成员按与类定义中相同的顺序排列在成员初始化列表中是一个很好的约定。但请记住，实际初始化的顺序与类定义中指定的数据成员的顺序相匹配，而不管成员初始化列表的顺序如何。
- en: It is interesting to note that a reference must use the member initialization
    list because references are implemented as constant pointers. That is, the pointer
    itself points to a specific other object and may not point elsewhere. The values
    of that object may change, but the reference always references a specific object,
    the one in which it was initialized.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，引用必须使用成员初始化列表，因为引用被实现为常量指针。也就是说，指针本身指向一个特定的其他对象，不能指向其他地方。该对象的价值可能会改变，但引用始终引用初始化时特定的对象。
- en: Using `const` qualification with pointers can be tricky to determine which scenarios
    require initialization with this list, and which do not. For example, a pointer
    to a constant object does not need to be initialized with the member initialization
    list. The pointer could point to any object, but once it does, it may not change
    the dereferenced value. However, a constant pointer must be initialized with the
    member initialization list because the pointer itself is fixed to a specific address.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`修饰符与指针一起使用可能会难以确定哪些场景需要使用这个列表进行初始化，哪些则不需要。例如，指向常量对象的指针不需要使用成员初始化列表进行初始化。该指针可以指向任何对象，但一旦指向，它就不能改变解引用的值。然而，常量指针必须使用成员初始化列表进行初始化，因为指针本身被固定在特定的地址上。
- en: 'Let’s take a look at a `const` data member and how to use the member initialization
    list to initialize its value in a full program example. We will also see how to
    use this list to initialize non-const data members. Though this example is segmented
    and not shown in its entirety, the full program can be found in the GitHub repository:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个完整的程序示例来看看`const`数据成员以及如何使用成员初始化列表来初始化其值。我们还将看到如何使用此列表来初始化非`const`数据成员。尽管这个例子被分割并且没有全部展示，但完整的程序可以在GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp)'
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the aforesaid `Student` class, notice that we have added a data member, `const
    int studentId;`, to the class definition. This data member will require the use
    of the member initialization list to initialize this constant data member in each
    of the constructors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Student`类中，请注意我们已向类定义中添加了一个数据成员，`const int studentId;`。这个数据成员将需要在每个构造函数中使用成员初始化列表来初始化这个常量数据成员。
- en: 'Let’s take a look at how the use of the member initialization list will work
    with constructors:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看成员初始化列表与构造函数的使用将如何工作：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code fragment, we see three `Student` constructors. Notice
    the various member initialization lists, designated by a `:` after the formal
    parameter list for each of the three constructors.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们看到有三个`Student`构造函数。注意三个构造函数正式参数列表后面的各种成员初始化列表。
- en: Of particular interest is the member initialization list usage for data members
    that are of type `string` (or as we’ll later see, of any class type). In this
    usage, the string data members are constructed using the member initialization
    list using the specified constructor; that is, the one whose signature matches
    the argument in `()`. This is inevitably more efficient than default constructing
    each string (which is what happened previously behind the scenes) and then resetting
    its value via assignment within the constructor method body.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是成员初始化列表在用于类型为`string`（或我们稍后将看到的任何类类型）的数据成员时的用法。在这种情况下，字符串数据成员使用指定的构造函数通过成员初始化列表进行构造；也就是说，其签名与`()`中的参数相匹配的那个构造函数。这比默认构造每个字符串（这是之前幕后发生的事情）然后通过构造函数方法体内的赋值来重置其值要高效得多。
- en: With this in mind, the default `string` constructor selection in the member
    initialization list of the `Student` default constructor – that is, `:firstName(),
    lastName(), currentCourse()` – is shown to emphasize that these data members are
    member objects (of type `string`) and will be constructed. In this case, they
    will each be default constructed, which will provide their contents with an empty
    string. However, member objects will always be default constructed unless otherwise
    directed using the member initialization list. For this reason, the `:firstName()`,
    `lastName()`, and `currentCourse()` specifications in the member initialization
    list are optional and will not be included in future examples.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Student`默认构造函数的成员初始化列表中的默认`string`构造函数选择——即`:firstName(), lastName(),
    currentCourse()`——被用来强调这些数据成员是成员对象（类型为`string`）并且将被构造。在这种情况下，它们将各自进行默认构造，这将给它们的内容提供一个空字符串。然而，除非使用成员初始化列表进行其他指示，否则成员对象总是会被默认构造。因此，成员初始化列表中的`:firstName()`、`lastName()`和`currentCourse()`指定是可选的，并且将不会包含在未来的示例中。
- en: 'Each constructor will make use of the member initialization list to set the
    values of data members that are `const`, such as `studentId`. Additionally, the
    member initialization list can be used as a simple (and more efficient) way to
    initialize any other data member. We can see examples of the member initialization
    list being used to simply set non-const data members by viewing the member initialization
    list in either the default or alternate constructor, for example, `Student::Student()
    : studentId(0), gpa(0.0)`. In this example, `gpa` is not `const`, so its use in
    the member initialization list is optional.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '每个构造函数都将使用成员初始化列表来设置`const`类型的数据成员的值，例如`studentId`。此外，成员初始化列表也可以用作简单（且更高效）的初始化任何其他数据成员的方法。我们可以通过查看默认构造函数或备用构造函数中的成员初始化列表来看到使用成员初始化列表简单设置非`const`数据成员的示例，例如，`Student::Student()
    : studentId(0), gpa(0.0)`。在这个例子中，`gpa`不是`const`，因此它在成员初始化列表中的使用是可选的。'
- en: 'Here is the output to accompany our full program example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是伴随我们完整程序示例的输出：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Important note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Even though the constructor’s member initialization list is the only mechanism
    that can be used to initialize const data members (or those that are references
    or member objects), it is also often the preferred mechanism to perform simple
    initialization for any data member for performance reasons. In many cases (such
    as member objects – for example, a string), this saves data members from being
    first initialized (constructed themselves) with a default state and then re-assigned
    a value in the body of the constructor.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管构造函数的成员初始化列表是唯一可以用来初始化`const`数据成员（或引用或成员对象）的机制，但它也常常是执行任何数据成员简单初始化的首选机制，出于性能考虑。在许多情况下（例如成员对象——例如，一个字符串），这可以节省数据成员首先以默认状态初始化（构造自身）然后再在构造函数体中重新赋值的步骤。
- en: 'It is interesting to note that programmers may choose to utilize either `()`
    or `{}` in the member initialization list to initialize data members. Notice the
    use of `{}` in the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，程序员可以选择在成员初始化列表中使用`()`或`{}`来初始化数据成员。注意以下代码中使用了`{}`：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `{}` as used here were originally added for instantiation in C++ (and hence
    with usage within member initialization lists to fully construct data members)
    in an effort to provide a uniform initialization syntax. The `{}` also potentially
    control the narrowing of data types. However, when `std::initializer_list` is
    used with templates (a feature we will see in [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*), the `{}` provides semantic confusion. Due to complexities
    such as these interfering with the goal of language uniformity, the next C++ standard
    may revert to preferring the use of `()` and so shall we. It is interesting to
    note that neither `()` nor `{}` has an advantage from the perspective of performance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`{}`最初是为了在C++中实例化（因此在使用成员初始化列表中完全构造数据成员时）而添加的，旨在提供一个统一的初始化语法。`{}`还可能控制数据类型的缩窄。然而，当与模板（我们将在[*第13章*](B19087_13.xhtml#_idTextAnchor561)，*与模板一起工作*）一起使用`std::initializer_list`时，`{}`可能会引起语义混淆。由于这些复杂性干扰了语言统一性的目标，下一个C++标准可能会回归到更喜欢使用`()`，我们也将这样做。有趣的是，从性能的角度来看，`()`和`{}`都没有优势。
- en: Next, let’s now move forward by adding the `const` qualifier to member functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加`const`限定符到成员函数来继续前进。
- en: Using const member functions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用const成员函数
- en: We have seen the constant qualifier used quite exhaustively now with data. It
    can also be used in conjunction with member functions. C++ provides a language
    mechanism to ensure that selected functions may not modify data; this mechanism
    is the `const` qualifier as applied to member functions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经非常详尽地看到了`const`限定符在数据中的应用。它也可以与成员函数结合使用。C++提供了一种语言机制来确保选定的函数不能修改数据；这种机制是应用于成员函数的`const`限定符。
- en: A **const member function** is a member function that specifies (and enforces)
    that the method can only perform read-only activities on the object invoking the
    function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**const成员函数**是一种成员函数，它指定（并强制）该函数只能对调用该函数的对象执行只读操作。'
- en: A constant member function means that no portion of `this` may be modified.
    However, because C++ allows typecasting, it is possible to cast `this` to its
    non-const counterpart and then change data members. However, if the class designer
    truly meant to be able to modify data members, they simply would not label a member
    function as `const`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 常量成员函数意味着`this`的任何部分都不能被修改。然而，由于C++允许类型转换，可以将`this`转换为它的非`const`对应类型，然后更改数据成员。但是，如果类设计者真正希望能够修改数据成员，他们就不会将成员函数标记为`const`。
- en: Constant instances declared in your program may only invoke `const` member functions.
    Otherwise, these objects could be directly modified.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中声明的常量实例只能调用`const`成员函数。否则，这些对象可能会被直接修改。
- en: To label a member function as `const`, the keyword `const` should be specified
    after the argument list in the function prototype and in the function definition.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要将成员函数标记为`const`，应在函数原型和函数定义中的参数列表后面指定`const`关键字。
- en: 'Let’s see an example. It will be divided into two sections with some portions
    omitted; however, the full example can be seen in the GitHub repository:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。它将被分为两个部分，其中一些部分被省略；然而，完整的示例可以在GitHub仓库中查看：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous program fragment, we see a class definition for `Student`, which
    is becoming very familiar to us. Notice, however, that we have added the `const`
    qualifier to most of the access member functions, that is, to those methods that
    are only providing read-only access to data.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序片段中，我们看到一个`Student`类的定义，这个定义对我们来说越来越熟悉。然而，请注意，我们已经将`const`限定符添加到大多数访问成员函数上，即那些只提供数据只读访问的方法。
- en: For example, let us consider `float GetGpa() const { return gpa; }`. The `const`
    keyword after the argument list indicates that this is a constant member function.
    Notice that this function does not modify any data member pointed to by `this`.
    It cannot do so, as it is marked as a `const` member function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑`float GetGpa() const { return gpa; }`。参数列表后面的`const`关键字表示这是一个常量成员函数。请注意，这个函数没有修改由`this`指向的任何数据成员。它不能这样做，因为它被标记为`const`成员函数。
- en: 'Now, let’s move on to the remainder of this example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续这个示例的剩余部分：
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the remainder of this program, notice that we have again chosen not to include
    the definitions for member functions with which we are already familiar, such
    as the constructors, the destructor, and `void Student::SetCurrentCourse()`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的其余部分，请注意，我们再次选择不包含我们已熟悉的成员函数的定义，例如构造函数、析构函数和`void Student::SetCurrentCourse()`。
- en: 'Instead, let’s focus our attention on the member function with the signature:
    `void Student::Print() const`. Here, the `const` keyword after the argument list
    indicates that no data members pointed to by `this` can be altered in the scope
    of this function. And none are. Likewise, any member functions called on this
    within `void Student::Print()` must also be `const` member functions. Otherwise,
    they could modify `this`.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们关注具有以下签名的成员函数：`void Student::Print() const`。在这里，参数列表后面的`const`关键字表示在这个函数的作用域内，由`this`指向的任何数据成员都不能被更改。实际上并没有。同样，在`void
    Student::Print()`中调用的任何成员函数也必须是`const`成员函数。否则，它们可能会修改`this`。
- en: Moving forward to examine our `main()` function, we instantiate a `Student`,
    namely `s1`. This `Student` calls several member functions, including some that
    are `const`. `Student s1` then changes their current course using `Student::SetCurrentCourse()`,
    and then the new value of this course is printed.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来检查我们的`main()`函数。我们实例化一个`Student`，即`s1`。这个`Student`调用几个成员函数，包括一些`const`成员函数。然后使用`Student::SetCurrentCourse()`更改`s1`的当前课程，并打印出这个课程的新值。
- en: Next, we instantiate another `Student`, `s2`, which is qualified as `const`.
    Notice that once this student is instantiated, the only member functions that
    may be applied to `s2` are those that are labeled as `const`. Otherwise, the instance
    may be modified. We then print out data for `s2` using `Student::Print();`, which
    is a `const` member function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化另一个`Student`，即`s2`，它被标记为`const`。请注意，一旦这个学生被实例化，可以应用于`s2`的唯一成员函数是那些被标记为`const`的。否则，实例可能会被修改。然后我们使用`Student::Print();`打印`s2`的数据，这是一个`const`成员函数。
- en: 'Did you notice the commented-out line of code: `s2.SetCurrentCourse("Advanced
    C++ Programming");`? This line is illegal and would not compile, because `SetCurrentCourse()`
    is not a constant member function and is hence inappropriate to be called via
    a constant instance, such as `s2`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到被注释掉的代码行：`s2.SetCurrentCourse("Advanced C++ Programming");`吗？这一行是非法的，并且无法编译，因为`SetCurrentCourse()`不是一个常量成员函数，因此不适宜通过常量实例（如`s2`）来调用。
- en: 'Let’s take a look at the output for the full program example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看完整程序示例的输出：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have fully explored `const` member functions, let’s continue to
    the final section of this chapter to delve into `static` data members and `static`
    member functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全探讨了`const`成员函数，让我们继续本章的最后部分，深入探讨`static`数据成员和`static`成员函数。
- en: Utilizing static data members and static member functions
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用静态数据成员和静态成员函数
- en: Now that we have been using C++ classes to define and instantiate objects, let’s
    add to our knowledge of object-oriented concepts by exploring the idea of a class
    attribute. A data member that is intended to be shared by all instances of a particular
    class is known as a **class attribute**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用C++类来定义和实例化对象了，让我们通过探索类属性的概念来丰富我们对面向对象概念的了解。一个旨在被特定类的所有实例共享的数据成员被称为**类属性**。
- en: Typically, each instance of a given class has distinct values for each of its
    data members. However, on occasion, it may be useful for all instances of a given
    class to share one data member containing a single value. The object-oriented
    concept of a class attribute can be modeled in C++ using a **static data member**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，给定类的每个实例都有其数据成员的不同值。然而，有时，让给定类的所有实例共享一个包含单个值的数据成员可能是有用的。在C++中，可以使用**静态数据成员**来模拟类属性的概念。
- en: Static data members themselves are implemented as external (global) variables
    whose scope is tied back to the class in question using *name mangling*. Hence,
    each static data member can have its scope limited to the class in question.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据成员本身被实现为外部（全局）变量，其作用域通过*名称修饰*与相关的类绑定。因此，每个静态数据成员的作用域都可以限制在相关的类中。
- en: Static data members are designated in the class definition with the keyword
    `static` preceding the data type. To finish modeling a `static` data member, an
    external variable definition, outside the class, must additionally follow the
    `static` data member specification in the class definition. Storage for this *class
    member* is obtained by the external variable that comprises its underlying implementation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字`static`在类定义中指定静态数据成员。为了完成对`static`数据成员的建模，必须在类定义之外，在`static`数据成员指定之后，添加一个外部变量定义。此类成员的存储是通过包含其底层实现的那个外部变量获得的。
- en: '`static` data members within a class or structure. A `static` member function
    does not receive a `this` pointer, hence it may only manipulate `static` data
    members and other external (global) variables.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类或结构中的`static`数据成员。一个`static`成员函数不接收`this`指针，因此它只能操作`static`数据成员和其他外部（全局）变量。
- en: To indicate a `static` member function, the keyword `static` must be specified
    in front of the function’s return type in the member function prototype only.
    The keyword `static` must not appear in the member function definition. If the
    keyword `static` appears in the function definition, the function will additionally
    be `static` in the C programming sense; that is, the function will be limited
    in scope to the file in which it is defined.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个`static`成员函数，必须在成员函数原型中函数返回类型之前指定关键字`static`。关键字`static`不得出现在成员函数定义中。如果函数定义中出现了关键字`static`，则该函数在C语言编程中也将是`static`的；也就是说，该函数的作用域将限制在定义它的文件中。
- en: 'Let’s take a look at an example of `static` data member and member function
    usage. The following example will be broken into segments, however, it will appear
    without any functions omitted or abbreviated, as it is the final example in this
    chapter. It can also be found in full in the GitHub repository:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`static`数据成员和成员函数使用的一个示例。下面的示例将被分成几个部分，但是它将完整地展示，没有任何函数被省略或缩写，因为它是本章的最后一个示例。它也可以在GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp)'
- en: '[PRE40]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the first segment of code comprising our full example, we have our `Student`
    class definition. In the `private` access region, we have added a data member,
    `static int numStudents;`, to model the object-oriented concept of a class attribute,
    a data member that will be shared by all instances of this class.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含我们完整示例的第一个代码段中，我们有 `Student` 类的定义。在 `private` 访问区域，我们添加了一个数据成员，`static int
    numStudents;`，来模拟面向对象的概念，即类属性，这是一个将被此类所有实例共享的数据成员。
- en: Next, notice toward the end of this class definition that we have added a `static`
    member function, `static int GetNumberStudents();`, to provide encapsulated access
    to the `private` data member `numStudents`. Note the keyword `static` is added
    in the prototype only. If we glance outside of the class definition to find the
    member function definition of `int Student::GetNumberStudents()`, we notice that
    there is no usage of the `static` keyword within the definition of this function
    itself. The body of this member function simply returns the shared `numStudents`,
    the static data member.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意在这个类定义的末尾，我们添加了一个 `static` 成员函数，`static int GetNumberStudents();`，以提供对
    `private` 数据成员 `numStudents` 的封装访问。注意，仅在原型中添加了 `static` 关键字。如果我们查看类定义之外的成员函数定义
    `int Student::GetNumberStudents()`，我们会注意到在函数本身的定义中没有使用 `static` 关键字。这个成员函数的主体只是简单地返回共享的
    `numStudents`，即静态数据成员。
- en: 'Also notice that just below the class definition is the external variable definition
    to support the implementation of the static data member: `int Student::numStudents
    = 0;`. Notice with this declaration the use of `::` (the scope resolution operator)
    to associate the class name to the identifier `numStudents`. Though this data
    member is implemented as an external variable, and because the data member is
    labeled as `private`, it may only be accessed by member functions within the `Student`
    class. The implementation of a `static` data member as an external variable helps
    us understand where the memory for this shared data comes from; it is not part
    of any instance of the class but stored as a separate entity in the global namespace.
    Also notice that the declaration `int Student::numStudents = 0;` initializes this
    shared variable to a value of zero.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在类定义下方是外部变量定义，用于支持静态数据成员的实现：`int Student::numStudents = 0;`。注意，在这个声明中使用
    `::`（作用域解析运算符）将类名与标识符 `numStudents` 相关联。尽管这个数据成员作为外部变量实现，并且因为数据成员被标记为 `private`，它只能由
    `Student` 类内的成员函数访问。将 `static` 数据成员作为外部变量实现有助于我们了解这个共享数据的内存来源；它不是任何类实例的一部分，而是作为全局命名空间中的独立实体存储。还要注意，声明
    `int Student::numStudents = 0;` 将这个共享变量初始化为零。
- en: As an interesting aside, notice that the data member `studentId` has been changed
    from a `const int` to `const char *studentId;` in this new version of our `Student`
    class. Keep in mind that this means `studentId` is a pointer to a constant string,
    not a constant pointer. Because the memory for the pointer itself is not `const`,
    this data member will not need to be initialized using the member initialization
    list, but it will require some special handling.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作为有趣的补充，注意在这个 `Student` 类的新版本中，数据成员 `studentId` 已经从 `const int` 改为 `const char
    *studentId;`。记住，这意味着 `studentId` 是一个指向常量字符串的指针，而不是一个常量指针。因为指针本身的内存不是 `const`，所以这个数据成员不需要使用成员初始化列表进行初始化，但它需要一些特殊处理。
- en: 'Let’s continue onward to review additional member functions comprising this
    class:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，回顾这个类包含的其他成员函数：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the previous program segment of member functions, most member functions look
    as we’ve grown accustomed to seeing, but there are some subtle differences.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的成员函数程序段中，大多数成员函数看起来与我们习惯看到的样子相似，但也有一些细微的差别。
- en: One difference, which relates to our `static` data member, is that `numStudents`
    is incremented in each of the constructors and decremented in the destructor.
    Since this `static` data member is shared by all instances of `class Student`,
    each time a new `Student` is instantiated, the counter will increase, and when
    an instance of a `Student` ceases to exist and its destructor is implicitly called,
    the counter will be decremented to reflect the removal of such an instance. In
    this way, `numStudents` will accurately reflect how many `Student` instances exist
    in our application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与我们的`static`数据成员相关的差异是，`numStudents`在每个构造函数中被增加，在析构函数中被减少。由于这个`static`数据成员被`class
    Student`的所有实例共享，每次创建一个新的`Student`实例时，计数器将增加，当一个`Student`实例不再存在并且其析构函数被隐式调用时，计数器将减少以反映这样一个实例的移除。这样，`numStudents`将准确地反映在我们的应用程序中存在多少个`Student`实例。
- en: This section of code has a few other interesting details to notice, unrelated
    to `static` data members and member functions. For example, in our class definition,
    we changed `studentId` from a `const int` to a `const char *`. This means that
    the data pointed to is constant, not the pointer itself, so we are not required
    to use the member initialization list to initialize this data member.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还有其他一些有趣的细节需要注意，与`static`数据成员和成员函数无关。例如，在我们的类定义中，我们将`studentId`从`const int`更改为`const
    char *`。这意味着所指向的数据是常量，而不是指针本身，因此我们不需要使用成员初始化列表来初始化这个数据成员。
- en: Nonetheless, in the default constructor, we choose to use the member initialization
    list to initialize `studentId` to a null pointer, `nullptr`. Recall that we may
    use the member initialization list for any data member, but we must use them to
    initialize `const` data members. That is, if the `const` part equates to memory
    that is allocated with an instance. Since the memory allocated within the instance
    for data member `studentId` is a pointer and the pointer part of this data member
    is not `const` (just the data pointed to), we do not need to use the member initialization
    list for this data member. We just choose to.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在默认构造函数中，我们选择使用成员初始化列表将`studentId`初始化为一个空指针，`nullptr`。回想一下，我们可以为任何数据成员使用成员初始化列表，但我们必须使用它们来初始化`const`数据成员。也就是说，如果`const`部分等于使用实例分配的内存。由于实例内部为数据成员`studentId`分配的内存是一个指针，而这个数据成员的指针部分不是`const`（只是所指向的数据），因此我们不需要为这个数据成员使用成员初始化列表。我们只是选择这样做。
- en: However, because `studentId` is a `const char *`, this means that the identifier
    `studentId` may not serve as an l-value, or be on the left-hand side of an assignment.
    In the alternate and copy constructors, we wish to initialize `studentId` and
    need the ability to use `studentId` as an l-value. But we cannot. We circumvent
    this dilemma by instead declaring a helper variable, `char *temp;`, and allocating
    it to contain the amount of memory we need to load the desired data. Then, we
    load the desired data into `temp`, and finally, we have `studentId` point to `temp`
    to establish a value for `studentId`. When we leave each constructor, the local
    pointer `temp` is popped off the stack; however, the memory is now captured by
    `studentId` and treated as `const`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为`studentId`是一个`const char *`，这意味着标识符`studentId`不能作为左值，或者不能在赋值表达式的左侧。在替代构造函数和复制构造函数中，我们希望初始化`studentId`并需要能够将`studentId`用作左值。但我们不能。我们通过声明一个辅助变量`char
    *temp;`并分配它以包含我们需要的内存量来规避这个困境。然后，我们将所需数据加载到`temp`中，最后，我们将`studentId`指向`temp`以为`studentId`建立一个值。当我们离开每个构造函数时，局部指针`temp`将从栈上弹出；然而，现在内存被`studentId`捕获并被视为`const`。
- en: Lastly, in the destructor, we delete the memory associated with `const char
    *studentid`, using `delete [] studentId;`. It is interesting to note that in less-recent
    compilers, we instead needed to typecast `studentId` to a non-constant `char *`;
    that is, `delete const_cast<char *> (studentId);`, as operator `delete()` previously
    did not expect a constant qualified pointer.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在析构函数中，我们使用`delete [] studentId;`删除与`const char *studentid`关联的内存。值得注意的是，在较旧的编译器中，我们反而需要将`studentId`强制类型转换为非常量`char
    *`；即`delete const_cast<char *>(studentId);`，因为操作符`delete()`之前并不期望一个常量限定指针。
- en: 'Now that we have completed reviewing new details in the member functions, let
    us continue by examining the final portion of this program example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对成员函数中新细节的审查，让我们继续检查这个程序示例的最后部分：
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `main()` function of our program, we start by instantiating two `Students`,
    `s1` and `s2`. As each instance is initialized with a constructor, the shared
    data member value of `numStudents` is incremented to reflect the number of students
    in our application. Note that the external variable `Student::numStudents`, which
    holds the memory for this shared data member, was initialized to `0` when the
    program started with the statement earlier in our code: `int Student::numStudents
    = 0;`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们程序的 `main()` 函数中，我们首先创建了两个 `Students` 实例，`s1` 和 `s2`。随着每个实例通过构造函数进行初始化，共享数据成员
    `numStudents` 的值增加，以反映我们应用程序中的学生数量。注意，外部变量 `Student::numStudents`，它为这个共享数据成员保留内存，在程序开始时通过我们代码中的以下语句初始化为
    `0`：`int Student::numStudents = 0;`。
- en: After we print out some details for each `Student`, we then print out the `static`
    data member `numStudents` using a `static` access function `Student::GetNumStudents()`.
    The preferred way to call this function is `Student::GetNumStudents();`. Because
    `numStudents` is `private`, only a method of the `Student` class may access this
    data member. We have now provided safe, encapsulated access to a `static` data
    member using a `static` member function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印出每个 `Student` 的详细信息之后，我们然后使用 `static` 访问函数 `Student::GetNumStudents()` 打印出
    `static` 数据成员 `numStudents`。调用此函数的首选方法是 `Student::GetNumStudents();`。因为 `numStudents`
    是 `private` 的，只有 `Student` 类的方法可以访问这个数据成员。我们现在已经通过 `static` 成员函数提供了对 `static`
    数据成员的安全、封装的访问。
- en: It is interesting to remember that `static` member functions do not receive
    a `this` pointer, therefore, the only data they may manipulate will be `static`
    data in the class (or other external variables). Likewise, the only other functions
    they may call will be other `static` member functions in the same class or external
    non-member functions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要记住，`static` 成员函数不会接收到 `this` 指针，因此，它们可能操作的唯一数据将是类中的 `static` 数据（或其他外部变量）。同样，它们可能调用的唯一其他函数将是同一类中的其他
    `static` 成员函数或外部非成员函数。
- en: It is also interesting to note that we can seemingly call `Student::GetNumStudents()`
    via any instance, such as `s1.GetNumStudents();`, as we see in the commented-out
    section of code. Though it seems as though we are calling the member function
    through an instance, the function will not receive a `this` pointer. Instead,
    the compiler reinterprets the call, which is seemingly through an instance, and
    replaces the invocation with a call to the internal, *name mangled* function.
    It is clearer from a programming point of view to call `static` member functions
    using the first calling method, and not seemingly through an instance that would
    never be passed along to the function itself.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有趣的是，我们似乎可以通过任何实例调用 `Student::GetNumStudents()`，例如 `s1.GetNumStudents();`，正如我们在注释掉的代码部分所看到的。尽管看起来我们是通过实例调用成员函数，但函数不会接收到
    `this` 指针。相反，编译器重新解释了调用，看起来是通过实例，并将其替换为对内部、*名称混淆*函数的调用。从编程的角度来看，使用第一种调用方法调用 `static`
    成员函数更清晰，而不是看似通过一个永远不会传递给函数本身的实例。
- en: 'Finally, here is the output for our full program example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的完整程序示例的输出：
- en: '[PRE43]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we have reviewed our final example of this chapter, it is time to recap
    everything that we have learned.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了本章的最终示例，是时候回顾我们所学的一切了。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have begun our journey with object-oriented programming.
    We have learned many object-oriented concepts and terms, and have seen how C++
    has direct language support to implement these concepts. We have seen how C++
    classes support encapsulation and information hiding, and how implementing designs
    supporting these ideals can lead to code that is easier to modify and maintain.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了面向对象编程的旅程。我们学习了大量的面向对象的概念和术语，并看到了 C++ 如何直接提供语言支持来实现这些概念。我们看到了 C++
    类如何支持封装和信息隐藏，以及实现支持这些理念的设计如何导致代码更容易修改和维护。
- en: We have detailed class basics, including member functions. We’ve moved deeper
    into member functions by examining member function internals, including understanding
    what the `this` pointer is and how it works – including the underlying implementation
    of member functions that implicitly receive a `this` pointer.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细介绍了类的基本知识，包括成员函数。我们通过检查成员函数的内部，包括理解 `this` 指针是什么以及它是如何工作的——包括隐式接收 `this`
    指针的成员函数的底层实现——来深入了解了成员函数。
- en: We have explored access labels and access regions. By grouping our data members
    in the `private` access region and providing a suite of `public` member functions
    to manipulate these data members, we have found that we can provide a safe, well-controlled,
    and well-tested means to manipulate data from the confines of each class. We have
    seen that making changes to a class can be limited to the member functions themselves.
    The user of the class need not know the underlying representation of data members
    – these details are hidden and can be changed as needed without causing a wave
    of changes elsewhere in an application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了访问标签和访问区域。通过将我们的数据成员分组在`private`访问区域，并提供一系列`public`成员函数来操作这些数据成员，我们发现我们可以提供一种安全、受控和经过良好测试的方法来从每个类的限制中操作数据。我们看到，对类的更改可以限制在成员函数本身。类的用户不需要知道数据成员的底层表示——这些细节是隐藏的，可以根据需要更改而不会在应用程序的其他地方引起连锁反应。
- en: We have deeply explored the many facets of constructors, by examining default,
    typical (overloaded) constructors, copy constructors, and even conversion constructors.
    We have been introduced to the destructor, and understand its proper usage.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查默认构造函数、典型（重载）构造函数、复制构造函数甚至转换构造函数，深入研究了构造函数的许多方面。我们已经介绍了析构函数，并理解了它的正确用法。
- en: We’ve added additional flavor to our classes by using various qualifiers to
    both data members and member functions, such as `inline` for efficiency, `const`
    to safeguard data and to ensure functions will as well, `static` data members
    to model the OO concept of class attributes, and `static` methods to provide safe
    interfaces to these `static` data members.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用各种限定符对数据成员和成员函数进行操作，为我们的类增加了额外的风味，例如使用`inline`以提高效率，使用`const`来保护数据并确保函数也会这样做，使用`static`数据成员来模拟面向对象的类属性概念，以及使用`static`方法来提供对这些`static`数据成员的安全接口。
- en: By immersing ourselves in object-oriented programming, we have gained a comprehensive
    set of skills relating to classes in C++. With a well-rounded set of skills and
    experience using classes under our respective belts and an appreciation for object-oriented
    programming, we can now move forward with [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Single Inheritance*, to learn how to grow a hierarchy
    of related classes. Let’s move forward!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过沉浸在面向对象编程中，我们已经获得了一套关于C++中类的全面技能。凭借一套全面的技能和经验，以及对我们各自使用的类和面向对象编程的欣赏，我们现在可以继续前进到[*第6章*](B19087_06.xhtml#_idTextAnchor314)，*使用单一继承实现层次结构*，学习如何扩展相关类的层次结构。让我们继续前进！
- en: Questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Create a C++ program to encapsulate a `Student`. You may use portions of your
    previous exercises. Try to do this yourself, rather than relying on any online
    code. You will need this class as a basis to move forward with future examples;
    now is a good time to try each feature on your own. Incorporate the following
    steps:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C++程序来封装一个`Student`。你可以使用你之前的练习的部分内容。尽量自己完成，而不是依赖任何在线代码。你需要这个类作为前进的基础，以学习未来的示例；现在是尝试每个功能的好时机。包括以下步骤：
- en: Create, or modify your previous `Student` class to fully encapsulate a student.
    Be sure to include several data members that be dynamically allocated. Provide
    several overloaded constructors to provide the means to initialize your class.
    Be sure to include a copy constructor. Also, include a destructor to release any
    dynamically allocated data members.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或修改你之前的`Student`类，以完全封装一个学生。确保包括几个可以动态分配的数据成员。提供几个重载构造函数，以提供初始化你的类的方法。确保包括一个复制构造函数。此外，包括一个析构函数来释放任何动态分配的数据成员。
- en: Add an assortment of access functions to your class to provide safe access to
    data members within your class. Decide for which data members you will offer a
    `GetDataMember()` interface, and whether any of these data members should have
    the ability to be reset after construction with a `SetDataMember()` interface.
    Apply the `const` and `inline` qualifiers to these methods as appropriate.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的类添加一系列访问函数，以提供对类内数据成员的安全访问。决定你将为哪些数据成员提供`GetDataMember()`接口，以及是否任何这些数据成员应该具有使用`SetDataMember()`接口在构造后重置的能力。根据适当的情况，将这些方法的`const`和`inline`限定符应用于这些方法。
- en: Be sure to utilize appropriate access regions – `private` for data members,
    and possibly for some helper member functions to break up a larger task. Add `public`
    member functions as necessary above and beyond your previous access functions.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用适当的访问区域 - 对于数据成员使用`private`，对于一些辅助成员函数可能也需要使用`private`以分解更大的任务。根据需要添加`public`成员函数，超出之前的访问函数。
- en: Include at least one `const` data member in your class and utilize the member
    initialization list to set this member. Add at least one `static` data member
    and one `static` member function.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的类中包含至少一个`const`数据成员，并使用成员初始化列表来设置此成员。添加至少一个`static`数据成员和一个`static`成员函数。
- en: Instantiate a `Student` using each constructor signature, including the copy
    constructor. Make several instances dynamically allocated using `new()`. Be sure
    to `delete()` each of these instances when you are done with them (so that their
    destructor will be called).
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每个构造函数签名实例化一个`Student`，包括拷贝构造函数。使用`new()`动态分配几个实例。确保在完成这些实例后删除它们（以便调用它们的析构函数）。
