- en: The FreeRTOS Scheduler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeRTOS 调度器
- en: The FreeRTOS scheduler takes care of all task switching decisions. The most
    basic things you can do with an RTOS include creating a few tasks and then starting
    the scheduler – which is exactly what we'll be doing in this chapter. Creating
    tasks and getting the scheduler up and running will become something you'll be
    well accustomed to after some practice. Even though this is straightforward, it
    doesn't always go smoothly (especially on your first couple of tries), so we'll
    also be covering some common problems and how to fix them. By the end, you'll
    be able to set up your own RTOS application from scratch and know how to troubleshoot
    common problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 调度器负责处理所有任务切换决策。您可以使用 RTOS 做的最基本的事情包括创建几个任务然后启动调度器——这正是本章我们将要做的。经过一些练习后，创建任务和启动调度器将变得您非常熟悉的事情。尽管这很简单，但并不总是顺利进行（尤其是在您的前几次尝试中），因此我们还将介绍一些常见问题和解决方法。到那时，您将能够从头开始设置自己的
    RTOS 应用程序，并了解如何排除常见问题。
- en: We'll start by covering two different ways of creating FreeRTOS tasks and the
    advantages each offer. From there, we'll cover how to start the scheduler and
    what to look for to make sure it is running. Next, we'll briefly touch on memory
    management options. After that, we'll take a closer look at task states and cover
    some tips on optimizing your application so that it uses task states effectively.
    Finally, some troubleshooting tips will be offered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍创建 FreeRTOS 任务的两种不同方法以及每种方法的优势。然后，我们将介绍如何启动调度器以及确保其运行时需要注意的事项。接下来，我们将简要介绍内存管理选项。之后，我们将更详细地探讨任务状态，并介绍一些优化应用程序以有效使用任务状态的技巧。最后，将提供一些故障排除技巧。
- en: 'Here''s what we''ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Creating tasks and starting the scheduler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务并启动调度器
- en: Deleting tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除任务
- en: Trying out the code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试运行代码
- en: Task memory allocation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务内存分配
- en: Understanding FreeRTOS task states
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 FreeRTOS 任务状态
- en: Troubleshooting startup problems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决启动问题
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To carry out the exercises in this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行本章的练习，您需要以下内容：
- en: Nucleo F767 development board
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767 开发板
- en: Micro USB cable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB 线
- en: STM32CubeIDE and its source code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE 及其源代码
- en: SEGGER JLink, Ozone, and SystemView installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone 和 SystemView 已安装
- en: For the installation instructions for STM32CubeIDE and its source code, please
    refer to [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml), *Selecting an
    IDE*. For SEGGER JLink, Ozone, and SystemView, please refer to [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),* Debugging
    Tools for Real-Time Systems.*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 STM32CubeIDE 及其源代码的安装说明，请参阅 [第 5 章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择
    IDE*。对于 SEGGER JLink、Ozone 和 SystemView，请参阅 [第 6 章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*。
- en: You can find the code files for this chapter here: [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_7](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_7).
    For individual files, whose code snippets can be found throughout the text, please
    go to the `src` folder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码文件：[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_7](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_7)。对于文本中可找到的代码片段的单独文件，请访问
    `src` 文件夹。
- en: You can build live projects that can be run with the STM32F767 Nucleo by downloading
    the entire tree and importing `Chapter_7` as an Eclipse project. To do this, go
    to [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过下载整个树并将其导入 Eclipse 项目来构建可以与 STM32F767 Nucleo 一起运行的实时项目。为此，请访问 [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers)。
- en: Creating tasks and starting the scheduler
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务并启动调度器
- en: 'In order to get an RTOS application up and running, a few things need to happen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 RTOS 应用程序运行起来，需要发生几件事情：
- en: The MCU hardware needs to be initialized.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MCU 硬件需要初始化。
- en: Task functions need to be defined.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要定义任务函数。
- en: RTOS tasks need to be created and mapped to the functions that were defined
    in *step 2*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要创建 RTOS 任务并将它们映射到在 *步骤 2* 中定义的函数。
- en: The RTOS scheduler must be started.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTOS 调度器必须启动。
- en: It is possible to create additional tasks after starting the scheduler. If you
    are unsure of what a task is, or why you would want to use one, please review
    [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml), *Understanding RTOS Tasks.*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动调度器之后，可以创建额外的任务。如果你不确定任务是什么，或者为什么你想使用它，请查阅 [第 2 章](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml)，*理解
    RTOS 任务*。
- en: Let's break down each of these steps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些步骤。
- en: Hardware initialization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件初始化
- en: 'Before we can do anything with the RTOS, we need to make sure that our hardware
    is configured properly. This will typically include carrying out activities such
    as ensuring GPIO lines are in their proper states, configuring external RAM, configuring
    critical peripherals and external circuitry, performing built-in tests, and so
    on. In all of our examples, MCU hardware initialization can be performed by calling
    `HWInit()`, which performs all of the basic hardware initialization required:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对 RTOS 做任何事情之前，我们需要确保我们的硬件配置正确。这通常包括确保 GPIO 线处于正确的状态、配置外部 RAM、配置关键外设和外部电路、执行内置测试等活动。在我们的所有示例中，可以通过调用
    `HWInit()` 来执行 MCU 硬件初始化，它执行所有基本硬件初始化所需的操作：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we'll be developing an application that blinks a few LED lights.
    Let's define the behavior we'll be programming and take a look at what our individual
    task functions look like.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个闪烁几个 LED 灯的应用程序。让我们定义我们将要编程的行为，并查看我们的各个任务函数的样子。
- en: Defining task functions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义任务函数
- en: Each of the tasks, that is, `RedTask`, `BlueTask`, and `GreenTask`, has a function
    associated with it. Remember – a task is really just an infinite `while` loop
    with its own stack and a priority. Let's cover them one by one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务，即 `RedTask`、`BlueTask` 和 `GreenTask`，都与一个函数相关联。记住——任务实际上只是一个具有自己的堆栈和优先级的无限循环
    `while`。让我们逐一介绍它们。
- en: '`GreenTask` sleeps for a little while (1.5 seconds) with the Green LED on and
    then deletes itself. There are a few noteworthy items here, some of which are
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreenTask` 在绿色 LED 亮起的情况下睡眠一段时间（1.5 秒），然后删除自己。这里有几个值得注意的事项，其中一些如下：'
- en: Normally, a task will contain an infinite `while` loop so that it doesn't return. `GreenTask` still
    doesn't return since it deletes itself.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，一个任务将包含一个无限循环 `while`，这样它就不会返回。`GreenTask` 仍然不返回，因为它会删除自己。
- en: 'You can easily confirm `vTaskDelete` doesn''t allow execution past the function
    call by looking at the Nucleo board. The green light will only be on for 1.5 seconds
    before shutting off permanently. Take a look at the following example, which is
    an excerpt from `main_taskCreation.c`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过查看 Nucleo 板来轻松确认 `vTaskDelete` 不允许在函数调用之后执行。绿灯只会亮起 1.5 秒，然后永久关闭。请看以下示例，这是
    `main_taskCreation.c` 的摘录：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The full source file for `main_taskCreation.c` is available at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_taskCreation.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_taskCreation.c).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`main_taskCreation.c` 的完整源代码可在 [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_taskCreation.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_taskCreation.c)
    获取。'
- en: '`BlueTask` blinks the blue LED rapidly for an indefinite period of time, thanks
    to the infinite `while` loop. However, the blue LED blinks are cut short because `RedTask` will
    delete `BlueTask` after 1 second. This can be seen in the following example, which
    is an excerpt from `Chapter_7/Src/main_taskCreation.c`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueTask` 由于无限循环 `while`，会无限期地快速闪烁蓝色 LED。然而，由于 `RedTask` 在 1 秒后删除 `BlueTask`，蓝色
    LED 的闪烁会被截断。这可以在以下示例中看到，这是 `Chapter_7/Src/main_taskCreation.c` 的摘录：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`RedTask` deletes `BlueTask` on its first run and then continues to blink the
    red LED indefinitely. This can be seen in the following excerpt from `Chapter_7/Src/main_taskCreation.c`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedTask` 在第一次运行时删除 `BlueTask`，然后无限期地闪烁红色 LED。这可以在以下 `Chapter_7/Src/main_taskCreation.c`
    的摘录中看到：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the preceding functions don't look like anything special – and they're not.
    They are simply standard C functions, two of which have infinite `while` loops
    in them. How do we go about creating FreeRTOS tasks out of these plain old functions?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的函数看起来并不特别——它们确实不特别。它们只是标准的 C 函数，其中有两个包含无限循环 `while`。我们如何将这些普通的旧函数转换为 FreeRTOS
    任务呢？
- en: Creating tasks
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'Here''s what the prototype for FreeRTOS task creation looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 FreeRTOS 任务创建的原型：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our example, the call to the preceding prototype looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，对前面的原型的调用如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function call might be a little longer than expected – let''s break it
    down:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用可能比预期的要长一些——让我们将其分解：
- en: '`Task1`: The name of the function that implements the infinite `while` loop
    that makes up the task.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task1`：实现组成任务的无限`while`循环的函数名称。'
- en: '`"task1"`: This is a human-friendly name used to reference the task during
    debugging (this is the string that shows up in tools such as Ozone and SystemView).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"task1"`：这是一个用于在调试期间引用任务的友好名称（这是在Ozone和SystemView等工具中显示的字符串）。'
- en: '`StackSizeWords`: The number of *words* reserved for the task''s stack.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackSizeWords`：为任务栈保留的*字*数。'
- en: '`NULL`: A pointer that can be passed to the underlying function. Make sure
    the pointer is still valid when the task finally runs after starting the scheduler.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NULL`：可以传递给底层函数的指针。确保在调度器启动后任务最终运行时，指针仍然有效。'
- en: '`tskIDLE_PRIORITY + 2 `: This is the priority of the task being created. This
    particular call is setting the priority to two levels higher than the priority
    of the IDLE task (which runs when no other tasks are running).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tskIDLE_PRIORITY + 2`：这是正在创建的任务的优先级。这个特定的调用将优先级设置为比IDLE任务的优先级高两级（当没有其他任务运行时运行的任务）。'
- en: '`TaskHandlePtr`: This is a pointer to a `TaskHandle_t` data type (this is a
    *handle* that can be passed to other tasks to programmatically reference the task).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskHandlePtr`：这是一个指向`TaskHandle_t`数据类型的指针（这是一个可以传递给其他任务的*句柄*，以便程序化地引用任务）。'
- en: '**Return value**: The `x` prefix of `**x**TaskCreation` signifies that it returns
    something. In this case, either `pdPASS` or `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY `
    is returned, depending on whether or not heap space was successfully allocated. **You
    must check this return value!**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：`**x**TaskCreation`的`x`前缀表示它返回某些内容。在这种情况下，根据堆空间是否成功分配，返回`pdPASS`或`errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY`。**你必须检查这个返回值**！'
- en: At least one task needs to be created before starting the scheduler. Because the
    call to start the scheduler doesn't return, it won't be possible to start a task
    from `main` after making a call to start the scheduler. Once the scheduler is
    started, tasks can create new tasks as necessary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动调度器之前，至少需要创建一个任务。因为启动调度器的调用不会返回，所以在调用启动调度器之后，将无法从`main`中启动任务。一旦调度器启动，任务就可以根据需要创建新的任务。
- en: Now that we've got a good idea of what the input parameters for creating a task
    are, let's take a look at why it's so important to check the return value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对创建任务所需的输入参数有了很好的了解，让我们来看看为什么检查返回值是如此重要。
- en: Checking the return value
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查返回值
- en: 'When creating a few tasks in `main` before starting the scheduler, it''s necessary
    to check the return values as each task is created. Of course, there are many
    ways to accomplish this. Let''s take a look at two of them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中创建一些任务并在启动调度器之前，检查每个任务创建时的返回值是必要的。当然，有许多方法可以实现这一点。让我们看看其中的两种：
- en: 'The first is by wrapping the call in an `if` statement with an inlined infinite
    `while` loop:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是使用包含内联无限`while`循环的`if`语句包裹调用：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second is by using ASSERT rather than the infinite `while` loop. If your
    project has ASSERT support, then it would be better to use ASSERT, rather than
    the infinite `while` loop. Since our project already has HAL included, we can
    make use of the `assert_param` macro:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是使用ASSERT而不是无限`while`循环。如果你的项目有ASSERT支持，那么使用ASSERT会比使用无限`while`循环更好。由于我们的项目已经包含了HAL，我们可以使用`assert_param`宏：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`assert_param` is an STM supplied macro that checks whether a condition is
    true. If the condition evaluates as false, then `assert_failed` is called. In
    our implementation, `assert_failed` prints out the failing function name and line
    and enters an infinite `while` loop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_param`是一个STM提供的宏，用于检查条件是否为真。如果条件评估为假，则调用`assert_failed`。在我们的实现中，`assert_failed`会打印出失败的函数名称和行号，并进入一个无限`while`循环：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will learn more about using assertions and how to configure them in [Chapter
    17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting Tips and Next
    Steps.*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第17章](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml)“故障排除技巧和下一步”中了解更多关于使用断言以及如何配置它们的信息。
- en: Now that we have created some tasks, let's get the scheduler started and the
    code running on our hardware, and watch some lights blink!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些任务，让我们启动调度器，让我们的硬件上的代码运行，并观察一些灯光闪烁！
- en: Starting the scheduler
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动调度器
- en: 'With all of the options we have for creating tasks, you might be thinking that
    starting the scheduler would be a complex affair. You''ll be pleasantly surprised
    at how easy it is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有这么多创建任务选项的情况下，你可能认为启动调度器会是一件复杂的事情。但你会发现它非常简单：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Yep, just one line of code and no input parameters!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，只需一行代码，没有输入参数！
- en: The `v` in front of the function name indicates it returns void. In reality,
    this function never returns – unless there is a problem. It is the point where
    `vTaskStartScheduler()` is called that the program transitions from a traditional
    single super loop to a multi-tasking RTOS.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名前的`v`表示它返回void。实际上，这个函数永远不会返回——除非有问题。这是`vTaskStartScheduler()`被调用的时候，程序从传统的单超级循环过渡到多任务实时操作系统（RTOS）。
- en: After the scheduler is started, we'll need to think about and understand the
    different states the tasks are in so we can debug and tune our system properly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动调度器后，我们需要考虑和理解任务的不同状态，以便我们可以正确地调试和调整我们的系统。
- en: 'For reference, here''s the entirety of `main()` we''ve just built up through
    the various examples. This excerpt has been taken from `main_taskCreation.c`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们通过各种示例构建的`main()`函数的全部内容。此摘录来自`main_taskCreation.c`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we've learned how to create tasks and get the scheduler up and running,
    the last detail to cover in this example is how to go about deleting a task.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建任务并启动调度器，在这个例子中需要覆盖的最后细节是如何删除任务。
- en: Deleting tasks
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除任务
- en: In some cases, it may be advantageous to have a task run and, eventually, after
    it has accomplished everything it needs to, remove it from the system. For example,
    in some systems with fairly involved startup routines, it might be advantageous
    to run some of the late initialization code inside a task. In this case, the initialization
    code would run, but there is no need for an infinite loop. If the task is kept
    around, it will still have its stack and TCB wasting FreeRTOS heap space. Deleting
    the task will free the task's stack and TCB, making the RAM available for reuse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，让一个任务运行，并在它完成所有需要做的事情后从系统中移除，可能是有利的。例如，在一些具有相当复杂的启动例程的系统中，可能有利于在任务内部运行一些后期初始化代码。在这种情况下，初始化代码会运行，但不需要无限循环。如果任务被保留，它仍然会有其栈和TCB，浪费FreeRTOS堆空间。删除任务将释放任务的栈和TCB，使RAM可用于重用。
- en: All of the critical initialization code should be run long before the scheduler
    starts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关键的初始化代码都应该在调度器启动之前运行。
- en: The task deletes itself
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务会自行删除
- en: 'The simplest way to delete a task after it has finished doing useful work is
    to call `vTaskDelete()` with a `NULL` argument from within the task, as shown
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务完成有用工作后删除任务的最简单方法是，在任务内部调用`vTaskDelete()`并传递一个`NULL`参数，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will immediately terminate the task code. The memory on the FreeRTOS heap
    associated with the TCB and task stack will be freed when the IDLE task runs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即终止任务代码。当IDLE任务运行时，与TCB和任务栈关联的FreeRTOS堆上的内存将被释放。
- en: In this example, the green LED will turn on for 1.5 seconds and then shut off.
    As noted in the code, the instructions after `vTaskDelete()` will never be reached.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，绿色LED将开启1.5秒然后关闭。如代码中所述，`vTaskDelete()`之后的指令永远不会被执行。
- en: Deleting a task from another task
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个任务中删除任务
- en: 'In order to delete a task from another task, `blueTaskHandle` needs to be passed
    to `xTaskCreate` and its value populated. `blueTaskHandle` can then be used by
    other tasks to delete `BlueTask,` as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从另一个任务中删除任务，需要将`blueTaskHandle`传递给`xTaskCreate`并填充其值。然后，`blueTaskHandle`可以被其他任务用来删除`BlueTask`，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The actual code in `main.c` results in the blue LED blinking for ~ 1 second
    before being deleted by `RedTask`. At this point, the blue LED stops blinking
    (since the task turning the LED on/off isn't running anymore).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.c`中的实际代码会导致蓝色LED闪烁约1秒，然后被`RedTask`删除。此时，蓝色LED停止闪烁（因为控制LED开关的任务不再运行）。
- en: 'There are a few things to keep in mind before deciding that deleting tasks
    is desirable:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定删除任务之前，有一些事情需要记住：
- en: The heap implementation used must support freeing memory (refer to [Chapter
    15,](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)* FreeRTOS Memory Management*,
    for details).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的堆实现必须支持释放内存（有关详细信息，请参阅[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS内存管理*）。
- en: Like any embedded heap implementation, it is possible for a heavily used heap
    to become fragmented if different sized elements are constantly being added and
    removed.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何嵌入式堆实现，如果不断添加和删除不同大小的元素，高度使用的堆可能会变得碎片化。
- en: '`#define configTaskDelete` must be set to `true` in `FreeRTOSConfig.h`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define configTaskDelete` 必须在 `FreeRTOSConfig.h` 中设置为 `true`。'
- en: That's it! We now have a FreeRTOS application. Let's get everything compiled
    and program the image onto the Nucleo board.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有一个 FreeRTOS 应用程序。让我们编译一切并将程序映像编程到 Nucleo 板上。
- en: Trying out the code
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试运行代码
- en: Now that you've learned how to set up a few tasks, let's go through how to get
    it running on our hardware. Running the examples, experimenting with breakpoints
    to observe execution, and sifting through traces in SystemView will greatly enhance
    your intuition of how an RTOS behaves.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何设置几个任务，让我们来看看如何在我们的硬件上运行它们。运行示例，使用断点观察执行，并在 SystemView 中筛选跟踪将大大增强你对实时操作系统行为的直觉。
- en: 'Let''s experiment with the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实验一下前面的代码：
- en: 'Open the `Chapter_7 STM32CubeIDE` project and set `TaskCreationBuild` as the
    active build:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter_7 STM32CubeIDE` 项目并将 `TaskCreationBuild` 设置为活动构建：
- en: '![](img/6c62a307-c9bf-4c88-bcd8-aac7862704c5.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c62a307-c9bf-4c88-bcd8-aac7862704c5.png)'
- en: Right-click on the project and select Build Configurations.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择“构建配置”。
- en: Select the desired build configuration (`TaskCreationBuild` contains `main_taskCreation.c`).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的构建配置（`TaskCreationBuild` 包含 `main_taskCreation.c`）。
- en: Select Build Project to build the active configuration.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“构建项目”以构建活动配置。
- en: 'After that, experiment with using Ozone to load and single-step through the
    program (details on how to do this were covered in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*). SystemView can also be used to watch
    the tasks run in real time. Here''s a quick example of a bird''s-eye view of what''s
    going on:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，尝试使用 Ozone 加载和单步执行程序（有关如何操作的详细信息已在 [第 6 章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*
    中介绍）。SystemView 也可以用来实时观察任务的运行。以下是一个快速查看正在发生什么的鸟瞰图示例：
- en: '![](img/f8490c6b-8777-48f7-b594-0cd1f063089d.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8490c6b-8777-48f7-b594-0cd1f063089d.png)'
- en: 'Let''s go over this step by step:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地过一遍：
- en: '`GreenTask` sleeps for 1.5 seconds, then deletes itself and never runs again
    (notice the absence of additional tick lines in the `GreenTask` row).'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenTask` 睡眠 1.5 秒，然后删除自己，以后不再运行（注意 `GreenTask` 行中没有额外的滴答线）。'
- en: '`BlueTask` executes for 1 second before being deleted by `RedTask`.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueTask` 在被 `RedTask` 删除之前执行 1 秒。'
- en: '`RedTask` continues to blink the red LED indefinitely.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RedTask` 持续闪烁红色 LED。'
- en: '`RedTask` deletes `BlueTask`. Deletions aren''t trivial – we can see from the
    callout it takes 7.4 ms to delete `BlueTask`.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RedTask` 删除 `BlueTask`。删除不是微不足道的——我们可以从注释中看到删除 `BlueTask` 需要 7.4 毫秒。'
- en: Congratulations, you've just made it through writing, compiling, loading, and
    analyzing an RTOS application! What?! You haven't gone through and actually *run*
    the application on hardware yet?! Really? If you're serious about learning, you
    should *seriously* consider getting a Nucleo board so that you can run the examples
    on actual hardware. All of the examples in this book are full-blown projects,
    ready to go!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你刚刚完成了编写、编译、加载和分析实时操作系统应用程序！什么？！你还没有在硬件上实际运行应用程序？！真的吗？如果你真的想学习，你应该认真考虑购买一块
    Nucleo 板，这样你就可以在实际硬件上运行示例。本书中的所有示例都是完整的项目，可以直接使用！
- en: One of the things we glossed over here was whyacall to `xTaskCreate()` can fail. That's
    an excellent question – let's find out!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里略过的一件事是为什么对 `xTaskCreate()` 的调用可能会失败。这是一个非常好的问题——让我们来找出答案！
- en: Task memory allocation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务内存分配
- en: One of the parameters for `xTaskCreate()` defines the task's stack size. But
    where does the RAM being used for this stack come from? There are two options –
    *dynamically allocated* memory and *statically allocated* memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`xTaskCreate()` 的一个参数定义了任务的堆栈大小。但用于此堆栈的 RAM 从哪里来？有两种选择——*动态分配*的内存和*静态分配*的内存。'
- en: Dynamic memory allocation is implemented with a heap. FreeRTOS ports contain
    several different options regarding how heaps are implemented. [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml),
    *FreeRTOS Memory Management*, provides details on how to select an appropriate
    heap implementation for a given project. For now, it is sufficient to assume a
    heap is available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配通过堆实现。FreeRTOS 端口包含有关堆如何实现的几个不同选项。[第 15 章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS
    内存管理*提供了如何为特定项目选择合适的堆实现的详细信息。目前，假设堆可用即可。
- en: Static allocation permanently reserves RAM for a variable for the life of the
    program. Let's see what each approach looks like.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配在程序生命周期内永久为变量保留 RAM。让我们看看每种方法的样子。
- en: Heap allocated tasks
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆分配的任务
- en: 'The call from the beginning of this section uses the heap to store the stack:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头的调用使用了堆来存储栈：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`xTaskCreate()` is the simpler of the two methods to call. It will use memory
    from the FreeRTOS heap for Task1''s stack and the **Task Control Block** (**TCB**).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`xTaskCreate()` 是两种调用方法中较简单的一种。它将为 Task1 的栈和 **任务控制块**（**TCB**）使用 FreeRTOS
    堆中的内存。'
- en: Statically allocated tasks
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分配的任务
- en: Tasks that are created without using the FreeRTOS heap require the programmer
    to perform allocation for the task's stack and TCB before creating the task. The
    static version of task creation is `xTaskCreateStatic()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 FreeRTOS 堆创建的任务需要程序员在创建任务之前为任务的栈和 TCB 进行分配。任务创建的静态版本是 `xTaskCreateStatic()`。
- en: 'The FreeRTOS prototype for `xTaskCreateStatic()` is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`xTaskCreateStatic()` 的 FreeRTOS 原型如下：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a look at how this is used in our example, which creates a task
    with a statically allocated stack:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的示例中如何使用它，它创建了一个具有静态分配栈的任务：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike `xTaskCreate()`, `xTaskCreateStatic()` is guaranteed to always create
    the task, provided `RedTaskStack` or `RedTaskTCB` isn't `NULL`. As long as your
    toolchain's linker can find space in RAM to store the variables, the task will
    be created successfully.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `xTaskCreate()` 不同，只要 `RedTaskStack` 或 `RedTaskTCB` 不是 `NULL`，`xTaskCreateStatic()`
    就会保证总是创建任务。只要你的工具链的链接器能在 RAM 中找到空间来存储变量，任务就会成功创建。
- en: '`configSUPPORT_STATIC_ALLOCATION` must be set to `1` in `FreeRTOSConfig.h`
    if you wish to make use of the preceding code.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用前面的代码，必须在 `FreeRTOSConfig.h` 中将 `configSUPPORT_STATIC_ALLOCATION` 设置为
    `1`。
- en: Memory protected task creation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保护任务创建
- en: Tasks can also be created in a memory protected environment, which guarantees
    a task only accesses memory specifically assigned to it. Implementations of FreeRTOS
    are available that take advantage of on-board MPU hardware.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任务也可以在内存保护环境中创建，这保证了任务只能访问为其专门分配的内存。FreeRTOS 的实现可以利用板载的 MPU 硬件。
- en: Please refer to[Chapter 4](c52d7cdb-b6cb-41e8-8d75-72494bc9d4d3.xhtml), *Selecting
    the Right MCU*, for details on MPUs. You can also find a detailed example on how
    to use the MPU in [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml), *FreeRTOS
    Memory Management.*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 4 章](c52d7cdb-b6cb-41e8-8d75-72494bc9d4d3.xhtml)，*选择合适的 MCU*，以获取有关 MPU
    的详细信息。你还可以在[第 15 章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS 内存管理*中找到如何使用
    MPU 的详细示例。
- en: Task creation roundup
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务创建总结
- en: 'Since there are a few different ways of creating tasks, you might be wondering
    which one should be used. All implementations have their strengths and weaknesses,
    and it really does depend on several factors. The following table shows a summary
    of the three ways of creating tasks, with their relative strengths represented
    by arrows – ⇑ for better, ⇓ for worse, and  ⇔ for neutral:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建任务有多种不同的方式，你可能想知道应该使用哪一种。所有实现都有其优点和缺点，并且这确实取决于几个因素。下表展示了创建任务的三种方式的总结，其相对优点通过箭头表示——⇑
    表示更好，⇓ 表示更差，⇔ 表示中性：
- en: '| **Characteristic** | **Heap** | **MPU Heap** | **Static ** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **堆** | **MPU 堆** | **静态** |'
- en: '| Ease of use | ⇑ | ⇓ | ⇔ |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 易用性 | ⇑ | ⇓ | ⇔ |'
- en: '| Flexibility | ⇑ | ⇓ | ⇔ |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性 | ⇑ | ⇓ | ⇔ |'
- en: '| Safety | ⇓ | ⇑ | ⇔ |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | ⇓ | ⇑ | ⇔ |'
- en: '| Regulatory Compliance | ⇓ | ⇑ | ⇔ |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 法规遵从性 | ⇓ | ⇑ | ⇔ |'
- en: As we can see, there is no clear-cut answer as to which system to use. However,
    if your MCU doesn't have an MPU on-board, there won't be an option to use the
    MPU variant.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有明确的答案来决定使用哪个系统。然而，如果你的微控制器（MCU）没有板载的 MPU，那么将无法选择使用 MPU 变体。
- en: The FreeRTOS heap-based approach is the easiest to code, as well as the most
    flexible of the three choices. This flexibility comes from the fact that tasks
    can be deleted, rather than simply forgotten about. Statically created tasks are
    the next easiest, with only an additional two lines required to specify the TCB
    and the task stack. They aren't as flexible since there is no way to free memory
    defined by a static variable. Static creation can also be more desirable in some
    regulatory environments that forbid the use of the heap altogether, although in
    most cases, the most FreeRTOS heap-based approach is acceptable – especially heap
    implementations 1, 2, and 3.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS基于堆的方法是三种选择中最容易编码的，也是最具灵活性的。这种灵活性来自于任务可以被删除，而不仅仅是被遗忘。静态创建的任务是下一个最容易的，只需要额外两行代码来指定TCB和任务堆栈。由于无法释放由静态变量定义的内存，因此它们不如前者灵活。在某些法规环境中，静态创建可能更受欢迎，因为这些环境完全禁止使用堆，尽管在大多数情况下，最常用的FreeRTOS基于堆的方法是可以接受的——特别是堆实现1、2和3。
- en: '*What is a heap implementation?* Don''t worry about it yet. We''ll learn about
    heap options for FreeRTOS in detail in [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml),
    *FreeRTOS Memory Management*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是堆实现？* 不要担心，我们将在第15章[FreeRTOS内存管理](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)中详细学习FreeRTOS的堆选项。'
- en: The MPU variant is the most involved of the three, but it is also the safest
    since the MPU guarantees the task isn't writing outside of its allowed memory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: MPU（内存保护单元）变体是三种中最复杂的，但也是最安全的，因为MPU保证了任务不会超出其允许的内存范围。
- en: Using statically defined stacks and TCBs has the advantage that the total program
    footprint can be analyzed by the linker. This ensures that if a program compiles
    and fits into the hardware constraints of the MCU, it won't fail to run due to
    a lack of heap space. With heap-based task creation, it is possible for a program
    to compile but have a runtime error that causes the entire application not to
    run. In other cases, the application may run for some time but then fail due to
    a lack of heap memory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态定义的堆栈和TCB（任务控制块）的优点是，链接器可以分析整个程序的内存占用。这确保了如果程序编译并适应了MCU的硬件限制，它不会因为堆空间不足而无法运行。基于堆的任务创建可能导致程序编译成功，但在运行时出现错误，导致整个应用程序无法运行。在其他情况下，应用程序可能运行一段时间后，由于堆内存不足而失败。
- en: Understanding FreeRTOS task states
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解FreeRTOS任务状态
- en: As explained in [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml), *Understanding
    RTOS Task*s, all of the context switching between tasks happens *in the background*,
    which is very convenient for the programmer responsible for implementing tasks.
    This is because it frees them from adding code into each task that attempts to
    load balance the system. While the task code isn't *explicitly* performing the
    task state transitions, it *is* interacting with the kernel. Calls to the FreeRTOS
    API cause the kernel's scheduler to run, which is responsible for transitioning
    the tasks between the necessary states.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章[理解RTOS任务](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml)中所述，所有任务之间的上下文切换都是在*后台*进行的，这对负责实现任务的开发者来说非常方便。这是因为它使他们免于在每个试图平衡系统负载的任务中添加代码。虽然任务代码并没有*明确地*执行任务状态转换，但它确实与内核交互。对FreeRTOS
    API的调用会导致内核调度器运行，负责在必要的状态之间转换任务。
- en: Understanding different task states
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同的任务状态
- en: 'Each transition shown in the following state diagram is caused by either an
    API call being made by your code or an action being taken by the scheduler. This
    is a simplified graphical overview of the possible states and transitions, along
    with a description of each:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的状态图中显示的每个转换都是由你的代码发出的API调用或调度器采取的行动引起的。这是一个简化的图形概述，包括可能的状态和转换，以及每个状态的描述：
- en: '![](img/05c6737c-baa0-4650-8e6a-6c3587bd589b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05c6737c-baa0-4650-8e6a-6c3587bd589b.png)'
- en: Let's look at them one by one.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Running
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行中
- en: A task in the running state is performing work; it is the only task that is
    in context. It will run until it either makes a call to an API that causes it
    to move to the `Blocked` state or it gets switched out of context by the scheduler
    due to a higher priority (or time-sliced task of equal priority). Examples of
    API calls that would cause a task to move from `Running` to `Blocked` include
    attempting to read from an empty queue or attempting to take a mutex that isn't
    available.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行状态的任务正在执行工作；它是唯一处于上下文中的任务。它将一直运行，直到它调用一个API导致其进入`Blocked`状态，或者由于优先级更高（或具有相同优先级的分时任务）而被调度器切换出上下文。可能导致任务从`Running`状态移动到`Blocked`状态的API调用示例包括尝试从空队列中读取或尝试获取不可用的互斥锁。
- en: Ready
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Tasks that are sitting in the ready state are simply waiting for the scheduler
    to give them processor context so they can run. For example, if *Task A* has gone
    into the `Blocked` state, waiting on an item to be added to a queue it was waiting
    on, then *Task A* will move into the `Ready` state. The scheduler will evaluate
    whether or not *Task A* is the highest priority task ready to run in the system.
    If *Task A* is the highest priority task that is ready, it will be given processor
    context and change to the `Running` state. Note that tasks can share the same
    priority. In this case, the scheduler will switch them between `Ready` and `Running`
    by using a round-robin scheduling scheme (see [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml),* Understanding
    RTOS Tasks*, for an example of this).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 处于就绪状态的任务只是在等待调度器赋予它们处理器上下文，以便它们可以运行。例如，如果*任务A*已经进入`Blocked`状态，等待它所等待的队列中添加一个项目，那么*任务A*将进入`Ready`状态。调度器将评估*任务A*是否是系统中最高的优先级且准备就绪的任务。如果*任务A*是准备就绪的最高优先级任务，它将被赋予处理器上下文并转换为`Running`状态。请注意，任务可以具有相同的优先级。在这种情况下，调度器将通过使用轮询调度方案在`Ready`和`Running`状态之间切换它们（有关此示例，请参阅[第2章](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml)，*理解RTOS任务*）。
- en: Blocked
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞
- en: 'A `Blocked` task is a task that is waiting for something. There are two ways
    for a task to move out of the `Blocked` state: either an event will trigger a
    transition from `Blocked` to `Ready` for the task, or a timeout will occur, placing
    the task in the `Ready` state.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blocked`状态的任务是正在等待某物的任务。任务从`Blocked`状态退出有两种方式：要么一个事件触发任务从`Blocked`状态到`Ready`状态的转换，要么发生超时，将任务置于`Ready`状态。'
- en: This is a very important feature of an RTOS:* each blocking call is time-bound*.
    That is, a task will only block while waiting for an event for as long as the
    programmer specifies it can be blocked. This is an important distinction between
    RTOS firmware programming and general-purpose application programming. For example,
    *an attempt to take a mutex that will fail if the mutex isn't available within
    the specified amount of time*. The same is true for API calls that accept and
    push data onto queues, as well as all the other non-interrupt API calls in FreeRTOS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RTOS的一个非常重要的特性：*每个阻塞调用都有时间限制*。也就是说，任务在等待事件时只会阻塞，直到程序员指定它可以阻塞的时间。这是RTOS固件编程和通用应用程序编程之间的重要区别。例如，*尝试获取一个互斥锁，如果在该指定时间内互斥锁不可用，则该尝试将失败*。对于接受并推送数据到队列的API调用以及FreeRTOS中所有其他非中断API调用也是如此。
- en: While a task is in the `Blocked` state, it doesn't consume any processor time.
    When a task is transitioned out of the `Blocked` state by the scheduler, it will
    be moved to the `Ready` state, allowing the calling task to run when it becomes
    the highest priority task in the system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务处于`Blocked`状态时，它不会消耗任何处理器时间。当调度器将任务从`Blocked`状态转换出来时，它将被移动到`Ready`状态，允许调用任务在它成为系统中最高的优先级任务时运行。
- en: Suspended
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停
- en: The `Suspended` state is a bit of a special case since it requires explicit
    FreeRTOS API calls to enter and exit. Once a task enters the `Suspended` state
    (via the `vTaskSuspend()` API call), it is effectively ignored by the scheduler
    until the `vTaskRusme()` API call is made. This state causes the scheduler to
    effectively ignore the task until it is moved into the `Ready` state by an explicit
    API call. Just like the `Blocked` state, the `Suspended` state will not consume
    any processor time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspended`状态是一个有点特殊的情况，因为它需要显式调用FreeRTOS API来进入和退出。一旦任务进入`Suspended`状态（通过`vTaskSuspend()`
    API调用），它将被调度器忽略，直到执行`vTaskResume()` API调用。这种状态导致调度器实际上忽略任务，直到通过显式API调用将其移动到`Ready`状态。就像`Blocked`状态一样，`Suspended`状态不会消耗任何处理器时间。'
- en: Now that we understand the various task states and how they interact with different
    parts of the RTOS, we can learn how to optimize an application so that it makes
    efficient use of tasks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种任务状态以及它们如何与RTOS的不同部分交互，我们可以学习如何优化应用程序，使其能够高效地使用任务。
- en: Optimizing task states
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化任务状态
- en: Thoughtful optimizations can be made to minimize the time tasks stay in the
    `Running` state. Since a task only consumes significant CPU time when in the `Running` state,
    it is usually a good idea to minimize time spent there on legitimate work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深思熟虑的优化可以最小化任务在`运行`状态的时间。由于任务只有在`运行`状态下才会消耗显著的CPU时间，因此通常最好将时间花在合法的工作上。
- en: As you'll see, polling for events does work but is usually an unnecessary waste
    of CPU cycles. If properly balanced with task priorities, the system can be designed
    to be both responsive to important events while also minimizing CPU time. There
    can be a few different reasons for optimizing an application in this way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，轮询事件是有效的，但通常是不必要的CPU周期浪费。如果与任务优先级平衡得当，系统可以设计为对重要事件做出响应，同时最大限度地减少CPU时间。以这种方式优化应用程序可能有几个不同的原因。
- en: Optimizing to reduce CPU time
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化以减少CPU时间
- en: Often, an RTOS is used because many different activities need to happen almost
    simultaneously. When a task needs to take action because an event occurs, there
    are a few ways of monitoring for the event.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RTOS被用于许多不同的活动几乎同时发生。当一个任务需要因为事件发生而采取行动时，有几种方法可以监控该事件。
- en: 'Polling is when a value is continuously read in order to capture a transition.
    An example of this would be waiting for a new ADC reading. A *polled* read might
    look something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是指连续读取一个值以捕获一个转换。一个例子就是等待新的ADC读数。一个*轮询*读取可能看起来像这样：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While this code *will* detect when a new ADC reading has occurred, it will also
    cause the task to continually be in the `Running` state. If this happens to be
    the highest priority task in the system, this will *starve* the other tasks of
    CPU time. This is because there is nothing to force the task to move out of the
    `Running` state – it is continually checking for a new value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码*会*检测到新的ADC读数发生，但它也会使任务持续处于`运行`状态。如果这成为系统中优先级最高的任务，这将*饿死*其他任务对CPU时间的获取。这是因为没有任何东西能迫使任务离开`运行`状态——它持续检查新的值。
- en: To minimize the time a task spends in the `Running` state (continually polling
    for a change), we can use the hardware included in the MCU to perform the same
    check without CPU intervention. For example, **interrupt service routines** (**ISRs**)
    and **direct memory access** (**DMA**) can both be used to offload some of the
    work from the CPU onto different hardware peripherals included in the MCU. An
    ISR can be interfaced with RTOS primitives to notify a task when there is valuable
    work to be done, thereby eliminating the need for CPU-intensive polling. [Chapter
    8](c6d7a0c6-6f18-4e06-a372-cd1605942ecd.xhtml), *Protecting Data and Synchronizing
    Tasks*, will cover polling in more detail, as well as multiple efficient alternatives.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化任务在`运行`状态（持续轮询以检测变化）所花费的时间，我们可以使用MCU中包含的硬件来执行相同的检查，而不需要CPU干预。例如，**中断服务例程**（**ISR**）和**直接内存访问**（**DMA**）都可以用来将CPU的一些工作卸载到MCU中包含的不同硬件外设。一个ISR可以与RTOS原语接口，以便在有价值的工作需要完成时通知任务，从而消除对CPU密集型轮询的需求。[第8章](c6d7a0c6-6f18-4e06-a372-cd1605942ecd.xhtml)，*保护数据和同步任务*，将更详细地介绍轮询，以及多个高效的替代方案。
- en: Optimizing to increase performance
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化以提高性能
- en: Sometimes, there are tight timing requirements that need a low amount of jitter.
    Other times, a peripheral requiring a large amount of throughput may need to be
    used. While it may be possible to meet these timing requirements by polling inside
    a high priority task, it is often more reliable (and more efficient) to implement
    the necessary functionality inside an ISR. It may also be possible to not involve
    the processor at all by using DMA. Both of these options prevent tasks from expending
    worthless CPU cycles on polling loops and allow them to spend more time on useful
    work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有严格的时序要求需要低量的抖动。其他时候，可能需要使用需要大量吞吐量的外设。虽然可能在高优先级任务中轮询以满足这些时序要求，但通常在ISR中实现所需的功能更可靠（也更高效）。也可能通过使用DMA完全不涉及处理器。这两种选项都防止任务在轮询循环上浪费无用的CPU周期，并允许它们有更多时间用于有用的工作。
- en: Take a look at the *Introducing DMA* section in [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml),
    *Understanding RTOS Tasks*, for a refresher on DMA. Interrupts are also covered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[第2章](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml)中的“*DMA介绍*”部分，以复习DMA。中断也包含在内。
- en: Because interrupts and DMA can operate completely below the RTOS (not requiring
    any kernel intervention), they can have a dramatically positive effect on creating
    a deterministic system. We'll look at how to write these types of drivers in detail
    in [Chapter 10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml), *Drivers and ISRs*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中断和DMA可以在RTOS完全以下运行（不需要任何内核干预），它们可以对创建确定性系统产生显著积极的影响。我们将在[第10章](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml)“*驱动器和中断服务例程*”中详细探讨如何编写这些类型的驱动程序。
- en: Optimizing to minimize power consumption
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化以最小化功耗
- en: With the prevalence of battery-powered and energy harvesting applications, programmers
    have another reason to make sure the system is using as few CPU cycles as possible.
    Similar ideas are present in creating power-conscious solutions, but instead of
    maximizing determinism, the focus is often on saving CPU cycles and operating
    with slower clock rates.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电池供电和能量收集应用的普遍存在，程序员有另一个确保系统使用尽可能少的CPU周期的理由。在创建节能解决方案时，也存在类似的想法，但重点通常不是最大化确定性，而是节省CPU周期并以较慢的时钟速率运行。
- en: There is an additional feature in FreeRTOS that is available for experimentation
    in this space – the tickless IDLE task. This trades timing accuracy for a reduction
    in how often the kernel runs. Normally, if the kernel was set up for a 1 ms tick
    rate (waiting up to every millisecond to check for the next activity), it would
    wake up and run the code at 1 kHz. In the case of a *tickless* IDLE task, the
    kernel only wakes up when necessary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS中有一个额外的功能，可用于在此空间进行实验——无滴答的IDLE任务。这是以牺牲时间精度为代价，减少内核运行的频率。通常，如果内核被设置为1
    ms的滴答率（等待最多每毫秒检查一次下一次活动），它将以1 kHz的频率唤醒并运行代码。在无滴答IDLE任务的情况下，内核仅在必要时唤醒。
- en: 'Now that we''ve covered some starting points on how to improve an already running
    system, let''s turn our attention to something more dire: a system that doesn''t
    start at all!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些如何改进已运行系统的起点，让我们将注意力转向更严重的事情：一个根本无法启动的系统！
- en: Troubleshooting startup problems
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除启动问题
- en: So, let's say you're working on a project and things haven't gone as planned.
    Instead of being rewarded with blinky lights, you're left staring at a very non-blinky
    piece of hardware. At this stage, it's usually best to get the debugger up and
    running, rather than making random guesses about what might be wrong and sporadically
    changing sections of code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在做一个项目，事情并没有按计划进行。你并没有得到闪烁的灯光作为奖励，而是被迫盯着一个非常不闪烁的硬件设备。在这个阶段，通常最好是启动调试器，而不是随意猜测可能的问题并随机更改代码部分。
- en: None of my tasks are running!
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的所有任务都没有运行！
- en: Most often, startup problems in the early stages of development will be caused
    by not allocating enough space in the FreeRTOS heap. There are typically two symptoms
    that result from this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的早期阶段，大多数启动问题都是由FreeRTOS堆中未分配足够空间引起的。通常会有两种症状由此产生。
- en: Task creation failed
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务创建失败
- en: 'In the following case, the code will get *stuck* before running the scheduler
    (no lights will be blinking). Perform the following steps to determine why:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，代码在运行调度器之前会*卡住*（没有灯光闪烁）。执行以下步骤以确定原因：
- en: Using a debugger, step through task creation until you find the offending task.
    This is easy to do because all of our attempts to create tasks will only progress
    if the tasks were successfully created.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试器，逐步执行任务创建，直到找到有问题的任务。这很容易做到，因为所有创建任务的尝试只有在任务成功创建的情况下才会进展。
- en: 'In this case, you''ll see that `xTaskCreate` doesn''t return `pdPASS ` when
    creating `BlueTask`. The following code is requesting a 50 KB stack for `BlueTask`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，你会看到在创建`BlueTask`时`xTaskCreate`没有返回`pdPASS`。以下代码请求为`BlueTask`分配50 KB的堆栈：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can find the full source for this example here: [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_FailedStartup.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_FailedStartup.c).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到此示例的完整源代码：[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_FailedStartup.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/blob/master/Chapter_7/Src/main_FailedStartup.c)。
- en: 'Here''s the code for `assert_failed`. The infinite `while` loop makes it very
    easy to track down the offending line using a debug probe and looks at the call
    stack:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`assert_failed`的代码。无限`while`循环使得使用调试探针追踪有问题的行变得非常容易，并查看调用堆栈：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the Ozone call stack, the failed assertion can be tracked back to creating `BlueTask`
    on line 37 of `main_FailedStartup.c`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ozone调用堆栈，失败的断言可以追溯到在`main_FailedStartup.c`的第37行创建`BlueTask`：
- en: '![](img/a97373bd-d3f0-4926-926f-e459b995ec4d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a97373bd-d3f0-4926-926f-e459b995ec4d.png)'
- en: After determining the cause of failure to be a task that failed to be created,
    it is time to consider increasing the FreeRTOS heap by modifying `FreeRTOSConfig.h`.
    This is done by modifying `configTOTAL_HEAP_SIZE` (it's currently set to 15 KB).
    This excerpt has been taken from `Chapter_7/Inc/FreeRTOSConfig.h`***:***
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定失败的原因是未能创建的任务后，是时候考虑通过修改`FreeRTOSConfig.h`来增加FreeRTOS的堆空间了。这是通过修改`configTOTAL_HEAP_SIZE`来完成的（目前设置为15
    KB）。此摘录取自`Chapter_7/Inc/FreeRTOSConfig.h`***：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unlike stack size specifications, which are specified in *words* (for example, `configMINIMAL_STACK_SIZE` )
    and passed as arguments to `xTaskCreate`, `configTOTAL_HEAP_SIZE ` is specified
    in bytes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与以*单词*（例如，`configMINIMAL_STACK_SIZE`）指定的堆栈大小规范不同，它作为参数传递给`xTaskCreate`，`configTOTAL_HEAP_SIZE`是以字节为单位的。
- en: Care needs to be taken when increasing `configTOTAL_HEAP_SIZE`. See the *Important
    notes* section on considerations to be made.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在增加`configTOTAL_HEAP_SIZE`时需要小心。请参阅*重要注意事项*部分，了解需要考虑的事项。
- en: Scheduler returns unexpectedly
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器意外返回
- en: 'It is also possible to run into issues with `vStartScheduler` returning this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能出现`vStartScheduler`返回此问题的情况：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is simply another symptom of the same underlying issue – inadequate heap
    space. The scheduler defines an IDLE task that requires `configMINIMAL_STACK_SIZE` words
    of heap space (plus room for the TCB).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是同一潜在问题的另一个症状——堆空间不足。调度器定义了一个需要`configMINIMAL_STACK_SIZE`个堆空间单词的IDLE任务（加上TCB的空间）。
- en: If you're reading this section because you *actually* *have* a program that
    isn't starting and you're *not* experiencing either of these symptoms, do not
    worry! There's an entire chapter in the back of this book, just for you. Check
    out [Chapter 17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting
    Tips and Next Steps*. It was actually created from real-world problems that were
    encountered during the creation of the example code in this book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这一部分，因为你*实际上*有一个无法启动的程序，并且你*没有*遇到这些症状中的任何一种，请不要担心！这本书的后面有一个专门的章节，专门为你准备。查看[第17章](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml)，*故障排除技巧和下一步行动*。它实际上是从这本书示例代码创建过程中遇到的真实问题中创建出来的。
- en: There are a few more considerations to be made if you have an application that
    is refusing to start.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序拒绝启动，还有一些其他考虑因素需要考虑。
- en: Important notes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: RAM on MCU-based embedded systems is usually a scarce resource. When increasing
    the heap space available to FreeRTOS (`configTOTAL_HEAP_SIZE`), you'll be reducing
    the amount of RAM available to non-RTOS code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MCU的嵌入式系统中的RAM通常是一种稀缺资源。当增加FreeRTOS可用的堆空间（`configTOTAL_HEAP_SIZE`）时，你将减少非RTOS代码可用的RAM量。
- en: 'There are several factors to be aware of when considering increasing the heap
    available to FreeRTOS via `configTOTAL_HEAP_SIZE`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑通过`configTOTAL_HEAP_SIZE`增加FreeRTOS可用的堆空间时，有几个因素需要注意：
- en: If a significantly sized non-RTOS stack has been defined – that is, the stack
    that is used by any code that isn't running inside a task (typically configured
    inside the startup file). Initialization code will use this stack, so if there
    are any deep function calls, this stack won't be able to be made especially small.
    USB stacks that have been initialized before the scheduler is started can be a
    culprit here. One possible solution to this on RAM-constrained systems is to move
    the bloated initialization code into a task with a large enough stack. This may
    allow for the non-RTOS stack to be minimized further.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经定义了一个较大尺寸的非RTOS堆栈——即任何不在任务内部运行的代码所使用的堆栈（通常在启动文件中配置）。初始化代码将使用这个堆栈，所以如果有任何深层函数调用，这个堆栈将无法特别小。在调度器启动之前初始化的USB堆栈可能是罪魁祸首。在内存受限的系统上，一个可能的解决方案是将膨胀的初始化代码移动到一个具有足够大堆栈的任务中。这可能允许进一步最小化非RTOS堆栈。
- en: ISRs will be making use of the non-RTOS stack as well, but they'll need it for
    the entire duration of the program.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断服务例程（ISRs）也将使用非实时操作系统（RTOS）堆栈，但它们在整个程序运行期间都需要它。
- en: Consider using statically allocated tasks instead – it's guaranteed there will
    be enough RAM when the program runs.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用静态分配的任务，因为在程序运行时可以保证有足够的RAM。
- en: A more in-depth discussion on memory allocation can be found in [Chapter  15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)*,
    FreeRTOS Memory Management.*
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存分配的更深入讨论可以在[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)*，FreeRTOS内存管理*中找到。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered the different ways of defining tasks and how
    to start the FreeRTOS scheduler. Along the way, we covered some more examples
    of using Ozone, SystemView, and STM32CubeIDE (or any Eclipse CDT-based IDE). All
    of this information was used to create a live demo that tied all of the RTOS concepts
    regarding task creation with the mechanics of actually loading and analyzing code
    running on embedded hardware. There were also some suggestions on how *not*to
    monitor for events (polling).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了定义任务的不同方式以及如何启动FreeRTOS调度器。在这个过程中，我们还介绍了一些使用Ozone、SystemView和STM32CubeIDE（或任何基于Eclipse
    CDT的IDE）的示例。所有这些信息都被用来创建一个实时演示，将有关任务创建的RTOS概念与在嵌入式硬件上实际加载和分析代码的机制联系起来。还有一些关于如何*不*监控事件的建议（轮询）。
- en: In the next chapter, we'll introduce what you *should* be using for event monitoring.
    Multiple ways of implementing inter-task signaling and synchronization will be
    covered – all through examples. There's going to be LOTS of code and a bunch of
    hands-on analysis using the Nucleo board.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍您*应该*用于事件监控的内容。我们将通过示例涵盖实现任务间信号和同步的多种方式。将会有大量的代码和许多使用Nucleo板进行的手动分析。将有大量的代码和许多使用Nucleo板进行的手动分析。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude this chapter, here is a list of questions so that you can test
    your knowledge regarding this chapter''s material. You will find the answers in
    the *Assessments* section of the *Appendix*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章内容时，这里有一份问题列表，以便您可以测试自己对本章材料的了解。您将在附录的*评估*部分找到答案：
- en: How many options are available when starting FreeRTOS tasks?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动FreeRTOS任务时有哪些选项可用？
- en: The return value needs to be checked when calling `xTaskCreate()`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`xTaskCreate()`时需要检查返回值。
- en: 'True'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: The return value needs to be checked when calling `vTaskStartScheduler()`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vTaskStartScheduler()`时需要检查返回值。
- en: 'True'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Because RTOSes are bloated middleware, FreeRTOS requires a huge heap for storing
    all of the task stacks, regardless of what functions the task is performing.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为RTOS是臃肿的中间件，FreeRTOS需要巨大的堆来存储所有任务栈，无论任务执行什么功能。
- en: 'True'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Once a task has been started, it can never be removed.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦任务启动，就无法将其移除。
- en: 'True'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Free RTOS customization (`FreeRTOSConfig.h`): [https://www.freertos.org/a00110.htm](https://www.freertos.org/a00110.html)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Free RTOS定制（`FreeRTOSConfig.h`）: [https://www.freertos.org/a00110.htm](https://www.freertos.org/a00110.html)'
