- en: '*Chapter 8*: Graphics and Animations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：图形和动画
- en: In this chapter, you will learn the fundamentals of Qt's graphics framework
    and how to render graphics on a screen. You will understand how general drawing
    is done in Qt. We will begin by discussing 2D graphics using **QPainter**. We
    will explore how to draw different shapes using a painter. Then you will learn
    about the Graphics View architecture used by **QGraphicsView** and **QGraphicsScene**.
    Later, we will discuss the **Scene Graph** mechanism used by Qt Quick. In this
    chapter, you will also learn how to make the user interface more interesting by
    adding animations and states.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Qt图形框架的基础知识以及如何在屏幕上渲染图形。您将了解Qt中如何进行一般绘图。我们将从讨论使用**QPainter**进行2D图形开始。我们将探讨如何使用绘图工具绘制不同的形状。然后，您将了解**QGraphicsView**和**QGraphicsScene**使用的图形视图架构。之后，我们将讨论Qt
    Quick使用的**场景图**机制。在本章中，您还将学习如何通过添加动画和状态使用户界面更有趣。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Understanding Qt's graphics framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Qt的图形框架
- en: '`QPainter` and 2D graphics'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter`和2D图形'
- en: The Graphics View framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形视图框架
- en: OpenGL implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL实现
- en: Qt Quick scene graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick场景图
- en: Animation in QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的动画
- en: State machines in Qt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt中的状态机
- en: By the end of this chapter, you will understand the graphics framework used
    by Qt. You will be able to draw onscreen and add animations to your UI elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，您将了解Qt使用的图形框架。您将能够在屏幕上绘制并向UI元素添加动画。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest version of a desktop platform such
    as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括Qt 6.0.0和Qt Creator 4.14.0的最低版本，安装在Windows 10、Ubuntu 20.04或macOS 10.14等最新版本的桌面平台上。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08)。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platforms on your machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图来自Windows平台。您将在您的机器上基于底层平台看到类似的屏幕。
- en: Understanding Qt's graphics framework
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Qt的图形框架
- en: Qt is one of the most popular frameworks for GUI applications. Developers can
    build awesome cross-platform GUI applications using Qt without worrying about
    the underlying graphics implementation. The Qt **Rendering Hardware Interface**
    (**RHI**) interprets graphics instructions from Qt applications to the available
    graphics APIs on the target platform.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是最受欢迎的GUI应用程序框架之一。开发人员可以使用Qt构建出色的跨平台GUI应用程序，而不必担心底层图形实现。Qt **渲染硬件接口**（**RHI**）将Qt应用程序的图形指令解释为目标平台上可用的图形API。
- en: 'RHI is the abstract interface for hardware-accelerated graphics APIs. The most
    important class in the `rhi` module is `QRhi`. The `QRhi` instance is supported
    by a backend for the specific graphics API. The selection of the backend occurs
    at runtime and is decided by the application or library that creates the `QRhi`
    instance. You can add the module by adding the following line into your project
    file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RHI是硬件加速图形API的抽象接口。`rhi`模块中最重要的类是`QRhi`。`QRhi`实例由特定图形API的后端支持。后端的选择在运行时确定，并由创建`QRhi`实例的应用程序或库决定。您可以通过将以下行添加到项目文件中来添加模块：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Different types of graphics APIs supported by RHI are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RHI支持的不同类型的图形API如下：
- en: '**OpenGL**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL**'
- en: '**OpenGL ES**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES**'
- en: '**Vulkan**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vulkan**'
- en: '**Direct3D**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Direct3D**'
- en: '**Metal**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属**'
- en: '*Figure 8.1* shows the major layers of the graphics stack in the Qt graphics
    framework:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1*显示了Qt图形框架中的主要图层：'
- en: '![Figure 8.1 – Major layers of the Qt 6 graphics stack'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - Qt 6图形堆栈的主要图层'
- en: '](img/Figure_8.1_B16231.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16231.jpg)'
- en: Figure 8.1 – Major layers of the Qt 6 graphics stack
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - Qt 6图形堆栈的主要图层
- en: 'Let''s get familiar with the graphics APIs shown in the preceding diagram.
    **OpenGL** is the most popular graphics API with cross-language and cross-platform
    application support. It is used to interact with the GPU, to achieve hardware-accelerated
    rendering. **OpenGL ES** is a flavor of the OpenGL API intended for embedded devices.
    It allows the rendering of advanced 2D and 3D graphics on embedded and mobile
    devices. **OpenGL ES on iOS devices** is also known as **EAGL**. OpenGL ES is
    also available on web platforms as WebGL. OpenGL and OpenGL ES are developed and
    maintained by the Khronos Group, a consortium of technology hardware and software
    companies. You can learn more about OpenGL at the following link:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉一下前面图中显示的图形API。**OpenGL**是最受欢迎的图形API，具有跨语言和跨平台应用程序支持。它用于与GPU交互，实现硬件加速渲染。**OpenGL
    ES**是OpenGL API的一种适用于嵌入式设备的变体。它允许在嵌入式和移动设备上渲染高级2D和3D图形。**iOS设备上的OpenGL ES**也称为**EAGL**。OpenGL
    ES也可在Web平台上作为WebGL使用。OpenGL和OpenGL ES由技术硬件和软件公司的联盟Khronos Group开发和维护。您可以在以下链接了解有关OpenGL的更多信息：
- en: https://www.opengl.org/about/
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.opengl.org/about/
- en: '**Vulkan** is a new-generation graphics API that helps in creating cross-platform
    and high-performance applications for modern GPUs. It was created by the Khronos
    Group. Vulkan''s explicit API design allows efficient implementations on a wide
    range of desktop, embedded, and mobile platforms. Qt 6 provides support for the
    Vulkan API. To use Vulkan, Qt applications require the LunarG Vulkan SDK. Explore
    more about Vulkan at the following link:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vulkan**是一个新一代的图形API，有助于为现代GPU创建跨平台和高性能的应用程序。它由Khronos Group创建。Vulkan的显式API设计允许在各种桌面、嵌入式和移动平台上进行高效实现。Qt
    6提供了对Vulkan API的支持。要使用Vulkan，Qt应用程序需要LunarG Vulkan SDK。在以下链接中探索更多关于Vulkan的信息：'
- en: https://www.lunarg.com/vulkan-sdk/
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.lunarg.com/vulkan-sdk/
- en: '**Direct3D** is a Microsoft proprietary graphics API that provides functions
    to render 2D and 3D graphics by utilizing underlying GPU capabilities. Microsoft
    Corporation created it for use on the Windows platform. It is a low-level API
    that can be used to draw primitives with the rendering pipeline or to perform
    parallel operations with the compute shader.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Direct3D**是微软专有的图形API，提供了利用底层GPU功能进行2D和3D图形渲染的函数。微软公司为Windows平台创建了它。它是一个低级API，可用于使用渲染管线绘制基元或使用计算着色器执行并行操作。'
- en: 'Direct3D exposes the advanced graphics capabilities of 3D graphics hardware,
    including stencil buffering, W-buffering, Z-buffering, perspective-correct texture
    mapping, spatial anti-aliasing, programmable HLSL shaders, and effects. Direct3D''s
    integration with other DirectX technologies allows it to provide several features
    comprising video mapping, hardware 3D rendering in 2D overlay planes, and even
    sprites and allowing the use of 2D and 3D graphics in interactive media ties.
    Direct3D is intended to virtualize 3D hardware interfaces in general. In contrast,
    OpenGL is intended to be a 3D hardware-accelerated rendering system that can be
    emulated in software. These two APIs are fundamentally designed in two distinct
    ways. The following link provides further insight into Direct3D:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Direct3D暴露了3D图形硬件的高级图形能力，包括模板缓冲、W缓冲、Z缓冲、透视纹理映射、空间反锯齿、可编程HLSL着色器和特效。Direct3D与其他DirectX技术的集成使其能够提供包括视频映射、硬件2D叠加平面中的3D渲染，甚至精灵，并允许在交互媒体中使用2D和3D图形的多个功能。Direct3D旨在通常虚拟化3D硬件接口。相比之下，OpenGL旨在成为可以在软件中模拟的3D硬件加速渲染系统。这两个API在设计上有根本的不同。以下链接提供了对Direct3D的进一步了解：
- en: https://docs.microsoft.com/en-in/windows/win32/getting-started-with-direct3d
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: https://docs.microsoft.com/en-in/windows/win32/getting-started-with-direct3d
- en: '**Metal** is Apple''s low-level computer graphics API, which offers near-direct
    access to the **graphics processing unit** (**GPU**), allowing you to optimize
    the graphics and compute capacity of your iOS, macOS, and tvOS apps. It also has
    a low-overhead architecture that includes pre-compiled GPU shaders, fine-grained
    resource management, and multithreading support. Before the announcement of Metal,
    Apple provided OpenGL for macOS and OpenGL ES for iOS, but there was a performance
    issue due to the highly abstracted hardware. Metal, on the other hand, has better
    performance than OpenGL thanks to its Apple-specific API. Metal enables a whole
    new generation of professional graphics output by supporting up to 100 times more
    draw calls than OpenGL. You can read more about Metal at the following link:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Metal**是苹果的低级计算机图形API，它提供了对**图形处理单元**（**GPU**）的几乎直接访问，使您能够优化iOS、macOS和tvOS应用程序的图形和计算能力。它还具有低开销的架构，包括预编译的GPU着色器、细粒度资源管理和多线程支持。在Metal宣布之前，苹果为macOS提供了OpenGL，为iOS提供了OpenGL
    ES，但由于高度抽象的硬件，存在性能问题。另一方面，Metal由于其苹果特定的API，比OpenGL具有更好的性能。Metal通过支持多达100倍于OpenGL的绘制调用，实现了全新一代的专业图形输出。您可以在以下链接中了解更多关于Metal的信息：'
- en: https://developer.apple.com/documentation/metal
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: https://developer.apple.com/documentation/metal
- en: In this section, we got familiar with Qt's graphics framework and RHI. You now
    have a basic understanding of this framework. In the next section, we will go
    further and discuss 2D graphics using QPainter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们熟悉了Qt的图形框架和RHI。您现在对这个框架有了基本的了解。在下一节中，我们将进一步讨论使用QPainter进行2D图形。
- en: QPainter and 2D graphics
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QPainter和2D图形
- en: Qt comes with an advanced windowing, painting, and typography system. The most
    important classes in the Qt GUI module are `QWindow` and `QGuiApplication`. This
    module includes classes for 2D graphics, imaging, fonts, and advanced typography.
    Additionally, the GUI module comes with classes for integrating windowing systems,
    OpenGL integration, event handling, 2D graphics, basic imaging, fonts, and text.
    Qt's user interface technologies use these classes internally, but they can directly
    be used to write applications that use low-level OpenGL graphics APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Qt具有先进的窗口、绘图和排版系统。Qt GUI模块中最重要的类是`QWindow`和`QGuiApplication`。该模块包括用于2D图形、图像、字体和高级排版的类。此外，GUI模块还包括用于集成窗口系统、OpenGL集成、事件处理、2D图形、基本图像、字体和文本的类。Qt的用户界面技术在内部使用这些类，但也可以直接用于编写使用低级OpenGL图形API的应用程序。
- en: Depending on the platform, the `QWindow` class supports rendering with OpenGL
    and OpenGL ES. Qt includes the `QOpenGLPaintDevice` class, which allows the use
    of OpenGL accelerated `QPainter` rendering and several convenience classes. These
    convenience classes simplify writing code in OpenGL by hiding the complexities
    of extension handling and the differences between OpenGL ES 2.0 and desktop OpenGL.
    `QOpenGLFunctions` is a convenience class that provides cross-platform access
    to the OpenGL ES 2.0 functions on desktop OpenGL without the need to manually
    resolve the OpenGL function pointers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台，`QWindow`类支持使用OpenGL和OpenGL ES进行渲染。Qt包括`QOpenGLPaintDevice`类，它允许使用OpenGL加速的`QPainter`渲染和几个便利类。这些便利类通过隐藏扩展处理的复杂性和OpenGL
    ES 2.0与桌面OpenGL之间的差异，简化了OpenGL中的编写代码。`QOpenGLFunctions`是一个便利类，它提供了跨平台访问桌面OpenGL上的OpenGL
    ES 2.0函数，而无需手动解析OpenGL函数指针。
- en: 'To make use of these APIs and classes on a qmake-based application, you have
    to include the `gui` module in your project file (`.pro`) as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于qmake的应用程序中使用这些API和类，您必须在项目文件（.pro）中包含`gui`模块，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are using a *Cmake*-based build system, then add the following to the
    `CMakeLists.txt` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于*Cmake*的构建系统，则将以下内容添加到`CMakeLists.txt`文件中：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `QPainter` class, primarily used for drawing operations, provides an API
    for various tasks such as drawing vector graphics, text, and images onto different
    surfaces, or `QPaintDevice` instances, including `QImage`, `QOpenGLPaintDevice`,
    `QWidget`, and `QPrinter`. For Qt Widgets user interfaces, Qt uses a software
    renderer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`类主要用于绘图操作，为绘制矢量图形、文本和图像到不同表面或`QPaintDevice`实例（包括`QImage`、`QOpenGLPaintDevice`、`QWidget`和`QPrinter`）提供API。对于Qt
    Widgets用户界面，Qt使用软件渲染器。'
- en: 'The following are Qt GUI''s high-level drawing APIs:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Qt GUI的高级绘图API：
- en: Paint system
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制系统
- en: Coordinate system
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标系统
- en: Drawing and filling
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制和填充
- en: We will explore these APIs in the following sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探讨这些API。
- en: Understanding the paint system
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解绘制系统
- en: Qt's paint system provides several convenience classes for drawing on the screen.
    The most important classes used are `QPainter`, `QPaintDevice`, and `QPaintEngine`.
    You can use `QPainter` to paint on widgets and other paint devices. This class
    can be used to draw things from simple lines to complex shapes such as `QPainter`
    inside the `paintEvent()` function or inside a function invoked by a function
    called by `paintEvent()`. `QPaintDevice` is the base class of the objects that
    allow 2D drawing by using a `QPainter` instance. `QPaintEngine` provides the interface
    that defines how `QPainter` paints to a specified device on a specified platform.
    The `QPaintEngine` class is an abstract class that is used internally by `QPainter`
    and `QPaintDevice`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的绘制系统提供了几个方便的类来在屏幕上绘制。最重要的类是`QPainter`、`QPaintDevice`和`QPaintEngine`。您可以使用`QPainter`在小部件和其他绘图设备上绘制。这个类可以用来从简单的线条到复杂的形状（比如在`paintEvent()`函数内部或在`paintEvent()`调用的函数内部绘制`QPainter`）绘制东西。`QPaintDevice`是允许使用`QPainter`实例进行2D绘制的对象的基类。`QPaintEngine`提供了定义`QPainter`如何在指定平台上的指定设备上绘制的接口。`QPaintEngine`类是`QPainter`和`QPaintDevice`内部使用的抽象类。
- en: Let's have a look at the hierarchy of painting-related classes to get a better
    idea of how to choose the right classes while using the paint system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看与绘制相关的类的层次结构，以更好地了解在使用绘制系统时如何选择合适的类。
- en: '![Figure 8.2 – The hierarchy of paint classes in Qt'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – Qt中绘制类的层次结构'
- en: '](img/Figure_8.2_B16231.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16231.jpg)'
- en: Figure 8.2 – The hierarchy of paint classes in Qt
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Qt中绘制类的层次结构
- en: The preceding hierarchical approach illustrates that all drawing approaches
    follow the same mechanism. So, it is easy to add provisions for new features and
    provide default implementations for unsupported ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的层次结构方法说明了所有绘图方法都遵循相同的机制。因此，很容易为新功能添加规定，并为不受支持的功能提供默认实现。
- en: Let's discuss the coordinate system in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节讨论坐标系统。
- en: Using the coordinate system
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用坐标系统
- en: The `QPainter` class controls the coordinate system. It forms the basis of Qt's
    painting system along with the `QPaintDevice` and `QPaintEngine` classes. The
    default coordinate system of a paint device has its origin in the top-left corner.
    The primary function of `QPainter` is to perform drawing operations. While the
    `QPaintDevice` class is an abstraction of a two-dimensional space, which can be
    painted on using `QPainter`, the `QPaintEngine` class offers a painter with the
    interface to draw on different types of devices. The `QPaintDevice` class is the
    base class of objects that can be painted, which inherits its drawing capabilities
    from the `QWidget`, `QImage`, `QPixmap`, `QPicture`, and `QOpenGLPaintDevice`
    classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`类控制坐标系统。它与`QPaintDevice`和`QPaintEngine`类一起构成了Qt的绘制系统的基础。绘图设备的默认坐标系统的原点在左上角。`QPainter`的主要功能是执行绘图操作。而`QPaintDevice`类是一个二维空间的抽象，可以使用`QPainter`进行绘制，`QPaintEngine`类提供了一个绘图器，用于在不同类型的设备上绘制。`QPaintDevice`类是可以进行绘制的对象的基类，它从`QWidget`、`QImage`、`QPixmap`、`QPicture`和`QOpenGLPaintDevice`类继承了其绘图能力。'
- en: 'You can learn more about the coordinate system in the following documentation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文档中了解更多关于坐标系统的信息：
- en: https://doc.qt.io/qt-6/coordsys.html
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc.qt.io/qt-6/coordsys.html
- en: Drawing and filling
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制和填充
- en: '`QPainter` provides a painter with highly optimized functions for most of the
    drawing requirements on the GUI. It can draw various types of shapes ranging from
    simple graphical primitives (such as `QPoint`, `QLine`, `QRect`, `QRegion`, and
    `QPolygon` classes) to complex shapes such as vector paths. The vector paths are
    represented by the `QPainterPath` class. `QPainterPath` works as a container for
    painting operations, allowing graphical shapes to be constructed and reused. It
    can be used for filling, outlining, and clipping. `QPainter` can also draw aligned
    text and pixmaps. To fill the shapes drawn by `QPainter`, you can use the `QBrush`
    class. It has color, style, texture, and gradient attributes and is defined with
    color and style.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`提供了一个高度优化的绘图器，用于大多数GUI上的绘图需求。它可以绘制各种类型的形状，从简单的图形基元（如`QPoint`、`QLine`、`QRect`、`QRegion`和`QPolygon`类）到复杂的矢量路径。矢量路径由`QPainterPath`类表示。`QPainterPath`作为绘制操作的容器，允许构建和重复使用图形形状。它可用于填充、轮廓和裁剪。`QPainter`还可以绘制对齐的文本和像素图。要填充`QPainter`绘制的形状，可以使用`QBrush`类。它具有颜色、样式、纹理和渐变属性，并且通过颜色和样式进行定义。'
- en: In the next section, we will use the APIs discussed so far to draw using `QPainter`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用到目前为止讨论的API来使用`QPainter`进行绘制。
- en: Drawing with QPainter
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用QPainter进行绘制
- en: '`QPainter` has several convenience functions to draw most primitive shapes,
    such as `drawLine()`, `drawRect()`, `drawEllipse()`, `drawArc()`, `drawPie()`,
    and `drawPolygon()`. You can fill the shapes using the `fillRect()` function.
    The `QBrush` class describes the fill pattern of shapes drawn by `QPainter`. A
    brush can be used to define the style, color, gradient, and texture.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`有几个便利函数来绘制大多数基本形状，例如`drawLine()`、`drawRect()`、`drawEllipse()`、`drawArc()`、`drawPie()`和`drawPolygon()`。您可以使用`fillRect()`函数填充形状。`QBrush`类描述了`QPainter`绘制的形状的填充图案。刷子可以用于定义样式、颜色、渐变和纹理。'
- en: 'Let''s look at the following `paintEvent()` function where we have used `QPainter`
    to draw text and different shapes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的`paintEvent()`函数，我们在其中使用`QPainter`来绘制文本和不同的形状：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we have created a `QPainter` instance and painted
    a line, text, ellipse, arc, and pie using the available default drawing functions.
    When you add the preceding code into your custom class and run the project, you
    will see the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个`QPainter`实例，并使用可用的默认绘图函数绘制了一条线、文本、椭圆、弧和扇形。当您将上述代码添加到自定义类中并运行项目时，您将看到以下输出：
- en: '![Figure 8.3 – Output of drawing with QPainter example'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 使用QPainter绘图示例的输出'
- en: '](img/Figure_8.3_B16231.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16231.jpg)'
- en: Figure 8.3 – Output of drawing with QPainter example
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用QPainter绘图示例的输出
- en: Qt provides several offscreen drawing classes, each with its own set of advantages
    and disadvantages. `QImage`, `QBitmap`, `QPixmap`, and `QPicture` are the classes
    involved. In most cases, you must choose between `QImage` and `QPixmap`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了几个离屏绘图类，每个类都有其自己的优缺点。`QImage`、`QBitmap`、`QPixmap`和`QPicture`是涉及的类。在大多数情况下，您必须在`QImage`和`QPixmap`之间进行选择。
- en: 'The `QImage` class in Qt allows for easy image reading, writing, and manipulation.
    `QImage` is the class to use if you''re working with resources, combining multiple
    images, and doing some drawing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的`QImage`类允许轻松读取、写入和操作图像。如果您正在处理资源、合并多个图像并进行一些绘图，则应使用`QImage`类：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line creates an image that''s 128 pixels square, encoding each pixel
    a 32-bit integer – 8 bits for each channel of opacity, red, green, and blue. The
    second line creates a `QPainter` instance that can draw on the `QImage` instance.
    Next, we perform the drawing you just saw in the previous section, and when we''re
    done, we write the image to a PNG file, with the following line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个128像素正方形的图像，每个像素编码为32位整数 - 每个通道的不透明度、红色、绿色和蓝色各占8位。第二行创建了一个可以在`QImage`实例上绘制的`QPainter`实例。接下来，我们执行了您在上一节中看到的绘图，完成后，我们将图像写入PNG文件，代码如下：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`QImage` supports several image formats, including PNG and JPEG. `QImage` also
    has a `load` method, where you can load an image from a file or resource.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage`支持多种图像格式，包括PNG和JPEG。`QImage`还有一个`load`方法，可以从文件或资源加载图像。'
- en: The `QBitmap` class is a monochromatic offscreen paint device that provides
    a pixmap with a depth of 1 bit. The `QPixmap` class provides an offscreen paint
    device. The `QPicture` class is a paint device that serializes `QPainter` commands.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`QBitmap`类是一个单色离屏绘图设备，提供深度为1位的位图。`QPixmap`类提供了一个离屏绘图设备。`QPicture`类是一个序列化`QPainter`命令的绘图设备。'
- en: 'You can also use the `QImageReader` and `QImageWriter` classes to have more
    fine-grained control over how images are loaded and saved. To add support for
    image formats other than those provided by Qt, image format plugins can be created
    using `QImageIOHandler` and `QImageIOPlugin`. The `QPainterPath` class helps in
    drawing different graphical shapes that can be created and reused. The following
    code snippet demonstrates how to use `QPainterPath`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`QImageReader`和`QImageWriter`类来更精细地控制图像的加载和保存。要添加对Qt提供的图像格式之外的图像格式的支持，可以使用`QImageIOHandler`和`QImageIOPlugin`创建图像格式插件。`QPainterPath`类有助于绘制可以创建和重复使用的不同图形形状。以下代码片段演示了如何使用`QPainterPath`：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have created a custom-drawn polygonal object with
    the desired painter path.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个自定义绘制的多边形对象，并使用所需的绘图路径。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that while doing a paint operation, ensure that there is no delay
    between painting the background and painting the content. Otherwise, you will
    notice flickering on the screen if the delay is more than 16 milliseconds. You
    can avoid this by rendering the background into a pixmap, then painting the content
    onto that pixmap. Finally, you can draw that pixmap onto the widget. This approach
    is known as **double buffering**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在进行绘制操作时，请确保在绘制背景和绘制内容之间没有延迟。否则，如果延迟超过16毫秒，您将在屏幕上看到闪烁。您可以通过将背景渲染到一个像素图中，然后在该像素图上绘制内容来避免这种情况。最后，您可以将该像素图绘制到小部件上。这种方法称为**双缓冲**。
- en: In this section, we have learned not only how to draw an image on the screen,
    but also how to draw it off the screen and save it as an image file. In the next
    section, we will learn about the basics of the Graphics View framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不仅学习了如何在屏幕上绘制图像，还学习了如何在屏幕外绘制图像并将其保存为图像文件。在下一节中，我们将学习图形视图框架的基础知识。
- en: Introducing the Graphics View framework
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入图形视图框架
- en: The Graphics View framework is a powerful graphics engine that allows you to
    visualize and interact with a large number of custom-made 2D graphical items.
    If you are an experienced programmer, you can use the graphics view framework
    to draw your GUI and have it animated completely manually. To draw hundreds or
    thousands of relatively lightweight customized items at once, Qt provides a separate
    view framework, the Graphics View framework. You can make use of the Graphics
    View framework if you are creating your own widget set from scratch, or if you
    have a large number of items to display on the screen at once, each with its own
    position and data. This is especially important for applications that process
    and display a large amount of data, such as geographic information systems or
    computer-aided design software.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Graphics View框架是一个强大的图形引擎，允许您可视化和与大量自定义的2D图形项进行交互。如果您是一名经验丰富的程序员，可以使用图形视图框架手动绘制GUI并进行完全手动动画化。为了一次绘制数百或数千个相对轻量级的自定义项，Qt提供了一个独立的视图框架，即Graphics
    View框架。如果您正在从头开始创建自己的小部件集，或者需要一次在屏幕上显示大量项，每个项都有自己的位置和数据，您可以利用Graphics View框架。这对于处理和显示大量数据的应用程序尤为重要，例如地理信息系统或计算机辅助设计软件。
- en: Graphics View offers a surface for managing as well as interacting with a multitude
    of custom-created 2D graphical items, and a view widget for visualizing the items,
    with zooming and rotation support. The framework consists of an event propagation
    architecture that enables interaction capabilities for the scene's items. These
    items respond to key events; mouse press, move, release, and double-click events;
    as well as tracking mouse movement. Graphics View employs a **Binary Space Partitioning**
    (**BSP**) tree to provide very fast item discovery, allowing it to visualize large
    scenes in real time, even when there are millions of items.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Graphics View提供了一个表面，用于管理和与大量自定义创建的2D图形项进行交互，并提供用于可视化这些项的视图小部件，支持缩放和旋转。该框架包括一个事件传播架构，可以为场景的项提供交互功能。这些项响应键盘事件；鼠标按下、移动、释放和双击事件；以及跟踪鼠标移动。Graphics
    View使用二进制空间分区（BSP）树来提供非常快速的项发现，使其能够实时可视化大型场景，即使有数百万个项也可以。
- en: The framework follows an item-based `approach` to model/view programming. It
    comprises three components, `QGraphicsScene`, `QGraphicsView`, and `QGraphicsItem`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架遵循基于项的模型/视图编程方法。它包括三个组件，`QGraphicsScene`、`QGraphicsView`和`QGraphicsItem`。
- en: '`QGraphicsItem` exposes an interface that your subclass can override to manage
    mouse and keyboard events, drag and drop, interface hierarchies, and collision
    detection. Each item has its own local coordinate system, and helper functions
    allow you to quickly transform an item''s coordinates to the scene''s coordinates.
    The Graphics View framework displays the contents of a `QGraphicsScene` class
    using one or more `QGraphicsView` instances. To see different parts of the scene,
    you can attach multiple views to the same scene, each with its own translation
    and rotation. Because the `QGraphicsView` widget is a scroll area, you can also
    attach scroll bars to the view and allow the user to scroll around it. The view
    receives keyboard and mouse input, generates scene events for the scene, and dispatches
    those scene events to the scene, which then dispatches those same events to the
    scene''s items. Previously, the framework was preferred for games development.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`公开了一个接口，您的子类可以重写该接口以管理鼠标和键盘事件、拖放、接口层次结构和碰撞检测。每个项都有自己的本地坐标系，并且助手函数允许您快速将项的坐标转换为场景的坐标。Graphics
    View框架使用一个或多个`QGraphicsView`实例来显示`QGraphicsScene`类的内容。为了查看场景的不同部分，可以将多个视图附加到同一个场景，每个视图都有自己的平移和旋转。由于`QGraphicsView`小部件是一个滚动区域，因此可以将滚动条附加到视图，并允许用户在其中滚动。视图接收键盘和鼠标输入，为场景生成场景事件，并将这些场景事件分派给场景，然后将这些相同的事件分派给场景的项。以前，该框架被用于游戏开发。'
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We will skip the details about the usages of the framework and examples as
    it lost its popularity after Qt Quick 2 came into existence. Qt Quick 2 comes
    with the Scene Graph API, which provides most of the functionalities that were
    earlier offered by the Graphics View framework. If you''d still like to learn
    more about the Graphics View framework, you can read the following documentation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过关于框架用法和示例的细节，因为在Qt Quick 2出现后，它失去了流行度。Qt Quick 2配备了场景图形API，提供了以前由Graphics
    View框架提供的大部分功能。如果您仍然想了解更多关于Graphics View框架的信息，可以阅读以下文档：
- en: https://doc.qt.io/qt-6/graphicsview.html
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc.qt.io/qt-6/graphicsview.html
- en: In this section, we discussed Qt's Graphics View framework. In the next section,
    we will learn about OpenGL integration with Qt.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Qt的Graphics View框架。在下一节中，我们将学习关于Qt与OpenGL集成。
- en: Understanding the Qt OpenGL module
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Qt OpenGL模块
- en: Qt Quick and Qt Widgets are the two main approaches to **user interface** (**UI**)
    development in Qt. They exist to support various types of UIs and are built on
    separate graphics engines that have been optimized for each of these. It is possible
    to combine OpenGL graphics API code with both of these UI types in Qt. This is
    useful when the application contains its own OpenGL-dependent code or when integrating
    with a third-party OpenGL-based renderer. The OpenGL/OpenGL ES XML API Registry
    is used to generate the OpenGL header.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick和Qt Widgets是Qt中用户界面（UI）开发的两种主要方法。它们存在以支持各种类型的UI，并构建在分别针对每种UI进行了优化的独立图形引擎上。在Qt中，可以将OpenGL图形API代码与这两种UI类型结合使用。当应用程序包含自己的OpenGL依赖代码或与第三方基于OpenGL的渲染器集成时，这将非常有用。OpenGL/OpenGL
    ES XML API注册表用于生成OpenGL头文件。
- en: The Qt OpenGL module is intended for use with applications that require OpenGL
    access. The convenience classes in the Qt OpenGL module help developers build
    applications more easily and faster. This module is responsible for maintaining
    compatibility with Qt 5 applications and Qt GUI. `QOpenGLWidget` is a widget that
    can add OpenGL scenes to UIs that use `QWidget`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Qt OpenGL模块旨在与需要OpenGL访问的应用程序一起使用。Qt OpenGL模块中的便利类帮助开发人员更轻松、更快地构建应用程序。这个模块负责与Qt
    5应用程序和Qt GUI保持兼容。`QOpenGLWidget`是一个可以将OpenGL场景添加到使用`QWidget`的UI中的部件。
- en: With the introduction of Qt RHI as the rendering foundation in Qt, most classes
    denoted by `QOpenGL` have been moved to the Qt OpenGL module in Qt 6\. The classes
    are still usable and fully supported for applications that rely solely on OpenGL.
    They are no longer considered essential because Qt has been extended to support
    other graphics APIs, such as Direct3D, Metal, and Vulkan, in its foundation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Qt RHI作为Qt的渲染基础的引入，在Qt 6中，大多数以`QOpenGL`表示的类已经移动到了Qt OpenGL模块中。这些类仍然可用，并且对仅依赖于OpenGL的应用程序提供完全支持。它们不再被认为是必不可少的，因为Qt已经扩展到支持其他图形API，如Direct3D、Metal和Vulkan。
- en: Existing application code will mostly continue to work, but it should now include
    Qt OpenGL in project files, as well as the headers if they were previously included
    indirectly via Qt GUI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的应用程序代码大部分仍将继续工作，但现在应该在项目文件中包含Qt OpenGL，并且如果以前是通过Qt GUI间接包含的话，也应该包含头文件。
- en: Qt 6 no longer directly employs OpenGL-compatible GLSL source snippets. Shaders
    are instead written in Vulkan-style GLSL, reflected and translated to other shading
    languages, and packaged into a serializable `QShader` object that `QRhi` can consume.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6不再直接使用兼容OpenGL的GLSL源代码片段。着色器现在以Vulkan风格的GLSL编写，反射并转换为其他着色语言，并打包成可序列化的`QShader`对象，供`QRhi`消费。
- en: 'The shader preparation pipeline in Qt 6 is the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6中的着色器准备流水线如下：
- en: '![Figure 8.4 – Illustration of the shader preparation pipeline as described
    in the Qt blog'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 在Qt博客中描述的着色器准备流水线的插图'
- en: '](img/Figure_8.4_B16231.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16231.jpg)'
- en: Figure 8.4 – Illustration of the shader preparation pipeline as described in
    the Qt blog
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 在Qt博客中描述的着色器准备流水线的插图
- en: 'With Qt 6.1, Qt Data Visualization supports only the OpenGL RHI backend. It
    requires the setting of the environment variable `QSG_RHI_BACKEND` to `opengl`.
    You can do this at the system level, or define it in `main()` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6.1中，Qt数据可视化仅支持OpenGL RHI后端。它需要将环境变量`QSG_RHI_BACKEND`设置为`opengl`。您可以在系统级别进行设置，或者在`main()`中定义如下：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's discuss how the framework is used with Qt Widgets in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节讨论框架如何与Qt Widgets一起使用。
- en: Qt OpenGL and Qt Widgets
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt OpenGL和Qt Widgets
- en: Qt Widgets is typically rendered by a highly optimized and accurate software
    rasterizer, with the final content being displayed on the screen using a method
    appropriate for the platform on which the application is running. However, Qt
    Widgets and OpenGL can be combined. The `QOpenGLWidget` class is the primary entry
    point for this. This class can be used to enable OpenGL rendering for a specific
    part of the widget tree, and the Qt OpenGL module's classes can be used to help
    with any application-side OpenGL code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Widgets通常由高度优化和准确的软件光栅化器进行渲染，最终的内容通过适合应用程序运行平台的方法显示在屏幕上。然而，Qt Widgets和OpenGL可以结合使用。`QOpenGLWidget`类是这样做的主要入口点。这个类可以用于为部件树的特定部分启用OpenGL渲染，并且Qt
    OpenGL模块的类可以用于帮助处理任何应用程序端的OpenGL代码。
- en: Important note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`QWindow` or `QWidget` based applications with OpenGL implementations, there
    are no other options but to directly call the OpenGL APIs at runtime. For Qt Quick
    and Qt Quick 3D applications, Qt 6 introduced support for Direct3D 11, Vulkan,
    and Metal, in addition to OpenGL. On Windows, the default choice remains Direct3D,
    therefore the removal of ANGLE is eased by having support for graphics APIs other
    than OpenGL as well.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`QWindow`或`QWidget`的OpenGL实现的应用程序，没有其他选择，只能在运行时直接调用OpenGL API。对于Qt Quick和Qt
    Quick 3D应用程序，Qt 6除了OpenGL外，还引入了对Direct3D 11、Vulkan和Metal的支持。在Windows上，默认选择仍然是Direct3D，因此通过支持除OpenGL以外的图形API，简化了ANGLE的移除。
- en: In this section, we learned how to use Qt's Open GL module. Let's move on to
    the next section, where we'll discuss graphics in Qt Quick in detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Qt的OpenGL模块。让我们继续下一节，详细讨论Qt Quick中的图形。
- en: Graphics in Qt Quick
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick中的图形
- en: Qt Quick is designed to take advantage of hardware-accelerated rendering. It
    will be built by default on the low-level graphics API that is most appropriate
    for the target platform. On Windows, for example, it will default to Direct3D,
    whereas on macOS, it will default to Metal. For rendering, Qt Quick applications
    make use of a scene graph. The scene graph renderer can make more efficient graphics
    calls, which improves performance. The scene graph has an accessible API that
    allows you to create complex but fast graphics. The Qt Quick 2D Renderer can also
    be used to render Qt Quick. This raster paint engine allows Qt Quick applications
    to be rendered on platforms that do not support OpenGL.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick旨在利用硬件加速渲染。它将默认构建在最适合目标平台的低级图形API上。例如，在Windows上，它将默认使用Direct3D，而在macOS上，它将默认使用Metal。对于渲染，Qt
    Quick应用程序使用场景图。场景图渲染器可以进行更有效的图形调用，从而提高性能。场景图具有可访问的API，允许您创建复杂但快速的图形。Qt Quick 2D渲染器也可以用于渲染Qt
    Quick。这个光栅绘图引擎允许Qt Quick应用程序在不支持OpenGL的平台上进行渲染。
- en: Qt uses the most appropriate graphics API on the target platform by default.
    However, it is possible to configure Qt's rendering path to use a specific API.
    In many cases, selecting a specific API improves performance and allows developers
    to deploy on platforms that support a specific graphics API. To change the render
    path in `QQuickWindow`, you can use the `QRhi` interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Qt默认情况下使用目标平台上最合适的图形API。但是，可以配置Qt的渲染路径以使用特定的API。在许多情况下，选择特定的API可以提高性能，并允许开发人员在支持特定图形API的平台上部署。要更改`QQuickWindow`中的渲染路径，可以使用`QRhi`接口。
- en: In the following sections, we will have a look at some functionalities that
    will further enhance your graphics-related skills in Qt Quick. Let's begin by
    discussing how we can use OpenGL in Qt Quick.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将看一些功能，这些功能将进一步增强您在Qt Quick中与图形相关的技能。让我们从讨论如何在Qt Quick中使用OpenGL开始。
- en: Qt OpenGL and Qt Quick
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt OpenGL和Qt Quick
- en: On platforms that support OpenGL, it is possible to manually select it as the
    active graphics API. In order to use this functionality when working with Qt Quick,
    the application should manually set the rendering backend to OpenGL in addition
    to adjusting project files and including headers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持OpenGL的平台上，可以手动选择它作为活动的图形API。为了在使用Qt Quick时使用这个功能，应用程序应该手动将渲染后端设置为OpenGL，同时调整项目文件并包含头文件。
- en: With Qt 6, there is no direct way of OpenGL rendering using Qt Quick. The QRhi-based
    rendering path of the Qt Quick scene graph is now the new default. Aside from
    the defaults, the methods for configuring which QRhi backend and thus which graphics
    API to use remain largely unchanged from Qt 5.15\. One key difference in Qt 6
    is improved API naming. Now, you can set the RHI backend by calling the `QQuickWindow::setGraphicsApi()`
    function, whereas earlier this was achieved by calling the `QQuickWindow::setSceneGraphBackend()`
    function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6中，没有直接使用Qt Quick进行OpenGL渲染的方法。基于QRhi的Qt Quick场景图的渲染路径现在是新的默认值。除了默认值之外，配置使用哪个QRhi后端以及因此使用哪个图形API的方法与Qt
    5.15基本保持不变。Qt 6中的一个关键区别是改进的API命名。现在，可以通过调用`QQuickWindow::setGraphicsApi()`函数来设置RHI后端，而在早期，这是通过调用`QQuickWindow::setSceneGraphBackend()`函数来实现的。
- en: 'You can learn more about the changes in the following article:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文章中了解更多关于这些变化的信息：
- en: https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d
- en: Custom Qt Quick items using QPainter
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用QPainter自定义Qt Quick项
- en: You can also make use of `QPainter` in your Qt Quick application. This can be
    done by subclassing `QQuickPaintedItem`. With the help of this subclass, you can
    render content using a `QPainter` instance. To render its content, the `QQuickPaintedItem`
    subclass uses an indirect 2D surface by either using software rasterization or
    using an **OpenGL Framebuffer Object** (**FBO**). Rendering is a two-step operation.
    The paint surface is rasterized before drawing. However, drawing using a scene
    graph is significantly faster than this rasterization approach.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Qt Quick应用程序中使用`QPainter`。这可以通过对`QQuickPaintedItem`进行子类化来实现。借助这个子类，您可以使用`QPainter`实例来渲染内容。为了渲染其内容，`QQuickPaintedItem`子类使用间接的2D表面，可以使用软件光栅化或使用**OpenGL帧缓冲对象**（**FBO**）。渲染是一个两步操作。在绘制之前，绘制表面被光栅化。然而，使用场景图进行绘制比这种光栅化方法要快得多。
- en: Let's explore the scene graph mechanism used by Qt Quick.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索Qt Quick使用的场景图机制。
- en: Understanding the Qt Quick scene graph
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Qt Quick场景图
- en: Qt Quick 2 employs a dedicated scene graph that is traversed and rendered using
    a graphics API, including OpenGL, OpenGL ES, Metal, Vulkan, or Direct 3D. Using
    a scene graph for graphics instead of traditional imperative painting systems
    (`QPainter` and similar), allows the scene to be rendered to be retained between
    frames and the entire set of primitives to render to be known before rendering
    begins. This allows for a variety of optimizations, including batch rendering
    to reduce state changes and discarding obscured primitives.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 2使用专用的场景图，使用图形API进行遍历和渲染，包括OpenGL、OpenGL ES、Metal、Vulkan或Direct 3D。使用场景图进行图形渲染而不是传统的命令式绘图系统（`QPainter`等），允许在渲染开始之前保留场景，并且在整个原语集合渲染之前就已知。这允许各种优化，包括批处理渲染以减少状态更改和丢弃被遮挡的原语。
- en: Let's assume a GUI comprises a list of 10 elements and each one has a different
    background color, text, and icon. This would give us 30 draw calls and an identical
    number of state changes using traditional drawing techniques. Contrarily, a scene
    graph reorganizes the primitives to render so that one call can draw all backgrounds,
    icons, and text, dropping the total number of draw calls to three. This type of
    batching and state change reduction can significantly improve performance on some
    hardware.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个GUI包括一个包含10个元素的列表，每个元素都有不同的背景颜色、文本和图标。这将给我们30个绘制调用和相同数量的状态更改，使用传统的绘图技术。相反，场景图重新组织原语以便绘制，这样一个调用就可以绘制所有的背景、图标和文本，将绘制调用的总数减少到三个。这种批处理和状态更改的减少可以显著提高一些硬件的性能。
- en: The scene graph is inextricably linked to Qt Quick 2 and cannot be used independently.
    The `QQuickWindow` class manages and renders the scene graph, and custom `Item`
    types can add their graphical primitives to the scene graph by calling `QQuickItem::updatePaintNode()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图与Qt Quick 2密不可分，不能独立使用。`QQuickWindow`类管理和渲染场景图，自定义`Item`类型可以通过调用`QQuickItem::updatePaintNode()`将它们的图形原语添加到场景图中。
- en: The scene graph represents an `Item` scene graphically and is a self-contained
    structure that has enough information to render all of the items. Once configured,
    it can be manipulated and rendered regardless of the state of the items. On several
    platforms, the scene graph is even rendered on a separate render thread while
    the GUI thread prepares the state for the next frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图以图形方式表示一个`Item`场景，并且是一个自包含的结构，具有足够的信息来渲染所有的项。一旦配置，它可以在项的状态不管如何被操作和渲染。在一些平台上，场景图甚至在单独的渲染线程上进行渲染，而GUI线程则准备下一帧的状态。
- en: In the following sections, we will dive deeper to improve our understanding
    of the scene graph structure and then learn the rendering mechanism. Further,
    we will be mixing the scene graph and the Native Graphics API while using Qt Quick
    3D.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨场景图结构，然后学习渲染机制。此外，在使用Qt Quick 3D时，我们将混合使用场景图和本机图形API。
- en: Qt Quick scene graph structure
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick场景图结构
- en: The scene graph is made up of a variety of predefined node types, each of which
    serves a specific purpose. Although we call it a scene graph, a node tree is a
    more precise definition. The tree is constructed from `QQuickItem` types in the
    QML scene, and the scene is then internally processed by a renderer, which draws
    the scene. There is no active drawing code in the nodes themselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图由各种预定义的节点类型组成，每种类型都有特定的用途。尽管我们称之为场景图，但节点树是更精确的定义。树是从QML场景中的`QQuickItem`类型构建的，然后场景由渲染器在内部处理，绘制场景。节点本身没有活动的绘制代码。
- en: Although the node tree is mostly built internally by the existing Qt Quick QML
    types, users can add complete subtrees with their own content, including subtrees
    that represent 3D models.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管节点树大多是由现有的Qt Quick QML类型在内部构建的，用户可以添加包括代表3D模型的完整子树在内的自己的内容。
- en: Node
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: Material
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料
- en: '`QSGGeometryNode` is the most important node for users. It creates customized
    graphics by specifying their geometry and material. The `QSGGeometry` class describes
    the shape or mesh of the graphical primitive and is used to define the geometry.
    It can define everything, be it a line, a rectangle, a polygon, a collection of
    disconnected rectangles, or a complex 3D mesh. The material defines how the pixels
    for a specific shape are filled. There can be multiple children for a node. The
    geometry nodes are rendered as per the child order and the parent nodes can be
    found behind their children.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSGGeometryNode`对用户来说是最重要的节点。它通过指定几何图形和材料来创建定制的图形。`QSGGeometry`类描述了图形原语的形状或网格，并用于定义几何图形。它可以定义一切，无论是线条、矩形、多边形、一组不连续的矩形，还是复杂的3D网格。材料定义了特定形状的像素如何填充。一个节点可以有多个子节点。几何节点按照子节点顺序进行渲染，父节点可以在其子节点后面找到。'
- en: The material describes how a geometry's interior in `QSGGeometryNode` is filled.
    It encapsulates graphics shaders for the vertex and fragment stages of the graphics
    pipeline and provides a great deal of flexibility in what can be done, even though
    the majority of Qt Quick items only use very basic materials such as solid color
    and texture fills.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 材料描述了`QSGGeometryNode`中几何图形的内部是如何填充的。它封装了用于图形管线的顶点和片段阶段的图形着色器，并提供了很大的灵活性，即使大多数Qt
    Quick项目只使用非常基本的材料，如纯色和纹理填充。
- en: The scene graph API is low-level and prioritizes performance over convenience.
    Creating the most basic custom geometries and materials from scratch requires
    a significant amount of code input. As a result, the API includes a few convenience
    classes that make the most commonly used custom nodes easily accessible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图API是低级的，优先考虑性能而不是便利性。从头开始创建最基本的自定义几何图形和材料需要大量的代码输入。因此，API包括一些方便的类，使最常用的自定义节点易于访问。
- en: In the next section, we will discuss how the rendering is done in a scene graph.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论场景图中的渲染是如何进行的。
- en: Rendering using a scene graph
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用场景图进行渲染
- en: A scene graph is internally rendered in the `QQuickWindow` class, and there
    is no public API to access it. However, there are a few points in the rendering
    pipeline where the user can insert application code. These points can be used
    for adding custom scene graph content or for inserting arbitrary rendering commands
    by calling the scene graph's graphics API (OpenGL, Vulkan, Metal, and so on) directly.
    The render loop determines the integration points.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图在`QQuickWindow`类中进行内部渲染，没有公共API可以访问它。但是，在渲染管道中有一些点，用户可以插入应用程序代码。这些点可以用于添加自定义场景图内容，或者通过直接调用场景图的图形API（OpenGL、Vulkan、Metal等）来插入任意的渲染命令。渲染循环确定了集成点。
- en: 'There are two types of render loops in a scene graph:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图中有两种类型的渲染循环：
- en: '`basic` is a single-threaded renderer.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic`是单线程渲染器。'
- en: '`threaded` is a multithread renderer that renders on a different thread.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded`是一个多线程渲染器，它在不同的线程上进行渲染。'
- en: Qt tries to select an appropriate render loop based on the platform and underlying
    graphics capabilities. When this is not sufficient, or during testing, the environment
    variable `QSG_RENDER_LOOP` can be used to force the use of a specific type of
    renderer loop. You can find the type of render loop in use by enabling the `qt.scenegraph.general`
    logging category.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Qt尝试根据平台和底层图形能力选择适当的渲染循环。当这不够用时，或者在测试期间，可以使用环境变量`QSG_RENDER_LOOP`来强制使用特定类型的渲染器循环。您可以通过启用`qt.scenegraph.general`日志类别来查找正在使用的渲染循环类型。
- en: In most applications that use a scene graph, the rendering takes place on a
    separate render thread. This is done to improve multi-core processor parallelism
    and make better use of stall times such as waiting for a blocking swap buffer
    call. This provides significant performance improvements, but it limits where
    and when interactions with the scene graph can occur.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数使用场景图的应用程序中，渲染是在单独的渲染线程上进行的。这是为了提高多核处理器的并行性，并更好地利用等待阻塞交换缓冲调用等停顿时间。这提供了显著的性能改进，但它限制了与场景图的交互发生的位置和时间。
- en: 'The following diagram depicts how a frame is rendered using the threaded render
    loop and OpenGL. Apart from the OpenGL context specifics, the steps are the same
    for other graphics APIs as well:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了如何使用线程化渲染循环和OpenGL渲染帧。除了OpenGL上下文的特定之外，其他图形API的步骤也是相同的：
- en: '![Figure 8.5 – Rendering sequence followed in a threaded render loop'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 在线程化渲染循环中遵循的渲染顺序'
- en: '](img/Figure_8.5_B16231.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16231.jpg)'
- en: Figure 8.5 – Rendering sequence followed in a threaded render loop
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 在线程化渲染循环中遵循的渲染顺序
- en: Currently, the threaded renderer is used by default on Windows with Direct3D
    11 or higher. You can force the use of the threaded renderer by setting `QSG_RENDER_LOOP`
    to `threaded` in the environment. However, the threaded render loop depends on
    the graphics API implementation for throttling. When building with Xcode 10 or
    later on macOS and OpenGL, the threaded render loop is not supported. For Metal,
    there are no such limitations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Windows上默认使用Direct3D 11或更高版本的线程化渲染器。您可以通过将环境中的`QSG_RENDER_LOOP`设置为`threaded`来强制使用线程化渲染器。但是，线程化渲染循环取决于图形API实现的节流。在macOS上使用Xcode
    10或更高版本和OpenGL构建时，不支持线程化渲染循环。对于Metal，没有这样的限制。
- en: 'If your system is not capable of providing Vsync-based throttling, then use
    the basic render loop by setting the environment variable `QSG_RENDER_LOOP` to
    `basic`. The following steps describe how a frame is rendered in a basic or non-threaded
    render loop:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统无法提供基于Vsync的节流功能，则通过将环境变量`QSG_RENDER_LOOP`设置为`basic`来使用基本渲染循环。以下步骤描述了在基本或非线程化渲染循环中如何渲染帧：
- en: '![Figure 8.6 – Rendering sequence followed in a non-threaded render loop'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 非线程化渲染循环中的渲染顺序'
- en: '](img/Figure_8.6_B16231.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B16231.jpg)'
- en: Figure 8.6 – Rendering sequence followed in a non-threaded render loop
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 非线程化渲染循环中的渲染顺序
- en: When the platform's standard OpenGL library is not used, then by default the
    non-threaded render loop is used on OpenGL-enabled platforms. This is primarily
    a preventive strategy for the latter because not all the combinations of OpenGL
    drivers and windowing systems have been verified. You may consider writing your
    code as if you are using the threaded renderer even if you are using the non-threaded
    render loop because otherwise, your code won't be portable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当平台的标准OpenGL库未被使用时，默认情况下在启用OpenGL的平台上使用非线程化渲染循环。这主要是为后者制定的预防策略，因为并未验证所有OpenGL驱动程序和窗口系统的组合。即使使用非线程化渲染循环，您可能需要将代码编写为使用线程化渲染器，否则您的代码将无法移植。
- en: 'To find further information on the workings of the scene graph renderer, you
    may visit the following link:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关场景图渲染器工作原理的信息，请访问以下链接：
- en: https://doc-snapshots.qt.io/qt6-dev/qtquick-visualcanvas-scenegraph.html
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc-snapshots.qt.io/qt6-dev/qtquick-visualcanvas-scenegraph.html
- en: In this section, you got to know about the rendering mechanism behind the scene
    graph. In the next section, we will discuss how to mix a scene graph with the
    Native Graphics API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了场景图背后的渲染机制。在下一节中，我们将讨论如何将场景图与原生图形API混合使用。
- en: Using a scene graph with the Native Graphics
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生图形的场景图
- en: The scene graph provides two methods for mixing the scene graph with the Native
    Graphics APIs. The first approach is by directly issuing commands to the underlying
    graphics engine, and the second approach is by generating a textured node in the
    scene graph. Applications can make OpenGL calls directly into the same context
    as the scene graph by connecting to the `QQuickWindow::beforeRendering()` and
    `QQuickWindow::afterRendering()` signals. Applications using APIs such as Metal
    or Vulkan can request native objects, such as the scene graph's command buffer,
    through `QSGRendererInterface`. Then the user can render content either within
    or outside of the Qt Quick scene. The advantage of mixing the two is that no additional
    framebuffer or memory is required to execute the rendering, and a potentially
    costly texturing step is avoided. The disadvantage is that Qt Quick chooses when
    to invoke the signals. The OpenGL engine is only allowed to draw during that time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图提供了两种方法来将场景图与原生图形API混合。第一种方法是直接向底层图形引擎发出命令，第二种方法是在场景图中生成纹理节点。应用程序可以通过连接到`QQuickWindow::beforeRendering()`和`QQuickWindow::afterRendering()`信号来直接在与场景图相同的上下文中进行OpenGL调用。使用Metal或Vulkan等API的应用程序可以通过`QSGRendererInterface`请求原生对象，例如场景图的命令缓冲区。然后用户可以在Qt
    Quick场景内部或外部渲染内容。混合两者的优势是执行渲染不需要额外的帧缓冲区或内存，并且可以避免潜在的昂贵的纹理步骤。缺点是Qt Quick选择何时调用信号。OpenGL引擎只允许在那个时间绘制。
- en: Beginning with Qt 6.0, direct use of the Native Graphics API must be invoked
    before the calls to the `QQuickWindow::beginExternalCommands()` and `QQuickWindow::endExternalCommands()`
    functions. This approach is identical to `QPainter::beginNativePainting()`, and
    it serves the same purpose. It allows the scene graph to identify any cached state
    or assumptions about the state inside the presently recorded render pass. If anything
    exists, then it becomes invalid as the code may have changed it by interacting
    directly with the Native Graphics API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从Qt 6.0开始，在调用`QQuickWindow::beginExternalCommands()`和`QQuickWindow::endExternalCommands()`函数之前必须调用原生图形API的直接使用。这种方法与`QPainter::beginNativePainting()`相同，目的也相同。它允许场景图识别当前记录的渲染通道内的任何缓存状态或对状态的假设。如果存在任何内容，则会因为代码可能直接与原生图形API交互而使其无效。
- en: Important note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When combining OpenGL content with scene graph rendering, it is crucial that
    the application doesn't leave the OpenGL context with buffers bound, attributes
    enabled, or specific values in the stencil buffer, or something similar. If you
    forget this, then you will see unexpected behavior. The custom rendering code
    must be thread-aware.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在将OpenGL内容与场景图渲染相结合时，应用程序不能使OpenGL上下文保持绑定缓冲区、启用属性或模板缓冲区中的特定值等。如果忘记了这一点，就会看到意外的行为。自定义渲染代码必须具有线程意识。
- en: The scene graph also provides support with several logging categories. These
    are useful in finding the root cause of performance issues and bugs. The scene
    graph features an adaptation layer in addition to the public API. The layer allows
    you to implement certain hardware-specific adaptations. It has an internal and
    proprietary plugin API that allows hardware adaption teams to get the most out
    of their hardware.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图还提供了几个日志类别的支持。这些对于查找性能问题和错误的根本原因非常有用。场景图除了公共 API 外还具有适配层。该层允许您实现某些特定于硬件的适配。它具有内部和专有的插件
    API，允许硬件适配团队充分利用其硬件。
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are observing graphics-related issues or to find which type of rendering
    loop or graphics API is currently used, start the application by setting the environment
    variable `QSG_INFO` to `1` or by enabling at least `qt.scenegraph.general` and
    `qt.rhi.*`. During initialization, this will print some crucial information required
    to debug the graphics issues.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察到与图形相关的问题，或者想要找出当前使用的渲染循环或图形 API 的类型，请通过将环境变量`QSG_INFO`设置为`1`或至少启用`qt.scenegraph.general`和`qt.rhi.*`来启动应用程序。在初始化期间，这将打印一些关键信息，以便调试图形问题。
- en: 3D graphics with Qt Quick 3D
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Qt Quick 3D 进行 3D 图形
- en: '**Qt Quick 3D** is a Qt Quick add-on that provides a high-level API for creating
    3D content and 3D user interfaces. It extends the Qt Quick scene graph, allowing
    you to integrate 3D content into 2D Qt Quick applications. Qt Quick 3D is a high-level
    API for creating 3D content and 3D user interfaces on the Qt Quick platform. Rather
    than relying on an external engine, which introduces syncing issues and additional
    layers of abstraction, we provide spatial content extensions to the existing Qt
    Quick scene graph, as well as a renderer for that extended scene graph. It is
    also possible to mix Qt Quick 2D and 3D content when using the spatial scene graph.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt Quick 3D** 是 Qt Quick 的附加组件，提供了用于创建 3D 内容和 3D 用户界面的高级 API。它扩展了 Qt Quick
    场景图，允许您将 3D 内容集成到 2D Qt Quick 应用程序中。Qt Quick 3D 是用于在 Qt Quick 平台上创建 3D 内容和 3D
    用户界面的高级 API。我们提供了空间内容扩展到现有的 Qt Quick 场景图，以及该扩展场景图的渲染器，而不是依赖外部引擎，这会引入同步问题和额外的抽象层。在使用空间场景图时，也可以混合使用
    Qt Quick 2D 和 3D 内容。'
- en: 'The following `import` statement in your `.qml` file can be used to import
    the QML types into your application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`.qml`文件中的以下`import`语句可用于将 QML 类型导入您的应用程序：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition to the base Qt Quick 3D model, additional functionality is provided
    by the following module imports:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 Qt Quick 3D 模型外，以下模块导入还提供了其他功能：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Qt Quick 3D is available for purchase under a commercial license. When building
    from source, make sure the modules and tools from the `qtdeclarative` and `qtshadertools`
    repositories are built first, as Qt Quick 3D cannot be used without them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 3D 可以在商业许可下购买。在构建源代码时，请确保首先构建`qtdeclarative`和`qtshadertools`存储库中的模块和工具，因为没有它们，Qt
    Quick 3D 无法使用。
- en: Let's discuss shader tools and shader effects in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节讨论着色器工具和着色器效果。
- en: Shader effects
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器效果
- en: For importing shaders into 3D scenes, Qt Quick 3D has its own framework. **Shader
    effects** enable the full, raw power of a graphics processing unit to be directly
    utilized via vertex and fragment shaders. Too many shader effects can result in
    increased power consumption and sometimes slow performance, but when used sparingly
    and carefully, a shader can allow complex and visually appealing effects to be
    applied to a visual object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将着色器导入到 3D 场景中，Qt Quick 3D 有自己的框架。**着色器效果**使得可以通过顶点和片段着色器直接利用图形处理单元的全部原始能力。使用过多的着色器效果可能会导致增加的功耗和有时的性能下降，但是当谨慎使用时，着色器可以允许将复杂和视觉上吸引人的效果应用于视觉对象。
- en: Both shaders are bound to the `vertexShader` and `fragmentShader` properties.
    Every shader's code requires a `main(){…}` function, which is executed by the
    GPU. A variable with the prefix `qt_` is provided by Qt. To understand the variables
    in shader code, have a look at the OpenGL API reference document.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个着色器都绑定到`vertexShader`和`fragmentShader`属性。每个着色器的代码都需要一个由 GPU 执行的`main(){...}`函数。以`qt_`为前缀的变量由
    Qt 提供。要了解着色器代码中的变量，请查看 OpenGL API 参考文档。
- en: 'When working with `ShaderEffect` or subclassing `QSGMaterialShader` in QML
    applications using Qt Quick, the application must provide a baked shader pack
    in the form of a `.qsb` file. The Qt Shader Tools module includes a command-line
    tool called `.qsb` files. The `ShaderEffect` QML type and `QSGMaterial` subclasses,
    in particular, can make use of qsb output. It can also be used to inspect the
    contents of a `.qsb` package. The input file extension is used to determine the
    type of shader. As a result, the extension has to be one of the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Qt Quick 的 QML 应用程序中使用`ShaderEffect`或对`QSGMaterialShader`进行子类化时，应用程序必须提供一个`.qsb`文件形式的烘焙着色器包。Qt
    Shader Tools 模块包括一个名为`.qsb`文件的命令行工具。特别是`ShaderEffect` QML 类型和`QSGMaterial`子类可以使用
    qsb 输出。它还可以用于检查`.qsb`包的内容。输入文件扩展名用于确定着色器的类型。因此，扩展名必须是以下之一：
- en: '`.vert` – Vertex shaders'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.vert` – 顶点着色器'
- en: '`.frag` – Fragment shaders'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.frag` – 片段着色器'
- en: '`.comp` – Compute shaders'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.comp` – 计算着色器'
- en: 'The example assumes `myeffect.vert` and `myeffect.frag` contain Vulkan-style
    GLSL code, processed by the `qsb` tool in order to generate the `.qsb` files.
    Now we convert that Vulkan-Style shader with `qsb` via the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '该示例假定`myeffect.vert`和`myeffect.frag`包含 Vulkan 风格的 GLSL 代码，通过`qsb`工具处理以生成`.qsb`文件。现在，通过以下命令将该
    Vulkan 风格着色器用`qsb`进行转换： '
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see an example of using the preceding syntax in the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下命令中看到使用上述语法的示例：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is not necessary to specify both `vertexShader` and `fragmentShader`. Many
    `ShaderEffect` implementations will only provide a fragment shader in practice,
    instead of relying on the built-in vertex shader.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要同时指定`vertexShader`和`fragmentShader`。实际上，许多`ShaderEffect`实现只会提供片段着色器，而不是依赖内置的顶点着色器。
- en: 'You can learn more about the shader tools at the following link:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解有关着色器工具的更多信息：
- en: https://doc.qt.io/qt-6/qtshadertools-qsb.html
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc.qt.io/qt-6/qtshadertools-qsb.html
- en: 'Let''s use shader effects in an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个示例中使用着色器效果：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we arranged two images in a row. The first one is
    the original image and the second one is the image with the shader effect.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将两个图像排成一行。第一个是原始图像，第二个是带有着色器效果的图像。
- en: In this section, you learned about different types of shader effects in Qt Quick
    and how to use the `qsb` tool to create compatible fragment files. In the next
    section, you will learn how to draw using `Canvas`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您了解了Qt Quick中不同类型的着色器效果以及如何使用`qsb`工具创建兼容的片段文件。在下一部分，您将学习如何使用`Canvas`进行绘制。
- en: Using the Canvas QML type
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas QML类型
- en: '`Canvas` output as an image. It provides a 2D canvas that uses a `Context2D`
    object for drawing and implements a paint signal handler.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`输出为图像。它提供了一个使用`Context2D`对象进行绘制并实现绘制信号处理程序的2D画布。 '
- en: 'Let''s have a look at the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, first, we got the context from `getContext("2d")`.
    Then we drew a rectangle with a red border. The output looks as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，首先我们从`getContext("2d")`获取了上下文。然后我们用红色边框绘制了一个矩形。输出如下所示：
- en: '![Figure 8.7 – Output of sample application using Canvas to draw a rectangle'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 使用Canvas绘制矩形的示例应用程序的输出'
- en: '](img/Figure_8.7_B16231.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B16231.jpg)'
- en: Figure 8.7 – Output of sample application using Canvas to draw a rectangle
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 使用Canvas绘制矩形的示例应用程序的输出
- en: In this section, you got familiar with drawing using `Canvas`. In the next section,
    we will discuss particle systems in Qt Quick.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你已经熟悉了使用`Canvas`进行绘制。在下一部分，我们将讨论Qt Quick中的粒子系统。
- en: Understanding particle simulations
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解粒子模拟
- en: Using particle systems, you can simulate effects such as explosions, fireworks,
    smoke, fog, and wind. Qt Quick includes a particle system that enables these types
    of complex, 2D simulations, including support for environmental effects such as
    gravity and turbulence. Particles are most commonly used in games to add subtle
    and visually appealing effects to currently selected items in lists or activity
    notifiers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用粒子系统，您可以模拟爆炸、烟花、烟雾、雾气和风等效果。Qt Quick包括一个粒子系统，可以实现这些复杂的2D模拟，包括对重力和湍流等环境效果的支持。粒子最常用于游戏中，以为当前选定的列表项或活动通知器添加微妙且视觉上吸引人的效果。
- en: '`ParticleSystem`, `Painters`, `Emitters`, and `Affectors` are the four main
    QML types in this particle system. The `ParticleSystem` system includes painter,
    emitter, and affector types. The `ParticleSystem` type connects all of these types
    and manages the shared timeline. They must all share the same `ParticleSystem`
    in order to interact. Subject to this constraint, you may have as many particle
    systems as you want, so the logical separation is to have one `ParticleSystem`
    type for all the types with which you want to interact, or just one if the number
    of types is small and easily controlled.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`、`Painters`、`Emitters`和`Affectors`是这个粒子系统中的四种主要QML类型。`ParticleSystem`系统包括painter、emitter和affector类型。`ParticleSystem`类型连接所有这些类型并管理共享的时间轴。它们必须共享相同的`ParticleSystem`才能相互交互。在此约束条件下，您可以拥有尽可能多的粒子系统，因此逻辑上的分离是为所有要交互的类型使用一个`ParticleSystem`类型，或者如果类型数量较少且易于控制，则只使用一个。'
- en: 'To use `ParticleSystem`, import the module with the following line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ParticleSystem`，请使用以下行导入模块：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The emitter produces particles. The emitter can no longer change a particle
    after it has been emitted. You can use `affectors` type to influence particles
    after they have been emitted.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器产生粒子。发射器在发射后不能再改变粒子。您可以使用`affectors`类型来影响发射后的粒子。
- en: 'Each type of `affector` affects particles differently:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每种`affector`类型对粒子的影响都不同：
- en: '`Age`: Modifies the particle''s lifespan'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Age`：修改粒子的寿命'
- en: '`Attractor`: Draws particles towards a certain location'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attractor`：将粒子吸引到特定位置'
- en: '`Friction`: Slows movement proportionate to the particle''s present velocity'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摩擦`：根据粒子当前速度减慢移动'
- en: '`Gravity`: Sets acceleration at an angle'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重力`：设置一个角度上的加速度'
- en: '`Turbulence`: Liquid-like behavior based on a noise image'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`湍流`：基于噪声图像的液体行为'
- en: '`Wander`: Changes the route randomly'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wander`：随机改变路线'
- en: '`GroupGoal`: Changes the state of a particle group'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupGoal`：改变粒子组的状态'
- en: '`SpriteGoal`: Changes the state of a sprite particle'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpriteGoal`：改变精灵粒子的状态'
- en: 'Let''s understand the use of `ParticleSystem` with the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例了解`ParticleSystem`的用法：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we have used the Qt logo, which is emitting particles
    around it. We have created an instance of `ImageParticle` that creates particles
    that are emitted by `Emitter`. The `AngleDirection` type is used to decide the
    angle and direction of particle emission. Since we want the particles to be emitted
    around the logo, we have used `360` for both attributes. The output of the preceding
    example is shown in *Figure 8.8*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了Qt标志，它在周围发射粒子。我们创建了一个`ImageParticle`的实例，它创建了由`Emitter`发射的粒子。`AngleDirection`类型用于决定粒子发射的角度和方向。由于我们希望粒子在标志周围发射，所以我们为两个属性都使用了`360`。前面示例的输出如*图8.8*所示：
- en: '![Figure 8.8 – Output of the above particle system example'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 上述粒子系统示例的输出'
- en: '](img/Figure_8.8_B16231.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B16231.jpg)'
- en: Figure 8.8 – Output of the above particle system example
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 上述粒子系统示例的输出
- en: 'You can explore more about these QML types on the following website:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网站上了解更多关于这些QML类型的信息：
- en: https://qmlbook.github.io/
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: https://qmlbook.github.io/
- en: In this section, we discussed different types of drawing mechanisms and components
    in Qt Quick. In the next section, we will learn how to do animation in Qt Widgets.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们讨论了Qt Quick中不同类型的绘制机制和组件。在下一部分，我们将学习如何在Qt Widgets中进行动画。
- en: Animation in Qt Widgets
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Widgets中的动画
- en: The animation framework simplifies the process of animating a GUI element by
    allowing its properties to be animated. `QPropertyAnimation` class, is one of
    the more common ways to animate a GUI element. This class is part of the animation
    framework, and it uses Qt's timer system to change the properties of a GUI element
    over a specified time period.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 动画框架通过允许动画化GUI元素的属性来简化动画GUI元素的过程。`QPropertyAnimation`类是动画GUI元素的更常见的方式之一。这个类是动画框架的一部分，它使用Qt的定时器系统在指定的时间段内改变GUI元素的属性。
- en: To create animations for our GUI application, Qt provides us with several subsystems,
    including a timer, timeline, animation framework, state machine framework, and
    the Graphics View framework.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的GUI应用程序创建动画，Qt为我们提供了几个子系统，包括定时器、时间轴、动画框架、状态机框架和图形视图框架。
- en: 'Let''s discuss how to use property animation with `QPushButton` in the following
    code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何在以下代码中使用`QPushButton`的属性动画：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code snippet, we animated a push button from one position to
    another position and changed the button size. You can add easing curve to control
    the animation simply by adding it to the property animation before calling the
    `start()` function. You can also experiment with different types of easing curves
    to see which one works best for you.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将一个按钮从一个位置动画到另一个位置，并改变了按钮的大小。您可以通过在调用`start()`函数之前将缓动曲线添加到属性动画中来控制动画。您还可以尝试不同类型的缓动曲线，看哪种对您最有效。
- en: Property animations and animation groups are both inherited from the `QAbstractAnimator`
    class. Hence, you can add one animation group to another to create a more complex,
    nested animation group. Qt currently provides two types of animation group classes,
    `QParallelAnimationGroup` and `QSequentialAnimationGroup`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 属性动画和动画组都是从`QAbstractAnimator`类继承的。因此，您可以将一个动画组添加到另一个动画组中，创建一个更复杂的嵌套动画组。Qt目前提供两种类型的动画组类，`QParallelAnimationGroup`和`QSequentialAnimationGroup`。
- en: 'Let''s use the `QSequentialAnimationGroup` group to manage the states of the
    animations within it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`QSequentialAnimationGroup`组来管理其中的动画状态：
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can explore more about Qt''s animation framework at the following link:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于Qt的动画框架：
- en: https://doc.qt.io/qt-6/animation-overview.html
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc.qt.io/qt-6/animation-overview.html
- en: In this section, we discussed animation in Qt Widgets. In the next section,
    you will learn how to do animation in Qt Quick.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Qt Widgets中的动画。在下一节中，您将学习如何在Qt Quick中进行动画。
- en: Animation and transitions in Qt Quick
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick中的动画和过渡
- en: In this section, you will learn how to create animation and add transitions
    in Qt Quick. To create an animation, you need to choose a proper animation type
    for the type of the property that is to be animated and then apply the animation
    for the required behavior.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在Qt Quick中创建动画并添加过渡效果。要创建动画，您需要为要动画化的属性类型选择适当的动画类型，然后将动画应用于所需的行为。
- en: 'Qt Quick has different types of animations, such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick有不同类型的动画，例如以下：
- en: '`Animator`: It is a special type of animation that operates directly on Qt
    Quick''s scene graph.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animator`：它是一种特殊类型的动画，直接作用于Qt Quick的场景图。'
- en: '`AnchorAnimation`: It is used for animating an anchor change.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnchorAnimation`：用于动画化锚点更改。'
- en: '`ParallelAnimation`: It runs animations in parallel.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelAnimation`：并行运行动画。'
- en: '`ParentAnimation`: It is used for animating a parent change.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParentAnimation`：用于动画化父级更改。'
- en: '`PathAnimation`: It animates an item along a path.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathAnimation`：沿着路径动画化一个项目。'
- en: '`PauseAnimation`: It enables pauses during animations.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PauseAnimation`：它允许在动画期间暂停。'
- en: '`PropertyAnimation`: It animates changes in property values.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropertyAnimation`：它动画化属性值的变化。'
- en: '`SequentialAnimation`: It runs animations sequentially.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SequentialAnimation`：按顺序运行动画。'
- en: '`ScriptAction`: During an animation, it allows JavaScript to be executed.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScriptAction`：在动画期间，允许执行JavaScript。'
- en: '`PropertyAction`: It can change a property immediately during an animation,
    without the need to animate a property change.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropertyAction`：它可以在动画期间立即更改属性，而无需动画化属性更改。'
- en: '*Figure 8.9* shows the hierarchy of animation classes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.9*显示了动画类的层次结构：'
- en: '![Figure 8.9 – The hierarchy of animation classes in Qt Quick'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 - Qt Quick中动画类的层次结构'
- en: '](img/Figure_8.9_B16231.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B16231.jpg)'
- en: Figure 8.9 – The hierarchy of animation classes in Qt Quick
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - Qt Quick中动画类的层次结构
- en: '`PropertyAnimation` provides a way to animate changes to a property''s value.
    Different subclasses of `PropertyAnimation` are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyAnimation`提供了一种方式来动画化属性值的变化。`PropertyAnimation`的不同子类如下：'
- en: '`ColorAnimation`: Animates changes in color values'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorAnimation`：动画化颜色值的变化'
- en: '`NumberAnimation`: Animates changes in `qreal`-type values'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberAnimation`：动画化`qreal`类型值的变化'
- en: '`RotationAnimation`: Animates changes in rotation values'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationAnimation`：动画化旋转值的变化'
- en: '`Vector3dAnimation`: Animates changes in `QVector3d` values'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3dAnimation`：动画化`QVector3d`值的变化'
- en: 'It can be used to define animations in several ways:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以多种方式定义动画：
- en: In a `Transition`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Transition`中
- en: In a `Behavior`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Behavior`中
- en: As a `property`
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`property`
- en: In a `signal` handler
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`signal`处理程序中
- en: Standalone
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的
- en: 'Property values are animated by applying animation types to them. To create
    smooth transitions, animation types will interpolate property values. State transitions
    can also assign animations to state changes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用动画类型来动画化属性值。为了创建平滑的过渡效果，动画类型将插值属性值。状态转换也可以将动画分配给状态变化：
- en: '`SmoothedAnimation`: It is a specialized `NumberAnimation` subclass. In animation,
    when the target value is changed, `SmoothAnimation` ensures smooth changes.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SmoothedAnimation`：它是一个专门的`NumberAnimation`子类。在动画中，当目标值发生变化时，`SmoothAnimation`确保平滑变化。'
- en: '`SpringAnimation`: With its specialized attributes including mass, damping,
    and epsilon, it provides a spring-like animation.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpringAnimation`：具有质量、阻尼和epsilon等专门属性，提供弹簧式动画。'
- en: 'Animation can be set for an object in different ways:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过不同方式为对象设置动画：
- en: Direct property animation
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接属性动画
- en: Predefined targets and properties
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义的目标和属性
- en: Animation as behaviors
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画作为行为
- en: Transitions during state changes
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化期间的过渡
- en: Animations are created by applying animation objects to property values in order
    to change the properties gradually over time. Smooth movements are used in these
    property animations by interpolating values between property value changes. Property
    animations allow for different interpolations and timing controls via easing curves.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是通过将动画对象应用于属性值来逐渐改变属性，从而创建的。通过在属性值变化之间插值来实现平滑的动作。属性动画允许通过缓动曲线进行不同的插值和时间控制。
- en: 'The following code snippet demonstrates two `PropertyAnimation` objects using
    predefined properties:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了使用预定义属性的两个“PropertyAnimation”对象：
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, the animation will begin as soon as the `Rectangle`
    is loaded and is applied to its `x` and `y` values automatically. Here, we have
    used the `<AnimationType> on <Property>` syntax. Hence, it is not required to
    set the target and the property values to `x` and `y`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，动画将在“Rectangle”加载后立即开始，并自动应用于其“x”和“y”值。在这里，我们使用了“<AnimationType> on
    <Property>”语法。因此，不需要将目标和属性值设置为“x”和“y”。
- en: Animations may be shown sequentially or parallelly. While sequential animations
    play a group of animations serially, parallel animations play a group of animations
    at the same time. Therefore, when animations are grouped inside a `SequentialAnimation`
    or a `ParallelAnimation`, they will be played sequentially or parallelly. `SequentialAnimation`
    can also be used for playing `Transition` animations since transition animations
    are automatically played in parallel. You can group the animations to ensure that
    all animations within a group are applied to the same property.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可以按顺序或并行显示。顺序动画依次播放一组动画，而并行动画同时播放一组动画。因此，当动画被分组在“SequentialAnimation”或“ParallelAnimation”中时，它们将被顺序或并行播放。“SequentialAnimation”也可以用于播放“Transition”动画，因为过渡动画会自动并行播放。您可以将动画分组以确保组内的所有动画都应用于同一属性。
- en: 'Let''s use `SequentialAnimation` to animate the rectangle''s `color` in the
    following example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的示例中使用“SequentialAnimation”来对矩形的“color”进行动画处理：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we have used `SequentialAnimation` on the `color`
    property using the `<AnimationType> on <Property>` syntax. As a result, the child
    `ColorAnimation` objects are automatically added to this property, and no `target`
    or `property` animation values are needed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了“<AnimationType> on <Property>”语法在“color”属性上使用了“SequentialAnimation”。因此，子“ColorAnimation”对象会自动添加到此属性，不需要设置“target”或“property”动画值。
- en: You can use `Behavior` animations to set the default property animations. Animations
    specified in `Behavior` types are applied to the property and animate any property
    value changes. To intentionally enable or disable the behavior animations, you
    can use the `enabled` property. You can use several methods to assign behavior
    animations to properties. One of the methods is the `Behavior on <property>` declaration.
    It conveniently assigns a behavior animation onto a property.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用“Behavior”动画来设置默认的属性动画。在“Behavior”类型中指定的动画将应用于属性，并使任何属性值的变化发生动画。要有意地启用或禁用行为动画，可以使用“enabled”属性。您可以使用多种方法将行为动画分配给属性。其中一种方法是“Behavior
    on <property>”声明。它可以方便地将行为动画分配到属性上。
- en: '`Animator` types are distinct from normal `Animation` types. Let''s create
    a simple example where we rotate an image using an `Animator`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: “Animator”类型与普通的“Animation”类型不同。让我们创建一个简单的例子，通过使用“Animator”来旋转图像：
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we have used the `RotationAnimator` type, which is
    used to animate the rotation of an `Image` QML type.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了“RotationAnimator”类型，用于动画处理“Image”QML类型的旋转。
- en: In this section, we discussed different types of animations in Qt Quick and
    created several examples. In the next section, we will discuss how to control
    animations.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Qt Quick中不同类型的动画，并创建了几个示例。在下一节中，我们将讨论如何控制动画。
- en: Controlling animations
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制动画
- en: '`Animation` type is the ancestor of all animation types. This type does not
    allow the creation of `Animation` objects. It equips a user with the necessary
    properties and methods to use animation types. All animation types consist of
    `start()`, `stop()`, `resume()`, `pause()`, `restart()`, and `complete()`, and
    they control how animations are executed.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: “Animation”类型是所有动画类型的祖先。这种类型不允许创建“Animation”对象。它为用户提供了使用动画类型所需的属性和方法。所有动画类型都包括“start()”、“stop()”、“resume()”、“pause()”、“restart()”和“complete()”，它们控制动画的执行方式。
- en: The animation's interpolation between the start and end values is defined by
    the easing curves. Different easing curves may extend beyond the defined interpolation
    range. The easing curves make it easier to create animation effects such as bounce,
    acceleration, deceleration, and cyclical animations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 动画在开始和结束值之间的插值由缓动曲线定义。不同的缓动曲线可能超出定义的插值范围。缓动曲线使得更容易创建动画效果，如弹跳、加速、减速和循环动画。
- en: In a QML object, each property animation may have a distinct easing curve. The
    curve can be controlled with various parameters and some of these parameters are
    unique to a particular curve. Visit the easing documentation for more information
    on easing curves.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML对象中，每个属性动画可能具有不同的缓动曲线。曲线可以通过各种参数进行控制，其中一些参数是特定于特定曲线的。请访问缓动文档以获取有关缓动曲线的更多信息。
- en: In this section, you learned about the way to control animations in Qt Quick.
    In the next section, you will learn how to use states and transitions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了如何在Qt Quick中控制动画。在下一节中，您将学习如何使用状态和过渡。
- en: States, state machine, and transitions in Qt Quick
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick中的状态、状态机和转换
- en: Qt Quick states are property configurations in which a property's value can
    change to reflect different states. State changes cause abrupt changes in property;
    animations smooth transitions to create visually appealing state changes. Types
    for creating and executing state graphs in QML are provided by the Declarative
    State Machine Framework. Consider using the QML states and transitions for user
    interfaces with multiple visual states that are independent of the application's
    logical state.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick状态是属性配置，其中属性的值可以更改以反映不同的状态。状态更改会导致属性的突然变化；动画平滑过渡，以创建视觉上吸引人的状态更改。声明性状态机框架提供了用于在QML中创建和执行状态图的类型。考虑使用QML状态和转换来创建用户界面，其中多个视觉状态独立于应用程序的逻辑状态。
- en: 'You can import the state machine module and the QML types into your application
    by adding the following statement:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加以下语句将状态机模块和QML类型导入到您的应用程序中：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Please note that there are two ways to define the states in QML. One is provided
    by `QtQuick` and the other by the `QtQml.StateMachine` module.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在QML中有两种定义状态的方式。一种由`QtQuick`提供，另一种由`QtQml.StateMachine`模块提供。
- en: Important note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While using `QtQuick` and `QtQml.StateMachine` in a single QML file, make sure
    to import `QtQml.StateMachine` after `QtQuick`. In this approach, the `State`
    type is provided by the Declarative State Machine Framework, not by `QtQuick`.
    To avoid any ambiguity with QtQuick's `State` item, you can import `QtQml.StateMachine`
    into a different namespace.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个QML文件中使用`QtQuick`和`QtQml.StateMachine`时，请确保在`QtQuick`之后导入`QtQml.StateMachine`。在这种方法中，`State`类型由声明性状态机框架提供，而不是由`QtQuick`提供。为了避免与QtQuick的`State`项产生任何歧义，您可以将`QtQml.StateMachine`导入到不同的命名空间中。
- en: To interpolate property changes caused by state changes, the `Transition` type
    can include animation types. Bind the transition to the `transitions` property
    to assign it to an object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了插值由状态更改引起的属性更改，`Transition`类型可以包括动画类型。将转换绑定到`transitions`属性以将其分配给对象。
- en: 'A button can have two states: `pressed` and `released`. For each state, we
    can assign a different property configuration. A transition would animate the
    transition from `pressed` to `released`. Similarly, there would be animation when
    switching from the `released` to the `pressed` state.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮可以有两种状态：`pressed`和`released`。对于每个状态，我们可以分配不同的属性配置。转换将动画化从`pressed`到`released`的过渡。同样，在从`released`到`pressed`状态切换时也会有动画。
- en: Let's have a look at the following example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。
- en: 'Create a circular LED using the `Rectangle` QML type and add a `MouseArea`
    to it. Assign the default state as `OFF` and the color as `green`. On mouse press,
    we want to change the LED color to `red` and once the mouse is released, the LED
    becomes `green` again:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Rectangle` QML类型创建一个圆形LED，并向其添加`MouseArea`。将默认状态分配为`OFF`，颜色为`绿色`。在鼠标按下时，我们希望将LED颜色更改为`红色`，一旦释放鼠标，LED再次变为`绿色`：
- en: '[PRE22]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, define the states. In this example, we have two states, `ON` and `OFF`.
    Here, we are manipulating the `color` property based on the state change:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义状态。在此示例中，我们有两个状态，`ON`和`OFF`。在这里，我们根据状态更改来操作`color`属性：
- en: '[PRE23]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can add an animation to the transitions. Let''s add `ColorAnimation` to
    the transition to make it smooth and attractive:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向转换添加动画。让我们向转换添加`ColorAnimation`，使其平滑而有吸引力：
- en: '[PRE24]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we have used two states, `ON` and `OFF`. We have used
    `MouseArea` to change the states based on mouse press and release events. When
    the state is `ON`, the rectangle color changes to `red`, and when it is `OFF`,
    the color changes to `green`. Here, we have also used `Transition` to switch between
    the states.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用了两个状态，`ON`和`OFF`。我们使用`MouseArea`根据鼠标按下和释放事件来更改状态。当状态为`ON`时，矩形颜色变为`红色`，当状态为`OFF`时，颜色变为`绿色`。在这里，我们还使用了`Transition`来在状态之间切换。
- en: 'When the `to` and `from` properties are bound to the state''s name, the transition
    will be associated with the state change. For simple or symmetric transitions,
    setting the `to` property to the wild card symbol `"*"` implies that the transition
    applies to any state change:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当`to`和`from`属性绑定到状态的名称时，转换将与状态更改相关联。对于简单或对称的转换，将`to`属性设置为通配符符号`"*"`意味着转换适用于任何状态更改：
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can explore more about the State Machine QML API at the following link:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解有关状态机QML API的更多信息：
- en: https://doc.qt.io/qt-6/qmlstatemachine-qml-guide.html
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: https://doc.qt.io/qt-6/qmlstatemachine-qml-guide.html
- en: In this section, you learned about the state machine in Qt Quick. In the next
    section, you will learn how to use the state machine in Qt Widgets.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了Qt Quick中的状态机。在下一节中，您将学习如何在Qt Widgets中使用状态机。
- en: The state machine in Qt Widgets
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Widgets中的状态机
- en: Classes in the State Machine framework are available for creating and executing
    state graphs. The State Machine framework provides an API and execution model
    for effectively embedding state chart elements and semantics in Qt applications.
    The framework is tightly integrated with Qt's meta-object system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机框架中的类可用于创建和执行状态图。状态机框架为在Qt应用程序中有效地嵌入状态图元素和语义提供了API和执行模型。该框架与Qt的元对象系统紧密集成。
- en: There was a major change to the State Machine framework in Qt 6\. The APIs were
    missing from the Qt 6.0.x core module. With Qt 6.1, the module was restored as
    the `statemachine` to the `.pro` file to use the framework.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6中，状态机框架发生了重大变化。API在Qt 6.0.x核心模块中丢失了。在Qt 6.1中，该模块被恢复为`statemachine`，以便在`.pro`文件中使用该框架。
- en: 'If you are using a `qmake` based build system, then add the following line
    to your `.pro` file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于`qmake`的构建系统，则将以下行添加到您的`.pro`文件中：
- en: '[PRE26]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are using a *CMake* based build system, then add the following to `CMakeLists.txt`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于*CMake*的构建系统，则将以下内容添加到`CMakeLists.txt`中：
- en: '[PRE27]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will need the following headers inside your C++ source file:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在C++源文件中包含以下标头：
- en: '[PRE28]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s create a simple Qt Widgets application that implements the state-machine.
    Modify the UI form by adding `QLabel` and `QPushButton`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Qt Widgets应用程序，实现状态机。通过添加`QLabel`和`QPushButton`修改UI表单：
- en: 'Add the following code to the constructor of your custom C++ class:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您自定义的C++类的构造函数中：
- en: '[PRE29]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we created a state to show the green-colored LED. Next,
    we will create another state for the red-colored LED:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个状态来显示绿色LED。接下来，我们将为红色LED创建另一个状态：
- en: '[PRE30]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add transitions for the state change events when the button is toggled:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮切换时的状态改变事件添加转换：
- en: '[PRE31]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now create a state machine instance and add the states to it:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个状态机实例并向其添加状态：
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last step is to start the state machine:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是启动状态机：
- en: '[PRE33]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you run the previous example, you will see an output window like the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行上面的示例时，您将看到一个输出窗口，如下所示：
- en: '![Figure 8.10 – Output of the application using the state machine in Qt Widgets'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 - 在Qt Widgets中使用状态机的应用输出'
- en: '](img/Figure_8.10_B16231.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B16231.jpg)'
- en: Figure 8.10 – Output of the application using the state machine in Qt Widgets
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 在Qt Widgets中使用状态机的应用输出
- en: The preceding diagram reinforces that in a parent state machine, only the states
    of the child state machine can be specified as transition targets. States of the
    parent state machine, on the other hand, cannot be specified as targets of transitions
    in the child state machine.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表强调了在父状态机中，只能将子状态机的状态指定为转换目标。另一方面，父状态机的状态不能被指定为子状态机中的转换目标。
- en: 'The following article nicely captures the performance considerations while
    using a state machine:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章很好地捕捉了在使用状态机时的性能考虑：
- en: https://www.embedded.com/how-to-ensure-the-best-qt-state-machine-performance/
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.embedded.com/how-to-ensure-the-best-qt-state-machine-performance/
- en: In this section, we learned about state machines and their usage in Qt Widgets.
    We discussed how to implement state machines in both Qt Widgets and Qt Quick.
    Let's summarize what we learned in this chapter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了状态机及其在Qt Widgets中的使用。我们讨论了如何在Qt Widgets和Qt Quick中实现状态机。让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different graphics APIs and we learned how to
    use the `QPainter` class to draw graphics both on and off the screen. We also
    looked into the Graphics View framework and scene graph rendering mechanism. We
    saw how Qt provides the `QPaintDevice` interface and the `QPainter` class to perform
    graphics operations throughout this chapter. We also discussed the Graphics View
    classes, OpenGL framework, and shader tools. At the end of the chapter, we explored
    the animation and state machine framework in both Qt Widgets and Qt Quick.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同的图形API，并学习了如何使用`QPainter`类在屏幕上和屏幕外绘制图形。我们还研究了图形视图框架和场景图渲染机制。我们看到了Qt如何在整个本章中提供`QPaintDevice`接口和`QPainter`类来执行图形操作。我们还讨论了图形视图类、OpenGL框架和着色器工具。在本章末尾，我们探讨了Qt
    Widgets和Qt Quick中的动画和状态机框架。
- en: In [*Chapter 9*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221), *Testing
    and Debugging*, we will learn about debugging and testing in Qt. It will help
    you to find the root cause of issues and fix defects.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221)，*测试和调试*中，我们将学习在Qt中进行调试和测试。这将帮助您找到问题的根本原因并修复缺陷。
