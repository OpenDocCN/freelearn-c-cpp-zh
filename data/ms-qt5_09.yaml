- en: Chapter 9.  Keeping Your Sanity with Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。用多线程保持你的理智
- en: In previous chapters, we managed to always write code without ever relying on
    threads. It is time to face the beast and truly understand how threading works
    in Qt. In this chapter, you will develop a multithreaded application that displays
    a Mandelbrot fractal. It is a heavy computational process that will bring tears
    to your CPU cores.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们设法总是编写不依赖线程的代码。现在是时候面对这个怪物，真正理解在 Qt 中线程是如何工作的了。在本章中，你将开发一个显示曼德布罗特分形的多线程应用程序。这是一个计算密集型过程，将让你的
    CPU 核心流泪。
- en: In the example project, the user can see the Mandelbrot fractal, zoom in the
    picture, and pan around to discover the magic of fractals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，用户可以看到曼德布罗特分形，放大图片，并四处移动以发现分形的神奇之处。
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Deep understanding of the `QThread` framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入理解 `QThread` 框架
- en: Overview of all the available threading technologies in Qt
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 中所有可用的线程技术概述
- en: Using a `QThreadPool` class to dispatch jobs and aggregate the results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `QThreadPool` 类调度任务并汇总结果
- en: How to synchronize threads and minimize sharing states
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同步线程并最小化共享状态
- en: Low-level drawing to optimize the performances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低级绘图以优化性能
- en: Common threading pitfalls and challenges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的线程陷阱和挑战
- en: Discovering QThread
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现 QThread
- en: Qt provides a sophisticated threading system. We assume you already know threading
    basics and the associated issues (deadlocks, threads synchronization, resource
    sharing, and so on) and we will focus on how Qt implements it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了一个复杂的线程系统。我们假设你已经了解了线程基础知识及其相关的问题（死锁、线程同步、资源共享等），我们将重点介绍 Qt 如何实现它。
- en: The `QThread` is the central class of the Qt threading system. A `QThread` instance
    manages one thread of execution within the program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThread` 是 Qt 线程系统的核心类。一个 `QThread` 实例管理程序中的一个执行线程。'
- en: 'You can subclass `QThread` to override the `run()` function, which will be
    executed in the `QThread` framework. Here is how you can create and start a `QThread`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继承 `QThread` 来重写 `run()` 函数，该函数将在 `QThread` 框架中执行。以下是创建和启动 `QThread` 的方法：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `start()` function calling will automatically call the `run()` function
    of the thread and emit the `started()` signal. Only at this point will the new
    thread of execution be created. When `run()` is completed, the `thread` object
    will emit the `finished()` signal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `start()` 函数将自动调用线程的 `run()` 函数并发出 `started()` 信号。只有在这一点上，新的执行线程才会被创建。当 `run()`
    完成时，`thread` 对象将发出 `finished()` 信号。
- en: 'This brings us to a fundamental aspect of `QThread`: it works seamlessly with
    the signal/slot mechanism. Qt is an event-driven framework, where a main event
    loop (or the GUI loop) processes events (user input, graphical, and so on) to
    refresh the UI.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了 `QThread` 的一个基本方面：它与信号/槽机制无缝工作。Qt 是一个事件驱动的框架，其中主事件循环（或 GUI 循环）处理事件（用户输入、图形等）以刷新
    UI。
- en: 'Each `QThread` comes with its own event loop that can process events outside
    the main loop. If not overridden, `run()` calls the `QThread::exec()` function,
    which starts the `thread` object''s event loop. You can also override `QThread`
    and call yourself `exec()`, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `QThread` 都有自己的事件循环，可以处理主循环之外的事件。如果不重写，`run()` 将调用 `QThread::exec()` 函数，该函数启动
    `thread` 对象的事件循环。你也可以重写 `QThread` 并调用自己的 `exec()`，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `started()`signal will be processed by the `Thread` event loop only upon
    the `exec()` call. It will block and wait until `QThread::exit()` is called.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在调用 `exec()` 后，`started()` 信号才会由 `Thread` 事件循环处理。它将阻塞并等待直到调用 `QThread::exit()`。
- en: 'A crucial thing to note is that a thread event loop delivers events for all
    `QObjects` that are living in that thread. This includes all objects created in
    that thread or moved to that thread. This is referred to as the thread affinity
    of an object. Let''s see an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的关键点是，线程事件循环为该线程中所有存活的 `QObjects` 提供事件。这包括在该线程中创建的所有对象或移动到该线程的对象。这被称为对象线程亲和力。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this snippet, `myObject` is constructed in `Thread` class's constructor,
    which is created in turn in `MainWindow`. At this point, `thread` is living in
    the GUI thread. Hence, `myObject` is also living in the GUI thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`myObject` 在 `Thread` 类的构造函数中构建，该构造函数在 `MainWindow` 中创建。此时，`thread` 正在
    GUI 线程中运行。因此，`myObject` 也生活在 GUI 线程中。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An object created before a `QCoreApplication` object has no thread affinity.
    As a consequence, no event will be dispatched to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `QCoreApplication` 对象之前创建的对象没有线程亲和性。因此，不会向其派遣任何事件。
- en: 'It is great to be able to handle signals and slots in our own `QThread`, but
    how can we control signals across multiple threads? A classic example is a long-running
    process that is executed in a separate thread that has to notify the UI to update
    some state:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在我们的 `QThread` 中处理信号和槽是非常棒的，但我们如何控制跨多个线程的信号呢？一个经典的例子是，一个长时间运行的过程在一个单独的线程中执行，必须通知
    UI 更新某些状态：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Intuitively, we assume that the first `connect` sends the signal across multiple
    threads (to have results available in `MainWindow::handleResult`), whereas the
    second `connect` should work on thread's event loop only.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉上，我们假设第一个 `connect` 会将信号发送到多个线程（以便在 `MainWindow::handleResult` 中可用结果），而第二个
    `connect` 应该只在工作线程的事件循环上工作。
- en: 'Fortunately, this is the case due to a default argument in the `connect()`
    function signature: the connection type. Let''s see the complete signature:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是由于 `connect()` 函数签名中的默认参数：连接类型。让我们看看完整的签名：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `type` keyword takes `Qt::AutoConnection` as a default value. Let''s review
    the possible values of the `Qt::ConectionType enum` as the official Qt documentation
    states:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 关键字默认取 `Qt::AutoConnection`。让我们回顾一下 `Qt::ConnectionType` 枚举的可能值，如官方
    Qt 文档所述：'
- en: '`Qt::AutoConnection`: If the receiver lives in the thread that emits the signal, `Qt::DirectConnection`
    is used. Otherwise, `Qt::QueuedConnection` is used. The connection type is determined
    when the signal is emitted.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::AutoConnection`：如果接收器位于发出信号的线程中，则使用 `Qt::DirectConnection`。否则，使用 `Qt::QueuedConnection`。连接类型在信号发出时确定。'
- en: '`Qt::DirectConnection`: This slot is invoked immediately when the signal is
    emitted. The slot is executed in the signaling thread.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::DirectConnection`：当信号发出时，将立即调用此槽。槽在发出信号的线程中执行。'
- en: '`Qt::QueuedConnection`: This slot is invoked when control returns to the event
    loop of the receiver''s thread. The slot is executed in the receiver''s thread.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::QueuedConnection`：当控制权返回接收器线程的事件循环时，将调用此槽。槽在接收器线程中执行。'
- en: '`Qt::BlockingQueuedConnection`: This is the same as `Qt::QueuedConnection`,
    except that the signaling thread blocks until the slot returns. This connection
    must not be used if the receiver lives in the signaling thread, or else the application
    will deadlock.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::BlockingQueuedConnection`：这与 `Qt::QueuedConnection` 相同，只不过信号线程会阻塞，直到槽返回。如果接收器位于信号线程中，则不得使用此连接，否则应用程序将发生死锁。'
- en: '`Qt::UniqueConnection`: This is a flag that can be combined with any one of
    the previous connection types, using a bitwise OR. When `Qt::UniqueConnection`
    is set, `QObject::connect()` will fail if the connection already exists (that
    is, if the same signal is already connected to the same slot for the same pair
    of objects).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::UniqueConnection`：这是一个可以与之前任何一种连接类型组合的标志，使用位或运算。当设置 `Qt::UniqueConnection`
    时，如果连接已经存在（即，如果相同的信号已经连接到相同的槽，针对同一对对象），`QObject::connect()` 将失败。'
- en: 'When using `Qt::AutoConnection`, the final `ConnectionType` is resolved only
    when the signal is effectively emitted. If you look again at our example, at the
    first `connect()`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Qt::AutoConnection` 时，最终的 `ConnectionType` 仅在信号实际发出时才被解决。如果你再次看我们的例子，第一个
    `connect()`：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `result()` is emitted, Qt will look at the `handleResult()` thread affinity,
    which is different from the thread affinity of the `result()` signal. The `thread`
    object is living in `MainWindow` (remember that it has been created in `MainWindow`),
    but the `result()` signal has been emitted in the `run()` function, which is running
    in a different thread of execution. As a result, a `Qt::QueuedConnection` slot
    will be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `result()` 发出时，Qt 会查看 `handleResult()` 线程亲和性，这与 `result()` 信号的线程亲和性不同。`thread`
    对象位于 `MainWindow` 中（记住它是在 `MainWindow` 中创建的），但 `result()` 信号是在 `run()` 函数中发出的，该函数在不同的执行线程中运行。因此，将使用
    `Qt::QueuedConnection` 槽。
- en: 'We can now take a look at the second `connect()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看看第二个 `connect()`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `deleteLater()` and `finished()` live in the same thread; therefore, a `Qt::DirectConnection`
    slot will be used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`deleteLater()` 和 `finished()` 都位于同一个线程中；因此，将使用 `Qt::DirectConnection` 槽。
- en: It is crucial that you understand that Qt does not care about the emitting object
    thread affinity, it looks only at the signal "context of execution".
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须明白，Qt 并不关心发出信号的线程亲和性，它只关注信号的“执行上下文”。
- en: 'Loaded with this knowledge, we can take another look at our first `QThread`
    class example to have a full understanding of this system:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们可以再次审视我们的第一个 `QThread` 类示例，以全面理解这个系统：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the `Object::started()` function is emitted, a `Qt::QueuedConnection` slot
    will be used. This is where your brain freezes. The `Thread::doWork()` function
    lives in another thread than `Object::started()`, which has been created in `run()`.
    If Thread has been instantiated in the UI thread, this is where `doWork()` would
    have belonged.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Object::started()` 函数被发出时，将使用一个 `Qt::QueuedConnection` 插槽。这就是你的大脑冻结的地方。`Thread::doWork()`
    函数位于 `Object::started()` 所在的另一个线程中，该线程是在 `run()` 中创建的。如果线程是在 UI 线程中实例化的，那么这就是
    `doWork()` 应该属于的地方。
- en: 'This system is powerful, but complex. To make things simpler, Qt favors the
    worker model. It splits the threading plumbing from the real processing. Here
    is an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统功能强大，但也很复杂。为了使事情更简单，Qt 倾向于使用工作模型。它将线程管道与实际处理分离。以下是一个例子：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start by creating a `Worker` class that has:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个具有以下内容的 `Worker` 类：
- en: A `doWork()` slot that will have the content of our old `QThread::run()`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将包含我们旧的 `QThread::run()` 内容的 `doWork()` 插槽
- en: A `result()` signal that will emit the resulting data
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将发出结果的 `result()` 信号
- en: Next in the `MainWindow` class, we create a simple `thread` object and an instance
    of `Worker`. The `worker->moveToThread(thread)` is where the magic happens. It
    changes the affinity of the `worker` object. The `worker` now lives in the `thread`
    object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类中，我们创建了一个简单的 `thread` 对象和一个 `Worker` 实例。`worker->moveToThread(thread)`
    是魔法发生的地方。它改变了 `worker` 对象的亲和力。现在 `worker` 位于 `thread` 对象中。
- en: You can only push an object from your current thread to another thread. Conversely,
    you cannot pull an object that lives in another thread. You cannot change the
    thread affinity of an object if the object does not live in your thread. Once
    `thread->start()` is executed, we cannot call `worker->moveToThread(this)` unless
    we are doing it from this new thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能从当前线程向另一个线程推送对象。相反，你不能从另一个线程中拉取一个对象。如果你不在你的线程中，你不能改变对象的线程亲和力。一旦执行了 `thread->start()`，除非我们从这个新线程中执行，否则我们不能调用
    `worker->moveToThread(this)`。
- en: 'After that, we do three `connect()`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们做了三个 `connect()`：
- en: We handle the `worker` life cycle by reaping it when the thread is finished.
    This signal will use a `Qt::DirectConnection`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在线程完成时回收它来处理 `worker` 生命周期。这个信号将使用 `Qt::DirectConnection`。
- en: We start the `Worker::doWork()` upon a possible UI event. This signal will use
    a `Qt::QueuedConnection`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可能的 UI 事件上启动 `Worker::doWork()`。这个信号将使用 `Qt::QueuedConnection`。
- en: We process the resulting data in the UI thread with `handleResult()`. This signal
    will use a `Qt::QueuedConnection`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `handleResult()` 在 UI 线程中处理结果数据。这个信号将使用 `Qt::QueuedConnection`。
- en: To sum up, `QThread` can be either subclassed or used in conjunction with a `worker`
    class. Generally, the worker approach is favored because it separates more cleanly
    the threading affinity plumbing from the actual operation you want to execute
    in parallel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`QThread` 可以被继承或与 `worker` 类一起使用。通常，更倾向于使用工作方法，因为它更清晰地分离了线程亲和力管道和实际并行执行的操作。
- en: Flying over Qt multithreading technologies
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞越 Qt 多线程技术
- en: 'Built upon `QThread`, several threading technologies are available in Qt. First,
    to synchronize threads, the usual approach is to use a mutual exclusion (mutex)
    to have a mutual exclusion for a given resource. Qt provides it by means of the `QMutex`
    class. Its usage is straightforward:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `QThread`，Qt 中提供了几种线程技术。首先，为了同步线程，通常的方法是使用互斥锁（mutex）来为给定资源提供互斥。Qt 通过 `QMutex`
    类提供它。其用法很简单：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the `mutex.lock()` instruction, any other thread trying to lock the `mutex`
    will wait until `mutex.unlock()` has been called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `mutex.lock()` 指令开始，任何尝试锁定 `mutex` 的其他线程都将等待直到 `mutex.unlock()` 被调用。
- en: 'The locking/unlocking mechanism is error-prone in complex code. You can easily
    forget to unlock a mutex in a specific exit condition, causing a deadlock. To
    simplify this situation, Qt provides a `QMutexLocker` that should be used where
    the `QMutex` needs to be locked:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂代码中，锁定/解锁机制容易出错。你可能会忘记在特定的退出条件下解锁互斥锁，从而导致死锁。为了简化这种情况，Qt 提供了一个 `QMutexLocker`，应该在需要锁定
    `QMutex` 的地方使用：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `mutex` is locked when the `locker` object is created and will be unlocked
    when the `locker` object is destroyed; for example, when it goes out of scope.
    This is the case for every condition we stated where the `return` statement appears.
    It makes the code simpler and more readable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`locker`对象时，`mutex`会被锁定，并在`locker`对象被销毁时解锁；例如，当它超出作用域时。对于每个我们提到的出现`return`语句的条件，情况都是如此。这使得代码更简单、更易读。
- en: You may need to create and destroy threads frequently, as managing `QThread`
    instances by hand can become cumbersome. For this, you can use the `QThreadPool`
    class, which manages a pool of reusable `QThreads`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要频繁地创建和销毁线程，因为手动管理`QThread`实例可能会变得繁琐。为此，你可以使用`QThreadPool`类，它管理着一组可重用的`QThread`。
- en: 'To execute code within threads managed by a `QThreadPool` class, you will use
    a pattern very close to the worker we covered earlier. The main difference is
    that the processing class has to extend the `QRunnable` class. Here is how it
    looks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在由`QThreadPool`类管理的线程中执行代码，你将使用一个与我们之前覆盖的工人非常相似的模式。主要区别在于处理类必须扩展`QRunnable`类。以下是它的样子：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just override the `run()` function and ask `QThreadPool` to execute your job
    in a separate thread. The `QThreadPool::globalInstance()` is a static helper function
    that gives you access to an application global instance. You can create your own `QThreadPool`
    if you need to have finer control over the `QThreadPool` life cycle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只需重写`run()`函数，并让`QThreadPool`在单独的线程中执行你的任务。`QThreadPool::globalInstance()`是一个静态辅助函数，它为你提供了访问应用程序全局实例的权限。如果你需要更精细地控制`QThreadPool`的生命周期，你可以创建自己的`QThreadPool`。
- en: Note that the `QThreadPool::start()` function takes the ownership of `job` and
    will automatically delete it when `run()` finishes. Watch out, this does not change
    the thread affinity like `QObject::moveToThread()` does with workers! A `QRunnable`
    class cannot be reused, it has to be a freshly baked instance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`QThreadPool::start()`函数会接管`job`的所有权，并在`run()`完成后自动删除它。小心，这不会像`QObject::moveToThread()`对工作者那样改变线程亲和力！`QRunnable`类不能重用，它必须是一个全新的实例。
- en: If you fire up several jobs, `QThreadPool` automatically allocates the ideal
    number of threads based on the core count of your CPU. The maximum number of threads
    that the `QThreadPool` class can start can be retrieved with `QThreadPool::maxThreadCount()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动了多个任务，`QThreadPool`会根据你的CPU核心数自动分配理想数量的线程。`QThreadPool`类可以启动的最大线程数可以通过`QThreadPool::maxThreadCount()`获取。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to manage threads by hand, but you want to base it on the number
    of cores of your CPU, you can use the handy static function, `QThreadPool::idealThreadCount()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要手动管理线程，但希望基于你的CPU核心数，你可以使用方便的静态函数`QThreadPool::idealThreadCount()`。
- en: Another approach to multi-threaded development is available with the Qt Concurrent
    framework. It is a higher-level API that avoids the use of mutexes/lock/wait conditions
    and promotes the distribution of the processing among CPU cores.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt并发框架，还有另一种多线程开发的方法。它是一个高级API，避免了使用互斥锁/锁定/等待条件，并促进了处理在CPU核心之间的分布。
- en: 'Qt Concurrent relies on the `QFuture` class to execute a function and expects
    a result later on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Qt并发依赖于`QFuture`类来执行函数，并期望稍后得到结果：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `longRunningFunction()` function will be executed in a separated thread
    obtained from the default `QThreadPool` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`longRunningFunction()`函数将在从默认的`QThreadPool`类获得的单独线程中执行。'
- en: 'To pass parameters to a `QFuture` class and retrieve the result of the operation,
    use the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将参数传递给`QFuture`类并检索操作的结果，请使用以下代码：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we pass `lenna` as a parameter to the `processGrayscale()` function. Because
    we want a `QImage` as a result, we declare the `QFuture` class with the template
    type, `QImage`. After that, `future.result()` blocks the current thread and waits
    for the operation to be completed to return the final `QImage`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`lenna`作为参数传递给`processGrayscale()`函数。因为我们想要一个`QImage`作为结果，所以我们使用模板类型声明`QFuture`类，为`QImage`。之后，`future.result()`会阻塞当前线程，等待操作完成以返回最终的`QImage`。
- en: 'To avoid blocking, `QFutureWatcher` comes to the rescue:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免阻塞，`QFutureWatcher`来帮忙：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start by declaring a `QFutureWatcher` class with the template argument matching
    the one used for `QFuture`. Then simply connect the `QFutureWatcher::finished`
    signal to the slot you want to be called when the operation has been completed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个`QFutureWatcher`类，其模板参数与`QFuture`使用的参数相匹配。然后只需将`QFutureWatcher::finished`信号连接到当操作完成后要调用的槽。
- en: The last step is to tell the `watcher` object to watch the future object with `watcher.setFuture(future)`.
    This statement looks almost like it comes from a science-fiction movie.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是告诉`watcher`对象使用`watcher.setFuture(future)`来监视未来的对象。这个语句看起来几乎像是来自科幻电影。
- en: 'Qt Concurrent also provides a `MapReduce` and `FilterReduce` implementation.
    The `MapReduce` is a programming model that basically does two things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Qt并发还提供了`MapReduce`和`FilterReduce`的实现。`MapReduce`是一种编程模型，基本上做两件事：
- en: Maps or distributes the processing of the dataset among multiple cores of the
    CPU
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CPU的多个核心之间映射或分配数据集的处理
- en: Reduces or aggregates the results to provide it to the caller
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果减少或聚合以提供给调用者
- en: This technique was first promoted by Google to be able to process huge datasets
    within a cluster of CPUs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术最初由谷歌推广，以便能够在CPU集群中处理大量数据集。
- en: 'Here is an example of a simple map operation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的映射操作的例子：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of `QtConcurrent::run()`, we use the mapped function that takes a list
    and the function to apply to each element in a different thread each time. The `images`
    list is modified in place, so there is no need to declare `QFuture` with a template
    type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用`QtConcurrent::run()`，而是使用映射函数，该函数每次都接受一个列表和应用于列表中每个元素的不同线程中的函数。`images`列表就地修改，因此不需要使用模板类型声明`QFuture`。
- en: The operation can be made to block by using `QtConcurrent::blockingMapped()`
    instead of `QtConcurrent::mapped()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`QtConcurrent::blockingMapped()`而不是`QtConcurrent::mapped()`来使操作阻塞。
- en: 'Finally, a `MapReduce` operation looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个`MapReduce`操作看起来是这样的：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we added a `combineImage()` function that will be called for each result
    returned by the map function, `processGrayscale()`. It will merge the intermediate
    data, `inputImage`, into the `finalImage`. This function is called only once at
    a time per thread, so there is no need to use a mutex to lock the result variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`combineImage()`函数，它将在`processGrayscale()`映射函数返回的每个结果上被调用。它将中间数据`inputImage`合并到`finalImage`中。这个函数在每个线程中只被调用一次，因此不需要使用互斥锁来锁定结果变量。
- en: The `FilterReduce` follows exactly the same pattern; the filter function simply
    allows you to filter the input list instead of transforming it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterReduce`遵循完全相同的模式；过滤器函数只是允许您过滤输入列表而不是转换它。'
- en: Architecting the Mandelbrot project
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建曼德布罗特项目架构
- en: The example project of this chapter is the multi-threaded calculation of a Mandelbrot
    fractal. The user will see the fractal and will be able to pan and zoom in that
    window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例项目是计算曼德布罗特分形的多线程计算。用户将看到分形，并能够在该窗口中平移和缩放。
- en: Before diving into the code, we have to have a broad understanding of a fractal
    and how we are going to achieve its calculation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们必须对分形有一个广泛的理解，以及我们如何实现其计算。
- en: 'The Mandelbrot fractal is a numerical set that works with complex numbers (a
    + bi). Each pixel is associated with a value calculated through iterations. If
    this iterated value diverges towards infinity then the pixel is out of the Mandelbrot
    set. If not, then the pixel is inside the Mandelbrot set. A visual representation
    of the Mandelbrot fractal looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗特分形是一个使用复数（a + bi）的数值集。每个像素都与通过迭代计算出的一个值相关联。如果这个迭代值发散到无穷大，那么这个像素就超出了曼德布罗特集。如果不发散，那么这个像素就在曼德布罗特集内。曼德布罗特分形的视觉表示如下：
- en: '![Architecting the Mandelbrot project](img/image00428.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![构建曼德布罗特项目架构](img/image00428.jpeg)'
- en: Every black pixel in this image tends to diverge to an infinite value, whereas
    white pixels are bounded to a finite value. The white pixels belong to the Mandelbrot
    set.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像中的每一个黑色像素都倾向于发散到无限大的值，而白色像素则被限制在有限值内。白色像素属于曼德布罗特集。
- en: What makes it interesting from a multi-threaded perspective, is that to determine
    if the pixel belongs or not to the Mandelbrot set, we have to iterate on a formula
    to be able to hypothesize its divergence or not. The more iterations we perform,
    the safer we are in claiming "yes, this pixel is in the Mandelbrot set, it is
    a white pixel".
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从多线程的角度来看，使其变得有趣的是，为了确定像素是否属于曼德布罗特集，我们必须迭代一个公式来假设它的发散与否。我们进行的迭代越多，我们声称“是的，这个像素在曼德布罗特集中，它是一个白色像素”就越安全。
- en: 'Even more fun, we can take any value in the graphical plot and always apply
    the Mandelbrot formula to deduce if the pixel should be black or white. As a consequence,
    you can zoom endlessly inside the graphics of your fractal. There are only two
    main limitations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们可以取图形图中的任何值，并始终应用Mandelbrot公式来推断像素应该是黑色还是白色。因此，你可以在分形图形内部无限缩放。只有两个主要限制：
- en: The power of your CPU hinders the picture generation speed.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的CPU性能阻碍了图片生成速度。
- en: The floating number precision of your CPU architecture limits the zoom. If you
    keep zooming, you will get visual artifacts because the scale factor can only
    handle 15 to 17 significant digits.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的CPU架构的浮点数精度限制了缩放。如果你继续缩放，你会得到视觉伪影，因为缩放因子只能处理15到17位有效数字。
- en: The architecture of the application has to be carefully designed. Because we
    are working with threads, it is very easy to cause deadlock, starve threads, or
    even worse, freeze the UI.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的架构必须精心设计。因为我们正在使用线程，所以很容易导致死锁、线程饥饿，甚至更糟糕的是，冻结UI。
- en: We really want to maximize the use of the CPU. To do so, we will execute as
    many threads as possible on each core. Each thread will be responsible for calculating
    a part of the Mandelbrot set before giving back its result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的想最大化CPU的使用。为此，我们将尽可能在每个核心上执行尽可能多的线程。每个线程将负责计算Mandelbrot集的一部分，然后再返回其结果。
- en: 'The architecture of the application is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的架构如下：
- en: '![Architecting the Mandelbrot project](img/image00429.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Mandelbrot项目架构](img/image00429.jpeg)'
- en: 'The application is divided into three parts:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序被分为三个部分：
- en: '`MandelbrotWidget`: This requests a picture to display. It handles the drawing
    and the user interaction. This object lives in the UI thread.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MandelbrotWidget`：这个请求显示图片。它处理绘图和用户交互。此对象位于UI线程中。'
- en: '`MandelbrotCalculator`: This handles the picture requests and aggregates the
    resulting `JobResults` before sending it back to `MandelbrotWidget`. This object
    lives in its own thread.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MandelbrotCalculator`：这个处理图片请求并在发送回 `MandelbrotWidget` 之前聚合结果 `JobResults`
    的对象。此对象在其自己的线程中运行。'
- en: '`Job`: This calculates a part of the final picture before transmitting the
    result back to `MandelbrotCalculator`. Each job lives in its own thread.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Job`：这个在将结果传回 `MandelbrotCalculator` 之前计算最终图片的一部分。每个任务都位于自己的线程中。'
- en: The `MandelbrotCalculator` thread will use a `QThreadPool` class to dispatch
    jobs in their own thread. This will scale perfectly according to your CPU cores.
    Each job will calculate a single line of the final picture before sending it back
    to `MandelbrotCalculator` through a `JobResult` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`MandelbrotCalculator` 线程将使用 `QThreadPool` 类在其自己的线程中调度任务。这将根据你的CPU核心完美缩放。每个任务将在将结果通过 `JobResult`
    对象发送回 `MandelbrotCalculator` 之前计算最终图片的一行。'
- en: The `MandelbrotCalculator` thread is really the orchestrator of the calculation.
    Consider a user that zooms in the picture before the calculation is complete; `MandelbrotWidget`
    will request a new picture to `MandelbrotCalculator`, which in turn has to cancel
    all the current jobs before dispatching new jobs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MandelbrotCalculator` 线程实际上是计算的总指挥。考虑一个用户在计算完成之前放大图片的情况； `MandelbrotWidget`
    将请求新的图片给 `MandelbrotCalculator`，而 `MandelbrotCalculator` 必须在调度新任务之前取消所有当前任务。'
- en: 'We will add a last constraint to this project: it has to be mutex free. Mutexes
    are very convenient tools, but they force threads to wait for each other and are
    error-prone. To do this, we will rely on multiple concepts and technologies provided
    by Qt: multi-threaded signal/slots, implicit sharing, and so on.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为此项目添加最后一个约束：它必须是互斥锁免费的。互斥锁是非常方便的工具，但它们迫使线程相互等待，并且容易出错。为此，我们将依赖Qt提供的多个概念和技术：多线程信号/槽，隐式共享等。
- en: By minimizing the sharing state between our threads, we will be able to let
    them execute as fast as they possibly can. That is why we are here, to burn some
    CPU cores, right?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最小化线程间的共享状态，我们将能够让它们尽可能快地执行。这就是我们在这里的原因，对吧？燃烧一些CPU核心？
- en: Now that the broad picture is clearer, we can start the implementation. Create
    a new **Qt Widget Application** project named `ch09-mandelbrot-threadpool`. Remember
    to add the `CONFIG += c++14` to the `.pro` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在宏观图景已经更加清晰，我们可以开始实施。创建一个名为 `ch09-mandelbrot-threadpool` 的新 **Qt Widget Application**
    项目。记得将 `CONFIG += c++14` 添加到 `.pro` 文件中。
- en: Defining a Job class with QRunnable
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QRunnable定义Job类
- en: Let's dive into the project's core. To speed up the Mandelbrot picture generation,
    we will split the whole computation into multiple jobs. A `Job` is a request of
    a task. Depending on your CPU architecture, several jobs will be executed simultaneously.
    A `Job` class produces a `JobResult` function containing result values. In our
    project, a `Job` class generates values for one line of the complete picture.
    For example, an image resolution of 800 x 600 requires 600 jobs, each one generating
    800 values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到项目的核心。为了加快 Mandelbrot 图片的生成，我们将整个计算分成多个工作。一个 `Job` 是一个任务请求。根据您的 CPU 架构，将同时执行多个工作。`Job`
    类生成包含结果值的 `JobResult` 函数。在我们的项目中，`Job` 类为完整图片的一行生成值。例如，800 x 600 的图像分辨率需要 600
    个工作，每个工作生成 800 个值。
- en: 'Please create a C++ header file called `JobResult.h`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请创建一个名为 `JobResult.h` 的 C++ 头文件：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This structure contains two parts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含两个部分：
- en: Input data (`areaSize`, `pixelPositionY`, ...)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入数据（`areaSize`，`pixelPositionY`，...）
- en: Result `values` generated by a `Job` class
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `Job` 类生成的结果 `values`
- en: 'We can now create the `Job` class itself. Create a C++ class `Job` using the
    next snippet of `Job.h` for the content:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建 `Job` 类本身。使用以下 `Job.h` 片段创建一个 C++ 类 `Job`：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This `Job` class is a `QRunnable`, so we can override `run()` to implement
    the Mandelbrot picture algorithm. As you can see, `Job` also inherits from `QObject`,
    allowing us to use the signal/slot feature of Qt. The algorithm requires some
    input data. Update your `Job.h` like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Job` 类是一个 `QRunnable`，因此我们可以重写 `run()` 来实现 Mandelbrot 图片算法。如您所见，`Job` 也继承自
    `QObject`，这允许我们使用 Qt 的信号/槽功能。算法需要一些输入数据。更新您的 `Job.h` 如下：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s talk about these variables:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这些变量：
- en: The `mPixelPositionY` variable is the picture height index. Because each `Job`
    generates data only for one picture line, we need this information.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mPixelPositionY` 变量是图片高度索引。因为每个 `Job` 只为一条图片线生成数据，我们需要这个信息。'
- en: The `mMoveOffset` variable is the Mandelbrot origin offset. The user can pan
    the picture, so the origin will not always be (0, 0).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMoveOffset` 变量是 Mandelbrot 原点偏移。用户可以平移图片，因此原点不总是 (0, 0)。'
- en: The `mScaleFactor` variable is the Mandelbrot scale value. The user can also
    zoom into the picture.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mScaleFactor` 变量是 Mandelbrot 缩放值。用户也可以放大图片。'
- en: The `mAreaSize` variable is the final picture size in a pixel.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mAreaSize` 变量是最终图片的像素大小。'
- en: The `mIterationMax` variable is the count of iterations allowed to determine
    the Mandelbrot result for one pixel.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mIterationMax` 变量是允许用于确定一个像素的 Mandelbrot 结果的迭代次数。'
- en: 'We can now add a signal, `jobCompleted()`, and the abort feature to `Job.h`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向 `Job.h` 添加一个信号，`jobCompleted()`，以及中止功能：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `jobCompleted()` signal will be emitted when the algorithm is over. The `jobResult`
    parameter contains result values. The `abort()` slot will allow us to stop the
    job updating the `mIsAbort` flag value. Notice that `mAbort` is not a classic `bool`,
    but a `QAtomicInteger<bool>`. This Qt cross-platform type allows us to perform
    atomic operations without interruption. You could use a mutex or another synchronization
    mechanism to do the job, but using an atomic variable is a fast way to safely
    update and access a variable from different threads.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法结束时，将发出 `jobCompleted()` 信号。`jobResult` 参数包含结果值。`abort()` 槽将允许我们停止工作，更新 `mIsAbort`
    标志值。请注意，`mAbort` 不是一个经典的 `bool`，而是一个 `QAtomicInteger<bool>`。这种 Qt 跨平台类型允许我们在不中断的情况下执行原子操作。您可以使用互斥锁或其他同步机制来完成工作，但使用原子变量是安全地从不同线程更新和访问变量的快速方法。
- en: 'It is time to switch to the implementation part with `Job.cpp`. Here is the `Job`
    class''s constructor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候切换到使用 `Job.cpp` 的实现部分了。以下是 `Job` 类的构造函数：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a classic initialization; do not forget to call the `QObject` constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的初始化；不要忘记调用 `QObject` 构造函数。
- en: 'We can now implement the `run()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现 `run()` 函数：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this first part, we initialize a `JobResult` variable. The width of the area
    size is used to construct `JobResult::values` as a `QVector` with the correct
    initial size. Other input data is copied from `Job` to `JobResult` to let the
    receiver of `JobResult` get the result with the context input data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，我们初始化一个 `JobResult` 变量。区域大小的宽度用于将 `JobResult::values` 构造为具有正确初始大小的 `QVector`。其他输入数据从
    `Job` 复制到 `JobResult`，以便 `JobResult` 的接收者可以使用上下文输入数据获取结果。
- en: 'Then we can update the `run()` function with the Mandelbrot algorithm:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 Mandelbrot 算法更新 `run()` 函数：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Mandelbrot algorithm itself is beyond the scope of this book. But you have
    to understand the main purpose of this `run()` function. Let''s break it down:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗特算法本身超出了本书的范围。但您必须理解这个`run()`函数的主要目的。让我们分解一下：
- en: The for loop iterates over all `x` positions of pixels over one line
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for循环遍历一行中所有像素的`x`位置
- en: The pixel position is converted into complex plane coordinates
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素位置被转换为复平面坐标
- en: If the trial count exceeds the maximum authorized iteration, the algorithm ends
    with `iteration` to the `mIterationMax` value
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试次数超过最大授权迭代次数，算法将以`iteration`到`mIterationMax`的值结束
- en: If the Mandelbrot check condition is true, the algorithm ends with `iteration
    < mIterationMax`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果曼德布罗特检查条件为真，算法将以`iteration < mIterationMax`结束
- en: In any case, for each pixel, the iteration count is stored in `values` of `JobResult`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何情况下，对于每个像素，迭代次数都存储在`JobResult`的`values`中
- en: Finally, the `jobCompleted()` signal is emitted with result values of this algorithm
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用此算法的结果值发出`jobCompleted()`信号
- en: We perform an atomic read with `mAbort.load()`; notice that if the return value
    is `true`, the algorithm is aborted and nothing is emitted
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`mAbort.load()`执行原子的读取；注意，如果返回值是`true`，则算法被终止，并且不会发出任何内容
- en: 'The last function is the `abort()` slot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是`abort()`槽：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method performs an atomic write of the value, `true`. The atomic mechanism
    ensures that we can call `abort()` from multiple threads without disrupting the `mAbort`
    read in the `run()` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法执行原子的值写入，`true`。原子机制确保我们可以从多个线程调用`abort()`而不会干扰`run()`函数中的`mAbort`读取。
- en: In our case, `run()` lives in the thread affected by the `QThreadPool` (we will
    cover it soon), while the `abort()` slot will be called in the `MandelbrotCalculator`
    thread context.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`run()`函数存在于受`QThreadPool`影响的线程中（我们很快会介绍它），而`abort()`槽将在`MandelbrotCalculator`线程上下文中被调用。
- en: 'You might want to secure the operations on `mAbort` with a `QMutex`. However,
    keep in mind that locking and unlocking a mutex can become a costly operation
    if you do it often. Using a `QAtomicInteger` class here presents only the advantages:
    the access to `mAbort` is thread-safe and we avoid an expensive lock.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想使用`QMutex`来确保对`mAbort`的操作。但是，请记住，如果频繁地进行锁定和解锁，锁定和解锁互斥锁可能会变得代价高昂。在这里使用`QAtomicInteger`类只提供了优势：对`mAbort`的访问是线程安全的，我们避免了昂贵的锁定。
- en: The end of the `Job` implementation only contains setter functions. Please refer
    to the complete source code if you have any doubt.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Job`实现的末尾只包含设置函数。如果您有任何疑问，请参阅完整的源代码。'
- en: Using QThreadPool in MandelbrotCalculator
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MandelbrotCalculator中使用QThreadPool
- en: 'Now that our `Job` class is ready to be used, we need to create a class to
    manage the jobs. Please create a new class, `MandelbrotCalculator`. Let''s see
    what we need in the file, `MandelbrotCalculator.h`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们的`Job`类准备好使用时，我们需要创建一个类来管理作业。请创建一个新的类，`MandelbrotCalculator`。让我们看看在文件`MandelbrotCalculator.h`中我们需要什么：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have already discussed `mMoveOffset`, `mScaleFactor`, `mAreaSize`, and `mIterationMax`
    in the previous section. We also have some new variables:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中讨论了`mMoveOffset`、`mScaleFactor`、`mAreaSize`和`mIterationMax`。我们还有一些新的变量：
- en: The `mReceivedJobResults` variable is the count of the `JobResult` received,
    which was sent by the jobs
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mReceivedJobResults`变量是接收到的`JobResult`的数量，这是由作业发送的'
- en: The `mJobResults` variable is a list that contains received `JobResult`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mJobResults`变量是一个包含接收到的`JobResult`的列表'
- en: The `mTimer` variable calculates the elapsed time to run all jobs for a requested
    picture
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTimer`变量计算运行请求图片所需的所有作业的经过时间'
- en: 'Now that you get a better picture of all member variables, we can add the signals,
    slots, and private methods. Update your `MandelbrotCalculator.h` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对所有的成员变量有了更好的了解，我们可以添加信号、槽和私有方法。更新您的`MandelbrotCalculator.h`文件：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are the roles of these:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些角色的作用：
- en: '`generatePicture()`: This slot is used by the caller to request a new Mandelbrot
    picture. This function prepares and starts jobs.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generatePicture()`：这个槽由调用者用来请求新的曼德布罗特图片。这个函数准备并启动作业。'
- en: '`process()`: This slot handles results generated by the jobs.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process()`：这个槽处理作业生成的结果。'
- en: '`pictureLinesGenerated()`: This signal is regularly triggered to dispatch results.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pictureLinesGenerated()`：这个信号会定期触发以分发结果。'
- en: '`abortAllJobs()`: This signal is used to abort all active jobs.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abortAllJobs()`：这个信号用于终止所有活动作业。'
- en: '`createJob()`: This is a helper function to create and configure a new job.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createJob()`：这是一个辅助函数，用于创建和配置一个新的作业。'
- en: '`clearJobs()`: This slot removes queued jobs and aborts active jobs.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearJobs()`：这个槽移除队列中的作业并中止正在进行的作业。'
- en: 'The header file is completed and we can now perform the implementation. Here
    is the beginning of the `MandelbrotCalculator.cpp` implementation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件已完成，我们现在可以执行实现。以下是 `MandelbrotCalculator.cpp` 实现的开始：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As always, we are using the initializer list with default values for our member
    variables. The role of `JOB_RESULT_THRESHOLD` will be covered soon. Here is the `generatePicture()`
    slot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们使用默认值初始化列表来设置我们的成员变量。`JOB_RESULT_THRESHOLD` 的作用将在稍后介绍。以下是 `generatePicture()`
    槽：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `areaSize` dimension is 0x0, we have nothing to do. If the request is
    valid, we can start `mTimer` to track the whole generation duration. Each new
    picture generation will first cancel existing jobs by calling `clearJobs()`. Then
    we set our member variables with the ones provided. Finally, we create a new `Job`
    class for each vertical picture line. The `createJob()` function that returns
    a `Job*` value will be covered soon.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `areaSize` 维度为 0x0，我们就没有什么要做的。如果请求有效，我们可以启动 `mTimer` 来跟踪整个生成持续时间。每次生成新图片时，首先通过调用
    `clearJobs()` 取消现有作业。然后我们设置成员变量为提供的那些。最后，为每条垂直图片线创建一个新的 `Job` 类。将很快介绍返回 `Job*`
    值的 `createJob()` 函数。
- en: The `QThreadPool::globalInstance()` is a static function that gives us the optimal
    global thread pool depending on the core count of our CPU. Even if we call `start()`
    for all the `Job` classes, only the firsts starts immediately. Others are added
    to the pool queue waiting for an available thread.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThreadPool::globalInstance()` 是一个静态函数，它根据我们CPU的核心数提供最优的全局线程池。即使我们为所有 `Job`
    类调用 `start()`，也只有一个会立即启动。其他则被添加到池队列中，等待可用的线程。'
- en: 'Let''s see now how a `Job` class is created with the `createJob()` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 `createJob()` 函数创建一个 `Job` 类：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the jobs are allocated on the heap. This operation takes some
    time in the `MandelbrotCalculator` thread. But the results are worth it; the overhead
    is being compensated by the multi-threading system. Notice that when we call `QThreadPool::start()`,
    the thread pool takes ownership of the `job`. As a consequence, it will be deleted
    by the thread pool when `Job::run()` ends. We set the input data of the `Job`
    class required by the Mandelbrot algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，作业是在堆上分配的。这个操作在 `MandelbrotCalculator` 线程中会花费一些时间。但结果是值得的；开销被多线程系统所补偿。注意，当我们调用
    `QThreadPool::start()` 时，线程池会接管 `job` 的所有权。因此，当 `Job::run()` 结束时，它将被线程池删除。我们设置了由
    Mandelbrot 算法所需的 `Job` 类的输入数据。
- en: 'Then two connections are performed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行两个连接：
- en: Emitting our `abortAllJobs()` signal will call the `abort()` slot of all jobs
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出我们的 `abortAllJobs()` 信号将调用所有作业的 `abort()` 槽
- en: Our `process()` slot is executed each time a `Job` completes its task
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `process()` 槽在每次 `Job` 完成其任务时执行
- en: Finally, the `Job` pointer is returned to the caller, in our case, the `generatePicture()`
    slot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `Job` 指针返回给调用者，在我们的例子中，是 `generatePicture()` 槽。
- en: 'The last helper function is `clearJobs()`. Add it to your `MandelbrotCalculator.cpp`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助函数是 `clearJobs()`。将其添加到你的 `MandelbrotCalculator.cpp`：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The counter of received job results is reset. We emit our signal to abort all
    active jobs. Finally, we remove queued jobs waiting for an available thread in
    the thread pool.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重置接收到的作业结果计数器。我们发出信号以中止所有正在进行的作业。最后，我们移除线程池中等待可用线程的队列中的作业。
- en: 'The last function of this class is `process()`, and is maybe the most important
    function. Update your code with the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一个函数是 `process()`，可能是最重要的函数。用以下代码片段更新你的代码：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This slot will be called each time a job completes its task. The first thing
    to check is that the current `JobResult` is still valid with the current input
    data. When a new picture is requested, we clear the jobs queue and abort the active
    jobs. However, if an old `JobResult` is still sent to this `process()` slot, we
    must ignore it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个槽将在每次作业完成其任务时被调用。首先需要检查的是当前的 `JobResult` 是否仍然与当前输入数据有效。当请求新的图片时，我们清除作业队列并中止正在进行的作业。然而，如果旧的
    `JobResult` 仍然发送到这个 `process()` 槽，我们必须忽略它。
- en: 'After that, we can increment the `mReceivedJobResults` counter and append this `JobResult`
    to our member queue, `mJobResults`. The calculator waits to get `JOB_RESULT_THRESHOLD`
    (that is, 10) results before dispatching them by emitting the `pictureLinesGenerated()`
    signal. You can try to tweak this value with caution:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以增加 `mReceivedJobResults` 计数器并将此 `JobResult` 添加到我们的成员队列 `mJobResults`
    中。计算器等待获取 `JOB_RESULT_THRESHOLD`（即 10）个结果，然后通过发出 `pictureLinesGenerated()` 信号来分发它们。您可以小心地尝试调整此值：
- en: A lower value, for example 1, will dispatch each line of data to the widget
    as soon as the calculator gets it. But the widget will be slower than the calculator
    to handle each line. Moreover, you will flood the widget event loop.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的值，例如 1，将在计算器获取每行数据后立即将每行数据发送到小部件。但是，小部件处理每行数据会比计算器慢。此外，您将淹没小部件事件循环。
- en: A higher value relieves the widget event loop. But the user will wait longer
    before seeing something happening. A continuous partial frame update gives a better
    user experience.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的值可以缓解小部件事件循环。但用户在看到动作之前需要等待更长的时间。连续的局部帧更新可以提供更好的用户体验。
- en: Also notice that when the event is dispatched, the `QList` class with the job
    result is sent by copy. But Qt performs implicit sharing with `QList`, so we only
    send a shallow copy not a costly deep copy. Then we clear the current `QList`
    of the calculator.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当事件被分发时，包含作业结果的 `QList` 类是通过复制发送的。但是 Qt 对 `QList` 执行隐式共享，所以我们只发送浅拷贝而不是昂贵的深拷贝。然后我们清除计算器的当前
    `QList`。
- en: Finally, if the processed `JobResult` is the last one in the area, we display
    a debug message with the elapsed time since the user call, `generatePicture()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果处理过的 `JobResult` 是区域中的最后一个，我们将显示一个调试消息，其中包含用户调用 `generatePicture()` 以来经过的时间。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Qt tip**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt 小贴士**'
- en: You can set the thread count used by the `QThreadPool` class with `setMaxThreadCount(x)`
    where `x` is the thread count.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `setMaxThreadCount(x)` 设置 `QThreadPool` 类使用的线程数，其中 `x` 是线程数。
- en: Displaying the fractal with MandelbrotWidget
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MandelbrotWidget 显示分形
- en: 'Here we are, the Mandelbrot algorithm is done and the multi-threading system
    is ready to compute complex fractals over all your CPU cores. We can now create
    the widget that will convert all `JobResult` to display a pretty picture. Create
    a new C++ class called `MandelbrotWidget`. For this widget, we will handle the
    painting ourselves. Thus, we do not need any `.ui``Qt Designer Form` file. Let''s
    begin with the `MandelbrotWidget.h` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们完成了，曼德布罗特算法已完成，多线程系统已准备好在所有 CPU 核心上计算复杂的分形。我们现在可以创建一个将所有 `JobResult` 转换为显示漂亮图片的小部件。创建一个新的
    C++ 类 `MandelbrotWidget`。对于这个小部件，我们将自己处理绘图。因此，我们不需要任何 `.ui` Qt Designer 表单文件。让我们从
    `MandelbrotWidget.h` 文件开始：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should recognize some known variable names such as `mScaleFactor`, `mMoveOffset`, `mAreaSize`,
    or `mIterationMax`. We have already covered them in the `JobResult` and `Job`
    implementation. Here are the real new ones:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能识别一些已知的变量名，例如 `mScaleFactor`、`mMoveOffset`、`mAreaSize` 或 `mIterationMax`。我们已经在
    `JobResult` 和 `Job` 实现中介绍了它们。以下是真正的新变量：
- en: The `mMandelbrotCalculator` variable is our multi-threaded `Job` manager. The
    widget will do requests to it and wait for results.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMandelbrotCalculator` 变量是我们多线程的 `Job` 管理器。小部件会向其发送请求并等待结果。'
- en: The `mThreadCalculator` variable allows the Mandelbrot calculator to run in
    its own thread.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mThreadCalculator` 变量允许曼德布罗特计算器在其自己的线程中运行。'
- en: The `mLastMouseMovePosition` variable is used by the widget to handle user events
    for the pan feature.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mLastMouseMovePosition` 变量被小部件用于处理用户事件，以实现平移功能。'
- en: The `mImage` variable is the current picture displayed by the widget. It is
    a `unique_ptr` pointer, so `MandelbrotWidget` is the owner of `mImage`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImage` 变量是小部件当前显示的图片。它是一个 `unique_ptr` 指针，因此 `MandelbrotWidget` 是 `mImage`
    的所有者。'
- en: 'We can now add the functions. Update your code like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加函数。更新您的代码如下：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before we dive into the implementation, let''s talk about these functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现之前，让我们谈谈这些函数：
- en: The `processJobResults()` function will handle the `JobResult` list dispatched
    by `MandelbrotCalculator`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processJobResults()` 函数将处理由 `MandelbrotCalculator` 分发的 `JobResult` 列表。'
- en: The `requestPicture()` signal is emitted each time the user changes the input
    data (offset, scale, or area size).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当用户更改输入数据（偏移量、缩放或区域大小）时，都会发出 `requestPicture()` 信号。
- en: The `paintEvent()` function draws the widget with the current `mImage`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paintEvent()` 函数使用当前的 `mImage` 绘制小部件。'
- en: The `resizeEvent()` function resizes the Mandelbrot area size when the user
    resizes the window.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户调整窗口大小时，`resizeEvent()` 函数会调整曼德布罗特区域的大小。
- en: The `wheelEvent()` function handles the user mouse wheel event to apply a scale
    factor.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wheelEvent()`函数处理用户的鼠标滚轮事件以应用缩放因子。'
- en: The `mousePressEvent()` function and `mouseMoveEvent()` retrieve user mouse
    events to move the Mandelbrot picture.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousePressEvent()`函数和`mouseMoveEvent()`函数检索用户的鼠标事件以移动Mandelbrot图片。'
- en: The `generateColorFromIteration()` is a helper function to colorize the Mandelbrot
    picture. The iteration value by pixel is converted into a color value.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generateColorFromIteration()`是一个辅助函数，用于将Mandelbrot图片着色。将像素的迭代值转换为颜色值。'
- en: 'We can now implement the `MandelbrotWidget` class. Here is the beginning of
    the `MandelbrotWidget.cpp` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现`MandelbrotWidget`类。以下是`MandelbrotWidget.cpp`文件的开始部分：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At the top of the snippet, we set some constant default values. Feel free to
    tweak these values if you want a different view when you start the application.
    The first thing the constructor does is to change the thread affinity of the `mMandelbrotCalculator`
    class. In this way, processing performed by the calculator (creating and starting
    jobs, aggregating job results, and clearing jobs) does not disturb the UI thread.
    Then we perform connections with the signal and slot of `MandelbrotCalculator`.
    Because the widget and the calculator have a different thread affinity, the connection
    will be automatically a `Qt::QueuedConnection` slot. Finally, we can start the
    thread of `mThreadCalculator`. We can now add the destructor:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的顶部，我们设置了一些默认的常量值。如果您希望在启动应用程序时看到不同的视图，可以随意调整这些值。构造函数首先执行的操作是改变`mMandelbrotCalculator`类的线程亲和性。这样，计算器执行的处理（创建和启动任务、汇总任务结果以及清除任务）不会干扰UI线程。然后，我们与`MandelbrotCalculator`的信号和槽进行连接。由于小部件和计算器有不同的线程亲和性，连接将自动成为`Qt::QueuedConnection`槽。最后，我们可以启动`mThreadCalculator`的线程。现在我们可以添加析构函数：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to request the calculator thread to quit. When the calculator thread
    event loop handles our request, the thread will return a code 0\. We wait 1,000
    ms for the thread to end. We can continue this implementation with all the cases
    that request a new picture. Here is the `resizeEvent()` slot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要请求计算器线程退出。当计算器线程的事件循环处理我们的请求时，线程将返回代码0。我们等待1,000毫秒以等待线程结束。我们可以继续实现所有请求新图片的情况。以下是`resizeEvent()`槽的实现：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We update `mAreaSize` with the new widget size. Then, a new black `QImage`
    is created with the correct dimensions. Finally, we request a picture computation
    to `MandelbrotCalculator`. Let''s see how the mouse wheel is handled:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的小部件大小更新`mAreaSize`。然后，创建一个新的具有正确尺寸的黑色`QImage`。最后，我们请求`MandelbrotCalculator`进行图片计算。让我们看看如何处理鼠标滚轮：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The mouse wheel value can be retrieved from `QWheelEvent::delta()`. We use
    a power function to apply a coherent value on `mScaleFactor` and we request an
    updated picture. We can now implement the pan feature:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从`QWheelEvent::delta()`中检索鼠标滚轮值。我们使用幂函数在`mScaleFactor`上应用一个连贯的值，并请求一张更新后的图片。现在我们可以实现平移功能：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first function stores the mouse position where the user begins the move
    gesture. Then the next function will use `mLastMouseMovePosition` to create an
    offset:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数存储用户开始移动手势时的鼠标位置。然后下一个函数将使用`mLastMouseMovePosition`来创建一个偏移量：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The difference between the new and the old mouse position gives us the pan
    offset. Notice that we invert a y-axis value because the mouse event is in a top-left
    referential, whereas the Mandelbrot algorithm relies on a bottom-left referential.
    Finally, we request a picture with updated input values. We covered all the user
    events that emit a `requestPicture()` signal. Let''s see now how we handle `JobResult`
    dispatched by `MandelbrotCalculator`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新旧鼠标位置之间的差异给我们提供了平移偏移量。请注意，我们反转了y轴的值，因为鼠标事件是在一个左上参照系中，而Mandelbrot算法依赖于一个左下参照系。最后，我们使用更新后的输入值请求一张图片。我们已经涵盖了所有发出`requestPicture()`信号的用戶事件。现在让我们看看我们如何处理由`MandelbrotCalculator`分发的`JobResult`：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The calculator sends us a `QList` of `JobResult`. For each one, we need to check
    if the concerned area size is still valid. We directly update the pixel colors
    of `mImage`. The `scanLine()` function returns a pointer on the pixel data. It
    is a fast way to update a `QImage` pixel color. The `JobResult` function contains
    the iteration count, and our helper function, `generateColorFromIteration()`,
    returns a RGB value depending on the iteration value. A complete repaint of the
    widget is not necessary, because we only update several lines of the `QImage`.
    Thus, we repaint only the updated region.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器发送给我们一个 `QList` 的 `JobResult`。对于每一个，我们需要检查相关区域的大小是否仍然有效。我们直接更新 `mImage` 的像素颜色。`scanLine()`
    函数返回像素数据的指针。这是一种快速更新 `QImage` 像素颜色的方法。`JobResult` 函数包含迭代次数，我们的辅助函数 `generateColorFromIteration()`
    根据迭代值返回一个 RGB 值。不需要完全重绘小部件，因为我们只更新 `QImage` 的几行。因此，我们只重绘更新区域。
- en: 'Here is how we convert an iteration value in an RGB value:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将迭代值转换为 RGB 值的：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Colorizing a Mandelbrot is an art on its own. We implement here a simple linear
    interpolation on the blue channel. A nice Mandelbrot picture depends on the maximum
    iteration per pixel and its color technique. Feel free to enhance it like you
    want!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为曼德布罗集上色本身就是一种艺术。在这里，我们在蓝色通道上实现了一种简单的线性插值。一个漂亮的曼德布罗集图片取决于每个像素的最大迭代次数及其着色技术。你可以随意增强它！
- en: 'Here we are, the last but not least function, `paintEvent()`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了，最后一个但同样重要的函数，`paintEvent()`：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We must override this function because we handle the widget drawing by ourselves.
    The first thing to do is to draw the updated region of the image. The `QPaintEvent`
    object contains the region that needs to be updated. The `QPainter` class makes
    the drawing easy. Finally, we draw some information texts of the current input
    data in white. You now have a complete overview of the progressive picture display
    line by line. Let''s sum up the workflow of this feature:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写这个函数，因为我们自己处理小部件的绘制。首先要做的是绘制图像的更新区域。`QPaintEvent` 对象包含需要更新的区域。`QPainter`
    类使绘制变得简单。最后，我们用白色绘制一些当前输入数据的文本信息。你现在可以逐行查看完整的图片显示概览。让我们总结一下这个功能的流程：
- en: Each `Job::run()` generates a `JobResult` object.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `Job::run()` 生成一个 `JobResult` 对象。
- en: The `MandelbrotCalculator::process()` signal aggregates the `JobResult` object
    and dispatches them by groups (by default, 10).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MandelbrotCalculator::process()` 信号聚合 `JobResult` 对象并将它们按组（默认为10组）分发。'
- en: The `MandelbrotWidget::processJobResults()` signal updates only concerned lines
    of the picture and requests a partial repaint of the widget.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MandelbrotWidget::processJobResults()` 信号只更新图片的相关行，并请求小部件的部分重绘。'
- en: The `MandelbrotWidget::paintEvent()` signal only redraws the picture with the
    new values.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MandelbrotWidget::paintEvent()` 信号只重新绘制带有新值的图片。'
- en: 'This feature causes a little overhead, but the user experience is smoother.
    Indeed, the application reacts quickly to the user events: the first lines are
    updated almost immediately. The user does not have to wait for the full picture
    generation to see something happening.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能会产生一点开销，但用户体验更平滑。确实，应用程序对用户事件反应迅速：前几行几乎立即更新。用户不需要等待整个图片生成才能看到变化。
- en: The widget is ready; do not forget to add it to `MainWindow`. Promoting a custom
    widget should be an easy task for you now. If you have any doubt, check [Chapter
    4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop UI"), *Conquering
    the Desktop UI*, or the complete source code of this chapter. You should now be
    able to display and navigate into your multi-threaded Mandelbrot set!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件已经准备好了；不要忘记将其添加到 `MainWindow`。现在提升自定义小部件应该对你来说是个简单的任务。如果你有任何疑问，请查看[第4章](part0040.xhtml#aid-164MG2
    "第4章。征服桌面UI")，“征服桌面UI”，或本章的完整源代码。你现在应该能够显示并导航到你的多线程曼德布罗集了！
- en: 'If you start the application, you should see something like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动应用程序，你应该会看到类似这样的内容：
- en: '![Displaying the fractal with MandelbrotWidget](img/image00430.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MandelbrotWidget 显示分形](img/image00430.jpeg)'
- en: 'Try to zoom now and pan into the Mandelbrot set. You should find some funny
    places like this one:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试放大并平移到曼德布罗集。你应该会找到一些有趣的地方，就像这样：
- en: '![Displaying the fractal with MandelbrotWidget](img/image00431.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MandelbrotWidget 显示分形](img/image00431.jpeg)'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: You discovered how a `QThread` class works and learned how to efficiently use
    tools provided by Qt to create a powerful multi-threaded application. Your Mandelbrot
    application is able to use all cores of your CPU to compute a picture quickly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了`QThread`类的工作原理，并学习了如何高效地使用Qt提供的工具来创建强大的多线程应用程序。您的Mandelbrot应用程序能够利用CPU的所有核心快速计算图片。
- en: Creating a multi-threaded application presents a lot of pitfalls (deadlock,
    event loop flood, orphan threads, overhead, and so on). The application architecture
    is important. If you are able to isolate the heavy code that you want to parallelize,
    everything should go well. Nevertheless, the user experience is of primary importance;
    you will sometimes have to accept a little overhead if your application gives
    the user a smoother feeling.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个多线程应用程序存在许多陷阱（死锁、事件循环泛滥、孤儿线程、开销等）。应用程序架构非常重要。如果您能够隔离您想要并行化的重代码，一切应该都会顺利。然而，用户体验是最重要的；如果您的应用程序能够给用户带来更平滑的感觉，有时您可能不得不接受一点开销。
- en: In the next chapter, we will see several ways to implement an IPC (Inter-Process
    Communication) between applications. The project example will enhance your current
    Mandelbrot application with a TCP/IP socket system. So the Mandelbrot generator
    will compute pictures over several CPU cores from multiple computers!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨几种在应用程序之间实现进程间通信（IPC）的方法。项目示例将使用TCP/IP套接字系统增强您当前的Mandelbrot应用程序。因此，Mandelbrot生成器将能够在多台计算机的多个CPU核心上计算图片！
