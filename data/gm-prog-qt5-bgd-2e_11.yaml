- en: Introduction to Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 简介
- en: In this chapter, you will be introduced to a technology called **Qt Quick**
    that allows us to implement resolution-independent user interfaces with lots of
    eye-candy, animations, and effects that can be combined with regular Qt code that
    implements the logic of the application. You will learn the basics of the QML
    declarative language that forms the foundation of Qt Quick. You will create a
    simple Qt Quick application and see the advantages offered by the declarative
    approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解到一种名为 **Qt Quick** 的技术，它允许我们实现具有众多视觉效果的分辨率无关的用户界面，包括动画和效果，这些都可以与实现应用程序逻辑的常规
    Qt 代码相结合。您将学习构成 Qt Quick 基础的 QML 声明性语言的基础知识。您将创建一个简单的 Qt Quick 应用程序，并看到声明性方法提供的优势。
- en: 'The main topics covered in this chapter are these:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题包括这些：
- en: QML basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML 基础
- en: Overview of Qt modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 模块概述
- en: Using Qt Quick Designer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Quick 设计器
- en: Utilizing Qt Quick modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Qt Quick 模块
- en: Property bindings and signal handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定和信号处理
- en: Qt Quick and C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 和 C++
- en: States and transitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态和转换
- en: Declarative UI programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明性 UI 编程
- en: Although it is technically possible to use Qt Quick by writing C++ code, the
    module is accompanied by a dedicated programming language called **QML** (**Qt
    Modeling Language**). QML is an easy to read and understand declarative language
    that describes the world as a hierarchy of components that interact and relate
    to one another. It uses a JSON-like syntax and allows us to use imperative JavaScript
    expressions as well as dynamic property bindings. So, what is a declarative language,
    anyway?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可以使用 C++ 代码使用 Qt Quick，但此模块附带一种称为 **QML**（**Qt 模型语言**）的专用编程语言。QML 是一种易于阅读和理解的表达性语言，它将世界描述为组件的层次结构，这些组件相互交互并关联。它使用类似
    JSON 的语法，并允许我们使用命令式 JavaScript 表达式以及动态属性绑定。那么，声明性语言到底是什么呢？
- en: Declarative programming is one of the programming paradigms that dictates that
    the program describes the logic of the computation without specifying how this
    result should be obtained. In contrast to imperative programming, where the logic
    is expressed as a list of explicit steps forming an algorithm that directly modifies
    the intermediate program state, a declarative approach focuses on what the ultimate
    result of the operation should be.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性编程是编程范式之一，它规定程序描述计算的逻辑，而不指定如何获得此结果。与将逻辑表达为形成算法的显式步骤列表、直接修改中间程序状态的命令式编程相反，声明性方法侧重于操作最终结果应该是什么。
- en: Time for action – Creating the first project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 创建第一个项目
- en: Let's create a project to better understand what QML is. In Qt Creator, select
    File and then New File or Project in the main menu. Choose Application in the
    left column and select the Qt Quick Application - Empty template. Name the project
    as `calculator` and go through the rest of the wizard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个项目，以便更好地理解 QML 是什么。在 Qt Creator 中，选择文件，然后在主菜单中选择新建文件或项目。在左侧列中选择应用程序，并选择
    Qt Quick 应用程序 - 空模板。将项目命名为 `calculator` 并完成向导的其余部分。
- en: 'Qt Creator created a sample application that displays an empty window. Let''s
    examine the project files. The first file is the usual `main.cpp`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 创建了一个示例应用程序，显示一个空窗口。让我们检查项目文件。第一个文件是常规的 `main.cpp`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code simply creates the application object, instantiates the QML engine,
    and asks it to load the `main.qml` file from the resources. If an error occurs,
    `rootObjects()` will return an empty list, and the application will terminate.
    If the QML file was loaded successfully, the application enters the main event
    loop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仅创建应用程序对象，实例化 QML 引擎，并请求它从资源中加载 `main.qml` 文件。如果发生错误，`rootObjects()` 将返回一个空列表，应用程序将终止。如果
    QML 文件成功加载，应用程序将进入主事件循环。
- en: The `*.qrc` file is a resource file. The concept of resource files should be
    familiar to you from [Chapter 3](ebffc011-752f-4dbe-a383-0917a002841d.xhtml),
    *Qt GUI Programming*. Basically, it contains the list of arbitrary project files
    that are required for project execution. During compilation, the contents of these
    files are embedded into the executable. You can then retrieve the content at runtime
    by specifying a virtual filename, such as `qrc:/main.qml` in the preceding code.
    You can expand the `Resources` section of the Project tree further to see all
    files added to the resource file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`*.qrc`文件是一个资源文件。从[第3章](ebffc011-752f-4dbe-a383-0917a002841d.xhtml)，*Qt GUI编程*中你应该熟悉资源文件的概念。基本上，它包含项目执行所需的任意项目文件列表。在编译期间，这些文件的内容被嵌入到可执行文件中。然后你可以通过指定一个虚拟文件名来在运行时检索内容，例如前述代码中的`qrc:/main.qml`。你可以进一步展开项目树的`Resources`部分，以查看添加到资源文件中的所有文件。'
- en: 'In the sample project, `qml.qrc` references a QML file named `main.qml`. If
    you don''t see it in the project tree, expand `Resources`, `qml.qrc`, and then
    `/` sections. The `main.qml` file is the top-level QML file that is loaded into
    the engine. Let''s take a look at it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，`qml.qrc`引用了一个名为`main.qml`的QML文件。如果你在项目树中看不到它，请展开`Resources`、`qml.qrc`，然后是`/`部分。`main.qml`文件是加载到引擎中的顶级QML文件。让我们看看它：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file *declares* what objects should be created at the start of the application.
    As it uses some QML types provided by Qt, it contains two `import` directives
    at the top of the file. Each `import` directive contains the name and the version
    of the imported module. In this example, `import QtQuick.Window 2.2` enables us
    to use the `Window` QML type provided by this module.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件*声明*了在应用程序开始时应创建哪些对象。因为它使用了Qt提供的某些QML类型，所以在文件的顶部包含两个`import`指令。每个`import`指令包含导入模块的名称和版本。在这个例子中，`import
    QtQuick.Window 2.2`使我们能够使用此模块提供的`Window` QML类型。
- en: The rest of the file is the declaration of the objects the engine should create.
    The `Window { ... }` construction tells QML to create a new object of the `Window` type. The
    code within this section assigns values to properties of this object. We explicitly
    assign a constant to the `visible`, `width`, and `height` properties of the window
    object. The `qsTr()` function is the translation function, just like `tr()` in
    C++ code. It returns the passed string without change by default. The `title`
    property will contain the result of evaluating the passed expression.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其余部分是引擎应创建的对象的声明。`Window { ... }`构造告诉QML创建一个新的`Window`类型的对象。此部分内的代码为此对象的属性赋值。我们显式地为窗口对象的`visible`、`width`和`height`属性分配了一个常量。`qsTr()`函数是翻译函数，就像C++代码中的`tr()`一样。它默认返回传递的字符串而不做任何更改。`title`属性将包含评估传递的表达式的结果。
- en: Time for action – Editing QML
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编辑QML
- en: 'Let''s add some content to our window. Edit the `main.qml` file with the following
    code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在窗口中添加一些内容。使用以下代码编辑`main.qml`文件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run the project, you will see a text field and a label in the window:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你将在窗口中看到一个文本字段和一个标签：
- en: '![](img/7ef74b08-fdd9-4e08-aae5-da1c917026ce.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ef74b08-fdd9-4e08-aae5-da1c917026ce.png)'
- en: What just happened?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we added an import statement to make the `QtQuick.Controls` module available
    in the current scope. If you're not sure which version to use, invoke Qt Creator's
    code completion and use the most recent version. Due to the new import, we can
    now use the `TextField` and `Label` QML types in our QML file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个导入语句，使`QtQuick.Controls`模块在当前作用域中可用。如果你不确定使用哪个版本，请调用Qt Creator的代码补全并使用最新版本。由于新的导入，我们现在可以在我们的QML文件中使用`TextField`和`Label`
    QML类型。
- en: Next, we declared two **children** of the top-level `Window` object. QML objects
    form a parent-child relationship, much like `QObject` in C++. However, you don't
    need to explicitly assign parents to items. Instead, you declare the object within
    the declaration of its parent, and QML will automatically ensure that relationship.
    In our example, the `TextField { ... }` part tells QML to create a new QML object
    of the `TextField` type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了顶级`Window`对象的两个**子元素**。QML对象形成一个父子关系，类似于C++中的`QObject`。然而，你不需要显式地为项目分配父元素。相反，你可以在其父元素的声明中声明对象，QML将自动确保这种关系。在我们的例子中，`TextField
    { ... }`部分告诉QML创建一个新的`TextField`类型的QML对象。
- en: Since this declaration lies within the `Window { ... }` declaration, the `TextField`
    object will have the `Window` object as its parent. The same applies to the `Label`
    object. You can create multiple levels of nesting in a single file, if needed.
    You can use the `parent` property to access the parent item of the current item.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个声明位于`Window { ... }`声明内，`TextField`对象将以`Window`对象为其父对象。对`Label`对象也是如此。如果需要，您可以在单个文件中创建多个嵌套级别。您可以使用`parent`属性来访问当前项目的父项目。
- en: After declaring a new object, we assign values to its properties within its
    declaration. The `text` property is self-explanatory—it contains the text displayed
    in the UI. Note that the `TextField` object allows the user to edit the text.
    When the text is edited in the UI, the `text` property of the object will reflect
    the new value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明新对象后，我们将在其声明内为其属性分配值。`text`属性是自解释的——它包含在UI中显示的文本。请注意，`TextField`对象允许用户编辑文本。当在UI中编辑文本时，对象的`text`属性将反映新值。
- en: Finally, we assign value to the `anchors` **property group** to position the
    items as we like. We put the text field in the top-left corner of the window and
    put the label in the bottom-left corner. This step requires a more thorough explanation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`anchors` **属性组**分配值以按我们的喜好定位项目。我们将文本字段放在窗口的左上角，并将标签放在左下角。这一步需要更详细的解释。
- en: Property groups
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性组
- en: 'Before we discuss anchors, let''s talk about property groups in general. This
    is a new concept introduced in QML. Property groups are used when there are multiple
    properties with a similar purpose. For example, the `Label` type has a number
    of properties related to the font. They can be implemented as separate properties;
    consider the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论锚点之前，让我们先谈谈属性组的一般概念。这是在QML中引入的新概念。当存在多个具有相似目的的属性时，会使用属性组。例如，`Label`类型有几个与字体相关的属性。它们可以实施为单独的属性；考虑以下示例：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, such repetitive code is hard to read. Luckily, font properties are
    implemented as a property group, so you can set them using the **group notation**
    syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的重复代码难以阅读。幸运的是，字体属性被实现为一个属性组，因此您可以使用**分组符号**语法来设置它们：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is much cleaner! Note that there is no colon character after `font`,
    so you can tell that this is a property group assignment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更简洁！请注意，在`font`之后没有冒号字符，因此您可以知道这是一个属性组赋值。
- en: 'In addition, if you only need to set one subproperty of the group, you can
    use the **dot notation** syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您只需要设置组中的一个子属性，您可以使用**点符号**语法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The dot notation is also used to refer to subproperties in the documentation.
    Note that you should prefer group notation if you need to set more than one subproperty.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号也用于在文档中引用子属性。请注意，如果您需要设置多个子属性，应首选分组符号。
- en: That's all you need to know about property groups. Besides `font`, you can find
    many other property groups in some QML types, for example, `border`, `easing`,
    and `anchors`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性组，你需要了解的就是这些。除了`font`之外，你还可以在QML的一些类型中找到许多其他属性组，例如`border`、`easing`和`anchors`。
- en: Anchors
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点
- en: 'Anchors allow you to manage item geometry by attaching certain points of some
    objects to points of another object. These points are called anchor lines. The
    following diagram shows the anchor lines that are available for each Qt Quick
    item:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点允许您通过将某些对象的某些点附着到另一个对象的点上来管理项目几何形状。这些点被称为锚线。以下图显示了每个Qt Quick项目可用的锚线：
- en: '![](img/525087ad-048e-4dfb-a6dd-2debe2a3e6bd.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/525087ad-048e-4dfb-a6dd-2debe2a3e6bd.png)'
- en: 'You can establish bindings between anchor lines to manage relative positioning
    of items. For each anchor line, there is a property that returns the current coordinate
    of that anchor line. For example, the `left` property returns the *x* coordinate
    of the left border of the item, and the `top` property returns the *y* coordinate
    of its top border. Next, each object contains the `anchors` property group that
    allows you to set coordinates of the anchor line for that item. For example, the `anchors.left` property
    can be used to request the position of the left border of the object. You can
    use these two kinds of properties together to specify relative positions of objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以建立锚线之间的绑定来管理项目的相对位置。对于每个锚线，都有一个属性返回该锚线的当前坐标。例如，`left`属性返回项目左侧边框的`x`坐标，而`top`属性返回其顶部边框的`y`坐标。接下来，每个对象都包含`anchors`属性组，允许你设置该项目的锚线坐标。例如，`anchors.left`属性可以用来请求对象的左侧边框位置。你可以使用这两种类型的属性一起指定对象的相对位置：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code declares that the top anchor line of the object must be bound to the
    bottom anchor line of the other object. It's also possible to specify a margin
    for such binding through properties, such as `anchors.topMargin`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码声明对象的顶部锚线必须绑定到另一个对象的底部锚线。也可以通过属性（如`anchors.topMargin`）指定此类绑定的边距。
- en: 'The `anchors.fill` property is the shortcut for binding the `top`, `bottom`, `left`,
    and `right` anchors to the specified object''s respective anchor lines. As a result,
    the item will have the same geometry as the other object. The following code snippet
    is often used to expand the item to the whole area of its parent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`anchors.fill`属性是将`top`、`bottom`、`left`和`right`锚点绑定到指定对象的相应锚线上的快捷方式。因此，项目将具有与其他对象相同的几何形状。以下代码片段通常用于将项目扩展到其父对象的整个区域：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Time for action – Positioning items relative to each other
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 相对定位项目
- en: 'In our previous example, we used the following code to position the label:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了以下代码来定位标签：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should be able to understand this code by now. The `parent` property returns
    the reference to the parent QML object. In our case, it's the window. The `parent.bottom`
    expression returns the *y* coordinate of the parent's bottom anchor line. By assigning
    this expression to the `anchors.bottom` property, we ensure that the bottom anchor
    line of the label stays in the same position as the bottom anchor line of the
    window. The *x* coordinate is restricted in a similar way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够理解这段代码。`parent`属性返回父QML对象的引用。在我们的例子中，它是窗口。`parent.bottom`表达式返回父对象的底部锚线的`y`坐标。通过将此表达式分配给`anchors.bottom`属性，我们确保标签的底部锚线与窗口的底部锚线保持在同一位置。`x`坐标以类似的方式受到限制。
- en: 'Now, let''s see whether we can position the label just below the text field.
    In order to do that, we need to bind the `anchors.top` property of the label to
    the bottom anchor line of the text field. However, we have no way to access the
    text field from within the label yet. We can fix this by defining the `id` property
    of the text field:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们是否可以将标签定位在文本框下方。为了做到这一点，我们需要将标签的`anchors.top`属性绑定到文本框的底部锚线。然而，我们目前无法从标签内部访问文本框。我们可以通过定义文本框的`id`属性来解决这个问题：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting an ID is similar to assigning the object to a variable. We can now use
    the `textField` variable to refer to our `TextField` object. The label is now
    positioned 20 pixels below the text field.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个ID类似于将对象分配给一个变量。现在我们可以使用`textField`变量来引用我们的`TextField`对象。标签现在位于文本框下方20像素处。
- en: QML types, components, and documents
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML类型、组件和文档
- en: 'QML introduces some new concepts that you should be familiar with. A **QML
    type** is a concept similar to C++ class. Any value or object in QML should have
    some type and should be exposed to JavaScript code in a certain way. There are
    two major kinds of QML types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: QML引入了一些新的概念，你应该熟悉。**QML类型**是一个类似于C++类的概念。QML中的任何值或对象都应该有某种类型，并且应以某种方式暴露给JavaScript代码。QML类型主要有两种：
- en: '**Basic types** are types that hold a concrete value and do not refer to any
    other objects, for example, `string` or `point`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本类型**是包含具体值且不引用任何其他对象的类型，例如`string`或`point`'
- en: '**Object types** are types that can be used to create objects with certain
    functionality and consistent interface'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类型**是可以用来创建具有特定功能一致接口的对象的类型'
- en: Basic QML types are similar to C++ primitive types and data structures, such
    as `QPoint`. Object types are closer to widget classes, such as `QLineEdit`, but
    they are not necessarily tied to GUI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 QML 类型类似于 C++ 原始类型和数据结构，例如 `QPoint`。对象类型更接近于小部件类，例如 `QLineEdit`，但它们不一定与
    GUI 相关。
- en: There are numerous QML types provided by Qt. We've already used the `Window`,
    `TextField`, and `Label` types in our previous examples. You can also create your
    own custom QML types with unique functionality and behavior. The simplest way
    to create a QML type is to add a new `.qml` file with a capitalized name to the
    project. The base file name defines the name of the created QML type. For example,
    the `MyTextField.qml` file will declare a new `MyTextField` QML type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了大量的 QML 类型。我们已经在之前的示例中使用了 `Window`、`TextField` 和 `Label` 类型。你还可以创建具有独特功能和行为的自定义
    QML 类型。创建 QML 类型最简单的方法是将一个新 `.qml` 文件（以大写字母命名）添加到项目中。基本文件名定义了创建的 QML 类型的名称。例如，`MyTextField.qml`
    文件将声明一个新的 `MyTextField` QML 类型。
- en: Any complete and valid QML code is called a **document**. Any valid QML file
    contains a document. It's also possible to load documents from any source (for
    example, over the network). A **component** is a document loaded into the QML
    engine.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任何完整且有效的 QML 代码都称为 **文档**。任何有效的 QML 文件都包含一个文档。从任何来源（例如，通过网络）加载文档也是可能的。**组件**是加载到
    QML 引擎中的文档。
- en: How does it work?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Qt Quick infrastructure hides most of the implementation details from the developer
    and allows you to keep your application code clean. Nevertheless, it's always
    important to understand what's going on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 基础设施隐藏了大部分实现细节，让开发者能够保持应用程序代码的整洁。然而，始终了解正在发生的事情是很重要的。
- en: The **QML engine** is a C++ class that understands QML code and executes the
    required actions to make it work. In particular, the QML engine is responsible
    for creating objects according to the requested hierarchy, assigning values to
    properties, and executing event handlers in response to events.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**QML 引擎**是一个理解 QML 代码并执行使其工作的必要操作的 C++ 类。特别是，QML 引擎负责根据请求的层次结构创建对象，为属性分配值，并在事件发生时执行事件处理器。'
- en: While QML language itself is quite far from JavaScript, it allows you to use
    any JavaScript expressions and code blocks for calculating values and handling
    events. This means that the QML engine must be capable of executing JavaScript.
    Under the hood, the implementation uses a very fast JavaScript engine, so you
    shouldn't usually worry about the performance of your JavaScript code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 QML 语言本身与 JavaScript 相去甚远，但它允许你使用任何 JavaScript 表达式和代码块来计算值和处理事件。这意味着 QML
    引擎必须能够执行 JavaScript。在底层，实现使用了一个非常快速的 JavaScript 引擎，所以你通常不需要担心 JavaScript 代码的性能。
- en: The JavaScript code should be able to interact with QML objects, so every QML
    object is exposed as a JavaScript object with corresponding properties and methods.
    This integration uses the same mechanism that we learned in [Chapter 10](fa5baf43-2d1a-4717-8ac1-cd190ab6e440.xhtml),
    *Scripting*. In C++ code, you have some control over the objects embedded into
    the QML engine and can even create new objects. We will get back to this topic
    later in the chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码应该能够与 QML 对象交互，因此每个 QML 对象都作为具有相应属性和方法的 JavaScript 对象公开。这种集成使用了我们在第
    10 章“脚本”中学到的相同机制。在 C++ 代码中，你可以对嵌入到 QML 引擎中的对象进行一些控制，甚至可以创建新的对象。我们将在本章的后面回到这个话题。
- en: While QML is a general purpose language, Qt Quick is a QML-based module that
    focuses on user interfaces. It provides a two-dimensional hardware accelerated
    canvas that contains a hierarchy of interconnected items. Unlike Qt Widgets, Qt
    Quick was designed to support visual effects and animations efficiently, so you
    can use its powers without significant performance degradation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 QML 是一种通用语言，但 Qt Quick 是一个基于 QML 的模块，专注于用户界面。它提供了一个二维的硬件加速画布，其中包含一系列相互连接的项目。与
    Qt Widgets 不同，Qt Quick 被设计成能够高效地支持视觉效果和动画，因此你可以使用其功能而不会显著降低性能。
- en: Qt Quick views are not based on a web browser engine. Browsers tend to be quite
    heavy, especially for mobile devices. However, you can use a web engine explicitly
    when you need it by adding the `WebView` or `WebEngine` object to your QML files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 视图不是基于网页浏览器引擎的。浏览器通常比较重，尤其是对于移动设备。但是，当你需要时，可以通过在 QML 文件中添加 `WebView`
    或 `WebEngine` 对象来显式使用网页引擎。
- en: Time for action – Property binding
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 属性绑定
- en: 'QML is much more powerful than simple JSON. Instead of specifying an explicit
    value for a property, you can use an arbitrary JavaScript expression that will
    be automatically evaluated and assigned to the property. For example, the following
    code will display "ab" in the label:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: QML 比简单的 JSON 强大得多。你不需要为属性指定一个显式的值，你可以使用任意 JavaScript 表达式，该表达式将被自动评估并分配给属性。例如，以下代码将在标签中显示
    "ab"：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also refer to properties of the other objects in the file. As we saw
    earlier, you can use the `textEdit` variable to set relative position of the label.
    This is one example of a property binding. If the value of the `textField.bottom`
    expression changes for some reason, the `anchors.top` property of the label will
    be automatically updated with the new value. QML allows you to use the same mechanism
    for every property. To make the effect more obvious, let''s assign an expression
    to the label''s text property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以引用文件中其他对象的属性。正如我们之前看到的，你可以使用 `textEdit` 变量来设置标签的相对位置。这是属性绑定的一个例子。如果 `textField.bottom`
    表达式的值因某种原因而改变，标签的 `anchors.top` 属性将自动更新为新值。QML 允许你为每个属性使用相同的机制。为了使效果更明显，让我们将一个表达式分配给标签的文本属性：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now the label''s text will be changed according to this expression. When you
    change the text in the input field, the text of the label will be automatically
    updated!:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，标签的文本将根据这个表达式进行更改。当你更改输入字段中的文本时，标签的文本将自动更新！：
- en: '![](img/8b4e90ea-05d8-45d2-a6a1-4526614636be.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b4e90ea-05d8-45d2-a6a1-4526614636be.png)'
- en: The property binding differs from a regular value assignment and binds the value
    of the property to the value of the supplied JavaScript expression. Whenever the
    expression's value changes, the property will reflect that change in its own value.
    Note that the order of statements in a QML document does not matter as you declare
    relations between properties.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定与常规值赋值不同，它将属性的值绑定到提供的 JavaScript 表达式的值。每当表达式的值发生变化时，属性将反映这种变化在其自己的值中。请注意，QML
    文档中语句的顺序并不重要，因为你在声明属性之间的关系。
- en: This example shows one of the advantages of the declarative approach. We didn't
    have to connect signals or explicitly determine when the text should be changed.
    We just *declared* that the text should be influenced by the input field, and
    the QML engine will enforce that relation automatically.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了声明式方法的一个优点。我们不必连接信号或明确确定何时应该更改文本。我们只需 *声明* 文本应该受输入字段的影响，QML 引擎将自动强制执行这种关系。
- en: 'If the expression is complex, you can replace it with a multiline block of
    text that works as a function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式复杂，你可以用多行文本块替换它，该文本块作为一个函数工作：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also declare and use a named JavaScript function within any QML object
    declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在任何 QML 对象声明中声明和使用一个命名 JavaScript 函数：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A limitation of automatic property updates
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动属性更新的限制
- en: 'QML does its best to determine when the function value may change, but it is
    not omnipotent. For our last function, it can easily determine that the function
    result depends on the value of the `textField.text` property, so it will re-evaluate
    the binding if that value changes. However, in some cases, it can''t know that
    a function may return a different value the next time it is called, and in such
    situations, the statement will not be re-evaluated. Consider the following property
    binding:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: QML 尽力确定函数值何时可能发生变化，但它并非万能。对于我们的最后一个函数，它可以很容易地确定函数结果取决于 `textField.text` 属性的值，因此如果该值发生变化，它将重新评估绑定。然而，在某些情况下，它无法知道函数在下一次调用时可能返回不同的值，在这种情况下，该语句将不会被重新评估。考虑以下属性绑定：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The color will be set at the start of the application, but it will not work
    properly. QML will only call the `colorByTime()` function once when the object
    is initialized, and it will never call it again. This is because it has no way
    of knowing how often this function must be called. We will see how to overcome
    this in [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml), *Customization
    in Qt Quick*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色将在应用程序开始时设置，但将无法正常工作。QML 只会在对象初始化时调用 `colorByTime()` 函数一次，并且它将永远不会再次调用它。这是因为它不知道这个函数必须调用多少次。我们将在第
    12 章 [自定义 Qt Quick](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml) 中看到如何克服这个问题。
- en: Overview of QML types provided by Qt
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 提供的 QML 类型概述
- en: Before we continue to work on our QML application, let's see what the built-in
    libraries are capable of. This will allow us to pick the right modules for the
    task. Qt provides a lot of useful QML types. In this section, we will provide
    an overview of the most useful modules available in Qt 5.9.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续开发我们的 QML 应用程序之前，让我们看看内置库的功能。这将使我们能够选择适合任务的正确模块。Qt 提供了许多有用的 QML 类型。在本节中，我们将概述
    Qt 5.9 中可用的最有用的模块。
- en: 'The following modules are important for building user interfaces:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块对于构建用户界面非常重要：
- en: The `QtQuick` base module provides functionality related to drawing, event handling,
    positioning of elements, transformations, and many other useful types
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick` 基础模块提供了与绘图、事件处理、元素定位、转换以及许多其他有用类型相关的功能'
- en: '`QtQuick.Controls` provides basic controls for user interfaces, such as buttons
    and input fields'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Controls` 提供了用户界面的基本控件，例如按钮和输入字段'
- en: '`QtQuick.Dialogs` contains file dialogs, color dialogs, and message boxes'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Dialogs` 包含文件对话框、颜色对话框和消息框'
- en: '`QtQuick.Extras` provides additional controls, such as dials, tumblers, and
    gauges'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Extras` 提供了额外的控件，例如旋钮、开关和仪表'
- en: '`QtQuick.Window` enables window management'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Window` 启用窗口管理'
- en: '`QtQuick.Layouts` provide layouts for automatic positioning of objects on screen'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Layouts` 提供了在屏幕上自动定位对象的布局'
- en: '`UIComponents` provides tab widget, progress bar, and switch types'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIComponents` 提供了标签控件、进度条和开关类型'
- en: '`QtWebView` allows you to add web content to the application'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtWebView` 允许您将网页内容添加到应用程序中'
- en: '`QtWebEngine` provides more sophisticated web browser functionality'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtWebEngine` 提供了更复杂的网页浏览器功能'
- en: 'If you want to implement rich graphics, the following modules may be of help:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想实现丰富的图形，以下模块可能会有所帮助：
- en: '`QtCanvas3D` provides a canvas for 3D rendering'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCanvas3D` 提供了一个用于 3D 渲染的画布'
- en: '`Qt3D` modules provide access to real-time simulation systems supporting 2D
    and 3D rendering'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt3D` 模块提供了访问支持 2D 和 3D 渲染的实时仿真系统的权限'
- en: '`QtCharts` allows you to create sophisticated charts'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCharts` 允许您创建复杂的图表'
- en: '`QtDataVisualization` can be used to build 3D visualizations of datasets'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtDataVisualization` 可以用于构建数据集的 3D 可视化'
- en: '`QtQuick.Particles` allows you to add particle effects'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.Particles` 允许您添加粒子效果'
- en: '`QtGraphicalEffects` can apply graphical effects (such as blur or shadow) to
    other Qt Quick objects'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtGraphicalEffects` 可以将图形效果（如模糊或阴影）应用于其他 Qt Quick 对象'
- en: 'Qt provides a lot of functionality commonly required on mobile devices:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了在移动设备上通常所需的大量功能：
- en: '`QtBluetooth` supports basic communication with other devices over Bluetooth'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtBluetooth` 支持通过蓝牙与其他设备的基本通信'
- en: '`QtLocation` allows you to display maps and find routes'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtLocation` 允许您显示地图和查找路线'
- en: '`QtPositioning` provides information about the current location'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtPositioning` 提供了当前位置信息'
- en: '`QtNfc` allows you to utilize NFC hardware'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtNfc` 允许您利用 NFC 硬件'
- en: '`QtPurchasing` implements in-app purchases'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtPurchasing` 实现了应用内购买'
- en: '`QtSensors` provides access to on-board sensors, such as accelerometer or gyroscope'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtSensors` 提供了对板载传感器（如加速度计或陀螺仪）的访问'
- en: '`QtQuick.VirtualKeyboard` provides an implementation of an onscreen keyboard'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtQuick.VirtualKeyboard` 提供了一个屏幕键盘的实现'
- en: 'Finally, there are two modules providing multimedia capabilities:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个模块提供了多媒体功能：
- en: '`QtMultimedia` provides access to audio and video playback, audio recording,
    camera, and radio'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtMultimedia` 提供了对音频和视频播放、音频录制、摄像头和收音机的访问'
- en: '`QtAudioEngine` implements 3D positional audio playback'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtAudioEngine` 实现了 3D 定位音频播放'
- en: There are many more QML modules that we didn't mention here. You can find the
    full list on the All QML Modules documentation page. Note that some of the modules
    are not provided under LGPL license.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多我们没有提到的 QML 模块。您可以在所有 QML 模块文档页面上找到完整的列表。请注意，某些模块不在 LGPL 许可下提供。
- en: Qt Quick Designer
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 设计器
- en: We can use QML to easily create a hierarchy of objects. If we need a few input
    boxes or buttons, we can just add some blocks to the code, just like we added
    the `TextField` and `Label` components in the previous example, and our changes
    will appear in the window. However, when dealing with complex forms, it's sometimes
    hard to position the objects properly. Instead of trying different `anchors` and
    relaunching the application, you can use the visual form editor to see the changes
    as you make them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用QML轻松创建对象层次结构。如果我们需要几个输入框或按钮，我们只需在代码中添加一些块，就像我们在前面的例子中添加`TextField`和`Label`组件一样，我们的更改将出现在窗口中。然而，在处理复杂表单时，有时很难正确定位对象。与其尝试不同的`anchors`并重新启动应用程序，不如使用可视表单编辑器在制作更改时查看更改。
- en: Time for action – Adding a form to the project
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 向项目中添加表单
- en: Locate the `qml.qrc` file in Qt Creator's project tree and invoke the Add New...
    option in its context menu. From Qt section, select the QtQuick UI File template.
    Input `Calculator` in the Component name field. The Component form name field
    will be automatically set to `CalculatorForm`. Finish the wizard.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Creator的项目树中找到`qml.qrc`文件，并在其上下文菜单中调用“添加新...”选项。从Qt部分，选择“QtQuick UI文件模板”。在组件名称字段中输入`Calculator`。组件表单名称字段将自动设置为`CalculatorForm`。完成向导。
- en: 'Two new files will appear in our project. The `CalculatorForm.ui.qml` file
    is the form file that can be edited in the form editor. The `Calculator.qml` file
    is a regular QML file that can be edited manually to implement the behavior of
    the form. Each of these files introduces a new QML type. The `CalculatorForm`
    QML type is immediately used in the generated `Calculator.qml` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中将出现两个新文件。`CalculatorForm.ui.qml`文件是可以在表单编辑器中编辑的表单文件。`Calculator.qml`文件是一个常规的QML文件，可以手动编辑以实现表单的行为。这些文件中的每一个都引入了一个新的QML类型。`CalculatorForm`
    QML类型立即在生成的`Calculator.qml`文件中使用：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to edit the `main.qml` file to add a `Calculator` object to the
    window:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编辑`main.qml`文件，向窗口添加一个`Calculator`对象：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: QML components are similar to C++ classes in some way. A QML component encapsulates
    an object tree so that you can use it without knowing about the exact content
    of the component. When the application is started, the `main.qml` file will be
    loaded into the engine, so the `Window` and `Calculator` objects will be created.
    The Calculator object, in turn, will contain a `CalculatorForm` object. The `CalculatorForm`
    object will contain the items that we add later in the form editor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: QML组件在某些方面类似于C++类。一个QML组件封装了一个对象树，这样你就可以在不了解组件确切内容的情况下使用它。当应用程序启动时，`main.qml`文件将被加载到引擎中，因此将创建`Window`和`Calculator`对象。`Calculator`对象反过来将包含一个`CalculatorForm`对象。`CalculatorForm`对象将包含我们在表单编辑器中稍后添加的项目。
- en: Form editor files
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单编辑器文件
- en: When we worked with Qt Widgets form editor, you may have noted that a widget
    form is an XML file that is converted to a C++ class during compilation. This
    does not apply to Qt Quick Designer. In fact, the files produced by this form
    editor are completely valid QML files that are directly included in the project.
    However, the form editor files have a special extension (`.ui.qml`), and there
    are some artificial restrictions that protect you from doing bad things.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Qt Widgets表单编辑器工作时，你可能已经注意到，小部件表单是一个在编译期间转换为C++类的XML文件。这并不适用于Qt Quick Designer。事实上，此表单编辑器生成的文件是完全有效的QML文件，它们直接包含在项目中。然而，表单编辑器文件有一个特殊的扩展名（`.ui.qml`），并且有一些人工限制来保护你免于做错事。
- en: The `ui.qml` files should only contain content that is visible in the form editor.
    You do not need to edit these files by hand. It's not possible to call functions
    or execute JavaScript code from these files. Instead, you should implement any
    logic in a separate QML file that uses the form as a component.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui.qml`文件应只包含在表单编辑器中可见的内容。你不需要手动编辑这些文件。无法从这些文件中调用函数或执行JavaScript代码。相反，你应该在单独的QML文件中实现任何逻辑，该文件将表单作为组件使用。'
- en: If you're curious about the content of a `ui.qml` file, you can click on the Text
    Editor tab that is positioned on the right border of the form editor's central
    area.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇`ui.qml`文件的内容，可以点击位于表单编辑器中央区域右侧的文本编辑器标签。
- en: Form editor interface
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单编辑器界面
- en: 'When you open a `.ui.qml` file, Qt Creator goes to the Design mode and opens
    the Qt Quick Designer interface:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开`.ui.qml`文件时，Qt Creator将进入设计模式并打开Qt Quick Designer界面：
- en: '![](img/77e0308b-cbaf-4db9-9269-498cc96a7cf4.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77e0308b-cbaf-4db9-9269-498cc96a7cf4.png)'
- en: 'We''ve highlighted the following important parts of the interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了界面的以下重要部分：
- en: The main area (**1**) contains visualization of the document's content. You
    can click on the Text Editor tab at the right border of the main area to view
    and edit the QML code of the form without exiting the form editor. The bottom
    part of the main area displays list of states of the component.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主区域（**1**）包含文档内容的可视化。您可以通过点击主区域右侧边界的文本编辑器标签来查看和编辑表单的QML代码，而无需退出表单编辑器。主区域底部显示组件的状态列表。
- en: The Library pane (**2**) shows the available QML object types and allows you
    to create new objects by dragging them to the navigator or to the main area. The
    Imports tab contains a list of available QML modules and allows you to export
    a module and access more QML types.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库面板（**2**）显示可用的QML对象类型，并允许您通过将它们拖动到导航器或主区域来创建新对象。导入标签包含可用QML模块的列表，并允许您导出模块并访问更多QML类型。
- en: The Navigator pane (**3**) displays the hierarchy of the existing objects and
    their names. The buttons to the right of the names allow you to export an object
    as public property and toggle its visibility in the form editor.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航器面板（**3**）显示现有对象及其名称的层次结构。名称右侧的按钮允许您将对象作为公共属性导出并在表单编辑器中切换其可见性。
- en: The Connections pane (**4**) provides ability to connect signals, change property
    bindings, and manage public properties of the form.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接面板（**4**）提供了连接信号、更改属性绑定和管理表单公共属性的能力。
- en: The Properties pane (**5**) allows you to view and edit properties of the selected
    object.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性面板（**5**）允许您查看和编辑所选对象的属性。
- en: We will now use the form editor to create a simple calculator application. Our
    form will contain two input boxes for operands, two radio buttons for selecting
    the operation, a label to display the result, and a button to reset everything
    to the original state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用表单编辑器创建一个简单的计算器应用程序。我们的表单将包含两个用于操作数的输入框，两个用于选择操作的单选按钮，一个用于显示结果的标签，以及一个用于重置一切到原始状态的按钮。
- en: Time for action – Adding an import
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 – 添加导入
- en: The default object palette contains a very minimal set of types provided by
    the `QtQuick` module. To access a richer set of controls, we need to add an `import`
    directive to our document. To do this, locate the Library pane in the top-left
    corner of the window and go to its Imports tab. Next, click on Add Import and
    select QtQuick.Controls 2.2 in the drop-down list. The selected import will appear
    in the tab. You can click on the × button to the left of the import to remove
    it. Note that you cannot remove the default import.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认对象调色板包含由`QtQuick`模块提供的非常少的类型集。要访问更丰富的控件集，我们需要在我们的文档中添加一个`import`指令。为此，请定位窗口左上角的库面板并转到其导入标签。接下来，点击添加导入，并在下拉列表中选择QtQuick.Controls
    2.2。选定的导入将出现在标签中。您可以通过点击导入左侧的×按钮来删除它。请注意，您不能删除默认导入。
- en: Adding the import using the form editor will result in adding the `import QtQuick.Controls
    2.2` directive to the `.ui.qml` file. You can switch the main area to the Text
    Editor mode to see this change.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单编辑器添加导入将会在`.ui.qml`文件中添加`import QtQuick.Controls 2.2`指令。您可以将主区域切换到文本编辑器模式以查看此更改。
- en: Now you can switch back to the QML Types tab of the Library pane. The palette
    will contain controls provided by the imported module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以切换回库面板的QML类型标签。调色板将包含导入模块提供的控件。
- en: Time for action – Adding items to the form
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 – 向表单添加项目
- en: 'Locate the Text Field type in the Qt Quick - Controls 2 section of the library
    pane and drag it to the main area. A new text field will be created. We will also
    need the Radio Button, Label, and Button types from the same section. Drag them
    to the form and arrange them as shown:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在库面板的Qt Quick - Controls 2部分中找到文本字段类型，并将其拖动到主区域。将创建一个新的文本字段。我们还需要从同一部分获取单选按钮、标签和按钮类型。将它们拖动到表单中，并按所示排列：
- en: '![](img/6e977c66-f03a-4ced-b927-27ee0bc1f8b2.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e977c66-f03a-4ced-b927-27ee0bc1f8b2.png)'
- en: Next, you need to select each element and edit its properties. Click on the
    first text field in the main area or in the navigator. The blue frame around the
    object in the main area will indicate that it is selected. Now you can use the
    property editor to view and edit properties of the selected element. First, we
    want to set the `id` property that will be used to refer to the object in the
    code. Set the `id` property of the text edits to `argument1` and `argument2`.
    Locate the Text property under the TextField tab in the property editor. Set it
    to `0` for both text fields. The changed text will be immediately displayed in
    the main area.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要选择每个元素并编辑其属性。在主区域或导航器中单击第一个文本字段。主区域中对象周围的蓝色框架将指示该对象已被选中。现在您可以使用属性编辑器查看和编辑选中元素的属性。首先，我们想要设置一个`id`属性，该属性将用于在代码中引用对象。将文本编辑的`id`属性设置为`argument1`和`argument2`。在属性编辑器中的`TextField`选项卡下找到`Text`属性。将两个文本字段的`Text`属性都设置为`0`。更改后的文本将立即在主区域中显示。
- en: Set `id` of the radio buttons to `operationAdd` and `operationMultiply`. Set
    their text to `+` and `×`. Set the `checked` property of the `operationAdd` button
    to `true` by toggling the corresponding checkbox in the property editor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将单选按钮的`id`设置为`operationAdd`和`operationMultiply`。将它们的文本设置为`+`和`×`。通过在属性编辑器中切换相应的复选框，将`operationAdd`按钮的`checked`属性设置为`true`。
- en: The first label will be used to statically display the `=` sign. Set its `id`
    to `equalSign` and `text` to `=`. The second label will actually display the result.
    Set its `id` to `result`. We will take care of the `text` property later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标签将用于静态显示`=`符号。将其`id`设置为`equalSign`，`text`设置为`=`。第二个标签实际上将显示结果。将其`id`设置为`result`。我们稍后会处理`text`属性。
- en: The button will reset the calculator to the original state. Set its `id` to
    `reset` and `text` to `Reset`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该按钮将重置计算器到原始状态。将其`id`设置为`reset`，`text`设置为`Reset`。
- en: You can run the application now. You will see that the controls are shown in
    the window, but they are not repositioned in respect to the window size. They
    always stay in the same positions. If you check out the text content of `CalculatorForm.ui.qml`,
    you will see that the form editor sets the `x` and `y` properties of each element.
    To make a more responsive form, we need to utilize the `anchors` property instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序。您会看到控件在窗口中显示，但它们相对于窗口大小没有重新定位。它们始终保持在相同的位置。如果您检查`CalculatorForm.ui.qml`的文本内容，您会看到表编辑器为每个元素设置了`x`和`y`属性。为了创建一个更响应式的表单，我们需要利用`anchors`属性。
- en: Time for action – Editing anchors
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 编辑锚点
- en: Let's see how we can edit anchors in the form editor and see the result on the
    fly. Select the `argument1` text field and switch to the Layout tab in the middle
    part of the Properties pane. The tab contains Anchors text, followed by a set
    of buttons for all anchor lines of this item. You can mouse over the buttons to
    see their tooltips. Click on the first button,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在表编辑器中编辑锚点，并实时查看结果。选择`argument1`文本字段，切换到属性面板中间部分的布局选项卡。该选项卡包含“锚点”文本，后面是一组按钮，用于此项目的所有锚线。您可以将鼠标悬停在按钮上以查看其工具提示。单击第一个按钮，
- en: Anchor item to the top. A new set of controls will appear below the button,
    allowing you to configure this anchor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将锚点项锚定到顶部。按钮下方将出现一组新的控件，允许您配置此锚点。
- en: First, you can select the target object, that is, the object containing the
    anchor line that will be used as the reference. Next, you can select the margin
    between the reference anchor line and the anchor line of the current object. To
    the right of the margin, there are buttons that allow you to choose which anchor
    line of the target to use as the reference. For example, if you choose the bottom
    line, our text field will retain its position relative to the bottom border of
    the form.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以选择目标对象，即包含用作参考的锚线的对象。接下来，您可以选择参考锚线和当前对象的锚线之间的边距。边距右侧有按钮，允许您选择要作为参考的目标的哪个锚线。例如，如果您选择底部线，我们的文本字段将保持相对于表底部的位置。
- en: 'Anchor the top line of the text field to the top line of the parent and set
    Margin to 20\. Next, anchor the horizontal center line to parent with Margin 0\.
    The property editor should look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本字段的顶部行锚定到父元素的顶部行，并将边距设置为20。接下来，将水平中心线锚定到父元素，边距为0。属性编辑器应如下所示：
- en: '![](img/94d9e4eb-eaed-45a2-a566-fa4be81e576b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94d9e4eb-eaed-45a2-a566-fa4be81e576b.png)'
- en: 'You can also verify the QML representation of these settings:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以验证这些设置的QML表示：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you drag the text field around using the mouse instead of setting the anchors,
    the form editor will set the `x` and `y` properties to position the element according
    to your actions. If you edit anchors of the item afterward, the `x` and `y` properties
    may remain set, but their effect will be overridden by the anchor effects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用鼠标拖动文本字段而不是设置锚点，表单编辑器将设置 `x` 和 `y` 属性以根据您的操作定位元素。如果您之后编辑项目的锚点，`x` 和 `y`
    属性可能仍然被设置，但它们的效果将被锚点效果覆盖。
- en: Let's repeat this process for the `operationAdd` radio button. First, we need
    to adjust its horizontal position relative to the horizontal center of the form.
    Select the radio button, click on the ![](img/1a31d9cc-40ac-4379-965f-3173d6cb6f85.png) Anchor
    item to the right button, leave `parent` as the target, and click on the
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复这个过程，针对 `operationAdd` 单选按钮。首先，我们需要调整其相对于表单横向中心的水平位置。选择单选按钮，点击右侧的 ![](img/1a31d9cc-40ac-4379-965f-3173d6cb6f85.png)
    锚点项目，将目标设置为 `parent`，然后点击
- en: '![](img/a72fda6d-5348-4cb5-9df5-0980531c8e12.png) Anchor to the horizontal
    center of the target button to the right of the margin input. Set margin to `10`.
    This will allow us to position the second radio button 10 points to the right
    of the horizontal center, and the space between the radio buttons will be 20.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/a72fda6d-5348-4cb5-9df5-0980531c8e12.png) 将锚点设置为目标按钮右侧的横向中心。设置边距为 `10`。这将使我们能够将第二个单选按钮定位在横向中心的右侧10点处，并且单选按钮之间的空间将是20点。'
- en: Now, what about the top anchor? We can attach it to the parent and just set
    the margin that will look nice. However, ultimately, what we want is a specific
    vertical margin between the first text field and the first radio button. We can
    do this easily.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于顶部锚点？我们可以将其附加到父元素上，并设置看起来很漂亮的边距。然而，我们最终想要的是第一个文本字段和第一个单选按钮之间的特定垂直边距。我们可以轻松地做到这一点。
- en: Enable the top anchor for the `operationAdd` radio button, select `argument1`
    in the Target drop-down list, click on the ![](img/7d6a8982-6c6a-457e-8c96-ed97c97a9cfe.png) Anchor
    to the bottom of the target button to the right of the margin field, and input
    20 in the margin field. Now the radio button is anchored to the text field above
    it. Even if we change the height of the text field, the vertical margin between
    the elements will stay intact. You can run the application and verify that the
    `argument1` and `operationAdd` elements now respond to window size changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `operationAdd` 单选按钮启用顶部锚点，在目标下拉列表中选择 `argument1`，点击 ![](img/7d6a8982-6c6a-457e-8c96-ed97c97a9cfe.png)
    锚点至目标按钮右侧的边距字段底部，并在边距字段中输入20。现在单选按钮已锚定到其上方的文本字段。即使我们更改文本字段的高度，元素之间的垂直边距也将保持不变。您可以运行应用程序并验证
    `argument1` 和 `operationAdd` 元素现在对窗口大小变化做出响应。
- en: Now, all we need is to repeat this process for the rest of the objects. However,
    this is quite a tedious task. It will get even more inconvenient in a larger form.
    Making changes to such forms will also be cumbersome. For example, to change the
    order of fields, you will need to carefully edit the anchors of involved objects.
    While anchors are good in simple cases, it's better to use a more automated approach
    for large forms. Luckily, Qt Quick provides layouts for this purpose.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要对剩余的对象重复此过程。然而，这相当繁琐。在更大的表单中会更不方便。对这样的表单进行更改也会很麻烦。例如，要更改字段的顺序，您需要仔细编辑相关对象的锚点。虽然锚点在简单情况下很好，但对于大型表单，使用更自动化的方法会更好。幸运的是，Qt
    Quick 提供了布局来实现这个目的。
- en: Time for action – Applying layouts to the items
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将布局应用于项目
- en: Before we apply layouts to objects, remove the anchors we had created. To do
    this, select each element and click on the buttons under Anchors text to uncheck
    them. The anchor properties below the buttons will disappear. The layout will
    now be able to position the objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将布局应用于对象之前，删除我们创建的锚点。为此，选择每个元素，然后点击“锚点”文本下的按钮取消选中它们。按钮下面的锚点属性将消失。布局现在可以定位对象。
- en: 'First, import the `QtQuick.Layouts 1.3` module into the form, like we did earlier
    for `QtQuick.Controls`. Locate the Qt Quick - Layouts section in the palette and
    examine the available layouts:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `QtQuick.Layouts 1.3` 模块导入表单，就像我们之前导入 `QtQuick.Controls` 一样。在调色板中找到 Qt
    Quick - 布局部分，并检查可用的布局：
- en: Column Layout will arrange its children vertically
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列布局将垂直排列其子元素。
- en: Row Layout will arrange its children horizontally
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行布局将水平排列其子元素。
- en: Grid Layout will arrange its children vertically and horizontally in a grid
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格布局将垂直和水平排列其子元素。
- en: Stack Layout will display only one of its children and hide the rest of them
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈布局将只显示其子项中的一个，并隐藏其余的。
- en: Layouts are sensitive to the hierarchy of the objects. Let's use Navigator instead
    of the main area to manage our items. This will allow us to see the parent-child
    relationships between items more clearly. First, drag a Row Layout and drop it
    over the root item in the Navigator. A new `rowLayout` object will be added as
    a child of the root object. Next, drag the `operationAdd` and `operationMultiply`
    objects in the Navigator and drop them to the `rowLayout`. The radio buttons are
    now children of the row layout, and they are automatically positioned next to
    each other.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 布局对对象的层次结构很敏感。让我们使用导航器而不是主区域来管理我们的项目。这将使我们能够更清楚地看到项目之间的父子关系。首先，将行布局拖动到导航器中的根项目上。将一个新的`rowLayout`对象添加为根对象的子项。接下来，将导航器中的`operationAdd`和`operationMultiply`对象拖动到`rowLayout`上。单选按钮现在是行布局的子项，并且它们自动并排定位。
- en: 'Now, drag a Column Layout to the root object. Select all other children of
    the root object, including `rowLayout`, in the Navigator, and drag them to the
    `columnLayout` object. If the items end up in wrong order, use the Move up and
    Move down buttons at the top part of the Navigator to arrange the items properly.
    You should get the following hierarchy:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将列布局拖动到根对象。在导航器中选择根对象的其余子项，包括`rowLayout`，并将它们拖动到`columnLayout`对象。如果项目最终顺序错误，请使用导航器顶部的向上移动和向下移动按钮来正确排列项目。您应该得到以下层次结构：
- en: '![](img/dbf872b0-4e72-442e-b1be-514cce400e21.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbf872b0-4e72-442e-b1be-514cce400e21.png)'
- en: The `columnLayout` object will automatically position its children, but how
    to position the object itself? We should use anchors to do that. Select `columnLayout`,
    switch to the Layout tab in the property editor and click on the ![](img/60485259-c353-44c3-85ce-97228e21b65a.png) Fill
    parent item button. This will automatically create 4 anchor bindings and expand
    `columnLayout` to fill the form.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`columnLayout`对象将自动定位其子项，但如何定位对象本身呢？我们应该使用锚点来做到这一点。选择`columnLayout`，在属性编辑器中切换到布局选项卡并点击![图片](img/60485259-c353-44c3-85ce-97228e21b65a.png)填充父项按钮。这将自动创建4个锚点绑定并将`columnLayout`扩展以填充表单。'
- en: The items are now positioned automatically, but they are bound to the left border
    of the window. Let's align them to the middle. Select the first text field and
    switch to the Layout tab. As the object is now in a layout, the anchor settings
    are replaced with settings the layout understands. The Alignment property defines
    how the item is positioned within the available space. Select `AlignHCenter` in
    the first drop-down list. Repeat the process for each direct child of `columnLayout`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已自动定位，但它们被绑定到窗口的左侧边界。让我们将它们对齐到中间。选择第一个文本字段并切换到布局选项卡。由于对象现在处于布局中，锚点设置被布局理解的设置所取代。对齐属性定义了项目如何在可用空间内定位。在第一个下拉列表中选择`AlignHCenter`。为`columnLayout`的每个直接子项重复此过程。
- en: 'You can now run the application and see how it reacts to changing window size:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序并查看它如何对窗口大小的变化做出反应：
- en: '![](img/19f83386-3473-4113-9cb0-106471ae5b54.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19f83386-3473-4113-9cb0-106471ae5b54.png)'
- en: The form is ready. Let's implement the calculations now.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表单已准备好。现在让我们进行计算。
- en: Time for action – Assigning an expression to the property
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将表达式分配给属性
- en: As you already saw, assigning constant text to a label is easy. However, you
    can also assign a dynamic expression to any property in the form editor. To do
    that, select the `result` label and mouse over the circle in the left part of
    Text property input field. When the circle turns into an arrow, click on it and
    select Set Binding in the menu. Input `argument1.text + argument2.text` in the
    binding editor and confirm the change.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，将常量文本分配给标签很容易。然而，您也可以在表单编辑器中为任何属性分配动态表达式。为此，选择`result`标签并将鼠标悬停在文本属性输入字段左侧的部分圆圈上。当圆圈变成箭头时，点击它并在菜单中选择设置绑定。在绑定编辑器中输入`argument1.text
    + argument2.text`并确认更改。
- en: If you run the application now, you will see that the `result` label will always
    display the concatenation of the strings the user inputs in the fields. That's
    because the `argument1.text` and `argument2.text` properties have the `string`
    type, so the `+` operation performs concatenation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，您将看到`result`标签将始终显示用户在字段中输入的字符串的连接。这是因为`argument1.text`和`argument2.text`属性具有`string`类型，所以`+`操作执行连接。
- en: This feature is very useful if you need to apply simple bindings. However, it
    is not sufficient in our case, as we need to convert strings to numbers and select
    which arithmetic operation the user requested. Using functions in the form editor
    is not allowed, so we cannot implement this complex logic right here. We need
    to do it in the `Calculator.qml` file. This restriction will help us separate
    the view from the logic behind it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要应用简单的绑定，此功能非常有用。然而，在我们的情况下，这并不足够，因为我们需要将字符串转换为数字并选择用户请求的算术运算。在表单编辑器中使用函数是不允许的，因此我们无法在这里实现这种复杂的逻辑。我们需要在`Calculator.qml`文件中完成它。这种限制将帮助我们分离视图及其背后的逻辑。
- en: Time for action – Exposing items as properties
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 将项目公开为属性
- en: Children of a component are not available from outside of it by default. This
    means that `Calculator.qml` cannot access input fields or radio buttons of our
    form. To implement the logic of the calculator, we need to access these objects,
    so let's expose them as public properties. Select the `argument1` text field in
    the Navigator and click on the ![](img/49a5ea47-dcc2-497f-b3e8-3b6cf42e19da.png)
    Toggles whether this item is exported as an alias property of the root item button to
    the right of the object ID. After you click on the button, its icon will change
    to indicate that the item is exported. Now we can use the `argument1` public property
    in `Calculator.qml` to access the input field object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的子组件默认情况下不可从外部访问。这意味着`Calculator.qml`无法访问表单的输入字段或单选按钮。为了实现计算器的逻辑，我们需要访问这些对象，因此让我们将它们作为公共属性公开。在导航器中选择`argument1`文本字段，然后点击![图片](img/49a5ea47-dcc2-497f-b3e8-3b6cf42e19da.png)切换是否将此项目作为根项按钮右侧对象ID的别名属性导出。点击按钮后，其图标将改变以指示项目已导出。现在我们可以在`Calculator.qml`中使用`argument1`公共属性来访问输入字段对象。
- en: Enable public properties for the `argument1`, `argument2`, `operationAdd`, `operationMultiply`,
    and `result` objects. The rest of the objects will remain hidden as implementation
    details of the form.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为`argument1`、`argument2`、`operationAdd`、`operationMultiply`和`result`对象启用公共属性。其余对象将保持隐藏，作为表单的实现细节。
- en: 'Now go to the `Calculator.qml` file and use the exposed properties to implement
    the calculator logic:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到`Calculator.qml`文件，并使用公开属性来实现计算器逻辑：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What just happened?
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Since we exported objects as properties, we can access them by ID from outside
    of the form. In this code, we bind the `text` property of the `result` object
    to the return value of the code block that is enclosed in braces. We use `argument1.text` and
    `argument2.text` to access the current text of the input fields. We also use `operationMultiply.checked` to
    see whether the user checked the `operationMultiply` radio button. The rest is
    just straightforward JavaScript code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将对象作为属性导出，我们可以从表单外部通过ID访问它们。在这段代码中，我们将`result`对象的`text`属性绑定到括号内代码块的返回值。我们使用`argument1.text`和`argument2.text`来访问输入字段的当前文本。我们还使用`operationMultiply.checked`来查看用户是否选中了`operationMultiply`单选按钮。其余部分只是简单的JavaScript代码。
- en: Run the application and see how the result label automatically displays the
    result when the user interacts with the form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并观察当用户与表单交互时，结果标签如何自动显示结果。
- en: Time for action – Creating an event handler
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 创建事件处理器
- en: 'Let''s implement the last bit of functionality. When the user clicks on the
    Reset button, we should change the form''s values. Go back to the form editor
    and right-click on the `reset` button in the Navigator or in the main area. Select
    Add New Signal Handler. Qt Creator will navigate to the corresponding implementation
    file (`Calculator.qml`) and display the Implement Signal Handler dialog. Select
    the `clicked` signal in the drop-down list and click on the OK button to confirm
    the operation. This operation will do two things:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现最后一点功能。当用户点击重置按钮时，我们应该更改表单的值。回到表单编辑器，在导航器或主区域中右键单击`reset`按钮。选择添加新信号处理器。Qt
    Creator将导航到相应的实现文件（`Calculator.qml`）并显示“实现信号处理器”对话框。在下拉列表中选择`clicked`信号，然后点击“确定”按钮以确认操作。此操作将执行以下两项操作：
- en: The `reset` button will be automatically exported as a public property, just
    like we did it manually for the other controls
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`按钮将自动导出为公共属性，就像我们手动为其他控件做的那样。'
- en: Qt Creator will create a boilerplate for the new signal handler in the `Calculator.qml`
    file
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Creator将在`Calculator.qml`文件中为新的信号处理器创建模板。
- en: 'Let''s add our implementation to the automatically generated block:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的实现添加到自动生成的块中：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the button is clicked on, this code will be executed. The text fields will
    be set to 0, and the `operationAdd` radio button will be checked. The `operationMultiply`
    radio button will be unchecked automatically.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，这段代码将被执行。文本字段将被设置为 0，并且 `operationAdd` 单选按钮将被选中。`operationMultiply`
    单选按钮将自动取消选中。
- en: Our calculator fully works now! We used declarative approach to implement a
    nicely looking and responsive application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算器现在完全工作！我们使用了声明式方法来实现一个看起来很好看且响应迅速的应用程序。
- en: Qt Quick and C++
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 快速开发与 C++
- en: While QML has a lot of built-in functionality available, it will almost never
    be enough. When you're developing a real application, it always needs some unique
    functionality that is not available in QML modules provided by Qt. The C++ Qt
    classes are much more powerful, and third-party C++ libraries are also always
    an option. However, the C++ world is separated from our QML application by the
    restrictions of QML engine. Let's break that boundary right away.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 QML 有很多内置的功能可用，但它几乎永远不够用。当你开发一个真实的应用程序时，它总是需要一些独特的功能，而这些功能在 Qt 提供的 QML 模块中是不可用的。C++
    Qt 类功能更强大，第三方 C++ 库也是一个选项。然而，C++ 世界被 QML 引擎的限制与我们的 QML 应用程序隔离开来。让我们立即打破这个界限。
- en: Accessing C++ objects from QML
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 QML 访问 C++ 对象
- en: Let's say that we want to perform a heavy calculation in C++ and access it from
    our QML calculator. We will choose factorial for this project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在 C++ 中执行一个复杂的计算，并从我们的 QML 计算器中访问它。我们将选择阶乘作为这个项目的功能。
- en: The QML engine is really fast, so you can most likely calculate factorials directly
    in JavaScript without performance problems. We just use it here as a simple example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: QML 引擎非常快，所以你很可能会直接在 JavaScript 中计算阶乘而不会出现性能问题。我们在这里只是用它作为一个简单的例子。
- en: Our goal is to inject our C++ class into the QML engine as a JavaScript object
    that will be available in our QML files. We will do that exactly like we did it
    in [Chapter 10](fa5baf43-2d1a-4717-8ac1-cd190ab6e440.xhtml), *Scripting*. The
    `main` function creates a `QQmlApplicationEngine` object that inherits `QJSEngine`,
    so we have access to the API that is already familiar to us from that chapter.
    Here, we'll just show how we can apply this knowledge to our application without
    going into detail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将我们的 C++ 类注入到 QML 引擎中，作为一个 JavaScript 对象，这样我们就可以在我们的 QML 文件中使用它。我们将按照我们在
    [第 10 章](fa5baf43-2d1a-4717-8ac1-cd190ab6e440.xhtml)，*脚本* 中所做的那样来做。`main` 函数创建了一个继承自
    `QJSEngine` 的 `QQmlApplicationEngine` 对象，因此我们可以访问从那一章中已经熟悉的 API。在这里，我们将仅展示如何将此知识应用到我们的应用程序中，而不会深入细节。
- en: Go to the Edit mode, right-click on the project in the project tree and select
    Add New. Select the C++ Class template, input `AdvancedCalculator` as the class
    name and select QObject in the Base Class drop-down list.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 进入编辑模式，在项目树中右键单击项目，并选择“添加新项”。选择 C++ 类模板，输入 `AdvancedCalculator` 作为类名，并在基类下拉列表中选择
    QObject。
- en: 'Declare the invokable `factorial` function in the generated `advancedcalculator.h`
    file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 `advancedcalculator.h` 文件中声明可调用的 `factorial` 函数：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can implement this function using the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来实现这个函数：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We guard the implementation against too large inputs because `double` wouldn't
    be able to fit the resulting values anyway. We also return `NaN` on invalid inputs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保护实现以防止输入过大，因为 `double` 无法容纳结果值。我们还在无效输入时返回 `NaN`。
- en: 'Next, we need to create an instance of this class and import it into the QML
    engine. We do this in the `main()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建这个类的实例并将其导入 QML 引擎。我们在 `main()` 中这样做：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our object is now available as the `advancedCalculator` global variable. Now
    we need to use this variable in the QML file. Open the form editor and add the
    third radio button to the `rowLayout` item. Set `id` of the radio button to `operationFactorial`
    and text to `!`. Export this radio button as a public property so that we can
    access it from the outside. Next, let''s adjust the `result.text` property binding
    in the `Calculator.qml` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对象现在作为 `advancedCalculator` 全局变量可用。现在我们需要在 QML 文件中使用这个变量。打开表单编辑器，并将第三个单选按钮添加到
    `rowLayout` 项目中。将单选按钮的 `id` 设置为 `operationFactorial` 并将文本设置为 `!`。将这个单选按钮导出为一个公共属性，这样我们就可以从外部访问它。接下来，让我们调整
    `Calculator.qml` 文件中的 `result.text` 属性绑定：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the `operationFactorial` radio button is checked, this code will call the `factorial()`
    method of the `advancedCalculator` variable and return it as the result. The user
    will see it as text of the `result` label. When factorial operation is selected,
    the second text field is unused. We'll do something about that later in this chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果勾选了`operationFactorial`单选按钮，此代码将调用`advancedCalculator`变量的`factorial()`方法，并将其作为结果返回。用户将看到它作为`result`标签的文本。当选择阶乘操作时，第二个文本字段将不被使用。我们将在本章后面对此进行处理。
- en: For more information about exposing C++ API to JavaScript, refer to [Chapter
    10](fa5baf43-2d1a-4717-8ac1-cd190ab6e440.xhtml), *Scripting*. Most of the techniques
    described there apply to the QML engine as well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将C++ API暴露给JavaScript的更多信息，请参阅第10章，*脚本*。其中描述的大部分技术也适用于QML引擎。
- en: We exposed a C++ object as a JavaScript object that is accessible from the QML
    engine. However, it is not a QML object, so you can't include it in the QML objects
    hierarchy or apply property bindings to properties of the object that was created
    this way. It's possible to create a C++ class that will work as a fully functional
    QML type, leading to a more powerful integration of C++ and QML. We will show
    that approach in [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml), *Customization
    in Qt Quick*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个C++对象暴露为JavaScript对象，该对象可以从QML引擎中访问。然而，它不是一个QML对象，因此您不能将其包含在QML对象层次结构中，也不能将属性绑定应用于以这种方式创建的对象的属性。可以创建一个C++类，使其作为一个完全功能的QML类型工作，从而实现更强大的C++和QML集成。我们将在第12章，*Qt
    Quick中的自定义*中展示这种方法。
- en: 'There is another way to expose our `AdvancedCalculator` class to JavaScript.
    Instead of adding it to the global object, we can register it as a singleton object
    in the QML module system using the `qmlRegisterSingletonType()` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将我们的`AdvancedCalculator`类暴露给JavaScript的方法是，而不是将其添加到全局对象中，我们可以使用`qmlRegisterSingletonType()`函数将其注册为QML模块系统中的单例对象：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We pass the QML module name, major and minor versions, and the singleton name
    to this function. You can choose these values arbitrarily. The last argument is
    a callback function that will be called when this singleton object is accessed
    in the JS engine for the first time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将QML模块名称、主版本号和次版本号以及单例名称传递给此函数。您可以选择这些值。最后一个参数是一个回调函数，当此单例对象在JS引擎中首次被访问时将被调用。
- en: 'The QML code also needs to be slightly adjusted. First, import our new QML
    module into scope:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: QML代码也需要稍作调整。首先，将我们的新QML模块导入作用域中：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you can just access the singleton by name:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需通过名称访问单例即可：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When this line is executed for the first time, Qt will call our C++ callback
    and create the singleton object. For subsequent calls, the same object will be
    used.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当此行首次执行时，Qt将调用我们的C++回调并创建单例对象。对于后续调用，将使用相同的对象。
- en: Accessing QML objects from C++
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++访问QML对象
- en: It is also possible to create QML objects from C++ and access the existing objects
    living in the QML engine (for example, those declared in some QML file). However,
    in general, doing this thing is bad practice. If we assume the most common case,
    which is that the QML part of our application deals with a user interface in Qt
    Quick for the logic written in C++, then accessing Qt Quick objects from C++ breaks
    the separation between logic and the presentation layer, which is one of the major
    principles in GUI programming. The user interface is prone to dynamic changes,
    relayouting up to a complete revamp. Heavy modifications of QML documents, such
    as adding or removing items from the design, will then have to be followed by
    adjusting the application logic to cope with those changes. In addition, if we
    allow a single application to have multiple user interfaces (skins), it might
    happen that because they are so different, it is impossible to decide upon a single
    set of common entities with hard-coded names that can be fetched from C++ and
    manipulated. Even if you managed to do that, such an application could crash easily
    if the rules were not strictly followed in the QML part.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以从 C++ 创建 QML 对象并访问存在于 QML 引擎中的现有对象（例如，在某个 QML 文件中声明的那些）。然而，总的来说，这样做通常是不良实践。如果我们假设最常见的情况，即我们的应用程序的
    QML 部分处理 Qt Quick 的用户界面，而逻辑是用 C++ 编写的，那么从 C++ 访问 Qt Quick 对象会打破逻辑和表示层之间的分离，这是
    GUI 编程中的一个主要原则。用户界面容易受到动态变化的影响，包括重新布局甚至彻底的改造。对 QML 文档的重度修改，如添加或删除设计中的项目，随后将需要调整应用程序逻辑以应对这些变化。此外，如果我们允许单个应用程序拥有多个用户界面（皮肤），可能会发生这样的情况，即由于它们差异很大，很难决定一组具有硬编码名称的通用实体，这些实体可以从
    C++ 中检索并操作。即使你设法做到了，如果 QML 部分没有严格遵守规则，这样的应用程序也可能会轻易崩溃。
- en: That said, we have to admit that there are cases when it does make sense to
    access QML objects from C++, and that is why we decided to familiarize you with
    the way to do it. One of the situations where such an approach is desired is when
    QML serves us as a way to quickly define a hierarchy of objects with properties
    of different objects linked through more or fewer complex expressions, allowing
    them to answer to changes taking place in the hierarchy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们不得不承认，确实存在一些情况下从 C++ 访问 QML 对象是有意义的，这就是我们决定向您介绍如何实现这一方法的原因。其中一种希望采用这种方法的情形是，当
    QML 作为一种快速定义具有不同对象属性的对象层次结构的方式时，通过更多或更少的复杂表达式将这些对象链接起来，使它们能够响应层次结构中发生的变化。
- en: The `QQmlApplicationEngine` class provides access to its top-level QML objects
    through the `rootObjects()` function. All nested QML objects form a parent-child
    hierarchy visible from C++, so you can use `QObject::findChild` or `QObject::findChildren`
    to access the nested objects. The most convenient way to find a specific object
    is to set its `objectName` property. For example, if we want to access the reset
    button from C++, we need to set its object name.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`QQmlApplicationEngine` 类通过 `rootObjects()` 函数提供对其顶级 QML 对象的访问。所有嵌套的 QML 对象形成一个从
    C++ 可见的父子层次结构，因此您可以使用 `QObject::findChild` 或 `QObject::findChildren` 来访问嵌套对象。找到特定对象最方便的方法是设置其
    `objectName` 属性。例如，如果我们想从 C++ 访问重置按钮，我们需要设置其对象名。'
- en: 'The form editor does not provide a way to set `objectName` for its items, so
    we need to use the text editor to make this change:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表单编辑器不提供为项目设置 `objectName` 的方法，因此我们需要使用文本编辑器来做出这个更改：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now access this button from the `main` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `main` 函数中访问这个按钮：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this code, we first access the top-level `Window` QML object. Then, we use
    the `findChild` method to find the object corresponding to our reset button. The
    `findChild()` method requires us to pass a class pointer as the template argument.
    Without knowing what class actually implements a given type, it is safest to simply
    pass `QObject*` as, once again, we know all QML objects inherit it. It is more
    important what gets passed as the function argument value—it is the name of the
    object we want returned. Note that it is not the `id` of the object but the value
    of the `objectName` property. When the result gets assigned to the variables,
    we verify whether the item has been successfully found and if that is the case,
    the generic `QObject` API is used to set its `highlighted` property to `true`.
    This property will change the appearance of the button.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先访问顶级的 `Window` QML 对象。然后，我们使用 `findChild` 方法找到与我们的重置按钮相对应的对象。`findChild()`
    方法要求我们传递一个类指针作为模板参数。由于不知道实际实现给定类型的类是什么，最安全的方法是简单地传递 `QObject*`，因为我们知道所有 QML 对象都继承自它。更重要的是传递给函数参数的值——它是我们想要返回的对象的名称。请注意，这并不是对象的
    `id`，而是 `objectName` 属性的值。当结果被分配给变量时，我们验证是否成功找到了项目，如果是这样，就使用通用的 `QObject` API
    将其 `highlighted` 属性设置为 `true`。这个属性将改变按钮的外观。
- en: The `QObject::findChild` and `QObject::findChildren` functions perform recursive
    search with unlimited depth. While they're easy to use, these functions may be
    slow if the object has many children. To improve performance, you can turn off
    recursive search by passing the `Qt::FindDirectChildrenOnly` flag to these functions.
    If the target object is not a direct child, consider calling `QObject::findChild`
    repeatedly to find each intermediate parent.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject::findChild` 和 `QObject::findChildren` 函数执行无限深度的递归搜索。虽然它们使用起来很方便，但如果对象有很多子对象，这些函数可能会很慢。为了提高性能，你可以通过将这些函数的
    `Qt::FindDirectChildrenOnly` 标志传递给这些函数来关闭递归搜索。如果目标对象不是直接子对象，考虑多次调用 `QObject::findChild`
    来找到每个中间父对象。'
- en: 'If you need to create a new QML object, you can use the `QQmlComponent` class
    for that. It accepts a QML document and allows you to create a QML object from
    it. The document is usually loaded from a file, but you can even provide it directly
    in C++ code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个新的 QML 对象，你可以使用 `QQmlComponent` 类来完成。它接受一个 QML 文档，并允许你从中创建一个 QML 对象。文档通常是从文件中加载的，但你甚至可以直接在
    C++ 代码中提供它：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `component.create()` function instantiates our new component and returns
    a pointer to it as `QObject`. In fact, any QML object derives from `QObject`.
    You can use Qt meta-system to manipulate the object without needing to cast it
    to a concrete type. The object's properties can be accessed using the `property()`
    and `setProperty()` functions. In this example, we set the `visible` property
    of the `Window` QML object to `true`. When our code is executed, a new window
    with a button will appear on screen.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`component.create()` 函数实例化我们的新组件，并返回一个指向它的 `QObject` 指针。实际上，任何 QML 对象都源自 `QObject`。你可以使用
    Qt 元系统来操作对象，而无需将其转换为具体类型。你可以使用 `property()` 和 `setProperty()` 函数访问对象的属性。在这个例子中，我们将
    `Window` QML 对象的 `visible` 属性设置为 `true`。当我们的代码执行时，一个带有按钮的新窗口将出现在屏幕上。'
- en: 'You can also call the object''s methods using the `QMetaObject::invokeMethod()`
    function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `QMetaObject::invokeMethod()` 函数调用对象的方法：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to embed a new object into the existing QML form, you need to set
    *visual parent* of the new object. Let''s say that we want to add a button to
    the calculator''s form. First, you need to assign `objectName` to it in `main.qml`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将新对象嵌入到现有的 QML 表单中，你需要设置新对象的 *视觉父级*。假设我们想要将一个按钮添加到计算器的表单中。首先，你需要在 `main.qml`
    中给它分配 `objectName`：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can now add a button to this form from C++:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从 C++ 中向这个表单添加一个按钮：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, we create a component and assign the main form as its `parent`
    property. This will make the object appear in the top-left corner of the form.
    Like with any other QML object, you can use the `anchors` property group to change
    position of the object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个组件，并将其主表单作为其 `parent` 属性。这将使对象出现在表单的左上角。像任何其他 QML 对象一样，你可以使用 `anchors`
    属性组来改变对象的位置。
- en: 'When creating complex objects, it takes time for them to instantiate and at
    times, it is desired to not block the control flow for too long by waiting for
    the operation to complete. In such cases, you can create an object in the QML
    engine asynchronously using the `QQmlIncubator` object. This object can be used
    to schedule instantiation and continue the flow of the program. We can query the
    state of the incubator and when the object is constructed, we will be able to
    access it. The following code demonstrates how to use the incubator to instantiate
    an object and keep the application responding while waiting for the operation
    to complete:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建复杂对象时，它们需要时间来实例化，有时，人们希望不要因为等待操作完成而长时间阻塞控制流。在这种情况下，你可以使用`QQmlIncubator`对象在QML引擎中异步创建对象。这个对象可以用来安排实例化并继续程序的流程。我们可以查询孵化器的状态，当对象构建完成时，我们将能够访问它。以下代码演示了如何使用孵化器来实例化对象，并在等待操作完成的同时保持应用程序响应：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Bringing life into static user interfaces
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为静态用户界面注入活力
- en: Our user interface has been quite static until now. In this section, we will
    add a simple animation to our calculator. When the user selects the factorial
    operation, the second (unused) text field will fade out. It will fade in when
    another operation is selected. Let's see how QML allows us to implement that.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面到目前为止一直相当静态。在本节中，我们将向我们的计算器添加一个简单的动画。当用户选择阶乘操作时，第二个（未使用）文本字段将淡出。当选择另一个操作时，它将淡入。让我们看看QML如何允许我们实现这一点。
- en: Fluid user interfaces
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流体用户界面
- en: So far, we have been looking at graphical user interfaces as a set of panels
    embedded one into another. This is well reflected in the world of desktop utility
    programs composed of windows and subwindows containing mostly static content scattered
    throughout a large desktop area where the user can use a mouse pointer to move
    around windows or adjust their size.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将图形用户界面视为一组嵌入彼此中的面板。这在桌面实用程序的世界中得到了很好的体现，这些实用程序由窗口和子窗口组成，其中包含大量静态内容，散布在整个大桌面区域，用户可以使用鼠标指针在窗口之间移动或调整它们的大小。
- en: However, this design doesn't correspond well with modern user interfaces that
    often try to minimize the area they occupy (because of either a small display
    size like with embedded and mobile devices or to avoid obscuring the main display
    panel like in games), at the same time providing rich content with a lot of moving
    or dynamically resizing items. Such user interfaces are often called "fluid",
    to signify that they are not formed as a number of separate different screens
    but contain dynamic content and layout where one screen fluently transforms into
    another. The `QtQuick` module provides a runtime to create rich applications with
    fluid user interfaces.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计与现代用户界面不太相符，现代用户界面通常试图最小化它们占据的面积（因为嵌入式和移动设备等显示尺寸较小，或者为了避免遮挡主显示面板，如游戏中的情况），同时提供大量动态移动或动态调整大小的丰富内容。这样的用户界面通常被称为“流体”，以表明它们不是由多个不同的屏幕组成，而是包含动态内容和布局，其中一屏可以流畅地转换到另一屏。`QtQuick`模块提供了一个运行时，用于创建具有流体用户界面的丰富应用程序。
- en: States and transitions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态和转换
- en: 'Qt Quick introduces a concept of **states**. Any Qt Quick object can have a
    predefined set of states. Each state corresponds to a certain situation in the
    application logic. For example, we can say that our calculator application has
    two states:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick引入了**状态**的概念。任何Qt Quick对象都可以有一个预定义的状态集。每个状态对应于应用程序逻辑中的某种情况。例如，我们可以说我们的计算器应用程序有两个状态：
- en: When add or multiply operations are selected, the user has to input two operands
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择加法或乘法操作时，用户必须输入两个操作数
- en: When factorial operation is selected, the user has to input only one operand
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择阶乘操作时，用户只需要输入一个操作数
- en: States are identified by `string` names. Implicitly, any object has the base
    state with an empty name. To declare a new state, you need to specify the state
    name and a set of property values that are different in that state, compared to
    the base state.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通过`字符串`名称来标识。隐式地，任何对象都有一个空名称的基本状态。要声明一个新的状态，你需要指定状态名称和一组与基本状态不同的属性值。
- en: Each Qt Quick object also has the `state` property. When you assign a state
    name to this property, the object goes to the specified state. This happens immediately
    by default, but it's possible to define **transitions** for the object and perform
    some visual effects when changing states.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Qt Quick对象也都有一个`state`属性。当你将状态名称分配给此属性时，对象将进入指定的状态。默认情况下，这会立即发生，但可以定义对象的**转换**并执行一些状态更改时的视觉效果。
- en: Let's see how we can utilize states and transitions in our project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在项目中利用状态和转换。
- en: Time for action – Adding states to the form
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 向表单添加状态
- en: Open the `CalculatorForm.ui.qml` file in the form editor. The bottom part of
    the main area contains the states editor. The base state item is always present
    on the left. Click on the Add a new state button on the right of the states editor.
    A new state will appear in the editor. It contains a text field that you can use
    to set the state's name. Set the name to `single_argument`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单编辑器中打开`CalculatorForm.ui.qml`文件。主区域的底部包含状态编辑器。基本状态项始终位于左侧。点击状态编辑器右侧的“添加新状态”按钮。编辑器中会出现一个新的状态。它包含一个文本字段，你可以用它来设置状态的名称。将名称设置为`single_argument`。
- en: Only one of the states can be selected at a time. When a custom state is selected,
    any changes in the form editor will only affect the selected state. When the base
    state is selected, you can edit the base state and all the changes will affect
    all other states unless the changed property is overridden in some state.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只能选择一个状态。当选择自定义状态时，任何在表单编辑器中的更改都只会影响所选状态。当选择基本状态时，你可以编辑基本状态，并且所有更改都将影响所有其他状态，除非某些状态中覆盖了更改的属性。
- en: Select the `single_argument` state by clicking on it in the state editor. It
    will also be automatically selected upon creation. Next, select the `argument2`
    text field and set its `opacity` property to 0\. The field will become completely
    transparent, except for the blue outline provided by the form editor. However,
    this change only affects the `single_argument` state. When you switch to the base
    state, the text field will become visible. When you switch back to the second
    state, the text field will become invisible again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在状态编辑器中点击它来选择`single_argument`状态。创建时它也会自动被选中。接下来，选择`argument2`文本字段并将其`opacity`属性设置为0。该字段将变得完全透明，除了表单编辑器提供的蓝色轮廓。然而，这种变化仅影响`single_argument`状态。当你切换到基本状态时，文本字段将变得可见。当你切换回第二个状态时，文本字段将再次变得不可见。
- en: 'You can switch to the text editor to see how this state is represented in the
    code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以切换到文本编辑器来查看这个状态在代码中的表示：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the state does not contain a full copy of the form. Instead,
    it only records the difference between this state and the base state.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，状态不包含表单的完整副本。相反，它只记录此状态与基本状态之间的差异。
- en: 'Now we need to ensure that the form''s state is properly updated. You just
    need to bind the `state` property of the form to a function that returns the current
    state. Switch to the `Calculator.qml` file and add the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确保表单的状态得到适当的更新。你只需要将表单的`state`属性绑定到一个返回当前状态的函数。切换到`Calculator.qml`文件并添加以下代码：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As with any other property binding, the QML engine will automatically update
    the value of the `state` property when needed. When the user selects the factorial
    operation, the code block will return `"single_argument"`, and the second text
    field will be hidden. In other cases, the function will return an empty string
    that corresponds to the base state. When you run the application, you should be
    able to see this behavior.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他属性绑定一样，当需要时，QML引擎会自动更新`state`属性的值。当用户选择阶乘操作时，代码块将返回`"single_argument"`，第二个文本字段将被隐藏。在其他情况下，函数将返回一个空字符串，对应于基本状态。当你运行应用程序时，你应该能够看到这种行为。
- en: Time for action – Adding smooth transition effect
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 添加平滑转换效果
- en: Qt Quick allows us to easily implement smooth transition between states. It
    will automatically detect when some property needs to be changed, and if there
    is a matching animation attached to the object, that animation will take over
    the process of applying the change. You don't even need to specify the starting
    and ending values of the animated property; it's all done automatically.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick允许我们轻松实现状态之间的平滑转换。它将自动检测何时需要更改某些属性，并且如果对象附加了匹配的动画，该动画将接管应用更改的过程。你甚至不需要指定动画属性的起始和结束值；这一切都是自动完成的。
- en: 'To add a smooth transition to our form, add the following code to the `Calculator.qml`
    file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的表单添加平滑的过渡，请将以下代码添加到 `Calculator.qml` 文件中：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the application and you will see that the text field's opacity changes gradually
    when the form transitions to another state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到当表单转换到另一个状态时，文本字段的透明度会逐渐变化。
- en: What just happened?
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `transitions` property holds the list of `Transition` objects for this object.
    It's possible to specify a different `Transition` object for each pair of states
    if you want to perform different animations in different cases. However, you can
    also use a single `Transition` object that will affect all transitions. For convenience,
    QML allows us to assign a single object to a property that expects a list.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`transitions` 属性包含此对象的 `Transition` 对象列表。如果您想在不同情况下执行不同的动画，可以为每一对状态指定不同的 `Transition`
    对象。然而，您也可以使用单个 `Transition` 对象，这将影响所有转换。为了方便起见，QML 允许我们将单个对象分配给期望列表的属性。'
- en: A `Transition` object must contain one or multiple animations that will be applied
    during this transition. In this example, we added `PropertyAnimation` that allows
    us to animate any property of any child object of the main form. The `PropertyAnimation`
    QML type has properties that allow you to configure what exactly it will do. We
    instructed it to animate the `opacity` property and take 300 ms to perform the
    animation. The opacity change will be linear by default, but you can use the `easing`
    property to select another easing function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Transition` 对象必须包含一个或多个动画，这些动画将在转换过程中应用。在这个例子中，我们添加了 `PropertyAnimation`，它允许我们动画化主表单的任何子对象的任何属性。`PropertyAnimation`
    QML 类型具有允许您配置它将执行什么操作的属性。我们指示它动画化 `opacity` 属性，并花费 300 毫秒来完成动画。默认情况下，不透明度变化将是线性的，但您可以使用
    `easing` 属性来选择另一个缓动函数。
- en: As always, the Qt documentation is a great source of detailed information about
    available types and properties. Refer to Transition QML Type and Animation QML
    Type documentation pages for more information. We will also talk more about states
    and transitions in [Chapter 13](bf16fe2f-f507-4980-96cd-9b53b200522e.xhtml),* Animations
    in Qt Quick Games*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，Qt 文档是关于可用类型和属性的详细信息的绝佳来源。请参阅 `Transition` QML 类型文档和 `Animation` QML 类型文档页面以获取更多信息。我们还将更多讨论第
    13 章*Qt Quick 游戏中的动画*中的状态和转换。
- en: Have a go hero – Adding an animation of the item's position
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 添加项目位置的动画
- en: You can make the calculator's transition even more appealing if you make the
    text field fly away off screen while fading out. Just use the form editor to change
    the text field's position in the `single_argument` state, and then attach another
    `PropertyAnimation` to the `Transition` object. You can play with different easing
    types to see which looks better for this purpose.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在文本字段淡出时将其飞出屏幕，可以使计算器的转换看起来更加吸引人。只需使用表单编辑器更改 `single_argument` 状态下文本字段的定位，然后将其附加到
    `Transition` 对象上。您可以尝试不同的缓动类型，看看哪种更适合这个目的。
- en: Pop quiz
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which property allows you to position a QML object relative to another
    object?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 哪个属性允许您将 QML 对象相对于另一个对象定位？
- en: '`border`'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`border`'
- en: '`anchors`'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`anchors`'
- en: '`id`'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`id`'
- en: Q2\. Which file name extension indicates that the file cannot be loaded into
    a QML engine?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 哪个文件扩展名表示该文件无法加载到 QML 引擎中？
- en: '`.qml`'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.qml`'
- en: '`.ui`'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.ui`'
- en: '`.ui.qml`'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.ui.qml`'
- en: All of the above are valid QML files
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述都是有效的 QML 文件
- en: Q3\. What is a Qt Quick transition?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. Qt Quick 转换是什么？
- en: A change of parent-child relationships among the existing Qt Quick objects
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有 Qt Quick 对象之间父-子关系的改变
- en: A set of properties that change when an event occurs
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事件发生时改变的一组属性
- en: A set of animations that play when the object's state changes
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对象状态改变时播放的一组动画
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to with a declarative language called QML.
    The language is used to drive Qt Quick—a framework for highly dynamic and interactive
    content. You learned the basics of Qt Quick—how to create documents with a number
    of element types and how to create your own in QML, or in C++. You also learned
    how to bind expressions to properties to automatically reevaluate them. You saw
    how to expose the C++ core of your application to QML-based user interfaces. You
    learned to use the visual form editor and how to create animated transitions in
    the interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被介绍了一种名为QML的声明性语言。这种语言用于驱动Qt Quick——一个用于高度动态和交互式内容的框架。你学习了Qt Quick的基础知识——如何使用多种元素类型创建文档，以及如何在QML或C++中创建自己的元素。你还学习了如何将表达式绑定到属性上，以便自动重新评估它们。你看到了如何将应用程序的C++核心暴露给基于QML的用户界面。你学习了如何使用可视化表单编辑器以及如何在界面中创建动画过渡。
- en: You also learned which QML modules are available. You were shown how to use
    the `QtQuick.Controls` and `QtQuick.Layouts` modules to build the application's
    user interface out of standard components. In the next chapter, we will see how
    you can make your own fully customized QML components with a unique look and feel.
    We will show how to implement custom graphics and event handling in QML applications.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了哪些QML模块可用。你被展示了如何使用`QtQuick.Controls`和`QtQuick.Layouts`模块使用标准组件构建应用程序的用户界面。在下一章中，我们将看到如何创建具有独特外观和感觉的完全自定义QML组件。我们将展示如何在QML应用程序中实现自定义图形和事件处理。
