["```cpp\nco_await X{}; \n```", "```cpp\noperator co_await for a time interval:\n```", "```cpp\nusing namespace std::chrono;\ntemplate <class Rep, class Period> \nauto operator co_await(duration<Rep, Period> d) { \n  struct Awaitable {     \n    system_clock::duration d_;\n    Awaitable(system_clock::duration d) : d_(d) {} \n    bool await_ready() const { return d_.count() <= 0; }\n    void await_suspend(std::coroutine_handle<> h) { /* ... */ } \n    void await_resume() {}\n  }; \n  return Awaitable{d};\n} \n```", "```cpp\nstd::cout << \"just about to go to sleep...\\n\";\nco_await 10ms;                   // Calls operator co_await()\nstd::cout << \"resumed\\n\"; \n```", "```cpp\nauto result = co_await expr; \n```", "```cpp\n// Pseudo code\nauto&& a = expr;         // Evaluate expr, a is the awaitable\nif (!a.await_ready()) {  // Not ready, wait for result\n  a.await_suspend(h);    // Handle to current coroutine\n                         // Suspend/resume happens here\n}\nauto result = a.await_resume(); \n```", "```cpp\nauto image = co_await load(\"image.jpg\");\nauto thumbnail = co_await resize(image, 100, 100);\nco_await save(thumbnail, \"thumbnail.jpg\"); \n```", "```cpp\ntemplate <typename T>\nclass [[nodiscard]] Task {\n  struct Promise { /* ... */ };          // See below\n  std::coroutine_handle<Promise> h_;\n  explicit Task(Promise & p) noexcept\n      : h_{std::coroutine_handle<Promise>::from_promise(p)} {}\n public:\n  using promise_type = Promise;\n  Task(Task&& t) noexcept : h_{std::exchange(t.h_, {})} {}\n  ~Task() { if (h_) h_.destroy(); }\n  // Awaitable interface\n  bool await_ready() { return false; }\n  auto await_suspend(std::coroutine_handle<> c) {\n    h_.promise().continuation_ = c;\n    return h_;\n  }\n  auto await_resume() -> T {\n    auto& result = h_.promise().result_;\n    if (result.index() == 1) {\n      return std::get<1>(std::move(result));\n    } else {\n      std::rethrow_exception(std::get<2>(std::move(result)));\n    }\n  }\n}; \n```", "```cpp\nstruct Promise {\n  std::variant<std::monostate, T, std::exception_ptr> result_;\n  std::coroutine_handle<> continuation_;  // A waiting coroutine\n  auto get_return_object() noexcept { return Task{*this}; }\n  void return_value(T value) { \n    result_.template emplace<1>(std::move(value)); \n  }\n  void unhandled_exception() noexcept {\n    result_.template emplace<2>(std::current_exception());\n  }\n  auto initial_suspend() { return std::suspend_always{}; }\n  auto final_suspend() noexcept {\n    struct Awaitable {\n      bool await_ready() noexcept { return false; }\n      auto await_suspend(std::coroutine_handle<Promise> h) noexcept {\n        return h.promise().continuation_;\n      }\n      void await_resume() noexcept {}\n    };\n    return Awaitable{};\n  }\n}; \n```", "```cpp\nclass Task {\n  // ...\n  auto await_suspend(std::coroutine_handle<> c) {\n    h_.promise().continuation_ = c;      // Save handle\n    return h_;\n  }\n  // ... \n```", "```cpp\nauto Promise::final_suspend() noexcept {\n  struct Awaitable {\n    bool await_ready() noexcept { return false; } // Suspend\n    auto await_suspend(std::coroutine_handle<Promise> h) noexcept{\n      return h.promise().continuation_;  // Transfer control to\n    }                                    // the waiting coroutine\n    void await_resume() noexcept {}\n  };\n  return Awaitable{};\n} \n```", "```cpp\n// ...\nauto await_suspend(std::coroutine_handle<Promise> h) noexcept {\n  h.promise().resume();         // Not recommended\n}\n// ... \n```", "```cpp\nauto a() -> Task<int> {  co_return 42; } \nauto b() -> Task<int> {         // The continuation\n  auto sum = 0;\n  for (auto i = 0; i < 1'000'000; ++i) {\n    sum += co_await a();\n  }\n  co_return sum;\n} \n```", "```cpp\n// ...\nauto await_suspend(std::coroutine_handle<Promise> h) noexcept {\n  return h.promise().continuation_;     // Symmetric transfer\n}\n// ... \n```", "```cpp\ntemplate <>\nclass [[nodiscard]] Task<void> {\n\n  struct Promise {\n    std::exception_ptr e_;   // No std::variant, only exception\n    std::coroutine_handle<> continuation_; \n    auto get_return_object() noexcept { return Task{*this}; }\n    void return_void() {}   // Instead of return_value() \n    void unhandled_exception() noexcept { \n      e_ = std::current_exception(); \n    }\n    auto initial_suspend() { return std::suspend_always{}; }\n    auto final_suspend() noexcept {\n      struct Awaitable {\n        bool await_ready() noexcept { return false; }\n        auto await_suspend(std::coroutine_handle<Promise> h) noexcept {\n          return h.promise().continuation_;\n        }\n        void await_resume() noexcept {}\n      };\n      return Awaitable{};\n    }\n  };\n  std::coroutine_handle<Promise> h_;\n  explicit Task(Promise& p) noexcept \n      : h_{std::coroutine_handle<Promise>::from_promise(p)} {}\npublic:\n  using promise_type = Promise;\n\n  Task(Task&& t) noexcept : h_{std::exchange(t.h_, {})} {}\n  ~Task() { if (h_) h_.destroy(); }\n  // Awaitable interface\n  bool await_ready() { return false; }\n  auto await_suspend(std::coroutine_handle<> c) {\n    h_.promise().continuation_ = c;\n    return h_;\n  }\n  void await_resume() {\n    if (h_.promise().e_)\n      std::rethrow_exception(h_.promise().e_);\n  }\n}; \n```", "```cpp\nTask<void> async_func() {      // A coroutine\n  co_await some_func();\n} \n```", "```cpp\nvoid f() {                          \n  co_await async_func(); // Error: A coroutine can't return void\n} \n```", "```cpp\nvoid g() {        \n  async_func();          // Warning: Does nothing\n} \n```", "```cpp\nauto some_async_func() -> Task<int> { /* ... */ }\nint main() { \n  auto result = sync_wait(some_async_func());\n  return result;\n} \n```", "```cpp\ntemplate<typename T>\nusing Result = decltype(std::declval<T&>().await_resume());\ntemplate <typename T>\nResult<T> sync_wait(T&& task) {\n  if constexpr (std::is_void_v<Result<T>>) {\n    struct Empty {};\n    auto coro = [&]() -> detail::SyncWaitTask<Empty> {\n      co_await std::forward<T>(task);\n      co_yield Empty{};\n      assert(false);\n    };\n    coro().get();\n  } else {\n    auto coro = [&]() -> detail::SyncWaitTask<Result<T>> {\n      co_yield co_await std::forward<T>(task);\n      // This coroutine will be destroyed before it\n      // has a chance to return.\n      assert(false);\n    };\n    return coro().get();\n  }\n} \n```", "```cpp\n co_yield some_value; \n```", "```cpp\nco_await promise.yield_value(some_value); \n```", "```cpp\nnamespace detail { // Implementation detail\ntemplate <typename T>\nclass SyncWaitTask {  // A helper class only used by sync_wait()\n  struct Promise { /* ... */ }; // See below\n  std::coroutine_handle<Promise> h_;\n  explicit SyncWaitTask(Promise& p) noexcept\n      : h_{std::coroutine_handle<Promise>::from_promise(p)} {}\n public:\n  using promise_type = Promise;\n\n  SyncWaitTask(SyncWaitTask&& t) noexcept \n      : h_{std::exchange(t.h_, {})} {}\n  ~SyncWaitTask() { if (h_) h_.destroy();}\n  // Called from sync_wait(). Will block and retrieve the\n  // value or error from the task passed to sync_wait()\n  T&& get() {\n    auto& p = h_.promise();\n    h_.resume();\n    p.semaphore_.acquire();               // Block until signal\n    if (p.error_)\n      std::rethrow_exception(p.error_);\n    return static_cast<T&&>(*p.value_);\n  }\n  // No awaitable interface, this class will not be co_await:ed\n};\n} // namespace detail \n```", "```cpp\nstruct Promise {\n  T* value_{nullptr};\n  std::exception_ptr error_;\n  std::binary_semaphore semaphore_;\n  SyncWaitTask get_return_object() noexcept { \n    return SyncWaitTask{*this}; \n  }\n  void unhandled_exception() noexcept { \n    error_ = std::current_exception(); \n  }\n  auto yield_value(T&& x) noexcept {     // Result has arrived\n    value_ = std::addressof(x);\n    return final_suspend();\n  }\n  auto initial_suspend() noexcept { \n    return std::suspend_always{}; \n  }\n  auto final_suspend() noexcept { \n  struct Awaitable {\n      bool await_ready() noexcept { return false; }\n      void await_suspend(std::coroutine_handle<Promise> h) noexcept {\n        h.promise().semaphore_.release();          // Signal! \n      }\n      void await_resume() noexcept {}\n    };\n    return Awaitable{};\n  }\n  void return_void() noexcept { assert(false); }\n}; \n```", "```cpp\n// ...\nauto coro = [&]() -> detail::SyncWaitTask<Result<T>> {\n  co_yield co_await std::forward<T>(task);  \n  // ... \n```", "```cpp\nauto height() -> Task<int> { co_return 20; }     // Dummy coroutines\nauto width() -> Task<int> { co_return 30; }\nauto area() -> Task<int> { \n  co_return co_await height() * co_await width(); \n}\n\nint main() {\n  auto a = area();\n  int value = sync_wait(a);\n  std::cout << value;          // Outputs: 600\n} \n```", "```cpp\nnamespace asio = boost::asio; \n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\nusing namespace std::chrono;\nnamespace asio = boost::asio;\nint main() {\n  auto ctx = asio::io_context{};\n  auto timer = asio::system_timer{ctx};\n  timer.expires_from_now(1000ms);\n  timer.async_wait([](auto error) {       // Callback\n    // Ignore errors..                          \n    std::cout << \"Hello from delayed callback\\n\"; \n  });\n  std::cout << \"Hello from main\\n\";\n  ctx.run();\n} \n```", "```cpp\nHello from main\nHello from delayed callback \n```", "```cpp\nstd::cout << \"Hello! \";\nco_await async_sleep(ctx, 100ms);\nstd::cout << \"Delayed output\\n\"; \n```", "```cpp\ntemplate <typename R, typename P>\nauto async_sleep(asio::io_context& ctx,\n                 std::chrono::duration<R, P> d) {\n  struct Awaitable {\n    asio::system_timer t_;\n    std::chrono::duration<R, P> d_;\n    boost::system::error_code ec_{};\n    bool await_ready() { return d_.count() <= 0; }\n    void await_suspend(std::coroutine_handle<> h) {\n      t_.expires_from_now(d_);\n      t_.async_wait([this, h](auto ec) mutable {\n        this->ec_ = ec;\n        h.resume();\n      });\n    } \n    void await_resume() {\n      if (ec_) throw boost::system::system_error(ec_);\n    }\n  };\n  return Awaitable{asio::system_timer{ctx}, d};\n} \n```", "```cpp\n// This code is here just to get our example up and running\nstruct Detached { \n  struct promise_type {\n    auto get_return_object() { return Detached{}; }\n    auto initial_suspend() { return std::suspend_never{}; }\n    auto final_suspend() noexcept { return std::suspend_never{};}\n    void unhandled_exception() { std::terminate(); } // Ignore\n    void return_void() {}\n  };\n};\nDetached run_task_impl(asio::io_context& ctx, Task<void>&& t) {\n  auto wg = asio::executor_work_guard{ctx.get_executor()};\n  co_await t;\n}\nvoid run_task(asio::io_context& ctx, Task<void>&& t) {\n  run_task_impl(ctx, std::move(t));\n  ctx.run();\n} \n```", "```cpp\nauto test_sleep(asio::io_context& ctx) -> Task<void> {\n  std::cout << \"Hello!  \";\n  co_await async_sleep(ctx, 100ms);\n  std::cout << \"Delayed output\\n\";\n}\nint main() {\n  auto ctx = asio::io_context{};\n  auto task = test_sleep(ctx);\n  run_task(ctx, std::move(task));  \n}; \n```", "```cpp\nHello! Delayed output \n```", "```cpp\n#include <boost/asio.hpp>\n#include <boost/asio/awaitable.hpp>\n#include <boost/asio/use_awaitable.hpp>\nusing namespace std::chrono;\nnamespace asio = boost::asio;\nusing boost::asio::ip::tcp;\nint main() {\n  auto server = [] {\n    auto endpoint = tcp::endpoint{tcp::v4(), 37259};\n    auto awaitable = listen(endpoint);\n    return awaitable;\n  };\n  auto ctx = asio::io_context{};\n  asio::co_spawn(ctx, server, asio::detached);\n  ctx.run(); // Run event loop from main thread\n} \n```", "```cpp\nauto listen(tcp::endpoint endpoint) -> asio::awaitable<void> {\n  auto ex = co_await asio::this_coro::executor;\n  auto a = tcp::acceptor{ex, endpoint};\n  while (true) {\n    auto socket = co_await a.async_accept(asio::use_awaitable);\n    auto session = [s = std::move(socket)]() mutable {\n      auto awaitable = serve_client(std::move(s));\n      return awaitable;\n    };\n    asio::co_spawn(ex, std::move(session), asio::detached);\n  }\n} \n```", "```cpp\nauto serve_client(tcp::socket socket) -> asio::awaitable<void> {\n  std::cout << \"New client connected\\n\";\n  auto ex = co_await asio::this_coro::executor;\n  auto timer = asio::system_timer{ex};\n  auto counter = 0;\n  while (true) {\n    try {\n      auto s = std::to_string(counter) + \"\\n\";\n      auto buf = asio::buffer(s.data(), s.size());\n      auto n = co_await async_write(socket, buf, asio::use_awaitable);\n      std::cout << \"Wrote \" << n << \" byte(s)\\n\";\n      ++counter;\n      timer.expires_from_now(100ms);\n      co_await timer.async_wait(asio::use_awaitable);\n    } catch (...) {\n      // Error or client disconnected\n      break;\n    }\n  }\n} \n```", "```cpp\n[client] $ nc localhost 37259              \n0\n1\n2\n3 \n```"]