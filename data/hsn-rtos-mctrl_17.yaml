- en: Creating Loose Coupling with Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列创建松散耦合
- en: Now that we've covered ways of architecting source code for flexibility, we'll
    take that a step further and explore how queues can be used to provide natural
    interface definitions for data exchange.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何为灵活性而架构源代码的方法，我们将更进一步，探讨如何使用队列来提供自然的数据交换接口定义。
- en: In this chapter, we'll develop a simple command queue that can be accessed from
    multiple physical interfaces. By the end of this chapter, you'll have an excellent
    understanding of why using common queue definitions is desirable, as well as how
    to implement both sides of an extremely flexible command queue. This will help
    you create flexible architectures with implementations that aren't tied to underlying
    hardware or physical interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的命令队列，可以从多个物理接口访问。到本章结束时，你将深刻理解为什么使用通用的队列定义是可取的，以及如何实现一个极其灵活的命令队列的两端。这将帮助你创建与底层硬件或物理接口无关的灵活架构。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding queues as interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解队列作为接口
- en: Creating a command queue
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令队列
- en: Reusing a queue definition for a new target
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新目标重用队列定义
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on experiments included in this chapter, you will require
    the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章中包含的动手实验，你需要以下设备：
- en: A Nucleo F767 development board
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: A Micro-USB cable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro-USB线
- en: STM32CubeIDE and source code (for instructions, visit the *Setting up our IDE*
    section in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)*, Selecting
    an IDE*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（有关说明，请访问[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)中的*设置我们的IDE*部分，选择IDE*）
- en: SEGGER J-Link, Ozone, and SystemView (for instructions, visit [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER J-Link、Ozone和SystemView（有关说明，请访问[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）
- en: Python >= 3.8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python >= 3.8
- en: All source code for this chapter is available at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码均可在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_13)找到。
- en: Understanding queues as interfaces
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解队列作为接口
- en: If you've just finished reading the previous chapter, you've likely picked up
    on the fact that there are many techniques that can be used to create quality
    code at one time and then reuse that same code across multiple projects. Just
    like using layers of abstractions is a technique that increases the likelihood
    of reusing code across multiple hardware platforms, using queues as interfaces
    also increases the likelihood that code will be used for more than just one project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚刚完成了上一章的阅读，你可能会注意到有许多技术可以用来一次性创建高质量的代码，然后在整个多个项目中重用相同的代码。就像使用抽象层是一种技术，可以增加代码在多个硬件平台间重用的可能性一样，使用队列作为接口也能增加代码被用于多个项目的可能性。
- en: The concepts presented in this chapter aren't limited to queues—they also apply
    to stream and message buffers. However, since queues have been around since the
    beginning of FreeRTOS (and are the most commonly available primitive), we'll use
    them in our examples. Let's take a look at why using queues is a good idea.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提出的概念不仅限于队列——它们也适用于流和消息缓冲区。然而，由于队列自FreeRTOS开始以来就存在（并且是最常见的原始数据结构），我们将在示例中使用它们。让我们看看为什么使用队列是一个好主意。
- en: Queues make excellent interface definitions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列是出色的接口定义
- en: Queues provide a very clear line of abstraction. In order to pass data through
    a queue and get a desired behavior on the other side, all of the data must be
    present and both the sender and receiver must have a common understanding of what
    the data format is. This clean line forces a level of conscientious thought as
    to what exactly needs to be communicated. Sometimes, this level of active thought
    isn't present when implementing individual functions. The delineation provided
    by the queue forces additional thought about what the exact information required
    is, as well as what its format should be. Responsible developers will be more
    likely to ensure these types of definitive interfaces are thoroughly documented.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 队列提供了一个非常清晰的抽象层次。为了通过队列传递数据并在另一侧获得期望的行为，所有数据都必须存在，并且发送方和接收方必须对数据格式有一个共同的理解。这条清晰的界限迫使人们进行深思熟虑，以确定需要传达的确切内容。有时，在实现单个功能时，这种积极思考的水平并不存在。队列提供的界限迫使人们进一步思考所需的确切信息及其格式。负责任的开发者更有可能确保这些类型的明确接口得到彻底的文档记录。
- en: When a queue is viewed as an interface to a subsystem, it pays dividends to
    document the functionality that will be provided, as well as the exact formatting
    required to use the subsystem. Often, the fact that an interface is well defined
    will increase the likelihood of reuse since it will be easily understood.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当将队列视为子系统的接口时，记录将要提供的功能以及使用子系统所需的精确格式是有益的。通常，接口定义得越好，重用的可能性就越大，因为它们更容易被理解。
- en: Queues increase flexibility
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列增加了灵活性
- en: Queues are beautiful in their simplicity—a sender places something in the queue
    and whatever task is monitoring the queue will receive the data and act on it.
    The only things the sender and the received task need to share are the code required
    for interacting with the queue and the definition of the data flowing through
    the queue. Since the list of shared resources is so short, there is a natural
    decoupling effect when queues are used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 队列以其简洁性而美丽——发送方将某物放入队列，而监控队列的任何任务都将接收数据并对其采取行动。发送方和接收方任务需要共享的唯一东西是用于与队列交互的代码以及通过队列流动的数据的定义。由于共享资源的列表如此之短，当使用队列时，自然会起到解耦的作用。
- en: Because of the clean break provided by the queue, the exact implementation of
    the functionality could change over time. The same functionality can be implemented
    in many different ways, which won't immediately affect the sender, as long as
    the queue interface doesn't change.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列提供的清晰分离，功能的确切实现可能会随时间而改变。只要队列接口不变，同样的功能可以用许多不同的方式实现，这不会立即影响发送方。
- en: It also means that data can be sent to the queue from anywhere; there are no
    explicit requirements for the physical interface—only the data format. This means
    that a queue can be designed to receive the same data stream from many different
    interfaces, which can provide system-level flexibility. The functionality doesn't
    need to be tied to a specific physical interface (such as Ethernet, USB, UART,
    SPI, CAN, and so on).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着数据可以从任何地方发送到队列中；对物理接口没有明确的要求——只需要数据格式。这意味着队列可以被设计成从许多不同的接口接收相同的数据流，这可以提供系统级的灵活性。功能不需要绑定到特定的物理接口（如以太网、USB、UART、SPI、CAN等）。
- en: Queues make testing easier
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列使测试变得更容易
- en: Similar to the way hardware abstractions provide easy insertion points for test
    data, queues also provide excellent places to enter test data. This provides a
    very convenient entry point for entering test data for code under development.
    The flexibility of implementation mentioned in the previous section also applies
    here. If a piece of code is sending data to a queue and expects a response from
    another queue, the actual implementation doesn't necessarily need to be used—it
    can be simulated by responding to the command. This approach makes it possible
    to develop the other side of code in the absence of fully implemented functionality
    (in case the hardware or subsystem is still under development). This approach
    is also extremely useful when running unit-level tests; the code-under-test can
    be easily isolated from the rest of the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件抽象提供易于插入测试数据的位置的方式类似，队列也提供了极佳的测试数据输入点。这为开发中的代码提供了非常方便的测试数据输入点。前一部分提到的实现灵活性也适用于此处。如果一段代码正在向队列发送数据并期望从另一个队列获得响应，实际实现不一定需要使用——可以通过响应命令来模拟。这种方法使得在没有完全实现的功能（例如硬件或子系统仍在开发中）的情况下，开发代码的另一部分成为可能。这种方法在运行单元级测试时也非常有用；被测试的代码可以很容易地从系统其余部分隔离出来。
- en: Now that we've covered some of the reasons to use queues as interfaces, let's
    take a look at how this plays out through an example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些使用队列作为接口的原因，让我们通过一个示例来看看它是如何实现的。
- en: Creating a command queue
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令队列
- en: To see how a queue can be used to keep an architecture loosely coupled, we'll
    take a look at an application that accepts commands over USB and lights LEDs.
    While the example application itself is very simple, the concepts presented here
    scale extremely well. So, regardless of whether there are only a few commands
    or hundreds, the same approach can be used to keep the architecture flexible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解队列如何用于保持架构松散耦合，我们将查看一个通过USB接收命令并点亮LED的应用程序。虽然示例应用程序本身非常简单，但这里提出的概念具有极高的可扩展性。因此，无论命令只有几个还是几百个，都可以使用相同的方法来保持架构的灵活性。
- en: 'This application also shows another example of how to keep higher-level code
    loosely coupled to the underlying hardware. It ensures the LED command code only
    uses a defined interface to access a **Pulse Width Modulation** (**PWM**) implementation,
    rather than directly interacting with the MCU registers/HAL. The architecture
    consists of the following major components:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序还展示了如何保持高级代码与底层硬件松散耦合的另一个示例。它确保LED命令代码仅使用定义的接口来访问**脉冲宽度调制**（**PWM**）实现，而不是直接与MCU寄存器/HAL交互。该架构由以下主要组件组成：
- en: '**A USB driver**: This is the same USB stack that has been used in previous
    examples. `VirtualCommDriverMultiTask.c/h` has been extended to provide an additional
    stream buffer to efficiently receive data from a PC (`Drivers/HandsOnRTOS/VirtualCommDriverMultiTask.c/h`).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB驱动程序**：这是之前示例中已经使用过的相同的USB堆栈。`VirtualCommDriverMultiTask.c/h`已扩展以提供额外的流缓冲区，以有效地从PC接收数据（`Drivers/HandsOnRTOS/VirtualCommDriverMultiTask.c/h`）。'
- en: '**iPWM**: An additional interface definition (`iPWM`) has been created to describe
    very simple PWM functionality (defined in `Chapter_13/Inc/iPWM.h`).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iPWM**：为了描述非常简单的PWM功能（在`Chapter_13/Inc/iPWM.h`中定义），已创建了一个额外的接口定义（`iPWM`）。'
- en: '**PWM implementation**: The implementation of three `iPWM` interfaces for the
    Nucleo hardware is found in `Chapter13/Src/pwmImplementation.c` and `Chapter13/Src/pwmImplementation.h`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PWM实现**：Nucleo硬件的三个`iPWM`接口实现可以在`Chapter13/Src/pwmImplementation.c`和`Chapter13/Src/pwmImplementation.h`中找到。'
- en: '**An LED command executor**: The state machine that drives LED states using
    pointers to implementations of `iPWM` (`Chapter_13/Src/ledCmdExecutor.c`).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LED命令执行器**：使用指向`iPWM`实现指针的状态机来驱动LED状态（`Chapter_13/Src/ledCmdExecutor.c`）。'
- en: '`main`: The `main` function, which ties all of the queues, drivers, and interfaces
    together and kicks off the FreeRTOS scheduler (`Chapter_13/Src/mainColorSelector.c`).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`：将所有队列、驱动程序和接口连接在一起并启动FreeRTOS调度器的`main`函数（`Chapter_13/Src/mainColorSelector.c`）。'
- en: We'll get into the details of exactly how all of these parts fit together and
    the details of their responsibilities; but first, let's discuss what is going
    to be placed in the command queue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论所有这些部分是如何组合在一起的以及它们的职责细节；但首先，让我们讨论将要放置在命令队列中的内容。
- en: Deciding on queue contents
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定队列内容
- en: When using queues as a way of passing commands to different parts of the system,
    it is important to think about what the queue should actually hold, instead of
    what might be coming *across the wire* in a physical sense. Even though a queue
    might be used to hold payloads from a datastream with header and footer information,
    the actual contents of the queue will usually only contain the parsed payload,
    rather than the entire message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用队列作为将命令传递到系统不同部分的方式时，重要的是要考虑队列实际上应该包含什么，而不仅仅是物理意义上可能通过线缆传递的内容。尽管队列可能用于持有具有头部和尾部信息的数据流的有效负载，但队列的实际内容通常只会包含解析后的有效负载，而不是整个消息。
- en: Using this approach allows more flexibility in the future to retarget the queue
    to work over other physical layers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以在未来提供更大的灵活性，以便将队列重新定向到其他物理层工作。
- en: Since `LedCmdExecution()` will be operating primarily on the `iPWM` pointers
    to interface with the LEDs, it is convenient for the queue to hold a data type
    that can be used directly by `iPWM`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `LedCmdExecution()` 主要将操作 `iPWM` 指针以与 LED 接口，因此队列持有可以直接由 `iPWM` 使用的数据类型是方便的。
- en: 'The `iPWM` definition from `Chapter13/Inc/iPWM.h` is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `Chapter13/Inc/iPWM.h` 的 `iPWM` 定义如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This struct only (currently) consists of a single function pointer: `iPwmDutyCycleFunc`. 
    `iPwmDutyCycleFunc` is defined as a constant pointer—after the initialization
    of the `iPWM` struct, the pointer can never be changed. This helps guarantee the
    pointer won't be overwritten, so constantly checking to ensure it isn't `NULL`
    won't be necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体（目前）只包含一个单个函数指针：`iPwmDutyCycleFunc`。`iPwmDutyCycleFunc` 被定义为常量指针——在 `iPWM`
    结构体初始化之后，指针不能被更改。这有助于保证指针不会被覆盖，因此不需要不断检查以确保它不是 `NULL`。
- en: Wrapping the function pointer in a struct such as `iPWM` provides the flexibility
    of adding additional functions while keeping refactoring to a minimum. We'll be
    able to pass a single pointer to the `iPWM` struct to functions, rather than individual
    function pointers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数指针包装在如 `iPWM` 这样的结构体中，可以在最小化重构的同时增加额外的功能。我们将能够传递一个指向 `iPWM` 结构体的单个指针到函数中，而不是单独的函数指针。
- en: If you are creating an *interface* definition that will be shared with other
    developers, it is important to be very careful to coordinate and communicate changes
    among your team!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个将与其他开发者共享的 *接口* 定义，那么在团队中协调和沟通更改非常重要！
- en: The `DutyCycle` argument is defined as `float`, which makes it easy to keep
    the interface consistent when interfacing with hardware that has different underlying
    resolutions. In our implementation, the MCU's timer (`TIM`) peripherals will be
    configured to have a 16-bit resolution, but the actual code interfacing to `iPWM`
    doesn't need to be concerned with the available resolution; it can simply map
    the desired output from `0.00` (off)  to `100.00` (on).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`DutyCycle` 参数定义为 `float`，这使得在与具有不同底层分辨率的硬件接口时保持接口一致性变得容易。在我们的实现中，MCU 的定时器
    (`TIM`) 外设将被配置为具有 16 位分辨率，但实际与 `iPWM` 接口的代码不需要关心可用的分辨率；它只需将所需的输出从 `0.00`（关闭）映射到
    `100.00`（开启）即可。'
- en: For most applications, `int32_t` would have been preferred over `float` since
    it has a consistent representation and is easier to serialize. `float` is used
    here to make it easier to see the differences in the data model versus communication.
    Also, most people tend to think of PWM as a percentage, which maps naturally to `float`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用来说，`int32_t` 比浮点数更受欢迎，因为它有统一的表示形式，并且更容易序列化。这里使用浮点数是为了更容易看到数据模型与通信之间的差异。此外，大多数人倾向于将
    PWM 视为一个百分比，这自然地映射到 `float`。
- en: 'There are two main considerations when deciding on what data `LedCmd` contains:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定 `LedCmd` 包含哪些数据时有两个主要考虑因素：
- en: '`ledCmdExecutor` will be dealing with `iPWM` directly, so it makes sense to
    store floats in `LedCmd`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledCmdExecutor` 将直接处理 `iPWM`，因此将浮点数存储在 `LedCmd` 中是有意义的。'
- en: We'd also like our LED controller to have different modes of operation, so it
    will also need a way of passing that information. We'll only have a handful of
    commands here, so a `uint8_t` 8-bit unsigned integer is a good fit. Each `cmdNum` case
    will be represented by `enum` (shown later).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还希望我们的 LED 控制器具有不同的操作模式，因此它还需要一种传递这些信息的方式。这里只有少数几个命令，所以一个 `uint8_t` 8 位无符号整数是一个很好的选择。每个
    `cmdNum` 情况将由 `enum` 表示（稍后展示）。
- en: 'This results in the following structure for `LedCmd`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了 `LedCmd` 的以下结构：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The **LED Cmd Executor**'s primary interface will be a queue of `LedCmd`s. State
    changes will be performed by writing new values in the queue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**LED命令执行器**的主要接口将是一个`LedCmd`队列。状态变化将通过在队列中写入新值来执行。'
- en: Since this structure is only 13 bytes, we'll simply pass it by value. Passing
    by reference (a pointer to the structure) would be faster, but it also complicates
    the ownership of the data. These trade-offs are discussed in [Chapter 9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml),
    *Intertask Communication*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个结构只有13个字节，我们将直接按值传递。通过引用（结构指针）传递会更快，但它也复杂化了数据的所有权。这些权衡在[第9章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)，*任务间通信*中进行了讨论。
- en: Now that we have a data model defined, we can look at the remaining components
    of this application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据模型，我们可以看看这个应用程序的其余组件。
- en: Defining the architecture
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义架构
- en: 'The command executor architecture is composed of three primary blocks; each
    block executes asynchronously to the others and communicates via a queue and stream
    buffer:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行器架构由三个主要块组成；每个块异步于其他块执行并通过队列和流缓冲区进行通信：
- en: '**LED Cmd Executor**: `LedCmdExecution` in `ledCmdExecutor.c`receives data
    from `ledCmdQueue` and actuates the LEDs via pointers to `iPWM` (one for each
    color). `LedCmdExecution` is a FreeRTOS task that takes `CmdExecArgs` as an argument
    upon creation.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LED命令执行器**：`ledCmdExecutor.c`中的`LedCmdExecution`从`ledCmdQueue`接收数据，并通过`iPWM`（每个颜色一个）指针激活LED。`LedCmdExecution`是一个FreeRTOS任务，在创建时以`CmdExecArgs`作为参数。'
- en: '**Frame protocol decoding**: `mainColorSelector.c` receives raw data from the
    stream buffer populated by the USB virtual comm driver, ensures valid framing,
    and populates the `LedCmd` queue.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧协议解码**：`mainColorSelector.c`从由USB虚拟通信驱动程序填充的流缓冲区接收原始数据，确保有效的帧结构，并填充`LedCmd`队列。'
- en: '**The USB virtual comm driver**:The USB stack is spread across many files;
    the primary user-entry point is `VirtualCommDriverMultiTask.c`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB虚拟通信驱动程序**：USB堆栈分布在许多文件中；主要用户入口点是`VirtualCommDriverMultiTask.c`。'
- en: 'Here''s a visual representation of how all of these major components stack
    up and flow together. Major blocks are listed on the left, while representations
    of the data they operate on are to the right:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有这些主要组件如何堆叠和协同工作的视觉表示。主要块列在左侧，而它们操作的数据表示在右侧：
- en: '![](img/eb1d337c-df75-4ffe-a67f-2b97b6f97078.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb1d337c-df75-4ffe-a67f-2b97b6f97078.png)'
- en: Let's take a closer look at each one of these components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些组件。
- en: ledCmdExecutor
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ledCmdExecutor
- en: '`ledCmdExecutor.c`implements a simple state machine, whose state is modified
    when a command is received from the queue.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledCmdExecutor.c`实现了一个简单的状态机，其状态在接收到队列中的命令时被修改。'
- en: 'The available commands are explicitly enumerated by `LED_CMD_NUM`. Each *command*
    has been given a human-friendly enumeration, along with an explicit definition.
    The enums are explicitly defined so they can be properly enumerated on the PC
    side. We also need to make sure the numbers assigned are <= 255, since we''ll
    only be allocating 1 byte in the frame to the command number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的命令通过`LED_CMD_NUM`显式枚举。每个*命令*都已被赋予一个便于理解枚举，并附有明确的定义。枚举被显式定义，以便在PC端正确枚举。我们还需要确保分配的数字
    <= 255，因为我们只会在帧中为命令号分配1个字节：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The only public function is `LedCmdExecution`, which will be used as a FreeRTOS
    task: `void LedCmdExecution(void* Args)`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的公共函数是`LedCmdExecution`，它将被用作FreeRTOS任务：`void LedCmdExecution(void* Args)`。
- en: '`void* Args` actually has a type of `CmdExecArgs`. However, the function signature
    for a FreeRTOS task requires a single parameter of `void*`. The actual data type
    being passed into `LedCmdExecution` is a pointer to this struct:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`void* Args`实际上有一个类型为`CmdExecArgs`。然而，FreeRTOS任务函数签名需要一个`void*`类型的单个参数。传递给`LedCmdExecution`的实际数据类型是这个结构的指针：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Passing in references to everything allows multiple instances of the task to
    be created and run simultaneously. It also provides extremely loose coupling to
    the underlying `iPWM` implementations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 传递所有引用允许创建和同时运行多个任务实例。它还提供了对底层`iPWM`实现的极度松耦合。
- en: '`LedCmdExecution` has a few local variables to track state:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`LedCmdExecution`有几个局部变量来跟踪状态：'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a closer look at these variables:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些变量：
- en: '`currCmdNum`: Local storage for the current command being executed.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currCmdNum`：当前正在执行命令的本地存储。'
- en: '`ledsOn`: Local storage used by the `blink` command to track state.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ledsOn`：由`blink`命令使用的本地存储，用于跟踪状态。'
- en: '`nextLedCmd`: Storage for the next command coming from the queue.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextLedCmd`：存储从队列中来的下一个命令。'
- en: '`args`: A local variable containing the arguments passed in through the `void*
    Args` parameter of our task (notice the explicit cast and check to ensure `NULL`
    hasn''t been passed in instead).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`: 一个局部变量，包含通过我们的任务`void* Args`参数传入的参数（注意显式的类型转换和检查以确保没有传入`NULL`）。'
- en: To ensure none of the pointers change, we're making a local copy. This also
    could have been accomplished by defining the `CmdExecArgs` struct to contain the `const`
    variables that could only be set at initialization to save a bit of space.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有指针发生变化，我们正在创建一个局部副本。这也可以通过定义`CmdExecArgs`结构体来包含只能初始化时设置的`const`变量，以节省一些空间来实现。
- en: This main loop has two responsibilities. The first responsibility, seen in the
    following code, is copying a value from `ledCmdQueue` into the `nextLedCmd` reading, setting
    the appropriate local variables and the duty cycle of the LEDs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此主循环有两个职责。第一个职责，如以下代码所示，是将`ledCmdQueue`中的值复制到`nextLedCmd`读取中，设置适当的局部变量和LED的占空比。
- en: '`ledCmdExecutor.c` is part of the main loop:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledCmdExecutor.c`是主循环的一部分：'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second part of the main loop, seen in the following code, executes if no
    command has been received from `ledCmdQueue` within 250 ticks (250 ms, since our
    configuration uses a 1 kHz tick). This code toggles the LEDs between their last
    commanded duty cycle and `OFF`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环的第二部分，如以下代码所示，在250个tick（250 ms，因为我们的配置使用1 kHz的tick）内没有从`ledCmdQueue`接收到命令时执行。此代码在最后命令的占空比和`OFF`之间切换LED：
- en: '`ledCmdExecutor.c` is the second half of the main loop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledCmdExecutor.c`是主循环的第二部分：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the `setDutyCycles` helper function uses the `iPWM` pointers to actuate
    the PWM duty cycles for the LEDs. The `iPWM` pointers were verified as not being
    `NULL` before the main loop, so the check doesn''t need to be repeated here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`setDutyCycles`辅助函数使用`iPWM`指针来激活LED的PWM占空比。在主循环之前已经验证了`iPWM`指针不是`NULL`，因此不需要在这里重复检查：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That wraps up the high-level functionality of our LED command executor. The
    main purpose of creating a task like this was to illustrate a way to create an
    extremely loosely coupled and scalable system. While it is silly to toggle a few
    LEDs in this way, this design paradigm is perfectly scalable to complex systems
    and capable of being used on different hardware without modification.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们LED命令执行器的高级功能。创建此类任务的主要目的是为了说明创建一个极其松散耦合且可扩展的系统的方法。虽然以这种方式切换几个LED很愚蠢，但这种设计模式完全可以扩展到复杂系统，并且可以在不同的硬件上使用而无需修改。
- en: Now that we have an idea of what the code does at a high level, let's take a
    look at how the `LedCmd` struct is populated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对代码在高级上做了了解，让我们看看`LedCmd`结构体是如何填充的。
- en: Frame decoding
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧解码
- en: 'As data comes in from the USB, it is placed in a stream buffer by the USB stack.
    The `StreamBuffer` function for incoming data can be accessed from `GetUsbRxStreamBuff()` in
    `Drivers/HandsOnRTOS/VirtualCommDriverMultiTask.c`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当USB上的数据到来时，USB堆栈将其放置在流缓冲区中。可以从前面的`GetUsbRxStreamBuff()`在`Drivers/HandsOnRTOS/VirtualCommDriverMultiTask.c`中访问传入数据的`StreamBuffer`函数：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function returns a constant pointer to `StreamBufferHandle_t`. This is
    done so the calling code can access the stream buffer directly, but isn't able
    to change the pointer's value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个指向`StreamBufferHandle_t`的常量指针。这样做是为了让调用代码可以直接访问流缓冲区，但不能更改指针的值。
- en: 'The protocol itself is a strictly binary stream that starts with 0x02 and ends
    with a CRC-32 checksum, transmitted in little endian byte order:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议本身是一个严格二进制流，以0x02开始，以CRC-32校验和结束，以小端字节顺序传输：
- en: '![](img/20ce3e11-1209-4cf8-9e54-c4b59575bbf4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20ce3e11-1209-4cf8-9e54-c4b59575bbf4.png)'
- en: 'There are many different ways of serializing data. A simple binary stream was
    chosen here for simplicity. A few points should be considered:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方式来序列化数据。这里为了简单起见选择了一个简单的二进制流。应该考虑以下几点：
- en: The `0x02` header is a convenient delimiter that can be used to find the (possible)
    start of a frame. It is not sufficiently unique since any of the other bytes in
    the message can also be `0x02` (it is a binary stream, not ASCII). The CRC-32
    at the end provides assurance that the frame was correctly received.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x02`头是一个方便的分隔符，可以用来找到（可能的）帧的开始。它并不足够独特，因为消息中的任何其他字节也可以是`0x02`（它是一个二进制流，不是ASCII）。末尾的CRC-32提供了帧正确接收的保证。'
- en: Since the frame has exactly 1 byte per LED value, we can represent the 0-100%
    duty cycle with 0-255 and we are guaranteed to have valid, in-range parameters,
    without any additional checking.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个LED值正好有1个字节，我们可以用0-255来表示0-100%的占空比，并且我们保证有有效的、范围内的参数，无需任何额外的检查。
- en: This simple method of framing is extremely rigid and provides no flexibility
    whatsoever. The moment we need to send something else over the wire, we're back
    to square one. A more flexible (and complex) serialization method is required
    if flexibility is desired.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种简单的帧方法非常僵化，并且完全没有任何灵活性。当我们需要通过电线发送其他东西时，我们就回到了起点。如果需要灵活性（并且更复杂），就需要一个更灵活的序列化方法。
- en: 'The `frameDecoder` function is defined in `mainColorSelector.c`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`frameDecoder`函数定义在`mainColorSelector.c`中：'
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break it down line by line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析：
- en: 'Two local variables, `incomingCmd` and `frame`, are created. `incomingCmd`
    is used to store the fully parsed command. `frame` is a buffer of bytes that is
    used to store exactly one frame''s worth of data while this function parses/verifies
    it:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了两个局部变量，`incomingCmd`和`frame`。`incomingCmd`用于存储完全解析的命令。`frame`是一个字节缓冲区，用于在函数解析/验证时存储恰好一个帧的数据：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the beginning of the loop, the contents of `frame` are cleared. Only clearing
    the first byte is strictly necessary so we can accurately detect `0x02` and since
    the frame is binary and has a well-defined length (only variable-length strings
    *need* to be null-terminated). However, it is very convenient to see `0` for unpopulated
    bytes, if you happen to be watching the variable during debugging:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环开始时，`frame`的内容被清除。仅清除第一个字节是严格必要的，这样我们才能准确地检测到`0x02`，因为帧是二进制并且有明确的长度（只有可变长度的字符串*需要*以空字符终止）。然而，如果在调试过程中查看变量，看到`0`对于未填充的字节来说非常方便：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A single byte is copied from the `StreamBuffer` function into the frame until `0x02`
    is detected. This should indicate the start of a frame (unless we were unlucky
    enough to start acquiring data in the middle of a frame with a binary value of
    `0x02` in the payload or CRC):'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`StreamBuffer`函数中复制一个字节到帧中，直到检测到`0x02`。这应该表示帧的开始（除非我们不幸在帧的中间开始获取数据，而有效载荷或CRC中的二进制值为`0x02`）：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The remaining bytes of the frame are received from `StreamBuffer`. They are
    placed in the correct index of the `frame` array:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧的剩余字节从`StreamBuffer`接收。它们被放置在`frame`数组正确的索引位置：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The entire frame''s CRC is evaluated. If the CRC is invalid, this data is discarded
    and we''ll begin looking for the start of another frame:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对整个帧的CRC进行评估。如果CRC无效，则丢弃这些数据，并开始寻找下一个帧的开始：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the frame was intact, `incomingCmd` is filled out with the values in the
    frame:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果帧是完整的，`incomingCmd`将填充帧中的值：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The populated command is sent to the queue, which is being watched by `LedCmdExecutor()`.
    Up to `100` ticks may elapse, waiting for space in the queue to become available
    before the command is discarded:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被填充的命令被发送到队列中，该队列正被`LedCmdExecutor()`监视。在命令被丢弃之前，可能需要等待多达`100`个tick，以等待队列中有可用空间：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is important to note that none of the framing protocol is being placed in `LedCmd`,
    which will be sent through the queue – only the payload is. This allows more flexibility
    in how data is acquired before being queued, as we will see in the *Reusing a
    queue definition for a new targe**t *section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，没有任何帧协议被放置在`LedCmd`中，它将通过队列发送——只有有效载荷。这允许在数据入队之前有更多的灵活性，正如我们将在*为新的目标重用队列定义*部分中看到的那样。
- en: Choosing the number of slots available in the queue can have important effects
    on the response of the application to incoming commands. The more slots that are
    available, the higher the likelihood that a command will incur a significant delay
    before being executed. For a system that requires more determinism on when (and
    if) a command will be executed, it is a good idea to limit the queue length to
    only a single slot and perform a protocol-level acknowledgment, based on whether
    the command was successfully queued.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 选择队列中可用的槽位数可以对应用程序对传入命令的响应产生重要影响。可用的槽位越多，命令在执行前发生显著延迟的可能性就越高。对于需要更多确定性来决定何时（以及是否）执行命令的系统，将队列长度限制为仅一个槽位并基于命令是否成功入队进行协议级确认是一个好主意。
- en: Now that we've seen how the frame is decoded, the only remaining piece of the
    puzzle is how data is placed into the USB's receiving stream buffer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了帧是如何被解码的，剩下的唯一一个谜团是如何将数据放入USB接收流缓冲区中。
- en: The USB virtual comm driver
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USB虚拟通信驱动程序
- en: 'The USB''s receiving `StreamBuffer` is populated by `CDC_Receive_FS()` in `Drivers/HandsOnRTOS/usbd_cdc_if.c`.
    This will look similar to the code from [Chapter 11](c76b2fa5-28ac-4467-bb7e-68593a27f9ce.xhtml),
    *S**haring Hardware Peripherals across Tasks, *where the transmit side of the
    driver was developed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: USB的接收`StreamBuffer`由`Drivers/HandsOnRTOS/usbd_cdc_if.c`中的`CDC_Receive_FS()`填充。这看起来与[第11章](c76b2fa5-28ac-4467-bb7e-68593a27f9ce.xhtml)中的代码类似，*在任务间共享硬件外围设备，*其中驱动程序的发送端被开发出来：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using a stream buffer instead of a queue allows larger blocks of memory to be
    copied from the USB stack's internal buffers while providing a queue-like interface
    that has flexibility in the number of bytes copied out of it. This flexibility
    is one of the reasons coding the protocol layer was so straightforward.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流缓冲区而不是队列，允许从USB堆栈的内部缓冲区复制更大的内存块，同时提供一个类似队列的接口，该接口在从其中复制字节数量方面具有灵活性。这种灵活性是编写协议层如此直接的一个原因。
- en: Remember that since a stream buffer is being used, only one task can be a designated
    reader. Otherwise, access to the stream buffer must be synchronized (that is,
    by a mutex).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于使用了流缓冲区，因此只能指定一个任务作为指定的读取器。否则，必须对流缓冲区的访问进行同步（即，通过互斥锁）。
- en: That wraps up all of the MCU-side code in this example. Since this example relies
    on a binary protocol over USB, let's have a look at how the code can be used.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了这个例子中所有MCU端代码的封装。由于这个例子依赖于USB上的二进制协议，让我们看看代码是如何使用的。
- en: Using the code
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码
- en: One of the goals for choosing this example was to have an approachable, real-world
    use case that was relevant. Most of the time, the use cases for the embedded systems
    we develop do not include a person typing away on a terminal emulator. To that
    end, a very simple GUI was created using Python to make it simple to send commands
    to the Nucleo board. The script is `Chapter_13/PythonColorSelectorUI/colorSelector.py`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个例子的一个目标是为了有一个易于接近、与实际应用相关的用例。大多数情况下，我们开发的嵌入式系统的用例并不包括有人在终端模拟器上键入。为此，使用Python创建了一个非常简单的GUI，以便简单地向Nucleo板发送命令。脚本位于`Chapter_13/PythonColorSelectorUI/colorSelector.py`。
- en: 'A Windows binary is also included (`Chapter_13/PythonColorSelectorUI/colorSelector.exe`). `*.exe`
    doesn''t require Python to be installed. For other operating systems, you''ll
    need to install the requisite packages listed in `Chapter_13/PythonColorSelectorUI/requirements.txt` 
    and run a Python 3 interpreter to use the script:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还包括了一个Windows可执行文件（`Chapter_13/PythonColorSelectorUI/colorSelector.exe`）。`.exe`不需要安装Python。对于其他操作系统，您需要安装`Chapter_13/PythonColorSelectorUI/requirements.txt`中列出的必需软件包，并运行Python
    3解释器来使用脚本：
- en: 'You''ll first need to select the STM virtual comm port:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要选择STM虚拟通信端口：
- en: '![](img/be28c33c-1f8b-49dd-9873-da348ac9bbcf.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be28c33c-1f8b-49dd-9873-da348ac9bbcf.png)'
- en: 'After the port has been successfully opened, use the sliders and various buttons
    to actuate the LEDs on the Nucleo development board. A command frame is constructed
    on each UI update event and immediately sent over USB to the MCU. The ASCII-encoded
    hex dump of the last frame sent is displayed:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口成功打开后，使用滑块和各种按钮来控制Nucleo开发板上的LED。在每次UI更新事件中构建一个命令帧，并立即通过USB发送到MCU。显示的是最后发送帧的ASCII编码十六进制转储：
- en: '![](img/3b2c45b4-1df7-46c6-9979-2ef793ab26d5.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b2c45b4-1df7-46c6-9979-2ef793ab26d5.png)'
- en: Alternatively, a terminal application capable of sending binary data could also
    be used (RealTerm is an example for Windows).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用能够发送二进制数据的终端应用程序（例如，Windows上的RealTerm）。
- en: So, we have some blinky lights and a (not-so) flashy UI. Let's address the real
    takeaway of this exercise—the flexibility we've built into our application by
    using a queue in the way that we did.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一些闪烁的灯光和一个（不那么）闪亮的用户界面。让我们来谈谈这个练习的真正收获——通过以我们这样做的方式使用队列，我们为我们的应用程序构建了灵活性。
- en: Reusing a queue definition for a new target
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用队列定义以用于新目标
- en: On the surface, it might be hard to appreciate just how flexible a setup such
    as this one is. On the command-entry side, we have the ability to acquire commands
    from anything, not just the binary framed protocol over USB. Since the data being
    placed into the queue was abstracted to not include any protocol-specific information,
    the underlying protocol could change without requiring any changes downstream.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，可能难以欣赏这种设置有多灵活。在命令输入方面，我们能够从任何地方获取命令，而不仅仅是USB上的二进制帧协议。由于放入队列中的数据被抽象化，不包括任何特定协议的信息，因此底层协议可以更改，而无需对下游进行任何更改。
- en: 'Let''s take a look at a few examples:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子：
- en: 'We could write a different routine for parsing incoming data that uses a comma-separated
    ASCII string, where duty cycles are represented by percentages between 0 and 100
    and a string-based enumeration, terminated by a new line: `BLINK, 20, 30, 100\n`.
    This would result in the following value being placed in `ledCmdQueue`:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为解析传入的数据编写不同的例程，该例程使用以逗号分隔的ASCII字符串，其中占空比由0到100之间的百分比表示，并以换行符结束的基于字符串的枚举：`BLINK,
    20, 30, 100\n`。这将导致以下值被放置在`ledCmdQueue`中：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The underlying interface could change completely (from USB to UART, SPI, I2C,
    Ethernet, an IoT framework, and so on).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层接口可以完全改变（从USB到UART、SPI、I2C、以太网、物联网框架等）。
- en: 'The commands could come in the form of a non-serialized data source (discrete
    duty cycles or physical pins of the MCU, for example):'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令可以是非序列化的数据源的形式（例如离散的占空比或MCU的物理引脚）：
- en: '![](img/9c4850a9-ddc6-40e9-8acd-66723eba2b2f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c4850a9-ddc6-40e9-8acd-66723eba2b2f.png)'
- en: There is also no reason for a queue to be limited to being populated by a single
    task. If it makes sense from a system design perspective, a command executor's
    queue could be populated by any number of simultaneous sources. The possibilities
    of how to get data into the system are truly endless, which is great news—especially
    if you're developing something considerably more complex that will be used in
    multiple systems. You're free to invest time in writing quality code once, knowing
    that the exact code will be used in multiple applications because it is flexible
    enough to adapt while still maintaining a consistent interface.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何理由让队列仅限于由单个任务填充。如果从系统设计角度来看是有意义的，命令执行器的队列可以由任何数量的同时源填充。将数据输入系统的可能性确实是无限的，这是一个好消息——特别是如果你正在开发一个相当复杂的将在多个系统中使用的产品。你可以自由地投资时间编写一次高质量的代码，因为确切的代码将在多个应用程序中使用，因为它足够灵活，可以适应同时保持一致的接口。
- en: There are two components of the ledCmd executor that provide flexibility—the
    queue interface and the `iPWM` interface.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ledCmd执行器有两个组件提供了灵活性——队列接口和`iPWM`接口。
- en: The queue interface
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列接口
- en: After the  `LedCmdExecution()` task is started, the only interaction it has
    with the higher-level code in the system is through its command queue. Because
    of this, we are free to change the underlying implementation without directly
    affecting the higher-level code (as long as the data passed through the queue
    has the same meaning).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LedCmdExecution()`任务启动后，它与系统中的高级代码的唯一交互是通过其命令队列。正因为如此，我们可以自由地更改底层实现，而不会直接影响到高级代码（只要通过队列传递的数据具有相同的意义）。
- en: For example, blinking could be implemented differently and none of the code
    feeding the queue would need to change. Since the only requirements for passing
    data through the queue are `uint8_t` and three floating-point numbers, we're also
    free to completely rewrite the implementation of `LedCmdExecution` (without the `iPWM`
    interface, for example). This change will only affect a single file that starts
    the task—`mainColorSelector.c`, in this example. Any other files that deal with
    the queue directly will be unaffected. If there were multiple sources feeding
    the queue (such as a USB, I2C, IoT framework, and so on), none of them would need
    to be modified, even after completely changing the underlying `LedCmdExecution`
    implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，闪烁可以以不同的方式实现，而向队列提供数据的任何代码都不需要更改。由于通过队列传递数据的要求仅为`uint8_t`和三个浮点数，我们也可以完全重写`LedCmdExecution`（例如，没有`iPWM`接口）的实现。这种更改只会影响启动任务的单个文件——在这个例子中是`mainColorSelector.c`。任何直接处理队列的其他文件将不受影响。如果有多个源向队列提供数据（例如USB、I2C、物联网框架等），即使完全更改了底层的`LedCmdExecution`实现，这些源也不需要修改。
- en: The iPWM interface
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iPWM接口
- en: In this implementation, we've taken flexibility one step further by using a
    flexible interface to actuate the LEDs (`iPWM`). Since all of the calls (such
    as `setDutyCycles`) are defined by a flexible interface (instead of interacting
    directly with hardware), we're free to substitute any other implementation of
    `iPWM` in place of the MCU's `TIM` peripheral implementation included here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们通过使用灵活的接口来驱动LED（`iPWM`）进一步提高了灵活性。由于所有调用（如`setDutyCycles`）都是由灵活的接口定义的（而不是直接与硬件交互），我们可以自由地用任何其他`iPWM`实现替换这里包含的MCU的`TIM`外围实现。
- en: For example, the LED on the other end of the `iPWM` interface could be an addressable
    LED driven by a serial interface, which requires a serial data stream rather than
    PWM. It may even be remotely located and require another protocol to actuate it.
    As long as it can be represented by a percentage between 0 and 100, it can be
    controlled by this code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`iPWM`接口另一端的LED可能是一个通过串行接口驱动的可寻址LED，它需要一个串行数据流而不是PWM。它甚至可能位于远程位置，并需要另一个协议来激活它。只要它可以表示为0到100之间的百分比，就可以通过此代码来控制。
- en: Now—realistically—in the real world, you're not likely to go to all of this
    trouble just to blink a few LEDs! Keep in mind that this is an example with fairly
    trivial functionality, so we're able to keep our focus on the actual architectural
    elements. In practice, flexible architectures provide a foundation to build long-living,
    adaptable code bases on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在——现实地讲——在现实世界中，你不太可能为了闪烁几个LED而费这么大的劲！记住，这是一个具有相当简单功能性的示例，所以我们能够将注意力集中在实际的架构元素上。在实践中，灵活的架构为构建长期存在的、可适应的代码库提供了基础。
- en: All of this flexibility does come with a warning—always be careful of the systems
    you are designing and ensure they meet their primary requirements. There are always
    tradeoffs to be made, whether they are between performance, initial development
    time, BOM cost, code elegance, flash space, or maintainability. After all, a beautifully
    extensible design doesn't do anyone any good if it doesn't fit in the available
    ROM and RAM!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些灵活性都伴随着一个警告——始终要小心你正在设计的系统，并确保它们满足其主要要求。总会有一些权衡，无论是性能、初始开发时间、BOM成本、代码优雅性、闪存空间还是可维护性之间的权衡。毕竟，一个美丽可扩展的设计如果无法适应可用的ROM和RAM，对任何人都没有好处！
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have gained first-hand experience in creating a simple
    end-to-end command executor architecture. At this point, you should be quite comfortable
    with creating queues and will have started to gain a deeper understanding of how
    they can be used to achieve specific design goals, such as flexibility. You can
    apply variations of these techniques to many real-world projects. If you're feeling
    particularly adventurous, feel free to implement one of the suggested protocols
    or add an entry point for another interface (such as a UART).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你获得了创建简单端到端命令执行器架构的第一手经验。此时，你应该非常熟悉创建队列，并且已经开始更深入地了解它们如何被用来实现特定的设计目标，例如灵活性。你可以将这些技术的变体应用于许多实际项目。如果你特别有冒险精神，可以自由地实现建议的协议之一或添加另一个接口的入口点（例如UART）。
- en: In the next chapter, we'll change gears a bit and discuss the available APIs
    for FreeRTOS, investigating when and why you might prefer one over the others.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改变节奏，讨论FreeRTOS的可用的API，探讨何时以及为什么你可能更喜欢其中一个而不是另一个。
- en: Questions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the appendix:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，这里有一份问题列表，供你测试对本章材料的了解。你将在附录的*评估*部分找到答案：
- en: 'Queues decrease design flexibility since they create a rigid definition of
    data transfer that must be adhered to:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列减少了设计灵活性，因为它们创建了一个必须遵守的、对数据传输的严格定义：
- en: 'True'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Queues don''t work well with other abstraction techniques; they must only contain
    simple data types:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列与其他抽象技术不兼容；它们必须只包含简单的数据类型：
- en: 'True'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: When using queues for commands acquired from a serial port, should the queue
    contain exactly the same information and formatting as the underlying serialized
    data stream? Why?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用从串行端口获取的命令的队列时，队列是否应该包含与底层序列化数据流完全相同的信息和格式？为什么？
- en: Name a reason why passing data by value into queues is *easier* than passing
    by reference.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一个原因，说明为什么通过值传递数据到队列比通过引用传递更简单。
- en: Name one reason why it is necessary to carefully consider the depth of queues
    in a real-time embedded system?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一个原因，说明为什么在实时嵌入式系统中仔细考虑队列的深度是必要的？
