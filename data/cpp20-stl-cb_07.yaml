- en: '*Chapter 7*: Strings, Streams, and Formatting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：字符串、流和格式化'
- en: The STL `string` class is a powerful, full-featured tool for storing, manipulating,
    and displaying character-based data. It has much of the convenience you would
    find in a high-level scripting language, yet remains as quick and agile as you
    would expect from C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `string` 类是存储、操作和显示基于字符数据的一个强大、功能齐全的工具。它具有您在高级脚本语言中会发现的大部分便利性，同时仍然像您期望的那样快速敏捷。
- en: 'The `string` class is based on `basic_string`, a contiguous container class
    that may be instantiated with any character type. Its class signature looks like
    this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类基于 `basic_string`，这是一个连续容器类，可以用任何字符类型实例化。其类签名如下：'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Traits` and `Allocator` template parameters are usually left to their default
    values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traits` 和 `Allocator` 模板参数通常保留为默认值。'
- en: 'The underlying storage of `basic_string` is a contiguous sequence of `CharT`,
    and can be accessed with the `data()` member function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic_string` 的底层存储是一个连续的 `CharT` 序列，可以通过 `data()` 成员函数访问：'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Output:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `data()` member function returns a `CharT*` that points to the underlying
    array of characters. Since C++11, the array returned by `data()` is null-terminated,
    making `data()` equivalent to `c_str()`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()` 成员函数返回一个指向字符底层数组的 `CharT*`。自 C++11 以来，`data()` 返回的数组是空终止的，这使得 `data()`
    等同于 `c_str()`。'
- en: The `basic_string` class includes many of the methods you would find in other
    contiguous-storage classes, including `insert()`, `erase()`, `push_back()`, `pop_back()`,
    and others. These methods operate on the underlying array of `CharT`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic_string` 类包含了许多在其他连续存储类中可以找到的方法，包括 `insert()`、`erase()`、`push_back()`、`pop_back()`
    以及其他方法。这些方法在 `CharT` 的底层数组上操作。'
- en: '`std::string` is a type alias for `std::basic_string<char>`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string` 是 `std::basic_string<char>` 的类型别名：'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For most purposes, you'll use `std::string`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用途，您将使用 `std::string`。
- en: String formatting
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: String formatting has traditionally been a weak point with the STL. Until recently,
    we've been left with an imperfect choice between the cumbersome STL `iostreams`
    or the archaic legacy `printf()`. Beginning with C++20 and the `format` library,
    STL string formatting has finally grown up. Closely based on Python's `str.format()`
    method, the new `format` library is fast and flexible, providing many of the advantages
    of both `iostreams` and `printf()`, along with good memory management and type
    safety.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化一直是 STL 的弱点。直到最近，我们只能在不完美的选择之间做出选择，要么是笨拙的 STL `iostreams`，要么是过时的遗产 `printf()`。从
    C++20 和 `format` 库开始，STL 字符串格式化终于成熟起来。新的 `format` 库紧密基于 Python 的 `str.format()`
    方法，快速灵活，提供了 `iostreams` 和 `printf()` 的许多优点，以及良好的内存管理和类型安全。
- en: For more about the `format` library, see the *Format text with the new format
    library* recipe in [*Chaper 1*](B18267_01_ePub.xhtml#_idTextAnchor027), *New C++20
    Features*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `format` 库的信息，请参阅 [*第1章*](B18267_01_ePub.xhtml#_idTextAnchor027) 中的 *使用新的格式化库格式化文本*
    菜谱，*新 C++20 功能*。
- en: While we no longer need to use `iostreams` for string formatting, it is still
    quite useful for other purposes, including file and stream I/O, and some type
    conversions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不再需要使用 `iostreams` 进行字符串格式化，但它仍然在其他用途中非常有用，包括文件和流 I/O 以及一些类型转换。
- en: 'In this chapter, we will cover these subjects and more in the following recipes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题以及更多内容：
- en: Use `string_view` as a lightweight string object
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `string_view` 用作轻量级字符串对象
- en: Concatenate strings
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接字符串
- en: Transform strings
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换字符串
- en: Format text with C++20's `format` library
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++20 的 `format` 库格式化文本
- en: Trim whitespace from strings
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中删除空白字符
- en: Read strings from user input
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户输入读取字符串
- en: Count words in a file
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中计算单词数
- en: Initialize complex structures from file input
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件输入初始化复杂结构
- en: Customize a string class with `char_traits`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `char_traits` 自定义字符串类
- en: Parse strings with Regular Expressions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串
- en: Technical requirements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07)。
- en: Use string_view as a lightweight string object
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `string_view` 用作轻量级字符串对象
- en: The `string_view` class provides a lightweight alternative to the `string` class.
    Instead of maintaining its own data store, `string_view` operates on a *view*
    of a C-string. This makes `string_view` smaller and more efficient than `std::string`.
    It's useful in cases where you need a string object but don't need the more memory-
    and computation-intensive features of `std::string`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类为 `string` 类提供了一个轻量级的替代方案。它不是维护自己的数据存储，而是对 C 字符串的 *视图* 进行操作。这使得
    `string_view` 比起 `std::string` 更小、更高效。在需要字符串对象但不需要 `std::string` 的更多内存和计算密集型功能的情况下，它非常有用。'
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `string_view` class looks deceptively similar to the STL `string` class,
    but it works a bit differently. Let''s consider some examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类看起来与 STL 的 `string` 类非常相似，但工作方式略有不同。让我们考虑一些例子：'
- en: 'Here''s an STL `string` initialized from a C-string (array of `char`):'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个从 C 字符串（`char` 数组）初始化的 STL `string`：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `string` does not change when we modify the array. This is because
    the `string` constructor creates its own copy of the underlying data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们修改数组时，`string` 并没有改变。这是因为 `string` 构造函数创建了底层数据的副本。
- en: 'When we do the same with a `string_view`, we get a different result:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们用 `string_view` 做同样的事情时，我们得到不同的结果：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `string_view` constructor creates a *view* of the underlying data. It does
    not make its own copy. This results in significant efficiencies but also allows
    for side effects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 构造函数创建底层数据的 *视图*。它不会创建自己的副本。这导致显著的效率，但也允许副作用。'
- en: 'Because `string_view` doesn''t copy the underlying data, the source data must
    remain in scope for the duration of the `string_view` object. So, this does not
    work:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `string_view` 不会复制底层数据，源数据必须在 `string_view` 对象持续的时间内保持作用域。因此，这行不通：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because the underlying data goes out of scope after the `sv()` function returns,
    the `greeting` object in `main()` is no longer valid by the time we use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层数据在 `sv()` 函数返回后超出作用域，所以在使用它的时候，`main()` 中的 `greeting` 对象就不再有效了。
- en: 'The `string_view` class has constructors that make sense for the underlying
    data. This includes character arrays (`const char*`), contiguous *ranges* (including
    `std::string`), and other `string_view` objects. This example uses the *ranges*
    constructor:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string_view` 类具有适合底层数据的构造函数。这包括字符数组（`const char*`）、连续 *范围*（包括 `std::string`）和其他
    `string_view` 对象。此示例使用 *范围* 构造函数：'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also a `string_view` literal operator `sv`, defined in the `std::literals`
    namespace:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 `string_view` 文字操作符 `sv`，它在 `std::literals` 命名空间中定义：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This constructs a `constexpr string_view` object and calls its method `substr()`
    to get the `4` values starting at index `1`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这构建了一个 `constexpr string_view` 对象，并调用其方法 `substr()` 来获取从索引 `1` 开始的 `4` 个值。
- en: 'Output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `string_view` class is effectively an *iterator adapter* on a contiguous
    sequence of characters. The implementation typically has two members: a `const
    CharT *` and a `size_t`. It works by wrapping a `contiguous_iterator` around the
    source data.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类实际上是一个连续字符序列的 *迭代器适配器*。其实现通常有两个成员：一个 `const CharT *` 和一个 `size_t`。它通过在源数据周围包装一个
    `contiguous_iterator` 来工作。'
- en: 'This means that you can use it like `std::string` for many purposes, with a
    few important distinctions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以像 `std::string` 一样用于许多目的，但有一些重要的区别：
- en: 'The copy constructor does not copy the data. This means that when you make
    a copy of a `string_view`, each copy operates on the same underlying data:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数不会复制数据。这意味着当你复制一个 `string_view` 时，每个副本都操作相同的底层数据：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Keep in mind that when you pass a `string_view` to a function, it uses the
    copy constructor:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，当你将一个 `string_view` 传递给一个函数时，它使用复制构造函数：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the address of the underlying data (returned by the `data()` member
    function) is the same for all instances of the `string_view`. That's because the
    copy constructor does not make a copy of the underlying data. Even though the
    `string_view` member pointer is `const`-qualified, it's still possible to cast
    away the `const` qualifier, though it's *not recommended* because it could cause
    unintended side effects. But it is worth noting that the data is never copied.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，底层数据的地址（由 `data()` 成员函数返回）对于所有 `string_view` 实例都是相同的。这是因为复制构造函数不会复制底层数据。尽管
    `string_view` 成员指针是 `const`-修饰的，但仍然可以取消 `const` 修饰符，尽管这 *不推荐* 因为它可能会引起意外的副作用。但值得注意的是，数据永远不会被复制。
- en: The `string_view` class lacks methods that directly operate on the underlying
    string. Methods such as `append()`, `operator+()`, `push_back()`, `pop_back()`,
    `replace()`, and `resize()`, which are supported in `string`, are not supported
    in `string_view`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string_view`类缺少直接操作底层字符串的方法。例如`append()`、`operator+()`、`push_back()`、`pop_back()`、`replace()`和`resize()`等，这些在`string`中支持的方法在`string_view`中不支持。'
- en: 'If you need to concatenate strings with the `+` operator, you''ll need a `std::string`.
    For example, this does not work with `string_view`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用`+`运算符连接字符串，你需要一个`std::string`。例如，这不能与`string_view`一起使用：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You''ll need to use `string` instead:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`string`：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Concatenate strings
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'There are several ways to concatenate strings in C++. In this recipe, we will
    look at the three most common: the `string` class `operator+()`, the `string`
    class `append()` function, and the `ostringstream` class `operator<<()`. New in
    C++20, we also have the `format()` function. Each of these has its advantages,
    disadvantages, and use cases.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中连接字符串有几种方法。在这个菜谱中，我们将查看三种最常见的方法：`string`类的`operator+()`运算符、`string`类的`append()`函数和`ostringstream`类的`operator<<()`运算符。C++20新引入的`format()`函数。每个都有其优点、缺点和使用场景。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we will examine ways to concatenate strings. We will then perform
    some benchmarks and consider the different use cases.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查连接字符串的方法。然后我们将进行一些基准测试并考虑不同的使用场景。
- en: 'We''ll start with a couple of `std::string` objects:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从一个`std::string`对象开始：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `string` objects are constructed from literal C-strings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`对象是由字面量C字符串构造的。'
- en: The C-string constructor makes a copy of the literal string and uses the local
    copy as the underlying data for the `string` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: C字符串构造函数复制字面量字符串，并使用本地副本作为`string`对象的底层数据。
- en: 'Now, let''s construct a new empty string object and concatenate `a` and `b`
    with a separator and a newline:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们构造一个新的空字符串对象，并使用分隔符和换行符将`a`和`b`连接起来：
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we used the `string` object''s `+=` and `+` operators to concatenate
    the `a` and `b` strings, along with literal strings `", "` and `"\n"`. The resulting
    string has the elements concatenated together:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`string`对象的`+=`和`+`运算符来连接`a`和`b`字符串，以及字面量字符串`", "`和`"\n"`。结果字符串将元素连接在一起：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could instead use the `string` object''s `append()` member function:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`string`对象的`append()`成员函数：
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This gives us the same result:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了相同的结果：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, we could construct an `ostringstream` object, which uses the stream interface:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以构造一个`ostringstream`对象，它使用流接口：
- en: '[PRE25]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We get the same result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到相同的结果：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could also use the C++20 `format()` function:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用C++20的`format()`函数：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, we have the same result:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到相同的结果：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `string` object has two distinct methods for concatenating a string, the
    `+` operator and the `append()` member function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`对象有两种不同的方法来连接字符串，即`+`运算符和`append()`成员函数。'
- en: The `append()` member function adds data to the end of the `string` object's
    data. It must allocate and manage memory to accomplish this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`成员函数将数据添加到`string`对象数据的末尾。它必须分配和管理内存以完成此操作。'
- en: The `+` operator uses the `operator+()` overload to construct a new `string`
    object with the old and new data, and returns the new object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符使用`operator+()`重载来构造一个新的`string`对象，该对象包含旧数据和新的数据，并返回新对象。'
- en: The `ostringstream` object works like an `ostream` but stores its output for
    use as a string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostringstream`对象的工作方式类似于`ostream`，但存储其输出以用作字符串。'
- en: The C++20 `format()` function uses a format string with variadic arguments and
    returns a newly constructed `string` object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的`format()`函数使用格式字符串和可变参数，并返回一个新构造的`string`对象。
- en: There's more…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: How do you decide which concatenation strategy is right for your code? We can
    start with some benchmarks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何决定哪种连接策略适合你的代码？我们可以从一些基准测试开始。
- en: Benchmarks
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'I performed these tests using GCC 11 on Debian Linux:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用GCC 11在Debian Linux上执行了这些测试：
- en: 'First, we''ll create a `timer` function using the `<chrono>` library:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`<chrono>`库创建一个`timer`函数：
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `timer` function calls the function passed to it, marking the time before
    and after the function call. It then displays the duration using `cout`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`函数调用传递给它的函数，标记函数调用前后的时间。然后它使用`cout`显示持续时间。'
- en: 'Now, we create a function that concatenates strings, using the `append()` member
    function:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个使用`append()`成员函数连接字符串的函数：
- en: '[PRE30]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For benchmarking purposes, this function repeats the concatenation 10 million
    times. We call this function from `main()` with `timer()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基准测试的目的，这个函数重复进行了1000万次的连接操作。我们从`main()`函数中调用这个函数并使用`timer()`：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get this output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, on this system, our concatenation ran 10 million iterations in about 425
    milliseconds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个系统上，我们的连接操作进行了1000万次迭代，大约耗时425毫秒。
- en: 'Now, let''s create the same function with the `+` operator overload:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们用`+`运算符重载创建相同的函数：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our benchmark output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基准输出：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This version performed 10 million iterations in about 660 milliseconds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本进行了1000万次迭代，大约耗时660毫秒。
- en: 'Now, let''s try it with `ostringstream`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们用`ostringstream`来试一试：
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our benchmark output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基准输出：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This version ran 10 million iterations in about 3.5 seconds.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本进行了1000万次迭代，大约耗时3.5秒。
- en: 'Here''s the `format()` version:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是`format()`版本的示例：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our benchmark output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基准输出：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `format()` version ran 10 million iterations in about 783 milliseconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`版本进行了1000万次迭代，大约耗时783毫秒。'
- en: 'Summary of the results:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果总结：
- en: '![A comparison of concatenation performance'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![连接性能比较'
- en: '](img/B18267_table_7.1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_table_7.1.jpg)'
- en: A comparison of concatenation performance
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 连接性能比较
- en: Why the performance discrepancies?
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能差异的原因是什么？
- en: We can see from these benchmarks that the `ostringstream` version takes many
    times longer than the `string`-based versions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些基准测试中我们可以看出，`ostringstream`版本比基于`string`的版本慢很多倍。
- en: The `append()` method is slightly faster than the `+` operator. It needs to
    allocate memory but does not construct new objects. Some optimizations may be
    possible due to repetition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`方法比`+`运算符略快。它需要分配内存但不构造新对象。由于重复，可能存在一些优化。'
- en: The `+` operator overload probably calls the `append()` method. The extra function
    call could make it incrementally slower than the `append()` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符重载可能调用`append()`方法。额外的函数调用可能会使其比`append()`方法逐渐慢。'
- en: The `format()` version creates one new `string` object but without the overhead
    of the `iostream` system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`版本创建了一个新的`string`对象，但没有`iostream`系统的开销。'
- en: The `ostringstream` operator `<<` overload creates a new `ostream` object for
    each operation. Given the complexity of the stream object, along with managing
    the stream state, this makes it much slower than either of the `string`-based
    versions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostringstream`的`<<`运算符重载为每个操作创建一个新的`ostream`对象。考虑到流对象的复杂性以及管理流状态，这使得它比基于`string`的任何版本都要慢得多。'
- en: Why would I choose one over another?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我会选择其中一个而不是另一个？
- en: Some measure of personal preference will be involved. The operator overloads
    (`+` or `<<`) can be convenient. Performance may or may not be an issue for you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 个人的偏好将涉及一些度量。运算符重载（`+`或`<<`）可能是方便的。性能可能对你来说是一个问题，也可能不是。
- en: 'The `ostringstream` class has one distinct advantage over the `string` methods:
    it specializes the `<<` operator for each different type, so it''s able to operate
    in circumstances where you may have different types calling the same code.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostringstream`类相对于`string`方法有一个独特的优势：它为每种不同类型专门化了`<<`运算符，因此能够在可能存在不同类型调用相同代码的情况下操作。'
- en: The `format()` function offers the same type-safety and customization options
    and is significantly faster than the `ostringstream` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`函数提供了相同类型安全和定制选项，并且比`ostringstream`类快得多。'
- en: The `string` object's `+` operator overload is fast, easy to use, and easy to
    read but is incrementally slower than `append()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`对象的`+`运算符重载速度快，使用方便，易于阅读，但比`append()`方法逐渐慢。'
- en: The `append()` version is fastest but requires a separate function call for
    each item.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`版本最快，但需要为每个项目调用一个单独的函数。'
- en: For my purposes, I like the `format()` function or the `string` object's `+`
    operator for most circumstances. I'll use `append()` if every bit of speed matters.
    I'll use `ostringstream` where I need its unique features and performance is not
    an issue.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的目的，我更喜欢`format()`函数或`string`对象的`+`运算符，在大多数情况下。如果每个速度的比特都很重要，我会使用`append()`。如果需要`ostringstream`的独特功能和性能不是问题，我会使用它。
- en: Transform strings
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换字符串
- en: The `std::string` class is a *contiguous container*, much like a `vector` or
    an `array`. It supports the `contiguous_iterator` concept and all corresponding
    algorithms.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`类是一个*连续容器*，类似于`vector`或`array`。它支持`contiguous_iterator`概念和所有相应的算法。'
- en: The `string` class is a specialization of `basic_string` with a `char` type.
    This means that the elements of the container are of type `char`. Other specializations
    are available, but `string` is most common.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类是`basic_string`的一个特化，其类型为`char`。这意味着容器的元素是`char`类型。其他特化也可用，但`string`是最常见的。'
- en: Because it is fundamentally a contiguous container of `char` elements, `string`
    may be used with the `transform()` algorithm, or any other technique that uses
    the `contiguous_iterator` concept.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它本质上是一个连续的`char`元素容器，所以`string`可以使用`transform()`算法，或者任何使用`contiguous_iterator`概念的技巧。
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: There are several ways to do transformations, depending on the application.
    This recipe will explore a few of them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用的不同，有多种方式进行转换。本食谱将探讨其中的一些。
- en: 'We''ll start with a few predicate functions. A predicate function takes a transformation
    element and returns a related element. For example, here is a simple predicate
    that returns an upper-case character:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从几个谓词函数开始。谓词函数接受一个转换元素并返回一个相关元素。例如，这里有一个简单的谓词，它返回一个大写字母：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function is a wrapper around `std::toupper()`. Because the `toupper()`
    function returns an `int` and `string` elements are type `char`, we cannot use
    the `toupper()` function directly in a transformation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`std::toupper()`的包装器。因为`toupper()`函数返回一个`int`，而`string`元素是`char`类型，所以我们不能直接在转换中使用`toupper()`函数。
- en: 'Here is a corresponding `char_lower()` function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的`char_lower()`函数：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `rot13()` function is a fun transformation predicate for demonstration
    purposes. It''s a simple substitution cypher, *not suitable for encryption* but
    commonly used for *obfuscation*:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rot13()`函数是一个用于演示目的的有趣转换谓词。它是一个简单的替换密码，**不适用于加密**，但常用于**混淆**：'
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can use these predicates with the `transform()` algorithm:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用这些谓词与`transform()`算法一起使用：
- en: '[PRE42]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `transform()` function calls `char_upper()` with each element of `s`, puts
    the result back in `s` and transforms all the characters to uppercase:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform()`函数对`s`的每个元素调用`char_upper()`，将结果放回`s`中，并将所有字符转换为大写：'
- en: 'Output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Instead of `transform()`, we can also use a simple `for` loop with a *predicate*
    *function*:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`transform()`，我们还可以使用一个简单的**带有谓词函数的**`for`循环：
- en: '[PRE44]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Starting with our uppercase string object, the result is:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的大写字符串对象开始，结果是：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The fun thing about the `rot13` cypher is that it unscrambles itself. Because
    there are 26 letters in the *ASCII* alphabet, rotating 13 and then rotating 13
    again results in the original string. Let''s transform to lowercase and `rot13`
    again to restore our string:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rot13`密码的有趣之处在于它可以自己解密。因为ASCII字母表中有26个字母，旋转13次然后再旋转13次会得到原始字符串。让我们将字符串转换为小写并再次进行`rot13`转换以恢复我们的字符串：'
- en: '[PRE46]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because of their uniform interface, the predicate functions may be *chained*
    as parameters of each other. We could also use `char_lower(rot13(c))` with the
    same result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的接口统一，谓词函数可以作为彼此的参数进行**链式**调用。我们也可以使用`char_lower(rot13(c))`得到相同的结果。
- en: 'If your requirement is too complex for a simple character-by-character transformation,
    you may use `string` iterators as you would with any contiguous container. Here''s
    a simple function that transforms a lowercase string to *Title Case* by capitalizing
    the first character and every character that follows a space:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的需求对于简单的字符转换过于复杂，你可以像使用任何连续容器一样使用`string`迭代器。以下是一个简单的函数，它通过将第一个字符和每个跟在空格后面的字符大写，将小写字符串转换为**标题大小写**：
- en: '[PRE48]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Because it returns a reference to the transformed string, we can call it with
    `cout`, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它返回转换后字符串的引用，我们可以像这样用`cout`调用它：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::basic_string` class, and its specializations (including `string`),
    are supported by iterators fully compliant with `contiguous_iterator`. This means
    that any technique that works with any contiguous container also works with `string`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_string`类及其特化（包括`string`），都由完全符合`contiguous_iterator`的迭代器支持。这意味着任何适用于任何连续容器的技巧也适用于`string`。'
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These transformations will not work with `string_view` objects because the underlying
    data is `const`-qualified.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换不会与`string_view`对象一起工作，因为底层数据是`const`修饰的。
- en: Format text with C++20's format library
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++20的格式库格式化文本
- en: C++20 introduces the new `format()` function, which returns a formatted representation
    of its arguments in a string. `format()` uses a Python-style formatting string,
    with concise syntax, type safety, and excellent performance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了新的 `format()` 函数，该函数返回其参数的格式化字符串表示。`format()` 使用 Python 风格的格式化字符串，具有简洁的语法、类型安全和优秀的性能。
- en: 'The `format()` function takes a format string and a template, *parameter pack*,
    for its arguments:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 函数接受一个格式字符串和一个模板，即 *参数包* 作为其参数：'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The format string uses curly braces `{}` as a placeholder for the formatted
    arguments:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串使用花括号 `{}` 作为格式化参数的占位符：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It also uses the braces for format specifiers, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它也使用花括号作为格式说明符，例如：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This recipe will show you how to use the `format()` function for some common
    string formatting solutions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何使用 `format()` 函数来实现一些常见的字符串格式化解决方案。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter was developed using a preview release of the Microsoft Visual C++
    compiler on Windows 10\. At the time of writing, this is the only compiler that
    fully supports the C++20 `<format>` library. Final implementations may differ
    in some details.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是在 Windows 10 上使用 Microsoft Visual C++ 编译器的预览版开发的。在撰写本文时，这是唯一完全支持 C++20 `<format>`
    库的编译器。最终实现可能在某些细节上有所不同。
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s consider some common formatting solutions using the `format()` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些使用 `format()` 函数的常见格式化解决方案：
- en: 'We''ll start with some variables to format:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从一些需要格式化的变量开始：
- en: '[PRE56]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `pi` constant is in the `<numbers>` header and the `std::numbers` namespace.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi` 常量在 `<numbers>` 头文件和 `std::numbers` 命名空间中。'
- en: 'We can display the variables using `cout`:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `cout` 来显示变量：
- en: '[PRE57]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We get this output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s look at each of these with `format()`, starting with the C-string,
    `human`:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们用 `format()` 来查看这些内容，从 C-string 的 `human` 开始：
- en: '[PRE59]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is the simplest form of the `format()` function. The format string has
    one placeholder `{}` and one corresponding variable, `human`. The output is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `format()` 函数的最简单形式。格式字符串有一个占位符 `{}` 和一个相应的变量 `human`。输出如下：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `format()` function returns a string, and we use `cout <<` to display the
    string.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format()` 函数返回一个字符串，我们使用 `cout <<` 来显示这个字符串。'
- en: 'The original proposal for the `format()` library included a `print()` function,
    using the same parameters as `format()`. That would allow us to print our formatted
    strings in one step:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 库的原版提案包括一个 `print()` 函数，它使用与 `format()` 相同的参数。这将允许我们一步打印我们的格式化字符串：'
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Unfortunately, `print()` didn't make it into the C++20 standard, although it
    is expected to be included in C++23.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`print()` 没有被纳入 C++20 标准，尽管它预计将在 C++23 中被包含。
- en: 'We can provide the same functionality with a simple function, using `vformat()`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的函数，通过 `vformat()` 来提供相同的功能：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This simple one-line function gives us a serviceable `print()` function. We
    can use it in place of the `cout << format()` combination:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的单行函数为我们提供了一个可用的 `print()` 函数。我们可以用它来代替 `cout << format()` 组合：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A more complete version of this function may be found in the `include` directory
    of the example files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例文件的 `include` 目录中可以找到这个函数的更完整版本。
- en: 'The format string also provides positional options:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式字符串还提供了位置选项：
- en: '[PRE65]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can change the order of the arguments by using positional options in the
    format string:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在格式字符串中使用位置选项来改变参数的顺序：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we get this output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到以下输出：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that the arguments remain the same. Only the positional values in the
    braces have changed. The positional indices are zero-based, just like the `[]`
    operator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数保持不变。只有花括号中的位置值发生了变化。位置索引是从零开始的，就像 `[]` 操作符一样。
- en: This feature can be useful for internationalization, as different languages
    use different orders for parts of speech in a sentence.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对于国际化很有用，因为不同的语言在句子中不同词性的顺序不同。
- en: 'There are many formatting options for numbers:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字有许多格式化选项：
- en: '[PRE69]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can specify the number of digits of precision:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定精度的位数：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The colon character `:` is used to separate positional indices from formatting
    arguments:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号字符 `:` 用于分隔位置索引和格式化参数：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we want a value to take up a certain amount of space, we can specify the
    number of characters like this:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想让一个值占据一定数量的空间，我们可以指定字符数，如下所示：
- en: '[PRE75]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can align it left or right:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其左对齐或右对齐：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By default, it fills with space characters, but we can change that:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它用空格字符填充，但我们可以更改它：
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can also center a value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以居中一个值：
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can format integer numbers as hexadecimal, octal, or the default decimal
    representation:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将整数格式化为十六进制、八进制或默认的十进制表示：
- en: '[PRE83]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice that I used right alignment to line up the labels.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用了右对齐来对齐标签。
- en: 'Use a capital `X` for uppercase hexadecimal:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大写 `X` 表示大写十六进制：
- en: '[PRE85]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE86]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Tip
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, Windows uses uncommon character encodings. Recent versions may default
    to UTF-16 or UTF-8 BOM. Older versions may default to "code page" 1252, a superset
    of the ISO 8859-1 ASCII standard. No Windows system defaults to the more common
    UTF-8 (no BOM).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Windows 使用不常见的字符编码。最新版本可能默认为 UTF-16 或 UTF-8 BOM。较旧版本可能默认为 "代码页" 1252，它是
    ISO 8859-1 ASCII 标准的超集。没有 Windows 系统默认使用更常见的 UTF-8（无 BOM）。
- en: By default, Windows will not display the standard UTF-8 `π` character. To make
    Windows compatible with UTF-8 encoding (and the rest of the world), use the compiler
    switch `/utf-8` and issue the command `chcp 65001` on the command line when testing.
    Now, you can have your `π` and eat it too.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Windows 不会显示标准的 UTF-8 `π` 字符。为了使 Windows 与 UTF-8 编码（以及世界上的其他部分）兼容，使用编译器开关
    `/utf-8` 并在命令行上执行 `chcp 65001` 命令进行测试。现在，你可以拥有你的 `π` 并享用它。
- en: How it works…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `<format>` library uses a template *parameter pack* to pass arguments to
    the formatter. This allows the arguments to be individually inspected for class
    and type. The library function, `make_format_args()` takes a parameter pack and
    returns a `format_args` object, which provides a *type erased* list of arguments
    to be formatted.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`<format>` 库使用模板 *参数包* 将参数传递给格式化器。这允许单独检查参数的类和类型。库函数 `make_format_args()` 接收一个参数包并返回一个
    `format_args` 对象，该对象提供了一个要格式化的 *类型擦除* 参数列表。'
- en: 'We can see this in action in our `print()` function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `print()` 函数中看到这一点：
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `make_format_args()` function takes a parameter pack and returns a `format_args`
    object. The `vformat()` function takes a format string and the `format_args` object,
    and returns a `std::string`. We use the `c_str()` method to get a C-string for
    use with `fputs()`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_format_args()` 函数接收一个参数包并返回一个 `format_args` 对象。`vformat()` 函数接收一个格式字符串和
    `format_args` 对象，并返回一个 `std::string`。我们使用 `c_str()` 方法获取用于 `fputs()` 的 C 字符串。'
- en: There's more…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'It''s common practice to overload the `ostream` `<<` operator for custom classes.
    For example, given a class `Frac` that holds the values of a fraction:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义类，通常的做法是重载 `ostream` 的 `<<` 操作符。例如，给定一个包含分数值的 `Frac` 类：
- en: '[PRE88]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We want to print the object as a fraction like `3/5`. So, we would write a
    simple `operator<<` specialization like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将对象打印成分数形式，例如 `3/5`。因此，我们会编写一个简单的 `operator<<` 特化如下：
- en: '[PRE89]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now our output is:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出是：
- en: '[PRE90]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To provide `format()` support for our custom class, we need to create a `formatter`
    object specialization, like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们自定义的类提供 `format()` 支持，我们需要创建一个 `formatter` 对象特化，如下所示：
- en: '[PRE91]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The specialization of the `std::formatter` class overloads its `format()` method.
    We inherit from the `formatter<unsigned>` specialization for simplicity. The `format()`
    method is called with a `Context` object, which provides the output context for
    the formatted string. For the return value, we use the `format_to()` function
    with `ctx.out`, a normal format string, and parameters.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::formatter` 类的特化重载了其 `format()` 方法。为了简单起见，我们继承自 `formatter<unsigned>`
    特化。`format()` 方法使用一个 `Context` 对象调用，该对象提供了格式化字符串的输出上下文。对于返回值，我们使用 `format_to()`
    函数与 `ctx.out`、一个普通格式字符串和参数。'
- en: 'Now, we can now use our `print()` function with the `Frac` class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `print()` 函数和 `Frac` 类：
- en: '[PRE92]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The formatter now recognizes our class and provides our desired output:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化器现在识别我们的类并提供了我们期望的输出：
- en: '[PRE93]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Trim whitespace from strings
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串中修剪空白
- en: It is common for input from users to include extraneous whitespace at one or
    both ends of a string. This can be problematic, so we often need to remove it.
    In this recipe, we'll use the `string` class methods, `find_first_not_of()` and
    `find_last_not_of()`, to trim whitespace from the ends of a string.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入通常会在字符串的一端或两端包含多余的空白。这可能会引起问题，因此我们通常需要删除它。在这个菜谱中，我们将使用 `string` 类的 `find_first_not_of()`
    和 `find_last_not_of()` 方法来修剪字符串的端部空白。
- en: How to do it…
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `string` class includes methods for finding elements that are, or are not,
    included in a list of characters. We''ll use these methods to trim `string`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类包含用于查找是否包含在字符列表中的元素的方法。我们将使用这些方法来修剪 `string`：'
- en: 'We start by defining `string` with input from a hypothetical ten-thumbed user:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用来自一个假设的多指用户的输入来定义 `string`：
- en: '[PRE94]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Our input has a few extra tab `\t` and newline `\n` characters before and after
    the content. We print it with surrounding brackets to show the whitespace:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容前后有一些额外的制表符 `\t` 和换行符 `\n` 字符。我们用括号包围它来显示空白：
- en: '[PRE95]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here''s a `trimstr()` function to remove all the whitespace characters from
    both ends of `string`:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个 `trimstr()` 函数，用于从 `string` 的两端删除所有空白字符：
- en: '[PRE96]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We defined our set of whitespace characters as *space*, *tab*, *return*, *newline*,
    *vertical tab*, and *form feed*. Some of these are more common than others, but
    that's the canonical set.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的一组空白字符为 *空格*、*制表符*、*回车*、*换行符*、*垂直制表符* 和 *换页符*。其中一些比其他更常见，但这是规范集合。
- en: This function uses the `find_first_not_of()` and `find_last_not_of()` methods
    of the `string` class to find the first/last elements that are *not* a member
    of the set.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `string` 类的 `find_first_not_of()` 和 `find_last_not_of()` 方法来查找第一个/最后一个不是集合成员的元素。
- en: 'Now, we can call the function to get rid of all that unsolicited whitespace:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以调用该函数来去除所有那些不请自来的空白字符：
- en: '[PRE97]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE98]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works…
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `string` class''s various `find...()` member functions return a position
    as a `size_t` value:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类的各个 `find...()` 成员函数返回一个 `size_t` 类型的位置：'
- en: '[PRE99]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The return value is the zero-based position of the first matching character
    (*not* in the `s` list of characters) or the special value, `string::npos`, if
    not found. `npos` is a static member constant that represents an invalid position.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是第一个匹配字符（不在 `s` 字符列表中）的零基于位置，或者如果没有找到，则返回特殊值，`string::npos`。`npos` 是一个静态成员常量，表示一个无效的位置。
- en: We test for `(first == string::npos)` and return an empty string `{}` if there
    is no match. Otherwise, we use the `first` and `last` positions with the `s.substr()`
    method to return the string without whitespace.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试 `(first == string::npos)`，如果没有匹配，则返回空字符串 `{}`。否则，我们使用 `first` 和 `last`
    位置与 `s.substr()` 方法一起返回没有空白的字符串。
- en: Read strings from user input
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户输入读取字符串
- en: The STL provides character-based input from the standard input stream using
    the `std::cin` object. The `cin` object is a global *singleton* that reads input
    from the console as an `istream` input stream.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: STL 使用 `std::cin` 对象从标准输入流提供基于字符的输入。`cin` 对象是一个全局 *单例*，它将输入从控制台作为 `istream`
    输入流读取。
- en: 'By default, `cin` reads *one word at a time* until it reaches the end of the
    stream:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cin` 一次读取 *一个单词*，直到达到流的末尾：
- en: '[PRE100]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Output:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE101]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is of limited usefulness, and it may lead some to dismiss `cin` as minimally
    functional.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这有限的使用价值，并且可能会导致一些人将 `cin` 视为功能最小化。
- en: While `cin` certainly has its quirks, it can be easily wrangled into providing
    line-oriented input.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `cin` 确实有其怪癖，但它可以轻松地被整理成提供面向行的输入。
- en: How to do it…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To get basic line-oriented functionality from `cin`, there are two significant
    behaviors that need to be understood. One is the ability to get a line at a time,
    instead of a word at a time. The other is the ability to reset the stream after
    an error condition. Let''s look at these in some detail:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `cin` 获取基本的面向行的功能，需要了解两个重要的行为。一个是能够一次获取一行，而不是一次一个单词。另一个是在错误条件下重置流的能力。让我们详细看看这些：
- en: 'First, we need to prompt the user for input. Here''s a simple `prompt` function:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要提示用户输入。这里有一个简单的 `prompt` 函数：
- en: '[PRE102]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `cout.flush()` function call ensures that the output is displayed immediately.
    Sometimes, when the output doesn't include a newline, the output stream may not
    flush automatically.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`cout.flush()` 函数调用确保输出立即显示。有时，当输出不包含换行符时，输出流可能不会自动刷新。'
- en: 'The `cin` class has a `getline()` method that gets a line of text from the
    input stream and puts it in a C-string array:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cin` 类有一个 `getline()` 方法，可以从输入流获取一行文本并将其放入 C-string 数组中：'
- en: '[PRE103]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE104]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `cin.getline()` method takes three arguments:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin.getline()` 方法接受三个参数：'
- en: '[PRE105]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The first argument is a C-string array for the destination. The second is the
    size of the array. The third is the delimiter for the end of the line.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是目标 C-string 数组。第二个是数组的大小。第三个是行结束的分隔符。
- en: The function will not put more than `count`-1 characters in the array, leaving
    room for a *null* terminator.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将不会在数组中放置超过 `count`-1 个字符，为 *空字符* 终止符留出空间。
- en: The delimiter defaults to the newline `'\n'` character.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符默认为换行符 `'\n'`。
- en: 'The STL also provides a stand-alone `getline()` function that works with an
    STL `string` object:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 还提供了一个独立的 `getline()` 函数，它可以与 STL `string` 对象一起使用：
- en: '[PRE106]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE107]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The stand-alone `std::getline()` function takes three arguments:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的 `std::getline()` 函数接受三个参数：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The first argument is the output stream, second is a reference to a `string`
    object, and the third is the end-of-line delimiter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是输出流，第二个参数是 `string` 对象的引用，第三个是行结束符。
- en: If not specified, the delimiter defaults to the newline `'\n'` character.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，分隔符默认为换行符 `'\n'`。
- en: I find the standalone `getline()` more convenient than the `cin.getline()` method.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现独立的 `getline()` 比使用 `cin.getline()` 方法更方便。
- en: We can use `cin` to get a specific type from the input stream. To do this, we
    must be able to handle an error condition.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `cin` 从输入流中获取特定类型。为了做到这一点，我们必须能够处理错误条件。
- en: 'When `cin` encounters an error, it sets the stream to an error condition and
    stops accepting input. To retry input after an error, we must reset the state
    of the stream. Here''s a function that resets the input stream after an error:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `cin` 遇到错误时，它会将流设置为错误条件并停止接受输入。为了在错误后重试输入，我们必须重置流的状态。这里有一个在错误后重置输入流的函数：
- en: '[PRE109]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `cin.clear()` function resets the error flags on the input stream but leaves
    text in the buffer. We then clear the buffer by reading a line and discarding
    it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin.clear()` 函数重置输入流的错误标志，但留下缓冲区中的文本。然后我们通过读取一行并丢弃它来清除缓冲区。'
- en: 'We can accept numeric input by using `cin` with numeric type variables:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `cin` 和数值类型变量来接受数值输入：
- en: '[PRE110]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Output:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE111]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `cin >> a >> b` expression accepts input from the console and attempts to
    convert the first two words to types compatible with `a` and `b` (`double`). If
    it fails, we call `clearistream()` and try again.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin >> a >> b` 表达式从控制台接受输入，并尝试将前两个单词转换为与 `a` 和 `b` (`double`) 兼容的类型。如果失败，我们调用
    `clearistream()` 并再次尝试。'
- en: 'We can use the `getline()` separator parameter to get comma-separated input:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `getline()` 的分隔符参数来获取逗号分隔的输入：
- en: '[PRE112]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE113]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Because this code runs after the numbers code, and because `cin` is messy, there
    may still be a line ending in the buffer. The `while(line.empty())` loop will
    optionally eat any empty lines.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这段代码在数字代码之后运行，并且因为 `cin` 输入混乱，缓冲区中可能仍然存在一个行结束符。`while(line.empty())` 循环将可选地吃掉任何空行。
- en: We use a `stringstream` object to process the words, so we don't have to do
    it with `cin`. This allows us to use `getline()` to get one line without waiting
    for the end-of-file state.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `stringstream` 对象来处理单词，因此我们不必使用 `cin` 来做。这允许我们使用 `getline()` 获取一行，而无需等待文件结束状态。
- en: Then, we call `getline()` on the `stringstream` object to parse out words separated
    by commas. This gives us words but with leading whitespace. We use the `trimstr()`
    function from the *Trim whitespace from strings* recipe in this chapter to trim
    the whitespace.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `stringstream` 对象上调用 `getline()` 来解析出由逗号分隔的单词。这给我们单词，但带有前导空白。我们使用本章中
    *从字符串中删除空白* 食谱中的 `trimstr()` 函数来删除空白。
- en: How it works…
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::cin` object is more useful than it may appear, but it can be a challenge
    to use. It tends to leave line endings on the stream, and in the case of errors,
    it can end up ignoring input.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cin` 对象比它看起来更有用，但使用它可能是一个挑战。它倾向于在流中留下行结束符，并且在错误的情况下，它可能会忽略输入。'
- en: The solution is to use `getline()` and, when necessary, put the line into a
    `stringstream` for convenient parsing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用 `getline()`，并在必要时将行放入 `stringstream` 中以便方便解析。
- en: Count words in a file
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中计数单词
- en: By default, the `basic_istream` class reads one word at a time. We can take
    advantage of this property to use an `istream_iterator` to count words.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`basic_istream` 类一次读取一个单词。我们可以利用这个特性来使用 `istream_iterator` 来计数单词。
- en: How to do it…
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'This is a simple recipe to count words using an `istream_iterator`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的使用 `istream_iterator` 来计数单词的食谱：
- en: 'We''ll start with a simple function to count words using an `istream_iterator`
    object:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从使用 `istream_iterator` 对象来计数单词的简单函数开始：
- en: '[PRE114]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `distance()` function takes two iterators and returns the number of steps
    between them. The `using` statement creates an alias `it_t` for the `istream_iterator`
    class with a `string` specialization. We then call `distance()` with an iterator,
    initialized with the input stream `it_t{is}`, and another with the default constructor,
    which gives us an end-of-stream sentinel.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance()` 函数接受两个迭代器并返回它们之间的步骤数。`using` 语句为具有 `string` 特化的 `istream_iterator`
    类创建了一个别名 `it_t`。然后我们使用一个初始化为输入流 `it_t{is}` 的迭代器和另一个使用默认构造函数的迭代器调用 `distance()`，后者给出了流结束的哨兵。'
- en: 'We call `wordcount()` from `main()`:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `main()` 函数中调用 `wordcount()`：
- en: '[PRE115]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This calls `wordcount()` with our `fstream` object and prints the number of
    words in the file. When I call it with the text of Edgar Allan Poe''s *The Raven*,
    we get this output:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用 `wordcount()` 并打印文件中的单词数。当我用埃德加·爱伦·坡的 *The Raven* 的文本调用它时，我们得到以下输出：
- en: '[PRE116]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: How it works…
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Because `basic_istream` defaults to word-by-word input, the number of steps
    in a file will be the number of words. The `distance()` function will measure
    the number of steps between two iterators, so calling it with the beginning and
    the sentinel of a compatible object will count the number of words in the file.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `basic_istream` 默认按单词输入，文件中的步骤数将是单词数。`distance()` 函数将测量两个迭代器之间的步骤数，因此使用起始迭代器和兼容对象的哨兵调用它将计算文件中的单词数。
- en: Initialize complex structures from file input
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件输入初始化复杂结构
- en: One strength of the *input stream* is its ability to parse different types of
    data from a text file and convert them to their corresponding fundamental types.
    Here's a simple technique for importing data into a container of structures using
    an input stream.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入流* 的一项优点是它能够从文本文件中解析不同类型的数据并将它们转换为相应的基本类型。这里有一个简单的技术，使用输入流将数据导入结构体的容器中。'
- en: How to do it…
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we''ll take a data file and import its disparate fields into
    a `vector` of `struct` objects. The data file represents cities with their populations
    and map coordinates:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从一个数据文件中导入其不同的字段到 `struct` 对象的 `vector` 中。数据文件表示城市及其人口和地图坐标：
- en: 'This is `cities.txt`, the data file we''ll read:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是 `cities.txt`，我们将要读取的数据文件：
- en: '[PRE117]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The city name is on a line by itself. The second line is population, followed
    by longitude and latitude. This pattern repeats for each of the five cities.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 城市名称独占一行。第二行是人口，后面跟着经度和纬度。这种模式为五个城市中的每一个重复。
- en: 'We''ll define our filename in a constant so that we can open it later:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在一个常量中定义我们的文件名，这样我们就可以稍后打开它：
- en: '[PRE118]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here''s a `City` struct to hold the data:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个用于存储数据的 `City` 结构体：
- en: '[PRE119]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We would like to read the file and populate a `vector` of `City` objects:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望读取文件并将 `City` 对象的 `vector` 填充：
- en: '[PRE120]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here''s where the input stream makes this easy. We can simply specialize `operator>>`
    for our `City` class like this:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是输入流使这变得简单的地方。我们可以简单地像这样为我们的 `City` 类特化 `operator>>`：
- en: '[PRE121]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `std::ws` input manipulator discards leading whitespace from the input stream.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ws` 输入操纵符会从输入流中丢弃前导空白字符。'
- en: We use `getline()` to read the city name, as it could be one or more words.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `getline()` 读取城市名称，因为它可能是一个或多个单词。
- en: This leverages the `>>` operator for the `population` (`unsigned long`), and
    `latitude` and `longitude` (both `double`) elements to populate the correct type.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了 `>>` 操作符为 `population`（`unsigned long`）、`latitude` 和 `longitude`（都是 `double`）元素填充正确的类型。
- en: 'Now, we can open the file and use the `>>` operator to read the file directly
    into the `vector` of `City` objects:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以打开文件并使用 `>>` 操作符直接将文件读取到 `City` 对象的 `vector` 中：
- en: '[PRE122]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We can display the vector using `format()`:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `format()` 显示这个向量：
- en: '[PRE123]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE124]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `make_commas()` function was also used in the *Use structured binding to
    return multiple values* recipe in [*Chapter 2*](B18267_02_ePub.xhtml#_idTextAnchor057),
    *General STL Features*. It takes a numeric value and returns a `string` object,
    with commas added for readability:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_commas()` 函数也用于 *使用结构化绑定返回多个值* 菜谱中的 [*第2章*](B18267_02_ePub.xhtml#_idTextAnchor057)，*通用
    STL 功能*。它接受一个数值并返回一个 `string` 对象，其中添加了逗号以提高可读性：'
- en: '[PRE125]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: How it works…
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The heart of this recipe is the `istream` class `operator>>` overload:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的核心是 `istream` 类的 `operator>>` 重载：
- en: '[PRE126]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'By specifying our `City` class in the function header, this function will be
    called every time a `City` object appears on the right-hand side of an input stream
    `>>` operator:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数头中指定我们的 `City` 类，每当一个 `City` 对象出现在输入流 `>>` 操作符的右侧时，这个函数就会被调用：
- en: '[PRE127]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This allows us to specify exactly how the input stream reads data into a `City`
    object.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们精确指定输入流如何将数据读入 `City` 对象。
- en: There's more…
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: When you run this code on a Windows system, you'll notice that the first word
    of the first line gets corrupted. That's because Windows always includes a **Byte
    Order Mark** (**BOM**) at the head of any UTF-8 file. So, when you read a file
    on Windows, the BOM will be included in the first object you read. The BOM is
    anachronistic, but at the time of writing, there is no way to stop Windows from
    employing it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Windows 系统上运行此代码时，你会注意到第一行的第一个单词被破坏。这是因为 Windows 总是在任何 UTF-8 文件的开头包含一个 **字节顺序标记**（**BOM**）。所以，当你读取
    Windows 上的文件时，BOM 将包含在你读取的第一个对象中。BOM 是过时的，但在写作的时候，没有方法可以阻止 Windows 使用它。
- en: 'The solution is to call a function that checks the first three bytes of a file
    for the BOM. The BOM for UTF-8 is `EF BB BF`. Here''s a function that searches
    for, and skips, a UTF-8 BOM:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是调用一个函数来检查文件的前三个字节是否为 BOM。UTF-8 的 BOM 是 `EF BB BF`。以下是一个搜索并跳过 UTF-8 BOM
    的函数：
- en: '[PRE128]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This reads the first three bytes of the file and checks them for the UTF-8 BOM
    signature. If any of the three bytes do not match, it resets the input stream
    to the beginning of the file. If the file has no BOM, there's no harm done.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数读取文件的前三个字节并检查它们是否为 UTF-8 BOM 签名。如果三个字节中的任何一个不匹配，它将输入流重置为文件的开头。如果文件没有 BOM，则不会造成任何损害。
- en: 'You simply call this function before you begin reading from a file:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需在开始读取文件之前调用此函数：
- en: '[PRE129]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This will ensure that the BOM is not included in the first string of the file.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 BOM 不会包含在文件的第一行字符串中。
- en: Note
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because the `cin` input stream is not seekable, the `skip_bom()` function will
    not work on the `cin` stream. It will only work with a seekable text file.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `cin` 输入流不可定位，所以 `skip_bom()` 函数在 `cin` 流上不会工作。它只能与可定位的文本文件一起工作。
- en: Customize a string class with char_traits
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 char_traits 自定义字符串类
- en: 'The `string` class is an alias of the `basic_string` class, with the signature:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类是 `basic_string` 类的别名，其签名为：'
- en: '[PRE130]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The first template parameter provides the type of character. The second template
    parameter provides a character traits class, which provides basic character and
    string operations for the specified character type. We normally use the default
    `char_traits<char>` class.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板参数提供了字符类型。第二个模板参数提供了一个字符 traits 类，它为指定的字符类型提供基本的字符和字符串操作。我们通常使用默认的 `char_traits<char>`
    类。
- en: We can modify the behavior of a string by providing our own custom character
    traits class.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供我们自己的自定义字符 traits 类来修改字符串的行为。
- en: How to do it…
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we will create a *character traits class* for use with `basic_string`
    that will ignore casing for comparison purposes:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个用于 `basic_string` 的 *字符 traits 类*，该类在比较时将忽略大小写：
- en: 'First, we''ll need a function to convert characters to a common case. We''ll
    use lowercase here, but it''s an arbitrary choice. Uppercase would work just as
    well:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个函数将字符转换为通用的大小写。这里我们将使用小写，但这是一个任意的选择。大写也可以工作：
- en: '[PRE131]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This function must be `constexpr` (for C++20 and later), so the existing `std::tolower()`
    function won't work here. Fortunately, it's a simple solution to a simple problem.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数必须是 `constexpr`（对于 C++20 及以后的版本），所以现有的 `std::tolower()` 函数在这里不会工作。幸运的是，这是一个简单问题的简单解决方案。
- en: 'Our traits class is called `ci_traits` (*ci* stands for case-independent).
    It inherits from `std::char_traits<char>`:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 traits 类称为 `ci_traits`（*ci* 代表不区分大小写）。它继承自 `std::char_traits<char>`：
- en: '[PRE132]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The inheritance allows us to override only the functions that we need.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许我们仅覆盖我们需要的函数。
- en: 'The comparison functions are called `lt()` for less than and `eq()` for equal
    to:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较函数分别称为 `lt()`（小于）和 `eq()`（等于）：
- en: '[PRE133]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Notice that we compare the *lowercase* versions of characters.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们比较的是字符的小写版本。
- en: 'There''s also a `compare()` function, which compares two C-strings. It returns
    `+1` for greater than, `-1` for less than, and `0` for equal to. We can use the
    spaceship `<=>` operator for this:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个 `compare()` 函数，它比较两个 C-字符串。它返回 `+1` 表示大于，`-1` 表示小于，`0` 表示等于。我们可以使用 spaceship
    `<=>` 运算符来完成这个操作：
- en: '[PRE134]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Finally, we need to implement a `find()` function. This returns a pointer to
    the first instance of a found character, or `nullptr` if not found:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要实现一个 `find()` 函数。它返回找到的第一个字符实例的指针，如果没有找到则返回 `nullptr`：
- en: '[PRE135]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now that we have a `ci_traits` class, we can define an alias for our `string`
    class:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了 `ci_traits` 类，我们可以为我们的 `string` 类定义一个别名：
- en: '[PRE136]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'In our `main()` function, we define a `string` and a `ci_string`:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们定义了一个 `string` 和一个 `ci_string`：
- en: '[PRE137]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We want to print them using `cout`, but this won''t work:'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想使用 `cout` 打印它们，但这不会工作：
- en: '[PRE138]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'First, we need an operator overload for the `operator<<`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为 `operator<<` 重载一个操作符：
- en: '[PRE139]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now, we get this output:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到以下输出：
- en: '[PRE140]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Let''s compare two `ci_string` objects with different cases:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们比较两个不同大小写的 `ci_string` 对象：
- en: '[PRE141]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Output:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE142]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The comparison works as expected.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 比较按预期工作。
- en: 'Using the `find()` function on the `ci_s` object, we search for a lowercase
    `b` and find an uppercase `B`:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ci_s` 对象上使用 `find()` 函数，我们搜索小写的 `b` 并找到一个大写的 `B`：
- en: '[PRE143]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Output:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE144]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the `format()` function doesn't require a specialization. This was
    tested with the `fmt.dev` reference implementation. It did not work with the preview
    release of MSVC's `format()`, even with a specialization. Hopefully, this will
    be fixed in a future release.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`format()` 函数不需要特化。这已经在 `fmt.dev` 参考实现中进行了测试。即使在特化的情况下，它也没有在 MSVC 的预览版 `format()`
    中工作。希望这将在未来的版本中得到修复。
- en: How it works…
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This recipe works by replacing the `std::char_traits` class in the template
    specialization of the `string` class with a `ci_traits` class of our own. The
    `basic_string` class uses the traits class for its fundamental character-specific
    functions, such as comparisons and searching. When we replace it with our own
    class, we can change these fundamental behaviors.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方通过在 `string` 类的模板特化中用我们自己的 `ci_traits` 类替换 `std::char_traits` 类来实现。`basic_string`
    类使用特性类为其基本字符特定功能，如比较和搜索。当我们用我们自己的类替换它时，我们可以改变这些基本行为。
- en: There's more…
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can also override the `assign()` and `copy()` member functions to create
    a class that stores lowercase characters:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重写 `assign()` 和 `copy()` 成员函数来创建一个存储小写字符的类：
- en: '[PRE145]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now, we can create an `lc_string` alias, and the object stores lowercase characters:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 `lc_string` 别名，并且对象存储小写字符：
- en: '[PRE146]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Output:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE147]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These techniques work as expected on GCC and Clang but not on the preview release
    of MSVC. I expect that this will be fixed in a future release.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在 GCC 和 Clang 上按预期工作，但在 MSVC 的预览版上不起作用。我预计这将在未来的版本中得到修复。
- en: Parse strings with Regular Expressions
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串
- en: '*Regular Expressions* (commonly abbreviated as *regex*) are commonly used for
    lexical analysis and pattern-matching on streams of text. They are common in Unix
    text-processing utilities, such as `grep`, `awk`, and `sed`, and are an integral
    part of the *Perl* language. There are a few common variations in the syntax.
    A POSIX standard was approved in 1992, while other common variations include *Perl*
    and *ECMAScript* (JavaScript) dialects. The C++ `regex` library defaults to the
    ECMAScript dialect.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（通常缩写为 *regex*）常用于文本流中的词法分析和模式匹配。它们在 Unix 文本处理工具中很常见，如 `grep`、`awk`
    和 `sed`，并且是 *Perl* 语言的一个组成部分。在语法中存在一些常见的变体。1992 年批准了一个 POSIX 标准，而其他常见的变体包括 *Perl*
    和 *ECMAScript*（JavaScript）方言。C++ 的 `regex` 库默认使用 ECMAScript 方言。'
- en: The `regex` library was first introduced to the STL with C++11\. It can be very
    useful for finding patterns in text files.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex` 库首次在 C++11 中引入到 STL 中。它对于在文本文件中查找模式非常有用。'
- en: To learn more about Regular Expression syntax and usage, I recommend the book,
    *Mastering Regular Expressions* by Jeffrey Friedl.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于正则表达式语法和用法的信息，我推荐阅读 Jeffrey Friedl 的书籍，*Mastering Regular Expressions*。
- en: How to do it…
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, we will extract hyperlinks from an HTML file. A hyperlink
    is coded in HTML like this:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将从 HTML 文件中提取超链接。超链接在 HTML 中的编码如下：
- en: '[PRE148]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We will use a `regex` object to extract both the link and the text, as two separate
    strings.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 `regex` 对象来提取链接和文本，作为两个单独的字符串。
- en: 'Our example file is called `the-end.html`. It''s taken from my website ([https://bw.org/end/](https://bw.org/end/)),
    and is included in the GitHub repository:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例文件名为 `the-end.html`。它来自我的网站 ([https://bw.org/end/](https://bw.org/end/))，并包含在
    GitHub 仓库中：
- en: '[PRE149]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now, we define our `regex` object with a regular expression string:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的 `regex` 对象，并使用正则表达式字符串：
- en: '[PRE150]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Regular expressions can look intimidating at first, but they're actually rather
    simple.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式一开始可能看起来很吓人，但实际上相当简单。
- en: 'This is parsed as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这被解析如下：
- en: Match the whole string.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配整个字符串。
- en: Find the substring `<a href="`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到子串 `<a href="`.
- en: Store everything up to the next `"` as sub-match `1`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将直到下一个 `"` 的所有内容存储为子匹配 `1`。
- en: Skip past the `>` character.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过 `>` 字符。
- en: Store everything up to the string `</a>` as sub-match `2`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将直到字符串 `</a>` 的所有内容存储为子匹配 `2`。
- en: 'Now, we read our file entirely into a string:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们将整个文件读入一个字符串中：
- en: '[PRE151]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This opens the HTML file, reads it line by line, and appends each line to the
    `string` object, `in`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 HTML 文件，逐行读取它，并将每一行追加到 `string` 对象 `in` 中。
- en: 'To extract the link strings, we set up an `sregex_token_iterator` object to
    step through the file and extract each of the matched elements:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提取链接字符串，我们设置一个 `sregex_token_iterator` 对象来遍历文件并提取每个匹配的元素：
- en: '[PRE152]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The `1` and `2` correspond to the sub-matches in the regular expression.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`1` 和 `2` 对应于正则表达式中的子匹配。'
- en: 'We have a corresponding function to step through the results with the iterator:'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个相应的函数来使用迭代器遍历结果：
- en: '[PRE153]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'We call the function with the `regex` iterator:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `regex` 迭代器调用该函数：
- en: '[PRE154]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'And we get this result with our descriptions and links:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用描述和链接得到这个结果：
- en: '[PRE155]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: How it works…
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The STL `regex` engine operates as a *generator* that evaluates and yields one
    result at a time. We set up the iterator using `sregex_iterator` or `sregex_token_iterator`.
    While `sregex_token_iterator` supports sub-matches, `sregex_iterator` does not.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `regex` 引擎作为一个 *生成器* 运行，每次评估并产生一个结果。我们使用 `sregex_iterator` 或 `sregex_token_iterator`
    设置迭代器。虽然 `sregex_token_iterator` 支持子匹配，但 `sregex_iterator` 不支持。
- en: 'The parentheses in our regex serve as *sub-matches*, numbered `1` and `2` respectively:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正则表达式中的括号作为 *子匹配*，分别编号为 `1` 和 `2`：
- en: '[PRE156]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Each part of the `regex` matches is illustrated here:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了 `regex` 匹配的每一部分：
- en: '![Figure 7.1 – A Regular Expression with sub-matches'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 带有子匹配的正则表达式'
- en: '](img/B18267_07_01.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18267_07_01.jpg](img/B18267_07_01.jpg)'
- en: Figure 7.1 – A Regular Expression with sub-matches
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 带有子匹配的正则表达式
- en: 'This allows us to match a string and use parts of that string as our results:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们匹配一个字符串，并使用该字符串的某些部分作为我们的结果：
- en: '[PRE157]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The sub-matches are numbered, beginning with `1`. Sub-match `0` is a special
    value that represents the entire match.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 子匹配是编号的，从 `1` 开始。子匹配 `0` 是一个特殊值，代表整个匹配。
- en: 'Once we have our iterator, we use it as we would any other iterator:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了迭代器，我们就像使用任何其他迭代器一样使用它：
- en: '[PRE158]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This simply steps through our results via the `regex` iterator, giving us the
    formatted output:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地通过 `regex` 迭代器遍历我们的结果，从而给出格式化的输出：
- en: '[PRE159]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
