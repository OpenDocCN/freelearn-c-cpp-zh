- en: Bluetooth Classic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙经典
- en: Bluetooth LE, which we saw in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml),
    *Bluetooth LE*, is an excellent choice when we need two devices to communicate
    wirelessly in short data bursts and where power consumption is a concern. There
    have been changes with Bluetooth LE with versions 4.2 and 5.0\. That make it more
    appealing for devices that need to transfer large amounts of data or even stream
    data. However, there is another Bluetooth technology that has been doing this
    for very successfully for many years, this technology is known as Bluetooth Classic.
    While the name may imply that this technology is out of date, don't let the name
    fool you as Bluetooth Classic is used in many Bluetooth devices, and until there
    are more Bluetooth 5.0 modules available for the Arduino that also support some
    of the newer features, Bluetooth Classic will remain an excellent choice when
    we need to transfer large amounts of data between two devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第20章中看到的蓝牙低功耗（*蓝牙低功耗*）是我们需要两个设备在短数据突发中无线通信且关注功耗时的一个优秀选择。随着蓝牙低功耗的4.2和5.0版本的出现，它发生了变化，这使得它对需要传输大量数据或甚至流式传输数据的设备更具吸引力。然而，还有一种蓝牙技术已经非常成功地做了很多年，这种技术被称为蓝牙经典。虽然名字可能意味着这项技术已经过时，但不要被名字所迷惑，因为蓝牙经典被用于许多蓝牙设备中，并且直到有更多支持一些新功能的Arduino蓝牙5.0模块可用，蓝牙经典在需要两个设备之间传输大量数据时仍将是一个优秀的选择。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: What the version numbers of Bluetooth Classic mean
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙经典版本号的意义
- en: How the Bluetooth radio works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙无线电的工作原理
- en: The network topology of a Bluetooth network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙网络的网络拓扑
- en: How to use the HC-05 Bluetooth module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用HC-05蓝牙模块
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Bluetooth is a wireless technology standard that is used by two devices to transmit
    or receive data over short distances using a 2.4GHz wireless connection. While
    the design goal of Bluetooth LE was to create a low-power wireless protocol, Bluetooth
    Classic had different design goals. Bluetooth Classic was created by engineers
    that work at Ericsson Mobile in Lund, Sweden, as a wireless alternative to serial
    (RS232) cables. This meant that this new protocol would be required to transmit
    large amounts of data, or even stream data, over short distances.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙是一种无线技术标准，两个设备使用2.4GHz无线连接在短距离内传输或接收数据。虽然蓝牙低功耗的设计目标是创建一个低功耗的无线协议，但蓝牙经典有不同的设计目标。蓝牙经典是由瑞典吕德的爱立信移动工程师创建的，作为一种无线替代串行（RS232）电缆。这意味着这个新协议将需要传输大量数据，甚至流式传输数据到短距离。
- en: The Bluetooth Classic specifications are managed by the **Bluetooth Special
    Interest Group** (**Bluetooth SIG**) as part of the Bluetooth core specifications.
    As we mentioned in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth
    LE*, you can find information about both Bluetooth LE and Bluetooth Classic by
    downloading the specifications form from the Bluetooth SIG site at [https://www.bluetooth.com](https://www.bluetooth.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙经典规范由**蓝牙特殊兴趣集团**（**蓝牙SIG**）管理，作为蓝牙核心规范的一部分。正如我们在[第20章](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml)中提到的*蓝牙低功耗*，您可以通过从蓝牙SIG网站[https://www.bluetooth.com](https://www.bluetooth.com)下载规范来找到有关蓝牙低功耗和蓝牙经典的信息。
- en: At first, it may seem strange to cover the newer technology (Bluetooth LE 4.0)
    prior to covering the older technology (Bluetooth Classic). The reason Bluetooth
    LE was covered first is that you will find that it is appropriate to use it in
    the more significant majority of projects that you will be creating with the Arduino,
    as most projects will want to send short bursts of data, which is what Bluetooth
    LE is designed for. Bluetooth LE is also easier to integrate with smartphones
    using Bluetooth LE because every smartphone OS has an easy to use and well documented
    Bluetooth LE API, which is not the case for Bluetooth Classic. For the cases where
    you will want to stream data or share large amounts of data between two custom
    devices, Bluetooth Classic may be more appropriate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，在介绍较新的技术（蓝牙低功耗4.0）之前介绍较旧的技术（蓝牙经典）可能看起来有些奇怪。蓝牙低功耗首先被介绍的原因是您会发现它在您将使用Arduino创建的绝大多数项目中都是合适的，因为大多数项目都希望发送短数据突发，这正是蓝牙低功耗的设计目的。蓝牙低功耗也更容易与使用蓝牙低功耗的智能手机集成，因为每个智能手机操作系统都有一个易于使用且文档齐全的蓝牙低功耗API，而蓝牙经典则不是这样。对于您想要在两个自定义设备之间流式传输数据或共享大量数据的情况，蓝牙经典可能更合适。
- en: 'When purchasing a Bluetooth Classic module for your project, you will have
    a choice of three different Bluetooth versions. These versions are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为项目购买蓝牙经典模块时，你将可以选择三种不同的蓝牙版本。这些版本是：
- en: '**Bluetooth 2.0 + EDR**: The core specifications for this version were released
    in 2004\. This update to the Bluetooth core specifications contained a number
    of minor improvements to the Bluetooth standard. The only significant improvement
    was **EDR** (**Enhanced Data Rate**), which increased the data transfer rate to
    3Mbits/sec from 1Mbits/sec. The name of the standard reads Bluetooth 2.0 + EDR,
    which means that the EDR feature is optional. The HC-05 Bluetooth module that
    we will be using for this chapter is Bluetooth 2.0, compatible which means it
    does not include the EDR feature. For the vast majority of projects that you will
    build with the Arduino, Bluetooth 2.0-compatible modules will be fine and are
    actually preferable since we are able to avoid the secure pairing feature that
    was introduced with Bluetooth 2.1\. While the new pairing feature may be called
    Simple Secure Pairing, it usually requires human interaction for the pairing process,
    which we may want to avoid since a lot of Arduino projects do not have the input
    capabilities to do this.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙 2.0 + EDR**：该版本的核心理念于 2004 年发布。这次对蓝牙核心规格的更新包含了对蓝牙标准的多项小改进。唯一的重大改进是 **EDR**（**增强数据速率**），将数据传输速率从
    1Mbits/sec 提高到 3Mbits/sec。该标准的名称为蓝牙 2.0 + EDR，这意味着 EDR 功能是可选的。我们将在本章中使用 HC-05
    蓝牙模块，它是蓝牙 2.0 兼容的，这意味着它不包括 EDR 功能。对于你将用 Arduino 构建的绝大多数项目，蓝牙 2.0 兼容的模块将足够好，实际上更可取，因为我们能够避免蓝牙
    2.1 中引入的安全配对功能。虽然新的配对功能可能被称为简单安全配对，但它通常需要人工交互来完成配对过程，而我们可能希望避免这种情况，因为许多 Arduino
    项目没有进行这种输入的能力。'
- en: '**Bluetooth 2.1 + EDR**: The core specifications for this version was released
    in 2007\. This version of the Bluetooth core specifications also offered a number
    of improvements on the previous version, with the featured improvement being the
    introduction of **SSP** (**Simple Secure Pairing**). SSP overhauled the pairing
    process, making it both simple and more secure.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙 2.1 + EDR**：该版本的核心理念于 2007 年发布。蓝牙核心规格的这次版本也对其前一个版本进行了多项改进，其中特色改进是引入了 **SSP**（**简单安全配对**）。SSP
    对配对过程进行了彻底的改革，使其既简单又更安全。'
- en: '**Bluetooth 3.0 + HS**: The core specifications for this version were released
    in 2009\. The HS in the specification name stands for High Speed. Bluetooth 3.0
    + HS can have a theoretical data transfer speed of 24 Mbits/sec, however the data
    is not transmitted over a Bluetooth connection. When in high-speed mode the data
    is actually transmitted over an 801.11 (Wi-Fi) connection. The Bluetooth link
    is only used to negotiate and establish the Wi-Fi connection. As with the Bluetooth
    2.X + EDR specification, the HS feature is optional, and you will see devices
    that only meet the Bluetooth 3.0 standard.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙 3.0 + HS**：该版本的核心理念于 2009 年发布。规格名称中的 HS 代表高速。蓝牙 3.0 + HS 的理论数据传输速度可达 24
    Mbits/sec，然而数据不是通过蓝牙连接传输的。在高速模式下，数据实际上是通过 801.11（Wi-Fi）连接传输的。蓝牙链路仅用于协商和建立 Wi-Fi
    连接。与蓝牙 2.X + EDR 规范一样，HS 功能是可选的，你将看到仅符合蓝牙 3.0 标准的设备。'
- en: As with Bluetooth LE, to really understand when to use Bluetooth Classic we
    need to understand the technology itself, so let's dive into in a bit more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与蓝牙 LE 一样，要真正理解何时使用蓝牙经典，我们需要了解这项技术本身，所以让我们更深入地探讨一下。
- en: Bluetooth radio
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙无线电
- en: 'The range of a Bluetooth radio is dependent on the class. The following chart
    shows the range of a Bluetooth radio by the class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙无线电的传输范围取决于类别。以下图表显示了不同类别蓝牙无线电的传输范围：
- en: '| **Class** | **Power (mW)** | **Power (dBm)** | **Range in meters** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **功率（毫瓦）** | **功率（dBm）** | **范围（米）** |'
- en: '| 1 | 100 | 20 | ~100 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 100 | 20 | ~100 |'
- en: '| 2 | 2.5 | 4 | ~10 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2.5 | 4 | ~10 |'
- en: '| 3 | 1 | 0 | ~1 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 0 | ~1 |'
- en: As with any radio technology the area surrounding the radio has a substantial
    effect on the range of the radio. The range listed in the previous chart is the
    theoretical maximum range with ideal conditions. The typical range is usually
    less than this theoretical maximum range.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何无线电技术一样，无线电周围的环境对无线电的传输范围有重大影响。前一个图表中列出的范围是在理想条件下的理论最大范围。典型的范围通常小于这个理论最大范围。
- en: Where the Bluetooth LE radio operates from 2,402 MHz to 2,480 MHz with each
    channel being 2 MHz apart, the Bluetooth Classic radio uses 79 channels from 2,402
    MHz to 2,480 MHz with each channel being 1 MHz apart. As with Bluetooth LE, the
    Bluetooth Classic radio uses frequency hopping, where the radio changes channels
    1,600 times a second, to reduce interference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝牙 LE 无线电从 2,402 MHz 到 2,480 MHz 运行，每个信道间隔 2 MHz 的情况下，蓝牙经典无线电使用从 2,402 MHz
    到 2,480 MHz 的 79 个信道，每个信道间隔 1 MHz。与蓝牙 LE 类似，蓝牙经典无线电使用跳频，无线电每秒改变信道 1,600 次，以减少干扰。
- en: With Bluetooth LE, the radio continuously turns itself off to reduce power,
    Bluetooth Classic does not do this. This makes the Bluetooth LE radio technology
    better at short bursts of data with low power while the Bluetooth Classic radio
    is better at transmitting large amounts of data or data streaming because the
    radio is continuously on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝牙 LE 中，无线电持续关闭自身以减少功耗，蓝牙经典不这样做。这使得蓝牙 LE 无线电技术在低功耗的短数据突发方面表现更好，而蓝牙经典无线电在传输大量数据或数据流方面表现更好，因为无线电是持续开启的。
- en: All Bluetooth devices have a unique 48-bit address that is assigned to the Bluetooth
    radio by the manufacturer. The upper half of the address (the most significant
    24 bits) is known as the **Organizationally Unique Identifier** and consists of
    two parts. These parts are the **Non-Significant Address** (**NAP**) and the **Upper
    Address Part** (**UAP**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有蓝牙设备都有一个独特的 48 位地址，由制造商分配给蓝牙无线电。地址的上半部分（最重要的 24 位）被称为**组织唯一标识符**，由两部分组成。这些部分是**非重要地址**（**NAP**）和**高地址部分**（**UAP**）。
- en: The NAP is the first 16 bits of the address and is used in frequency hopping
    synchronization. The UAP is the next 8 bits and is assigned to the radio manufacturer
    by the IEEE organization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: NAP 是地址的前 16 位，用于跳频同步。UAP 是接下来的 8 位，由 IEEE 组织分配给无线电制造商。
- en: 'The last 24-bits of the address is known as the **Lower Address Part** (**LAP**).
    The LAP is assigned by the manufacturer to identify the radio uniquely. The following
    diagram shows how the Bluetooth address is made up:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的最后 24 位被称为**低地址部分**（**LAP**）。LAP 由制造商分配，以唯一标识无线电。以下图表显示了蓝牙地址的构成：
- en: '![](img/4aeb2940-c65e-438e-8855-71499af8f2d7.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4aeb2940-c65e-438e-8855-71499af8f2d7.png)'
- en: Now let's look that the network topology for Bluetooth Classic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看蓝牙经典的网络拓扑。
- en: Network topology
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络拓扑
- en: 'The topology of a Bluetooth Classic piconet is very similar to the topology
    of a Bluetooth LE network where one device acts as a master and the other devices
    act as slaves to the master. In a Bluetooth Classic piconet, one master can have
    up to seven slaves for a total of eight devices in the piconet. The following
    diagram shows a Bluetooth classic piconet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙经典 piconet 的拓扑结构与蓝牙 LE 网络的拓扑结构非常相似，其中一个设备充当主设备，其他设备充当主设备的从设备。在蓝牙经典 piconet
    中，一个主设备可以有最多七个从设备，总共八个设备在 piconet 中。以下图表显示了蓝牙经典 piconet：
- en: '![](img/b9fe22df-97db-48f3-a094-143fa3824def.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9fe22df-97db-48f3-a094-143fa3824def.png)'
- en: Piconets can interact with other piconets to form what is known as scatternets.
    A scatternet is one where the master of one piconet acts as a slave in another
    piconet. This does allow devices in one piconet to share data with devices in
    other piconets; however, this does require complex synchronization and bandwidth
    sharing, making these networks more complex and less efficient. It is good to
    know that we can create scatternets, but it is something that, in my experience,
    is rarely used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Piconets 可以与其他 piconets 交互，形成所谓的散射网。在散射网中，一个 piconet 的主设备在另一个 piconet 中充当从设备。这确实允许一个
    piconet 中的设备与其他 piconet 中的设备共享数据；然而，这需要复杂的同步和带宽共享，使得这些网络更加复杂且效率较低。了解我们可以创建散射网是好的，但根据我的经验，这很少被使用。
- en: There is a lot more to Bluetooth than what is described here; however, for the
    vast majority of use cases you will want to use Bluetooth LE as described in [Chapter
    20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth LE*. With the Arduino,
    we would use Bluetooth Classic when we want to connect two devices and stream
    data between them. Let's look at how we would do this with three projects. For
    the first project we will configure the Bluetooth modules, the second project
    we will learn how to send and receive data from the Bluetooth module, and in the
    third project, we will see how we can stream data from one radio to another. We
    will start off by looking at the components that we will need for these projects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙的内容远不止这里所描述的；然而，对于绝大多数用例，您将希望使用第20章中描述的蓝牙低功耗（Bluetooth LE）。使用Arduino时，当我们想要连接两个设备并在它们之间传输数据时，我们会使用蓝牙经典。让我们看看我们如何通过三个项目来实现这一点。对于第一个项目，我们将配置蓝牙模块；在第二个项目中，我们将学习如何从蓝牙模块发送和接收数据；在第三个项目中，我们将看到如何从一个无线电流式传输数据到另一个无线电。我们将从查看这些项目所需的组件开始。
- en: Components needed
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要的组件
- en: 'For these projects you will need the following items:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些项目，您需要以下物品：
- en: Two Arduino Uno or compatible boards
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Arduino Uno或兼容板
- en: Two HC-05 Bluetooth modules
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个HC-05蓝牙模块
- en: One Joystick breakout module for the Arduino
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于Arduino的摇杆扩展模块
- en: Jumper wires
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: Breadboard
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: Now let's look at the circuit diagram for our project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们项目的电路图。
- en: Circuit diagrams
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路图
- en: 'In this chapter, we will be writing code for three projects. In the first project
    we will be configuring the Bluetooth modules, in the second project we will create
    an application that will send data, in byte format, from one Bluetooth radio to
    another and in the last project we will attach a joystick to one of the Arduinos
    and stream the joystick position to the other Arduino through the Bluetooth connection.
    The following shows the circuit diagram for our projects:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为三个项目编写代码。在第一个项目中，我们将配置蓝牙模块；在第二个项目中，我们将创建一个应用程序，该应用程序将以字节格式从一台蓝牙无线电发送数据到另一台；在最后一个项目中，我们将把一个摇杆连接到一个Arduino上，并通过蓝牙连接将摇杆位置流式传输到另一个Arduino。以下是我们项目的电路图：
- en: '![](img/b5ecaaaf-a9c5-44e3-8b5d-b8f4c7a51393.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5ecaaaf-a9c5-44e3-8b5d-b8f4c7a51393.png)'
- en: The two Arduino circuits are completely isolated from each other, therefore
    they do not need a common ground. Both HC-06 Bluetooth modules are connected to
    the Arduino in the same way where the VCC pin on the HC-06 Bluetooth module is
    connected to 5V out, and the GND pin is connected to the ground out on the Arduino.
    The key pin on the Bluetooth module is connected to the digital 9 pin on the Arduino,
    the RX pin is connected to the digital 10 pin, and the TX pin is connected to
    the digital 11 pin.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个Arduino电路彼此完全隔离，因此它们不需要公共地线。两个HC-06蓝牙模块以相同的方式连接到Arduino，其中HC-06蓝牙模块的VCC引脚连接到5V输出，GND引脚连接到Arduino的地线输出。蓝牙模块的关键引脚连接到Arduino的数字9引脚，RX引脚连接到数字10引脚，TX引脚连接到数字11引脚。
- en: We will want to connect a joystick breakout module to one of the Arduinos. To
    do this, we will want to connect the VCC pin on the breakout board to the 5V out
    on the Arduino and the GND pin to the ground out on the Arduino. We will connect
    the SEK or SW pin, depending on your joystick module, to the digital 2 pin on
    the Arduino. Finally, we will connect the HOR or *x *axis pin on the breakout
    board to the Analog 0 pin on the Arduino and the VER or *y *axis pin to the Analog
    1 pin.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将一个摇杆扩展模块连接到其中一个Arduino上。为此，我们需要将扩展板上的VCC引脚连接到Arduino的5V输出，并将GND引脚连接到Arduino的地线输出。我们将根据您的摇杆模块连接SEK或SW引脚到Arduino的数字2引脚。最后，我们将扩展板上的HOR或*x*轴引脚连接到Arduino的模拟0引脚，并将VER或*y*轴引脚连接到模拟1引脚。
- en: Now let's look start with our projects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的项目。
- en: Project 1 – configuring the Bluetooth modules
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目1 – 配置蓝牙模块
- en: To communicate with the HC-05 Bluetooth module, we will use the same `SoftwareSerial`
    library that we used in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml),
    *Bluetooth LE*. The code that is used to communicate is very similar between the
    HM-10 (Bluetooth LE) and the HC-05 (Bluetooth Classic). How the two radios transmit
    and receive the data is a lot different, therefore understanding how the radios
    work and what they should be used for will define when to use the different technologies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要与HC-05蓝牙模块通信，我们将使用与[第20章](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml)中相同的 `SoftwareSerial`
    库，即 *蓝牙低功耗*。用于通信的代码在HM-10（蓝牙低功耗）和HC-05（蓝牙经典）之间非常相似。这两款无线电如何传输和接收数据有很大不同，因此理解无线电的工作原理以及它们应该用于什么将决定何时使用不同的技术。
- en: 'For this first project, we will be writing an application that will allow us
    to configure the Bluetooth modules. This code will start off exactly as we did
    with the Bluetooth LE code by including the `SoftwareSerial` library and creating
    an instance of the `SoftwareSerial` type. The following code shows how to do this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个项目，我们将编写一个应用程序，允许我们配置蓝牙模块。此代码将与我们之前使用的蓝牙低功耗代码完全一样，通过包含 `SoftwareSerial`
    库并创建 `SoftwareSerial` 类型的实例。以下代码展示了如何做到这一点：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line includes the `SoftwareSerial` library and the second line creates
    an instance of the type. The Boolean variable in the last line will be used to
    tell the application when to add a new line in the serial console.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含了 `SoftwareSerial` 库，第二行创建了这个类型的实例。最后一行的布尔变量将用于告诉应用程序何时在串行控制台中添加新行。
- en: 'Now we need to add code to the `setup()` function that will configure the serial
    console and the `SoftwareSerial` instance. The following code shows the `setup()`
    function for this first project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在 `setup()` 函数中添加代码来配置串行控制台和 `SoftwareSerial` 实例。以下代码展示了这个第一个项目的 `setup()`
    函数：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code starts off by setting up the serial console with a baud rate of `9600`
    and then define that the digital 9 pin will be an output pin and set it to high.
    The digital 9 pin is connected to the key pin on the HC-05\. We pull this pin
    high to enable the Bluetooth module. We then configure the `HC05` instance of
    the `SoftwareSerial` type with a baud rate of `38400` and print a message to the
    serial console letting the user know that everything is configured and ready to
    go.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先使用波特率 `9600` 设置串行控制台，然后定义数字9脚将是一个输出脚并将其设置为高电平。数字9脚连接到HC-05的按键引脚。我们将此引脚拉高以启用蓝牙模块。然后我们使用波特率
    `38400` 配置 `HC05` 类型的 `SoftwareSerial` 实例，并向串行控制台打印一条消息，告知用户一切已配置并准备就绪。
- en: You will note, in this first project we set the baud rate of the `SoftwareSerial`
    instance to `38400` because we are configuring the Bluetooth module. In the next
    two projects, we set the baud rate to `9600` because we will be sending and receiving
    data to/from the Bluetooth module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在这个第一个项目中，我们将 `SoftwareSerial` 实例的波特率设置为 `38400`，因为我们正在配置蓝牙模块。在接下来的两个项目中，我们将波特率设置为
    `9600`，因为我们将在蓝牙模块之间发送和接收数据。
- en: 'In the `loop()` function, just like in the Bluetooth LE code, we will take
    any input from the Bluetooth module and print it to the serial console and any
    input from the serial console we will send out through the Bluetooth module. The
    following code will do this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，就像在蓝牙低功耗（BLE）代码中一样，我们将从蓝牙模块接收任何输入并将其打印到串行控制台，同时任何来自串行控制台的输入将通过蓝牙模块发送出去。以下代码将执行此操作：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this function, the first thing we do is to see if there is any data available
    from the `HC05` `SoftwareSerial` instance (the Bluetooth module) by using the
    `available()` function. If there is data available we check to see if we need
    to add a new line to the serial console by checking the `addNewLine` Boolean variable.
    If we need to add a new line, we write a carriage return and line feed to the
    serial console and then set the `addNewLine` Boolean variable to `false`. We then
    write the data that was received from the Bluetooth module to the serial console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先使用 `available()` 函数检查是否有来自 `HC05` `SoftwareSerial` 实例（蓝牙模块）的数据可用。如果有数据可用，我们会检查是否需要向串行控制台添加新行，通过检查
    `addNewLine` 布尔变量。如果需要添加新行，我们将回车和换行符写入串行控制台，并将 `addNewLine` 布尔变量设置为 `false`。然后我们将从蓝牙模块接收到的数据写入串行控制台。
- en: Next, we check to see if there is any data available from the serial console,
    also using the `available()` function and if so we write that data to the Bluetooth
    module which is then transmitted to the connected device. We also set the `addNewLine`
    Boolean variable to true, so that the next time data is received from the connected
    device, we will add a carriage return and line feed to the serial console.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查串行控制台是否有任何可用数据，也使用`available()`函数，如果有，我们将该数据写入蓝牙模块，然后将其传输到连接的设备。我们还设置`addNewLine`布尔变量为true，这样下次从连接的设备接收数据时，我们将在串行控制台添加回车符和换行符。
- en: Before we plug the Arduino and run this code, we will need to set the HC-05
    Bluetooth module into configuration mode. To do this, we will need to press and
    hold down the button on the Bluetooth module and then plug the Arduino into the
    computer giving power to the Bluetooth module. In just a couple of seconds, the
    light on the Bluetooth module will start to blink very slowly; the light will
    be on for two seconds and then turn off for two seconds. Once the light starts
    to blink, we can release the button, and the Bluetooth module is ready to be configured.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Arduino插入并运行此代码之前，我们需要将HC-05蓝牙模块设置为配置模式。为此，我们需要按住蓝牙模块上的按钮，然后将Arduino插入电脑，为蓝牙模块供电。只需几秒钟，蓝牙模块上的灯就会开始非常缓慢地闪烁；灯亮两秒钟，然后熄灭两秒钟。一旦灯开始闪烁，我们可以松开按钮，蓝牙模块就准备好配置了。
- en: 'To configure the Bluetooth module, we issue AT commands similar to how we did
    it with the Bluetooth LE module. To send an AT command, you would use the following
    format:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置蓝牙模块，我们将发出与蓝牙低功耗模块类似的AT命令。要发送AT命令，您将使用以下格式：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To set an item, you type in the letters AT followed by the plus sign, the command
    and the new setting without any spaces. For example, to set the role of the Bluetooth
    module to a salve role we would issue the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个项目，您输入字母AT，然后是加号，命令和新的设置，中间没有空格。例如，要将蓝牙模块的角色设置为从属角色，我们将发出以下命令：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Note**: AT commands are case insensitive.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：AT命令不区分大小写。'
- en: 'To query the item, we would type in the letters `at` followed by the plus sign,
    the command and then a question mark. For example, to query the role of the Bluetooth
    module, we would use the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询项目，我们将输入字母`at`，然后是加号，命令，然后是问号。例如，要查询蓝牙模块的角色，我们将使用以下命令：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To issue the command, we type the command into the input box on the serial
    console and press *Enter*. We will need to set the serial console to add both
    an NL (new line) and a CR (carriage return). The following screenshot shows how
    to issue an AT command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出命令，我们将在串行控制台上的输入框中输入命令，然后按*Enter*键。我们需要将串行控制台设置为添加NL（换行符）和CR（回车符）。以下截图显示了如何发出AT命令：
- en: '![](img/2e21481a-3e96-407a-b53d-df53fac17ba4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e21481a-3e96-407a-b53d-df53fac17ba4.png)'
- en: 'After we type in the `at+role?` command, we press the *Enter* key or the Send
    button to send the command to the Bluetooth module. The Bluetooth module will
    respond with the results of the query, as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入`at+role?`命令后，我们按*Enter*键或发送按钮来将命令发送到蓝牙模块。蓝牙模块将响应查询结果，如下面的截图所示：
- en: '![](img/71003801-57d4-45e0-92a5-8b9fc754b50f.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71003801-57d4-45e0-92a5-8b9fc754b50f.png)'
- en: Before we configure the modules, let's look at some of the commands that we
    can issue to the HC-05 Bluetooth module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置模块之前，让我们看看我们可以向HC-05蓝牙模块发出的某些命令。
- en: Test command
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT` | `OK` | None | This is a test command that can be used to test theconnection
    to the Bluetooth module. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `AT` | `OK` | 无 | 这是一个测试命令，可以用来测试与蓝牙模块的连接。|'
- en: Reset command
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置命令
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+RESET` | `OK` | None | This command will reset the Bluetooth module.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `AT+RESET` | `OK` | 无 | 此命令将重置蓝牙模块。|'
- en: Query firmware
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询固件
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+VERSION?` | `+VERSION:<Param>` | None | Returns the version of the firmware
    on theHC-05 Bluetooth module. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `AT+VERSION?` | `+VERSION:<Param>` | 无 | 返回HC-05蓝牙模块上的固件版本。|'
- en: Restore defaults
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复出厂设置
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ORGL` | `OK` | None | Restores the HC-05 Bluetooth module to thedefault
    settings. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ORGL` | `OK` | 无 | 将 HC-05 蓝牙模块恢复到默认设置。|'
- en: Query module address
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询模块地址
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADDR?` | `+ADDR:<Param>` | None | Returns the address of the HC-05 Bluetoothmodule.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADDR?` | `+ADDR:<Param>` | 无 | 返回 HC-05 蓝牙模块的地址。|'
- en: Set/Query module mode
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置/查询模块模式
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ROLE?` | `+ROLE:<Param>` | `0` Slave`1` Master | Queries the role of
    the HC-05 Bluetooth module. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE?` | `+ROLE:<Param>` | `0` 从机`1` 主机 | 查询 HC-05 蓝牙模块的角色。|'
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ROLE=<Param>` | `OK` | `0` Slave`1` Master | Sets the role of the HC-05
    Bluetooth module. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE=<Param>` | `OK` | `0` 从机`1` 主机 | 设置 HC-05 蓝牙模块的角色。|'
- en: Set/Query UART parameters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置/查询 UART 参数
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+UART?` | `+UART:<Param1>, <Param2>, <Param3>` | `Param1` = Baud Rate`Param2`
    = Stop Bit`Param3` = Parity | Queries the UARTparameters. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UART?` | `+UART:<Param1>, <Param2>, <Param3>` | `Param1` = 波特率`Param2`
    = 停止位`Param3` = 奇偶校验 | 查询 UART 参数。|'
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+UART=<Param1>, <Param2>, <Param3>` | `OK` | `Param1` = Baud Rate`Param2`
    = Stop Bit`Param3` = Parity | Sets the UARTparameters. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UART=<Param1>, <Param2>, <Param3>` | `OK` | `Param1` = 波特率`Param2` =
    停止位`Param3` = 奇偶校验 | 设置 UART 参数。|'
- en: Set/Query connection mode
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置/查询连接模式
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CMODE?` | `+UART:<Param>` | `0` Connect to Fixed Address`1` Connect to
    any address`2` Slave-loop | Queries the connection mode ofthe HC-05 Bluetooth
    module. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CMODE?` | `+UART:<Param>` | `0` 连接到固定地址`1` 连接到任何地址`2` 从机环回 | 查询 HC-05
    蓝牙模块的连接模式。|'
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CMODE=<Param>` | `OK` | `0` Connect to Fixed Address`1` Connect to any
    address`2` Slave-loop | Sets the connection mode forthe HC-05 Bluetooth module.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CMODE=<Param>` | `OK` | `0` 连接到固定地址`1` 连接到任何地址`2` 从机环回 | 设置 HC-05 蓝牙模块的连接模式。|'
- en: Set/Query bind address
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置/查询绑定地址
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+BIND?` | `+BIND:<Param>` | None | Queries the address that the module
    is configuredto bind to. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `AT+BIND?` | `+BIND:<Param>` | 无 | 查询模块配置的绑定地址。|'
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+BIND=<Param>` | `OK` | Fixed address | Sets the address to bind to. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `AT+BIND=<Param>` | `OK` | 固定地址 | 设置要绑定的地址。|'
- en: Now that we have seen most of the AT commands let's configure the two Bluetooth
    modules. We are going to need to configure one of the Bluetooth modules as the
    master and the other one as a slave. For the purposes of the next two projects,
    I configured the Bluetooth module that is connected to the same Arduino as the
    joystick as the slave. This, however, is not necessary and either module can be
    the master or slave.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了大多数 AT 命令，让我们配置两个蓝牙模块。我们需要将一个蓝牙模块配置为主机，另一个配置为从机。为了下一两个项目的目的，我将连接到摇杆的同一
    Arduino 的蓝牙模块配置为从机。然而，这并非必要，任何模块都可以是主机或从机。
- en: Let's start off by configuring the slave device. To do this connect one of the
    Arduinos to the computer, run the application that we wrote at the beginning of
    this section and then run through the command that we will outline in the next
    few paragraphs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从配置从设备开始。为此，将一个 Arduino 连接到计算机，运行本节开头编写的应用程序，然后运行下一几段中将要概述的命令。
- en: The first thing we will want to do is to issue the test `AT` command to the
    Bluetooth module. The module should respond back with an `OK` message. If you
    do not get a response back, check to make sure that the serial console is configured
    to send both the NL and CR. If you receive an error response, try issuing the
    `AT` command again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是向蓝牙模块发送测试 `AT` 命令。模块应该返回一个 `OK` 消息。如果你没有收到任何响应，请检查串行控制台是否已配置为发送 NL
    和 CR。如果你收到错误响应，请再次尝试发送 `AT` 命令。
- en: 'Now that we are sure that the serial monitor and the Bluetooth module are talking,
    we will want to see what the UART settings are currently set to for this module.
    To do this send the `AT+UART?` command. For the examples in this chapter, we are
    going to assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity.
    If this is not how your module is configured then issue the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信串行监视器和蓝牙模块正在通信，我们想要查看此模块当前的UART设置。为此，发送`AT+UART?`命令。在本章的示例中，我们将假设UART设置为9600波特率，0停止位，0奇偶校验。如果您的模块不是这样配置的，请发出以下命令：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next thing we want to do is to set the role of the device to a slave role.
    To do this, we issue the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要做的是将设备的角色设置为从角色。为此，我们发出以下命令：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we will want to retrieve the address of this Bluetooth module. The
    following command will retrieve the address:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要检索这个蓝牙模块的地址。以下命令将检索地址：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure the address is written down because we will be using it when we configure
    the master device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保记下地址，因为我们将在配置主设备时使用它。
- en: 'The commands that we ran to configure the slave module are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行以配置从模块的命令如下：
- en: '| **Command** | **Response** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** |'
- en: '| `AT` | `OK` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `AT` | `OK` |'
- en: '| `AT+UART?` | `+UART:9600,0,0` (if not, set it to this) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UART?` | `+UART:9600,0,0`（如果不是，设置为这个值）|'
- en: '| `AT+ROLE=0` | `OK` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE=0` | `OK` |'
- en: '| `AT+ADDR?` | `+ADDR:{address}` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADDR?` | `+ADDR:{address}` |'
- en: Now let's configure the master. To do this, connect the other Arduino to the
    computer (remember to press and hold the button as you power up the module), run
    the code we wrote at the beginning of this section and issue the commands that
    we will go through in the next few paragraphs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们配置主设备。为此，将另一个Arduino连接到计算机（记住在给模块供电时按住按钮），运行本节开头编写的代码，并发出下几段中将要讨论的命令。
- en: As with the slave device, the first thing we will want to do is to issue the
    `AT` command to the Bluetooth module. The module should respond back with an `OK`
    message. If you do not get a response back, check to make sure that the serial
    console is configured to send both the NL and CR. If you receive an error response,
    try issuing the `AT` command again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从设备一样，我们首先想要做的是向蓝牙模块发出`AT`命令。模块应该返回一个`OK`消息。如果你没有收到任何响应，请检查确保串行控制台已配置为发送NL和CR。如果你收到错误响应，请再次发出`AT`命令。
- en: 'Now we will want to see what the UART settings are for the module. To do this
    send the `AT+UART?` command. For the examples in this chapter, we are going to
    assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity. If this
    is not how your module is configured then issue the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要查看模块的UART设置。为此，发送`AT+UART?`命令。在本章的示例中，我们将假设UART设置为9600波特率，0停止位，0奇偶校验。如果您的模块不是这样配置的，请发出以下命令：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next thing we want to do is to set the role of the device to a master role.
    To do this, we issue the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要做的是将设备的角色设置为主角色。为此，我们发出以下命令：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we will want to set the connection mode to connect to a fixed address (mode
    0). To do this issue the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将想要将连接模式设置为连接到固定地址（模式0）。为此，发出以下命令：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we are telling the Bluetooth module to connect to a fixed address, we
    need to give it the address of the slave device we need it to connect to.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要告诉蓝牙模块连接到一个固定的地址，因此我们需要提供它需要连接的从设备地址。
- en: 'To do this, issue the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，发出以下命令：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The question marks are the address of the slave device. When we queried the
    address of the slave device the address was returned separated with colons like
    this, `98d3:31:300e42`. When entering the address in the `BIND` command, the address
    needs to be separated by commas like this `98d3,31,300e42`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 问号是从设备的地址。当我们查询从设备的地址时，地址以冒号分隔返回，例如`98d3:31:300e42`。在`BIND`命令中输入地址时，地址需要以逗号分隔，例如`98d3,31,300e42`。
- en: 'The commands that we used to configure the master device are:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来配置主设备的命令如下：
- en: '| **Command** | **Response** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** |'
- en: '| `AT` | `OK` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `AT` | `OK` |'
- en: '| `AT+UART?` | `+UART:9600,0,0` (if not, set it to this) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UART?` | `+UART:9600,0,0`（如果不是，设置为这个值）|'
- en: '| `AT+ROLE=1` | `OK` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE=1` | `OK` |'
- en: '| `AT+CMODE=0` | `OK` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CMODE=0` | `OK` |'
- en: '| `AT+BIND=????,??,??????` (question marks are the address of the slave device)
    | `OK` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `AT+BIND=????,??,??????`（问号是从设备的地址）| `OK` |'
- en: Now if we reset both devices by recycling the power, the two Bluetooth modules
    should connect. Start off by recycling the power on the slave device, and you
    will see the LED blinking rapidly. Then recycle the power on the master and once
    the two devices connect the LED on both devices will blink rapidly twice, then
    turn off for two seconds and then repeat. This light sequence indicates that the
    two devices are connected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们通过重新供电来重置两个设备，两个蓝牙模块应该会连接。首先，在从设备上重新供电，你会看到LED快速闪烁。然后，在主设备上重新供电，一旦两个设备连接，两个设备上的LED都会快速闪烁两次，然后关闭两秒钟，然后重复。这个灯光序列表明两个设备已经连接。
- en: If the devices do not connect, the most common mistake that is made is to type
    in the wrong address in the `AT+BIND` command. I would start off by checking that
    by running the `AT+BIND?` command and verifying the address is correct. If that
    is correct, then verify the `AT+CMODE`, and `AT+ROLE` commands ran properly by
    running the `AT+CMODE?` and `AT+ROLE?` commands. Now that we have the two Bluetooth
    modules connected let's go on to project two.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备没有连接，最常见的一个错误就是在`AT+BIND`命令中输入了错误的地址。我会首先通过运行`AT+BIND?`命令来检查，并验证地址是否正确。如果地址正确，那么通过运行`AT+CMODE?`和`AT+ROLE?`命令来验证`AT+CMODE`和`AT+ROLE`命令是否正确执行。现在我们已经将两个蓝牙模块连接起来，让我们继续进行项目二。
- en: Project 2 – serial connection, sending data
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目2 – 串行连接，发送数据
- en: For this project, in order to see the data going from one device to the other,
    you will need two computers. One connected to the master device and one connected
    to the slave device. If you do not have two computers, it is still worth reading
    through this section to understand the protocol that we are creating because we
    will be using the same protocol for the third project as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，为了看到数据从一个设备传输到另一个设备，你需要两台计算机。一台连接到主设备，另一台连接到从设备。如果你没有两台计算机，仍然值得阅读这一部分，以了解我们正在创建的协议，因为我们将在第三个项目中使用相同的协议。
- en: When we are streaming data or sending large amounts of variable length data,
    we need some way to tell the receiving device where a new message starts and where
    it ends. Luckily for us, there are built-in ASCII codes that allow for this. The
    `0x01` **SOH** (**Start Of Heading**) and the `0x04` **EOT** (**End Of Transmission**)
    codes can be used to tell the receiving device when a message starts and when
    it ends.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在传输数据或发送大量可变长度的数据时，我们需要一种方式来告诉接收设备新消息的开始和结束位置。幸运的是，我们有内置的ASCII代码可以实现这一点。`0x01`
    **SOH**（**标题开始**）和`0x04` **EOT**（**传输结束**）代码可以用来告诉接收设备消息的开始和结束。
- en: In this project and the next one, the protocol that we will define is when the
    receiving device receives a `0x01` ASCII character, it will know that a new message
    has started. When it receives a `0x04` ASCII character, it will know that the
    message has ended and everything between the `0x01` and the `0x04` characters
    are the message itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目和下一个项目中，我们将定义的协议是：当接收设备接收到`0x01` ASCII字符时，它会知道一个新的消息已经开始。当它接收到`0x04` ASCII字符时，它会知道消息已经结束，并且`0x01`和`0x04`字符之间的所有内容都是消息本身。
- en: 'If you are not familiar with ASCII codes, the following chart shows the ASCII
    chart:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉ASCII代码，以下图表显示了ASCII表：
- en: '![](img/b021a1bb-fa89-4560-947b-5e88de99afef.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b021a1bb-fa89-4560-947b-5e88de99afef.png)'
- en: Basically, when we transmit character data between two Bluetooth Classic devices,
    we are actually sending the ASCII codes. For example, if we send the word "Dog,"
    we are actually sending three bytes of data, which are `0x44` (D), `0x111` (o),
    and `0x67` (g). With the protocol that we are defining, if we send the word Dog,
    we would send five bytes of data because we need to start with the `0x01` character
    and end with the `0x04` character. The five bytes that we would send would be
    `0x01`, `0x44`, `0x111`, `0x67` and `0x04`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们通过两个蓝牙经典设备之间传输字符数据时，我们实际上是在发送ASCII代码。例如，如果我们发送单词“Dog”，我们实际上在发送三个字节数据，分别是`0x44`（D），`0x111`（o），和`0x67`（g）。根据我们定义的协议，如果我们发送单词Dog，我们会发送五个字节数据，因为我们需要以`0x01`字符开始，以`0x04`字符结束。我们将发送的五个字节将是`0x01`，`0x44`，`0x111`，`0x67`和`0x04`。
- en: 'Now let''s look at the code to send and receive the messages between the two
    Bluetooth modules. This code will run on both the master and the slave devices.
    We will start off by including the `SoftwareSerial` library in the project and
    creating an instance of the `SoftwareSerial` type. The following code does this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下在两个蓝牙模块之间发送和接收消息的代码。此代码将在主设备和从设备上运行。我们将首先在项目中包含`SoftwareSerial`库，并创建一个`SoftwareSerial`类型的实例。以下代码执行此操作：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line includes the `SoftwareSerial` library in the project, and then
    the next line creates an instance of the `SoftwareSerial` type. The third line
    creates a global variable that will define when a new message is started.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在项目中包含`SoftwareSerial`库，下一行创建一个`SoftwareSerial`类型的实例。第三行创建一个全局变量，用于定义何时开始新消息。
- en: 'Now we will need to configure the serial console and the `HC05` `SoftwareSerial`
    instance in the `setup()` method. The following code will do this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`setup()`方法中配置串行控制台和`HC05` `SoftwareSerial`实例。以下代码将执行此操作：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we start off by configuring the serial console with a baud rate
    of 9600\. We then define that the digital 9 pin will be an output pin and set
    it to high. The digital 9 pin is connected to the key pin on the HC-05 Bluetooth
    module. We pull this pin high to enable it. We configure the `HC05` instance of
    the `SoftwareSerial` type with a baud rate of 9600 and then print a message to
    the serial console letting the user know that everything is configured and ready
    to go.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先配置串行控制台，波特率为9600。然后定义数字9脚将作为输出脚，并将其设置为高电平。数字9脚连接到HC-05蓝牙模块的按键引脚。我们将此引脚拉高以启用它。我们使用波特率为9600配置`HC05`类型的`SoftwareSerial`实例，并在串行控制台上打印一条消息，告知用户一切已配置就绪，准备开始。
- en: 'The `loop()` function will need to monitor both the serial console and the
    `HC05` `SoftwareSerial` instance for new data coming in. If it receives new data
    from the serial console, it will need to transmit it out through the Bluetooth
    module, and if it receives new data from the Bluetooth module, it will need to
    display the data in the serial console. The following code does this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数需要监控串行控制台和`HC05` `SoftwareSerial`实例，以接收新数据。如果它从串行控制台接收到新数据，它需要通过蓝牙模块将其发送出去，如果它从蓝牙模块接收到新数据，它需要在串行控制台上显示这些数据。以下代码执行此操作：'
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this function, we check to see if there is any data available from the `HC05`
    `SoftwareSerial` instance and if so, it is read into the `val` variable. The `val`
    variable is then written to the serial console. We then see if the `val` variable
    is equal to `0x04` and if so we write a carriage return and line feed to the serial
    console because that particular message has ended.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们检查`HC05` `SoftwareSerial`实例是否有任何可用数据，如果有，它将被读取到`val`变量中。然后将`val`变量写入串行控制台。然后我们检查`val`变量是否等于`0x04`，如果是，我们在串行控制台上写入一个回车符和换行符，因为这条特定的消息已经结束。
- en: Now we check to see if there is any data available from the serial console and
    if so, we check to see if we are starting a new message by checking if the `newMessage`
    variable is equal to `true`. If the `newMessage` variable is equal to `true`,
    we write a `0x01` character to the `HC05` `SoftwareSerial` instance and then set
    the `newMessage` variable to `false`. We then read the character from the serial
    console and see if it is equal to the tilde (`~`) character. We are going to use
    the tilde character to specify that the message has ended therefore when the user
    types in a tilde we will write the `0x04` character to the `HC05` `SoftwareSerial`
    instance and set the `newMessage` variable to `true` because this particular message
    has ended. If the character does not equal a tilde, we write the character to
    the `SoftwareSerial` instance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查串行控制台是否有任何可用数据，如果有，我们检查是否开始了一个新消息，通过检查`newMessage`变量是否等于`true`。如果`newMessage`变量等于`true`，我们将一个`0x01`字符写入`HC05`
    `SoftwareSerial`实例，并将`newMessage`变量设置为`false`。然后我们从串行控制台读取字符，并检查它是否等于波浪号（`~`）字符。我们将使用波浪号字符来指定消息已结束，因此当用户输入波浪号时，我们将写入`0x04`字符到`HC05`
    `SoftwareSerial`实例，并将`newMessage`变量设置为`true`，因为这条特定的消息已经结束。如果字符不等于波浪号，我们将字符写入`SoftwareSerial`实例。
- en: Now if we run this code on both the master and slave device, whatever we type
    into the serial console on one device will be transmitted to the other device
    through the Bluetooth modules. The message will continue to be printed on one
    line of the serial console until the user types in a tilde signifying the end
    of the message.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们在这两个主从设备上运行此代码，无论我们在一个设备的串行控制台上输入什么，都会通过蓝牙模块传输到另一个设备。消息将继续打印在串行控制台的一行上，直到用户输入波浪号（~）表示消息的结束。
- en: Transmitting text back and forth is good but we can do that with Bluetooth LE
    as we saw in [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth
    LE*. Let's do something that is a bit more useful by looking at how this can be
    used as a remote control by connecting an Arduino joystick module to one of the
    devices and streaming the joystick position to the other device.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 互相传输文本是好的，但正如我们在第20章中看到的，我们可以使用蓝牙低功耗（Bluetooth LE）来做这件事，*蓝牙低功耗*。让我们通过将Arduino摇杆模块连接到其中一个设备并将摇杆位置流式传输到另一个设备来做一些更有用的事情。
- en: Project 3 – joystick remote control
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目3 – 摇杆遥控
- en: If you have not connected the joystick breakout module to one of the Arduino's
    you will need to do it before you start this project. Once the joystick breakout
    module is connected to the Arduino, we will write the code that will read the
    position of the joystick and transmit it to the other Arduino via the HC-05 Bluetooth
    modules; however, before we do this we need to figure out the protocol that we
    are going to use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有将摇杆扩展模块连接到Arduino之一，你需要在开始此项目之前完成连接。一旦摇杆扩展模块连接到Arduino，我们将编写代码来读取摇杆的位置并将其通过HC-05蓝牙模块传输到另一个Arduino；然而，在我们这样做之前，我们需要弄清楚我们将要使用的协议。
- en: 'For this example, we will use the same protocol that we used in the previous
    project, where the message will start off with a `0x01` byte and end with a `0x04`
    byte and everything in between is the message itself. The message itself will
    contain two bytes, one that indicates the *x* position of the joystick and one
    that indicates the *y* position. Therefore, a complete transmission will contain
    a total of four bytes likes this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用与上一个项目相同的协议，其中消息以`0x01`字节开始，以`0x04`字节结束，而中间的一切都是消息本身。消息本身将包含两个字节，一个表示摇杆的*x*位置，另一个表示*y*位置。因此，一个完整的传输将包含总共四个字节，如下所示：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have the protocol that will be used to transmit the joystick position
    from one Arduino to the other let's begin by writing the code that will run on
    the Arduino that the joystick breakout module is connected to. The position of
    the joystick is read through the two analog pins that are connected to it. We
    also need to bring the SEL pin, which is connected to the digital 2 pin, high.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将摇杆位置从一块Arduino传输到另一块的协议，让我们开始编写将在连接摇杆扩展模块的Arduino上运行的代码。摇杆的位置是通过连接到它的两个模拟引脚读取的。我们还需要将连接到数字2引脚的SEL引脚设置为高电平。
- en: 'The first thing we will need to do in the code is to include the `SoftwareSerial`
    library for the Bluetooth module, create an instance of the `SoftwareSerial` type
    and define the pins that the joystick module is connected to. The following code
    will do this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们首先需要包含蓝牙模块的`SoftwareSerial`库，创建一个`SoftwareSerial`类型的实例，并定义摇杆模块连接到的引脚。以下代码将完成这项工作：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, we define the SEL pin for the joystick to be the digital 2 pin,
    the key pin on the Bluetooth module to be the digital 9 pin and the *x*/*y* axes
    to be the analog 0 and 1 pins.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义摇杆的SEL引脚为数字2引脚，蓝牙模块上的按键引脚为数字9引脚，*x*和*y*轴为模拟0和1引脚。
- en: 'In the `setup()` function we will need bring both the `SW_PIN` and the `BT_PIN`
    high and initialize both the serial console and the instance of the `SoftwareSerial`
    instance. Here is the code for the `setup()` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们需要将`SW_PIN`和`BT_PIN`都设置为高电平，并初始化串行控制台和`SoftwareSerial`实例。以下是`setup()`函数的代码：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code should look very familiar by now. The first four lines initialize
    the digital pins and pull them high. The next two lines initialize the `SoftwareSerial`
    instance and the serial console with baud rates of 9600\. Finally, a message is
    printed to the serial console letting the user know that everything is ready to
    go.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码应该看起来很熟悉了。前四行初始化数字引脚并将它们拉高。接下来的两行初始化`SoftwareSerial`实例和串行控制台，波特率为9600。最后，在串行控制台上打印一条消息，告知用户一切准备就绪。
- en: 'In our `loop()` function, we will need to read the position of the joystick
    and then write the message to the Bluetooth module. The following code will do
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`loop()`函数中，我们需要读取操纵杆的位置，然后将消息写入蓝牙模块。以下代码将执行此操作：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two lines read the *x* and *y* axes of the joystick module. When reading
    an analog pin the values that are returned range from 0 to 1024; however, we only
    want to send a single byte to represent the position of the joystick. A single
    byte can have a range from 0 to 255, therefore we divide the value from the analog
    read by `4`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行读取操纵杆模块的*x*轴和*y*轴。当读取模拟引脚时，返回的值范围从0到1024；然而，我们只想发送一个字节来表示操纵杆的位置。一个字节的范围可以从0到255，因此我们将模拟读取的值除以`4`。
- en: After we retrieve the values for the *x* and *y* axes of the joystick, we need
    to send the message through the Bluetooth module with these values. The next four
    lines of code writes a `0x01` (SOH), the value of the *x* axis, the value of the
    *y *axis and finally a `0x04` (EOT). After the message is sent, we pause for 500
    milliseconds and then loops back.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取操纵杆的*x*轴和*y*轴的值之后，我们需要将这些值通过蓝牙模块发送消息。接下来的四行代码写入`0x01`（SOH），*x*轴的值，*y*轴的值，最后是`0x04`（EOT）。消息发送后，我们暂停500毫秒，然后循环返回。
- en: 'Now that we have the code that will run on the Arduino that the joystick is
    connected to, we need to write the code that will run on the Arduino that will
    receive the data. This code will need to start off by including the `SoftwareSerial`
    library for the Bluetooth module and create an instance of the `SoftwareSerial`
    type. We will also need to define a buffer that will be used to store the data
    as it comes in through the Bluetooth module. The following code will do this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将在连接操纵杆的Arduino上运行的代码，我们需要编写将在接收数据的Arduino上运行的代码。此代码需要首先包含蓝牙模块的`SoftwareSerial`库，并创建一个`SoftwareSerial`类型的实例。我们还需要定义一个缓冲区，用于存储通过蓝牙模块传入的数据。以下代码将执行此操作：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code starts off by including the `SoftwareSerial` library and then defines
    the max size for the input buffer, which is `255`. While we could limit the size
    of the buffer to four because we know that each message will be four bytes in
    size, we always want to have extra space in the buffer, especially with wireless
    communication, in case the message gets messed up in transmission. If this was
    a production system, I would probably limit the size of the buffer to 12 or 16
    bytes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先包含`SoftwareSerial`库，然后定义输入缓冲区的最大大小，为`255`。虽然我们知道每条消息的大小为4个字节，但我们总是希望在缓冲区中留有额外空间，尤其是在无线通信中，以防消息在传输过程中出错。如果这是一个生产系统，我可能会将缓冲区的大小限制为12或16字节。
- en: We define that the key pin on the Bluetooth module is connected to the digital
    9 pin on the Arduino. We then create an instance of the `SoftwareSerial` type
    and a `byte` array for the input buffer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义蓝牙模块上的按键引脚连接到Arduino的数字9号引脚。然后我们创建一个`SoftwareSerial`类型的实例和一个输入缓冲区的`byte`数组。
- en: 'In the `setup()` function we will initialize the serial console and the `SoftwareSerial`
    instance. We will also need to pull the key pin for that Bluetooth module high.
    The following code does this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们将初始化串行控制台和`SoftwareSerial`实例。我们还需要将蓝牙模块的按键引脚拉高。以下代码执行此操作：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now in the `loop()` function we will want to continuously read the input from
    the Bluetooth module until we receive and EOT (`0x04`) byte. As we read the data
    in, it will be stored in the byte array and once the `0x04` byte is read in we
    will print out the message and then loop back. Here is the code for the `loop()`
    function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`loop()`函数中，我们希望持续读取蓝牙模块的输入，直到我们接收到EOT（`0x04`）字节。当我们读取数据时，它将被存储在字节数组中，一旦读取到`0x04`字节，我们将打印出消息，然后循环返回。以下是`loop()`函数的代码：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function starts off by using the `memset()` function to initialize the
    buffer with all zeros. We then create an integer variable that will count how
    many bytes are read in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先使用`memset()`函数将缓冲区初始化为零。然后我们创建一个整数变量，该变量将计算读取的字节数。
- en: A `while` loop is used to continuously loop until the maximum number of bytes
    have been read. Within the `while` loop, we use the `available()` function from
    the `HC05` `SoftwareSerial` instance to see if there are any values to read from
    the Bluetooth module. If there is a value to read, we use the `read()` function
    to read the value in, store it in the `buf` byte array and increments the counter.
    We then check to see if the value that was read in is equal to `0x04` and if so
    we use the `break` statement to break out of the `while` loop.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环用于持续循环，直到读取到最大字节数。在 `while` 循环中，我们使用 `HC05` `SoftwareSerial` 实例的
    `available()` 函数来查看蓝牙模块是否有可读取的值。如果有可读取的值，我们使用 `read()` 函数读取该值，将其存储在 `buf` 字节数组中，并增加计数器。然后我们检查读取的值是否等于
    `0x04`，如果是，我们使用 `break` 语句跳出 `while` 循环。'
- en: 'Finally, we create a `for` loop that will loop through the values in the buffer
    and print them to the serial console. If we execute the code on both Arduinos
    and move the joystick around, we will see output similar to the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `for` 循环，该循环将遍历缓冲区中的值并将它们打印到串行控制台。如果我们同时在两个 Arduino 上执行代码并移动摇杆，我们将看到类似于以下截图的输出：
- en: '![](img/82c6a280-e172-4231-9b8b-54cf6aca98dd.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82c6a280-e172-4231-9b8b-54cf6aca98dd.png)'
- en: As we can see from the output, each message starts with the `0x01` byte and
    ends with the `0x04` byte. In between these two bytes are the joystick position
    on the *x* axis and the *y* axis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，每个消息都以 `0x01` 字节开始，以 `0x04` 字节结束。在这两个字节之间是摇杆在 *x* 轴和 *y* 轴上的位置。
- en: We know that the packets are supposed to be four bytes in length. In a production
    environment we would want to toss out any messages that were not four bytes in
    length because we know that if the message is not four bytes in length, then the
    message got messed up in transmission.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道数据包应该是四个字节长。在生产环境中，我们希望丢弃任何长度不是四个字节的消息，因为我们知道如果消息长度不是四个字节，那么消息在传输过程中可能已经损坏。
- en: 'We could also use a checksum to ensure that the message was received correctly.
    A checksum is some value that is calculated using the data that is sent. One of
    the easiest ways to generate a checksum is to add up all of the data bytes, storing
    the value in a byte that will cause the value to wrap around when it is greater
    than 255\. Here is an example of a function that would generate a checksum:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用校验和来确保消息被正确接收。校验和是使用发送的数据计算出的某个值。生成校验和的最简单方法之一是将所有数据字节相加，将值存储在一个字节中，当该值大于
    255 时将导致值回绕。以下是一个生成校验和的函数示例：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function takes a pointer to a `byte` array and the size of the array as
    parameters. It then loops through the array and adds each byte to the checksum
    and then returns the value. A byte can have a maximum value of 255, therefore
    once the value gets above 255 the value will loop around. For example, if the
    checksum byte had a value of 252 and a value of 10 was added to it, the checksum
    value would then be 7\. We could then send the checksum before the `0x04` value,
    and the device that receives the message could verify the message integrity by
    calculating the checksum on the receiving end and verifying that the two values
    match.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个指向 `byte` 数组的指针和数组的大小作为参数。然后它遍历数组，将每个字节添加到校验和中，然后返回值。一个字节的最大值为 255，因此一旦值超过
    255，值将回绕。例如，如果校验和字节值为 252，向其添加一个值为 10 的值，则校验和值将变为 7。然后我们可以在 `0x04` 值之前发送校验和，接收消息的设备可以通过在接收端计算校验和并验证两个值是否匹配来验证消息的完整性。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a lot about Bluetooth Classic, starting with a brief
    introduction on how the radio works and the network topology for Bluetooth Classic
    connections. We demonstrated how we could configure the Bluetooth HC-05 Bluetooth
    module as both a slave and master. We also saw how we could configure the Bluetooth
    modules to connect to each other on startup automatically. Finally, we saw how
    we could stream data from one device to another using Bluetooth classic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了有关蓝牙经典的大量知识，从对无线电工作原理和蓝牙经典连接的网络拓扑的简要介绍开始。我们演示了如何配置蓝牙 HC-05 蓝牙模块作为从机和主机。我们还看到了如何配置蓝牙模块在启动时自动连接到彼此。最后，我们看到了如何使用蓝牙经典从一台设备向另一台设备传输数据。
- en: In [Chapter 20](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml), *Bluetooth LE*,
    and this chapter we looked at two different Bluetooth technologies, but the question
    may still be when to use which one. When we have a use case that defines that
    we want one device to ask another device for information periodically, like a
    weather station, we generally want to use Bluetooth LE. When we want to stream
    data from one device to another without waiting for the receiving device to ask
    for it, we generally want to use Bluetooth Classic.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20章](7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml)，“蓝牙低功耗”以及本章中，我们探讨了两种不同的蓝牙技术，但问题可能仍然在于何时使用哪一种。当我们有一个用例定义了我们需要一个设备定期向另一个设备请求信息，比如气象站时，我们通常希望使用蓝牙低功耗。当我们想要从一台设备向另一台设备传输数据而不需要等待接收设备请求时，我们通常希望使用蓝牙经典。
- en: Over the course of this book, we have looked at many different items from a
    microcontroller to sensors and from motors to wireless communication modules.
    The idea was to expose you to a number of different items to hopefully give you
    ideas for your own projects. The best thing about the Arduino, is the projects
    that you do are only limited by your imagination, so start imagining what super
    awesome projects you can do and then create them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们从微控制器到传感器，从电机到无线通信模块，考察了许多不同的项目。我们的想法是让你接触到许多不同的项目，希望这能给你自己的项目带来灵感。关于Arduino最好的事情是，你做的项目只受限于你的想象力，所以开始想象你可以做哪些超级酷炫的项目，然后去创造它们。
