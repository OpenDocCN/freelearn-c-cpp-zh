- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Accessing Databases with SQL Driver and Qt
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQL驱动器和Qt访问数据库
- en: '**Structured Query Language** (**SQL**) is a special programming language used
    to manage data held in a relational database management system. A SQL server is
    a database system designed to use one of the many types of SQL programming languages
    to manage its data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**SQL**）是一种特殊的编程语言，用于管理关系数据库管理系统中的数据。SQL服务器是一个数据库系统，旨在使用多种SQL编程语言之一来管理其数据。'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up a database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库
- en: Connecting to a database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Writing basic SQL queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基本的SQL查询
- en: Creating a login screen with Qt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt创建登录界面
- en: Displaying information from a database in model view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型视图中显示数据库信息
- en: Advanced SQL queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级SQL查询
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括Qt 6.6.1 MinGW 64位和Qt Creator 12.0.2。本章中使用的所有代码都可以从以下GitHub仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12)。
- en: Setting up a database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: Qt supports several different types of SQL drivers in the form of plugins/add-ons,
    such as **SQLite**, **ODBC**, **PostgreSQL**, **MySQL**, and so on. However, it’s
    very easy to integrate these drivers into your Qt project. We will learn how to
    do this in the following example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Qt支持多种不同类型的SQL驱动程序，以插件/附加组件的形式存在，例如**SQLite**、**ODBC**、**PostgreSQL**、**MySQL**等。然而，将这些驱动程序集成到Qt项目中非常容易。我们将在下面的示例中学习如何做到这一点。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this example, we will learn how to use Qt with **SQLite**. Let’s set up
    our SQLite editor before we dive into Qt:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何使用Qt与**SQLite**。在我们深入Qt之前，让我们设置我们的SQLite编辑器：
- en: 'Download **SQLiteStudio** from [https://sqlitestudio.pl](https://sqlitestudio.pl)
    and install it to administrate your SQLite databases:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://sqlitestudio.pl](https://sqlitestudio.pl)下载**SQLiteStudio**并安装它以管理您的SQLite数据库：
- en: '![Figure 12.1 – Install SQLiteStudio onto your computer](img/B20976_12_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 将SQLiteStudio安装到您的计算机上](img/B20976_12_001.jpg)'
- en: Figure 12.1 – Install SQLiteStudio onto your computer
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 将SQLiteStudio安装到您的计算机上](img/B20976_12_001.jpg)'
- en: 'Open **SQLiteStudio** and you should see something like this:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**SQLiteStudio**，您应该看到类似以下内容：
- en: '![Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases](img/B20976_12_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – SQLiteStudio是一个管理SQLite数据库的便捷程序](img/B20976_12_002.jpg)'
- en: Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – SQLiteStudio是一个管理SQLite数据库的便捷程序](img/B20976_12_002.jpg)'
- en: 'We need to create a new database before we start; go to **Database** | **Add
    a database**. Select the **SQLite 3** option for your database type, followed
    by selecting your file name and setting your database name. Then, click the **Test
    connection** button. You should see a green tick appearing beside the button.
    After that, click on the **OK** button:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要创建一个新的数据库；转到**数据库** | **添加数据库**。选择您的数据库类型为**SQLite 3**，然后选择您的文件名并设置数据库名称。然后，点击**测试连接**按钮。您应该在按钮旁边看到一个绿色的勾号。之后，点击**确定**按钮：
- en: '![Figure 12.3 – Creating a new SQLite 3 database](img/B20976_12_003.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 创建新的SQLite 3数据库](img/B20976_12_003.jpg)'
- en: Figure 12.3 – Creating a new SQLite 3 database
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 创建新的SQLite 3数据库
- en: 'Once the database has been created, you should see the database appear in the
    **Databases** window. Then, right-click on **Tables** and select **Create a table**
    option from the menu that pops up:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库创建完成后，您应该在**数据库**窗口中看到数据库出现。然后，右键单击**表**，从弹出的菜单中选择**创建表**选项：
- en: '![Figure 12.4 – Select the Create a table option from the menu](img/B20976_12_004.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 从菜单中选择创建表选项](img/B20976_12_004.jpg)'
- en: Figure 12.4 – Select the Create a table option from the menu
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 从菜单中选择创建表选项
- en: 'Set the table name as `employee`. Then, click on the **Add column (lns)** button
    located above the table name input field. The **Column** window will now pop up:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表名设置为`employee`。然后，点击位于表名输入字段上方的**添加列（lns）**按钮。此时，**列**窗口将弹出：
- en: '![Figure 12.5 – Create a new column called emp_id](img/B20976_12_005.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 创建一个名为emp_id的新列](img/B20976_12_005.jpg)'
- en: Figure 12.5 – Create a new column called emp_id
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 创建一个名为emp_id的新列
- en: 'Set the column name as `emp_id`, set the data type as **INTEGER**, and check
    the **Primary key** checkbox. Then, click on the **Configure** button at the right
    of the **Primary key** checkbox. The **Edit constraint** window will now pop up.
    Check on the **Autoincrement** checkbox and click **Apply**:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列名设置为`emp_id`，将数据类型设置为**整数**，并勾选**主键**复选框。然后，点击**主键**复选框右侧的**配置**按钮。现在将弹出**编辑约束**窗口。勾选**自动递增**复选框并点击**应用**：
- en: '![Figure 12.6 – Enable the Autoincrement checkbox](img/B20976_12_006.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 启用自动递增复选框](img/B20976_12_006.jpg)'
- en: Figure 12.6 – Enable the Autoincrement checkbox
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 启用自动递增复选框
- en: 'After that, press the `emp_id`. Let’s repeat the steps above (without enabling
    the primary key) to create other columns. You may follow the same settings as
    seen here:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按`emp_id`。让我们重复上述步骤（不启用主键）来创建其他列。您可以遵循此处看到的相同设置：
- en: '![Figure 12.7 – Create all five columns](img/B20976_12_007.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 创建所有五个列](img/B20976_12_007.jpg)'
- en: Figure 12.7 – Create all five columns
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 创建所有五个列
- en: 'The columns are not actually created at this point. Click on the button with
    a green tick icon located above the table name. A window will pop up to confirm
    the creation of the columns. Press **OK** to proceed:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列实际上在此点并未创建。点击位于表名上方的带绿色勾选图标按钮。将弹出一个窗口以确认列的创建。按**确定**继续：
- en: '![Figure 12.8 – Click the OK button to confirm](img/B20976_12_008.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 点击“确定”按钮进行确认](img/B20976_12_008.jpg)'
- en: Figure 12.8 – Click the OK button to confirm
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 点击“确定”按钮进行确认
- en: 'Now, we have created the `employee` table. Let’s move on from the `employee`
    table, which is currently empty. Let’s insert dummy data into the `employee` table
    by clicking on the **Insert row (Ins)** button, which is the one with a green
    plus icon. Then, simply insert some dummy data like so:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了`employee`表。让我们从当前为空的`employee`表继续。通过点击带绿色加号图标的**插入行（Ins）**按钮将虚拟数据插入到`employee`表中。然后，简单地插入一些虚拟数据如下：
- en: '![Figure 12.9 – Insert dummy data into the employee table](img/B20976_12_009.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 将虚拟数据插入到员工表中](img/B20976_12_009.jpg)'
- en: Figure 12.9 – Insert dummy data into the employee table
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 将虚拟数据插入到员工表中
- en: Let’s set up the SQL driver for our Qt project. Just go to your Qt installation
    folder and look for the `sqldrivers` folder. For example, mine is located at `C:\Qt\6.4.2\mingw_64\plugins\sqldrivers`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的Qt项目设置SQL驱动程序。只需转到您的Qt安装文件夹，并查找`sqldrivers`文件夹。例如，我的位于`C:\Qt\6.4.2\mingw_64\plugins\sqldrivers`。
- en: Copy the entire `sqldrivers` folder to your project’s build directory. You can
    remove the DLL files that are not relevant to the SQL server you’re running. In
    our case, since we’re using `qsqlite.dll`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个`sqldrivers`文件夹复制到您的项目构建目录中。您可以删除与您运行的SQL服务器不相关的DLL文件。在我们的例子中，因为我们使用`qsqlite.dll`。
- en: 'The DLL files mentioned in the previous step are the drivers that enable Qt
    to communicate with different types of SQL architecture. You may also need the
    DLL file of the SQL client library in order for the driver to work. In our case,
    we need `sqlite3.dll` to be located in the same directory as our program’s executable.
    You can either get it from the installation directory of **SQLiteStudio** or from
    the official website of **SQLite**: [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步中提到的DLL文件是使Qt能够与不同类型的SQL架构通信的驱动程序。您可能还需要SQL客户端库的DLL文件，以便驱动程序能够工作。在我们的例子中，我们需要`sqlite3.dll`位于我们的程序可执行文件相同的目录中。您可以从**SQLiteStudio**的安装目录或**SQLite**的官方网站[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)获取它。
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt provides us with SQL drivers so that we can easily connect to different types
    of SQL servers without implementing them ourselves.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了SQL驱动程序，这样我们就可以轻松地连接到不同类型的SQL服务器，而无需自己实现它们。
- en: Currently, Qt officially supports SQLite, ODBC, and PostgreSQL. If you need
    to connect directly to MySQL, you need to recompile Qt drivers by yourself, which
    is out of the scope of this book. For security reasons, it’s not recommended that
    you connect to MySQL directly from your application. Instead, your application
    should interact with your MySQL database (or any other SQL servers that are not
    officially supported by Qt) indirectly by sending an HTTP request using `QNetworkAccessManager`
    to your backend script (such as PHP, ASP, and JSP), which can then communicate
    with the database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Qt 正式支持 SQLite、ODBC 和 PostgreSQL。如果你需要直接连接到 MySQL，你需要自己重新编译 Qt 驱动程序，这超出了本书的范围。出于安全原因，不建议你直接从你的应用程序连接到
    MySQL。相反，你的应用程序应该通过使用 `QNetworkAccessManager` 发送 HTTP 请求到你的后端脚本（如 PHP、ASP 和 JSP）来间接与
    MySQL 数据库（或任何其他 Qt 未官方支持的 SQL 服务器）交互，然后该脚本可以与数据库通信。
- en: If you only need a simple file-based database and don’t plan to use a server-based
    database, **SQLite** is a good choice for you, which is what we have chosen for
    this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个简单的基于文件的数据库，并且不打算使用基于服务器的数据库，**SQLite** 是你的一个不错的选择，这也是我们本章所选择的方法。
- en: In the *Connecting to a database* recipe, we will learn how to connect to our
    SQL database using Qt’s SQL module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *连接到数据库* 菜谱中，我们将学习如何使用 Qt 的 SQL 模块连接到我们的 SQL 数据库。
- en: Connecting to a database
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: In this recipe, we will learn how to connect our Qt 6 application to the SQL
    server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将我们的 Qt 6 应用程序连接到 SQL 服务器。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Connecting to SQL Server in Qt is really simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中连接到 SQL 服务器非常简单：
- en: Open Qt Creator and create a new **Qt Widgets** **Application** project.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Qt Creator 并创建一个新的 **Qt Widgets** **应用程序**项目。
- en: 'Open your project file (`.pro`), add the `sql` module to your project, and
    run `qmake` like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目文件（`.pro`），将 `sql` 模块添加到你的项目中，并像这样运行 `qmake`：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 12.10 –  Setting the text properties](img/B20976_12_010.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 设置文本属性](img/B20976_12_010.jpg)'
- en: Figure 12.10 – Setting the text properties
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 设置文本属性
- en: 'Open `mainwindow.h` and add the following headers below the `QMainWindow` header:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.h` 并在 `QMainWindow` 头部下方添加以下头文件：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'MainWindow::MainWindow(QWidget *parent) :'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MainWindow::MainWindow(QWidget *parent) :'
- en: QMainWindow(parent), ui(new Ui::MainWindow) {
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QMainWindow(parent), ui(new Ui::MainWindow) {
- en: ui->setupUi(this);
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui->setupUi(this);
- en: QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
- en: db.setDatabaseName("database.db3");
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db.setDatabaseName("database.db3");
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start the SQL query once the database connection has been opened:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库连接打开后开始 SQL 查询：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Print out any error texts:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出任何错误文本：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you compile and run your project now, you should get something like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行你的项目，你应该会得到类似这样的结果：
- en: '![Figure 12.11 – The data from our database is now showing on the Qt program](img/B20976_12_011.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 我们数据库的数据现在显示在 Qt 程序中](img/B20976_12_011.jpg)'
- en: Figure 12.11 – The data from our database is now showing on the Qt program
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 我们数据库的数据现在显示在 Qt 程序中
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The previous example shows you how to connect to your SQL database using the
    `QSqlDatabase` class derived from the SQL module. You won’t be able to access
    any of the classes related to SQL without adding the module to your Qt project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了如何使用从 SQL 模块派生的 `QSqlDatabase` 类连接到你的 SQL 数据库。如果不将模块添加到你的 Qt 项目中，你将无法访问任何与
    SQL 相关的类。
- en: 'We must tell Qt which SQL architecture we are running by mentioning it when
    calling the `addDatabase()` function. The options supported by Qt are `QSqlDatabase:
    QMYSQL driver not loaded`, you should check whether the DLL files are placed in
    the correct directory.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '我们必须在调用 `addDatabase()` 函数时提到我们正在运行的 SQL 架构，Qt 支持的选项包括 `QSqlDatabase: QMYSQL
    driver not loaded`，你应该检查 DLL 文件是否放置在正确的目录中。'
- en: We can send our SQL statements to the database through the `QSqlQuery` class
    and wait for it to return the results, which are usually either the data you requested
    or error messages due to invalid statements. If there are any data coming from
    the database server, they will all be stored in the `QSqlQuery` class. All you
    need to retrieve these data is to perform a “while” loop on the `QSqlQuery` class
    to check for all existing records and retrieve them by calling the `value()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `QSqlQuery` 类将我们的 SQL 语句发送到数据库，并等待它返回结果，这些结果通常是请求的数据或由于无效语句而产生的错误信息。如果有任何数据来自数据库服务器，它们都将存储在
    `QSqlQuery` 类中。你只需要在 `QSqlQuery` 类上执行一个“while”循环来检查所有现有记录并通过调用 `value()` 函数来检索它们。
- en: Since we used SQLite in the preceding example, we don’t need to set the server
    host, username, and password when connecting to the database. SQLite is a file-based
    SQL database; therefore, we only need to set the file name when calling `QSqlDatabase::setDatabaseName()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的示例中使用了 SQLite，因此连接到数据库时我们不需要设置服务器主机、用户名和密码。SQLite 是一个基于文件的 SQL 数据库；因此，我们只需要在调用
    `QSqlDatabase::setDatabaseName()` 时设置文件名。
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Qt 6 no longer officially supports QMYSQL or QMYSQL3\. You can add MySQL support
    by re-compiling Qt from the source yourself. However, this method is not recommended
    for beginners. For more information, check out [https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver](https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 不再官方支持 QMYSQL 或 QMYSQL3。你可以通过从源代码重新编译 Qt 来添加 MySQL 支持。然而，这种方法不建议初学者使用。更多信息，请查看
    [https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver](https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver)。
- en: Writing basic SQL queries
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本的 SQL 查询
- en: In the previous example, we wrote our very first SQL query, which involves the
    `SELECT` statement. This time, we will learn how to use some other SQL statements,
    such as `INSERT`, `UPDATE`, and `DELETE`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们编写了我们非常第一个 SQL 查询，它涉及 `SELECT` 语句。这次，我们将学习如何使用一些其他的 SQL 语句，例如 `INSERT`、`UPDATE`
    和 `DELETE`。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s create a simple program that demonstrates basic SQL query commands by
    following these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个简单的程序，通过它演示基本的 SQL 查询命令：
- en: 'We can use our previous project files, but there are a couple of things we
    need to change. Open `mainwindow.ui` and replace the labels for `UPDATE`, `INSERT`,
    and `DELETE`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们之前的项目文件，但有一些事情我们需要更改。打开 `mainwindow.ui` 并替换 `UPDATE`、`INSERT` 和 `DELETE`
    的标签：
- en: '![Figure 12.12 – Modify the UI to this](img/B20976_12_012.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 将 UI 修改为这样](img/B20976_12_012.jpg)'
- en: Figure 12.12 – Modify the UI to this
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 将 UI 修改为这样
- en: 'Open `mainwindow.h` and add the following variables under the private inheritance:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.h` 并在私有继承下添加以下变量：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'MainWindow::MainWindow(QWidget *parent) :'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MainWindow::MainWindow(QWidget *parent) :'
- en: QMainWindow(parent), ui(new Ui::MainWindow) {
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QMainWindow(parent), ui(new Ui::MainWindow) {
- en: ui->setupUi(this);
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui->setupUi(this);
- en: db = QSqlDatabase::addDatabase("QSQLITE");
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db = QSqlDatabase::addDatabase("QSQLITE");
- en: db.setDatabaseName("database.db3");
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db.setDatabaseName("database.db3");
- en: connected = db.open();
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: connected = db.open();
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s make a query after we have connected to the database:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在连接到数据库后执行一个查询：
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Print out any error messages:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出任何错误信息：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go to `mainwindow.ui` and right-click on one of the buttons we added to the
    canvas in step 1\. Select `mainwindow.h` and `mainwindow.cpp`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `mainwindow.ui` 并在步骤 1 中添加到画布上的一个按钮上右键单击。选择 `mainwindow.h` 和 `mainwindow.cpp`：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open `mainwindow.cpp` and we will declare what the program will do when we
    click on the **Update** button:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.cpp` 并声明当我们点击 **更新** 按钮时程序将执行的操作：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Make an `UPDATE` query like so:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似的 `UPDATE` 查询：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print out the last error message, if any:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有的话，打印出最后的错误信息：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Declare what will happen when the **INSERT** button is clicked:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明当点击 **INSERT** 按钮时将发生什么：
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Make an `INSERT` query like so:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似的 `INSERT` 查询：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Declare what will happen when the **Delete** button is clicked:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明当点击 **Delete** 按钮时将发生什么：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call `QSqlDatabase::close()` at the class destructor to properly terminate
    the SQL connection before exiting the program:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类析构函数中调用 `QSqlDatabase::close()` 以在退出程序之前正确终止 SQL 连接：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you compile and run the program now, you should be able to select the default
    data from the database. Then, you can choose to update it or delete it from the
    database. You can also insert new data into the database by clicking the Insert
    button. You can use **SQLiteStudio** to check whether the data are being altered
    correctly:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行程序，你应该能够从数据库中选择默认数据。然后，你可以选择更新它或从数据库中删除它。你也可以通过点击插入按钮将新数据插入到数据库中。你可以使用
    **SQLiteStudio** 来检查数据是否被正确修改：
- en: '![Figure 12.13 – Data successfully modified in SQLite](img/B20976_12_013.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – SQLite 中数据成功修改](img/B20976_12_013.jpg)'
- en: Figure 12.13 – Data successfully modified in SQLite
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – SQLite 中数据成功修改
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It’s very important to check whether the database is connected before we proceed
    to send an SQL query to the database. Therefore, we keep that status in a variable
    and use it to check before sending out any queries. This, however, is not recommended
    for complex programs that are kept open for long periods of time, as the database
    might get disconnected during those periods, and a fixed variable may not be accurate.
    In that case, it’s better to check the actual status by calling `QSqlDatabase::isOpen()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向数据库发送 SQL 查询之前，检查数据库是否连接是非常重要的。因此，我们将该状态保存在一个变量中，并在发送任何查询之前使用它进行检查。然而，对于长时间保持打开的复杂程序，这并不推荐，因为在这些期间数据库可能会断开连接，而固定的变量可能不准确。在这种情况下，最好通过调用
    `QSqlDatabase::isOpen()` 来检查实际状态。
- en: The `currentID` variable is used to save the ID of the current data you obtained
    from the database. When you want to update the data or delete them from the database,
    this variable is crucial for letting the database know what data you’re trying
    to update or delete. If you set your database table correctly, SQLite will treat
    each item of data as a unique entry, so you can be sure that no repeated ID will
    be produced in the database when new data are being saved.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentID` 变量用于保存从数据库中获取的当前数据的 ID。当你想要更新数据或从数据库中删除它们时，这个变量对于让数据库知道你正在尝试更新或删除什么数据至关重要。如果你正确设置了数据库表，SQLite
    将将每条数据视为一个唯一的条目，因此你可以确信在保存新数据时数据库中不会产生重复的 ID。'
- en: After inserting new data into the database, we call `QSqlQuery::lastInsertId()`
    to obtain the ID of the new data and save it as a `currentID` variable so that
    it becomes the current data that we can update or delete from the database. It
    is a good habit to test your SQL queries on `SQLiteStudio` before using them in
    Qt. You can instantly find out whether your SQL statements are correct or incorrect
    instead of waiting for your project to be built, trying it out, and then rebuilding
    it. As programmers, we must work in the most efficient way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新数据插入数据库后，我们调用 `QSqlQuery::lastInsertId()` 来获取新数据的 ID 并将其保存为 `currentID` 变量，以便它成为我们可以更新或从数据库中删除的当前数据。在将
    SQL 查询用于 Qt 之前在 `SQLiteStudio` 上测试你的 SQL 查询是一个好习惯。你可以立即发现你的 SQL 语句是否正确，而不是等待你的项目构建，尝试它，然后重新构建它。作为程序员，我们必须以最有效的方式工作。
- en: Work hard and work smart.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 努力工作，聪明工作。
- en: Creating a login screen with Qt
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt 创建登录界面
- en: In this recipe, we will learn how put our knowledge to use and create a functional
    login screen using Qt and SQLite.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何将我们的知识付诸实践，并使用 Qt 和 SQLite 创建一个功能性的登录界面。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create your first functional login screen by following these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的第一个功能性的登录界面：
- en: 'Open a web browser and go to `user`, which looks like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器并转到 `user`，看起来像这样：
- en: '![Figure 12.14 – Create a new user table](img/B20976_12_014.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 创建新的用户表](img/B20976_12_014.jpg)'
- en: Figure 12.14 – Create a new user table
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 创建新的用户表
- en: 'Let’s insert our first item of data into the newly created table and set `user_employeeID`
    to the ID of an existing employee. In this way, the user account we create will
    be linked to the data of one of the employees:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将第一条数据插入到新创建的表中，并将 `user_employeeID` 设置为现有员工的 ID。这样，我们创建的用户账户将与其中一位员工的资料相链接：
- en: '![Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id
    column](img/B20976_12_015.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – user_employeeID 列与员工的 emp_id 列相链接](img/B20976_12_015.jpg)'
- en: Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id
    column
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – user_employeeID 列与员工的 emp_id 列相链接
- en: 'Open `mainwindow.ui`. Place a stacked widget on the canvas and make sure it
    contains two pages. Then, set up the two pages in the stacked widget as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui`。在画布上放置一个堆叠小部件，并确保它包含两页。然后，按照以下方式设置堆叠小部件中的两页：
- en: '![Figure 12.16 – Create a two-page UI inside a stacked widget](img/B20976_12_016.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – 在堆叠小部件内创建两页 UI](img/B20976_12_016.jpg)'
- en: Figure 12.16 – Create a two-page UI inside a stacked widget
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 在堆叠小部件内创建两页 UI
- en: 'On the first page of the stacked widget, click the **Edit Tab Order** icon
    on top of the widget so that you can adjust the order of the widgets in your program:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆叠小部件的第一页上，点击小部件顶部的 **编辑标签顺序** 图标，这样你就可以调整程序中小部件的顺序：
- en: '![Figure 12.17 – Change the order of the widgets by pressing this button](img/B20976_12_017.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – 通过按此按钮更改小部件的顺序](img/B20976_12_017.jpg)'
- en: Figure 12.17 – Change the order of the widgets by pressing this button
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 通过按此按钮更改小部件的顺序
- en: 'Once you click the **Edit Tab Order** icon, you will see some numbers appear
    on top of each widget in the canvas. Make sure the numbers look the same as they
    do in the screenshot that follows. Otherwise, click on the numbers to change their
    order. We only do this for the first page of the stacked widget; it’s okay to
    keep the second page as it is:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你点击了**编辑标签顺序**图标，你会在画布中每个小部件的上方看到一些数字。确保这些数字与下面的截图中的数字相同。如果不是，请点击数字以更改它们的顺序。我们只为堆叠小部件的第一页做这件事；第二页保持原样即可：
- en: '![Figure 12.18 – The order of each widget is shown](img/B20976_12_018.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.18 – 每个小部件的顺序显示](img/B20976_12_018.jpg)'
- en: Figure 12.18 – The order of each widget is shown
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 每个小部件的顺序显示
- en: Right-click on the `clicked()` option is selected and press **OK**. Qt will
    then create a slot function for you in your project source files. Repeat this
    step for the **Log Out** button as well.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**clicked()**选项并按**确定**。Qt 将随后在你的项目源文件中为你创建一个槽函数。同样，为**注销**按钮重复此步骤。
- en: 'Open `mainwindow.h` and add the following headers after the `#include <``QMainWindow>`
    line:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.h` 并在 `#include <QMainWindow>` 行之后添加以下头文件：
- en: '[PRE17]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'private:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'private:'
- en: Ui::MainWindow *ui;
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ui::MainWindow *ui;
- en: QSqlDatabase db;
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QSqlDatabase db;
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open `mainwindow.cpp` and put this code in the class constructor:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.cpp` 并在类构造函数中放入以下代码：
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define what will happen if the `Login` button is clicked:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义如果点击**登录**按钮会发生什么：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Make a SQL query:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 SQL 查询：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We continue with the preceding code, and we set the gender and married texts
    before switching the stacked widget to its second page:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续使用前面的代码，并在切换到堆叠小部件的第二页之前设置性别和已婚文本：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Print an error message if the login fails:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果登录失败，打印错误信息：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define what will happen if the **Log Out** button is clicked:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义如果点击**注销**按钮会发生什么：
- en: '[PRE24]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Close the database when the main window is closed:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当主窗口关闭时关闭数据库：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile and run the program, and you should be able to log in with the dummy
    account. After you have logged in, you should be able to see the dummy employee
    information linked to the user account. You can also log out by clicking on the
    **Log** **Out** button:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序，你应该能够使用虚拟账户登录。登录后，你应该能够看到与用户账户关联的虚拟员工信息。你也可以通过点击**注销**按钮来注销：
- en: '![Figure 12.19 – A simple, working login screen](img/B20976_12_019.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.19 – 一个简单、可用的登录界面](img/B20976_12_019.jpg)'
- en: Figure 12.19 – A simple, working login screen
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 – 一个简单、可用的登录界面
- en: How it works…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, we select data from the user table that matches the username
    and password that we inserted into the text fields. If nothing is found, it means
    we have provided an invalid username or password. Otherwise, obtain the `user_employeeID`
    data from the user account and do another SQL query to look for information from
    the `employee` table that matches the `user_employeeID` variable. Then, display
    the data according to the UI of your program.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从用户表中选择与我们在文本字段中插入的用户名和密码匹配的数据。如果没有找到任何内容，这意味着我们提供了无效的用户名或密码。否则，从用户账户中获取
    `user_employeeID` 数据，并对 `employee` 表执行另一个 SQL 查询以查找与 `user_employeeID` 变量匹配的信息。然后，根据你的程序界面显示数据。
- en: We must set the widget order in the **Edit Tab Order** mode so that when the
    program has started, the first widget that gets focused on is the username line-edit
    widget. If the user presses the *Tab* key on the keyboard, the focus should switch
    to the second widget, which is the password line edit. An incorrect widget order
    will ruin the user experience and drive away any potential users. Make sure that
    the **echoMode** option of the password line edit is set to **Password**. That
    setting will hide the actual password inserted into the line edit and replace
    it with dot symbols for security purposes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在**编辑标签顺序**模式下设置小部件顺序，以便程序启动时，第一个获得焦点的小部件是用户名行编辑小部件。如果用户按下键盘上的**Tab**键，焦点应切换到第二个小部件，即密码行编辑。不正确的小部件顺序会破坏用户体验并驱赶任何潜在用户。请确保密码行编辑的**echoMode**选项设置为**密码**。该设置将隐藏实际插入到行编辑中的密码，并用点符号替换以实现安全目的。
- en: Since SQLite does not support returning the query size, we cannot use the `QSqlQuery::size()`
    function to determine how many results are being returned; the result will always
    be -`1`. Therefore, we declared a `resultSize` variable to count the result within
    the while loop operation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 不支持返回查询大小，我们无法使用 `QSqlQuery::size()` 函数来确定返回多少结果；结果始终为 -`1`。因此，我们在
    while 循环操作中声明了一个 `resultSize` 变量来计数结果。
- en: Displaying information from a database in model view
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型视图中显示数据库信息
- en: 'Follow these steps to display information from a database on a model view widget:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在模型视图小部件上显示数据库信息：
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we will learn how to display multiple sets of data obtained
    from our SQL database in a model view in our program:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在程序中的模型视图中显示从我们的 SQL 数据库中获取的多组数据：
- en: 'We will be using the database table called `employee`, which we used in the
    previous example in *Creating a login screen with Qt*. This time, we need a lot
    more data in the employee table. Open up your **SQLiteStudio** control panel.
    Add data for a few more employees so that we can display it later in our program:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用名为 `employee` 的数据库表，这是我们之前在 *使用 Qt 创建登录界面* 的示例中使用的。这次，我们需要在员工表中添加更多的数据。打开你的
    **SQLiteStudio** 控制面板。为几个更多的员工添加数据，以便我们可以在程序中稍后显示：
- en: '![Figure 12.20 – Add more dummy data to the employee table](img/B20976_12_020.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.20 – 向员工表添加更多虚拟数据](img/B20976_12_020.jpg)'
- en: Figure 12.20 – Add more dummy data to the employee table
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20 – 向员工表添加更多虚拟数据
- en: Open Qt Creator, create a new **Qt Widgets Application** project, and then add
    the **SQL** module to your project.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Qt Creator，创建一个新的 **Qt Widgets Application** 项目，然后向你的项目添加 **SQL** 模块。
- en: 'Open `mainwindow.ui` and add a table widget (not a table view) from **Item
    Widget** (item-based) under the **Widget** box pane. Select the main window on
    the canvas and click on either the **Lay Out Vertically** or **Lay Out Horizontally**
    button to make the table widget stick to the size of the main window even when
    it’s resized:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 并从 **Widget**（基于项）下的 **Item Widget** 中添加一个表格小部件（不是表格视图）。在画布上选择主窗口，然后点击
    **Lay Out Vertically** 或 **Lay Out Horizontally** 按钮使表格小部件粘附到主窗口的大小，即使它被调整大小：
- en: '![Figure 12.21 – Click on the Lay Out Vertically button](img/B20976_12_021.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.21 – 点击“垂直布局”按钮](img/B20976_12_021.jpg)'
- en: Figure 12.21 – Click on the Lay Out Vertically button
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 – 点击“垂直布局”按钮
- en: 'Double-click on the table widget and a window will appear. Under the **Columns**
    tab, add five items by clicking on the **+** button in the top-left corner. Name
    the items **ID**, **Name**, **Age**, **Gender**, and **Married**. Click **OK**
    when you’re done:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击表格小部件，将出现一个窗口。在 **列** 选项卡下，通过点击左上角的 **+** 按钮添加五个项目。将项目命名为 **ID**、**Name**、**Age**、**Gender**
    和 **Married**。完成后点击 **OK**：
- en: '![Figure 12.22 – We also set the text alignment to center](img/B20976_12_022.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.22 – 我们还设置了文本居中对齐](img/B20976_12_022.jpg)'
- en: Figure 12.22 – We also set the text alignment to center
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 – 我们还设置了文本居中对齐
- en: Right-click on the table widget and select `itemChanged(QTableWidgetItem*)`
    option in the pop-up window, and press **OK**. A slot function will be created
    in both of your source files.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击表格小部件，在弹出窗口中选择 `itemChanged(QTableWidgetItem*)` 选项，然后按 **OK**。将在两个源文件中创建一个槽函数。
- en: 'Open `mainwindow.h` and add these private variables to the `MainWindow` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.h` 并将这些私有变量添加到 `MainWindow` 类中：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#include <QtSql>'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QtSql>'
- en: '#include <QSqlDatabase>'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QSqlDatabase>'
- en: '#include <QSqlQuery>'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QSqlQuery>'
- en: '#include <QMessageBox>'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QMessageBox>'
- en: '#include <QDebug>'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QDebug>'
- en: '#include <QTableWidgetItem>'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <QTableWidgetItem>'
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open `mainwindow.cpp`; we’re going to write tons of code there. We need to
    declare what will happen when the program is started. Add the following code to
    the constructor of the `MainWindow` class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.cpp`；我们将在那里写大量的代码。我们需要声明程序启动时会发生什么。将以下代码添加到 `MainWindow` 类的构造函数中：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The SQL query code looks like this:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL 查询代码看起来像这样：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create several `QTableWidgetItem` objects:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建几个 `QTableWidgetItem` 对象：
- en: '[PRE30]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Move those objects to the table widget:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些对象移动到表格小部件中：
- en: '[PRE31]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare what will happen when an item of the table widget has been edited.
    Add the following code to the `on_tableWidget_itemChanged()` slot function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明当表格小部件的项被编辑时会发生什么。将以下代码添加到 `on_tableWidget_itemChanged()` 槽函数中：
- en: '[PRE32]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Close the database at the class destructor:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类析构函数中关闭数据库：
- en: '[PRE33]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you compile and run the example now, you should get something like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行示例，你应该会得到类似这样的结果：
- en: '![Figure 12.23 – We have created our own SQL editor](img/B20976_12_023.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23 – 我们已经创建了自己的 SQL 编辑器](img/B20976_12_023.jpg)'
- en: Figure 12.23 – We have created our own SQL editor
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23 – 我们已经创建了自己的 SQL 编辑器
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The table widget is similar to the one you see in spreadsheet applications such
    as **Microsoft Excel** and **OpenOffice Calc**. In contrast to other types of
    model viewers, such as list view or tree view, table view (or table widget) is
    a two-dimensional model viewer, which displays data in the form of rows and columns.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表小部件与你在类似 **Microsoft Excel** 和 **OpenOffice Calc** 这样的电子表格应用中看到的小部件类似。与其他类型的模型查看器，如列表视图或树形视图相比，表格视图（或表小部件）是一个二维模型查看器，它以行和列的形式显示数据。
- en: The main difference between a table view and a table widget in Qt is that a
    table widget is built on top of a table view class, which means a table widget
    is easier to use and more suitable for beginners. However, a table widget is less
    flexible and tends to be less scalable than a table view, which is not the best
    choice if you want to customize your table. After retrieving data from SQLite,
    we created a `QTableWidgetItem` item for each of the data items and set which
    column and row should be added to the table widget. Before adding an item to the
    table widget, we must increase the row count of the table by calling `QTableWidget::setRowCount()`.
    We can also get the current row count of the table widget by simply calling `QTableWidget::rowCount()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，表格视图与表格小部件的主要区别在于，表格小部件是建立在表格视图类之上的，这意味着表格小部件更容易使用，更适合初学者。然而，表格小部件不如表格视图灵活，并且往往不如表格视图可扩展，如果你想要自定义表格，这并不是最佳选择。在从
    SQLite 中检索数据后，我们为每个数据项创建了一个 `QTableWidgetItem` 项目，并设置了应该添加到表格小部件中的列和行。在将项目添加到表格小部件之前，我们必须通过调用
    `QTableWidget::setRowCount()` 来增加表格的行数。我们也可以通过简单地调用 `QTableWidget::rowCount()`
    来获取表格小部件的当前行数。
- en: The first column from the left is hidden from view because we only use it to
    save the ID of the data so that we can use it to update the database when one
    of the data items in its row has changed. The `on_tableWidget_itemChanged()` slot
    function will be called when the data in one of the cells has changed. It will
    not only get called when you edit the data in the cell but also when the data
    are first added to the table after being retrieved from the database. To ensure
    that this function is only triggered when we edit the data, we use a Boolean variable
    called `hasInit` to check whether we have done the initialization process (adding
    the first batch of data to the table). If `hasInit` is false, ignore the function
    call.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的列被隐藏起来，因为我们只使用它来保存数据的 ID，以便在行中的某个数据项发生变化时，我们可以用它来更新数据库。当其中一个单元格中的数据发生变化时，将调用
    `on_tableWidget_itemChanged()` 插槽函数。它不仅会在你编辑单元格中的数据时被调用，也会在从数据库检索后首次将数据添加到表格中时被调用。为了确保这个函数只在我们编辑数据时被触发，我们使用一个名为
    `hasInit` 的布尔变量来检查我们是否已经完成了初始化过程（将第一批数据添加到表格中）。如果 `hasInit` 为假，则忽略函数调用。
- en: To prevent users from entering a totally irrelevant type of data, such as inserting
    letters into a numerical-only data cell, we manually check whether the data are
    anything close to what we’d expected when they were being edited. Revert it to
    a default value if it doesn’t come close to anything considered valid. This is,
    of course, a simple hack, which does the job but is not the most professional
    method. Alternatively, you can try to create a new class that inherits the `QItemDelegate`
    class and defines how your model view should behave. Then, call `QTableWidget::setItemDelegate()`
    to apply the class to your table widget.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户输入完全无关的数据类型，例如在只允许数字的数据单元格中插入字母，我们手动检查在它们被编辑时数据是否接近我们期望的任何有效内容。如果不符合任何有效内容，则将其还原为默认值。这当然是一个简单的技巧，虽然它能完成任务，但不是最专业的方法。或者，你可以尝试创建一个新的类，该类继承自
    `QItemDelegate` 类，并定义你的模型视图应该如何行为。然后，通过调用 `QTableWidget::setItemDelegate()` 将该类应用到你的表格小部件上。
- en: Advanced SQL queries
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 SQL 查询
- en: By following this recipe, you will learn how to use advanced SQL statements
    such as `INNER` `JOIN`, `COUNT`, `LIKE`, and `DISTINCT`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个食谱，你将学习如何使用高级 SQL 语句，例如 `INNER` `JOIN`、`COUNT`、`LIKE` 和 `DISTINCT`。
- en: How to do it…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'You can do a lot more than just perform simple queries on the SQL database.
    Let’s follow these steps to learn how:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 SQL 数据库上执行的操作远不止简单的查询。让我们遵循以下步骤来学习如何：
- en: 'We need to add a few tables to our database before we can dive into the programming
    part. Open your **SQLiteStudio**. We need several tables for this example to work:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以进入编程部分之前，我们需要在我们的数据库中添加几个表。打开你的 **SQLiteStudio**。为了使这个示例正常工作，我们需要几个表：
- en: '![Figure 12.24 – Additional tables that we need to create for this example](img/B20976_12_024.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.24 – 我们需要为这个示例创建的附加表](img/B20976_12_024.jpg)'
- en: Figure 12.24 – Additional tables that we need to create for this example
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24 – 我们需要为这个例子创建的附加表
- en: 'I will show you the structure of each of the tables required for this project
    and the dummy data inserted into the tables for testing. The first table is called
    `branch`, which is used to store the IDs and names of different branches of the
    dummy company:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将向您展示本项目中所需每个表的架构以及为测试插入到表中的虚构数据。第一个表称为 `branch`，用于存储虚构公司不同分支的 ID 和名称：
- en: '![Figure 12.25 – The branch table](img/B20976_12_025.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.25 – 分支表](img/B20976_12_025.jpg)'
- en: Figure 12.25 – The branch table
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.25 – 分支表
- en: 'Secondly, we have the `department` table, which stores the IDs and names of
    different departments of the dummy company, which is also linked to the `branch`
    data by the branch IDs:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们有 `department` 表，它存储了虚构公司不同部门的 ID 和名称，这些部门通过分支 ID 与 `branch` 数据相链接：
- en: '![Figure 12.26 – The department table, which links to the branch table](img/B20976_12_026.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.26 – 部门表，它与分支表相链接](img/B20976_12_026.jpg)'
- en: Figure 12.26 – The department table, which links to the branch table
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26 – 部门表，它与分支表相链接
- en: 'We also have an `employee` table, which stores information on all the employees
    in the dummy company. This table is similar to the one we used in the previous
    examples, except it has two extra columns, `emp_birthday` and `emp_departmentID`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个 `employee` 表，它存储了虚构公司中所有员工的信息。这个表与我们在前面的例子中使用过的表类似，但它有两个额外的列，`emp_birthday`
    和 `emp_departmentID`：
- en: '![Figure 12.27 – The employee table, which links to the department table](img/B20976_12_027.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.27 – 员工表，它与部门表相链接](img/B20976_12_027.jpg)'
- en: Figure 12.27 – The employee table, which links to the department table
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27 – 员工表，它与部门表相链接
- en: 'We also have a table called `log`, which contains dummy records of the login
    time for each employee. `log_loginTime` will be set as a date-time variable type:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `log` 的表，其中包含每个员工登录时间的虚构记录。`log_loginTime` 将被设置为日期时间变量类型：
- en: '![Figure 12.28 – The log table, which links to the user table](img/B20976_12_028.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.28 – 日志表，它与用户表相链接](img/B20976_12_028.jpg)'
- en: Figure 12.28 – The log table, which links to the user table
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.28 – 日志表，它与用户表相链接
- en: 'We have the `user` table that we also used in the previous examples:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有 `user` 表，我们也在前面的例子中使用过：
- en: '![Figure 12.29 – The user table](img/B20976_12_029.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.29 – 用户表](img/B20976_12_029.jpg)'
- en: Figure 12.29 – The user table
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29 – 用户表
- en: 'Open Qt Creator. This time, instead of choosing **Qt Widgets Application**,
    we select **Qt** **Console Application**:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Qt Creator。这次，我们不是选择 **Qt Widgets Application**，而是选择 **Qt** **Console Application**：
- en: '![Figure 12.30 – Create a Qt Console Application project](img/B20976_12_030.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.30 – 创建 Qt 控制台应用程序项目](img/B20976_12_030.jpg)'
- en: Figure 12.30 – Create a Qt Console Application project
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.30 – 创建 Qt 控制台应用程序项目
- en: 'Open your project file (.pro) and add the `sql` module to your project:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目文件 (.pro) 并将 `sql` 模块添加到你的项目中：
- en: '[PRE34]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#include <QSqlDatabase>'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QSqlDatabase>`'
- en: '#include <QSqlQuery>'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QSqlQuery>`'
- en: '#include <QSqlError>'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QSqlError>`'
- en: '#include <QDate>'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QDate>`'
- en: '#include <QDebug>'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QDebug>`'
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following function to display employees who are more than 30 years
    old:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数以显示年龄超过 30 岁的员工：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following function to display the `department` and `branch` information
    of each employee:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数以显示每个员工的 `department` 和 `branch` 信息：
- en: '[PRE37]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following function, which displays employees who are working in the
    New York branch and are under 40 years old:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，用于显示在纽约分支工作且年龄低于 40 岁的员工：
- en: '[PRE38]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following function, which counts the total number of female employees
    in the dummy company:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，用于计算虚构公司中女性员工的总数：
- en: '[PRE39]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following function, which filters the employee list and only displays
    those names that start with `Ja`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，用于过滤员工列表并仅显示以 `Ja` 开头的名字：
- en: '[PRE40]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following function, which displays employees who have birthdays in
    August:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，用于显示八月份生日的员工：
- en: '[PRE41]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following function, which checks who logged into the dummy system on
    27 April 2024 and displays their names on the terminal:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，用于检查谁在 2024 年 4 月 27 日登录了虚构系统，并在终端上显示他们的名字：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `main()` function, connect the program to the SQLite database and call
    all the functions that we defined in the previous steps. Close the database connection,
    and we’re done:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，将程序连接到 SQLite 数据库并调用我们在前面步骤中定义的所有函数。关闭数据库连接，任务完成：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you compile and run the project now, you should see a terminal window that
    displays the filtered results:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行项目，你应该会看到一个显示过滤结果的终端窗口：
- en: '![Figure 12.31 – Printing the results on the Application Output window](img/B20976_12_031.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图12.31 – 在应用程序输出窗口中打印结果](img/B20976_12_031.jpg)'
- en: Figure 12.31 – Printing the results on the Application Output window
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 – 在应用程序输出窗口中打印结果
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A console application does not have a GUI and only shows you a text display
    in a terminal window. This is usually used in a backend system, as it uses fewer
    resources compared to a widget application. We used it in this example because
    it’s faster to display the result without the need to place any widgets in the
    program, which we don’t need in this case.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序没有 GUI，只在一个终端窗口中显示文本显示。这通常用于后端系统，因为它与使用小部件的应用程序相比，使用的资源更少。我们在这个例子中使用它是因为它更快地显示结果，无需在程序中放置任何小部件，而这在本例中是不需要的。
- en: We separated the SQL queries into different functions so that it’s easier to
    maintain the code and it doesn’t become too messy. Do note that in C++, the functions
    have to be located before the `main()` function; otherwise, they will not be able
    to be called by `main()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 SQL 查询分成了不同的函数，这样更容易维护代码，并且不会变得过于杂乱。请注意，在 C++ 中，函数必须位于 `main()` 函数之前；否则，它们将无法被
    `main()` 函数调用。
- en: There’s more…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `INNER JOIN` statement used in the preceding example joins two tables together
    and selects all rows from both tables, as long as there is a match between the
    columns in both tables. There are many other types of `JOIN` statements that you
    can use in SQLite (and some other types of SQL architecture), such as `LEFT JOIN`,
    `RIGHT JOIN`, and `FULL` `OUTER JOIN`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中使用的 `INNER JOIN` 语句将两个表连接起来，并选择两个表中的所有行，只要两个表中的列之间存在匹配即可。在 SQLite（以及一些其他类型的
    SQL 架构）中，你可以使用许多其他类型的 `JOIN` 语句，例如 `LEFT JOIN`、`RIGHT JOIN` 和 `FULL OUTER JOIN`。
- en: 'The following diagram shows the different types of `JOIN` statements and their
    effects:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了不同类型的 `JOIN` 语句及其效果：
- en: '![Figure 12.32 – Different types of JOIN statements](img/B20976_12_032.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图12.32 – 不同类型的 JOIN 语句](img/B20976_12_032.jpg)'
- en: Figure 12.32 – Different types of JOIN statements
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 – 不同类型的 JOIN 语句
- en: 'The following bullet points explain the `LIKE` and `DISTINCT` statements, which
    we used in our example code in this recipe:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目符号解释了我们在本食谱示例代码中使用的 `LIKE` 和 `DISTINCT` 语句：
- en: The `LIKE` statement is normally used to search for a string variable in the
    database without the full word. Notice that there are two % symbols located before
    and after the search keyword.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIKE` 语句通常用于在数据库中搜索不包含完整单词的字符串变量。请注意，在搜索关键字前后各有一个 % 符号。'
- en: The `DISTINCT` statement used in the previous example filters out results that
    have the exact same variable. For example, without the `DISTINCT` statement, you
    will see two versions of Larry King appear in the terminal because there are two
    records of him logging into the system on the same day. By adding the `DISTINCT`
    statement, SQLite will eliminate one of the results and ensure every result is
    unique.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的示例中使用的 `DISTINCT` 语句过滤掉了具有完全相同变量的结果。例如，如果没有使用 `DISTINCT` 语句，你将在终端中看到两个版本的拉里·金，因为他在同一天登录系统的记录有两条。通过添加
    `DISTINCT` 语句，SQLite 将消除其中一个结果，并确保每个结果都是唯一的。
- en: You may be wondering what `d-MMMM-yyyy` stands for and why we used it in the
    preceding example. That is actually an expression supplied to the `QDateTime`
    class in Qt to display the date-time result using a given format. In this case,
    it will change the date-time data that we get from SQLite, 2024-08-06, to the
    format that we specified, resulting in 6-August-2024.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想知道 `d-MMMM-yyyy` 代表什么，以及为什么我们在前面的示例中使用它。这实际上是一个提供给 Qt 中的 `QDateTime` 类的表达式，用于使用给定格式显示日期时间结果。在这种情况下，它将我们从
    SQLite 获取的日期时间数据，2024-08-06，转换为指定的格式，结果为 6-August-2024。
- en: For more information, check out Qt’s documentation at [http://doc.qt.io/qt-6/qdatetime.html#toString](http://doc.qt.io/qt-6/qdatetime.html#toString),
    which has the full list of expressions that can be used to determine the format
    of the date and time string.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 Qt 的文档[http://doc.qt.io/qt-6/qdatetime.html#toString](http://doc.qt.io/qt-6/qdatetime.html#toString)，其中包含可以用来确定日期时间字符串格式的完整表达式列表。
- en: SQL provides an easy and efficient way to save and load user data without reinventing
    the wheel. Qt provides you with an out-of-the-box solution for connecting your
    application with a SQL database; in this chapter, we have learned how to do this
    by using a step-by-step approach, and we were able to load and save our user’s
    data into the SQL database.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: SQL提供了一种简单高效的方法来保存和加载用户数据，无需重新发明轮子。Qt为您提供了一个现成的解决方案，用于将您的应用程序与SQL数据库连接；在本章中，我们通过逐步的方法学习了如何实现这一点，并且能够将我们的用户数据加载和保存到SQL数据库中。
