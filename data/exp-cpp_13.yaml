- en: Designing a Strategy Game Using Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设计模式设计策略游戏
- en: Game development is one of the most interesting topics in software engineering.
    C++ is extensively used in game development because of its efficiency. However,
    since the language doesn't have GUI components, it's used on the backend. In this
    chapter, we will learn how to design a strategy game on the backend. We will incorporate
    almost everything that we've learned in previous chapters, including design patterns
    and multithreading.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发是软件工程中最有趣的话题之一。C++在游戏开发中被广泛使用，因为它的效率。然而，由于该语言没有GUI组件，因此它被用于后端。在本章中，我们将学习如何在后端设计策略游戏。我们将整合几乎所有我们在之前章节中学到的内容，包括设计模式和多线程。
- en: The game that we will design is a strategy game called **Readers and Disturbers**.
    Here, the player creates units, known as readers, who are able to build libraries
    and other buildings, and soldiers, who are defending those buildings from the
    enemy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计的游戏是一个名为**读者和扰乱者**的策略游戏。在这里，玩家创建单位，称为读者，他们能够建造图书馆和其他建筑物，以及士兵，他们保卫这些建筑物免受敌人的攻击。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to game design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计简介
- en: Diving into the process of game design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入游戏设计的过程
- en: Using design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设计模式
- en: Designing the game loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计游戏循环
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the `-std=c++2a` option will be used to compile the examples
    throughout this chapter. You can find the source files that will be used throughout
    this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，将使用带有`-std=c++2a`选项的g++编译器来编译示例。您可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章中将使用的源文件。
- en: Introduction to game design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计简介
- en: In this chapter, we will design the backend of a strategy game where the player
    can create units (workers, soldiers), build buildings, and fight the enemy. Whenever
    you design a game, whether it's a strategy game or a first-person shooter, there
    are several fundamental components that are the same, such as game physics, which
    are used to make the game feel more real and immersive to the player.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计一个策略游戏的后端，玩家可以创建单位（工人、士兵）、建造建筑物，并与敌人战斗。无论您设计的是策略游戏还是第一人称射击游戏，都有一些基本组件是相同的，例如游戏物理，用于使游戏对玩家更真实和沉浸。
- en: There are components in game design that are repeated in almost all games, such
    as collision detection mechanisms, the audio system, graphics rendering, and so
    on. When designing a game, we can either distinguish between the engine and the
    game or develop a strongly tied application representing both the engine and the
    game as a single outcome. Designing the game engine separately allows it to be
    extended for further releases and even used for other games. After all, games
    have the same mechanics and the same flow. They differ mostly by in their plotline.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有游戏中都有一些重复的游戏设计组件，例如碰撞检测机制、音频系统、图形渲染等。在设计游戏时，我们可以区分引擎和游戏，或者开发一个紧密联系的应用程序，代表引擎和游戏作为一个单一的结果。将游戏引擎单独设计允许它在后续版本中进行扩展，甚至用于其他游戏。毕竟，游戏具有相同的机制和相同的流程。它们主要通过情节线有所不同。
- en: When designing a game engine, you should carefully plan the types of game that
    will be designed using the engine. Though most fundamental features are the same.
    independent of the game type, there are distinctions for a 3D shooter and, for
    example, a strategy game. In a strategy game, the player strategically deploys
    units across a large playing field. The game world is displayed from a top-down
    viewing angle.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计游戏引擎时，您应该仔细规划将使用引擎设计的游戏类型。虽然大多数基本功能是相同的，独立于游戏类型，但在3D射击游戏和策略游戏中有区别。在策略游戏中，玩家会在一个大的游戏场地上进行单位的战略部署。游戏世界是从俯视角度显示的。
- en: Introduction to the Readers and Disturbers game
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者和扰乱者游戏简介
- en: 'The basic idea of the game is simple: the player has a limited set of resources.
    Those resources can be used to create buildings for game characters. We name the
    character units, which are divided into readers and soldiers. The Readers are
    smart characters who build libraries and other buildings. Each built library can
    host up to 10 readers. If the player moves 10 readers into the library, after
    a specified amount of time, the library produces one professor. A professor is
    a powerful unit that can destroy three enemy soldiers at once. A professor can
    create better weapons for the player''s soldiers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的基本理念很简单：玩家拥有有限的资源。这些资源可以用来为游戏角色创建建筑物。我们称这些角色单位，分为读者和士兵。读者是聪明的角色，他们建造图书馆和其他建筑物。每个建成的图书馆可以容纳多达10名读者。如果玩家将10名读者移入图书馆，经过一定时间后，图书馆会产生一名教授。教授是一个强大的单位，可以一次摧毁三名敌方士兵。教授可以为玩家的士兵制造更好的武器。
- en: The game starts with a single house already built, two soldiers, and three readers.
    A house produces a new reader every 5 minutes. Readers can build new houses, which
    then produce more readers. They can also build barracks that produce soldiers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从一个已建好的房子开始，有两名士兵和三名读者。房子每5分钟产生一个新的读者。读者可以建造新的房子，然后产生更多的读者。他们还可以建造兵营，生产士兵。
- en: 'The goal of the player is to build five libraries, each of which has produced
    at least one professor. The player has to defend his/her buildings and readers
    from the enemy during the game. Enemies are called **disturbers** because their
    goal is to disturb readers from their main goal: studying inside the libraries.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的目标是建造五座图书馆，每座图书馆至少产生一名教授。玩家在游戏过程中必须保卫自己的建筑物和读者免受敌人的攻击。敌人被称为**扰乱者**，因为他们的目标是打扰读者的主要目标：在图书馆里学习。
- en: Strategy game components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略游戏组件
- en: As we mentioned previously, our strategy game will comprise basic components –
    readers and soldiers (we'll refer to them as units), buildings, and a map. The
    game map contains coordinates for each object in the game. We will discuss a lighter
    version of a game map. Now, let's leverage our project-designing skills to decompose
    the game itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们的策略游戏将包括基本组件-读者和士兵（我们将称它们为单位），建筑物和地图。游戏地图包含游戏中每个对象的坐标。我们将讨论游戏地图的简化版本。现在，让我们利用我们的项目设计技能来分解游戏本身。
- en: 'The game consists of the following character units:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏包括以下角色单位：
- en: A reader
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一位读者
- en: A soldier
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一名士兵
- en: A professor
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一位教授
- en: 'It also consists of the following buildings:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括以下建筑：
- en: A library
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一座图书馆
- en: A house
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一座房子
- en: A barrack
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一座兵营
- en: 'Now, let''s discuss the properties for each component of the game. A game character
    has the following properties:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论游戏的每个组件的属性。游戏角色具有以下属性：
- en: Life points (an integer, which decreases after each attack from the enemy)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命点数（一个整数，在每次来自敌方的攻击后减少）
- en: Power (an integer, which defines the amount of damage a unit can cause to enemy
    units)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力量（一个整数，定义单位对敌方单位造成的伤害量）
- en: Type (a reader, a soldier, or a professor)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型（读者，士兵或教授）
- en: The life property should have an initial value based on the type of the unit.
    For example, a reader's initial life points are 10, whereas a soldier's life points
    are 12\. When interacting in the game, all of the units might be attacked by enemy
    units. Each attack is described as a decrease in life points. The amount we will
    decrease the life points by is based on the value of the power of the attacker.
    For example, the power of a soldier is set to three, which means each attack that's
    made by a soldier will decrease the victim's life points by three. When the victim's
    life points become zero, the character unit will be destroyed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 生命属性应该有一个基于单位类型的初始值。例如，读者的初始生命点数为10，而士兵的生命点数为12。在游戏中互动时，所有单位都可能受到敌方单位的攻击。每次攻击都被描述为生命点数的减少。我们减少生命点数的数量取决于攻击者的力量值。例如，士兵的力量值设定为3，这意味着士兵发动的每次攻击都会使受害者的生命点数减少3。当受害者的生命点数变为零时，角色单位将被摧毁。
- en: 'The same goes for buildings. A building has a construction duration that it
    will be completely built by. A complete building also has life points, and any
    damage caused to the building by enemy forces will decrease these life points.
    The following is the full list of building properties:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑物也是如此。建筑物有一个完全建成的建造持续时间。完整的建筑物也有生命点数，敌方部队造成的任何损害都会减少这些生命点数。以下是建筑物属性的完整列表：
- en: Life points
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命点数
- en: Type
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Construction duration
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造持续时间
- en: Unit production duration
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位生产持续时间
- en: The unit production duration is the amount of time it takes for a new character
    unit to be produced. For example, a barrack produces a soldier every 3 minutes,
    a house produces a reader every 5 minutes, and a library produces a professor
    from 10 readers instantly when the last missing reader goes inside the library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单位生产持续时间是生产新角色单位所需的时间。例如，一个兵营每3分钟生产一个士兵，一座房子每5分钟生产一个读者，一座图书馆在最后一个缺失的读者进入图书馆时立即产生一名教授。
- en: Now that we've defined the game components, let's discuss the interaction between
    them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了游戏组件，让我们讨论它们之间的互动。
- en: Interaction between the components
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件之间的互动
- en: 'The next important thing in the design of the Readers and Disturbers game is
    the interaction between the characters. We already mentioned that readers can
    build buildings. In the game, this process should be taken care of because each
    type of building has its duration of construction. Therefore, if a reader is busy
    with the building process, we should measure the time to make sure the building
    will be ready after a specified time. However, to make the game even better, we
    should take into account that more than one reader can take part in the process
    of construction. This should make constructing a building faster. For example,
    if a barrack is built in 5 minutes by one reader, then it should be built in 2
    and a half minutes by two readers, and so on. This is one example of complex interactions
    in the game and can be depicted with the following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 读者和扰乱者游戏设计中的下一个重要事项是角色之间的互动。我们已经提到读者可以建造建筑物。在游戏中，这个过程应该得到照顾，因为每种类型的建筑都有其建造持续时间。因此，如果读者忙于建筑过程，我们应该测量时间，以确保建筑物在指定时间后准备好。然而，为了使游戏变得更好，我们应该考虑到不止一个读者可以参与建筑过程。这应该使建筑物的建造速度更快。例如，如果一名读者在5分钟内建造一座兵营，那么两名读者应该在2分半钟内建造一座兵营，依此类推。这是游戏中复杂互动的一个例子，并可以用以下图表来描述：
- en: '![](img/e52d3229-e4d3-4f13-b697-607876bc466e.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e52d3229-e4d3-4f13-b697-607876bc466e.png)'
- en: Complex interaction
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂互动
- en: 'Next comes the attack handling. When one unit is attacked by enemies, we should
    decrease the defendant''s life points. The defendant itself could attack the attacker
    (to defend itself). Whenever there is more than one attacker or defender, we should
    correspondingly handle how the life points of each attacked unit decrease. We
    should also define the duration of each hit by the unit. A unit shouldn''t hit
    another very fast. To make things a bit more natural, we might introduce a 1 second
    or 2 second pause between each hit. The following diagram depicts a simple attack
    interaction. This will be replaced with a class interaction diagram later in this
    chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是攻击处理。当一个单位受到敌人的攻击时，我们应该减少被告的生命点数。被告本身可以攻击攻击者（为了自卫）。每当有多个攻击者或被告时，我们应该相应地处理每个受攻击单位的生命点数减少。我们还应该定义每个单位的攻击持续时间。一个单位不应该很快地攻击另一个单位。为了使事情更加自然，我们可以在每次攻击之间引入1秒或2秒的暂停。以下图表描述了简单的攻击互动。这将在本章后面用类互动图表替换：
- en: '![](img/888a94bb-3bb8-4339-abab-f453c0a64778.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888a94bb-3bb8-4339-abab-f453c0a64778.png)'
- en: Simple attack interaction
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单攻击互动
- en: An even bigger interaction is happening in the game in general. There are two
    groups in the game, one of which is controlled by the player. The other one is
    automatically controlled by the game itself. That means that we, as the game designers,
    are obliged to define the life cycle of the enemy forces. The game will automatically
    create readers who will be assigned the tasks of creating libraries, barracks,
    and houses. Each soldier should take responsibility for defending the buildings
    and readers (the people). And from time to time, soldiers should group together
    and go on an attack mission.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中发生了更大的互动。游戏中有两个组，其中一个由玩家控制，另一个由游戏自动控制。这意味着我们作为游戏设计者有责任定义敌方力量的生命周期。游戏将自动创建读者，他们将被分配创建图书馆、兵营和房屋的任务。每个士兵都应该负责保卫建筑和读者（人们）。而士兵们也应该不时地组成小组进行进攻任务。
- en: 'We will be designing a platform that lets the player create an empire; however,
    the game should also create the enemy to make the game complete. The player will
    face regular attacks from the enemy, and the enemy will evolve by constructing
    more buildings and producing more units. Overall, we can depict the interaction
    using the following diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个平台，让玩家创建一个帝国；然而，游戏也应该创建敌人以使游戏完整。玩家将面临来自敌人的定期攻击，而敌人将通过建造更多建筑和生产更多单位来发展。总的来说，我们可以用以下图表来描述这种互动：
- en: '![](img/e4dd9522-8e38-463f-855d-946467b87157.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4dd9522-8e38-463f-855d-946467b87157.png)'
- en: Illustration between the player and the automated player
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家和自动玩家之间的互动
- en: We will refer to the preceding diagram regularly while designing the game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计游戏时，我们将经常参考上述类图。
- en: Designing the game
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏
- en: Though a game is not a typical piece of software, its design doesn't differ
    much from regular application design. We will start with the main entities and
    decompose them further into classes and their relationships.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然游戏不是典型的软件，但其设计与常规应用程序设计并无太大不同。我们将从主要实体开始，并进一步分解为类及其关系。
- en: In the previous section, we discussed all the necessary game components and
    their interaction. We did a requirement analysis and gathering in terms of the
    project development life cycle. Now, we'll start designing the game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了所有必要的游戏组件及其交互。我们进行了项目开发生命周期的需求分析和收集。现在，我们将开始设计游戏。
- en: Designing character units
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计角色单位
- en: 'The following class diagram represents a reader:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图表示了一个读者：
- en: '![](img/b494e5af-c72e-493b-bd01-f51ffc39c83b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b494e5af-c72e-493b-bd01-f51ffc39c83b.png)'
- en: 'As we go through the other character units, we will come up with a base class
    for each character unit. Each specific unit will inherit from that base class
    and will add its specific properties, if any. Here''s the complete class diagram
    for character units:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们浏览其他角色单位时，我们将为每个角色单位创建一个基类。每个特定单位将继承自该基类，并添加其特定的属性（如果有）。以下是角色单位的完整类图：
- en: '![](img/98c96e09-c293-4218-a3dc-f4f5e713e7a5.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98c96e09-c293-4218-a3dc-f4f5e713e7a5.png)'
- en: 'Pay attention to the base class – it''s an interface rather than a regular
    class. It defines pure virtual functions to be implemented in derived classes.
    Here''s what the `CharacterUnit` interface looks like in code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意基类-它是一个接口，而不是一个常规类。它定义了要在派生类中实现的纯虚函数。以下是代码中`CharacterUnit`接口的样子：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `attack()` method decreases the life points of the character, while `destroy()`
    destroys the character. Destroying means not only removing the character from
    the scene but also stopping all the interactions that the unit has in progress
    (such as constructing buildings, defending itself, and so on).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`attack()`方法减少角色的生命点数，而`destroy()`摧毁角色。摧毁意味着不仅从场景中移除角色，还停止了单位正在进行的所有交互（如建筑建造、自卫等）。'
- en: 'The derived classes provide an implementation for the pure virtual functions
    of the `CharacterUnit` interface class. Let''s take a look at the code for the
    `Reader` character unit:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类为`CharacterUnit`接口类的纯虚函数提供了实现。让我们来看一下`Reader`角色单位的代码：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can create `Reader` units by declaring them in any of the following
    ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下任何一种方式声明`Reader`单位：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will mostly refer to character units by their base interface class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要通过它们的基接口类来引用角色单位。
- en: Pay attention to the copy constructor and the assignment operators. We intentionally
    marked them as deleted because we don't want to create units by copying others.
    We will use the `Prototype` pattern for that behavior. This will be discussed
    later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意复制构造函数和赋值运算符。我们故意将它们标记为删除，因为我们不希望通过复制其他单位来创建单位。我们将使用`Prototype`模式来实现这一行为。这将在本章后面讨论。
- en: 'Having the `CharacterUnit` interface is crucial in scenarios where we should
    do the same thing for different types of unit. For example, suppose that we have
    to calculate the complete damage that two soldiers, one reader, and a professor
    can cause to a building. Instead of keeping three different references to refer
    to three different types of unit, we are free to refer to them all as `CharacterUnits`.
    Here''s how:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要对不同类型的单位执行相同操作的情况下，具有`CharacterUnit`接口至关重要。例如，假设我们需要计算两名士兵、一名读者和一名教授对建筑物造成的完整伤害。我们可以自由地将它们都称为`CharacterUnits`，而不是保留三个不同的引用来引用三种不同类型的单位。以下是具体操作：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `calculate_damage()` function abstracts from unit types; it doesn't care
    about readers or soldiers. It just calls the `get_power()` method of the `CharacterUnit`
    interface, which is guaranteed to have an implementation for the specific object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_damage()`函数抽象出了单位类型；它不关心读者或士兵。它只调用`CharacterUnit`接口的`get_power()`方法，这个方法保证了特定对象的实现。'
- en: We will update character unit classes as we go. Now, let's move on to designing
    classes for buildings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着进展，我们将更新角色单位类。现在，让我们继续设计建筑物的类。
- en: Designing buildings
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计建筑物
- en: 'Classes for buildings are similar to character units in terms of their common
    interface. For example, we can start by defining the class for a house as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑类与角色单位类似，具有共同的接口。例如，我们可以从以下定义房屋类开始：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we use `std::chrono::duration` to keep a time interval for the `House`
    construction duration. It is defined in the `<chrono>` header as a number of ticks
    and a tick period, where the tick period is the number of seconds from one tick
    to the next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`std::chrono::duration`来保持`House`施工持续时间的时间间隔。它在`<chrono>`头文件中定义为一定数量的滴答和滴答周期，其中滴答周期是从一个滴答到下一个滴答的秒数。
- en: 'The `House` class needs more details, but we will soon come to the realization
    that we need a base interface (or even an abstract class) for all the buildings.
    The buildings that will be described in this chapter share certain behaviors.
    The interface for `Building` is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`House`类需要更多细节，但我们很快会意识到我们需要一个所有建筑的基本接口（甚至是一个抽象类）。本章将描述的建筑共享某些行为。`Building`的接口如下：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the `I` prefix in front of `Building`. Many developers suggest using a
    prefix or postfix for interface classes for better readability. For example, `Building`
    might have been named `IBuilding` or `BuildingInterface`. We will use the same
    naming technique for the previously described `CharacterUnit`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Building`前面的`I`前缀。许多开发人员建议为接口类使用前缀或后缀以提高可读性。例如，`Building`可能已被命名为`IBuilding`或`BuildingInterface`。我们将对先前描述的`CharacterUnit`使用相同的命名技术。
- en: 'The `House`, `Barrack`, and `Library` classes implement the `IBuilding` interface
    and must provide implementations for pure virtual methods. For example, the `Barrack` class
    will look as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`House`、`Barrack`和`Library`类实现了`IBuilding`接口，并且必须为纯虚方法提供实现。例如，`Barrack`类将如下所示：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's discuss the construction duration implementation in more detail, At this
    point, `std::chrono::` duration point, kept as a reminder to us that the construction
    should take a specified amount of time. Also, note that the final design of classes
    might change over the course of this chapter. Now, let's find out how will we
    make the components of the game interact with each other.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论施工持续时间的实现。在这一点上，`std::chrono::`持续时间点，作为一个提醒，告诉我们施工应该需要指定的时间。还要注意，类的最终设计可能会在本章的过程中发生变化。现在，让我们找出游戏组件如何相互交互。
- en: Designing game controllers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏控制器
- en: Designing classes for character units and buildings is just the first step in
    designing the game itself. One of the most important things in the game is designing
    the interaction between those components. We should carefully analyze and design
    cases such as two or more characters constructing a building. We already introduced
    a construction time for a building, but we didn't take into account that a building
    might be constructed by more than one reader (the character unit that can build
    buildings).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为角色单位和建筑设计类只是设计游戏本身的第一步。游戏中最重要的事情之一是设计这些组件之间的交互。我们应该仔细分析和设计诸如两个或更多角色建造一个建筑的情况。我们已经为建筑引入了施工时间，但我们没有考虑到一个建筑可能由多个读者（可以建造建筑的角色单位）来建造。
- en: We could say that a building built by two readers should be built twice as fast
    than when it's built by one reader. And if another reader joins the construction,
    we should recalculate the duration. However, we should limit the number of readers
    that can work on constructing the same building.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，由两个读者建造的建筑应该比一个读者建造的建筑快两倍。如果另一个读者加入建设，我们应该重新计算持续时间。然而，我们应该限制可以在同一建筑上工作的读者数量。
- en: If any of the readers get attacked by the enemy, that should disturb the reader
    from building so that they can concentrate on self-defense. When a reader stops
    working on the building, we should recalculate the construction time again. The
    attack is another case that's similar to the building. When a character gets attacked,
    it should defend itself by fighting back. Each hit will decrease the character's
    life points. A character might be attacked by more than one enemy character at
    the same time. That will decrease their life points even faster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何读者受到敌人的攻击，那应该打扰读者建造，以便他们可以集中精力进行自卫。当一个读者停止在建筑上工作时，我们应该重新计算施工时间。攻击是另一种类似于建筑的情况。当一个角色受到攻击时，它应该通过反击来进行自卫。每次攻击都会减少角色的生命值。一个角色可能会同时受到多个敌方角色的攻击。这将更快地减少他们的生命值。
- en: A building has a timer because it produces a character periodically. The most
    important thing to design is the game dynamics – that is, the loop. At each specified
    time frame, something happens in the game. This can be enemy soldiers approaching,
    the character units building something, or anything else. The execution of an
    action is not strictly tied to the finishing of another unrelated action. This
    means that the construction of a building happens concurrently with the creation
    of a character. Unlike most applications, the game should keep moving, even if
    the user didn't provide any input. The game doesn't freeze if the player fails
    to perform an action. The character units might wait for a command, but the buildings
    will be continuously doing their job – producing new characters. Also, the enemy
    player (the automated one) strives for victory and never pauses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑有一个计时器，因为它会周期性地产生角色。设计最重要的是游戏动态-也就是循环。在每个指定的时间段，游戏中会发生一些事情。这可能是敌人士兵的接近，角色单位建造某物，或其他任何事情。一个动作的执行并不严格地与另一个无关的动作的完成相关。这意味着建筑的施工与角色的创建同时进行。与大多数应用程序不同，即使用户没有提供任何输入，游戏也应该保持运行。如果玩家未执行任何操作，游戏不会冻结。角色单位可能会等待命令，但建筑将不断地完成它们的工作-生产新的角色。此外，敌方玩家（自动化的）力求胜利，从不停顿。
- en: Concurrent actions
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发动作
- en: Many actions in the game happen concurrently. As we've just discussed, the construction
    of buildings should not stop because a unit that is not involved in the construction
    gets attacked by the enemy. If the enemy attacks, a building should not stop producing
    new characters. This means we should design concurrent behavior for many of the
    objects in the game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的许多动作是同时发生的。正如我们刚才讨论的，建筑的建造不应该因为一个没有参与建造的单位被敌人攻击而停止。如果敌人发动攻击，建筑也不应该停止生产新角色。这意味着我们应该为游戏中的许多对象设计并发行为。
- en: 'One of the best ways to achieve concurrency in C++ is using threads. We can
    redesign the units and buildings so that they include an overridable action in
    their base class that will be executed in a separate thread. Let''s redesign `IBuilding`
    so that it''s an abstract class that has an additional `run()` virtual function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中实现并发的最佳方法之一是使用线程。我们可以重新设计单位和建筑，使它们包括一个可以在其基类中重写的动作，该动作将在单独的线程中执行。让我们重新设计`IBuilding`，使其成为一个抽象类，其中包含一个额外的`run()`虚函数：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pay attention to the `background_action_()` function; it's private, but virtual.
    We can override it in derived classes. The `run()` function is not virtual; it
    runs the private implementation in a thread. Here, the derived classes might provide
    an implementation for the `background_action_()`. When a unit is assigned to construct
    the building, the `build()` virtual function is called. The `build()` function
    delegates the job of calculating the construction time to the `run()` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`background_action_()`函数；它是私有的，但是虚的。我们可以在派生类中重写它。`run()`函数不是虚的；它在一个线程中运行私有实现。在这里，派生类可以为`background_action_()`提供一个实现。当一个单位被分配来建造建筑时，将调用`build()`虚函数。`build()`函数将计算建造时间的工作委托给`run()`函数。
- en: The game event loop
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏事件循环
- en: 'The simplest approach to this problem is defining an event loop. An event loop
    looks as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是定义一个事件循环。事件循环如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even if there is no action from the user (the player), the game still goes on
    by calling the `updateGame()` function. Note that the preceding code is just a
    general introduction to the event loop. As you can see, it loops indefinitely
    and processes and updates the game on each iteration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户（玩家）没有任何操作，游戏仍会通过调用`updateGame()`函数继续进行。请注意，上述代码只是对事件循环的一般介绍。正如你所看到的，它会无限循环，并在每次迭代中处理和更新游戏。
- en: Each loop iteration advances the state of the game. If user action processing
    takes a long time, it might block the loop. The game will freeze for a moment.
    We usually measure the speed of the game in **frames per second** (**FPS**). The
    higher its value, the smoother the game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代都会推进游戏的状态。如果用户操作处理时间很长，可能会阻塞循环。游戏会短暂地冻结。我们通常用**每秒帧数**（**FPS**）来衡量游戏的速度。数值越高，游戏越流畅。
- en: We need to design the game loop that runs continuously during gameplay. It's
    important to design it in such a way that the user action processing won't block
    the loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计游戏循环，使其在游戏过程中持续运行。设计它的重要之处在于用户操作处理不会阻塞循环。
- en: The game loop takes care of everything happening in the game, including AI.
    By AI, we mean the automation of the enemy player we discussed previously. Other
    than that, the game loop handles the actions of characters, and building, and
    updates the state of the game accordingly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环负责游戏中发生的一切，包括AI。这里的AI指的是我们之前讨论过的敌方玩家的自动化。除此之外，游戏循环处理角色和建筑的动作，并相应地更新游戏的状态。
- en: Before diving into the game loop design, let's understand several design patterns
    that will help us in this complex task. After all, the game loop is another design
    pattern!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入游戏循环设计之前，让我们先了解一些设计模式，这些模式将帮助我们完成这个复杂的任务。毕竟，游戏循环本身也是一个设计模式！
- en: Using design patterns
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设计模式
- en: It's natural to design a game using the **object-oriented** **programming**
    (**OOP**) paradigm. After all, a game represents a combination of objects that
    intensively interact with each other. In our strategy game, we have buildings
    built by units. Units defend themselves from enemy units and so on. This inter-communication
    leads to the growth of complexity. As the project evolves and gains more features,
    it will become harder to support it. It's already obvious to us that designing
    is one of the most important (if not the most important) part of building projects.
    Incorporating design patterns will drastically improve both the design process
    and project support.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**面向对象**（**OOP**）**编程**范式来设计游戏是很自然的。毕竟，游戏代表了一组对象，它们之间进行了密集的互动。在我们的策略游戏中，有单位建造的建筑。单位会抵御来自敌方单位的攻击等等。这种相互通信导致了复杂性的增长。随着项目的发展和功能的增加，支持它将变得更加困难。很明显，设计是构建项目中最重要的（如果不是最重要的）部分之一。整合设计模式将极大地改善设计过程和项目支持。
- en: Let's examine some design patterns that are useful in game development. We will
    start with classic patterns and then discuss more game-specific patterns.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些在游戏开发中有用的设计模式。我们将从经典模式开始，然后讨论更多与游戏相关的模式。
- en: The Command pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: 'Developers categorize design patterns into creational, structural, and behavioral
    categories. The Command pattern is a behavioral design pattern. Behavioral design
    patterns are mainly concerned with providing flexibility in communication between
    objects. In this context, the Command pattern encapsulates an action in an object
    that contains the necessary information, along with the action itself. This way,
    the Command pattern behaves as a smart function. The simplest way to implement
    it in C++ is by overloading the `operator()` for a class, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员将设计模式分为创建型、结构型和行为型三类。命令模式是一种行为设计模式。行为设计模式主要关注对象之间通信的灵活性。在这种情况下，命令模式将一个动作封装在一个包含必要信息以及动作本身的对象中。这样，命令模式就像一个智能函数。在C++中实现它的最简单方法是重载一个类的`operator()`，如下所示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A class with an overloaded `operator()` is sometimes referred to as a **functor**.
    The preceding code is almost the same as the following regular function declaration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 具有重载`operator()`的类有时被称为**函数对象**。前述代码几乎与以下常规函数声明相同：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Calling the regular function and the object of the `Command` class looks similar,
    as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用常规函数和`Command`类的对象看起来很相似，如下所示：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The difference between these two is obvious whenever we need to use a state
    for the function. To store the state for a regular function, we use a static variable.
    To store the state in the object, we use the object itself. Here''s how we can
    track the number of calls of the overloaded operator:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别在于，当我们需要为函数使用状态时，这一点就显而易见了。为了为常规函数存储状态，我们使用静态变量。为了在对象中存储状态，我们使用对象本身。以下是我们如何跟踪重载运算符的调用次数：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The number of calls is unique for each instance of the `Command` class. The
    following code declares two instances of `Command` and calls them two and three
    times, respectively:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Command`类的实例的调用次数是唯一的。以下代码声明了两个`Command`的实例，并分别调用了两次和三次：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's try to apply this pattern to our strategy game. The final version
    of the game has a graphical interface that allows its users to control the game
    using various buttons and mouse clicks. For example, to make a character unit
    build a house, and not a barrack, we should choose the corresponding icon on the
    game panel. Let's visualize a game panel with a map of the game and a bunch of
    buttons to control the game dynamics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将这种模式应用到我们的策略游戏中。游戏的最终版本具有图形界面，允许用户使用各种按钮和鼠标点击来控制游戏。例如，要让一个角色单位建造一座房子，而不是兵营，我们应该在游戏面板上选择相应的图标。让我们想象一个带有游戏地图和一堆按钮来控制游戏动态的游戏面板。
- en: 'The game provides the following commands to the player:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏为玩家提供以下命令：
- en: Move the character unit from point A to point B
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角色单位从A点移动到B点
- en: Attack the enemy
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击敌人
- en: Construct a building
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造建筑
- en: Settle the house
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安置房屋
- en: 'The design of the game commands looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏命令的设计如下：
- en: '![](img/03f3119a-3a41-4fd1-b3ac-f5245be1e74b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03f3119a-3a41-4fd1-b3ac-f5245be1e74b.png)'
- en: 'Each class encapsulates the action logic. The client code is not concerned with
    processing the action. It operates with command pointers, each of which will point
    to the concrete **Command** (as shown in the preceding image). Note that we''ve
    only depicted commands that the player will execute. The game itself communicates
    between modules using commands. Examples of automatic commands include **Run**,
    **Defend**, **Die**, and **Create**. The following is a broader diagram showing
    the commands in the game:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类封装了动作逻辑。客户端代码不关心处理动作。它操作命令指针，每个指针将指向具体的**Command**（如前图所示）。请注意，我们只描述了玩家将执行的命令。游戏本身使用命令在模块之间进行通信。自动命令的示例包括**Run**，**Defend**，**Die**和**Create**。以下是游戏中命令的更广泛的图表：
- en: '![](img/87e3d426-3977-49b5-ac4e-266dfcb3a93b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87e3d426-3977-49b5-ac4e-266dfcb3a93b.png)'
- en: The preceding commands execute any of the aforementioned events that arise during
    the gameplay. To listen to those events, we should consider using the Observer
    pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令执行游戏过程中出现的任何事件。要监听这些事件，我们应该考虑使用观察者模式。
- en: The Observer pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer pattern is an architectural mechanism that allows us to subscribe
    to object state changes. We say that we observe the changes of the object. The
    Observer pattern is also a behavioral design pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种允许我们订阅对象状态变化的架构机制。我们说我们观察对象的变化。观察者模式也是一种行为设计模式。
- en: Most strategy games incorporate the concept of a resource. This might be a rock,
    gold, wood, and so on. For example, upon constructing a building, the player has
    to spend 20 units of wood, 40 units of rock, and 10 units of gold. Eventually,
    the player will run out of resources and has to collect them. This player creates
    more character units and tasks them with collecting resources – almost like what
    happens in real life.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数策略游戏都包含资源的概念。这可能是岩石、黄金、木材等。例如，在建造建筑时，玩家必须花费20单位的木材、40单位的岩石和10单位的黄金。最终，玩家将耗尽资源并必须收集资源。玩家创建更多角色单位并指派它们收集资源
    - 几乎就像现实生活中发生的情况一样。
- en: Now, let's suppose we have a similar resource gathering or spending activity
    in our game. When the player tasks units to collect a resource, they should somehow
    notify us each time a fixed amount of resource is collected. The player is the
    subscriber to the **resource collected** event.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的游戏中有类似的资源收集或消耗活动。当玩家指派单位收集资源时，他们应该在每次收集到一定数量的资源时通知我们。玩家是“资源收集”事件的订阅者。
- en: The same is true for buildings. A building produces a character – subscribers
    get a notification. A character unit finishes the building construction – subscribers
    get a notification. In most cases, the subscriber is the player. We update the
    player dashboard to keep the game state up to date for the player; that is, the
    player oversees how many resources, how many units, and how many buildings they
    have while playing the game.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑也是如此。建筑物生产角色 - 订阅者会收到通知。角色单位完成建筑施工 - 订阅者会收到通知。在大多数情况下，订阅者是玩家。我们更新玩家仪表板，以便在玩游戏时保持游戏状态最新；也就是说，玩家在玩游戏时可以了解自己拥有多少资源、多少单位和多少建筑物。
- en: 'The Observer involves implementing a class that stores its subscribers and
    calls the specified function on an event. It consists of two entities: a subscriber
    and a publisher. As shown in the following diagram, the number of subscribers
    is not limited to one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者涉及实现一个存储其订阅者并在事件上调用指定函数的类。它由两个实体组成：订阅者和发布者。如下图所示，订阅者的数量不限于一个：
- en: '![](img/5441e6d9-b94b-435b-ac15-bf16bd0be9a3.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5441e6d9-b94b-435b-ac15-bf16bd0be9a3.png)'
- en: 'For example, when a character unit is assigned to build a building, it will
    continuously strive to build it unless it gets stopped. There are various reasons
    why this may happen:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当角色单位被指定建造建筑时，它将不断努力建造，除非它被停止。可能会有各种原因导致这种情况发生：
- en: The player decides to cancel the process of constructing the building.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家决定取消建筑施工过程。
- en: The character unit has to defend itself from an enemy attack and pauses the
    construction process.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色单位必须保护自己免受敌人的攻击，并暂停施工过程。
- en: The building has been finished, so the character unit stops working on it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建筑已经完成，所以角色单位停止在上面工作。
- en: 'The player would also like to be notified when the building is completed because
    they might have plans for the character unit to perform other tasks when they''re
    done with the building process. We can design the building process so that it
    notifies its listeners (subscribers) when the event is completed. The following
    class diagram also involves an Action interface. Consider it as an implementation
    of the Command pattern:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家也希望在建筑完成时收到通知，因为他们可能计划在建筑完成后让角色单位执行其他任务。我们可以设计建筑过程，使其在事件完成时通知其监听者（订阅者）。以下类图还涉及一个Action接口。将其视为命令模式的实现：
- en: '![](img/2ae90c0d-17e8-4028-8bfa-e944ffac3e4a.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae90c0d-17e8-4028-8bfa-e944ffac3e4a.png)'
- en: 'Developing classes with regards to the Observer leads us to a point where almost
    all the entities in the game are subscribers, publishers, or both. If you encounter
    a similar scenario, you might consider using the Mediator – another behavioral
    pattern. Objects communicate with each other via a mediator object. An object
    that triggers an event lets the Mediator know about it. The Mediator then passes
    the message to any related object that''s "subscribed" to the object state. The
    following diagram is a simplified version of the Mediator''s integration:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据观察者开发类，我们会发现游戏中几乎所有实体都是订阅者、发布者或两者兼而有之。如果遇到类似情况，可以考虑使用中介者-另一种行为模式。对象通过中介者对象相互通信。触发事件的对象会让中介者知道。然后中介者将消息传递给任何与对象状态“订阅”相关的对象。以下图表是中介者集成的简化版本：
- en: '![](img/db974456-125d-46b8-bb44-65bf4da3fb29.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db974456-125d-46b8-bb44-65bf4da3fb29.png)'
- en: Each object contains a Mediator that's used to notify subscribers about changes.
    The Mediator object usually contains all the objects that communicate with each
    other. On an event, each object notifies the interested parties via the mediator.
    For example, when the building construction is done, it triggers the Mediator,
    which, in turn, notifies all the subscribed parties. To receive those notifications,
    each object should be subscribed to the Mediator beforehand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都包含一个中介者，用于通知订阅者有关更改的信息。中介者对象通常包含彼此通信的所有对象。在事件发生时，每个对象通过中介者通知感兴趣的各方。例如，当建筑施工完成时，它会触发中介者，中介者会通知所有订阅的各方。为了接收这些通知，每个对象都应该事先订阅中介者。
- en: The Flyweight pattern
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flyweight模式
- en: Flyweight is a structural design pattern. Structural patterns take care of assembling
    objects and classes into larger, more flexible, structures. Flyweight allows us
    to cache objects by sharing their common parts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight是一种结构设计模式。结构模式负责将对象和类组装成更大、更灵活的结构。Flyweight允许我们通过共享它们的共同部分来缓存对象。
- en: In our strategy game, we're dealing with many objects being rendered on the
    screen. The number of objects increases during gameplay. The longer the player
    plays the game, the more character units and buildings they create (the same is
    true for the automated enemy). Each unit in the game represents a separate object
    containing data. A character unit takes at least 16 bytes of memory (for its two
    integer data members and the virtual table pointer).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的策略游戏中，屏幕上渲染了许多对象。在游戏过程中，对象的数量会增加。玩家玩得越久，他们创建的角色单位和建筑就越多（自动敌人也是如此）。游戏中的每个单位都代表一个包含数据的单独对象。角色单位至少占用16字节的内存（用于其两个整数数据成员和虚拟表指针）。
- en: Things get worse when we add additional fields to units in order to render them
    on the screen; for example, their height, width, and sprite (the image representing
    the unit for rendering). Besides the character units, the game should have supplementary
    items to make the user experience even better, for example, decorative items such
    as trees, rocks, and so on. At some point, we'll conclude that we have plenty
    of objects to render on the screen, each of which represents almost the same object,
    but with a small difference in their states. The Flyweight pattern comes to the
    rescue here. For the character unit, its height, width, and sprite store almost
    identical data across all units.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为了在屏幕上渲染单位而向单位添加额外字段时，情况变得更糟；例如，它们的高度、宽度和精灵（代表渲染单位的图像）。除了角色单位，游戏还应该有一些补充物品，以提高用户体验，例如树木、岩石等装饰物品。在某个时候，我们会得出结论，我们有大量对象需要在屏幕上渲染，每个对象几乎代表相同的对象，但在其状态上有一些小差异。Flyweight模式在这里发挥了作用。对于角色单位，其高度、宽度和精灵在所有单位中存储的数据几乎相同。
- en: 'The Flyweight pattern suggests decomposing a heavy object into two:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight模式建议将一个重对象分解为两个：
- en: An immutable object that contains the same data for each object of the same
    kind
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不可变的对象，包含相同类型对象的相同数据
- en: A mutable object that uniquely identifies itself from others
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可变对象，可以从其他对象中唯一标识自己
- en: 'For example, a moving character unit has its own height, length, and sprite,
    all of which are repeated for all the character units. Therefore, we can represent
    those properties as a single immutable object with the same values for the properties
    for all the objects. However, a character unit might have a different location
    on the screen than others, and when the player commands the unit to move somewhere
    else or start constructing a building, the position of the unit changes continuously
    until it reaches an endpoint. At each step, the unit should be redrawn on the
    screen. By doing this, we arrive at the following design:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，移动的角色单位有自己的高度、长度和精灵，所有这些对于所有角色单位都是重复的。因此，我们可以将这些属性表示为具有相同值的单个不可变对象，对于所有对象的属性都是相同的。然而，角色单位在屏幕上的位置可能与其他位置不同，当玩家命令单位移动到其他位置或开始建造建筑时，单位的位置会不断变化直到达到终点。在每一步，单位都应该在屏幕上重新绘制。通过这样做，我们得到以下设计：
- en: '![](img/969db8dd-89fb-4fc8-91eb-c7c9a186c889.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/969db8dd-89fb-4fc8-91eb-c7c9a186c889.png)'
- en: The left-hand side is the `CharacterUnit` before modifications, while the right-hand
    side represents recent modifications using the Flyweight pattern. The game can
    now deal with a bunch of `CharacterUnit` objects, while each of them will store
    a reference to a few `UnitData` objects. This way, we save a lot of memory. We
    store the values that are unique to each unit in a `CharacterUnit` object. These
    values change over time. The dimensions and sprite are constant, so we can keep
    a single object with these values. This immutable data is called the **intrinsic
    state**, while the mutable part of the object (the `CharacterUnit`) is called
    the **extrinsic** **state**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是修改前的`CharacterUnit`，右侧是使用享元模式进行了最近修改。游戏现在可以处理一堆`CharacterUnit`对象，而每个对象都将存储对几个`UnitData`对象的引用。这样，我们节省了大量内存。我们将每个单位独有的值存储在`CharacterUnit`对象中。这些值随时间变化。尺寸和精灵是恒定的，所以我们可以保留一个具有这些值的单个对象。这些不可变数据称为**内在状态**，而对象的可变部分（`CharacterUnit`）称为**外在状态**。
- en: We intentionally moved the data members to `CharacterUnit`, thus redesigning
    it from an interface into an abstract class. As we discussed in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details
    of Object-Oriented Programming*, an abstract class is almost the same as the interface
    that might contain an implementation. The `move()` method is an example of a default
    implementation for all types of units. This way, the derived classes only provide
    the necessary behavior because all the units share common properties, such as
    life points and power.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意将数据成员移动到`CharacterUnit`，从而将其从接口重新设计为抽象类。正如我们在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)中讨论的那样，抽象类几乎与可能包含实现的接口相同。`move()`方法是所有类型单位的默认实现的一个例子。这样，派生类只提供必要的行为，因为所有单位共享生命点和力量等共同属性。
- en: After optimizing memory usage, we should deal with copying objects. The game
    involves extensively creating new objects. Each building produces a specific character
    unit; character units construct buildings, and the game world itself renders decorative
    elements (trees, rocks, and so on). Now, let's try to improve `CharacterUnit`
    by incorporating a cloning functionality. Earlier in this chapter, we intentionally
    deleted the copy constructor and assignment operator. Now, it's time to provide
    a mechanism that will create new objects from existing ones.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化内存使用之后，我们应该处理复制对象的问题。游戏涉及大量创建新对象。每个建筑物都会产生一个特定的角色单位；角色单位建造建筑物，游戏世界本身渲染装饰元素（树木、岩石等）。现在，让我们尝试通过整合克隆功能来改进`CharacterUnit`。在本章的早些时候，我们有意删除了复制构造函数和赋值运算符。现在，是时候提供一个从现有对象创建新对象的机制了。
- en: The Prototype pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: 'This pattern lets us create duplicates of objects independently of their type. The
    following code represents the final version of the `CharacterUnit` class with
    regard to our recent modifications. We''ll also add the new `clone()` member function
    in order to incorporate the Prototype pattern:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式让我们能够独立于它们的类型创建对象的副本。以下代码代表了`CharacterUnit`类的最终版本，关于我们最近的修改。我们还将添加新的`clone()`成员函数，以便整合原型模式：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We deleted the assignment operator and moved the copy constructor to the private
    section. The derived classes override the `clone()` member function, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了赋值运算符，并将复制构造函数移到了私有部分。派生类重写了`clone()`成员函数，如下所示：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Prototype pattern delegates cloning to the objects. The common interface
    allows us to decouple the client code from the class of the object. Now, we can
    clone a character unit without knowing it''s a `Reader` or a `Soldier`. Look at
    the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式将克隆委托给对象。通用接口允许我们将客户端代码与对象的类解耦。现在，我们可以克隆一个角色单位，而不知道它是`Reader`还是`Soldier`。看下面的例子：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A dynamic cast works fine whenever we need to convert the object into a specific
    type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 动态转换在我们需要将对象转换为特定类型时非常有效。
- en: In this section, we've discussed many useful design patterns. This might seem
    a little overwhelming if you are new to these patterns; however, using them properly allows
    us to design flexible and maintainable projects. Let's finally get back to the
    game loop that we introduced earlier.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了许多有用的设计模式。如果您对这些模式还不熟悉，可能会感到有些不知所措；然而，正确使用它们可以让我们设计出灵活和易维护的项目。让我们最终回到之前介绍的游戏循环。
- en: Designing the game loop
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏循环
- en: Strategy games have one of the most intensively changing gameplays. At each
    point in time, many actions happen simultaneously. Readers finish their building;
    a barrack produces a soldier; a soldier gets attacked by the enemy; the player
    commands units to move, build, attack, or run; and so on. The game loop handles
    everything. Usually, a game engine provides a well-designed game loop.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 策略游戏拥有最频繁变化的游戏玩法之一。在任何时间点，许多动作会同时发生。读者完成他们的建筑；兵营生产士兵；士兵受到敌人的攻击；玩家命令单位移动、建造、攻击或逃跑；等等。游戏循环处理所有这些。通常，游戏引擎提供了一个设计良好的游戏循环。
- en: The game loop runs while we play the game. As we already mentioned, the loop
    handles player actions, updates the game state, and also renders the game (makes
    state changes visible to the player). It does so on each iteration. The loop should
    also control the rate of gameplay, that is, its FPS. A common term for one iteration
    of the game loop is a frame, which is why we emphasize the FPS as the speed of
    the gameplay. For example, if you design a game running at 60 FPS, this means
    each frame takes around 16ms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们玩游戏时，游戏循环运行。正如我们已经提到的，循环处理玩家的动作，更新游戏状态，并渲染游戏（使状态变化对玩家可见）。它在每次迭代中都这样做。循环还应该控制游戏的速率，即其FPS。游戏循环的一次迭代的常见术语是帧，这就是为什么我们强调FPS作为游戏速度的原因。例如，如果你设计一个以60FPS运行的游戏，这意味着每帧大约需要16毫秒。
- en: 'The following code was used earlier in this chapter for a simple game loop:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候用于简单游戏循环的以下代码：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code will run quickly if there are no long user actions to process.
    It will run even faster on fast machines. Your goal is to stick to the 16ms for
    a frame. This might require us to wait a bit after processing actions and updating
    the game state, as shown in the following diagram:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有长时间的用户操作需要处理，上述代码将运行得很快。在快速的机器上运行得更快。你的目标是坚持每帧16毫秒。这可能需要我们在处理操作和更新游戏状态后稍微等待一下，就像下图所示：
- en: '![](img/73b78d78-f5e3-4e4d-8398-eefd4d363046.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73b78d78-f5e3-4e4d-8398-eefd4d363046.png)'
- en: Each update advances the game time by a fixed amount, which takes a fixed amount
    of real-world time to process. On the other hand, the game will slow down if the
    processing takes longer than the specified milliseconds for a frame.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更新都会按固定的数量推进游戏时间，这需要固定的现实时间来处理。另一方面，如果处理时间超过了帧的指定毫秒数，游戏就会变慢。
- en: 'Everything that happens in the game is mostly covered in the update part of
    the game, as shown in the preceding diagram. Most of the time, updating might
    require performing several operations at a time. Also, as we mentioned earlier,
    we have to keep timers for some of the operations that occur in the game in the
    background. It mostly depends on how detailed we want to make the game. For example,
    constructing a building might be represented as two states: initial and final.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中发生的一切大部分都在游戏的更新部分中涵盖，就像前面的图表所示。大多数情况下，更新可能需要同时执行多个操作。此外，正如我们之前提到的，我们必须为游戏中发生的一些操作保持计时器。这主要取决于我们想要使游戏变得多么详细。例如，建造一个建筑物可能被表示为两种状态：初始和最终。
- en: In terms of graphic design, those two states should represent two different
    images. The first image contains some fundamental part for the building and might
    include a couple of rocks around it as if it's just getting ready to be constructed.
    The next image represents the final constructed building. When a character unit
    just starts constructing the building, we show the player the first image (the
    fundament with a couple of rocks around it). When the construction is finished,
    we replace the first image with the image containing the final building. To make
    the process more natural (more real-world), we artificially make it take longer.
    This means we keep a timer lasting 30 seconds or more between two states of the
    image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形设计方面，这两种状态应该代表两种不同的图像。第一张图像包含建筑的一些基本部分，可能包括周围的一些岩石，就像它刚准备开始施工一样。下一张图像代表最终建成的建筑。当一个角色单位刚开始建造建筑时，我们向玩家展示第一张图像（基础部分和周围的一些岩石）。当建筑完成时，我们用包含最终建筑的图像替换第一张图像。为了使过程更加自然（更接近现实世界），我们人为地延长了时间。这意味着我们在两个图像状态之间保持一个持续30秒或更长的计时器。
- en: We described the simplest case with the least amount of detail. If we need to
    make the game more detailed, for example, by rendering every change of in the
    building during the construction, we should keep a lot of timers between a lot
    of images representing each step of the construction. Take a look at the preceding
    diagram once again. After updating the game, we wait for *N* milliseconds. Waiting
    for more milliseconds tends to make the flow of the game closer to real life.
    What if the update takes so long that the player experience lags behind? In that
    case, we need to optimize the game so that it fits the time frame that's the most
    optimal in terms of user experience. Now, let's say updating the game takes more
    than hundreds of operations to perform; the player has achieved a prosperous empire;
    is now constructing lots of buildings, and attacks the enemy with many soldiers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了最简单的情况，细节最少。如果我们需要使游戏更加详细，例如在建筑物施工过程中渲染每一个变化，我们应该在很多图像之间保持很多计时器，每个图像代表施工的每一步。再次看一下前面的图表。更新游戏后，我们等待*N*毫秒。等待更多毫秒会使游戏的流程更接近现实生活。如果更新花费的时间太长，导致玩家体验滞后怎么办？在这种情况下，我们需要优化游戏，使其适应最优用户体验的时间框架。现在，假设更新游戏需要执行数百个操作；玩家已经建立了一个繁荣的帝国；现在正在建造大量建筑，并用许多士兵攻击敌人。
- en: Each action of one character unit, such as moving from one point to another
    one, attacking an enemy unit, constructing a building, and so on, is rendered
    on the screen on time. Now, what if we render states of hundreds of units on the
    screen at once? That's where we use a multithreaded approach. Each action involves
    independently modifying the state of an object (an object being any of the units
    in the game, including static buildings).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色单位的每个动作，比如从一个点移动到另一个点，攻击一个敌人单位，建造一个建筑等，都会及时显示在屏幕上。现在，如果我们一次在屏幕上渲染数百个单位的状态会怎样？这就是我们使用多线程方法的地方。每个动作都涉及独立修改对象的状态（对象可以是游戏中的任何一个单位，包括静态建筑）。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Designing a game is a complex task. We can consider game development as a separate
    programming area. Games have different genres, and one of them is strategy games.
    Strategy game design involves designing game components such as units and buildings.
    Usually, a strategy game involves collecting resources, building an empire, and
    fighting the enemy. The gameplay involves dynamic communication between game components,
    such as character units constructing buildings and collecting resources, soldiers
    defending the land from enemies, and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设计游戏是一项复杂的任务。我们可以将游戏开发视为一个独立的编程领域。游戏有不同的类型，其中之一是策略游戏。策略游戏设计涉及设计单位和建筑等游戏组件。通常，策略游戏涉及收集资源、建立帝国和与敌人战斗。游戏过程涉及游戏组件之间的动态交流，比如角色单位建造建筑和收集资源，士兵保卫土地免受敌人侵袭等。
- en: To properly design a strategy game, we incorporate OOP design skills, along
    with design patterns. Design patterns play a huge role in designing the whole
    game and how its components interact. In this chapter, we discussed the Command
    pattern, which encapsulates actions under objects; the Observer pattern, which
    is used to subscribe to object events; and the Mediator pattern, which is used
    to advance the Observer to a level of complex interactions between components.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设计策略游戏，我们需要结合面向对象设计技能和设计模式。设计模式在设计整个游戏以及其组件之间的交互方面起着重要作用。在本章中，我们讨论了命令模式，它将动作封装在对象下；观察者模式，用于订阅对象事件；以及中介者模式，用于将观察者提升到组件之间复杂交互的水平。
- en: The most important part of the game is its loop. The game loop controls rendering,
    timely updates of the game state, and other subsystems. Designing it involves
    using event queues and timers. Modern games use networking to allow multiple players
    to play together via the internet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏最重要的部分是其循环。游戏循环控制渲染、游戏状态的及时更新以及其他子系统。设计它涉及使用事件队列和定时器。现代游戏使用网络，允许多个玩家通过互联网一起玩游戏。
- en: In the next chapter, we will introduce network programming in C++ so that you
    will have the skills you need to incorporate networking into your games.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍C++中的网络编程，这样你就会拥有将网络编程融入游戏中所需的技能。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the purpose of overriding a private virtual function?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写私有虚函数的目的是什么？
- en: Describe the Command design pattern.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述命令设计模式。
- en: How does the Flyweight pattern save memory usage?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 飞行权重模式如何节省内存使用？
- en: What's the difference between the Observer and Mediator patterns?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者模式和中介者模式有什么区别？
- en: Why did we design the game loop as an infinite loop?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们将游戏循环设计为无限循环？
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Development Patterns and Best Practices: Better games, less hassle* by
    John P. Doran, Matt Casanova: [https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/](https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《游戏开发模式与最佳实践：更好的游戏，更少的麻烦》John P. Doran, Matt Casanova著*：[https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/](https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/)。'
