- en: '*Chapter 5*: Exploring Clang''s Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：探索 Clang 的架构'
- en: '**Clang** is LLVM''s official frontend for **C-family** programming languages,
    including C, C++, and Objective-C. It processes the input source code (parsing,
    type checking, and semantic reasoning, to name a few) and generates equivalent
    LLVM IR code, which is then taken over by other LLVM subsystems to perform optimization
    and native code generation. Many *C-like* dialects or language extensions also
    find Clang easy to host their implementations. For example, Clang provides official
    support for OpenCL, OpenMP, and CUDA C/C++. In addition to normal frontend jobs,
    Clang has been evolving to partition its functionalities into libraries and modules
    so that developers can use them to create all kinds of tools related to **source
    code processing**; for example, code refactoring, code formatting, and syntax
    highlighting. Learning Clang development can not only bring you more engagement
    into the LLVM project but also open up a wide range of possibilities for creating
    powerful applications and tools.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clang** 是 LLVM 的官方前端，用于 **C 家族** 编程语言，包括 C、C++ 和 Objective-C。它处理输入源代码（例如解析、类型检查和语义推理等）并生成等效的
    LLVM IR 代码，然后由其他 LLVM 子系统接管以执行优化和本地代码生成。许多 *类似 C* 的方言或语言扩展也发现 Clang 很容易托管它们的实现。例如，Clang
    提供了对 OpenCL、OpenMP 和 CUDA C/C++ 的官方支持。除了正常的前端工作外，Clang 一直在发展，将其功能划分为库和模块，以便开发者可以使用它们创建各种与
    **源代码处理** 相关的工具；例如，代码重构、代码格式化和语法高亮。学习 Clang 开发不仅可以让你更深入地参与到 LLVM 项目中，还可以为创建强大的应用程序和工具开辟广泛的可能性。'
- en: Unlike LLVM, which arranges most of its tasks into a single pipeline (that is,
    **PassManager**) and runs them sequentially, there is more diversity in how Clang
    organizes its subcomponents. In this chapter, we will show you a clear picture
    of how Clang's important subsystems are organized, what their roles are, and which
    part of the code base you should be looking for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与将大多数任务安排在单个管道（即 **PassManager**）中并按顺序运行的 LLVM 不同，Clang 组织其子组件的方式更加多样化。在本章中，我们将向您展示一个清晰的图像，说明
    Clang 的重要子系统是如何组织的，它们的作用是什么，以及你应该查找代码库的哪个部分。
- en: Terminology
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 术语
- en: From this chapter through to the rest of this book, we will be using Clang (which
    starts with an uppercase C and a Minion Pro font face) to refer to the *project*
    and its *techniques* as a whole. Whenever we use `clang` (all in lowercase with
    a Courier font face), we are referring to the *executable program*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始到本书的其余部分，我们将使用 Clang（以大写 C 开头，并使用 Minion Pro 字体）来指代整个 **项目** 和其 **技术**。当我们使用
    `clang`（全部小写，并使用 Courier 字体）时，我们指的是 **可执行程序**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Learning Clang's subsystems and their roles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Clang 的子系统及其角色
- en: Exploring Clang's tooling features and extension options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Clang 的工具功能和扩展选项
- en: By the end of this chapter, you will have a roadmap of this system so that you
    can kickstart your own projects and have some gravity for later chapters related
    to Clang development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有这个系统的路线图，以便你可以启动自己的项目，并为后续章节中关于 Clang 开发的相关内容奠定基础。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In [*Chapter 1*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014), *Saving Resources
    When Building LLVM*, we showed you how to build LLVM. Those instructions, however,
    did not build Clang. To include Clang in the build list, please edit the value
    that''s been assigned to the `LLVM_ENABLE_PROJECTS` CMake variable, like so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014) 中，*构建 LLVM 时的资源节约*，我们向您展示了如何构建
    LLVM。然而，这些说明并没有构建 Clang。要包括 Clang 在构建列表中，请编辑分配给 `LLVM_ENABLE_PROJECTS` CMake 变量的值，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of that variable should be a semi-colon-separated list, where each
    item is one of LLVM's subprojects. In this case, we're including Clang and `clang-tools-extra`,
    which contains a bunch of useful tools based on Clang's techniques. For example,
    the `clang-format` tool is used by countless open source projects, especially
    large-scale ones, to impose a unified coding style in their code base.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量的值应该是一个分号分隔的列表，其中每个项目都是 LLVM 的子项目之一。在这种情况下，我们包括 Clang 和 `clang-tools-extra`，它包含基于
    Clang 技术的一组有用工具。例如，`clang-format` 工具被无数开源项目使用，特别是大型项目，以在其代码库中强制实施统一的编码风格。
- en: Adding Clang to an existing build
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Clang 添加到现有构建中
- en: If you already have an LLVM build where Clang was not enabled, you can edit
    the `LLVM_ENABLE_PROJECTS` CMake argument's value in `CMakeCache.txt` without
    invoking the original CMake command again. CMake should reconfigure itself once
    you've edited the file and run Ninja (or a build system of your choice) again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一个 Clang 未启用的 LLVM 构建，您可以在不再次调用原始 CMake 命令的情况下编辑 `CMakeCache.txt` 中的 `LLVM_ENABLE_PROJECTS`
    CMake 参数的值。编辑文件后，CMake 应该会重新配置自己，然后再次运行 Ninja（或您选择的构建系统）。
- en: 'You can build `clang`, Clang''s driver, and the main program using the following
    command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令构建 `clang`、Clang 的驱动程序和主程序：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can run all the Clang tests using the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行所有 Clang 测试：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, you should have the `clang` executable in the `/<your build directory>/bin`
    folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在 `/<您的构建目录>/bin` 文件夹中拥有 `clang` 可执行文件。
- en: Learning Clang's subsystems and their roles
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Clang 的子系统及其作用
- en: In this section, we will give you an overview of Clang's structures and organizations.
    We will briefly introduce some of the important components or subsystems, before
    using dedicated sections or chapters to expand them further in later parts of
    this book. We hope this will give you some idea of Clang's internals and how they
    will benefit your development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为您概述 Clang 的结构和组织。在本书的后续部分，我们将通过专门的章节或章节进一步介绍一些重要的组件或子系统。我们希望这能给您一些关于
    Clang 内部结构和它们如何对您的开发有益的想法。
- en: 'First, let''s look at the big picture. The following diagram shows the high-level
    structure of Clang:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看整体情况。以下图表显示了 Clang 的高级结构：
- en: '![Figure 5.1 – High-level structure of Clang'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – Clang 的高级结构'
- en: '](img/Figure_5.1_B14590.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B14590.jpg)'
- en: Figure 5.1 – High-level structure of Clang
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Clang 的高级结构
- en: As explained in the legend, rectangles with rounded corners represent subsystems
    that might consist of multiple components with similar functionalities. For example,
    the **frontend** can be further dissected into components such as the preprocessor,
    parser, and code generation logic, to name a few. In addition, there are intermediate
    results, depicted as ovals in the preceding diagram. We are especially interested
    in two of them – **Clang AST** and **LLVM IR**. The former will be discussed in
    depth in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093), *Handling
    AST*, while the latter is the main character of *Part 3*, *Middle-End Development*,
    which will talk about optimizations and analyses you can apply to LLVM IR.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如图例所述，圆角矩形代表可能由具有相似功能的多个组件组成的子系统。例如，**前端** 可以进一步细分为预处理器、解析器和代码生成逻辑等组件。此外，还有中间结果，如图中所示为椭圆形。我们特别关注其中的两个
    – **Clang AST** 和 **LLVM IR**。前者将在 [*第 7 章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)
    中深入讨论，*处理 AST*，而后者是 *第 3 部分*，*中间端开发* 的主角，将讨论可以应用于 LLVM IR 的优化和分析。
- en: Let's start by looking at an overview of the driver. The following subsections
    will give you a brief introduction to each of these driver components.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看驱动程序的概述开始。以下小节将简要介绍这些驱动程序组件的每个组件。
- en: Driver
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动程序
- en: A common misunderstanding is that `clang`, the executable, is the compiler frontend.
    While `clang` does use Clang's frontend components, the executable itself is actually
    a kind of program called a **compiler driver**, or **driver** for short.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是 `clang` 可执行文件是编译器前端。虽然 `clang` 确实使用了 Clang 的前端组件，但可执行文件本身实际上是一种称为 **编译器驱动程序**
    或 **驱动程序** 的程序。
- en: 'Compiling source code is a complex process. First, it consists of multiple
    phases, including the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译源代码是一个复杂的过程。首先，它包括多个阶段，如下所示：
- en: '**Frontend**: Parsing and semantic checking'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：解析和语义检查'
- en: '**Middle-end**: Program analysis and optimization'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间端**：程序分析和优化'
- en: '**Backend**: Native code generation'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端**：本地代码生成'
- en: '**Assembling**: Running the assembler'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编**：运行汇编器'
- en: '**Linking**: Running the linker'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：运行链接器'
- en: Among these phases and their enclosing components, there are countless options/arguments
    and flags, such as the option to tell compilers where to search for include files
    (that is, the `-I` command-line option in GCC and Clang). Furthermore, we hope
    that the compiler can figure out the values for some of these options. For example,
    it would be great if the compiler could include some folders of C/C++ standard
    libraries (for example, `/include` and `/usr/include` in Linux systems) in the
    header file search paths *by default*, so that we don't need to assign each of
    those folders manually in the command line. Continuing with this example, it's
    clear that we want our compilers to be **portable** across different operating
    systems and platforms, but many operating systems use a different C/C++ standard
    library path. So, how do compilers pick the correct one accordingly?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些阶段及其包含的组件中，有无数选项/参数和标志，例如告诉编译器在哪里搜索包含文件的选项（即 GCC 和 Clang 中的 `-I` 命令行选项）。此外，我们希望编译器能够确定这些选项中的某些值。例如，如果编译器能够默认将一些
    C/C++ 标准库文件夹（例如 Linux 系统中的 `/include` 和 `/usr/include`）包含在头文件搜索路径中，那就太好了，这样我们就不需要在命令行中手动指定每个文件夹。继续这个例子，很明显，我们希望我们的编译器能够在不同的操作系统和平台上**通用**，但许多操作系统使用不同的
    C/C++ 标准库路径。那么，编译器是如何相应地选择正确的路径的呢？
- en: 'In this situation, a driver is designed to come to the rescue. It''s a piece
    of software that acts as a housekeeper for core compiler components, serving them
    essential information (for example, a OS-specific system include path, as we mentioned
    earlier) and arranging their executions so that users only need to supply important
    command-line arguments. A good way to observe the hard work of a driver is to
    use the `-###` command-line flag on a normal `clang` invocation. For example,
    you could try to compile a simple hello world program with that flag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个驱动程序被设计出来以提供帮助。它是一段软件，充当核心编译组件的管家，为他们提供必要的信息（例如，我们之前提到的特定于操作系统的系统包含路径）并安排它们的执行，以便用户只需提供重要的命令行参数。观察驱动程序辛勤工作的一个好方法是使用
    `clang` 调用中的 `-###` 命令行标志。例如，你可以尝试使用该标志编译一个简单的 hello world 程序：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is part of the output after running the preceding command on
    a macOS computer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 macOS 计算机上运行先前命令后的输出的一部分：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are essentially the flags being passed to the *real* Clang frontend after
    the driver's *translation*. While you don't need to understand all these flags,
    it's true that even for a simple program, the compilation flow consists of an
    enormous amount of compiler options and many subcomponents.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是驱动程序翻译后传递给**真实** Clang 前端的标志。虽然你不需要理解所有这些标志，但确实，即使是简单的程序，编译流程也包含大量的编译器选项和许多子组件。
- en: The source code for the driver can be found under `clang/lib/Driver`. In [*Chapter
    8*](B14590_08_Final_JC_ePub.xhtml#_idTextAnchor108), *Working with Compiler Flags
    and Toolchains*, we will look at this in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的源代码可以在 `clang/lib/Driver` 下找到。在[*第 8 章*](B14590_08_Final_JC_ePub.xhtml#_idTextAnchor108)
    *与编译器标志和工具链一起工作*中，我们将更详细地探讨这一点。
- en: Frontend
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前端
- en: A typical compiler textbook might tell you that a compiler frontend consists
    of a **lexer** and a **parser**, which generates an **abstract syntax tree** (**AST**).
    Clang's frontend also uses this skeleton, but with some major differences. First,
    the lexer is usually coupled with the **preprocessor**, and the semantic analysis
    that's performed on the source code is detached into a separate subsystem, called
    the **Sema**. This builds an AST and does all kinds of semantic checking.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一本典型的编译器教科书可能会告诉你，编译器前端由一个**词法分析器**和一个**解析器**组成，它们生成一个**抽象语法树**（**AST**）。Clang
    的前端也使用这个框架，但有一些主要区别。首先，词法分析器通常与**预处理器**结合使用，对源代码进行的语义分析被分离到一个单独的子系统，称为**Sema**。这构建了一个
    AST 并执行各种语义检查。
- en: Lexer and preprocessor
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 词法分析和预处理器
- en: Due to the complexity of programming language standards and the scale of real-world
    source code, preprocessing becomes non-trivial. For example, resolving included
    files becomes tricky when you have 10+ layers of a header file hierarchy, which
    is common in large-scale projects. Advanced directives such as `#pragma` can be
    challenged in cases where OpenMP uses `#pragma` to parallelize for loops. Solving
    these challenges requires close cooperation between the preprocessor and the lexer,
    which provides primitives for all the preprocessing actions. Their source code
    can be found under `clang/lib/Lex`. In [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Extending the Preprocessor*, you will become familiar with preprocessor and lexer
    development, and learn how to implement custom logic with a powerful extension
    system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程语言标准的复杂性和现实世界源代码的规模，预处理变得非同寻常。例如，当你有10+层的头文件层次结构时，解决包含的文件变得复杂，这在大型项目中很常见。在OpenMP使用`#pragma`并行化for循环的情况下，高级指令如`#pragma`可能会受到挑战。解决这些挑战需要预处理程序和词法分析器之间的紧密合作，它们为所有预处理动作提供原语。它们的源代码可以在`clang/lib/Lex`下找到。在[*第6章*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078)
    *扩展预处理程序*中，你将熟悉预处理程序和词法分析器开发，并学习如何使用强大的扩展系统实现自定义逻辑。
- en: Parser and Sema
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析器和Sema
- en: Clang's parser consumes token streams from the preprocessor and lexer and tries
    to realize their semantic structures. Here, the Sema sub-system performs more
    semantic checking and analysis from the parser's result before generating the
    AST. Historically, there was another layer of abstraction where you could create
    your own *parser action* callbacks to specify what actions you wanted to perform
    when certain language directives (for example, identifiers such as variable names)
    were parsed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Clang的解析器从预处理程序和词法分析器消耗标记流，并试图实现它们的语义结构。在这里，Sema子系统在生成AST之前，从解析器的结果中进行更多的语义检查和分析。历史上，还有一个抽象层，你可以创建自己的*解析器动作*回调，以指定在解析某些语言指令（例如，变量名等标识符）时想要执行的操作。
- en: Back then, Sema was one of these parser actions. However, later on, people found
    that this additional layer of abstraction was not necessary, so the parser only
    interacts with Sema nowadays. Nevertheless, Sema still retains this kind of callback-style
    design. For example, the `clang::Sema::ActOnForStmt(…)` function (defined in `clang/lib/Sema/SemaStmt.cpp`)
    will be invoked when a for loop structure is parsed. It will then do all kinds
    of checking to make sure the syntax is correct and generate the AST node for the
    for loop; that is, a `ForStmt` object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时，Sema是这些解析器动作之一。然而，后来人们发现这一额外的抽象层并不是必要的，所以解析器现在只与Sema交互。尽管如此，Sema仍然保留了这种回调式设计。例如，当解析到for循环结构时，会调用`clang::Sema::ActOnForStmt(…)`函数（在`clang/lib/Sema/SemaStmt.cpp`中定义）。然后它会进行各种检查以确保语法正确，并为for循环生成AST节点；即，一个`ForStmt`对象。
- en: AST
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AST
- en: 'The AST is the most important primitive when it comes to extending Clang with
    your custom logic. All the common Clang extensions/plugins that we will introduce
    operate on an AST. To get a taste of AST, you can use the following command to
    print out the an AST from the source code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: AST（抽象语法树）是当你想要用自定义逻辑扩展Clang时最重要的基本元素。我们将要介绍的所有的常见Clang扩展/插件都是基于AST操作的。为了体验AST，你可以使用以下命令从源代码中打印出AST：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, on my computer, I have used the following simple code, which only
    contains one function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的电脑上，我使用了以下简单的代码，它只包含一个函数：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will yield the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command is pretty useful because it tells you the C++ AST class that represents
    certain language directives, which is crucial for writing AST callbacks – the
    core of many Clang plugins. For example, from the previous lines, we can know
    that a variable reference site (`c` in the `c + 1` expression) is represented
    by the `DeclRefExpr` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令非常有用，因为它告诉你代表某些语言指令的C++ AST类，这对于编写AST回调——许多Clang插件的核心至关重要。例如，从前面的行中，我们可以知道变量引用位置（在`c
    + 1`表达式中的`c`）由`DeclRefExpr`类表示。
- en: Similar to how the parser was organized, you can register different kinds of
    `ASTConsumer` instances to visit or manipulate the AST. **CodeGen**, which we
    will introduce shortly, is one of them. In [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*, we will show you how to implement custom AST processing logic
    using plugins.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与解析器的组织方式类似，你可以注册不同类型的`ASTConsumer`实例来访问或操作AST。**CodeGen**，我们将在稍后介绍，是其中之一。在[*第7章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)
    *处理AST*中，我们将向您展示如何使用插件实现自定义AST处理逻辑。
- en: CodeGen
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CodeGen
- en: Though there are no prescriptions for how you should process the AST (for example,
    if you use the `-ast-dump` command-line option shown previously, the frontend
    will print the textual AST representation), the most common task that's performed
    by the CodeGen subsystem is emitting the LLVM IR code, which will later be compiled
    into native assembly or object code by LLVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有关于如何处理AST（例如，如果你使用前面显示的`-ast-dump`命令行选项，前端将打印文本AST表示）的规定，但CodeGen子系统执行的最常见任务是生成LLVM
    IR代码，该代码随后将被LLVM编译成本地汇编或目标代码。
- en: LLVM, assemblers, and linkers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM、汇编器和链接器
- en: Once the LLVM IR code has been emitted by the CodeGen subsystem, it will be
    processed by the LLVM compilation pipeline to generate native code, either assembly
    code or object code. LLVM provides a framework called the **MC layer**, in which
    architectures can choose to implement assemblers that have been directly integrated
    into LLVM's pipeline. Major architectures such as x86 and ARM use this approach.
    If you don't do this, any textual assembly code that's emitted at the end of LLVM's
    pipeline needs to be processed by external assembler programs invoked by the driver.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码生成子系统生成了LLVM IR代码，它将被LLVM编译管道处理以生成本地代码，无论是汇编代码还是目标代码。LLVM提供了一个名为**MC层**的框架，其中架构可以选择实现直接集成到LLVM管道中的汇编器。主要架构如x86和ARM都采用这种方法。如果你不这样做，LLVM管道末尾生成的任何文本汇编代码都需要由驱动程序调用的外部汇编程序处理。
- en: Despite the fact that LLVM already has its own linker, known as the **LLD**
    project, an *integrated* linker is still not a mature option yet. Therefore, external
    linker programs are always invoked by the driver to link the object files and
    generate the final binary artifacts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管LLVM已经拥有自己的链接器，即被称为**LLD**项目，但一个**集成**链接器仍然不是一个成熟的选项。因此，外部链接器程序总是由驱动程序调用以链接目标文件并生成最终的二进制工件。
- en: External versus integrated
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 外部与集成
- en: Using external assemblers or linkers means invoking a *separate process* to
    run the program. For example, to run an external assembler, the frontend needs
    to put assembly code into a temporary file before launching the assembler with
    that file path as one of its command-line arguments. On the other hand, using
    integrated assemblers/linkers means the functionalities of assembling or linking
    are packaged into *libraries* rather than an executable. So, at the end of the
    compilation pipeline, LLVM will call APIs to process the assembly code's *in-memory*
    instances to emit object code. The advantage of this integrated approach is, of
    course, saving many indirections (writing into temporary files and reading them
    back right away). It also makes the code more concise to some extent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部汇编器或链接器意味着调用一个**独立进程**来运行程序。例如，要运行外部汇编器，前端需要将汇编代码放入一个临时文件中，然后使用该文件路径作为其命令行参数之一来启动汇编器。另一方面，使用集成汇编器/链接器意味着汇编或链接的功能被打包到**库**中，而不是可执行文件。因此，在编译管道的末尾，LLVM将调用API来处理汇编代码的**内存中**实例以生成目标代码。这种集成方法的优点当然是节省许多间接操作（写入临时文件并立即读取）。这在一定程度上也使代码更加简洁。
- en: With that, you have been given an overview of a normal compilation flow, from
    the source code all the way to the native code. In the next section, we will go
    beyond the `clang` executable and provide an overview of the tooling and extension
    options provided by Clang. This not only augments the functionalities of `clang`,
    but also provides a way to use Clang's amazing techniques in out-of-tree projects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经对正常的编译流程有了概述，从源代码到本地代码。在下一节中，我们将超越`clang`可执行文件，并提供Clang提供的工具和扩展选项的概述。这不仅增强了`clang`的功能，还提供了一种在树外项目中使用Clang惊人技术的方法。
- en: Exploring Clang's tooling features and extension options
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Clang的工具功能和扩展选项
- en: The Clang project contains not just the `clang` executable. It also provides
    interfaces for developers to extend its tools, as well as to export its functionalities
    as libraries. In this section, we will give you an overview of all these options.
    Some of them will be covered in later chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 项目不仅包含 `clang` 可执行文件。它还为开发者提供了扩展其工具的接口，以及将其功能作为库导出的接口。在本节中，我们将为您概述所有这些选项。其中一些将在后面的章节中介绍。
- en: 'There are currently three kinds of tooling and extension options available
    in Clang: `clang::FrontendAction` class.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 Clang 中有三种工具和扩展选项可用：`clang::FrontendAction` 类。
- en: The FrontendAction class
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`FrontendAction` 类'
- en: 'In the *Learning Clang''s subsystems and their roles* section, we went through
    a variety of Clang''s frontend components, such as the preprocessor and Sema,
    to name a few. Many of these important components are encapsulated by a single
    data type, called `FrontendAction`. A `FrontendAction` instance can be treated
    as a single task running inside the frontend. It provides a unified interface
    for the task to consume and interact with various resources, such as input source
    files and ASTs, which is similar to the role of an **LLVM Pass** from this perspective
    (an LLVM Pass provides a unified interface to process LLVM IR). However, there
    are some significant differences with an LLVM Pass:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *学习 Clang 的子系统及其角色* 部分，我们探讨了 Clang 的各种前端组件，例如预处理器和 Sema，仅举几个例子。许多这些重要的组件都被一个单一的数据类型封装，称为
    `FrontendAction`。一个 `FrontendAction` 实例可以被视为在前端运行的单个任务。它提供了一个统一的接口，以便任务可以消费和与各种资源进行交互，例如输入源文件和
    AST，从这个角度来看，它类似于 **LLVM Pass** 的角色（LLVM Pass 提供了一个统一的接口来处理 LLVM IR）。然而，与 LLVM
    Pass 也有一些显著的不同：
- en: Not all of the frontend components are encapsulated into a `FrontendAction`,
    such as the parser and Sema. They are standalone components that generate materials
    (for example, the AST) for other FrontendActions to run.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有前端组件都被封装到 `FrontendAction` 中，例如解析器和 Sema。它们是独立的组件，为其他 FrontendAction 运行生成材料（例如，AST）。
- en: Except for a few scenarios (the Clang plugin is one of them), a Clang compilation
    instance rarely runs multiple FrontendActions. Normally, only one `FrontendAction`
    will be executed.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了少数场景（Clang 插件就是其中之一）外，Clang 编译实例很少运行多个 FrontendAction。通常情况下，只有一个 `FrontendAction`
    将被执行。
- en: Generally speaking, a `FrontendAction` describes the task to be done at one
    or two important places in the frontend. This explains why it's so important for
    tooling or extension development – we're basically building our logic into a `FrontendAction`
    (one of FrontendAction's derived classes, to be more precise) instance to control
    and customize the behavior of a normal Clang compilation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，一个 `FrontendAction` 描述了在前端一个或两个重要位置要执行的任务。这也解释了为什么它对于工具或扩展开发如此重要——我们基本上是将我们的逻辑构建到一个
    `FrontendAction`（更精确地说，是 `FrontendAction` 的一个派生类）实例中，以控制和定制正常 Clang 编译的行为。
- en: 'To give you a feel for the `FrontendAction` module, here are some of its important
    APIs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对 `FrontendAction` 模块有一个感觉，这里列出了一些它的重要 API：
- en: '`FrontendAction::BeginSourceFileAction(…)/EndSourceFileAction(…)`: These are
    callbacks that derived classes can override to perform actions right before processing
    a source file and once it has been processed, respectively.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontendAction::BeginSourceFileAction(…)/EndSourceFileAction(…)`: 这些是派生类可以覆盖的回调，分别在处理源文件之前和之后执行操作。'
- en: '`FrontendAction::ExecuteAction(…)`: This callback describes the main actions
    to do for this `FrontendAction`. Note that while no one stops you from overriding
    this method directly, many of FrontendAction''s derived classes already provide
    simpler interfaces to describe some common tasks. For example, if you want to
    process an AST, you should inherit from `ASTFrontendAction` instead and leverage
    its infrastructures.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontendAction::ExecuteAction(…)`: 这个回调描述了为这个 `FrontendAction` 需要执行的主要操作。请注意，虽然没有人阻止你直接覆盖这个方法，但许多
    `FrontendAction` 的派生类已经提供了更简单的接口来描述一些常见任务。例如，如果你想处理一个 AST，你应该从 `ASTFrontendAction`
    继承并利用其基础设施。'
- en: '`FrontendAction::CreateASTConsumer(…)`: This is a factory function that''s
    used to create an `ASTConsumer` instance, which is a group of callbacks that will
    be invoked by the frontend when it''s traversing different parts of the AST (for
    example, a callback to be called when the frontend encounters a group of declarations).
    Note that while the majority of FrontendActions work after the AST has been generated,
    the AST might not be generated at all. This may happen if the user only wants
    to run the preprocessor, for example (such as to dump the preprocessed content
    using Clang''s `-E` command-line option). Thus, you don''t always need to implement
    this function in your custom `FrontendAction`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontendAction::CreateASTConsumer(…)`: 这是一个工厂函数，用于创建 `ASTConsumer` 实例，它是一组回调，当前端遍历
    AST 的不同部分时会被调用（例如，当前端遇到一组声明时会被调用的回调）。请注意，尽管大多数 FrontendAction 的工作是在 AST 生成之后，但
    AST 可能根本不会生成。这可能发生在用户只想运行预处理器的情况下（例如，使用 Clang 的 `-E` 命令行选项来转储预处理器的内容）。因此，你不必总是实现你自定义的
    `FrontendAction` 中的这个函数。'
- en: Again, normally, you won't derive your class directly from `FrontendAction`,
    but understanding FrontendAction's internal role in Clang and its interfaces can
    give you more material to work with when it comes to tooling or plugin development.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，通常你不会直接从 `FrontendAction` 派生你的类，但了解 FrontendAction 在 Clang 中的内部角色及其接口，可以在进行工具或插件开发时为你提供更多的材料。
- en: Clang plugins
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang 插件
- en: A Clang plugin allows you to dynamically register a new `FrontendAction` (more
    specifically, an `ASTFrontendAction`) that can process the AST either before or
    after, or even replace, the main action of `clang`. A real-world example can be
    found in the `virtual` keyword has been placed on methods that should be virtual.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 插件允许你动态注册一个新的 `FrontendAction`（更具体地说，是一个 `ASTFrontendAction`），它可以在 `clang`
    的主要动作之前、之后，甚至替换主要动作来处理 AST。一个现实世界的例子是将 `virtual` 关键字放置在应该为虚拟的方法上。
- en: 'A plugin can be easily loaded into a normal `clang` by using simple command-line
    options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用简单的命令行选项将插件轻松加载到普通的 `clang` 中：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is really useful if you want to customize the compilation but have no control
    over the `clang` executable (that is, you can't use a modified version of `clang`).
    In addition, using the Clang plugin allows you to integrate with the build system
    more tightly; for example, if you want to rerun your logic once the source files
    or even arbitrary build dependencies have been modified. Since the Clang plugin
    is still using `clang` as the driver and modern build systems are pretty good
    at resolving normal compilation command dependencies, this can be done by making
    a few compile flag tweaks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义编译但没有控制 `clang` 可执行文件（即你不能使用修改过的 `clang` 版本），这非常有用。此外，使用 Clang 插件允许你更紧密地集成到构建系统中；例如，如果你想在源文件或任意构建依赖项被修改后重新运行你的逻辑。由于
    Clang 插件仍然使用 `clang` 作为驱动程序，而现代构建系统在解析常规编译命令依赖项方面相当出色，这可以通过对编译标志进行一些调整来实现。
- en: However, the biggest downside of using the Clang plugin is its `clang` executable,
    but only if the C++ APIs (and the ABI) are used by your plugin and the `clang`
    executable matches it. Unfortunately, for now, Clang (and also the whole LLVM
    project) has no intention to make any of its C++ APIs stable. In other words,
    to take the safest path, you need to make sure both your plugin and `clang` are
    using the *exact same* (major) version of LLVM. This issue makes the Clang plugin
    pretty hard to be released standalone.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Clang 插件的最大缺点是其 `clang` 可执行文件，但这仅当你的插件使用了 C++ API（以及 ABI）并且 `clang` 可执行文件与之匹配时。不幸的是，目前
    Clang（以及整个 LLVM 项目）没有意向使其任何 C++ API 稳定。换句话说，为了走最安全的路线，你需要确保你的插件和 `clang` 都使用完全相同的（主要）版本的
    LLVM。这个问题使得 Clang 插件很难独立发布。
- en: We will look at this in more detail in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 7 章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093) 中更详细地探讨这个问题，*处理
    AST*。
- en: LibTooling and Clang Tools
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LibTooling 和 Clang Tools
- en: '`clang` executable. Also, the APIs are designed to be more high-level so that
    you don''t need to deal with many of Clang''s internal details, making it more
    friendly to non-Clang developers.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang` 可执行文件。此外，API 被设计得更加高级，这样你就不需要处理许多 Clang 的内部细节，使其对非 Clang 开发者更加友好。'
- en: '**Language server** is one of the most famous use cases of libTooling. A Language
    server is launched as a daemon process and accepts requests from editors or IDEs.
    These requests can be as simple as syntax checking a code snippet or complicated
    tasks such as code completions. While a Language server does not need to compile
    the incoming source code into native code as normal compilers do, it needs a way
    to parse and analyze that code, which is non-trivial to build from scratch. libTooling
    avoids the need to *recreate the wheels* in this case by taking Clang''s techniques
    off-the-shelf and providing an easier interface for Language server developers.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言服务器**是libTooling最著名的用例之一。语言服务器作为一个守护进程启动，并接受来自编辑器或IDE的请求。这些请求可能非常简单，如检查代码片段的语法，或者非常复杂，如代码补全。虽然语言服务器不需要像普通编译器那样将传入的源代码编译成本地代码，但它需要一种方式来解析和分析该代码，这从头开始构建是非平凡的。libTooling通过采用Clang的技术并为语言服务器开发者提供一个更简单的接口，避免了在这种情况下需要“重新造轮子”的需求。'
- en: 'To give you a more concrete idea of how libTooling differs from the Clang plugin,
    here is a (simplified) code snippet for executing a custom `ASTFrontendAction`
    called `MyCustomAction`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更具体地了解libTooling与Clang插件的区别，这里有一个（简化的）代码片段，用于执行一个名为`MyCustomAction`的自定义`ASTFrontendAction`：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown in the previous code, you can't just embed this code into *any* code
    base. libTooling also provides lots of nice utilities, such as `CommonOptionsParser`,
    which parses textual command-line options and transforms them into Clang options
    for you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，你不能随意将此代码嵌入到任何代码库中。libTooling还提供了许多有用的工具，例如`CommonOptionsParser`，它可以解析文本命令行选项并将它们转换为Clang选项。
- en: libTooling's API Stability
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: libTooling的API稳定性
- en: Unfortunately, libTooling doesn't provide stable C++ APIs either. Nevertheless,
    this isn't a problem since you have full control over what LLVM version you're
    using.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，libTooling也没有提供稳定的C++ API。然而，这并不是问题，因为你完全控制着使用的LLVM版本。
- en: 'Last but not least, `clang-refactor` to refactor the code. This includes renaming
    a variable, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`clang-refactor`用于重构代码。这包括重命名变量，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to rename the `Lat` member variable in the `Location` struct `Latitude`,
    we can use the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重命名`Location`结构体中的`Lat`成员变量`Latitude`，我们可以使用以下命令：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building clang-refactor
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建clang-refactor
- en: Be sure to follow the instructions at the beginning of this chapter to include
    `clang-tools-extra` in the list for the `LLVM_ENABLE_PROJECTS` CMake variable.
    By doing this, you'll be able to build `clang-refactor` using the `ninja clang-refactor`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必遵循本章开头的说明，将`clang-tools-extra`包含在`LLVM_ENABLE_PROJECTS` CMake变量的列表中。通过这样做，您将能够使用`ninja
    clang-refactor`命令构建`clang-refactor`。
- en: 'You will get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is done by the refactoring framework built inside libTooling; `clang-refactor`
    merely provides a command-line interface for it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由libTooling内部构建的重构框架完成的；`clang-refactor`仅仅为其提供了一个命令行接口。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how Clang is organized and the functionalities
    of some of its important subsystems and components. Then, we learned about the
    differences between Clang's major extension and tooling options – the Clang plugin,
    libTooling, and Clang Tools – including what each of them looks like and what
    their pros and cons are. The Clang plugin provides an easy way to insert custom
    logic into Clang's compilation pipeline via dynamically loaded plugins but suffers
    from API stability issues; libTooling has a different focus than the Clang plugin
    in that it aims to provide a toolbox for developers to create a standalone tool;
    and Clang Tools provides various applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Clang的组织结构以及一些重要子系统组件的功能。然后，我们了解了Clang的主要扩展和工具选项之间的区别——Clang插件、libTooling和Clang
    Tools——包括它们的外观以及它们的优缺点。Clang插件通过动态加载的插件提供了一种简单的方法将自定义逻辑插入到Clang的编译管道中，但存在API稳定性问题；libTooling与Clang插件的关注点不同，它旨在为开发者提供一个工具箱以创建独立工具；Clang
    Tools提供了各种应用。
- en: In the next chapter, we will talk about preprocessor development. We will learn
    how the preprocessor and the lexer work in Clang, and show you how to write plugins
    for the sake of customizing preprocessing logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论预处理器开发。我们将学习预处理器和词法分析器在Clang中的工作方式，并展示如何编写插件以定制预处理逻辑。
- en: Further reading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is a list of checks that are done by Chromium''s Clang plugin: [https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h](https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是Chromium的Clang插件执行的检查列表：[https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h](https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h).
- en: 'You can learn more about choosing the right Clang extension interface here:
    [https://clang.llvm.org/docs/Tooling.html](https://clang.llvm.org/docs/Tooling.html).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于选择正确的Clang扩展接口的信息：[https://clang.llvm.org/docs/Tooling.html](https://clang.llvm.org/docs/Tooling.html).
- en: 'LLVM also has its own libTooling-based Language server, called `clangd`: [http://clangd.llvm.org](http://clangd.llvm.org).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM还有一个基于libTooling的自己的语言服务器，称为`clangd`：[http://clangd.llvm.org](http://clangd.llvm.org).
