- en: '*Chapter 18*: Particle Systems and Shaders'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第18章*：粒子系统和着色器'
- en: In this chapter, we will look at what a particle system is and then go ahead
    and code one into our game. We will scratch the surface of the topic of OpenGL
    shaders and see how writing code in another language (**GLSL**), that can be run
    directly on the graphics card, can lead to smooth graphical effects that might
    otherwise be impossible. As usual, we will also use our new skills and knowledge
    to enhance the current project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨粒子系统是什么，然后将其编码到我们的游戏中。我们将探讨OpenGL着色器的基础，并看看用另一种语言（**GLSL**）编写代码，该代码可以直接在图形卡上运行，可以产生可能无法实现的平滑图形效果。像往常一样，我们也将使用我们的新技能和知识来增强当前项目。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a particle system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建粒子系统
- en: OpenGL shaders and GLSL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL着色器和GLSL
- en: Using shaders in the Thomas Was Late game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《托马斯迟到》游戏中使用着色器
- en: Building a particle system
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建粒子系统
- en: Before we start coding, it will be helpful to see exactly what it is that we
    are trying to achieve.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，看看我们究竟要实现什么是非常有帮助的。
- en: 'Take a look at the following diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表：
- en: '![](img/B14278_18_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_18_01.jpg)'
- en: The previous illustration is a screenshot of the particle effect on a plain
    background. We will use this effect in our game. We will spawn one of these effects
    each time the player dies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的插图是粒子效果在普通背景上的截图。我们将在我们的游戏中使用这个效果。每当玩家死亡时，我们将生成这些效果之一。
- en: 'The way we achieve this effect is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现这种效果的方式如下：
- en: First, we spawn 1,000 dots (particles), one on top of the other, at a chosen
    pixel position.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在一个选定的像素位置生成 1,000 个点（粒子），一个叠在另一个上面。
- en: Each frame of the game moves each of the 1,000 particles outwards at a predetermined
    but random speed and angle.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏的每一帧都会将 1,000 个粒子以预定的但随机的速度和角度向外移动。
- en: Repeat step two for two seconds and then make the particles disappear.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复第二步两秒钟，然后让粒子消失。
- en: We will use a `VertexArray` to draw all the dots and the primitive type of `Point`
    to represent each particle visually. Furthermore, we will inherit from the SFML
    `Drawable` class so that our particle system can take care of drawing itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `VertexArray` 来绘制所有点，并使用 `Point` 的原始类型来在视觉上表示每个粒子。此外，我们将从SFML的 `Drawable`
    类继承，这样我们的粒子系统就可以负责绘制自己。
- en: Coding the Particle class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码粒子类
- en: The `Particle` class will be a simple class that represents just one particle
    from a thousand particles. Let's get coding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle` 类将是一个简单的类，它只代表一千个粒子中的一个。让我们开始编码。'
- en: Coding Particle.h
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码 `Particle.h`
- en: Right-click `Particle.h`. Finally, click the `Particle` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `Particle.h`。最后，点击 `Particle` 类。
- en: 'Add the following code to the `Particle.h` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Particle.h` 文件中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have two `Vector2f` objects. One will represent the
    horizontal and vertical coordinate of the particle, while the other will represent
    the horizontal and vertical speed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个 `Vector2f` 对象。一个将代表粒子的水平和垂直坐标，而另一个将代表水平和垂直速度。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When you have a rate of change (speed) in more than one direction, the combined
    values also define a direction. This is called `Vector2f` is called `m_Velocity`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在多个方向上有变化率（速度）时，组合的值也定义了一个方向。这个 `Vector2f` 被称为 `m_Velocity`。
- en: We also have several public functions. First is the constructor. It takes a
    `Vector2f` and uses this to let it know which direction/velocity this particle
    will have. This implies that the system, not the particle itself, will be choosing
    the velocity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个公共函数。首先是构造函数。它接受一个 `Vector2f` 并使用它来让系统知道这个粒子将有什么方向/速度。这意味着系统，而不是粒子本身，将选择速度。
- en: Next is the `update` function, which takes the time the previous frame has taken.
    We will use this to move the particle by precisely the correct amount.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `update` 函数，它接受上一帧所花费的时间。我们将使用这个时间来精确地移动粒子。
- en: The final two functions, `setPosition` and `getPosition`, are used to move the
    particle in position and find out its position, respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数，`setPosition` 和 `getPosition`，用于移动粒子的位置和分别找出其位置。
- en: All of these functions will make complete sense when we code them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编码这些函数时，它们都将完全有意义。
- en: Coding the Particle.cpp file
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码 `Particle.cpp` 文件
- en: Right-click `Particle.cpp`. Finally, click the `.cpp` file for the `Particle`
    class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `Particle.cpp`。最后，点击 `Particle` 类的 `.cpp` 文件。
- en: 'Add the following code to `Particle.cpp`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Particle.cpp`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of these functions use concepts we have seen before. The constructor sets
    up the `m_Velocity.x` and `m_Velocity.y` values using the passed in `Vector2f`
    object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都使用了我们之前见过的概念。构造函数使用传入的`Vector2f`对象设置`m_Velocity.x`和`m_Velocity.y`值。
- en: The `update` function moves the horizontal and vertical positions of the particle
    by multiplying `m_Velocity` by the elapsed time (`dtAsSeconds`). Notice how, to
    achieve this, we simply add the two `Vector2f` objects together. There is no need
    to perform calculations for both the x and y members separately.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数通过将`m_Velocity`乘以经过的时间(`dtAsSeconds`)来移动粒子的水平和垂直位置。注意，为了实现这一点，我们只需将两个`Vector2f`对象相加即可。没有必要分别对x和y成员进行计算。'
- en: The `setPosition` function, as we explained previously, initializes the `m_Position`
    object with the passed in values. The `getPosition` function returns `m_Position`
    to the calling code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition`函数，正如我们之前解释的，使用传入的值初始化`m_Position`对象。`getPosition`函数将`m_Position`返回给调用代码。'
- en: We now have a fully functioning `Particle` class. Next, we will code a `ParticleSystem`
    class to spawn and control the particles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完全功能的`Particle`类。接下来，我们将编写一个`ParticleSystem`类来生成和控制粒子。
- en: Coding the ParticleSystem class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写ParticleSystem类
- en: The `ParticleSystem` class does most of the work for our particle effects. It
    is this class that we will create an instance of in the `Engine` class. Before
    we do, however, let's talk a little bit more about OOP and the SFML `Drawable`
    class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`类为我们处理大部分粒子效果的工作。我们将在这个`Engine`类中创建这个类的实例。在我们这样做之前，让我们再谈谈面向对象编程和SFML的`Drawable`类。'
- en: Exploring SFML's Drawable class and OOP
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SFML的Drawable类和面向对象编程
- en: The `Drawable` class has just one function. It has no variables either. Furthermore,
    its one and only function is pure virtual. This means that, if we inherit from
    `Drawable`, we must implement its one and only function. The purpose, as a reminder
    from [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *Abstraction
    and Code Management – Making Better Use of OOP*, is that we can then use our class
    that inherits from `drawable` as a polymorphic type. Put more simply, anything
    that SFML allows us to do with a `Drawable` object, we will be able to do with
    our class that inherits from it. The only requirement is that we must provide
    a definition for the pure virtual function, `draw`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawable`类只有一个函数。它也没有变量。此外，它的唯一函数是纯虚函数。这意味着，如果我们从`Drawable`继承，我们必须实现它的唯一函数。提醒一下，从[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)，*抽象和代码管理
    – 更好地利用面向对象编程*，我们的类可以继承自`drawable`作为多态类型。更简单地说，我们可以用继承自`Drawable`的类做任何SFML允许我们对`Drawable`对象做的事情。唯一的要求是我们必须为纯虚函数`draw`提供一个定义。'
- en: Some classes that inherit from `Drawable` already include `Sprite` and `VertexArray`
    (among others). Whenever we have used `Sprite` or `VertexArray`, we passed them
    to the `draw` function of the `RenderWindow` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些继承自`Drawable`的类已经包括`Sprite`和`VertexArray`（以及其他）。每次我们使用`Sprite`或`VertexArray`时，我们都会将它们传递给`RenderWindow`类的`draw`函数。
- en: The reason that we have been able to draw every object we have ever drawn, in
    this entire book, is because they have all been inherited from `Drawable`. We
    can use this knowledge to our advantage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能够在这整本书中绘制出我们曾经绘制过的每一个对象，是因为它们都继承自`Drawable`。我们可以利用这一知识来发挥优势。
- en: 'We can inherit from `Drawable` with any object we like, as long as we implement
    the pure virtual `draw` function. This is also a straightforward process. Consider
    a hypothetical `SpaceShip` class. The header file (`SpaceShip.h`) of the `SpaceShip`
    class that inherits from `Drawable` would look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们喜欢的任何对象继承自`Drawable`，只要我们实现了纯虚函数`draw`。这也是一个简单直接的过程。考虑一个假设的`SpaceShip`类。继承自`Drawable`的`SpaceShip`类的头文件(`SpaceShip.h`)可能看起来像这样：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, we can see the pure virtual `draw` function and a `Sprite`
    instance. Notice there is no way to access the private `Sprite` outside of the
    class – not even a `getSprite` function!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到纯虚函数`draw`和一个`Sprite`实例。注意，在类外部无法访问私有的`Sprite` – 甚至没有`getSprite`函数！
- en: 'The `SpaceShip.cpp` file would look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpaceShip.cpp`文件可能看起来像这样：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code, notice the simple implementation of the `draw` function.
    The parameters are beyond the scope of this book. Just note that the `target`
    parameter is used to call `draw` and passes in `m_Sprite` as well as `states`,
    the other parameter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意 `draw` 函数的简单实现。这些参数超出了本书的范围。只需记住，`target` 参数用于调用 `draw` 函数，并传入 `m_Sprite`
    以及其他参数。
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'While it is not necessary to understand the parameters to take full advantage
    of `Drawable`, in the context of this book, you might be intrigued. You can read
    more about SFML `Drawable` on the SFML website here: [https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php](https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理解参数并非充分利用 `Drawable` 的必要条件，但在本书的语境中，你可能对此感到好奇。你可以在 SFML 网站上了解更多关于 SFML `Drawable`
    的信息：[https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php](https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php)。
- en: 'In the main game loop, we could now treat a `SpaceShip` instance as if it were
    a `Sprite` or any other class that inherits from `Drawable`, like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在主游戏循环中，我们现在可以将 `SpaceShip` 实例视为 `Sprite` 或任何继承自 `Drawable` 的其他类，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is because `SpaceShip` `Drawable` that we can treat it like it was a `Sprite`
    or `VertexArray` and, because we overrode the pure virtual `draw` function, everything
    just works as we want it to. You will use this approach in this chapter to draw
    the particle system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为 `SpaceShip` 是 `Drawable`，我们才能将其视为 `Sprite` 或 `VertexArray`，并且因为我们重写了纯虚函数
    `draw`，所以一切都能按预期工作。你将在本章中使用这种方法来绘制粒子系统。
- en: While we are on the subject of OOP, let's look at an alternative way of encapsulating
    the drawing code into the game object that we will use in the next project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论面向对象编程（OOP）的主题时，让我们看看将绘图代码封装到游戏对象中的另一种方法，这是我们将在下一个项目中使用的方法。
- en: An alternative to inheriting from Drawable
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承自 `Drawable` 的替代方案
- en: 'It is also possible to keep all the drawing functionality within the class
    that is the object to be drawn by implementing our own function, within our class,
    perhaps by using the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在类中实现自己的函数，我们也可以将所有绘图功能保留在要绘制的对象所在的类中，例如使用以下代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous code assumes that `m_Sprite` represents the visual appearance
    of the current class we are drawing, as it has throughout this and the previous
    project. Assuming that the instance of the class that contains the `drawThisObject`
    function is called `playerHero` and further assuming we have an instance of `RenderWindow`
    called `m_Window`, we could then draw the object from the main game loop with
    this code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码假设 `m_Sprite` 代表当前我们正在绘制的类的视觉外观，正如在本项目和上一个项目中一样。假设包含 `drawThisObject` 函数的类的实例被称作
    `playerHero`，并且进一步假设我们有一个名为 `m_Window` 的 `RenderWindow` 实例，我们就可以使用以下代码从主游戏循环中绘制对象：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this solution, we pass the `RenderWindow`, `m_Window`, into the `drawThisObject`
    function as a parameter. The `drawThisObject` function then uses `RenderWindow`
    to draw the `Sprite`, `m_Sprite`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们将 `RenderWindow` 的 `m_Window` 作为参数传递给 `drawThisObject` 函数。然后，`drawThisObject`
    函数使用 `RenderWindow` 来绘制 `Sprite`，`m_Sprite`。
- en: If we have a more complicated set of game objects, then passing a reference
    of `RenderWindow` to the object to be drawn, each frame, so it can draw itself,
    is a good tactic.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一组更复杂的游戏对象，那么在每一帧将 `RenderWindow` 的引用传递给要绘制的对象，以便它能够自行绘制，这是一种很好的策略。
- en: We will use this tactic in the final project of this book, which we will start
    in the next chapter. Let's finish the particle system by coding the `ParticleSystem`
    class, which will inherit from `Drawable`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的最终项目中使用这种策略，我们将在下一章开始。让我们通过编码继承自 `Drawable` 的 `ParticleSystem` 类来完成粒子系统，这将继承自
    `ParticleSystem` 类。
- en: Coding ParticleSystem.h
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码 `ParticleSystem.h`
- en: Right-click `ParticleSystem.h`. Finally, click the `ParticleSystem` class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `ParticleSystem.h`。最后，点击 `ParticleSystem` 类。
- en: 'Add the code for the `ParticleSystem` class to `ParticleSystem.h`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ParticleSystem` 类的代码添加到 `ParticleSystem.h` 中：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's go through this a bit at a time. First, notice that we are inheriting
    from SFML's `Drawable` class. This is what will allow us to pass our `ParticleSystem`
    instance to `m_Window.draw`, because `ParticleSystem` `Drawable`. And, since we
    inherit from `Drawable`, we can override the `draw` function using the same function
    signature as the `Drawable` class uses internally. Shortly, when we use the `ParticleSystem`
    class, we will see the following code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一点一点地来。首先，注意我们正在继承自 SFML 的 `Drawable` 类。这将允许我们将 `ParticleSystem` 实例传递给 `m_Window.draw`，因为
    `ParticleSystem` `Drawable`。而且，由于我们继承自 `Drawable`，我们可以使用与 `Drawable` 类内部使用的相同函数签名来重写
    `draw` 函数。简而言之，当我们使用 `ParticleSystem` 类时，我们会看到以下代码。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `m_PS` object is an instance of our `ParticleSystem` class, and we will
    pass it directly to the `draw` function of the `RenderWindow` class, just like
    we have done for the `Sprite`, `VertexArray`, and `RectangleShape` instances.
    All this is made possible by the power of inheritance and polymorphism.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_PS` 对象是我们 `ParticleSystem` 类的一个实例，我们将直接将其传递给 `RenderWindow` 类的 `draw` 函数，就像我们为
    `Sprite`、`VertexArray` 和 `RectangleShape` 实例所做的那样。所有这一切都是通过继承和多态的力量实现的。'
- en: Tip
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don't add the `m_Window.draw…` code just yet; we have a bit more work to do
    first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要添加 `m_Window.draw…` 代码；我们还有更多的工作要做。
- en: There is a vector named `m_Particles` of the `Particle` type. This vector will
    hold each and every instance of `Particle`. Next, we have a `VertexArray` called
    `m_Vertices`. This will be used to draw all the particles in the form of a whole
    bunch of `Point` primitives.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `m_Particles` 的 `Particle` 类型的向量。这个向量将保存每个 `Particle` 实例。接下来，我们有一个名为 `m_Vertices`
    的 `VertexArray`。这将用于以大量 `Point` 原语的形式绘制所有粒子。
- en: The `m_Duration`, `float` variable is how long each effect will last. We will
    initialize it in the constructor function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_Duration`，`float` 变量表示每个效果将持续多长时间。我们将在构造函数中初始化它。'
- en: The `m_IsRunning` Boolean variable will be used to indicate whether the particle
    system is currently in use or not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_IsRunning` 布尔变量将用于指示粒子系统是否正在使用中。'
- en: Next, in the public section, we have the pure virtual function, `draw`, that
    we will soon implement to handle what happens when we pass our instance of `ParticleSystem`
    to `m_Window.draw`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在公共部分，我们有一个纯虚函数 `draw`，我们很快就会实现它来处理当我们传递 `ParticleSystem` 实例到 `m_Window.draw`
    时会发生什么。
- en: The `init` function will prepare the `VertexArray` and the `vector`. It will
    also initialize all the `Particle` objects (held by the `vector`) with their velocities
    and initial positions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数将准备 `VertexArray` 和 `vector`。它还将使用速度和初始位置初始化所有 `Particle` 对象（由 `vector`
    持有）。'
- en: The `update` function will loop through each `Particle` instance in the `vector`
    and call their individual `update` functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数将遍历 `vector` 中的每个 `Particle` 实例，并调用它们的单个 `update` 函数。'
- en: The `running` function provides access to the `m_IsRunning` variable so that
    the game engine can query whether the `ParticleSystem` is currently in use.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`running` 函数提供了访问 `m_IsRunning` 变量的权限，以便游戏引擎可以查询 `ParticleSystem` 是否正在使用中。'
- en: Let's code the function definitions to see what goes on inside `ParticleSystem`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写函数定义，看看 `ParticleSystem` 内部发生了什么。
- en: Coding the ParticleSystem.cpp file
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 `ParticleSystem.cpp` 文件
- en: Right-click `ParticleSystem.cpp`. Finally, click the `.cpp` file for the `ParticleSystem`
    class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `ParticleSystem.cpp`。最后，点击 `ParticleSystem` 类的 `.cpp` 文件。
- en: 'We will split this file into five sections so that we can code and discuss
    it in more detail. Add the first section of code, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件分成五个部分，这样我们就可以更详细地进行编码和讨论。添加以下代码的第一部分：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the necessary `includes`, we have the definition of the `init` function.
    We call `setPrimitiveType` with `Points` as the argument so that `m_VertexArray`
    knows what type of primitives it will be dealing with. We resize `m_Vertices`
    with `numParticles`, which was passed in to the `init` function when it was called.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要的 `includes` 之后，我们有 `init` 函数的定义。我们使用 `Points` 作为参数调用 `setPrimitiveType`，以便
    `m_VertexArray` 知道它将处理哪种类型的原语。我们使用 `numParticles` 调整 `m_Vertices` 的大小，这是在调用 `init`
    函数时传递给它的。
- en: The `for` loop creates random values for speed and angle. It then uses trigonometric
    functions to convert those values into a vector which is stored in the `Vector2f`,
    `direction`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环为速度和角度创建随机值。然后使用三角函数将这些值转换为存储在 `Vector2f`，`direction` 中的向量。'
- en: Tip
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to know more about how the trigonometric functions (`cos` and `sin`)
    convert angles and speeds into a vector, then you can take a look at this article
    series: [http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于如何使用三角函数（`cos`和`sin`）将角度和速度转换为向量，你可以查看这篇文章系列：[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)。
- en: The last thing that happens in the `for` loop (and the `init` function) is that
    the vector is passed into the `Particle` constructor. The new `Particle` instance
    is stored in `m_Particles` using the `push_back` function. Therefore, a call to
    `init` with a value of `1000` would mean we have 1,000 instances of `Particle`,
    with random velocity, stashed away in `m_Particles`, just waiting to blow!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环（以及`init`函数）中最后发生的事情是将向量传递给`Particle`构造函数。新的`Particle`实例使用`push_back`函数存储在`m_Particles`中。因此，调用`init`并传入`1000`的值意味着我们在`m_Particles`中有1,000个`Particle`实例，它们具有随机速度，正等待着爆炸！
- en: 'Next, add the `update` function to `ParticleSysytem.cpp`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`update`函数添加到`ParticleSysytem.cpp`中：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `update` function is simpler than it looks at first glance. First of all,
    `m_Duration` is reduced by the passed in time, `dt`. This is so we know when the
    two seconds have elapsed. A vector iterator, `i`, is declared for use with `m_Particles`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数看起来比实际要简单。首先，`m_Duration`通过传入的时间`dt`减少。这样我们就可以知道两秒钟是否已经过去。声明了一个向量迭代器`i`用于`m_Particles`。'
- en: The `for` loop goes through each of the `Particle` instances in `m_Particles`.
    For each one, it calls its `update` function and passes in `dt`. Each particle
    will update its position.  After the particle has updated itself, the appropriate
    vertex in `m_Vertices` is updated by using the particle's `getPosition` function.
    At the end of each pass through the `for` loop, `currentVertex` is incremented,
    ready for the next vertex.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历`m_Particles`中的每个`Particle`实例。对于每一个实例，它调用其`update`函数并传入`dt`。每个粒子将更新其位置。粒子更新后，使用粒子的`getPosition`函数更新`m_Vertices`中适当的顶点。每次`for`循环结束时，`currentVertex`增加，为下一个顶点做准备。'
- en: After the `for` loop has completed the code, `if(m_Duration < 0)` checks whether
    it is time to switch off the effect. If two seconds have elapsed, `m_IsRunning`
    is set to `false`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环完成后，代码检查`if(m_Duration < 0)`是否是时候关闭效果。如果已经过去了两秒钟，`m_IsRunning`被设置为`false`。'
- en: 'Next, add the `emitParticles` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`emitParticles`函数：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the function we will call to start the particle system. So predictably,
    we set `m_IsRunning` to `true` and `m_Duration` to `2`. We declare an `iterator`,
    `i`, to iterate through all the `Particle` objects in `m_Particles` and then we
    do so in a `for` loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将调用来启动粒子系统的函数。所以，不出所料，我们将`m_IsRunning`设置为`true`，将`m_Duration`设置为`2`。我们声明了一个迭代器`i`来遍历`m_Particles`中的所有`Particle`对象，然后在`for`循环中这样做。
- en: Inside the `for` loop, we set each particle in the vertex array to yellow and
    set each position to `startPosition`, which was passed in as a parameter. Remember
    that each particle starts life in the same position, but they are each assigned
    a different velocity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内部，我们将顶点数组中的每个粒子设置为黄色，并将每个位置设置为传入的参数`startPosition`。记住，每个粒子从相同的位置开始，但它们被分配了不同的速度。
- en: 'Next, add the pure virtual `draw` function definition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加纯虚`draw`函数的定义：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we simply use `target` to call `draw`, passing `m_Vertices`
    and `states` as parameters. Remember that we will never call this function directly!
    Shortly, when we declare an instance of `ParticleSystem`, we will pass that instance
    to the `RenderWindow draw` function. The `draw` function we have just coded will
    be called internally from there.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们简单地使用`target`调用`draw`，传入`m_Vertices`和`states`作为参数。记住，我们永远不会直接调用这个函数！不久，当我们声明`ParticleSystem`的实例时，我们将该实例传递给`RenderWindow
    draw`函数。我们刚刚编写的`draw`函数将从那里内部调用。
- en: 'Finally, add the `running` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`running`函数：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `running` function is a simple getter function that returns the value of
    `m_IsRunning`. We will see where this is useful in this chapter, so that we can
    determine the current state of the particle system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`running`函数是一个简单的getter函数，它返回`m_IsRunning`的值。我们将在本章中看到它的用途，以便我们可以确定粒子系统的当前状态。'
- en: Using the ParticleSystem object
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ParticleSystem`对象
- en: Putting our particle
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的粒子
- en: system to work is very straightforward, especially because we inherited from
    `Drawable`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 系统要工作的方式非常简单，尤其是在我们继承了`Drawable`之后。
- en: Adding a ParticleSystem object to the Engine class
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`ParticleSystem`对象添加到`Engine`类中
- en: 'Open `Engine.h` and add a `ParticleSystem` object, as shown in the following
    highlighted code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件，并添加一个`ParticleSystem`对象，如下所示突出显示的代码：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we need to initialize the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要初始化系统。
- en: Initializing ParticleSystem
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化粒子系统
- en: 'Open the `Engine.cpp` file and add the short highlighted code right at the
    end of the `Engine` constructor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.cpp`文件，并在`Engine`构造函数的末尾添加以下简短的突出显示代码：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `VertexArray` and the `vector` of `Particle` instances are ready for action.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexArray`和`Particle`实例的`vector`已经准备好行动了。'
- en: Updating the particle system each frame
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每帧更新粒子系统
- en: 'Open the `Update.cpp` file and add the following highlighted code. It can go
    right at the end of the `update` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Update.cpp`文件，并添加以下突出显示的代码。它可以直接放在`update`函数的末尾：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All that is needed in the previous code is the call to `update`. Notice that
    it is wrapped in a check to make sure the system is currently running. If it isn't
    running, there is no point updating it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中所需的一切就是调用`update`。注意，它被包裹在一个检查中，以确保系统目前正在运行。如果它没有运行，就没有更新它的必要。
- en: Starting the particle system
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动粒子系统
- en: Open the `DetectCollisions.cpp` file, which has the `detectCollisions` function
    in it. We left a comment in it when we originally coded it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`DetectCollisions.cpp`文件，其中包含`detectCollisions`函数。我们在最初编写代码时在其中留下了注释。
- en: 'Identify the correct place from the context and add the following highlighted
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从上下文中识别正确的位置，并添加以下突出显示的代码：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, the code checks if the particle system is already running. If it isn't,
    it checks if the current tile being checked is either a water or fire tile. If
    either is the case, it checks whether the character's feet are in contact with
    it. When each of these `if` statements are true, the particle system is started
    by calling the `emitParticles` function and passing in the location of the center
    of the character as the coordinates to start the effect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查粒子系统是否已经在运行。如果不是，它会检查当前正在检查的瓷砖是否是水或火瓷砖。如果是其中之一，它会检查角色的脚是否与之接触。当这些`if`语句中的每一个都为真时，通过调用`emitParticles`函数并传入角色的中心位置作为开始效果的坐标，粒子系统将通过调用`emitParticles`函数并传入角色的中心位置作为开始效果的坐标来启动。
- en: Drawing the particle system
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制粒子系统
- en: This is the best bit. See how easy it is to draw `ParticleSystem`. We pass our
    instance directly to the `m_Window.draw` function, after checking that the particle
    system is running.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最精彩的部分。看看绘制`ParticleSystem`有多简单。我们在确认粒子系统正在运行后，直接将我们的实例传递给`m_Window.draw`函数。
- en: 'Open the `Draw.cpp` file and add the following highlighted code in all the
    necessary places:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Draw.cpp`文件，并在所有必要的位置添加以下突出显示的代码：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we must draw the particle system in all of the left, right, and full-screen
    code blocks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须在所有左、右和全屏代码块中绘制粒子系统。
- en: 'Run the game and move one of the character''s feet over the edge of a fire
    tile. Notice the particle system burst into life:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，并将其中一个角色的脚移到火瓷砖的边缘。注意粒子系统瞬间活跃起来：
- en: '![](img/B14278_18_02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_18_02.jpg)'
- en: Now, it's time for something else that's new.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候介绍一些新的内容了。
- en: OpenGL, Shaders, and GLSL
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL、着色器和GLSL
- en: The **Open Graphics Library** (**OpenGL**) is a programming library that handles
    2D as well as 3D graphics. OpenGL works on all major desktop operating systems
    and there is also a version that works on mobile devices, known as OpenGL ES.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放图形库**（**OpenGL**）是一个处理2D和3D图形的编程库。OpenGL在所有主要的桌面操作系统上运行，还有一个版本可以在移动设备上运行，称为OpenGL
    ES。'
- en: OpenGL was originally released in 1992\. It has been refined and improved over
    more than twenty years. Furthermore, graphics card manufacturers design their
    hardware to make it work well with OpenGL. The point of mentioning this is not
    for the history lesson but to explain that it would be a fool's errand to try
    and improve upon OpenGL and use it in 2D (and 3D games) on the desktop, especially
    if we want our game to run on more than just Windows, which is the obvious choice.
    We are already using OpenGL because SFML uses OpenGL. Shaders are programs that
    run on the GPU itself. We'll find out more about them in the following section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL最初于1992年发布。经过二十多年的改进和优化。此外，显卡制造商设计他们的硬件以使其与OpenGL良好配合。提到这一点并不是为了历史课，而是为了解释尝试改进OpenGL并在桌面上的2D（和3D游戏）中使用它将是一个徒劳的行为，尤其是如果我们希望我们的游戏在Windows以外的操作系统上运行，这是显而易见的选择。我们已经在使用OpenGL，因为SFML使用了OpenGL。着色器是运行在GPU上的程序。我们将在下一节中了解更多关于它们的信息。
- en: The programmable pipeline and shaders
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可编程管道和着色器
- en: Through OpenGL, we have access to what is called a`RenderWindow` instance's
    `draw` function. We can also write code that runs on the GPU that can manipulate
    each and every pixel independently, after the call to `draw`. This is a very powerful
    feature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过OpenGL，我们可以访问`RenderWindow`实例的`draw`函数。我们还可以编写在调用`draw`之后可以在GPU上运行的代码，以独立操纵每个像素。这是一个非常强大的功能。
- en: This extra code that runs on the GPU is called a **shader program**. We can
    write code to manipulate the geometry (position) of our graphics in a **vertex
    shader**. We can also write code that manipulates the appearance of every pixel
    individually in code. This is known as a **fragment shader**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上运行的额外代码被称为**着色器程序**。我们可以编写代码来操纵我们的图形的几何（位置）在**顶点着色器**中。我们也可以编写代码来单独操纵每个像素的外观。这被称为**片段着色器**。
- en: Although we will not be exploring shaders in any great depth, we will write
    some shader code using the **GL Shader Language** (**GLSL**) and we will get a
    glimpse of the possibilities that it offers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会深入探讨着色器，但我们将使用**GL着色器语言**（**GLSL**）编写一些着色器代码，并一窥它提供的可能性。
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry, and we can also combine these
    elements to make the complex graphics that we see in today's modern games. These
    are collectively known as `VertexArray`, as well as the `Sprite` and `Shape` classes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，一切都是一个点、一条线或一个三角形。此外，我们还可以将颜色和纹理附加到这些基本几何形状上，我们还可以将这些元素组合起来，以制作出我们在现代游戏中看到的复杂图形。这些统称为`VertexArray`，以及`Sprite`和`Shape`类。
- en: In addition to primitives, OpenGL uses matrices. Matrices are a method and structure
    for performing arithmetic. This arithmetic can range from extremely simple high
    school-level calculations such as  moving (translating) a coordinate or it can
    be quite complex, such as performing more advanced mathematics, for example, to
    convert our game world coordinates into OpenGL screen coordinates that the GPU
    can use. Fortunately, it is this complexity that SFML handles for us behind the
    scenes. SFML also allows us to handle OpenGL directly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本图形元素外，OpenGL还使用矩阵。矩阵是一种进行算术运算的方法和结构。这种算术运算可以非常简单，例如移动（平移）坐标，也可以非常复杂，例如执行更高级的数学运算，例如将我们的游戏世界坐标转换为GPU可以使用的OpenGL屏幕坐标。幸运的是，SFML在幕后为我们处理了这种复杂性。SFML还允许我们直接处理OpenGL。
- en: Tip
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to find out more about OpenGL, you can get started here: [http://learnopengl.com/#!Introduction](http://learnopengl.com/#!Introduction).
    If you want to use OpenGL directly, alongside SFML, you can read this article
    to find out more: [https://www.sfml-dev.org/tutorials/2.5/window-opengl.php](https://www.sfml-dev.org/tutorials/2.5/window-opengl.php).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于OpenGL的信息，你可以从这里开始：[http://learnopengl.com/#!Introduction](http://learnopengl.com/#!Introduction)。如果你想直接使用OpenGL，同时使用SFML，你可以阅读这篇文章来获取更多信息：[https://www.sfml-dev.org/tutorials/2.5/window-opengl.php](https://www.sfml-dev.org/tutorials/2.5/window-opengl.php)。
- en: An application can have many shaders. We can then *attach* different shaders
    to different game objects to create the desired effects. We will only have one
    vertex and one fragment shader in this game. We will apply it to every frame,
    as well as to the background.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个着色器。然后我们可以将不同的着色器附加到不同的游戏对象上以创建所需的效果。在这个游戏中，我们只有一个顶点着色器和一个片段着色器。我们将将其应用于每一帧，以及背景。
- en: However, when you see how to attach a shader to a `draw` call, it will be plain
    that it is trivial to have more shaders.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你看到如何将着色器附加到 `draw` 调用时，很明显可以轻松地拥有更多着色器。
- en: 'We will follow these steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循以下步骤：
- en: First, we need the code for the shader that will be executed on the GPU.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为将在 GPU 上执行的着色器代码。
- en: Then, we need to compile that code.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要编译这段代码。
- en: Finally, we need to attach the shader to the appropriate `draw` function call
    in the draw function of our game engine.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将着色器附加到我们游戏引擎的绘制函数中适当的 `draw` 函数调用。
- en: GLSL is a language and it also has its own types, and variables of those types,
    which can be declared and utilized.  Furthermore, we can interact with the shader
    program's variables from our C++ code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 是一种语言，它也有自己的类型，以及这些类型的变量，可以声明和使用。此外，我们可以从我们的 C++ 代码中与着色器程序的变量进行交互。
- en: As we will see, GLSL has some syntax similarities to C++.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，GLSL 有一些与 C++ 的语法相似之处。
- en: Coding a fragment shader
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写片段着色器
- en: 'Here is the code from the `rippleShader.frag` file in the `shaders` folder.
    We don''t need to code this because it is in the assets that we added back in
    [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *Abstraction and
    Code Management – Making Better Use of OOP*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `shaders` 文件夹中 `rippleShader.frag` 文件的代码。我们不需要编写这个，因为它包含在我们之前添加的资产中，在 [*第
    14 章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)，*抽象和代码管理 – 更好地利用面向对象编程*：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first four lines (excluding comments) are the variables that the fragment
    shader will use, but they are not ordinary variables. The first type we can see
    is `varying`. These are variables which are in scope between both `shaders`. Next,
    we have the `uniform` variables. These variables can be manipulated directly from
    our C++ code. We will see how we do this soon.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行（不包括注释）是片段着色器将使用的变量，但它们不是普通变量。我们首先看到的是 `varying` 类型。这些变量在两个 `shaders` 之间都有作用域。接下来，我们有
    `uniform` 变量。这些变量可以直接从我们的 C++ 代码中操作。我们很快就会看到如何做到这一点。
- en: 'In addition to the `varying` and `uniform` types, each of the variables also
    has a more conventional type that defines the actual data, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `varying` 和 `uniform` 类型之外，每个变量还有一个更传统的类型，它定义了实际的数据，如下所示：
- en: '`vec4` is a vector with four values.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec4` 是一个包含四个值的向量。'
- en: '`vec2` is a vector with two values.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec2` 是一个包含两个值的向量。'
- en: '`sampler2d` will hold a texture.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampler2d` 将保存一个纹理。'
- en: '`float` is just like a `float data type` in C++.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 就像 C++ 中的 `float 数据类型`。'
- en: The code inside the `main` function is executed. If we look closely at the code
    in `main`, we will see each of the variables in use. Exactly what this code does
    is beyond the scope of the book. In summary, however, the texture coordinates
    (`vTexCoord`) and the color of the pixels/fragments (`glFragColor`) are manipulated
    by several mathematical functions and operations. Remember that this executes
    for each pixel involved in the `draw` function that's called on each frame of
    our game. Furthermore, be aware that `uTime` is passed in as a different value
    for each frame. The result, as we will soon see, will be a rippling effect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数内部的代码被执行。如果我们仔细查看 `main` 中的代码，我们会看到正在使用的每个变量。这段代码的确切功能超出了本书的范围。然而，总的来说，纹理坐标（`vTexCoord`）和像素/片段的颜色（`glFragColor`）通过几个数学函数和操作进行操作。请记住，这将在我们游戏的每一帧中调用的
    `draw` 函数涉及的每个像素上执行。此外，请注意 `uTime` 在每一帧中传递的值都不同。结果，正如我们很快将看到的，将会产生波纹效果。'
- en: Coding a vertex shader
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写顶点着色器
- en: 'Here is the code from the `vertShader.vert` file. You don''t need to code this.
    It was in the assets we added back in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `vertShader.vert` 文件的代码。您不需要编写这个。它包含在我们之前添加的资产中，在 [*第 14 章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)，*抽象和代码管理
    – 更好地利用面向对象编程*：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First of all, notice the two `varying` variables. These are the very same variables
    that we manipulated back in the fragment shader. In the `main` function, the code
    manipulates the position of each and every vertex. How the code works is beyond
    the scope of this book, but there is some quite in-depth mathematics going on
    behind the scenes. If it interests you, then exploring GLSL further will be fascinating.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意两个 `varying` 变量。这些正是我们在片段着色器中操作的变量。在 `main` 函数中，代码操作每个顶点的位置。代码的工作原理超出了本书的范围，但幕后有一些相当深入的数学运算。如果您对此感兴趣，那么进一步探索
    GLSL 将会非常有趣。
- en: Now that we have two shaders (one fragment and one vertex), we can use them
    in our game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个着色器（一个片段和一个顶点），我们可以在游戏中使用它们。
- en: Adding shaders to the engine class
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将着色器添加到引擎类中
- en: 'Open the `Engine.h` file. Add the following highlighted line of code, which
    adds an SFML `Shader` instance called `m_RippleShader` to the `Engine` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Engine.h` 文件。添加以下高亮显示的代码行，它将一个名为 `m_RippleShader` 的SFML `Shader` 实例添加到 `Engine`
    类中：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The engine object and all its functions now have access to `m_RippleShader`.
    Note that an SFML `Shader` object will be comprised of both shader code files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎对象及其所有功能现在都可以访问 `m_RippleShader`。请注意，一个SFML `Shader` 对象将包含着色器代码文件。
- en: Loading the shaders
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载着色器
- en: Add the following code, which checks whether the player's GPU can handle shaders.
    The game will quit if it can't.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，检查玩家的GPU是否可以处理着色器。如果不行，游戏将退出。
- en: Tip
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will have to have an exceptionally old PC for this not to work. If you do
    have a GPU that doesn't handle shaders, please accept my apologies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的GPU不能处理着色器，你需要有一台非常旧的PC才能使这个功能不起作用。如果你有一个不支持着色器的GPU，请接受我的道歉。
- en: 'Next, we will add an `else` clause that loads the shaders if the system can
    handle them. Open the `Engine.cpp` file and add this code to the constructor:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `else` 子句，如果系统可以处理着色器，则加载着色器。打开 `Engine.cpp` 文件，并将以下代码添加到构造函数中：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are nearly ready to see our ripple effect in action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以看到我们的涟漪效果在行动了。
- en: Updating and drawing the shader
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和绘制着色器
- en: Open the `Draw.cpp` file. As we already discussed when we coded the shaders,
    we will update the `uTime` variable directly from our C++ code each frame. We
    will do so with the `setParameter` function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Draw.cpp` 文件。正如我们在编写着色器时已经讨论过的，我们将直接从我们的C++代码中每帧更新 `uTime` 变量。我们将使用 `setParameter`
    函数这样做。
- en: 'Add the following highlighted code to update the shader''s `uTime` variable
    and change the call to `draw` for `m_BackgroundSprite`, in each of the possible
    drawing scenarios:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮显示的代码以更新着色器的 `uTime` 变量，并更改对 `m_BackgroundSprite` 的 `draw` 调用，在每个可能的绘制场景中：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It would be best to delete the lines of code that were commented out.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最好删除被注释掉的代码行。
- en: 'Run the game and you will get an eerie kind of molten rock. Experiment with
    changing the background image to have some fun:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你将得到一种神秘的熔岩岩石效果。尝试更改背景图像以获得乐趣：
- en: '![](img/B14278_18_03.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_18_03.jpg)'
- en: That's it! Our fourth game is done.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的第四个游戏完成了。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concepts of particle systems and shaders. Although
    we looked at probably the simplest possible case for each, we still managed to
    create a simple explosion and an eerie molten rock effect.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了粒子系统和着色器的概念。尽管我们可能已经看到了每个的最简单案例，但我们仍然设法创建了一个简单的爆炸和一个神秘的熔岩岩石效果。
- en: In the next four chapters, we will look at more ways that we can improve our
    code using design patterns at the same time as building a Space Invaders game.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的四章中，我们将探讨更多使用设计模式改进我们代码的方法，同时构建《太空侵略者》游戏。
