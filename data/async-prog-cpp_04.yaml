- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Thread Synchronization with Locks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: In [*Chapter 2*](B22219_02.xhtml#_idTextAnchor035) , we learned that threads
    can read and write memory shared by the process they belong to. While the operating
    system implements process memory access protection, there is no such protection
    for threads accessing shared memory in the same process. Concurrent memory write
    operations to the same memory address from multiple threads require synchronization
    mechanisms to avoid data races and ensure data integrity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第2章*](B22219_02.xhtml#_idTextAnchor035) 中，我们了解到线程可以读取和写入它们所属进程共享的内存。虽然操作系统实现了进程内存访问保护，但同一进程中对共享内存的线程访问没有这种保护。来自多个线程对同一内存地址的并发内存写操作需要同步机制来避免数据竞争并确保数据完整性。
- en: 'In this chapter, we will describe in detail the problems created by concurrent
    access to shared memory by multiple threads and how to fix them. We are going
    to study in detail the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细描述由多个线程对共享内存并发访问所引起的问题以及如何解决这些问题。我们将详细研究以下主题：
- en: Race conditions – what they are and how they can happen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件 – 它们是什么以及如何发生
- en: Mutual exclusion as a synchronization mechanism and how it is implemented in
    C++ by **std::mutex**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥作为同步机制及其在C++中通过 **std::mutex** 的实现
- en: Generic lock management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型锁管理
- en: What condition variables are and how to use them with mutexes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件变量是什么以及如何与互斥锁一起使用
- en: Implementing a fully synchronized queue using **std::mutex** and **std::condition_variable**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **std::mutex** 和 **std::condition_variable** 实现一个完全同步的队列
- en: The new synchronization primitives introduced with C++20 – semaphores, barriers,
    and latches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20引入的新同步原语 – 信号量、屏障和闩锁
- en: These are all lock-based synchronization mechanisms. Lock-free techniques are
    the subject of the next chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是基于锁的同步机制。无锁技术是下一章的主题。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter are the same as for the concepts
    explained in the previous chapter, and to compile and run the examples, a C++
    compiler with C++20 support is required (for semaphores, latches, and barriers
    examples). Most of the examples require just C++11. Examples have been tested
    on Linux Ubuntu LTS 24.04.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与上一章中解释的概念相同，要编译和运行示例，需要一个支持C++20的C++编译器（用于信号量、闩锁和屏障示例）。大多数示例只需要C++11。示例已在Linux
    Ubuntu LTS 24.04上测试。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: Understanding race conditions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解竞态条件
- en: A race condition happens when the outcome of running a program depends on the
    sequence in which its instructions are executed. We will begin with a very simple
    example to show how race conditions happen, and later in this chapter, we will
    learn how to resolve this problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行的输出结果取决于其指令执行的顺序时，就会发生竞态条件。我们将从一个非常简单的例子开始，展示竞态条件是如何发生的，然后在本章的后面部分，我们将学习如何解决这个问题。
- en: 'In the following code, the **counter** global variable is incremented by two
    threads running concurrently:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，**counter** 全局变量由两个并发运行的线程递增：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After running the preceding code three times, we get the following **counter**
    values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码三次后，我们得到以下 **counter** 值：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We see two main issues here: first, the value of **counter** is incorrect;
    second, every execution of the program ends with a different value of **counter**
    . The results are non-deterministic and most frequently incorrect. If you are
    very lucky, you may get the right values, but that is very unlikely.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了两个主要问题：首先，**counter** 的值是不正确的；其次，每次程序执行都以不同的 **counter** 值结束。结果是不可预测的，并且大多数情况下是错误的。如果你非常幸运，可能会得到正确的值，但这非常不可能。
- en: This scenario involves two threads, **t1** and **t2** , that run concurrently
    and modify the same variable, which is essentially some memory region. It seems
    like it should work fine because there is only one line of code that increases
    the **counter** value and thus modifies the memory content (by the way, it doesn’t
    matter if we use the post-increment operator like in **counter++** or the pre-increment
    operator like in **++counter** ; the results will be equally wrong).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况涉及两个线程，**t1**和**t2**，它们并发运行并修改相同的变量，本质上是一些内存区域。看起来它应该可以正常工作，因为只有一行代码增加了**计数器**的值，从而修改了内存内容（顺便说一句，我们使用后增量运算符如**counter++**或前增量运算符如**++counter**并不重要；结果都会同样错误）。
- en: 'Looking closer at the preceding code, let’s study the following line carefully:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察前面的代码，让我们仔细研究以下这一行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It increments **counter** in three steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过三个步骤增加**计数器**：
- en: The contents of the memory address where the **counter** variable is stored
    are loaded into a CPU register. In this case, an **int** data type is loaded from
    memory into a CPU register.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在**计数器**变量内存地址中的内容被加载到一个CPU寄存器中。在这种情况下，从内存中加载一个**int**数据类型到CPU寄存器中。
- en: The value in the register is incremented by one.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器中的值增加一。
- en: The value in the register is stored in the **counter** variable memory address.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器中的值存储在**计数器**变量内存地址中。
- en: 'Now, let us consider a possible scenario when two threads attempt to increment
    the counter concurrently. Let us look at *Table 4.1* :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个可能的情况，即当两个线程尝试并发地增加计数器时。让我们看看*表4.1*：
- en: '| **THREAD 1** | **THREAD 2** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **线程1** | **线程2** |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [1] Load counter value into register | [3] Load counter value into register
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| [1] 将计数器值加载到寄存器 | [3] 将计数器值加载到寄存器 |'
- en: '| [2] Increment register value | [5] Increment register value |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| [2] 增加寄存器值 | [5] 增加寄存器值 |'
- en: '| [4] Store register in counter | [6] Store register in counter |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| [4] 将寄存器存储到计数器 | [6] 将寄存器存储到计数器 |'
- en: 'Table 4.1: Two threads incrementing the counter concurrently'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：两个线程并发增加计数器
- en: Thread 1 executes [1] and loads the current value of the counter (let’s assume
    it is 1) into a CPU register. Then, it increments the value in the register by
    one [2] (now, the register value is 2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线程1执行[1]，并将计数器的当前值（假设是1）加载到一个CPU寄存器中。然后，它通过[2]将寄存器中的值增加一（现在，寄存器中的值是2）。
- en: Thread 2 is scheduled for execution and [3] loads the current value of the counter
    (remember – it has not been modified yet, so it is still 1) into a CPU register.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 线程2被调度执行，[3]将计数器的当前值（记住——它尚未被修改，所以仍然是1）加载到一个CPU寄存器中。
- en: Now, thread 1 is scheduled again for execution and [4] stores the updated value
    into memory. The value of **counter** is now equal to two.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，线程1再次被调度执行，[4]将更新后的值存储到内存中。此时，**计数器**的值现在是二。
- en: Finally, thread 2 is scheduled again, and [5] and [6] are executed. The register
    value is incremented by one and then the value two is stored in memory. The **counter**
    variable has been incremented just once when it should have been incremented twice
    and its value should be three.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，线程2再次被调度，并执行[5]和[6]。寄存器值增加一，然后将值二存储在内存中。**计数器**变量只增加了一次，而它应该增加两次，其值应该是三。
- en: The previous issue happened because the increment operation on the counter is
    not atomic. If each thread could execute the three instructions required to increment
    the **counter** variable without being interrupted, **counter** would be incremented
    twice as expected. However, depending on the order in which the operations are
    executed, the result can be different. This is called a **race condition** .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的问题发生是因为对计数器的增量操作不是原子的。如果每个线程都能在没有被中断的情况下执行增加**计数器**变量所需的三个指令，那么**计数器**就会像预期的那样增加两次。然而，根据操作执行的顺序，结果可能会有所不同。这被称为**竞态条件**。
- en: To avoid race conditions, we need to ensure that shared resources are accessed
    and modified in a controlled manner. One way to achieve this is by using locks.
    A **lock** is a synchronization primitive that allows only one thread to access
    a shared resource at a time. When a thread wants to access a shared resource,
    it must first acquire the lock. Once the thread has acquired the lock, it can
    access the shared resource without interference from other threads. When the thread
    has finished accessing the shared resource, it must release the lock so that other
    threads can access it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免竞态条件，我们需要确保共享资源以受控的方式被访问和修改。实现这一目标的一种方法是通过使用锁。**锁**是一种同步原语，它允许一次只有一个线程访问共享资源。当线程想要访问共享资源时，它必须首先获取锁。一旦线程获取了锁，它就可以在没有其他线程干扰的情况下访问共享资源。当线程完成对共享资源的访问后，它必须释放锁，以便其他线程可以访问它。
- en: Another way to avoid race conditions is by using **atomic operations** . An
    atomic operation is an operation that is guaranteed to be executed in a single,
    indivisible step. This means that no other thread can interfere with an atomic
    operation while it is being executed. Atomic operations are typically implemented
    using hardware instructions that are designed to be indivisible. Atomic operations
    will be explained in [*Chapter 5*](B22219_05.xhtml#_idTextAnchor097) .
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免竞态条件的方法是使用**原子操作**。原子操作是一种保证在单个、不可分割的步骤中执行的操作。这意味着在操作执行期间，没有其他线程可以干扰原子操作。原子操作通常使用设计为不可分割的硬件指令来实现。原子操作将在[*第五章*](B22219_05.xhtml#_idTextAnchor097)中解释。
- en: 'In this section, we have seen the most common and important problem created
    by multithreaded code: race conditions. We have seen how, depending on the order
    of the operations performed, the results can be different. With this problem in
    mind, we are going to study how to solve it in the next section.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了由多线程代码引起的最常见和重要的问题：竞态条件。我们看到了根据操作执行的顺序，结果可能会有所不同。带着这个问题，我们将研究如何在下一节中解决它。
- en: Why do we need mutual exclusion?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要互斥锁？
- en: '**Mutual exclusion** is a fundamental concept in concurrent programming that
    ensures that multiple threads or processes do not simultaneously access a shared
    resource such as a shared variable, a critical section of code, or a file or network
    connection. Mutual exclusion is crucial for preventing race conditions such as
    the one we have seen in the previous section.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁**是并发编程中的一个基本概念，它确保多个线程或进程不会同时访问共享资源，例如共享变量、代码的关键部分或文件或网络连接。互斥锁对于防止如前节所见到的竞态条件至关重要。'
- en: Imagine a small coffee shop with a single espresso machine. The machine can
    only make one espresso at a time. This means the machine is a critical resource
    that all baristas must share.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一家小咖啡馆，只有一台意式浓缩咖啡机。这台机器一次只能制作一杯浓缩咖啡。这意味着这台机器是一个所有咖啡师都必须共享的关键资源。
- en: 'The coffee shop is attended by three baristas: Alice, Bob, and Carol. They
    use the coffee machine *concurrently* , but they cannot use it simultaneously
    because that could create problems: Bob puts the right amount of freshly ground
    coffee in the machine and starts making an espresso. Then, Alice does the same
    but first removes the coffee from the machine, thinking that Bob just forgot to
    do it. Bob then takes the espresso from the machine, and after that, Alice finds
    that there is no espresso! This is a disaster – a real-life version of our counter
    program.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这家咖啡馆由三位咖啡师：Alice、Bob和Carol负责。他们*并发*使用咖啡机，但不能同时使用，因为这可能会造成问题：Bob将适量的新鲜研磨咖啡放入机器中，开始制作浓缩咖啡。然后，Alice也这样做，但首先从机器中取出咖啡，认为Bob忘记做了。Bob然后从机器中取出浓缩咖啡，之后，Alice发现没有浓缩咖啡了！这是一场灾难——我们计数程序的现实版本。
- en: To fix the problems in the coffee shop, they may appoint Carol as a machine
    manager. Before using the machine, both Alice and Bob ask her if they can start
    making a new espresso. That would solve the issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决咖啡馆的问题，他们可能会任命Carol为机器管理员。在使用机器之前，Alice和Bob都会问她是否可以开始制作新的浓缩咖啡。这样就能解决问题。
- en: Back to our counter program, if we could allow just one thread at a time to
    access **counter** (what Carol did in the coffee shop), our software problem would
    be solved too. Mutual exclusion is a mechanism that can be used to control concurrent
    thread access to memory. The C++ Standard Library provides the **std::mutex**
    class, a synchronization primitive used to protect shared data from being simultaneously
    accessed by two or more threads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的计数器程序，如果我们能允许一次只有一个线程访问**counter**（就像Carol在咖啡馆里做的那样），我们的软件问题也会得到解决。互斥是一种可以用来控制并发线程访问内存的机制。C++标准库提供了**std::mutex**类，这是一个同步原语，用于保护共享数据不被两个或更多线程同时访问。
- en: 'This new version of the code we saw in the previous section implements two
    ways of concurrently incrementing **counter** : free access, as in the previous
    section, and synchronized access using mutual exclusion:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上节中看到的这个新版本的代码实现了两种并发增加**counter**的方式：自由访问，如前节所述，以及使用互斥同步的访问：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a thread runs **funcWithLocks** , it acquires a lock with **mtx.lock()**
    before incrementing **counter** . Once **counter** has been incremented, the thread
    releases the lock ( **mtx.unlock()** ).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程运行**funcWithLocks**时，它在增加**counter**之前使用**mtx.lock()**获取锁。一旦**counter**被增加，线程将释放锁（**mtx.unlock()**）。
- en: 'The lock can only be owned by one thread. If, for example, **t1** acquires
    the lock and then **t2** tries to acquire it too, **t2** will be blocked and will
    wait until the lock is available. Because only one thread can own the lock at
    any time, this synchronization primitive is called a **mutex** (from *mutual exclusion*
    ). If you run this program a few times, you will always get the correct result:
    **2000000** .'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 锁只能被一个线程拥有。例如，如果**t1**获取了锁，然后**t2**也尝试获取它，**t2**将被阻塞并等待直到锁可用。因为任何时刻只有一个线程可以拥有锁，所以这种同步原语被称为**互斥锁**（来自“互斥”）。如果你运行这个程序几次，你总是会得到正确的结果：**2000000**。
- en: In this section, we introduced the concept of mutual exclusion and learned that
    the C++ Standard Library provides the **std::mutex** class as a primitive for
    thread synchronization. In the next section, we will study **std::mutex** in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了互斥的概念，并了解到C++标准库提供了**std::mutex**类作为线程同步的原语。在下一节中，我们将详细研究**std::mutex**。
- en: C++ Standard Library mutual exclusion implementation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++标准库互斥实现
- en: In the previous section, we introduced the concept of mutual exclusion and mutexes
    and why they are needed to synchronize concurrent memory access. In this section,
    we will see the classes provided by the C++ Standard Library to implement mutual
    exclusion. We will also see some helper classes the C++ Standard Library provides
    to make the use of mutexes easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了互斥和互斥锁的概念，以及为什么需要它们来同步并发内存访问。在本节中，我们将看到C++标准库提供的用于实现互斥的类。我们还将看到C++标准库提供的一些辅助类，使互斥锁的使用更加容易。
- en: 'The following table summarizes the mutex classes provided by the C++ Standard
    Library and their main features:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了C++标准库提供的互斥锁类及其主要特性：
- en: '| **Mutex Type** | **Access** | **Recursive** | **Timeout** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **Mutex Type** | **Access** | **Recursive** | **Timeout** |'
- en: '| **std::mutex** | EXCLUSIVE | NO | NO |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **std::mutex** | EXCLUSIVE | NO | NO |'
- en: '| **std::recursive_mutex** | EXCLUSIVE | YES | NO |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **std::recursive_mutex** | EXCLUSIVE | YES | NO |'
- en: '| **std::shared_mutex** | 1 - EXCLUSIVEN - SHARED | NO | NO |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **std::shared_mutex** | 1 - EXCLUSIVEN - SHARED | NO | NO |'
- en: '| **std::timed_mutex** | EXCLUSIVE | NO | YES |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **std::timed_mutex** | EXCLUSIVE | NO | YES |'
- en: '| **std::recursive_timed_mutex** | EXCLUSIVE | YES | YES |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **std::recursive_timed_mutex** | EXCLUSIVE | YES | YES |'
- en: '| **std::shared_timed_mutex** | 1 - EXCLUSIVEN - SHARED | NO | YES |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **std::shared_timed_mutex** | 1 - EXCLUSIVEN - SHARED | NO | YES |'
- en: 'Table 4.2: Mutex classes in C++ Standard Library'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2：C++标准库中的互斥锁类
- en: Let us explore these classes one by one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一探索这些类。
- en: std::mutex
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::mutex
- en: The **std::mutex** class was introduced in C++11 and is one of the most important
    and most frequently used synchronization primitives provided by the C++ Standard
    Library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex**类是在C++11中引入的，它是C++标准库提供的最重要的、最常使用的同步原语之一。'
- en: As we have seen earlier in this chapter, **std::mutex** is a synchronization
    primitive that can be used to protect shared data from being simultaneously accessed
    by multiple threads.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所见，**std::mutex**是一个同步原语，可以用来保护共享数据不被多个线程同时访问。
- en: The **std::mutex** class offers exclusive, non-recursive ownership semantics.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex**类提供了独占、非递归的所有权语义。'
- en: 'The main features of **std::mutex** are the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex**的主要特性如下：'
- en: A calling thread owns the mutex from the time it successfully calls **lock()**
    or **try_lock()** until it calls **unlock()** .
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调用线程成功调用**lock()**或**try_lock()**到调用**unlock()**，调用线程拥有互斥锁。
- en: A calling thread must not own the mutex before calling **lock()** or **try_lock(**
    ). This is the non-recursive ownership semantics property of **std::mutex** .
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用**lock()**或**try_lock(**)之前，调用线程不得拥有互斥锁。这是**std::mutex**的非递归所有权语义属性。
- en: When a thread owns a mutex, all other threads will block (when calling **lock())**
    or receive a **false** return value (when calling **try_lock()** ). This is the
    exclusive ownership semantics of **std::mutex** .
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程拥有互斥锁时，所有其他线程将阻塞（在调用**lock()**时）或接收一个**false**返回值（在调用**try_lock()**时）。这是**std::mutex**的独占所有权语义。
- en: If a thread owning a mutex tries to acquire it again, the resulting behavior
    is undefined. Usually, an exception is thrown when this happens, but this is implementation-defined.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个拥有互斥锁的线程尝试再次获取它，其行为是未定义的。通常，在这种情况下会抛出一个异常，但这是由实现定义的。
- en: If, after a thread releases a mutex, it tries to release it again, this is also
    undefined behavior (as in the previous case).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程在释放互斥锁之后，再次尝试释放它，这同样是不确定的行为（就像前一个情况一样）。
- en: A mutex being destroyed while a thread has it locked or a thread terminating
    without releasing the lock are also causes of undefined behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程持有互斥锁时，互斥锁被销毁，或者线程在未释放锁的情况下终止，这些都是不确定行为的原因。
- en: 'The **std::mutex** class has three methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex**类有三个方法：'
- en: '**lock()** : Calling **lock()** acquires the mutex. If the mutex is already
    locked, then the calling thread is blocked until the mutex is unlocked. From the
    application’s point of view, it is as if the calling thread waits for the mutex
    to be available.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lock()**：调用**lock()**会获取互斥锁。如果互斥锁已被锁定，则调用线程将被阻塞，直到互斥锁被解锁。从应用程序的角度来看，这就像调用线程在等待互斥锁可用一样。'
- en: '**try_lock()** : When called, this function returns either **true** , indicating
    that the mutex has been successfully locked, or **false** in the event of the
    mutex being already locked. Note that **try_lock** is non-blocking, and the calling
    thread either acquires the mutex or not, but it is not blocked like when calling
    **lock()** . The **try_lock()** method is generally used when we don’t want the
    thread to wait until the mutex is available. We will call **try_lock()** when
    we want the thread to proceed with some processing and try to acquire the mutex
    later.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try_lock()**：当调用此函数时，它返回**true**，表示互斥锁已被成功锁定，或者在互斥锁已被锁定的情况下返回**false**。请注意，**try_lock**是非阻塞的，调用线程要么获取互斥锁，要么不获取，但它不会像调用**lock()**时那样被阻塞。**try_lock()**方法通常在我们不希望线程等待互斥锁可用时使用。当我们希望线程继续进行一些处理并稍后尝试获取互斥锁时，我们将调用**try_lock()**。'
- en: '**unlock()** : Calling **unlock()** releases the mutex.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unlock()**：调用**unlock()**会释放互斥锁。'
- en: std::recursive_mutex
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::recursive_mutex
- en: The **std::mutex** class offers exclusive, non-recursive ownership semantics.
    While exclusive ownership semantics are always required at least for a thread
    (it is a mutual exclusion mechanism, after all), in some instances, we may need
    to recursively acquire the mutex. For example, a recursive function may need to
    acquire a mutex. We may also need to acquire a mutex in function **g()** called
    from another function **f()** , which acquired the same mutex.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex**类提供了独占、非递归的所有权语义。虽然对于至少一个线程来说，独占所有权语义总是需要的（毕竞它是一个互斥机制），但在某些情况下，我们可能需要递归地获取互斥锁。例如，一个递归函数可能需要获取一个互斥锁。我们也可能需要在从另一个函数**f()**中调用的函数**g()**中获取互斥锁。'
- en: 'The **std::recursive_mutex** class offers exclusive, recursive semantics. Its
    main features are the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::recursive_mutex**类提供了独占、递归语义。其主要特性如下：'
- en: A calling thread may acquire the same mutex more than once. It will own the
    mutex until it releases the mutex the same number of times it acquired it. For
    example, if a thread recursively acquires a mutex three times, it will own the
    mutex until it releases it for the third time.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用线程可能多次获取相同的互斥锁。它将持有互斥锁，直到它释放互斥锁的次数与它获取的次数相同。例如，如果一个线程递归地获取一个互斥锁三次，它将持有互斥锁，直到它第三次释放它。
- en: The maximum number of times a recursive mutex can be recursively acquired is
    unspecified and hence implementation-defined. Once a mutex has been acquired for
    the maximum number of times, calls to **lock()** will throw **std::system_error**
    , and calls to **try_lock()** will return **false** .
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归互斥锁可以递归获取的最大次数是不确定的，因此是实现定义的。一旦互斥锁已被获取最大次数，调用 **lock()** 将会抛出 **std::system_error**，而调用
    **try_lock()** 将返回 **false**。
- en: 'Ownership is the same as for **std::mutex** : if a thread owns a **std::recursive_mutex**
    class, any other threads will block if they try to acquire it by calling **lock()**
    , or they will get false as a return when calling **try_lock()** .'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有权与 **std::mutex** 相同：如果一个线程拥有 **std::recursive_mutex** 类，那么任何其他线程在尝试通过调用 **lock()**
    获取它时都会阻塞，或者在调用 **try_lock()** 时返回 **false**。
- en: The **std::recursive_mutex** interface is exactly the same as for **std::mutex**
    .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::recursive_mutex** 的接口与 **std::mutex** 完全相同。'
- en: std::shared_mutex
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::shared_mutex
- en: Both **std::mutex** and **std::shared_mutex** have exclusive ownership semantics,
    and just one thread can be the mutex owner at any given time. There are some cases,
    though, when we may need to let several threads simultaneously access the protected
    data and give just one thread exclusive access.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::mutex** 和 **std::shared_mutex** 都具有独占所有权的语义，在任何给定时间只有一个线程可以是互斥锁的所有者。尽管如此，也有一些情况下，我们可能需要让多个线程同时访问受保护的数据，并只给一个线程提供独占访问权限。'
- en: The counter example required exclusive access to a single variable for every
    thread because they were all updating **counter** values. Now, if we have threads
    that only require reading the current value in **counter** and just one thread
    to increment its value, it would be much better to let the reader threads access
    **counter** concurrently and give the writer exclusive access.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的计数器反例要求每个线程对单个变量具有独占访问权限，因为它们都在更新**counter**值。现在，如果我们有只要求读取**counter**当前值的线程，并且只有一个线程需要增加其值，那么让读取线程并发访问**counter**并将写入线程的独占访问权限会更好。
- en: This functionality is implemented using what is called a Readers-Writer lock.
    The C++ Standard Library implements the **std::shared_mutex** class, with a similar
    (but not exactly the same) functionality.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能是通过所谓的读者-写者锁实现的。C++ 标准库实现了具有类似（但不完全相同）功能的 **std::shared_mutex** 类。
- en: 'The main difference between **std::shared_mutex** and other mutex types is
    that it has two access levels:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::shared_mutex** 与其他互斥锁类型的主要区别在于它有两个访问级别：'
- en: '**Shared** : Several threads can share the ownership of the same mutex. Shared
    ownership is acquired/released calling **lock_shared()** , **try_lock_shared()**
    / **unlock shared()** . While at least one thread has acquired shared access to
    the lock, no other thread can get exclusive access to it, but it can acquire shared
    access.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享**：多个线程可以共享同一个互斥锁的所有权。共享所有权通过调用 **lock_shared()**、**try_lock_shared()**
    / **unlock_shared()** 来获取/释放。当至少有一个线程已经获取了对锁的共享访问权限时，没有其他线程可以获取独占访问权限，但它可以获取共享访问权限。'
- en: '**Exclusive** : Only one thread can own the mutex. Exclusive ownership is acquired/released
    by calling **lock()** , **try_lock()** / **unlock()** . While a thread has acquired
    exclusive access to the lock, no other thread can acquire either shared or exclusive
    access to it.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独占**：只有一个线程可以拥有互斥锁。独占所有权通过调用**lock()**、**try_lock()** / **unlock()** 来获取/释放。当一个线程已经获取了对锁的独占访问权限时，没有其他线程可以获取共享或独占访问权限。'
- en: 'Let’s see a simple example using **std::shared_mutex** :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看如何使用 **std::shared_mutex**：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The example uses **std::shared_mutex** to synchronize six threads: two threads
    are writers, and they increment the value of **counter** and require exclusive
    access. The remaining four threads just read **counter** and only require shared
    access. Also, note that in order to use **std::shared_mutex** , we need to include
    the **<shared_mutex>** header file.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用 **std::shared_mutex** 来同步六个线程：其中两个线程是写入者，它们增加**counter**的值并需要独占访问。其余四个线程只读取**counter**，只需要共享访问。此外，请注意，为了使用
    **std::shared_mutex**，我们需要包含 **<shared_mutex>** 头文件。
- en: Timed mutex types
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时互斥锁类型
- en: 'The mutex types we have seen until now behave in the same way when we want
    to acquire the lock for exclusive use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今所见到的互斥锁类型，当我们想要获取锁以进行独占使用时，表现方式相同：
- en: '**std::lock()** : The calling thread blocks until the lock is available'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::lock()** : 调用线程会阻塞，直到锁可用'
- en: '**std::try_lock()** : Returns **false** if the lock is not available'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::try_lock()**：如果锁不可用，则返回 **false**'
- en: In the case of **std::lock()** , the calling thread may be waiting for a long
    time, and we may need to just wait for a certain period of time and then let the
    thread proceed with some processing if it has not been able to acquire the lock.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在**std::lock()**的情况下，调用线程可能需要等待很长时间，我们可能只需要等待一段时间，然后如果线程还没有能够获取到锁，就让它继续进行一些处理。
- en: 'To achieve this goal, we can use the timed mutexes provided by the C++ Standard
    Library: **std::timed_mutex** , **std::recursive_timed_mutex** , and **std::shared_time_mutex**
    .'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们可以使用C++标准库提供的定时互斥锁：**std::timed_mutex**、**std::recursive_timed_mutex**和**std::shared_time_mutex**。
- en: 'They are similar to their non-timed counterparts and implement the following
    additional functions to allow waiting for the lock to be available for a specific
    period of time:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们与它们的非定时对应物类似，并实现了以下附加功能，以允许等待锁在特定时间段内可用：
- en: '**try_lock_for()** : Tries to lock the mutex and blocks the thread until the
    specified time duration has elapsed (timed out). If the mutex is locked before
    the specified time duration, then it returns **true** ; otherwise, it returns
    **false** .'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try_lock_for()**：尝试锁定互斥锁，并在指定的时间段内（超时）阻塞线程。如果在指定的时间段之前互斥锁被锁定，则返回**true**；否则，返回**false**。'
- en: If the specified time duration is less than or equal to zero ( **timeout_duration.zero()**
    ), then the function behaves exactly like **try_lock()** .
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果指定的时间段小于或等于零（**timeout_duration.zero()**），则该函数的行为与**try_lock()**完全相同。
- en: This function may block for longer than the specified duration due to scheduling
    or contention delays.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于调度或竞争延迟，此函数可能会阻塞超过指定的时间段。
- en: '**try_lock_until()** : Tries to lock the mutex until the specified timeout
    time or the mutex is locked, whichever comes first. In this case, we specify an
    instance in the future as a limit for the waiting.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try_lock_until()**：尝试锁定互斥锁，直到指定的超时时间或互斥锁被锁定，以先到者为准。在这种情况下，我们指定一个未来的实例作为等待的限制。'
- en: 'The following example shows how to use **std::try_lock_for()** :'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用**std::try_lock_for()**：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code uses two locks: **tm** , a timed mutex, to synchronize access
    to **counter** and writing to the screen if acquiring **tm** is successful, and
    **m** , a non-timed mutex, to synchronize access to **failed** and writing to
    the screen if acquiring **tm** is not successful.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了两个锁：**tm**，一个定时互斥锁，用于同步对**counter**的访问以及在成功获取**tm**的情况下向屏幕写入，以及**m**，一个非定时互斥锁，用于在未成功获取**tm**的情况下同步对**failed**的访问以及向屏幕写入。
- en: Problems when using locks
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用锁时可能出现的问题
- en: We have seen examples using just a mutex (lock). If we only need one mutex and
    we acquire and release it properly, in general is not very difficult to write
    correct multithreaded code. Once we need more than one lock, the code complexity
    increases. Two common problems when using multiple locks are *deadlock* and *livelock*
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了仅使用互斥锁（锁）的示例。如果我们只需要一个互斥锁并且正确地获取和释放它，通常编写正确的多线程代码并不困难。一旦我们需要多个锁，代码复杂性就会增加。使用多个锁时常见的两个问题是*死锁*和*活锁*。
- en: Deadlock
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 死锁
- en: 'Let’s consider the following scenario: to perform a certain task, a thread
    needs to access two resources, and they cannot be accessed simultaneously by two
    or more threads (we need mutual exclusion to properly synchronize access to the
    required resources). Each resource is synchronized with a different **std::mutex**
    class. In this case, a thread must acquire the first resource mutex then acquire
    the second resource mutex, and finally process the resources and release both
    mutexes.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：为了执行某个任务，一个线程需要访问两个资源，并且两个或更多线程不能同时访问这些资源（我们需要互斥来正确同步对所需资源的访问）。每个资源都由不同的**std::mutex**类进行同步。在这种情况下，一个线程必须先获取第一个资源互斥锁，然后获取第二个资源互斥锁，最后处理资源并释放两个互斥锁。
- en: 'When two threads try performing the aforementioned processing, something like
    this may happen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个线程尝试执行上述处理时，可能会发生类似以下情况：
- en: '*Thread 1* and *thread 2* need to acquire two mutexes to perform the required
    processing. *Thread 1* acquires the first mutex and *thread 2* acquires the second
    mutex. Then, *thread 1* will be blocked forever waiting for the second mutex to
    be available, and *thread 2* will be blocked forever waiting for the first mutex
    to be available. This is called a **deadlock** because both threads will be blocked
    forever waiting for each other to release the required mutex.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程 1* 和 *线程 2* 需要获取两个互斥锁来执行所需的处理。*线程 1* 获取第一个互斥锁，*线程 2* 获取第二个互斥锁。然后，*线程 1*
    将永远阻塞等待第二个互斥锁可用，而 *线程 2* 将永远阻塞等待第一个互斥锁可用。这被称为**死锁**，因为两个线程都将永远阻塞等待对方释放所需的互斥锁。'
- en: This is one of the most common issues in multithreaded code. In [*Chapter 11*](B22219_11.xhtml#_idTextAnchor228)
    , about debugging, we will learn how to spot this problem by inspecting the running
    (deadlocked) program with a debugger.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在多线程代码中最常见的问题之一。在[*第 11 章*](B22219_11.xhtml#_idTextAnchor228)中，关于调试，我们将学习如何通过检查运行（死锁）程序来发现这个问题。
- en: Livelock
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活锁
- en: 'A possible solution for deadlock could be the following: when a thread tries
    to acquire the lock, it will block just for a limited time, and if still unsuccessful,
    it will release any lock it may have acquired.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解决死锁的一个可能方案是：当线程尝试获取锁时，它将仅阻塞有限的时间，如果仍然不成功，它将释放它可能已经获得的任何锁。
- en: For example, *thread 1* acquires the first lock and *thread 2* acquires the
    second lock. After a certain time, *thread 1* still has not acquired the second
    lock, so it releases the first one. *Thread 2* may finish waiting too and release
    the lock it acquired (in this example, the second lock).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*线程 1* 获得了第一个锁，*线程 2* 获得了第二个锁。经过一段时间后，*线程 1* 仍然没有获得第二个锁，因此它释放了第一个锁。*线程 2*
    也可能完成等待并释放它所获得的锁（在这个例子中，是第二个锁）。
- en: 'This solution may work sometimes, but it is not right. Imagine this scenario:
    *Thread 1* has acquired the first lock and has acquired the second lock. After
    some time, both threads release their already acquired locks, and then they acquire
    the same locks again. Then, the threads release the locks, then acquire them again,
    and so on.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案有时可能有效，但并不正确。想象一下这个场景：*线程 1* 获得了第一个锁和第二个锁。过了一段时间后，两个线程都释放了它们已经获得的锁，然后再次获取相同的锁。然后，线程释放锁，再次获取，如此循环。
- en: The threads are unable to do anything but acquire a lock, wait, release the
    lock, and do the same again. This situation is called **livelock** because the
    threads are not just waiting forever (as in the deadlock case), but they are kind
    of alive and acquire and release a lock continuously.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 线程无法做任何事情，除了获取锁、等待、释放锁，然后再重复同样的操作。这种情况被称为**活锁**，因为线程不仅仅是永远等待（如死锁情况），它们似乎是活跃的，不断地获取和释放锁。
- en: The most common solution for both deadlock and livelock situations is acquiring
    the locks in a consistent order. For example, if a thread needs to acquire two
    locks, it will always acquire the first lock first, and then it will acquire the
    second lock. The locks will be released in the opposite order (first releasing
    the second lock and then the first). If a second thread tries to acquire the first
    lock, it will have to wait until the first thread releases both locks, and deadlock
    will never happen.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于死锁和活锁的情况，最常用的解决方案是按照一致的顺序获取锁。例如，如果一个线程需要获取两个锁，它将始终先获取第一个锁，然后获取第二个锁。锁的释放将按照相反的顺序进行（首先释放第二个锁，然后是第一个）。如果第二个线程尝试获取第一个锁，它将不得不等待直到第一个线程释放了两个锁，这样就不会发生死锁。
- en: In this section, we have seen the mutex classes provided by the C++ Standard
    Library. We have studied their main features and the issues we may experience
    when using more than one lock. In the next section, we will see the mechanisms
    that the C++ Standard Library provides to make acquiring and releasing mutexes.
    easier.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了 C++ 标准库提供的互斥类。我们研究了它们的主要特性和在使用多个锁时可能遇到的问题。在下一节中，我们将看到 C++ 标准库提供的机制，以使获取和释放互斥锁更加容易。
- en: Generic lock management
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用锁管理
- en: 'In the previous section, we saw the different types of mutexes provided by
    the C++ Standard Library. In this section, we will see the provided classes to
    make the use of mutexes easier. This is done by using different wrapper classes.
    The following table summarizes the lock management classes and their main features:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了 C++ 标准库提供的不同类型的互斥量。在本节中，我们将看到提供的类，这些类使得使用互斥量更加容易。这是通过使用不同的包装器类来实现的。以下表格总结了锁管理类及其主要特性：
- en: '| **Mutex** **Manager Class** | **Supported** **Mutex Types** | **Mutexes Managed**
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **互斥量管理类** | **支持的互斥量类型** | **管理的互斥量** |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **std::lock_guard** | All | 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **std::lock_guard** | 所有 | 1 |'
- en: '| **std::scoped_lock** | All | Zero or more |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **std::scoped_lock** | 所有 | 零个或多个 |'
- en: '| **std::unique_lock** | All | 1 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **std::unique_lock** | 所有 | 1 |'
- en: '| **std::shared_lock** | **std::shared_mutex****std::shared_timed_mutex** |
    1 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **std::shared_lock** | **std::shared_mutex** | **std::shared_timed_mutex**
    | 1 |'
- en: 'Table 4.3: Lock management classes and their features'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3：锁管理类及其特性
- en: Let’s see each of the mutex management classes and their main features.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个互斥量管理类及其主要特性。
- en: std::lock_guard
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::lock_guard
- en: The **std::lock_guard** class is a **Resource Acquisition Is Initialization**
    ( **RAII** ) class that makes it easier to use mutexes and guarantees that a mutex
    will be released when the **lock_guard** destructor is called. This is very useful,
    for example, when dealing with exceptions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::lock_guard** 类是一个 **资源获取即初始化** ( **RAII** ) 类，它使得使用互斥量更加容易，并保证当调用 **lock_guard**
    析构函数时，互斥量将被释放。这在处理异常时非常有用，例如。'
- en: 'The following code shows the use of **std::lock_guard** and how it makes handling
    exceptions easier when a lock is already acquired:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 **std::lock_guard** 的使用以及它是如何使在已经获取锁的情况下处理异常变得更容易的：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The **function_throws()** function is just a utility function that will throw
    an exception.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**function_throws()** 函数只是一个实用函数，它将抛出一个异常。'
- en: In the previous code example, the **worker_exceptions()** function is executed
    by **t1** . In this case, the exception is handled to print meaningful messages.
    The lock is not explicitly acquired/released. This is delegated to **lock** ,
    a **std::lock_guard** object. When the lock is constructed, it wraps the mutex
    and calls **mtx.lock()** , acquiring the lock. When **lock** is destroyed, the
    mutex is released automatically. In the event of an exception, the mutex will
    also be released because the scope where **lock** was defined is exited.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，**worker_exceptions()** 函数由 **t1** 执行。在这种情况下，异常被处理以打印有意义的消息。锁不是显式地获取/释放。这被委托给
    **lock**，一个 **std::lock_guard** 对象。当 **lock** 被构造时，它会包装互斥量并调用 **mtx.lock()**，获取锁。当
    **lock** 被销毁时，互斥量将自动释放。在发生异常的情况下，互斥量也将被释放，因为 **lock** 被定义的作用域已经退出。
- en: There is another constructor implemented for **std::lock_guard** , receiving
    a parameter of type **std::adopt_lock_t** . Basically, this constructor makes
    it possible to wrap an already acquired non-shared mutex, which will be released
    automatically in the **std::lock_guard** destructor.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为 **std::lock_guard** 实现了另一个构造函数，接收一个类型为 **std::adopt_lock_t** 的参数。基本上，这个构造函数使得能够包装一个已经获取的非共享互斥量，该互斥量将在
    **std::lock_guard** 析构函数中自动释放。
- en: std::unique_lock
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::unique_lock
- en: The **std::lock_guard** class is just a simple **std::mutex** wrapper that automatically
    acquires the mutex in its constructor (the thread will be blocked, waiting until
    the mutex is released by another thread) and releases the mutex in its destructor.
    This is very useful, but sometimes we need more control. For example, **std::lock_guard**
    will either call **lock()** on the mutex or assume the mutex is already acquired.
    We may prefer or really need to call **try_lock** . We also may want the **std::mutex**
    wrapper not to acquire the lock in its constructor; that is, we may want to defer
    the locking until a later moment. All this functionality is implemented by **std::unique_lock**
    .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::lock_guard** 类只是一个简单的 **std::mutex** 包装器，它在构造函数中自动获取互斥量（线程将被阻塞，等待另一个线程释放互斥量）并在析构函数中释放互斥量。这非常有用，但有时我们需要更多的控制。例如，**std::lock_guard**
    将会在互斥量上调用 **lock()** 或者假设互斥量已经被获取。我们可能更喜欢或者确实需要调用 **try_lock** 。我们可能还希望 **std::mutex**
    包装器在其构造函数中不获取锁；也就是说，我们可能希望在稍后的某个时刻再进行锁定。所有这些功能都是由 **std::unique_lock** 实现的。'
- en: 'The **std::unique_lock** constructor accepts a tag as its second parameter
    to indicate what we want to do with the underlying mutex. There are three options:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::unique_lock** 构造函数接受一个标签作为其第二个参数，以指示我们想要如何处理底层的互斥量。这里有三种选项：'
- en: '**std::defer_lock** : Does not acquire ownership of the mutex. The mutex is
    not locked in the constructor, and it will not be unlocked in the destructor if
    it is never acquired.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::defer_lock**：不获取互斥锁的所有权。构造函数中不会锁定互斥锁，如果从未获取，则析构函数中也不会解锁。'
- en: '**std::adopt_lock** : Assumes that the mutex has been acquired by the calling
    thread. It will be released in the destructor. This option is also available for
    **std::lock_guard** .'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::adopt_lock**：假设互斥锁已被调用线程获取。它将在析构函数中释放。此选项也适用于**std::lock_guard**。'
- en: '**std::try_to_lock** : Try to acquire the mutex without blocking.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::try_to_lock**：尝试获取互斥锁而不阻塞。'
- en: 'If we just pass the mutex as the only parameter to the **std::unique_lock**
    constructor, the behavior is the same as in **std::lock_guard** : it will block
    until the mutex is available and then acquire it. It will release the mutex in
    the destructor.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是将互斥锁作为唯一参数传递给**std::unique_lock**构造函数，其行为与**std::lock_guard**相同：它会阻塞直到互斥锁可用，然后获取它。它将在析构函数中释放互斥锁。
- en: The **std::unique_lock** class, unlike **std::lock_guard** , allows you to call
    **lock()** and **unlock()** to respectively acquire and release the mutex.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与**std::lock_guard**不同，**std::unique_lock**类允许你分别调用**lock()**和**unlock()**来获取和释放互斥锁。
- en: std::scoped_lock
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::scoped_lock
- en: The **std::scoped_lock** class, as with **std::unique_lock** , is a **std::mutex**
    wrapper implementing an RAII mechanism (remember – the mutexes will be released
    in the destructor if they are acquired). The main difference is that **std::unique_lock**
    , as its name implies, just wraps one mutex, but **std::scoped_lock** wraps zero
    or more mutexes. Also, the mutexes are acquired in the order they are passed to
    the **std::scoped_lock** constructor, hence avoiding deadlock.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::scoped_lock**类，与**std::unique_lock**一样，是一个实现RAII机制（记住——如果获取了互斥锁，它们将在析构函数中释放）的**std::mutex**包装器。主要区别在于，**std::unique_lock**，正如其名称所暗示的，仅包装一个互斥锁，而**std::scoped_lock**可以包装零个或多个互斥锁。此外，互斥锁的获取顺序与传递给**std::scoped_lock**构造函数的顺序相同，从而避免了死锁。'
- en: 'Let’s look at the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet shows how we can work with two mutex locks very easily.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示了我们可以非常容易地处理两个互斥锁。
- en: std::shared_lock
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::shared_lock
- en: The **std::shared_lock** class is another general-purpose mutex ownership wrapper.
    As with **std::unique_lock** and **std::scoped_lock** , it allows deferred locking
    and transferring the lock ownership. The main difference between **std::unique_lock**
    and **std::shared_lock** is that the latter is used to acquire/release the wrapped
    mutex in shared mode while the former is used to do the same in exclusive mode.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::shared_lock**类是另一种通用互斥锁所有权包装器。与**std::unique_lock**和**std::scoped_lock**一样，它允许延迟锁定和转移锁所有权。**std::unique_lock**和**std::shared_lock**之间的主要区别在于，后者用于以共享模式获取/释放包装的互斥锁，而前者用于以独占模式执行相同的操作。'
- en: 'In this section, we saw mutex wrapper classes and their main features. Next,
    we will introduce another synchronization mechanism: condition variables.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了互斥锁包装类及其主要功能。接下来，我们将介绍另一种同步机制：条件变量。
- en: Condition variables
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: '**Condition variables** are another synchronization primitive provided by the
    C++ Standard Library. They allow multiple threads to communicate with each other.
    They also allow for several threads to wait for a notification from another thread.
    Condition variables are always associated with a mutex.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件变量**是C++标准库提供的另一种同步原语。它们允许多个线程相互通信。它们还允许多个线程等待另一个线程的通知。条件变量始终与一个互斥锁相关联。'
- en: 'In the following example, a thread must wait for a counter to be equal to a
    certain value:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，一个线程必须等待计数器等于某个特定值：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two ways to wait for a certain condition: one is waiting in a loop
    and using a mutex as a synchronization mechanism. This is implemented in **wait_for_counter_non_zero_mtx**
    . The function acquires the lock, reads the value in **counter** , and releases
    the lock. Then, it sleeps for 10 milliseconds, and the lock is acquired again.
    This is done in a **while** loop until **counter** is nonzero.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种等待特定条件的方法：一种是在循环中等待并使用互斥锁作为同步机制。这在**wait_for_counter_non_zero_mtx**函数中实现。该函数获取锁，读取**counter**中的值，然后释放锁。然后，它睡眠10毫秒，再次获取锁。这是在**while**循环中完成的，直到**counter**不为零。
- en: Condition variables help us to simplify the previous code. The **wait_for_counter_10_cv**
    function waits until **counter** is equal to 10. The thread will wait on the **cv**
    condition variable until it is notified by **t1** , the thread increasing **counter**
    in a loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量帮助我们简化了之前的代码。**wait_for_counter_10_cv** 函数等待直到 **counter** 等于 10。线程将在 **cv**
    条件变量上等待，直到它被 **t1**（在循环中增加 **counter** 的线程）通知。
- en: '**The wait_for_counter_10_cv** function works like this: a condition variable,
    **cv** , waits on a mutex, **mtx** . After calling **wait()** , the condition
    variable locks the mutex and waits until the condition is **true** (the condition
    is implemented in the lambda passed as a second parameter to the **wait** function).
    If the condition is not **true** , the condition variable remains in a *waiting*
    state until it is signaled and releases the mutex. Once the condition is met,
    the condition variable ends its waiting state and locks the mutex again to synchronize
    its access to **counter** .'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**wait_for_counter_10_cv** 函数是这样工作的：一个条件变量，**cv**，在互斥锁，**mtx** 上等待。在调用 **wait()**
    之后，条件变量锁定互斥锁并等待直到条件为 **true**（条件是在传递给 **wait** 函数作为第二个参数的 lambda 表达式中实现的）。如果条件不是
    **true**，条件变量将保持 *等待* 状态，直到它被发出信号并释放互斥锁。一旦条件满足，条件变量结束其等待状态并再次锁定互斥锁以同步其对 **counter**
    的访问。'
- en: One important issue is that the conditional variable may be signaled by an unrelated
    thread. This is called **spurious wakeup** . To avoid errors due to spurious wakeups,
    the condition is checked in **wait** . When the condition variable is signaled,
    the condition is checked again. In the event of a spurious wakeup and the counter
    being zero (the condition check returns **false** ), the waiting would resume.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的问题是条件变量可能被一个无关的线程发出信号。这被称为 **虚假唤醒**。为了避免由于虚假唤醒而引起的错误，条件在 **wait** 中被检查。当条件变量被发出信号时，条件再次被检查。在发生虚假唤醒且计数器为零（条件检查返回
    **false** ）的情况下，等待将重新开始。
- en: A different thread increments the counter by running **increment_counter** .
    Once **counter** has the desired value (in the example, this value is 10), it
    signals the waiting thread condition variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同的线程通过运行 **increment_counter** 来增加计数器的值。一旦 **counter** 达到期望的值（在示例中，这个值是 10），它就会向等待的线程的条件变量发出信号。
- en: 'There are two functions provided to signal a condition variable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两个函数来发出条件变量信号：
- en: '**cv.notify_one()** : Signal only one of the waiting threads'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cv.notify_one()** : 仅向等待的线程中的一个发出信号'
- en: '**cv.notify_all()** : Signal all of the waiting threads'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cv.notify_all()** : 向所有等待的线程发出信号'
- en: In this section, we have introduced condition variables, and we have seen a
    simple example of synchronization using condition variables and how in some cases
    it can simplify the synchronization/waiting code. Now, let us turn our attention
    to implementing a synchronized queue using a mutex and two condition variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了条件变量，并看到了一个使用条件变量进行同步的简单示例，以及在某些情况下它如何简化同步/等待代码。现在，让我们将注意力转向使用互斥锁和两个条件变量来实现一个同步队列。
- en: Implementing a multithreaded safe queue
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个线程安全的队列
- en: 'In this section, we will see how to implement a simple **multithreaded safe
    queue** . The queue will be accessed by multiple threads, some of them adding
    elements to it ( **producer threads** ) and some of them removing elements from
    it ( **consumer threads** ). For starters, we are going to assume just two threads:
    one producer and one consumer.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何实现一个简单的 **线程安全的队列**。队列将由多个线程访问，其中一些线程向其中添加元素（ **生产者线程**），而另一些线程从中移除元素（
    **消费者线程**）。为了开始，我们将假设只有两个线程：一个生产者和一个消费者。
- en: Queues or **first-in-first-outs** ( **FIFOs** ) are a standard way of communication
    between threads. For example, if we need to receive packets containing data from
    a network connection as fast as possible, we may not have enough time in just
    one thread to receive all the packets and process them. In this case, we use a
    second thread to process the packets read by the first thread. Using just one
    consumer thread is simpler to synchronize (we will see how this is the case in
    [*Chapter 5*](B22219_05.xhtml#_idTextAnchor097) ), and we have a guarantee that
    the packets will be processed in the same order as they arrived and were copied
    to the queue by the producer thread. It is true that the packets will really be
    read in the same order they were copied to the queue irrespective of the number
    of threads we have as consumers, but the consumer threads may be scheduled in
    and out by the operating system, and the full sequence of processed packets could
    be in a different order.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 队列或**先进先出**（**FIFOs**）是线程之间通信的标准方式。例如，如果我们需要尽可能快地接收包含来自网络连接的数据的包，我们可能没有足够的时间仅在一个线程中接收所有包并处理它们。在这种情况下，我们使用第二个线程来处理第一个线程读取的包。仅使用一个消费者线程更容易同步（我们将在[*第5章*](B22219_05.xhtml#_idTextAnchor097)中看到这一点），并且我们有保证包将被按照它们到达和被生产者线程复制到队列中的顺序进行处理。确实，包将真正按照它们被复制到队列中的顺序被读取，无论我们有多少消费者线程，但消费者线程可能被操作系统调度进和出，处理过的包的完整序列可能以不同的顺序出现。
- en: In general, the easiest problem is that of a **single-producer-single-consumer**
    ( **SPSC** ) queue. Different problems may require multiple consumers if the processing
    of each item is too costly for just a thread, and we may have different sources
    of data to be processed and need multiple producer threads. The queue described
    in this section will work in every case.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最简单的问题是一个**单生产者单消费者**（**SPSC**）队列。如果每个项目的处理成本太高，以至于仅一个线程无法处理，那么可能需要多个消费者，我们可能还有不同的数据源需要处理，并且需要多个生产者线程。本节中描述的队列将适用于所有情况。
- en: The first step in designing the queue is deciding what data structure we will
    use to store the queued items. We want the queue to contain elements of any type
    *T* , so we will implement it as a template class. Also, we are going to limit
    the capacity of the queue so that the maximum number of elements we can store
    in the queue will be fixed and set in the class constructor. It is possible, for
    example, to use a linked list and make the queue unbounded, or even use a **Standard
    Template Library** ( **STL** ) queue, **std::queue** , and let the queue grow
    to an arbitrary size. In this chapter, we will implement a fixed-size queue. We
    will revisit the implementation in [*Chapter 5*](B22219_05.xhtml#_idTextAnchor097)
    and implement it in a very different way (we won’t be using any mutex or waiting
    on condition variables). For our current implementation, we will use an STL vector,
    **std::vector<T>** , to store the queued items. The vector will allocate memory
    for all the elements in the queue class constructor, so there will be no memory
    allocations after that. When the queue is destroyed, the vector will destroy itself
    and will free the allocated memory. This is convenient and simplifies the implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设计队列的第一步是决定我们将使用什么数据结构来存储队列中的项目。我们希望队列包含任何类型 *T* 的元素，因此我们将它实现为一个模板类。此外，我们将限制队列的容量，以便我们可以在队列中存储的最大元素数量是固定的，并在类构造函数中设置。例如，可以使用链表并使队列无界，或者甚至使用**标准模板库**（**STL**）队列，**std::queue**，并让队列增长到任意大小。在本章中，我们将实现一个固定大小的队列。我们将在[*第5章*](B22219_05.xhtml#_idTextAnchor097)中重新审视实现，并以非常不同的方式实现它（我们不会使用任何互斥锁或等待条件变量）。对于我们的当前实现，我们将使用STL向量，**std::vector<T>**，来存储队列中的项目。向量将在队列类构造函数中为所有元素分配内存，因此之后将不会有内存分配。当队列被销毁时，向量将自行销毁并释放分配的内存。这是方便的，并且简化了实现。
- en: We will use the vector as a **ring buffer** . This means that, once we store
    an element at the end of the vector, the next one will be stored at the beginning,
    so we *wrap around* both locations to write and read elements from the vector.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用向量作为**环形缓冲区**。这意味着，一旦我们在向量的末尾存储了一个元素，下一个元素将被存储在开头，因此我们将在读写元素时对这两个位置进行**循环**。
- en: 'This is the first version of the queue class, quite simple and not useful yet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是队列类的第一个版本，相当简单，但还没有什么用处：
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The **head** and **tail** variables are used to indicate where to read or write
    the next element respectively. We also need to know when the queue is empty or
    full. If the queue is empty, the consumer thread won’t be able to get any item
    from the queue. If the queue is full, the producer thread will not be able to
    put any items in the queue.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**head** 和 **tail** 变量用于指示分别读取或写入下一个元素的位置。我们还需要知道队列何时为空或满。如果队列为空，消费者线程将无法从队列中获取任何项目。如果队列已满，生产者线程将无法将任何项目放入队列中。'
- en: 'There are different ways to indicate when a queue is empty and when it is full.
    In this example, we follow this convention:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方式来指示队列何时为空和何时已满。在这个例子中，我们遵循以下约定：
- en: If **tail_ == head_** , then the queue is empty
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 **tail_ == head_**，则队列是空的
- en: If **(tail_ + 1) % capacity_ == head_** , then the queue is full
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 **(tail_ + 1) % capacity_ == head_**，则队列已满
- en: Another way to implement it would require just checking if **tail_ == head_**
    and using an extra flag to indicate if the queue is full or not (or using a counter
    to know how many items there are in the queue). We avoid any extra flag or counter
    in this example because the flag will be read and written by both the consumer
    and the producer threads, and we aim to minimize sharing data among threads as
    much as we can. Also, reducing sharing data will be the only option when we revisit
    the implementation of the queue in [*Chapter 5*](B22219_05.xhtml#_idTextAnchor097)
    .
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式只需检查 **tail_ == head_** 并使用一个额外的标志来指示队列是否已满（或者使用计数器来知道队列中有多少项）。在这个例子中，我们避免使用任何额外的标志或计数器，因为标志将由消费者和生产者线程同时读写，并且我们旨在尽可能减少线程间的数据共享。此外，减少数据共享将是我们在[*第五章*](B22219_05.xhtml#_idTextAnchor097)重新实现队列时的唯一选项。
- en: There is a small issue here. Because of the way we check if the queue is full,
    we lose one slot in the buffer, so the real capacity is **capacity_ - 1** . We
    will consider the queue as full when there is just one empty slot. Because of
    this, we lose one queue slot (note that the slot will be used, but the queue will
    still be full when the number of items is **capacity_ - 1** ). In general, this
    is not an issue.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小问题。由于我们检查队列是否已满的方式，我们丢失了一个缓冲区槽位，因此实际容量是 **capacity_ - 1**。我们将认为队列已满，当只有一个空槽位时。由于这个原因，我们丢失了一个队列槽位（请注意，槽位将被使用，但当项目数量为
    **capacity_ - 1** 时，队列仍然会显示为满）。通常情况下，这不是一个问题。
- en: The queue we are going to implement is a bounded queue (fixed size) implemented
    as a ring buffer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的队列是一个有界队列（固定大小），实现为一个环形缓冲区。
- en: 'There is another detail to be considered here: **head_ + 1** must take into
    account that we wrap around the indices to the buffer (it is a ring buffer). So,
    we must do **(head_ + 1) % capacity_** . The modulo operator calculates the remainder
    of the index value divided by the queue capacity.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要考虑的细节：**head_ + 1** 必须考虑到我们将索引回绕到缓冲区（它是一个环形缓冲区）。因此，我们必须做 **(head_ +
    1) % capacity_**。模运算符计算索引值除以队列容量的余数。
- en: 'The following code shows the basic utility functions implemented as helper
    functions in the synchronized queue:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了作为同步队列中的辅助函数实现的基本实用函数：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have implemented a few useful functions to update both the head and the tail
    of the ring buffer and to check if the buffer is full or empty. Now, we can start
    implementing the queue functionality.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一些有用的函数来更新环形缓冲区的头和尾，并检查缓冲区是否已满或为空。现在，我们可以开始实现队列功能。
- en: The code for the full queue implementation is in the accompanying GitHub repo
    for the book. *Here, we only show the important bits* for the sake of simplicity
    and focus just on the synchronization aspects of the queue implementation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完整队列实现的代码位于本书的配套GitHub仓库中。*在这里，我们只展示重要的部分，以简化内容并专注于队列实现的同步方面*。
- en: 'The interface to the queue has the following two functions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的接口具有以下两个功能：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **push** function inserts an element in the queue, while **pop** gets an
    element from the queue.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**push** 函数用于在队列中插入一个元素，而 **pop** 函数用于从队列中获取一个元素。'
- en: Let’s start with **push** . It inserts an item in the queue. If the queue is
    full, **push** will wait until the queue has at least an empty slot (a consumer
    removed an element from the queue). This way, the producer thread will be blocked
    until the queue has at least one empty slot (the not-full condition is met).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 **push** 开始。它将一个项目插入到队列中。如果队列已满，**push** 将等待直到队列至少有一个空槽（消费者从队列中移除了一个元素）。这样，生产者线程将阻塞，直到队列至少有一个空槽（满足非满条件）。
- en: We have seen earlier in this chapter that there is a synchronization mechanism
    called a condition variable that does just that. The **push** function will check
    if the condition is met, and when it is met, it will insert an item in the queue.
    If the condition is not met, the lock associated with the condition variable will
    be released, and the thread will wait on the condition variable until the condition
    is satisfied.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们已经看到，存在一种称为条件变量的同步机制，它正是这样做的。**push**函数将检查条件是否满足，如果满足，它将在队列中插入一个项目。如果条件不满足，与条件变量关联的锁将被释放，线程将等待在条件变量上，直到条件得到满足。
- en: It is possible for the condition variable to just wait until the lock is released.
    We still need to check if the queue is full because a condition variable may end
    its waiting due to a spurious wakeup. This happens when the condition variable
    receives a notification not sent explicitly by any other thread.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量可能只是等待直到锁被释放。我们仍然需要检查队列是否已满，因为条件变量可能因为虚假唤醒而结束等待。这种情况发生在条件变量接收到一个通知，而这个通知并非由任何其他线程明确发送时。
- en: 'We add the following three member variables to the queue class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向队列类添加以下三个成员变量：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need two condition variables – one to notify the consumers that the queue
    is not full ( **not_full_** ) and another to notify the producers that the queue
    is not empty ( **not_empty_** ).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个条件变量——一个用于通知消费者队列不为满（**not_full_**），另一个用于通知生产者队列不为空（**not_empty_**）。
- en: 'This is the code implementing **push** :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现**push**的代码：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s think about a scenario with a single producer and a single consumer. We
    will see the **pop** function later, but as an advance, it also synchronizes with
    the mutex/condition variable. Both threads try to access the queue at the same
    time – the producer when inserting an element and the consumer when removing it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个只有一个生产者和一个消费者的场景。我们稍后会看到**pop**函数，但作为提前了解，它也同步于互斥锁/条件变量。两个线程同时尝试访问队列——生产者在插入元素时，消费者在移除元素时。
- en: Let’s assume the consumer acquires the lock first. This happens in **[1]** .
    The use of **std::unique_lock** is required by condition variables to use a mutex.
    In **[2]** , we wait on the condition variable until the condition in the predicate
    of the **wait** function is met. If it is not met, the lock is released for the
    consumer thread to be able to access the queue.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设消费者首先获取锁。这发生在**[1]**处。条件变量需要**std::unique_lock**的使用来使用互斥锁。在**[2]**中，我们等待在条件变量上，直到**wait**函数谓词中的条件得到满足。如果条件不满足，锁将被释放，以便消费者线程能够访问队列。
- en: Once the condition is met, the lock is acquired again, and the queue is updated
    in **[3]** . After updating the queue, **[4]** releases the lock and then **[5]**
    notifies one consumer thread that may be waiting on **not_empty** that the queue
    is effectively not empty now.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦条件满足，锁再次被获取，队列在**[3]**处更新。更新队列后，**[4]**释放锁，然后**[5]**通知一个可能正在等待**not_empty**的消费者线程，队列现在实际上不为空。
- en: The **std::unique_lock** class could release the mutex lock in its destructor,
    but we needed to release it in **[4]** because we didn’t want to release the lock
    after notifying the condition variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::unique_lock**类可以在其析构函数中释放互斥锁，但我们需要在**[4]**处释放它，因为我们不希望在通知条件变量后释放锁。'
- en: 'The **pop()** function follows a similar logic, as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**pop()**函数遵循类似的逻辑，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code is very similar to that in the **push** function. **[1]** creates the
    **std::unique_lock** class required to use the **not_empty_** condition variable.
    **[2]** waits on **not_empty_** until it is notified that the queue is not empty.
    **[3]** reads the item from the queue, assigning it to the **item** variable,
    and then in **[4]** , the lock is released. Finally, in **[5]** , the **not_full_**
    condition variable is notified to indicate to the consumer that the queue is not
    full.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与**push**函数中的代码非常相似。**[1]**创建了使用**not_empty_**条件变量所需的**std::unique_lock**类。**[2]**在**not_empty_**上等待，直到它被通知队列不为空。**[3]**从队列中读取项目，将其分配给**item**变量，然后在**[4]**中释放锁。最后，在**[5]**中，通知**not_full_**条件变量，向消费者指示队列不为满。
- en: Both **push** and **pop** functions are blocking and waiting until the queue
    is not full or not empty respectively. We may need the thread to keep on running
    in the event of not being able to either insert or get a message to/from the queue
    – for example, to let it do some independent processing – and then try again to
    access the queue.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**push** 和 **pop** 函数都是阻塞的，分别等待队列不满或不满。我们可能需要在无法插入或从队列中获取/发送消息的情况下让线程继续运行——例如，让它执行一些独立处理——然后再次尝试访问队列。'
- en: 'The **try_push** function does exactly that. If the mutex is free to be acquired
    and the queue is not full, then the functionality is the same as the **push**
    function, but in this case, **try_push** doesn’t need to use any condition variable
    for synchronization (but it must notify the consumer). This is the code for **try_push**
    :'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**try_push** 函数正是如此。如果互斥锁可以获取并且队列未满，那么功能与 **push** 函数相同，但在此情况下，**try_push**
    不需要使用任何条件变量进行同步（但必须通知消费者）。这是 **try_push** 的代码：'
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code works like this: **[1]** tries to acquire the lock and returns without
    blocking the calling thread. If the lock was already acquired, then it will evaluate
    to **false** . In **[2]** , in case the lock has not been acquired or the queue
    is full, **try_push** returns **false** to indicate to the caller that no item
    was inserted in the queue and delegates the waiting/blocking to the caller. Note
    that **[3]** returns **false** and the function terminates. If the lock was acquired,
    it will be released when the function exits and the **std::unique_lock** destructor
    is called.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是这样工作的：**[1]** 尝试获取锁并返回，而不阻塞调用线程。如果锁已经被获取，那么它将评估为 **false**。在 **[2]** 中，如果锁尚未获取或队列已满，**try_push**
    返回 **false** 以指示调用者没有在队列中插入任何项，并将等待/阻塞委托给调用者。请注意，**[3]** 返回 **false** 并且函数终止。如果锁已被获取，它将在函数退出和
    **std::unique_lock** 析构函数被调用时释放。
- en: After the lock is acquired and has checked that the queue is not full, then
    the item is inserted in the queue, and **tail_** is updated. In **[5]** , the
    lock is released, and in **[6]** , the consumer is notified that the queue is
    not empty anymore. This notification is required because the consumer may call
    **pop** instead of **try_pop** .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取锁并检查队列未满之后，然后将项插入队列，并更新 **tail_**。在 **[5]** 中，释放锁，在 **[6]** 中，通知消费者队列不再为空。这种通知是必需的，因为消费者可能会调用
    **pop** 而不是 **try_pop**。
- en: Finally, the function returns **true** to indicate to the caller that the item
    was successfully inserted in the queue.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数返回 **true** 以指示调用者项已成功插入队列。
- en: 'The code for the corresponding **try_pop** function is shown next. As an exercise,
    try to understand how it works:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了相应的 **try_pop** 函数。作为一个练习，尝试理解它是如何工作的：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the full code for the queue we have implemented in this section:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本节中实现队列的完整代码：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this section, we have introduced condition variables and implemented a basic
    queue synchronized with a mutex and two condition variables, the two basic synchronization
    primitives provided by the C++ Standard Library since C++11.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了条件变量，并实现了一个与互斥锁和两个条件变量同步的基本队列，这是自 C++11 以来 C++ 标准库提供的两种基本同步原语。
- en: The queue example shows how synchronization is implemented using these synchronization
    primitives and can be used as a basic building block for more elaborate utilities
    such as, for example, a thread pool.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 队列示例展示了如何使用这些同步原语实现同步，并且可以用作更复杂工具（例如线程池）的基本构建块。
- en: Semaphores
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: C++20 introduces new synchronization primitives to write multithreaded applications.
    In this section, we will look at semaphores.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了新的同步原语来编写多线程应用程序。在本节中，我们将查看信号量。
- en: 'A **semaphore** is a counter that manages the number of permits available for
    accessing a shared resource. Semaphores can be classified into two main types:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是一个管理可用于访问共享资源许可数的计数器。信号量可以分为两大类：'
- en: 'A **binary semaphore** is like a mutex. It has only two states: 0 and 1. Even
    though a binary semaphore is conceptually like a mutex, there are some differences
    between a binary semaphore and a mutex that we will see later in this section.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制信号量**就像互斥锁。它只有两种状态：0 和 1。尽管二进制信号量在概念上类似于互斥锁，但二进制信号量和互斥锁之间有一些差异，我们将在本节后面看到。'
- en: A **counting semaphore** can have a value greater than 1 and is used to control
    access to a resource that has a limited number of instances.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数信号量**可以具有大于 1 的值，并用于控制对具有有限实例数的资源的访问。'
- en: C++20 implements both binary and counting semaphores.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 实现了二进制和计数信号量。
- en: Binary semaphores
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制信号量
- en: 'A binary semaphore is a synchronization primitive that can be used to control
    access to a shared resource. It has two states: 0 and 1. A semaphore with a value
    of 0 indicates that the resource is unavailable, while a semaphore with a value
    of 1 indicates that the resource is available.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制信号量是一种同步原语，可用于控制对共享资源的访问。它有两个状态：0 和 1。值为 0 的信号量表示资源不可用，而值为 1 的信号量表示资源可用。
- en: Binary semaphores can be used to implement mutual exclusion. This is achieved
    by using a binary semaphore to control access to the resource. When a thread wants
    to access the resource, it first checks the semaphore. If the semaphore is 1,
    the thread can access the resource. If the semaphore is 0, the thread must wait
    until the semaphore is 1 before it can access the resource.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制信号量可用于实现互斥。这是通过使用二进制信号量来控制对资源的访问来实现的。当线程想要访问资源时，它首先检查信号量。如果信号量为 1，则线程可以访问资源。如果信号量为
    0，则线程必须等待信号量变为 1，然后才能访问资源。
- en: The most significant difference between mutexes and semaphores is that mutexes
    have exclusive ownership, whereas binary semaphores do not. Only the thread owning
    the mutex can release it. Semaphores can be signaled by any thread. A mutex is
    a locking mechanism for a critical section, and a semaphore is more like a signaling
    mechanism. In this respect, a semaphore is closer to a condition variable than
    a mutex. For this reason, semaphores are commonly used for signaling rather than
    for mutual exclusion.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和信号量之间最显著的区别是，锁具有独占所有权，而二进制信号量则没有。只有拥有锁的线程可以释放它。信号量可以被任何线程发出信号。锁是一个临界区的锁定机制，而信号量更像是一个信号机制。在这方面，信号量比锁更接近条件变量。因此，信号量通常用于信号而不是互斥。
- en: In C++20, **std::binary_semaphore** is an alias for the specialization of **std::counting_semaphore**
    , with **LeastMaxValue** being 1.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，**std::binary_semaphore** 是 **std::counting_semaphore** 特化的别名，其 **LeastMaxValue**
    为 1。
- en: 'Binary semaphores must be initialized with either 1 or 0, such as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制信号量必须初始化为 1 或 0，例如：
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the initial value is **0** , acquiring the semaphore will block the thread
    trying to acquire it, and before it can be acquired, it must be released by another
    thread. Acquiring a semaphore decreases the counter, and releasing it increases
    the counter. As previously stated, if the counter is **0** and a thread tries
    to acquire the lock (semaphore), the thread will be blocked until the semaphore
    counter is greater than **0** .
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始值为 **0**，获取信号量将阻塞尝试获取它的线程，并且必须在另一个线程释放它之后才能获取。获取信号量会减少计数器，而释放信号量会增加计数器。如前所述，如果计数器为
    **0**，并且一个线程尝试获取锁（信号量），则该线程将被阻塞，直到信号量计数器大于 **0**。
- en: Counting semaphores
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数信号量
- en: A counting semaphore allows access to a shared resource by more than one thread.
    The counter can be initialized to an arbitrary number, and it will be decreased
    every time a thread acquires the semaphore. As an example of how to use counting
    semaphores, we will modify the multithread safe queue we implemented in the previous
    section and use semaphores instead of condition variables to synchronize access
    to the queue.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 计数信号量允许多个线程访问共享资源。计数器可以初始化为任意数值，每次线程获取信号量时，计数器将减少。作为使用计数信号量的示例，我们将修改上一节中实现的线程安全队列，并使用信号量而不是条件变量来同步对队列的访问。
- en: 'The member variables of the new class are the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 新类的成员变量如下：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We still need **head_** and **tail_** to know where to read and write an element,
    **capacity_** for the wraparound of the indices, and **buffer_** , a **std::vector<T>**
    vector. But for now, we are not using a mutex, and we will use counting semaphores
    instead of condition variables. We will use two of them: **sem_empty_** to count
    the empty slots in the buffer (initially set to **capacity_** ) and **sem_full_**
    to count the non-empty slots in the buffer, initially set to 0.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要 **head_** 和 **tail_** 来确定读取和写入元素的位置，**capacity_** 用于索引的回绕，以及 **buffer_**
    ，一个 **std::vector<T>** 向量。但到目前为止，我们并没有使用互斥锁，而是将使用计数信号量代替条件变量。我们将使用两个信号量：**sem_empty_**
    用于计算缓冲区中的空槽位（初始设置为 **capacity_**），而 **sem_full_** 用于计算缓冲区中的非空槽位，初始设置为 0。
- en: Now, let’s see how to implement **push** , the function used to insert items
    in a queue.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何实现 **push** 函数，它是用于在队列中插入项目的函数。
- en: 'In **[1]** , **sem_empty_** is acquired, decreasing the semaphore counter.
    If the queue is full, then the thread will block until **sem_empty_** is released
    (signaled) by another thread. If the queue is not full, then the item is copied
    to the buffer, and **tail_** is updated in **[2]** and **[3]** . Finally, **sem_full_**
    is released in **[4]** , signaling another thread that the queue is not empty
    and there is at least one item in the buffer:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **[1]** 中，**sem_empty_** 被获取，减少了信号量计数器。如果队列已满，则线程将阻塞，直到另一个线程通过释放（信号）**sem_empty_**
    来解除阻塞。如果队列未满，则项目将被复制到缓冲区，并在 **[2]** 和 **[3]** 中更新 **tail_** 。最后，在 **[4]** 中释放
    **sem_full_**，向另一个线程发出信号，表明队列不为空，且缓冲区中至少有一个项目：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **pop** function is used to get elements from a queue:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**pop** 函数用于从队列中获取元素：'
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, in **[1]** , we successfully acquire **sem_full_** if the queue is not
    empty. Then, the item is read and **head_** updated in **[2]** and **[3]** respectively.
    Finally, we signal the consumer thread that the queue is not full, releasing **sem_empty**
    .
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 **[1]** 中，如果队列不为空，我们成功获取了 **sem_full_**。然后，读取项目并在 **[2]** 和 **[3]** 中分别更新
    **head_**。最后，我们向消费者线程发出信号，表明队列不为空，释放 **sem_empty**。
- en: There are several issues in our first version of **push** . The first and most
    important one is that **sem_empty_** allows more than one thread to access the
    critical section in the queue ( **[2]** and **[3]** ). We need to synchronize
    this critical section and use a mutex.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **push** 的第一个版本中存在几个问题。第一个也是最重要的问题是 **sem_empty_** 允许多个线程访问队列中的临界区（**[2]**
    和 **[3]**）。我们需要同步这个临界区并使用互斥锁。
- en: Here is the new version of **push** using a mutex for synchronization.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用互斥锁进行同步的 **push** 的新版本。
- en: 'In **[2]** , the lock is acquired (using **std::unique_lock** ), and in **[5]**
    , it is released. Using the lock will synchronize the critical section, preventing
    several threads from simultaneously accessing it and updating the queue concurrently
    without any synchronization:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **[2]** 中，获取了锁（使用 **std::unique_lock**），在 **[5]** 中释放了锁。使用锁将同步临界区，防止多个线程同时访问它，并更新队列而没有任何同步：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A second issue is that acquiring a semaphore is blocking, and as we have seen
    previously, sometimes the caller thread can do some processing instead of just
    waiting. The **try_push** function (and its corresponding **try_pop** function)
    implements this functionality. Let’s study the code of **try_push** . Note that
    **try_push** may still block on the mutex:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是获取信号量是阻塞的，正如我们之前所看到的，有时调用线程可以做一些处理，而不仅仅是等待。**try_push** 函数（及其对应的 **try_pop**
    函数）实现了这一功能。让我们研究一下 **try_push** 的代码。请注意，**try_push** 可能仍然会在互斥锁上阻塞：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only changes are **[1]** and **[2]** . Instead of blocking when acquiring
    the semaphore, we just try to acquire it, and if we fail, we return **false**
    . The **try_acquire** function may spuriously fail and return **false** even if
    the semaphore can be acquired (count is not zero).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是 **[1]** 和 **[2]**。在获取信号量时，我们只是尝试获取它，如果失败，则返回 **false**。**try_acquire**
    函数可能会意外失败并返回 **false**，即使信号量可以被获取（计数不是零）。
- en: 'Here is the complete code for the queue synchronized with semaphores:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用信号量同步的队列的完整代码。
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this section, we have seen semaphores, a new synchronization primitive included
    in the C++ Standard Library since C++20. We learned how to use them to implement
    the same queue we implemented before but using semaphores as synchronization primitives.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了信号量，这是自 C++20 以来包含在 C++ 标准库中的一个新的同步原语。我们学习了如何使用它们来实现我们之前实现的相同队列，但使用信号量作为同步原语。
- en: In the next section, we will introduce **barriers** and **latches** , two new
    synchronization mechanisms included in the C++ Standard Library since C++20.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 **屏障** 和 **闩锁**，这是自 C++20 以来包含在 C++ 标准库中的两个新的同步机制。
- en: Barriers and latches
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏障和闩锁
- en: In this section, we will introduce barriers and latches, two new synchronization
    primitives introduced in C++20. These mechanisms allow threads to wait for each
    other, thereby coordinating the execution of concurrent tasks.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍屏障和闩锁，这是C++20中引入的两个新的同步原语。这些机制允许线程相互等待，从而协调并发任务的执行。
- en: std::latch
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::latch
- en: The **std::latch** latch is a synchronization primitive that allows one or more
    threads to block until a specified number of operations are completed. It is a
    single-use object, and once the count reaches zero, it cannot be reset.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::latch** 闩锁是一种同步原语，允许一个或多个线程阻塞，直到指定的操作数量完成。它是一个一次性对象，一旦计数达到零，就不能重置。'
- en: The following example is a simple illustration of the use of latches in a multithreaded
    application. We want to write a function to multiply by two each element of a
    vector and then add all the elements of the vector. We will use three threads
    to multiply the vector elements by two and then one thread to add all the elements
    of the vector and obtain the result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是 latch 在多线程应用程序中使用的简单说明。我们想要编写一个函数，将向量的每个元素乘以二，然后添加向量的所有元素。我们将使用三个线程将向量元素乘以二，然后使用一个线程添加向量的所有元素并获取结果。
- en: We need two latches. The first one will be decremented by each of the three
    threads multiplying by two vector elements. The adding thread will wait for this
    latch to be zero. Then, the main thread will wait on the second latch to synchronize
    printing the result of adding all the vector’s elements. We can also wait for
    the thread performing the additions calling **join** on it, but this can be done
    with a latch too.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个闩锁。第一个闩锁将由每个乘以两个向量元素的三个线程递减。添加线程将等待此闩锁为零。然后，主线程将在第二个闩锁上等待以同步打印添加所有向量元素的结果。我们也可以等待执行加法操作的线程调用
    **join**，但这也可以使用闩锁来完成。
- en: 'Now, let’s analyze the code in functional blocks. We will include the full
    code for the latches and barriers example later in this section:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析代码的功能块。我们将在本节后面包含闩锁和屏障示例的完整代码：
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each multiplying thread will run this lambda function, multiplying by two elements
    of a certain range in the vector (from **start** to **end** ). Once the thread
    is done, it will decrease the **map_latch** counter by one. Once all the threads
    finish their tasks, the latch counter will be zero, and the thread blocked waiting
    on **map_latch** will be able to go on and add all the elements of the vector
    together. Note that the threads access different elements of the vector, so we
    don’t need to synchronize access to the vector itself, but we cannot start adding
    the numbers until all the multiplications are done.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个乘法线程将运行此lambda函数，乘以向量中一定范围内的两个元素（从 **start** 到 **end**）。一旦线程完成，它将递减 **map_latch**
    计数器一次。一旦所有线程完成其任务，闩锁计数器将为零，等待在 **map_latch** 上的线程将能够继续并添加向量的所有元素。请注意，线程访问向量的不同元素，因此我们不需要同步对向量本身的访问，但我们不能开始添加数字，直到所有乘法完成。
- en: 'The code for the adding thread is the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 添加线程的代码如下：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This thread waits until the **map_latch** counter goes down to zero, then adds
    all the elements of the vector, and finally decrements the **reduce_latch** counter
    (it will go down to zero) for the main thread to be able to print the final result:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此线程将等待直到 **map_latch** 计数器降至零，然后添加向量的所有元素，并最终递减 **reduce_latch** 计数器（它将降至零），以便主线程能够打印最终结果：
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Having seen a basic application of latches, next, let’s learn about barriers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了闩锁的基本应用之后，接下来，让我们学习关于屏障的内容。
- en: std::barrier
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::barrier
- en: The **std::barrier** barrier is another synchronization primitive used to synchronize
    a group of threads. The **std::barrier** barrier is reusable. Each thread reaches
    the barrier and waits until all participating threads reach the same barrier point
    (like what happens when we use latches).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::barrier** 屏障是另一种用于同步一组线程的同步原语。**std::barrier** 屏障是可重用的。每个线程达到屏障并等待，直到所有参与线程达到相同的屏障点（就像我们使用闩锁时发生的情况）。'
- en: The main difference between **std::barrier** and **std::latch** is the reset
    capability. The **std::latch** latch is a single-use barrier with a countdown
    mechanism that cannot be reset. Once it reaches zero, it stays at zero. In contrast,
    **std::barrier** is reusable. It resets after all threads have reached the barrier,
    allowing the same set of threads to synchronize at the same barrier multiple times.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::barrier**和**std::latch**之间的主要区别是重置能力。**std::latch**是一个单次使用的barrier，具有计数器机制，不能重置。一旦它达到零，它就会保持在零。相比之下，**std::barrier**是可重用的。所有线程都达到barrier后，它会重置，允许同一组线程在同一个barrier上多次同步。'
- en: When to use latches and when to use barriers? Use **std::latch** when you have
    a one-time gathering point for threads, such as waiting for multiple initializations
    to complete before proceeding. Use **std::barrier** when you need to synchronize
    threads repeatedly through multiple phases of a task or iterative computations.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用latches和何时使用barriers？当您有一个线程的一次性聚集点时，使用**std::latch**，例如在等待多个初始化完成后再继续之前。当您需要通过任务的多个阶段或迭代计算反复同步线程时，使用**std::barrier**。
- en: We will now rewrite the previous example, this time using barriers instead of
    latches. Each thread will multiply by two its corresponding range of vector elements,
    and then it will add them. The main thread will use **join()** in this example
    to wait for the processing to be finished and then add the results obtained by
    each of the threads.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重写之前的示例，这次使用barriers而不是latches。每个线程将乘以二其对应的向量元素的范围，然后将其相加。在这个例子中，主线程将使用**join()**等待处理完成，然后添加每个线程获得的结果。
- en: 'The code for the worker thread is the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程的代码如下：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code is synchronized with a barrier. When a worker thread finishes doing
    the multiplications, it decreases the **map_barrier** counter and waits for the
    barrier counter to be zero. Once it goes down to zero, the threads end their waiting
    and start doing the additions. The barrier counter is reset, and its value is
    again equal to three. Once the additions are done, the barrier counter is decremented
    again, but this time, the threads won’t wait because their task is done.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过一个barrier进行同步。当一个工作线程完成乘法运算后，它会减少**map_barrier**计数器，并等待barrier计数器变为零。一旦它降到零，线程结束等待并开始进行加法运算。barrier计数器被重置，其值再次等于三。一旦加法完成，barrier计数器再次减少，但这次线程不会等待，因为他们的任务已经完成。
- en: Sure – each thread could have done the additions and then multiplied by two.
    They don’t need to wait for each other because the work done by any thread is
    independent of the work done by any other thread, but this is a good way of explaining
    how barriers work with an easy example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然——每个线程都可以先进行加法运算，然后再乘以二。它们不需要互相等待，因为任何线程完成的工作都不依赖于其他线程完成的工作，但这是一个很好的方法来解释barriers是如何通过一个简单的例子来工作的。
- en: 'The main thread just waits with **join** for the worker threads to finish and
    then prints the result:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程只是通过**join**等待工作线程完成，然后打印结果：
- en: '[PRE29]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the full code for the latches and barriers example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是latches和barriers示例的完整代码：
- en: '[PRE30]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this section, we have seen barriers and latches. Though they are not so
    commonly used as mutexes, condition variables, and semaphores, it is always useful
    to know what they are. The simple examples presented here have illustrated a common
    use of barriers and latches: synchronizing threads performing processing in different
    stages.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了barriers和latches。虽然它们不像mutexes、condition variables和semaphores那样常用，但了解它们总是有用的。这里提供的简单示例展示了barriers和latches的常见用法：同步在不同阶段执行处理的线程。
- en: Finally, we will see a mechanism to execute code just once, even if the code
    is called more than once from different threads.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到一个机制，即使代码从不同的线程中被多次调用，也能只执行一次。
- en: Performing a task only once
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只执行一次任务
- en: Sometimes, we need to perform a certain task just one time. For example, in
    a multithreaded application, several threads may run the same function to initialize
    a variable. Any of the running threads may do it, but we want the initialization
    to be done exactly once.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只需要执行某个任务一次。例如，在一个多线程应用程序中，几个线程可能运行相同的函数来初始化一个变量。任何正在运行的线程都可以这样做，但我们希望初始化恰好只进行一次。
- en: The C++ Standard Library provides both **std::once_flag** and **std::call_once**
    to implement exactly that functionality. We will see how to implement this functionality
    using atomic operations in the next chapter.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了**std::once_flag**和**std::call_once**来实现这一功能。我们将在下一章中看到如何使用原子操作来实现这一功能。
- en: 'The following example will help us to understand how to use **std::once_flag**
    and **std::call_once** to achieve our goal of performing a task just one time
    when more than one thread tries to do it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将帮助我们理解如何使用**std::once_flag**和**std::call_once**在多个线程尝试执行同一任务时仅执行一次任务：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first part of the example, three threads, **t1** , **t2** , and **t3**
    , run the **thread_function** function. This function calls a lambda from **std::call_once**
    . If you run the example, you will see that the message **This must run just once**
    is printed only one time, as expected.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第一部分，三个线程**t1**、**t2**和**t3**运行**thread_function**函数。这个函数从**std::call_once**调用一个lambda表达式。如果您运行此示例，您将看到预期的消息**This
    must run just once**只打印一次。
- en: In the second part of the example, again, three threads, **t4** , **t5** , and
    **t6** , run the **thread_function_1** function. This function calls **function_throws**
    , which depending on a parameter may throw or not throw an exception. This code
    shows that, if the function called from **std::call_once** does not terminate
    successfully, then it doesn’t count as done and **std::call_once** should be called
    again. Only a successful function counts as a run function.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第二部分，再次，三个线程**t4**、**t5**和**t6**运行**thread_function_1**函数。这个函数调用**function_throws**，该函数根据一个参数可能抛出异常或不抛出异常。此代码表明，如果从**std::call_once**调用的函数没有成功终止，则它不算作完成，并且应该再次调用**std::call_once**。只有成功的函数才算作运行函数。
- en: This final section showed a simple mechanism we can use to ensure that a function
    is executed exactly once, even if it is called more than once from the same or
    a different thread.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后展示了一种简单的机制，我们可以用它来确保即使函数被从同一线程或不同线程多次调用，该函数也只被执行一次。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the lock-based synchronization primitives
    provided by the C++ Standard Library.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用C++标准库提供的基于锁的同步原语。
- en: 'We started with an explanation of race conditions and the need for mutual exclusion.
    Then, we studied **std::mutex** and how to use it to solve race conditions. We
    also learned about the main problems when synchronizing with locks: deadlock and
    livelock.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对竞争条件和互斥需求进行解释开始。然后，我们研究了**std::mutex**及其如何用于解决竞争条件。我们还了解了使用锁进行同步时出现的主要问题：死锁和活锁。
- en: 'After learning about mutexes, we studied condition variables and implemented
    a synchronized queue using mutex and condition variables. Finally, we saw the
    new synchronization primitives introduced in C++20: semaphores, latches, and barriers.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了解锁之后，我们研究了条件变量，并使用互斥锁和条件变量实现了一个同步队列。最后，我们看到了C++20中引入的新同步原语：信号量、闩锁和屏障。
- en: Finally, we studied the mechanisms provided by the C++ Standard Library to run
    a function just one time.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了C++标准库提供的机制，以运行一个函数仅一次。
- en: In this chapter, we learned about the basic building blocks of thread synchronization
    and the foundation of asynchronous programming with multiple threads. Lock-based
    thread synchronization is the most used method to synchronize threads.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了线程同步的基本构建块以及多线程异步编程的基础。基于锁的线程同步是同步线程最常用的方法。
- en: In the next chapter, we will study lock-free thread synchronization. We will
    start with a review of atomicity, atomic operations, and atomic types provided
    by the C++20 Standard Library. We will show an implementation of a lock-free bound
    single-producer-single-consumer queue. We will also introduce the C++ memory model.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究无锁线程同步。我们将从回顾C++20标准库提供的原子性、原子操作和原子类型开始。我们将展示一个无锁的单生产者单消费者队列的实现。我们还将介绍C++内存模型。
- en: Further reading
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: David R. Butenhof, *Programming with POSIX Threads* , Addison Wesley, 1997.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大卫·R·布滕霍夫，《使用POSIX线程编程》，Addison Wesley，1997。
- en: Anthony Williams, *C++ Concurrency in Action* , Second Edition, Manning, 2019.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安东尼·威廉姆斯，《C++并发实战》，第二版，Manning，2019。
