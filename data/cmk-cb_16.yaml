- en: Porting a Project to CMake
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将项目移植到CMake
- en: In the final chapter of this book, we will combine a number of different building
    blocks that we have discussed in the previous chapters and apply them to a real-life
    project. Our goal will be to demonstrate step-by-step how to port a non-trivial
    project to CMake and discuss the steps involved in such a process. We will provide
    recommendations for porting your own projects or adding CMake support to legacy
    code, be it from Autotools, from hand-written configure scripts and Makefiles,
    or from Visual Studio project files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将结合前面章节中讨论的多个不同的构建块，并将其应用于一个实际项目。我们的目标将是逐步展示如何将一个非平凡的项目移植到CMake，并讨论这样的过程中的步骤。我们将为移植您自己的项目或为遗留代码添加CMake支持提供建议，无论是来自Autotools，来自手工编写的配置脚本和Makefile，还是来自Visual
    Studio项目文件。
- en: To have a tangible and realistic example, we will use the source code behind
    the popular editor Vim ([https://www.vim.org](https://www.vim.org)) and attempt
    to port the configuration and compilation from Autotools to CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个具体和现实的示例，我们将使用流行的编辑器Vim（[https://www.vim.org](https://www.vim.org)）背后的源代码，并尝试将配置和编译从Autotools移植到CMake。
- en: To keep the discussion and the examples relatively simple, we will not attempt
    to present a full port to CMake for the entire Vim code with all options. Instead,
    we will single out and discuss the most important aspects and only build a core
    version of Vim, without support for a graphical user interface (GUI). Nevertheless,
    we will arrive at a working version of Vim, configured, built, and tested with
    CMake and the other tools we have presented in the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持讨论和示例的相对简单性，我们将不尝试为整个Vim代码提供完整的CMake移植，包括所有选项。相反，我们将挑选并讨论最重要的方面，并且只构建一个核心版本的Vim，不支持图形用户界面（GUI）。尽管如此，我们将得到一个使用CMake和本书中介绍的其他工具配置、构建和测试的Vim工作版本。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Initial steps when porting a project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植项目时的初始步骤
- en: Generating files and writing platform checks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文件和编写平台检查
- en: Detecting required dependencies and linking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测所需的依赖项并进行链接
- en: Reproducing compiler flags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重现编译器标志
- en: Porting tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植测试
- en: Porting install targets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植安装目标
- en: Common pitfalls when converting projects to CMake
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目转换为CMake时常见的陷阱
- en: Where to start
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从哪里开始
- en: We will first show where to find our example online and then discuss the porting
    example step by step.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先展示在哪里可以在线找到我们的示例，然后逐步讨论移植示例。
- en: Reproducing the porting example
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现移植示例
- en: 'We will start from the `v8.1.0290` release tag of the Vim source code repository
    ([https://github.com/vim/vim](https://github.com/vim/vim)) and base our work on
    the Git commit hash `b476cb7`. The following steps can be reproduced by cloning
    the source code repository of Vim and checking out that particular version of
    the code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Vim源代码仓库的`v8.1.0290`发布标签（[https://github.com/vim/vim](https://github.com/vim/vim)）开始，并基于Git提交哈希`b476cb7`进行工作。以下步骤可以通过克隆Vim的源代码仓库并检出该特定版本的代码来重现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, our solution can be found on the `cmake-support` branch at [https://github.com/dev-cafe/vim](https://github.com/dev-cafe/vim) and
    cloned to your computer using this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们的解决方案可以在[https://github.com/dev-cafe/vim](https://github.com/dev-cafe/vim)的`cmake-support`分支上找到，并使用以下命令克隆到您的计算机上：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we will emulate a `./configure --enable-gui=no` configuration
    in CMake, built with the GNU compiler collection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将模拟在CMake中使用GNU编译器集合构建的`./configure --enable-gui=no`配置。
- en: For comparison with our solution later, and for additional inspiration, we encourage
    readers to also study the Neovim project ([https://github.com/neovim/neovim](https://github.com/neovim/neovim)),
    which is a fork of the traditional Vi editor and provides a CMake build system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与我们的解决方案进行比较，并获得额外的灵感，我们鼓励读者也研究Neovim项目（[https://github.com/neovim/neovim](https://github.com/neovim/neovim)），这是一个传统的Vi编辑器的分支，并提供了一个CMake构建系统。
- en: Creating a top-level CMakeLists.txt
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建顶层CMakeLists.txt
- en: 'As a start, we create a top-level `CMakeLists.txt` in the root directory of
    the source code repository where we set the minimum CMake version, the project
    name, and supported languages, in this case C:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开始，我们在源代码仓库的根目录中创建一个顶级的`CMakeLists.txt`，在其中设置最小CMake版本、项目名称和支持的语言，在本例中为C：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before adding any targets or sources, we can already set the default build
    type. In this case, we default to the `Release` configuration, which will turn
    on certain compiler optimizations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何目标或源文件之前，我们可以设置默认的构建类型。在这种情况下，我们默认使用`Release`配置，这将启用某些编译器优化：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also use portable install directory variables, as defined for GNU software:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用便携式安装目录变量，如GNU软件所定义：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a sanity check, we can already try to configure and build the project, but
    so far there are no targets so the output from the build step will be empty:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为健全性检查，我们可以尝试配置和构建项目，但到目前为止还没有目标，因此构建步骤的输出将为空：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will start adding targets in a moment to put more flesh on the bones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将开始添加目标，以使构建更加充实。
- en: How to allow both conventional configuration and configuration with CMake at
    the same time
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何同时允许传统配置和CMake配置
- en: 'A very nice feature of CMake is that we build *out-of-source*, the build directory
    can be any directory, and it does not have to be a subdirectory of the project
    directory. This means that we can port a project to CMake while not intruding
    into the previous/present configuration and build mechanism. For the migration
    of a non-trivial project, it is very useful that CMake files can coexist with
    other build frameworks to allow a gradual migration, both in terms of options,
    features, and portability, and to allow the developer community to adapt to the
    new framework. To allow both traditional and CMake configurations to coexist for
    a while, a typical strategy is to collect all CMake code in `CMakeLists.txt` files
    and all auxiliary CMake source files under a `cmake` subdirectory. In our example,
    we will not introduce a `cmake` subdirectory, but rather keep auxiliary files
    closer to the targets and sources requiring them, but we will take care to keep
    almost all files used by the traditional Autotools build unmodified, with one
    exception: we will apply few modifications in order to place autogenerated files
    under the build directory and not in the source tree.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的一个非常好的特性是，我们可以在源代码目录之外构建，构建目录可以是任何目录，而不必是项目目录的子目录。这意味着我们可以在不干扰先前/当前配置和构建机制的情况下将项目迁移到CMake。对于非平凡项目的迁移，CMake文件可以与其他构建框架共存，以允许逐步迁移，无论是选项、功能和可移植性方面，还是允许开发人员社区适应新框架。为了允许传统和CMake配置在一段时间内共存，一个典型的策略是将所有CMake代码收集在`CMakeLists.txt`文件中，并将所有辅助CMake源文件放在`cmake`子目录下。在我们的示例中，我们不会引入`cmake`子目录，而是将辅助文件更靠近需要它们的目标和源文件，但我们会注意保持几乎所有用于传统Autotools构建的文件不变，只有一个例外：我们将对自动生成的文件进行少量修改，以便将它们放置在构建目录下，而不是源代码树中。
- en: Capturing a record of what the traditional build does
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录传统构建过程的记录
- en: 'Before we add any targets to the configuration, it is often useful to first
    capture a record of what the traditional build does, and save the output of the
    configuration and the build step into a log file. For our Vim example, this can
    be done using the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向配置中添加任何目标之前，通常首先记录传统构建过程的内容，并将配置和构建步骤的输出保存到日志文件中，这通常很有用。对于我们的Vim示例，可以使用以下方法完成：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our case (the complete content of `build.log` is not shown here), we are
    able to verify which sources are compiled and which compile flags are used (`-I.
    -Iproto
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下（`build.log`的完整内容未在此处显示），我们能够验证哪些源文件被编译以及使用了哪些编译标志（`-I. -Iproto`）
- en: '-DHAVE_CONFIG_H -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1`). From the log
    file, we can deduce the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`-DHAVE_CONFIG_H -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1`。从日志文件中，我们可以推断出以下内容：'
- en: All objects are linked into a single binary
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象都被链接成一个单一的二进制文件
- en: No libraries are produced
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不生成库文件
- en: The executable target is linked against the following libraries: `-lSM -lICE
    -lXpm -lXt -lX11 -lXdmcp -lSM -lICE -lm -ltinfo -lelf -lnsl -lacl -lattr -lgpm
    -ldl`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行目标链接了以下库：`-lSM -lICE -lXpm -lXt -lX11 -lXdmcp -lSM -lICE -lm -ltinfo -lelf
    -lnsl -lacl -lattr -lgpm -ldl`
- en: Debugging the migration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试迁移过程
- en: 'When gradually moving targets and commands to the CMake side, it will be useful
    to print values of variables using the `message` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在逐步将目标和命令迁移到CMake侧时，使用`message`命令打印变量值将非常有用：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By adding options, targets, sources, and dependencies while debugging using
    `message`, we will inch our way towards a working build.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加选项、目标、源文件和依赖项，同时使用`message`进行调试，我们将逐步构建起一个可用的构建系统。
- en: Implementing options
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选项
- en: 'Find out which options the traditional configuration offers to the users (for
    example, by running `./configure --help`). The Vim project offers a very long
    list of options and flags and to keep the discussion in this chapter simple, we
    will implement only four of the options on the CMake side:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 找出传统配置向用户提供的选项（例如，通过运行`./configure --help`）。Vim项目提供了一个非常长的选项和标志列表，为了在本章中保持讨论的简单性，我们只会在CMake侧实现四个选项：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will also ignore any GUI support and emulate `--enable-gui=no`, since it
    would complicate the example without significantly adding to the learning outcome.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将忽略任何GUI支持，并模拟`--enable-gui=no`，因为这会使示例复杂化，而对学习成果没有显著增加。
- en: 'We will place the following options and defaults in `CMakeLists.txt`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`CMakeLists.txt`中放置以下选项和默认值：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will emulate the `--with-features` flag using a variable, `FEATURES`, that
    can be defined with `cmake -D FEATURES=value`. We make sure that if `FEATURES`
    is not set, it defaults to "huge":'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个变量`FEATURES`来模拟`--with-features`标志，该变量可以通过`cmake -D FEATURES=value`来定义。我们确保如果`FEATURES`未设置，它默认为"huge"：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also make sure that users provide a valid value for `FEATURES`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还要确保用户为`FEATURES`提供有效的值：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last line, containing `set_property(CACHE FEATURES PROPERTY STRINGS ${_available_features})`,
    has the nice effect that when configuring the project using `cmake-gui`, the user
    is presented with a selection field for `FEATURES` listing all available features
    that we have defined already (see also [https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/](https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行`set_property(CACHE FEATURES PROPERTY STRINGS ${_available_features})`有一个很好的效果，即在使用`cmake-gui`配置项目时，用户会看到一个用于`FEATURES`的选择字段，列出了我们已定义的所有可用功能（另请参见[https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/](https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/)）。
- en: The options can either be placed in the top-level `CMakeLists.txt` (as we have
    done here) or they can be defined close to the targets that query `ENABLE_NETBEANS`, `ENABLE_CHANNEL`, `ENABLE_TERMINAL`,
    and `FEATURES`. The former strategy has the advantage that options are listed
    in one place and one does not need to traverse a tree of `CMakeLists.txt` files
    to find the definition of an option. Since we have not defined any targets yet,
    we can start with keeping the options in a central file, but we may later move
    the option definition closer to the targets to localize scope and arrive at more
    reusable CMake building blocks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以放在顶层的`CMakeLists.txt`中（正如我们在这里所做的），或者可以定义在查询`ENABLE_NETBEANS`、`ENABLE_CHANNEL`、`ENABLE_TERMINAL`和`FEATURES`的目标附近。前一种策略的优势在于选项集中在一个地方，不需要遍历`CMakeLists.txt`文件树来查找选项的定义。由于我们还没有定义任何目标，我们可以从将选项保存在一个中心文件开始，但稍后我们可能会将选项定义移到更接近目标的位置，以限制范围并得到更可重用的CMake构建块。
- en: Start with the executable and very few targets, later localize scope
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从可执行文件和非常少的目标开始，稍后限制范围
- en: 'Let us add some sources. In the Vim example, sources are under `src` and to
    keep the main `CMakeLists.txt` readable and maintainable, we will create a new
    file, `src/CMakeLists.txt`, and process this file in its own directory scope by
    adding this to the main `CMakeLists.txt`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些源文件。在Vim示例中，源文件位于`src`目录下，为了保持主`CMakeLists.txt`的可读性和可维护性，我们将创建一个新文件`src/CMakeLists.txt`，并通过在主`CMakeLists.txt`中添加以下内容来在它自己的目录范围内处理该文件：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside `src/CMakeLists.txt`, we could start out defining the executable target
    and listing all sources that we have extracted from `build.log`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/CMakeLists.txt`内部，我们可以开始定义可执行目标并列出从`build.log`中提取的所有源文件：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a start. In this case, the code will not even configure since the list
    of sources contains generated files. Before we discuss generated files and link
    dependencies, we will split this long list up a bit to limit the scope of target
    dependencies and to make the project more manageable. We will also make it easier
    for CMake to scan source file dependencies and avoid a very long link line if
    we group them to targets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开始。在这种情况下，代码甚至不会配置，因为源文件列表包含生成的文件。在我们讨论生成的文件和链接依赖之前，我们将把这个长列表分成几个部分，以限制目标依赖的范围，并使项目更易于管理。如果我们将它们分组到目标中，我们还将使CMake更容易扫描源文件依赖关系，并避免出现非常长的链接行。
- en: For the Vim example, we can gain further insight into the grouping of sources
    from `src/Makefile` and `src/configure.ac`. From these files, we can deduce that
    most sources are basic and required. Some sources are optional (`netbeans.c` should
    only be built if `ENABLE_NETBEANS` is `ON` and `channel.c` should only be built
    when `ENABLE_CHANNEL` is `ON`). In addition, we can probably group all sources
    under `src/libvterm/` and make their compilation optional with `ENABLE_TERMINAL`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vim示例，我们可以从 `src/Makefile` 和 `src/configure.ac` 中获得关于源文件分组的更多见解。从这些文件中，我们可以推断出大多数源文件是基本的和必需的。有些源文件是可选的（`netbeans.c`
    应该只在 `ENABLE_NETBEANS` 为 `ON` 时构建，`channel.c` 应该只在 `ENABLE_CHANNEL` 为 `ON` 时构建）。此外，我们可能可以将所有源文件归类在
    `src/libvterm/` 下，并使用 `ENABLE_TERMINAL` 使它们的编译成为可选。
- en: 'With this, we reorganize the CMake structure to the following tree structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们将CMake结构重新组织为以下树形结构：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The top-level file adds `src/CMakeLists.txt` with `add_subdirectory(src)`.
    The `src/CMakeLists.txt` file now contains three targets (one executable and two
    libraries), each carrying compile definitions and include directories. We first
    define the executable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级文件添加了 `src/CMakeLists.txt` 并包含 `add_subdirectory(src)`。`src/CMakeLists.txt`
    文件现在包含三个目标（一个可执行文件和两个库），每个目标都带有编译定义和包含目录。我们首先定义可执行文件：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we define the required sources:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义所需的源文件：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we define the optional sources:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义可选的源文件：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The file also optionally processes and links `src/libvterm/` with the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还选择性地处理并链接 `src/libvterm/`，使用以下代码：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The corresponding `src/libvterm/CMakeLists.txt` contains the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 `src/libvterm/CMakeLists.txt` 包含以下内容：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have extracted the compile definitions from the recorded `build.log`. The
    advantage of the tree structure is that targets are defined close to where sources
    are located. If we decide to refactor the code and rename or move directories,
    the CMake files describing the targets have the chance to move with the sources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从记录的 `build.log` 中提取了编译定义。树形结构的优点是目标定义靠近源文件所在的位置。如果我们决定重构代码并重命名或移动目录，描述目标的CMake文件有机会随源文件一起移动。
- en: 'Our example code still does not even configure (unless this is tried after
    a successful Autotools build):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例代码甚至还没有配置（除非在成功的Autotools构建之后尝试）：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We need to generate `auto/pathdef.c` (and other files), which we will consider
    in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要生成 `auto/pathdef.c`（以及其他文件），我们将在下一节中考虑这一点。
- en: Generating files and writing platform checks
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文件和编写平台检查
- en: 'It turns out that for the Vim code example, we need to generate three files
    at configure time, `src/auto/pathdef.c`, `src/auto/config.h`, and `src/auto/osdef.h`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，对于Vim代码示例，我们需要在配置时生成三个文件：`src/auto/pathdef.c`、`src/auto/config.h` 和 `src/auto/osdef.h`：
- en: '`pathdef.c` records the install path, compile and link flags, the user who
    compiled the code, and the hostname'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathdef.c` 记录安装路径、编译和链接标志、编译代码的用户以及主机名'
- en: '`config.h` contains compile definitions that are specific to the system environment'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.h` 包含特定于系统环境的编译定义'
- en: '`osdef.h` is a file containing compile definitions generated by `src/osdef.sh`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osdef.h` 是一个包含由 `src/osdef.sh` 生成的编译定义的文件。'
- en: This situation is rather common. We will need to configure a file based on CMake
    variables, perform a number of platform checks to generate `config.h`, and execute
    a script at configure time. In particular, the platform checks are very common
    for projects striving for portability to accommodate the subtle differences between
    operating systems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况相当常见。我们需要根据CMake变量配置一个文件，执行一系列平台检查以生成 `config.h`，并在配置时执行一个脚本。特别是，平台检查对于追求可移植性的项目来说非常常见，以适应操作系统之间的微妙差异。
- en: 'In the original layout, files are generated under the `src` folder. We do not
    like this approach and we will do it differently in our example CMake port: these
    files will be generated in the build directory. The reason for this is that generated
    files often depend on the chosen options, compiler, or build type and we wish
    to keep the ability to configure multiple builds with the same source. To enable
    generation in the build directory, we will have to apply minimal changes to the
    script which generates one of the files listed before.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始布局中，文件在 `src` 文件夹下生成。我们不喜欢这种方法，在我们的示例CMake移植中将采取不同的做法：这些文件将在构建目录中生成。这样做的原因是，生成的文件通常依赖于所选的选项、编译器或构建类型，我们希望保持能够配置多个具有相同源代码的构建的能力。为了在构建目录中启用生成，我们将不得不对之前列出的文件之一的生成脚本进行最小程度的更改。
- en: How to structure files
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何组织文件
- en: 'We will collect functions that generate these files in `src/autogenerate.cmake`,
    include this module, and call these functions in `src/CMakeLists.txt` before defining
    the executable target:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收集生成这些文件的函数在`src/autogenerate.cmake`中，包含此模块，并在定义可执行目标之前在`src/CMakeLists.txt`中调用这些函数：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The included `src/autogenerate.cmake` contains other includes for functionality
    that we will require to probe header files, functions, and libraries, as well
    as the three functions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的`src/autogenerate.cmake`包含其他包含功能，我们将需要这些功能来探测头文件，函数和库，以及三个函数：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We choose to generate files with functions rather than in macros or "naked"
    CMake code. As we discussed in previous chapters, this sidesteps many pitfalls:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用函数生成文件，而不是宏或“裸”CMake代码。正如我们在前几章中讨论的那样，这避免了许多陷阱：
- en: It lets us avoid files being generated multiple times, in case we accidentally
    include the module multiple times. As noted in Recipe 5, *Redefining functions
    and macros*, in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, we could employ an include guard to protect against accidentally running
    code multiple times.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够避免文件被多次生成，以防我们不小心多次包含该模块。如第5章中的*重新定义函数和宏*所述，在[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构*中，我们可以使用包含保护来防止不小心多次运行代码。
- en: It guarantees full control over the scope of variables defined within the functions.
    This avoids that these definitions spill out and pollute the main scope.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保完全控制函数内部定义的变量的作用域。这避免了这些定义泄漏并污染主作用域。
- en: Configuring preprocessor definitions based on the system environment
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据系统环境配置预处理器定义
- en: 'The `config.h` file is generated from `src/config.h.in`, which contains preprocessor
    flags that are configured depending on the system capabilities:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.h`文件是从`src/config.h.in`生成的，其中包含根据系统能力配置的预处理器标志：'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An example generated from `src/config.h` can start like this example (definitions
    can differ depending on the environment):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从`src/config.h`生成的示例可以像这个示例一样开始（定义可能因环境而异）：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A great resource for platform checks is this page: [https://www.vtk.org/Wiki/CMake:How_To_Write_Platform_Checks](https://www.vtk.org/Wiki/CMake:How_To_Write_Platform_Checks).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 平台检查的一个很好的资源是这个页面：[https://www.vtk.org/Wiki/CMake:How_To_Write_Platform_Checks](https://www.vtk.org/Wiki/CMake:How_To_Write_Platform_Checks)。
- en: In `src/configure.ac`, we can examine which platform checks we need to perform
    to set corresponding preprocessor definitions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/configure.ac`中，我们可以检查需要执行哪些平台检查以设置相应的预处理器定义。
- en: We will make use of `#cmakedefine` ([https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine](https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine))
    and to make sure we do not break the existing Autotools build, we will copy `config.h.in`
    to `config.h.cmake.in` and change all `#undef SOME_DEFINITION` to `#cmakedefine
    SOME_DEFINITION @SOME_DEFINITION@`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`#cmakedefine`（[https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine](https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine)），并确保我们不会破坏现有的Autotools构建，我们将复制`config.h.in`到`config.h.cmake.in`，并将所有`#undef
    SOME_DEFINITION`更改为`#cmakedefine SOME_DEFINITION @SOME_DEFINITION@`。
- en: 'In the `generate_config_h` function, we first define a couple of variables:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`generate_config_h`函数中，我们首先定义一些变量：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we perform a couple of type size checks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行一些类型大小检查：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we loop over functions and check whether the system is able to resolve
    them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历函数并检查系统是否能够解析它们：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We verify whether a particular library contains a particular function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证特定的库是否包含特定的函数：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we loop over header files and check whether they are available:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历头文件并检查它们是否可用：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we translate CMake options from the main `CMakeLists.txt` to preprocessor
    definitions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将CMake选项从主`CMakeLists.txt`转换为预处理器定义：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, we check whether we are able to compile a particular code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查是否能够编译特定的代码片段：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The defined variables are then used to configure `src/config.h.cmake.in` to
    `config.h`, which concludes the `generate_config_h` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用定义的变量来配置`src/config.h.cmake.in`到`config.h`，这完成了`generate_config_h`函数：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuring files with paths and compiler flags
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径和编译器标志配置文件
- en: 'We generate `pathdef.c` from `src/pathdef.c.in`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成`pathdef.c`从`src/pathdef.c.in`：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `generate_pathdef_c` function configures `src/pathdef.c.in`, but we leave
    out link flags for simplicity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_pathdef_c`函数配置`src/pathdef.c.in`，但我们省略了链接标志以简化：'
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Executing shell scripts at configure time
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置时执行shell脚本
- en: 'Finally, we generate `osdef.h` using the following function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下函数生成`osdef.h`：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In order to generate `osdef.h` in `${CMAKE_CURRENT_BINARY_DIR}/src/auto` instead
    of `src/auto`, we had to adapt `osdef.sh` to accept `${CMAKE_CURRENT_BINARY_DIR}`
    as a command line argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `${CMAKE_CURRENT_BINARY_DIR}/src/auto` 而不是 `src/auto` 中生成 `osdef.h`，我们不得不修改
    `osdef.sh` 以接受 `${CMAKE_CURRENT_BINARY_DIR}` 作为命令行参数。
- en: 'Inside `osdef.sh`, we check whether this argument is given:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`osdef.sh`内部，我们检查是否给出了这个参数：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then, we generate `${target_directory}/auto/osdef.h`. To do so, we also
    had to adjust the following compilation line inside `osdef.sh`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成 `${target_directory}/auto/osdef.h`。为此，我们还需要调整`osdef.sh`内部的下述编译行：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Detecting required dependencies and linking
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测所需依赖项和链接
- en: 'We have now all generated files in place, so let us retry the build. We should
    be able to configure and compile the sources, but we will not be able to link:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有生成的文件放置到位，让我们重新尝试构建。我们应该能够配置和编译源代码，但我们无法链接：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Again, we can take the log file from the Autotools compilation and, in particular,
    the link line as inspiration to resolve the missing dependencies by adding the
    following code to `src/CMakeLists.txt`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从Autotools编译的日志文件中，特别是链接行中获得灵感，通过在`src/CMakeLists.txt`中添加以下代码来解决缺失的依赖：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Observe how we can add one library dependency to the target at a time and do
    not have to construct and carry around a list of libraries in a variable, which
    would produce more brittle CMake code since the variable could get corrupted on
    the way, in particular for larger projects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何一次向目标添加一个库依赖，而不必构建和携带一个变量中的库列表，这会导致更脆弱的CMake代码，因为变量在过程中可能会被破坏，尤其是在大型项目中。
- en: 'With this change, the code compiles and links:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，代码编译并链接：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can now try to execute the compiled binary and edit some files with our newly
    compiled version of Vim!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试执行编译后的二进制文件，并用我们新编译的Vim版本编辑一些文件！
- en: Reproducing compiler flags
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现编译器标志
- en: Let us now try to adjust the compiler flags to mirror the reference build.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试调整编译器标志以反映参考构建。
- en: Defining compiler flags
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义编译器标志
- en: So far, we have not defined any custom compiler flags, but from the reference
    Autotools build, we remember that the code was compiled with `-g -U_FORTIFY_SOURCE
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有定义任何自定义编译器标志，但从参考Autotools构建中，我们记得代码是用`-g -U_FORTIFY_SOURCE`编译的
- en: -D_FORTIFY_SOURCE=1 -O2` using the GNU C compiler.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D_FORTIFY_SOURCE=1 -O2` 使用GNU C编译器。'
- en: 'Our first approach could be to define the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个方法可能是定义以下内容：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And, we would place this code on top of `src/CMakeLists.txt`, right before
    generating source files (since `pathdef.c` uses `${CMAKE_C_FLAGS}`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，我们会将这段代码放在`src/CMakeLists.txt`的顶部，就在生成源文件之前（因为`pathdef.c`使用了`${CMAKE_C_FLAGS}`）：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A slight improvement to the compiler flag definitions would be to define `-O2`
    as a `Release` configuration flag and to turn off optimization for a `Debug` configuration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对编译器标志定义的一个小改进是将`-O2`定义为`Release`配置标志，并为`Debug`配置关闭优化：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Please verify with `make VERBOSE=1` that the build uses the expected flags.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`make VERBOSE=1`验证构建是否使用了预期的标志。
- en: Scope of compiler flags
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器标志的范围
- en: In this particular example project, all source files use the same compile flags.
    For other projects, we may prefer to not define compile flags globally as we have
    done above, but to define flags individually for each target using `target_compile_options`.
    The advantage would be more flexibility and more local scope. The price to pay
    in our example here would probably be unnecessary code duplication.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的示例项目中，所有源文件使用相同的编译标志。对于其他项目，我们可能更倾向于不全局定义编译标志，而是使用`target_compile_options`为每个目标单独定义标志。这样做的好处是更灵活和更局部的范围。在我们这里的例子中，代价可能是不必要的代码重复。
- en: Porting tests
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植测试
- en: Let us now discuss how to port tests from the reference build to our CMake build.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何将测试从参考构建移植到我们的CMake构建。
- en: Getting started
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'If the project that is being ported contains a test target or any form of automated
    testing or test scripts, the first step will again be to run the traditional test
    step and record the commands used. For the Vim project, the place to start is `src/testdir/Makefile`.
    It will probably make sense to define tests on the CMake side close to `src/testdir/Makefile`
    and the test scripts, and we will choose to define tests in `src/testdir/CMakeLists.txt`.
    To process such a file, we must reference it in `src/CMakeLists.txt`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在移植的项目包含测试目标或任何形式的自动化测试或测试脚本，第一步将再次是运行传统的测试步骤并记录使用的命令。对于Vim项目，起点是`src/testdir/Makefile`。在CMake侧定义测试可能是有意义的，接近`src/testdir/Makefile`和测试脚本，我们将选择在`src/testdir/CMakeLists.txt`中定义测试。为了处理这样的文件，我们必须在其`src/CMakeLists.txt`中引用它：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We should also enable the test target in the top-level `CMakeLists.txt`, right
    before processing `src/CMakeLists.txt`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在顶层`CMakeLists.txt`中启用测试目标，就在处理`src/CMakeLists.txt`之前：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So far, the test target is empty before we populate `src/testdir/CMakeLists.txt`
    with `add_test` directives. The minimum to specify in `add_test` is a test name
    and a command to run. The command can be any script written in any language. The
    essential part for CMake is that the script returns zero if the test is successful
    and non-zero if the test fails. For more details, we refer the reader to [Chapter
    4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running Tests*.
    In the case of Vim, we will need a bit more to accommodate multi-step tests, which
    we will discuss in the next section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们向`src/testdir/CMakeLists.txt`填充`add_test`指令之前，测试目标还是空的。`add_test`中最少需要指定的是测试名称和一个运行命令。该命令可以是任何语言编写的任何脚本。对于CMake来说，关键的是如果测试成功，脚本返回零，如果测试失败，则返回非零。更多详情，我们请读者参考[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*。对于Vim的情况，我们需要更多来适应多步骤测试，我们将在下一节讨论。
- en: Implementing a multi-step test
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多步骤测试
- en: 'The targets in `src/testdir/Makefile` indicate that the Vim code runs tests
    as multi-step tests: first the `vim` executable processes a script and produces
    an output file, then in a second step the output file is compared with a reference
    file and if these files do not differ, the test is successful. Temporary files
    are then removed in a third step. This can probably not be fitted into a single
    `add_test` command in a portable way since `add_test` can only execute one command.
    One solution would be to define the test steps in a Python script and to execute
    the Python script with some arguments. The alternative we will present here, which
    is also cross-platform, is to define the test steps in a separate CMake script
    and to execute this script from `add_test`.  We will define the test steps in
    `src/testdir/test.cmake`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/testdir/Makefile`中的目标表明Vim代码以多步骤测试运行：首先，`vim`可执行文件处理一个脚本并生成一个输出文件，然后在第二步中，输出文件与参考文件进行比较，如果这些文件没有差异，则测试成功。临时文件随后在第三步中被删除。这可能无法以可移植的方式适应单个`add_test`命令，因为`add_test`只能执行一个命令。一个解决方案是将测试步骤定义在一个Python脚本中，并用一些参数执行该Python脚本。我们将在这里介绍的另一种替代方案也是跨平台的，即将测试步骤定义在一个单独的CMake脚本中，并从`add_test`执行该脚本。我们将在`src/testdir/test.cmake`中定义测试步骤：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Again, we choose a function over a macro to make sure variables do not escape
    the function scope. We will process this script, which will call the `execute_test`
    function. However, we have to make sure that `${VIM_EXECUTABLE}`, `${WORKING_DIR}`,
    and `${TEST_SCRIPT}` are defined from outside. These are defined in `src/testdir/CMakeLists.txt`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们选择函数而非宏来确保变量不会逃逸函数作用域。我们将处理这个脚本，该脚本将调用`execute_test`函数。然而，我们必须确保从外部定义了`${VIM_EXECUTABLE}`、`${WORKING_DIR}`和`${TEST_SCRIPT}`。这些在`src/testdir/CMakeLists.txt`中定义：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Vim project has many tests but in this example, we have ported only one
    (test1) as a proof of concept.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Vim项目有许多测试，但在本例中，我们只移植了一个（test1）作为概念验证。
- en: Recommendation for tests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试建议
- en: We can give at least two recommendations for porting tests. First, to make sure
    that the test does not always report success, verify that the test fails if you
    break the code or change the reference data. Second, add `COST` estimates to tests
    so that when run in parallel, longer tests are started first to minimize the total
    test time (see [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 8, *Running tests in parallel*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少可以给出两个关于移植测试的建议。首先，确保测试不会总是报告成功，如果代码被破坏或参考数据被更改，请验证测试是否失败。其次，为测试添加`COST`估计，以便在并行运行时，较长的测试首先启动，以最小化总测试时间（参见[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，第8个配方，*并行运行测试*）。
- en: Porting install targets
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植安装目标
- en: We can now configure, compile, link, and test the code, but we are missing the
    install target, which we will add in this section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以配置、编译、链接和测试代码，但我们缺少安装目标，我们将在本节中添加它。
- en: 'This is the Autotools approach to building and installing code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Autotools构建和安装代码的方法：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And this is the CMake way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是CMake的方式：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To add an install target, we add the following snippet in `src/CMakeLists.txt`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加安装目标，我们需在`src/CMakeLists.txt`中添加以下代码片段：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we only install the executable. The Vim project installs a
    large number of files along with the binary (symbolic links and documentation
    files). To keep this section digestible, we don't install all other files in this
    example migration. For your own project, you should verify that the result of
    the install step matches the install target of the legacy build framework.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们只安装了可执行文件。Vim项目在安装二进制文件的同时安装了大量文件（符号链接和文档文件）。为了使本节易于理解，我们没有在本例迁移中安装所有其他文件。对于你自己的项目，你应该验证安装步骤的结果是否与遗留构建框架的安装目标相匹配。
- en: Further steps
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的步骤
- en: 'After a successful port to CMake, the next step should be to localize the scope
    of targets and variables even further: consider moving options, targets, and variables
    closer to where they are used and modified. Avoid global variables since they
    will enforce an order to CMake commands, and this order may not be evident and
    will lead to a brittle CMake code. One approach to enforcing the separation of
    variable scopes is to divide larger projects into CMake projects, which are composed
    using the superbuild pattern (see [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml),
    *The Superbuild Pattern*). Consider splitting large `CMakeLists.txt` files into
    smaller modules.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 成功移植到CMake后，下一步应该是进一步限定目标和变量的范围：考虑将选项、目标和变量移动到它们被使用和修改的位置附近。避免全局变量，因为它们会强制CMake命令的顺序，而这个顺序可能不明显，会导致脆弱的CMake代码。一种强制分离变量范围的方法是将大型项目划分为CMake项目，这些项目使用超级构建模式（参见[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*）。考虑将大型`CMakeLists.txt`文件拆分为较小的模块。
- en: The next steps can be to test the configuration and compilation on other platforms
    and operating systems in order to generalize and bullet-proof the CMake code and
    make it more portable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤可能是在其他平台和操作系统上测试配置和编译，以便使CMake代码更加通用和防弹，并使其更具可移植性。
- en: Finally, when migrating projects to a new build framework, the developer community
    needs to adapt to it too. Help your colleagues with training, documentation, and
    code review. The hardest part in porting code to CMake can be to change the habits
    of humans.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在将项目迁移到新的构建框架时，开发社区也需要适应它。通过培训、文档和代码审查帮助你的同事。在将代码移植到CMake时，最难的部分可能是改变人的习惯。
- en: Summary and common pitfalls when converting projects to CMake
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换项目到CMake时的总结和常见陷阱
- en: Let us summarize what we have achieved in this chapter and what we learned.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章我们取得了哪些成就以及我们学到了什么。
- en: Summary of code changes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码变更总结
- en: 'In this chapter, we have discussed how to port a project to CMake. We have
    considered the Vim project as an example and added the following files:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何将项目移植到CMake。我们以Vim项目为例，并添加了以下文件：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The changes can be browsed online: [https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support](https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在线浏览变更：[https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support](https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support)。
- en: This was an incomplete proof of concept port to CMake, where we left out many
    options and tweaks for simplicity and tried to focus on the most salient features
    and steps.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不完整的CMake移植概念证明，我们省略了许多选项和调整以简化，并试图专注于最突出的特性和步骤。
- en: Common pitfalls
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: We would like to conclude this discussion by pointing out some common pitfalls
    when moving to CMake.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过指出转向CMake时的一些常见陷阱来结束这次讨论。
- en: '**Global variables are code smell**: This is true for any programming language,
    and CMake is no exception. Variables that are carried across CMake files, and
    in particular "upwards" from leaf to parent `CMakeLists.txt` files, indicate code
    smell. There is typically a better way to transfer dependencies. Ideally, dependencies
    should be imported through targets. Instead of assembling a list of libraries
    into a variable and carrying the variable across files, link to libraries one
    by one close to where they are defined. Instead of assembling source files into
    variables, add source files using `target_sources`. When linking to libraries
    use imported targets when available, instead of variables.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量是代码异味**：这在任何编程语言中都是如此，CMake也不例外。跨越CMake文件的变量，特别是从叶子到父级`CMakeLists.txt`文件“向上”传递的变量，表明代码存在问题。通常有更好的方式来传递依赖。理想情况下，依赖应该通过目标来导入。不要将一系列库组合成一个变量并在文件之间传递该变量，而是将库一个接一个地链接到它们定义的位置附近。不要将源文件组合成变量，而是使用`target_sources`添加源文件。在链接库时，如果可用，使用导入的目标而不是变量。'
- en: '**Minimize the effect of order**: CMake is not a declarative language, but
    we should not approach it with an imperative paradigm either. CMake sources that
    enforce a strict order tend to be brittle. This also connects to the discussion
    about variables (see previous paragraph). Some order of statements and modules
    will be necessary, but to arrive at robust CMake frameworks, we should avoid unnecessary
    enforcement of order. Use `target_sources`, `target_compile_definitions`, `target_include_directories`,
    and `target_link_libraries`. Avoid global scope statements such as `add_definitions`,
    `include_directories`, and `link_libraries`. Avoid global definitions of compile
    flags. If possible, define compile flags per target.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化顺序影响**：CMake不是一种声明式语言，但我们也不应该用命令式范式来处理它。强制严格顺序的CMake源码往往比较脆弱。这也与变量的讨论有关（见前一段）。某些语句和模块的顺序是必要的，但为了得到稳健的CMake框架，我们应该避免不必要的顺序强制。使用`target_sources`、`target_compile_definitions`、`target_include_directories`和`target_link_libraries`。避免全局范围的语句，如`add_definitions`、`include_directories`和`link_libraries`。避免全局定义编译标志。如果可能，为每个目标定义编译标志。'
- en: '**Do not place generated files outside the build directory**: It is highly
    recommended to never place generated files outside the build directory. The reason
    for this is that generated files often depend on the chosen options or compiler
    or build type, and by writing into the source tree, we give up the possibility
    to maintain several builds with the same source and we complicate reproducibility
    of the build steps.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要将生成的文件放置在构建目录之外**：强烈建议永远不要将生成的文件放置在构建目录之外。这样做的原因是，生成的文件通常依赖于所选的选项、编译器或构建类型，而将文件写入源代码树中，我们放弃了维护多个具有相同源代码的构建的可能性，并且使构建步骤的可重复性变得复杂。'
- en: '**Prefer functions over macros**: They have different scopes and the function
    scope is limited. All variable modifications need to be explicitly marked, which
    also signals variable redefinitions to the reader. Use a macro when you must but
    prefer functions if you can.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用函数而非宏**：它们具有不同的作用域，函数作用域是有限的。所有变量修改都需要明确标记，这也向读者表明了变量重定义。当你必须使用宏时使用，但如果你能使用函数，则优先使用函数。'
- en: '**Avoid shell commands**: They may not be portable to other platforms (such
    as Windows). Prefer using CMake equivalents. If no CMake equivalent is available,
    consider calling a Python script.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免shell命令**：它们可能不兼容其他平台（如Windows）。优先使用CMake的等效命令。如果没有可用的CMake等效命令，考虑调用Python脚本。'
- en: '**In Fortran projects, be careful with the suffix case**: Fortran sources that
    need to be preprocessed should have an uppercase `.F90` suffix. Sources that are
    not to be preprocessed should carry the `.f90` suffix.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Fortran项目中，注意后缀大小写**：需要预处理的Fortran源文件应具有大写的`.F90`后缀。不需要预处理的源文件应具有小写的`.f90`后缀。'
- en: '**Avoid explicit paths**: This is true both when defining targets and when
    referencing files. Use `CMAKE_CURRENT_LIST_DIR` when referring to the current
    path. The advantage of this is that when you move or rename a directory, it will
    still work.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免显式路径**：无论是在定义目标时还是在引用文件时都是如此。使用`CMAKE_CURRENT_LIST_DIR`来引用当前路径。这样做的好处是，当你移动或重命名目录时，它仍然有效。'
- en: '**Module includes should not be function calls**: Modularizing the CMake code
    into modules is a good strategy, but including a module should ideally not execute
    CMake code. Instead, wrap CMake code into functions and macros and explicitly
    call these after including the module. This protects against unintended effects
    when accidentally including a module multiple times and makes the action of executing
    CMake code modules more explicit to the reader.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块包含不应是函数调用**：将CMake代码模块化是一个好的策略，但包含模块理想情况下不应执行CMake代码。相反，应将CMake代码封装到函数和宏中，并在包含模块后显式调用这些函数和宏。这可以防止无意中多次包含模块时产生的不良后果，并使执行CMake代码模块的动作对读者更加明确。'
