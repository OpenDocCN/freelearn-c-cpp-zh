- en: Reactive Microservices Using C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++的响应式微服务
- en: 'So far, we have covered essential aspects of reactive programming using C++.
    Some of the key topics covered include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了使用C++进行响应式编程的基本方面。涵盖的一些关键主题包括：
- en: The reactive programming model and its cognitive prerequisites
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程模型及其认知先决条件
- en: The RxCpp library and its programming model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxCpp库及其编程模型
- en: Reactive GUI programming using Qt/RxCpp
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt/RxCpp进行响应式GUI编程
- en: Writing Custom Operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义操作符
- en: Design patterns and the reactive programming model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式和响应式编程模型
- en: If you take a closer look, all examples so far in this book are related to what
    happens inside a process. Or, we were essentially focusing on shared memory parallel
    and concurrent techniques. The Rx.net, RxJava and most Rx implementations are  
    basically concerned with shared memory concurrent and parallel programming. A
    system such as Akka applies reactive programming model to the distributed world.
    In Akka, we can write reactive logic that spans processes and machines. The reactive
    programming model is also good for exposing REST-based web services and consuming
    them. The RxJs library is mostly used for consuming REST-based services from a
    browser page. The RxCpp library can be used for writing web clients for aggregating
    the contents from various service endpoints. We can leverage the RxCpp library 
    from  console and GUI applications. Another use case is aggregating data from
    multiple fine-grained services and delivering it to web clients.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，这本书中到目前为止的所有例子都与进程内发生的事情有关。或者，我们基本上关注的是共享内存并发和并行技术。Rx.net、RxJava和大多数Rx实现基本上都涉及共享内存并发和并行编程。像Akka这样的系统将响应式编程模型应用于分布式世界。在Akka中，我们可以编写跨进程和机器的响应式逻辑。响应式编程模型也适用于暴露基于REST的Web服务和消费它们。RxJs库主要用于从浏览器页面消费基于REST的服务。RxCpp库可用于编写用于聚合来自各种服务端点的内容的Web客户端。我们可以从控制台和GUI应用程序中利用RxCpp库。另一个用例是从多个细粒度服务中聚合数据并将其传递给Web客户端。
- en: In this chapter, we will write a basic web application, using C++, that will
    leverage the Microsoft C++ REST SDK to write the server part and use the (C++
    REST SDK ) client library to consume those services. In the process, we will explain
    what micro-services are and how to consume them. We will also explain how the
    RxCpp library can be used to access REST endpoints and HTML pages ,by writing
    a wrapper on top of the `libcurl` library. We are planning to leverage Kirk Shoop's
    RxCurl library (written as part of his Twitter analysis application) to demonstrate
    this technique.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用C++编写一个基本的Web应用程序，利用Microsoft C++ REST SDK编写服务器部分，并使用（C++ REST SDK）客户端库来消费这些服务。在这个过程中，我们将解释什么是微服务以及如何消费它们。我们还将解释如何使用RxCpp库来访问REST端点和HTML页面，通过在`libcurl`库的顶部编写包装器。我们计划利用Kirk
    Shoop的RxCurl库（作为他的Twitter分析应用程序的一部分编写）来演示这种技术。
- en: The C++ language and web programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++语言和Web编程
- en: Nowadays, most web-centric applications are developed using Python, Java, C#,
    PHP, and other high-level languages. But, for these applications, people place
    reverse proxies, such as NGINX, Apache Web server, or IIS redirector, to manage
    the traffic . All of these reverse proxies are written in C++. Likewise, most
    of the web browsers and HTTP client libraries, such as `libwww`, `libcurl`, and
    `WinInet`, are written using C++.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数面向Web的应用程序都是使用Python、Java、C#、PHP和其他高级语言开发的。但是，对于这些应用程序，人们会放置反向代理，如NGINX、Apache
    Web服务器或IIS重定向器，来管理流量。所有这些反向代理都是用C++编写的。同样，大多数Web浏览器和HTTP客户端库，如`libwww`、`libcurl`和`WinInet`，都是使用C++编写的。
- en: One reason why Java, (statically-typed) C#, and other dynamic languages (such
    as Python, Ruby, and PHP) became popular is the fact that these languages support
    reflective capabilities (in the case of static languages, such as C#/Java) and
    duck typing (supported by dynamic languages). These features help web application
    servers to load  web page handlers dynamically. Read about them by searching for
    keywords such as *Reflection API* and *Duck Typing*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java、（静态类型的）C#和其他动态语言（如Python、Ruby和PHP）变得流行的一个原因是，这些语言支持反射能力（在静态语言如C#/Java的情况下）和鸭子类型（动态语言支持）。这些功能帮助Web应用程序服务器动态加载Web页面处理程序。通过搜索关键字如*Reflection
    API*和*Duck Typing*来了解它们。
- en: The REST programming model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST编程模型
- en: 'The REST, which stands for  **REpresentational State Transfer**, is an architectural
    style spearheaded by Roy Fielding as part of his PhD thesis. Nowadays, it is one
    of the most popular technique for exposing and consuming web services. REST follows
    a resource-centric approach and nicely maps to the CRUD pattern, which are popular
    among programmers who are well versed in writing enterprise business applications.
    We use **JavaScript Object Notation** (also known as **JSON**) as payload while
    writing REST services, instead of the XML format (which is in vogue for SOAP services).
    The REST programming model relies on HTTP verbs (GET,POST,PUT,DELETE and so on
    )to indicate the kind of operations to be executed while receiving a REST API
    call. The most popular methods supported are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表**表现状态转移**，是由Roy Fielding作为他的博士论文的一部分推动的一种架构风格。如今，它是最流行的暴露和消费Web服务的技术之一。REST遵循以资源为中心的方法，并很好地映射到CRUD模式，这在熟悉编写企业业务应用程序的程序员中很受欢迎。在编写REST服务时，我们使用**JavaScript对象表示法**（也称为**JSON**）作为有效载荷，而不是XML格式（这在SOAP服务中很流行）。REST编程模型依赖于HTTP动词（GET、POST、PUT、DELETE等），以指示在接收REST
    API调用时要执行的操作类型。支持的最流行的方法有：
- en: '`POST`: Creates a new resource'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建新资源'
- en: '`GET`: Retrieves a resource'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：检索资源'
- en: '`PUT`: Updates an existing resource (if it''s a new resource, behaves like
    `POST`)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新现有资源（如果是新资源，则行为类似于`POST`）'
- en: '`DELETE`: Deletes a resource'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除资源'
- en: The C++ REST SDK
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ REST SDK
- en: 'The C++ REST SDK is a Microsoft project for cloud-based client-server communication
    in native code using a modern asynchronous C++ API design. This toolkit aims to
    help C++ developers connect to and interact with HTTP based services. The SDK
    has the following features that help you to write robust services:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++ REST SDK是一个Microsoft项目，用于使用现代异步C++ API设计在本机代码中进行基于云的客户端-服务器通信。这个工具包旨在帮助C++开发人员连接和与基于HTTP的服务进行交互。该SDK具有以下功能，可帮助您编写健壮的服务：
- en: HTTP client/server
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端/服务器
- en: JSON support
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON支持
- en: Asynchronous streams
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步流
- en: WebSocket's client
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket的客户端
- en: oAuth support
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: oAuth支持
- en: The C++ REST SDK relies on the parallel patterns library's task API. The PPL
    tasks is a powerful model for composing asynchronous operations based on modern
    C++ features. The C++ REST SDK supports Windows desktop, Windows Store (UWP),
    Linux, macOS, Unix, iOS, and Android.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C++ REST SDK依赖于并行模式库的任务API。PPL任务是一个基于现代C++特性组合异步操作的强大模型。C++ REST SDK支持Windows桌面、Windows
    Store（UWP）、Linux、macOS、Unix、iOS和Android。
- en: HTTP client programming using the C++ REST SDK
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++ REST SDK进行HTTP客户端编程
- en: 'The C++ REST SDK programming model is inherently  asynchronous in nature, and
    we can invoke the API calls in a synchronous manner as well. The following program
    will demonstrate how we can invoke HTTP client API calls asynchronously. The program
    demonstrates workings of the client side of the HTTP protocol supported by the
    C++ REST SDK. We use a technique called **task continuation** (a technique of
    chaining blocks of code) here to retrieve data from a web page and store it in
    a local disk file. The C++ REST SDK follows an asynchronous I/O model and we chain
    operations together. Finally, we invoke the composition using the `wait()` method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C++ REST SDK编程模型本质上是异步的，我们也可以以同步的方式调用API调用。以下程序将演示我们如何异步调用HTTP客户端API调用。该程序演示了C++
    REST SDK支持的HTTP协议的客户端端的工作方式。我们在这里使用了一种称为**任务继续**（一种链接代码块的技术）的技术来从网页中检索数据并将其存储在本地磁盘文件中。C++
    REST SDK遵循异步I/O模型，我们将操作链接在一起。最后，我们使用`wait()`方法调用组合：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above program demonstrate workings of the task continuation style of programming.
    The bulk of the code is about composing lambdas, and the actual execution starts
    when the `wait()` method is called. The lazy evaluation strategy of lambda functions
    helps us to compose code in the manner given above.We can invoke the logic in
    a synchronous manner as well. Consult the Microsoft C++ REST SDK documentation
    to learn more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序演示了任务继续编程风格的工作方式。大部分代码都是关于组合lambda表达式，实际执行是在调用`wait()`方法时开始的。lambda函数的惰性评估策略帮助我们以上述方式组合代码。我们也可以以同步的方式调用逻辑。请参阅Microsoft
    C++ REST SDK文档以了解更多信息。
- en: HTTP server programming using the C++ REST SDK
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++ REST SDK进行HTTP服务器编程
- en: We have already learned about HTTP client programming model supported by the
    C++ REST SDK. We worked with the asynchronous task-continuation-based API to retrieve
    contents of a web page and persist it into a disk file. Now, it is time to start
    concentrating on the REST SDK HTTP server programming. The C++ REST SDK has a
    listener interface that will handle HTTP requests, and we can place handlers for
    each type of the HTTP verbs, such as `GET`, `PUT`, `POST and so on`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了C++ REST SDK支持的HTTP客户端编程模型。我们使用了基于异步任务继续的API来检索网页内容并将其保存到磁盘文件中。现在，是时候开始集中精力研究REST
    SDK的HTTP服务器编程了。C++ REST SDK具有一个监听器接口，用于处理HTTP请求，我们可以为每种HTTP动词类型（如`GET`、`PUT`、`POST`等）放置处理程序。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `SimpleServer` C++ class is basically a wrapper on top of the `http_listener`
    class supported by the C++ REST SDK. The class listens for the incoming HTTP request,
    and it is possible to set request handlers for each request type (`GET`, `POST`,
    `PUT`, and so on). When a request arrives, `http_listener` will dispatch request
    information to associated handlers, depending upon the HTTP verb.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleServer` C++类基本上是C++ REST SDK支持的`http_listener`类的包装器。该类监听传入的HTTP请求，可以为每种请求类型（`GET`、`POST`、`PUT`等）设置请求处理程序。当请求到达时，`http_listener`将根据HTTP动词将请求信息分派给关联的处理程序。'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous code snippets bind request handlers to the `http_request` object.
    We are only focusing on the `GET`, `PUT`, `POST`, and `DELETE` verbs. These verbs
    are the most popular commands supported by all REST implementations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将请求处理程序绑定到`http_request`对象。我们只关注`GET`、`PUT`、`POST`和`DELETE`动词。这些动词是所有REST实现都支持的最流行的命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above code block follows a pattern that can be easily deciphered by any
    developer. All the handler does is print the request parameters to the console
    of the server and return a string to the client to indicate that the request was
    successfully completed. (HTTP status code - 200)  We will show how we can access
    these services through the POSTMAN and CURL utilities in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块遵循一种模式，任何开发人员都可以轻松解读。处理程序的所有操作只是将请求参数打印到服务器的控制台上，并向客户端返回一个字符串，指示请求已成功完成（HTTP状态码-200）。我们将在下一节中展示如何通过POSTMAN和CURL工具访问这些服务。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The main function instantiates an  instance of the  `SimpleListener`  class
    through the `StartServer` function. Then, the `main` function waits for a key
    to be pressed before the `ShutDown` function is called. Once we have kick-started
    the application, we can use the `CURL` tool or `POSTMAN` to test whether program
    works or not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数通过`StartServer`函数实例化`SimpleListener`类的实例。然后，`main`函数在调用`ShutDown`函数之前等待按键。一旦我们启动了应用程序，我们可以使用`CURL`工具或`POSTMAN`来测试程序是否工作。
- en: Testing the HTTP server using CURL and POSTMAN
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CURL和POSTMAN测试HTTP服务器
- en: '`CURL` is a command-line tool that is portable across Windows, GNU Linux, MacOS,
    and other POSIX compliant systems. The tool helps to transfer data using various
    TCP/IP-based application protocols. Some of the common protocols supported include
    HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, and LDAP,to name a few.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL`是一个跨Windows、GNU Linux、MacOS和其他POSIX兼容系统的命令行工具。该工具有助于使用各种基于TCP/IP的应用协议传输数据。一些常见的支持的协议包括HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、DICT、TELNET和LDAP等。'
- en: 'We will be using the `CURL` tool to test the HTTP server we wrote. The command-line
    utility can be invoked by giving the requisite command-line parameters to place
    HTTP requests with associated verbs. We give the command-line parameters for invoking
    the `GET` and the `PUT` request to the server we wrote:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CURL`工具来测试我们编写的HTTP服务器。可以通过给定必要的命令行参数来调用命令行实用程序，以发送带有关联动词的HTTP请求。我们给出了调用`GET`和`PUT`请求到我们编写的服务器的命令行参数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Embed the previous command in a batch file or shell script, depending upon
    your platform. The output on the console should be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个命令嵌入批处理文件或shell脚本中，具体取决于您的平台。控制台上的输出应该如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, by consulting the `CURL` documentation, we can test the other HTTP
    verbs as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过查阅`CURL`文档，我们也可以测试其他HTTP动词。
- en: POSTMAN is a powerful HTTP client for testing HTTP based services. It started
    as a side project by an Indian developer by the name  Abhinav Asthana.  It was
    a Chrome plugin that went viral. Today, it is an independent platform and there
    exists a company formed around this application, where Mr. Asthana is the CEO.
    You can download POSTMAN tool to test these services. Since download  URLs can
    change, please consult your favorite search engine to find the download URL in
    vogue. ( search for "POSTMAN HTTP Client")
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: POSTMAN是一个强大的HTTP客户端，用于测试基于HTTP的服务。它最初是由一位名叫Abhinav Asthana的印度开发人员作为一个副业项目开始的。它是一个在Chrome上广受欢迎的插件。今天，它是一个独立的平台，并且围绕这个应用程序成立了一家公司，Asthana先生是CEO。您可以下载POSTMAN工具来测试这些服务。由于下载URL可能会更改，请查阅您喜欢的搜索引擎以找到当前的下载URL。（搜索“POSTMAN
    HTTP客户端”）
- en: The libcurl and the HTTP client programming
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libcurl和HTTP客户端编程
- en: 'We have already come across the CURL utility, which is, in fact a wrapper on
    top of the `libcurl` library. We will use the libcurl  library to access REST
    services we wrote,in this chapter. To get you familiar with the libcurl library
    and its programming model, we will write a basic HTTP client using the library:
    The program will ping the  http://example.com.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了CURL实用程序，实际上是`libcurl`库的一个包装器。我们将使用libcurl库来访问我们在本章中编写的REST服务。为了让您熟悉libcurl库及其编程模型，我们将使用该库编写一个基本的HTTP客户端：该程序将ping
    http://example.com。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code pings the [http://example.com](http://example.com) URL to
    retrieve its contents and displays them on the console. The programming model
    is very simple, and the documentation of the library is really good. It is one
    of the most popular libraries for accessing the TCP/IP application services. In
    the next section, we will leverage a reactive wrapper on to top of the libcurl
    library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码会ping [http://example.com](http://example.com) URL以检索其内容，并在控制台上显示它们。编程模型非常简单，库的文档真的很好。它是访问TCP/IP应用服务的最受欢迎的库之一。在下一节中，我们将在libcurl库的顶部使用一个响应式包装器。
- en: Kirk Shoop's libCURL Wrapper library
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kirk Shoop的libCURL包装库
- en: The primary implementer of the RxCpp library is Kirk Shoop, who is currently
    associated with the Microsoft. He wrote a Twitter analysis sample app ([https://github.com/kirkshoop/twitter](https://github.com/kirkshoop/twitter))
    to demonstrate various facets of reactive programming. One of the things he did
    as part of the initiative was to write a reactive wrapper over `libcurl` to implement
    HTTP `GET` and `POST` methods. The authors of this book have extended his code
    to support the `PUT` and `DELETE` methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp库的主要实现者是Kirk Shoop，他目前与微软有关。他编写了一个Twitter分析示例应用程序（[https://github.com/kirkshoop/twitter](https://github.com/kirkshoop/twitter)），以演示响应式编程的各个方面。作为该倡议的一部分，他做的一件事是编写一个响应式包装器覆盖`libcurl`，以实现HTTP的`GET`和`POST`方法。本书的作者已经扩展了他的代码，以支持`PUT`和`DELETE`方法。
- en: 'Take a look at the `RxCurl` library bundled with the source code of this book:
    (The listing is too big to be included here )'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本书源代码捆绑的`RxCurl`库：（列表太长，无法在此处包含）
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created an `observable` by using the `factory` class for creating the HTTP
    `request` object. The `map` function just retrieves body of the response object.
    The most important structure in the whole code is the `http_request` struct, whose
    definition is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`factory`类创建HTTP `request`对象来创建一个`observable`。`map`函数只是检索响应对象的主体。整个代码中最重要的结构是`http_request`结构，其定义如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The purpose of the http_request structure is pretty much obvious from the above
    declaration. The members are
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的声明中，可以很明显地看出`http_request`结构的目的。成员是
- en: url - the target URL
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: url - 目标URL
- en: method - The HTTP verb
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: method - HTTP动词
- en: headers - HTTP headers
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: headers - HTTP头
- en: body - body of the request
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: body - 请求的主体
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `request` Observable can be subscribed for `on_next` using a lambda function
    that takes `observable<string>` ,as the `map` function returns `observable<string>`.
    In the body of the `on_next` function, we aggregate the content to produce a string
    using the `observable<string>::sum()` reducer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` Observable可以通过订阅`on_next`来使用lambda函数，该函数以`observable<string>`为参数，因为`map`函数返回`observable<string>`。在`on_next`函数的主体中，我们使用`observable<string>::sum()`约简器来聚合内容以生成一个字符串：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `response_message` Observable is subscribed with a lambda, which takes a
    string as the parameter. In the body of the `on_next` function, we simply assign
    the string containing the HTML to the `html` variable. Finally, we display the
    contents on to the console. Please take a look at the `rxcurl.h` header file to
    see how the library works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`response_message` Observable通过lambda进行订阅，该lambda以字符串作为参数。在`on_next`函数的主体中，我们简单地将包含HTML的字符串分配给`html`变量。最后，我们将内容显示在控制台上。请查看`rxcurl.h`头文件，以了解库的工作原理。'
- en: The JSON and HTTP protocol
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON和HTTP协议
- en: The payload format for invoking web services were once monopolized by the XML
    format. The SOAP-based services mostly support the XML format. With the advent
    of REST-based services, developers use **JavaScript Object Notation** (**JSON**)
    as the payload format.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: The payload format for invoking web services were once monopolized by the XML
    format. The SOAP-based services mostly support the XML format. With the advent
    of REST-based services, developers use **JavaScript Object Notation** (**JSON**)
    as the payload format. 用于调用Web服务的有效载荷格式曾经被XML格式垄断。基于SOAP的服务大多支持XML格式。随着基于REST的服务的出现，开发人员使用**JavaScript对象表示**（**JSON**）作为有效载荷格式。
- en: 'The following table shows a comparison between XML and corresponding JSON object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following table shows a comparison between XML and corresponding JSON object:
    以下表格显示了XML和相应的JSON对象之间的比较：'
- en: '| **XML** | **JSON** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **XML** | **JSON** |'
- en: '| `<person>` `   <firstName>John</firstName>`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '| `<person>` `   <firstName>John</firstName>`人'
- en: '`   <lastName>Smith</lastName>`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <lastName>Smith</lastName>` <姓>史密斯</姓>'
- en: '`   <age>25</age>`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <age>25</age>` <年龄>25</年龄>'
- en: '`   <address>`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <address>` <地址>'
- en: '`     <streetAddress>21 2nd`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <streetAddress>21 2nd` <街道地址>21 2nd'
- en: '`     Street</streetAddress>`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`     Street</streetAddress>` 街道</streetAddress>'
- en: '`     <city>New York</city>`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <city>New York</city>` <城市>纽约</城市>'
- en: '`     <state>NY</state>`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <state>NY</state>` <州>纽约</州>'
- en: '`     <postalCode>10021</postalCode>`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <postalCode>10021</postalCode>` <postalCode>10021</postalCode>'
- en: '`   </address>`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`   </address>` </地址>'
- en: '`   <phoneNumber>`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <phoneNumber>` <电话号码>'
- en: '`     <type>home</type>`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <type>home</type>` <类型>家庭</类型>'
- en: '`     <number>212 555-1234</number>`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <number>212 555-1234</number>` <号码>212 555-1234</号码>'
- en: '`   </phoneNumber>`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`   </phoneNumber>` </电话号码>'
- en: '`   <phoneNumber>`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <phoneNumber>` <电话号码>'
- en: '`     <type>fax</type>`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <type>fax</type>` <类型>传真</类型>'
- en: '`     <number>646 555-4567</number>`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`     <number>646 555-4567</number>` <号码>646 555-4567</号码>'
- en: '`   </phoneNumber>`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`   </phoneNumber>` </电话号码>'
- en: '`   <gender>`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`   <gender>` <性别>'
- en: '`     <type>male</type>`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`<type>male</type>`男性'
- en: '`   </gender>`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`   </gender>` </性别>'
- en: '`</person>` | `{` `   "firstName": "John",`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`</person>` | `{` `   "firstName": "John",` </人> | `{` `   "firstName": "John",'
- en: '`   "lastName": "Smith",`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`   "lastName": "Smith",` "姓"："史密斯"'
- en: '`   "age": 25,`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`   "age": 25,` "年龄"：25，'
- en: '`   "address": {`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`   "address": {` "地址"：{'
- en: '`     "streetAddress": "21 2nd'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "streetAddress": "21 2nd` "街道地址"："21 2nd'
- en: Street",`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Street",` 街道",
- en: '`     "city": "New York",`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "city": "New York",` "城市"："纽约"'
- en: '`     "state": "NY",`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "state": "NY",` "州"："纽约"'
- en: '`     "postalCode": "10021"`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "postalCode": "10021"` "邮政编码"："10021"'
- en: '` },`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '` },` },'
- en: '` "phoneNumber": [`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '` "phoneNumber": [` "电话号码"：['
- en: '`   {`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`   {` {'
- en: '`     "type": "home",`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "type": "home",` "类型"："家庭"'
- en: '`     "number": "212 555-1234"`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "number": "212 555-1234"` "号码"："212 555-1234"'
- en: '`   },`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`   },` },'
- en: '`   {`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`   {` {'
- en: '`     "type": "fax",`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "type": "fax",` "类型"："传真"'
- en: '`     "number": "646 555-4567"`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "number": "646 555-4567"` "号码"："646 555-4567"'
- en: '`   }`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`   }` }'
- en: '`   ],`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`   ],` ],'
- en: '`  "gender": {`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`  "gender": {` "性别"：{'
- en: '`     "type": "male"`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`     "type": "male"` "类型"："男性"'
- en: '`   }`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`   }` }'
- en: '`}` |'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: 'The JSON format contains following data types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'The JSON format contains following data types: JSON格式包含以下数据类型：'
- en: String
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String
- en: Number
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Number
- en: Object (JSON object)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Object (JSON object) 对象（JSON对象）
- en: Array
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Array 数组
- en: Boolean
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boolean
- en: Let us inspect a JSON object, to see how preceding data types are represented
    in the real world.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Let us inspect a JSON object, to see how preceding data types are represented
    in the real world. 让我们检查一个JSON对象，看看前面的数据类型是如何在现实世界中表示的。
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The mappings are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'The mappings are: 映射如下：'
- en: '`name`: The value is string type (`"john"`)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: The value is string type (`"john"`) 名字：值是字符串类型（"john"）'
- en: '`age`: The value is number (`35`)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`: The value is number (`35`) 年龄：值是数字（35）'
- en: '`spouse`: This is a JSON object'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spouse`: This is a JSON object 配偶：这是一个JSON对象'
- en: '`siblings`: This is an array'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`siblings`: This is an array 兄弟姐妹：这是一个数组'
- en: '`employed`: This is a Boolean (`true`)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`employed`: This is a Boolean (`true`) 就业：这是一个布尔值（`true`）'
- en: 'Now that we have a better understanding of JSON and its core aspects, we will
    write a simple program that demonstrates usage of the JSON API, available as part
    of the C++ REST SDK:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now that we have a better understanding of JSON and its core aspects, we will
    write a simple program that demonstrates usage of the JSON API, available as part
    of the C++ REST SDK: 现在我们对JSON及其核心方面有了更好的理解，我们将编写一个简单的程序，演示作为C++ REST SDK的一部分可用的JSON
    API的用法：'
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `JSonToObject` static method converts a JSON object to the `EMPLOYEE_INFO`
    structure. `json::at` returns a reference to `json::value` based on the string
    that we used to index it. The resultant `json::value` reference is used to invoke
    the type-specific conversion methods, such as `as_string`, `as_integer`, and `as_double`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `JSonToObject` static method converts a JSON object to the `EMPLOYEE_INFO`
    structure. `json::at` returns a reference to `json::value` based on the string
    that we used to index it. The resultant `json::value` reference is used to invoke
    the type-specific conversion methods, such as `as_string`, `as_integer`, and `as_double`:
    `JSonToObject`静态方法将JSON对象转换为`EMPLOYEE_INFO`结构。`json::at`根据我们用于索引的字符串返回对`json::value`的引用。结果`json::value`引用用于调用特定类型的转换方法，例如`as_string`，`as_integer`和`as_double`：'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ObjectToJson` is an instance method of `EMPLOYEE_STRUCT`, which helps to produce
    JSON output from the instance data. Here, we use conversion methods to transfer
    instance data to `json::value`. Next, we will focus on how we can create `json::object`
    from scratch:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectToJson` is an instance method of `EMPLOYEE_STRUCT`, which helps to produce
    JSON output from the instance data. Here, we use conversion methods to transfer
    instance data to `json::value`. Next, we will focus on how we can create `json::object`
    from scratch: `ObjectToJson`是`EMPLOYEE_STRUCT`的一个实例方法，它帮助从实例数据生成JSON输出。在这里，我们使用转换方法将实例数据转移到`json::value`。接下来，我们将专注于如何从头开始创建`json::object`：'
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create an `EMPLOYEE_INFO` struct and assign some values into the fields.
    We then invoke `EMPLOYEE_INFO::ObjectToJSon()` to create a `json::value` object.
    We call the `serialize()` method to generate the JSON textual output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'We create an `EMPLOYEE_INFO` struct and assign some values into the fields.
    We then invoke `EMPLOYEE_INFO::ObjectToJSon()` to create a `json::value` object.
    We call the `serialize()` method to generate the JSON textual output: 我们创建一个`EMPLOYEE_INFO`结构并将一些值分配到字段中。然后我们调用`EMPLOYEE_INFO::ObjectToJSon()`来创建一个`json::value`对象。我们调用`serialize()`方法来生成JSON文本输出：'
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous code snippets demonstrate the use to parse textual strings to
    produce `json::value` objects. We invoked the `serialize` method to print the
    JSON string to the console:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'The previous code snippets demonstrate the use to parse textual strings to
    produce `json::value` objects. We invoked the `serialize` method to print the
    JSON string to the console: 前面的代码片段演示了解析文本字符串以生成`json::value`对象的用法。我们调用`serialize`方法将JSON字符串打印到控制台：'
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The C++ REST SDK-based REST server
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The C++ REST SDK-based REST server 基于C++ REST SDK的REST服务器
- en: In this section, we have leveraged code from Marius Bancila's excellent article
    about the C++ REST SDK. In fact, the key/value database code is borrowed from
    his implementation. The authors are thankful to him for the excellent article,
    available at [https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/](https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: In this section, we have leveraged code from Marius Bancila's excellent article
    about the C++ REST SDK. In fact, the key/value database code is borrowed from
    his implementation. The authors are thankful to him for the excellent article,
    available at [https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/](https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/).
    在本节中，我们利用了Marius Bancila关于C++ REST SDK的优秀文章中的代码。实际上，键/值数据库代码是从他的实现中借用的。作者对他提供的优秀文章表示感谢，该文章可在[https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/](https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/)上找到。
- en: 'Let''s write a micro-service application that puts everything together we have
    learned so far in the context of Microsoft C++ REST SDK. We will consume REST
    services by leveraging the RxCurl library written by Kirk Shoop, as part of his
    Twitter analysis application. We have added support to the DELETE and PUT verbs,
    as the original implementation contained only support for GET and POST verbs.
    The REST service implemented here supports the following verbs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s write a micro-service application that puts everything together we have
    learned so far in the context of Microsoft C++ REST SDK. We will consume REST
    services by leveraging the RxCurl library written by Kirk Shoop, as part of his
    Twitter analysis application. We have added support to the DELETE and PUT verbs,
    as the original implementation contained only support for GET and POST verbs.
    The REST service implemented here supports the following verbs: 让我们编写一个微服务应用程序，将我们迄今为止在Microsoft
    C++ REST SDK的上下文中学到的一切整合起来。我们将通过利用Kirk Shoop编写的RxCurl库来消费REST服务，作为他的Twitter分析应用程序的一部分。我们已经添加了对DELETE和PUT动词的支持，因为原始实现只包含对GET和POST动词的支持。这里实现的REST服务支持以下动词：'
- en: '`GET`: Lists all the key/value pairs in the storage. The response will be in
    the `{ key:value,key:value}` format.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: Lists all the key/value pairs in the storage. The response will be in
    the `{ key:value,key:value}` format. 获取：列出存储中的所有键/值对。响应将以`{ key:value,key:value}`格式呈现。'
- en: '`POST`: Retrieves values corresponding to an array of keys. The request should
    be in the `[key1,...,keyn]` format. The response will be in the `{key:value,key:value....}`
    format.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：检索与一组键对应的值。请求应该是`[key1,...,keyn]`格式。响应将以`{key:value,key:value....}`格式返回。'
- en: '`PUT`: Inserts a collection of key/value pairs into the storage. The request
    should be in the `{key:value,key:value}` format.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：将一组键/值对插入存储中。请求应该是`{key:value,key:value}`格式。'
- en: '`DELETE`: Deletes an array of keys and their corresponding values from the
    storage. The request should be in the `[key,key]` format.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：从存储中删除一组键及其相应的值。请求应该是`[key,key]`格式。'
- en: 'Let''s have a look at the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `RequestWorker` is a global function, that takes `http_request` as a parameter
    along, with a lambda with specific signature. The lambda takes two parameters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestWorker`是一个全局函数，它以`http_request`作为参数，以及一个具有特定签名的lambda。lambda接受两个参数：'
- en: An input JSON object of the `json::value` type (a constant parameter)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json::value`类型的输入JSON对象（一个常量参数）'
- en: An output JSON object that contains result from the lambda call
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含来自lambda调用结果的输出JSON对象
- en: 'The JSON payload is extracted and passed to the `then` continuation. Once the
    data is retrieved, the handler lambda is invoked. Since the result is passed by
    reference, we can use the resultant JSON for generating the HTTP response. Now,
    we will create a simple key/value data store to simulate an industrial-strength
    key/value database:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSON有效载荷被提取并传递给`then`继续。一旦数据被检索，处理程序lambda被调用。由于结果是通过引用传递的，我们可以使用生成HTTP响应的结果JSON。现在，我们将创建一个简单的键/值数据存储来模拟一个工业强度的键/值数据库：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The key/value pairs are stored in an STL map for the sake of the ease of implementation.
    In the constructor, we initialize STL map with some records. We can use `PUT`
    and `POST` to add additional records, and `DELETE` for deleting records:  Let
    us dissect the source code of the function which handles GET requests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于实现，键/值对存储在STL映射中。在构造函数中，我们使用一些记录初始化STL映射。我们可以使用`PUT`和`POST`来添加额外的记录，使用`DELETE`来删除记录：让我们剖析处理GET请求的函数的源代码。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `GET_HANLDER` method will be invoked by the HTTP listener, when it encounters
    an HTTP `GET` verb as part of the request payload. After creating `json::value::object`,
    we stuff contents of the storage map into it. The resulting JSON object is returned
    to the HTTP client: Let us take a look at source code of the POST handler.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTP监听器遇到请求有效负载的一部分时，`GET_HANLDER`方法将被调用。创建`json::value::object`后，我们将存储映射的内容填充到其中。生成的JSON对象将返回给HTTP客户端：让我们看一下POST处理程序的源代码。
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `POST_HANDLER` expects an array of JSON values in the body of request,
    and cycles through each element to retrieve the data corresponding to keys provided.
    The resultant object stores the returned value. If some keys are not present in
    the key/value DB, a  literal string ("notond") is returned to indicate that the
    value is not found:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST_HANDLER`期望在请求主体中有一个JSON值数组，并循环遍历每个元素以检索相应键提供的数据。结果对象存储返回的值。如果一些键不在键/值DB中，将返回一个字面字符串("notond")来指示未找到该值：'
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `PUT_HANDLER` expects a list of key/value pairs in the JSON format. The
    collection of keys is iterated to do the lookup into the storage. If the key already
    exists in the storage, the value is updated, otherwise the key/value is inserted
    into the storage. A JSON object (result) is returned to indicate the action performed
    on each key (whether it was an insert or an update):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT_HANDLER`期望以JSON格式的键/值对列表。对键的集合进行迭代以在存储中查找。如果键已经存在于存储中，则更新值，否则将键/值插入存储中。返回一个JSON对象（结果）以指示对每个键执行的操作（是插入还是更新）。'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `DEL_HANDLER` expects an array of keys as the input, and it cycles through
    the array to retrieve the data. If the key is already present in the storage,
    keys are added to a delete list (- an STL set). A JSON object (result) is populated
    with the kind of action taken on each key. The resultant object will be returned
    to the client:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEL_HANDLER`期望一个键数组作为输入，并循环遍历数组以检索数据。如果键已经存在于存储中，键将被添加到删除列表（-一个STL集合）。一个JSON对象（结果）将被填充以指示对每个键执行的操作。结果对象将返回给客户端：'
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have a functional simulated key/value database `engine`, we will
    use the functionality of the database to the outside world as a REST service endpoint
    with `GET`, `POST`, `PUT`, and `DELETE` commands. The HTTP handlers will just
    delegate the call to the `HttpValueDBEngine` instance. The code is very similar
    to the code that we wrote for the `SimpleServer` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个功能模拟的键/值数据库`engine`，我们将使用数据库的功能作为REST服务端点与`GET`、`POST`、`PUT`和`DELETE`命令对外部世界提供服务。HTTP处理程序只是将调用委托给`HttpValueDBEngine`实例。这段代码与我们为`SimpleServer`类编写的代码非常相似：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The above code binds HTTP verbs to the corresponding handlers. The bodies of
    the handlers are similar in character, as the handlers are just delegating the
    HTTPcall to the key/value engine:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将HTTP动词绑定到相应的处理程序。处理程序的主体在性质上是相似的，因为处理程序只是将HTTP调用委托给键/值引擎：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code for the HTTP controller is not different from `SimpleServer` ,which
    we wrote earlier in the chapter. We provided the listing here for the sake of
    completeness. With this, we have learned how to expose a REST service endpoint
    to the outside world, using the C++ REST SDK.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP控制器的代码与我们在本章前面编写的`SimpleServer`没有区别。我们在这里提供列表是为了完整起见。通过这样，我们学会了如何使用C++ REST
    SDK向外部世界公开REST服务端点。
- en: We have already discussed how we can expose a REST endpoint and how to write
    handlers for the various HTTP verbs. In a micro-services architecture style, we
    will have lot of REST endpoints deployed independently. The process of breaking
    a coarse-grained service into a micro-service is an art that is highly dependent
    upon context. The micro-services are exposed to outside world, sometimes through
    aggregation services.  An aggregation service will make request to multiple end
    points and the results from different endpoints will be aggregated, before responding
    to Its client. The aggregation services are a candidate for writing reactive client
    logic for accessing the REST micro-services. Since network calls are asynchronous,
    the reactive programming model is natural here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何公开REST端点以及如何为各种HTTP动词编写处理程序。在微服务架构风格中，我们将独立部署许多REST端点。将粗粒度服务拆分为微服务的过程是高度依赖于上下文的艺术。微服务有时通过聚合服务向外部世界公开。聚合服务将向多个端点发出请求，并在响应其客户端之前聚合来自不同端点的结果。聚合服务是编写用于访问REST微服务的反应式客户端逻辑的候选者。由于网络调用是异步的，反应式编程模型在这里是自然的。
- en: Invoking REST services using the RxCurl library
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxCurl库调用REST服务
- en: 'The `RxCurl` library, written by Kirk Shoop, originally supported  `GET` and
    `POST` verbs. The Twitter analysis app only warrants that. The authors of the book
    have added support for the `PUT` and `DELETE` verbs.  You can refer to the source
    of `rxcurl.h` ,to  see necessary changes made to support these additional verbs,
    in the Github repository: Let us see how we can use the modified library to make
    calls to the REST server, we wrote above.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由Kirk Shoop编写的`RxCurl`库最初支持`GET`和`POST`动词。Twitter分析应用程序只支持这两个。本书的作者已经为`PUT`和`DELETE`动词添加了支持。您可以参考`rxcurl.h`的源代码，查看为支持这些额外动词所做的必要更改，在Github存储库中：让我们看看如何使用修改后的库来调用上面我们编写的REST服务器。
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the `factory` object, we can create request object by calling the `create`
    method. The `create` method expects:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`factory`对象，我们可以通过调用`create`方法创建请求对象。`create`方法期望：
- en: The URL endpoint
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL端点
- en: The HTTP method
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法
- en: HTTP headers
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头
- en: 'The body of HTTP request:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求的主体：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The above code creates a `request` object by composing creation of the HTTP
    request and a function to map from `http_response` to the HTTP body. There is
    an option to return chunks of data.  We are not using it here, as we expect only
    small amount of data as response.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过组合创建HTTP请求和从`http_response`映射到HTTP主体的函数来创建`request`对象。有一个选项可以返回数据块。我们这里没有使用它，因为我们只期望响应的数据量很小。
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The above code makes a blocking call to the  `observable` we created earlier.
    The body of the `subscribe` method''s `on_next` function concatenates the content
    to form another Observable. In real life, we can make this call in an asynchronous
    manner as well. That involves a little more programming effort. Moreover, the
    code listing won''t fit in the available page budget:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对我们之前创建的`observable`进行了阻塞调用。`subscribe`方法的主体的`on_next`函数将内容连接起来形成另一个Observable。在现实生活中，我们也可以以异步方式进行这种调用。这需要更多的编程工作。此外，代码清单不适合可用的页面预算：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `main` method demonstrates how we can invoke the `HttpCall` function created
    by us. The code has been provided to show how you can leverage the RxCurl library.
    We can use the library to issue multiple requests asynchronously and wait for
    their completion as well. The reader can tweak the code to support such a feature.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法演示了我们如何调用我们创建的`HttpCall`函数。提供了代码，以展示如何利用RxCurl库。我们可以使用该库异步发出多个请求，并等待它们的完成。读者可以调整代码以支持这样的功能。'
- en: A word about the Reactive micro-services architecture
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于反应式微服务架构的一点说明
- en: 'We have learned how to write a microservices controller using the C++ REST
    SDK. Maybe we can say that the server we just implemented can be a microservice
    instance. In a real-life microservices architecture scenario, there will be multiple
    services hosted in different boxes (Docker containers or Virtual machines), and
    microservices controller will access these independently deployed services to
    cater to the client. The microservice controller will aggregate output from different
    services to send as a response to the client. A basic architecture for a microservice
    application is shown in the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用C++ REST SDK编写微服务控制器。也许我们可以说，我们刚刚实现的服务器可以是一个微服务实例。在现实生活中的微服务架构场景中，将在不同的盒子（Docker容器或虚拟机）中托管多个服务，并且微服务控制器将访问这些独立部署的服务以满足客户端的需求。微服务控制器将从不同服务中聚合输出，以作为响应发送给客户端。微服务应用程序的基本架构如下图所示：
- en: '![](img/6addcc36-9af8-4635-9f66-3691c9ebbc2f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6addcc36-9af8-4635-9f66-3691c9ebbc2f.png)'
- en: In the previous diagram, the REST (HTTP) client makes an HTTP call to the microservices
    controller, which wraps `http_listener` object. The controller invokes three microservices
    to retrieve data, and the resultant data will be assembled or merged to provide
    a response to the REST client. The endpoints can be deployed in a container or
    in different containers, using technologies such as Docker.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，REST（HTTP）客户端向微服务控制器发出HTTP调用，该控制器包装了`http_listener`对象。控制器调用三个微服务来检索数据，并将结果数据组装或合并以向REST客户端提供响应。端点可以使用Docker等技术在容器中或在不同的容器中部署。
- en: 'According to Martin Fowler:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Martin Fowler：
- en: '"*The term "Microservice Architecture" has sprung up over the last few years
    to describe a particular way of designing software applications as suites of independently
    deployable services. While there is no precise definition of this architectural
    style, there are certain common characteristics around organization around business
    capability, automated deployment, intelligence in the endpoints, and decentralized
    control of languages and data*."'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “*“微服务架构”这个术语在过去几年中出现，用来描述设计软件应用程序的一种特定方式，即独立部署的服务套件。虽然对这种架构风格没有明确的定义，但围绕业务能力的组织、自动化部署、端点的智能和语言和数据的分散控制等方面有一些共同的特征*。”
- en: The topic of microservices architecture is a subject in its own right, and the
    topic warrants a book of its own. What we have covered here is how we can leverage
    the C++ programming language to write web applications in this style. The description
    given here is meant to point readers to the right information. The reactive programming
    model is suitable for aggregating information from different service endpoints
    and presenting it uniformly to the client. The aggregation of services is the
    key concern, which ought to be further researched by the readers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的主题本身就是一个独立的课题，值得一本专门的书来探讨。我们在这里所涵盖的是如何利用C++编程语言来以这种风格编写Web应用程序。这里给出的描述旨在指引读者找到正确的信息。响应式编程模型适合从不同的服务端点聚合信息并统一呈现给客户端。服务的聚合是关键问题，读者应进一步研究。
- en: 'When we talk about microservices architecture, we need to understand following
    topics:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论微服务架构时，我们需要了解以下主题：
- en: Fine-grained services
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细粒度服务
- en: Polyglot persistence
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言持久性
- en: Independent deployment
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立部署
- en: Service orchestration and Service choreography
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务编排和服务编舞
- en: Reactive web service calls
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式Web服务调用
- en: We will discuss them in detail in following sections.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细讨论它们。
- en: Fine-grained services
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细粒度服务
- en: Traditional SOA- and REST-based services are mostly coarse-grained services
    and are written with a mindset in which reduction of network roundtrip is the
    core concern. To reduce the network roundtrip, developers often created payload
    formats that were composite (multiple data elements packed together ) in nature.
    So, an endpoint or a URI was used to handle more than one concern, and violated
    the principle of Separation Of Concerns. The microservices architecture expects
    services to perform a single responsibility, and payload formats are tailored
    for that. In this way, the service becomes granular.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的SOA和基于REST的服务大多是粗粒度的服务，并且是以减少网络往返为核心关注点而编写的。为了减少网络往返，开发人员经常创建了复合（多个数据元素打包在一起）的有效负载格式。因此，一个端点或URI被用于处理多个关注点，并违反了关注点分离的原则。微服务架构期望服务执行单一职责，并且有效负载格式是为此量身定制的。这样，服务变得更加细粒度。
- en: Polyglot persistence
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言持久性
- en: Polyglot persistence is a term used to denote the use of multiple storage technologies
    while persisting data. The term come from the term **polyglot programming**, where
    the choice of programming language is determined by the context. In the case of
    polyglot programming, we mix different programming languages. The authors of this
    book have come across systems that use Java for the application server code, Scala
    for stream processing,  C++ for storage-related concerns, C# for writing the web
    layer, and, of course, TypeScript/JavaScript for the client-side programming.
    In the case of polyglot persistence, we have the choice of using RDBMS, key/value
    stores, document databases, graph databases, columnar databases, and even time
    series databases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言持久性是一个术语，用来表示在持久化数据时使用多种存储技术。这个术语来自于“多语言编程”的术语，其中编程语言的选择取决于上下文。在多语言编程的情况下，我们混合使用不同的编程语言。本书的作者们曾遇到过使用Java编写应用服务器代码、Scala进行流处理、C++处理存储相关问题、C#编写Web层，当然还有TypeScript/JavaScript用于客户端编程的系统。在多语言持久性的情况下，我们可以选择使用关系型数据库、键值存储、文档数据库、图数据库、列数据库，甚至时间序列数据库。
- en: An e-commerce portal is a classic example of a system where polyglot persistence
    can be really handy. Such a platform will deal with many types of data (for example,
    shopping cart, inventory, and completed orders). Instead of trying to store all
    of this data in one database, we might use RDBMS (to record transactions), key/value
    DBs (caching and lookup), a document database for storing logs, and so on. *Choose
    the right persistence model for your concern and context* is the main motto here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务门户是多语言持久性可以真正派上用场的经典例子。这样的平台将处理许多类型的数据（例如，购物车、库存和已完成的订单）。我们可以选择使用关系型数据库（记录交易）、键值数据库（缓存和查找）、文档数据库（存储日志）等，而不是试图将所有这些数据存储在一个数据库中。在这里，“为您的关注点和上下文选择正确的持久性模型”是主要的座右铭。
- en: Independent deployment
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立部署
- en: The biggest difference between microservices architecture and traditional SOA
    is in the area of deployment. With the evolution of container technologies, we
    can deploy services independently and in isolation, very easily. The DevOps movement
    helped a lot in popularizing the independent deployment model of services and
    applications. We can now automate the process of provisioning a VM and associated
    containers with CPU, memory, storage, additional disks, virtual networks, firewalls,
    load balancing, auto scaling  and so on, in deployment policies attached to a
    cloud service, such as AWS,Azure  or Google Cloud. Policies help you deploy microservices
    in an automatic manner, using automation scripts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构和传统SOA之间最大的区别在于部署领域。随着容器技术的发展，我们可以非常容易地独立和隔离地部署服务。DevOps运动在推广服务和应用程序的独立部署模型方面起到了很大的帮助。我们现在可以自动化虚拟机和相关容器的配置过程，包括CPU、内存、存储、附加磁盘、虚拟网络、防火墙、负载均衡、自动扩展等，将其附加到AWS、Azure或Google
    Cloud等云服务的部署策略中。策略可以帮助您以自动化脚本的方式自动部署微服务。
- en: While developing applications using the microservices architectural style, the
    notion of container technology will pop up again and again. An associated movement,
    called DevOps, is brought into the realm of discussion. Covering DevOps and containerization
    (and cluster management) in the context of independent deployment is beyond the
    scope of this book. You can search for Docker, Kubernetes, and "Infrastructure
    as code", to gain more insight into these technologies.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务架构风格开发应用程序时，容器技术的概念会一再出现。一个相关的运动，称为 DevOps，被引入到讨论的范围之内。在独立部署的情况下，涵盖 DevOps
    和容器化（以及集群管理）超出了本书的范围。您可以搜索 Docker、Kubernetes 和“基础设施即代码”，以更深入地了解这些技术。
- en: Service orchestration and choreography
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务编排和编舞
- en: Let's start with service orchestration. You put together several services by
    a fixed logic. This logic is described in a single place. But we might deploy
    multiple instances of same services, for availability. An aggregator service will
    call these services independently and aggregate the data for the downstream systems.
    On the other hand, in service choreography, the decision logic is distributed
    with no centralized point. A call to service will trigger multiple calls between
    services, before data reaches the downstream system. Service choreography requires
    more effort than implementing orchestration. You can read more about service orchestration
    and choreography by searching the web using your favorite search engine.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务编排开始。您可以通过固定逻辑将多个服务组合在一起。这个逻辑在一个地方描述。但我们可能部署多个相同服务的实例，以确保可用性。一个聚合器服务将独立调用这些服务并为下游系统聚合数据。另一方面，在服务编舞中，决策逻辑是分布式的，没有集中的点。对服务的调用将在数据到达下游系统之前触发多次服务之间的调用。服务编舞比实现编排需要更多的工作。您可以通过使用您喜欢的搜索引擎在网络上阅读更多关于服务编排和编舞的信息。
- en: Reactive web service call
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式网络服务调用
- en: The processing of web requests is nicely mapped to the reactive programming
    model. In the case of applications with responsive UI, we typically make a call
    to the server once. An aggregator service running on the server will spawn a series
    of requests asynchronously. The resulting responses are aggregated to give a response
    to the UI layer. The modified `RxCurl` can be used as a mechanism to invoke multiple
    services in projects which use C++ programming language.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Web 请求的处理很好地映射到了响应式编程模型。在具有响应式 UI 的应用程序中，我们通常只需向服务器发出一次调用。在服务器上运行的聚合器服务将异步生成一系列请求。生成的响应被聚合以向
    UI 层提供响应。修改后的 `RxCurl` 可以作为一种机制，用于在使用 C++ 编程语言的项目中调用多个服务。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how the Rx programming model can be used to write
    reactive microservices using C++. As part of the process, we introduced you to
    the Microsoft C++ REST SDK and its programming model. The C++ REST SDK follows
    an asynchronous programming model based on a technique called task continuation
    style, while writing client-side code. To write REST clients, we leveraged Kirk
    Shoop's `RxCurl` library, with some modifications to support the `PUT` and `DELETE`
    verbs. Finally, we wrote a REST server and consumed it in a reactive manner.In
    the next chapter, we will learn how to handle errors and exceptions using constructs
    available in the RxCpp library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用 Rx 编程模型来使用 C++ 编写响应式微服务。作为这个过程的一部分，我们向您介绍了微软的 C++ REST SDK 及其编程模型。C++
    REST SDK 遵循一种基于任务继续样式的异步编程模型，用于编写客户端代码。为了编写 REST 客户端，我们利用了 Kirk Shoop 的 `RxCurl`
    库，并对其进行了一些修改以支持 `PUT` 和 `DELETE` 动词。最后，我们以一种响应式的方式编写了一个 REST 服务器并对其进行了消费。在下一章中，我们将学习如何使用
    RxCpp 库中可用的构造来处理错误和异常。
