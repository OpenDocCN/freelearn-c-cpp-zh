- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: IDE Support and Clangd
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE支持和Clangd
- en: This chapter is about the **Language Server Protocol (LSP)** and how you can
    utilize it to enhance your **Integrated Development Environment** **(IDE)**. Our
    primary IDE of choice is **Visual Studio Code (VS Code)**. LLVM has its own implementation
    of LSP known as **Clangd**. We will begin by describing LSP and exploring how
    Clangd leverages it to extend the capabilities provided by the IDE. Finally, we
    will conclude with examples of how various Clang tools, such as Clang-Tidy and
    Clang-Format, can be seamlessly integrated into the IDE through Clangd.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍**语言服务器协议（LSP**）以及如何利用它来增强你的**集成开发环境（IDE**）。我们首选的IDE是**Visual Studio Code
    (VS Code**)。LLVM有自己实现的LSP，称为**Clangd**。我们将首先描述LSP，并探讨Clangd如何利用它来扩展IDE提供的能力。最后，我们将通过示例说明如何通过各种Clang工具，如Clang-Tidy和Clang-Format，通过Clangd无缝集成到IDE中。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is Language Server Protocol (LSP) and how does it improve an IDE’s capabilities?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是语言服务器协议（LSP）以及它是如何提高IDE能力的？
- en: How VS Code and Clangd (the Clang LSP server) can be installed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装VS Code和Clangd（Clang LSP服务器）
- en: How LSP is used to connect VS Code and Clangd, through an example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例说明如何使用LSP连接VS Code和Clangd
- en: How Clangd is integrated with other Clang tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clangd如何与其他Clang工具集成
- en: Why performance matters for Clangd and what optimizations were made to make
    Clangd fast
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么性能对Clangd很重要以及为了使Clangd快速所进行的优化
- en: 8.1 Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 技术要求
- en: 'The source code for this chapter is located in the `chapter8` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书GitHub仓库的`chapter8`文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8)
- en: 8.2 Language Server Protocol
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 语言服务器协议
- en: An IDE is a software application or platform that provides a comprehensive set
    of tools and features to assist developers in creating, editing, debugging, and
    managing software code. An IDE typically includes a code editor with syntax highlighting,
    debugging capabilities, project management features, version control integration,
    and, often, plugins or extensions to support various programming languages and
    frameworks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是一种软件应用程序或平台，它提供了一套全面的工具和功能，以帮助开发者创建、编辑、调试和管理软件代码。IDE通常包括具有语法高亮的代码编辑器、调试功能、项目管理功能、版本控制集成，以及通常支持各种编程语言和框架的插件或扩展。
- en: Popular examples of IDEs are Visual Studio/VS Code, IntelliJ IDEA, Emacs, and
    Vim. These tools are designed to streamline the development process, making it
    easier for developers to write, test, and maintain their code efficiently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流行IDE的例子有Visual Studio/VS Code、IntelliJ IDEA、Emacs和Vim。这些工具旨在简化开发过程，使开发者能够更高效地编写、测试和维护代码。
- en: A typical IDE supports multiple languages, and integrating each language can
    be a challenging task. Each language requires specific support, which can be visualized
    in [Figure 8.1](#Figure8.1). It’s worth noting that there are many similarities
    in the development process of different programming languages. For example, the
    languages shown in [Figure 8.1](#Figure8.1) have a code navigation feature that
    allows developers to quickly locate and view the definition of a symbol or identifier
    within their code base.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的IDE支持多种语言，集成每种语言可能是一项具有挑战性的任务。每种语言都需要特定的支持，这可以在[图8.1](#Figure8.1)中可视化。值得注意的是，不同编程语言的开发过程有许多相似之处。例如，[图8.1](#Figure8.1)中显示的语言具有代码导航功能，允许开发者快速定位和查看其代码库中符号或标识符的定义。
- en: '![Figure 8.1: Programming languages integration in IDEs ](img/Figure8.1_B19722.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：IDE中的编程语言集成](img/Figure8.1_B19722.png)'
- en: '**Figure 8.1**: Programming languages integration in IDEs'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.1**：IDE中的编程语言集成'
- en: 'The feature will be referred to as **go-to definition** in this chapter. Such
    similarities suggest a way to simplify the relationships shown in [Figure 8.1](#Figure8.1)
    by introducing an intermediate level called the **Language Server Protocol**,
    or **LSP**, as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将此功能称为**跳转到定义**。这些相似之处表明，通过引入一个称为**语言服务器协议（LSP**）的中间层，可以简化[图8.1](#Figure8.1)中显示的关系。如上所示：
- en: '![Figure 8.2: Programming languages integration in IDEs using LSP ](img/Figure8.2_B19722.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：使用LSP在IDE中集成编程语言](img/Figure8.2_B19722.png)'
- en: '**Figure 8.2**: Programming languages integration in IDEs using LSP'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.2**: 在IDE中使用LSP进行编程语言集成'
- en: The **LSP** project was initiated by Microsoft in 2015 as part of its efforts
    to improve VS Code, a lightweight, open source code editor. Microsoft recognized
    the need for a standardized way to provide rich language services across different
    programming languages within VS Code and other code editors.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**LSP**项目由微软于2015年启动，作为其改进VS Code（一个轻量级、开源代码编辑器）努力的一部分。微软认识到在VS Code和其他代码编辑器中为不同编程语言提供丰富语言服务需要一个标准化的方式。'
- en: LSP quickly gained popularity and adoption in the developer community. Many
    code editors and IDEs, including VS Code, Emacs, and Eclipse, began implementing
    support for LSP.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LSP在开发者社区中迅速获得了流行和采用。包括VS Code、Emacs和Eclipse在内的许多代码编辑器和IDE开始实现LSP的支持。
- en: Language server implementations emerged for various programming languages. These
    language servers, developed by both Microsoft and the open source community, offered
    language-specific intelligence and services, making it easier to integrate language
    features into different editors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为各种编程语言出现了语言服务器实现。这些语言服务器由微软和开源社区共同开发，提供了特定于语言的知识和服务，使得将语言功能集成到不同的编辑器中变得更加容易。
- en: In this chapter, we will explore **Clangd**, a language server that is part
    of clang-tools-extra. Clangd leverages the Clang compiler frontend and offers
    a comprehensive suite of code analysis and language support features. Clangd assists
    developers with intelligent code completion, semantic analysis, and real-time
    diagnostics, helping them to write code more efficiently and catch errors early
    in the development process. We will delve into Clangd in detail here, starting
    with a real example of the interaction between the IDE (VS Code) and Clangd. We
    will begin with the environment setup, including the Clangd build and VS Code
    setup.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**Clangd**，它是clang-tools-extra的一部分的语言服务器。Clangd利用Clang编译器前端，提供了一套全面的代码分析和语言支持功能。Clangd通过智能代码补全、语义分析和实时诊断帮助开发者更高效地编写代码，并在开发过程中早期捕捉错误。我们将在此处详细探讨Clangd，从IDE（VS
    Code）和Clangd之间的交互的真实示例开始。我们将从环境设置开始，包括Clangd构建和VS Code设置。
- en: 8.3 Environment setup
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 环境设置
- en: We will begin our environment setup by building Clangd. Then, we will install
    VS Code, set up the Clangd extension, and configure Clangd within it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的环境设置，首先构建Clangd。然后，我们将安装VS Code，设置Clangd扩展，并在其中配置Clangd。
- en: 8.3.1 Clangd build
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 Clangd构建
- en: 'It’s worth building Clangd in release mode, as we did for LLDB in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,*
    *The LLVM debugger, its build, and usage*. This is because performance is crucial
    in IDEs. For instance, Clangd requires building an AST to provide code navigation
    functionality. If a user modifies a document, the document should be rebuilt,
    and the navigation functionality will not be available until the rebuild process
    is completed. This can result in delays in IDE responses. To prevent IDE slowness
    in responses, we should ensure that Clangd is built with all the required optimizations.
    You can use the following project configuration command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们应该以发布模式构建Clangd，就像我们在[*第1.3.3节*](B19722_01.xhtml#x1-290003)中为LLDB所做的那样，即*LLVM调试器、其构建和使用*。这是因为性能在IDE中至关重要。例如，Clangd需要构建AST以提供代码导航功能。如果用户修改了文档，则应重新构建文档，并且导航功能将不会在重新构建过程完成之前可用。这可能导致IDE响应延迟。为了防止IDE响应缓慢，我们应该确保Clangd以所有必需的优化构建。您可以使用以下项目配置命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 8.3**: Release configuration for Clangd build'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.3**: Clangd构建的发布配置'
- en: 'The command has to be run from the `release` folder that we created in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,
    The LLVM debugger, its build, and usage*, as shown in [Figure 1.8](B19722_01.xhtml#x1-29011r8).
    As you can see, we have enabled two projects in [Figure 8.3](#x1-156003r3): `clang`
    and `clang-tools-extra` .'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令必须在我们在[*第1.3.3节*](B19722_01.xhtml#x1-290003)中创建的`release`文件夹中运行，即LLVM调试器、其构建和使用，如图[图1.8](B19722_01.xhtml#x1-29011r8)所示。正如您所看到的，我们在[图8.3](#x1-156003r3)中启用了两个项目：`clang`和`clang-tools-extra`。
- en: 'You can use the following command to build and install Clangd:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令构建和安装Clangd：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will utilize the maximum available threads on the system and install
    the binary into the folder specified in our CMake command in [Figure 8.3](#x1-156003r3),
    which is the `install` folder under the LLVM source tree.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将利用系统上可用的最大线程数，并将二进制文件安装到我们在[图8.3](#x1-156003r3)中指定的CMake命令的文件夹中，即LLVM源树下的`install`文件夹。
- en: After building the Clangd binary, our next step will include installing VS Code
    and configuring it to work with Clangd.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Clangd 二进制文件后，我们的下一步将包括安装 VS Code 并将其配置为与 Clangd 一起使用。
- en: 8.3.2 VS Code installation and setup
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 VS Code 安装和配置
- en: 'You can download and install VS Code from the VS Code website: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 VS Code 网站 [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    下载并安装 VS Code。
- en: 'The first step after running VS Code is to install the **Clangd** extension.
    An open source extension is available to work with Clangd via LSP. The extension’s
    source code can be found on GitHub: [https://github.com/clangd/vscode-clangd](https://github.com/clangd/vscode-clangd).
    However, we can easily install the latest version of the extension directly from
    within VS Code.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 VS Code 后的第一步是安装 **Clangd** 扩展。有一个开源扩展可以通过 LSP 与 Clangd 一起使用。该扩展的源代码可以在 GitHub
    上找到：[https://github.com/clangd/vscode-clangd](https://github.com/clangd/vscode-clangd)。然而，我们可以轻松地从
    VS Code 内部直接安装扩展的最新版本。
- en: To do this, press *Ctrl+Shift+X* (or ![The Apple Key](img/Mac_icon.png) *+Shift+X*
    for macOS) to open the extensions panel. Search for `Clangd` and click the **Install**
    button.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按 *Ctrl+Shift+X*（或在 macOS 上按 ![苹果键](img/Mac_icon.png) *+Shift+X*）以打开扩展面板。搜索
    `Clangd` 并单击 **安装** 按钮。
- en: '![Figure 8.4: Installing the Clangd extension ](img/file4.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：安装 Clangd 扩展](img/file4.png)'
- en: '**Figure 8.4**: Installing the Clangd extension'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.4**：安装 Clangd 扩展'
- en: After installing the extension, we need to set it up. The main step is to specify
    the path to the Clangd executable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展后，我们需要对其进行设置。主要步骤是指定 Clangd 可执行文件的路径。
- en: 'You can access this setting via the **File — Preferences — Settings** menu
    or by pressing *Ctrl + ,* (or ![The Apple Key](img/Mac_icon.png) *+,* for macOS),
    as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 **文件 — 首选项 — 设置** 菜单或按 *Ctrl + ,*（或在 macOS 上按 ![苹果键](img/Mac_icon.png)
    *+,*）访问此设置，如下面的截图所示：
- en: '![Figure 8.5: Setting up the Clangd extension ](img/file5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5：设置 Clangd 扩展](img/file5.png)'
- en: '**Figure 8.5**: Setting up the Clangd extension'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.5**：设置 Clangd 扩展'
- en: As shown in [Figure 8.5](#Figure8.5), we have configured the Clangd path to
    be `/home/ivanmurashko` `/clangbook/llvm-project/install/bin/clangd` . This path
    was used during the installation of the Clangd binary in [*Section** 8.3.1*](#x1-1560001)*,
    Clangd build*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 8.5](#Figure8.5) 所示，我们已将 Clangd 路径配置为 `/home/ivanmurashko` `/clangbook/llvm-project/install/bin/clangd`。此路径在
    [*第 8.3.1 节*](#x1-1560001) 中使用，即 Clangd 二进制文件的安装和构建。
- en: You can open your favorite C/C++ source file and try to navigate through it.
    For instance, you can search for a definition for a token, switch between a source
    and a header, and so on. In our next example, we will investigate how navigation,
    and especially go-to definition, works through LSP.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开您喜欢的 C/C++ 源文件并尝试在其中导航。例如，您可以搜索一个标记的定义，在源文件和头文件之间切换，等等。在我们的下一个示例中，我们将研究如何通过
    LSP 进行导航，特别是如何实现跳转到定义。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Our setup works only for simple projects that do not require special compilation
    flags. If your project requires special configuration to build, then you have
    to use a generated `compile``_commands.json` file that should be placed at the
    root of your project. This file should contain a **Compilation Database** (**CDB**)
    in JSON format, specifying compilation flags for each file in your project. For
    more information about the setup, please refer to [*Figure** 9.5*](B19722_09.xhtml#x1-1880003)*,
    Clangd* *Setup for Large Projects*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置仅适用于不需要特殊编译标志的简单项目。如果您的项目需要特殊配置才能构建，那么您必须使用生成的 `compile_commands.json`
    文件，该文件应放置在您的项目根目录下。此文件应包含一个 **编译数据库**（**CDB**），以 JSON 格式指定项目中每个文件的编译标志。有关设置的更多信息，请参阅
    [*图 9.5*](B19722_09.xhtml#x1-1880003) 中关于 Clangd 为大型项目设置的内容。
- en: With the required components installed, we are now ready for an LSP demo where
    we will emulate typical development activities in an IDE (open and modify a document,
    jump to a token definition, etc.) and explore how it’s represented via LSP.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所需的组件后，我们现在准备进行 LSP 演示，我们将模拟在 IDE 中典型的开发活动（打开和修改文档、跳转到标记定义等）并探索它是如何通过 LSP
    表示的。
- en: 8.4 LSP demo
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 LSP 演示
- en: In this brief LSP demo, we will demonstrate how Clangd opens a file and finds
    a symbol’s definition. Clangd features a comprehensive logging subsystem that
    offers valuable insights into its interaction with the IDE. We will use the log
    subsystem to obtain the necessary information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的LSP演示中，我们将展示Clangd如何打开文件并找到符号的定义。Clangd具有一个全面的日志子系统，它提供了关于其与IDE交互的宝贵见解。我们将使用日志子系统来获取必要的信息。
- en: 8.4.1 Demo description
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 演示描述
- en: 'In our example, we open a test file as shown in the following screenshot and
    retrieve the definition of the `doPrivateWork` token:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们打开一个测试文件，如图所示，并检索`doPrivateWork`标记的定义：
- en: '![Figure 8.6: Go-to definition and hover for the doPrivateWork token ](img/file6.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：跳转到doPrivateWork标记的定义并悬停](img/file6.png)'
- en: '**Figure 8.6**: Go-to definition and hover for the `doPrivateWork` token'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.6**：跳转到`doPrivateWork`标记的定义并悬停'
- en: VS Code communicates with Clangd via standard input/output, and we will use
    Clangd logs to capture the interaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code通过标准输入/输出与Clangd通信，我们将使用Clangd日志来捕获交互。
- en: 'This can be achieved by setting up a wrapper shell script instead of using
    the actual clangd binary in the VS Code settings:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在VS Code设置中设置包装器shell脚本而不是使用实际的clangd二进制文件来实现：
- en: '![Figure 8.7: Wrapper shell script setup in VS Code ](img/file7.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：在VS Code中设置包装器shell脚本](img/file7.png)'
- en: '**Figure 8.7**: Wrapper shell script setup in VS Code'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.7**：在VS Code中设置包装器shell脚本'
- en: 'We can use the following script, `clangd.sh` :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下脚本，`clangd.sh`：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Figure 8.8**: Wrapper shell script for clangd'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.8**：clangd的包装器shell脚本'
- en: 'In [Figure 8.8](#x1-159010r8), we use two log options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8.8](#x1-159010r8)中，我们使用了两个日志选项：
- en: The first one, `-log verbose` , activates verbose logging to ensure that actual
    LSP messages from and to Clangd will be logged.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项，`-log verbose`，激活详细日志记录以确保Clangd与IDE之间的实际LSP消息将被记录。
- en: The second option, `-pretty` , is used to provide nicely formatted JSON messages.
    We also redirect stderr output to the log file, `/tmp/clangd.log` , in our case.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个选项，`-pretty`，用于提供格式良好的JSON消息。在我们的例子中，我们还把stderr输出重定向到日志文件，`/tmp/clangd.log`。
- en: 'As a result, the file will contain logs from our example session. We can view
    these logs using the following command::'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该文件将包含我们示例会话的日志。我们可以使用以下命令查看这些日志：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the logs, we can find `"textDocument/definition"` that was sent by VS Code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，我们可以找到由VS Code发送的`"textDocument/definition"`：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 8.9**: The ”textDocument/definition” request sent by the IDE'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.9**：IDE发送的”textDocument/definition”请求'
- en: 'The request sent by the IDE is received and processed by Clangd. The corresponding
    log is recorded as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: IDE发送的请求被Clangd接收并处理。相应的日志记录如下：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 8.10**: Handling of the ”textDocument/definition” request in Clangd'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.10**：Clangd对”textDocument/definition”请求的处理'
- en: 'Finally, Clangd creates the response and sends it to the IDE. The corresponding
    log record shows that the reply was sent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Clangd创建响应并将其发送到IDE。相应的日志记录显示回复已发送：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Figure 8.11**: The ”textDocument/definition” reply from Clangd'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.11**：Clangd的”textDocument/definition”回复'
- en: The logs will be our primary tool to investigate LSP internals. Let’s dive into
    more complex examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 日志将成为我们调查LSP内部的主要工具。让我们深入研究更复杂的示例。
- en: 8.4.2 LSP session
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 LSP会话
- en: 'An LSP session consists of several requests to and responses from the Clangd
    server. It starts with an `"initialize"` request. Then, we open a document, and
    VS Code sends a `"textDocument/didOpen"` notification. After the request, Clangd
    will periodically respond with `"textDocument/publishDiagnostics"` notifications
    when the state of the opened file changes. For example, this occurs when compilation
    is finished and its ready to process navigation requests. Next, we initiate a
    go-to definition request for a token, and Clangd responds with the location information
    for the found definition. We also investigate how Clangd processes file modifications
    that are notified by the client via `"textDocument` `/didChange"` notifications.
    We finish our session with a `"textDocument/didClose"` request when we close the
    opened file. A diagram depicting the interaction is presented in the following
    figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 会话由对 Clangd 服务器的多个请求和响应组成。它从一个 `"initialize"` 请求开始。然后，我们打开一个文档，VS Code 发送一个
    `"textDocument/didOpen"` 通知。在请求之后，Clangd 将定期响应 `"textDocument/publishDiagnostics"`
    通知，当打开的文件状态发生变化时。例如，这发生在编译完成并且准备好处理导航请求时。接下来，我们发起一个针对标记的跳转到定义请求，Clangd 响应以找到的定义的位置信息。我们还研究了
    Clangd 如何处理客户端通过 `"textDocument/didChange"` 通知通知的文件修改。当我们关闭打开的文件时，我们通过 `"textDocument/didClose"`
    请求结束我们的会话。以下图展示了交互的示意图：
- en: '![Figure 8.12: LSP session example ](img/Figure8.12_B19722.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12: LSP 会话示例](img/Figure8.12_B19722.png)'
- en: '**Figure 8.12**: LSP session example'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.12**: LSP 会话示例'
- en: Let’s look at the example in detail. We will start with the `"initialize"` request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个例子。我们将从 `"initialize"` 请求开始。
- en: Initialization
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化
- en: 'To establish communication, the client (code editor or IDE) and the language
    server exchange JSON-RPC messages. The initialization process begins with the
    client sending an `"initialize"` request to the language server, specifying the
    capabilities it supports. The actual request sent by VS Code is quite large, and
    a simplified version, where some parts of the request are replaced with `"..."`
    , is shown as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立通信，客户端（代码编辑器或 IDE）和语言服务器交换 JSON-RPC 消息。初始化过程以客户端向语言服务器发送一个 `"initialize"`
    请求开始，指定它支持的功能。VS Code 实际发送的请求相当大，以下是一个简化版本，其中请求的一些部分被 `"..."` 替换：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Figure 8.13**: VS Code to Clangd (initialize request)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.13**: VS Code 到 Clangd（初始化请求）'
- en: In the request, the client (VS Code) tells the server (Clangd) what capabilities
    are supported on the client side; for example, at *Lines 10-13* in [Figure 8.13](#x1-161024r13),
    the client says that it supports the `"textDocument/definition"` request type
    that is used for go-to definition requests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求中，客户端（VS Code）告诉服务器（Clangd）客户端支持哪些功能；例如，在 [图 8.13](#x1-161024r13) 的 *第 10-13
    行*，客户端表示它支持用于跳转到定义请求的 `"textDocument/definition"` 请求类型。
- en: 'The language server replies to the request with a response that contains capabilities
    supported by the server:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务器以包含服务器支持的功能的响应来回复请求：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 8.14**: Clangd to VS Code (initialize reply)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.14**: Clangd 到 VS Code（初始化回复）'
- en: As we can see, the same `id` is used to connect the request with its reply.
    Clangd replied that it supports go-to definition requests as specified in *Line*
    *7* in [Figure 8.14](#x1-161042r14). Thus our client (VS Code) can send the navigation
    request to the server, which we will explore later in [*Figure** 8.19*](#x1-1630002)*,
    Go-to* *definition*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，相同的 `id` 用于将请求与其回复连接起来。Clangd 回复说它支持在 *第 7 行* [图 8.14](#x1-161042r14)
    中指定的跳转到定义请求。因此，我们的客户端（VS Code）可以向服务器发送导航请求，我们将在 [*图 8.19*](#x1-1630002)*，跳转到定义*
    中稍后探讨。
- en: 'VS Code acknowledges the initialization by sending an `"initialized"` notification:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 通过发送 `"initialized"` 通知来确认初始化：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Contrary to the `"initialize"` request, there is a notification, and it does
    not expect any response from the server. As a result, it does not have an `"id"`
    field. The `"initialized"` notification can be sent only once, and it should be
    received before any other requests or notifications are sent from the client side.
    After the initialization, we are ready to open a document and send the corresponding
    `"textDocument/didOpen"` notification.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `"initialize"` 请求相反，这里有一个通知，并且它不期望服务器有任何响应。因此，它没有 `"id"` 字段。`"initialized"`
    通知只能发送一次，并且它应该在客户端发送任何其他请求或通知之前接收。初始化完成后，我们就可以打开文档并发送相应的 `"textDocument/didOpen"`
    通知。
- en: Open document
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开文档
- en: 'When a developer opens a C++ source file, the client sends a `"textDocument/didOpen"`
    notification to inform the language server about the newly opened file. In our
    example, the opened file is located at `/home/ivanmurashko/clangbook/helper.hpp`
    , and the corresponding notification sent by VS Code will look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者打开一个C++源文件时，客户端发送`"textDocument/didOpen"`通知，通知语言服务器关于新打开的文件。在我们的例子中，打开的文件位于`/home/ivanmurashko/clangbook/helper.hpp`，VS
    Code发送的相应通知将如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Figure 8.15**: VS Code to Clangd (didOpen notification)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.15**: VS Code到Clangd（didOpen通知）'
- en: As we can see, VS Code sends the notification with parameters included in the
    `"params/` `textDocument"` field. These parameters consist of the filename in
    the `"uri"` field and the source file text within the `"text"` field.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，VS Code发送了包含在`"params/textDocument"`字段中的参数的通知。这些参数包括`"uri"`字段中的文件名和`"text"`字段中的源文件文本。
- en: 'Clangd starts compiling the file upon receiving the ’didOpen’ notification.
    It builds an AST and extracts semantic information about different tokens from
    it. The server uses this information to distinguish between different tokens with
    the same name. For example, we can use a token named ’foo’ that may serve as a
    class member or a local variable depending on the scope in which it is used, as
    shown in the following code fragment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd在接收到’didOpen’通知后开始编译文件。它构建一个AST并从中提取关于不同标记的语义信息。服务器使用这些信息来区分具有相同名称的不同标记。例如，我们可以使用名为’foo’的标记，它可能根据使用的范围作为类成员或局部变量，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Figure 8.16**: Occurrences of the ’foo’ token in foo.hpp'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.16**: foo.hpp中’foo’标记的出现'
- en: 'As we can see in *Line 8*, we use the `’foo’` token two times: as a function
    call and in a local variable definition.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第8行*中看到的，我们使用了`’foo’`标记两次：作为函数调用和在局部变量定义中。
- en: The go-to definition request will be delayed until the compilation process is
    finished. It’s worth noting that the majority of requests are put in a queue and
    wait until the compilation process is finished. The rule has some exemptions,
    and some requests can be executed without an AST with a limited provided functionality.
    One of the examples is the code-formatting requests. The code formatting does
    not require an AST and therefore the formatting functionality can be provided
    before the AST is built.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到定义的请求将延迟到编译过程完成。值得注意的是，大多数请求都被放入队列中，等待编译过程完成。该规则有一些例外，一些请求可以在没有AST的情况下执行，并具有有限的提供功能。其中一个例子是代码格式化请求。代码格式化不需要AST，因此格式化功能可以在AST构建之前提供。
- en: 'If the state of the file is changed, then Clangd will notify VS Code with the
    `"textDocument/publishDiagnostics"` notification. For example, when the compilation
    process is finished, then Clangd will send the notification to VS Code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件的状态发生变化，Clangd将通过`"textDocument/publishDiagnostics"`通知通知VS Code。例如，当编译过程完成后，Clangd将发送通知到VS
    Code：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 8.17**: Clangd to VS Code (publishDiagnostics notification)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.17**: Clangd到VS Code（publishDiagnostics通知）'
- en: 'As we can see, there are no compilation errors; `params/diagnostics` is empty.
    It will contain errors or warning descriptions if our code contains a compilation
    error or warning, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有编译错误；`params/diagnostics`为空。如果我们的代码包含编译错误或警告，它将包含错误或警告描述，如下所示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Figure 8.18**: Clangd to VS Code (publishDiagnostics with compilation error)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.18**: Clangd到VS Code（带有编译错误的publishDiagnostics）'
- en: 'VS Code processes the diagnostics and displays it, as shown in the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code处理诊断信息并将其显示出来，如下面的屏幕截图所示：
- en: '![Figure 8.19: Compilation error in helper.hpp ](img/file8.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19: helper.hpp中的编译错误](img/file8.png)'
- en: '**Figure 8.19**: Compilation error in helper.hpp'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.19**: helper.hpp中的编译错误'
- en: After the compilation finished and we got `"textDocument/publishDiagnostics"`
    , Clangd is ready to process navigation requests, such as `"textDocument/definition"`
    (go-to definition).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，我们收到`"textDocument/publishDiagnostics"`后，Clangd就准备好处理导航请求，例如`"textDocument/definition"`（跳转到定义）。
- en: Go-to definition
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳转到定义
- en: 'To find the definition of a symbol in a C++ file, the client sends a `"textDocument/`
    `definition"` request to the language server:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一个C++文件中查找符号的定义，客户端向语言服务器发送`"textDocument/definition"`请求：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure 8.20**: VS Code to Clangd (textDocument/definition request)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.20**: VS Code到Clangd（textDocument/definition请求）'
- en: The line position is specified as 7 instead of the actual line 8 in the editor,
    as shown in [Figure 8.6](#Figure8.6). This is because line numbering starts at
    0.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 行位置指定为 7 而不是编辑器中的实际行 8，如图 8.6 所示。这是因为行号从 0 开始。
- en: 'The language server responds with the definition location in the C++ code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务器在 C++ 代码中响应定义位置：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Figure 8.21**: Clangd to VS Code (textDocument/definition response)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.21**：Clangd 到 VS Code（textDocument/definition 响应）'
- en: As we can see, the server responded with the actual position of the definition.
    Another popular action in the IDE is document modification. This functionality
    is served by the `"textDocument/didChange"` notification. Let’s look at it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，服务器响应了定义的实际位置。在 IDE 中另一个流行的操作是文档修改。此功能由 `"textDocument/didChange"` 通知提供。让我们看看它。
- en: Change document
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改文档
- en: 'As part of the document modification, let’s insert a comment, `//` `Constructor`,
    at *Line 6*, as shown in this screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文档修改的一部分，让我们在 *第 6 行* 插入注释 `// Constructor`，如图所示：
- en: '![Figure 8.22: Change document ](img/file9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.22：更改文档](img/file9.png)'
- en: '**Figure 8.22**: Change document'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.22**：更改文档'
- en: 'VS Code will detect that the document has been modified and notify the LSP
    server (Clangd) using the following notification:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 将检测到文档已被修改，并使用以下通知通过 LSP 服务器（Clangd）进行通知：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Figure 8.23**: VS Code to Clangd (didChange notification)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.23**：VS Code 到 Clangd（didChange 通知）'
- en: As we can see, the notification contains the range specification and the text
    for replacing the specified range in the document. One important part of the notification
    is the `"version"` field, which specifies the version of the document.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通知包含范围规范和用于替换文档中指定范围的文本。通知的一个重要部分是 `"version"` 字段，它指定了文档的版本。
- en: We can observe that `version` changed from 1, as used in the document open (see
    *Line 9* in [Figure 8.15](#x1-162014r15)), to 2 for the document modification
    (see *Line 23* in [Figure 8.23](#x1-164030r23)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到 `version` 从文档打开时使用的 1 变为 2，用于文档修改（如图 8.23 的第 23 行[图 8.23](#x1-164030r23)所示）。
- en: 'Clangd starts the document compilation because the document modification can
    cause a significant change in the resulting AST, which is used for navigation
    requests. Once the compilation is finished, the server will respond with the corresponding
    `"textDocument/publishDiagnostics"` notification, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档修改可能导致用于导航请求的结果 AST 发生重大变化，Clangd 将开始文档编译。一旦编译完成，服务器将响应相应的 `"textDocument/publishDiagnostics"`
    通知，如图所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 8.24**: Clangd to VS Code (publishDiagnostics notification)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.24**：Clangd 到 VS Code（publishDiagnostics 通知）'
- en: As we can see, the diagnostic was sent for the modified document because it
    contains the version field pointing to version 2, which corresponds to the modified
    document, as seen in *Line 7* of [Figure 8.24](#x1-164042r24).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于它包含指向版本 2 的版本字段，因此对修改后的文档发送了诊断信息，这对应于图 8.24 的第 7 行[图 8.24](#x1-164042r24)。
- en: Our last action in the example is to close the document. Let’s take a closer
    look at it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中的最后一个操作是关闭文档。让我们更仔细地看看它。
- en: Closing a document
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭文档
- en: 'When we finish our work with the document and close it, VS Code sends a `"textDocument/didClose"`
    notification to the language server:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成对文档的工作并关闭它时，VS Code 向语言服务器发送 `"textDocument/didClose"` 通知：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 8.25**: VS Code to Clangd (textDocument/didClose request)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.25**：VS Code 到 Clangd（textDocument/didClose 请求）'
- en: 'After receiving the request, Clangd will remove the document from its internal
    structures. Clangd will not send any updates for the document anymore, thus it
    will empty out the list of diagnostics shown on the client (e.g., in the **Problems**
    pane of VS Code) by sending the final empty `"textDocument/publishDiagnostics"`
    message, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到请求后，Clangd 将从其内部结构中删除文档。Clangd 将不再为该文档发送任何更新，因此它将通过发送最终的空 `"textDocument/publishDiagnostics"`
    消息来清空客户端（例如，在 VS Code 的 **问题** 面板中）上显示的诊断列表，如图所示：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 8.26**: Clangd to VS Code (textDocument/didClose request)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.26**：Clangd 到 VS Code（textDocument/didClose 请求）'
- en: The shown example demonstrates the typical interactions between Clangd and VS
    Code. The provided example utilizes functionality from the Clang frontend, that
    is, basic Clang functionality. On the other hand, Clangd has a strong connection
    with other Clang tools, such as Clang-Format and Clang-Tidy, and can reuse the
    functionality provided by these tools. Let’s take a closer look at this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所示示例演示了 Clangd 和 VS Code 之间的典型交互。提供的示例利用了 Clang 前端的功能，即基本的 Clang 功能。另一方面，Clangd
    与其他 Clang 工具（如 Clang-Format 和 Clang-Tidy）有很强的联系，并且可以重用这些工具提供的功能。让我们更详细地看看这一点。
- en: 8.5 Integration with Clang tools
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 与 Clang 工具的集成
- en: 'Clangd takes advantage of the LLVM module architecture and has a very strong
    integration with other Clang tools. In particular, Clangd uses Clang-Format libraries
    to provide formatting functionality and Clang-Tidy libraries (such as libraries
    with clang-tidy checks) to support linters in the IDE. The integration is schematically
    shown in the following figure:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd 利用 LLVM 模块架构，并与其他 Clang 工具有非常强的集成。特别是，Clangd 使用 Clang-Format 库来提供格式化功能，并使用
    Clang-Tidy 库（例如带有 clang-tidy 检查的库）来支持 IDE 中的代码检查器。集成方案在以下图中展示：
- en: '![Figure 8.27: VS Code with LSP extension and Clangd server for C++ ](img/Figure8.27_B19722.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.27：带有 LSP 扩展和 Clangd 服务器用于 C++ 的 VS Code](img/Figure8.27_B19722.png)'
- en: '**Figure 8.27**: VS Code with LSP extension and Clangd server for C++'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.27**：带有 LSP 扩展和 Clangd 服务器用于 C++ 的 VS Code'
- en: The configuration from `.clang-format` (see [*Section** 7.4.1*](B19722_07.xhtml#x1-1470001)*,
    Clang-Format* *configuration and usage examples*) is used for formatting, and
    from `.clang-tidy` (see [*Figure** 5.12*](B19722_05.xhtml#x1-1080002)*, Clang-Tidy
    configuration*) for linters. Let’s see how the formatting works in Clangd.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`.clang-format`（参见 [*第 7.4.1 节*](B19722_07.xhtml#x1-1470001)*，Clang-Format*
    *配置和使用示例*）中的配置用于格式化，而 `.clang-tidy`（参见 [*图 5.12*](B19722_05.xhtml#x1-1080002)*，Clang-Tidy
    配置*）用于代码检查器。让我们看看 Clangd 中格式化是如何工作的。'
- en: 8.5.1 Clangd support for code formatting using LSP messages
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 Clangd 使用 LSP 消息支持代码格式化
- en: Clangd provides robust support for code formatting. This feature is essential
    for developers to maintain consistent code styles and readability in their C and
    C++ projects. Clangd leverages LSP messages, primarily the `"textDocument/formatting"`
    and `"textDocument/rangeFormatting"` requests, to achieve this functionality.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd 提供了对代码格式化的强大支持。这一功能对于开发者保持 C 和 C++ 项目的代码风格一致性和可读性至关重要。Clangd 利用 LSP 消息，主要是
    `"textDocument/formatting"` 和 `"textDocument/rangeFormatting"` 请求，来实现这一功能。
- en: Formatting entire documents
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式化整个文档
- en: 'The `"textDocument/formatting"` request is used when a developer wants to format
    the entire content of a document. This request is typically initiated by the user
    in VS Code by pressing *Ctrl + Shift + I* (or ![The Apple Key](img/Mac_icon.png)
    *+ Shift + I* for macOS); the IDE sends a `"textDocument/formatting"` request
    to Clangd for the entire document:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者想要格式化文档的全部内容时，会使用 `"textDocument/formatting"` 请求。此请求通常由用户在 VS Code 中通过按
    *Ctrl + Shift + I*（或 macOS 上的 ![苹果键](img/Mac_icon.png) *+ Shift + I*）来启动；IDE 会向
    Clangd 发送一个针对整个文档的 `"textDocument/formatting"` 请求：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 8.28**: VS Code to Clangd (textDocument/formatting request)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.28**：VS Code 到 Clangd（textDocument/formatting 请求）'
- en: Clangd processes this request by utilizing the code style configuration specified
    in the project’s `.clang-format` file. The `.clang-format` file contains formatting
    rules and preferences, allowing developers to define their desired code style;
    see [*Section** 7.4.1*](B19722_07.xhtml#x1-1470001)*, Clang-Format configuration
    and usage* *examples*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd 通过利用项目 `.clang-format` 文件中指定的代码风格配置来处理此请求。`.clang-format` 文件包含格式化规则和首选项，允许开发者定义他们想要的代码风格；参见
    [*第 7.4.1 节*](B19722_07.xhtml#x1-1470001)*，Clang-Format 配置和使用* *示例*。
- en: 'The response contains the list of modifications to be applied to the opened
    document:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中包含要应用到打开文档中的修改列表：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Figure 8.29**: Clangd to VS Code (textDocument/formatting response)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.29**：Clangd 到 VS Code（textDocument/formatting 响应）'
- en: In the example, we should replace the text at the specified range at *Lines
    7-16* in [Figure 8.29](#x1-168038r29) with new text specified at *Line 6*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们应该将 [图 8.29](#x1-168038r29) 中 *第 7-16 行* 的文本替换为新文本，该文本指定在 *第 6 行*。
- en: Formatting specific code ranges
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式化特定的代码范围
- en: 'In addition to formatting entire documents, Clangd also supports formatting
    specific code ranges within a document. This is achieved using the `"textDocument/rangeFormatting"`
    request. Developers can select a range within the code, such as a function, a
    block of code, or even just a few lines, and request formatting for that specific
    range, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式化整个文档外，Clangd还支持格式化文档中的特定代码范围。这是通过使用`"textDocument/rangeFormatting"`请求实现的。开发者可以在代码中选择一个范围，例如一个函数、一段代码块，甚至只有几行，并请求对该特定范围进行格式化，如下面的截图所示：
- en: '![Figure 8.30: Reformatting a specific code range in helper.hpp ](img/file10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图8.30：在helper.hpp中重新格式化特定的代码范围](img/file10.png)'
- en: '**Figure 8.30**: Reformatting a specific code range in helper.hpp'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.30**：在helper.hpp中重新格式化特定的代码范围'
- en: 'When selecting the menu item or pressing *Ctrl + K* and then *Ctrl + F* (or
    ![The Apple Key](img/Mac_icon.png) *+ K* and then ![The Apple Key](img/Mac_icon.png)
    *+ F* for macOS), VS Code will send the following request to Clangd:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择菜单项或按*Ctrl + K*然后*Ctrl + F*（或macOS上的![苹果键](img/Mac_icon.png) *+ K*然后![苹果键](img/Mac_icon.png)
    *+ F*），VS Code将向Clangd发送以下请求：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Figure 8.31**: VS Code to Clangd (textDocument/rangeFormatting request)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.31**：VS Code到Clangd（textDocument/rangeFormatting请求）'
- en: The `"textDocument/rangeFormatting"` request specifies the range to be formatted
    within the document, and Clangd applies the same formatting rules from the `.clang-format`
    file to this specific code segment. The response will be similar to the one used
    for the formatting request and will contain the modification that should be applied
    to the original text, as shown in [Figure 8.29](#x1-168038r29). The only difference
    will be the method name, which should be `"textDocument/rangeFormatting"` in this
    case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`"textDocument/rangeFormatting"`请求指定了文档中需要格式化的范围，Clangd将`.clang-format`文件中的相同格式化规则应用于这个特定的代码段。响应将与格式化请求类似，并将包含应用于原始文本的修改，如图[图8.29](#x1-168038r29)所示。唯一的区别将是方法名，在这种情况下应该是`"textDocument/rangeFormatting"`。'
- en: Another tool that is integrated via Clangd is Clang-Tidy, and it utilizes the
    LSP protocol in a different manner compared to the formatting functionality that
    we just described.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通过Clangd集成的工具是Clang-Tidy，它相对于我们刚刚描述的格式化功能，以不同的方式使用LSP协议。
- en: 8.5.2 Clang-Tidy
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 Clang-Tidy
- en: 'As we can see, Clangd uses specific LSP methods to implement integration with
    Clang-Format:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Clangd使用特定的LSP方法来实现与Clang-Format的集成：
- en: '`"textDocument/formatting"`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"textDocument/formatting"`'
- en: '`"textDocument/rangeFormatting"`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"textDocument/rangeFormatting"`'
- en: On the other hand, the integration with Clang-Tidy is implemented differently,
    and it reuses the `"publishDiagnostics"` notification to report linter warnings
    and errors.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，与Clang-Tidy的集成实现不同，它重用了`"publishDiagnostics"`通知来报告lint警告和错误。
- en: Let’s investigate how it works and create a custom Clang-Tidy configuration
    as the first step.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查它是如何工作的，并作为第一步创建一个自定义的Clang-Tidy配置。
- en: Clang-Tidy integration with LSP
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Clang-Tidy与LSP集成
- en: 'We will run the misc-methodrename check that we recently created for testing
    method renaming, see [*Section** 7.3*](B19722_07.xhtml#x1-1410003)*, Clang-Tidy
    as a code modification tool*. Our Clang-Tidy configuration will look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行我们最近创建的用于测试方法重命名的`misc-methodrename`检查，参见[*第7.3节*](B19722_07.xhtml#x1-1410003)*，Clang-Tidy作为一个代码修改工具*。我们的Clang-Tidy配置将如下所示：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Figure 8.32**: .clang-tidy config for IDE integration'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.32**：IDE集成用的.clang-tidy配置'
- en: The `.clang-tidy` file with the configuration should be placed in the folder
    with our test project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应将包含配置的`.clang-tidy`文件放置在我们的测试项目文件夹中。
- en: 'If we rename our helper class to `TestHelper`, we will be able to observe that
    the lint check we created in [*Section** 7.3*](B19722_07.xhtml#x1-1410003)*, Clang-Tidy
    as a code modification* *tool* will start reporting diagnostics about the incorrect
    method name used for the test class. The corresponding diagnostic is displayed
    in the drop-down pane and in the **PROBLEMS** tab, as we can see in the following
    screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将辅助类重命名为`TestHelper`，我们将能够观察到我们在[*第7.3节*](B19722_07.xhtml#x1-1410003)*，Clang-Tidy作为一个代码修改工具*中创建的lint检查将开始报告关于测试类使用的错误方法名。相应的诊断将在下拉面板和**问题**选项卡中显示，如下面的截图所示：
- en: '![Figure 8.33: Clang-Tidy integration ](img/file11.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图8.33：Clang-Tidy集成](img/file11.png)'
- en: '**Figure 8.33**: Clang-Tidy integration'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.33**：Clang-Tidy集成'
- en: 'The message is displayed as part of diagnostics. Specifically, the following
    notification is sent from Clang to VS Code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 消息作为诊断信息的一部分显示。具体来说，以下通知是从 Clang 发送到 VS Code 的：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Figure 8.34**: Clangd to VS Code (publishDiagnostics notification)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.34**：Clangd 到 VS Code（publishDiagnostics 通知）'
- en: As we can see in the figure (*Line 11*), a fix for the problem is also available.
    There is an amazing opportunity to apply Clang-Tidy fixes in the IDE. Let’s explore
    how the functionality is implemented with LSP.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中（*第 11 行*）所示，问题的修复也是可用的。在 IDE 中应用 Clang-Tidy 修复有一个惊人的机会。让我们探索如何使用 LSP 实现此功能。
- en: Applying fixes in the IDE
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 IDE 中应用修复
- en: 'The fixes can be applied in the IDE and the functionality is provided via the
    `"textDocument/codeAction"` method. The method is used by VS Code to prompt Clangd
    to compute commands for the specific document and range. The most important parts
    of the command are provided in the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 修复可以在 IDE 中应用，并且该功能通过 `"textDocument/codeAction"` 方法提供。此方法由 VS Code 用于提示 Clangd
    计算特定文档和范围的命令。以下示例中提供了命令最重要的部分：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Figure 8.35**: VS Code to Clangd (textDocument/codeAction request)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.35**：VS Code 到 Clangd（textDocument/codeAction 请求）'
- en: 'The most important part of the request is at *Lines 7-11*, where we can see
    a copy of the original diagnostics notification. This information will be used
    to retrieve the necessary document modifications provided by `clang``::``FixItHint`
    in the activated check. Consequently, Clangd can respond with the action that
    describes the required modification to be made:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请求最重要的部分在 *第 7-11 行*，我们可以看到原始诊断通知的副本。此信息将被用于检索由 `clang::FixItHint` 在激活的检查中提供的必要文档修改。因此，Clangd
    可以响应描述所需修改的动作：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Figure 8.36**: Clangd to VS Code (codeAction response)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.36**：Clangd 到 VS Code（codeAction 响应）'
- en: The `"edit"` field in [Figure 8.36](#x1-172049r36) is the most important part
    of the response, as it describes the changes to be applied to the original text.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.36](#x1-172049r36) 中的 `"edit"` 字段是响应中最重要的一部分，因为它描述了对原始文本的更改。'
- en: The integration with Clang-Tidy is possible without extra computation because
    the AST is built for navigation and diagnostics purposes by Clangd core. The AST
    can be used as the seed for Clang-Tidy checks, eliminating the need to run a separate
    Clang-Tidy executable to retrieve messages from the linter. This is not the only
    optimization made in Clangd; let’s now look at another example of performance
    optimizations in Clangd.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Clangd 核心构建 AST 用于导航和诊断目的，因此无需额外计算即可与 Clang-Tidy 集成。AST 可以用作 Clang-Tidy 检查的种子，从而消除运行单独的
    Clang-Tidy 可执行文件以从代码检查器检索消息的需求。这不是 Clangd 做出的唯一优化；现在让我们看看 Clangd 中性能优化的另一个示例。
- en: 8.6 Performance optimizations
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 性能优化
- en: Obtaining a smooth IDE experience with accurate results provided without visible
    delays is a challenging task. One of the ways to achieve this experience is through
    compiler performance optimization, as good navigation can be provided with well-parsed
    source code. Clangd offers excellent examples of performance optimization, which
    we will explore in some detail. We will start with the optimizations for code
    modifications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 获得平滑的 IDE 体验，提供准确的结果且无可见延迟是一项挑战性任务。实现这种体验的一种方法是通过编译器性能优化，因为良好的导航可以通过良好解析的源代码提供。Clangd
    提供了性能优化的优秀示例，我们将详细探讨。我们将从代码修改的优化开始。
- en: 8.6.1 Optimizations for modified documents
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.1 修改文档的优化
- en: As we saw in [*Line** 4*](#x1-1620002)*, Open document*, navigation support
    requires the AST as the basic data structure, so we have to use the Clang frontend
    to obtain it. Additionally, we have to rebuild the AST when there are document
    modifications. Document modification is a common activity for developers, and
    we won’t be able to provide a good IDE experience if we always start the build
    process from scratch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 4 行*](#x1-1620002)中看到的那样，打开文档、导航支持需要 AST 作为基本数据结构，因此我们必须使用 Clang 前端来获取它。此外，当文档发生修改时，我们必须重建
    AST。文档修改是开发者的常见活动，如果我们总是从头开始启动构建过程，我们将无法提供良好的 IDE 体验。
- en: Source code preamble
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源代码前缀
- en: 'To gain insights into the ideas used to speed up AST building for modified
    documents, let’s examine a simple C++ program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解用于加速修改文档的抽象语法树（AST）构建的想法，让我们检查一个简单的 C++ 程序：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Figure 8.37**: C++ program: helloworld.cpp'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.37**：C++ 程序：helloworld.cpp'
- en: 'The program has six lines of code, but the conclusion can be deceptive. The
    `#``include` directive inserts a lot of additional code. We can estimate the amount
    of code inserted by the preprocessor if we run Clang with the `-E` command-line
    option and calculate the number of lines, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 程序有六行代码，但结论可能会误导。`#include`指令插入了大量的附加代码。如果我们使用带有`-E`命令行选项的Clang运行并计算行数，我们可以估计预处理器插入的代码量，如下所示：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Figure 8.38**: Number of lines in the post-processed program'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.38**：后处理程序中的行数'
- en: where `<...>` is the folder where llvm-project was cloned; see [Figure 1.1](B19722_01.xhtml#x1-25005r1).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`<...>`是克隆llvm-project的文件夹；参见[图1.1](B19722_01.xhtml#x1-25005r1)。
- en: As we can see, the code that should be parsed contains more than 36,000 lines
    of code. This is a common pattern, and the majority of the code to be compiled
    is inserted from included headers. The part of the document located at the beginning
    of the source file and containing the include directives is called the **preamble**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，应该解析的代码包含超过36,000行代码。这是一个常见的模式，大多数要编译的代码都是从包含的头文件中插入的。位于源文件开头并包含包含指令的部分称为**前导部分**。
- en: It’s worth noting that preamble modifications are possible but rare, for instance,
    when we insert a new header. The majority of the modifications are located in
    the code outside the preamble.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，前导部分的修改是可能的，但很少见，例如，当我们插入一个新的头文件时。大多数的修改都位于前导部分之外的代码中。
- en: The primary idea for performance optimization is to cache the preamble AST and
    reuse it for any compilation of a modified document.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化的主要思想是缓存前导部分的AST，并为其任何修改的文档重用。
- en: AST build at Clangd
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Clangd中构建的AST
- en: The performance optimization made in Clangd involves a two-part compilation
    process. In the first part, the preamble that contains all included header files
    is compiled into a precompiled header; see [*Section** 10.2*](B19722_10.xhtml#x1-1920002)*,
    Precompiled headers*. This precompiled header is then used in the second stage
    of the compilation process to build the AST.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd中进行的性能优化涉及两个部分的编译过程。在第一部分，包含所有包含的头文件的前导部分被编译成一个预编译头文件；参见[*第10.2节*](B19722_10.xhtml#x1-1920002)*，预编译头文件*。然后，这个预编译头文件在编译过程的第二阶段用于构建AST。
- en: This complex process serves as a performance optimization, especially when a
    user makes changes to a file that requires recompilation. Although a significant
    portion of compilation time is spent on header files, these files are typically
    not modified frequently. To address this, Clangd caches the AST for header files
    within the precompiled header file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂的过程作为性能优化，尤其是在用户对需要重新编译的文件进行修改时。尽管编译时间的大部分都花在了头文件上，但这些文件通常不会频繁修改。为了解决这个问题，Clangd将预编译头文件中的头文件AST进行缓存。
- en: As a result, when modifications are made outside header files, Clangd does not
    need to rebuild them from scratch. Instead, it can reuse the cached AST for headers,
    significantly improving compilation performance and reducing the time needed for
    recompilation when working with header files. If a user modification affects header
    files, then the entire AST should be rebuilt, resulting in a cache miss in such
    cases. It’s worth noting that modifications to headers are not as common as modifications
    to the primary source code (outside the included headers). Therefore, we can expect
    a pretty good cache hit rate for ordinary document modifications.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当对头文件之外的部分进行修改时，Clangd不需要从头开始重新构建它们。相反，它可以重用缓存的头文件AST，显著提高编译性能，并减少处理头文件时重新编译所需的时间。如果用户的修改影响了头文件，那么整个AST应该被重新构建，这会导致在这些情况下缓存失效。值得注意的是，对头文件的修改不如对主要源代码（不包括包含的头文件）的修改常见。因此，我们可以预期普通文档修改的缓存命中率相当高。
- en: The precompiled header can be stored on a disk as a temporary file but can also
    reside in memory, which can also be considered a performance optimization.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头文件可以存储在磁盘上的临时文件中，但也可以驻留在内存中，这也可以被视为一种性能优化。
- en: 'The cached preamble is a powerful tool that significantly improves Clangd’s
    performance in processing document changes made by a user. On the other hand,
    we should always consider edge cases that involve preamble modification. The preamble
    can be modified in two main ways:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的前导部分是一个强大的工具，它显著提高了Clangd处理用户对文档所做的更改的性能。另一方面，我们应该始终考虑涉及前导部分修改的边缘情况。前导部分可以通过两种主要方式修改：
- en: '**Explicitly**: When the user explicitly modifies the preamble, for instance,
    by inserting a new header into it or deleting an existing one'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显式地**：当用户显式修改前言时，例如，通过向其中插入一个新的头文件或删除现有的一个'
- en: '**Implicitly**: When the user implicitly modifies the preamble, for instance,
    by modifying the headers that are included in the preamble'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**隐式地**：当用户隐式修改前言时，例如，通过修改包含在前言中的头文件'
- en: The first one can be easily detected via a `"textDocument/didChange"` notification
    that affects the range where the preamble is located. The second one is tricky,
    and Clangd should monitor the modifications in the included headers to correctly
    process navigation requests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可以通过影响前言位置的“textDocument/didChange”通知轻松检测到。第二个比较棘手，Clangd应该监控包含的头文件中的修改，以正确处理导航请求。
- en: Clangd also has some modifications aimed at making preamble compilation faster.
    Some of these modifications required specific processing in Clang. Let’s delve
    into it in detail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd也有一些修改旨在使前言编译更快。其中一些修改需要在Clang中进行特定处理。让我们详细探讨一下。
- en: 8.6.2 Building preamble optimization
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.2 构建前言优化
- en: 'An interesting optimization can be applied to function bodies. A function body
    can be considered an essential part of primary indexing because it contains symbols
    that a user can click on, such as getting a definition for the symbol. This primarily
    applies to function bodies that are visible to the user in the IDE. On the other
    hand, many functions and their implementations (bodies) are hidden from the user
    in included headers. As a result, the user cannot request information about symbols
    from such function bodies. However, these bodies are visible to the compiler because
    it resolves include directives and parses the header files from the directives.
    The time spent by the compiler can be significant, considering that a complex
    project can have numerous dependencies, resulting in many header files being included
    in the document opened by the user. One obvious optimization is to skip function
    bodies when parsing header files from the preamble. This can be achieved using
    a special frontend option:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用一种有趣的优化到函数体上。函数体可以被视为主索引的一个基本部分，因为它包含用户可以点击的符号，例如获取符号的定义。这主要适用于用户在IDE中可见的函数体。另一方面，许多函数及其实现（函数体）在包含的头文件中隐藏起来，用户无法从这样的函数体请求符号信息。然而，这些函数体对编译器是可见的，因为编译器解析包含指令并从指令中解析头文件。考虑到一个复杂的项目可能有众多的依赖关系，导致用户打开的文档中包含许多头文件，编译器花费的时间可能是显著的。一个明显的优化是在解析前言中的头文件时跳过函数体。这可以通过使用一个特殊的前端选项来实现：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Figure 8.39**: The FrontendOptions class from clang/Frontend/FrontendOptions.h'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.39**：来自clang/Frontend/FrontendOptions.h的FrontendOptions类'
- en: 'Clangd utilizes this option when building the preamble in the following manner:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Clangd在以下方式构建前言时使用此选项：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Figure 8.40**: buildPreamble from clang-tools-extra/clangd/Preamble.cpp'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.40**：来自clang-tools-extra/clangd/Preamble.cpp的buildPreamble'
- en: As we can see, Clangd uses the frontend option to skip function bodies in headers
    but disables it just before building the AST for the main document; see *Lines
    10* *and 16* in [Figure 8.40](#x1-177033r40).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Clangd使用前端选项在头文件中跳过函数体，但在构建主文档的AST之前禁用它；参见[图8.40](#x1-177033r40)中的*第10行*和*第16行*。
- en: Such optimization can significantly improve the document readiness time (when
    the opened document is ready for navigation requests from the user) for complex
    C++ source files.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化可以显著提高复杂C++源文件的文档准备时间（当打开的文档准备好响应用户的导航请求时）。
- en: While the performance optimizations discussed here offer valuable insights into
    Clangd’s efficiency, it’s important to note that Clangd employs a multitude of
    other techniques to ensure its reliability and speed. Clangd serves as an excellent
    platform for experimenting with and implementing various optimization strategies,
    making it a versatile environment for performance enhancements and innovations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里讨论的性能优化为Clangd的效率提供了宝贵的见解，但重要的是要注意，Clangd采用了多种其他技术来确保其可靠性和速度。Clangd是一个出色的平台，用于实验和实现各种优化策略，使其成为性能增强和创新的灵活环境。
- en: 8.7 Summary
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 总结
- en: In this chapter, we acquired knowledge of LSP, a protocol used to provide developer
    tools integration with IDEs. We explored Clangd, an LSP server that is part of
    LLVM and can be considered as a prime example of how it integrates various tools
    discussed in the book. Clangd utilizes the Clang frontend to display compilation
    errors and leverages the AST as a fundamental data structure that provides information
    for navigation requests, such as go-to definition requests. Additionally, Clangd
    is seamlessly integrated with other tools covered in previous chapters, such as
    Clang-Tidy and Clang-Format. This integration showcases the significant benefits
    of the LLVM/Clang module structure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 LSP（语言服务器协议），这是一种用于提供开发工具与 IDE 集成的协议。我们探讨了 Clangd，它是 LLVM 的一部分，可以被视为书中讨论的各种工具如何集成的典范。Clangd
    使用 Clang 前端来显示编译错误，并利用 AST（抽象语法树）作为基本的数据结构，为导航请求提供信息，例如跳转到定义的请求。此外，Clangd 与前几章中介绍的其他工具无缝集成，例如
    Clang-Tidy 和 Clang-Format。这种集成展示了 LLVM/Clang 模块结构的显著优势。
- en: 8.8 Further reading
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 进一步阅读
- en: 'Language Server Protocol specification: [https://microsoft.github.io/language-server-protocol/](https://microsoft.github.io/language-server-protocol/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言服务器协议规范：[https://microsoft.github.io/language-server-protocol/](https://microsoft.github.io/language-server-protocol/)
- en: 'Clangd documentation: [https://clangd.llvm.org/](https://clangd.llvm.org/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clangd 文档：[https://clangd.llvm.org/](https://clangd.llvm.org/)
