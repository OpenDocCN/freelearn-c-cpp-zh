- en: '*Chapter 1*: Understanding Basic C++ Assumptions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：理解基本的C++假设'
- en: This chapter will briefly identify the basic language syntax, constructs, and
    features of C++, which you are assumed to have familiarity with from either the
    basic syntax of C++, C, Java, or similar languages. These core language features
    will be reviewed concisely. If these basic syntax skills are not familiar to you
    after completing this chapter, please first take the time to explore a more basic
    syntax-driven C++ text before continuing with this book. The goal of this chapter
    is not to teach each of the assumed skills in detail, but to briefly provide a
    synopsis of each basic language feature to allow you to quickly recall a skill
    that should already be in your programming repertoire.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍C++的基本语言语法、结构和特性，这些您应该已经熟悉了，无论是来自C++、C、Java或类似语言的基本语法。这些核心语言特性将被简要回顾。如果在完成本章后这些基本语法技能对您来说不熟悉，请先花时间探索更基本的基于语法的C++文本，然后再继续阅读本书。本章的目标不是详细教授每个假定的技能，而是简要提供每个基本语言特性的概要，以便您能够快速回忆起应该已经掌握的技能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主要主题：
- en: Basic language syntax
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语言语法
- en: Basic I/O
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本输入/输出
- en: Control structures, statements, and looping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构、语句和循环
- en: Operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Function basics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数基础
- en: User defined type basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义类型基础
- en: Namespace basics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间基础
- en: By the end of this chapter, you'll have a succinct review of the very basic
    C++ language skills in which you're assumed to be proficient. These skills will
    be necessary in order to move forward with the next chapter successfully. Because
    most of these features do not utilize OO features of C++, I will refrain from
    using OO terminology (as much as possible) and will instead introduce appropriate
    OO terminology when we move into the OO sections of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对您应该熟练掌握的非常基本的C++语言技能进行简要回顾。这些技能将是成功进入下一章所必需的。因为大多数这些特性不使用C++的面向对象特性，我将尽量避免使用面向对象的术语，并在我们进入本书的面向对象部分时引入适当的面向对象术语。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please ensure that you have a current C++ compiler available; you'll want to
    try many of the online code examples. Minimally, please download g++ from [https://gcc.gnu.org](https://gcc.gnu.org).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您有一个当前的C++编译器可用；您会想要尝试许多在线代码示例。至少，请从[https://gcc.gnu.org](https://gcc.gnu.org)下载g++。
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter01` in a file named `Chp1-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，文件名由章节号和当前章节中的示例号组成。例如，本章的第一个完整程序可以在子目录`Chapter01`中的名为`Chp1-Ex1.cpp`的文件中找到，位于上述GitHub目录中。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3c6oQdK](https://bit.ly/3c6oQdK).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接观看：[https://bit.ly/3c6oQdK](https://bit.ly/3c6oQdK)。
- en: Reviewing basic C++ language syntax
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾基本的C++语言语法
- en: In this section, we will briefly review basic C++ syntax. We'll assume that
    you are either a C++ programmer with non-OO programming skills, or that you've
    programmed in C, Java, or a similar strongly typed checked language with related
    syntax. You may also be a long-standing professional programmer who is able to
    pick up another language's basics quickly. Let's begin our brief review.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾基本的C++语法。我们假设您要么是具有非面向对象编程技能的C++程序员，要么是在C、Java或类似的强类型检查语言中编程过，并且熟悉相关语法。您也可能是一个长期从事专业编程的程序员，能够快速掌握另一种语言的基础知识。让我们开始我们的简要回顾。
- en: Variable declarations and standard data types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明和标准数据类型
- en: 'Variables may be any length and may consist of letters, digits, and underscores.
    Variables are case-sensitive and must begin with a letter or an underscore. Standard
    data types in C++ include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以是任意长度，并且可以由字母、数字和下划线组成。变量区分大小写，并且必须以字母或下划线开头。C++中的标准数据类型包括：
- en: '`int`: To store whole numbers'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：用于存储整数'
- en: '`float`: To store floating-point values'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：用于存储浮点值'
- en: '`double`: To store double-precision floating-point values'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：用于存储双精度浮点值'
- en: '`char`: To store a single character'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：用于存储单个字符'
- en: '`bool`: For Boolean values of true or false'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：用于布尔值true或false'
- en: 'Here are a few straightforward examples using the standard data types described
    above:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上述标准数据类型的一些简单示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reviewing the previous fragment of code, note that a variable can be assigned
    a literal value, such as `int x = 5;`, or that a variable may be assigned the
    value or contents of another variable, such as `int a = x;`. These examples illustrate
    this ability with various standard data types. Note that for the `bool` type,
    the value can be set to `true` or `false`, or to the opposite of one of those
    values using `!` (not).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的代码片段，注意变量可以被赋予文字值，比如`int x = 5;`，或者变量可以被赋予另一个变量的值或内容，比如`int a = x;`。这些例子展示了对各种标准数据类型的能力。注意对于`bool`类型，值可以被设置为`true`或`false`，或者使用`!`（非）来设置为这些值的相反值。
- en: Variables and array basics
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和数组基础
- en: Arrays can be declared of any data type. The array name represents the starting
    address of the contiguous memory associated with the array's contents. Arrays
    are zero-based in C++, meaning they are indexed starting with array `element[0]`
    rather than array `element[1]`. Most importantly, range checking is not performed
    on arrays in C++; if you access an element outside the size of an array, you are
    accessing memory belonging to another variable and your code will likely fault
    very soon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以声明为任何数据类型。数组名称表示与数组内容相关的连续内存的起始地址。在C++中，数组是从零开始的，这意味着它们的索引从数组`element[0]`开始，而不是从数组`element[1]`开始。最重要的是，在C++中不对数组执行范围检查；如果访问超出数组大小的元素，那么您正在访问属于另一个变量的内存，您的代码很快可能会出错。
- en: 'Let''s review some simple array declarations, an initialization, and an assignment:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些简单的数组声明、初始化和赋值：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Above, notice that the first array, `name`, contains 10 `char` elements, which
    are initialized to the seven characters in the string literal `"Dorothy"`, followed
    by the null character (`'\0'`). The array currently has two unused elements at
    the end. The elements in the array can be accessed individually using `name[0]`
    through `name[9]`, as arrays in C++ are zero-based. Similarly, the array above,
    which is identified by the variable `grades`, has 20 elements, none of which are
    initialized. Any array value accessed prior to initialization or assignment can
    contain any value; this is true for any uninitialized variable. Notice that just
    after the array `grades` is declared, its zeroth element is assigned a value of
    `4.0`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上面注意到，第一个数组`name`包含10个`char`元素，它们被初始化为字符串字面值`"Dorothy"`中的七个字符，后面跟着空字符(`'\0'`)。数组目前有两个未使用的元素。可以使用`name[0]`到`name[9]`来单独访问数组中的元素，因为C++中的数组是从零开始的。同样，上面的数组，由变量`grades`标识，有20个元素，没有一个被初始化。在初始化或赋值之前访问任何数组值都可以包含任何值；对于任何未初始化的变量都是如此。注意，在声明数组`grades`后，它的零元素被赋值为`4.0`。
- en: 'Arrays of characters are often conceptualized as strings. Many standard string
    functions exist in libraries such as `<cstring>`. Arrays of characters should
    be null-terminated if they are to be treated as strings. When arrays of characters
    are initialized with a string of characters, the null character is added automatically.
    However, if characters are added one by one to the array via assignment, it would
    then be the programmer''s job to add the null character (`''\0''`) as the final
    element in the array. Let''s see some basic examples:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数组经常被概念化为字符串。许多标准字符串函数存在于诸如`<cstring>`的库中。如果要将字符数组作为字符串处理，应该以空字符结尾。当用字符数组的字符串初始化时，空字符会被自动添加。然而，如果通过赋值逐个添加字符到数组中，那么程序员就需要在数组中添加空字符(`'\0'`)作为最后一个元素。让我们看一些基本的例子：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Above, the first variable `book1` is declared to be 20 characters in length
    and is initialized to a string literal of `"C++ Programming"`. Next, variable
    `book2` is declared to be an array of 25 characters in length but is not initialized
    with a value. Next, the function `strcpy()` from `<cstring>` is used to copy the
    string literal `"OO Programming with C++"` into the variable `book2`. Note that
    `strcpy()` will automatically add the null terminating character to the destination
    string. On the next line, `strcmp()`, also from `<cstring>`, is used to lexicographically
    compare the contents of variables `book1` and `book2`. This function returns an
    integer value, which can be captured in another variable or used in a comparison.
    Lastly, the function `strlen()` is used to count the number of characters in `book2`
    (excluding the null character).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，第一个变量`book1`被声明为长度为20个字符，并初始化为字符串字面值`"C++ Programming"`。接下来，变量`book2`被声明为长度为25个字符的数组，但没有用值初始化。然后，使用`<cstring>`中的`strcpy()`函数将字符串字面值`"OO
    Programming with C++"`复制到变量`book2`中。注意，`strcpy()`将自动添加空字符到目标字符串。在下一行，也来自`<cstring>`的`strcmp()`函数用于按字典顺序比较变量`book1`和`book2`的内容。该函数返回一个整数值，可以存储在另一个变量中或用于比较。最后，使用`strlen()`函数来计算`book2`中的字符数（不包括空字符）。
- en: Comment styles
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释风格
- en: 'Two styles of comments are available in C++:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有两种注释风格：
- en: The `/* */` style provides comments spanning multiple lines of code. This style
    may not be nested with other comments of this same style.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/* */`风格提供了跨越多行代码的注释。这种风格不能与同一风格的其他注释嵌套。'
- en: The `//` style of comment provides a simple comment to the end of the current
    line.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`风格的注释提供了一个简单的注释，直到当前行的末尾。'
- en: Using the two comment styles together can allow nested comments, which can be
    useful when debugging code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用两种注释风格可以允许嵌套注释，在调试代码时可能会很有用。
- en: 'Now that we have successfully reviewed basic C++ language features such as
    variable declarations, standard data types, array basics, and comment styles,
    let''s move forward to recap another fundamental language feature of C++: basic
    keyboard input and output using the `<iostream>` library.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地回顾了基本的C++语言特性，比如变量声明、标准数据类型、数组基础和注释风格，让我们继续回顾C++的另一个基本语言特性：使用`<iostream>`库进行基本键盘输入和输出。
- en: Recapping basic I/O
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本I/O回顾
- en: In this section, we'll briefly review simple character-based input and output
    with the keyboard and monitor. Simple manipulators will also be reviewed to both
    explain the underlying mechanics of I/O buffers and to provide basic enhancements
    and formatting.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将简要回顾使用键盘和显示器进行简单基于字符的输入和输出。还将简要介绍简单的操作符，以解释I/O缓冲区的基本机制，并提供基本的增强和格式化。
- en: The iostream library
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iostream库
- en: 'One of the easiest mechanisms for input and output in C++ is the use of the
    `<iostream>` library. The header file `<iostream>` contains definitions of the
    data types `cin`, `cout`, and `cerr`, are incorporated by including the `std`
    namespace. The `<iostream>` library facilitates simple I/O:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，最简单的输入和输出机制之一是使用`<iostream>`库。头文件`<iostream>`包含了`cin`、`cout`和`cerr`的数据类型定义，通过包含`std`命名空间来使用。`<iostream>`库简化了简单的I/O：
- en: '`cin` can be used in conjunction with the extraction operator `>>` for input'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cin`可以与提取运算符`>>`一起用于输入'
- en: '`cout` can be used in conjunction with the insertion operator `<<` for output'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cout`可以与插入运算符`<<`一起用于输出'
- en: '`cerr` can also be used in conjunction with the insertion operator, but for
    errors'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cerr`也可以与插入运算符一起使用，但用于错误'
- en: 'Let''s review an example showcasing simple I/O:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个展示简单I/O的例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex1.cpp)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex1.cpp)'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we include the `<iostream>` library and indicate that we''re using the
    `std` namespace to gain usage of `cin` and `cout` (more on namespaces later in
    this chapter). Next, we introduced the `main()` function, which is the entry point
    in our application. Here we declare two variables, `name` and `age`, neither of
    which is initialized. Next, we prompt the user for input by placing the string
    `"Please enter a name and an age: "` in the buffer associated with `cout`. When
    the buffer associated with `cout` is flushed, the user will see this prompt on
    the screen.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们包含`<iostream>`库，并指示我们使用`std`命名空间来使用`cin`和`cout`（本章后面将更多介绍命名空间）。接下来，我们引入了`main()`函数，这是我们应用程序的入口点。在这里，我们声明了两个变量，`name`和`age`，都没有初始化。接下来，我们通过在与`cout`相关的缓冲区中放置字符串`"Please
    enter a name and an age: "`来提示用户输入。当与`cout`相关的缓冲区被刷新时，用户将在屏幕上看到这个提示。'
- en: The keyboard input string is then placed in the buffer associated with `cout`
    using the extraction operator `<<`. Conveniently, one mechanism that automatically
    flushes the buffer associated with `cout` is the use of `cin` to read keyboard
    input into variables, such as on the next line where we read the user input into
    the variables, `name` and `age`, respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用提取运算符`<<`将键盘输入的字符串放入与`cout`相关的缓冲区。方便的是，自动刷新与`cout`相关的缓冲区的机制是使用`cin`将键盘输入读入变量，比如下一行我们将用户输入读入变量`name`和`age`中。
- en: Next, we print out a greeting of `"Hello"` to the user, followed by the name
    entered, followed by an indication of their age, gathered from the second piece
    of user input. The `endl` at the end of this line both places a newline character
    `'\n'` into the output buffer and ensures that the output buffer is flushed –
    more of that next. The `return 0;` declaration simply returns a program exit status
    to the programming shell, in this case, the value `0`. Notice that the `main()`
    function indicates an `int` for a return value to ensure this is possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向用户打印出一个问候语“Hello”，然后是输入的姓名，再然后是他们的年龄，从第二个用户输入中获取。这一行末尾的`endl`既将换行符`'\n'`放入输出缓冲区，又确保输出缓冲区被刷新
    - 更多内容请看下文。`return 0;`声明只是将程序退出状态返回给编程外壳，这里是值`0`。请注意，`main()`函数指示了一个`int`类型的返回值，以确保这是可能的。
- en: Basic iostream manipulators
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本iostream操纵器
- en: 'Often, it is desirable to be able to manipulate the contents of the buffers
    associated with `cin`, `cout`, and `cerr`. Manipulators allow the internal state
    of these objects to be modified, which affects how their associated buffers are
    formatted and manipulated. Manipulators are defined in the `<iomanip>` header
    file. Common manipulator examples include:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，希望能够操作与`cin`、`cout`和`cerr`相关的缓冲区的内容。操纵器允许修改这些对象的内部状态，从而影响它们相关的缓冲区的格式和操作。操纵器在`<iomanip>`头文件中定义。常见的操纵器示例包括：
- en: '`endl`: Places a newline character in the buffer associated with `cout` then
    flushes the buffer'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endl`: 将换行符放入与`cout`相关的缓冲区，然后刷新缓冲区'
- en: '`flush`: Clears the contents of the output stream'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush`: 清除输出流的内容'
- en: '`setprecision(int)`: Sets floating-point precision'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setprecision(int)`: 设置浮点数精度'
- en: '`setw(int)`: Sets width for input and output'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setw(int)`: 设置输入和输出的宽度'
- en: '`ws`: Removes whitespace characters from the buffer'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ws`: 从缓冲区中移除空白字符'
- en: 'Let''s see a simple example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex2.cpp)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex2.cpp)'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, first notice the inclusion of the `<iomanip>` header file.
    Also, notice that `setw(20)` is used to ensure that we do not overflow the name
    variable, which is only 20 characters long; `setw()` will automatically deduct
    one from the size provided to ensure there is room for the null character. Notice
    that `flush` is used on the second output line – it's not necessary here to flush
    the output buffer; this manipulator merely demonstrates how a `flush` may be applied.
    On the last output line with `cout`, notice that `setprecision(3)` is used to
    print the floating-point `gpa`. Three points of precision account for the decimal
    point plus two places to the right of the decimal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先注意到包含了`<iomanip>`头文件。还要注意到，`setw(20)`用于确保我们不会溢出名字变量，它只有20个字符长；`setw()`会自动减去一个提供的大小，以确保有空间放置空字符。注意第二个输出行上使用了`flush`
    - 这里不需要刷新输出缓冲区；这个操纵器只是演示了如何应用`flush`。在最后一个`cout`输出行上，注意使用了`setprecision(3)`来打印浮点数`gpa`。三位精度包括小数点和小数点右边的两位。
- en: Now that we have reviewed simple input and output using the `<iostream>` library,
    let's move forward by briefly reviewing control structures, statements, and looping
    constructs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了使用`<iostream>`库进行简单输入和输出，让我们继续通过简要回顾控制结构、语句和循环结构。
- en: Revisiting control structures, statements, and looping
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视控制结构、语句和循环
- en: C++ has a variety of control structures and looping constructs, which allow
    for non-sequential program flow. Each can be coupled with simple or compound statements.
    Simple statements end with a semicolon; more compound statements are enclosed
    in a block of code using a pair of brackets `{}`. In this section, we will be
    revisiting various types of control structures (`if` , `else if`, and `else`),
    and looping constructs (`while`, `do while`, and `for`) to recap simple methods
    for non-sequential program flow within our code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C++有各种控制结构和循环结构，允许非顺序程序流。每个都可以与简单或复合语句配对。简单语句以分号结束；更复杂的语句则用一对大括号`{}`括起来。在本节中，我们将重新讨论各种类型的控制结构（`if`，`else
    if`和`else`）和循环结构（`while`，`do while`和`for`），以回顾代码中非顺序程序流的简单方法。
- en: 'Control structures: if, else if, and else'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制结构：if，else if和else
- en: 'Conditional statements using `if`, `else if`, and `else` can be used with simple
    statements or a block of statements. Note that an `if` clause can be used without
    a following `else if` or `else` clause. Actually, `else if` is really a condensed
    version of an `else` clause with a nested `if` clause inside of it. Practically
    speaking, developers flatten the nested use into `else if` format for readability
    and to save excess indenting. Let''s see an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`，`else if`和`else`进行条件语句可以与简单语句或一组语句一起使用。请注意，`if`子句可以在没有后续`else if`或`else`子句的情况下使用。实际上，`else
    if`实际上是`else`子句的一种简化版本，其中包含一个嵌套的`if`子句。实际上，开发人员将嵌套使用展平为`else if`格式，以提高可读性并节省多余的缩进。让我们看一个例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex3.cpp)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex3.cpp)'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that in the `else` clause above, multiple statements are bundled into
    a block of code, whereas in the `if` and `else if` conditions only a single statement
    follows each condition. As a side note, in C++ any non-zero value is considered
    to be true. So, for example, testing `if (x)` would imply that `x` is not equal
    to zero – it would not be necessary to write `if (x !=0)`, except possibly for
    readability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的`else`子句中，多个语句被捆绑成一个代码块，而在`if`和`else if`条件中，每个条件后面只有一个语句。另外，需要注意的是，在C++中，任何非零值都被视为true。因此，例如，测试`if
    (x)`会暗示`x`不等于零 - 无需写`if (x !=0)`，除非可能是为了可读性。
- en: 'Looping constructs: while, do while, and for loops'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环结构：while，do while和for循环
- en: C++ has several looping constructs. Let's take a moment to review a brief example
    for each style, starting with the `while` and `do while` loop constructs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++有几种循环结构。让我们花点时间来回顾每种样式的简短示例，从`while`和`do while`循环结构开始。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex4.cpp)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `while` loop, the condition to enter the loop must evaluate to true
    prior to each entry of the loop body. However, with the `do while` loop, the first
    entry to the loop body is guaranteed – the condition is then evaluated before
    another iteration through the loop body. In the example above, both the `while`
    and `do while` loops are executed 10 times, each printing values 0-9 for variable
    `i`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环时，进入循环的条件必须在每次进入循环体之前求值为true。然而，使用`do while`循环时，保证第一次进入循环体 - 然后在再次迭代循环体之前求值条件。在上面的示例中，`while`和`do
    while`循环都执行10次，每次打印变量`i`的值为0-9。
- en: 'Next, let''s review a typical `for` loop. The `for` loop has three parts within
    the `()`. First, there is a statement that is executed exactly once and is often
    used to initialize a loop control variable. Next, separated on both sides by semicolons
    in the center of the `()` is an expression. This expression is evaluated each
    time before entering the body of the loop. The body of the loop is only entered
    if this expression evaluates to true. Lastly, the third part within the `()` is
    a second statement. This statement is executed immediately after executing the
    body of the loop and is often used to modify a loop control variable. Following
    this second statement, the center expression is re-evaluated. Here is an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下典型的`for`循环。`for`循环在`()`内有三部分。首先，有一个语句，它只执行一次，通常用于初始化循环控制变量。接下来，在`()`的中心两侧用分号分隔的是一个表达式。这个表达式在进入循环体之前每次都会被求值。只有当这个表达式求值为true时，才会进入循环体。最后，在`()`内的第三部分是第二个语句。这个语句在执行完循环体后立即执行，并且通常用于修改循环控制变量。在执行完这个第二个语句后，中心的表达式会被重新求值。以下是一个例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex5.cpp)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex5.cpp)'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above, we have two `for` loops. Prior to the first loop, variable `i` is declared.
    Variable `i` is then initialized with a value of `0` in statement 1 between the
    loop parentheses `()`. The loop condition is tested, and if true, the loop body
    is then entered and executed, followed by statement 2 being executed prior to
    the loop condition being retested. This loop is executed 10 times for `i` values
    0 through 9\. The second `for` loop is similar, with the only difference being
    variable `j` is both declared and initialized within statement 1 of the loop construct.
    Note that variable `j` only has scope for the `for` loop itself, whereas variable
    `i` has the scope of the entire block in which it is declared, from its declaration
    point forward.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们有两个`for`循环。在第一个循环之前，变量`i`被声明。然后在循环括号`()`之间的语句1中用值`0`初始化变量`i`。测试循环条件，如果为真，则进入并执行循环体，然后在重新测试循环条件之前执行语句2。这个循环对`i`的值从0到9执行10次。第二个`for`循环类似，唯一的区别是变量`j`在循环结构的语句1中声明和初始化。请注意，变量`j`只在`for`循环本身的范围内，而变量`i`在其声明点之后的整个块的范围内。
- en: Let's quickly see an example using nested loops. The looping constructs can
    be of any type, but below we'll review nested `for` loops.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一个使用嵌套循环的示例。循环结构可以是任何类型，但下面我们将回顾嵌套的`for`循环。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex6.cpp)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex6.cpp)'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Above, the outer loop will execute 10 times with `i` values of 0 through 9\.
    For each value of `i`, the inner loop will execute 10 times, with `j` values of
    0 through 9\. Remember, with `for` loops, the loop control variable is automatically
    incremented with the `i++` or `j++` within the loop construct. Had a `while` loop
    been used, the programmer would need to remember to increment the loop control
    variable in the last line of the body of each such loop.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的外部循环中，`i`的值从0到9执行10次。对于每个`i`的值，内部循环将执行10次，`j`的值从0到9。请记住，使用`for`循环时，循环控制变量会在循环结构内部自动递增`i++`或`j++`。如果使用了`while`循环，程序员需要记住在每个这样的循环体的最后一行递增循环控制变量。
- en: Now that we have reviewed control structures, statements, and looping constructs
    in C++, we can move onward by briefly recalling C++'s operators.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了C++中的控制结构、语句和循环结构，我们可以通过简要回顾C++的运算符来继续前进。
- en: Reviewing C++ operators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾C++运算符
- en: 'Unary, binary, and ternary operators exist in C++. C++ allows operators to
    have different meanings based on the context of usage. C++ also allows programmers
    to redefine the meaning of selected operators when used in the context of at least
    one user-defined type. The operators are listed below as a concise list. We''ll
    see examples of these operators throughout the remainder of this section and throughout
    the course. Here is a synopsis of the binary, unary, and ternary operators in
    C++:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一元、二元和三元运算符都存在于C++中。C++允许运算符根据使用的上下文具有不同的含义。C++还允许程序员重新定义至少一个用户定义类型的上下文中使用的选定运算符的含义。以下是运算符的简明列表。我们将在本节的其余部分和整个课程中看到这些运算符的示例。以下是C++中二元、一元和三元运算符的概要：
- en: '![Table 1.1 – Binary Operators](img/Table_1.1_B15702.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![表1.1 - 二元运算符](img/Table_1.1_B15702.jpg)'
- en: Table 1.1 – Binary Operators
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 - 二元运算符
- en: 'In the aforementioned binary operator list, notice how many of the operators
    have "shortcut" versions when paired with the assignment operator `=`. For example,
    `a = a * b` can be written equivalently using a shortcut operator `a *= b`. Let''s
    take a look at an example that incorporates an assortment of operators, including
    usage of a shortcut operator:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述二元运算符列表中，注意到许多运算符在与赋值运算符`=`配对时具有“快捷”版本。例如，`a = a * b`可以使用快捷操作符`a *= b`等效地编写。让我们看一个包含各种运算符使用的示例，包括快捷操作符的使用：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code fragment, notice the use of the shortcut operator `+=`.
    Here, the statement `score += 5;` is equivalent to `score = score + 5;`. Next,
    the unary increment operator `++` is used to increment `score` by 1\. Then we
    see the equality operator `==` to compare the score with a value of 100\. Finally,
    we see an example of the ternary operator `?:` to replace a simple `if`-`else`
    statement. It is instructive to note that `?:` is not preferred by some programmers,
    yet it is always interesting to review an example of its use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，注意到了快捷操作符`+=`的使用。在这里，语句`score += 5;`等同于`score = score + 5;`。接下来，使用一元递增运算符`++`来将`score`增加1。然后我们看到等号运算符`==`用于将分数与100进行比较。最后，我们看到了三元运算符`?:`的示例，用于替换简单的`if`-`else`语句。值得注意的是，一些程序员不喜欢使用`?:`，但总是有趣的回顾其使用示例。
- en: Now that we have very briefly recapped the operators in C++, let's revisit function
    basics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要回顾了C++中的运算符，让我们重新审视函数基础知识。
- en: Revisiting function basics
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视函数基础知识
- en: 'A function identifier must begin with a letter or underscore and may also contain
    digits. The function''s return type, argument list, and return value are optional.
    The basic form of a C++ function is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数标识符必须以字母或下划线开头，也可以包含数字。函数的返回类型、参数列表和返回值都是可选的。C++函数的基本形式如下：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s review a simple function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的函数：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex7.cpp)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex7.cpp)'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the simple example above, first, a `minimum()` function is defined. It has
    a return type of `int` and it takes two integer arguments: formal parameters `a`
    and `b`. In the `main()` function, `minimum()` is called with actual parameters
    `x` and `y`. The call to `minimum()` is permitted within the `cout` statement
    because `minimum()` returns an integer value; this value is passed along to the
    extraction operator (`<<`) in conjunction with printing. In fact, the string `"The
    minimum is: "` is first placed into the buffer associated with `cout`, followed
    by the return value from calling function `minimum()`. The output buffer is then
    flushed by `endl` (which first places a newline character in the buffer before
    flushing).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的简单示例中，首先定义了一个`minimum()`函数。它的返回类型是`int`，它接受两个整数参数：形式参数`a`和`b`。在`main()`函数中，使用实际参数`x`和`y`调用了`minimum()`。在`cout`语句中允许调用`minimum()`，因为`minimum()`返回一个整数值；这个值随后传递给提取运算符（`<<`），与打印一起使用。实际上，字符串`"The
    minimum is: "`首先被放入与`cout`关联的缓冲区中，然后是调用函数`minimum()`的返回值。然后输出缓冲区被`endl`刷新（它首先在刷新之前将换行符放入缓冲区）。'
- en: Notice that the function is first defined in the file and then called later
    in the file in the `main()` function. Strong type checking is performed on the
    call to the function by comparing the parameter types and their usage in the call
    to the function's definition. What happens, however, when the function call precedes
    its definition? Or if the call to the function is in a separate file from its
    definition?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数首先在文件中定义，然后在文件的`main()`函数中稍后调用。通过比较参数类型和它们在函数调用中的使用，对函数的调用执行了强类型检查。然而，当函数调用在其定义之前时会发生什么？或者如果对函数的调用在与其定义不同的文件中呢？
- en: In these cases, the default action is for the compiler to assume a certain *signature*
    to the function, such as an integer return type and that the formal parameters
    will match the types of arguments in the function call. Often, the default assumptions
    are incorrect; when the compiler then encounters the function definition later
    in the file (or when another file is linked in), an error will be raised indicating
    that the function call and definition do not match.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，编译器的默认操作是假定函数的某种*签名*，比如整数返回类型，并且形式参数将匹配函数调用中的参数类型。通常，默认假设是不正确的；当编译器在文件中稍后遇到函数定义（或者链接另一个文件时），将会引发错误，指示函数调用和定义不匹配。
- en: These issues have historically been solved with a forward declaration of a function
    included at the top of a file where the function will be called. Forward declarations
    consist of a function return type, function name and types, and the number of
    parameters. In C++, a forward declaration has been improved upon and is instead
    known as a function prototype. Since there are many interesting details surrounding
    function prototyping, this topic will be covered in reasonable detail in the next
    chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在历史上已经通过在将调用函数的文件顶部包含函数的前向声明来解决。前向声明由函数返回类型、函数名称和类型以及参数数量组成。在C++中，前向声明已经得到改进，而被称为函数原型。由于围绕函数原型存在许多有趣的细节，这个主题将在下一章中得到合理详细的介绍。
- en: As we move to the object-oriented sections in this book ([*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*, and beyond), we will learn that there are many
    more details and quite interesting features relating to functions. Nonetheless,
    we have sufficiently recalled the basics needed to move forward. Next, let's continue
    our C++ language review with user-defined types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书的面向对象部分（*第5章*，*详细探讨类*，以及更多）中学习时，我们将了解到有关函数的许多更多细节和相当有趣的特性。尽管如此，我们已经充分回顾了前进所需的基础知识。接下来，让我们继续我们的C++语言回顾，学习用户定义类型。
- en: Reviewing user-defined type basics
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾用户定义类型的基础
- en: C++ offers several mechanisms to create user-defined types. Bundling together
    like characteristics into one data type (later, we'll also add relevant behaviors)
    will form the basis for an object-oriented concept known as encapsulation in a
    later section of this text. For now, let's review the basic mechanisms to bundle
    together only data in `struct`, `class`, and `typedef` (to a lesser extent). We
    will also review enumerated types to represent lists of integers more meaningfully.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了几种机制来创建用户定义的类型。将类似特征捆绑成一个数据类型（稍后，我们还将添加相关的行为）将形成面向对象概念的封装的基础，这将在本文的后面部分中进行介绍。现在，让我们回顾一下将数据仅捆绑在`struct`、`class`和`typedef`（在较小程度上）中的基本机制。我们还将回顾枚举类型，以更有意义地表示整数列表。
- en: struct
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: struct
- en: 'A C++ structure in its simplest form can be used to collect common data elements
    together in a single unit. Variables may then be declared of the composite data
    type. The dot operator is used to access specific members of each structure variable.
    Here is a structure used in the most simple fashion:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C++结构在其最简单的形式中可以用来将共同的数据元素收集在一个单一的单元中。然后可以声明复合数据类型的变量。点运算符用于访问每个结构变量的特定成员。这是以最简单方式使用的结构：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex8.cpp)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex8.cpp
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Stylistically, type names are typically in lower case when using structs. In
    the example above, we declare the user-defined type `student` using `struct`.
    The type `student` has three fields or data members: `name`, `semesterGrades`,
    and `gpa`. In the `main()` function, a variable `s1` of type student is declared;
    the dot operator is used to access each of the variable''s data members. Since
    structs are typically not used for OO programming in C++, we''re not going to
    yet introduce significant OO terminology relating to their use. It''s worthy of
    note that in C++, the tag `student` also becomes the type name (unlike in C where
    a variable declaration would need the word `struct` to precede the type).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从风格上看，使用结构体时，类型名称通常是小写的。在上面的例子中，我们使用`struct`声明了用户定义类型`student`。类型`student`有三个字段或数据成员：`name`，`semesterGrades`和`gpa`。在`main()`函数中，声明了一个类型为student的变量`s1`；点运算符用于访问变量的每个数据成员。由于在C++中，结构体通常不用于面向对象编程，因此我们还不会介绍与其使用相关的重要面向对象术语。值得注意的是，在C++中，标签`student`也成为类型名称（与C中需要在变量声明之前使用`struct`一词不同）。
- en: typedef
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: typedef
- en: 'A `typedef` can be used to provide a more mnemonic representation for data
    types. In C++, the relative need for a `typedef` has been eliminated in usage
    with a `struct`. Historically, a `typedef` in C allowed the bundling together
    of the keyword `struct` and the structure tag to create a user-defined type. However,
    in C++, as the structure tag automatically becomes the type, a `typedef` then
    becomes wholly unnecessary for a `struct`. Typedefs can still be used with standard
    types for enhanced readability in code, but in this fashion, the typedef is not
    being used to bundle together like data elements, such as with a `struct`. Let''s
    take a look at a simple typedef:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef`可以用于为数据类型提供更易记的表示。在C++中，使用`struct`时相对不需要`typedef`。在C中，`typedef`允许将关键字`struct`和结构标签捆绑在一起，创建用户定义的类型。然而，在C++中，由于结构标签自动成为类型，因此对于`struct`来说，`typedef`变得完全不必要。Typedefs仍然可以与标准类型一起使用，以增强代码的可读性，但在这种情况下，typedef并不像`struct`那样用于捆绑数据元素。让我们看一个简单的typedef：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous declaration, the new type `dollars` can be used interchangeably
    with the type `float`. It is not productive to demonstrate the archaic use of
    typedef with a structure, so let's move on to the most used user-defined type
    in C++, the `class`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的声明中，新类型`dollars`可以与类型`float`互换使用。展示结构体的古老用法并不具有生产力，因此让我们继续前进，看看C++中最常用的用户定义类型，即`class`。
- en: class
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: class
- en: 'A `class` in its simplest form can be used nearly like a `struct` to bundle
    together related data into a single data type. In [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*, we''ll see that a `class` is typically also used
    to bundle related functions together with the new data type. Grouping together
    data and behaviors relevant to that data is the basis of encapsulation. For now,
    let''s see a `class` in its simplest form, much like a `struct`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`在其最简单的形式中几乎可以像`struct`一样用于将相关数据捆绑成单个数据类型。在[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199)，*详细探讨类*中，我们将看到`class`通常也用于将相关函数与新数据类型捆绑在一起。将相关数据和行为分组到该数据是封装的基础。现在，让我们看一个`class`的最简单形式，就像`struct`一样：'
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex9.cpp)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex9.cpp)'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice above that the code is very similar to that used in the `struct` example.
    The main difference is the keyword `class` instead of the keyword `struct` and
    the addition of the access label `public:` at the beginning of the class definition
    (more on that in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*). Stylistically, the capitalization of the first
    letter in the data type, such as `Student`, is typical for classes. We''ll see
    that classes have a wealth of features and are the building blocks for OO programming.
    We''ll introduce new terminology such as *instance*, to be used rather than *variable*.
    However, this section is only a review of skills assumed, so we''ll need to wait
    to get to the exciting OO features of the language. Spoiler alert: all the wonderful
    things classes will be able to do also apply to structs; however, we''ll see that
    structs stylistically won''t be used to exemplify OO programming.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面的代码与`struct`示例中使用的代码非常相似。主要区别是关键字`class`而不是关键字`struct`，以及在类定义的开头添加访问标签`public:`（更多内容请参见[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199)，*详细探讨类*）。从风格上看，类似`Student`这样的数据类型的首字母大写是典型的。我们将看到类具有丰富的特性，是面向对象编程的基本组成部分。我们将介绍新的术语，例如*实例*，而不是*变量*。然而，本节只是对假定技能的复习，因此我们需要等待才能了解语言的令人兴奋的面向对象特性。剧透警告：所有类将能够做的美妙事情也适用于结构体；然而，我们将看到，从风格上讲，结构体不会被用来举例说明面向对象编程。
- en: enum
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: enum
- en: 'Enumerated types may be used to mnemonically represent lists of integers. Unless
    otherwise initialized, integer values in the enumeration begin with zero and increase
    by one throughout the list. Two enumerated types may not utilize the same enumerator
    names. Let''s now see an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型可以用来记忆地表示整数列表。除非另有初始化，枚举中的整数值从零开始，并在整个列表中递增一。两个枚举类型不能使用相同的枚举器名称。现在让我们看一个例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex10.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex10.cpp)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex10.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex10.cpp)'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous example the enumerated type `day` has values of 0 through 6,
    starting with `Sunday`. The enumerated type `workDay` has values of 1 through
    5, starting with `Mon`. Notice the explicit use of `Mon = 1` as the first item
    in the enumerated type has been used to override the default starting value of
    0\. Interestingly, we may not repeat enumerators between two enumerated types.
    For that reason, you will notice that `Mon` is used as an enumerator in `workDay`
    because `Monday` has already been used in enumerated type `day`. Now, when we
    create variables such as birthday or payday, we can use meaningful enumerated
    types to initialize or assign values, such as `Monday` or `Fri`. As meaningful
    as the enumerators may be within the code, please note that the values when manipulated
    or printed will be their corresponding integer values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，枚举类型`day`的值从`Sunday`开始，从0到6。枚举类型`workDay`的值从`Mon`开始，从1到5。请注意，显式使用`Mon
    = 1`作为枚举类型中的第一项已被用来覆盖默认的起始值0。有趣的是，我们可能不会在两个枚举类型之间重复枚举器。因此，您会注意到`Mon`在`workDay`中被用作枚举器，因为`Monday`已经在枚举类型`day`中使用过。现在，当我们创建变量如`birthday`或`payday`时，我们可以使用有意义的枚举类型来初始化或赋值，比如`Monday`或`Fri`。尽管枚举器在代码中可能是有意义的，请注意，当操作或打印值时，它们将是相应的整数值。
- en: Now that we have revisited simple user-defined types in C++, including `struct`,
    `typedef`, `class`, and `enum`, we are ready to move onward to reviewing our next
    language necessity, the `namespace`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新访问了C++中的简单用户定义类型，包括`struct`、`typedef`、`class`和`enum`，我们准备继续审查我们下一个语言必需品，即`namespace`。
- en: Recapping namespace basics
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间基础回顾
- en: 'The namespace utility was added to C++ to add a scoping level beyond the global
    scope to applications. This feature can be used to allow two or more libraries
    to be utilized without concern that they may contain duplicative data types, functions,
    or identifiers. The programmer needs to activate the desired namespace in each
    relevant portion of their application with the keyword `using`. Programmers can
    also create their own namespaces (usually for creating reusable library code)
    and activate each namespace as applicable. In the above examples, we''ve seen
    simple use of the `std` namespace to include `cin` and `cout`, which are instances
    of `istream` and `ostream` (whose definitions are found in `<iostream>`). Let''s
    review how we can create namespaces ourselves:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间实用程序被添加到C++中，以在全局范围之外添加一个作用域级别到应用程序。这个特性可以用来允许两个或更多库被使用，而不必担心它们可能包含重复的数据类型、函数或标识符。程序员需要在应用程序的每个相关部分使用关键字`using`来激活所需的命名空间。程序员还可以创建自己的命名空间（通常用于创建可重用的库代码），并在适用时激活每个命名空间。在上面的例子中，我们已经看到了简单使用`std`命名空间来包括`cin`和`cout`，它们是`istream`和`ostream`的实例（它们的定义可以在`<iostream>`中找到）。让我们回顾一下如何创建自己的命名空间：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex11.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex11.cpp)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex11.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter01/Chp1-Ex11.cpp)'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second line of code above, we use the keyword `using` to indicate that
    we''d like to use or activate the `std` namespace. We can utilize `using` to open
    existing libraries that may contain useful classes; the keyword `using` activates
    the namespace that a given library may belong to. Next in the code, a user-created
    namespace is created called `DataTypes`, using the `namespace` keyword. Within
    this namespace exists a variable, `total`, and two class definitions: `LinkList`
    and `Stack`. Following this namespace, a second namespace `AbstractDataTypes`
    is created and includes two class definitions: `Stack` and `Queue`. Additionally,
    the namespace `AbstractDataTypes` is augmented by a second occurrence of the *namespace*
    definition in which a variable, `total`, and a class definition for `Tree` are
    added.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的第二行代码中，我们使用关键字`using`表示我们想要使用或激活`std`命名空间。我们可以利用`using`来打开包含有用类的现有库；关键字`using`激活给定库可能属于的命名空间。接下来在代码中，使用`namespace`关键字创建了一个名为`DataTypes`的用户创建的命名空间。在这个命名空间中存在一个变量`total`和两个类定义：`LinkList`和`Stack`。在这个命名空间之后，创建了第二个命名空间`AbstractDataTypes`，其中包括两个类定义：`Stack`和`Queue`。此外，命名空间`AbstractDataTypes`通过第二次*namespace*定义的出现增加了一个变量`total`和一个`Tree`的类定义。
- en: In the `main()` function, first, the `AbstractDataTypes` namespace is opened
    with the `using` keyword. This activates all names in this namespace. Next, the
    keyword `using` is combined with the scope resolution operator (`::`) to only
    activate the `LinkList` class definition from the `DataTypes` namespace. Had there
    also been a `LinkList` class within the `AbstractDataType` namespace, the initial
    visible `LinkList` would now be hidden by the activation of `DataTypes::LinkList`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，首先使用关键字`using`打开了`AbstractDataTypes`命名空间。这激活了这个命名空间中的所有名称。接下来，关键字`using`与作用域解析运算符(`::`)结合，只激活了`DataTypes`命名空间中的`LinkList`类定义。如果`AbstractDataType`命名空间中也有一个`LinkList`类，那么初始可见的`LinkList`现在将被`DataTypes::LinkList`的激活所隐藏。
- en: 'Next, a variable of type `LinkList` is declared, whose definition comes from
    the `DataTypes` namespace. A variable of type `Stack` is next declared; though
    both namespaces have a `Stack` class definition, there is no ambiguity since only
    one `Stack` has been activated. Next, we use `cin` to read into to `total`, which
    is active from the `AbstractDataTypes` namespace. Lastly, we use the scope resolution
    operator to explicitly read into `DataTypes::total`, a name that would otherwise
    be hidden. One caveat to note: should two or more namespaces contain the same
    "name," the one last opened will preside, hiding all previous occurrences.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明了一个类型为“LinkList”的变量，其定义来自“DataTypes”命名空间。接下来声明了一个类型为“Stack”的变量；虽然两个命名空间都有“Stack”类的定义，但由于只激活了一个“Stack”，所以没有歧义。接下来，我们使用“cin”读取到来自“AbstractDataTypes”命名空间的“total”。最后，我们使用作用域解析运算符显式地读取到“DataTypes::total”，否则该名称将被隐藏。需要注意的一点是：如果两个或更多的命名空间包含相同的“名称”，则最后打开的命名空间将主导，隐藏所有先前的出现。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed core C++ syntax and non-OO language features to
    refresh your existing skillset. These features include basic language syntax,
    basic I/O with `<iostream>`, control structures/statements/looping, operator basics,
    function basics, simple user-defined types as well as namespaces. Most importantly,
    you are now ready to move to the next chapter, in which we will expand on some
    of these ideas with additional language necessities such as `const` qualified
    variables, understanding and using prototypes (including with default values),
    and function overloading.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了核心C++语法和非面向对象语言特性，以刷新您现有的技能。这些特性包括基本语言语法，使用“<iostream>”进行基本I/O，控制结构/语句/循环，运算符基础，函数基础，简单的用户定义类型以及命名空间。最重要的是，您现在已经准备好进入下一章，在这一章中，我们将扩展一些这些想法，包括“const”限定变量，理解和使用原型（包括默认值），以及函数重载等额外的语言必需品。
- en: The ideas in the next chapter begin to move us closer to our goal for OO programming,
    as many of these aggregate skills are used often and matter of factly as we move
    deeper into the language. It is important to remember that in C++ you can do anything,
    whether you mean to do so or not. There is great power in the language and having
    a solid base for its many nuances and features is crucial. Over the next couple
    of chapters, the solid groundwork will be laid with an arsenal of non-OO C++ skills,
    so that we may realistically engage OO programming in C++ with a high level of
    understanding and success.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章中的想法开始让我们更接近面向对象编程的目标，因为许多这些聚合技能经常被使用，并且随着我们深入语言，它们变得理所当然。重要的是要记住，在C++中，你可以做任何事情，无论你是否有意这样做。语言中有巨大的力量，对其许多微妙和特性有一个坚实的基础是至关重要的。在接下来的几章中，将奠定坚实的基础，以掌握一系列非面向对象的C++技能，这样我们就可以以高水平的理解和成功实现在C++中进行面向对象编程。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe a situation in which `flush`, rather than `endl`, may be useful for
    clearing the contents of the buffer associated with `cout`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一种情况，在这种情况下，“flush”而不是“endl”可能对清除与“cout”关联的缓冲区的内容有用。
- en: The unary operator `++` can be used as a pre- or post-increment operator, such
    as `i++` or `++i`. Can you describe a situation in which choosing a pre- versus
    post-increment for `++` would have different consequences in the code?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一元运算符“++”可以用作前置或后置递增运算符，例如“i++”或“++i”。你能描述一种情况，在这种情况下，选择前置递增还是后置递增对代码会产生不同的后果吗？
- en: Create a simple program using a `struct` or `class` to make a user-defined type
    for `Book`. Add data members for title, author, and number of pages. Create two
    variables of type `Book` and use the dot operator `.` to fill in the data members
    for each such instance. Use `iostreams` to both prompt the user for input values,
    and to print each `Book` instance when complete. Use only features covered in
    this section.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的程序，使用“struct”或“class”为“Book”创建一个用户定义类型。为标题、作者和页数添加数据成员。创建两个类型为“Book”的变量，并使用点运算符“.”为每个实例填写数据成员。使用“iostreams”提示用户输入值，并在完成时打印每个“Book”实例。只使用本节介绍的功能。
