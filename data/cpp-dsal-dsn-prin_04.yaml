- en: 4\. Divide and Conquer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 分治
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章结束时，您将能够:'
- en: Describe the divide-and-conquer design paradigm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述分治设计范式
- en: Implement standard divide-and-conquer algorithms such as merge sort, quicksort,
    and linear time selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标准的分治算法，如归并排序、快速排序和线性时间选择
- en: Solve problems using the MapReduce programming model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MapReduce编程模型解决问题
- en: Learn how to use a multithreaded C++ MapReduce implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用多线程的C++ MapReduce实现
- en: In this chapter, we shall study the divide-and-conquer algorithm design paradigm
    and learn how to use it to solve computational problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习分治算法设计范式，并学习如何使用它来解决计算问题。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we studied some commonly used data structures. Data
    structures are organizations of data in different forms, and a data structure
    enables and controls the cost of access to the data stored inside it. However,
    what makes software useful is not just the ability to store and retrieve data
    in various formats, but the ability to make transformations on data in order to
    solve computational problems. For a given problem, the precise definition and
    order of transformations on data is determined by a sequence of instructions called
    an **algorithm**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了一些常用的数据结构。数据结构是以不同形式组织数据的方式，数据结构使得控制和访问存储在其中的数据的成本成为可能。然而，使软件有用的不仅仅是存储和检索各种格式的数据的能力，而是能够对数据进行转换以解决计算问题的能力。对于给定的问题，对数据的精确定义和转换顺序由一系列称为**算法**的指令确定。
- en: 'An algorithm takes in a set of inputs that define an instance of a problem,
    applies a series of transformations, and outputs a set of results. If these results
    are the correct solutions to the computational problem at hand, our algorithm
    is said to be *correct*. The *goodness* of an algorithm is determined by its efficiency,
    or how few instructions the algorithm needs to perform to produce correct results:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 算法接受一组定义问题实例的输入，应用一系列变换，并输出一组结果。如果这些结果是手头计算问题的正确解决方案，我们称算法是*正确*的。算法的*好坏*由其效率决定，或者说算法需要执行多少指令才能产生正确的结果：
- en: '![Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input](img/C14498_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：算法所需步骤随输入大小的扩展](img/C14498_04_01.jpg)'
- en: 'Figure 4.1: Scaling of steps taken by an algorithm with respect to the size
    of the input'
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：算法所需步骤随输入大小的扩展
- en: The preceding diagram shows the growth in the number of steps required by an
    algorithm as a function of the size of the input. Algorithms that are more complex
    grow more quickly with the size of the input, and with sufficiently large inputs
    they can become infeasible to run, even on modern computer systems. For instance,
    let's assume that we have a computer that can perform a million operations per
    second. For an input of size 50, an algorithm that takes *N log(N)* steps will
    take 283 microseconds to complete; an algorithm that takes *N**2* steps will take
    2.5 milliseconds; and an algorithm that takes *N!* (factorial of *N*) steps would
    take approximately 9,637,644,561,599,544,267,027,654,516,581,964,749,586,575,812,734.82
    **centuries** to run!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了算法所需步骤随输入大小的增长情况。复杂度更高的算法随着输入大小的增加而增长更快，对于足够大的输入，它们甚至在现代计算机系统上也可能无法运行。例如，假设我们有一台每秒可以执行一百万次操作的计算机。对于大小为50的输入，需要*N
    log(N)*步的算法将花费283微秒完成；需要*N**2*步的算法将花费2.5毫秒；需要*N!*（*N*的阶乘）步的算法将需要大约9,637,644,561,599,544,267,027,654,516,581,964,749,586,575,812,734.82
    **世纪**来运行！
- en: '*An algorithm is said to be efficient if, for the size of input N, it solves
    the problem in a number of steps that is a polynomial of N.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果对于输入大小N，算法以N的多项式步骤解决问题，则称算法是高效的。*'
- en: 'The problems that express **polynomial-time algorithms** as solutions are also
    said to belong to the class *P* (polynomial) of computational complexity. There
    are several other computational complexities that problems can be divided into,
    a few examples of which are given here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将**多项式时间算法**表达为解决方案的问题也被称为属于计算复杂性的类*P*（多项式）。问题可以分为几种其他计算复杂性，以下是一些示例：
- en: '**NP** (**Non-Deterministic Polynomial Time**) problems have solutions that
    can be verified in polynomial time, but do not have any known polynomial-time
    solutions.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP**（非确定性多项式时间）问题的解决方案可以在多项式时间内验证，但没有已知的多项式时间解决方案。'
- en: '**EXPTIME** (**Exponential Time**) problems have solutions that run in time
    exponential to the size of the input.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPTIME**（指数时间）问题的解决方案运行时间与输入大小呈指数关系。'
- en: '**PSPACE** (**Polynomial Space**) problems require a polynomial amount of space.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PSPACE**（多项式空间）问题需要多项式数量的空间。'
- en: Finding out whether the set of problems in *P* is exactly the same as the set
    of problems in *NP* is the famous *P = NP* problem, which remains unsolved after
    decades of efforts and even carries a $1 million prize for anyone who can solve
    it. We shall take another look at *P* and *NP*-type problems in *Chapter 9*, *Dynamic
    Programming II*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 找出*P*中的问题集是否与*NP*中的问题集完全相同是著名的*P = NP*问题，经过数十年的努力仍未解决，甚至为任何能解决它的人提供了100万美元的奖金。我们将在*第9章*
    *动态规划II*中再次研究*P*和*NP*类型的问题。
- en: Algorithms have been studied as mathematical objects by computer scientists
    for several decades and a set of general approaches (or **paradigms**) to design
    efficient algorithms have been identified that can be used to solve a wide variety
    of problems. One of the most widely applicable algorithm design paradigms is called
    *divide and conquer* and shall be our subject of study in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家们几十年来一直将算法作为数学对象进行研究，并确定了一组通用的方法（或**范式**）来设计高效的算法，这些方法可以用来解决各种各样的问题。其中最广泛适用的算法设计范式之一被称为*分治*，将是我们在本章的研究对象。
- en: A **divide-and-conquer** type algorithm breaks the given problem into smaller
    parts, tries to solve the problem for each part, and, finally, combines the solution
    for each part into the solution for the whole problem. Several widely used algorithms
    fall into this category, for example, binary search, quicksort, merge sort, matrix
    multiplication, Fast Fourier Transform, and the skyline algorithms. These algorithms
    appear in almost all the major applications that are used today, including databases,
    web browsers, and even language runtimes such as the Java Virtual Machine and
    the V8 JavaScript engine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**分而治之**类型的算法将给定的问题分解成较小的部分，尝试为每个部分解决问题，最后将每个部分的解决方案合并为整个问题的解决方案。几种广泛使用的算法属于这一类，例如二分搜索、快速排序、归并排序、矩阵乘法、快速傅里叶变换和天际线算法。这些算法几乎出现在今天使用的所有主要应用程序中，包括数据库、Web浏览器，甚至语言运行时，如Java虚拟机和V8
    JavaScript引擎。'
- en: In this chapter, we will show you what it means to solve problems using divide
    and conquer, and how you can identify whether your problem is amenable to such
    a solution. Next, we will practice thinking recursively and show you the tools
    that the modern C++ Standard Library gives you so that you can solve your problems
    using divide and conquer. We'll end this chapter by looking at MapReduce, including
    a discussion on why and how it scales, and how you can use the same paradigm to
    scale up your programs using both CPU-level and machine-level parallelization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示使用分而治之的方法解决问题的含义，以及如何确定您的问题是否适合这样的解决方案。接下来，我们将练习递归思维，并向您展示现代C++标准库提供的工具，以便您可以使用分而治之来解决问题。最后，我们将通过查看MapReduce来结束本章，包括讨论为什么以及如何扩展，以及如何使用相同的范例来扩展您的程序，包括CPU级别和机器级别的并行化。
- en: Let's dive into a basic algorithm that uses the divide-and-conquer approach
    – binary search.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究一种使用分而治之方法的基本算法-二分搜索。
- en: Binary Search
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分搜索
- en: 'Let''s start with the standard search problem: say we are given a sorted sequence
    of positive integers and are required to find out if a number, *N*, exists in
    the sequence. There are several places where the search problem shows up naturally;
    for example, a receptionist looking for a customer''s file in a set of files that
    are kept ordered by customer IDs or a teacher looking for the marks obtained by
    a student in their register of students. They are both, in effect, solving the
    search problem.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从标准搜索问题开始：假设我们有一个排序的正整数序列，并且需要找出一个数字*N*是否存在于序列中。搜索问题自然地出现在几个地方；例如，接待员在一组按客户ID排序的文件中寻找客户的文件，或者老师在学生注册表中寻找学生的成绩。他们实际上都在解决搜索问题。
- en: 'Now, we can approach the problem in two different ways. In the first approach,
    we iterate over the entire sequence, checking whether each element is equal to
    *N*. This is called a **linear search** and is shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以两种不同的方式解决问题。在第一种方法中，我们遍历整个序列，检查每个元素是否等于*N*。这称为**线性搜索**，并在以下代码中显示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One benefit of this approach is that it works for all arrays, sorted or unsorted.
    However, it is inefficient and does not take into account that the given array
    is sorted. In terms of its algorithmic complexity, it is an *O(N)* algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是它适用于所有数组，无论是排序还是未排序。但是，它效率低下，并且没有考虑到给定数组是排序的。在算法复杂度方面，它是一个*O(N)*算法。
- en: 'An alternative solution that exploits the fact that the sequence is sorted
    is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 利用序列已排序的事实的另一种解决方案如下：
- en: Start with the whole sequence in `range`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`range`中开始整个序列。
- en: Compare the middle element of the current `range` with *N*. Let this middle
    element be *M*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前`range`的中间元素与*N*进行比较。让这个中间元素为*M*。
- en: If *M = N*, we have found *N* in the sequence and, therefore, the search stops.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*M = N*，我们在序列中找到了*N*，因此搜索停止。
- en: 'Otherwise, we modify the `range` according to two rules:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们根据两条规则修改`range`：
- en: –  If *N < M*, it means that if *N* were to be present in the `range`, it would
    be to the left of *M* and, therefore, we can safely remove all the elements to
    the right of *M* from the `range`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*N < M*，这意味着如果*N*存在于`range`中，它将在*M*的左侧，因此我们可以安全地从`range`中删除*M*右侧的所有元素。'
- en: –  If *N > M*, the algorithm removes all the elements to the left of *M* from
    the `range`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*N > M*，算法从`range`中删除所有左侧的*M*元素。'
- en: If more than 1 element remains in the `range`, go to *step 2*.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`range`中仍有多于1个元素，则转到*步骤2*。
- en: Otherwise, *N* does not exist in the sequence and the search stops.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，*N*不存在于序列中，搜索停止。
- en: 'To illustrate this algorithm, we''ll show how binary search works where *S*
    is a sorted sequence of integers from *1* to 9 and *N = 2*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个算法，我们将展示二分搜索是如何工作的，其中*S*是从*1*到*9*的整数排序序列，*N = 2*：
- en: 'The algorithm starts with putting all the elements of *S* in range. The middle
    element in this step is found to be *5*. We compare *N* and *5*:![Figure 4.2:
    Binary search algorithm – step 1](img/C14498_04_02.jpg)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法从将*S*的所有元素放入范围开始。在这一步中，中间元素被发现是*5*。我们比较*N*和*5*：
- en: 'Figure 4.2: Binary search algorithm – step 1'
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：二分搜索算法-步骤1
- en: 'Since *N < 5*, if *N* was present in the sequence, it would have to be to the
    left of *5*. Therefore, we can safely discard all the elements of the sequence
    lying toward the right of *5* from our search. Our range now has elements only
    between *1* and *5*, and the middle element is now *3*. We can now compare *N*
    and *3*:![Figure 4.3: Binary search algorithm – step 2](img/C14498_04_03.jpg)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于*N < 5*，如果*N*存在于序列中，它必须在*5*的左边。因此，我们可以安全地丢弃序列中位于*5*右侧的所有元素。现在我们的范围只有*1*到*5*之间的元素，中间元素现在是*3*。我们现在可以比较*N*和*3*：
- en: 'Figure 4.3: Binary search algorithm – step 2'
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：二分搜索算法-步骤2
- en: 'We find that the current middle element, *3*, is still greater than *N*, and
    the range can further be pruned to contain elements only between *1* and *3*.
    The new middle element is now *2*, which is equal to *N*, and the search terminates:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们发现当前的中间元素*3*仍然大于*N*，并且范围可以进一步修剪为仅包含*1*和*3*之间的元素。新的中间元素现在是*2*，它等于*N*，搜索终止：
- en: '![Figure 4.4: Binary search algorithm – step 3](img/C14498_04_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：二分搜索算法-步骤3](img/C14498_04_04.jpg)'
- en: 'Figure 4.4: Binary search algorithm – step 3'
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：二分搜索算法-步骤3
- en: In the following exercise, we shall look at the implementation of the binary
    search algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看一下二分搜索算法的实现。
- en: 'Exercise 18: Binary Search Benchmarks'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：二分搜索基准
- en: 'In this exercise, we will write and benchmark a binary search implementation.
    Follow these steps to complete this exercise:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写并基准测试二分搜索实现。按照以下步骤完成这个练习：
- en: 'Begin by adding the following headers:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加以下头文件：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the linear search code like so:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加线性搜索代码如下：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the binary search code shown here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此处显示的二分搜索代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To evaluate the performance of binary search, we will implement two functions.
    First, write the small test:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估二分搜索的性能，我们将实现两个函数。首先，编写小测试：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add the large test function, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加大型测试函数，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, add the following driver code, which searches for the number `36543`
    in randomly generated vectors of different sizes:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下驱动程序代码，用于在不同大小的随机生成向量中搜索数字`36543`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the program in x64-Debug mode and run it. The output should look like
    the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以x64-Debug模式编译程序并运行。输出应如下所示：
- en: '![Figure 4.5: Binary search with debugging enabled](img/C14498_04_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：启用调试的二分搜索](img/C14498_04_05.jpg)'
- en: 'Figure 4.5: Binary search with debugging enabled'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：启用调试的二分搜索
- en: Notice that each of the three input arrays are all 10 times bigger than the
    previous arrays, so the third array is a hundred times larger than the first array,
    which itself contains a hundred thousand elements. Still, the time taken to search
    in the arrays using binary search increases only by 10 microseconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，三个输入数组的大小都比前一个数组大10倍，因此第三个数组比第一个数组大100倍，它本身包含十万个元素。然而，使用二分搜索在数组中搜索所花费的时间仅增加了10微秒。
- en: 'In the previous test, we did not allow any compiler optimizations and ran with
    the debugger attached to the program. Now, let''s see what happens when our compiler
    is allowed to optimize the C++ code with no debugger attached. Try compiling the
    code in *Exercise 18*, *Binary Search Benchmarks*, in x64-Release mode and run
    it. The output should look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个测试中，我们没有允许任何编译器优化，并且在运行时附加了调试器。现在，让我们看看当我们的编译器允许优化C++代码而没有附加调试器时会发生什么。尝试以x64-Release模式编译*练习18*中的*二分搜索基准*代码，并运行。输出应如下所示：
- en: '![Figure 4.6: Binary search with compiler optimizations turned on](img/C14498_04_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：打开编译器优化的二分搜索](img/C14498_04_06.jpg)'
- en: 'Figure 4.6: Binary search with compiler optimizations turned on'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：打开编译器优化的二分搜索
- en: The binary search takes approximately equal time in all three cases, even with
    vastly different vector sizes!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论向量大小如何，二分搜索在这三种情况下大致需要相同的时间！
- en: Note that our implementation of binary search uses iterators and the C++ Standard
    Library functions such as `std::distance()` and `std::advance()`. This is considered
    good practice in modern C++ since it helps keep our code agnostic of the underlying
    data type and safe from index out-of-bounds errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的二分搜索实现使用迭代器和C++标准库函数，如`std::distance()`和`std::advance()`。这在现代C++中被认为是良好的实践，因为它有助于使我们的代码不依赖于基础数据类型，并且可以避免索引越界错误。
- en: 'Now, say we wanted to perform a search on a vector of floating-point numbers.
    How would we modify our functions in the previous exercise? The answer is exceedingly
    simple. We can modify the function signatures as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在一个浮点数向量上执行搜索。我们如何修改上一个练习中的函数？答案非常简单。我们可以修改函数签名如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rest of the code inside of the search functions can still remain exactly
    the same since it is completely independent of the underlying datatype and depends
    only on the behavior of a container datatype. **This separation of core algorithm
    logic from the underlying datatype on which the algorithm operates is a cornerstone
    of writing reusable code in modern C++.** We shall see several examples of such
    separation in the duration of this book and dive into more functions that the
    Standard Library provides that can help us write reusable and robust code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索函数内部的其余代码仍然可以保持完全相同，因为它完全独立于基础数据类型，仅取决于容器数据类型的行为。**在现代C++中，将核心算法逻辑与算法操作的基础数据类型分离开来，是编写可重用代码的基石。**我们将在本书的过程中看到几个这样的分离示例，并深入研究标准库提供的更多函数，这些函数可以帮助我们编写可重用和健壮的代码。
- en: 'Activity 8: Vaccinations'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：疫苗接种
- en: 'Imagine that it is flu season and health department officials are planning
    to visit a school to ensure that all the enrolled children are administered their
    flu shot. However, there is a problem: a few children have already taken their
    flu shots but do not remember if they have been vaccinated against the specific
    category of flu that the health officials plan to vaccinate all the students against.
    Official records are sought out and the department is able to find a list of students
    that have already been administered the vaccine. A small excerpt of the list is
    shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在是流感季节，卫生部门官员计划访问一所学校，以确保所有入学的孩子都接种了流感疫苗。然而，出现了一个问题：一些孩子已经接种了流感疫苗，但不记得他们是否已经接种了卫生官员计划为所有学生接种的特定类别的流感疫苗。官方记录被寻找出来，部门能够找到已经接种疫苗的学生名单。这里显示了名单的一个小节：
- en: '![Figure 4.7: Excerpt of vaccination records](img/C14498_04_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：疫苗接种记录摘录](img/C14498_04_07.jpg)'
- en: 'Figure 4.7: Excerpt of vaccination records'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：疫苗接种记录摘录
- en: 'Assume that all the names are positive integers and that the given list is
    sorted. Your task is to write a program that can look up the vaccination status
    of a given student in the list and outputs to the officials whether the student
    needs to be vaccinated. Students need to be vaccinated in case of two conditions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有名称都是正整数，并且给定列表已排序。您的任务是编写一个程序，可以查找列表中给定学生的接种状况，并向官员输出学生是否需要接种疫苗。学生需要接种疫苗，如果满足以下两个条件：
- en: If they are not present in the list
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不在列表中
- en: If they are present in the list but have not been administered a flu shot
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们在名单上但尚未接种流感疫苗。
- en: 'Since the list can have a large number of students, your program should be
    as fast and efficient as possible. The final output of your program should look
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表中可能有大量学生，您的程序应尽可能快速和高效。程序的最终输出应如下所示：
- en: '![Figure 4.8: Sample output of Activity 8](img/C14498_04_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：活动8的示例输出](img/C14498_04_08.jpg)'
- en: 'Figure 4.8: Sample output of Activity 8'
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：活动8的示例输出
- en: '**High-level Steps**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级步骤**'
- en: 'The solution to this activity uses a slightly modified version of the binary
    search algorithm. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案使用了稍微修改过的二分搜索算法。让我们开始吧：
- en: 'Represent each student as an object of the `Student` class, which can be defined
    as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个学生表示为`Student`类的对象，可以定义如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Overload the required operators for the `Student` class so that a vector of
    students can be sorted using the Standard Library's `std::sort()` function.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载`Student`类的必要运算符，以便可以使用标准库的`std::sort()`函数对学生向量进行排序。
- en: Use a binary search to see if the student is present on the list.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用二分搜索查看学生是否在名单上。
- en: If the student isn't present in the list, your function should return *true*
    since the student needs to be administered the vaccine.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果学生不在列表中，则您的函数应返回*true*，因为学生需要接种疫苗。
- en: Otherwise, if the student is present in the list but has not been administered
    the vaccine, return *true*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果学生在名单上但尚未接种疫苗，则返回*true*。
- en: Else, return *false*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，返回*false*。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 506.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第506页找到。
- en: Understanding the Divide-and-Conquer Approach
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解分而治之方法
- en: 'At the core of the divide-and-conquer approach is a simple and intuitive idea:
    if you don''t know how to solve a large instance of a problem, find a small part
    of the problem that you can solve, and then solve it. Then, iterate for more such
    parts, and once you have solved all the parts, combine the results into a large
    coherent solution to the original problem. There are three steps to solving a
    problem using the divide-and-conquer approach:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在分而治之方法的核心是一个简单直观的想法：如果您不知道如何解决问题的大实例，请找到一个小部分的问题，您可以解决，然后解决它。然后，迭代更多这样的部分，一旦解决了所有部分，将结果合并成原始问题的大一致解决方案。使用分而治之方法解决问题有三个步骤：
- en: '**Divide**: Take the original problem and divide it into parts so that the
    same problem needs to be solved for each part.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**划分**：将原始问题划分为部分，以便为每个部分解决相同的问题。'
- en: '**Conquer**: Solve the problem for each part.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 征服：解决每个部分的问题。
- en: '**Combine**: Take the solutions for the different parts and combine them into
    a solution for the original problem.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**：将不同部分的解决方案合并成原始问题的解决方案。'
- en: 'In the previous section, we looked at an example of using divide and conquer
    to search within a sequence. At each step, binary search tries to search in only
    a part of the sequence, which is marked as the `range`. The search terminates
    when either the element is found or there is no longer a way to further divide
    the `range` into smaller parts. However, the search problem differs from most
    divide-and-conquer algorithms in the following manner: in the search problem,
    if an element can be found in a smaller `range` of the sequence, then it also
    definitely exists in the complete sequence. In other words, the solution to the
    problem in a smaller part of the sequence gives us the solution to the whole problem.
    Therefore, the solution does not need to implement the combination step of the
    general divide-and-conquer approach. This property, unfortunately, is not exhibited
    by the vast majority of computational problems that can be solved using a divide-and-conquer
    approach. In the following section, we shall dive deeper and look at more examples
    of using the divide-and-conquer approach to solve problems.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了一个使用分而治之来在序列中搜索的示例。在每一步中，二分搜索尝试仅在标记为`range`的序列的一部分中搜索。当找到元素或不再能将`range`进一步分割为更小的部分时，搜索终止。然而，搜索问题与大多数分而治之算法有所不同：在搜索问题中，如果元素可以在序列的较小`range`中找到，则它也一定存在于完整序列中。换句话说，在序列的较小部分中的问题的解决方案给出了整个问题的解决方案。因此，解决方案不需要实现一般分而治之方法的组合步骤。遗憾的是，这种特性并不适用于绝大多数可以使用分而治之方法解决的计算问题。在接下来的部分中，我们将深入探讨并查看更多使用分而治之方法解决问题的示例。
- en: Sorting Using Divide and Conquer
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分而治之进行排序
- en: We shall now explore how to implement the divide-and-conquer approach when it
    comes to solving another standard problem – sorting. The importance of having
    an efficient sorting algorithm cannot be overstated. In the early days of computing
    in the 1960s, computer manufacturers estimated that 25% of all CPU cycles in their
    machines were spent sorting elements of arrays. Although the computing landscape
    has changed significantly over the years, sorting is still widely studied today
    and remains a fundamental operation in several applications. For instance, it
    is the key idea behind indexes in databases, which then allow quick access to
    the stored data using a logarithmic time search, which is similar to binary search.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨如何在解决另一个标准问题——排序时实现分治方法。拥有高效的排序算法的重要性不言而喻。在计算机发展的早期，即20世纪60年代，计算机制造商估计他们机器中25%的CPU周期都用于对数组元素进行排序。尽管多年来计算机领域发生了重大变化，但排序仍然是当今广泛研究的内容，并且仍然是几个应用中的基本操作。例如，它是数据库索引背后的关键思想，然后允许使用对数时间搜索快速访问存储的数据，这类似于二分搜索。
- en: 'The general requirements for an implementation of a sorting algorithm are as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法的一般要求如下：
- en: The implementation should be able to work with any datatype. It should be able
    to sort integers, floating-point decimals, and even C++ structures or classes
    where an order among different elements can be defined.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应该能够处理任何数据类型。它应该能够对整数、浮点小数甚至C++结构或类进行排序，其中不同元素之间可以定义顺序。
- en: The sorting algorithm should be able to handle large amounts of data, that is,
    the same algorithm should work with sizes of data even greater than the main memory
    of a computer.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法应该能够处理大量数据，也就是说，相同的算法应该能够处理甚至大于计算机主存储器的数据大小。
- en: The sorting algorithm should be fast, both asymptotically and in practice.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法应该在理论上和实践中都很快。
- en: While all three listed goals are desirable, in practice, it is hard to achieve
    the second and third objectives simultaneously. The second objective requires
    external sorting, that is, sorting data that does not reside on the main memory
    of a computer. External sorting algorithms can work while holding only a small
    subset of the whole data in memory at any point during execution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有三个列出的目标都是可取的，但在实践中，很难同时实现第二和第三个目标。第二个目标需要外部排序，即对不驻留在计算机主存储器上的数据进行排序。外部排序算法可以在执行期间仅持有整个数据的一个小子集时工作。
- en: 'In this section, we will introduce two sorting algorithms: merge sort and quicksort.
    Merge sort is an external sorting algorithm and, therefore, achieves our second
    objective, while quicksort, as its name suggests, is one of the fastest known
    sorting algorithms in practice and appears as a part of the C++ Standard Library''s
    `std::sort()` function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种排序算法：归并排序和快速排序。归并排序是一种外部排序算法，因此实现了我们的第二个目标，而快速排序，顾名思义，是实践中已知的最快的排序算法之一，并且作为C++标准库的`std::sort()`函数的一部分出现。
- en: Merge Sort
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 归并排序
- en: '**Merge sort** is one of the oldest known sorting algorithms and appeared in
    reports in the late 1940s. The computers of that time had a few hundred bytes
    of main memory and were often used for complex mathematical analyses. Therefore,
    it was crucial for sorting algorithms to be able to work, even when all the data
    to be operated upon could not be held in the main memory. Merge sort solved this
    problem by exploiting a simple idea – sorting a large set of elements is the same
    as sorting a small subset of elements, and then merging the sorted subsets so
    that the increasing or decreasing order of elements is maintained:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**归并排序**是已知的最古老的排序算法之一，出现在20世纪40年代末的报告中。当时的计算机只有几百字节的主存储器，通常用于复杂的数学分析。因此，对于排序算法来说，即使不能将所有要操作的数据都保存在主存储器中，也是至关重要的。归并排序通过利用一个简单的思想解决了这个问题——对一组大量元素进行排序与对一小部分元素进行排序，然后合并排序的子集，以保持元素的递增或递减顺序是相同的：'
- en: '![Figure 4.9: Merge sort](img/C14498_04_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：归并排序](img/C14498_04_09.jpg)'
- en: 'Figure 4.9: Merge sort'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.9：归并排序
- en: The preceding diagram shows an example of sorting an array of integers using
    merge sort. First, the algorithm divides the original array into subarrays until
    each subarray only consists of one element (*steps 1* to *4*). In all the subsequent
    steps, the algorithm merges elements into larger arrays, keeping elements in each
    subarray in increasing order.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了使用归并排序对整数数组进行排序的示例。首先，算法将原始数组分成子数组，直到每个子数组只包含一个元素（*步骤1*至*4*）。在随后的所有步骤中，算法将元素合并到更大的数组中，保持每个子数组中的元素按递增顺序排列。
- en: 'Exercise 19: Merge Sort'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：归并排序
- en: 'In this exercise, we shall implement the merge sort algorithm. The steps are
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将实现归并排序算法。步骤如下：
- en: 'Import the following headers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下头文件：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The C++ code for the merge operation on two vectors is as follows. Write the
    `merge()` function like so:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对两个向量进行合并操作的C++代码如下。编写`merge()`函数如下：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The templatized `merge()` function takes in references to two vectors of type
    `T` and returns a new vector containing the elements in input arrays, but sorted
    in increasing order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模板化的`merge()`函数接受类型为`T`的两个向量的引用，并返回一个包含输入数组中元素的新向量，但按递增顺序排序。
- en: 'We can now use the merge operation to write a recursive merge sort implementation,
    as shown here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用合并操作来编写递归的归并排序实现，如下所示：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following function to print the vector:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数以打印向量：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function allows us to test our implementation of the merge sort
    algorithm:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数允许我们测试归并排序算法的实现：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and run the program. The output should look like the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序。输出应该如下所示：
- en: '![Figure 4.10: Sorting by merge sort](img/C14498_04_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10：归并排序](img/C14498_04_10.jpg)'
- en: 'Figure 4.10: Sorting by merge sort'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.10：归并排序
- en: Our implementation of merge sort in this exercise continues our theme of not
    tying implementations of algorithms to underlying datatypes and relying only on
    the functions exposed by the containers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习中对归并排序的实现延续了我们不将算法实现与底层数据类型绑定并且仅依赖于容器公开的函数的主题。
- en: Quicksort
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速排序
- en: While the goal in the case of merge sort was to sort large amounts of data,
    quicksort tries to reduce the average-case running time. The underlying idea in
    quicksort is also the same as merge sort – divide the original input array into
    smaller subarrays, sort the subarrays, and merge the results to get the sorted
    array. However, the fundamental operation that quicksort uses is **partition**
    and not merge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在归并排序的情况下，目标是对大量数据进行排序，而快速排序试图减少平均情况下的运行时间。快速排序中的基本思想与归并排序相同-将原始输入数组分成较小的子数组，对子数组进行排序，然后合并结果以获得排序后的数组。但是，快速排序使用的基本操作是**分区**而不是合并。
- en: '**Working of the Partition Operation**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区操作的工作原理**'
- en: 'Given an array and a **pivot element**, *P*, in the array, the **partition
    operation** does two things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数组和数组中的**枢轴元素** *P*，**分区操作**执行两件事：
- en: It divides the original array into two subarrays, *L* and *R*, where *L* contains
    all the elements of the given array that are less than or equal to *P*, and *R*
    contains all elements of the given array that are greater than *P*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将原始数组分成两个子数组*L*和*R*，其中*L*包含给定数组中小于或等于*P*的所有元素，*R*包含给定数组中大于*P*的所有元素。
- en: It reorganizes the elements in the array in the order *L*, *P*, *R*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它重新组织数组中的元素顺序*L*，*P*，*R*。
- en: 'The following diagram shows the result of a partition that was applied to an
    unsorted array, with the first element chosen as the pivot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了对未排序数组应用的分区的结果，其中选择了第一个元素作为枢轴：
- en: '![Figure 4.11: Selecting a pivot and partitioning the vector around it](img/C14498_04_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11：选择一个枢轴并围绕它对向量进行分区](img/C14498_04_11.jpg)'
- en: 'Figure 4.11: Selecting a pivot and partitioning the vector around it'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.11：选择一个枢轴并围绕它对向量进行分区
- en: A useful property of the partition operation is that after it is applied, the
    new position of the pivot, *P*, in the vector becomes the position that *P* would
    have if the vector were sorted. For example, the element *5* appears at the 5th
    position in the array after we apply the partition operation, which is the same
    position that element *5* would have been in if the array was sorted in increasing
    order.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 分区操作的一个有用属性是，在应用分区操作后，向量中枢轴*P*的新位置成为向量排序时*P*将具有的位置。例如，元素*5*在应用分区操作后出现在数组的第5个位置，这是元素*5*在数组按递增顺序排序时将出现的位置。
- en: 'The preceding property is also the core idea behind the quicksort algorithm,
    which works as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的属性也是快速排序算法的核心思想，其工作原理如下：
- en: If the input array, *A*, has more than 1 element in it, apply the partition
    operation on *A*. It results in subarrays *L* and *R*.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入数组*A*中有超过1个元素，则在*A*上应用分区操作。它将产生子数组*L*和*R*。
- en: Use *L* as an input to *step 1*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*L*作为*步骤1*的输入。
- en: Use *R* as an input to *step 1*.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*R*作为*步骤1*的输入。
- en: '*Steps 2* and *3* are recursive calls to the partition operation on the arrays
    that are generated by the partition operation and applied to the original input
    array. This simple recursive application of the partition operation results in
    sorting elements in increasing order. Since the quicksort recursion trees can
    quickly become deep, the following diagram shows an example of applying quicksort
    on a small array of six elements, *{5, 6, 7, 3, 1, 9}*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*和*3*是对由分区操作生成的数组进行递归调用，然后应用于原始输入数组。分区操作的简单递归应用导致元素按递增顺序排序。由于快速排序递归树可能会迅速变得很深，因此以下图表显示了在一个包含六个元素的小数组*{5,
    6, 7, 3, 1, 9}*上应用快速排序的示例：'
- en: '![Figure 4.12: Visualization of the quicksort algorithm](img/C14498_04_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12：快速排序算法的可视化](img/C14498_04_12.jpg)'
- en: 'Figure 4.12: Visualization of the quicksort algorithm'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.12：快速排序算法的可视化
- en: Each iteration of the algorithm shows the result of the partition operation
    being applied to the subarrays generated in the previous step using the highlighted
    pivots. It should be noted that our choice of the first element of the array as
    the pivot is arbitrary. Any element of the array can be chosen as the pivot without
    affecting the correctness of the quicksort algorithm.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的每次迭代都显示了对先前步骤中使用突出显示的枢轴应用的分区操作的结果。应该注意，我们将数组的第一个元素作为枢轴的选择是任意的。数组的任何元素都可以被选择为枢轴，而不会影响快速排序算法的正确性。
- en: 'Exercise 20: Quicksort'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习20：快速排序
- en: 'In this exercise, we shall implement and test our implementation of quicksort.
    Let''s get started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将实现并测试快速排序的实现。让我们开始吧：
- en: 'Import the following headers:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下标头：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The C++ code for the partition operation is as follows. Write the `partition()`
    function as shown here:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分区操作的C++代码如下。按照以下所示编写`partition()`函数：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The implementation shown here takes in only the iterators over an underlying
    container object and returns another iterator that points to the index of the
    partition in the array. This means that all the elements of the vector are greater
    than the pivot in the right partition, and all the elements less than or equal
    to the pivot are in the left partition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此处显示的实现仅接受底层容器对象上的迭代器，并返回指向数组中分区索引的另一个迭代器。这意味着向量的所有元素都大于右分区中的枢轴，而小于或等于枢轴的所有元素都在左分区中。
- en: 'The quicksort algorithm uses the partition operation recursively, as shown
    in the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序算法递归使用分区操作，如下所示：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`print_vector()` is used to print a vector to the console and is implemented
    as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print_vector()`用于将向量打印到控制台，并实现如下：'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Adapt the driver code from *Exercise 19*, *Merge Sort*, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据*练习19*，*归并排序*中的驱动程序代码进行调整：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Write a `main()` function that calls `run_quick_sort_test()`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`main()`函数，调用`run_quick_sort_test()`：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Your final output should look as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的最终输出应如下所示：
- en: '![Figure 4.13: Sorting by quicksort](img/C14498_04_13.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：快速排序排序](img/C14498_04_13.jpg)'
- en: 'Figure 4.13: Sorting by quicksort'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：快速排序排序
- en: However, the runtime of quicksort does depend on how "good" our choice of pivot
    is. The best case for quicksort is when the pivot at any step is the median element
    of the current array; in such a case, quicksort is able to partition the elements
    into vectors of equal sizes at each step, and, therefore, the depth of the recursion
    tree is exactly *log(n)*. If the medians are not chosen as pivots, it results
    in an imbalance in the partition sizes and, therefore, a deeper recursion tree
    and greater running time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快速排序的运行时间取决于我们选择的枢轴有多“好”。快速排序的最佳情况是在任何步骤中，枢轴都是当前数组的中位数元素；在这种情况下，快速排序能够将元素分成每一步相等大小的向量，因此，递归树的深度恰好是*log(n)*。如果不选择中位数作为枢轴，会导致分区大小不平衡，因此递归树更深，运行时间更长。
- en: 'The asymptotic complexity of quicksort and merge sort is shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序和归并排序的渐近复杂度如下所示：
- en: '![Figure 4.14: Asymptotic complexity of quicksort and merge sort](img/C14498_04_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14：快速排序和归并排序的渐近复杂度](img/C14498_04_14.jpg)'
- en: 'Figure 4.14: Asymptotic complexity of quicksort and merge sort'
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：快速排序和归并排序的渐近复杂度
- en: 'Activity 9: Partial Sorting'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：部分排序
- en: In the last two exercises, we have implemented **total sorting** algorithms
    that order all the elements of a vector in an increasing (or decreasing) order.
    However, this can be overkill in several problem instances. For example, imagine
    that you are given a vector containing the ages of all humans on earth and are
    asked to find the median age of the oldest 10% of the population.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个练习中，我们实现了**总排序**算法，它按照递增（或递减）顺序对向量的所有元素进行排序。然而，在一些问题实例中，这可能是过度的。例如，想象一下，您得到一个包含地球上所有人的年龄的向量，并被要求找到人口最老的10%的人的中位数年龄。
- en: A naïve solution to this problem is to sort the vector of ages, extract the
    ages of the oldest 10% people from the vector, and then find the median of the
    extracted vector. However, this solution is wasteful as it does far more than
    is strictly needed in order to compute the solution, that is, it sorts the entire
    array to ultimately use only 10% of the sorted array for the required solution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的一个天真的解决方案是对年龄向量进行排序，从向量中提取最老的10%人的年龄，然后找到提取向量的中位数。然而，这种解决方案是浪费的，因为它做的远远超出了计算解决方案所需的，也就是说，它对整个数组进行排序，最终只使用排序数组的10%来计算所需的解决方案。
- en: A better solution to such problems can be derived by specializing the total
    sorting algorithms such as merge sort and quicksort into **partial sorting algorithms**.
    A partial sorting algorithm sorts only a specified number of elements in a given
    vector and leaves the rest of the vector unsorted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对这类问题的更好解决方案可以通过将归并排序和快速排序等总排序算法专门化为**部分排序算法**来得到。部分排序算法只对给定向量中的指定数量的元素进行排序，而将向量的其余部分保持未排序状态。
- en: 'The partial quicksort is described as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 部分快速排序的描述如下：
- en: Assume that we are given a vector, *V*, and we are required to create a sorted
    subvector of *k* elements.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个向量*V*，我们需要创建一个有序的*k*元素的子向量。
- en: Apply the partition operation on *V*, assuming the first element of *V* as the
    pivot (again, this choice is completely arbitrary). The result of the partition
    operation are two vectors, *L* and *R*, where *L* contains all the elements of
    *V* that are less than the pivot and *R* contains all the elements greater than
    the pivot. Also, the new position of the pivot is the "correct" position of the
    pivot in the sorted array.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*V*上应用分区操作，假设*V*的第一个元素作为枢轴（同样，这个选择完全是任意的）。分区操作的结果是两个向量，*L*和*R*，其中*L*包含所有小于枢轴的*V*的元素，*R*包含所有大于枢轴的元素。此外，枢轴的新位置是排序数组中枢轴的“正确”位置。
- en: Use *L* as input to *step 1*.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*L*作为*步骤1*的输入。
- en: If the new position of pivot in *step 2* is less than *k*, use *R* as input
    to *step 1*.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*步骤2*中枢轴的新位置小于*k*，则使用*R*作为*步骤1*的输入。
- en: 'Your task in this activity is to implement the partial quicksort algorithm
    that uses randomly generated arrays to test the output of the algorithm. The final
    output with a vector of size *100* and *k = 100* should look as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本活动中的任务是实现部分快速排序算法，该算法使用随机生成的数组来测试算法的输出。大小为*100*且*k = 100*的向量的最终输出应如下所示：
- en: '![Figure 4.15: Sample output of Activity 9](img/C14498_04_15.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15：活动9的示例输出](img/C14498_04_15.jpg)'
- en: 'Figure 4.15: Sample output of Activity 9'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.15：活动9的示例输出
- en: Note
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 510.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第510页找到。
- en: Linear Time Selection
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性时间选择
- en: In the previous section, we looked at simple examples of algorithms that use
    the divide-and-conquer paradigm and were introduced to the partition and merge
    operations. So far, our view of divide-and-conquer algorithms has been restricted
    to ones that recursively divide each intermediate step into exactly two subparts.
    However, there are certain problems where dividing each step into more subparts
    can yield substantial benefits. In the following section, we shall study one such
    problem – linear time selection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了使用分治范式的简单算法示例，并介绍了分区和合并操作。到目前为止，我们对分治算法的看法局限于那些将每个中间步骤递归地分成两个子部分的算法。然而，有些问题在将每一步分成更多子部分时可以产生实质性的好处。在接下来的部分，我们将研究这样一个问题——线性时间选择。
- en: 'Imagine that you are in charge of organizing a marching band parade for your
    school. To ensure that all the band members look uniform, it is important that
    the heights of students be the same. Moreover, students from all grades are required
    to participate. To solve these problems, you come up with the following solution
    – you will select only the 15th shortest student in every grade to participate
    in the parade. The problem can be formalized as follows: given a randomly ordered
    set of elements, *S*, you are asked to find the *i**th* smallest element in *S*.
    A simple solution could be sorting the input and then selecting the *i**th* element.
    However, the algorithmic complexity of this solution is *O(n log n)*. In this
    section, we will work through a divide-and-conquer solution that solves the problem
    in *O(n)*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你负责为你的学校组织一场游行队伍。为了确保所有乐队成员看起来一致，学生的身高是相同的很重要。此外，要求所有年级的学生都参加。为了解决这些问题，你提出了以下解决方案——你将选择每个年级第15矮的学生参加游行。问题可以形式化如下：给定一个随机排序的元素集*S*，要求你找到*S*中第*i*小的元素。一个简单的解决方案可能是对输入进行排序，然后选择第*i*个元素。然而，这种解决方案的算法复杂度是*O(n
    log n)*。在本节中，我们将通过分治法解决这个问题，其复杂度为*O(n)*。
- en: 'Our solution hinges on using the partition operation correctly. The partition
    operation we introduced in the previous subsection takes in a vector and a pivot,
    and then divides the vector into two parts, one containing all the elements less
    than the pivot and the other containing all the elements greater than the pivot.
    The final algorithm works as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案依赖于正确使用分区操作。我们在上一小节介绍的分区操作接受一个向量和一个枢轴，然后将向量分成两部分，一部分包含所有小于枢轴的元素，另一部分包含所有大于枢轴的元素。最终算法的工作如下：
- en: Assume that we are given an input vector, *V*, and we need to find the *ith*
    smallest element.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个输入向量*V*，我们需要找到第*i*小的元素。
- en: Divide the input vector, *V*, into vectors *V**1*, *V**2*, *V**3*, *…* , *V**n/5*,
    each containing five elements (the last vector can have less than five elements,
    if necessary).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入向量*V*分成向量*V**1*、*V**2*、*V**3*、*…*、*V**n/5*，每个向量包含五个元素（如果需要，最后一个向量可以少于五个元素）。
- en: Next, we sort each *V**i*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对每个*V**i*进行排序。
- en: 'For each *V**i*, find the median, *m**i*, and collect all medians into a set,
    *M*, as shown here:![Figure 4.16: Finding the medians of each subvector](img/C14498_04_16.jpg)'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个*V**i*，找到中位数*m**i*，并将所有中位数收集到一个集合*M*中，如下所示：![图4.16：找到每个子向量的中位数](img/C14498_04_16.jpg)
- en: 'Figure 4.16: Finding the medians of each subvector'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：找到每个子向量的中位数
- en: 'Find the median element, *q*, of *M*:![Figure 4.17: Finding the median of a
    set of medians](img/C14498_04_17.jpg)'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到*M*的中位数元素*q*：![图4.17：找到一组中位数的中位数](img/C14498_04_17.jpg)
- en: 'Figure 4.17: Finding the median of a set of medians'
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：找到一组中位数的中位数
- en: 'Use the partition operation on *V* using *q* as the pivot to get two vectors,
    *L* and *R*:![Figure 4.18: Partitioning the whole vector](img/C14498_04_18.jpg)'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分区操作在*V*上使用*q*作为枢轴得到两个向量*L*和*R*：![图4.18：对整个向量进行分区](img/C14498_04_18.jpg)
- en: 'Figure 4.18: Partitioning the whole vector'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：对整个向量进行分区
- en: 'By the definition of the partition operation, *L* contains all the elements
    less than *q* and *R* contains all the elements greater than *q*. Let''s say *L*
    has *(k – 1)* elements:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据分区操作的定义，*L*包含所有小于*q*的元素，*R*包含所有大于*q*的元素。假设*L*有*(k-1)*个元素：
- en: –  If *i = k*, then *q* is the *i**th* element in *V*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i = k*，那么*q*就是*V*中的第*i*个元素。'
- en: –  If *i < k*, set *V = L* and go to *step 1*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i < k*，则设置*V = L*并转到*步骤1*。'
- en: –  If *i > k*, set *V = R* and *i = i – k*, and go to *step 1*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果*i > k*，则设置*V = R*并*i = i - k*，并转到*步骤1*。'
- en: The following exercise demonstrates the implementation of this algorithm in
    C++.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了在C++中实现此算法。
- en: 'Exercise 21: Linear Time Selection'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：线性时间选择
- en: 'In this exercise, we shall implement the linear time selection algorithm. Let''s
    get started:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现线性时间选择算法。让我们开始吧：
- en: 'Import the following headers:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下头文件：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write the helper function shown here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写如下所示的辅助函数：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In *Exercise 20*, *Quicksort*, our partition function assumed that the first
    element in a given vector was always the pivot to be used. We now need a more
    general form of the partition operation that can work with any pivot element:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*练习20*中，*快速排序*，我们的分区函数假设给定向量中的第一个元素始终是要使用的枢轴。现在我们需要一个更一般的分区操作形式，可以与任何枢轴元素一起使用：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the following code to implement our linear time search algorithm:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码来实现我们的线性时间搜索算法：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the merge sort implementation shown in the following code. We shall use
    the sorting algorithm to demonstrate the correctness of our implementation:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加合并排序实现，如下所示的代码。我们将使用排序算法来证明我们实现的正确性：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, add the following driver and test functions:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下驱动程序和测试函数：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile and run the code. Your final output should look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。你的最终输出应该如下所示：
- en: '![Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection](img/C14498_04_19.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19：使用线性时间选择找到第3、第5和第11个元素](img/C14498_04_19.jpg)'
- en: 'Figure 4.19: Finding the 3rd, 5th, and 11th elements using linear time selection'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：使用线性时间选择找到第3、第5和第11个元素
- en: While a detailed theoretical analysis of the given algorithm is beyond the scope
    of this chapter, the runtime of the algorithm merits some discussion. The basic
    idea why the preceding algorithm works is that every time `linear_time_select()`
    is called with an input, *V*, a partition operation is applied, and the function
    then recursively calls itself on only one of the partitions. At each recursion
    step, the size of the problem reduces by at least 30%. Since finding a median
    of five elements is a constant time operation, the recurrence equation that's
    obtained by the preceding algorithm can be then solved using induction to see
    that the runtime is indeed *O(n)*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对给定算法的详细理论分析超出了本章的范围，但算法的运行时间值得讨论。前面算法为什么有效的基本思想是，每次调用`linear_time_select()`时，都会应用分区操作，然后函数在其中一个分区上递归调用自身。在每个递归步骤中，问题的大小至少减少30%。由于找到五个元素的中位数是一个常数时间操作，因此通过对前面算法得到的递归方程进行归纳，可以看到运行时间确实是*O(n)*。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting property of the linear time selection algorithm is that its well-known
    asymptotic complexity (linear) is achieved when *V* is divided into subvectors
    of five elements each. Finding a constant size of subvectors that results in better
    asymptotic complexity remains an open problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间选择算法的一个有趣特性是，当*V*被分成每个五个元素的子向量时，它的已知渐近复杂度（线性）被实现。找到导致更好渐近复杂度的子向量的恒定大小仍然是一个未解决的问题。
- en: C++ Standard Library Tools for Divide and Conquer
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++标准库工具用于分治
- en: 'In the previous section, we manually implemented the necessary functions for
    divide-and-conquer algorithms. However, the C++ standard library comes bundled
    with a large set of predefined functions that can save us a lot of work when programming.
    The following table provides a handy list of the most commonly used functions
    that are used while implementing algorithms that use the divide-and-conquer paradigm.
    We are briefly describing these functions for reference, but the detailed implementation
    is left out of the scope of this chapter for brevity. Feel free to explore more
    about these functions; you should be able to understand them based on the concepts
    we''ve covered in this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们手动实现了分治算法所需的函数。然而，C++标准库捆绑了一大批预定义函数，可以在编程时节省大量工作。以下表格提供了一个常用函数的便捷列表，这些函数在实现使用分治范例的算法时使用。我们简要描述了这些函数以供参考，但出于简洁起见，详细实现超出了本章的范围。请随意探索更多关于这些函数的信息；基于本章涵盖的概念，您应该能够理解它们。
- en: '![Figure 4.20: Some useful STL functions for algorithms](img/C14498_04_20_1.jpg)![](img/C14498_04_20_2.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20：一些用于算法的有用STL函数](img/C14498_04_20_1.jpg)![](img/C14498_04_20_2.jpg)'
- en: 'Figure 4.20: Some useful STL functions for algorithms'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：一些用于算法的有用STL函数
- en: Dividing and Conquering at a Higher Abstraction Level – MapReduce
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在更高抽象级别上的分治-MapReduce
- en: So far in this chapter, we have looked at divide and conquer as an algorithm
    design technique and used it to solve our problems using a predefined set of divide-conquer-merge
    steps. In this section, we'll take a slight detour and see how the same principle
    of dividing a problem into smaller parts and solving each part separately can
    be particularly helpful when we need to scale software beyond the computational
    power of a single machine and use clusters of computers to solve problems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经将分治作为一种算法设计技术，并使用它来使用预定义的分治合并步骤集来解决我们的问题。在本节中，我们将稍微偏离一下，看看当我们需要将问题分解为较小部分并分别解决每个部分时，相同的分治原则如何在需要将软件扩展到单台计算机的计算能力之外并使用计算机集群来解决问题时特别有帮助。
- en: 'The original **MapReduce** paper starts as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 原始**MapReduce**论文的开头如下：
- en: '*"MapReduce is a programming model and an associated implementation for processing
    and generating large datasets. Users specify a map function that processes a key-value
    pair to generate a set of intermediate key/value pairs, and a reduce function
    that merges all the intermediate values associated with the same intermediate
    key."*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: “MapReduce是一个用于处理和生成大型数据集的编程模型及其相关实现。用户指定一个映射函数，该函数处理键值对以生成一组中间键/值对，以及一个减少函数，该函数合并与相同中间键关联的所有中间值。”
- en: Note
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to the original research paper about the MapReduce model, which
    was published by Jeffrey Dean and Sanjay Ghemawat in 2004, here: [https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf](https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考Jeffrey Dean和Sanjay Ghemawat于2004年发表的有关MapReduce模型的原始研究论文，链接在这里：[https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf](https://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf)。
- en: Since the original paper first appeared, several open source implementations
    of the MapReduce programming model have appeared, the most notable of which is
    Hadoop. Hadoop provides a programming toolkit for the user to write map and reduce
    functions that can be applied to data stored in a distributed filesystem called
    the Hadoop Distributed File System (HDFS). Since HDFS can easily scale up to a
    cluster of several thousand machines connected over a network, MapReduce programs
    are therefore capable of scaling with the size of the cluster.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 自从原始论文首次出现以来，MapReduce编程模型的几个开源实现已经出现，其中最引人注目的是Hadoop。Hadoop为用户提供了一个编程工具包，用户可以编写映射和减少函数，这些函数可以应用于存储在名为Hadoop分布式文件系统（HDFS）中的数据。由于HDFS可以轻松扩展到通过网络连接的数千台机器的集群，因此MapReduce程序能够随着集群的规模而扩展。
- en: In this section, however, we are interested not in Hadoop, but in MapReduce
    as a programming paradigm, and its association with the topic at hand, that is,
    the divide-and-conquer technique. Instead of Hadoop, we will stick to an open
    source single-machine implementation of MapReduce that uses multithreading to
    emulate the original worker model for task parallelization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这一部分，我们对Hadoop不感兴趣，而是对MapReduce作为一种编程范式以及它与手头的主题，即分治技术的关联感兴趣。我们将坚持使用一个使用多线程来模拟任务并行化的开源单机MapReduce实现，而不是Hadoop。
- en: The Map and Reduce Abstractions
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射和减少抽象
- en: The terms *map* and *reduce* have their origins in functional programming languages
    such as Lisp.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*map*和*reduce*这两个术语起源于诸如Lisp之类的函数式编程语言。'
- en: '**Map** is an operation that takes in a container, *C*, and applies a given
    function, *f(x)*, to each element of *C*. An example of using *f(x) = x**2* is
    shown in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**是一个操作，它接受一个容器*C*，并对*C*的每个元素应用给定的函数*f(x)*。下图显示了使用*f(x) = x**2*的示例：'
- en: '![Figure 4.21: Mapping the values of a container](img/C14498_04_21.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21：映射容器的值](img/C14498_04_21.jpg)'
- en: 'Figure 4.21: Mapping the values of a container'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：映射容器的值
- en: '**Reduce** is an operation that aggregates values in a container, *C*, by applying
    a given function, *f(acc, x)*, to each element, *x*, of *C*, and returning a single
    value. This is shown in the following diagram:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少**是一个操作，它通过将给定函数*f(acc, x)*应用于容器*C*的每个元素*x*来聚合值，并返回单个值。下图显示了这一点：'
- en: '![Figure 4.22: Reducing the values of a container](img/C14498_04_22.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22：减少容器的值](img/C14498_04_22.jpg)'
- en: 'Figure 4.22: Reducing the values of a container'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：减少容器的值
- en: The C++ Standard Library contains map and reduce operations, that is, `std::transform()`
    and `std::accumulate()`, respectively (`std::reduce()` is also available in C++
    17).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库包含映射和减少操作，即`std::transform()`和`std::accumulate()`，分别（`std::reduce()`也在C++
    17中可用）。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`std::accumulate()` is a restricted form of the reduce operation that uses
    only the addition function. The newer compilers also provide `std::reduce()`,
    which is more general and can be parallelized.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::accumulate()`是一种只使用加法函数的限制形式的减少操作。更新的编译器还提供了`std::reduce()`，它更通用并且可以并行化。'
- en: The following exercise demonstrates the implementation of MapReduce using the
    C++ Standard Library.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了使用C++标准库实现MapReduce。
- en: 'Exercise 22: Map and Reduce in the C++ Standard Library'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习22：在C++标准库中进行映射和减少
- en: 'In this exercise, we shall see how we can use these functions to further understand
    the map and reduce operations. Let''s get started:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何使用这些函数来进一步理解映射和减少操作。让我们开始吧：
- en: 'Import the following headers:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下头文件：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Begin by creating an array with random elements:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个具有随机元素的数组：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `transform_test()` function randomly generates a vector of a given size
    and applies a transformation, *f(x) = x**2*, to the vector.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transform_test()`函数随机生成给定大小的向量，并将变换*f(x) = x**2*应用于向量。'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following driver code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下驱动程序代码：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compile and run the code. Your output should look as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。您的输出应该如下所示：
- en: '![Figure 4.23: Mapping and reducing an array](img/C14498_04_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23：映射和减少数组](img/C14498_04_23.jpg)'
- en: 'Figure 4.23: Mapping and reducing an array'
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：映射和减少数组
- en: Integrating the Parts – Using a MapReduce Framework
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合部分-使用MapReduce框架
- en: 'To write a program using the MapReduce model, we must be able to express our
    desired computation in a series of two stages: **Map** (also referred to as **Partition**),
    where the program reads the input and creates a set of intermediate *<key,value>*
    pairs, and **Reduce**, where the intermediate *<key,value>* pairs are then combined
    in the required manner to generate the final result. The following diagram illustrates
    this idea:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MapReduce模型编写程序，我们必须能够将我们期望的计算表达为两个阶段的系列：**映射**（也称为**分区**），在这个阶段程序读取输入并创建一组中间*<key,value>*对，以及**减少**，在这个阶段中间*<key,value>*对以所需的方式组合以生成最终结果。以下图表说明了这个想法：
- en: '![Figure 4.24: Generalized MapReduce framework](img/C14498_04_24.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24：通用MapReduce框架](img/C14498_04_24.jpg)'
- en: 'Figure 4.24: Generalized MapReduce framework'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：通用MapReduce框架
- en: The main value that frameworks such as Hadoop add to the MapReduce programming
    model is that they make the map and reduce operations distributed and highly scalable
    so that the computation runs on a cluster of machines and the total time taken
    is reduced.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 像Hadoop这样的框架为MapReduce编程模型增加的主要价值在于，它们使映射和减少操作分布式和高度可扩展，从而使计算在一组机器上运行，并且总共所需的时间减少了。
- en: We shall use the MapReduce framework to execute a sample task in the following
    exercise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MapReduce框架来执行以下练习中的示例任务。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following exercise and activity need the Boost C++ libraries to be installed
    on your system. Follow these links to get the Boost libraries:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的练习和活动需要在您的系统上安装Boost C++库。请按照以下链接获取Boost库：
- en: 'Windows: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Windows：[https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/windows.html)
- en: 'Linux/macOS: [https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/macOS：[https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_71_0/more/getting_started/unix-variants.html)
- en: 'Exercise 23: Checking Primes Using MapReduce'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习23：使用MapReduce检查质数
- en: 'Given a positive integer, *N*, we wish to find out the prime numbers between
    *1* and *N*. In this exercise, we shall see how we can implement this using the
    MapReduce programming model and solve the problem using multiple threads. Let''s
    get started:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个正整数*N*，我们希望找出*1*和*N*之间的质数。在这个练习中，我们将看到如何使用MapReduce编程模型来实现这一点，并使用多个线程解决这个问题。让我们开始吧：
- en: 'Let''s begin by including the required libraries and defining a function to
    check whether a given number is prime using prime factorization:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括所需的库，并定义一个使用质因数分解检查给定数字是否为质数的函数：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following class is used to generate a range of numbers with a given difference
    between consecutive numbers (also called the **step size**):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类用于生成具有给定差值的一系列数字（也称为**步长**）：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following function defines the steps to be performed in the map stage:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数定义了映射阶段要执行的步骤：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s implement the reduce stage:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现减少阶段：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding namespace has three functions: first, it defines a function that
    checks whether a given number is prime; second, it defines a function that generates
    a range of numbers within given bounds; third, it defines the map and reduce tasks.
    The map function, as defined earlier, emits *< k, v >* pairs, where both *k* and
    *v* are of the `long` type, where *k* is *1* if *v* is a prime, and *0* if *v*
    is not a prime number. The reduce function then acts as a filter and outputs *<
    k, v >* pairs only where *k = 1*.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命名空间有三个函数：首先，它定义了一个检查给定数字是否为质数的函数；其次，它定义了一个在给定范围内生成一系列数字的函数；第三，它定义了映射和减少任务。如前所述，映射函数发出*<
    k, v >*对，其中*k*和*v*都是`long`类型，其中*k*如果*v*是质数，则为*1*，如果*v*不是质数，则为*0*。然后，减少函数充当过滤器，仅在*k
    = 1*时输出*< k, v >*对。
- en: 'The following driver code then sets the relevant parameters and starts the
    MapReduce computation:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的驱动代码设置了相关参数并启动了MapReduce计算：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The driver code sets the parameters that are required for the MapReduce framework,
    runs the computation, collects results from the reduce function, and, finally,
    outputs the results.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动代码设置了MapReduce框架所需的参数，运行计算，从减少函数收集结果，最后输出结果。
- en: 'Compile and run the preceding code. Your output should look as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行上述代码。您的输出应如下所示：
- en: '![](img/C14498_04_25.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_04_25.jpg)'
- en: 'Figure 4.25: Calculating prime numbers using the MapReduce framework'
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：使用MapReduce框架计算质数
- en: The main benefit of programming using the MapReduce model is that it results
    in software that is massively scalable. The MapReduce framework we used in this
    exercise was one that only used multithreading on a single machine to achieve
    parallelization. But had it been able to support distributed systems, the same
    code we wrote here could have run on a large cluster of servers, enabling the
    computation to scale to massive sizes. Porting the preceding code to systems such
    as Hadoop is a trivial exercise in Java, but beyond the scope of this book.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MapReduce模型编程的主要好处是它产生了具有极大可扩展性的软件。我们在本练习中使用的MapReduce框架只在单台机器上使用多线程来实现并行化。但是，如果它能够支持分布式系统，我们在这里编写的相同代码可以在大型服务器集群上运行，使计算规模扩展到巨大。将前面的代码移植到Hadoop等系统是Java中的一个微不足道的练习，但超出了本书的范围。
- en: 'Activity 10: Implementing WordCount in MapReduce'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动10：在MapReduce中实现WordCount
- en: In this chapter, we have seen how powerful the idea behind the divide-and-conquer
    technique can be as an exceedingly useful algorithm design technique, as well
    as in providing useful tools to handle large and complex computations. In this
    activity, we shall practice dividing a large problem into smaller parts, solving
    the smaller parts, and merging the subsequent results by using the MapReduce model
    that was presented in the preceding section.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了分治技术背后的强大思想作为一种非常有用的算法设计技术，以及在处理大型和复杂计算时提供有用工具的能力。在这个活动中，我们将练习将一个大问题分解成小部分，解决小部分，并使用前一节中介绍的MapReduce模型合并后续结果。
- en: 'Our problem definition has been taken from the original MapReduce paper, and
    is given as follows: given a set of files containing text, find the frequency
    of each word that appears in the files. For example, let''s say you are given
    two files with the following contents:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题定义来自原始的MapReduce论文，如下所示：给定一组包含文本的文件，找到文件中出现的每个单词的频率。例如，假设您有两个文件，内容如下：
- en: 'File 1:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 文件1：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'File 2:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 文件2：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Considering the input files, our program should output the following result:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑输入文件，我们的程序应该输出以下结果：
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Such problems often arise in indexing workloads, that is, when you are given
    a large corpus of text and are required to index the contents so that subsequent
    searches on the text can be made faster. Search engines such as Google and Bing
    heavily use such indexes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这类问题经常出现在索引工作负载中，也就是说，当您获得大量文本并需要对内容进行索引以便后续对文本的搜索可以更快地进行时。谷歌和必应等搜索引擎大量使用这样的索引。
- en: In this activity, you are required to implement the map and reduce stages of
    the word count problem. Since this involves a significant portion of code that
    is specific to our library, boilerplate code has been provided for you in `mapreduce_wordcount_skeleton.cpp`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您需要实现单词计数问题的映射和减少阶段。由于这涉及到我们库特定的大部分代码，因此在`mapreduce_wordcount_skeleton.cpp`中为您提供了样板代码。
- en: '**Activity Guidelines:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南：**'
- en: 'Read through and understand the given code in `mapreduce_wordcount_skeleton.cpp`.
    You will notice that we need to import the Boost libraries in the header. Another
    thing to note is that the map stage in the given code creates *< k, v >* pairs,
    where *k* is a string and *v* is set to *1*. For example, say your set of input
    files contained a random combination of words, *w**1*, *w**2*, *w**3*, …, *w**n*.
    If so, the map stage should output *< k, 1>* pairs with *k = {w**1**, w**2**,
    w**3**, …, w**n**}*, as illustrated in the following diagram:![Figure 4.26: Mapping
    stage](img/C14498_04_26.jpg)'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读并理解`mapreduce_wordcount_skeleton.cpp`中给定的代码。您会注意到我们需要在头文件中导入Boost库。另一个需要注意的是，给定代码中的映射阶段创建了*<
    k, v >*对，其中*k*是一个字符串，*v*设置为*1*。例如，假设您的输入文件集包含一组随机组合的单词，*w**1*，*w**2*，*w**3*，…，*w**n*。如果是这样，映射阶段应该输出*k,
    1*对，其中*k = {w**1**, w**2**, w**3**, …, w**n**}*，如下图所示：![图4.26：映射阶段](img/C14498_04_26.jpg)
- en: 'Figure 4.26: Mapping stage'
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.26：映射阶段
- en: 'The skeleton code for the map stage looks as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地图阶段的骨架代码如下：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since the map stage of the problem generated *< k, 1 >* pairs, the reduce task
    of our program should now combine the pairs with matching values of *k*, as shown
    here:![Figure 4.27: Reducing stage](img/C14498_04_27.jpg)'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于问题的地图阶段生成了*< k, 1 >*对，我们的程序的减少任务现在应该组合具有匹配*k*值的对，如下所示：![图4.27：减少阶段](img/C14498_04_27.jpg)
- en: 'Figure 4.27: Reducing stage'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.27：减少阶段
- en: 'In the given code, the reduce task accepts two iterators, which can be used
    to iterate over the elements with the same key, that is, all the elements between
    `it` and `ite` are guaranteed to have the same key. Your reduce phase should then
    create a new *< k, v >* pair, with *k* set to the key of the input pairs and *v*
    equal to the number of input pairs:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的代码中，减少任务接受两个迭代器，这些迭代器可用于迭代具有相同键的元素，即，`it`和`ite`之间的所有元素都保证具有相同的键。然后，您的减少阶段应创建一个新的*<
    k, v >*对，其中*k*设置为输入对的键，*v*等于输入对的数量：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You are given a set of test data in `testdata/`. Compile and run your code.
    The output should look as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在`testdata/`中获得一组测试数据。编译并运行您的代码。输出应如下所示：
- en: '![Figure 4.28: Getting the frequency of words in the given input files](img/C14498_04_28.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图4.28：获取给定输入文件中单词的频率](img/C14498_04_28.jpg)'
- en: 'Figure 4.28: Getting the frequency of words in the given input files'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.28：获取给定输入文件中单词的频率
- en: Note
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 514.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第514页找到。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed divide and conquer in two different ways: first
    as an algorithm design paradigm, and then its use in designing other tools that
    help us in scaling our software. We covered some standard divide-and-conquer algorithms
    (merge sort and quicksort). We also saw how simple operations such as **partition**
    underlie the solutions to different problems such as partial sorting and linear
    time selection.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以两种不同的方式讨论了分而治之：首先作为算法设计范式，然后在设计其他帮助我们扩展软件的工具中使用它。我们涵盖了一些标准的分而治之算法（归并排序和快速排序）。我们还看到了简单操作，如**分区**是不同问题的解决方案的基础，例如部分排序和线性时间选择。
- en: An important idea to keep in mind while implementing these algorithms in practice
    is the separation of data structures that hold data from the implementation of
    the algorithm itself. Using C++ templates is often a good way to achieve this
    separation. We saw that the C++ Standard Library comes with a large set of primitives
    that can be used for implementing divide-and-conquer algorithms.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中实施这些算法时要牢记的一个重要思想是将保存数据的数据结构与算法本身的实现分开。使用C++模板通常是实现这种分离的好方法。我们看到，C++标准库配备了一大套原语，可用于实现分而治之算法。
- en: The simplicity of the underlying idea behind divide and conquer makes it an
    incredibly useful tool in solving problems and allows for the creation of parallelization
    frameworks such as MapReduce. We also saw an example of using the MapReduce programming
    model to find prime numbers in a given range.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之背后的基本思想的简单性使其成为解决问题的非常有用的工具，并允许创建诸如MapReduce之类的并行化框架。我们还看到了使用MapReduce编程模型在给定范围内找到质数的示例。
- en: In the next chapter, we shall cover the greedy algorithm design paradigm, which
    results in solutions such as Dijkstra's algorithm to find the shortest paths in
    graphs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍贪婪算法设计范式，这将导致诸如Dijkstra算法在图中找到最短路径的解决方案。
