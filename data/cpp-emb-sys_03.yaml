- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Challenges in Embedded Systems with Limited Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源受限嵌入式系统中的挑战
- en: If you are reading this book, chances are you have a good grasp of embedded
    systems. There are many definitions of embedded systems, and while the following
    may not be the most common, it captures the essence shared by others. **Embedded
    systems** are specialized computing systems for specific use with a limited set
    of responsibilities, in contrast to general-purpose computing systems. Embedded
    systems can be embedded in a larger electronic or mechanical system, or act as
    a standalone device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，那么你很可能对嵌入式系统有很好的了解。嵌入式系统有许多定义，虽然以下定义可能不是最常见的，但它捕捉到了其他定义所共有的本质。**嵌入式系统**是为特定用途而设计的专用计算系统，具有有限的责任范围，与通用计算系统形成对比。嵌入式系统可以嵌入到更大的电子或机械系统中，或者作为独立设备运行。
- en: The line between embedded systems and general-purpose computing devices is sometimes
    blurred. We can all agree that the system that controls a toaster or a pump in
    an airplane is an embedded system. Cellphones and early smartphones were also
    considered embedded systems. Nowadays, smartphones are closer to the definition
    of a general-purpose computing device. In this book, we will focus on firmware
    development using modern C++ on small embedded systems or resource-constrained
    embedded systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统和通用计算设备之间的界限有时是模糊的。我们都可以同意，控制烤面包机或飞机泵的系统是嵌入式系统。手机和早期的智能手机也被认为是嵌入式系统。如今，智能手机更接近通用计算设备的定义。在本书中，我们将专注于使用现代C++在小型嵌入式系统或资源受限的嵌入式系统上进行固件开发。
- en: Resource-constrained embedded systems are often employed in safety-critical
    applications. They have a responsibility to control a process in a timely manner
    and they cannot fail, as failure can mean the loss of human lives. In this chapter,
    we will cover limitations imposed by regulations on software development for safety-critical
    devices and implications for the usage of C++. We will learn how to mitigate these
    concerns.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 资源受限的嵌入式系统通常用于安全关键的应用。它们有责任及时控制一个过程，并且不能失败，因为失败可能意味着人类生命的丧失。在本章中，我们将讨论对安全关键设备软件开发施加的限制以及C++使用的含义。我们将学习如何减轻这些担忧。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Safety-critical and hard real-time embedded systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全关键和硬实时嵌入式系统
- en: Dynamic memory management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存管理
- en: Disabling unwanted C++ features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用不想要的C++特性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features, make sure to select C++23 standard,
    by adding `-std=c++23` in compiler options box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议你在阅读示例时使用编译器探索器([https://godbolt.org/](https://godbolt.org/))。选择GCC作为你的编译器，并针对x86架构。这将允许你看到标准输出（stdio）结果，更好地观察代码的行为。由于我们使用了大量的现代C++特性，请确保选择C++23标准，通过在编译器选项框中添加`-std=c++23`。
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02))。
- en: Safety-critical and hard real-time embedded systems
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全关键和硬实时嵌入式系统
- en: '**Safety-critical embedded systems** are systems whose failure may result in
    damage to property or environment, injury to people, or even a loss of life. Failure
    of these systems is not acceptable. Brakes, steering systems, and airbags in cars
    are good examples of safety-critical systems. The correct functioning of these
    systems is essential for the safe operation of a vehicle.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全关键嵌入式系统**是那些故障可能导致财产或环境损坏、人员受伤甚至生命丧失的系统。这些系统的故障是不可接受的。汽车中的刹车、转向系统和安全气囊是安全关键系统的良好例子。这些系统的正确运行对于车辆的安全运行至关重要。'
- en: Next, we will analyze the real-time requirements of an airbag control unit in
    a car.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分析汽车安全气囊控制单元的实时要求。
- en: Airbag control unit and real-time requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全气囊控制单元和实时要求
- en: Safety-critical embedded systems often impose hard real-time requirements, meaning
    that any missed deadline results in system failure. An **A****irbag Control Unit**
    (**ACU**) collects data from accelerometers and pressure sensors, runs an algorithm
    that processes the collected data, and detects side, front, and rear-end crashes.
    Upon the crash detection, the ACU controls the deployment of different restraint
    systems, including airbags and seat belt tensioners.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安全关键型嵌入式系统通常强制执行严格的实时性要求，这意味着任何错过截止时间都会导致系统故障。**气囊控制单元**（**ACU**）从加速度计和压力传感器收集数据，运行一个处理收集到的数据的算法，并检测侧面、正面和追尾碰撞。在检测到碰撞后，ACU控制不同约束系统的部署，包括气囊和座椅安全带张紧器。
- en: ACU implementations must be resilient to different scenarios, such as malfunctioning
    sensors and electronics. These are mitigated by redundant sensors, comparing data
    from sensors, comparing data against thresholds, and self-tests. Most importantly,
    ACUs need to meet timing requirements, as they have only a couple of milliseconds
    to collect data, make decisions, and initiate deployment of restraint systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ACU的实现必须能够应对不同的场景，例如传感器和电子设备故障。这些问题可以通过冗余传感器、比较传感器数据、比较数据与阈值以及自检来缓解。最重要的是，ACUs需要满足时间要求，因为它们只有几毫秒的时间来收集数据、做出决策并启动约束系统的部署。
- en: The ACU fails if it doesn’t detect a crash on time, but it also fails if it
    deploys restraint systems just a bit too late, as this can do more harm to a driver
    and passengers than if the ACU hadn’t initiated a deployment at all. This is why
    an ACU must meet hard real-time requirements, and when it comes to firmware, this
    means all the worst-case execution times must be predictable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ACU未能及时检测到碰撞，它就会失效，但即使它部署约束系统稍晚一点，也会造成比ACU根本未启动部署更大的伤害给驾驶员和乘客。这就是为什么ACU必须满足严格的实时性要求，而在固件方面，这意味着所有最坏情况的执行时间都必须可预测。
- en: 'The effect of delayed airbag deployment is the subject of many studies concerned
    with injuries caused to occupants. The following extract is part of the conclusion
    from the paper *Study regarding the influence of airbag deployment time on the
    occupant injury level during a frontal vehicle collision*, published at MATEC
    Web of Conferences 184(1):01007, by authors Alexandru Ionut Radu, Corneliu Cofaru,
    Bogdan Tolea, and Dragoș Sorin Dima, outlining results of simulations of delayed
    airbag deployment:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟气囊部署的影响是许多关于乘客受伤的研究的主题。以下摘录是来自论文《关于气囊部署时间对正面车辆碰撞中乘客受伤水平影响的研究》的结论部分，该论文发表在MATEC
    Web of Conferences 184(1):01007上，作者为Alexandru Ionut Radu、Corneliu Cofaru、Bogdan
    Tolea和Dragoș Sorin Dima，概述了延迟气囊部署的模拟结果：
- en: '*“It has been found that by increasing the delay of the airbag deployment time
    in the event of a frontal impact, the probability of injury to the occupant’s
    head increases by up to 46%. Reducing the distance between the occupant’s head
    and the dashboard / steering wheel when the airbag ignites would result in a force
    expansion of the gas that is transmitted to the occupant’s head generating an
    extra acceleration and also throws back the occupant increasing the injury potential
    due to the impact between the head and headrest. Thus, an increase in injury probability
    of 8% was observed in the 0 ms delay of the airbag deployment, while a 100 ms
    delay resulted in a 54% increase in the head acceleration value. So, the role
    of the airbag is reversed, it no longer has the role of cushioning the collision,
    but to generate injuries.”*'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“研究发现，在正面碰撞事件中增加气囊部署时间延迟，乘客头部受伤的概率会增加高达46%。当气囊点燃时，减少乘客头部与仪表盘/方向盘之间的距离会导致气体膨胀力传递到乘客头部，产生额外的加速度，并使乘客向后移动，增加头部与头枕之间的碰撞伤害潜力。因此，在气囊部署延迟为0毫秒时观察到8%的受伤概率增加，而100毫秒的延迟导致头部加速度值增加54%。因此，气囊的作用被逆转，它不再具有缓冲碰撞的作用，而是产生伤害。”*'
- en: 'A graphic illustration of collision and delayed airbag deployment is shown
    in the following figure (source: [https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision](https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision)):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下图（来源：[https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision](https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision)）展示了碰撞和延迟安全气囊部署的图形说明：
- en: '![Figure 2.1 – Crash simulation with delayed restraint system deployment](img/B22402_2_1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 延迟部署约束系统的碰撞模拟](img/B22402_2_1.png)'
- en: Figure 2.1 – Crash simulation with delayed restraint system deployment
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 延迟部署约束系统的碰撞模拟
- en: '*Figure 2**.1* effectively illustrates what happens if an ACU doesn’t meet
    hard real-time requirements and produces delayed results. The figure is taken
    from the paper *Study regarding the influence of airbag deployment time on the
    occupant injury level during a frontal vehicle collision*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.1* 有效说明了如果 ACU 无法满足硬实时要求并产生延迟结果的情况。该图取自论文《关于正面车辆碰撞中安全气囊部署时间对乘员伤害水平影响的研究》。'
- en: 'There are multiple reasons why an ACU may fail and cause no or a delayed deployment:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因可能导致 ACU 失败并导致无延迟或延迟部署：
- en: Sensor malfunctioning
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器故障
- en: Electronics malfunctioning
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子设备故障
- en: Crash detection algorithm failure
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测算法失败
- en: Firmware failure to meet a deadline
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固件未能按时完成任务
- en: Sensors and electronics malfunctioning are mitigated by redundancy, data sanity
    checks, cross-comparison, and startup and runtime self-tests. This puts additional
    stress on firmware and its correct functioning. A crash detection algorithm may
    fail due to a bad model that was built upon, or other factors that are out of
    firmware responsibilities. The firmware’s job is to feed the algorithm with sensors’
    data on time, execute it in a timely manner within a set time window, and act
    based on the output of the algorithm.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过冗余、数据完整性检查、交叉比较、启动和运行时自检来减轻传感器和电子设备故障。这给固件及其正确运行增加了额外的压力。碰撞检测算法可能由于基于不良模型构建或超出固件职责的其他因素而失败。固件的职责是按时向算法提供传感器的数据，在设定的时间窗口内及时执行它，并根据算法的输出采取行动。
- en: Measuring firmware performance and non-determinism
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量固件性能和非确定性
- en: How do we ensure that the firmware will run all functions within imposed real-time
    requirements? We measure it. We can measure different metrics, such as performance
    profiling, response to external events, and A-B timing. Performance profiling
    will tell us in which functions the program spends the most time. Response to
    external events will indicate how much time it takes for a system to respond to
    an external event, such as an interrupt or a message on a communication bus.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保固件将在规定的实时要求内运行所有功能？我们进行测量。我们可以测量不同的指标，例如性能分析、对外部事件的响应和 A-B 定时。性能分析将告诉我们程序在哪些函数上花费了最多时间。对外部事件的响应将表明系统对外部事件（如中断或通信总线上的消息）做出响应所需的时间。
- en: A-B timing and real-time execution
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A-B 定时和实时执行
- en: The most important metric when dealing with real-time requirements is **A-B
    timing**. We measure how long it takes for firmware to execute a program from
    point A to point B. A-B timing can measure a function’s duration, but not necessarily.
    We can use it to measure different things. Going from A to B can take different
    times, based on the state of the system and inputs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 处理实时要求时最重要的指标是 **A-B 定时**。我们测量固件从 A 点到 B 点执行程序所需的时间。A-B 定时可以测量函数的持续时间，但不一定。我们可以用它来测量不同的事情。从
    A 点到 B 点可能需要不同的时间，这取决于系统的状态和输入。
- en: A simple way to make an A-B measurement is toggling a **General Purpose Input
    Output** (**GPIO**) and using an oscilloscope to measure the time between changes
    of a GPIO. It’s a simple solution that works well but doesn’t scale, as we would
    need a GPIO for every function we want to measure or we’d need to measure one
    function at a time. We could also use the internal timer of a **Microcontroller
    Unit (MCU)**to make precise measurements and output that information over a UART
    port. This would require us to utilize a general-purpose timer just for the sake
    of measuring. Most microcontrollers have specialized units for instrumentation
    and profiling.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 进行A-B测量的简单方法是通过切换**通用输入输出**（**GPIO**）并使用示波器测量GPIO变化之间的时间。这是一个简单且效果良好的解决方案，但它不具可扩展性，因为我们可能需要一个GPIO来测量每个我们想要测量的函数，或者我们可能需要一次只测量一个函数。我们还可以使用**微控制器单元（MCU**）的内部定时器进行精确测量，并通过UART端口输出该信息。这需要我们仅为了测量目的而利用通用定时器。大多数微控制器都有专门的仪器和配置文件单元。
- en: 'Some ARM-based microcontrollers have a **Data Watchpoint and Trace** (**DWT**)
    unit. DWT is used for data tracing and system profiling, including the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基于ARM的微控制器具有**数据观察点和跟踪**（**DWT**）单元。DWT用于数据跟踪和系统配置文件分析，包括以下内容：
- en: '**Program Counter** (**PC**) sampling'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）采样'
- en: Cycle counting
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环计数
- en: DWT generates events and outputs them using an **Instrumentation Trace Macrocell**
    (**ITM**) unit. The ITM unit can also be used to output data generated from the
    firmware itself, in the `printf` style. ITM buffers data and sends it over to
    an ITM sink. **Single Wire Output** (**SWO**) can be used as an ITM sink.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: DWT生成事件并通过**仪器跟踪宏单元**（**ITM**）单元输出它们。ITM单元还可以用于输出固件本身生成的数据，以`printf`风格。ITM缓冲数据并将其发送到ITM接收器。**单线输出**（**SWO**）可以用作ITM接收器。
- en: 'We can utilize DWT and ITM for profiling as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样利用DWT和ITM进行配置文件分析：
- en: DWT can generate periodic sampling of the PC and use ITM to send them over SWO.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DWT可以生成PC的周期性采样，并使用ITM将它们通过SWO发送。
- en: On a host machine, we capture and analyze the received data.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机上，我们捕获和分析接收到的数据。
- en: By using a linker map file for our firmware, we can generate the distribution
    of time spent in each of the functions in our program.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为我们固件使用链接器映射文件，我们可以生成程序中每个函数花费时间的分布。
- en: This can help us to see which function takes the most time. It’s not particularly
    useful for A-B timing measurements, but it allows us to see where the program
    spends most of the time without any direct software instrumentation except setting
    up DWT and ITM units.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助我们看到哪个函数花费了最多时间。对于A-B时间测量来说，它并不特别有用，但它允许我们在不直接设置DWT和ITM单元的情况下，看到程序花费最多时间的地方。
- en: Sotware instrumentation with GCC
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GCC进行软件测试
- en: '**GNU Compiler Collection** (**GCC**) supports software instrumentation by
    using the `-finstrument-functions` flag to instrument functions’ entries and exists.
    This inserts `entry` and `exit` calls to each function with the following signature:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU编译器集合**（**GCC**）通过使用`-finstrument-functions`标志来支持软件测试，该标志用于测试函数的入口和退出。这会在每个函数中插入具有以下签名的`entry`和`exit`调用：'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can utilize DWT and ITM in the `__cyg_profile_func_enter` and `__cyg_profile_func_exit`
    functions to send the clock cycle count and analyze it on the host machine to
    make A-B timing measurements. The following is an example of a simplified implementation
    of `entry` and `exit` functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用DWT和ITM在`__cyg_profile_func_enter`和`__cyg_profile_func_exit`函数中发送时钟周期数，并在主机上分析它以进行A-B时间测量。以下是一个简化的`entry`和`exit`函数实现的示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding implementation uses `extern` `"C"` as a linkage language specifier
    for `entry` and `exit` instrumentation functions as they are linked with C libraries
    by the compiler. The example also assumes that `printf` is redirected to use ITM
    as output and that the cycle counter register in DWT is started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现使用`extern` `"C"`作为`entry`和`exit`测试函数的链接语言指定符，因为它们由编译器与C库链接。示例还假设`printf`被重定向以使用ITM作为输出，并且DWT中的周期计数器寄存器已启动。
- en: Another option is to use ITM’s timestamping and send both timestamps and function
    addresses from `entry` and `exit` instrumentation functions. With the help of
    a linker map file, we can then reconstruct the sequence of function calls and
    returns. There are specialized formats for sending traces, such as **Common Trace
    Format** (**CTF**), and desktop tools called **trace viewers** that can allow
    us to streamline software instrumentation. CTF is an open format used to serialize
    an event in a packet with one or more fields. Specialized tools, such as **barectf**
    ([https://barectf.org/docs/barectf/3.1/index.html](https://barectf.org/docs/barectf/3.1/index.html))
    are used to facilitate CTF packet generation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 ITM 的时间戳功能，并从 `entry` 和 `exit` 仪器函数发送时间戳和函数地址。借助链接器映射文件，我们随后可以重建函数调用的顺序和返回。存在用于发送跟踪的专用格式，例如**通用跟踪格式**（**CTF**），以及称为**跟踪查看器**的桌面工具，这些工具可以让我们简化软件仪器化。CTF
    是一种开放格式，用于在数据包中序列化一个事件，该数据包包含一个或多个字段。专用工具，如 **barectf** ([https://barectf.org/docs/barectf/3.1/index.html](https://barectf.org/docs/barectf/3.1/index.html))
    用于简化 CTF 数据包的生成。
- en: Events are described using a **YAML Ain’t Markup Language** (**YAML**) configuration
    file. A simple C library containing trace functions is generated by `barectf`
    using the configuration file. These functions are used in source code in places
    where we want to emit traces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事件使用 **YAML Ain’t Markup Language**（**YAML**）配置文件进行描述。`barectf` 使用配置文件生成一个包含跟踪函数的简单
    C 库。这些函数用于源代码中我们想要发出跟踪的地方。
- en: CTF traces can be sent over different transport layers such as ITM or serial.
    Traces can be analyzed using tools such as Babeltrace ([https://babeltrace.org](https://babeltrace.org))
    and TraceCompass ([https://eclipse.dev/tracecompass](https://eclipse.dev/tracecompass)).
    There are other tools that facilitate trace generation, transfer, and viewing
    such as SEGGER SystemView. On the target side, a small software module provided
    by SEGGER is included to make calls to tracing functions. Traces are sent over
    SEGGER’s **Real Time Transfer** (**RTT**) protocol using SWD and analyzed in SystemView.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CTF 跟踪可以通过不同的传输层发送，例如 ITM 或串行。可以使用工具如 Babeltrace ([https://babeltrace.org](https://babeltrace.org))
    和 TraceCompass ([https://eclipse.dev/tracecompass](https://eclipse.dev/tracecompass))
    分析跟踪。还有其他工具可以简化跟踪生成、传输和查看，例如 SEGGER SystemView。在目标侧，SEGGER 提供了一个小型的软件模块，用于调用跟踪函数。跟踪通过
    SEGGER 的 **实时传输**（**RTT**）协议使用 SWD 发送，并在 SystemView 中进行分析。
- en: We covered some basic approaches to A-B timing. There are more advanced techniques,
    and they often depend on the target capabilities, as there are some more advanced
    tracing units that can be utilized for A-B measurements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 A-B 定时的基本方法。还有更多高级技术，它们通常取决于目标能力，因为有一些更高级的跟踪单元可以用于 A-B 测量。
- en: Determinism vs. Non-Determinism in Firmware
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固件中的确定性与非确定性
- en: If we measure the duration of a function using the A-B timing approach and have
    the same duration and function output for the same inputs, we say that the function
    is **deterministic**. If a function depends on a global state and the measured
    duration is different for the same inputs, we say it is **non-deterministic**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 A-B 定时方法来测量函数的持续时间，并且对于相同的输入具有相同的持续时间和函数输出，我们称该函数是**确定性的**。如果一个函数依赖于全局状态，并且对于相同的输入测量的持续时间不同，我们称它是**非确定性的**。
- en: Default dynamic memory allocators in C++ tend to be non-deterministic. The duration
    of allocation depends on the current global state of the allocator and the complexity
    of the allocating algorithm. We can measure duration for the same inputs with
    different global states, but it is hard to evaluate all possible global states
    and to guarantee the **Worst-Case Execution Time** (**WCET**) with default allocators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的默认动态内存分配器往往是非确定性的。分配的持续时间取决于分配器的当前全局状态和分配算法的复杂性。我们可以使用不同的全局状态对相同的输入进行持续时间测量，但很难评估所有可能的全局状态，并保证使用默认分配器的**最坏情况执行时间**（**WCET**）。
- en: The non-deterministic behavior of dynamic memory allocation is just one problem
    for safety-critical systems. The other problem is that it can fail. If there is
    no more available memory or if the memory is fragmented, then the allocation can
    fail. This is why many safety coding standards such as **Motor Industry Software
    Reliability Association** (**MISRA**) and **Automotive Open System Architecture**
    (**AUTOSAR**) discourage dynamic memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配的非确定性行为是安全性关键系统的一个问题。另一个问题是它可能会失败。如果没有更多的可用内存或内存碎片化，分配可能会失败。这就是为什么许多安全编码标准，如**汽车行业软件可靠性协会**（**MISRA**）和**汽车开放系统架构**（**AUTOSAR**），都反对使用动态内存。
- en: We will explore dynamic memory management implications and safety-critical concerns
    next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨动态内存管理的影响和安全性关键问题。
- en: Dynamic memory management
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存管理
- en: 'The C++ standard defines the following storage durations for objects:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准为对象定义了以下存储持续时间：
- en: '**Automatic storage duration**: Objects with automatic storage duration are
    automatically created and destroyed as the program enters and exits the block
    in which they are defined. These are typically local variables within functions,
    except those declared `static`, `extern`, or `thread_local`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动存储持续时间**：具有自动存储持续时间的对象在程序进入和退出定义它们的代码块时自动创建和销毁。这些通常是函数内的局部变量，除了声明为`static`、`extern`或`thread_local`的变量。'
- en: '**Static storage duration**: Objects with static storage duration are allocated
    when the program starts and deallocated when the program ends. All objects declared
    at the namespace scope (including the global namespace) have this static duration,
    plus those declared with `static` or `extern`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态存储持续时间**：具有静态存储持续时间的对象在程序开始时分配，在程序结束时释放。所有在命名空间作用域内声明的对象（包括全局命名空间）都具有这种静态持续时间，以及使用`static`或`extern`声明的对象。'
- en: '**Thread storage duration**: Introduced in C++11, objects with thread storage
    duration are created and destroyed with the thread in which they are defined,
    allowing each thread to have its own instance of a variable. They are declared
    with the `thread_local` specifier.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程存储持续时间**：在C++11中引入，具有线程存储持续时间的对象与定义它们的线程一起创建和销毁，允许每个线程都有自己的变量实例。它们使用`thread_local`说明符声明。'
- en: '**Dynamic storage duration**: Objects with dynamic storage duration are explicitly
    created and destroyed using dynamic memory allocation functions (`new` and `delete`
    in C++), giving the software developer control over the lifetime of these objects.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态存储持续时间**：具有动态存储持续时间的对象使用动态内存分配函数（在C++中为`new`和`delete`）显式创建和销毁，使软件开发者能够控制这些对象的生命周期。'
- en: 'Dynamic storage gives great flexibility to a software developer, providing
    full control over an object’s lifetime. With great power comes great responsibility.
    Objects are dynamically allocated using the `new` operator and freed using `delete`.
    Every object that is allocated dynamically must be freed exactly once and should
    never be accessed after it has been freed. This is a straightforward rule but
    failing to follow it causes a range of problems, such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 动态存储为软件开发者提供了极大的灵活性，使得他们能够完全控制一个对象的生命周期。权力越大，责任越大。对象使用`new`运算符动态分配，并使用`delete`释放。每个动态分配的对象必须恰好释放一次，并且在释放后不应再被访问。这是一条简单的规则，但未能遵循它会导致一系列问题，例如以下所述：
- en: Memory leaks occur when dynamically allocated memory is not freed properly.
    Over time, this unused memory accumulates potentially exhausting system resources.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当动态分配的内存未被正确释放时，会发生内存泄漏。随着时间的推移，这种未使用的内存会积累，可能耗尽系统资源。
- en: Dangling pointers happen when a pointer still references a memory location that
    has been freed. Accessing such a pointer leads to undefined behavior.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂指针发生在指针仍然引用一个已经被释放的内存位置时。访问这样的指针会导致未定义的行为。
- en: Double free errors occur when memory that has already been freed is deleted
    again, leading to undefined behavior.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已经释放的内存再次被删除时，会发生双重释放错误，导致未定义的行为。
- en: Another problem with dynamic memory management is memory fragmentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存管理中的另一个问题是内存碎片化。
- en: Memory fragmentation
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存碎片化
- en: '**Memory fragmentation** occurs when free memory is divided into small, non-contiguous
    blocks over time, making it difficult or impossible to allocate large blocks of
    memory even when there is enough free memory available in total. There are two
    main types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存碎片化**发生在随着时间的推移，空闲内存被分成小块的非连续块时，即使总共有足够的空闲内存，也难以或无法分配大块内存。主要有两种类型：'
- en: '**External fragmentation**: This happens when there is enough total memory
    available to satisfy an allocation request but no single continuous block is large
    enough due to fragmentation. It’s common in systems where memory allocation and
    deallocation occur frequently, and sizes vary significantly.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部碎片化**：当总内存足够满足分配请求，但由于碎片化而没有足够大的单个连续块时，就会发生这种情况。这在内存分配和释放频繁且大小差异显著的系统中最常见。'
- en: '**Internal fragmentation**: This occurs when allocated memory blocks are larger
    than the requested memory, leading to wasted space within allocated blocks. It
    happens when using allocators that have fixed-size memory blocks or memory pools
    and with allocators designed to give WCET.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部碎片化**：当分配的内存块大于请求的内存时，会导致分配块内的空间浪费。这在使用具有固定大小内存块或内存池的分配器以及旨在提供WCET的分配器时发生。'
- en: 'Memory fragmentation leads to inefficient memory use, reducing the performance
    or preventing further allocations resulting in out-of-memory scenarios, even when
    it appears that sufficient memory is available. Let’s visualize the memory region
    reserved for dynamic memory allocation in the following figure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 内存碎片化导致内存使用效率低下，降低性能或防止进一步分配，即使在看起来有足够内存可用的情况下，也会导致内存不足的情况。让我们在以下图中可视化动态内存分配保留的内存区域：
- en: '![Figure 2.2 – Memory region used for dynamic allocation](img/B22402_2_2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 用于动态分配的内存区域](img/B22402_2_2.png)'
- en: Figure 2.2 – Memory region used for dynamic allocation
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 用于动态分配的内存区域
- en: In *Figure 2**.2*, each block represents a memory unit allocated during the
    allocation process. Empty regions were not allocated, or they were freed using
    the `delete` operator. Even though there is plenty of memory available, if there
    were a request for the allocation of four memory units, the allocation would fail,
    as there are not four continuous memory blocks available due to memory fragmentation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.2*中，每个块代表在分配过程中分配的内存单元。未分配的区域或使用`delete`运算符释放的区域是空的。尽管有足够的内存可用，但如果请求分配四个内存单元，由于内存碎片化而没有四个连续的内存块可用，分配将失败。
- en: Non-deterministic behavior of default memory allocators and out-of-memory scenarios
    are major concerns for safety-critical systems. MISRA and AUTOSAR provide coding
    guidelines for the use of C++ in safety-critical systems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内存分配器的非确定性行为和内存不足的情况是关键安全系统的主要关注点。MISRA和AUTOSAR为在关键安全系统中使用C++提供了编码指南。
- en: MISRA is an organization that provides guidelines for the software developed
    for electronic components used in the automotive industry. It is a collaboration
    between vehicle manufacturers, component suppliers, and engineering consultancies.
    Standards produced by MISRA are also used in aerospace, defense, space, medical,
    and other industries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: MISRA是一个为汽车行业使用的电子组件开发的软件提供指南的组织。它是汽车制造商、组件供应商和工程咨询公司之间的合作。MISRA产生标准也用于航空航天、国防、太空、医疗和其他行业。
- en: AUTOSAR is a global development partnership by automotive manufacturers, suppliers,
    and other companies from the electronics, semiconductor, and software industries.
    AUTOSAR also produces guidelines for the use of C++ in critical and safety-related
    systems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: AUTOSAR是由汽车制造商、供应商以及来自电子、半导体和软件行业的其他公司组成的全球发展伙伴关系。AUTOSAR还制定了关于在关键和安全相关系统中使用C++的指南。
- en: Safety-critical guidelines for dynamic memory management in C++
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中动态内存管理的安全关键指南
- en: 'MISRA C++ 2008, which covers the C++03 standard, prohibits the usage of dynamic
    memory allocation, while AUTOSAR’s *Guidelines for the use of the C++14 language
    in critical and safety-related systems* specifies, among others, the following
    rules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MISRA C++ 2008，它涵盖了C++03标准，禁止使用动态内存分配，而AUTOSAR的*关于在关键和安全相关系统中使用C++14语言的指南*规定了以下规则：
- en: Rule A18-5-5 (required, toolchain, partially automated)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则A18-5-5（必需，工具链，部分自动化）
- en: '“Memory management functions shall ensure the following: (a) deterministic
    behavior resulting with the existence of worst-case execution time, (b) avoiding
    memory fragmentation, (c) avoid running out of memory, (d) avoiding mismatched
    allocations or deallocations, (e) no dependence on non-deterministic calls to
    kernel.”'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “内存管理函数应确保以下内容：（a）存在最坏情况执行时间的结果，具有确定性行为，（b）避免内存碎片化，（c）避免内存耗尽，（d）避免不匹配的分配或释放，（e）不依赖于内核的非确定性行为调用。”
- en: Rule A18-5-6 (required, verification / toolchain, non-automated)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则A18-5-6（必需，验证/工具链，非自动化）
- en: '“An analysis shall be performed to analyze the failure modes of dynamic memory
    management. In particular, the following failure modes shall be analyzed: (a)
    non-deterministic behavior resulting with nonexistence of worst-case execution
    time, (b) memory fragmentation, (c) running out of memory, (d) mismatched allocations
    and deallocations, (e) dependence on non-deterministic calls to kernel.”'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “应进行一项分析，以分析动态内存管理的故障模式。特别是，应分析以下故障模式：(a)由于不存在最坏情况执行时间而产生的非确定性行为，(b)内存碎片化，(c)内存耗尽，(d)分配和释放不匹配，(e)依赖于对内核的非确定性调用。”
- en: Now, following these two rules to the letter is an extremely hard task. We can
    write a custom allocator that has deterministic WCET and minimizes fragmentation,
    but how do we write an allocator that avoids running out of memory? Or, in case
    it happens, how do we ensure the non-failure of the system? Every call to the
    allocator would need to verify the success of the operation and, in case of failure,
    somehow mitigate it. Or we would need to be able to estimate the amount of memory
    needed for an allocator accurately, so it doesn’t run out of memory in runtime
    under any circumstances. This adds a whole new layer of complexity to our software
    design and adds more complexity than we would add value by allowing dynamic memory
    allocation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在严格遵循这两条规则是一项极其困难的任务。我们可以编写一个具有确定WCET（最坏情况执行时间）并最小化碎片化的自定义分配器，但如何编写一个避免内存耗尽的分配器？或者，如果发生这种情况，我们如何确保系统的非故障？每次调用分配器都需要验证操作的成功，并在失败的情况下，以某种方式减轻其影响。或者我们需要能够准确估计分配器所需的内存量，以确保在任何情况下都不会在运行时耗尽内存。这给我们的软件设计增加了全新的复杂性，并且比通过允许动态内存分配增加的复杂性还要多。
- en: An in-between approach to dynamic memory allocation policy is to allow it on
    startup, but not when the system is running. This is the policy used by **Joint
    Strike Fighter Air Vehicle C++ Coding Standards**. MISRA C++ 2023 also advises
    against the usage of dynamic memory allocation when the system is running, and
    as a mitigation policy, recommends using it at startup.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配策略的一种折中方法是允许在启动时使用，但在系统运行时不允许。这是**联合攻击战斗机空中车辆C++编码标准**所使用的策略。MISRA C++
    2023也建议在系统运行时不要使用动态内存分配，并作为缓解策略，建议在启动时使用。
- en: The C++ standard library uses dynamic memory allocation heavily. Exception handling
    mechanism implementations also often use dynamic allocation. Before dismissing
    the idea of using the standard library in embedded projects, let’s discover the
    internal workings of the `std::vector` container and see what C++ offers to mitigate
    our concerns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库大量使用动态内存分配。异常处理机制实现也经常使用动态分配。在放弃在嵌入式项目中使用标准库的想法之前，让我们发现`std::vector`容器的工作原理，并看看C++提供了什么来缓解我们的担忧。
- en: Dynamic memory management in the C++ standard library
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++标准库中的动态内存管理
- en: We introduced `std::vector` as a container from the standard library that uses
    dynamic memory allocation. `vector` is a template class, and we can specify the
    underlying type. It stores the elements contiguously, and we can get direct access
    to the underlying contiguous storage using the `data` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了`std::vector`作为标准库中的一个使用动态内存分配的容器。`vector`是一个模板类，我们可以指定底层类型。它连续存储元素，我们可以使用`data`方法直接访问底层的连续存储。
- en: 'The following code example demonstrates the usage of a vector:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了向量的使用：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created a vector with the underlying `uint8_t` type and added values from
    `0` to `8` using the `push_back` method. The example also demonstrates access
    to a pointer to the underlying contiguous storage, which we provided as an argument
    to the `print_array` lambda.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个以`uint8_t`为底层类型的向量，并使用`push_back`方法添加了从`0`到`8`的值。示例还演示了对底层连续存储的指针的访问，我们将它作为参数传递给了`print_array`
    lambda。
- en: 'The usual allocation strategy of `vector` is to allocate one element on the
    first insertion, then double it each time it reaches its capacity. Storing values
    for `0` to `8` would result in 4 allocation requests, as shown in the following
    figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`的通常分配策略是在第一次插入时分配一个元素，然后每次达到其容量时加倍。存储从`0`到`8`的值将导致4个分配请求，如下面的图所示：'
- en: '![Figure 2.3 – Vector allocation requests](img/B22402_2_3.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 向量分配请求](img/B22402_2_3.png)'
- en: Figure 2.3 – Vector allocation requests
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 向量分配请求
- en: '*Figure 2**.3* depicts the vector’s allocation requests. In order to inspect
    vector implementation on any platform, we can overload the `new` and `delete`
    operators and monitor the allocation requests:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.3* 描述了向量的分配请求。为了检查任何平台的向量实现，我们可以重载 `new` 和 `delete` 运算符并监控分配请求：'
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `new` overloaded operator passes allocation calls to `malloc`, and it prints
    out the size requested by the caller. The `delete` overloaded operator just prints
    out the function signature so we can see when it is called. Some standard library
    implementations using GCC implement the `new` operator using `malloc`. Our vector
    allocation calls will result in the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 重载运算符将分配调用传递给 `malloc`，并打印出调用者请求的大小。`delete` 重载运算符仅打印出函数签名，以便我们可以看到它何时被调用。一些使用
    GCC 的标准库实现使用 `malloc` 实现了 `new` 运算符。我们的向量分配调用将产生以下输出：'
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding results are obtained using the GCC compiler, and they are the
    same both for x86_64 and Arm Cortex-M4 platforms. When the vector fills the available
    memory, it requests allocation of the doubled amount of currently used memory.
    It then copies data from the original storage to newly acquired memory. Afterward,
    it deletes previously used storage, as we can see from the preceding generated
    output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结果使用 GCC 编译器获得，对于 x86_64 和 Arm Cortex-M4 平台都是相同的。当向量填满可用内存时，它将请求分配当前使用内存的两倍数量。然后，它将数据从原始存储复制到新获得的内存中。之后，它删除之前使用的存储，正如我们从前面的生成输出中可以看到的那样。
- en: Overloading the `new` and `delete` operators would allow us to change the allocation
    mechanism globally, in order to meet the safety-critical guidelines requesting
    for deterministic WTEC and avoiding out-of-memory scenarios, which is quite challenging.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重载 `new` 和 `delete` 运算符将允许我们全局地改变分配机制，以满足要求确定性的 WTEC 和避免内存不足场景的安全关键指南，这相当具有挑战性。
- en: 'The allocation requests from the vector can be optimized by using the `reserve`
    method if the number of elements is known beforehand:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事先知道元素的数量，可以通过使用 `reserve` 方法优化向量的分配请求：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the `reserve` method will make the vector request eight elements, and
    it will ask for more memory only if we go beyond eight elements. This makes it
    useful for projects that allow dynamic allocation at startup if we can guarantee
    that the number of elements at any point will stay within reserved memory. If
    we add a ninth element to the vector, it will make another allocation request,
    requesting the memory to fit 16 elements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `reserve` 方法将使向量请求八个元素，并且只有当我们超出八个元素时，它才会请求更多内存。这使得它对于在启动时允许动态分配，并且我们可以保证在任何时刻元素的数量都将保持在预留内存内的项目非常有用。如果我们向向量中添加第九个元素，它将进行另一个分配请求，请求足以容纳
    16 个元素的内存。
- en: 'The C++ standard library also makes possible usage of local allocators for
    containers. Let’s take a look at the vector’s declaration:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库还使得容器可以使用局部分配器。让我们看看向量的声明：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that the second template parameter is `Allocator`, and the default
    argument is `std::allocator`, which uses the `new` and `delete` operators. C++17
    introduced `std::pmr::polymorphic_allocator`, an allocator that exhibits different
    allocation behavior depending upon the `std::pmr::memory_resource` type from which
    it is constructed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第二个模板参数是 `Allocator`，默认参数是 `std::allocator`，它使用 `new` 和 `delete` 运算符。C++17
    引入了 `std::pmr::polymorphic_allocator`，这是一个根据其构建的 `std::pmr::memory_resource` 类型表现出不同分配行为的分配器。
- en: 'There is a memory resource that can be constructed by providing it with an
    initial, statically allocated buffer, and it’s called `std::pmr::monotonic_buffer_resource`.
    The monotonic buffer is built for performance, and it releases memory only when
    it is destroyed. Initializing it with a statically allocated buffer makes it suitable
    for embedded applications. Let’s see how we can use it for a vector:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过提供一个初始的静态分配的缓冲区来构建一个内存资源，它被称为 `std::pmr::monotonic_buffer_resource`。单调缓冲区是为了性能而构建的，并且仅在它被销毁时释放内存。使用静态分配的缓冲区初始化它使其适合嵌入式应用。让我们看看我们如何使用它来创建一个向量：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们做了以下操作：
- en: Create a `std::array` container, with an underlying type of `uint8_t`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `std::array` 容器，其底层类型为 `uint8_t`。
- en: Construct a monotonic buffer and provide it with the array we just created as
    the initial buffer.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个单调缓冲区，并为其提供我们刚刚创建的数组作为初始缓冲区。
- en: Use the monotonic buffer to create a polymorphic allocator, which we use to
    create a vector.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单调缓冲区创建一个多态分配器，我们用它来创建一个向量。
- en: 'Please note that the vector is from the `std::pmr` namespace, and it’s just
    a partial specialization of `std::vector`, as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该向量来自`std::pmr`命名空间，它只是`std::vector`的部分特化，如下所示：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A vector created by utilizing a monotonic buffer will allocate memory in the
    space provided by the buffer. Let’s examine the behavior of such a vector in the
    following example built from the previously explained code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 利用单调缓冲区创建的向量将在缓冲区提供的空间中分配内存。让我们通过以下示例来检查此类向量的行为，该示例由之前解释的代码构建而成：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding program will provide the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将提供以下输出：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see that even though we used the monotonic buffer, the program called the
    `new` operator. You can notice that the call to the `reserve` method is commented.
    This will result in a vector-expanding strategy, as described previously. When
    the monotonic buffer initial memory is used, it will fall to the upstream memory
    resource pointer. The default upstream memory resource will use the `new` and
    `delete` operators.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，尽管我们使用了单调缓冲区，程序仍然调用了`new`运算符。您会注意到对`reserve`方法的调用被注释掉了。这将导致向量扩展策略，如之前所述。当单调缓冲区的初始内存被使用时，它将退回到上游内存资源指针。默认的上游内存资源将使用`new`和`delete`运算符。
- en: 'If we print the buffer used as initial storage for `monotonic_buffer_resource`,
    we can see that the vector is allocating the first element and storing `0` to
    it, then it doubles it and stores `0` and `1`, and then doubles it again, storing
    `0`, `1`, `2`, and `3`. When it tries to double it again, the monotonic buffer
    will not be able to meet the allocation request and will fall to using the default
    allocator, which relies on the `new` and `delete` operators. We can visualize
    this in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印用作`monotonic_buffer_resource`初始存储的缓冲区，我们可以看到向量正在分配第一个元素并将`0`存储到其中，然后将其翻倍并存储`0`和`1`，然后再次翻倍，存储`0`、`1`、`2`和`3`。当它尝试再次翻倍时，单调缓冲区将无法满足分配请求，并将退回到使用默认分配器，该分配器依赖于`new`和`delete`运算符。我们可以在以下图中可视化这一点：
- en: '![Figure 2.4 – State of the buffer used by the monotonic buffer resource](img/B22402_2_4.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 单调缓冲区资源使用的缓冲区状态](img/B22402_2_4.png)'
- en: Figure 2.4 – State of the buffer used by the monotonic buffer resource
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 单调缓冲区资源使用的缓冲区状态
- en: '*Figure 2**.4* depicts the internal state of the used by the monotonic buffer
    resource. We can see that the monotonic buffer resource is not deallocating memory
    in any way. On an allocation buffer request, it returns a pointer to the last
    available element in the initial buffer if there is enough space in the buffer
    to fit the requested number of elements.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.4* 描述了单调缓冲区资源使用的内部状态。我们可以看到，单调缓冲区资源没有以任何方式释放内存。在分配缓冲区请求时，如果缓冲区中有足够的空间来容纳请求的元素数量，它将返回初始缓冲区中最后一个可用元素的指针。'
- en: You will notice that the `new` operator used in this example has a different
    signature from the one previously used. Actually, the standard library defines
    different versions of `new` and matching `delete` operators, and it’s hard to
    tell which version is used by a container from the standard library without inspection.
    This makes overloading them globally and replacing implementation with a custom
    one even more challenging, making a local allocator usually a better choice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在此示例中使用的`new`运算符的签名与之前使用的不同。实际上，标准库定义了不同版本的`new`和匹配的`delete`运算符，并且没有检查很难确定标准库容器使用的是哪个版本。这使得全局重载它们并替换实现为自定义版本变得更加具有挑战性，使得局部分配器通常是一个更好的选择。
- en: The polymorphic allocator utilizing a monotonic buffer initialized with a buffer
    on the stack may be a good option to mitigate some of the issues imposed by the
    dynamic memory management when working with containers from the standard C++ library.
    The approach we demonstrated on the vector can be used on other containers from
    standard libraries, such as `list` and `map`, but also other types from the library,
    such as `basic_string`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在栈上初始化的缓冲区作为单调缓冲区的多态分配器可能是一个减轻在处理标准C++库中的容器时动态内存管理强加的一些问题的好选项。我们在向量上展示的方法可以用于标准库中的其他容器，例如`list`和`map`，也可以用于库中的其他类型，例如`basic_string`。
- en: Mitigating concerns of dynamic memory allocation is possible but it still poses
    some challenges. If you want to be absolutely sure that your C++ program is not
    calling a `new` operator, there are means to ensure it. Let us explore how we
    can disable unwanted C++ features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解动态内存分配的担忧是可能的，但它仍然带来了一些挑战。如果你想要绝对确定你的C++程序没有调用`new`运算符，有方法可以确保这一点。让我们探索我们如何禁用不想要的C++功能。
- en: Disabling unwanted C++ features
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用不想要的C++功能
- en: You may have noticed that we used `printf` from the C standard library for printing
    debug information on standard output instead of `std::cout` from the C++ standard
    library. The reason is twofold – the implementation of the `std::cout` global
    object from `ostream` has a large memory footprint and it uses dynamic memory
    allocation. C++ works well with the C standard library, and using `printf` is
    a good alternative for resource-constrained systems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们使用C标准库中的`printf`在标准输出上打印调试信息，而不是使用C++标准库中的`std::cout`。原因有两个——`std::cout`全局对象的实现有一个很大的内存占用，并且它使用动态内存分配。C++与C标准库很好地协同工作，使用`printf`是资源受限系统的良好替代方案。
- en: We already discussed the exception handling mechanism, which often relies on
    dynamic memory allocation. Disabling exceptions in C++ is as easy as passing the
    appropriate flag to the compiler. In the case of GCC, that flag is `–fno-exceptions`.
    The same goes for **Run-Time Type Information** (**RTTI**). We can disable it
    with the `–fno-rtti` flag.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了异常处理机制，它通常依赖于动态内存分配。在C++中禁用异常就像向编译器传递适当的标志一样简单。在GCC的情况下，该标志是`–fno-exceptions`。对于**运行时类型信息**（**RTTI**）也是如此。我们可以使用`–fno-rtti`标志来禁用它。
- en: 'Disabling exceptions will result in calling `std::terminate` when an exception
    is thrown. We can replace the default terminate handler with our own implementation
    and handle it appropriately, as shown in the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用异常将在抛出异常时调用`std::terminate`。我们可以用我们自己的实现替换默认的终止处理程序，并适当地处理它，如下面的例子所示：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding example demonstrates setting the terminate handler using `std::set_terminate`
    by our own implementation. This allows us to handle cases that shouldn’t happen
    in runtime and try to recover from them or gracefully terminate them. Some features
    or behaviors in C++ can’t be disabled by compiler flags, but there are other means
    to handle them,
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了如何通过我们自己的实现使用`std::set_terminate`来设置终止处理程序。这允许我们处理在运行时不应发生的情况，并尝试从中恢复或优雅地终止它们。C++中的一些功能或行为不能通过编译器标志禁用，但还有其他方法来处理它们，
- en: 'As we saw previously, we can redefine global `new` and `delete` operators.
    We can also delete them, which will make the compilation fail if we use a software
    component that calls `new`, effectively allowing us to prevent any attempts of
    dynamic memory allocation if needed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以重新定义全局`new`和`delete`运算符。我们还可以删除它们，如果在调用`new`的软件组件中使用，这将导致编译失败，从而有效地防止任何需要的动态内存分配尝试：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding example will fail with the following compiler message (among
    others):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子将因以下编译器消息（以及其他消息）而失败：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By deleting `new` operators, we can make the compilation of a C++ program that
    is trying to use dynamic memory management fail. This is useful if we want to
    be sure our program is not using dynamic memory management.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除`new`运算符，我们可以使尝试使用动态内存管理的C++程序的编译失败。如果我们想要确保我们的程序没有使用动态内存管理，这很有用。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: C++ allows a great degree of flexibility. Resource-constrained embedded systems
    and safety-critical guidelines can impose some limitations on the usage of certain
    C++ features, such as exception handling, RTTI, and the usage of dynamic memory
    allocation by containers and other modules from the standard C++ library. C++
    acknowledges those concerns and provides mechanisms for disabling unwanted features.
    In this chapter, we learned about different strategies for mitigating concerns
    of dynamic memory allocation by means of local allocators and overloading global
    `new` and `delete` operators.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许极大的灵活性。资源受限的嵌入式系统和安全关键性指南可以对某些C++功能的用法施加一些限制，例如异常处理、RTTI以及标准C++库中容器和其他模块使用动态内存分配。C++承认这些担忧，并提供机制来禁用不想要的特性。在本章中，我们学习了通过本地分配器和重载全局`new`和`delete`运算符来缓解动态内存分配担忧的不同策略。
- en: The learning curve is steep but worth the effort, so let’s continue our journey
    of discovering C++ in embedded systems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 学习曲线陡峭，但值得付出努力，因此让我们继续我们的旅程，探索嵌入式系统中的C++。
- en: In the next chapter, we will explore the C++ ecosystem for embedded development.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨嵌入式开发中的 C++ 生态系统。
