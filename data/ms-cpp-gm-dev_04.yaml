- en: Building the Asset Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建资产流水线
- en: 'Games are essentially a collection of assets or content packaged in a fun and
    engaging way. Handling all the needed content for a video game can be a large
    challenge in itself. Having a structure in place to import, convert, and consume
    these assets is a necessity in any real project. In this chapter, we are going
    to explore the topic of developing and implementing an asset pipeline. The following
    are the topics we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏本质上是以有趣和引人入胜的方式打包的资产或内容的集合。处理视频游戏所需的所有内容本身就是一个巨大的挑战。在任何真正的项目中，都需要一个结构来导入、转换和使用这些资产。在本章中，我们将探讨开发和实施资产流水线的主题。以下是我们将要涵盖的主题：
- en: Handling audio
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理音频
- en: Working with images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理图像
- en: Importing model meshes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模型网格
- en: What is an asset pipeline?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是资产流水线？
- en: In [Chapter 3](00070916-c402-4eb3-88d6-f3e02a4d8455.xhtml), *Building a Strong
    Foundation*, we took a look at how we can use the structure of helper and manager
    classes to wrap multiple methods into an easy to consume interface to work with
    various pieces of the project. We are going to use these techniques throughout
    the next few sections to build our own custom framework/content pipeline.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](00070916-c402-4eb3-88d6-f3e02a4d8455.xhtml)中，*构建坚实的基础*，我们看了一下如何使用辅助和管理类的结构，将多个方法封装成易于消费的接口，以处理项目的各个部分。在接下来的几节中，我们将使用这些技术来构建我们自己的自定义框架/内容流水线。
- en: Handling audio
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理音频
- en: 'To get started, we are going to ease ourselves into the process, by looking
    at how to handle audio assets in our game projects. To help us with the process
    we are going to again use a helper library. There are literally hundreds of different
    libraries to help with the use of audio. Some of the more popular choices are
    listed here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将通过查看如何处理游戏项目中的音频资产来逐步进入这个过程。为了帮助我们进行这个过程，我们将再次使用一个辅助库。有数百种不同的库可以帮助使用音频。以下是一些较受欢迎的选择：
- en: FMOD ([http://www.fmod.org](http://www.fmod.org/))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FMOD ([http://www.fmod.org](http://www.fmod.org/))
- en: Wwise ([https://www.audiokinetic.com/products/wwise/](https://www.audiokinetic.com/products/wwise/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wwise ([https://www.audiokinetic.com/products/wwise/](https://www.audiokinetic.com/products/wwise/))
- en: XAudio2 ([https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAudio2 ([https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx))
- en: OpenAL ([https://www.openal.org/](https://www.openal.org/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAL ([https://www.openal.org/](https://www.openal.org/))
- en: SDL_mixer ([https://www.libsdl.org/projects/SDL_mixer/](https://www.libsdl.org/projects/SDL_mixer/))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL_mixer ([https://www.libsdl.org/projects/SDL_mixer/](https://www.libsdl.org/projects/SDL_mixer/))
- en: Each library has its own strengths and weaknesses. Choosing the right one for
    your project boils down to a few different questions you should ask yourself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有其自身的优势和劣势。为您的项目选择合适的库归结为您应该问自己的几个不同问题。
- en: Does this library meet your technical needs? Does it have all the features you
    want?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是否满足你的技术需求？它是否具有你想要的所有功能？
- en: Does it meet the project's budget constraints? A lot of the more robust libraries
    have a large price tag.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否符合项目的预算限制？许多更强大的库都有很高的价格标签。
- en: Is this library's learning curve within your own, or team's, skill range? Picking
    an advanced API with a bunch of cool features might seem like a good idea, but
    if you spend more time trying to understand the API than implementing it, that
    could be detrimental.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的学习曲线是否在你或团队的技能范围内？选择一个带有许多酷炫功能的高级API可能看起来是个好主意，但如果你花费更多时间来理解API而不是实施它，那可能是有害的。
- en: For the examples in this book, I chose to use `SDL_mixer API` for a few reasons.
    First, it is fairly easy to get started with, compared to some of the others.
    Second, it matches my project's needs very well. It has support for FLAC, MP3,
    and even Ogg Vorbis files. Third, it connects well with the rest of the project's
    framework since it is an extension to the SDL library we are already using. Lastly,
    I chose this API because it is open source and has a simple license that does
    not require me to pay the creator a share of my game's proceeds in return for
    using the library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我选择使用`SDL_mixer API`有几个原因。首先，与其他一些库相比，它相对容易上手。其次，它非常符合我的项目需求。它支持FLAC、MP3，甚至Ogg
    Vorbis文件。第三，它与项目框架的其余部分连接良好，因为它是SDL库的扩展，而我们已经在使用。最后，我选择这个API是因为它是开源的，而且有一个简单的许可证，不需要我支付创建者我的游戏收益的一部分来使用该库。
- en: Let's start by taking a look at the declaration and implementation of a few
    different classes we will need. The file we are looking at is the `AudioManager.h` file
    that can be found in the `Chapter04` folder of the code repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们需要的几个不同类的声明和实现。我们要看的文件是`AudioManager.h`文件，可以在代码库的`Chapter04`文件夹中找到。
- en: 'We begin with the necessary includes, the `SDL/SDL_mixer.h`, `string`, and
    `map` implementations. Like all other engine components, we have been building,
    we wrap these declarations in the `BookEngine` namespace:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从必要的包含开始，`SDL/SDL_mixer.h`，`string`和`map`的实现。与所有其他引擎组件一样，我们将这些声明封装在`BookEngine`命名空间中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the `"AudioManager.h"` file, we have the declaration of a few helper
    classes. The first one is the `SoundEffect` class. This class defines the structure
    of the sound effect object to be used in our game:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`"AudioManager.h"`文件中，我们声明了一些辅助类。第一个是`SoundEffect`类。这个类定义了游戏中要使用的音效对象的结构：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These can include sounds like the player jumping, weapon fire, and really anything
    we will play in a short burst.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以包括玩家跳跃、武器开火等声音，以及我们将在短暂时间内播放的任何声音。
- en: Inside the class definition, we need a `friend` class statement that will allow
    this class access to the `AudioManager` class methods and variables, including
    private ones. Next we have the definition of the `Play` function. This function
    will simply play the sound effect and take just one argument, the number of times
    to loop through the sound. By default, we set this to `0`, if you pass `-1` as
    the number of loops it will set the sound effect to loop indefinitely. The last
    definition is for a private variable of type `Mix_Chunk`. `Mix_Chunk` is a `SDL_mixer`
    object type that stores the audio data in memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义内部，我们需要一个`friend`类语句，允许这个类访问`AudioManager`类的方法和变量，包括私有的。接下来是`Play`函数的定义。这个函数将简单地播放音效，并只接受一个参数，循环播放声音的次数。默认情况下，我们将其设置为`0`，如果您将循环次数设置为`-1`，它将无限循环播放音效。最后一个定义是一个`Mix_Chunk`类型的私有变量。`Mix_Chunk`是一个`SDL_mixer`对象类型，它在内存中存储音频数据。
- en: 'The `Mix_Chunk` object structure is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mix_Chunk`对象的结构如下：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are the internals of the object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对象的内部：
- en: '`allocated`: If this is set to `1`, `struct` has its own allocated buffer'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allocated`：如果设置为`1`，`struct`有自己的分配缓冲区'
- en: '`abuf`: This is a pointer to the audio data'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abuf`：这是指向音频数据的指针'
- en: '`alen`: This is the length of the audio data, in bytes'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alen`：这是音频数据的长度，以字节为单位'
- en: '`volume`: This is a per sample volume value between 0 and 128'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：这是每个样本的音量值，介于0和128之间'
- en: 'The next helper class we have in the `AudioManager.h` file is the `Music` class.
    Like the sound effect, the `Music` class defines the structure of a `Music` object.
    This can be used for sounds like the loading screen music, background music, and
    really any sound we wish to play for an extended time or will need to stop, start,
    and pause:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AudioManager.h`文件中的下一个辅助类是`Music`类。像音效一样，`Music`类定义了`Music`对象的结构。这可以用于像加载屏幕音乐、背景音乐和任何我们希望长时间播放或需要停止、开始和暂停的声音：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the class definition, we again start with a `friend` class statement so
    that the `Music` class will have access to the needed parts of the `AudioManager`
    class. Next we have a `Play` function, and just like the `SoundEffect` class,
    it takes a single argument to set the amount of loops the sound will go through.
    After the `Play` function, we have three more functions, `Pause()`, `Stop()`,
    and `Resume()` function. These three functions are just wrappers to the underlining
    SDL_mixer API calls, for pausing, stopping, and resuming the music, respectively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类定义，我们再次从一个`friend`类语句开始，以便`Music`类可以访问`AudioManager`类的所需部分。接下来是一个`Play`函数，就像`SoundEffect`类一样，它接受一个参数来设置声音循环的次数。在`Play`函数之后，我们有另外三个函数，`Pause()`、`Stop()`和`Resume()`函数。这三个函数只是对底层SDL_mixer
    API调用的包装，用于暂停、停止和恢复音乐。
- en: 'Finally, we have a private declaration for the `Mix_Music` object. `Mix_Music`
    is the SDL_mixer datatypes used for music data. It supports the loading of WAV,
    MOD, MID, OGG, and MP3 sound files. We will see more about this in the implementation
    section next:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`Mix_Music`对象的私有声明。`Mix_Music`是用于音乐数据的SDL_mixer数据类型。它支持加载WAV、MOD、MID、OGG和MP3音频文件。我们将在接下来的实现部分中了解更多关于这个的信息：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the two `Music` and `SoundEffect` helper classes, we now come to the `AudioManager`
    class definition. The `AudioManager` class will do most of the heavy lifting on
    our side, it will load, hold, and manage creation and deletion of all music and
    sound effects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个`Music`和`SoundEffect`辅助类之后，我们现在来到`AudioManager`类的定义。`AudioManager`类将在我们这一边承担大部分繁重的工作，它将加载、保存和管理所有音乐和音效的创建和删除。
- en: Our declaration of the class starts like most others with a default constructor
    and destructor. Next we have an `Init()` function. This function will handle the
    setup or initialization of our audio system. We then have a `Destroy()` function
    that will handle the deletion and cleanup of our audio system. After the `Init`
    and `Destroy` functions, we have two loader functions, `LoadSoundEffect()` and
    `LoadMusicEffent()` function. Both of these functions take a single argument,
    a standard string that holds the path to the audio file. These functions will
    load the audio files and return a `SoundEffect` or `Music` object depending on
    the function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类声明像大多数其他类一样以默认构造函数和析构函数开始。接下来是一个`Init()`函数。这个函数将处理音频系统的设置或初始化。然后是一个`Destroy()`函数，它将处理音频系统的删除和清理。在`Init`和`Destroy`函数之后，我们有两个加载函数，`LoadSoundEffect()`和`LoadMusicEffent()`函数。这两个函数都接受一个参数，一个标准字符串，其中包含音频文件的路径。这些函数将加载音频文件，并根据函数返回`SoundEffect`或`Music`对象。
- en: The private section of our class has three objects. The first two private objects
    are maps of either type `Mix_Chunk` or `Mix_Music`. This is where we will store
    all the effects and music we will need. By storing a list of sound effects and
    music files we load, we are creating a cache. If we need the file at a later time
    in the project, we can then check these lists and save some valuable loading time.
    The last variable, `m_isInitialized`, holds a Boolean value to specify whether
    the `AudioManager` class has been initialized or not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类的私有部分有三个对象。前两个私有对象是`Mix_Chunk`或`Mix_Music`类型的映射。这是我们将存储所有需要的效果和音乐的地方。通过存储我们加载的音效和音乐文件列表，我们创建了一个缓存。如果在项目的以后时间需要文件，我们可以检查这些列表并节省一些宝贵的加载时间。最后一个变量`m_isInitialized`保存一个布尔值，指定`AudioManager`类是否已经初始化。
- en: 'That completes the declaration of the `AudioManager` and helper classes, let''s
    move on to the implementation where we can take a closer look at some of the functions.
    You can find the `AudioManager.cpp` file in the `Chapter04` folder of the code
    repository:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`AudioManager`和辅助类的声明，让我们继续实现，我们可以更仔细地查看一些函数。您可以在代码存储库的`Chapter04`文件夹中找到`AudioManager.cpp`文件：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our implementation starts out with the includes, default constructor, and destructor.
    Nothing new here, only thing of note is that we call `Destroy()` function from
    the destructor. This allows us two methods of cleaning up the class, through the
    destructor or by explicitly calling the `Destroy()` function on the object itself:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现从包括、默认构造函数和析构函数开始。这里没有什么新东西，唯一值得注意的是我们从析构函数中调用`Destroy()`函数。这允许我们通过析构函数或通过显式调用对象本身的`Destroy()`函数来清理类的两种方法：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next function in the `AudioManager` class implementation is the `Init()`
    function. This is the function that will setup all the needed components for our
    manager. The function starts out with a simple check to see if we have already
    initialized the class; if we have, we throw an exception with a debug message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager`类实现中的下一个函数是`Init()`函数。这是设置管理器所需组件的函数。函数开始时进行简单检查，看看我们是否已经初始化了该类；如果是，我们会抛出一个带有调试消息的异常：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After we check that we haven''t already, we move on to initializing the SDL_mixer
    objects. We do this by calling the `Mix_Init()` function and passing in a bitwise
    combination of flags to set the supported file types. This can be a combination
    of FLAC, MOD, MP3, and OGG. In this example, we are passing the flags for OGG
    and MP3 support. We wrap this call in an if statement to check if the `Mix_Init()` function
    call had any issues. If it does run into an error, we throw another exception
    with a debug message containing the error information returned from the `Mix_Init()`
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们是否已经这样做之后，我们继续初始化SDL_mixer对象。我们通过调用`Mix_Init()`函数并传入一组标志的位组合来实现这一点，以设置支持的文件类型。这可以是FLAC、MOD、MP3和OGG的组合。在这个例子中，我们传递了OGG和MP3支持的标志。我们将这个调用包装在一个if语句中，以检查`Mix_Init()`函数调用是否有任何问题。如果遇到错误，我们会抛出另一个带有从`Mix_Init()`函数返回的错误信息的调试消息的异常：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the  `SDL_mixer` function has been initialized, we can call `Mix_OpenAudio`
    to configure the `frequency`, `format`, `channels`, and `chunksize` to use. It
    is important to note that this function must be called before any other `SDL_mixer`
    functions. The function definition looks like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`SDL_mixer`函数被初始化，我们就可以调用`Mix_OpenAudio`来配置要使用的`frequency`、`format`、`channels`和`chunksize`。重要的是要注意，这个函数必须在任何其他`SDL_mixer`函数之前调用。函数定义如下：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is what the arguments mean:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参数的含义：
- en: '`frequency`: This is the output sampling frequency in samples per second, Hz.
    In the example, we use `MIX_DEFAULT_FREQUENCY` define, which is 22050, a good
    value for most cases.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frequency`：这是每秒采样的输出频率，以赫兹为单位。在示例中，我们使用`MIX_DEFAULT_FREQUENCY`定义，即22050，这是大多数情况下的一个很好的值。'
- en: '`format`: This is the output sample format; again, in the example, we set this
    to the default value by using `MIX_DEFAULT_FORMAT` define, which is the same as
    using `AUDIO_S16SYS` or Signed 16-bit samples, in system byte order. To see the
    full format, define list, see the `SDL_audio.h` file.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：这是输出样本格式；同样，在示例中，我们将其设置为默认值，使用`MIX_DEFAULT_FORMAT`定义，这与使用`AUDIO_S16SYS`或有符号16位样本，系统字节顺序相同。要查看完整的格式定义列表，请参见`SDL_audio.h`文件。'
- en: '`channels`: This is the number of sound channels in the output. 2 channels
    for stereo, 1 for mono. The value 2 is used for our example.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels`：这是输出中的声道数。立体声为2声道，单声道为1声道。我们的示例中使用值2。'
- en: '`chunksize`: This is the bytes used per output sample. We use `1024` bytes
    or 1 **megabyte** (**mb**) for our chunksize.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chunksize`：这是每个输出样本使用的字节数。我们使用`1024`字节或1兆字节（mb）作为我们的chunksize。'
- en: 'Finally, the last thing we do in this function is to set the `m_isInitalized`
    Boolean value to true. This will stop us from accidentally trying to initialize
    the class again:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个函数中我们做的最后一件事是将`m_isInitalized`布尔值设置为true。这将阻止我们意外地尝试再次初始化该类：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next function in the `AudioManager` class is the `Destroy()` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager`类中的下一个函数是`Destroy()`方法：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I will not go through this function line by line as it is self-explanatory.
    The basic overview is; check if `AudioManager` has been initialized, if it has
    then we use the `Mix_FreeChunk()` function to free each of the sound and music
    resources we have created. Finally we use `Mix_CloseAudio()` and `Mix_Quit()` to
    shutdown, clean up, and close the SDL_mixer API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会逐行讲解这个函数，因为它是不言自明的。基本概述是：检查`AudioManager`是否已经初始化，如果是，则使用`Mix_FreeChunk()`函数释放我们创建的每个声音和音乐资源。最后，我们使用`Mix_CloseAudio()`和`Mix_Quit()`来关闭、清理和关闭SDL_mixer
    API。
- en: 'The `LoadSoundEffect` is the next function we have to look at. This function
    much like its name suggests is the function that loads sound effects:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadSoundEffect`是我们需要查看的下一个函数。这个函数就像它的名字所暗示的那样，是加载音效的函数：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first step in this function is to create a `SoundEffect` object to temporarily
    hold the data until we return the effect to the calling method. We simply call
    this variable, effect.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一步是创建一个`SoundEffect`对象，临时保存数据，直到我们将效果返回给调用方法。我们简单地称这个变量为effect。
- en: 'After we have created our holding variable, we do a quick check to see if this
    effect we need has already been created and stored in our cache, the map object,
    `m_effectList`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的临时变量后，我们快速检查一下我们需要的这个效果是否已经被创建并存储在我们的缓存中，即map对象`m_effectList`：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The interesting way we do it here is by creating an iterator variable and assigning
    it the result of `Map.find()`, where the argument passed is the location of the
    sound file we want to load. The cool thing about this method is that if the sound
    effect is not found in the cache, the iterator value will be set to the index
    of the end object of the map, allowing us to do a simple check that you shall
    see as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的有趣的方法是创建一个迭代器变量，并将其赋值为`Map.find()`的结果，其中传递的参数是我们要加载的声音文件的位置。这种方法的有趣之处在于，如果在缓存中找不到声音效果，迭代器的值将被设置为地图的末尾对象的索引，从而允许我们进行一个简单的检查，你将看到如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the iterator value trick, we simply do a check to see if the value of
    `iter` variable matches the return value of the `Map.end()` function; if it does,
    this means that the sound effect is not in the cache list and should be created.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器值技巧，我们只需检查`iter`变量的值是否与`Map.end()`函数的返回值匹配；如果是，这意味着音效不在缓存列表中，应该创建。
- en: To load the sound effect, we call the `Mix_LoadWAV()` function with the argument
    of the files path location as a `c` string. We assign the returning object to
    a `Mix_Chunk` pointer called chunk.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载音效，我们使用`Mix_LoadWAV()`函数，并将文件路径位置作为`c`字符串的参数。我们将返回的对象分配给一个名为块的`Mix_Chunk`指针。
- en: We then check to see if the value of the chunk is a `nullptr` pointer,indicating
    that the loading function has hit an error. If it is a `nullptr` pointer, we throw
    an exception with some debug information provided by the handy `Mix_GetError()`
    function. If successful, we assign our temporary holder, the effect's member `m_chunk`,
    the value of chunk, which is our loaded sound effects data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查块的值是否为`nullptr`指针，表示加载函数出现错误。如果是`nullptr`指针，我们将抛出一个异常，并提供`Mix_GetError()`函数提供的一些调试信息。如果成功，我们将临时持有者，效果的成员`m_chunk`，赋值为块的值，即我们加载的音效数据。
- en: Next we add this newly loaded effect into our cache so that we can save some
    effort in the future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个新加载的效果添加到我们的缓存中，以便将来节省一些工作。
- en: 'Alternatively, if our check on the `iter` value returns false, that means the
    sound effect we are trying to load is in the cache:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们对`iter`值的检查返回false，这意味着我们尝试加载的音效在缓存中：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The true beauty of the iterator tick is now revealed. The lookup result, that
    is the result of the line `auto iter = m_effectList.find(filePath);`, when it
    finds the sound effect will then point to that effect in the list. So all we have
    to do is assign the holder variable effects member value `m_chunk` to the `iter`
    second value, which is the data value for the effect. The last thing we do in
    the `LoadSoundEffect()` function is return the effect variable to the calling
    method. This completes the process and our sound effect is now ready to be used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在迭代器的真正美丽被揭示了。查找结果，也就是`auto iter = m_effectList.find(filePath);`这一行的结果，当它找到音效时，将指向列表中的音效。所以我们所要做的就是将持有者变量效果成员值`m_chunk`分配给`iter`的第二个值，即音效的数据值。`LoadSoundEffect()`函数中的最后一件事是将效果变量返回给调用方法。这完成了过程，我们的音效现在可以使用了。
- en: 'After the `LoadSoundEffect()` function, comes the `LoadMusic()` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoadSoundEffect()`函数之后，是`LoadMusic()`函数：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I am not going to go over this function in detail, because as you can see it
    is very much like the `LoadSoundEffect()` function, but instead of wrapping the
    `Mix_LoadWAV()` function, it instead wraps the `Mix_LoadMUS()` of the `SDL_mixer`
    library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍这个函数，因为您可以看到它非常像`LoadSoundEffect()`函数，但它不是包装`Mix_LoadWAV()`函数，而是包装了`SDL_mixer`库的`Mix_LoadMUS()`。
- en: 'The last two function implementations in the `AudioManager.cpp` file do not
    belong to the `AudioManager` class itself, but instead are implementations of
    the `Play` functions for both the `SoundEffect` and `Music` helper classes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager.cpp`文件中的最后两个函数实现不属于`AudioManager`类本身，而是`SoundEffect`和`Music`辅助类的`Play`函数的实现：'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I won't step through each function line by line, instead I would like to simply
    point out how these functions create wrappers around the SDL_mixer, `Mix_PlayChannel`,
    and `Mix_PlayMusic` functions. This is in essentially the point of the `AudioManager`
    class, it is simply a wrapper that abstracts the process of loading the files
    and creating the objects directly. This helps us to create an expandable framework,
    the pipeline, without the worry of the underlying mechanisms. This means that
    at any time we could, in theory, replace the underlying library with another or
    even multiple libraries, without disturbing the code that calls the manager class
    functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会逐行步进每个函数，而是想简单指出这些函数如何在SDL_mixer的`Mix_PlayChannel`和`Mix_PlayMusic`函数周围创建包装器。这实质上是`AudioManager`类的目的，它只是一个抽象加载文件和直接创建对象的包装器。这帮助我们创建一个可扩展的框架，管道，而不必担心底层机制。这意味着在任何时候，理论上，我们可以用另一个或甚至多个库替换底层库，而不会影响调用管理器类函数的代码。
- en: To round out this example, let's take a look at how we would use this `AudioManager`
    in a demo project. You can find this demo in the `Chapter04` folder of the code
    repository, labeled `SoundExample`. Credit for the music goes to Bensound ([http://www.bensound.com](http://www.bensound.com/)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个示例，让我们看看如何在演示项目中使用这个`AudioManager`。您可以在代码存储库的`Chapter04`文件夹中找到这个演示，标记为`SoundExample`。音乐的来源归功于Bensound（[http://www.bensound.com](http://www.bensound.com/)）。
- en: 'Starting with the `GameplayScreen.h` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GameplayScreen.h`文件开始：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We add two new objects to the private declarations, one for the `AudioManager`
    named `m_AudioManager` and one for the `Music` object, named `m_bgMusic`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在私有声明中添加了两个新对象，一个是名为`m_AudioManager`的`AudioManager`，另一个是名为`m_bgMusic`的`Music`对象。
- en: 'In the `GameplayScreen.cpp` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameplayScreen.cpp`文件中：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To initialize, load, and play our music file, we need to add three lines to
    the `GameplayScreen` classes `OnEntry()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化、加载和播放我们的音乐文件，我们需要在`GameplayScreen`类的`OnEntry()`中添加三行。
- en: The first line `m_AudioManager.Init()` sets up the `AudioManager` and initializes
    all the components as we saw earlier.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行`m_AudioManager.Init()`设置了`AudioManager`并像之前看到的那样初始化了所有组件。
- en: Next we load the music file, in this case the `bensound-epic.mp3` file, and
    assign it to the `m_bgMusic` variable.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来加载音乐文件，这里是`bensound-epic.mp3`文件，并将其分配给`m_bgMusic`变量。
- en: The last line, `m_bgMusic.Play()`, starts the music track playing. By not passing
    in the amount of times to loop the music track, it defaults to `-1`, which means
    it will continue to loop until the program stops.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行`m_bgMusic.Play()`开始播放音乐曲目。通过不传入循环音乐曲目的次数，默认为`-1`，这意味着它将继续循环直到程序停止。
- en: That handles the playing of the music track, but we need to add a couple of
    more function calls to clean up the `AudioManager` when the game is ended and
    to stop the music if we switch screens.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了音乐曲目的播放，但当游戏结束时，我们需要添加一些更多的函数调用来清理`AudioManager`，并在切换屏幕时停止音乐。
- en: 'To stop the music from playing when we leave this screen, we add the following
    to the `GameplayScreen` class `OnExit` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在离开这个屏幕时停止音乐播放，我们在`GameplayScreen`类的`OnExit`函数中添加以下内容：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To clean up the `AudioManager` and stop any potential memory leaks, we call
    the following in the `GameplayScreen` class `Destroy` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理`AudioManager`并阻止任何潜在的内存泄漏，我们在`GameplayScreen`类的`Destroy`函数中调用以下内容：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will in turn handle the destruction and clean-up of any audio assets we
    have loaded as we covered in the previous section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将进而处理我们在前一节中所加载的任何音频资产的销毁和清理。
- en: With all this in place now, if you run the `SoundExample` demo, you will hear
    some epic adventure music start to play, and continuously loop if you are patient
    enough. Now that we have some sound in the game, let's step it up a bit and look
    at how we can get some visual assets into our project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都已经就位，如果你运行`SoundExample`演示，你将听到一些史诗般的冒险音乐开始播放，并且如果你足够耐心，它将不断循环。现在我们在游戏中有了一些声音，让我们再进一步，看看如何将一些视觉资产导入到我们的项目中。
- en: Working with textures
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理纹理
- en: A texture, if you are unfamiliar with the term, can basically be thought of
    as an image. These textures can be applied to a simple geometric square, two triangles,
    to make an image. This type of image is commonly referred to as a `Sprite`. We
    use a `Sprite` class in the demo at the end of this section. It is also important
    to note that textures can be applied to more complex geometry and are used in
    3D modeling to skin objects. Textures will play a larger part as we continue with
    the demos later on in the book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个术语不熟悉，纹理基本上可以被认为是一种图像。这些纹理可以应用到一个简单的几何正方形，两个三角形，以制作一幅图像。这种类型的图像通常被称为`Sprite`。我们在本节末尾的演示中使用了`Sprite`类。还需要注意的是，纹理可以应用到更复杂的几何图形中，并且在3D建模中用于给物体上色。随着我们在书中后面继续进行演示，纹理将扮演更重要的角色。
- en: Resource manager
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理器
- en: 'Let''s start at the high level class, the `ResourceManager`. This manager class
    will be responsible for maintaining resource objects in a cache as well as providing
    a simple, abstracted interface to acquiring the resource:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高级别的类`ResourceManager`开始。这个管理类将负责在缓存中维护资源对象，并提供一个简单的、抽象的接口来获取资源：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The declaration file, `ResourceManager.h`, is a simple class consisting of
    one public function `GetTexture`, and one private member of type `TextureCache`.
    The `GetTexure` will be the function we expose to other classes. It will be responsible
    for returning the texture object. The `TextureCache` is like the cache we used
    in `AudioManager`, it will hold loaded textures for later use. Let''s move on
    to the implementation so we can see how this is setup:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文件`ResourceManager.h`是一个简单的类，包括一个公共函数`GetTexture`，和一个私有成员`TextureCache`。`GetTexure`将是我们向其他类公开的函数。它将负责返回纹理对象。`TextureCache`就像我们在`AudioManager`中使用的缓存，它将保存加载的纹理以供以后使用。让我们继续实现，这样我们就可以看到这是如何设置的：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `ResourceManager` implementation is really just an abstracted call to the
    underlying structure. When we call the `GetTexture` function of the `ResourceManager` class
    we are expecting to get a `GLTexture` type back. As the caller of this function,
    I don't need to worry about the internal workings of `TextureCache` or how the
    object is parsed. All I have to do is specify the path of the texture I wish to
    load and the asset pipeline does the rest. This should be the ultimate goal of
    the asset pipeline system regardless of the methods, the interfaces should be
    sufficiently abstract to allow developers and designers to import and consume
    assets in the project without the implementation of the underlying systems becoming
    a blocker.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager`的实现实际上只是对底层结构的抽象调用。当我们调用`ResourceManager`类的`GetTexture`函数时，我们期望得到一个`GLTexture`类型的返回。作为这个函数的调用者，我不需要担心`TextureCache`的内部工作方式或对象是如何解析的。我所需要做的就是指定我希望加载的纹理的路径，然后资产管道就会完成剩下的工作。这应该是资产管道系统的最终目标，无论采用何种方法，接口都应该足够抽象，以允许开发人员和设计师在项目中导入和使用资产，而不需要底层系统的实现成为阻碍。'
- en: Next we will look at this example texture system that is the core underneath
    the simplicity of the `ResourceManager` class interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一下这个例子纹理系统，它是`ResourceManager`类接口简单性的核心。
- en: Texture and TextureCache
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理和纹理缓存
- en: Earlier we saw two new objects introduced that comprise the structure of the
    `ResourceManager` class, the `GLTexture` and `TextureCache`. In the coming sections,
    we will take a look at these two classes in more detail so we can see how these
    classes connect to other systems to build a robust asset management system, all
    leading back to the simple interface of `ResourceManager`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到了`ResourceManager`类结构中引入的两个新对象，`GLTexture`和`TextureCache`。在接下来的章节中，我们将更详细地看一下这两个类，以便了解这些类如何与其他系统连接，构建一个强大的资产管理系统，最终回到`ResourceManager`的简单接口。
- en: 'To start with we will take a look at the class, `GLTexture`. This class is
    comprised solely of a `struct` that describes the attributes of our texture. Here
    is the code for the `GLTexture` class in its entirety:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将看一下`GLTexture`类。这个类完全由一个描述我们纹理属性的`struct`组成。以下是`GLTexture`类的完整代码：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As mentioned earlier, the `GLTexture` class is really just a wrapper for a `struct`,
    also called `GLTexture`. This `struct` holds some simple values. A `GLuint id`,
    used to identify the texture and two integer values, `width` and `height`, which
    of course hold the textures/images height and width. This `struct` could easily
    be included in the `TextureClass`, I chose to implement it this way to, one, make
    it a little easier to read, and two, to allow some flexibility for future development.
    Again we want to make sure that our asset pipeline allows for the adaption of
    different needs and the inclusion of new asset types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`GLTexture`类实际上只是一个名为`GLTexture`的`struct`的包装器。这个`struct`保存了一些简单的值。一个`GLuint
    id`，用于标识纹理和两个整数值，`width`和`height`，当然保存了纹理/图像的高度和宽度。这个`struct`可以很容易地包含在`TextureClass`中，我选择以这种方式实现它，一是为了使它更容易阅读，二是为了允许一些未来发展的灵活性。再次，我们希望确保我们的资产管道允许适应不同的需求和包含新的资产类型。
- en: Next we have the `TextureCache` class, as we did with our audio assets, it is
    a good idea to create a cache for our image files. This again will provide us
    quicker access to the needed image files by saving them in a map and returning
    them as needed. We only have to create a new texture if it does not already exist
    in the cache. I tend to favor this type of implementation with a cache mechanism
    when building any system that works with assets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有`TextureCache`类，就像我们对音频资产所做的那样，为图像文件创建一个缓存是一个好主意。这将再次通过将它们保存在一个映射中并根据需要返回它们来为我们提供更快的访问所需的图像文件。我们只需要在缓存中不存在时创建一个新的纹理。在构建任何与资产相关的系统时，我倾向于使用这种带有缓存机制的实现方式。
- en: 'While these examples provide a basic implementation, they are a great starting
    points for creating more robust systems, with memory management and other components
    integrated. The following is the declaration of the `TextureCache` class, it should
    look very familiar from the preceding audio example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些示例提供了一个基本的实现，但它们是创建更健壮的系统的绝佳起点，可以集成内存管理和其他组件。以下是`TextureCache`类的声明，它应该从前面的音频示例中看起来非常熟悉：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Moving on to the implementation of the `TextureCache` class, in the `TextureCache.cpp`
    file, let''s take a look at the `GetTexture()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现`TextureCache`类，在`TextureCache.cpp`文件中，让我们看一下`GetTexture()`：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This implementation again will look very similar to the `AudioManager` example
    we saw earlier. The main line to pay attention to here is the line that calls
    the `ImageLoader` class to load the image file, `GLTexture newTexture = ImageLoader::LoadPNG(texturePath);`.
    This call is the heavy lifting aspect of the class, and as you can see we again
    are abstracting the underlying system and simply providing a `GLTexture` as the
    return type from our `GetTexture` class. Let's jump ahead and look at the implementation
    of the `ImageLoader` class in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现看起来与我们之前看到的`AudioManager`示例非常相似。这里需要注意的主要一行是调用`ImageLoader`类加载图像文件的那一行，`GLTexture
    newTexture = ImageLoader::LoadPNG(texturePath);`。这个调用是类的重要部分，正如你所看到的，我们再次抽象了底层系统，只是从我们的`GetTexture`类中提供了一个`GLTexture`作为返回类型。让我们跳到下一节，看一下`ImageLoader`类的实现。
- en: The ImageLoader class
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImageLoader类
- en: Now that we have the structure in place to pass our texture object back up to
    our calling resource manager, we need to implement to class that actually loads
    the image file. The `ImageLoader` is that class. It will handle the loading, processing,
    and creating of the texture. This simple example will load a **Portable Network
    Graphics** (**PNG**) format image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了结构来将纹理对象传递回给调用资源管理器，我们需要实现一个实际加载图像文件的类。`ImageLoader`就是这个类。它将处理加载、处理和创建纹理。这个简单的例子将加载一个**便携式网络图形**（**PNG**）格式的图像。
- en: Since we are focusing on the structure of the asset pipe here, I am going to
    stick to the core sections of the class. I will assume some knowledge of OpenGL's
    buffer and texture creation. If you are not familiar with OpenGL, I highly recommend
    the OpenGL bible series as a great reference. We will be looking at some of these
    features later on when we look at some of the advanced rendering and animation
    techniques in the future chapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里专注于资产管道的结构，我将坚持课程的核心部分。我将假设您对OpenGL的缓冲区和纹理创建有一些了解。如果您对OpenGL不熟悉，我强烈推荐OpenGL圣经系列作为一个很好的参考。在未来的章节中，当我们研究一些高级渲染和动画技术时，我们将会看到一些这些特性。
- en: 'For this example, the `ImageLoader.h` file has only a single declaration for
    a `LoadPNG` function. This function takes one parameter, which is the path to
    the image file and it will return a `GLTexture`. Here is the `ImageLoader` in
    its entirety:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ImageLoader.h`文件只有一个`LoadPNG`函数的声明。这个函数接受一个参数，即图像文件的路径，并将返回一个`GLTexture`。以下是完整的`ImageLoader`：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moving on to the implementation, inside of the `ImageLoader.cpp` file, let''s
    go through the `LoadPNG` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现，在`ImageLoader.cpp`文件中，让我们看一下`LoadPNG`函数：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first thing we do is create a few temporary variables to hold our working
    data. An unsigned `long` for `height` and `width`, a `GLTexture` object, which
    we then initialize all its fields to `0`. Then we have two vector containers of
    unsigned char's. The `in` vector will be the container that will house the raw
    encoded data to be read in from the PNG. The `out` vector will hold the decoded
    data that has been converted.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一些临时变量来保存我们的工作数据。一个无符号的`长`用于`高度`和`宽度`，一个`GLTexture`对象，然后我们将其所有字段初始化为`0`。然后我们有两个存储无符号字符的向量容器。`in`向量将容纳从PNG中读取的原始编码数据。`out`向量将保存已转换的解码数据。
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next we have two function calls. The first we call a function that uses the
    `IOManager` class `ReadFileToBuffer` function to read in the image files raw data.
    We pass in the `pathToFile`, and the vector in; the function will then fill the
    vector with the raw encoded data. The second call is to the `DecodePNG` function;
    this is the call to the single function library I mentioned before. This library
    will handle the reading of the raw data, decoding, and filling of the out vector
    container with the decoded data. The function takes four parameters:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有两个函数调用。首先我们调用一个使用`IOManager`类的`ReadFileToBuffer`函数来读取图像文件的原始数据的函数。我们传入`pathToFile`和`in`向量；函数将用原始编码数据填充向量。第二个调用是`DecodePNG`函数；这是我之前提到的单一函数库的调用。这个库将处理原始数据的读取、解码，并用解码后的数据填充输出向量容器。函数有四个参数：
- en: The first is the vector to hold the decoded data, in our case the `out` vector
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是用来保存解码数据的向量，我们的例子中是`out`向量
- en: The second is the `width` and the `height` variables, which the `DecodePNG`
    function will fill in with the images values
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是`width`和`height`变量，`DecodePNG`函数将用图像的值填充它们
- en: The third is a reference to a container that holds the encoded data, in our
    case, the `in` vector
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是指一个容器，它保存着编码数据，在我们的例子中，是`in`向量
- en: The last parameter is the size of the buffer, the size of the vector `in`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是缓冲区的大小，也就是向量`in`的大小
- en: These two calls are the major part of this class, they complete the system that
    comprise the image loading component of our asset pipeline. We won't dive into
    the reading of the raw data and decoding right now. In the next section, we will
    see a similar technique to load 3D models, where we will see how to read and decode
    data in detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用是这个类的主要部分，它们完成了我们资产管道的图像加载组件的系统。我们现在不会深入到原始数据的读取和解码中。在下一节中，我们将看到一个类似的技术来加载3D模型，我们将看到如何详细地读取和解码数据。
- en: The rest of the function will handle the uploading and processing of the image
    in OpenGL, again I am not going to spend time on this section of the function.
    We will see more of the OpenGL framework's calls as we move forward and I will
    go into more depth at that time. This example is built specifically for OpenGL,
    it however could easily be replaced with more generic code, or code specific to
    another graphics library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分将处理在OpenGL中上传和处理图像，我不会在这部分函数上花时间。随着我们继续前进，我们将看到更多OpenGL框架的调用，并且在那时我会更深入地讨论。这个例子是专门为OpenGL构建的，但它很容易被更通用的代码或特定于其他图形库的代码所替代。
- en: Minus the `IOManger` and `DecodePNG` classes, this rounds out the image handling
    of the asset pipeline. As hopefully you can see, having a structure in place,
    such as we have seen, allows a lot of flexibility under the hood while providing
    a simple interface that requires little knowledge of the underlying system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`IOManger`和`DecodePNG`类，这就完成了资产管道的图像处理。希望你能看到，有一个像我们所见的这样的结构，可以在底层提供很大的灵活性，同时提供一个简单的接口，几乎不需要了解底层系统。
- en: 'Now that we have a texture returned with a simple one line call, `ResourceManger::GetTexture(std::string
    pathToTextureFile)`, let''s bring this example full circle and see how we plug
    into this system to create a `Sprite` (2D image) from the loaded texture:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过一个简单的一行调用返回了一个纹理，`ResourceManger::GetTexture(std::string pathToTextureFile)`，让我们把这个例子完整地展示一下，看看我们如何插入这个系统来创建一个`Sprite`（2D图像）从加载的纹理中：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the texture example project, jumping into the `Sprite` class, if we focus
    on the `Init()`, we see where our simple interface allows us to call the `ResourceManager` classes
    `GetTexture` to return the handled image. That's it, very simple! Of course this
    is not limited to just sprites we can use this function to load textures for other
    uses, such as modeling and GUI uses. We can also expand this system to load more
    than just PNG's, in fact I would challenge you to spend some time building this
    out for more file formats, DDS, BMP, JPG, and others. The `ResourceManager` itself
    has a lot of room for improvement and growth. This basic structure is easily repeatable
    for other assets, such as sound, 3D models, fonts, and everything else. In the
    next section, we dive a little deeper and will look at the loading of 3D models
    or meshes as they are commonly referred to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在纹理示例项目中，进入`Sprite`类，如果我们关注`Init()`，我们会看到我们的简单接口允许我们调用`ResourceManager`类的`GetTexture`来返回处理过的图像。就是这样，非常简单！当然，这不仅限于精灵，我们可以使用这个函数来加载其他用途的纹理，比如建模和GUI用途。我们还可以扩展这个系统，加载不仅仅是PNG的文件，事实上，我会挑战你花一些时间为更多的文件格式构建这个系统，比如DDS、BMP、JPG和其他格式。`ResourceManager`本身有很大的改进和增长空间。这个基本结构很容易重复用于其他资产，比如声音、3D模型、字体和其他一切。在下一节中，我们将深入一点，看看加载3D模型或网格时的情况。
- en: To see the whole system at work, run the texture example project, you will be
    presented with a very nice image of the sun, provided by the kind folks at NASA.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要看整个系统的运行情况，运行纹理示例项目，你将看到一个由NASA的善良人士提供的非常漂亮的太阳图像。
- en: 'The following is the output on Windows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Windows上的输出：
- en: '>![](img/3a736c0d-67d0-48d3-af09-1d555fcdf520.png)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/3a736c0d-67d0-48d3-af09-1d555fcdf520.png)'
- en: 'The following is the output on macOS:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在macOS上的输出：
- en: '![](img/aa594644-04dd-475e-8dbf-230a26edc3bf.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa594644-04dd-475e-8dbf-230a26edc3bf.png)'
- en: Importing models – meshes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入模型-网格
- en: 'Models or meshes are representations of objects in a three-dimensional space.
    These models could be anything from the player''s character to a small scenery
    object, such as a table or chair. Loading and manipulating these object is a huge
    part of the game engine and the underlying systems. In this section, we will look
    at the process of loading in a 3D mesh. We will walk through a simple file format
    that describes the object in three-dimensional terms. We will look at how to load
    this file format and parse it into a readable format to share with the graphics
    processor. Finally, we will touch on the steps used by OpenGL to render the object.
    Let''s dive right in and begin with the `Mesh` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模型或网格是三维空间中物体的表示。这些模型可以是玩家角色，也可以是小型景物，比如桌子或椅子。加载和操作这些对象是游戏引擎和底层系统的重要部分。在本节中，我们将看看加载3D网格的过程。我们将介绍一种描述三维对象的简单文件格式。我们将学习如何加载这种文件格式并将其解析为可供图形处理器使用的可读格式。最后，我们将介绍OpenGL用于渲染对象的步骤。让我们立即开始并从`Mesh`类开始：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our `Mesh` class declaration file, `Mesh.h`, is pretty simple. We have the `normal`
    constructor and destructors. Then we have two more functions exposed as `public`.
    The `Init()` function, which will initialize all of the `Mesh` components, and
    the `Draw` function, which will do the actual processing to pass the information
    to the renderer. In the `private` declarations, we have a bunch of variables to
    hold the mesh's data. The first is the `GLuint m_vao` variable. This variable
    will hold a handle to the OpenGL vertex array object, I won't go into this in
    detail right now, refer to the OpenGL documentation for a quick break down.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Mesh`类声明文件`Mesh.h`非常简单。我们有`normal`构造函数和析构函数。然后我们有另外两个作为`public`公开的函数。`Init()`函数将初始化所有`Mesh`组件，`Draw`函数将实际处理并将信息传递给渲染器。在`private`声明中，我们有一堆变量来保存网格的数据。首先是`GLuint
    m_vao`变量。这个变量将保存OpenGL顶点数组对象的句柄，我现在不会详细介绍，可以参考OpenGL文档进行快速了解。
- en: The next two `GLuint` variables, `m_vertexbuffer` and `m_uvbuffer` are holders
    for, like their names suggest, buffers of data for the `vertex` and `uv` information.
    More on this in the implementation that follows. After the buffers, we have a
    `GLTexture` variable `m_texture`. You will remember this object type from earlier;
    this will house the mesh's texture. The last three variables are vectors of `glm
    vec3`. These hold the Cartesian coordinates for the `vertices`, texture `uvs`,
    and `normal` of the `Mesh`. In this current example, we will not be using the
    normal values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个`GLuint`变量，`m_vertexbuffer`和`m_uvbuffer`是用来保存`vertex`和`uv`信息数据的缓冲区。在接下来的实现中会更多介绍。在缓冲区之后，我们有一个`GLTexture`变量`m_texture`。你会记得这个对象类型之前提到过；这将保存网格的纹理。最后三个变量是`glm
    vec3`的向量。这些向量保存了`Mesh`的顶点的笛卡尔坐标，纹理`uvs`和`normal`。在当前的例子中，我们不会使用normal值。
- en: 'That gives us a good understanding of what our `Mesh` class will need; now
    we can move on to the implementation. We will walk through the class, diverting
    to other classes as they arise. Let''s begin in the `Mesh.cpp` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对`Mesh`类需要什么有了很好的理解；现在我们可以继续实现。我们将逐步学习这个类，遇到其他类时会转到其他类。让我们从`Mesh.cpp`文件开始：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Mesh.cpp` file starts out with the constructor implementation. The `Mesh`
    constructor sets the values of the two buffers and the vertex array object to
    zero. We do this so we can do a simple check later on to see if they have been
    initialized or for deletion, which we will see next:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mesh.cpp`文件以构造函数的实现开始。`Mesh`构造函数将两个缓冲区和顶点数组对象的值设置为零。我们这样做是为了以后进行简单的检查，看它们是否已经被初始化或删除，接下来我们将看到：'
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The destructor for the `Mesh` class handles the deletion of the `Buffer` and
    `Vertex` arrays. We do a simple check to see if they are not set to zero, meaning
    they have been created, and then delete them if they are not:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mesh`类的析构函数处理了`Buffer`和`Vertex`数组的删除。我们进行简单的检查，看它们是否不等于零，这意味着它们已经被创建，如果它们不是，则删除它们：'
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Moving on to the `Init()` function, we start off with the loading of our assets.
    Here we the texture that our model will need using a familiar helper function
    the `ResourceManager` class `GetTexture` function. We also load `Mesh`, in this
    case an OBJ format model called `Dwarf_2_Low.obj`, provided by andromeda vfx on
    [TurboSquid.com](https://www.turbosquid.com/). This happens through the use of
    the `LoadOBJ` function. Let's jump out of our `Mesh` class for a minute and look
    at how this function is implemented.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Init()`函数，我们从加载我们的资源开始。在这里，我们使用熟悉的帮助函数`ResourceManager`类的`GetTexture`函数来获取模型所需的纹理。我们还加载`Mesh`，在这种情况下是一个名为`Dwarf_2_Low.obj`的OBJ格式模型，由andromeda
    vfx提供在[TurboSquid.com](https://www.turbosquid.com/)上。这是通过使用`LoadOBJ`函数实现的。让我们暂时离开`Mesh`类，看看这个函数是如何实现的。
- en: 'In the `MeshLoader.h` file, we see the declaration of the `LoadOBJ` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MeshLoader.h`文件中，我们看到了`LoadOBJ`函数的声明：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `LoadOBJ` function takes four parameters, the file path to the OBJ file
    to load, and three vectors that will be filled with the data found in the OBJ
    file. The function also has a return type of a Boolean, this is for a simple error
    checking ability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadOBJ`函数有四个参数，OBJ文件的文件路径和三个将填充OBJ文件中数据的向量。该函数还具有布尔类型的返回值，这是为了简单的错误检查能力。'
- en: 'Before we move on and see how this function is put together and how it will
    parse the data to fill the vectors we created, it is important to understand the
    structure of the file we are using. Luckily for us the OBJ file is an open file
    format and can actually be read in plain text in any text editor. It is also possible
    for you to create very simple models by hand with the OBJ format. To give you
    an example let''s look at the `cube.obj` file as viewed in a text editor. Side
    note, you can view an OBJ formatted model 3D rendering in Visual Studio; it even
    has basic editing tools:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续查看这个函数是如何组合的，以及它将如何解析数据来填充我们创建的向量之前，重要的是要了解我们正在使用的文件的结构。幸运的是，OBJ文件是一种开放的文件格式，实际上可以在任何文本编辑器中以纯文本形式阅读。您也可以使用OBJ格式手工创建非常简单的模型。举个例子，让我们看一下在文本编辑器中查看的`cube.obj`文件。顺便说一句，您可以在Visual
    Studio中查看OBJ格式的3D渲染模型；它甚至有基本的编辑工具：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, there is a lot of data packed into these files. Remember this
    is just a simple cube model being described. Take a look at the dwarf OBJ file
    to get an even deeper sense of the data contained. The important parts to us are
    the `v`, `vt`, `vn`, and `f` lines. The `v` lines describe the geometric vertices
    of the `Mesh`, that is the `x`, `y`, `z` values of the model in local space (coordinates
    with a origin that is relative to the model itself). The `vt` lines describe the
    texture vertices for the model, this time the values are normalized x and y coordinates,
    normalized meaning they are a value between `0` and `1`. The `vn` lines are the
    descriptions of the vertex normals, we won''t use these in our current example,
    but these values give normalized vector units that are perpendicular to the vertex.
    These are very useful values to know when computing things like lighting and shading.
    The following figure depicts the vertex normals of a dodecahedral shaped mesh:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些文件中包含了大量的数据。请记住，这只是一个简单的立方体模型的描述。看一下矮人OBJ文件，以更深入地了解其中包含的数据。对我们来说重要的部分是`v`、`vt`、`vn`和`f`行。`v`行描述了`Mesh`的几何顶点，即模型在局部空间中的`x`、`y`、`z`值（相对于模型本身的原点的坐标）。`vt`行描述了模型的纹理顶点，这次值是标准化的x和y坐标，标准化意味着它们是`0`和`1`之间的值。`vn`行是顶点法线的描述，我们在当前示例中不会使用这些，但这些值给出了垂直于顶点的标准化向量单位。在计算光照和阴影等内容时，这些是非常有用的值。以下图示了一个十二面体形状网格的顶点法线：
- en: '![](img/ad51a2a6-61ac-40c0-a653-2051ae5fa0e2.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad51a2a6-61ac-40c0-a653-2051ae5fa0e2.png)'
- en: The last set of lines, the `f` lines, describe the faces of the mesh. These
    are groups of three vector values that make a single face, a triangle, of the
    mesh. These are again local space x, y, and z coordinates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组行，`f`行，描述了网格的面。这些是构成网格的单个面，三角形的三个向量值组。这些再次是局部空间的x、y和z坐标。
- en: 'This file once rendered in our example engine will look like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例引擎中渲染此文件将如下所示：
- en: '![](img/86bfbce9-6b72-4de1-a863-f627e9343062.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86bfbce9-6b72-4de1-a863-f627e9343062.png)'
- en: 'Okay that is the OBJ file format in a nutshell, now let''s move ahead and take
    a look at how we will parse this data and store it in buffers for our renderer
    to use. Inside the `MeshLoader.cpp` file, we find the implementation of the `LoadOBJ()`
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是OBJ文件格式的概况，现在让我们继续并看看我们将如何解析这些数据并将其存储在缓冲区中供我们的渲染器使用。在`MeshLoader.cpp`文件中，我们找到了`LoadOBJ()`函数的实现：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To start the `LoadOBJ` function, a few holder variables are created. The first
    line of variable declarations is a set of three vectors of integers. These will
    hold the indices of the `vertices`, `uvs`, and `normals`. After the indices, we
    have three more vectors. Two `vec3` vectors for the `vertices` and `normal`, and
    one `vec2` vector for the `uvs`. These vectors will hold the temporary values
    for each, allowing us to perform some calculations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始`LoadOBJ`函数，创建了一些占位变量。变量声明的第一行是三个整数向量。这些将保存`vertices`、`uvs`和`normals`的索引。在索引之后，我们有另外三个向量。两个`vec3`向量用于`vertices`和`normal`，一个`vec2`向量用于`uvs`。这些向量将保存每个临时值，允许我们执行一些计算：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next we start a `try` block that will house the core logic for the function.
    We do this so we can throw some exception if any issues arise and catch them internally
    at the end of this function. The first line in the `try` block, `std::ifstream
    in(path, std::ios::in);` attempts to load the file at the location we passed in.
    The `ifstream`, which, as you might have noticed, is part of the standard library,
    is used to define a stream object that can be used to read in character data from
    a file. It is very common to see `ifstream` used in modern I/O systems, it is
    the C++ replacement for the commonly seen `fopen`, which is actually C:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们开始一个`try`块，它将包含函数的核心逻辑。我们这样做是为了在这个函数的最后内部抛出一些异常，如果出现任何问题就在内部捕获它们。`try`块中的第一行，`std::ifstream
    in(path, std::ios::in);`尝试加载我们传入位置的文件。`ifstream`，正如您可能已经注意到的，是标准库的一部分，用于定义一个流对象，可以用来从文件中读取字符数据。在现代I/O系统中经常看到`ifstream`的使用，它是C++中常见的`fopen`的替代品，后者实际上是C的：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then test to see if there were any errors loading the file with the
    simple if statement `if(!in)`, which is the same as checking the state flags directly
    such as `in.bad() == true; or in.fail() == true`. If we do encounter an error,
    we throw an exception with a debug message. We handle this exception later in
    the function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以测试是否有任何加载文件错误，使用简单的if语句`if(!in)`，这与直接检查状态标志相同，例如`in.bad() == true;`或`in.fail()
    == true`。如果我们遇到错误，我们会抛出一个带有调试消息的异常。我们稍后在函数中处理这个异常：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next we need to create a loop so we can traverse the file and parse the data
    as needed. We do this using a `while()` loop using the `std::getline(in, line)`
    function as the parameter. The `std::getline` returns a single line of characters
    until it reaches an end of line character. The `parameters std::getline()` takes
    are the stream containing the characters, in our case `in` and a `std::string`
    object that will hold the function's output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个循环，这样我们就可以遍历文件并根据需要解析数据。我们使用`while()`循环，使用`std::getline(in, line)`函数作为参数。`std::getline`返回一行字符，直到它达到一个换行符。`parameters
    std::getline()`接受的是包含字符的流，我们的情况下是`in`，以及一个将保存函数输出的`std::string`对象。
- en: 'By using this as the `while` loop''s condition parameter, we will continue
    to step through the input file, line by line, until we reach the end of the file.
    The time during which the condition will become false, we will stop the loop.
    This is a very handy method of stepping through files to parse:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个作为`while`循环的条件参数，我们将继续逐行遍历输入文件，直到达到文件的末尾。在条件变为假的时间内，我们将停止循环。这是一个非常方便的逐步遍历文件以解析的方法：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside of our `while` loop, the first thing we want to try and parse is the
    vertex data in the OBJ file. If you remember from our earlier explanation, the
    vertex data is contained in a single line, denoted by a `v`. Then to parse our
    vertex data, we should first test to see if the line is a vertex (`v`) line. The
    `std::string()` object has a handy method that allows you to select a defined
    amount of characters from the string. This method is the `substr()`, the `substr()`
    method can take two arguments, the starting position and the ending position of
    the characters in the string. This creates a substring object that we can then
    test against.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`while`循环内，我们首先要尝试解析的是OBJ文件中的顶点数据。如果你还记得我们之前的解释，顶点数据包含在一个单独的行中，用`v`表示。然后，为了解析我们的顶点数据，我们应该首先测试一下这行是否是一个顶点（`v`）行。`std::string()`对象有一个方便的方法，允许你从字符串中选择一定数量的字符。这个方法就是`substr()`，`substr()`方法可以接受两个参数，字符在字符串中的起始位置和结束位置。这样就创建了一个子字符串对象，然后我们可以对其进行测试。
- en: In this example, we use the `substr()` method to take the first two characters
    of the string, line, and then test to see if they match the string `"v "` (notice
    the space). If this condition is `true`, that means we have a vertex line and
    can then move on to parsing it into a useful form for our system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`substr()`方法来取字符串`line`的前两个字符，然后测试它们是否与字符串`"v "`（注意空格）匹配。如果这个条件是`true`，那就意味着我们有一个顶点行，然后可以继续将其解析成我们系统中有用的形式。
- en: 'The code is pretty self-explanatory, but let''s highlight some important parts.
    The first is the `std::istringstream` object `v`. A `stringstream` is a special
    object that provides a string buffer with a convenient way to manipulate strings
    much like it was an I/O object (`std::cout`). This means you can treat it like
    a stream using the `>>` and `<<` operators, but also use it like a `std::string`
    using the `str()` method. We use our string stream object to house a new collection
    of characters. These new characters are provided by the method call to `line.substr(2)`.
    This time by only passing one argument, `2`, to the `substr` method, we are telling
    it to return the rest of the line starting at the second character. What this
    does is return the values `x`, `y`, and `z` of the vertex line without the `v`
    denotation. Once we have this new collection of characters, we can step through
    each one and assign it to the double variable it matches. As you can see, this
    is where we use the unique nature of the string stream object to stream out the
    character to its variable, the `v >> x;``v >> y; v >> x;` line. At the end of
    the `if` statement we then turn these `x`,`y`,`z` doubles into a `vec3` and finally
    push the newly created `vec3` to the back of the temp `vertices` vector:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当容易理解，但让我们来强调一些重要的部分。首先是`std::istringstream`对象`v`。`stringstream`是一个特殊的对象，它提供了一个字符串缓冲区，方便地操作字符串，就像操作I/O对象（`std::cout`）一样。这意味着你可以使用`>>`和`<<`操作符来处理它，也可以使用`str()`方法来像处理`std::string`一样处理它。我们使用我们的字符串流对象来存储一组新的字符。这些新字符是通过对`line.substr(2)`的方法调用提供的。这一次，通过只传递一个参数`2`给`substr`方法，我们告诉它返回从第二个字符开始的行的其余部分。这样做的效果是返回顶点行的值`x`、`y`和`z`，而不包括`v`标记。一旦我们有了这组新的字符，我们就可以逐个遍历每个字符，并将其分配给它匹配的双精度变量。正如你所看到的，这就是我们使用字符串流对象的独特性来将字符流到它的变量的地方，即`v
    >> x;``v >> y; v >> x;`行。在`if`语句的末尾，我们将这些`x`、`y`、`z`双精度数转换为`vec3`，最后将新创建的`vec3`推送到临时`vertices`向量的末尾：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the textures we do much of the same thing. The major difference, besides
    checking for `"vt"`, is that we are only looking for two values, or `vec2` vector''s.
    The other note here is that we invert the `v` coordinate since we are using texture
    formats, which are inverted. Remove if you want to use TGA or BMP format loaders:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纹理，我们做了很多相同的事情。除了检查`"vt"`之外，主要的区别是我们只寻找两个值，或者`vec2`向量。这里的另一个注意事项是我们反转了`v`坐标，因为我们使用的是纹理格式，它们是反转的。如果你想使用TGA或BMP格式的加载器，可以删除这部分：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For the normals, we do the exact same as we did for the vertices, but look
    for `vn` lines:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于法线，我们做的和顶点一样，但是寻找的是`vn`行：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the faces, a collection of triangles, we do something a little differently.
    First we check to see if we have a `"f "` line. If we do, we setup a few arrays
    to hold the indexes of the `vertex`, `uv`, and `normal`. We then convert our `std::string`,
    line, to a character array, which is referred to as C string, with the line `const
    char* cstring = line.c_str();`. We then use another C function, `sscanf_s` to
    parse the actual string and separate out each character into the specific index
    array element. Once this statement finishes, the `sscanf_s()` function will return
    an integer value of the element''s set, which we give to the variable matches:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面，一个三角形的集合，我们做一些不同的事情。首先，我们检查是否有一个`"f "`行。如果有，我们设置一些数组来保存`vertex`，`uv`和`normal`的索引。然后我们将我们的`std::string`，line，转换为一个字符数组，即C字符串，使用`const
    char* cstring = line.c_str();`这一行。然后我们使用另一个C函数，`sscanf_s`来解析实际的字符串，并将每个字符分离到特定的索引数组元素中。一旦这个语句完成，`sscanf_s()`函数将返回一个元素集的整数值，我们将其赋给变量matches：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then use the `matches` variable to check and see if it is equal to `9`,
    which means we have nine elements and it is a format we can work with. If the
    value of matches is not `9`, that means we have a format that we are not setup
    to handle, so we throw an exception with a simple debug message:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`matches`变量来检查它是否等于`9`，这意味着我们有九个元素，这是我们可以处理的格式。如果matches的值不是`9`，那意味着我们有一个我们没有设置好处理的格式，所以我们抛出一个带有简单调试消息的异常：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last thing we do in the `"f "` or face line if statement, is to take all
    the separated elements and push them into the corresponding indices vector. We
    use these values to build the actual mesh data next:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`"f "`或面行的if语句中，我们做的最后一件事是将所有分离的元素推入相应的索引向量中。我们使用这些值来构建实际的网格数据：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To create our final mesh data to give the output vectors, we create another
    loop to step through the model data, this time using a for loop and the amount
    of vertices as the condition. We then create three variables to hold the current
    index to each `vertex`, `uv`, and `normal`. Each time we go through this loop,
    we set this index to the value of `i`, which increments each step through:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的最终网格数据以提供输出向量，我们创建另一个循环来遍历模型数据，这次使用一个for循环和顶点数量作为条件。然后我们创建三个变量来保存每个`vertex`，`uv`和`normal`的当前索引。每次我们通过这个循环，我们将这个索引设置为`i`的值，这个值在每一步中递增：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then thanks to these index values, we can get the attributes for each `vertex`,
    `uv`, and `normal`. We set these in either a `vec2` or `vec3`, which is what we
    will need for the output vectors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于这些索引值，我们可以获得每个`vertex`，`uv`和`normal`的属性。我们将这些设置为`vec2`或`vec3`，这是我们输出向量所需要的：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, the last step is to push these new values into their specific output
    vectors:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步是将这些新值推入它们特定的输出向量中：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Lastly, we have the `catch` block to match the `try` block from the top. This
    catch is very simple, we take the reason member object from the incoming `Exception`
    object and use it to print the debug message to the error log file. We also return
    false from the `LoadOBJ()` function to let the calling object know that there
    was an error. If there is nothing to catch, we simply return true, to let the
    calling object know everything worked as expected. We are now ready to use this
    function to load our OBJ files and produce useful data for the rendering system.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`catch`块来匹配顶部的`try`块。这个catch非常简单，我们从传入的`Exception`对象中取出reason成员对象，并用它来将调试消息打印到错误日志文件中。我们还从`LoadOBJ()`函数中返回false，以让调用对象知道发生了错误。如果没有什么可捕捉的，我们简单地返回true，以让调用对象知道一切都按预期工作。现在我们准备使用这个函数来加载我们的OBJ文件，并为渲染系统生成有用的数据。
- en: 'Now, moving back to the `Mesh.cpp` file, we will continue on and use this loaded
    data to draw the model with the example engine. I won''t spend too much time on
    each function, again this is specific to the OpenGL API, but could be written
    in a more generic way or to use another graphics library such as DirectX:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Mesh.cpp`文件，我们将继续使用这个加载的数据来使用示例引擎绘制模型。我不会在每个函数上花太多时间，这再次是特定于OpenGL API，但可以以更通用的方式编写，或者使用其他图形库，比如DirectX：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here we check to see if the vertex array object has already been generated;
    if it has not, we go ahead a make one using our `m_vao` as the referenced object.
    Next we bind the VAO, this will allow us to use it for all subsequent OpenGL calls
    in this class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查顶点数组对象是否已经生成；如果没有，我们使用我们的`m_vao`作为引用对象来创建一个。接下来我们绑定VAO，这将允许我们在这个类中的所有后续OpenGL调用中使用它：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next we check if our vertex buffer has been created; if not we create one using
    the `m_vertexbuffer` variable as the referenced object. We do the same for the
    `uvbuffer`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们检查我们的顶点缓冲是否已经创建；如果没有，我们使用`m_vertexbuffer`变量作为引用对象来创建一个。我们对`uvbuffer`也是同样的操作：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The last things we do in our `Meshes Init()` function, is to bind the `vertex`
    and `uv` buffers and then upload the data to those buffers on the graphics card
    with the use of the OpenGL, `glBindBuffer()` and `glBufferData()` functions. Check
    out the OpenGL documentation for more detailed information on these functions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Meshes Init()`函数中，我们做的最后一件事是绑定`vertex`和`uv`缓冲区，然后使用OpenGL的`glBindBuffer()`和`glBufferData()`函数将数据上传到图形卡上。查看OpenGL文档以获取有关这些函数的更详细信息：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the `Mesh` class `Draw()` function, we start out setting up the texture
    in the OpenGL API framework. We do this with the function calls `glActiveTexture()`,
    which activates the texture, and `glBindTexture()`, which does the actual binding
    of the texture data in memory:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Mesh`类的`Draw()`函数，我们首先在OpenGL API框架中设置纹理。我们使用函数调用`glActiveTexture()`来激活纹理，使用`glBindTexture()`来实际绑定内存中的纹理数据：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next we bind the buffers and set the attributes for both the vertex data and
    texture coordinate data. Again, I won't focus on the details here, the code has
    comments to explain the parameters of each. For more information on the functions,
    I recommend viewing the OpenGL documentation online.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们绑定缓冲区并设置顶点数据和纹理坐标数据的属性。同样，我不会在这里专注于细节，代码中有注释来解释每个参数。关于这些函数的更多信息，我建议在线查看OpenGL文档。
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After all the data is bound, and all the attributes are set, we can call the
    function to actually draw the `Mesh` object. In this case, we use the `glDrawArrays()`
    function, passing in `GL_TRIANGLES` as the method of drawing. This means we want
    to render the vertex data using triangles. For fun try changing this value to
    `GL_POINTS`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有数据都绑定，并且所有属性都设置好之后，我们可以调用函数来实际绘制`Mesh`对象。在这种情况下，我们使用`glDrawArrays()`函数，传入`GL_TRIANGLES`作为绘制的方法。这意味着我们要使用三角形来渲染顶点数据。尝试将这个值更改为`GL_POINTS`来玩玩。
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: At the end of our draw call, we have one last step to complete, the clean up.
    After every OpenGL draw call, it is required to disable the used attributes that
    have been set, and to unbind the used buffers. The `glDisableVertexAttribArray()`
    and `glBindBuffer()` functions are used for these tasks.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的绘制调用结束时，我们还有最后一步要完成，清理工作。在每次OpenGL绘制调用之后，需要禁用已设置的使用过的属性，并解绑已使用的缓冲区。`glDisableVertexAttribArray()`和`glBindBuffer()`函数用于这些任务。
- en: 'In the `GameplayScreen.cpp` file, we add our call to initialize the model:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameplayScreen.cpp`文件中，我们添加了初始化模型的调用：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then start to draw it by simply adding a call to the model''s `Draw()`
    function in the `Draw()` function of `GameplayScreen`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过简单地在`GameplayScreen`的`Draw()`函数中添加对模型的`Draw()`函数的调用来开始绘制它：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And that's it! If you run the `ModelExample`, you will see the output of the
    dwarf model on screen. I have also added a simple 3D camera to the game so you
    can move around the model. `W`, `A`, `S`, and `D` for moving the camera up, left,
    right, and down in game space. Use the mouse to look around.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果你运行`ModelExample`，你会在屏幕上看到矮人模型的输出。我还为游戏添加了一个简单的3D摄像头，这样你就可以在模型周围移动。在游戏空间中，使用`W`、`A`、`S`和`D`来移动摄像头。使用鼠标来四处看。
- en: 'The following is the output on Windows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Windows上的输出：
- en: '![](img/3b10abf5-6f28-4d57-9bda-a5ada9fa57a4.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b10abf5-6f28-4d57-9bda-a5ada9fa57a4.png)'
- en: 'The following is the output on macOS:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在macOS上的输出：
- en: '![](img/f83fd587-2824-447e-867f-26f6bff4ddee.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f83fd587-2824-447e-867f-26f6bff4ddee.png)'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a very important part of development, the handling
    of assets. We took a look at the process of importing, processing, and managing
    content, such as sound, images, and 3D objects. With this groundwork system in
    place, we can move on to rounding out the rest of the systems needed for game
    development.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了开发中非常重要的一个部分，即处理资产。我们看了一下导入、处理和管理内容（如声音、图像和3D对象）的过程。有了这个基础系统，我们可以继续完善游戏开发所需的其余系统。
- en: In the next chapter, we will look at developing the core gameplay systems needed,
    including state systems, physics, cameras, and GUI/HUD systems.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将着眼于开发核心的游戏玩法系统，包括状态系统、物理系统、摄像头和GUI/HUD系统。
