- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Libraries and Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和框架
- en: While the C++ standard library offers a vast array of containers and algorithms,
    certain aspects – such as dynamic memory allocation – can pose challenges in constrained
    environments. In [*Chapter 2*](Chapter_02.xhtml), we explored some of these issues
    and ways to address them. However, specialized libraries, like the **Embedded
    Template Library** (**ETL**), offer deterministic behavior and fixed memory footprints,
    making them well suited for embedded systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++标准库提供了大量的容器和算法，但某些方面——例如动态内存分配——在受限环境中可能会带来挑战。在[*第2章*](Chapter_02.xhtml)中，我们探讨了这些问题及其解决方法。然而，像**嵌入式模板库**（**ETL**）这样的专用库提供了确定性行为和固定内存占用，非常适合嵌入式系统。
- en: Embedded applications depend on **Hardware Abstraction Layers** (**HALs**) provided
    by vendors as C libraries. In [*Chapter 12*](Chapter_12.xhtml), we examined how
    to use interfaces to decouple application-level C++ code from the underlying C-based
    hardware interactions. Wrapping entire HALs in C++ is a lot of work, but luckily,
    there are projects such as Google’s Pigweed that are tackling exactly that, while
    offering additional functionality and flexibility for embedded development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用程序依赖于供应商提供的作为C库的**硬件抽象层**（**HALs**）。在[*第12章*](Chapter_12.xhtml)中，我们探讨了如何使用接口将应用层C++代码与底层基于C的硬件交互解耦。将整个HAL用C++包装是一项大量工作，但幸运的是，有像Google的Pigweed这样的项目正在处理这个问题，同时为嵌入式开发提供了额外的功能和灵活性。
- en: 'In [*Chapter 11*](Chapter_11.xhtml), we explored how C++ can perform computations
    at compile time, reducing memory footprint. In [*Chapter 15*](Chapter_15.xhtml),
    we learned about the Observer pattern and examined its compile-time implementation.
    Intel’s **Compile-time Initialization and Build** (**CIB**) elevates these ideas
    even further, enabling a declarative approach to configuring firmware applications
    at compile time. In this chapter, we will go through the following C++ libraries:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](Chapter_11.xhtml)中，我们探讨了C++如何在编译时执行计算，从而减少内存占用。在[*第15章*](Chapter_15.xhtml)中，我们学习了观察者模式并检查了其编译时实现。英特尔公司的**编译时初始化和构建**（**CIB**）将这些想法提升到了更高的层次，使得在编译时配置固件应用成为一种声明式方法。在本章中，我们将介绍以下C++库：
- en: Standard library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库
- en: Embedded template library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式模板库
- en: Pigweed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猪草
- en: Compile-time Initialization and Build
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时初始化和构建
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can try the examples from this chapter in the Renode simulator in the Docker
    container you set up in [*Chapter 4*](Chapter_04.xhtml). Make sure that the Docker
    container is running.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第4章*](Chapter_04.xhtml)中设置的Docker容器中的Renode模拟器中尝试本章的示例。请确保Docker容器正在运行。
- en: You can find the files for this chapter on GitHub at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的文件，地址为[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17)。
- en: Standard library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: 'The C++ standard defines two types of standard library implementation – hosted
    and freestanding:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准定义了两种标准库实现类型——带宿主环境和独立环境：
- en: A freestanding implementation is designed to run without relying on services
    typically provided by an OS, such as filesystem access or multi-threading support.
    As a result, the C++ standard specifies only a limited subset of standard library
    headers that must be provided by a freestanding implementation.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立实现旨在在没有依赖操作系统通常提供的服务的情况下运行，例如文件系统访问或多线程支持。因此，C++标准仅指定了必须由独立实现提供的标准库头文件的一个有限子集。
- en: A hosted implementation requires a globally defined main function, and the environment
    is responsible for invoking this function at startup. In a freestanding implementation,
    the startup routines and the entry point of the program are implementation-defined,
    allowing developers greater flexibility in specifying the initialization and execution
    flow of their applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宿主环境的实现需要一个全局定义的主函数，环境负责在启动时调用此函数。在独立实现中，启动例程和程序的入口点是实现定义的，这允许开发者有更大的灵活性来指定其应用程序的初始化和执行流程。
- en: Although the standard makes a clear distinction between hosted and freestanding
    implementation in terms of the globally defined main function, the configuration
    in some examples in this book blurs the line between the two.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准在全局定义的 `main` 函数方面对托管和独立实现进行了明确的区分，但本书中的一些示例配置模糊了两者之间的界限。
- en: Freestanding and hosted implementations in GCC
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GCC 中的独立和托管实现
- en: 'Even though we operate in a freestanding environment (no OS), some examples
    in this book use components from the C++ standard library (e.g., `std::function`),
    which are typically associated with hosted implementations. This is possible because:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在一个独立的环境中操作（没有操作系统），本书中的一些示例使用了 C++ 标准库的组件（例如，`std::function`），这些组件通常与托管实现相关联。这是可能的，因为：
- en: As we observed in [*Chapter 4*](Chapter_04.xhtml), we set the program entry
    point in the linker script to `Reset_Handler`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 4 章*](Chapter_04.xhtml) 中观察到的，我们在链接器脚本中将程序入口点设置为 `Reset_Handler`。
- en: '`Reset_Handler`, implemented in the assembler startup script, performs low-level
    initialization and explicitly calls `main`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在汇编器启动脚本中实现的 `Reset_Handler` 执行低级初始化并显式调用 `main`。
- en: We use nano specs ([*Chapter 7*](Chapter_07.xhtml)), linking against a size-optimized
    subset of the C++ standard library. This allows limited use of hosted features
    like `std::function` while avoiding dependencies on an OS.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 nano 规范（[*第 7 章*](Chapter_07.xhtml)），链接到一个大小优化的 C++ 标准库子集。这允许有限地使用托管功能，如
    `std::function`，同时避免对操作系统的依赖。
- en: This hybrid approach leverages GCC’s flexibility to combine freestanding execution
    (custom entry point, no OS) with hosted library features (standard headers, utilities)
    in a bare-metal environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合方法利用 GCC 的灵活性，在裸机环境中结合独立执行（自定义入口点，没有操作系统）和托管库功能（标准头文件，实用工具）。
- en: To explicitly request GCC to use a freestanding implementation of the standard
    library, the compiler flag `-ffreestanding` should be used. The C++ standard library
    provides many components that are “pay only for what you use” and can be very
    useful even in resource‐constrained environments. In previous chapters, you’ve
    already worked with many parts of the standard library, so you have a solid understanding
    of its capabilities. Here, we’ll provide an overview of the parts that are best
    suited for resource‐constrained environments and point out which ones should be
    used with caution or avoided.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确请求 GCC 使用标准库的独立实现，应使用编译器标志 `-ffreestanding`。C++ 标准库提供了许多“按需付费”的组件，即使在资源受限的环境中也非常有用。在前几章中，你已经与标准库的许多部分一起工作过，因此你对它的功能有了坚实的理解。在这里，我们将概述最适合资源受限环境的部分，并指出哪些部分应谨慎使用或避免使用。
- en: Numeric and math
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值和数学
- en: Embedded systems are often employed in automation and process control, requiring
    precise control over numeric types, their ranges, and math operations. The C++
    standard library provides the `<cstdint>`, `<limits>`, and `<cmath>` headers to
    define fixed-width integers, query numeric limits, and perform mathematical computations,
    helping ensure predictable behavior, portability, and efficiency in resource-constrained
    environments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常用于自动化和过程控制，需要精确控制数值类型、它们的范围和数学运算。C++ 标准库提供了 `<cstdint>`、`<limits>` 和
    `<cmath>` 头文件来定义固定宽度的整数、查询数值限制和执行数学计算，有助于确保在资源受限环境中可预测的行为、可移植性和效率。
- en: <cstdint>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<cstdint>`'
- en: The `<cstdint>` header provides fixed-width integer types such as `std::int8_t`,
    `std::uint32_t`, and other well-known C types defined in `stdint.h`. These types
    are useful in embedded contexts where integer size and bit width are important
    for direct hardware register access, predictable overflow behavior, and memory
    usage considerations. By using them, you explicitly document your intention for
    a variable’s size, thereby improving code portability and preventing potential
    surprises when moving between platforms with different native integer widths.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cstdint>` 头文件提供了固定宽度的整数类型，如 `std::int8_t`、`std::uint32_t`，以及其他在 `stdint.h`
    中定义的知名 C 类型。这些类型在嵌入式环境中非常有用，在这些环境中，整数的大小和位宽对于直接访问硬件寄存器、可预测的溢出行为和内存使用考虑非常重要。通过使用它们，你明确记录了变量大小的意图，从而提高了代码的可移植性，并防止在不同原生整数宽度平台之间迁移时出现潜在惊喜。'
- en: <limits>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<limits>`'
- en: The header provides the `std::numeric_limits` template, which describes properties
    of fundamental numeric types (like minimum and maximum values, sign, and precision).
    This is especially useful in embedded contexts for handling overflow. Typical
    usage occurs at compile-time or through trivial inlining by the compiler, resulting
    in minimal runtime overhead. By using functions like `std::numeric_limits::max()`,
    you avoid scattering magic constants or architecture-specific assumptions, aiding
    portability and maintainability.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该头文件提供了 `std::numeric_limits` 模板，它描述了基本数值类型（如最小和最大值、符号和精度）的性质。这在嵌入式环境中处理溢出时特别有用。典型用法发生在编译时或通过编译器的简单内联，从而产生最小的运行时开销。通过使用
    `std::numeric_limits::max()` 等函数，您避免了散布魔法常数或架构特定的假设，有助于可移植性和可维护性。
- en: <cmath>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <cmath>
- en: The `<cmath>` header provides standard math functions such as `std::sin`, `std::cos`,
    `std::sqrt`, and more. In embedded environments, especially those without floating-point
    hardware, these functions can be relatively expensive in terms of both runtime
    performance and code size. Carefully consider whether you really need floating-point
    math, and if so, whether approximations or fixed-point routines might be sufficient
    and more efficient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cmath>` 头文件提供了标准数学函数，如 `std::sin`、`std::cos`、`std::sqrt` 等。在嵌入式环境中，尤其是在没有浮点硬件的环境中，这些函数在运行时性能和代码大小方面可能相对昂贵。仔细考虑您是否真的需要浮点数学，如果是这样，是否近似或定点例程可能足够且更高效。'
- en: Containers and algorithms
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和算法
- en: Embedded systems often manage structured data and require efficient ways to
    process it under tight resource constraints. The C++ standard library offers container
    and algorithm headers such as `<array>`, `<span>`, and `<algorithm>` to organize
    data and perform common operations like searching, sorting, and transforming,
    enabling more readable and maintainable code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常管理结构化数据，并在资源受限的紧密约束下需要高效地处理它。C++ 标准库提供了容器和算法头文件，如 `<array>`、`<span>`
    和 `<algorithm>`，以组织数据并执行常见的操作，如搜索、排序和转换，从而实现更易读和可维护的代码。
- en: std::array
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::array
- en: The only fixed-size container in the standard library that avoids dynamic allocation
    is `std::array`. We covered it in [*Chapter 1*](Chapter_01.xhtml), when we discussed
    generic types. In the same chapter, we based the ring buffer implementation on
    `std::array`, which allowed us to create ring buffers of different types and sizes
    using the same generic code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，唯一避免动态分配的固定大小容器是 `std::array`。我们在[*第一章*](Chapter_01.xhtml)中讨论泛型类型时提到了它。在同一章中，我们将环形缓冲区实现基于
    `std::array`，这使得我们可以使用相同的泛型代码创建不同类型和大小的环形缓冲区。
- en: '`std::array` is typically implemented as a wrapper around a C-style array.
    Besides being a generic type, it also offers the `at` method for index-based access
    with runtime bounds checking, making it a safer alternative to raw arrays. If
    an out-of-bounds index is requested, the `at` method will throw an exception.
    If exceptions are disabled, it may call `std::terminate` or `std::abort`, depending
    on the library implementation. These behaviors should be handled according to
    your system requirements by implementing appropriate terminate and signal handlers.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 通常被实现为一个围绕 C 风格数组的包装器。除了是一个泛型类型外，它还提供了基于索引访问的 `at` 方法，该方法具有运行时边界检查，使其成为原始数组的更安全替代品。如果请求超出边界的索引，`at`
    方法将抛出异常。如果禁用了异常，它可能会调用 `std::terminate` 或 `std::abort`，具体取决于库的实现。这些行为应根据您的系统要求通过实现适当的终止和信号处理程序来处理。'
- en: 'std:: priority_queue'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'std:: priority_queue'
- en: '`std::priority_queue` is a container adapter that provides priority queue functionality.
    By default, it uses `std::vector` as the underlying container. However, as shown
    in [*Chapter 14*](Chapter_14.xhtml), you can substitute it with `etl::vector`
    from ETL, avoiding issues with dynamic memory allocation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 是一个提供优先队列功能的容器适配器。默认情况下，它使用 `std::vector` 作为底层容器。然而，如[*第14章*](Chapter_14.xhtml)所示，您可以将其替换为来自
    ETL 的 `etl::vector`，从而避免动态内存分配的问题。'
- en: 'std:: span'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'std:: span'
- en: As shown in [*Chapter 9*](Chapter_09.xhtml), `std::span` is a lightweight, non-owning
    wrapper around a contiguous sequence of objects, where the first element is at
    position 0\. It provides essential functionality such as the `size()` method,
    `operator[]` for element access, and the `begin()` and `end()` iterators, allowing
    it to integrate seamlessly with standard library algorithms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第 9 章*](Chapter_09.xhtml)所示，`std::span` 是围绕连续对象序列的轻量级、非拥有包装器，其中第一个元素位于位置
    0。它提供了诸如 `size()` 方法、用于元素访问的 `operator[]` 以及 `begin()` 和 `end()` 迭代器等基本功能，使其能够无缝地与标准库算法集成。
- en: '`std::span` can be constructed from C-style arrays as well as containers like
    `std::array` and `std::vector` or `etl::vector`. This makes it a practical alternative
    to using separate pointer and size parameters, which is especially useful when
    interfacing C++ code with C libraries such as those used in HAL.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 可以从 C 风格数组以及容器如 `std::array`、`std::vector` 或 `etl::vector` 中构造。这使得它成为使用单独的指针和大小参数的实用替代品，这在将
    C++ 代码与 C 库（如 HAL 中使用的库）接口时特别有用。'
- en: Iterators
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: Iterators are abstractions that act like generalized pointers, providing a uniform
    way to traverse and access elements within a container. For example, standard
    library containers implement the `begin()` and `end()` methods, which return iterators
    marking the start and one-past-the-end of their sequence. This consistent interface
    allows algorithms to work generically over different container types, enhancing
    code reusability and clarity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是抽象，它们像通用指针一样工作，提供了一种统一的方式来遍历和访问容器内的元素。例如，标准库容器实现了 `begin()` 和 `end()` 方法，它们返回标记序列起始和结束位置的迭代器。这种一致的接口允许算法在多种容器类型上以通用方式工作，增强代码的可重用性和清晰性。
- en: 'Let us go through the following example using `std::array`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下使用 `std::array` 的示例来了解：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example demonstrates how to use iterators with a standard library container:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了如何使用标准库容器与迭代器一起使用：
- en: The iterator `start` is explicitly declared as `std::array<int, 5>::iterator`
    to illustrate the full type name, while the iterator `finish` is declared using
    `auto` for conciseness, allowing the compiler to deduce its type.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器 `start` 明确声明为 `std::array<int, 5>::iterator` 以展示完整的类型名，而迭代器 `finish` 使用
    `auto` 声明以提高简洁性，允许编译器推断其类型。
- en: The `std::sort` algorithm is applied using the iterators `start` and `finish`,
    obtained from `arr.begin()` and `arr.end()`, to sort the array in ascending order.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从 `arr.begin()` 和 `arr.end()` 获得的迭代器 `start` 和 `finish` 应用 `std::sort` 算法，以升序对数组进行排序。
- en: The loop uses `auto` to declare the iterator `it`, which makes the code more
    concise. The loop traverses the sorted array, and `printf` is used to print each
    element.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环使用 `auto` 声明迭代器 `it`，这使得代码更加简洁。循环遍历排序后的数组，并使用 `printf` 打印每个元素。
- en: Iterators are used to traverse containers. They not only promote generic programming
    but also make it easy to switch container types without changing the algorithmic
    logic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器用于遍历容器。它们不仅促进了通用编程，还使得在不更改算法逻辑的情况下轻松切换容器类型变得容易。
- en: Algorithms
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'Algorithms from the standard library offer a consistent way to solve common
    problems across different containers, making the code more expressive and easier
    to maintain. They allow you to perform operations like searching, sorting, copying,
    and accumulating data using a uniform interface. Some of the most used algorithms
    are listed here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的算法提供了一种在不同容器中解决常见问题的统一方式，使代码更具表达性和易于维护。它们允许您使用统一接口执行搜索、排序、复制和累积数据等操作。以下列出了一些最常用的算法：
- en: '`std::sort`: Sorts a range of elements in ascending order by default, using
    the less-than operator for comparison. It can also accept a custom comparator
    to sort based on different criteria, such as descending order or a specific object
    property.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort`：默认按升序对元素范围进行排序，使用小于运算符进行比较。它还可以接受自定义比较器，根据不同的标准进行排序，例如降序或特定对象属性。'
- en: '`std::find`: Searches for the first occurrence of a given value in a range
    and returns an iterator to it. If the value is not found, it returns the end iterator,
    signaling that the search failed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::find`：在范围内搜索给定值的第一个出现，并返回指向它的迭代器。如果找不到该值，则返回结束迭代器，表示搜索失败。'
- en: '`std::for_each`: Applies a specified function or lambda to each element in
    a range.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::for_each`：将指定的函数或 lambda 应用于范围内的每个元素。'
- en: '`std::copy`: Copies the elements of one range into another destination range.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::copy`：将一个范围的元素复制到另一个目标范围。'
- en: '`std::copy_if`: Copies only elements that satisfy a specified predicate, making
    it useful for filtering data as you copy.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::copy_if`：仅复制满足指定谓词的元素，这使得在复制数据时过滤数据变得很有用。'
- en: '`std::min` and `std::max`: Return the smaller or larger of two values, respectively,
    using the less-than operator by default (or a provided comparison function). They’re
    handy for quick comparisons where you just need the minimum or maximum of two
    values.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::min` 和 `std::max`：分别返回两个值中的较小或较大值，默认使用小于运算符（或提供的比较函数）。它们在只需要比较两个值的最小或最大值时非常有用。'
- en: '`std::min_element` and `std::max_element`: Return an iterator to the smallest
    or largest element in a range. These are useful when you need to find the position
    of an extreme value in a container (instead of comparing just two values).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::min_element` 和 `std::max_element`：返回范围中最小或最大元素的迭代器。当您需要在一个容器中找到极端值的位罝时（而不是仅仅比较两个值），这些非常有用。'
- en: '`std::accumulate`: Iterates over a range and combines the elements with an
    initial value using a binary operation (default is addition). This allows for
    summing values, computing products, or performing any custom aggregation you define.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::accumulate`：遍历一个范围，并使用二进制运算（默认为加法）将元素与初始值组合。这允许对值求和、计算乘积或执行您定义的任何自定义聚合。'
- en: Template metaprogramming
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板元编程
- en: As discussed in [*Chapter 8*](Chapter_08.xhtml), C++ type traits are compile-time
    predicates and transformations that allow the compiler to enforce constraints
    based on a type’s properties. They are used for writing generic, robust code without
    incurring runtime overhead. In [*Chapter 12*](Chapter_12.xhtml), we used type
    traits to create type-safe register access, preventing invalid type usage at compile
    time and reducing the risk of subtle errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第8章*](Chapter_08.xhtml)所述，C++类型特性是编译时谓词和转换，允许编译器根据类型的属性强制约束。它们用于编写通用、健壮的代码，而不会产生运行时开销。在[*第12章*](Chapter_12.xhtml)中，我们使用类型特性创建类型安全的寄存器访问，防止编译时无效类型的使用，并降低细微错误的几率。
- en: 'Here are some concrete type traits we’ve utilized in the chapters mentioned
    in this section:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中提到的章节中，我们利用了一些具体的类型特性：
- en: '`std::enable_if`: Enables or disables function templates based on a Boolean
    compile-time expression'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::enable_if`：根据布尔编译时表达式启用或禁用函数模板'
- en: '`std::is_same`: Checks if two types are exactly the same'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_same`：检查两个类型是否完全相同'
- en: '`std::is_enum`: Checks if a type is an enumeration type'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_enum`：检查一个类型是否是枚举类型'
- en: '`std::underlying_type`: Retrieves the underlying integer type of an enum'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::underlying_type`：检索枚举的基本整数类型'
- en: '`std::is_arithmetic`: Checks if a type is an arithmetic type (integral or floating-point)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_arithmetic`：检查一个类型是否是算术类型（整型或浮点型）'
- en: '`std::is_integral`: Checks if a type is an integral type'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_integral`：检查一个类型是否是整型'
- en: '`std::is_floating_point`: Checks if a type is a floating-point type'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_floating_point`：检查一个类型是否是浮点类型'
- en: Parts of the standard library to avoid in embedded applications
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在嵌入式应用程序中应避免的标准库部分
- en: Many containers from the standard library, such as `std::vector`, `std::list`,
    and `std::string`, use dynamic memory allocation. If dynamic memory allocation
    is not allowed in your embedded application, these should be avoided.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的许多容器，如 `std::vector`、`std::list` 和 `std::string`，使用动态内存分配。如果您的嵌入式应用程序不允许动态内存分配，应避免使用这些。
- en: The `iostream` library, included with header `<iostream>,` requires significant
    memory resources and also relies on dynamic allocation. That’s why we used the
    `<cstdio>` header and the `printf` function for console output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在头文件 `<iostream>` 中的 `iostream` 库需要大量的内存资源，并且依赖于动态分配。这就是为什么我们使用了 `<cstdio>`
    头文件和 `printf` 函数来进行控制台输出。
- en: In [*Chapter 10*](Chapter_10.xhtml), we covered `std::function` from the `<functional>`
    header. There, we outlined that in some scenarios, `std::function` can use dynamic
    memory allocation, meaning if used, it should be used with caution. Note that
    `std::function` is not available in a freestanding implementation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](Chapter_10.xhtml)中，我们介绍了 `<functional>` 头文件中的 `std::function`。在那里，我们概述了在某些情况下，`std::function`
    可以使用动态内存分配，这意味着如果使用，应谨慎使用。请注意，`std::function` 在独立实现中不可用。
- en: Next, we will give a short overview of ETL that compliments the standard library
    in the context of restricted embedded environments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要概述 ETL，它补充了在受限嵌入式环境中的标准库。
- en: Embedded template library
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式模板库
- en: 'In [*Chapter 2*](Chapter_02.xhtml), we saw that `std::vector` uses dynamic
    memory allocation by default. We also saw that we can use `std:: polymorphic_allocator`
    and a monotonic buffer to make it use statically allocated memory. This approach
    is still not bulletproof as `std::vector` in some cases can resort to dynamic
    memory allocation even with this approach.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](Chapter_02.xhtml)中，我们了解到`std::vector`默认使用动态内存分配。我们还了解到，我们可以使用`std::polymorphic_allocator`和一个单调缓冲区使其使用静态分配的内存。这种方法仍然不是万无一失的，因为即使在采用这种方法的情况下，`std::vector`在某些情况下仍然可能求助于动态内存分配。
- en: To address some of the challenges posed by the standard library in embedded
    contexts, ETL provides a set of templated containers and algorithms that closely
    mimic the interfaces of standard library counterparts but are tailored for systems
    with limited resources.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决标准库在嵌入式环境中所提出的挑战，ETL提供了一套模板容器和算法，它们紧密模仿标准库对应物的接口，但针对资源有限的系统进行了定制。
- en: Fixed-size containers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定大小的容器
- en: One of the primary advantages of ETL is that its containers (such as `etl::vector`,
    `etl::list`, `etl::string`, and others) allow you to specify a fixed maximum size
    at compile time. Container implementations ensure that no dynamic memory allocation
    is performed at runtime as memory is reserved up front as atomic or static storage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ETL的主要优势之一是其容器（如`etl::vector`、`etl::list`、`etl::string`等）允许你在编译时指定一个固定的最大大小。容器实现确保在运行时不会执行动态内存分配，因为内存是在前端作为原子或静态存储预留的。
- en: As ETL containers are designed to mimic standard library containers, and they
    implement iterators, they can be used with most algorithms and container adapters
    from the standard library. This allows us to leverage components from the standard
    library without worrying about dynamic allocation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ETL容器旨在模仿标准库容器，并且它们实现了迭代器，因此它们可以与标准库中的大多数算法和容器适配器一起使用。这使我们能够利用标准库中的组件，而无需担心动态分配。
- en: ETL also offers `etl::array` for platforms that do not support C++11, since
    `std::array` was introduced in C++11.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++11中引入了`std::array`，ETL为不支持C++11的平台提供了`etl::array`。
- en: Storing a callable with etl::delegate
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`etl::delegate`存储可调用对象
- en: As shown in [*Chapter 14*](Chapter_14.xhtml), you can use `etl::delegate` instead
    of `std::function` to store a callable. However, `etl::delegate` is non-owning,
    so you must handle potential dangling references carefully.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第14章*](Chapter_14.xhtml)所示，你可以使用`etl::delegate`代替`std::function`来存储可调用对象。然而，`etl::delegate`是非所有权的，因此你必须小心处理潜在的悬垂引用。
- en: Other utilities provided by ETL
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ETL提供的其他实用工具
- en: Besides fixed-size containers and `etl::delegate`, ETL also provides utilities
    such as a messaging framework – a collection of messages, message routers, message
    buses, and finite state machines. It also offers CRC calculations, checksums,
    and hash functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了固定大小的容器和`etl::delegate`之外，ETL还提供了一些实用工具，例如消息框架——一组消息、消息路由器、消息总线以及有限状态机。它还提供了CRC计算、校验和以及哈希函数。
- en: ETL allows you to configure error handling. It can be configured to throw exceptions
    or send errors to the user-defined handler. This allows greater flexibility and
    project-based configuration depending on system requirements.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ETL允许你配置错误处理。它可以配置为抛出异常或将错误发送到用户定义的处理程序。这提供了更大的灵活性和基于项目需求的配置。
- en: You can learn more about ETL at the website [https://www.etlcpp.com/](https://www.etlcpp.com/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.etlcpp.com/](https://www.etlcpp.com/)网站上了解更多关于ETL的信息。
- en: Next, we will discuss Pigweed – a collection of lightweight, modular C++ libraries
    for embedded systems, developed by Google, offering components like logging, assertions,
    and Bluetooth connectivity to simplify development and improve code reuse.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Pigweed——由Google开发的一组轻量级、模块化的C++库，用于嵌入式系统，提供日志记录、断言和蓝牙连接等组件，以简化开发并提高代码重用性。
- en: Pigweed
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pigweed
- en: One of the biggest challenges in embedded systems development is portability.
    For code to be truly portable, it must depend on interfaces. To run it on different
    hardware targets, someone needs to implement those interfaces on different targets.
    Maintaining consistent interfaces across various projects and devices can be difficult.
    Google’s Pigweed project aims to solve this by providing software modules for
    embedded applications, with hardware interfaces already implemented for many targets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统开发中最大的挑战之一是可移植性。为了使代码真正可移植，它必须依赖于接口。为了在不同的硬件目标上运行，需要有人在不同的目标上实现这些接口。在各个项目和设备之间维护一致的接口可能很困难。Google的Pigweed项目旨在通过提供嵌入式应用的软件模块来解决这一问题，其中许多目标已经实现了硬件接口。
- en: 'Pigweed is intended for complex projects and large-scale teams. Besides the
    hardware interfaces, it also:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pigweed旨在用于复杂项目和大型团队。除了硬件接口外，它还：
- en: Packs software modules built on top of them, such as logging, serial communication
    (SPI, I2C, and UART), Bluetooth **Host Controller Interface** (**HCI**), interactive
    console, **Remote Procedure Call** (**RPC**) system, and more.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包了基于它们的软件模块，例如日志记录、串行通信（SPI、I2C和UART）、蓝牙**主机控制器接口**（**HCI**）、交互式控制台、**远程过程调用**（**RPC**）系统等。
- en: 'Provides embedding-friendly alternatives to standard library components: fixed-size
    strings and containers.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了标准库组件的嵌入式友好替代方案：固定大小的字符串和容器。
- en: Manages the entire toolchain out of the box and simplifies setting up your development
    environment.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开箱即用管理整个工具链，简化了开发环境的设置。
- en: Provides an entire framework – `pw_system` – which pulls together many modules
    across Pigweed to construct a working system with RPC, logging, and more.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个完整的框架——`pw_system`——它将Pigweed中的许多模块组合在一起，构建了一个具有RPC、日志记录等功能的运行系统。
- en: As you can see, Pigweed is not only a library – it is an entire development
    ecosystem. It can be used as a framework, but you can also cherry-pick individual
    modules that suit your needs. As stated on the documentation website – [https://pigweed.dev/](https://pigweed.dev/)
    – Pigweed is still in its early stages; some modules are still in development
    stages, while some are stable and used on devices that are already on the market.
    As with any library, you need to evaluate it for potential use in your projects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Pigweed不仅是一个库——它是一个完整的开发生态系统。它可以作为一个框架使用，但您也可以挑选适合您需求的单个模块。正如文档网站[https://pigweed.dev/](https://pigweed.dev/)上所述——Pigweed仍处于早期阶段；一些模块仍在开发中，而一些则已稳定并用于市场上的一些设备。与任何库一样，您需要评估它是否适合在您的项目中使用。
- en: We’ll go through Pigweed’s Sense tutorial to demonstrate some of its capabilities
    – mainly the interactive console and **RPC** system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行Pigweed的Sense教程，以展示其一些功能——主要是交互式控制台和**RPC**系统。
- en: Pigweed’s Sense tutorial
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pigweed的Sense教程
- en: The Sense project is a demo project that utilizes many Pigweed components and
    shows how they work together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Sense项目是一个演示项目，它利用了许多Pigweed组件，并展示了它们是如何协同工作的。
- en: 'Sense is a simplified version of an air quality sensor that only includes some
    of the functions of a full product. The goal is to give you practical experience
    with working with Pigweed by following these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Sense是一个简化版的空气质量传感器，它只包含完整产品的一些功能。目标是让您通过以下步骤获得使用Pigweed的实际经验：
- en: 'First, make sure the Docker daemon is running. Start a Docker image in network
    host mode and attach it to Bash. You can use the following commands in a Linux
    environment:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保Docker守护进程正在运行。以网络主机模式启动一个Docker镜像并将其附加到Bash。在Linux环境中，您可以使用以下命令：
- en: '[PRE1]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the Windows-based host, use the following command to forward the ports
    needed to run the tutorial:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Windows的主机，请使用以下命令来转发运行教程所需的端口：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, clone the Sense repo:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，克隆Sense仓库：
- en: '[PRE3]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, start Visual Studio Code, attach to the running container, and open the
    `/workspace/sense` folder. If you see a pop-up message in **Visual Studio Code**
    recommending the installation of the Pigweed extension, accept it; otherwise,
    go to **Extensions**, search for `Pigweed`, and install it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动Visual Studio Code，连接到正在运行的容器，并打开`/workspace/sense`文件夹。如果您在**Visual Studio
    Code**中看到一个弹出消息建议安装Pigweed扩展，请接受它；否则，转到**扩展**，搜索`Pigweed`并安装它。
- en: '![Figure 17.1 – Visual Studio Code extension](img/B22402_17_1.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – Visual Studio Code扩展](img/B22402_17_1.png)'
- en: Figure 17.1 – Visual Studio Code extension
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – Visual Studio Code扩展
- en: '*Figure 17**.1* depicts the Visual Studio Code Pigweed extension.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.1*展示了Visual Studio Code Pigweed扩展。'
- en: After the installation of the extension, go to Explorer view and expand the
    **BAZEL BUILD TARGETS** node. Click on the **Refresh Target List** button.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装扩展后，转到资源管理器视图并展开 **BAZEL 构建目标** 节点。点击 **刷新目标列表** 按钮。
- en: '![Figure 17.2 – BAZEL BUILD TARGETS node](img/B22402_17_2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2 – BAZEL 构建目标节点](img/B22402_17_2.png)'
- en: Figure 17.2 – BAZEL BUILD TARGETS node
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – BAZEL 构建目标节点
- en: 'Refreshing the target list can take between 30 seconds and a couple of minutes.
    Pigweed uses Bazel for build automation. The refreshed target list should look
    similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新目标列表可能需要 30 秒到几分钟不等。Pigweed 使用 Bazel 进行构建自动化。刷新后的目标列表应类似于以下内容：
- en: '![Figure 17.3 – BAZEL BUILD TARGETS](img/B22402_17_3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – BAZEL 构建目标](img/B22402_17_3.png)'
- en: Figure 17.3 – BAZEL BUILD TARGETS
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – BAZEL 构建目标
- en: '*Figure 17**.3* depicts Bazel build targets.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17.3* 描述了 Bazel 构建目标。'
- en: Next, expand the **//apps/blinky** node.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，展开 **//apps/blinky** 节点。
- en: '![Figure 17.4 – //apps/blinky targets](img/B22402_17_4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – //apps/blinky 目标](img/B22402_17_4.png)'
- en: Figure 17.4 – //apps/blinky targets
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – //apps/blinky 目标
- en: 'Now, we will build a version of the app that runs on the host. Right-click
    **simulator_blinky (host_device_simulator_binary)** and then click **Build Target**.
    The build can take around 10 minutes. When completed, you should see a message
    similar to this one:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将构建一个在主机上运行的应用程序版本。右键单击 **simulator_blinky (host_device_simulator_binary**)，然后点击
    **构建目标**。构建可能需要大约 10 分钟。完成后，你应该会看到类似以下的消息：
- en: '![Figure 17.5 – Successful build](img/B22402_17_5.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.5 – 构建成功](img/B22402_17_5.png)'
- en: Figure 17.5 – Successful build
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 – 构建成功
- en: 'After a successful build, we will start the app. Right-click **simulator_blinky
    (host_device_simulator_binary)** and then **Run Target**. If successful, you should
    see the following message in the terminal: **Awaiting connection on port 33000**.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建成功后，我们将启动应用程序。右键单击 **simulator_blinky (host_device_simulator_binary**)，然后选择
    **运行目标**。如果成功，你应该会在终端中看到以下消息：**在端口 33000 上等待连接**。
- en: 'Next, right-click **simulator_console (native_binary)** and then **Run Target**.
    This will build a console and connect it to the running simulator. If successful,
    you should see the following screen:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击 **simulator_console (native_binary**)，然后选择 **运行目标**。这将构建一个控制台并将其连接到正在运行的模拟器。如果成功，你应该会看到以下屏幕：
- en: '![Figure 17.6 – Interactive console running in terminal view](img/B22402_17_6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6 – 在终端视图中运行的交互式控制台](img/B22402_17_6.png)'
- en: Figure 17.6 – Interactive console running in terminal view
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 – 在终端视图中运行的交互式控制台
- en: In *Figure 17**.6*, you can see the interactive console running in the terminal
    view in Visual Studio Code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 17.6* 中，你可以看到在 Visual Studio Code 的终端视图中运行的交互式控制台。
- en: 'To make the console easier to work with, right-click on **Run //apps/blinky:simulator_console**
    and select **Move Terminal into New Window**. This will move the console into
    a separate window, as shown in this image:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使控制台更容易使用，右键单击 **Run //apps/blinky:simulator_console** 并选择 **将终端移动到新窗口**。这将把控制台移动到单独的窗口，如图所示：
- en: '![Figure 17.7 – Interactive console running in a separate window](img/B22402_17_7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.7 – 在单独窗口中运行的交互式控制台](img/B22402_17_7.png)'
- en: Figure 17.7 – Interactive console running in a separate window
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – 在单独窗口中运行的交互式控制台
- en: In *Figure 17**.7*, in the top-right pane, **Device Logs**, we can see logs
    coming from the simulated device (app running on the host). It sends **LED blinking**
    messages every second.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 17.7* 中，右上角的 **设备日志** 窗格中，我们可以看到来自模拟设备（在主机上运行的应用程序）的日志。它每秒发送 **LED 闪烁**
    消息。
- en: 'Next, we will send a message to the device using the RPC protocol, to retrieve
    the temperature measured by the device. Enter the following command in the bottom-left
    pane – **Python Repl**:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 RPC 协议向设备发送消息，以检索设备测量的温度。在左下角的窗格中输入以下命令 – **Python Repl**：
- en: '[PRE4]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following response:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, send a message that will toggle the LED:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，发送一条将切换 LED 的消息：
- en: '[PRE6]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This call will make the LED blink three times at a 200 ms interval and afterward
    stop the **LED blinking** messages. This shows us that we can also provide arguments
    to RPC calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用将使 LED 以 200 毫秒的间隔闪烁三次，然后停止 **LED 闪烁** 消息。这表明我们也可以向 RPC 调用提供参数。
- en: Next, we will go through Pigweed’s RPC in more detail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更详细地介绍 Pigweed 的 RPC。
- en: RPC and Protocol Buffers
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPC 和 Protocol Buffers
- en: Pigweed’s RPC system is based on Protocol Buffers – a platform-neutral mechanism
    used for data serialization. Protocol Buffers is a language with its own syntax,
    which can be compiled into a targeted language such as C++ on our Sense device
    and the Python code we used in the Python **Read Eval Print Loop** (**REPL**).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Pigweed 的 RPC 系统基于 Protocol Buffers – 一种用于数据序列化的平台无关机制。Protocol Buffers 是一种具有自己语法的语言，它可以编译成我们的
    Sense 设备上的 C++ 等目标语言以及我们在 Python **Read Eval Print Loop**（**REPL**）中使用的 Python
    代码。
- en: 'So, why use an extra layer of abstraction, such as Protocol Buffers, in an
    embedded application? There are a couple of benefits a standardized serialization
    brings to your projects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么在嵌入式应用程序中使用像 Protocol Buffers 这样的额外抽象层呢？标准化序列化给您的项目带来了一些好处：
- en: Compact binary messages – they add very little overhead.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑的二进制消息 – 它们添加的额外开销非常小。
- en: A precise contract (a `.proto` file) between different parts of a system, ensuring
    that all parties agree on the structure and meaning of the exchanged data.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统不同部分之间精确的合同（`.proto` 文件），确保所有各方都同意交换数据的结构和含义。
- en: Updates to the communication protocol can be managed by modifying a proto file.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改 proto 文件可以管理通信协议的更新。
- en: In short, instead of writing serialization and deserialization code in multiple
    code bases (C++ and Python) and maintaining it as such, you write the communication
    protocol in a proto file and use the Protocol Buffers compiler to generate C++
    and Python code used for serialization.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，而不是在多个代码库（C++ 和 Python）中编写序列化和反序列化代码并维护它们，您在 proto 文件中编写通信协议，并使用 Protocol
    Buffers 编译器生成用于序列化的 C++ 和 Python 代码。
- en: 'Let us examine a part of the `modules/blinky/blinky.proto` file describing
    the Blinky service used in the *Pigweed’s Sense tutorial* section to blink the
    LED three times at 200 ms intervals in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `modules/blinky/blinky.proto` 文件的一部分，该部分描述了在 *Pigweed 的 Sense 教程* 部分中使用的
    Blinky 服务，该服务在以下代码中以 200 毫秒的间隔闪烁 LED 三次：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This proto file defines a service called `Blinky` for controlling an LED, using
    Protocol Buffers version 3 (`syntax = "proto3"`). It imports a `common` proto
    file and defines two methods:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此 proto 文件定义了一个名为 `Blinky` 的服务，用于控制 LED，使用 Protocol Buffers 版本 3（`syntax = "proto3"`）。它导入了一个
    `common` proto 文件并定义了两个方法：
- en: '`ToggleLed`: A simple method that switches the LED on or off, using an empty
    request and response.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToggleLed`: 一个简单的使用空请求和响应切换 LED 开关的方法。'
- en: '`Blink`: A method that blinks the LED with a configurable `interval_ms` and
    `optional blink_count` (members of `BlinkRequest`). The use of the `optional`
    keyword means this parameter can be omitted when calling the method.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blink`: 一种通过可配置的 `interval_ms` 和 `optional blink_count`（`BlinkRequest` 的成员）闪烁
    LED 的方法。使用 `optional` 关键字意味着在调用方法时可以省略此参数。'
- en: 'This is a short explanation of the blinky.proto file. A more thorough guide
    to Protocol Buffers can be found at the following website: [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 blinky.proto 文件的简要说明。更详细的 Protocol Buffers 指南可以在以下网站上找到：[https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)。
- en: 'For each service in a `blinky` proto file, Pigweed’s code generator will generate
    a corresponding C++ class. The generated `Blinky` class resides in a dedicated
    `pw_rpc::nanopb` sub-namespace within the file’s package: `blinky::pw_rpc::nanopb::Blinky::Service`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `blinky` proto 文件中的每个服务，Pigweed 的代码生成器将生成相应的 C++ 类。生成的 `Blinky` 类位于文件包的专用
    `pw_rpc::nanopb` 子命名空间内：`blinky::pw_rpc::nanopb::Blinky::Service`。
- en: 'The generated class serves as a base class that must be inherited to implement
    the service’s methods. It is templated on the derived class. The `BlinkyService`
    class implements the base class. The following code is part of its definition
    from the `modules/blinky/service.h` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的类作为必须继承以实现服务方法的基类。它基于派生类进行模板化。`BlinkyService` 类实现了基类。以下代码是其定义的一部分，来自 `modules/blinky/service.h`
    文件：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`BlinkyService` bridges the generated RPC interface with the concrete implementation
    for controlling the LED. It has a private object, `blinky_`, of type `Blinky`,
    which is used to control an LED, as shown in the implementation of the `ToggleLed`
    and `Blink` methods in the following code block from the `modules/blinky/service.cc`
    file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlinkyService` 在生成的 RPC 接口与控制 LED 的具体实现之间架起桥梁。它有一个私有的 `blinky_` 对象，其类型为 `Blinky`，用于控制
    LED，如以下代码块中 `modules/blinky/service.cc` 文件中 `ToggleLed` 和 `Blink` 方法的实现所示：'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, the methods `ToggleLed` and `Blink` use the `blinky_` object to
    control the LED. When binary proto messages for the `blinky` service are received
    over a transport layer, they are converted into actual calls to the code used
    to control hardware, which is the essence of RPC.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`ToggleLed`和`Blink`方法使用`blinky_`对象来控制LED。当通过传输层接收到`blinky`服务的二进制proto消息时，它们被转换为对用于控制硬件的代码的实际调用，这是RPC的本质。
- en: As an exercise, expand the `blinky` service by adding the `BlinkTwice` method.
    You already know the files where you need to make changes – the proto file and
    the `BlinkyService` implementation files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，通过添加`BlinkTwice`方法来扩展`blinky`服务。你已经知道需要修改的文件——proto文件和`BlinkyService`实现文件。
- en: 'Pigweed uses **nanopb** ([https://github.com/nanopb/nanopb](https://github.com/nanopb/nanopb))
    to compile proto files in C files and then wrap them in C++. There is a pure C++
    implementation of Protocol Buffers designed especially for microcontrollers –
    Embedded Proto. It is an object-oriented implementation that only uses static
    memory allocation. It has been developed using the MISRA C++ guidelines. These
    traits together make Embedded Proto suitable for applications with a wide range
    of requirements, from low memory usage to safety concerns. You can find more about
    it on the GitHub page: [https://github.com/Embedded-AMS/EmbeddedProto](https://github.com/Embedded-AMS/EmbeddedProto).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Pigweed使用**nanopb** ([https://github.com/nanopb/nanopb](https://github.com/nanopb/nanopb))在C文件中编译proto文件，然后将其封装在C++中。为微控制器特别设计的纯C++实现协议缓冲区是嵌入式Proto。它是一个面向对象的实现，只使用静态内存分配。它是在遵循MISRA
    C++指南的基础上开发的。这些特性使得嵌入式Proto适用于具有广泛要求的各种应用，从低内存使用到安全性考虑。你可以在GitHub页面上了解更多信息：[https://github.com/Embedded-AMS/EmbeddedProto](https://github.com/Embedded-AMS/EmbeddedProto)。
- en: Pigweed has a steep learning curve and should be carefully evaluated based on
    your system requirements. It is better suited for larger, more complex projects
    due to the learning overhead. Additionally, evaluate the hardware support and
    take into consideration the memory overhead some modules may introduce.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Pigweed的学习曲线很陡峭，应该根据您的系统要求仔细评估。由于学习成本较高，它更适合大型、更复杂的项目。此外，评估硬件支持，并考虑一些模块可能引入的内存开销。
- en: In contrast to Pigweed, Intel’s **CIB** library leverages C++ compile-time capabilities.
    This approach minimizes memory overhead while enhancing flexibility and expressiveness.
    Next, we will cover the CIB library.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pigweed相比，Intel的**CIB**库利用了C++的编译时能力。这种方法在增强灵活性和表现力的同时，最小化了内存开销。接下来，我们将介绍CIB库。
- en: Compile-time Initialization and Build
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时初始化和构建
- en: One of C++’s major advantages in embedded systems is its ability to perform
    compile-time computation. In most cases, we have significant knowledge about the
    application beforehand, allowing us to configure it at compile time. Intel’s CIB
    library provides a declarative interface for configuring firmware components during
    compilation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，C++的一个主要优势是它能够在编译时执行计算。在大多数情况下，我们在编译之前对应用程序有相当的了解，这使我们能够在编译时对其进行配置。Intel的CIB库在编译时提供了一个声明性接口来配置固件组件。
- en: As you saw in [*Chapter 15*](Chapter_15.xhtml), the Observer design pattern
    is commonly used in event-driven systems to decouple the source of events (publisher)
    from the entities that react to those events (observers or subscribers). By using
    a subscriber interface, observers can register themselves with the event source,
    which then notifies them of changes or events without needing to know details
    about the observers’ implementations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[*第15章*](Chapter_15.xhtml)中看到的，观察者设计模式在事件驱动系统中被广泛使用，用于将事件源（发布者）与对那些事件做出反应的实体（观察者或订阅者）解耦。通过使用订阅者接口，观察者可以注册自己到事件源，然后事件源会通知它们变化或事件，而无需了解观察者实现的具体细节。
- en: This decoupling allows for greater flexibility and modularity in system design,
    as components can be added, removed, or modified without tightly coupling them
    to the event generator. This property is leveraged by the CIB library, which implements
    a compile-time observer pattern to provide a declarative interface for configuring
    firmware applications. By resolving dependencies and establishing event-driven
    relationships at compile time, CIB eliminates runtime overhead while keeping components
    loosely coupled and efficiently interconnected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解耦使得系统设计在灵活性、模块化方面更加出色，因为组件可以添加、删除或修改，而无需将它们紧密耦合到事件生成器。CIB 库利用了这一特性，它通过实现编译时观察者模式来提供配置固件应用程序的声明性接口。通过在编译时解决依赖关系并建立事件驱动关系，CIB
    消除了运行时开销，同时保持组件松散耦合和高效互联。
- en: 'We will start exploring the CIB library on a simple example of a temperature
    publisher. The entire example is available at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib).
    You can run it using the following commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的温度发布者示例开始探索 CIB 库。整个示例可在 [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib)
    找到。您可以使用以下命令运行它：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can use `app/src/main.cpp` to follow through the example, as CIB, at the
    time of writing, is not available as a library in Compiler Explorer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `app/src/main.cpp` 来跟踪示例，因为撰写本文时，CIB 在 Compiler Explorer 中不可作为库使用。
- en: Using CIB in a temperature publisher example
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在温度发布者示例中使用 CIB
- en: 'Let’s begin with the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始：
- en: 'We first need to declare a service (publisher) as an empty struct that inherits
    from `callback::service`, a variadic class template, provided with types that
    will be accepted by subscribers, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要声明一个服务（发布者），它是一个继承自 `callback::service` 的空结构体，`callback::service` 是一个变长类模板，提供了将被订阅者接受的类型，如下代码所示：
- en: '[PRE11]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will create the subscribers (also called components in the context
    of the CIB library) `display_temperature_component` and `data_sender_component`,
    as shown in this code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建订阅者（在 CIB 库的上下文中也称为组件）`display_temperature_component` 和 `data_sender_component`，如下代码所示：
- en: '[PRE12]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code defines two components, which do the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了两个组件，它们执行以下操作：
- en: Provide handlers for the `send_temperature` service in the `constexpr` lambdas
    `display_temperature` and `send_temp`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `constexpr` 狼形函数 `display_temperature` 和 `send_temp` 中为 `send_temperature`
    服务提供处理程序。
- en: Define the `constexpr static auto config` member through which they extend the
    service (subscribe to the events).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义通过它们扩展服务（订阅事件）的 `constexpr static auto config` 成员。
- en: 'Config members are instances of variadic template class `cib::config`, and
    they are used by the CIB library to wire the application at compile time, that
    is, to connect services (event generators, publishers) with software components
    that extend those services (observers). Compile-time initialization and the build
    process are performed by `cib::nexus`, which needs to be supplied with the project
    configuration. Here is the code for configuration for this simple project:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置成员是变长模板类 `cib::config` 的实例，并由 CIB 库在编译时连接应用程序，即连接服务（事件生成器、发布者）与扩展这些服务的软件组件（观察者）。编译时初始化和构建过程由
    `cib::nexus` 执行，它需要提供项目配置。以下是此简单项目的配置代码：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This project configuration is a simple struct, `my_project`, with the `constexpr`
    member config, which is provided with the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目配置是一个简单的结构体 `my_project`，具有 `constexpr` 成员 `config`，它提供了以下内容：
- en: '`cib::exports<send_temperature>`: Used to declare services (publishers)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cib::exports<send_temperature>`：用于声明服务（发布者）'
- en: '`cib::components<display_temperature_component, data_sender_component>`: Used
    to declare software components that can extend services'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cib::components<display_temperature_component, data_sender_component>`：用于声明可以扩展服务的软件组件'
- en: 'Next, let’s see how we use all of this in a firmware application in the following
    code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在以下代码中的固件应用程序中使用所有这些功能：
- en: '[PRE14]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, we perform these steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们执行以下步骤：
- en: '`cib::nexus<my_project> nexus{};`: Create an instance of the class template
    `cib::nexus` provided by the project configuration `my_project`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cib::nexus<my_project> nexus{};`：创建由项目配置 `my_project` 提供的类模板 `cib::nexus`
    的实例。'
- en: '`nexus.init();`: Initialize Nexus.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nexus.init();`：初始化 Nexus。'
- en: '`nexus.service<send_temperature>(42.0f);`: Access the service and provide it
    with the float argument (temperature). This will trigger calls to lambdas in components
    that extend the `send_temperature` service.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nexus.service<send_temperature>(42.0f);`: 访问服务并提供浮点参数（温度）。这将触发调用扩展 `send_temperature`
    服务的组件中的 lambda。'
- en: Extending the temperature publisher example
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展温度发布器示例
- en: 'Next, we will extend this simple example with two components – a dummy temperature
    sensor and I2C components that we will name `temperature_sensor_component` and
    `i2c`. We will also introduce two new services – `runtime_init` and `main_loop`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加两个组件扩展这个简单的示例 – 一个虚拟温度传感器和名为 `temperature_sensor_component` 和 `i2c`
    的 I2C 组件。我们还将引入两个新的服务 – `runtime_init` 和 `main_loop`：
- en: 'Let’s start with defining new services in this code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从定义此代码中的新服务开始：
- en: '[PRE15]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we define two services:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个服务：
- en: '`runtime_init`: Derives from the variadic class template `flow::service`, allowing
    us to sequence actions'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime_init`: 继承自变长类模板 `flow::service`，允许我们按顺序执行操作。'
- en: '`main_loop`: Derives from `callback::service`, which will be called in the
    main `while` loop'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_loop`: 继承自 `callback::service`，它将在主 `while` 循环中被调用。'
- en: 'We will move now to implementations of I2C components, as shown in this code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将转向 I2C 组件的实现，如下所示：
- en: '[PRE16]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code defines a new component – `i2c` – as a struct with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个新的组件 – `i2c` – 作为具有以下内容的结构体：
- en: '`constexpr static auto init`: A lambda wrapped in `flow::action` that implements
    the initialization of the I2C peripheral.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr static auto init`: 一个包装在 `flow::action` 中的 lambda，它实现了 I2C 外设的初始化。'
- en: '`constexpr static auto config`: Adds the above action to the `runtime_init`
    flow service. The `*` operator explicitly adds an action to the flow. Without
    it, the action is referenced but never added, causing a compile-time error.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr static auto config`: 将上述操作添加到 `runtime_init` 流服务中。`*` 操作符显式地将操作添加到流程中。没有它，操作会被引用但不会添加，导致编译时错误。'
- en: 'Next, let’s go through the temperature sensor component shown in the following
    code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下代码查看温度传感器组件：
- en: '[PRE17]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code shows the struct `temperature_sensor_component` with the
    following members:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了具有以下成员的 `temperature_sensor_component` 结构体：
- en: '`constexpr static auto init`: A `flow_action` that implements the initialization
    of the temperature sensor'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr static auto init`: 一个实现温度传感器初始化的 `flow_action`。'
- en: '`constexpr static auto read_temperature`: A lambda that implements periodic
    readings of a temperature sensor and uses `cib::service<read_temperature>` to
    publish the read value'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr static auto read_temperature`: 一个 lambda，它实现温度传感器的周期性读取，并使用 `cib::service<read_temperature>`
    发布读取值。'
- en: '`constexpr static auto config`: Extends the `main_loop` service with the `read_temperature`
    lambda and the `runtime_init` flow with `i2c::init >> *init`, indicating that
    `i2c::init` precedes `init`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr static auto config`: 使用 `read_temperature` lambda 扩展 `main_loop`
    服务，并使用 `runtime_init` 流中的 `i2c::init >> *init` 扩展 `runtime_init` 流，表示 `i2c::init`
    在 `init` 之前。'
- en: 'Next, we need to modify the `my_project` struct to export new services and
    add new components, as shown in this code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改 `my_project` 结构体以导出新的服务和添加新的组件，如下所示：
- en: '[PRE18]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this code, we simply added:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们简单地添加了：
- en: The `runtime_init` and `main_loop` services to `cib::exports`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `runtime_init` 和 `main_loop` 服务添加到 `cib::exports`
- en: '`i2c` and `temperature_sensor_component` to `cib::components`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2c` 和 `temperature_sensor_component` 添加到 `cib::components`'
- en: 'Finally, let us see the new `main` function, as shown here:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看新的 `main` 函数，如下所示：
- en: '[PRE19]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As previously, we first create a `cib::nexus` instance and initialize it. Then,
    we perform the following steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们首先创建一个 `cib::nexus` 实例并初始化它。然后，我们执行以下步骤：
- en: '`nexus.service<runtime_init>()`: This will run all actions in the flow `runtime_init`
    and ensure the specified order of actions.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nexus.service<runtime_init>()`: 这将运行 `runtime_init` 流中的所有操作，并确保操作的指定顺序。'
- en: '`nexus.service<main_loop>()`: This is a call in the main loop executing all
    lambdas that are extending this service.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nexus.service<main_loop>()`: 这是在主循环中执行的所有扩展此服务的 lambda 的调用。'
- en: 'This structure is typical for many firmware applications: initialize all components
    (including hardware peripherals), then repeatedly call relevant services in the
    main loop. Any changes to the application are done in the `my_project` struct
    in a declarative way – by extending services and adding or removing components.
    All initialization is performed in the components themselves, meaning the main
    function does not need to know the details of individual components and their
    dependencies.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构对于许多固件应用来说是典型的：初始化所有组件（包括硬件外设），然后在主循环中反复调用相关服务。对应用的任何更改都是在`my_project`结构中以声明方式进行的——通过扩展服务和添加或删除组件。所有初始化都在组件自身中执行，这意味着主函数不需要了解各个组件及其依赖的细节。
- en: 'The CIB library also includes logging, interrupt, message, and string constant
    libraries – all leveraging C++’s compile-time computation. You can find more information
    about CIB on GitHub: [https://github.com/intel/compile-time-init-build](https://github.com/intel/compile-time-init-build).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: CIB库还包括日志、中断、消息和字符串常量库——所有这些都利用了C++的编译时计算。你可以在GitHub上找到有关CIB的更多信息：[https://github.com/intel/compile-time-init-build](https://github.com/intel/compile-time-init-build)。
- en: 'You can run the full CIB example in Renode. Start Visual Studio Code, attach
    it to the running container, open the `Chapter17/cib` project, as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Renode中运行完整的CIB示例。启动Visual Studio Code，将其附加到正在运行的容器，打开`Chapter17/cib`项目，如[*第4章*](Chapter_04.xhtml)中所述，然后在Visual
    Studio Code终端中运行以下命令，或者直接在容器终端中运行：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the above example will generate the output shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述示例将生成以下输出：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example demonstrates the usage of the CIB library in an event-driven system
    with loosely coupled components, where some generate events and others react to
    them. The wiring of publishers and subscribers happens at compile time, minimizing
    the memory footprint and reducing runtime overhead, while the declarative project
    configuration improves readability.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本例演示了在具有松散耦合组件的事件驱动系统中使用CIB库的情况，其中一些组件生成事件，而另一些则对它们做出反应。发布者和订阅者的连接是在编译时发生的，这最小化了内存占用并减少了运行时开销，而声明性的项目配置则提高了可读性。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw an overview of the libraries used throughout this book
    – the C++ standard library and ETL. You also got an insight into Google’s Pigweed
    library and its capabilities and Intel’s CIB library.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了本书中使用的库——C++标准库和ETL。你还了解了谷歌的Pigweed库及其功能和英特尔CIB库。
- en: In the next chapter, we will go through cross-platform development.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍跨平台开发。
