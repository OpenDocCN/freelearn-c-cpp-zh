- en: 2A. No Ducks Allowed – Types and Deduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2A. 禁止鸭子 - 类型和推断
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够：
- en: Implement your own classes that behave like built-in types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自己的类，使其行为类似于内置类型
- en: Implement classes that control which functions the compiler creates (Rule of
    Zero/Rule of Five)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现控制编译器创建的函数的类（零规则/五规则）
- en: Develop functions using auto variables, like you always have
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用auto变量开发函数，就像你一直做的那样
- en: Implement classes and functions by making use of strong typing to write safer
    code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用强类型编写更安全的代码来实现类和函数
- en: This chapter will give you a good grounding in the C++ type system and allow
    you to write your own types that work in that system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供对C++类型系统的良好基础，并使您能够编写适用于该系统的自己的类型。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: C++ is a strongly typed, statically typed language. The compiler uses type information
    related to the variables that are used and the context in which they are used
    to detect and prevent certain classes of programming errors. This means that every
    object has a type and that type does not change, ever. In contrast, dynamically
    typed languages such as Python and PHP defer this type checking until runtime
    (also known as late binding), and the type of a variable may change during the
    execution of the application. These languages use the duck test instead of the
    variables type – that is, "if it walks and talks like a duck, then it must be
    a duck." Statically typed languages such as C++ rely on the type to determine
    whether a variable can be used for a given purpose, while dynamically typed languages
    rely on the presence of certain methods and properties to determine its suitability.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种强类型、静态类型的语言。编译器使用与使用的变量相关的类型信息以及它们所用的上下文来检测和防止某些类别的编程错误。这意味着每个对象都有一个类型，而且该类型永远不会改变。相比之下，Python和PHP等动态类型语言将类型检查推迟到运行时（也称为后期绑定），变量的类型可能在应用程序执行过程中发生变化。这些语言使用鸭子测试而不是变量类型
    - 也就是说，“如果它走起来像鸭子，叫起来像鸭子，那么它一定是鸭子。”C++等静态类型语言依赖于类型来确定变量是否可以用于特定目的，而动态类型语言依赖于某些方法和属性的存在来确定其适用性。
- en: C++ was originally described as "C with classes". What does this mean? Basically,
    C provided a set of built-in fundamental types – int, float, char, and so on –
    along with pointers and arrays of these items. You aggregate these into data structures
    of related items using a struct. C++ extends this to classes so that you can define
    your own types completely with the operators that can be used to manipulate them,
    thereby making them first-class citizens in the language. Since its humble beginnings,
    C++ has evolved to be way more than just "C with classes", as it can now express
    the object-oriented paradigm (encapsulation, polymorphism, abstraction, and inheritance),
    the functional paradigm, and generic programming (templates).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++最初被描述为“带类的C”。这是什么意思？基本上，C提供了一组内置的基本类型 - int、float、char等 - 以及这些项的指针和数组。您可以使用struct将这些聚合成相关项的数据结构。C++将此扩展到类，以便您可以完全定义自己的类型，包括可以用来操作它们的运算符，从而使它们成为语言中的一等公民。自其谦卑的开始以来，C++已经发展成为不仅仅是“带类的C”，因为它现在可以表达面向对象范式（封装、多态、抽象和继承）、函数范式和泛型编程（模板）。
- en: In this book, we will focus on what it means for C++ to support the object-oriented
    paradigm. As your experience as a developer grows and you are exposed to languages
    such as Clojure, Haskell, Lisp, and other functional languages, they will help
    you to write robust C++ code. Dynamically typed languages such as Python, PHP,
    and Ruby have already influenced the way we write C++ code. With the arrival of
    C++17 came the introduction of the `std::variant` class – a class that holds whatever
    type that we choose (at compile time) and acts a lot like variables in dynamic
    languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点关注C++支持面向对象范式的含义。随着您作为开发人员的经验增长，并且接触到像Clojure、Haskell、Lisp和其他函数式语言，它们将帮助您编写健壮的C++代码。动态类型语言如Python、PHP和Ruby已经影响了我们编写C++代码的方式。随着C++17的到来，引入了`std::variant`类
    - 一个在编译时保存我们选择的任何类型，并且在动态语言中的变量类似。
- en: In the previous chapter, we learned how to create C++ projects that are portable
    and maintainable using CMake. We learned how to incorporate unit tests in our
    projects to help write correct code and how to debug problems when they arise.
    We learned how the toolchain takes our code and runs it through a pipeline of
    programs to produce the executable files. We finished with some rules of thumb
    that help us to create readable, understandable, and maintainable code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用CMake创建可移植和可维护的C++项目。我们学习了如何在项目中加入单元测试，以帮助编写正确的代码，并在出现问题时进行调试。我们了解了工具链如何将我们的代码通过一系列程序流水线处理，以生成可执行文件。最后，我们总结了一些经验法则，帮助我们创建可读性强、理解性好、易于维护的代码。
- en: In this chapter, we will go on a whirlwind tour of the C++ type system, declaring
    and using our own types as we go.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速浏览C++类型系统，声明和使用我们自己的类型。
- en: C++ Types
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++类型
- en: As a strongly and, statically typed language, C++ provides several fundamental
    types and the ability to define their own types with as much or as little functionality
    as needed to solve the problem at hand. This section will start by introducing
    the fundamental types, initializing them, declaring a variable, and associating
    a type with it. We will then explore how to declare and define a new type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种强类型和静态类型的语言，C++提供了几种基本类型，并能够根据需要定义自己的类型，以解决手头的问题。本节将首先介绍基本类型，初始化它们，声明变量，并将类型与之关联。然后我们将探讨如何声明和定义新类型。
- en: C++ Fundamental Types
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++基本类型
- en: C++ includes several *fundamental types*, or *built-in types*. The C++ standard
    defines the minimum size in memory for each type and their relative sizes. The
    compiler recognizes these fundamental types and has built-in rules that define
    what operations can and cannot be performed on them. There are also rules for
    implicit conversions between types; for example, conversion from an int type to
    a float type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C++包括几种*基本类型*或*内置类型*。C++标准定义了每种类型在内存中的最小大小和它们的相对大小。编译器识别这些基本类型，并具有内置规则来定义可以对它们执行哪些操作和不能执行哪些操作。还有关于类型之间的隐式转换的规则；例如，从int类型到float类型的转换。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: See the **Fundamental Types** section at [https://en.cppreference.com/w/cpp/language/types](https://en.cppreference.com/w/cpp/language/types)
    for a brief description of all the built-in types.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有内置类型的简要描述，请参阅[https://en.cppreference.com/w/cpp/language/types](https://en.cppreference.com/w/cpp/language/types)中的**基本类型**部分。
- en: C++ Literals
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++文字量
- en: C++ literals are used to tell the compiler the values that you wish to associate
    with a variable either when you declare it or when you assign to it. Each of the
    built-in types in the previous section has a form of literal associated with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C++文字量用于告诉编译器您希望在声明变量或对其进行赋值时与变量关联的值。前一节中的每种内置类型都有与之关联的文字量形式。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: See the **Literals** section at [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)
    for a brief description of the literals for each type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每种类型的文字量的简要描述，请参阅[https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)中的**文字量**部分。
- en: Specifying Types – Variables
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定类型 - 变量
- en: 'As C++ is a statically typed language, it is necessary to specify the type
    of a variable when it is declared. When you declare a function, it is necessary
    to specify the return type and the types of arguments that are being passed to
    it. There are two choices for specifying the type to a variable when you declare
    it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++是一种静态类型语言，在声明变量时需要指定变量的类型。当声明函数时，需要指定返回类型和传递给它的参数的类型。在声明变量时，有两种选择可以指定类型：
- en: '**Explicitly**: You, as the programmer, are dictating exactly what the type
    is.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式**：您作为程序员正在明确指定类型。'
- en: '**Implicitly** (using auto): You are telling the compiler to look at the value
    that was used to initialize the variable and determine its type. This is known
    as (auto) **type deduction**.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式**（使用auto）：您告诉编译器查看用于初始化变量的值并确定其类型。这被称为（auto）**类型推导**。'
- en: 'The general form of declaration for a scalar variable is one of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标量变量的声明一般形式如下之一：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`type-specifier` indicates what type (fundamental or user-defined) you wish
    to associate with the `var` variable. All three forms result in the compiler allocating
    some storage to hold the value in, and all future references to `var` will refer
    to that location. `init-value` is used to initialize the storage location. Default
    initialization does nothing for built-in types and will call the constructor of
    a user-defined type according to the function overloading resolution to initialize
    the storage.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`type-specifier`指示您希望将`var`变量与之关联的类型（基本类型或用户定义类型）。所有三种形式都会导致编译器分配一些存储空间来保存值，并且将来对`var`的所有引用都将引用该位置。`init-value`用于初始化存储位置。默认初始化对内置类型无效，并将根据函数重载解析调用用户定义类型的构造函数来初始化存储。'
- en: The compiler must know how much memory to allocate and provides an operator
    to determine how large a type or variable is – `sizeof`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须知道要分配多少内存，并提供一个运算符来确定类型或变量有多大 - `sizeof`。
- en: 'Based on our declarations, the compiler will set aside space in the computer''s
    memory to store the data item that the variable refers to. Consider the following
    declarations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的声明，编译器将在计算机的内存中留出空间来存储变量引用的数据项。考虑以下声明：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If these are declared within the scope of a function, then the compiler allocates
    the memory for them from what is known as the stack. The memory layout for this
    may look something like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是在函数范围内声明的，那么编译器会从所谓的堆栈中为它们分配内存。这可能看起来像以下的内存布局：
- en: '![Figure 2A.1: Memory layout of variables](img/C14583_02A_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.1：变量的内存布局](img/C14583_02A_01.jpg)'
- en: 'Figure 2A.1: Memory layout of variables'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.1：变量的内存布局
- en: The compiler will allocate the memory in the order we declare the variables.
    The unused memory occurs because the compiler allocates the memory so that the
    fundamental types are generally accessed atomically and are aligned to the appropriate
    memory boundaries for efficiency. Note that `title` is of the `const char *` type,
    which is a `const`. The **"Sir Robin of Loxley"** string will be stored in a different
    part of memory that is initialized when the program is loaded. We will discuss
    program memory later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将按照我们声明变量的顺序分配内存。未使用的内存是因为编译器分配内存，以便基本类型通常是原子访问的，并且为了效率而对齐到适当的内存边界。请注意，`title`是`const
    char *`类型，是`const`。**"Sir Robin of Loxley"**字符串将存储在程序加载时初始化的内存的不同部分。我们将在后面讨论程序内存。
- en: 'A slight modification of the scalar declaration syntax gives us the syntax
    for declaring arrays of values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 标量声明语法的轻微修改给我们提供了声明值数组的语法：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This can be done for multi-dimensional arrays like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于多维数组，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that `count`, `countX`, and other items in the preceding declarations must
    be evaluated to a constant during compile time, otherwise this will result in
    an error. Additionally, the number of items in the comma-separated initializer
    list must be less than or equal to `count` or, again, there will be a compilation
    error. In the next section, we'll apply the concepts we've learned so far in an
    exercise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前述声明中的`count`、`countX`和其他项目在编译时必须评估为常量，否则将导致错误。此外，逗号分隔的初始化列表中的项目数必须小于或等于`count`，否则将再次出现编译错误。在下一节中，我们将在练习中应用到目前为止学到的概念。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Before solving any practical in this chapter, download this book's GitHub repository
    ([https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus))
    and import the folder of Lesson 2A in Eclipse so that you can view the codes for
    each exercise and activity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的任何实际操作之前，下载本书的GitHub存储库（[https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus)），并在Eclipse中导入Lesson
    2A文件夹，以便您可以查看每个练习和活动的代码。
- en: 'Exercise 1: Declaring Variables and Exploring Sizes'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：声明变量和探索大小
- en: 'This exercise will set up all the exercises for this chapter and then get you
    familiar with declaring and initializing variables that are of a built-in type.
    You will also be introduced to the `auto declaration`, `arrays`, and `sizeof`.
    Let''s get started:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将为本章的所有练习设置，并让您熟悉声明和初始化内置类型的变量。您还将介绍`auto声明`，`数组`和`sizeof`。让我们开始吧：
- en: Open Eclipse (used in *Chapter 1*, *Anatomy of Portable C++ Software*) and if
    the Launcher window appears, click on Launch.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse（在*第1章* *可移植C++软件的解剖*中使用），如果出现启动窗口，请点击启动。
- en: Go to **File**, select **Project…** under **New** **►**, and go to Select C++
    Project (not the C/C++ Project).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**File**，在**New** **►**下选择**Project…**，然后转到选择C++ Project（而不是C/C++ Project）。
- en: Click **Next >**, clear the **Use default location** checkbox, and enter **Lesson2A**
    as the **Project name**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next >**，清除**Use default location**复选框，并输入**Lesson2A**作为**Project name**。
- en: Select **Empty Project** for the **Project Type**. Then, click on **Browse…**
    and navigate to the folder containing the Lesson2A examples.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Empty Project**作为**Project Type**。然后，点击**Browse…**并导航到包含Lesson2A示例的文件夹。
- en: Click on **Open** to select the folder and close the dialog.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**以选择文件夹并关闭对话框。
- en: Click **Next >**, **Next >**, and then **Finish**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next >**，**Next >**，然后点击**Finish**。
- en: To help you with the exercises, we will configure the workspace to automatically
    save the files before builds. Go to **Window** and select **Preferences**. Under
    **General**, open **Workspace** and select **Build**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助您进行练习，我们将配置工作区在构建之前自动保存文件。转到**Window**，选择**Preferences**。在**General**下，打开**Workspace**并选择**Build**。
- en: Check the **Save automatically before build** box and then click **Apply and
    Close**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**Save automatically before build**框，然后点击**Apply and Close**。
- en: Just like *Chapter* *1*, *Anatomy of Portable C++ Software*, this is a CMake-based
    project, so we need to change the current builder. Click on **Lesson2A** in the
    **Project Explorer** and then on **Properties** under the **Project** menu. Select
    Tool Chain Editor under C/C++ Build from the left pane and set Current builder
    to Cmake Build (portable).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像*第1章* *可移植C++软件的解剖*一样，这是一个基于CMake的项目，所以我们需要更改当前的构建器。在**Project**资源管理器中点击**Lesson2A**，然后在**Project**菜单下点击**Properties**。在左侧窗格中选择C/C++
    Build下的Tool Chain Editor，并将Current builder设置为Cmake Build（portable）。
- en: 'Click **Apply and Close**. Then, choose the **Project** | **Build All** menu
    item to build all the exercises. By default, the console at the bottom of the
    screen will display the **CMake Console [Lesson2A]**:![Figure 2A.2: CMake console
    output](img/C14583_02A_02.jpg)'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Apply and Close**。然后，选择**Project** | **Build All**菜单项来构建所有练习。默认情况下，屏幕底部的控制台将显示**CMake
    Console [Lesson2A]**：![图2A.2：CMake控制台输出](img/C14583_02A_02.jpg)
- en: 'Figure 2A.2: CMake console output'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.2：CMake控制台输出
- en: 'In the top-right corner of the console, click on the **Display Selected Console**
    button and then select **CDT Global Build Console** from the list:![Figure 2A.3:
    Selecting a different console](img/C14583_02A_03.jpg)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台的右上角，点击**Display Selected Console**按钮，然后从列表中选择**CDT Global Build Console**：![图2A.3：选择不同的控制台](img/C14583_02A_03.jpg)
- en: 'Figure 2A.3: Selecting a different console'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.3：选择不同的控制台
- en: 'This will show the outcome of the build – it should show 0 errors and 3 warnings:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示构建的结果 - 应该显示0个错误和3个警告：
- en: '![Figure 2A.4: Build process console output](img/C14583_02A_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.4：构建过程控制台输出](img/C14583_02A_04.jpg)'
- en: 'Figure 2A.4: Build process console output'
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.4：构建过程控制台输出
- en: 'As the build was successful, we want to run Exercise1\. At the top of the window,
    click on the drop-down list where it says **No Launch Configurations**:![Figure
    2A.5: Launch Configuration menu](img/C14583_02A_05.jpg)'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于构建成功，我们希望运行Exercise1。在窗口顶部，点击下拉列表，选择**No Launch Configurations**：![图2A.5：启动配置菜单](img/C14583_02A_05.jpg)
- en: 'Figure 2A.5: Launch Configuration menu'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.5：启动配置菜单
- en: Click on **New Launch Configuration…**. Leave the defaults as is and click **Next
    >**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**New Launch Configuration…**。保持默认设置，然后点击**Next >**。
- en: 'Change **Name** to **Exercise1** and then click **Search Project**:![Figure
    2A.6: Exercise1 Launch Configuration ](img/C14583_02A_06.jpg)'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Name**更改为**Exercise1**，然后点击**Search Project**：![图2A.6：Exercise1启动配置](img/C14583_02A_06.jpg)
- en: 'Figure 2A.6: Exercise1 Launch Configuration'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.6：Exercise1启动配置
- en: From the list of programs displayed in the Binaries window, click on **Exercise1**
    and click **OK**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Binaries窗口中显示的程序列表中，点击**Exercise1**，然后点击**OK**。
- en: 'Click **Finish**. This will result in exercise1 being displayed in the Launch
    Configuration drop-down box:![Figure 2A.7: Change to Launch Configuration](img/C14583_02A_07.jpg)'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Finish**。这将导致exercise1显示在启动配置下拉框中：![图2A.7：更改启动配置](img/C14583_02A_07.jpg)
- en: 'Figure 2A.7: Change to Launch Configuration'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.7：更改启动配置
- en: 'To run **Exercise1**, click on the **Run** button. Exercise1 will execute and
    display its output in the console:![Figure 2A.8: Output from exercise1](img/C14583_02A_08.jpg)'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行**Exercise1**，点击**Run**按钮。Exercise1将在控制台中执行并显示其输出：![图2A.8：exercise1的输出](img/C14583_02A_08.jpg)
- en: 'Figure 2A.8: Output from exercise1'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.8：exercise1的输出
- en: The program does nothing of worth – it just outputs the sizes of various types
    on your system. But this shows that the program is valid and can be compiled.
    Note that the numbers for your system may be different (especially the sizeof(title)
    value).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序没有任何价值 - 它只输出系统中各种类型的大小。但这表明程序是有效的并且可以编译。请注意，您系统的数字可能会有所不同（特别是sizeof（title）的值）。
- en: 'In the **Project Explorer**, expand **Lesson2A**, then **Exercise01**, and
    double-click on **Exercise1.cpp** to open the file for this exercise in the editor:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目资源管理器”中，展开“Lesson2A”，然后展开“Exercise01”，双击“Exercise1.cpp”以在编辑器中打开此练习的文件：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One thing to note about the preceding program is that the first statement of
    the main function is actually an executable statement and not a declaration. C++
    allows you to declare a variable just about anywhere. Its predecessor, C, originally
    required that all variables must be declared before any executable statements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的程序，需要注意的一点是，主函数的第一条语句实际上是可执行语句，而不是声明。 C++允许您几乎可以在任何地方声明变量。 它的前身C最初要求所有变量必须在任何可执行语句之前声明。
- en: Best Practice
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Declare a variable as close as possible to where it will be used and initialize
    it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能靠近将要使用的位置声明变量并初始化它。
- en: 'In the editor, uncomment the line marked as `step 24` by removing the delimiters
    (`//`) at the beginning of the line:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，通过删除行开头的分隔符（//）取消注释标记为“步骤24”的行：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Click on the **Run** button again. This will cause the program to be built
    again. This time, the build will fail with an error:![Figure 2A.9: Errors in Workspace
    dialog](img/C14583_02A_09.jpg)'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击“运行”按钮。 这将导致再次构建程序。 这一次，构建将失败，并显示错误：![图2A.9：工作区中的错误对话框](img/C14583_02A_09.jpg)
- en: 'Figure 2A.9: Errors in Workspace dialog'
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.9：工作区中的错误对话框
- en: 'Click on **Cancel** to close the dialog. If **CDT Build Console [Lesson2A]**
    is not displayed, then select it as the active console:![Figure 2A.10: Duplicate
    declaration error](img/C14583_02A_10.jpg)'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“取消”关闭对话框。 如果未显示“CDT构建控制台[Lesson2A]”，则将其选择为活动控制台：![图2A.10：重复声明错误](img/C14583_02A_10.jpg)
- en: 'Figure 2A.10: Duplicate declaration error'
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.10：重复声明错误
- en: This time, the build fails because we have tried to redefine the type of the
    variable, that is, pi. The compiler gives helpful information about where we need
    to look to fix it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，构建失败，因为我们尝试重新定义变量pi的类型。 编译器提供了有关我们需要查找以修复错误的位置的有用信息。
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 25` by removing the delimiters (//) at the beginning
    of the line:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注释分隔符恢复到行的开头。 在编辑器中，通过删除行开头的分隔符（//）取消注释标记为“步骤25”的行：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Click on the **Run** button again. When the Errors in Workspace dialog appears,
    click **Cancel**:![Figure 2A.11: Auto declaration error – no initialization](img/C14583_02A_11.jpg)'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击“运行”按钮。 当“工作区中的错误”对话框出现时，单击“取消”：![图2A.11：自动声明错误-无初始化](img/C14583_02A_11.jpg)
- en: 'Figure 2A.11: Auto declaration error – no initialization'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.11：自动声明错误-无初始化
- en: Again, the build fails, but this time, we did not give the compiler enough information
    to deduce the type of speed – auto typed variables MUST be initialized.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建失败，但这次我们没有给编译器足够的信息来推断速度的类型-自动类型的变量必须初始化。
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 26` by removing the comment starting delimiter (//) at
    the beginning of the line:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注释分隔符恢复到行的开头。 在编辑器中，通过删除注释起始分隔符（//）取消注释标记为“步骤26”的行：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Click on the `value`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“值”。
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 27` by removing the delimiters (//) at the beginning
    of the line:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注释分隔符恢复到行的开头。 在编辑器中，通过删除行开头的分隔符（//）取消注释标记为“步骤27”的行：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Click on the `int`, to title, which is a `const char*`. A very useful thing
    to note here is that `title` was declared with the `auto` type. The error message
    that was generated by the compiler tells us that title was deduced to be of the
    `const char*` type.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“int”，以标题，这是一个“const char*”。 这里非常重要的一点是，“title”是用“auto”类型声明的。 编译器生成的错误消息告诉我们，“title”被推断为“const
    char*”类型。
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 28` by removing the delimiters (//) at the beginning
    of the line:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注释分隔符恢复到行的开头。 在编辑器中，通过删除行开头的分隔符（//）取消注释标记为“步骤28”的行：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Click on the `sh_int` with (`short` type. A short occupies two bytes of memory
    and is considered a signed quantity of 16 bits. This means that the range of values
    that can be stored in a short is `-2^(16-1)` to `2^(16-1)-1`, or **-32768** to
    **32767**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“sh_int”与（`short`类型。 短占用两个字节的内存，被认为是16位的有符号数量。 这意味着可以存储在短中的值的范围是“-2^(16-1)”到“2^(16-1)-1”，或**-32768**到**32767**。
- en: Change the value from `short`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值从“short”更改。
- en: Change the value from `short`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值从“short”更改。
- en: Restore the comment delimiter to the start of the line. In the editor, make
    any change you can think of to explore variable declaration using any of the fundamental
    types and their associated literals and then click on the **Run** button as often
    as necessary. Examine the output in the Build Console for any error messages because
    it might help you find the error.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注释分隔符恢复到行的开头。 在编辑器中，尝试使用任何基本类型及其相关文字来探索变量声明，然后尽可能多地单击“运行”按钮。 检查“构建控制台”的输出是否有任何错误消息，因为这可能会帮助您找到错误。
- en: In this exercise, we learned how to set up the Eclipse development, implement
    variable declaration, and troubleshoot problems with declarations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何设置Eclipse开发，实现变量声明，并解决声明中的问题。
- en: Specifying Types – Functions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定类型-函数
- en: Now that we can declare a variable to be of a certain type, we need to do something
    with those variables. In C++, we do things by calling a function. A function is
    a sequence of statements that deliver an outcome. That outcome could be a mathematical
    calculation (for example, an exponent) that is then sent to a file or written
    to a Terminal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明一个变量为某种类型，我们需要对这些变量做些什么。 在C++中，我们通过调用函数来做事情。 函数是一系列语句，产生结果。 结果可能是数学计算（例如，指数）然后发送到文件或写入终端。
- en: Functions allow us to break our solution into sequences of statements that are
    easier to manage and understand. As we write these packaged statements, we can
    reuse them where it makes sense. If we need it to operate differently based on
    the context, then we pass in an argument. If it returns a result, then the function
    needs a return type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许我们将解决方案分解为更易于管理和理解的语句序列。当我们编写这些打包的语句时，我们可以在合适的地方重复使用它们。如果我们需要根据上下文使其以不同方式运行，那么我们会传入一个参数。如果它返回一个结果，那么函数需要一个返回类型。
- en: As C++ is a strongly typed language, we need to specify the types related to
    the functions that we implement – the type of value returned by the function (including
    no return) and the type of argument(s) that are passed to it, if any.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++是一种强类型语言，我们需要指定与我们实现的函数相关的类型 - 函数返回的值的类型（包括无返回）以及传递给它的参数的类型（如果有的话）。
- en: 'The following is a typical hello world program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的hello world程序：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Two functions have been declared in the preceding example – `hello_world()`
    and `main()`. The `main()` function is the entry point to every C++ program ever
    written and it returns an `int` value that is passed into the host system. It
    is known as the exit code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中声明了两个函数 - `hello_world()`和`main()`。`main()`函数是每个C++程序的入口点，并返回一个传递给主机系统的`int`值。它被称为退出代码。
- en: Everything from the declaration of the return type up to the opening brace ({)
    is known as the **function prototype**. It defines three things, namely the return
    type, the name of the function, and the number and types of an argument.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从返回类型的声明到开括号（{）之间的所有内容都被称为**函数原型**。它定义了三件事，即返回类型、函数的名称和参数的数量和类型。
- en: 'For the first function, the return type is `void` – that is, it returns no
    value; it has a name of `hello_world` and takes no arguments:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个函数，返回类型是`void` - 也就是说，它不返回任何值；它的名称是`hello_world`，不需要参数：
- en: '![Figure 2A.15: Declaration of a function that takes no arguments and returns
    nothing](img/C14583_02A_15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.15：不带参数并且不返回任何内容的函数声明](img/C14583_02A_15.jpg)'
- en: 'Figure 2A.15: Declaration of a function that takes no arguments and returns
    nothing'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.15：不带参数并且不返回任何内容的函数声明
- en: 'The second function returns an `int` value, has the name of `main`, and takes
    two arguments. These arguments are `argc` and `argv` and have the `int` and *pointer
    to a pointer of* `char` types, respectively:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数返回一个`int`值，名称为`main`，并带有两个参数。这些参数分别是`argc`和`argv`，类型分别为`int`和`char`类型的*指针的指针*：
- en: '![Figure 2A.16: Declaration of a function that takes two arguments and returns
    an int](img/C14583_02A_16.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.16：带有两个参数并返回int的函数声明](img/C14583_02A_16.jpg)'
- en: 'Figure 2A.16: Declaration of a function that takes two arguments and returns
    an int'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.16：带有两个参数并返回int的函数声明
- en: Everything after the function prototype is known as the **function body**. The
    function body contains variable declarations and the statements to execute.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型之后的所有内容都被称为**函数体**。函数体包含变量声明和要执行的语句。
- en: A function must be declared before it is used – that is, the compiler needs
    to know its arguments and its return type. If the function is defined in the file
    that it is to be used in after the call to it, then you can solve this problem
    by providing a forward declaration of the function before it is used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在使用之前必须声明 - 也就是说，编译器需要知道它的参数和返回类型。如果函数在调用它的文件中定义在它之后，那么可以通过在使用之前提供函数的前向声明来解决这个问题。
- en: 'A forward declaration is made by placing the function prototype that was terminated
    by a semicolon in the file before it is called. For `hello_world()`, this would
    be done as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在调用之前的文件中放置以分号终止的函数原型来进行前向声明。对于`hello_world()`，可以这样做：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the main function, this would be done as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主函数，可以这样做：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A function prototype does not need the names of the arguments, only the types.
    However, to help the users of the function, it is a good idea to keep them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型不需要参数的名称，只需要类型。但是，为了帮助函数的用户，保留参数是个好主意。
- en: In C++, the definition of the function can be in one file and needs to be called
    from a different file. So, how does the second file know the prototype of the
    function it wishes to call? This is achieved by placing the forward declarations
    into a separate file known as a header file and including it in the second file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，函数的定义可以在一个文件中，需要从另一个文件中调用。那么，第二个文件如何知道它希望调用的函数的原型？这是通过将前向声明放入一个名为头文件的单独文件中并在第二个文件中包含它来实现的。
- en: 'Exercise 2: Declaring Functions'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：声明函数
- en: In this exercise, we will test what the compiler needs to know when it encounters
    a function call and implements a forward declaration to resolve an unknown function.
    Let's get started.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试编译器在遇到函数调用时需要了解的内容，并实现一个前向声明来解析未知的函数。让我们开始吧。
- en: Open the **Lesson2A** project in Eclipse, and then, in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise02** and double-click on **Exercise2.cpp**
    to open the file for this exercise into the editor.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在**Project Explorer**中展开**Lesson2A**，然后展开**Exercise02**，双击**Exercise2.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。
- en: Configure **Exercise2** to run with the name **Exercise2**. When that is complete,
    it will be the currently selected Launch Configuration.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Exercise2**配置为以名称**Exercise2**运行。完成后，它将成为当前选择的启动配置。
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 2A.17: Output from the exercise2 program](img/C14583_02A_17.jpg)'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮。练习2将运行并产生以下输出：![图2A.17：exercise2程序的输出](img/C14583_02A_17.jpg)
- en: 'Figure 2A.17: Output from the exercise2 program'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.17：exercise2程序的输出
- en: 'Go into the editor and change the code by moving the `gcd` function so that
    it''s after `main`. It should look as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入编辑器，通过将`gcd`函数移动到`main`之后来更改代码。它应该如下所示：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click on the `gcd()` function. It has no knowledge of the function at the point
    it needs to call it, even though it is defined in the same file but after the
    call.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`gcd()`函数。在需要调用它的时候，它对该函数没有任何了解，即使它在相同的文件中定义，但是在调用之后。
- en: 'In the editor, place the forward declaration before the definition of the main
    function. Also add a semicolon (;) at the end:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将前向声明放在主函数定义之前。同时在末尾添加一个分号（;）：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click on the **Run** button again. This time, the program compiles and the original
    output is restored.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**运行**按钮。这次，程序编译并恢复原始输出。
- en: In this exercise, we learned how to forward declare functions and troubleshoot
    compiler errors that occur when a function is not declared before it is used.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何提前声明函数并解决编译器错误，这些错误发生在使用函数之前未声明的情况下。
- en: In the early versions of C compilers, this was acceptable. The program would
    assume that the function existed and returned an int. The functions' arguments
    could be inferred from the call. However, this is not true in the case of modern
    C++ as you must declare a function, class, variable, and so on before using it.
    In the next section, we'll learn about pointer types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的C编译器版本中，这是可以接受的。程序会假定函数存在并返回一个int。函数的参数可以从调用中推断出来。然而，在现代C++中并非如此，因为您必须在使用之前声明函数、类、变量等。在下一节中，我们将学习指针类型。
- en: Pointer Types
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针类型
- en: 'Because of its origins in the C language, that is, writing optimally efficient
    systems and having direct access to hardware, C++ allows you to declare a variable
    as a pointer type. It is of the following format:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C语言的起源，即编写高效的系统并直接访问硬件，C++允许您将变量声明为指针类型。其格式如下：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the same as before, except for two things:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以前一样，只有两个不同之处：
- en: Use of the special declarator asterisk (`*`) to indicate that the variable named
    pvar points to a location or address in memory.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊声明符星号（`*`）指示名为pvar的变量指向内存中的位置或地址。
- en: It is initialized using the special operator ampersand (`&`), which in this
    context tells the compiler to return the address of the `var` variable.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用特殊运算符和号（`&`）进行初始化，在这种情况下告诉编译器返回`var`变量的地址。
- en: 'As C is a high-level language, but with low-level access, pointers allow users
    to access memory directly, which is helpful when we wish to provide input/output
    to hardware and thus control it. Another use of pointers is to allow functions
    to be provided with access to common data items and remove the need to copy large
    amounts of data when calling functions as it defaults to passing by value. To
    access the value that''s being pointed to by the pointer, the special operator
    asterisk (`*`) is used to **dereference** the location:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C是一种高级语言，但具有低级访问权限，指针允许用户直接访问内存，这在我们希望向硬件提供输入/输出并控制硬件时非常有帮助。指针的另一个用途是允许函数访问共同的数据项，并在调用函数时消除大量数据的复制需求，因为它默认为按值传递。要访问指针指向的值，使用特殊运算符星号（`*`）来**解引用**位置：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following diagram shows how the compiler allocates the memory. `pvalue`
    requires memory to store the pointer, while `five` needs memory to store the integer
    value of 5:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了编译器分配内存的方式。`pvalue`需要内存来存储指针，而`five`需要内存来存储整数值5：
- en: '![Figure 2A.19: Memory layout for pointer variables](img/C14583_02A_19.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.19：指针变量的内存布局](img/C14583_02A_19.jpg)'
- en: 'Figure 2A.19: Memory layout for pointer variables'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.19：指针变量的内存布局
- en: When accessing a user-defined type via a pointer, there is a second special
    operator (->) that is also used for dereferencing member variables and functions.
    In modern C++, these pointers are referred to as **raw pointers** and the way
    in which they are used has changed significantly. Working with pointers in C and
    C++ has always proved challenging for programmers, and their incorrect use is
    the source of many problems, the most common being resource leaks. A resource
    leak is a scenario where a program has grabbed a resource (a memory, a file handle,
    or other system resource) for its use and fails to let it go when it's finished
    with it. These resource leaks can lead to performance issues, program failures,
    and even system crashes. The use of raw pointers in modern C++ to manage the ownership
    of a resource is now deprecated since smart pointers arrived in C++11\. Smart
    pointers (implemented as classes in the STL) now do the housekeeping required
    to be a good citizen in your host system. More about this will be covered in *Chapter
    3*, *The Distance Between Can and Should – Objects, Pointers, and Inheritance*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过指针访问用户定义的类型时，还有第二个特殊运算符（->）用于解引用成员变量和函数。在现代C++中，这些指针被称为**原始指针**，它们的使用方式发生了显著变化。在C和C++中使用指针一直是程序员面临的挑战，它们的错误使用是许多问题的根源，最常见的是资源泄漏。资源泄漏是指程序获取了资源（内存、文件句柄或其他系统资源）供其使用，但在使用完毕后未释放。这些资源泄漏可能导致性能问题、程序失败，甚至系统崩溃。在现代C++中使用原始指针来管理资源的所有权现已被弃用，因为智能指针在C++11中出现。智能指针（在STL中实现为类）现在执行所需的清理工作，以成为主机系统中的良好组成部分。关于这一点将在*第3章*，*能与应该之间的距离-对象、指针和继承*中进行更多介绍。
- en: In the preceding code, when `pvalue` is declared, the compiler allocates memory
    to store only the address of the memory it will be referring to. Like other variables,
    you should always ensure that a pointer is initialized before it is used as dereferencing
    an uninitialized pointer results in an undefined behavior. Exactly how much memory
    is allocated to store a pointer is dependent upon the system that the compiler
    is designed for and how many bits the processor supports. But all pointers will
    be of the same size, regardless of what type they point to.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，当声明`pvalue`时，编译器只分配内存来存储它将引用的内存的地址。与其他变量一样，您应始终确保在使用指针之前对其进行初始化，因为对未初始化的指针进行解引用会导致未定义的行为。存储指针的内存量取决于编译器设计的系统以及处理器支持的位数。但是，无论它们指向什么类型，所有指针的大小都将相同。
- en: 'A pointer can also be passed to a function. This allows the function to access
    the data being pointed to and possibly modify it. Consider the following implementation
    of swap:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 指针也可以传递给函数。这允许函数访问指向的数据并可能修改它。考虑以下swap的实现：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows how to declare pointers as arguments to a function, how to get the
    value from the pointer by using the dereferencing operator `*`, as well as how
    to set a value through the dereference operator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何将指针声明为函数的参数，如何使用解引用运算符`*`从指针获取值，以及如何通过解引用运算符设置值。
- en: 'The following example allocates memory from the host system using the new operator
    and releases it back to the host system using the delete operator:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用new运算符从主机系统中分配内存，并使用delete运算符将其释放回主机系统：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, the first line creates an array of 20 characters using
    the array allocation form of the new operator. It makes a call to the host system
    to allocate 20 * sizeof(char) bytes of memory for our use. Exactly how much memory
    is allocated is up to the host system, but it is guaranteed to be at least 20
    * sizeof(char) bytes. If it fails to allocate the required memory, then one of
    two things will happen:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，第一行使用new运算符的数组分配形式创建了一个包含20个字符的数组。它向主机系统发出调用，为我们分配20 * sizeof(char)字节的内存。分配多少内存取决于主机系统，但保证至少为20
    * sizeof(char)字节。如果无法分配所需的内存，则会发生以下两种情况之一：
- en: It will throw an exception
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会抛出一个异常
- en: It will return `nullptr`. This is a special literal that was introduced in C++11\.
    Earlier, C++ used 0 or NULL to indicate a non-valid pointer. C++11 made this a
    strongly typed value as well.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将返回`nullptr`。这是C++11中引入的特殊文字。早期，C++使用0或NULL表示无效指针。C++11也将其作为强类型值。
- en: On most systems, the first outcome will be the result, and you will need to
    deal with the exception. The second outcome is possible from two scenarios – calling
    the nothrow variant of new, that is, `new(std::nothrow) int [250]`, or on embedded
    systems where the overhead of exception processing is not sufficiently deterministic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，第一个结果将是结果，并且您需要处理异常。第二个结果可能来自两种情况——调用new的nothrow变体，即`new(std::nothrow)
    int [250]`，或者在嵌入式系统上，异常处理的开销不够确定。
- en: 'Finally, note that the call to delete uses the array form of the delete operator,
    that is, with square brackets, []. It is important to ensure that the same form
    is used with the new and delete operators. When new is used on a user-defined
    type (which will be discussed in the next section), it does more than just allocate
    memory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，delete的调用使用了delete运算符的数组形式，即带有方括号[]。重要的是确保与new和delete运算符一起使用相同的形式。当new用于用户定义的类型（将在下一节中讨论）时，它不仅仅是分配内存：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, the call to new allocates sufficient memory to store
    MyClass and, if successful, it then proceeds to call the constructor to initialize
    the data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，对new的调用分配了足够的内存来存储MyClass，如果成功，它会继续调用构造函数来初始化数据：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, the call to new allocates sufficient memory to store
    12 copies of MyClass and, if successful, it then proceeds to call the constructor
    12 times to initialize the data for each object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，对new的调用分配了足够的内存来存储12个MyClass的副本，如果成功，它会继续调用构造函数12次来初始化每个对象的数据。
- en: Note that `object` and `objects`, which were declared in the preceding snippets
    of code, have the `objects` should be a pointer to an array of MyClass, but it
    is actually a pointer to an instance of MyClass. `objects` points to the first
    instance in the array of MyClass.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面代码片段中声明的`object`和`objects`，`objects`应该是指向MyClass数组的指针，但实际上它是MyClass实例的指针。`objects`指向MyClass数组中的第一个实例。
- en: 'Consider the following excerpt of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码摘录：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the process() function, `objects` is of the "array of 12 MyClass items"
    type, but when it is passed to `printMyClasses()`, it is converted (by the compiler)
    into the "a pointer to MyClass" type. This is by design (inherited from C) and
    is known as `printMyClasses()` as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在process()函数中，`objects`是"包含12个MyClass项的数组"类型，但当它传递给`printMyClasses()`时，它被（由编译器）转换为"指向MyClass的指针"类型。这是有意设计的（从C继承而来），并且被称为`printMyClasses()`如下：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This would still suffer from array decay as the compiler changes the argument
    object to MyClass*; it does not keep the dimension information in this case. Array
    decay is the reason that we need to pass number to the `printMyClasses()` function:
    so that we know how many items are in the array. C++ provides two mechanisms for
    dealing with array decay:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会受到数组衰减的影响，因为编译器将参数对象更改为MyClass*；在这种情况下，它不保留维度信息。数组衰减是我们需要将数字传递给`printMyClasses()`函数的原因：这样我们就知道数组中有多少项。C++提供了两种处理数组衰减的机制：
- en: Use of iterators to pass a range into the method. STL containers (see the *C++
    Pre-Packaged Templates* section in *Chapter 2B*, *No Ducks Allowed – Templates
    and Deduction*) offer the `begin()` and `end()` methods so that we can obtain
    iterators that allow algorithms to traverse an array or part thereof.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器将范围传递到方法中。STL容器（参见*第2B章*中的*C++预打包模板*部分，*不允许鸭子-模板和推断*）提供`begin()`和`end()`方法，以便我们可以获得允许算法遍历数组或其部分的迭代器。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For C++20, the ISO standard committee is considering the inclusion of a concept
    known as Ranges that will allow both the begin and end iterators to be captured
    in one object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++20，ISO标准委员会正在考虑包含一种称为Ranges的概念，它将允许同时捕获起始和结束迭代器的对象。
- en: Use of templates (see the *Non-Type Template Arguments* section in *Chapter
    2B, No Ducks Allowed – Templates and Deduction*).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板（参见*第2B章，不允许鸭子-模板和推断*中的*非类型模板参数*部分）。
- en: 'Exercise 3: Declaring and Using Pointers'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：声明和使用指针
- en: 'In this exercise, we will implement functions that take pointers and arrays
    as arguments and compare their behavior while considering array decay. Let''s
    get started:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现接受指针和数组作为参数并比较它们的行为，同时考虑数组衰减的函数。让我们开始吧：
- en: Open the **Lesson2A** project in Eclipse, and then in the Project Explorer,
    expand **Lesson2A**, then **Exercise03**, and double-click on **Exercise3.cpp**
    to open the file for this exercise into the editor.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在项目资源管理器中展开**Lesson2A**，然后**Exercise03**，双击**Exercise3.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise3** to run with the name **Exercise3**.
    When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。配置**Exercise3**以运行名称**Exercise3**。完成后，它将成为当前选择的Launch
    Configuration。
- en: 'Click on the **Run** button. Exercise 3 will run and produce the following
    output:![Figure 2A.20: Exercise 3 output](img/C14583_02A_20.jpg)'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮。练习3将运行并产生以下输出：![图2A.20：练习3输出](img/C14583_02A_20.jpg)
- en: 'Figure 2A.20: Exercise 3 output'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.20：练习3输出
- en: In the editor, insert a blank line somewhere and click on the **Run** button.
    (By changing the file, it will force the build system to recompile **Exercise3.cpp**.)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中的某个地方插入一行空行，然后点击**Run**按钮。（通过更改文件，它将强制构建系统重新编译**Exercise3.cpp**。）
- en: 'If we now look at the `print_array_size2()` is of the `int*` type and is borne
    out by the warning stating that sizeof `will return size of ''int*''`:![Figure
    2A.22: Exercise 3 partial output](img/C14583_02A_22.jpg)'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在看`print_array_size2()`是`int*`类型，并且由警告说明`sizeof`将返回'int*'的大小所证实：![图2A.22：练习3部分输出](img/C14583_02A_22.jpg)
- en: 'Figure 2A.22: Exercise 3 partial output'
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.22：练习3部分输出
- en: The `sizeof(ary)/sizeof(arg[0])` calculation should return the number of elements
    in an array. The first `elements in (ary) = 10` is generated from the main function
    and ary was declared as `ary[10]`, so it is correct. The `elements in (ary) =
    2` under the ---print_array_size2--- banner shows the problem with array decay
    and why the compiler generated a warning. Why the value of 2? On a test PC, a
    pointer occupies 8 bytes (64 bits), while an int only occupies 4 bytes, so we
    get 8/4 = 2.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof(ary)/sizeof(arg[0])`的计算应返回数组中的元素数。`elements in (ary) = 10`是从main函数生成的，ary声明为`ary[10]`，所以是正确的。在---print_array_size2---横幅下的`elements
    in (ary) = 2`显示了数组衰减的问题，以及为什么编译器生成了警告。为什么值是2？在测试PC上，指针占用8字节（64位），而int只占用4字节，所以我们得到8/4
    = 2。'
- en: 'In the editor, locate the line in main() where ary is declared and change it
    to the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，找到main()中声明ary的行，并将其更改为以下内容：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Click on the `int ary[15]` would cause an error or at least a warning since
    the argument prototypes do not match. As we stated previously, the compiler treats
    the argument as `int* ary`, so the function may as well have been declared as
    follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`int ary[15]`会导致错误或至少警告，因为参数原型不匹配。正如我们之前所述，编译器将参数视为`int* ary`，因此函数也可以声明如下：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the editor, change the name of `print_array_size2` to `print_array_size`
    all through the file. Click on the `int* ary` and `int ary[10]`. This is the confirmation
    that, when used as an argument to a function, `int ary[10]` generates the same
    as if `int*` ary was declared.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将`print_array_size2`的名称全部更改为`print_array_size`。点击`int* ary`和`int ary[10]`。这是确认，当作为函数参数使用时，`int
    ary[10]`生成的结果与声明`int*` ary时相同。
- en: Restore the file to its original state.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件恢复到其原始状态。
- en: In the `main()` function, locate the line with `Step 11` in a comment and remove
    the comment at the beginning of the line. Click on the `title` to be `const char*`
    and p of type `char*`. The const-ness is important. The p pointer allows us to
    change the value of whatever it points at.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，找到带有`Step 11`注释的行，并删除该行开头的注释。点击`title`以使其为`const char*`，p的类型为`char*`。const很重要。p指针允许我们更改其指向的值。
- en: 'Take a look at the following line:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下以下行：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Change it to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Click on the **Run** button. This time, it builds and runs properly. It is OK
    to assign a non-const pointer to a const pointer.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮。这次，它构建并正确运行。将非const指针分配给const指针是可以的。
- en: In this exercise, we learned that arrays need to treated carefully when passing
    them into functions as critical information (the size of the array) will be lost
    in the call.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学到了当将数组传递到函数中时，需要小心处理数组，因为关键信息（数组的大小）将在调用中丢失。
- en: Creating User Types
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户类型
- en: The great thing about C++ is that you can create your own types using **struct**,
    **class**, **enum**, or **union** and the compiler will treat it as a fundamental
    type throughout the code. In this section, we will explore creating our own type
    and the methods that we need to write to manipulate it, as well as some methods
    that the compiler will create for us.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C++的伟大之处在于您可以使用**struct**、**class**、**enum**或**union**创建自己的类型，编译器将在整个代码中将其视为基本类型。在本节中，我们将探讨创建自己的类型以及我们需要编写的方法来操纵它，以及编译器将为我们创建的一些方法。
- en: Enumerations
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The simplest user-defined type is the enumeration. Enumerations got an overhaul
    in C++11 to make them even more type-safe, so we have to consider two different
    declaration syntaxes. Before we look at how to declare them, let''s figure out
    why we need them. Consider the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用户定义类型是枚举。C++11对枚举进行了改进，使它们更加类型安全，因此我们必须考虑两种不同的声明语法。在看如何声明它们之前，让我们弄清楚为什么需要它们。考虑以下代码：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is typical of many C library functions where a status code is returned
    and you need the main page to know what they mean. In the preceding code, `-1`,
    `-2`, `-3`, and `0` are known as **magic numbers**. You need to read the code
    to understand what each number means. Now, consider the following version of the
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多C库函数的典型特征，其中返回状态代码，您需要主页知道它们的含义。在前述代码中，`-1`、`-2`、`-3`和`0`被称为**魔术数字**。您需要阅读代码以了解每个数字的含义。现在，考虑以下版本的代码：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This uses an enumeration class to communicate the result and attach the meaning
    to the name of the values. A user of the function can now use the enumerations
    as the code is easier to understand and use. So, the magic numbers (related to
    the status) have been replaced with an enumerated value that has a descriptive
    title. Let''s learn about the declaration of `FileCheckStatus` by referring to
    the following pieces of code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用枚举类来传达结果并将含义附加到值的名称上。函数的用户现在可以使用枚举，因为代码更容易理解和使用。因此，魔术数字（与状态相关）已被替换为具有描述性标题的枚举值。让我们通过以下代码片段了解`FileCheckStatus`的声明：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we want to use the values from the magic numbers, then we would declare
    them like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用魔术数字的值，那么我们会这样声明它们：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, by turning the order around, we can set the first value and
    the compiler will do the rest:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过改变顺序，我们可以设置第一个值，编译器会完成其余部分：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding function can also be written as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数也可以写成如下形式：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that the scoping directive, `FileCheckStatus::`, is missing from the code,
    but it will still compile and work. This raises the issue of scope, which we will
    discuss in detail later in the *Visibility, Lifetime, and Access* section of *Chapter
    2B*, *No Ducks Allowed – Templates and Deduction*. For now, know that every type
    and variable has a scope and the problem with old-style enumerations is that their
    enumerators are added into the same scope as the enumeration. Let''s say we have
    two enumerations defined as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中缺少作用域指令`FileCheckStatus::`，但它仍将编译并工作。这引发了作用域的问题，我们将在*第2B章*的*可见性、生命周期和访问*部分中详细讨论。现在，知道每种类型和变量都有一个作用域，旧式枚举的问题在于它们的枚举器被添加到与枚举相同的作用域中。假设我们有两个枚举定义如下：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now have a problem in which the `Pass` enumerator is defined twice and has
    two different values. Old-style enumerations also allow us to write a valid compiler
    but apparently nonsensical code, such as the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个问题，`Pass`枚举器被定义两次并具有两个不同的值。旧式枚举还允许我们编写有效的编译器，但显然毫无意义的代码，例如以下代码：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we are trying to develop code that is clear in intent and easy to understand,
    comparing a result to an option has no meaning. The problem is that the compiler
    would implicitly convert the value into an integer and thus be able to compare
    it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们试图开发清晰明了的代码，易于理解，将结果与选项进行比较是没有意义的。问题在于编译器会隐式将值转换为整数，从而能够进行比较。
- en: 'C++11 introduced a new concept that is referred to as an **enum class** or
    **scoped enumeration**. The scoped enumeration definition of the preceding code
    looks as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一个被称为**枚举类**或**作用域枚举**的新概念。前述代码的作用域枚举定义如下：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This means that the preceding code will no longer compile:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前述代码将不再编译：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As the name implies, **scoped enumeration** places the enumerators inside the
    scope of the enumeration name. In addition, a scoped enumeration will no longer
    be implicitly converted into an integer (hence the if statement will fail to compile).
    You can still convert the enumerator into an integer, but you will need to cast
    it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，**作用域枚举**将枚举器放置在枚举名称的作用域内。此外，作用域枚举将不再被隐式转换为整数（因此 if 语句将无法编译通过）。您仍然可以将枚举器转换为整数，但需要进行类型转换：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exercise 4: Enumerations – Old and New School'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：枚举-新旧学校
- en: 'In this exercise, we will implement a program that uses enumerations to represent
    predefined values and determine the consequential changes required when they are
    changed to a scoped enum. Let''s get started:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个程序，使用枚举来表示预定义的值，并确定当它们更改为作用域枚举时所需的后续更改。让我们开始吧：
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise04**, and double-click on **Exercise4.cpp**
    to open the file for this exercise in the editor.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在**Project Explorer**中展开**Lesson2A**，然后展开**Exercise04**，双击**Exercise4.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise4** to run with the name **Exercise4**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新建启动配置…**。配置**Exercise4**以使用名称**Exercise4**运行。
- en: When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，它将成为当前选择的启动配置。
- en: 'Click on the **Run** button. Exercise 4 will run and produce the following
    output:![Figure 2A.25: Exercise 4 output](img/C14583_02A_25.jpg)'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习4将运行并产生以下输出：![图2A.25：练习4输出](img/C14583_02A_25.jpg)
- en: 'Figure 2A.25: Exercise 4 output'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.25：练习4输出
- en: 'Examine the code in the editor. Currently, we can compare apples and oranges.
    At the definition of `printOrange()`, change the argument to be `Orange`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查编辑器中的代码。目前，我们可以比较苹果和橙子。在`printOrange()`的定义处，将参数更改为`Orange`：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**:![Figure 2A.26: Cannot convert error](img/C14583_02A_26.jpg)'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。当出现工作区中的错误对话框时，单击**取消**：![图2A.26：无法转换错误](img/C14583_02A_26.jpg)
- en: 'Figure 2A.26: Cannot convert error'
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.26：无法转换错误
- en: By changing the argument type, we forced the compiler to enforce the type of
    the value that was passed to the function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改参数类型，我们迫使编译器强制执行传递给函数的值的类型。
- en: 'Call the `printOrange()` function twice by passing the `orange` `enum` variable
    in the initial call and the `apple` variable in the second call, respectively:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在初始调用中传递`orange` `enum`变量并在第二次调用中传递`apple`变量，两次调用`printOrange()`函数：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shows that the compiler is implicitly converting the orange and apple into
    an `int` so that it can call the function. Also, note the warning about comparing
    `Apple` and `Orange`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明编译器会将橙色和苹果隐式转换为`int`，以便调用该函数。还要注意关于比较`Apple`和`Orange`的警告。
- en: 'Restore the `printOrange()` function by taking an int argument and changing
    the definition of the `orange` `enum` to the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过采用int参数并将`orange` `enum`的定义更改为以下内容来恢复`printOrange()`函数：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**:![Figure 2A.27: Multiple errors for scoped enum changes](img/C14583_02A_27.jpg)'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。当出现工作区中的错误对话框时，单击**取消**：![图2A.27：作用域枚举更改的多个错误](img/C14583_02A_27.jpg)
- en: 'Figure 2A.27: Multiple errors for scoped enum changes'
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.27：作用域枚举更改的多个错误
- en: 'Locate the first error listed for this build:![Figure 2A.28: First scoped enum
    error ](img/C14583_02A_28.jpg)'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到此构建的第一个错误：![图2A.28：第一个作用域枚举错误](img/C14583_02A_28.jpg)
- en: 'Figure 2A.28: First scoped enum error'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.28：第一个作用域枚举错误
- en: 'The first thing to note about scoped enums is that when you reference the enumerators,
    they must have a scope specifier. Therefore, in the editor, go and change this
    line to the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于作用域枚举的第一件事是，当您引用枚举器时，它们必须具有作用域限定符。因此，在编辑器中，转到并更改此行如下：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Click on the `Orange` type. Because this involves a template-based class (which
    we'll talk about later), the error messages become very long-winded. Take a minute
    to look at all the messages that appear from this error to the next (red lines).
    It shows you what the compiler was trying to do to be able to compile that line.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Orange`类型。因为这涉及基于模板的类（我们稍后会讨论），错误消息变得非常冗长。花一分钟时间查看从此错误到下一个错误（红线）出现的所有消息。它向您展示了编译器试图做什么以能够编译该行。
- en: 'Change the indicated line to read the following:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改指定的行以读取如下内容：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Click on the `Orange::` scope specifier.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Orange::`作用域限定符。
- en: It is left as an exercise for you to get the file to compile again with `orange`
    as a scope enumeration.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留给你的练习是使用`orange`作为作用域枚举重新编译文件。
- en: In this exercise, we found that scope enums improve the strong type checking
    of C++ and if we wish to use them as an integral value, then we need to cast them,
    unlike non-scope enums, which are implicitly converted.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们发现作用域枚举改进了C++的强类型检查，如果我们希望将它们用作整数值，那么我们需要对它们进行转换，而非作用域枚举则会隐式转换。
- en: Troubleshooting Compiler Errors
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除编译器错误
- en: As seen from the preceding exercise, the compiler can generate a very large
    amount of error and warning messages from one error. This is why it is recommended
    to find the first error and fix it first. Development in IDEs or using build systems
    that color-code errors can make this easier.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的练习中可以看出，编译器可以从一个错误生成大量的错误和警告消息。这就是为什么建议找到第一个错误并首先修复它。在IDE中开发或使用着色错误的构建系统可以使这更容易。
- en: Structures and Classes
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构和类
- en: Enumerations are the first of the user-defined types, but they do not really
    extend the language so that we can express the solutions to our problems at the
    appropriate level of abstraction. Structs and classes, however, allow us to capture
    and group the data and then associate methods to manipulate that data in a consistent
    and meaningful manner.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是用户定义类型中的第一个，但它们并没有真正扩展语言，以便我们可以以适当的抽象级别表达问题的解决方案。然而，结构和类允许我们捕获和组合数据，然后关联方法以一致和有意义的方式来操作这些数据。
- en: 'If we consider the multiplication of two matrices, *A (m x n)* and *B (n x
    p)*, which results in matrix *C (m x p)*, then the equation for the ith row and
    jth column of C is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑两个矩阵的乘法，*A（m x n）*和*B（n x p）*，其结果是矩阵*C（m x p）*，那么C的第i行和第j列的方程如下：
- en: '![](img/C14583_02A_31.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_02A_31.jpg)'
- en: 'Figure 2A.31: Equation of ith row and jth column'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.31：第i行和第j列的方程
- en: 'If we had to write it every time we wished to multiply two matrices, we would
    end up with many nested for loops. But if we could abstract a matrix into a class,
    then we could express it as simple as we express the multiplication of two integers
    or two floating-point numbers:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们每次都必须这样写来乘两个矩阵，我们最终会得到许多嵌套的for循环。但是，如果我们可以将矩阵抽象成一个类，那么我们可以像表达两个整数或两个浮点数的乘法一样来表达它：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the beauty of object-oriented design – data encapsulation and the abstraction
    of concepts are explained at such a level that we can easily understand what the
    program is trying to achieve without getting buried in the details. Once we have
    established that the matrix multiplication is correctly implemented, then we are
    free to focus on solving our problem at a higher level.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象设计的美妙之处 - 数据封装和概念的抽象被解释在这样一个层次上，以至于我们可以轻松理解程序试图实现的目标，而不会陷入细节。一旦我们确定矩阵乘法被正确实现，那么我们就可以自由地专注于以更高层次解决我们的问题。
- en: The discussion that follows refers to classes, but it applies equally to structs
    and, mostly, to unions. We will outline the differences between classes, structs,
    and unions after we learn how to define and use a class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的讨论涉及类，但同样适用于结构体，大部分适用于联合体。在学习如何定义和使用类之后，我们将概述类、结构体和联合体之间的区别。
- en: Fraction Class
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数类
- en: To show you how to define and use a class, we will work on developing the `Fraction`
    class to implement rational numbers. When defined, we can use `Fraction` like
    any other built-in type (add, subtract, multiply, divide) without worrying about
    the details – this is abstraction. We can now just think and reason about a fraction
    at a higher level, that is, an abstract level.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示如何定义和使用类，我们将致力于开发`Fraction`类来实现有理数。一旦定义，我们可以像使用任何其他内置类型一样使用`Fraction`（加法、减法、乘法、除法），而不必担心细节
    - 这就是抽象。现在我们只需在更高的抽象层次上思考和推理分数。
- en: 'The `Fraction` class will do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fraction`类将执行以下操作：'
- en: Contain two integer member variables, `m_numerator` and `m_denominator`
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个整数成员变量，`m_numerator`和`m_denominator`
- en: Provide methods to copy itself, assign to it, multiply, divide, add, and subtract
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供方法来复制自身，分配给自身，相乘，相除，相加和相减
- en: Provide a method to write to an output stream
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方法写入输出流
- en: 'To attain the preceding objective, we have the following definitions:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述目标，我们有以下定义：
- en: '![Figure 2A.32: Definitions of operations](img/C14583_02A_32.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.32：操作的定义](img/C14583_02A_32.jpg)'
- en: 'Figure 2A.32: Definitions of operations'
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.32：操作的定义
- en: In addition, the operations that we perform will need to normalize the fraction
    by reducing it to the lowest terms. To do this, the numerator and the denominator
    are both divided by their greatest common divisor (GCD).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们执行的操作将需要将分数归一化为最低项。为此，分子和分母都要除以它们的最大公约数（GCD）。
- en: Constructors, Initialization, and Destructors
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数、初始化和析构函数
- en: 'A class definition, as expressed in C++ code, is the pattern that''s used for
    creating objects in memory and manipulating objects through their methods. The
    first thing that we need to do is tell the compiler that we wish to declare a
    new type – a class. To declare the `Fraction` class, we start with the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义在C++代码中表达的是用于在内存中创建对象并通过它们的方法操作对象的模式。我们需要做的第一件事是告诉编译器我们希望声明一个新类型 - 一个类。要声明`Fraction`类，我们从以下开始：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We place this in a header file, **Fraction.h**, as we wish to reuse this class
    specification in other areas of our code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这放在一个头文件**Fraction.h**中，因为我们希望在代码的其他地方重用这个类规范。
- en: 'The next thing we need to do is introduce the data to be stored in the class,
    which in this case are `m_numerator` and `m_denominator`. These are both of the
    int type:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是引入要存储在类中的数据，在这种情况下是`m_numerator`和`m_denominator`。这两者都是int类型：
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have now declared the data to be stored and given them names that anyone
    familiar with mathematics would understand regarding what each member variable
    stores:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经声明了要存储的数据，并为它们赋予了任何熟悉数学的人都能理解的名称，以了解每个成员变量存储的内容：
- en: '![](img/C14583_02A_33.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_02A_33.jpg)'
- en: 'Figure 2A.33: Formula of fraction'
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.33：分数的公式
- en: 'As this is a class, by default, any item that''s declared is assumed to be
    `private`. This means that no external entity can access these variables. It is
    this feature of hiding (making data private, and for that matter, some methods)
    that enables encapsulation in C++. C++ has three class access modifiers:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个类，默认情况下，声明的任何项目都被假定为`private`。这意味着没有外部实体可以访问这些变量。正是这种隐藏（使数据私有，以及某些方法）使得C++中的封装成为可能。C++有三种类访问修饰符：
- en: '**public**: This means that the member (variable or function) is accessible
    from anywhere outside of the class.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public**：这意味着成员（变量或函数）可以从类外部的任何地方访问。'
- en: '**private**: This means that the member (variable or function) cannot be accessed
    from outside the class. In fact, it cannot even be viewed. Private variables and
    functions can only be accessed from within the class or by a friend method or
    class. The private members (variables and functions) are used by the public functions
    to achieve the desired functionality.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private**：这意味着成员（变量或函数）无法从类外部访问。事实上，甚至无法查看。私有变量和函数只能从类内部或通过友元方法或类访问。私有成员（变量和函数）由公共函数使用以实现所需的功能。'
- en: '**protected**: This is a cross between private and public. From outside the
    class, the variable or function is private. However, for any class that is derived
    from the class that declares the protected members, they are treated as public.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected**：这是私有和公共之间的交叉。从类外部来看，变量或函数是私有的。但是，对于从声明受保护成员的类派生的任何类，它们被视为公共的。'
- en: 'At this point in our definition of the class, this is not very useful. Let''s
    change the declaration to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义类的这一点上，这并不是很有用。让我们将声明更改为以下内容：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By doing this, we can access the internal variables. The `Fraction number;`
    variable declaration will cause the compiler to do two things:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以访问内部变量。`Fraction number;`变量声明将导致编译器执行两件事：
- en: Allocate enough memory to hold both the data items (depending on the types,
    this may or may not involve padding, that is, the inclusion or addition of unused
    memory to align members for the most efficient access). The `sizeof` operator
    can tell us how much memory is allocated for our class.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配足够的内存来容纳数据项（取决于类型，这可能涉及填充，即包括或添加未使用的内存以对齐成员以实现最有效的访问）。`sizeof`运算符可以告诉我们为我们的类分配了多少内存。
- en: Initialize the data items by calling the **default constructor**.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用**默认构造函数**来初始化数据项。
- en: These steps are the same that the compiler does for built-in types, that is,
    step 2 does nothing, leading to uninitialized variables. But what is this default
    constructor? And what does it do?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤与编译器为内置类型执行的步骤相同，即步骤2什么也不做，导致未初始化的变量。但是默认构造函数是什么？它做什么？
- en: Firstly, the default constructor is a special member function. It is one of
    the many possible constructors, three of which are deemed special member functions.
    Constructors can be declared with zero, one, or more arguments, just like any
    other function, but they do NOT specify a return type. Constructors serve the
    special purpose of initializing all the member variables to place the object into
    a well-defined state. If the member variables are themselves a class, then it
    may not be necessary to specify how to initialize the variable. It the member
    variable is of a built-in type, then we will need to provide the initial values
    for them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，默认构造函数是一个特殊成员函数。它是许多可能构造函数中的一个，其中三个被视为特殊成员函数。构造函数可以声明零个、一个或多个参数，就像任何其他函数一样，但它们不指定返回类型。构造函数的特殊目的是将所有成员变量初始化，将对象置于一个明确定义的状态。如果成员变量本身是一个类，那么可能不需要指定如何初始化变量。如果成员变量是内置类型，那么我们需要为它们提供初始值。
- en: Class Special Member Functions
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类特殊成员函数
- en: 'When we define a new type (struct or class), the compiler will create up to
    six (6) special member functions for us:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个新类型（结构体或类）时，编译器会为我们创建多达六个（6）个特殊成员函数：
- en: '`Fraction::Fraction()`): This is called when no arguments are provided (such
    as in the preceding section). This can be achieved by either having no argument
    list for the constructor or by defining a default value for all the arguments,
    such as `Fraction(int numerator=0, denominator=1)`. The compiler provides an `implicit`
    `inline` default constructor that performs the default initialization of member
    variables – for built-in types, this means do nothing.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction::Fraction()`): 当没有提供参数时调用（例如在前面的部分中）。这可以通过构造函数没有参数列表或为所有参数定义默认值来实现，例如`Fraction(int
    numerator=0, denominator=1)`。编译器提供了一个`implicit` `inline`默认构造函数，执行成员变量的默认初始化 -
    对于内置类型，这意味着什么也不做。'
- en: '`Fraction::~Fraction()`): This is a special member function that is called
    when the object''s lifetime ends. Its purpose is to release any resources that
    were allocated and kept by the object during its lifetime. The compiler provides
    a `public` `inline` member function that calls the destructors of the member variables.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction::~Fraction()`): 这是一个特殊成员函数，当对象的生命周期结束时调用。它的目的是释放对象在其生命周期中分配和保留的任何资源。编译器提供了一个`public`
    `inline`成员函数，调用成员变量的析构函数。'
- en: '`Fraction::Fraction(const Fraction&)`): This is another constructor where the
    first parameter is a form of `Fraction&` and there are no other arguments, or
    the remainder of the arguments have default values. The form of the first argument
    is one of `Fraction&`, `const Fraction&`, `volatile Fraction&`, or `const volatile
    Fraction&`. We will deal with `const` later but not with `volatile` in this book.
    The compiler provides a `non-explicit` `public` `inline` member function, usually
    with the form of `Fraction::Fraction(const Fraction&)`, that copies each of the
    member variables in the order of initialization.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction::Fraction(const Fraction&)`): 这是另一个构造函数，其中第一个参数是`Fraction&`的形式，没有其他参数，或者其余参数具有默认值。第一个参数的形式是`Fraction&`、`const
    Fraction&`、`volatile Fraction&`或`const volatile Fraction&`。我们将在后面处理`const`，但在本书中不处理`volatile`。编译器提供了一个`non-explicit`
    `public` `inline`成员函数，通常形式为`Fraction::Fraction(const Fraction&)`，按初始化顺序复制每个成员变量。'
- en: '`Fraction& Fraction::operator=(Fraction&)`): This is a member function with
    the name `operator=` and the first argument is either a value or any of the reference
    types of the class, in this case, `Fraction`, `Fraction&`, `const Fraction&`,
    `volatile Fraction&`, or `const volatile Fraction&`. The compiler provides a `public`
    `inline` member function, usually with the form of `Fraction::Fraction(const Fraction&)`,
    that copies each of the member variables in the order of initialization.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction& Fraction::operator=(Fraction&)`): 这是一个成员函数，名称为`operator=`，第一个参数可以是值，也可以是类的任何引用类型，在这种情况下是`Fraction`、`Fraction&`、`const
    Fraction&`、`volatile Fraction&`或`const volatile Fraction&`。编译器提供了一个`public` `inline`成员函数，通常形式为`Fraction::Fraction(const
    Fraction&)`，按初始化顺序复制每个成员变量。'
- en: '`Fraction::Fraction(Fraction&&)`): This is a new type of constructor that was
    introduced in C++11 where the first parameter is a form of `Fraction&&` and there
    are no other arguments, or the remainder of the arguments have default values.
    The form of the first argument is one of `Fraction&&`, `const Fraction&&`, `volatile
    Fraction&&`, or `const volatile Fraction&&`. The compiler provides a `non-explicit`
    `public` `inline` member function, usually with the form of `Fraction::Fraction(Fraction&&)`,
    that moves each of the member variables in the order of initialization.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction::Fraction(Fraction&&)`): 这是C++11中引入的一种新类型的构造函数，第一个参数是`Fraction&&`的形式，没有其他参数，或者其余参数具有默认值。第一个参数的形式是`Fraction&&`、`const
    Fraction&&`、`volatile Fraction&&`或`const volatile Fraction&&`。编译器提供了一个`non-explicit`
    `public` `inline`成员函数，通常形式为`Fraction::Fraction(Fraction&&)`，按初始化顺序移动每个成员变量。'
- en: '`Fraction& Fraction::operator=(Fraction&&)`): This is a new type of assignment
    operator that was introduced in C++11 and is a member function with the name `operator=`,
    and the first argument is any of the forms that are allowed for the move constructor.
    The compiler provides a `public` `inline` member function, usually with the form
    of `Fraction::Fraction(Fraction&&)`, that copies each of the member variables
    in the order of initialization.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fraction& Fraction::operator=(Fraction&&)`): 这是C++11中引入的一种新类型的赋值运算符，是一个名为`operator=`的成员函数，第一个参数是允许移动构造函数的任何形式之一。编译器提供了一个`public`
    `inline`成员函数，通常采用`Fraction::Fraction(Fraction&&)`的形式，按初始化顺序复制每个成员变量。'
- en: Except for the default constructor, these functions deal with managing the resources
    owned by this class – that is, how to copy/move them and how to dispose of them.
    On the other hand, the default constructor is more like any other constructor
    that takes values – it only initializes the resources.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认构造函数外，这些函数处理了该类拥有的资源的管理-即如何复制/移动它们以及如何处理它们。另一方面，默认构造函数更像是接受值的任何其他构造函数-它只初始化资源。
- en: We can declare any of these special functions, force them to be defaulted (that
    is, have the compiler generate the default version), or force them to not be created.
    There are also rules about when these are automatically generated in the presence
    of the other special functions. The first four functions are relatively straightforward
    conceptually, but the two "move" special member functions take some additional
    explanation. We will deal with what is known as move semantics in detail in *Chapter
    3*, *The Distance Between Can and Should – Objects, Pointers, and Inheritance*,
    but for now it is essentially what it indicates – it moves something from one
    object to the other.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明任何这些特殊函数，强制它们被默认（即，让编译器生成默认版本），或者强制它们不被创建。关于这些特殊函数在其他特殊函数存在时何时自动生成也有一些规则。前四个函数在概念上相对直接，但是两个“移动”特殊成员函数需要额外的解释。我们将在第三章“可以和应该之间的距离-对象、指针和继承”中详细讨论移动语义，但现在它基本上就是它所指示的意思-将某物从一个对象移动到另一个对象。
- en: Implicit Versus Explicit Constructors
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式构造函数与显式构造函数
- en: 'The preceding description talks about the compiler generating implicit or non-explicit
    constructors. If a constructor exists that can be called with one argument, for
    example, a Copy Constructor, or a Move Constructor, by default, the compiler is
    allowed to invoke it if necessary so that it can convert it from one type to another
    type, allowing an expression, function call, or assignment to be encoded. This
    is not always a desired behavior, and we may wish to prevent the implicit conversion
    and ensure that if the user of our class really wants that conversion, then they
    have to write it out in the program. To achieve this, we prefix the declaration
    of the constructor with the `explicit` keyword, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述讨论了编译器生成隐式或非显式构造函数。如果存在可以用一个参数调用的构造函数，例如复制构造函数或移动构造函数，默认情况下，编译器可以在必要时调用它，以便将其从一种类型转换为另一种类型，从而允许对表达式、函数调用或赋值进行编码。这并不总是期望的行为，我们可能希望阻止隐式转换，并确保如果我们类的用户真的希望进行转换，那么他们必须在程序中写出来。为了实现这一点，我们可以在构造函数的声明前加上`explicit`关键字，如下所示：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The explicit keyword can be applied to other operators as well, where the compiler
    may use it for type conversion.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`explicit`关键字也可以应用于其他运算符，编译器可能会用它进行类型转换。'
- en: Class Special Member Functions – Compiler Generation Rules
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类特殊成员函数-编译器生成规则
- en: Firstly, the `Default Constructor` will not be generated if we declare any other
    form of constructor – default, copy, move, or user-defined. None of the other
    special member functions affect its generation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们声明了任何其他形式的构造函数-默认、复制、移动或用户定义的构造函数，就不会生成`Default Constructor`。其他特殊成员函数都不会影响它的生成。
- en: Secondly, a `Destructor` will not be generated if a destructor is declared.
    None of the other special member functions affect its generation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果声明了析构函数，则不会生成`Destructor`。其他特殊成员函数都不会影响它的生成。
- en: 'The generation of the other four special functions is dependent on the presence
    of the declaration of the destructor or one of the other special functions, as
    shown in the following table:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 其他四个特殊函数的生成取决于析构函数或其他特殊函数的声明的存在，如下表所示：
- en: '![](img/C14583_02A_34.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_02A_34.jpg)'
- en: 'Figure 2A.34: Special Member Function Generation Rules'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.34：特殊成员函数生成规则
- en: Defaulting and Deleting Special Member Functions
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认和删除特殊成员函数
- en: 'Prior to C++11, if we wanted to prevent the use of a copy constructor or copy
    assignment member function, then we had to declare the function as private and
    not provide a definition of the function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，如果我们想要阻止使用复制构造函数或复制赋值成员函数，那么我们必须将函数声明为私有，并且不提供函数的定义：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this manner, we ensured that if anyone tried to access the copy constructor
    or copy assignment from outside the class, then the compiler would generate an
    error stating that the function is not accessible. This still declares the functions,
    and they are accessible from within the class. It is an effective means, but not
    perfect, to remove these special member functions from use.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们确保如果有人试图从类外部访问复制构造函数或复制赋值，那么编译器将生成一个错误，说明该函数不可访问。这仍然声明了这些函数，并且它们可以从类内部访问。这是一种有效的方法，但并不完美，以防止使用这些特殊成员函数。
- en: But we can do better since C++11 introduced two new declaration forms that allow
    us to override the default behavior of the compiler, as defined in the preceding
    rules.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但是自C++11引入了两种新的声明形式，允许我们覆盖编译器的默认行为，如前述规则所定义。
- en: 'Firstly, we can force the compiler to not generate the method by declaring
    it with the `= delete` suffix, like so:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过使用`= delete`后缀来声明方法，强制编译器不生成该方法，如下所示：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We can omit the name of the parameter if it is not used. This is true for any
    function or member function. In fact, depending on the warning level that's been
    set for the compiler, it may even generate a warning that the argument is not
    being used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数没有被使用，我们可以省略参数的名称。对于任何函数或成员函数都是如此。实际上，根据编译器设置的警告级别，它甚至可能会生成一个警告，表明参数没有被使用。
- en: 'Alternatively, we can force the compiler to generate its default implementation
    of a special member function by using the `= default` suffix, like so:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用`= default`后缀来强制编译器生成特殊成员函数的默认实现，就像这样：
- en: '[PRE50]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If this is only the declaration of the function, then we can also omit the name
    of the argument. Although, good practice dictates that we should name the argument
    to indicate its use. That way, the users of our classes do not need to look at
    the implementation of calling the function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这只是函数的声明，那么我们也可以省略参数的名称。尽管如此，良好的实践规定我们应该命名参数以指示其用途。这样，我们类的用户就不需要查看调用函数的实现。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring a special member function using the default suffix is deemed to be
    a user-defined member function for the purpose of the aforementioned rules.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认后缀声明特殊成员函数被视为用户定义的成员函数，用于上述规则的目的。
- en: Rule of Three/Five and Rule of Zero
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三五法则和零法则
- en: As we discussed previously, with the exception of the default constructor, the
    special member functions deal with the semantics of managing the resources owned
    by this class – that is, how to copy/move them and how to dispose of them. This
    leads to two "rules" within the C++ community about dealing with the special functions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，除了默认构造函数之外，特殊成员函数处理了管理该类拥有的资源的语义 - 即如何复制/移动它们以及如何处理它们。这导致了C++社区内关于处理特殊函数的两个“规则”。
- en: Prior to C++11, there was the **Rule of Three**, which dealt with the copy constructor,
    copy assignment operator, and the destructor. It basically states that we need
    to implement one of these methods since the management of the encapsulated resource
    is non-trivial.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，有“三法则”，它涉及复制构造函数、复制赋值运算符和析构函数。基本上它表明我们需要实现其中一个方法，因为封装资源的管理是非平凡的。
- en: With the introduction of the move constructor and move assignment operator in
    C++11, this rule was expanded to the **Rule of Five**. No changes were made to
    the essence of the rule. Simply, the number of special member functions increased
    to five. Remembering the rules for compiler generation, there is an additional
    reason for ensuring all five special methods are implemented (or forced via =
    default), and that is, if the compiler does not have access to a move-semantic
    function, it will attempt to use a copy-semantic function, and this may not be
    what is desired.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++11中移动构造函数和移动赋值运算符的引入，这个规则扩展为“五法则”。规则的本质没有发生变化。简单地说，特殊成员函数的数量增加到了五个。记住编译器生成规则，确保所有五个特殊方法都被实现（或通过=
    default强制），这是一个额外的原因，如果编译器无法访问移动语义函数，它将尝试使用复制语义函数，这可能不是所期望的。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details, see the C.ctor: Constructors, assignments, and destructors
    section of the C++ Core Guidelines, which can be found here: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅C.ctor：C++核心指南中的构造函数、赋值和析构函数部分，网址为：[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)。
- en: Constructors – Initializing the Object
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数 - 初始化对象
- en: The main task of a constructor is to put the object into a stable state so that
    any operations performed on or by the object through its member functions result
    in a consistent defined behavior. While the previous statement is true of the
    copy and move constructors, they achieve this by different semantics (copying
    or moving from another object).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的主要任务是将对象置于稳定状态，以便通过其成员函数对对象执行的任何操作都会产生一致的定义行为。虽然前面的陈述对于复制和移动构造函数是正确的，但它们通过不同的语义（从另一个对象复制或移动）来实现这一点。
- en: There are four different mechanisms available for us to control the initial
    state of an object. C++ has a lot of rules for which initialization is used in
    such a case. We will not go into the details of the C++ standard's default initialization,
    zero initialization, value initialization, constant initialization, and so on.
    Just know that the best approach is to be explicit about the initialization of
    your variables.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四种不同的机制可以控制对象的初始状态。C++对于在这种情况下使用哪种初始化有很多规则。我们不会详细讨论C++标准的默认初始化、零初始化、值初始化、常量初始化等等。只需知道最好的方法是明确地初始化您的变量。
- en: 'The **first** and least preferred initialization mechanism is to assign values
    to the member variables in the body of the constructor, like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种，也是最不受欢迎的初始化机制是在构造函数的主体中为成员变量赋值，就像这样：
- en: '[PRE51]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It is clear what values are used to initialize the variables. Strictly speaking,
    this is not the initialization of the class – according to the standard, initialization
    is complete when the body of the constructor is called. This is simple to maintain,
    particularly in this class. For larger classes that have multiple constructors
    and many member variables, it can be a maintenance problem. If you change one
    constructor, you will need to change them all. It also has the problem that if
    the member variable is of a reference type (which we'll talk about later), then
    it cannot be done in the body of the constructor.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地知道了用于初始化变量的值。严格来说，这不是类的初始化 - 根据标准，当构造函数的主体被调用时，初始化才算完成。这在这个类中很容易维护。对于有多个构造函数和许多成员变量的较大类，这可能是一个维护问题。如果更改一个构造函数，您将需要更改它们所有。它还有一个问题，如果成员变量是引用类型（我们稍后会讨论），那么它就不能在构造函数的主体中完成。
- en: The default constructor uses the `this` pointer. Every member function, including
    constructors and destructors, are called with one implicit argument (even though
    it is never declared) – the `this` pointer. `this` points to the current instance
    of the object. The `->` operator is another dereference operator and is shorthand
    in this case, that is, `*(this).m_numerator`. The use of `this->` is optional
    and can be omitted. Other languages, such as Python, require the implicit pointer/reference
    to be declared and used (the convention in Python is to call *self*).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数使用`this`指针。每个成员函数，包括构造函数和析构函数，都带有一个隐式参数（即使它从未声明过）- `this`指针。`this`指向对象的当前实例。`->`操作符是另一个解引用操作符，在这种情况下是简写，即`*(this).m_numerator`。使用`this->`是可选的，可以省略。其他语言，如Python，要求声明和使用隐式指针/引用（Python中的约定是称为*self*）。
- en: 'The **second** mechanism is the use of a member initialization list, which
    has a caveat in its use. For our Fraction class, we have the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二**种机制是使用成员初始化列表，其在使用中有一个警告。对于我们的Fraction类，我们有以下内容：'
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The sections of code after the colon, :, and before the opening brace, {, in
    (`m_numerator(0), m_denominator(1)` and `m_numerator(numerator), m_denominator(denominator)`
    are the member initialization lists. We can initialize a reference type in the
    member initialization list.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号:后面和左花括号{前面的代码部分（`m_numerator(0), m_denominator(1)`和`m_numerator(numerator),
    m_denominator(denominator)`）是成员初始化列表。我们可以在成员初始化列表中初始化引用类型。
- en: Member Initialization List Order
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 成员初始化列表顺序
- en: Regardless of the order in which you place the members in the member initialization
    list, the compiler will initialize the members in the order that they are declared
    in the class.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在成员初始化列表中放置成员的顺序如何，编译器都将按照它们在类中声明的顺序初始化成员。
- en: 'The **third** and **recommended** initialization is the default member initialization
    that was introduced in C++11\. We define default initial values when the variable
    is declared either using assignment or the brace initializer:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三**种和**推荐**的初始化是C++11中引入的默认成员初始化。我们在变量声明时使用赋值或大括号初始化器定义默认初始值：'
- en: '[PRE53]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the constructor does not define the initial value of the member variable,
    then this default value will be used to initialize the variable. This has the
    advantage of ensuring that all the constructors produce the same initialization
    unless they have been explicitly modified in the definition of the constructor.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数没有定义成员变量的初始值，则将使用此默认值来初始化变量。这样做的好处是确保所有构造函数产生相同的初始化，除非它们在构造函数的定义中被明确修改。
- en: 'C++11 also introduced a fourth style of initialization, known as constructor
    delegation. It is a modification of the Member Initialization List where, instead
    of listing the member variables and their initial values, another constructor
    is called. The following example is contrived, and you would not write a class
    this way, but it shows the syntax for the constructor delegation:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: C++11还引入了第四种初始化样式，称为构造函数委托。它是成员初始化列表的修改，其中不是列出成员变量及其初始值，而是调用另一个构造函数。以下示例是人为的，您不会以这种方式编写类，但它显示了构造函数委托的语法：
- en: '[PRE54]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You call the single argument constructor from the constructor with two arguments.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您从具有两个参数的构造函数中调用单参数构造函数。
- en: 'Exercise 5: Declaring and Initializing Fractions'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：声明和初始化分数
- en: 'In this exercise, we will implement class member initialization using the different
    techniques available to us, including constructor delegation. Let''s get started:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用不同的技术实现类成员初始化，包括构造函数委托。让我们开始吧：
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise05**, and double-click on **Exercise5.cpp**
    to open the file for this exercise in the editor.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在**Project Explorer**中展开**Lesson2A**，然后展开**Exercise05**，双击**Exercise5.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise5** to run with the name Exercise5.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置…**。将**Exercise5**配置为以名称Exercise5运行。
- en: When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，它将成为当前选择的启动配置。
- en: Click on the **Run** button. **Exercise 5** will run and produce something similar
    to the following output:![](img/C14583_02A_35.jpg)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。**练习5**将运行并产生类似以下输出：![](img/C14583_02A_35.jpg)
- en: 'Figure 2A.35: Exercise 5 typical output'
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.35：练习5典型输出
- en: The values that were reported for the fraction come from not initializing the
    member variables in any way. If you run it again, you will most likely get a different
    fraction.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的分数值来自以任何方式初始化成员变量。如果再次运行，您很可能会得到不同的分数。
- en: Click on the **Run** button a few times. You will see that the fraction changes.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮几次。您会看到分数发生变化。
- en: 'In the editor, change the constructor to read as follows:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将构造函数更改为如下所示：
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Click on the **Run** button and observe the output:![](img/C14583_02A_36.jpg)
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮并观察输出：![](img/C14583_02A_36.jpg)
- en: 'Figure 2A.36: Modified Exercise 5 output'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.36：修改后的练习5输出
- en: This time, the fraction value is defined by the values we specified in the member
    initialization list.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，分数值由我们在成员初始化列表中指定的值定义。 '
- en: 'In the editor, add the following two `constructors`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，添加以下两个`构造函数`：
- en: '[PRE56]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the main function, change the declaration of `fraction` to include initialization:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，更改`fraction`的声明以包括初始化：
- en: '[PRE57]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Click on the **Run** button and observe the output:![](img/C14583_02A_37.jpg)
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮并观察输出：![](img/C14583_02A_37.jpg)
- en: 'Figure 2A.37: Example of constructor delegation'
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.37：构造函数委托示例
- en: In this exercise, we implemented member variable initialization using the member
    initialization list and constructor delegation. *We will return to fractions in
    Exercise 7, Adding Operators to the Fraction Class.*
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用成员初始化列表和构造函数委托实现了成员变量的初始化。*我们将在练习7中返回到分数，为分数类添加运算符。*
- en: Values Versus References and Const
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值与引用和常量
- en: So far, we have only dealt with value types, that is, the variable holds the
    value of the object. A pointer holds a value (which is the address of the object)
    that we are interested in (or nullptr). But this can lead to inefficiencies and
    problems with managing resources. We will talk about addressing the inefficiencies
    here but deal with the resource management problem in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了值类型，也就是变量保存了对象的值。指针保存了我们感兴趣的值（即对象的地址）（或nullptr）。但这可能导致效率低下和资源管理问题。我们将在这里讨论如何解决效率低下的问题，但在*第3章*，*可以和应该之间的距离-对象、指针和继承*中解决资源管理问题。
- en: 'Consider the following problem..We have a 10×10 matrix of double types that
    we wish to write an inversion function for. The class is declared as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题..我们有一个10×10的双精度矩阵，我们希望为其编写一个反转函数。该类声明如下：
- en: '[PRE58]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we were to take `sizeof(Matrix10x10)`, we would get `sizeof(double)` x 10
    x 10 = 800 bytes. Now, if we were to implement an inversion matrix function for
    this, its signature might look like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要取`sizeof(Matrix10x10)`，我们会得到`sizeof(double)` x 10 x 10 = 800字节。现在，如果我们要为此实现一个矩阵反转函数，其签名可能如下所示：
- en: '[PRE59]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Firstly, this means that the compiler would need to pass the value held by
    `mat` to the `invert()` function and copy the 800 bytes onto the stack. The function
    then does whatever it needs to do to invert the matrix (an L-U decomposition,
    calculation of the determinant – whatever approach the implementer chooses) and
    then copy the 800-byte result back to the `inv` variable. Passing large values
    on the stack is never a good idea, for two reasons:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这意味着编译器需要将`mat`持有的值传递给`invert()`函数，并将800字节复制到堆栈上。然后函数执行其需要执行的操作来反转矩阵（L-U分解、计算行列式-无论实现者选择的方法是什么），然后将800字节的结果复制回`inv`变量。在堆栈上传递大量值从来都不是一个好主意，原因有两个：
- en: The stack is a finite resource that's given to our program by the host operating
    system.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈是主机操作系统给我们程序的有限资源。
- en: Copying large values around the system is inefficient.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统中复制大量值是低效的。
- en: This approach is known as pass-by-value. That is, the value of an item we wish
    to process is copied to the function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为按值传递。也就是说，我们希望处理的项目的值被复制到函数中。
- en: 'In C (and C++), this limitation is addressed by the use of pointers. The preceding
    code may become the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在C（和C++）中，通过使用指针来解决这个限制。上面的代码可能变成下面这样：
- en: '[PRE60]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we just pass the address of the src and target for the inverse result
    as two pointers (which is a small number of bytes). Unfortunately, this results
    in code inside the function that has to use the dereference operator (`*`) every
    time we use `src` or `inv`, making the code more difficult to read. In addition,
    the use of pointers has led to many problems.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是传递了src和target的地址作为两个指针的逆结果（这是少量字节）。不幸的是，这导致函数内部的代码在每次使用`src`或`inv`时都必须使用解引用操作符（`*`），使得代码更难阅读。此外，指针的使用导致了许多问题。
- en: 'C++ introduced a better approach – the variable alias or reference. A reference
    type is declared with the ampersand (`&`) operator. So, we can declare the invert
    method as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: C++引入了一个更好的方法-变量别名或引用。引用类型是用和号（`&`）操作符声明的。因此，我们可以将invert方法声明如下：
- en: '[PRE61]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that calling the method requires no special operator to pass the reference.
    From the compiler's viewpoint, a reference is still a pointer with one limitation
    – it cannot hold a nullptr. From the programmer's viewpoint, a reference allows
    us to reason about our code without having to worry about having the right dereference
    operator in the right place. This is known as **pass-by-reference**.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用该方法不需要特殊的操作符来传递引用。从编译器的角度来看，引用仍然是一个带有一个限制的指针-它不能保存nullptr。从程序员的角度来看，引用允许我们在不必担心在正确的位置使用解引用操作符的情况下推理我们的代码。这被称为**按引用传递**。
- en: We saw references being passed to the copy constructor and the copy assignment
    method. The types of references, when used for their move equivalents, are known
    as **rvalue reference operators** and will be explained in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到引用被传递给了复制构造函数和复制赋值方法。当用于它们的移动等价物时，引用的类型被称为**右值引用运算符**，将在*第3章*，*可以和应该之间的距离-对象、指针和继承*中解释。
- en: 'One advantage of `pass-by-value` was that we cannot inadvertently modify the
    value of the variable that''s passed into a method. Now, if we pass-by-reference,
    we can no longer guarantee that the method we are calling will not modify the
    original variable. To address this, we can change the signature of the invert
    method to read as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`按值传递`的一个优点是我们不能无意中修改传递给方法的变量的值。现在，如果我们`按引用传递`，我们就不能再保证我们调用的方法不会修改原始变量。为了解决这个问题，我们可以将invert方法的签名更改为如下所示：'
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The const keyword tells the compiler that, when it is processing the definition
    of the `invert()` function, it is illegal to assign a new value to any part of
    the value referenced by `src`. If the method does attempt to modify src, the compiler
    will generate an error.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: const关键字告诉编译器，在处理`invert()`函数的定义时，将值引用到`src`的任何部分都是非法的。如果该方法尝试修改src，编译器将生成一个错误。
- en: In the Specifying Types – Variables section, we found that the declaration of
    `auto title` resulted in `title` being of the `const char *` type. Now, we can
    explain the `const` part.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定类型-变量部分，我们发现`auto title`的声明导致`title`是`const char *`类型。现在，我们可以解释`const`部分了。
- en: 'The `title` variable is **a pointer to a char that is constant**. In other
    words, we cannot change the value of the data stored in the memory that we are
    pointing to. Therefore, we cannot do the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`变量是**指向常量字符的指针**。换句话说，我们不能改变指向的内存中存储的数据的值。因此，我们不能执行以下操作：'
- en: '[PRE63]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is because the compiler will generate an error related to changing a constant
    value. We can, however, change the value stored in the pointer. We are allowed
    to do the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器将生成与更改常量值相关的错误。然而，我们可以改变指针中存储的值。我们可以执行以下操作：
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We have now been introduced to references for use as argument types to functions,
    but they can also be used as member variables instead of pointers. There are differences
    between references and pointers:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了引用作为函数参数类型的用法，但它们也可以用作成员变量而不是指针。引用和指针之间有区别：
- en: A reference must refer to an actual object (no equivalent of nullptr). A reference
    cannot be changed once it has been initialized (this has the consequence that
    a reference must either be default member initialized or appear in the member
    initialization list).The object must exist for as long as the reference to it
    exists (if the object can be destroyed before the reference is destroyed, then
    there is the potential for undefined behavior if an attempt is made to access
    the object).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 引用必须引用实际对象（没有nullptr的等价物）。一旦初始化，引用就不能被改变（这意味着引用必须要么是默认成员初始化的，要么出现在成员初始化列表中）。对象必须存在，只要对它的引用存在（如果对象可以在引用被销毁之前被销毁，那么如果尝试访问对象就有潜在的未定义行为）。
- en: 'Exercise 6: Declaring and Using Reference Types'
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：声明和使用引用类型
- en: 'In this exercise, we will declare and use reference types to make the code
    efficient and easier to read. Let''s get started:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将声明和使用引用类型，以使代码更高效、更易读。让我们开始吧：
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise06**, and double-click on **Exercise6.cpp**
    to open the file for this exercise in the editor.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在**Project Explorer**中展开**Lesson2A**，然后展开**Exercise06**，双击**Exercise6.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise6** to run with the name Exercise6.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。配置**Exercise6**以使用名称Exercise6运行。
- en: When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，它将成为当前选择的启动配置。
- en: Click on the `rvalue` variable allows us to manipulate (read from and write
    to) the data stored in the `value` variable. We have a reference, `rvalue`, to
    the `value` variable. We can also see that the values stored in the `a` and `b`
    variables were exchanged by the `swap()` function.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`rvalue`变量允许我们操纵（读取和写入）存储在`value`变量中的数据。我们有一个对`value`变量的引用`rvalue`。我们还可以看到`swap()`函数交换了`a`和`b`变量中存储的值。
- en: 'In the editor, change the function definition of swap:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改swap函数的函数定义：
- en: '[PRE65]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**. The first error that''s reported by the compiler is shown here:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Run**按钮。当出现工作区中的错误对话框时，点击**Cancel**。编译器报告的第一个错误如下所示：
- en: '![Figure 2A.39: Read-only error on assignment](img/C14583_02A_39.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.39：赋值时的只读错误](img/C14583_02A_39.jpg)'
- en: 'Figure 2A.39: Read-only error on assignment'
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.39：赋值时的只读错误
- en: By changing the arguments from `int& lhs` to `const int& lhs`, we've told the
    compiler that the arguments should not be changed inside this function. And because
    we assign to lhs in the function, the compiler generates the error about lhs being
    read-only and terminates.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将参数从`int& lhs`更改为`const int& lhs`，我们告诉编译器在此函数内部参数不应该被改变。因为我们在函数中对lhs进行了赋值，所以编译器生成了关于lhs为只读的错误并终止了程序。
- en: Implementing Standard Operators
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现标准运算符
- en: 'To use fractions like a built-in class, we need them to work with the standard
    mathematical operators (`+, -, *, /`) and their assignment counterparts (`+=,
    -=, *=, /=`). If you are unfamiliar with assignment operators, then consider the
    following two expressions – they produce the same output:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 要像内置类一样使用分数，我们需要使它们能够使用标准数学运算符（`+，-，*，/`）及其赋值对应物（`+=，-=，*=，/=`）。如果您不熟悉赋值运算符，请考虑以下两个表达式
    - 它们产生相同的输出：
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The syntax for declaring these two operators for Fraction is as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为Fraction声明这两个运算符的语法如下：
- en: '[PRE67]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Because the `operator+=` method modifies the contents of the left-hand variable
    (adds a to b and then stores it again in a), it is recommended that it is implemented
    as a member variable. In this case, as we have not created a new value, we can
    just return a reference to the existing lhs.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`operator+=`方法修改了左侧变量的内容（将a添加到b然后再次存储在a中），建议将其实现为成员变量。在这种情况下，由于我们没有创建新值，我们可以直接返回对现有lhs的引用。
- en: The operator+ method, on the other hand, should not modify lhs nor rhs and return
    a new object. The implementer is free to implement it as a member function or
    as a free function. Both are shown in the preceding code, but only one should
    exist. The interesting thing to note about the member function's implementation
    is the const keyword at the end of the declaration. This tells the compiler that
    when this member function is called, it will not modify the internal state of
    the object. While both approaches are valid, if possible, `operator+` should be
    implemented as a normal function, outside of the class.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`operator+`方法不应修改lhs或rhs并返回一个新对象。实现者可以自由地将其实现为成员函数或自由函数。在前面的代码中都展示了这两种方法，但只应存在一种。关于成员函数实现的有趣之处在于声明末尾的const关键字。这告诉编译器，当调用这个成员函数时，它不会修改对象的内部状态。虽然这两种方法都是有效的，但如果可能的话，`operator+`应该作为一个普通函数实现，而不是类的一部分。
- en: The same approach can be used for the other operators `– (subtract)`, `* (multiply)`,
    and `/ (divide)`. The preceding methods implement the semantics for the standard
    mathematical operators and make our type act like the built-in types.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法也可以用于其他运算符`-（减法）`，`*（乘法）`和`/（除法）`。前面的方法实现了标准数学运算符的语义，并使我们的类型像内置类型一样工作。
- en: Implementing the Output Stream Operator (<<)
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现输出流操作符（<<）
- en: 'C++ abstracts Input/Output (I/O) into the stream class hierarchy in the standard
    library (which we will talk about in *Chapter 2B*, *No Ducks Allowed – Templates
    and Deduction*). In *Exercise 5*, *Declaring and Initializing Fractions*, we saw
    that we could insert the fraction into an output stream as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: C++将输入/输出（I/O）抽象为标准库中的流类层次结构（我们将在*第2B章*，*不允许鸭子 - 模板和推断*中讨论）。在*练习5*，*声明和初始化分数*中，我们看到我们可以将分数插入到输出流中，如下所示：
- en: '[PRE68]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So far, for our Fraction class, we have written out the numerator and denominator
    values by accessing the data values from outside using the `getNumerator()` and
    `getDenominator()` methods, but there is a better way to do this. As part of making
    our classes first-class citizens in C++, where it makes sense, we should overload
    the I/O operators. In this chapter, we will only look at the output operator,
    <<, also known as the insertion operator. That way, we can replace the previous
    code with a much cleaner version:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于我们的分数类，我们已经通过使用`getNumerator()`和`getDenominator()`方法从外部访问数据值来写出了分子和分母的值，但有更好的方法。作为使我们的类在C++中成为一等公民的一部分，在合适的情况下，我们应该重载I/O运算符。在本章中，我们只会看输出运算符<<，也称为插入运算符。这样，我们可以用更清晰的版本替换以前的代码：
- en: '[PRE69]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can overload the operator as either a friend function or a normal function
    (if the class provides getter functions of the data that we need to insert). For
    our purpose, we define it as a normal function:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将运算符重载为友元函数或普通函数（如果类提供我们需要插入的数据的getter函数）。对于我们的目的，我们将其定义为普通函数：
- en: '[PRE70]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Structuring Our Code
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的代码结构
- en: Before we delve into the exercise where we implement the operators and turn
    our Fraction into a full-blown type in the C++ world, we need to have a brief
    discussion about where we put the bits and pieces of our class – the declaration
    and the definition. The declaration is the blueprint for our class that indicates
    what data storage it requires and the methods that it will implement. The definition
    is the actual implementation details of each of the methods.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入练习之前，我们需要讨论一下我们的类的各个部分放在哪里 - 声明和定义。声明是我们的类的蓝图，指示它需要什么数据存储和将实现的方法。定义是每个方法的实际实现细节。
- en: In languages such as Java and C#, the declaration and the definition are one
    and the same and they must exist in one file (Java) or across multiple files (C#
    partial classes). In C++, depending on the class and how much you wish to expose
    to other classes, the declaration MUST appear in a header file (which can be `#included`
    in other files for use) and the definition can appear in one of three places –
    inline in the definition, `inline` in the same file as the definition, or in a
    separate implementation file.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和C#等语言中，声明和定义是一样的，它们必须存在于一个文件（Java）或跨多个文件（C#部分类）中。在C++中，取决于类和您希望向其他类公开多少，声明必须出现在头文件中（可以在其他文件中`#include`使用），定义可以出现在三个地方之一
    - 内联在定义中，在相同文件中的`inline`定义，或在单独的实现文件中。
- en: The header file is usually named with the .hpp extension, while the implementation
    file is typically one of `*.cpp` or `*.cxx`. The implementation file is also known
    as a **translation unit**. By defining a function as inline, we allow the compiler
    to optimize the code in a way that the function may not even exist in the final
    program – it has substituted the steps we put into the function into the locations
    that we call the function from.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件通常以.hpp扩展名命名，而实现文件通常是`*.cpp`或`*.cxx`之一。实现文件也称为**翻译单元**。通过将函数定义为内联，我们允许编译器以函数可能甚至不存在于最终程序中的方式优化代码
    - 它已经将我们放入函数中的步骤替换为我们从中调用函数的位置。
- en: 'Exercise 7: Adding Operators to the Fraction Class'
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：为分数类添加运算符
- en: 'In this exercise, we aim to implement operators in our Fraction class using
    unit tests to develop the functionality. This makes our Fraction class a real
    type. Let''s get started:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是使用单元测试在我们的分数类中实现运算符功能。这使我们的分数类成为一个真正的类型。让我们开始吧：
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise07**, and double-click on **Exercise7.cpp**
    to open the file for this exercise in the editor.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2A**项目，然后在**项目资源管理器**中展开**Lesson2A**，然后**Exercise07**，双击**Exercise7.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure Exercise7 to run with the name Exercise7.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置…**。配置Exercise7以使用名称Exercise7运行。
- en: When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，它将成为当前选择的启动配置。
- en: We also need to configure a unit test. In Eclipse, click on the menu item called
    **Run** | **Run Configurations…**, right-click **C/C++ Unit** on the left-hand
    side, and select **New Configuration**.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要配置一个单元测试。在Eclipse中，单击名为**运行** | **运行配置…**的菜单项，在左侧右键单击**C/C++单元**，然后选择**新配置**。
- en: Change the name from `Lesson2A Debug` to `Exercise7 Tests`.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称从`Lesson2A Debug`更改为`Exercise7 Tests`。
- en: Under **C/C++ Application**, select the **Search Project** option and choose
    **tests** in the new dialog.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**C/C++应用程序**下，选择**搜索项目**选项，并在新对话框中选择**tests**。
- en: 'Next, go to the **C/C++ Testing** tab and select **Google Tests Runner** in
    the dropdown. Click on **Apply** at the bottom of the dialog and click on the
    **Run** option for the test, which we have to run for the first time:![Figure
    2A.40: Failing tests – multiplication](img/C14583_02A_40.jpg)'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**C/C++测试**选项卡，并在下拉菜单中选择**Google测试运行器**。点击对话框底部的**应用**，然后点击我们第一次运行的测试选项：![图2A.40：失败的测试
    - 乘法](img/C14583_02A_40.jpg)
- en: 'Figure 2A.40: Failing tests – multiplication'
  id: totrans-443
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.40：失败的测试 - 乘法
- en: 'Open the `operator*=` function. Update it with the following code:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`operator*=`函数。更新它的代码如下：
- en: '[PRE71]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Click on the **Run** button to rerun the tests. This time, all the tests pass:![Figure
    2A.41: Passing tests](img/C14583_02A_41.jpg)'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新运行测试。这次，所有的测试都通过了：![图2A.41：通过测试](img/C14583_02A_41.jpg)
- en: 'Figure 2A.41: Passing tests'
  id: totrans-447
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.41：通过测试
- en: In your IDE, open the `operator*=()`, while the other tested `operator*()`.
    How did fixing `operator*=()` fix `operator*()`? If you open Fraction.hpp in the
    editor, you will find that the `operator*()` function was implemented for you
    by making a call to `operator*=()`, that is, it is marked inline and is a normal
    function and not a member function. In general, this is the approach to take when
    overloading these operators – the one that modifies the object that is calling
    it is a member function, whereas the one that has to generate a new value is a
    normal function that calls the member function.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中打开`operator*=()`，同时测试其他的`operator*()`。修复`operator*=()`如何修复`operator*()`？如果在编辑器中打开Fraction.hpp，你会发现`operator*()`函数是通过调用`operator*=()`来实现的，也就是说，它被标记为内联函数，是一个普通函数而不是成员函数。一般来说，当重载这些运算符时，修改调用它的对象的函数是成员函数，而生成新值的函数是调用成员函数的普通函数。
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file so that it reads like so:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并将文件顶部的行更改为以下内容：
- en: '[PRE72]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Click on the `AddFractions` and `AddFractions2`:![Figure 2A.42: Additional
    tests to fail](img/C14583_02A_42.jpg)'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**AddFractions**和**AddFractions2**：![图2A.42：额外的失败测试](img/C14583_02A_42.jpg)
- en: 'Figure 2A.42: Additional tests to fail'
  id: totrans-452
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.42：额外的失败测试
- en: Locate the `operator+=` function in the **Function.cpp** file.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Function.cpp**文件中找到`operator+=`函数。
- en: Make the necessary changes to the function and click on the `operator*=()` was
    implemented.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对函数进行必要的更改，然后点击实现`operator*=()`。
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并将文件顶部的行更改为以下内容：
- en: '[PRE73]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Click on the `SubtractFractions` and `SubtractFractions2`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**SubtractFractions**和**SubtractFractions2**。
- en: Locate the `operator-=` function in the Function.cpp file.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Function.cpp文件中找到`operator-=`函数。
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对函数进行必要的更改，然后点击**运行**按钮，直到测试通过。
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并将文件顶部的行更改为以下内容：
- en: '[PRE74]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Click on the **Run** button to rerun the tests – this time, we have added two
    more tests that fail – **DivideFractions** and **DivideFractions2**.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新运行测试 - 这次，我们添加了两个失败的测试 - **DivideFractions**和**DivideFractions2**。
- en: Locate the `operator/=` function in the **Function.cpp** file.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Function.cpp**文件中找到`operator/=`函数。
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对函数进行必要的更改，然后点击**运行**按钮，直到测试通过。
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**Fraction.hpp**，并将文件顶部的行更改为以下内容：
- en: '[PRE75]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Click on the `InsertOperator`.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**插入运算符**。
- en: Locate the `operator<<` function in the Function.hpp file.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Function.hpp文件中找到`operator<<`函数。
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对函数进行必要的更改，然后点击**运行**按钮，直到测试通过。
- en: 'From the **Launch Configuration**, select **Exercise7** and click on the **Run**
    button. This will produce the following output:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**启动配置**中选择**Exercise7**，然后点击**运行**按钮。这将产生以下输出：
- en: '![Figure 2A.43: Functional Fraction class](img/C14583_02A_43.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.43：功能性分数类](img/C14583_02A_43.jpg)'
- en: 'Figure 2A.43: Functional Fraction class'
  id: totrans-472
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.43：功能性分数类
- en: This completes our implementation of the `Fraction` class for now. We will return
    to it again when we consider exceptions in *Chapter 3*, *The Distance Between
    Can and Should – Objects, Pointers, and Inheritance*, so that we can deal with
    illegal values in our fractions (denominators of 0).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`Fraction`类的实现。当我们考虑*第3章*中的异常时，我们将再次返回它，*可以和应该之间的距离 - 对象、指针和继承*，这样我们就可以处理分数中的非法值（分母为0）。
- en: Function Overloading
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'C++ supports a feature known as function overloading, which is where two or
    more functions have the same name, but their argument list is different. The number
    of arguments can be the same, but at least one of the argument types has to be
    different. Alternatively, they may have a different number of arguments. So, the
    function prototype for the multiple functions are different. However, two functions
    cannot have the same function name, the same argument types, and a different return
    type. The following is an example of overloading:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持一种称为函数重载的特性，即两个或多个函数具有相同的名称，但它们的参数列表不同。参数的数量可以相同，但至少一个参数类型必须不同。或者，它们可以具有不同数量的参数。因此，多个函数的函数原型是不同的。但是，两个函数不能具有相同的函数名称、相同的参数类型和不同的返回类型。以下是一个重载的示例：
- en: '[PRE76]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So far, the multiple constructors on `Fraction` and the overloaded arithmetic
    operators are all examples of overloaded functions that the compiler has to refer
    to when it meets one of these functions. Consider the following code:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`Fraction`上的多个构造函数和重载的算术运算符都是编译器在遇到这些函数时必须引用的重载函数的示例。考虑以下代码：
- en: '[PRE77]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When the compiler meets the line `print(42)`, it needs to work out which of
    the previously defined functions to call, so it performs the following process
    (grossly simplified):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到`print(42)`这一行时，它需要确定调用先前定义的函数中的哪一个，因此执行以下过程（大大简化）：
- en: '![Figure 2A.44: Function overload resolution (simplified)](img/C14583_02A_44.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.44：函数重载解析（简化）](img/C14583_02A_44.jpg)'
- en: 'Figure 2A.44: Function overload resolution (simplified)'
  id: totrans-481
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.44：函数重载解析（简化）
- en: The C++ standard defines rules for how the compiler determines the best candidate
    function based on how it has to manipulate (that is, convert) the arguments to
    get a match. If no conversions are required, then that function is the best match.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准定义了编译器根据如何操作（即转换）参数来确定最佳候选函数的规则。如果不需要转换，则该函数是最佳匹配。
- en: Classes, Structs, and Unions
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类，结构体和联合
- en: 'When you define a class and do not specify an access modifier (public, protected,
    private), all the members will be private by default:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个类并且不指定访问修饰符（public，protected，private）时，默认情况下所有成员都将是private的：
- en: '[PRE78]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When you define a struct and do not specify an access modifier (public, protected,
    private), all the members will be public by default:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个结构体并且不指定访问修饰符（public，protected，private）时，默认情况下所有成员都将是public的：
- en: '[PRE79]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'There is one other difference, which we will look at after we explain inheritance
    and polymorphism. A union is a different type of data construct from a struct
    and a class but is the same. A union is a special type of struct declaration where
    all the members occupy the same memory and only one member is valid at a given
    time. An example of a `union` declaration is as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个区别，我们将在解释继承和多态性之后进行讨论。联合是一种与结构体和类不同但又相同的数据构造类型。联合是一种特殊类型的结构声明，其中所有成员占用相同的内存，并且在给定时间只有一个成员是有效的。`union`声明的一个示例如下：
- en: '[PRE80]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When you define a union and do not specify an access modifier (public, protected,
    private), all the members will be public by default.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个联合并且不指定访问修饰符（public，protected，private）时，默认情况下所有成员都将是public的。
- en: The main problem with a union is that there is no intrinsic way to know which
    of the values is valid at any given time. This is resolved by defining what is
    known as a *tagged union* – that is, a struct that holds the union and an enum
    that identifies whether it is the valid value. There are also other restrictions
    on what can and cannot be included in a union (for example, only one member can
    have a default member initializer). We will not be exploring unions in depth in
    this book.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 联合的主要问题是没有内在的方法来知道在任何给定时间哪个值是有效的。这通过定义所谓的*标记联合*来解决 - 即一个包含联合和一个枚举的结构，用于标识它是有效值。联合还有其他限制（例如，只有一个成员可以有默认成员初始化程序）。我们不会在本书中深入探讨联合。
- en: 'Activity 1: Graphics Processing'
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：图形处理
- en: 'In a modern computing environment, matrices are used everywhere to solve various
    problems – to solve simultaneous equations, to analyze electricity power grids
    or electric circuits, to perform manipulations on objects for graphics rendering,
    and to deliver implementations of machine learning. In the world of graphics,
    whether two-dimensional (2D) or three-dimensional (3D), all the operations that
    you would want to perform on your objects can be done with the help of matrix
    multiplication. Your team has been tasked with developing a representation of
    points, transformation matrices, and the operations that you might want to perform
    on them. Follow these steps to achieve this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算环境中，矩阵被广泛用于解决各种问题 - 解决同时方程，分析电力网格或电路，对图形渲染对象进行操作，并提供机器学习的实现。在图形世界中，无论是二维（2D）还是三维（3D），您希望对对象执行的所有操作都可以通过矩阵乘法来完成。您的团队被要求开发点，变换矩阵的表示以及您可能希望对它们执行的操作。按照以下步骤来实现这一点：
- en: Load the prepared project from the **Lesson2A/Activity01** folder.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson2A/Activity01**文件夹加载准备好的项目。
- en: Create a class called **Point3d** that can be constructed by default to be the
    origin, or using an initializer list of three or four values (data is stored directly
    in the class).
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Point3d**的类，可以默认构造为原点，或使用三个或四个值的初始化列表（数据直接存储在类中）来构造。
- en: Create a class called **Matrix3d** that can be constructed by default to an
    identity matrix, or using a nested initializer list to provide all the values
    (data is stored directly in the class).
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Matrix3d**的类，可以默认构造为单位矩阵，或使用嵌套初始化列表来提供所有值（数据直接存储在类中）来构造。
- en: On `operator()` so that it takes the (`index`) argument in order to return the
    value at `x(0)`, `y(1)`, `z(2)`, and `w(3)`.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`operator()`上，以便它接受（`index`）参数以返回`x(0)`，`y(1)`，`z(2)`和`w(3)`处的值。
- en: On `operator()` to take (`row, col`) arguments so that it returns the value.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`operator()`上接受（`row, col`）参数，以便返回该值。
- en: Add the unit tests to verify all of the aforementioned features.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加单元测试以验证所有上述功能。
- en: Add `operator*=(const Matrix3d&)` and `operator==(const Matrix3d&)` to the **Matrix3d**
    class, as well as the unit tests for them.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Matrix3d**类中添加`operator*=(const Matrix3d&)`和`operator==(const Matrix3d&)`，以及它们的单元测试。
- en: Add free functions for multiplying two **Matrix3d** objects and a **Matrix3d**
    object by a **Point3d** object with unit tests.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于将两个**Matrix3d**对象相乘以及将**Matrix3d**对象乘以**Point3d**对象的自由函数，并进行单元测试。
- en: Add standalone methods for creating a matrix to translate, scale, and rotate
    (around the x, y, z axes) and their unit tests.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于创建平移，缩放和旋转矩阵（围绕x，y，z轴）及其单元测试的独立方法。
- en: 'After implementing the preceding steps, the expected output is as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上述步骤之后，预期输出如下：
- en: '![](img/C14583_02A_45.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_02A_45.jpg)'
- en: 'Figure 2A.45: Successfully running the activity program'
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.45：成功运行活动程序
- en: For the purpose of this activity, we will not be worrying about the possibility
    of out of range on indices. We will talk about this in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*. An identity matrix
    is a square matrix (4 x 4, in our case) where all the values on the diagonal are
    set to one (1) and all the other values are zero (0).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次活动中，我们不会担心索引超出范围的可能性。我们将在*第3章*“能与应该之间的距离-对象、指针和继承”中讨论这个问题。单位矩阵是一个方阵（在我们的例子中是4x4），对角线上的所有值都设置为1，其他值都为0。
- en: When working with 3D graphics, we use an augmented matrix for the points (vertices)
    and for the transformations so that all the transformations (translation, scaling,
    rotation) can be achieved by using multiplication.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理3D图形时，我们使用增广矩阵来表示点（顶点）和变换，以便所有的变换（平移、缩放、旋转）都可以通过乘法来实现。
- en: 'An `n × m` matrix is an array of n rows of m numbers. For example, a `2 x 3`
    matrix could look like this:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`n × m`矩阵是一个包含n行m个数字的数组。例如，一个`2 x 3`矩阵可能如下所示：
- en: '![Figure 2A.46: Matrix of 2x3](img/C14583_02A_46.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.46：2x3矩阵](img/C14583_02A_46.jpg)'
- en: 'Figure 2A.46: Matrix of 2x3'
  id: totrans-510
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.46：2x3矩阵
- en: 'A vertex in three dimensions can be represented as a `three-tuple (x,y,z)`.
    However, we augment it with another ordinate, `w (=1 for a vertex, =0 for a direction)`,
    making it a `four-tuple (x, y, z, 1)`. Rather than using a tuple, we place it
    in a `4 x 1` matrix, as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 三维空间中的顶点可以表示为一个三元组（x，y，z）。然而，我们用另一个坐标`w（对于顶点为1，对于方向为0）`来增强它，使其成为一个四元组（x，y，z，1）。我们不使用元组，而是将其放在一个`4
    x 1`矩阵中，如下所示：
- en: '![Figure 2A.47: 4x1 Matrix](img/C14583_02A_47.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.47：4x1矩阵](img/C14583_02A_47.jpg)'
- en: 'Figure 2A.47: 4x1 Matrix'
  id: totrans-513
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.47：4x1矩阵
- en: 'If we multiply the `4 x 1` matrix (point) by a `4 x 4` matrix (transformation),
    we can manipulate the point. If `Ti` represents a transformation, then we can
    multiply the transformations together to achieve some manipulation of the point:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`4 x 1`矩阵（点）乘以`4 x 4`矩阵（变换），我们可以操纵这个点。如果`Ti`表示一个变换，那么我们可以将变换相乘，以实现对点的某种操纵。
- en: '![Figure 2A.48: Multiplying transformations](img/C14583_02A_48.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.48：乘法变换](img/C14583_02A_48.jpg)'
- en: 'Figure 2A.48: Multiplying transformations'
  id: totrans-516
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.48：乘法变换
- en: 'To multiply a transformation matrix, `A x P = B`, we do the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个转换矩阵相乘，`A x P = B`，我们需要做以下操作：
- en: '![Figure 2A.49: Multiplying transformation matrix](img/C14583_02A_49.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.49：乘法变换矩阵](img/C14583_02A_49.jpg)'
- en: 'Figure 2A.49: Multiplying transformation matrix'
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.49：乘法变换矩阵
- en: 'We can also express it like so:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样表达：
- en: '![Figure 2A.50: Expression of multiplying transformations](img/C14583_02A_50.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.50：乘法变换表达式](img/C14583_02A_50.jpg)'
- en: 'Figure 2A.50: Expression of multiplying transformations'
  id: totrans-522
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.50：乘法变换表达式
- en: 'Likewise, the same can be done for two `4 x 4` matrices, multiplied together,
    `AxB=C`:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，两个`4 x 4`矩阵也可以相乘，`AxB=C`：
- en: '![Figure 2A.51 Expression of 4x4 matrix multiplication:](img/C14583_02A_51.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.51：4x4矩阵乘法表达式：](img/C14583_02A_51.jpg)'
- en: 'Figure 2A.51 Expression of 4x4 matrix multiplication:'
  id: totrans-525
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.51：4x4矩阵乘法表达式：
- en: 'The matrices for the transformations are as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 变换的矩阵如下：
- en: '![Figure 2A.52: List of matrices for transformation](img/C14583_02A_52.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![图2A.52：变换矩阵列表](img/C14583_02A_52.jpg)'
- en: 'Figure 2A.52: List of matrices for transformation'
  id: totrans-528
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.52：变换矩阵列表
- en: Note
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 635.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 本次活动的解决方案可以在第635页找到。
- en: Summary
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about types in C++. Firstly, we touched on the built-in
    types and then learned how to create our own types that behave like the built-in
    types. We learned how to declare and initialize variables, got a glimpse of what
    the compiler generates from the source, where it puts variables, how the linker
    puts it together, and then what that looks like in the computer's memory. We learned
    some of the C++ tribal wisdom around the Rule of Zero and the Rule of Five. These
    form the building blocks of C++. In the next chapter, we will look at creating
    functions and classes with C++ templates and explore further type deduction as
    it applies to templates.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C++中的类型。首先，我们介绍了内置类型，然后学习了如何创建行为类似于内置类型的自定义类型。我们学习了如何声明和初始化变量，了解了编译器从源代码生成的内容，变量的存储位置，链接器如何将其组合，以及在计算机内存中的样子。我们学习了一些关于C++的部落智慧，比如零规则和五规则。这些构成了C++的基本组成部分。在下一章中，我们将学习如何使用C++模板创建函数和类，并探索模板类型推导的更多内容。
