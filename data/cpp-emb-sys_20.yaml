- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Designing Scalable Finite State Machines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可扩展的有限状态机
- en: A **Finite State Machine** (`FSM`) is an abstract computational module used
    to represent a system that can be in exactly one of a finite number of states
    at any given time. An `FSM` can transition from one state to another on a given
    input, and it can perform an action during the transition.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限状态机**（`FSM`）是一个抽象的计算模块，用于表示在任何给定时间可以处于有限多个状态之一的状态系统。`FSM`可以在给定输入的情况下从一个状态转换到另一个状态，并且在转换过程中可以执行一个动作。'
- en: In control theory, there is a classification of Moore and Mealy machines. Moore’s
    `FSM` output depends only on a state, that is, the `FSM` uses only entry actions.
    Mealy’s `FSM` output depends on the input and current state, that is, the action
    it performs is determined by both the current state and the input.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制理论中，有Moore和Mealy机器的分类。Moore的`FSM`输出只依赖于状态，也就是说，`FSM`只使用入口动作。Mealy的`FSM`输出依赖于输入和当前状态，也就是说，它执行的动作由当前状态和输入共同决定。
- en: The `FSM`s that we will cover in this chapter are a combination of both Moore
    and Mealy `FSM`s as they support both actions performed during transitions and
    entry and exit actions that depend only on a current state. `FSM`s are also called
    **Unified Modeling Language** (**UML**) state machines and are used in real-life
    applications in embedded systems to describe and control machines. For example,
    `FSM`s are commonly used to control washing machines, elevator systems, or communication
    protocols in networking devices, for managing complex sequences of operations
    based on various inputs. Understanding `FSM`s will help you design more predictable
    and maintainable embedded systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的`FSM`是Moore和Mealy `FSM`的组合，因为它们支持在转换期间执行的动作以及仅依赖于当前状态的动作。`FSM`也称为**统一建模语言**（**UML**）状态机，并在嵌入式系统的实际应用中用于描述和控制机器。例如，`FSM`通常用于控制洗衣机、电梯系统或网络设备的通信协议，以基于各种输入管理复杂的操作序列。理解`FSM`将帮助您设计更可预测和可维护的嵌入式系统。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: '`FSM` – a simple implementation'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSM` – 一个简单的实现'
- en: '`FSM` – implementation using the State pattern'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSM` – 使用状态模式实现'
- en: State pattern implementation using tag dispatching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签分派实现状态模式
- en: Boost SML (State Machine Language)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost SML（状态机语言）
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (`stdio`) results and better observe the code’s behavior.
    As we are using a lot of modern C++ features, make sure to select the C++23 standard,
    by adding `-std=c++23` in the compiler options box.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议在阅读示例时使用Compiler Explorer（[https://godbolt.org/](https://godbolt.org/))。选择GCC作为您的编译器，并针对x86架构。这将允许您看到标准输出（`stdio`）结果，并更好地观察代码的行为。由于我们使用了大量的现代C++特性，请确保在编译器选项框中添加`-std=c++23`以选择C++23标准。
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in a Renode simulator on an ARM Cortex M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Compiler Explorer使得尝试代码、调整代码并立即看到它如何影响输出和生成的汇编变得容易。大多数示例也可以在ARM Cortex M0目标上的Renode模拟器中运行，并在GitHub上提供（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16))。
- en: FSM – a simple implementation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FSM – 一个简单的实现
- en: We will jump straight into an example of an `FSM` handling **Bluetooth Low Energy**
    (**BLE**) device connection states, analyze its shortcomings, and see how we can
    improve it using the State design pattern.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入一个处理`FSM`的`Bluetooth Low Energy`（**BLE**）设备连接状态的示例，分析其不足之处，并看看我们如何可以使用状态设计模式来改进它。
- en: 'The example `FSM` will be simplified for the purpose of clarity and easier
    understanding. We will have three states – `idle`, `advertising`, and `connected`.
    Here is a state diagram of the example `FSM`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰和更容易理解，示例`FSM`将被简化。我们将有三个状态 – `idle`（空闲）、`advertising`（广播）和`connected`（连接）。以下是示例`FSM`的状态图：
- en: '![Figure 16.1 – BLE device connection state diagram](img/B22402_16_1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – BLE设备连接状态图](img/B22402_16_1.png)'
- en: Figure 16.1 – BLE device connection state diagram
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – BLE设备连接状态图
- en: '*Figure 16**.1* depicts the state diagram of the BLE device connection `FSM`.
    The diagram depicts transitions between states and actions described as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.1* 描述了BLE设备连接的`FSM`状态图。该图展示了状态之间的转换以及以下描述的动作：'
- en: The default state is `idle`. It transitions to the `advertising` state on a
    `ble_button_pressed` event. During the transition, the `start_advertising` action
    is executed. In simple words, this means that if the device is in an `idle` state
    and a user presses a designated button, it will start advertising and change state.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认状态是`idle`。在`ble_button_pressed`事件发生时，它转换到`advertising`状态。在转换过程中，执行`start_advertising`动作。简单来说，这意味着如果设备处于`idle`状态，并且用户按下指定的按钮，它将开始广播并改变状态。
- en: From the `advertising` state, the `FSM` can transition to `connected` on a `connection_request`
    event or go back to `idle` on the `timer_expired` state while stopping the advertising
    by executing the `stop_advertising` action.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`advertising`状态，`FSM`可以在`connection_request`事件发生时转换到`connected`状态，或者在`timer_expired`状态下返回`idle`状态，同时通过执行`stop_advertising`动作停止广播。
- en: When in the `connected` state, the `FSM` can go only to `idle` on the `ble_button_pressed`
    event while executing the `disconnect` action.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于`connected`状态时，在执行`disconnect`动作的同时，`FSM`只能由`ble_button_pressed`事件转换到`idle`状态。
- en: Keep in mind that this is an extremely simplified `FSM` we are using for the
    purpose of an example, and a real-life `FSM` would include more states and events
    to properly describe the connecting behavior of a BLE device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个为了示例目的而极度简化的`FSM`，而在现实生活中的`FSM`将包括更多的状态和事件，以正确描述BLE设备的连接行为。
- en: 'An `FSM` can also be described using state transition tables. This table shows
    the state to which the `FSM` moves based on the current state and input (received
    event), as well as the action it performs during the transition. Here is the transition
    table for the BLE device `FSM` we are analyzing in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSM`也可以使用状态转换表来描述。此表显示了`FSM`根据当前状态和输入（接收的事件）移动到的状态，以及它在转换期间执行的动作。以下是本章中分析的BLE设备`FSM`的转换表：'
- en: '| **Current State** | **Event** | **Next State** | **Action** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **当前状态** | **事件** | **下一个状态** | **动作** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **idle** | `ble_button_pressed` | advertising | `start_advertising` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **idle** | `ble_button_pressed` | advertising | `start_advertising` |'
- en: '| **advertising** | `timer_expired` | `idle` | `stop_advertising` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **advertising** | `timer_expired` | `idle` | `stop_advertising` |'
- en: '| **advertising** | `connection_request` | connected |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **advertising** | `connection_request` | connected |  |'
- en: '| **connected** | `ble_button_pressed` | `idle` | disconnect |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **connected** | `ble_button_pressed` | `idle` | disconnect |'
- en: Table 16.1 – BLE device state transition table
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 – BLE设备状态转换表
- en: '*Table 16.1* describes the BLE device `FSM` by listing transitions in rows.
    It serves as an alternative to the state diagram for describing `FSM` behavior.
    We will start with the implementation of this `FSM` first by defining states and
    events.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*表16.1* 通过列出行中的转换来描述BLE设备的`FSM`。它作为状态图的替代，用于描述`FSM`的行为。我们将首先通过定义状态和事件来实现这个`FSM`。'
- en: Describing states and events
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述状态和事件
- en: 'We will model states and events as `enum`erators, as shown in the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`enum`类型来表示状态和事件，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `enum`erators describe states and events for our BLE device `FSM`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`enum`类型描述了我们的BLE设备`FSM`的状态和事件。
- en: Tracking current state and handling events – the FSM class
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪当前状态和处理事件 – `FSM`类
- en: 'Next, we will define a class `ble_fsm` that will keep track of the current
    state and provide a public method, `handle_event`, which we will use to feed the
    `FSM` with events. The code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个名为`ble_fsm`的类，该类将跟踪当前状态并提供一个公共方法`handle_event`，我们将使用它向`FSM`提供事件。代码如下：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the code above, we define the class ble_fsm with the following members:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了具有以下成员的`ble_fsm`类：
- en: '`ble_state current_state_` – A private member with the default value `ble_state::idle`.
    We use it to track the current state, and the initial value is set to `idle`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state current_state_` – 默认值为`ble_state::idle`的私有成员。我们使用它来跟踪当前状态，初始值设置为`idle`。'
- en: '`void start_advertising()` – A private method used to implement an action.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void start_advertising()` – 用于实现动作的私有方法。'
- en: '`void stop_advertising()` – A private method used to implement an action.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void stop_advertising()` – 用于实现动作的私有方法。'
- en: '`void disconnect()` – A private method used to implement an action.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void disconnect()` – 用于实现动作的私有方法。'
- en: '`ble_state get_state() const` – A private method used to retrieve the current
    state.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state get_state() const` – 一个私有方法，用于检索当前状态。'
- en: '`void handle_event(ble_event event)` – A public method used to respond to events
    by executing actions and changing the current state depending on the `current_event_`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void handle_event(ble_event event)` – 一个公共方法，用于通过执行操作并根据 `current_event_`
    改变当前状态来响应事件。'
- en: 'The `handle_event` method implements the actual behavior of the `FSM`, and
    the code for it is shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_event` 方法实现了 `FSM` 的实际行为，其代码如下所示：'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code shows the implementation of the `handle_event` method for
    the `ble_fsm` class. It uses a `switch` statement on `current_state_` to handle
    the event according to it and receive the event. The event is handled by calling
    an appropriate action and changing the state as described by the `FSM`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了 `ble_fsm` 类的 `handle_event` 方法的实现。它使用 `switch` 语句在 `current_state_`
    上进行 `switch`，根据它处理事件并接收事件。事件通过调用适当的操作并按照 `FSM` 描述的状态进行状态转换来处理。
- en: Next, we will see how to use the `ble_fsm` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用 `ble_fsm` 类。
- en: Using the ble_fsm class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ble_fsm 类
- en: 'We will first define a helper function, `state_to_string`, used to debug our
    `FSM`. The code is shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个辅助函数 `state_to_string`，用于调试我们的 `FSM`。代码如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `state_to_string` function returns a string literal for a given state `enum`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`state_to_string` 函数返回一个给定状态 `enum` 的字符串字面量。'
- en: 'Next, let us see how to use the `ble_fsm` class, as shown in the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 `ble_fsm` 类，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code in the `main` function creates an object, `my_ble_fsm`,
    of the `ble_fsm` type, and it feeds it with events in the following order:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `main` 函数中的代码创建了一个 `ble_fsm` 类型的对象 `my_ble_fsm`，并按照以下顺序向其中提供事件：
- en: It first passes `ble_event::ble_button_pressed` to the `FSM` handle_event method.
    The initial state of the `FSM` is `idle`, and after this event, it will transition
    to `advertising`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先将 `ble_event::ble_button_pressed` 传递给 `FSM` 的 `handle_event` 方法。`FSM` 的初始状态是
    `idle`，在此事件之后，它将过渡到 `advertising` 状态。
- en: Next, it passes the `ble_event::connection_request` event to the `FSM`, which
    will make it transition to the `connected` state.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将 `ble_event::connection_request` 事件传递给 `FSM`，这将使其过渡到 `connected` 状态。
- en: Finally, it passes the `ble_event::ble_button_pressed` event to the `FSM` for
    the second time, making it transition back to the `idle` state.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它第二次将 `ble_event::ble_button_pressed` 事件传递给 `FSM`，使其返回到 `idle` 状态。
- en: The code above uses the `state_to_string` function to get the string literal
    from the state `enum`, and it uses it to print the current state of the `FSM`
    after it feeds it with an event.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `state_to_string` 函数从状态 `enum` 获取字符串字面量，并使用它来打印在向 `FSM` 提供事件后的当前状态。
- en: Analyzing the output
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析输出
- en: 'Running the full example will provide the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完整示例将提供以下输出：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding output shows `FSM` states and the executed actions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了 `FSM` 状态和执行的操作。
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从书籍的 GitHub 仓库中的 Renode 模拟器运行完整示例。它位于 `Chapter16/fsm` 目录下，您可以使用以下命令构建和运行它：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The approach for implementing an `FSM` we just went through works well for simple
    `FSM`s. In real-life applications, `FSM`s are more complex – they have more states,
    actions, and events. The `handle_event` method in `ble_fsm` doesn’t scale well
    as it is implemented using `switch-case` and `if-else` logic. Adding more states,
    and handling more events and actions, makes it less readable and harder to maintain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的 `FSM` 实现方法对于简单的 `FSM` 来说效果很好。在实际应用中，`FSM` 通常更复杂——它们有更多的状态、操作和事件。`ble_fsm`
    中的 `handle_event` 方法由于使用了 `switch-case` 和 `if-else` 逻辑，因此扩展性不佳。添加更多状态，以及处理更多事件和操作，使得代码可读性降低，维护难度增加。
- en: Next, we will see how we can utilize the State design pattern to mitigate these
    issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何利用状态设计模式来缓解这些问题。
- en: FSM – implementation using the State pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FSM – 使用状态模式实现
- en: Building on our switch-based approach, we will now refactor the BLE device connection
    `FSM` using the State design pattern. This pattern is “state-centric,” meaning
    each state is encapsulated as its own class. A common base class interface will
    allow the `FSM` to store pointers to these concrete state classes in a container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于我们的开关方法的基础上，我们现在将使用状态设计模式重构 BLE 设备连接 `FSM`。这种模式是“以状态为中心”的，意味着每个状态都被封装为其自己的类。一个常见的基类接口将允许
    `FSM` 在容器中存储指向这些具体状态类的指针。
- en: In a typical `FSM`, states change dynamically at runtime in response to external
    interrupts and timers. In our example, we will continue using an `enum` to differentiate
    states and store the current one in a private member variable. This `enum`-based
    approach still works well with the State pattern, since it lets us quickly locate
    and switch between the concrete state objects that the `FSM` manages. We will
    start the implementation with the state class interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的`FSM`中，状态在运行时动态变化，以响应外部中断和定时器。在我们的示例中，我们将继续使用枚举来区分状态，并将当前状态存储在私有成员变量中。这种基于枚举的方法仍然与状态模式很好地工作，因为它允许我们快速定位并在`FSM`管理的具体状态对象之间切换。我们将从状态类接口开始实现。
- en: Understanding state class interfaces
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态类接口
- en: 'The `state` class interface is shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`类接口如下所示：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we see that the state interface is simple and has two
    pure virtual methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到状态接口简单且有两个纯虚方法：
- en: '`virtual ble_state handle_event(ble_event event)` – A method intended to be
    implemented by a derived class to handle an actual event. It returns a `ble_state`
    `enum` to signal a new state to an `FSM`. If handling an event doesn’t cause transition,
    it should return the `enum` that corresponds to the current state.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual ble_state handle_event(ble_event event)` – 一个旨在由派生类实现的方法，用于处理实际事件。它返回一个`ble_state`枚举以向`FSM`信号新状态。如果处理事件不会导致转换，则应返回对应于当前状态的枚举。'
- en: '`virtual ble_state get_state_enum()` – A method used to return a `ble_state`
    `enum` corresponding to an actual state.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual ble_state get_state_enum()` – 一个用于返回对应于实际状态的`ble_state`枚举的方法。'
- en: 'Next, we will go over the implementation of concrete state classes: `idle`,
    `advertising`, and `connected`. We will start with the `idle` class, as shown
    in this code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍具体状态类的实现：`idle`、`advertising`和`connected`。我们将从`idle`类开始，如下所示代码所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we see that the `idle` class implements pure virtual
    methods defined in the `state` interface class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`idle`类实现了在`state`接口类中定义的纯虚方法：
- en: '`ble_state handle_event(ble_event event)` – The `idle` class checks whether
    the received event is `ble_event::ble_button_pressed` and calls `start_advertising`
    if it is and returns the `ble_state::advertising` `enum`. In the case that it
    receives any other event, it returns the state provided with `get_state_enum`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state handle_event(ble_event event)` – `idle`类检查接收到的事件是否为`ble_event::ble_button_pressed`，如果是，则调用`start_advertising`并返回`ble_state::advertising`枚举。在接收到任何其他事件的情况下，它返回由`get_state_enum`提供的状态。'
- en: '`ble_state get_state_enum()` – This returns the `ble_state` `enum` corresponding
    to the `idle` class, which is `ble_state::idle`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state get_state_enum()` – 这返回与`idle`类对应的`ble_state`枚举，即`ble_state::idle`。'
- en: 'Next, we will go through the derived class `advertising`, as shown in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过以下代码查看派生类`advertising`：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, the `advertising` class implements pure virtual methods defined
    in the `state` interface class by handling the events appropriately.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`advertising`类通过适当地处理事件实现了在`state`接口类中定义的纯虚方法。
- en: 'Next, we will go over the `connected` concrete class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍`connected`的具体类：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see in the preceding code, the `connected` class implements a state
    interface and implements the virtual methods `handle_event` and `get_state_enum`
    appropriately.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，`connected`类实现了状态接口，并适当地实现了`handle_event`和`get_state_enum`虚方法。
- en: Next, we will refactor the `ble_fsm` class to use the state class interface
    to store pointers to concrete class objects in a container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构`ble_fsm`类，以使用状态类接口在容器中存储具体类对象的指针。
- en: Refactoring the ble_fsm class
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构ble_fsm类
- en: 'We will start with refactoring the `ble_fsm` class, as shown in the following
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下代码所示的`ble_fsm`类的重构开始：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us break down the implementation of the `ble_fsm` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解`ble_fsm`类的实现：
- en: '`ble_state current_state_` – A private member with the default value `ble_state::idle`.
    We use it to track the current state, as we did previously.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state current_state_` – 一个具有默认值`ble_state::idle`的私有成员。我们使用它来跟踪当前状态，就像之前一样。'
- en: '`etl::vector<state*, 3> states_` – A container used to hold pointers to the
    state interface. If you are following this example using Compiler Explorer, you
    can replace it with `std::vector` (and include a `<vector>` header).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etl::vector<state*, 3> states_` – 一个用于存储状态接口指针的容器。如果您使用编译器探索器跟随此示例，您可以将其替换为`std::vector`（并包含`<vector>`头文件）。'
- en: '`state* get_the_state(ble_state state_enum)` – A private method used to get
    an actual state using the `ble_state` `enum`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state* get_the_state(ble_state state_enum)` – 一个用于使用`ble_state` `enum`获取实际状态的私有方法。'
- en: '`void handle_event(ble_event event)` – A public method used to handle events.
    It calls the `get_the_state` method provided with `current_state_` to get a pointer
    to the actual state object. If the pointer is valid, it calls `handle_event` on
    the state object and stores the return value in `current_state_`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void handle_event(ble_event event)` – 一个用于处理事件的公共方法。它调用提供`current_state_`的`get_the_state`方法来获取实际状态对象的指针。如果指针有效，它将在状态对象上调用`handle_event`并存储返回值在`current_state_`中。'
- en: 'Next, let us go through the `get_the_state` method implementation, as shown
    here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下`get_the_state`方法实现，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `get_the_state` method, we use the `std::find_if` function (from the
    `<algorithm>` header) to search for a pointer to a `state` object that matches
    the given `state_enum`. The search uses the `is_state_enum` lambda as a predicate,
    which compares each state’s `enum` value. If a matching state is found, the method
    returns a pointer to it; otherwise, the `nullptr`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_the_state`方法中，我们使用`std::find_if`函数（来自`<algorithm>`头文件）来搜索一个指向匹配给定`state_enum`的`state`对象的指针。搜索使用`is_state_enum`lambda作为谓词，它比较每个状态的`enum`值。如果找到匹配的状态，方法返回指向它的指针；否则，返回`nullptr`。
- en: Next, let us see how to use the refactored `ble_fsm` class, the `state` interface,
    and the concrete classes `idle`, `advertising`, and `connected` to implement the
    `FSM`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用重构的`ble_fsm`类、`state`接口以及具体的`idle`、`advertising`和`connected`类来实现`FSM`。
- en: Implementing the State pattern
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态模式
- en: 'Next, we will see how to use the above implementation of the State pattern
    in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在以下代码中使用上述状态模式的实现：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this code, we see that after creating an object `my_ble_fsm` of the `ble_fsm`
    type, we create instances of concrete states: `idle`, `advertising`, and `connected`.
    Then, we add pointers to the concrete states to the `my_ble_fsm` object using
    the `add_state` method. Next, we use the `FSM` as we did in the initial implementation
    and feed it with events.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们看到在创建`ble_fsm`类型的对象`my_ble_fsm`之后，我们创建了具体状态的实例：`idle`、`advertising`和`connected`。然后，我们使用`add_state`方法将具体状态的指针添加到`my_ble_fsm`对象中。接下来，我们像在初始实现中那样使用`FSM`并给它提供事件。
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从书中GitHub仓库的Renode模拟器中运行完整的示例。它位于`Chapter16/fsm`目录下，您可以使用以下命令构建和运行它：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The example we just went through is using the State design pattern. Next, we
    will go through the generic form of the State design pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的例子是使用状态设计模式。接下来，我们将讨论状态设计模式的通用形式。
- en: State design pattern
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: 'Let us go over the UML diagram of the BLE device connection `FSM`, as shown
    in *Figure 16**.2*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下BLE设备连接`FSM`的UML图，如图*图16.2*所示：
- en: '![Figure 16.2 – BLE device connection FSM – UML diagram](img/B22402_16_2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – BLE设备连接状态机-FSM UML图](img/B22402_16_2.png)'
- en: Figure 16.2 – BLE device connection FSM – UML diagram
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – BLE设备连接状态机-FSM UML图
- en: '*Figure 16**.2* depicts a UML diagram of the BLE device connection `FSM`. We
    already went through applying the State design pattern to the `FSM` implementation.
    Let us summarize it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.2*展示了BLE设备连接`FSM`的UML图。我们已经讨论了如何将状态设计模式应用于`FSM`实现。让我们总结一下：'
- en: The `FSM` class holds pointers to the state class interface in a container.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSM`类在容器中持有对状态类接口的指针。'
- en: The `FSM` keeps track of the current state.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSM`跟踪当前状态。'
- en: The `FSM` delegates `handle_event` calls to a current concrete state.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSM`将`handle_event`调用委托给当前的具体状态。'
- en: Concrete states implement the state interface.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体状态实现状态接口。
- en: Concrete states implement actions and call them appropriately when handling
    events.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体状态实现动作并在处理事件时适当地调用它们。
- en: Concrete states return a new state from the `handle_event` method. This allows
    the `FSM` to update the current state.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体状态从`handle_event`方法返回一个新的状态。这允许`FSM`更新当前状态。
- en: The state design pattern is a simple yet effective pattern that allows us to
    break down complex switch statements into more manageable code. Still, as we were
    able to see in the previous example, concrete states handle events using `if-else`
    logic. With the increasing complexity of an `FSM`, the handle functions can also
    clutter. To mitigate this, we can apply the tag-dispatching technique.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式是一种简单而有效的模式，它允许我们将复杂的switch语句分解成更易于管理的代码。然而，正如我们之前在示例中看到的那样，具体状态通过`if-else`逻辑处理事件。随着`FSM`复杂性的增加，处理函数也可能变得杂乱。为了减轻这种情况，我们可以应用标签调度技术。
- en: State pattern implementation using tag dispatching
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签调度实现状态模式
- en: 'In the previous example (in the previous sections), the program flow in event
    handlers was determined at runtime using `if-else` logic. Next, we will use the
    tag-dispatching technique to decouple event handling of different events in separate
    methods. We will rely no longer on the `ble_event` `enum`, and will create empty
    types as events instead, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例（前几节中），事件处理程序中的程序流程是在运行时使用`if-else`逻辑确定的。接下来，我们将使用标签调度技术将不同事件的处理解耦到单独的方法中。我们将不再依赖于`ble_event`枚举，而是创建空类型作为事件，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the class `state` will overload `handle_event` virtual methods for every
    defined event, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类`state`将为每个定义的事件重载`handle_event`虚拟方法，如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we see that the class `state` is no longer an interface but an
    abstract class (as not all virtual methods are pure). It overloads the `handle_event`
    function for types `ble_button_pressed`, `connection_request`, and `timer_expired`.
    It implements all overloads by returning the value generated by `get_state_enum`
    – a pure virtual method that will be implemented by derived classes, that is,
    concrete states.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到类`state`不再是接口，而是一个抽象类（因为并非所有虚拟方法都是纯方法）。它为类型`ble_button_pressed`、`connection_request`和`timer_expired`重载了`handle_event`函数。它通过返回由`get_state_enum`生成的值来实现所有重载，这是一个纯虚拟方法，将由派生类实现，即具体状态。
- en: 'Next, let us see the implementation of the `advertising` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`advertising`类的实现：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code, we see that the `advertising` class implements the following
    overloads of the virtual method `handle_event`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到`advertising`类实现了以下虚拟方法的重载：
- en: '`ble_state handle_event(connection_request cr)` returns `ble_state::connected`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state handle_event(connection_request cr)` 返回 `ble_state::connected`。'
- en: '`ble_state handle_event(timer_expired te)` calls `stop_advertising` and returns
    `ble_state::idle`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ble_state handle_event(timer_expired te)` 调用 `stop_advertising` 并返回 `ble_state::idle`。'
- en: 'By using overloaded functions, we can implement the handling of different events
    in separate methods and easily dispatch calls to them by calling `handle_event`
    with different types. To complete the implementation, we also need to overload
    the `handle_event` method in the `FSM` for all possible events. We can do this
    easily by making it a template method, as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用重载函数，我们可以在单独的方法中实现不同事件的处理，并通过调用`handle_event`并传递不同类型来轻松地调度对这些方法的调用。为了完成实现，我们还需要在`FSM`中对所有可能的事件重载`handle_event`方法。我们可以通过将其制作成模板方法来实现这一点，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code shows the template method `handle_event` from the `ble_fsm`
    class, which makes our tag-dispatching technique application complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了`ble_fsm`类的模板方法`handle_event`，这使我们的标签调度技术应用完整。
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书中GitHub仓库的Renode模拟器中运行完整示例。它位于`Chapter16/fsm`目录下，您可以使用以下命令构建和运行它：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Until this point, we saw three approaches in this chapter to implement an `FSM`
    in C++. We started with a simple switch and if-else-based approach, applied the
    State design pattern, and then utilized tag dispatching. Each step provided us
    with more flexibility in the design – making code more readable and easier to
    manage, which is important when working with complex `FSM`s.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中看到了三种在C++中实现`FSM`的方法。我们从一个简单的基于switch和if-else的方法开始，应用了状态设计模式，然后利用了标签调度。每一步都为我们提供了更多的设计灵活性——使代码更易于阅读和管理，这对于处理复杂的`FSM`非常重要。
- en: There are other approaches to implementing an `FSM`, based on a state transition
    table, which describes transitions in a single place. Boost **State Machine Language**
    (**SML**) uses a table-based approach to describe an `FSM` using descriptive syntax.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个 `FSM` 的其他方法基于状态转换表，它在一个地方描述转换。Boost **状态机语言**（**SML**）使用基于表的策略来使用描述性语法描述
    `FSM`。
- en: Boost SML
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost SML
- en: 'Boost SML is a highly expressive C++14 single header library used to implement
    `FSM`s. We will jump straight ahead in using it by implementing the same BLE device
    connection `FSM`. Here is the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Boost SML 是一个高度表达的 C++14 单头库，用于实现 `FSM`s（有限状态机）。我们将直接通过实现相同的 BLE 设备连接 `FSM`
    来使用它。以下是代码：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let us break down this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个示例：
- en: The events are modeled as structs, the same as in our tag-dispatching implementation.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件被建模为结构体，与我们的标签分派实现相同。
- en: Actions are defined as `constexpr` lambdas.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作被定义为 `constexpr` lambda 表达式。
- en: We define the type `ble_fsm` as a struct with an overloaded `operator()`, which
    returns the result of a call to `make_transition_table` from the namespace `sml`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `ble_fsm` 类型定义为具有重载 `operator()` 的结构体，该操作符从 `sml` 命名空间调用 `make_transition_table`
    返回结果。
- en: 'The code in `make_transition_table` allows SML to extract transition definitions,
    and within it, we are using the following syntax: `src_state + event [ guard ]
    / action = dst_state`. Here is a breakdown of the syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_transition_table` 中的代码允许 SML 提取转换定义，在其中，我们使用以下语法：`src_state + event [
    guard ] / action = dst_state`。以下是语法的分解：'
- en: '`src_state` – This is the state from which the transition starts.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_state` – 这是转换开始的初始状态。'
- en: '`+ event` – This is the event that triggers checking for a possible transition.
    If the event arrives and the guard is satisfied, then the transition proceeds.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+ event` – 这是触发检查可能转换的事件。如果事件到达且守卫满足条件，则进行转换。'
- en: '`[ guard ]` – The guard is an optional bool predicate that must evaluate to
    true for the transition to occur. If omitted, the transition happens unconditionally
    at the specified event.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ guard ]` – 守卫是一个可选的布尔谓词，必须评估为真才能发生转换。如果省略，则指定事件无条件发生转换。'
- en: '`/ action` – The action is an optional lambda to execute whenever the transition
    takes place.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ action` – 当状态转换发生时，动作是一个可选的 lambda 表达式，用于执行操作。'
- en: '`= dst_state` – The destination state is where the `FSM` will go if the transition
    occurs.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`= dst_state` – 如果发生转换，`FSM` 将进入的目标状态。'
- en: The transition syntax is the essence of SML. By writing multiple lines of these
    rules inside the `operator()`, we fully describe the `FSM`'s behavior in a declarative,
    human-readable way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 转换语法是 SML 的精髓。通过在 `operator()` 内写入多行这些规则，我们以声明性和可读性的方式完全描述了 `FSM` 的行为。
- en: 'Let us now see how to use the `FSM` we discussed using Boost SML:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 Boost SML 中讨论的 `FSM`：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, we create an object `my_ble_fsm` of the type `sm<ble_fsm>`. Then,
    we use the `process_event` method to send an event to it. You can run the full
    example in the Renode simulator from the book’s GitHub repo. It is placed under
    `Chapter16/fsm`, and you can build and run it using the following commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个 `my_ble_fsm` 类型的对象。然后，我们使用 `process_event` 方法向其发送事件。您可以从书籍的 GitHub
    仓库中的 Renode 模拟器运行完整示例。它位于 `Chapter16/fsm` 目录下，您可以使用以下命令构建和运行它：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Boost SML is a highly expressive library that reduces boilerplate code from
    the previous implementations of an `FSM`. It also offers features such as guard
    variables and composite states. Here is a project link where you can explore more:
    [https://github.com/boost-ext/sml](https://github.com/boost-ext/sml).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Boost SML 是一个高度表达的库，它减少了之前 `FSM` 实现中的样板代码。它还提供了诸如守卫变量和组合状态等功能。以下是您可以探索更多信息的项目链接：[https://github.com/boost-ext/sml](https://github.com/boost-ext/sml)。
- en: 'Boost SML is not only an expressive library but also highly performant, thanks
    to its use of compile-time template metaprogramming to aggressively optimize code.
    Event dispatching relies on tag dispatching (resolved at compile time) paired
    with minimal runtime lookups, avoiding costly branching or indirection. This approach
    typically outperforms both manual switch-`enum`-based solutions and State pattern-based
    implementations (which incur virtual call overhead). For concrete performance
    comparisons, see the benchmark at the following link: [https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark](https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Boost SML不仅是一个高度表达性的库，而且性能也非常出色，这得益于它使用编译时模板元编程来积极优化代码。事件调度依赖于标签调度（在编译时解决）与最小运行时查找相结合，避免了昂贵的分支或间接引用。这种方法通常优于基于手动switch-`enum`的解决方案和基于状态模式的实现（这些实现会带来虚拟调用开销）。具体性能比较，请参阅以下链接的基准测试：[https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark](https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark)。
- en: Summary
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through `FSM` implementation starting from the simple
    switch-case-based approach, to the State pattern, tag dispatching, and using the
    Boost SML library for highly expressive code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从基于简单switch-case方法的实现开始，讨论了状态模式、标签调度以及使用Boost SML库进行高度表达性代码的实现。
- en: The most basic, switch-based implementation is suitable for small `FSM`s with
    a limited number of states and transitions. When the complexity of an `FSM` increases,
    it gets hard to read and manage. Moving to a State pattern-based solution increases
    code readability and makes changes easier. Boost SML offers ultimate expressiveness,
    providing us with a human-readable syntax that allows us to write very complex
    `FSM`s in a concise manner.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的基于switch的实现适用于具有有限状态和转换的小型`FSM`。当`FSM`的复杂性增加时，阅读和管理变得困难。转向基于状态模式的解决方案可以提高代码的可读性，并使更改更容易。Boost
    SML提供了终极的表达性，为我们提供了一个可读性强的语法，使我们能够以简洁的方式编写非常复杂的`FSM`。
- en: In the next chapter, we will go through an overview of libraries and frameworks
    in C++ usable for embedded systems development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将概述可用于嵌入式系统开发的C++库和框架。
