- en: Taking VR Further - Extending Unreal Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步发展VR - 扩展虚幻引擎
- en: One of the major factors that differentiates professional developers from the
    newbies is how they leverage existing tools and libraries to accelerate their
    work. Very often, new developers try to do everything themselves, either because
    they're unaware of resources that could help them or because they think that leaning
    on an existing library is somehow *cheating*. It isn't. If you're a photographer,
    you're not cheating if you didn't build your own camera in your garage—you're
    focusing on the part of your art that actually matters to you. Don't be afraid
    to make use of tools and libraries that can accelerate your development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 区分专业开发者和新手开发者的一个重要因素是他们如何利用现有的工具和库来加速工作。很多时候，新手开发者尝试自己做所有的事情，要么是因为他们不知道有哪些资源可以帮助他们，要么是因为他们认为依赖现有的库是一种“作弊”。其实不是这样的。如果你是一名摄影师，在你的车库里没有自己建造相机并不是作弊——你只是专注于你真正关心的艺术部分。不要害怕利用可以加速你开发的工具和库。
- en: 'Here''s the rub though: to make effective use of another developer''s work,
    you need to put in the effort to understand what they''re doing. Don''t simply
    paste in someone else''s code without really understanding why it works—you''re
    just asking for difficult-to-find bugs if you do this. Do your homework and find
    code you can rely on, but consider it part of your homework to understand how
    it''s built so you can make deliberate choices about how you use it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要有效地利用其他开发者的工作，你需要付出努力去理解他们在做什么。不要只是简单地粘贴别人的代码而不真正理解它为什么有效——如果你这样做，你只会引发难以找到的错误。做好功课，找到你可以依赖的代码，但同时也要把它作为你的功课的一部分，去理解它是如何构建的，这样你才能在使用它时做出明智的选择。
- en: Sooner or later in your development career, you'll encounter the phrase *cargo
    cult programming*. This term, commonly attributed to the physicist Richard Feynman,
    refers to aboriginal religious practices observed in some islands of the South
    Pacific after World War II, whereby the natives built replica airfields in an
    attempt to lure back the god-like cargo planes that had supplied the islands during
    the war. In doing this, they were reproducing the forms, but they didn't understand
    how those forms worked and didn't understand why they weren't working now. Don't
    let this describe how you develop software. For anything you include in the project
    you're building, you should be able to give a clear answer when another engineer
    points to any part of it and asks, *What is this doing*? This won't be possible
    in all cases, of course, but in general, consider that your work isn't finished
    until you've spent the time to understand how the library or plugin is doing what
    it's doing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发生涯中，迟早会遇到“模仿神秘”的编程术语。这个术语通常被归功于物理学家理查德·费曼，它指的是二战后南太平洋一些岛屿上观察到的土著宗教习俗，他们建造了复制的机场，试图吸引战争期间供应岛屿的神秘货机回来。他们只是复制了形式，但他们不理解这些形式是如何工作的，也不理解为什么它们现在不起作用。不要让这描述你开发软件的方式。对于你在项目中包含的任何内容，当另一个工程师指着其中的任何部分问“这是做什么的？”时，你应该能够给出一个清晰的答案。当然，并非所有情况下都可能做到这一点，但总的来说，要考虑到你的工作在你花时间去理解库或插件是如何工作的之前是不完整的。
- en: In this chapter, we're going to focus primarily on one of the most useful plugins
    available for VR Developers: Joshua (MordenTral) Statzer's **VRExpansion** plugin.
    It's licensed under the MIT license (we're going to talk about licenses shortly—they're
    important), which means that it can be used freely in both non-commercial and
    commercial software. It doesn't cost anything, but it represents absolutely outstanding
    professional-caliber work, so if you use it, seriously consider supporting his
    Patreon to allow the project to continue.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注一款对VR开发者非常有用的插件：Joshua (MordenTral) Statzer的**VRExpansion**插件。它采用MIT许可证（我们马上会谈到许可证——它们很重要），这意味着它可以在非商业和商业软件中自由使用。它不需要任何费用，但它代表了非常出色的专业工作，所以如果你使用它，认真考虑支持他的Patreon，以便项目能够继续进行。
- en: In this chapter, we're going to learn how to make effective use of an advanced
    plugin such as the VR Expansion plugin, and use the example Blueprints from its
    sample project to learn how it's intended to be used. We'll learn strategies for
    exploring and making sense of unfamiliar code, and ways of using debugging tools
    to show us how code runs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何有效地使用高级插件，如VR扩展插件，并使用其示例项目中的蓝图示例来学习它的预期使用方式。我们将学习探索和理解陌生代码的策略，以及使用调试工具来展示代码的运行方式。
- en: 'Specifically, we''ll learn to do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将学习以下内容：
- en: Install and build plugins to extend the capabilities of the engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和构建插件以扩展引擎的功能
- en: Use documentation and sample projects to learn a plugin's capabilities and intended
    use
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文档和示例项目来了解插件的功能和预期使用方式
- en: Make use of new native classes provided by the plugin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用插件提供的新的本地类
- en: Use strategies to read complicated blueprints and make sense of their structure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略来阅读复杂的蓝图并理解它们的结构
- en: Use debugging tools to help us to explore unfamiliar blueprints and learn their
    execution flow
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试工具来帮助我们探索陌生的蓝图并了解它们的执行流程
- en: This chapter is going to involve less direct Blueprint-building than those that
    came before it, and that's deliberate. The real focus here is on helping you to
    develop strategies to learn how unfamiliar code works so you can leverage it for
    your own development and use it to learn advanced techniques. This is one of the
    most important skills you can cultivate as a developer. It's fairly easy to find
    tutorials for basic topics, but once you get into more advanced territory, you
    mostly need to learn by looking at other advanced work. It's not as daunting as
    it might seem at first. We're going to learn a number of strategies to do this
    effectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及的直接蓝图构建比之前的章节要少，这是有意为之的。真正的重点在于帮助您开发学习如何使用陌生代码的策略，以便您可以利用它进行自己的开发并学习高级技术。这是作为开发人员可以培养的最重要的技能之一。对于基本主题，很容易找到教程，但一旦进入更高级的领域，您主要需要通过查看其他高级工作来学习。一开始可能看起来有些令人生畏，但我们将学习一些有效的策略来做到这一点。
- en: With that, let's add to the engine and learn how to make it do things it couldn't
    do before.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们为引擎添加一些功能，并学习如何使其做以前无法做到的事情。
- en: Creating a project to house our plugin
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于存放插件的项目
- en: 'Let''s begin by creating a new blank project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的空白项目开始：
- en: Create a new Blueprint project using the Blank template, and set its hardware
    target to Mobile / Tablet, and its graphics target to Scalable 3D or 2D, No starter
    content.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空白模板创建一个新的蓝图项目，并将其硬件目标设置为移动/平板电脑，图形目标设置为可扩展的3D或2D，没有起始内容。
- en: Installing the VRExpansion plugin
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装VRExpansion插件
- en: Once we've created our project, we're going to add the VRExpansion plugin to
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了项目，我们将把VRExpansion插件添加到其中。
- en: 'The first thing we need to do before we can install any plugin to our project
    is create a place to put it. Plugins must live in a directory named `Plugins`
    in your project directory or in the `Engine` directory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以安装任何插件到项目之前，我们需要做的第一件事是创建一个放置插件的位置。插件必须位于项目目录或`Engine`目录中名为`Plugins`的目录中：
- en: Open the directory containing your new project file. You should see your `.uproject`
    file here, along with your `Config` and `Content` directories.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包含您的新项目文件的目录。您应该在这里看到您的`.uproject`文件，以及您的`Config`和`Content`目录。
- en: 'Create a new directory here named `Plugins`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里创建一个名为`Plugins`的新目录：
- en: '![](img/0b79cacd-6685-4290-88ac-40ea82cbc786.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b79cacd-6685-4290-88ac-40ea82cbc786.png)'
- en: Now that we've created a `Plugins` directory for our project, let's add the
    VRExpansion plugin to it. There are a few ways we can do this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为项目创建了一个`Plugins`目录，让我们将VRExpansion插件添加到其中。我们有几种方法可以做到这一点。
- en: Installing using precompiled binaries
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预编译的二进制文件进行安装
- en: 'The easiest way to get the plugin is to navigate to its forum discussion, [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin),
    and use the Plugin Pre-built Downloads link for your engine version:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 获取插件的最简单方法是导航到其论坛讨论页面，[https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin)，并使用适用于您的引擎版本的插件预构建下载链接：
- en: Hit the Full Binaries and Source Package link for your engine version and download
    the zipped plugin
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完整的二进制和源代码包链接，下载压缩的插件
- en: Once the download has completed, open the `.zip` file and drag the `VRExpansionPlugin`
    directory contained within it into your `Plugins` directory
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，打开`.zip`文件，并将其中包含的`VRExpansionPlugin`目录拖到您的`Plugins`目录中
- en: That's it. As long as you installed the plugin version that was built for your
    engine version, you're ready to go and can open up your project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。只要安装了适用于您的引擎版本构建的插件版本，您就可以开始并打开您的项目。
- en: Compiling your own plugin binaries
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译自己的插件二进制文件
- en: 'If you need newer code for the plugin than what''s included in the pre-built
    binaries (which you will if you''re running a preview version of the engine),
    you''re going to need to build your plugin binaries on their own. This isn''t
    hard to do:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要插件的更新代码，而预构建的二进制文件中没有包含（如果您正在运行引擎的预览版本，则需要），您需要单独构建插件的二进制文件。这并不难：
- en: Navigate to the VRExpansionPlugin depot on BitBucket here: [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里导航到VRExpansionPlugin存储库的BitBucket：[https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
- en: Hit the Downloads link and hit the Download repository link to download a zipped
    version of the depot
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载链接，然后点击下载存储库链接，下载一个压缩版本的存储库
- en: It's also possible to clone the plugin's Git depot directly into your project's
    plugins directory, but unless you're working on the bleeding edge and need absolutely
    up-to-date code, you don't really need to do this. You will want to do this if
    you're planning to contribute your own changes to the plugin. For most users,
    though, it's easier to download the zipped repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接将插件的Git存储库克隆到项目的插件目录中，但除非你正在进行最新的工作并且需要绝对最新的代码，否则你不需要这样做。如果你计划对插件进行自己的更改，你将需要这样做。然而，对于大多数用户来说，下载压缩的存储库更容易。
- en: Now open up the `.zip` file you just downloaded.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开刚刚下载的`.zip`文件。
- en: You'll see a folder inside it named something like `mordentral-vrexpansionplugin-9c1737a17bef`
    (the hash at the end will be different)—drag this into your new `Plugins` directory.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个文件夹，里面的名字类似于`mordentral-vrexpansionplugin-9c1737a17bef`（末尾的哈希值会不同）-将其拖到你的新`Plugins`目录中。
- en: 'Change the name of the directory you just extracted to `VRExpansionPlugin`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚解压的目录的名称更改为`VRExpansionPlugin`：
- en: '![](img/3640ba69-20cb-4b39-abca-58d50bc2ff46.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3640ba69-20cb-4b39-abca-58d50bc2ff46.png)'
- en: Now launch your project, or if it was already open, close it and re-open it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动您的项目，或者如果它已经打开，请关闭并重新打开它。
- en: 'A dialog should now appear indicating that you need to build your plugin binaries:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该会出现一个对话框，指示您需要构建插件的二进制文件：
- en: '![](img/c7bc58fe-e057-43f2-a48b-2d9be7d295fb.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7bc58fe-e057-43f2-a48b-2d9be7d295fb.png)'
- en: If you set up Visual Studio Community 2017 as directed in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting Up Your Development Environment*, this isn't a problem. (If you didn't,
    jump back there now and follow the directions to set it up. It's always worth
    it to have a working compiler set up on your system because you will sometimes
    need it.) Say Yes and let Visual Studio build new binaries for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中的指示设置了Visual Studio Community
    2017，那么这不是一个问题。（如果您没有，请立即返回那里并按照说明进行设置。在您的系统上设置一个工作的编译器总是值得的，因为有时您会需要它。）点击“是”并让Visual
    Studio为您构建新的二进制文件。
- en: Your plugin should build successfully, but if it doesn't, navigate to the plugin's
    home page at [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
    and follow the instructions under *Basic Installation Step-By-Step*, which will
    take you through the manual build process. As mentioned earlier, you also have
    the option to download pre-built binaries from here: [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的插件应该能够成功构建，但如果不能，请转到插件的主页[https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)并按照“基本安装步骤”下的说明进行操作，这将引导您完成手动构建过程。正如之前提到的，您还可以选择从这里下载预构建的二进制文件：[https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin)。
- en: 'If you hit Show Log on the build dialog, you should be able to see your build
    progress. Expect it to take a few minutes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在构建对话框上点击“显示日志”，您应该能够看到构建进度。预计需要几分钟：
- en: '![](img/d7d29455-8f0b-48c8-b9f6-f7bffae5ed8e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7d29455-8f0b-48c8-b9f6-f7bffae5ed8e.png)'
- en: Once the build finishes, your project will open.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，您的项目将打开。
- en: Verifying the plugins in your project
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证项目中的插件
- en: Regardless of how you downloaded and installed the plugin, it should now be
    available to you once you've opened the project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是如何下载和安装插件的，一旦您打开项目，它现在应该可用。
- en: 'On opening the project, you should see two indicators in the lower-right corner
    indicating that you have new plugins available and asking whether you want to
    update your project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目时，您应该在右下角看到两个指示，表示您有新的插件可用，并询问您是否要更新项目：
- en: '![](img/20ee2192-5b15-4ef8-94ee-0a8de82ec578.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20ee2192-5b15-4ef8-94ee-0a8de82ec578.png)'
- en: Hit Manage Plugins... to open the plugins list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“管理插件...”打开插件列表。
- en: 'You should see two entries for the VRExpansion plugin, and they should both
    be enabled:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到两个VRExpansion插件条目，并且它们都应该已启用：
- en: '![](img/9948cdb0-158e-43df-9035-33fbaf476014.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9948cdb0-158e-43df-9035-33fbaf476014.png)'
- en: This is as it should be, so we can close this window.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应该的，所以我们可以关闭这个窗口。
- en: Now, let's update our project file by hitting the Update button.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过点击“更新”按钮来更新我们的项目文件。
- en: 'Remember that your `.uproject` file is really just a text file telling Unreal
    a few basic things about your project. If you open it up in a text editor, you''ll
    see that new entries were added indicating that this project now relies on the
    VRExpansion plugin and its companion OpenVRExpansion plugin:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的`.uproject`文件实际上只是一个文本文件，向虚幻引擎提供有关项目的一些基本信息。如果您在文本编辑器中打开它，您会看到添加了新条目，指示该项目现在依赖于VRExpansion插件及其伴生的OpenVRExpansion插件：
- en: '![](img/41e2d270-b5d6-48a0-b8a2-65902c7cf7a0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41e2d270-b5d6-48a0-b8a2-65902c7cf7a0.png)'
- en: This is a text comparison of the .uproject file before and after we added the
    VRExpansion plugin
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在添加VRExpansion插件之前和之后的.uproject文件的文本比较
- en: That's it. We're ready to start developing using the plugin, but before we do,
    let's talk a little bit about what we just did.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经准备好使用插件进行开发了，但在开始之前，让我们稍微谈一下我们刚刚做了什么。
- en: Understanding plugins
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解插件
- en: Plugins are an important part of the Unreal ecosystem. They can contain content,
    blueprints, native code, and anything else that affects what Unreal Engine can
    do and how it does it. They can save you tremendous amounts of time and extend
    the engine's capabilities almost infinitely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是虚幻生态系统的重要组成部分。它们可以包含内容、蓝图、本地代码和任何其他影响虚幻引擎能够做什么以及如何做的东西。它们可以节省大量时间，并几乎无限地扩展引擎的功能。
- en: For the most part, you really don't need to know much about how Unreal handles
    plugins to use them—they pretty much just work, but if you want to be able to
    fix things if something goes wrong, or if you need to update a plugin to accommodate
    a new engine version, it is helpful to know a little bit about where they live
    and how they're put together. We're not going to go too deep into the weeds here,
    but there are a few quick things to point out that will help you in your future
    development. (If you do need to get deeper into how plugins are developed, begin
    with the documentation here: [https://docs.unrealengine.com/en-us/Programming/Plugin](https://docs.unrealengine.com/en-us/Programming/Plugins))
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您实际上不需要了解虚幻引擎如何处理插件才能使用它们-它们基本上只是工作的，但如果您想要能够在出现问题时修复问题，或者如果您需要更新插件以适应新的引擎版本，了解一些关于插件存放位置和组成方式的知识是有帮助的。我们不会在这里深入探讨，但有一些快速要点可以帮助您进行未来的开发。（如果您确实需要深入了解插件的开发，请从这里开始阅读文档：[https://docs.unrealengine.com/en-us/Programming/Plugin](https://docs.unrealengine.com/en-us/Programming/Plugins)）
- en: Where plugins live
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的位置
- en: First, it's important to know where to put new plugins that you want to install
    to a project or the engine and to know where plugins downloaded from the Epic
    Games launcher will be placed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要知道将要安装到项目或引擎的新插件放在哪里，并知道从Epic Games启动器下载的插件将被放置在哪里。
- en: 'Any plugin you install will live in one of two places: in a `Plugins` directory
    in your project for plugins that are installed just to that specific project or
    in an `Engine\Plugins` directory for plugins that are installed to the engine
    and apply to all projects.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您安装的任何插件都将位于两个位置之一：对于仅安装到特定项目的插件，它们将位于项目的`Plugins`目录中，对于安装到引擎并适用于所有项目的插件，它们将位于`Engine\Plugins`目录中。
- en: 'Take a moment to look at your currently-installed engine plugins as given in
    the following step:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间查看以下步骤中给出的当前安装的引擎插件：
- en: 'Open the directory where you installed Unreal Engine (by default, this will
    be in `C:\Program Files\Epic Games`), and open the `Engine\Plugins` subdirectory:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您安装虚幻引擎的目录（默认情况下，这将位于`C:\Program Files\Epic Games`），然后打开`Engine\Plugins`子目录：
- en: '![](img/4c960396-7c47-40fb-bbe8-c3f5dc0ef038.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c960396-7c47-40fb-bbe8-c3f5dc0ef038.png)'
- en: 'Here you''ll notice something interesting: many features of the engine, even
    those we think of as core engine capabilities, such as effects editors, are really
    plugins living within the Unreal framework. That''s worth remembering. Plugins
    aren''t second-class citizens in Unreal Engine. Adding something to the engine
    through a plugin is really not meaningfully different than writing it directly
    into the engine code, except that it''s easier to replace it or to turn it on
    or off if it''s set up this way.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会注意到一些有趣的事情：引擎的许多功能，甚至我们认为是核心引擎功能的东西，例如特效编辑器，实际上都是作为插件存在于虚幻框架中。这值得记住。在虚幻引擎中，插件并不是二等公民。通过插件将某些东西添加到引擎中与直接将其编写到引擎代码中并没有实质性的区别，只是如果以这种方式设置，更容易替换、打开或关闭它。
- en: Plugins you download through the Epic Games launcher will appear in the Marketplace
    subdirectory of your `Engine\Plugins` directory. In general, the Epic Games launcher
    will alert you when a plugin you've installed from the launcher has an update
    available, and you can update it directly from within the launcher. You'll rarely,
    if ever, need to open your `Engine\Plugins` directory, but it's worth knowing
    that it's there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Epic Games启动器下载的插件将出现在`Engine\Plugins`目录的“市场”子目录中。通常情况下，Epic Games启动器会在您从启动器安装的插件有可用更新时提醒您，并且您可以直接从启动器中更新它。您很少需要打开`Engine\Plugins`目录，但了解它的存在是值得的。
- en: Installing plugins from the Marketplace
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从市场安装插件
- en: 'To install a plugin using the Epic Games launcher, select the plugin you want
    from the Marketplace or from your Library, and hit the Install to Engine button,
    or if the plugin has been configured as an asset pack, hit the Add to Project button
    instead. Install to Engine will put the plugin in your engine install''s `Engine\Plugins\Marketplace`
    directory, while Add to Project will put it in your project''s `Plugins` directory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Epic Games启动器安装插件，从“市场”或“库”中选择您想要的插件，然后点击“安装到引擎”按钮，或者如果插件已配置为资源包，则点击“添加到项目”按钮。将插件安装到引擎将把它放在引擎安装的`Engine\Plugins\Marketplace`目录中，而将其放在项目的`Plugins`目录中则点击“添加到项目”按钮：
- en: '![](img/875a3ba1-e363-4b64-9660-8847a04f445f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/875a3ba1-e363-4b64-9660-8847a04f445f.png)'
- en: The Epic Games launcher will alert you automatically if a plugin you've installed
    using the tool has an update available.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用该工具安装的插件有可用的更新，Epic Games启动器将自动提醒您。
- en: What's inside a plugin?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的内部是什么？
- en: Now that we know a bit about where plugins live in Unreal Engine, let's take
    a look at what they're made of.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了虚幻引擎中插件的存放位置，让我们来看看它们由什么组成。
- en: 'To do this, we''re going to do a quick exploration of the VRExpansion plugin
    we installed to our project''s `Plugins` directory:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将快速探索一下我们安装到项目的`Plugins`目录中的VRExpansion插件：
- en: Open up your project's `Plugins` directory, and open up the `VRExpansionPlugin`
    directory within it
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目的`Plugins`目录，然后打开其中的`VRExpansionPlugin`目录
- en: 'You''ll see that VRExpansion actually consists of two separate plugins within
    this directory: `VRExpansionPlugin` and `OpenVRExpansionPlugin`. The latter exists
    to support Valve Software''s OpenVR SDK. For our purposes here, we''re not going
    to worry about it and we''ll just focus on VRExpansion.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到VRExpansion实际上由此目录中的两个单独的插件组成：`VRExpansionPlugin`和`OpenVRExpansionPlugin`。后者存在是为了支持Valve
    Software的OpenVR SDK。在这里，我们不需要担心它，我们只关注VRExpansion。
- en: There are two files here that we should take a moment to mention.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个文件，我们应该花点时间提及一下。
- en: The first is the `README.md` file. Take a moment to open it up. This is a markdown
    file containing some basic information about the plugin.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`README.md`文件。请花点时间打开它。这是一个包含有关插件的一些基本信息的markdown文件。
- en: If you have Visual Studio Code installed on your system, you can use VSCode
    to open markdown files. Once the file is open, you can right-click on its tab
    in the viewing area and select Open Preview, or just hit *Ctrl* + *Shift* + *V*
    to view the markdown with formatting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上安装了Visual Studio Code，您可以使用VSCode打开markdown文件。打开文件后，您可以右键单击查看区域中的选项卡，然后选择“打开预览”，或者只需按下*Ctrl*
    + *Shift* + *V*以带格式查看markdown。
- en: You'll see that this `readme` file basically recreates the text on the main
    BitBucket page here: [https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)
    and links to instruction and information pages. Many plugins will come with documentation
    or `readme` files that tell you where to find the documentation. It's worth it
    to take a look.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到这个`readme`文件基本上重新创建了主BitBucket页面上的文本：[https://bitbucket.org/mordentral/vrexpansionplugin](https://bitbucket.org/mordentral/vrexpansionplugin)，并链接到指令和信息页面。许多插件都附带有文档或`readme`文件，告诉您如何找到文档。值得一看。
- en: About licenses
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于许可证
- en: The other file we should look at here is the `LICENSE.txt` file. If you're going
    to include a plugin in your project, it's important to know how you're allowed
    to use it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们还应该看一下`LICENSE.txt`文件。如果您要在项目中包含插件，了解如何使用它是很重要的。
- en: If you've downloaded a plugin through the Marketplace, you don't need to worry
    about it. All plugins distributed through Epic's Marketplace are licensed for
    non-commercial or commercial use and don't place any additional restrictions on
    how they can be used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过市场下载了一个插件，你不需要担心它。通过Epic的市场分发的所有插件都可以用于非商业或商业用途，并且不会对它们的使用方式施加任何额外的限制。
- en: If you need more information about licensing for plugins on the Marketplace,
    the details live here: [https://www.unrealengine.com/en-US/marketplace-distribution-agreement](https://www.unrealengine.com/en-US/marketplace-distribution-agreement).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于市场上插件许可证的信息，详细信息在这里：[https://www.unrealengine.com/en-US/marketplace-distribution-agreement](https://www.unrealengine.com/en-US/marketplace-distribution-agreement)。
- en: If you're downloading a plugin directly from the net, as we did previously,
    you need to check the license and make sure the author allows you to use the plugin
    in the way you want to use it. Most plugin authors will not put restrictions on
    the way you use the software, but always read the license and make sure. You don't
    want to build a project with a plugin at its foundation only to discover when
    it's time to sell the software that you're not actually allowed to do so. Read
    the license first.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从网络上直接下载插件，就像我们之前做的那样，你需要检查许可证并确保作者允许你按照你想要的方式使用插件。大多数插件作者不会对你使用软件的方式施加限制，但总是阅读许可证并确保。你不想在构建一个以插件为基础的项目时，发现在销售软件时你实际上是不被允许这样做的。先阅读许可证。
- en: Be especially careful of software licensed under the GNU **General Public License**
    (**GPL**)—this license places significant restrictions on the software in which
    it can be used and isn't compatible with Unreal Engine's licensing terms. The
    much more permissive **MIT** and **Apache** licenses, however, are fine, and you'll
    encounter many Unreal plugins that use them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要小心使用GNU**通用公共许可证**（**GPL**）许可的软件，这个许可证对软件的使用施加了重要的限制，并且与虚幻引擎的许可条款不兼容。然而，更宽松的**MIT**和**Apache**许可证是可以的，你会遇到很多使用它们的虚幻插件。
- en: In our case, the license for VRExpansion plugin allows you to do pretty much
    anything you want (other than removing the license file and trying to pretend
    that the work was your own), including modifying the plugin's code. It places
    no restrictions on the kind of project you use it for in terms of content or commercial
    versus non-commercial use. This is ideal. Whether we're making our project for
    sale as a commercial game, using it for live performance, just building as a hobby,
    or whatever, we're fine.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，VRExpansion插件的许可证允许你几乎做任何你想做的事情（除了删除许可证文件并试图假装这是你自己的作品），包括修改插件的代码。它对你使用它的项目的内容或商业与非商业使用没有任何限制。这是理想的。无论我们是将项目作为商业游戏出售，还是用于现场演出，只是作为一种爱好建设，或者其他任何情况，都没有问题。
- en: Inside a plugin directory
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在插件目录中
- en: If we now open up the `VRExpansionPlugin` directory within the outer `VRExpansionPlugin`
    directory, we'll see a directory structure that looks a lot like the structure
    for an Unreal project. This isn't accidental. You can pretty much think of plugins
    almost as though they are mini projects being inserted into your project. They
    can contain code, blueprints, or assets and other content just as a project can.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开外部`VRExpansionPlugin`目录中的`VRExpansionPlugin`目录，我们会看到一个非常类似于虚幻项目结构的目录结构。这并非偶然。你可以将插件几乎看作是被插入到项目中的迷你项目。它们可以包含代码、蓝图或资产和其他内容，就像一个项目一样。
- en: 'We''re not going to worry about the contents of this directory except to take
    a look at one thing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会关心这个目录的内容，只是看一下其中的一个东西：
- en: Open up the `VRExpansionPlugin.uplugin` file in a text editor
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`VRExpansionPlugin.uplugin`文件
- en: 'You''ll see that this file, just like your `.uproject` files, is just a text
    file containing information about your plugin. It''s rare that you''re ever going
    to need to open this file up, but just as with your `.uproject` files, you should
    know about it if you ever need to debug something or change something by hand:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这个文件，就像你的`.uproject`文件一样，只是一个包含有关插件信息的文本文件。你很少需要打开这个文件，但就像你的`.uproject`文件一样，如果你需要手动调试或更改某些内容，你应该知道它：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the information in here is just descriptive, but there''s one important
    detail: the `Plugins` block is used to specify dependencies between a plugin and
    other plugins. In this case, we can see that the `VRExpansion` plugin requires
    the `PhysXVehicles` plugin to be enabled. This shouldn''t be a problem because
    it''s on by default, but if you ever run into an instance where a plugin isn''t
    working, take a look at what it depends on and make sure those plugins are present
    as well.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分信息只是描述性的，但有一个重要的细节：`Plugins`块用于指定插件与其他插件之间的依赖关系。在这种情况下，我们可以看到`VRExpansion`插件需要启用`PhysXVehicles`插件。这不应该是个问题，因为它默认是启用的，但如果你遇到插件无法工作的情况，看看它依赖于什么，并确保这些插件也存在。
- en: 'There''s one other property you''ll sometimes run into. Some plugins specify
    an engine version that they''re allowed to work with, using an `EngineVersion` entry
    that looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个你可能会遇到的属性。一些插件会指定它们可以使用的引擎版本，使用一个看起来像这样的`EngineVersion`条目：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If a plugin contains this entry, Unreal will only allow it to load with the
    engine version specified here. (You can *sometimes* get around this by modifying
    this value by hand in your `.uplugin` file, but whether the plugin will compile
    and work will depend entirely on what's in it and what's changed in the engine
    version for which you're trying to compile it.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个插件包含这个条目，虚幻将只允许它与指定的引擎版本一起加载。（你可以通过手动修改`.uplugin`文件中的这个值来绕过这个限制，但插件是否能编译和工作将完全取决于其中的内容以及你尝试编译的引擎版本中发生了什么变化。）
- en: Finishing our brief tour
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束我们的简短之旅
- en: This has been a quick look at how Unreal plugins are installed and what's inside
    them. As we mentioned earlier, through most of your development, you won't need
    to mess with any of this, but when you do need to figure out what's going on with
    your software, it can be invaluable to know where to begin looking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速了解虚幻插件安装和内部内容的过程。正如我们之前提到的，在大部分开发过程中，你不需要去处理这些内容，但当你需要弄清楚软件的情况时，知道从哪里开始查找是非常有价值的。
- en: With this, then, let's move on and start working in VR.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们继续在VR中工作吧。
- en: Exploring the VRExpansion example project
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索VRExpansion示例项目
- en: Before we jump back into our own project, we're going to take one more detour
    to look at the example project maintained alongside the VRExpansion plugin, so
    we can see what sorts of things this plugin is going to let us do. We're also
    going to accelerate some of our development through this chapter by using blueprints
    from this project, so don't skip this step.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到自己的项目之前，我们将再次进行一次绕道，看看与VRExpansion插件一起维护的示例项目，这样我们就可以看到这个插件能让我们做什么样的事情。我们还将通过使用这个项目中的蓝图来加速本章的一些开发，所以不要跳过这一步。
- en: 'Let''s begin by downloading it from here: [https://bitbucket.org/mordentral/vrexppluginexample/downloads/](https://bitbucket.org/mordentral/vrexppluginexample/downloads/).
    Follow the given steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这里开始下载它：[https://bitbucket.org/mordentral/vrexppluginexample/downloads/](https://bitbucket.org/mordentral/vrexppluginexample/downloads/)。按照给定的步骤进行：
- en: Hit the Download repository link to download a zipped version of the project
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载存储库链接以下载项目的压缩版本
- en: Unzip the downloaded project to wherever you keep your Unreal example projects
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的项目解压到你保存虚幻示例项目的任何位置
- en: Open up the project directory, right-click `VRExpPluginExample.uproject`, and
    from the context menu, select Switch Unreal Engine version...
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目目录，右键点击`VRExpPluginExample.uproject`，从上下文菜单中选择切换虚幻引擎版本...
- en: Set it to your current Unreal Engine version
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为你当前的虚幻引擎版本
- en: Because this project was created as a C++ project, a Visual Studio solution
    file will also be created for you when you set a new engine version association.
    You don't need to work in C++ to use this plugin. Everything in the project itself
    was created using blueprints on top of the plugin, and this is how we're going
    to build our project as well, but if you're interested in digging deeper into
    the C++ classes and seeing how the plugin was built, this solution file offers
    a good way to do this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目是作为一个C++项目创建的，当你设置一个新的引擎版本关联时，Visual Studio也会为你创建一个解决方案文件。你不需要使用C++来使用这个插件。项目本身中的所有内容都是在插件之上使用蓝图创建的，这也是我们将要构建项目的方式，但如果你对C++类有兴趣并想看看插件是如何构建的，这个解决方案文件提供了一个很好的方法。
- en: Try launching the project. It may ask you to build its included plugins. Let
    it. (Again, be sure you installed and set up Visual Studio according to the directions
    in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml), *Setting Up Your Development
    Environment*.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试启动项目。它可能会要求你构建其中包含的插件。让它去做吧。（再次确保你按照[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中的指示安装和设置了Visual
    Studio，*设置开发环境*。）
- en: 'Once the project launches, let it compile the shaders, and then explore a bit
    to see what it offers. It should become apparent fairly quickly that VRExpansion
    offers a tremendous leg-up to VR developers. It''s a treasure trove of professionally-written
    code and Blueprint examples of things you can do in VR, and numerous professionally-made
    and released games have used this plugin or parts of it in their development:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 项目启动后，让它编译着色器，然后探索一下看看它提供了什么。很快就会明显，VRExpansion为VR开发者提供了巨大的帮助。它是一个宝库，里面有专业编写的代码和蓝图示例，展示了你可以在VR中做的各种事情，许多专业制作和发布的游戏都在开发中使用了这个插件或其中的部分内容：
- en: '![](img/5f4aabf0-9b7e-4d52-93ea-ee17077d47ec.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f4aabf0-9b7e-4d52-93ea-ee17077d47ec.png)'
- en: A view of the VR Expansion Plugin's test project. You'll find a wealth of useful
    VR development examples in here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: VR扩展插件测试项目的视图。你会在这里找到大量有用的VR开发示例。
- en: Play around in here. We're not going to cover everything in this example project,
    since we're about to begin building our own, but you won't be wasting your time
    to explore enough to come away with a good sense of what's included and what you
    could re-purpose for your own applications.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里玩一下。我们不会覆盖这个示例项目中的所有内容，因为我们即将开始构建我们自己的项目，但是探索一下足够让你对其中包含的内容有一个很好的了解，并且你可以为自己的应用程序重新定制一些东西。
- en: 'Here are a few tips to get you started:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议，帮助你开始：
- en: Your controller's D-Pad or thumbstick triggers teleport movement, just as it
    did in our own examples
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的控制器的D-Pad或拇指杆触发传送移动，就像我们自己的示例中一样。
- en: Squeezing the controller grips when you don't have an object in your hand changes
    your movement modes
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你手中没有物体时，挤压控制器抓握会改变你的移动模式
- en: 'We strongly encourage you now to spend some time experimenting with each movement
    mode. Teleportation and DPadPress-ControllerOrient modes will be familiar to you
    from the locomotion project we built earlier. Others will be new to you. Play
    with them and get ideas:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你现在花些时间尝试每种移动模式。传送和DPadPress-ControllerOrient模式对你来说应该很熟悉，因为我们之前构建的定位项目中有这些模式。其他模式对你来说可能是新的。尝试一下并得到一些想法：
- en: Many objects can be gripped and used. Use the triggers to grip.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多物体可以被抓住和使用。使用扳机进行抓握。
- en: White objects can be gripped and climbed.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色物体可以被抓住和攀爬。
- en: The player character does a nice job of handling cases where players shove their
    heads through walls. Try it.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家角色在处理玩家将头伸进墙壁的情况时做得很好。试试看。
- en: The Barf Platform lives up to its name. (If you recall our discussions from
    [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Th**inking in VR*, you'll
    understand why.)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呕吐平台名副其实。（如果你还记得我们在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中的讨论，*在VR中思考*，你就会明白为什么。）
- en: Consider this example project to be a major resource as you learn what this
    plugin allows you to do. As a result of the work you've done in this book, you
    should be set up well to understand what you're seeing in the blueprints and to
    use them as starting points to develop further.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例项目视为一个重要的资源，因为您将了解到此插件允许您做什么。由于您在本书中所做的工作，您应该能够很好地理解蓝图中所看到的内容，并将其用作进一步开发的起点。
- en: Now, let's jump in and build our own project using this plugin as a basis for
    our own work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个插件作为我们自己工作的基础，来构建我们自己的项目。
- en: Finishing our project setup
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成项目设置
- en: Now that we have our project set up, the VRExpansion plugin installed, and a
    basic understanding of what plugins are, let's jump back into building content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的项目，安装了VRExpansion插件，并对插件有了基本的了解，让我们回到构建内容的过程中。
- en: 'First, of course, we need to set our project settings appropriately for VR:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们首先需要适当地设置我们的项目设置以用于VR：
- en: Project | Description | Settings | Start in VR: False
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 | 描述 | 设置 | 在VR中启动：False
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 正向渲染器 | 正向着色：True
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 环境光遮蔽静态分数：False
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 实例化立体声：True
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 轮询遮挡查询：True
- en: 'Now let''s give ourselves an environment to play in:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给自己一个可以玩耍的环境：
- en: 'Find the soul: Cave environment pack in the marketplace and add it to your
    new project. (It''s fine to do this while your project is open.)'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在市场中找到灵魂：洞穴环境包，并将其添加到您的新项目中。（在项目打开时这样做是可以的。）
- en: Once the environment pack has finished downloading, open up your project if
    it wasn't already open.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦环境包下载完成，如果项目还没有打开，请打开您的项目。
- en: Under `Content/SoulCave/Maps`, find the LV_Soul_Cave_Mobile level and open it.
    Let your shaders compile.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content/SoulCave/Maps`下，找到LV_Soul_Cave_Mobile级别并打开它。让您的着色器编译。
- en: 'While this is happening, let''s set this as your project''s default level:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，让我们将其设置为您项目的默认级别：
- en: Open Settings | Project Settings | Project | Maps & Modes, and set Editor Startup
    Map and Game Default Map to LV_Soul_Cave_Mobile
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置 | 项目设置 | 项目 | 地图和模式，并将编辑器启动地图和游戏默认地图设置为LV_Soul_Cave_Mobile
- en: Once your shaders have finished compiling, we can get down to work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的着色器编译完成，我们就可以开始工作了。
- en: Using VRExpansion classes
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VRExpansion类
- en: We're going to use this project both as a review of the things we need to do
    when we set up a scene for VR and as an introduction to the VRExpansion classes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个项目作为回顾我们在为VR设置场景时需要做的事情，并作为VRExpansion类的介绍。
- en: Adding navigation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加导航
- en: The first thing we're going to need to do, of course, now that we have our environment,
    is set it up with a nav mesh so we'll have the option to use teleport locomotion
    and so AI characters can navigate through it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们已经有了我们的环境，我们首先要做的事情是设置一个导航网格，这样我们就可以选择使用传送定位和让AI角色在其中导航。
- en: 'Begin by checking your collision environment:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查你的碰撞环境：
- en: Hit *Alt* + *C* (or the from the viewport, Show | Collision) to visualize your
    collision environment and make sure it looks sensible.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *C*（或从视口中选择Show | Collision）来可视化你的碰撞环境，并确保它看起来合理。
- en: The collision here looks good, so let's add a Nav Mesh Bounds Volume to the
    scene.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的碰撞看起来不错，所以让我们在场景中添加一个导航网格边界体。
- en: Drag a Nav Mesh Bounds Volume into the scene and scale it to encompass the areas
    where you want your player to be able to navigate.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个导航网格边界体拖入场景并缩放它以包含您希望玩家能够导航的区域。
- en: 'The following values work reasonably well: Location (X= -11420.0, Y= -3790.0,
    Z= -490.0), and Scale (X= 100.0, Y= 160.0, Z= 20.0).'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下数值效果较好：位置（X= -11420.0，Y= -3790.0，Z= -490.0），缩放（X= 100.0，Y= 160.0，Z= 20.0）。
- en: Remember that you can make your life easier when setting up volumes by using
    the viewport's top and side views to make sense of what you're doing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在设置体积时，您可以使用视口的顶部和侧面视图来理解您正在做的事情，从而使您的工作更加轻松。
- en: The resulting navmesh is going to cover a lot of spots where you're not going
    to want players to navigate, so remember to use Nav Modifier Volumes to block
    out undesirable teleport destinations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的导航网格将覆盖许多您不希望玩家导航的地方，因此请记住使用导航修改器体积来阻止不希望的传送目的地。
- en: Adding a game mode
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个游戏模式
- en: 'As always, we''re going to want to set up a game mode for our project to specify
    which classes to load and to handle any rules we want to apply to our game:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们将为我们的项目设置一个游戏模式，以指定要加载的类并处理我们想要应用于游戏的任何规则：
- en: Create a directory for your project inside the `Content` directory, and then
    create a blueprints directory inside this.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`目录中为您的项目创建一个目录，然后在其中创建一个蓝图目录。
- en: Create a new Blueprint Class inside this directory and use Game Mode Base as
    its parent. Name it `BP_VRExpansionGameMode`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中创建一个新的蓝图类，并将其父类设置为Game Mode Base。将其命名为`BP_VRExpansionGameMode`。
- en: Open Settings | Project Settings | Project | Maps & Modes, and set the Default
    GameMode to the new game mode you just created.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置 | 项目设置 | 项目 | 地图和模式，并将默认游戏模式设置为您刚刚创建的新游戏模式。
- en: Open the World Settings for your map and reset Game Mode | GameMode Override
    to clear it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您地图的世界设置，并重置游戏模式 | 游戏模式覆盖以清除它。
- en: We'll be revisiting our new game mode multiple times as we add new classes based
    on the VRExpansion classes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们基于VRExpansion类添加新类，我们将多次回顾我们的新游戏模式。
- en: Updating the PlayerStart class
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新PlayerStart类
- en: 'The VRExpansion plugin provides a new player start class that''s scaled more
    accurately for the `VRCharacter` we''re going to spawn, so it represents more
    accurately where the player can fit. We''re going to use it here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: VRExpansion插件提供了一个新的玩家起始类，它更准确地缩放了我们要生成的`VRCharacter`，因此更准确地表示了玩家可以适应的位置。我们将在这里使用它：
- en: Drag a VRPlayerStart into your scene near the existing `PlayerStart` actor.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个VRPlayerStart拖动到场景中现有的“PlayerStart”演员附近。
- en: From the old `PlayerStart` Details, right-click its Transform | Location, and
    copy the value.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旧的“PlayerStart”详细信息中，右键单击其Transform | Location，并复制该值。
- en: Delete the old `PlayerStart`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除旧的“PlayerStart”。
- en: Select the VRPlayerStart and in its Details, right-click its Transform | Location,
    and paste in the value you copied from the old one.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择VRPlayerStart，在其详细信息中，右键单击其Transform | Location，并粘贴从旧位置复制的值。
- en: Move it down a bit to place it on the floor. (X= -20220.0, Y= -13080.0, Z= -2118.0)
    works pretty well.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其向下移动一点以放置在地板上。（X= -20220.0，Y= -13080.0，Z= -2118.0）效果还不错。
- en: Adding a VR character
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个VR角色
- en: 'Now it''s time to add a VR-enabled character to our project. The `VRExpansion`
    plugin gives us two new classes from which we can derive a character for use in
    VR:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们的项目添加一个VR启用的角色了。VRExpansion插件为我们提供了两个新的类，我们可以从中派生出一个用于VR的角色：
- en: '`VRSimpleCharacter` is a base class for VR-enabled characters that automatically
    sets up two `GripControllers`, a network-replicated VR camera, and implements
    a movement component specifically designed for use in VR.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “VRSimpleCharacter”是一个为VR启用的角色提供基础功能的基类，它自动设置了两个“GripControllers”，一个网络复制的VR摄像机，并实现了专为VR使用的移动组件。
- en: '`VRCharacter` includes everything found in `VRSimpleCharacter`, but adds a
    few additional methods to offset the collision by neck location and support more
    significant re-scaling of the character''s collision capsule.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “VRCharacter”包括“VRSimpleCharacter”中的所有内容，但还添加了一些额外的方法来通过颈部位置偏移碰撞，并支持角色碰撞胶囊的更大缩放。
- en: In general, unless you're sure you need to use the neck collision offset or
    you're going to be radically changing the collision capsule size, use `VRSimpleCharacter`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除非您确定需要使用颈部碰撞偏移或者您将大幅改变碰撞胶囊的大小，否则请使用“VRSimpleCharacter”。
- en: 'Let''s do this now:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来做这个：
- en: From within the blueprints directory where you placed your GameMode, right-click
    to create a new Blueprint Class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置GameMode的蓝图目录中，右键单击创建一个新的蓝图类。
- en: Expand the All Classes expander, and in the search box, type `vr char`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开所有类扩展器，在搜索框中键入“vr char”。
- en: 'You''ll see the `VRCharacter` and VRSimpleCharacter classes listed. Select
    VRSimpleCharacter. Name the new blueprint `BP_VRCharacter`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到列出了“VRCharacter”和“VRSimpleCharacter”类。选择“VRSimpleCharacter”。将新的蓝图命名为“BP_VRCharacter”：
- en: '![](img/d5266a44-3f4c-4da0-bab0-eb7bc953275f.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5266a44-3f4c-4da0-bab0-eb7bc953275f.png)'
- en: Now, open up your Game Mode and set `BP_VRCharacter` as its Default Pawn Class.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开您的游戏模式并将“BP_VRCharacter”设置为其默认的Pawn类。
- en: Run the map. You won't be able to move around yet, but you should be properly
    registered to the floor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行地图。您现在还无法移动，但应该已经正确注册到地板上。
- en: Setting up input
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置输入
- en: Now that our character is in place and our game mode has been told to spawn
    it, let's allow our player to control it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的角色已经就位，游戏模式已被告知生成它，让我们允许玩家控制它。
- en: 'First, we''re going to need to map some inputs. If we wanted to do this by
    hand, we would do this through Settings | Project Settings | Engine | Input, but
    to save a bit of time here, let''s just copy the `DefaultInput.ini` file from
    the VRExpansion sample project into ours:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要映射一些输入。如果我们想手动完成这个过程，我们可以通过设置 | 项目设置 | 引擎 | 输入来完成，但为了节省一些时间，让我们将“DefaultInput.ini”文件从VRExpansion示例项目复制到我们的项目中：
- en: Open the directory where you unzipped the VRExpansion example project, and copy
    the `DefaultInput.ini` file from its `Config` directory
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解压VRExpansion示例项目的目录，并从其“Config”目录中复制“DefaultInput.ini”文件。
- en: Open your current project directory and paste `DefaultInput.ini` into it
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开当前项目目录并将“DefaultInput.ini”粘贴到其中
- en: Re-open your working project. Of course, if we were building our own game, we
    would design our own input scheme for it, but this gives us a quick way to have
    a few inputs already mapped and ready to go for testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开您的工作项目。当然，如果我们正在构建自己的游戏，我们会为其设计自己的输入方案，但这样可以让我们快速地有一些已经映射好并准备好进行测试的输入。
- en: Setting up your VR character using example assets
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例资产设置您的VR角色
- en: Now, ordinarily we would walk through the process of building this character
    from the ground up, but we have a lot of material to get through here, so we're
    going to save ourselves a bit of time by migrating the example character from
    the VRExpansion example project into our own, and then we're going to dig into
    how it works.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通常情况下，我们会逐步介绍如何从头开始构建这个角色，但是在这里我们有很多材料要介绍，所以我们将通过将VRExpansion示例项目中的示例角色迁移到我们自己的项目中，然后深入研究它的工作原理来节省一些时间。
- en: Making effective use of example assets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用示例资产
- en: This brings up a point worth mentioning about using plugins and example assets
    and code. Very often, libraries and plugins will ship with example assets that
    have already been designed to work with them. It's always a good idea to get familiar
    with these, as they show you the author's intention for how they expect their
    code to be used. It's often the case, too, that these assets will be pretty close
    right out of the box to what you need them to be, though they'll rarely be exactly
    what you need.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们一个值得一提的关于使用插件和示例资产和代码的问题。很多时候，库和插件会附带已经设计好与它们配合使用的示例资产。熟悉这些资产总是一个好主意，因为它们向您展示了作者对代码使用的期望。通常情况下，这些资产也会非常接近您所需要的，尽管它们很少会完全符合您的需求。
- en: There are two approaches you can take when making use of someone's example assets
    or code—you can incorporate the example wholesale, and then modify or remove anything
    that works differently than the way you want it to work, or you can build your
    own assets from scratch, using the example for guidance to see how the author
    recommends that you use their code. There are benefits and drawbacks to each approach.
    The first approach tends to get you working much earlier, but you'll often wind
    up with a lot of extra stuff that you don't need that then needs to be cleaned
    out. (Remember that we don't believe in cargo-cult programming here—you're not
    simply going to dump this code into your project and walk away without understanding
    it.) The second approach can take a more time, but gives you a clean class that
    does exactly what you need and only what you need, and that you understand fairly
    well because you wrote it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用他人的示例资产或代码时，有两种方法可以采取：您可以整体使用示例，然后修改或删除与您想要的方式不同的任何内容，或者您可以从头开始构建自己的资产，使用示例作为指导，了解作者建议您如何使用他们的代码。每种方法都有其优点和缺点。第一种方法往往可以让您更早地开始工作，但通常会得到许多不需要的额外内容，然后需要清理掉这些内容。（请记住，我们不相信这里的模仿编程——您不会简单地将这些代码倾倒到您的项目中并离开而不理解它。）第二种方法可能需要更多的时间，但可以为您提供一个干净的类，它只做您需要的事情，并且您对它的理解相当好，因为您自己编写了它。
- en: 'There''s a middle road too, which is the path we recommend. Remember Kent Beck''s
    advice: *Make it work; make it right; make it fast*? Consider using an existing
    example asset or class as part of your *make it work* phase. During this phase,
    you''re experimenting with the class as the author wrote it, and learning how
    it works and how it''s meant to be used. Then, once you have a handle on things,
    start pulling out the stuff you now know you don''t need, and changing things
    that need to work differently, until you have a version that does what you need
    it to do. Now, move into your *make it right* phase. Is it OK as it is? Could
    it be maintained easily? Would another engineer, or future-you, a year from now,
    be able to read this blueprint and understand what''s going on? Consider in light
    of these questions whether you want to write a new, parallel version of the class
    now that you have a workable template for how it should be built.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种中间道路，这是我们推荐的路径。记住肯特·贝克的建议：“让它工作；让它正确；让它快”？考虑在“让它工作”阶段使用现有的示例资产或类作为您的一部分。在这个阶段，您正在尝试使用作者编写的类，并学习它的工作原理和使用方法。然后，一旦您掌握了这些知识，开始删除您现在知道不需要的东西，并更改需要以不同方式工作的东西，直到您拥有一个能够满足您需求的版本。现在，进入“让它正确”的阶段。它现在可以吗？是否可以轻松维护？另一个工程师或未来的您一年后能否阅读这个蓝图并理解其中的内容？考虑到这些问题，您是否想要编写一个新的、并行的类版本，现在您已经有了一个可行的模板来构建它。
- en: Migrating the example pawn
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移示例角色
- en: 'In light of this approach, let''s migrate the example project''s VR character
    blueprint into our project so we can start experimenting with it and learn how
    it''s built:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种方法，让我们将示例项目的VR角色蓝图迁移到我们的项目中，以便我们可以开始尝试并了解它是如何构建的：
- en: From the `VRExpPluginExample` project, find the `Vive_PawnCharacter` blueprint
    in `Content/VRExpansion/Vive`, and migrate it into your new project's `Content`
    folder
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“VRExpPluginExample”项目中，在“Content/VRExpansion/Vive”中找到“Vive_PawnCharacter”蓝图，并将其迁移到您的新项目的“Content”文件夹中
- en: Don't worry about the Vive-centric name. This character works fine with the
    Oculus Rift and Windows Mixed Reality headsets as well. When this plugin was first
    written, only the Vive supported room-scale VR. Once Oculus added this support,
    the plugin was updated to accommodate it, but the example names were never changed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心Vive中心化的名称。这个角色也可以与Oculus Rift和Windows Mixed Reality头戴式显示器一起使用。当这个插件首次编写时，只有Vive支持房间规模的VR。一旦Oculus添加了这个支持，插件就会更新以适应它，但示例名称从未更改过。
- en: Return to your new project, and switch your Game Mode's Default Pawn Class to
    the `Vive_PawnCharacter` we just migrated in.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的新项目，并将您的游戏模式的默认角色类切换为我们刚刚迁移的“Vive_PawnCharacter”。
- en: We wanted to create the other VR character as an example to demonstrate that
    new classes introduced in plugins can be used just like any other engine class,
    but for the work we're actually going to do here, we're going to use the migrated
    character.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建另一个VR角色作为示例，以证明插件中引入的新类可以像任何其他引擎类一样使用，但对于我们实际要做的工作，我们将使用迁移的角色。
- en: 'Test it out. You should now be able to navigate through the environment using
    teleport, and you should be able to use the grip buttons to change your movement
    mode:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下。现在，您应该能够使用传送来浏览环境，并且应该能够使用抓握按钮来更改移动模式：
- en: '![](img/ddae8f2f-d912-48e8-9302-33cc4160b97f.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddae8f2f-d912-48e8-9302-33cc4160b97f.png)'
- en: Play around a bit with this, and then we're going to take a look under the hood.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微试验一下，然后我们将来看看内部情况。
- en: Making sense of complicated blueprints
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解复杂的蓝图
- en: Now that we have the basics working, let's do some digging and understand how
    this class was built. You should find, as we do this, that many of the techniques
    you'll see in this blueprint will make more sense as a result of the work you've
    done so far in this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的工作原理，让我们深入了解一下这个类是如何构建的。当我们这样做时，您会发现，在本书中迄今为止所做的工作，将使您更好地理解这个蓝图中的许多技术。
- en: The techniques we're going to explore here are valuable. If you work professionally
    in software development, or even if you work as a hobbyist, sooner or later, you're
    going to encounter an existing piece of code and you're going to need to figure
    out how it works. We're going to guide you through a few strategies to make this
    a far less-daunting task than it might at first seem.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要探索的技术是有价值的。如果您在软件开发中从事专业工作，或者即使您是业余爱好者，迟早都会遇到现有的代码，并且您需要弄清楚它是如何工作的。我们将指导您通过一些策略，使这个任务比起初看起来要容易得多。
- en: 'Let''s get to it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Open `Content/VRExpansion/Vive`, and find the `Vive_PawnCharacter` blueprint.
    Open it up.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Content/VRExpansion/Vive`，找到`Vive_PawnCharacter`蓝图。打开它。
- en: Open its Event Graph.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它的事件图。
- en: Yikes! There's a lot of stuff in here.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊！这里有很多东西。
- en: '![](img/966de70f-524f-4afc-a471-74d8769d2e27.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/966de70f-524f-4afc-a471-74d8769d2e27.png)'
- en: The example project's Vive_PawnCharacter Blueprint contains a lot of Blueprint
    code. Digging through it isn't as daunting as it may seem at first.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目的`Vive_PawnCharacter`蓝图包含了很多蓝图代码。一开始挖掘它可能看起来令人生畏，但实际上并不是那么困难。
- en: 'Here''s the thing though: as daunting as this may seem at first, you''re going
    to appreciate this soon enough. This class is an incredible compendium of useful
    techniques for developing VR characters. On its own, this would be a thing of
    beauty, but what makes it even more amazingly useful is that the blueprints written
    here and the underlying C++ code have been written with network replication in
    mind, so if you''re planning to write a networked VR experience, this class will
    help you right out of the box.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一开始可能看起来令人生畏，但你很快就会欣赏到它的价值。这门课程是一个令人难以置信的有用技术汇编，用于开发虚拟现实角色。单独来看，这已经是一件美妙的事情了，但更令人惊叹的是，这里编写的蓝图和底层C++代码都考虑了网络复制，因此如果你计划编写一个网络虚拟现实体验，这门课程将会对你有所帮助。
- en: To make use of it, however, you need some sense of where to begin. Let's learn
    how to approach a new class and figure it out.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要使用它，你需要知道从哪里开始。让我们学习如何处理一个新的类并弄清楚它。
- en: Begin by checking the parent class
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先检查父类
- en: The first thing you want to do any time you're looking at a new blueprint is
    check the upper-right corner of the interface, and see what its parent class is.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你查看一个新的蓝图时，你首先要做的是检查界面右上角的父类是什么。
- en: In our case, we can see that this blueprint derives from `VRCharacter`. `VRCharacter`
    is a native class written in C++. If you follow the link provided by the parent
    class indicator, it will open Visual Studio to this class, and you can explore
    its native implementation to learn more about it. For our purposes here, we're
    going to stay in Blueprints, but it's worth knowing that this is a thing you can
    do.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以看到这个蓝图派生自`VRCharacter`。`VRCharacter`是一个用C++编写的本地类。如果你按照父类指示器提供的链接，它将打开Visual
    Studio到这个类，你可以探索它的本地实现以了解更多信息。对于我们在这里的目的，我们将继续使用蓝图，但值得知道你也可以这样做。
- en: (If we were to burrow through this class in its native implementation, we would
    see that it derives from a `VRBaseCharacter` class, which in turn derives from
    `Character`. So, this class is essentially an Unreal character as described here: [https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character](https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character).
    But it has additional VR-specific modifications to replicate the camera and hand-controller
    positions, and handle movement in ways that make sense for VR.)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: （如果我们在其本地实现中深入研究这个类，我们会发现它派生自一个`VRBaseCharacter`类，而这个类又派生自`Character`。因此，这个类本质上是一个虚幻角色，如此处所述：[https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character](https://docs.unrealengine.com/en-US/Gameplay/Framework/Pawn/Character)。但它还有额外的针对VR的修改，以复制相机和手柄控制器的位置，并以适合VR的方式处理移动。）
- en: Looking at the components to see what they're made of
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看组件以了解它们是由什么组成的
- en: 'The next thing to look at for any new class you''re exploring is its Components
    list:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 探索任何你正在研究的新类时，下一步要看的是它的组件列表：
- en: '![](img/9d8d230f-ff8d-4c2d-aebd-703744ac24fc.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d8d230f-ff8d-4c2d-aebd-703744ac24fc.png)'
- en: Looking at this components list tells us a lot about this character class and
    what it can do. It's worth doing this with the viewport active so you can see
    which components have visible representations. Roll over each component to see
    what type of component it is, and allow this to build an overall sense of the
    whole class in your mind.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个组件列表可以告诉我们很多关于这个角色类以及它能做什么的信息。最好在视口处于活动状态时进行查看，这样你就可以看到哪些组件具有可见表示。将鼠标悬停在每个组件上，查看它是什么类型的组件，并让这些信息在你的脑海中建立起整个类的整体感觉。
- en: We can see that the `VRCharacter` supports a static mesh for the head, a static
    mesh for the body, and two motion controllers with text renderers, grab-detection
    spheres, and skeletal meshes attached. (This motion controller setup should feel
    somewhat familiar to the work we did on grip interactions.) We can also see that
    it provides a character movement component and some support for VOIP communication.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`VRCharacter`支持一个用于头部的静态网格，一个用于身体的静态网格，以及两个带有文本渲染器、抓取检测球和骨骼网格的运动控制器。（这个运动控制器的设置应该对我们在抓握交互方面的工作感到有些熟悉。）我们还可以看到它提供了一个角色移动组件和一些用于VOIP通信的支持。
- en: You don't need to agonize over every detail when you're doing this. The point
    at this stage of the process is to build an overall mental model of what's in
    the class and how the parts fit together.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你不需要为每个细节而苦恼。在这个过程的这个阶段，重点是建立一个关于类的整体思维模型，以及各个部分如何组合在一起。
- en: Look for known events and see what happens when they run
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找已知事件并查看它们运行时发生了什么。
- en: Another useful starting point for getting information about a blueprint is to
    begin with events we know are likely to be implemented and see what they do.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 获取关于蓝图信息的另一个有用的起点是从我们知道可能已经实现的事件开始，并查看它们的功能。
- en: 'Most classes will do some sort of setup work on Event BeginPlay, and most will
    do some work on Event Tick, so these are generally smart starting points:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类在事件BeginPlay上会进行一些设置工作，并且大多数类在事件Tick上也会进行一些工作，所以这些通常是明智的起点：
- en: Hit *Ctrl* + *F* to activate the Find Results panel and type `beginplay` into
    the search bar.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *F*激活查找结果面板，然后在搜索栏中输入`beginplay`。
- en: 'Hit *Enter*, since we''re just interested in searching inside this blueprint:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*，因为我们只对在这个蓝图内部进行搜索感兴趣：
- en: '![](img/4df34041-d73e-4cb0-a596-7df2468c25fa.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4df34041-d73e-4cb0-a596-7df2468c25fa.png)'
- en: Event BeginPlay appears on the Find Results list. We can double-click it to
    jump to that event in the blueprint.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找结果列表中出现了事件BeginPlay。我们可以双击它跳转到蓝图中的该事件。
- en: Looking at BeginPlay, we can see that it only handles this event on clients
    from the server; it uses a SetupOnPossession custom event instead. We can see
    that it's setting up grip components for the locally-controlled player; it's adjusting
    the tracking origin and spectator screen, and then for every body it's going to
    spawn and set up a pair of `BP_Teleport_Controller` actors, which get attached
    to the motion controllers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 观察BeginPlay，我们可以看到它只在服务器上处理此事件；它使用了一个名为SetupOnPossession的自定义事件。我们可以看到它为本地控制的玩家设置了抓取组件；它调整了跟踪原点和观众屏幕，然后对于每个物体，它将生成并设置一对`BP_Teleport_Controller`角色，这些角色会附加到运动控制器上。
- en: 'We may not know everything yet about this pawn, but just from looking at its
    BeginPlay, we''ve learned a few things:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们还不完全了解这个角色，但仅仅从观察它的BeginPlay，我们已经学到了一些东西：
- en: This pawn has been set up to be used in network play—it's executing different
    paths depending on whether it has the authority
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个角色已经设置为在网络游戏中使用-它根据是否具有权限执行不同的路径
- en: The pawn handles some things differently depending on whether it's running locally
    or controlled by another player
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据本地运行还是由其他玩家控制，角色会以不同的方式处理一些事情。
- en: Teleport handling is managed by a separate class from the pawn. We'll want to
    look at this
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传送处理由一个与角色不同的类管理。我们将要查看这个类。
- en: 'Now let''s do the same thing for Event Tick:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对Event Tick做同样的事情：
- en: 'Search for `Tick`, and double-click the Event Tick entry that comes up in the
    results:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索`Tick`，并双击结果中出现的Event Tick条目：
- en: '![](img/3788e1d2-aab8-448a-85fa-24ef3fa96fa7.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3788e1d2-aab8-448a-85fa-24ef3fa96fa7.png)'
- en: 'Again, this tells us a few things right off the bat:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些信息可以立即告诉我们一些事情：
- en: Remote pawns don't do anything on the tick at all. This is good.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程角色在tick中不执行任何操作。这很好。
- en: The tick is handling movement for the most part, but climbing movement was moved
    to a separate event.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tick主要处理移动，但攀爬移动被移到了一个单独的事件中。
- en: Grip animations and teleport rotations are being handled on the tick too.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓取动画和传送旋转也在tick中处理。
- en: It's not necessary to do a deep dig at this stage of the process yet. Your intention
    here is to give yourself a broad view of what parts this class contains and when
    and how they do their work. This way, when you're looking for details later on,
    you'll have a good sense of where to look.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段还不需要进行深入挖掘。你的目的是给自己一个广泛的视角，了解这个类包含的部分以及它们何时以及如何工作。这样，当你稍后寻找细节时，你就会知道在哪里寻找。
- en: This process has given us a bit of information so far. Just by knowing the parent
    class, the components it contains, and two of its known events, we can already
    intuit a fair bit about what this class can do. Now it's time to get more specific
    and begin with a simple question—what happens when the player tries to teleport?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个过程已经给我们提供了一些信息。仅凭知道父类、它包含的组件和两个已知事件，我们就可以对这个类的功能有一定的直觉。现在是时候更具体地开始，从一个简单的问题开始-当玩家尝试传送时会发生什么？
- en: Using inputs as a way to find a starting point in your blueprint
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入作为蓝图中的起点
- en: We could try to answer this question by looking through this huge event graph
    and trying to find what we're looking for (and in this instance, that would work
    out reasonably well for us because the graph is well-organized and the author
    has done a good job of documenting it), but there's an easier way.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看这个庞大的事件图并尝试找到我们要找的内容来回答这个问题（在这种情况下，这对我们来说可能会相当顺利，因为图表组织得很好，作者在文档中做得很好），但有一种更简单的方法。
- en: Start with a thing you know, and follow the execution from there to see what
    happens.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从你所知道的东西开始，然后从那里开始执行，看看会发生什么。
- en: 'In our case, we know that the player executes the teleport by hitting one of
    the Dpads or thumbsticks, depending on whether they''re on a Vive, an Oculus,
    or some other device. That''s going to be mapped as an input. Let''s find it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们知道玩家通过按下Dpads或拇指杆之一来执行传送，具体取决于他们是使用Vive、Oculus还是其他设备。这将被映射为一个输入。让我们找到它：
- en: Open Settings | Project Settings | Engine | Input, and expand the Action Mappings
    expander.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置 | 项目设置 | 引擎 | 输入，并展开动作映射扩展器。
- en: 'There''s an input here named TeleportRight that sounds promising. If we expand
    it, we can see that it''s mapped to the right thumbstick, or FaceButton 1 (which
    is on the Vive is the Dpad''s top quadrant). That''s the one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为TeleportRight的输入听起来很有希望。如果我们展开它，我们可以看到它被映射到右拇指杆或FaceButton 1（在Vive上是Dpad的顶部象限）。就是这个：
- en: '![](img/de743c61-b7d4-4a0d-b019-7ade40639dc0.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de743c61-b7d4-4a0d-b019-7ade40639dc0.png)'
- en: Now that we have an input name to look for, we'll search for TeleportRight in
    our blueprints, and we're probably going to find something. (Some projects handle
    their inputs in the native C++ environment, but it's much more common to do it
    in blueprints.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个要查找的输入名称，我们将在蓝图中搜索TeleportRight，我们可能会找到一些东西。（有些项目在本机C++环境中处理输入，但在蓝图中处理输入更为常见。）
- en: Jump back to your event graph and hit *Ctrl* + *F* to bring up the Find Results
    panel.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转回你的事件图并按下Ctrl + F来打开查找结果面板。
- en: 'Type `TeleportRight` in the search box and hit the binoculars symbol to the
    right of the box to run the search in all blueprints:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`TeleportRight`，然后点击框右侧的放大镜符号以在所有蓝图中运行搜索：
- en: '![](img/3748c1ed-3b46-453c-982b-c0c46c252305.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3748c1ed-3b46-453c-982b-c0c46c252305.png)'
- en: 'There it is. Our character is handling that input:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的角色正在处理这个输入：
- en: '![](img/1fe78abf-ac43-4e84-9a61-b1f2e0084490.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe78abf-ac43-4e84-9a61-b1f2e0084490.png)'
- en: Another useful strategy when you're looking for inputs is simply to type inputaction
    into your search box. Any input that's been mapped using the project's Inputs
    settings (which are written to DefaultInput.ini) will begin with this prefix.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在寻找输入时，另一个有用的策略是在搜索框中直接输入inputaction。任何使用项目的输入设置（写入DefaultInput.ini）映射的输入都会以这个前缀开头。
- en: 'Double-click the entry for InputAction TeleportRight, and you''ll be taken
    to that event handler in the event graph:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击InputAction TeleportRight的条目，你将进入事件图中的事件处理程序：
- en: '![](img/b53ae1c1-b260-4951-80f6-c7da504b070f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53ae1c1-b260-4951-80f6-c7da504b070f.png)'
- en: Now we have something to look at. We can use a breakpoint to confirm that we're
    looking at the right thing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有东西可以看了。我们可以使用断点来确认我们正在查看正确的内容。
- en: Setting breakpoints and tracing execution
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置断点和跟踪执行
- en: 'We''re going to use a breakpoint to verify that the code we think is going
    to execute when we trigger the input is really what executes. This is a common
    technique for understanding someone else''s code. When you''re not sure about
    its execution path, put breakpoints at locations you expect to be hit, and then
    see which ones really trip. This will give you a starting point from which to
    begin exploring the software:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用断点来验证当我们触发输入时，我们认为将执行的代码是否真的执行。这是一种理解他人代码的常用技术。当你对其执行路径不确定时，在你预期会被触发的位置设置断点，然后看看哪些断点真正被触发。这将为你开始探索软件提供一个起点：
- en: 'Select the InputAction TeleportRight node, and hit *F9* to put a breakpoint
    on it, or right-click and select Toggle breakpoint from the context menu:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择InputAction TeleportRight节点，按下*F9*在其上设置一个断点，或者右键点击并从上下文菜单中选择切换断点：
- en: '![](img/cb2dcc73-a9e9-44ed-b885-57bd2285c398.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb2dcc73-a9e9-44ed-b885-57bd2285c398.png)'
- en: When a breakpoint is active on a blueprint node, it instructs the editor to
    pause the blueprint's execution when it reaches the node containing the breakpoint.
    You can then step through execution one action at a time and see what the blueprint
    is doing. Let's test this now.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当蓝图节点上有断点时，它会指示编辑器在达到包含断点的节点时暂停蓝图的执行。然后，你可以逐步执行每个动作并查看蓝图正在做什么。现在让我们来测试一下。
- en: With the breakpoint still set on InputAction TeleportRight, launch a VR Preview
    session (you don't really need to put on your headset for this—we're going to
    be back out of it in a second), and activate the right teleport input.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在InputAction TeleportRight上仍然设置断点的情况下，启动VR预览会话（你不需要真的戴上头盔，我们将在一秒钟内退出它），并激活右侧传送输入。
- en: The game should appear to freeze on you, and your VR headset will stop displaying
    the environment.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏应该会看起来冻结在那里，你的VR头戴式显示器将停止显示环境。
- en: 'Take a look now at the InputAction TeleportRight node. You''ll see a red arrow
    indicating that the blueprint simulation has paused at this node:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在看一下InputAction TeleportRight节点。你会看到一个红色箭头，表示蓝图模拟已在此节点处暂停：
- en: '![](img/4c957c4f-7d28-4913-876d-c1ef0e0ce9d1.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c957c4f-7d28-4913-876d-c1ef0e0ce9d1.png)'
- en: 'Let''s take note of a few other things here too. You can see that the blueprint
    display is ringed with a yellow indicator to indicate that it''s currently simulating,
    and you can see from the title line that the graph is currently in a read-only
    state. You''re not allowed to change a blueprint while you''re simulating it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也注意一下这里的其他一些事情。你可以看到蓝图显示被黄色指示器环绕，表示它当前正在模拟，并且从标题行可以看出，图表当前处于只读状态。在模拟蓝图时，你不允许更改蓝图：
- en: '![](img/5d32e937-713b-4d16-8013-8047eff116cd.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d32e937-713b-4d16-8013-8047eff116cd.png)'
- en: 'Let''s also take a look at the execution controls that have appeared on our
    toolbar:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来看一下出现在工具栏上的执行控制：
- en: The Resume button will resume normal execution. (This is dicey when running
    VR—your headset may not properly wake back up from the paused state.)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复按钮将恢复正常执行。（在运行VR时这是有风险的——你的头戴式显示器可能无法从暂停状态正确唤醒。）
- en: The Frame Skip button allows a single frame to execute and returns to a paused
    state.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧跳过按钮允许执行一帧并返回到暂停状态。
- en: The Stop button will shut down your **Play-in-Editor** (**PIE**) session and
    return to the editor.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止按钮将关闭你的**编辑器中播放**（**PIE**）会话并返回到编辑器。
- en: The Find Node button takes you back to the node at which execution is currently
    stopped.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找节点按钮将带你回到当前停止执行的节点。
- en: 'These next three nodes are the important ones for stepping through code, and
    you should memorize their hotkeys because you''ll use them all of the time:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个节点是用于逐步执行代码的重要节点，你应该记住它们的快捷键，因为你会经常使用它们：
- en: Step Into (*F11*) steps to the next executed node, and jumps into a function's
    implementation if the node represents a blueprint function call or a macro.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Step Into（*F11*）步进到下一个执行的节点，并且如果该节点表示蓝图函数调用或宏，则跳转到函数的实现。
- en: Let's see this in action before we move on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看一下它的运行情况。
- en: 'Hit *F11* now. See how we''ve now jumped to the Switch on MovementMode node:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下*F11*。看看我们现在跳转到了Switch on MovementMode节点：
- en: 'Roll over the selection input of Switch on MovementMode node. The rollover
    tooltip indicates the input''s type and its current value:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在Switch on MovementMode节点的选择输入上。悬停提示显示输入的类型和当前值：
- en: '![](img/3360295a-3b4c-460a-b356-40fd9d19e608.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3360295a-3b4c-460a-b356-40fd9d19e608.png)'
- en: We can see that Movement Mode Right is currently set to Teleport, so the first
    branch of the switch statement is going to execute.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Movement Mode Right当前设置为Teleport，所以switch语句的第一个分支将执行。
- en: Hit *F11* again, and execution steps to the `Branch` statement.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下*F11*，执行步进到`Branch`语句。
- en: Rolling over its input value, we can see that, because we're not hand-climbing,
    out of body, or in a movement-disabled state, this value is false and the false
    branch is going to execute.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停在其输入值上，我们可以看到，因为我们没有手爬行、离开身体或处于禁止移动状态，所以这个值为false，将执行false分支。
- en: Hitting *F11* again takes us to the SetTeleporterActive node as we expected.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下*F11*，我们如预期地跳转到了SetTeleporterActive节点。
- en: Hit *F11* again, and this time something interesting happened. Instead of jumping
    to the next node in the event graph, we jumped inside of the `Set Teleporter Active`
    function.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下*F11*，这次发生了一些有趣的事情。我们没有跳转到事件图中的下一个节点，而是跳转到了`Set Teleporter Active`函数内部。
- en: This is the difference between Step Into (*F11*) and Step Over (*F10*). *Step
    into* will take you wherever execution goes, even into function calls or macros,
    while *F10* will step over a function call without taking us inside it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Step Into（*F11*）和Step Over（*F10*）之间的区别。*Step into*会带你到执行的任何地方，甚至是函数调用或宏，而*F10*会跳过函数调用而不进入其中。
- en: Continue hitting *F11* until we step inside of the Is Valid macro.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续按下*F11*，直到我们进入“Is Valid”宏的内部。
- en: We're not actually interested in the contents of this macro, so we'd like to
    step back out so we can continue looking at our `SetTeleporterActive` function.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上对这个宏的内容不感兴趣，所以我们想要跳出来，这样我们就可以继续查看我们的“SetTeleporterActive”函数。
- en: Hit *Alt* + *Shift* + *F11*, or the Step Out button to get back to the `SetTeleporterActive`
    graph.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *Shift* + *F11*，或者点击“步出”按钮返回到“SetTeleporterActive”图中。
- en: Now you've seen each of these three navigation operations in action. Practice
    them and get used to using their hotkeys. Stepping through blueprints like this
    is one of the fastest and most effective ways of seeing how a complex blueprint
    runs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了这三个导航操作的实际效果。练习它们并熟悉使用它们的快捷键。像这样逐步查看蓝图是看到复杂蓝图运行方式最快、最有效的方法之一。
- en: 'Remember the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 记住以下内容：
- en: '*F11* (Step Into) steps to the next executed node, even if it''s inside another
    function or macro.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F11*（步入）跳转到下一个执行的节点，即使它在另一个函数或宏内部。'
- en: '*F10* (Step Over) steps to the next executed node in the current context, but
    does not step inside functions or macros that get called from that context.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F10*（步过）在当前上下文中跳转到下一个执行的节点，但不会进入从该上下文调用的函数或宏中。'
- en: '*Alt* + *Shift* + *F11* (Step Out) steps back out of a function or macro to
    the context that called it.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Alt* + *Shift* + *F11*（步出）从函数或宏中退出到调用它的上下文。'
- en: Memorize these keys. You'll be happy you did.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些快捷键。你会为此感到高兴的。
- en: These hotkeys—*F9* to toggle a breakpoint, *F10* to step over, and *F11* to
    step in, also work pretty much exactly the same way in Visual Studio when tracing
    through C++ code, and the same general techniques—find a known point in the code,
    set a breakpoint, and then step through to see how it works, and apply it there
    too. Use *Shift* + *F11* to step out of a method in Visual Studio.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快捷键——*F9*切换断点，*F10*步过，*F11*步入，在Visual Studio中跟踪C++代码时也基本上以相同的方式工作，相同的一般技巧——找到代码中的已知点，设置断点，然后逐步查看它的工作方式，并在那里应用它。在Visual
    Studio中使用*Shift* + *F11*从一个方法中步出。
- en: Hit *F11* until execution jumps into the `Activate Teleporter` method.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*F11*，直到执行跳转到“Activate Teleporter”方法中。
- en: Take a look at your tab bar and you'll see that you've now jumped into a different
    class altogether. The VRExpansion plugin's example project uses a separate Blueprint
    actor called `BP_TeleportController` to handle drawing the teleport beam and the
    target indicator. This is useful information.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下你的标签栏，你会发现你现在已经跳转到了一个完全不同的类中。VRExpansion插件的示例项目使用一个名为`BP_TeleportController`的独立蓝图角色来处理绘制传送光束和目标指示器。这是有用的信息。
- en: This is also a smart way to design this system. Keeping a system such as this
    bundled together into its own object makes it easier in the long run to swap things
    out, to add it to a new character class, or to find what you're looking for if
    you need to debug. What you're seeing here is a more advanced organizational principle,
    but it's worth learning to think in these terms.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是设计这个系统的聪明方式。将这样的系统捆绑到自己的对象中，可以更容易地在长期运行中进行替换，将其添加到新的角色类中，或者在需要调试时找到你要找的东西。你在这里看到的是一种更高级的组织原则，但学会用这些术语思考是值得的。
- en: Viewing the execution trace
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看执行跟踪
- en: 'Let''s say we were stepping through a blueprint and we realized we needed to
    jump back a few steps to see what values drove a branch or a switch. To do this,
    we can make use of the Debug panel''s Execution Trace:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在逐步查看蓝图，并意识到我们需要跳回几个步骤来查看是什么值驱动了一个分支或一个开关。为了做到这一点，我们可以利用调试面板的执行跟踪：
- en: Select Window | Debug to bring up the Debug panel.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“窗口”|“调试”以打开调试面板。
- en: Expand the panel's Execution Trace section.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开面板的执行跟踪部分。
- en: 'Continue stepping through your blueprint and watch what happens here:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续逐步查看你的蓝图，并观察这里发生了什么：
- en: '![](img/f265f7c7-f8b3-417a-8346-d03025d52168.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f265f7c7-f8b3-417a-8346-d03025d52168.png)'
- en: The execution trace will build a list of breadcrumbs showing where we've been
    so far as we step through execution. Any time you need to revisit a previous execution
    step, you can click it, and you'll be taken to that section of the graph, where
    you can see what inputs were driving it and what outputs it produced.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 执行跟踪将构建一个面包屑列表，显示我们在执行过程中已经经过的部分。每当你需要重新访问以前的执行步骤时，你可以点击它，然后你将被带到图表的那个部分，你可以看到驱动它的输入和它产生的输出。
- en: 'This is one of the most effective ways you can learn a new blueprint: set breakpoints
    and see how it runs. You''ll develop a very clear sense of how the class is built
    this way.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学习新蓝图的最有效的方法之一：设置断点并查看它的运行方式。通过这种方式，你将对类的构建方式有一个非常清晰的认识。
- en: As you progress through your development career and get good at figuring out
    and leveraging existing code, you're probably going to be surprised by how many
    developers you encounter who hold themselves back by failing to learn to do this
    effectively and wind up doing things the hard way, if they get anything done at
    all. Some of this, you'll find, is what developers call the *not-invented-here* syndrome
    (generally a fear of doing the work masked as an ego), and some of it is simply
    lack of knowledge. The time you spend doing your research and learning what's
    already been figured out about the problem you're trying to solve is never wasted
    time.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在开发职业中的进步，并且擅长于解决和利用现有代码，你可能会惊讶地发现有多少开发人员因为未能有效地学会这样做而束缚了自己，并最终以困难的方式完成任务，如果他们真的能完成的话。你会发现，其中一些是开发人员所谓的“非自创”综合症（通常是一种将工作视为自我而掩盖的恐惧），而另一些则是简单的缺乏知识。你花在研究和学习已经解决的关于你要解决的问题的内容上的时间永远不会浪费。
- en: Managing breakpoints with the Debug window
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试窗口管理断点
- en: 'We''re going to do another exploration in a moment, but, first, we''re going
    to clear our breakpoints out of the Vive_PawnCharacter blueprint:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上要进行另一次探索，但首先，我们要清除Vive_PawnCharacter蓝图中的断点：
- en: Hit the Stop button to end the simulation and return to the editor.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击停止按钮结束模拟并返回编辑器。
- en: Tab back to the Vive_PawnCharacter blueprint, and if it isn't still open, select
    Window | Debug.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回Vive_PawnCharacter蓝图，如果它还没有打开，请选择窗口 | 调试。
- en: 'This time, we''re interested in the Breakpoints list displayed on this panel:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们对此面板上显示的断点列表感兴趣：
- en: '![](img/0e2e7e37-02c4-49f4-bf1b-76ddf2123f37.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e2e7e37-02c4-49f4-bf1b-76ddf2123f37.png)'
- en: In this screenshot, I've added a few more breakpoints to make the example clearer.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，我添加了一些额外的断点以使示例更清晰。
- en: You can click any breakpoint in the list to jump to its location in the blueprint,
    and you can right-click to disable or remove a breakpoint.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击列表中的任何断点以跳转到蓝图中的位置，并可以右键单击禁用或删除断点。
- en: Disabling a breakpoint turns the breakpoint off without removing it. This is
    useful if you want to omit a breakpoint temporarily but still want to be able
    to re-enable it later for further debugging.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用断点会关闭断点而不删除它。如果您想暂时省略断点但仍然希望能够稍后重新启用它以进行进一步调试，这将非常有用。
- en: You can also toggle any breakpoint on or off by selecting a blueprint node and
    hitting *F9*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过选择蓝图节点并按下*F9*来切换任何断点的开启或关闭状态。
- en: 'Let''s clear them all out of our class for now:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将它们全部清除出我们的类：
- en: Hit Debug | Delete All Breakpoints (or use *Ctrl* + *Shift* + *F9*).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击调试 | 删除所有断点（或使用*Ctrl* + *Shift* + *F9*）。
- en: This will remove the breakpoint we set on the input action earlier, along with
    any other breakpoints we might have set in this blueprint. This menu also gives
    you the option to disable and enable all breakpoints in a class, as well.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除我们之前在输入动作上设置的断点，以及在此蓝图中设置的任何其他断点。此菜单还提供了禁用和启用类中所有断点的选项。
- en: Using the call stack
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调用堆栈
- en: Let's do another experiment now. We've seen how we can begin stepping through
    execution at an input event to see what happens when the event gets called, but
    what if we're interested in a particular function, and we want to see when it
    gets called and who calls it? We have a few powerful tools to help us here too.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行另一个实验。我们已经看到了如何在输入事件上开始逐步执行以查看调用事件时会发生什么，但是如果我们对特定函数感兴趣，并且想要查看它何时被调用以及由谁调用呢？我们有一些强大的工具可以帮助我们。
- en: 'Let''s say we were seeing a camera fade happen in-game and we wanted to find
    out who was calling it. Maybe we''re not even sure what the name of the call is
    going to be, but we''re guessing it might have the word *fade* in its name:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在游戏中看到了一个相机淡入的情况，并且我们想找出是谁在调用它。也许我们甚至不确定调用的名称是什么，但我们猜测它可能包含单词*fade*：
- en: Hit *Ctrl* + *F* to activate the Find Results window, and type `fade` into the
    search bar.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *F*激活查找结果窗口，然后在搜索栏中键入“fade”。
- en: 'Use the binoculars to find in all blueprints:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用望远镜在所有蓝图中查找：
- en: '![](img/ddc5211e-48f5-4a3c-84df-295fb039c4ba.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddc5211e-48f5-4a3c-84df-295fb039c4ba.png)'
- en: We can see a number of entries here, but most of them are variables. Clearly,
    the stuff in the fog sheet isn't what we're looking for, but these Start Camera
    Fade calls in Vive_PawnCharacter look promising.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有很多条目，但大多数都是变量。显然，迷雾表中的东西不是我们要找的，但是Vive_PawnCharacter中的这些Start Camera
    Fade调用看起来很有希望。
- en: Double-click the first Start Camera Fade entry to jump to its location in the
    graph, and hit *F9* to set a breakpoint on it.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击第一个“Start Camera Fade”条目，跳转到图表中的位置，并按下*F9*在其上设置断点。
- en: Repeat this for the other three.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其他三个重复此操作。
- en: Launch a VR Preview session and activate a teleport.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动VR预览会话并激活传送。
- en: Execution will stop at one of the Start Camera Fade nodes. This time, though,
    instead of stepping through the code to see what happens next, we want to see
    how we got here.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将停在一个“Start Camera Fade”节点上。不过，这一次，我们不想逐步执行代码以查看接下来会发生什么，而是想看看我们是如何到达这里的。
- en: Hit Window | Developer Tools | Blueprint Debugger to open up Blueprint Debugger.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口 | 开发人员工具 | 蓝图调试器以打开蓝图调试器。
- en: 'You''ll see that the first of the three displayed tabs is labeled Call Stack:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到显示的三个选项卡中的第一个标签为调用堆栈：
- en: '![](img/83f2aa82-6431-4211-adaa-c587a01ac1af.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83f2aa82-6431-4211-adaa-c587a01ac1af.png)'
- en: The Call Stack is a list of all of the events and functions that led to where
    the execution has currently been paused. This gives you an enormous amount of
    information. The top of a call stack represents where execution is currently paused,
    and the entry right below it is the function or event that called it. The entry
    below that one is whatever called that function, and so on.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈是一个列出了导致当前执行暂停的所有事件和函数的列表。这为您提供了大量的信息。调用堆栈的顶部表示当前执行暂停的位置，其下方的条目是调用它的函数或事件。再下方的条目是调用该函数的内容，依此类推。
- en: 'Looking at this stack, we can see that a C++ routine detected the button-press
    and triggered InputAction TeleportRight. Then, a call was made from the event
    graph. Let''s double-click this entry in the Call Stack to see it:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此堆栈，我们可以看到一个C++例程检测到按钮按下并触发了InputAction TeleportRight。然后，从事件图表中进行了调用。让我们双击调用堆栈中的此条目以查看它：
- en: '![](img/e5cdb9e3-ffc5-476a-a4e2-9712953097fd.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5cdb9e3-ffc5-476a-a4e2-9712953097fd.png)'
- en: It's an Execute Teleportation call triggered by the input action's Released
    event.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由输入动作的Released事件触发的Execute Teleportation调用。
- en: We can double-click the next call—the `ExecuteTeleportation` event, and see
    the graph that leads to the camera fade we were looking for.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以双击下一个调用——“ExecuteTeleportation”事件，并查看导致我们寻找的相机淡入的图表。
- en: This is a powerful technique, and you should get into the habit of using it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的技术，您应该养成使用它的习惯。
- en: For more information on using Unreal's blueprint debugging tools, look here: [https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用虚幻蓝图调试工具的更多信息，请查看这里：[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Debugging)。
- en: Do a bit of exploring through the blueprint using this tool, and then hit Stop
    to return to the editor.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具在蓝图中进行一些探索，然后点击停止返回编辑器。
- en: Finding variable references
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找变量引用
- en: Going back to our teleport example, what if we wanted to know what changes that
    `Movement Mode` variable that drives the `switch` statements from InputAction
    TeleportRight?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的传送示例，如果我们想知道是什么改变了驱动`switch`语句的`Movement Mode`变量，那么怎么办呢？
- en: 'This is easy to do:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做到：
- en: Select the Movement Mode Right variable.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Movement Mode Right变量。
- en: 'Right-click it and select Find References, or hit *Alt* + *Shift* + *F*:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击它并选择Find References，或者按下*Alt* + *Shift* + *F*：
- en: '![](img/7fa3ecd8-cd80-4425-baeb-20290d5124df.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fa3ecd8-cd80-4425-baeb-20290d5124df.png)'
- en: 'We can see that this variable is used in a number of places, but it''s only
    set in two locations. This is what we''re interested in:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个变量在很多地方被使用，但只在两个位置被设置。这就是我们感兴趣的：
- en: '![](img/23491156-c90f-4b70-ae71-12d5b920f801.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23491156-c90f-4b70-ae71-12d5b920f801.png)'
- en: Double-click on of the Set MovementModeRight entries in your Find Results.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击Find Results中的Set MovementModeRight条目之一。
- en: This takes us to the location where this variable is set, and we can see that
    this is taking place in a function called `Cycle Movement Modes`. We could then
    use the strategies we've learned to see when and how this function gets called,
    and what else happens along with it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到设置这个变量的位置，我们可以看到这是在一个名为`Cycle Movement Modes`的函数中进行的。然后我们可以使用我们学到的策略来查看这个函数何时以及如何被调用，以及与之相关的其他事情。
- en: You can use *Alt* + Shift + *F* with functions as well as variables. Practice
    doing this.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*Alt* + Shift + *F*来查找函数和变量。练习一下。
- en: Making sense of someone else's code is like untying a complicated knot. You'll
    discourage yourself if you try to make sense of it all at once. Instead, you find
    a single strand and start following it and pulling it apart, and the structure
    of it becomes clear as you go. These tools can help you to do this.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 理解别人的代码就像解开一个复杂的结。如果你试图一次理解所有内容，你会让自己感到沮丧。相反，你找到一根单独的线，开始跟随它并解开它，随着你的进行，它的结构就会变得清晰起来。这些工具可以帮助你做到这一点。
- en: Using more of the VRExpansion plugin
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更多的VRExpansion插件
- en: '**VRExpansion** is a large plugin, and it provides a great deal of functionality
    to VR developers. Now that you have some strategies in place for exploring it
    and figuring out how it works and how you can use it, you''re going to be able
    to unlock enormous potential.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**VRExpansion**是一个庞大的插件，为VR开发者提供了很多功能。现在你已经有了一些探索它、弄清楚它的工作原理以及如何使用它的策略，你将能够释放巨大的潜力。'
- en: In addition to the character we've just explored, this plugin provides a VR-enabled
    player controller, an AI controller, stereo widgets, buttons, levers, and much
    more.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚探索的角色之外，这个插件还提供了一个支持VR的玩家控制器、一个AI控制器、立体小部件、按钮、杠杆等等。
- en: 'If you''d like to get a better sense of what this plugin includes (there''s
    far too much to fit within this chapter), hit the View Options popout in your
    content browser, turn on Show Plugin Content, and make sure Show C++ Classes is
    visible:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地了解这个插件包含了什么（这远远超出了本章的范围），在内容浏览器中点击View Options弹出菜单，打开Show Plugin Content，并确保Show
    C++ Classes可见：
- en: '![](img/199df761-7872-4dc1-a1c2-38ecd9b5c26e.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/199df761-7872-4dc1-a1c2-38ecd9b5c26e.png)'
- en: Browse through the class directory and see what's in there. If you double-click
    any of these classes, its native source will open in Visual Studio.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览类目录，看看里面有什么。如果你双击其中任何一个类，它的原始源代码将在Visual Studio中打开。
- en: One of your best resources though is the VR Expansion Plugin forum at UnrealEngine.com,
    found here: [https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好的资源之一是UnrealEngine.com上的VR Expansion Plugin论坛，网址在这里：[https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin](https://forums.unrealengine.com/development-discussion/vr-ar-development/89050-vr-expansion-plugin)。
- en: The plugin's author, Joshua Statzer (mordentral) is very active on the forum
    and is surrounded by a community of helpful developers who are very willing to
    help new developers to get on their feet.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的作者Joshua Statzer（mordentral）在论坛上非常活跃，并且周围有一群乐于助人的开发者社区，他们非常愿意帮助新开发者入门。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter took a bit of a different turn from the tutorials we've done up
    to this point, as its intention really is to help you to get to a point where
    you can explore the numerous plugins, templates, examples, and other projects
    you find within the Unreal ecosystem and learn how to use them to accelerate your
    work and learn new techniques. This is one of the most valuable skills you can
    teach yourself as a developer. If you get comfortable exploring code you find
    in the wild, you'll develop much more powerful software in a much shorter time
    and learn more advanced techniques by seeing how experienced developers have approached
    the problem you're trying to solve. This will make you a better developer faster.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章与我们到目前为止所做的教程有些不同，因为它的目的实际上是帮助你达到一个能够探索Unreal生态系统中的众多插件、模板、示例和其他项目，并学习如何使用它们来加速你的工作和学习新技术的能力。这是你作为开发者可以自学的最有价值的技能之一。如果你能够熟练地探索在外部找到的代码，你将能够在更短的时间内开发出更强大的软件，并通过看到经验丰富的开发者如何解决你正在尝试解决的问题来学习更高级的技术。这将使你成为一个更好的开发者。
