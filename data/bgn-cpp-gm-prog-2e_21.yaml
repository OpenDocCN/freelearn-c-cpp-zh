- en: '*Chapter 20*: Game Objects and Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第20章*：游戏对象和组件'
- en: In this chapter, we will be doing all the coding related to the Entity-Component
    pattern we discussed at the beginning of the previous chapter. This means we will
    code the base `Component` class, which all the other components will be derived
    from. We will also put our new knowledge of smart pointers to good use so that
    we don't have to concern ourselves with keeping track of the memory we allocate
    for these components. We will also code the `GameObject` class in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写与上一章开头讨论的实体-组件模式相关的所有编码。这意味着我们将编写基础`Component`类，其他所有组件都将从这个类派生。我们还将充分利用我们对智能指针的新知识，以便我们不必担心跟踪为这些组件分配的内存。我们还将在本章中编写`GameObject`类。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Preparing to code the components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备编写组件
- en: Coding the Component base class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写组件基类
- en: Coding the collider components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写碰撞器组件
- en: Coding the graphics components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写图形组件
- en: Coding the update components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更新组件
- en: Coding the GameObject class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏对象类
- en: Let's discuss the components a bit more before we start coding. Please note
    that, in this chapter, I will try and reinforce how the Entity-Component system
    fits together and how all the components compose a game object. I will not be
    explaining each and every line or even block of logic or SFML-related code that
    we have seen many times already. It is up to you to study these details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们更详细地讨论一下组件。请注意，在本章中，我将尝试加强实体-组件系统如何结合在一起，以及所有组件如何组成一个游戏对象。我不会解释每一行或甚至每一个逻辑块或已经多次见过的SFML相关代码。这些细节需要你自己去研究。
- en: Preparing to code the components
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备编写组件
- en: As you work through this chapter, there will be lots of errors, and some of
    them won't seem logical. For example, you will get errors saying that a class
    doesn't exist when it is one of the classes you have already coded. The reason
    for this is that, when a class has an error in it, other classes can't reliably
    use it without getting errors as well. It is because of the interconnected nature
    of all the classes that we will not get rid of all the errors and have executable
    code again until near the end of the next chapter. It would have been possible
    to add code in smaller chunks to the various classes and the project would have
    been error-free more frequently. Doing things that gradually, however, would have
    meant constantly dipping in and out of classes. When you are building your own
    projects, this is sometimes a good way to do it, but I thought the most instructive
    thing to do for this project would be to help you get it built as quickly as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成本章的过程中，会有很多错误，其中一些可能看起来没有逻辑。例如，你可能会得到错误信息，说某个类不存在，而实际上它正是你已经编写的类之一。原因在于，当一个类中存在错误时，其他类无法可靠地使用它，否则也会出现错误。正因所有类之间相互关联的特性，我们直到下一章的结尾才能消除所有错误，再次获得可执行的代码。本可以分小块向各个类和项目添加代码，这样项目出现错误的频率会更高。然而，逐步进行意味着需要不断在各个类之间切换。当你构建自己的项目时，这有时是一种好的做法，但我认为对于这个项目来说，最有教育意义的事情是帮助你尽可能快地构建它。
- en: Coding the Component base class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写组件基类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `Component.h`
    and add the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`过滤器中创建一个新的头文件，命名为`Component.h`，并添加以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the base class of every component in every game object. The pure virtual
    functions mean that a component can never be instantiated and must always be inherited
    from first. Functions allow the type and specific type of a component to be accessed.
    Component types include collider, graphics, transform, and update, but more types
    could be added in line with the requirements of the game. Specific types include
    standard graphics, invader update, player update, and more besides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个游戏对象中每个组件的基类。纯虚函数意味着组件不能被实例化，必须首先继承。函数允许访问组件的类型和特定类型。组件类型包括碰撞器、图形、变换和更新，但根据游戏需求还可以添加更多类型。具体类型包括标准图形、入侵者更新、玩家更新等。
- en: There are two functions that allow the component to be enabled and disabled.
    This is useful because a component can then be tested for whether it is currently
    enabled before it is used. For example, you could call the `enabled` function
    to test whether a component's update component was enabled before calling its
    `update` function or that a graphics component is enabled before calling its `draw`
    function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数允许组件被启用和禁用。这很有用，因为组件可以在使用之前测试它是否当前已启用。例如，你可以调用 `enabled` 函数来测试在调用 `update`
    函数之前组件的更新组件是否已启用，或者图形组件在调用 `draw` 函数之前是否已启用。
- en: The `start` function is probably the most interesting function because it has
    a new class type as one of its parameters. The `GameObjectSharer` class will give
    access to all the game objects after they have been instantiated with all their
    components. This will give every component in every game object the opportunity
    to query details and even obtain a pointer to a specific piece of data in another
    game object. As an example, all an invader's update components will need to know
    the location of the player's transform component so that it knows when to fire
    a bullet. Absolutely any part of any object can be accessed in the `start` function.
    The point is that each specific component will decide what they need and there
    is no requirement during the critical game loop to start querying for the details
    of another game object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 函数可能是最有趣的功能，因为它将其参数之一设为一个新的类类型。`GameObjectSharer` 类将在所有组件实例化后提供对所有游戏对象的访问。这将给每个游戏对象中的每个组件提供查询详细信息甚至获取指向另一个游戏对象中特定数据指针的机会。例如，所有侵略者的更新组件都需要知道玩家变换组件的位置，以便知道何时开火。在
    `start` 函数中，可以访问任何对象的任何部分。关键是每个特定的组件将决定它们需要什么，并且在关键的游戏循环中不需要查询另一个游戏对象的详细信息。'
- en: The `GameObject` that the component is contained in is also passed to the `start`
    function so that any component can find out more about itself as well. For example,
    a graphics component needs to know about the transform component so that it knows
    where to draw itself. As a second example, the update components of the invaders
    and the player's ship will need a pointer to their own collider component so that
    they can update its location whenever they move.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该组件的 `GameObject` 也会传递给 `start` 函数，这样任何组件都可以了解更多关于自己的信息。例如，图形组件需要了解变换组件，以便知道在哪里绘制自己。作为第二个例子，侵略者和玩家飞船的更新组件需要指向它们自己的碰撞器组件的指针，这样它们就可以在移动时更新其位置。
- en: We will see more use cases for the `start` function as we progress.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将看到更多 `start` 函数的使用案例。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `Component.cpp`
    and add the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/GameObjects` 过滤器中创建一个新的源文件，命名为 `Component.cpp`，并添加以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the `Component` class can never be instantiated, I have put the preceding
    comments in `Component.cpp` as a reminder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Component` 类永远不能实例化，我将前面的注释放在 `Component.cpp` 中作为提醒。
- en: Coding the collider components
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写碰撞器组件
- en: The Space Invaders ++ game will only have one simple type of collider. It will
    be a rectangular box around the object, just like those we had in the Zombie Apocalypse
    and Pong games. However, it is easily conceivable that you might need other types
    of collider; perhaps a circle-shaped collider or a non-encompassing collider such
    as those we used for the head, feet, and sides of Thomas and Bob back in the Thomas
    Was Late game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 《太空侵略者++》游戏将只包含一种简单的碰撞器类型。它将是一个围绕对象的矩形框，就像我们在《僵尸末日》和《乒乓》游戏中使用的那样。然而，很容易想象你可能需要其他类型的碰撞器；可能是一个圆形碰撞器，或者是一个非包围的碰撞器，就像我们在《托马斯迟到了》游戏中用于托马斯和鲍勃的头、脚和侧面的那些。
- en: For this reason, there will be a base `ColliderComponent` class (that inherits
    from `Component`) which will handle the basic functionality of all the colliders,
    as well as `RectColliderComponent`, which will add the specific functionality
    of an all-encompassing rectangle-shaped collider. New collider types can then
    be added as required for the game being developed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将有一个基类 `ColliderComponent`（继承自 `Component`），它将处理所有碰撞器的基本功能，以及 `RectColliderComponent`，它将添加包围矩形形状碰撞器的特定功能。然后可以根据正在开发的游戏需求添加新的碰撞器类型。
- en: What follows is the base class to the specific collider, `ColliderComponent`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是特定碰撞器的基类，`ColliderComponent`。
- en: Coding the ColliderComponent class
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 `ColliderComponent` 类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `ColliderComponent.h`
    and add the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`过滤器中创建一个新的头文件，命名为`ColliderComponent.h`，并添加以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ColliderComponent` class inherits from the `Component` class. In the preceding
    code, you can see that the `m_Type` member variable is initialized to `"collider"`
    and that `m_Enabled` is initialized to `false`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColliderComponent`类从`Component`类继承。在前面的代码中，你可以看到`m_Type`成员变量被初始化为`"collider"`，而`m_Enabled`被初始化为`false`。'
- en: In the `public` section, the code overrides the pure virtual functions of the
    `Component` class. Study them to become familiar with them because they work in
    a very similar way in all the component classes. The `getType` function returns
    `m_Type`. The `disableComponent` function sets `m_Enabled` to `false`. The `enableComponent`
    function sets `m_Enabled` to `true`. The `enabled` function returns the value
    of `m_Enabled`. The `start` function has no code but will be overridden by many
    of the more specific component-based classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，代码覆盖了`Component`类的纯虚函数。研究它们，以便熟悉它们，因为它们在所有组件类中都以非常相似的方式工作。`getType`函数返回`m_Type`。`disableComponent`函数将`m_Enabled`设置为`false`。`enableComponent`函数将`m_Enabled`设置为`true`。`enabled`函数返回`m_Enabled`的值。`start`函数没有代码，但将被许多更具体的基于组件的类覆盖。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `ColliderComponent.cpp`
    and add the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`过滤器中创建一个新的源文件，命名为`ColliderComponent.cpp`，并添加以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I added the preceding comments to `ColliderComponent.cpp` to remind myself that
    all the functionality is in the header file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`ColliderComponent.cpp`中添加了前面的注释，以提醒自己所有功能都在头文件中。
- en: Coding the RectColliderComponent class
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写RectColliderComponent类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `RectColliderComponent.h`
    and add the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`过滤器中创建一个新的头文件，命名为`RectColliderComponent.h`，并添加以下代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `RectColliderComponent` class inherits from the `ColliderComponent` class.
    It has a `m_SpecificType` variable initialized to `"rect"`. It is now possible
    to query any `RectColliderComponent` instance in a vector of generic `Component`
    instances and determine that it has a type of  `"collider"` and a specific type
    of  `"rect"`. All component-based classes will have this functionality because
    of the pure virtual functions of the `Component` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`RectColliderComponent`类从`ColliderComponent`类继承。它有一个`m_SpecificType`变量，初始化为`"rect"`。现在可以查询向量中的任何`RectColliderComponent`实例，该向量包含通用的`Component`实例，并确定它具有类型`"collider"`和特定类型`"rect"`。所有基于组件的类都将具有此功能，因为这是`Component`类的纯虚函数所提供的。'
- en: There is also a `FloatRect` instance called `m_Collider` that will store the
    coordinates of this collider.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`m_Collider`的`FloatRect`实例，它将存储此碰撞器的坐标。
- en: In the `public` section, we can view the constructor. Notice that it receives
    a `string`. The value that's passed in will be text that identifies the type of
    game object this `RectColliderComponent` is attached to, such as an invader, a
    bullet, or the player's ship. It will then be possible to determine what type
    of objects have collided with each other.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，我们可以查看构造函数。注意，它接收一个`string`。传入的值将是标识此`RectColliderComponent`附加到的游戏对象类型的文本，例如入侵者、子弹或玩家的飞船。这样就可以确定哪些类型的对象相互碰撞了。
- en: There are three more functions before the overridden functions; make a note
    of their names and parameters and then we will discuss them in a moment when we
    code their definitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写函数之前还有三个函数；记下它们的名称和参数，然后我们将在编写它们的定义时稍后讨论它们。
- en: Note that the `getSpecificType` function definition returns `m_SpecificType`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getSpecificType`函数定义返回`m_SpecificType`。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `RectColliderComponent.cpp`
    and add the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`过滤器中创建一个新的源文件，命名为`RectColliderComponent.cpp`，并添加以下代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor, the passed-in `string` value is assigned to the `m_Tag`
    variable and the `getColliderTag` function makes that value available via the
    instance of the class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，传入的`string`值被分配给`m_Tag`变量，而`getColliderTag`函数则通过类的实例使该值可用。
- en: The `setOrMoveCollider` function positions `m_Collider` at the coordinates passed
    in as arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`setOrMoveCollider`函数将`m_Collider`定位到作为参数传入的坐标。'
- en: The `getColliderRectF` function returns a reference to `m_Collider`. This is
    ideal for carrying out a collision test with another collider using the `intersects`
    function of the `FloatRect` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`getColliderRectF`函数返回对`m_Collider`的引用。这非常适合使用`FloatRect`类的`intersects`函数与另一个碰撞器进行碰撞测试。'
- en: Our colliders are now complete and we can move on to the graphics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了碰撞器，可以继续进行图形处理。
- en: Coding the graphics components
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写图形组件
- en: The Space Invaders ++ game will only have one specific type of graphics component.
    It is called `StandardGraphicsComponent`. As with the collider components, we
    will implement a base `GraphicsComponent` class to make it easy to add other graphics-related
    components, should we wish. For example, in the classic arcade version of Space
    Invaders, the invaders flapped their arms up and down with two frames of animation.
    Once you see how `StandardGraphicsComponent` works, you will be able to easily
    code another class (perhaps `AnimatedGraphicsComponent`) that draws itself with
    a different `Sprite` instance every half a second or so. You could also have a
    graphics component that has a shader (perhaps `ShaderGraphicsComponent`) for fast
    and cool effects. There are more possibilities besides these.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Space Invaders ++游戏将只有一种特定的图形组件。它被称为`StandardGraphicsComponent`。与碰撞器组件一样，我们将实现一个基本的`GraphicsComponent`类，以便于将来添加其他图形相关组件。例如，在经典的太空侵略者街机版本中，侵略者会通过两个动画帧上下摆动手臂。一旦你了解了`StandardGraphicsComponent`的工作原理，你将能够轻松地编写另一个类（可能是`AnimatedGraphicsComponent`），它每隔半秒左右使用不同的`Sprite`实例绘制自己。你也可以有一个具有着色器（可能是`ShaderGraphicsComponent`）的图形组件，以实现快速和酷炫的效果。除了这些之外，还有更多可能性。
- en: Coding the GraphicsComponent class
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`GraphicsComponent`类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `GraphicsComponent.h`
    and add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`GraphicsComponent.h`，并添加以下代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of the preceding code implements the `Component` class's pure virtual functions.
    What's new to the `GraphicsComponent` class is the `draw` function, which has
    two parameters. The first parameter is a reference to the `RenderWindow` instance
    so that the component can draw itself, while the second is a shared smart pointer
    to the `TransformComponent` instance of the `GameObject` so that vital data such
    as position and scale can be accessed each frame of the game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的大部分代码实现了`Component`类的纯虚函数。对于`GraphicsComponent`类来说，新的是`draw`函数，它有两个参数。第一个参数是`RenderWindow`实例的引用，以便组件可以绘制自己，而第二个参数是`GameObject`的`TransformComponent`实例的共享智能指针，以便在游戏的每一帧可以访问诸如位置和缩放等关键数据。
- en: What's also new in the `GraphicsComponent` class is the `initializeGraphics`
    function, which also has two parameters. The first is a `string` value that represents
    the file name of the graphics file to be used, while the second is a `Vector2f`
    instance that will represent the size of the object in the game world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeGraphics`函数也是`GraphicsComponent`类中新增的，它也有两个参数。第一个是一个`string`值，表示要使用的图形文件的文件名，而第二个是一个`Vector2f`实例，它将代表游戏世界中对象的大小。'
- en: Both preceding functions are pure virtual, which makes the `GraphicsComponent`
    class abstract. Any class that inherits from `GraphicsComponent` will need to
    implement these functions. In the next section, we will see how `StandardGraphicsComponent`
    does so.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都是纯虚函数，这使得`GraphicsComponent`类成为抽象类。任何从`GraphicsComponent`继承的类都需要实现这些函数。在下一节中，我们将看到`StandardGraphicsComponent`是如何做到这一点的。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `GraphicsComponent.cpp`
    and add the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`GraphicsComponent.cpp`，并添加以下代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding comment is a reminder that the code is all within the related
    header file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的注释是一个提醒，说明代码都在相关的头文件中。
- en: Coding the StandardGraphicsComponent class
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`StandardGraphicsComponent`类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `StandardGraphicsComponent.h`
    and add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`StandardGraphicsComponent.h`，并添加以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `StandardGraphicsComponent` class has a `Sprite` member. It doesn't need
    a `Texture` instance because that will be obtained each frame from the `BitmapStore`
    class. This class also overrides the required functions from both the `Component`
    and `GraphicsComponent` classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardGraphicsComponent`类有一个`Sprite`成员。它不需要一个`Texture`实例，因为每个帧都会从`BitmapStore`类中获取。这个类还重写了`Component`和`GraphicsComponent`类中所需的所有函数。'
- en: Let's code the implementation of the two pure virtual functions, `draw` and
    `initializeGraphics`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编码两个纯虚函数`draw`和`initializeGraphics`的实现。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `StandardGraphicsComponent.cpp`
    and add the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`StandardGraphicsComponent.cpp`，并添加以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `initializeGraphics` function, the `addBitmap` function of the `BitmapStore`
    class is called and the file path of the image, along with the size of the object
    in the game world, is passed in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializeGraphics`函数中，调用了`BitmapStore`类的`addBitmap`函数，并将图像的文件路径以及游戏世界中对象的尺寸传递进去。
- en: Next, the `Texture` instance that was just added to the `BitmapStore` class
    is retrieved and set as the image for the `Sprite`. Following on, two functions,
    `getTexture` and `getSize`, are chained together to get the size of the texture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检索刚刚添加到`BitmapStore`类的`Texture`实例，并将其设置为`Sprite`的图像。随后，将`getTexture`和`getSize`两个函数串联起来以获取纹理的尺寸。
- en: The next line of code uses the `setScale` function to make the `Sprite` the
    same size as the texture, which in turn was set to the size of this object in
    the game world.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码使用`setScale`函数使`Sprite`与纹理大小相同，而纹理的大小被设置为游戏世界中此对象的尺寸。
- en: The `setColor` function then applies a green tint to the `Sprite`. This gives
    it a bit more of a retro feel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`setColor`函数为`Sprite`应用绿色色调。这给它增添了一丝复古的感觉。
- en: In the `draw` function, the `Sprite` is moved into position using `setPosition`
    and the `getLocation` function of `TransformComponent`. We'll code the `TransformComponent`
    class next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`函数中，使用`setPosition`和`TransformComponent`的`getLocation`函数将`Sprite`移动到指定位置。接下来，我们将编码`TransformComponent`类。
- en: The final line of code draws the `Sprite` to `RenderWindow`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码将`Sprite`绘制到`RenderWindow`。
- en: Coding the TransformComponent class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码TransformComponent类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `TransformComponent.h`
    and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`TransformComponent.h`，并添加以下代码：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class has a `Vector2f` to store the position of the object in the game
    world, a `float` to store the height, and another `float` to store the width.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个`Vector2f`用于存储游戏世界中对象的定位，一个`float`用于存储高度，另一个`float`用于存储宽度。
- en: In the `public` section, there is a constructor we will use to set up the instances
    of this class, as well as two functions, `getLocation` and `getSize`, we'll use
    to share the location and size of the object. We  used these functions already
    when we coded the `StandardGraphicsComponent` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，有一个构造函数，我们将使用它来设置此类实例，以及两个函数`getLocation`和`getSize`，我们将使用它们来共享对象的定位和尺寸。我们在编码`StandardGraphicsComponent`类时已经使用了这些函数。
- en: The remaining code in the `TransformComponent.h` file is the implementation
    of the `Component` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformComponent.h`文件中的剩余代码是`Component`类的实现。'
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `TransformComponent.cpp`
    and add the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`TransformComponent.cpp`，并添加以下代码：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing the three functions of this class is straightforward. The constructor
    receives a size and location and initializes the appropriate member variables.
    The `getLocation` and `getSize` functions return this data when it is requested.
    Notice that the values are returned by reference, so they will be modifiable by
    the calling code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类中的三个函数很简单。构造函数接收一个尺寸和一个位置，并初始化相应的成员变量。当请求时，`getLocation`和`getSize`函数返回这些数据。请注意，值是通过引用返回的，因此它们可以被调用代码修改。
- en: Next, we will code all update-related components.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编码所有与更新相关的组件。
- en: Coding update components
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码更新组件
- en: As you might expect by now, we will code an `UpdateComponent` class that will
    inherit from the `Component` class. It will have all the functionality that every
    `UpdateComponent` will need and then we will code classes derived from `UpdateComponent`.
    These will contain functionality specific to individual objects in the game. For
    this game, we will have `BulletUpdateComponent`, `InvaderUpdateComponent`, and
    `PlayerUpdateComponent`. When you work on your own project and you want an object
    in the game that behaves in a specific unique manner, just code a new update-based
    component for it and you'll be good-to-go. Update-based components define behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，我们将编写一个继承自`Component`类的`UpdateComponent`类。它将包含每个`UpdateComponent`所需的所有功能，然后我们将编写从`UpdateComponent`派生的类。这些类将包含针对游戏中单个对象的功能。对于这个游戏，我们将有`BulletUpdateComponent`、`InvaderUpdateComponent`和`PlayerUpdateComponent`。当你在自己的项目中工作时，如果你想创建一个以特定独特方式行为的游戏对象，只需为它编写一个新的基于更新的组件，然后你就可以开始了。基于更新的组件定义行为。
- en: Coding the UpdateComponent class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UpdateComponent类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `UpdateComponent.h`
    and add the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`UpdateComponent.h`，并添加以下代码：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`UpdateComponent` only brings one piece of functionality: the `update` function.
    This function is pure virtual so it must be implemented by any class that aspires
    to be a usable instance of `UpdateComponent`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateComponent`只提供一项功能：`update`函数。这个函数是纯虚函数，因此任何希望成为`UpdateComponent`可用实例的类都必须实现它。'
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `UpdateComponent.cpp`
    and add the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`UpdateComponent.cpp`，并添加以下代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a helpful comment to remind us that this class has all its code in the
    related header file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的注释，提醒我们这个类的所有代码都在相关的头文件中。
- en: Coding the BulletUpdateComponent class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写BulletUpdateComponent类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `BulletUpdateComponent.h`
    and add the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`BulletUpdateComponent.h`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to understand the behavior/logic of a bullet, you will need to spend
    some time learning the names and types of the member variables as I won't be explaining
    precisely how a bullet behaves; we have covered these topics many times. I will,
    however, point out that there are variables to cover basics such as movement,
    variables to help randomize the speed of each bullet within a certain range, and
    Booleans that identify whether the bullet belongs to the player or an invader.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解子弹的行为/逻辑，你需要花一些时间学习成员变量名称和类型，因为我不会精确解释子弹是如何行为的；我们已经多次覆盖了这些主题。然而，我会指出，有一些变量用于处理基本操作，如移动，还有一些变量用于帮助在特定范围内随机化每颗子弹的速度，以及布尔值用于标识子弹属于玩家还是入侵者。
- en: The key thing which you don't yet know but will have to learn here is that each
    `BulletUpdateComponent` instance will hold a shared pointer to the owning game
    object's `TransformComponent` instance and a shared pointer to the owning game
    object's `RectColliderComponent` instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在还不知道但必须在这里学习的关键点是，每个`BulletUpdateComponent`实例将持有对拥有游戏对象的`TransformComponent`实例的共享指针和对拥有游戏对象的`RectColliderComponent`实例的共享指针。
- en: Now, look closely at the overridden `start` function. In the `start` function,
    the aforementioned shared pointers are initialized. The code achieves this by
    using the `getComponentByTypeAndSpecificType` function of the owning game object
    (`self`), which is a pointer to the owning game object. We will code the `GameObject`
    class, including this function, in a later section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仔细看看重写的`start`函数。在`start`函数中，上述共享指针被初始化。代码通过使用拥有游戏对象的`getComponentByTypeAndSpecificType`函数（`self`是一个指向拥有游戏对象的指针）来实现这一点。我们将在稍后的部分中编码`GameObject`类，包括这个函数。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `BulletUpdate.cpp`
    and add the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`BulletUpdate.cpp`，并添加以下代码：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first two functions are unique to the `BulletUpdateComponent` class; they
    are `spawnForPlayer` and `spawnForInvader`. Both of these functions prepare the
    member variables, transform component and collider component for action. Each
    one does so in a slightly different way. For example, for a player-owned bullet,
    it is prepared to move up the screen from the top of the player's ship, while
    a bullet is prepared for an invader to move down the screen from the underside
    of an invader. The key thing to notice is that all this is achievable via the
    shared pointers to the transform component and the collider component. Also, note
    that the `m_IsSpawned` Boolean is set to true, making this update component's
    `update` function ready to call each frame of the game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数是 `BulletUpdateComponent` 类独有的；它们是 `spawnForPlayer` 和 `spawnForInvader`。这两个函数都为成员变量、变换组件和碰撞器组件准备行动。每个都略有不同。例如，对于玩家拥有的子弹，它被准备从玩家的船顶向上移动，而对于入侵者的子弹，它被准备从入侵者的底部向下移动屏幕。要注意的关键是，所有这些都可以通过变换组件和碰撞器组件的共享指针来实现。此外，请注意，`m_IsSpawned`
    布尔值被设置为 true，这使得这个更新组件的 `update` 函数准备好在每一帧调用游戏。
- en: In the `update` function, the bullet is moved up or down the screen at the appropriate
    speed. It is tested to see if it has disappeared off the top or bottom of the
    screen, and the collider is updated to wrap around the current location so that
    we can test for collisions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `update` 函数中，子弹以适当的速度在屏幕上下移动。它被测试以查看是否已经消失在屏幕顶部或底部，并且碰撞器被更新以包裹当前位置，以便我们可以测试碰撞。
- en: This is the same logic we have seen throughout this book; what's new is the
    shared pointers we are using to communicate with the other components that make
    up this game object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在这本书中看到的相同逻辑；新的地方是我们用来与其他组成游戏对象的组件通信的共享指针。
- en: The bullets just need to be spawned and tested for collisions; we will see how
    to do that in the next two chapters. Now, we will code the behavior of the invaders.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹只需要被生成并测试碰撞；我们将在下一章中看到如何做。现在，我们将编写入侵者的行为代码。
- en: Coding the InvaderUpdateComponent class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 InvaderUpdateComponent 类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `InvaderUpdateComponent.h`
    and add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/GameObjects` 过滤器中创建一个新的头文件，命名为 `InvaderUpdateComponent.h`，并添加以下代码：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the class declaration, we can see all the features that we need in order
    to code the behavior of an invader. There is a pointer to the transform component
    so that the invader can move, as well as a pointer to the collider component so
    that it can update its location and be collided with:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中，我们可以看到编写入侵者行为所需的全部功能。有一个指向变换组件的指针，这样入侵者就可以移动，以及一个指向碰撞器组件的指针，这样它就可以更新其位置并被碰撞：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are pointers to the player''s transform and collider so that an invader
    can query the position of the player and make decisions about when to shoot bullets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有指向玩家变换和碰撞器的指针，这样入侵者可以查询玩家的位置并决定何时射击子弹：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, there is a `BulletSpawner` instance, which we will code in the next chapter.
    The `BulletSpawner` class will allow an invader or the player to spawn a bullet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个 `BulletSpawner` 实例，我们将在下一章中编写。`BulletSpawner` 类将允许入侵者或玩家生成子弹。
- en: 'What follows is a whole bunch of variables that we will use to control the
    speed, direction, rate of fire, the precision with which the invader aims, and
    the speed of bullets that are fired. Familiarize yourself with them as they will
    be used in fairly in-depth logic in the function definitions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一系列我们将用来控制速度、方向、射击速率、入侵者瞄准的精确度以及发射子弹速度的变量。熟悉它们，因为它们将在函数定义中的相当深入的逻辑中使用：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can see three new public functions that different parts of the system
    can call to make the invaders move down a little and head in the other direction,
    test the direction of travel, and pass in a pointer to the aforementioned `BulletSpawner`
    class, respectively:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到三个新的公共函数，系统中的不同部分可以调用这些函数使入侵者稍微向下移动并改变方向，测试移动方向，并分别传递上述 `BulletSpawner`
    类的指针：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to study the `start` function where the smart pointers to the invader
    and the player are initialized. Now, we will code the function definitions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要研究 `start` 函数，其中初始化了指向入侵者和玩家的智能指针。现在，我们将编写函数定义。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `InvaderUpdate.cpp`
    and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/GameObjects` 过滤器中创建一个新的源文件，名为 `InvaderUpdate.cpp`，并添加以下代码：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That was a lot of code. Actually, there's no C++ code in there that we haven't
    seen before. It is all just logic to control the behavior of an invader. Let's
    get an overview of what it all does, with parts of the code reprinted for convenience.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多。实际上，其中没有我们之前没有见过的 C++ 代码。它只是控制入侵者行为的逻辑。让我们概述一下它所做的一切，并方便地重新打印部分代码。
- en: Explaining the update function
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `update` 函数
- en: 'The first `if` and `else` blocks move the invader right or left each frame,
    as appropriate:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `if` 和 `else` 块根据需要将入侵者向右或向左移动每一帧：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, the collider is updated to the new position:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将碰撞器更新到新位置：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code tracks how long it''s been since this invader last fired a shot and
    then tests to see if the player is one world unit to the left or right of the
    invader (+ or – for the random accuracy modifier, so that each invader is a little
    bit different):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码追踪自上次入侵者开火以来已经过去的时间，然后测试玩家是否位于入侵者左侧或右侧一个世界单位的位置（+ 或 - 用于随机精度修正，使得每个入侵者都略有不同）：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the preceding `if` test, another test makes sure that the invader has
    waited long enough since the last shot it took. If it has, then a shot is taken.
    A sound is played, a spawn location for the bullet is calculated, the `spawnBullet`
    function of the `BulletSpawner` instance is called, and a new random time to wait
    before another shot can be taken is calculated:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `if` 测试中，另一个测试确保入侵者自上次射击以来已经等待了足够长的时间。如果是这样，那么就会开火。播放声音，计算子弹的生成位置，调用 `BulletSpawner`
    实例的 `spawnBullet` 函数，并计算下一次射击前的新随机等待时间：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The details of the `BulletSpawner` class will be revealed in the next chapter,
    but as a glimpse into the future, it will be an abstract class with one function
    called `spawnBullet` and will be inherited from by the `GameScreen` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulletSpawner` 类的详细信息将在下一章中揭晓，但作为一个对未来的预览，它将是一个具有一个名为 `spawnBullet` 的函数的抽象类，并将由
    `GameScreen` 类继承。'
- en: Explaining the dropDownAndReverse function
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `dropDownAndReverse` 函数
- en: 'In the `dropDownAndReverse` function, the direction is reversed and the vertical
    location is increased by the height of an invader. In addition, the speed of the
    invader is increased relative to how many waves the player has cleared and how
    many invaders remain to be destroyed. The more waves that are cleared and the
    fewer invaders remaining, the faster the invaders will move:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dropDownAndReverse` 函数中，方向被反转，垂直位置增加一个入侵者的高度。此外，入侵者的速度相对于玩家清除的波数和剩余要摧毁的入侵者数量而增加。清除的波数越多，剩余的入侵者越少，入侵者的移动速度就越快：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next function is simple but included for the sake of completeness.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数很简单，但为了完整性而包含在内。
- en: Explaining the isMovingRight function
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `isMovingRight` 函数
- en: 'This code simply provides access to the current direction of travel:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地提供了访问当前移动方向的方法：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It will be used to test whether to look out for collisions with the left of
    the screen (when moving left) or the right of the screen (when moving right) and
    will allow the collision to trigger a call to the `dropDownAndReverse` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它将用于测试是否需要检查屏幕左侧（当向左移动时）或右侧（当向右移动时）的碰撞，并允许碰撞触发对 `dropDownAndReverse` 函数的调用。
- en: Explaining the initializeBulletSpawner function
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `initializeBulletSpawner` 函数
- en: 'I have already mentioned that the `BulletSpawner` class is abstract and will
    be implemented by the `GameScreen` class. When the `GameScreen` class'' `initialize`
    function is called, this `initializeBulletSpawner` function will be called on
    each of the invaders. As you can see, the first parameter is a pointer to a `BulletSpawner`
    instance. This gives every `InvaderUpdateComponent` the ability to call the `spawnBullet`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到过，`BulletSpawner` 类是抽象的，将由 `GameScreen` 类实现。当调用 `GameScreen` 类的 `initialize`
    函数时，这个 `initializeBulletSpawner` 函数将在每个入侵者上被调用。正如你所看到的，第一个参数是 `BulletSpawner`
    实例的指针。这使每个 `InvaderUpdateComponent` 都能够调用 `spawnBullet` 函数：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The rest of the code in the `initializeBulletSpawner` function sets up the random
    values that make each invader behave slightly differently from the others.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeBulletSpawner` 函数中的其余代码设置了使每个入侵者与其他入侵者略有不同行为的随机值。'
- en: Coding the PlayerUpdateComponent class
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 `PlayerUpdateComponent` 类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `PlayerUpdateComponent.h`
    and add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/GameObjects` 过滤器中创建一个新的头文件，命名为 `PlayerUpdateComponent.h`，并添加以下代码：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `PlayerUpdateComponent` class, we have all the Boolean variables needed
    to keep track of whether the player is holding down a keyboard key, as well as
    functions that can toggle these Boolean values. We haven't seen anything like
    the `m_XExtent` and `M_YExtent float` type variables before and we will explain
    them when we look at their usage in the function definitions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlayerUpdateComponent` 类中，我们拥有所有必要的布尔变量来跟踪玩家是否按下了键盘键，以及可以切换这些布尔值的函数。我们之前没有见过像
    `m_XExtent` 和 `M_YExtent float` 类型变量这样的东西，我们将在查看它们在函数定义中的使用时解释它们。
- en: Note, just like the `BulletUpdateComponent` and the `InvaderUpdateComponent`
    classes, that we have shared pointers to this game object's transform and collider
    components. These shared pointers, as we are coming to expect, are initialized
    in the `start` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像 `BulletUpdateComponent` 和 `InvaderUpdateComponent` 类一样，我们为这个游戏对象的变换和碰撞组件使用了共享指针。正如我们所期待的，这些共享指针在
    `start` 函数中被初始化。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `PlayerUpdate.cpp`
    and add the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/GameObjects` 过滤器中创建一个新的源文件，命名为 `PlayerUpdate.cpp`，并添加以下代码：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the first `if` block of the update function, the condition is `sf::Joystick::isConnected(0)`.
    This condition returns true when the player has a gamepad plugged in to a USB
    port. Inside the `if` block, the location of both the horizontal and vertical
    positions of the transform component are altered:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新函数的第一个 `if` 块中，条件是 `sf::Joystick::isConnected(0)`。当玩家将游戏手柄插入 USB 端口时，此条件返回
    true。在 `if` 块内部，变换组件的水平和垂直位置都被改变了：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code divides the target speed by 100 before multiplying it by
    `m_YExtent`. `The m_XExtent` and `m_YExtent` variables will be updated each frame
    to hold values that represent the extent to which the player has moved their gamepad
    thumbstick in a horizontal and vertical direction. The range of values is from
    -100 to 100, and so the preceding code has the effect of moving the transform
    component at full speed in any direction when the thumbstick is positioned at
    any of its full extents or a fraction of that speed when it is partially positioned
    between the center (not moving at all) and its full extent. This means that the
    player will have finer control over the speed of the ship should they opt to use
    a gamepad instead of the keyboard.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在将目标速度乘以 `m_YExtent` 之前将其除以 100。`m_XExtent` 和 `m_YExtent` 变量将在每一帧更新，以保存表示玩家在水平和垂直方向上移动游戏手柄摇杆的程度。值的范围是从
    -100 到 100，因此上述代码的效果是当摇杆位于任何全范围或该范围的分数之一时，以全速移动变换组件；当它部分位于中心（完全不移动）和全范围之间时，则以该速度的分数移动。这意味着如果玩家选择使用游戏手柄而不是键盘，他们将能够更精细地控制飞船的速度。
- en: We will see more details about the operation of the gamepad in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)中看到更多关于游戏手柄操作细节，*使用游戏对象和构建游戏*。
- en: The rest of the `update` function responds to the Boolean variables, which represent
    the keyboard keys that the player is holding down or has released.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数的其余部分响应代表玩家按下的或释放的键盘键的布尔变量。'
- en: After the gamepad and keyboard handling, the collider component is moved into
    the new position and a series of `if` blocks ensures the player ship can't move
    outside of the screen or above the half-way-up point on the screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理游戏手柄和键盘之后，碰撞组件被移动到新位置，一系列的 `if` 块确保玩家飞船不会移出屏幕或超过屏幕中间的上方点。
- en: The next function is the `updateShipTravelWithController` function; when a controller
    is plugged in, it will update the extent to which the thumbstick is moved or at
    rest for each frame.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是 `updateShipTravelWithController` 函数；当控制器被插入时，它将更新每一帧拇指摇杆移动或静止的程度。
- en: The remaining functions update the Boolean values that indicate whether keyboard
    keys are being used to move the ship. Notice that the update component does not
    handle firing a bullet. We could have handled it from here, and some games might
    have a good reason to do so. In this game, it was slightly more direct to handle
    shooting a bullet from the `GameInputHandler` class. The `GameInputHandler` class,
    as we will see in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*, will call all the functions that let
    the `PlayerUpdateComponent` class know what is happening with the gamepad and
    keyboard. We coded the basics of keyboard responses in the `GameInputHandler`
    class in the previous chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的函数更新表示是否使用键盘按键来移动飞船的布尔值。请注意，更新组件不处理发射子弹。我们本来可以在这里处理它，而且有些游戏可能出于某些原因这样做。在这个游戏中，从`GameInputHandler`类中处理射击子弹要直接一些。正如我们将在[*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)中看到的那样，`GameInputHandler`类将调用所有让`PlayerUpdateComponent`类知道游戏手柄和键盘发生什么的函数。在前一章中，我们在`GameInputHandler`类中编写了键盘响应的基本代码。
- en: Now, let's code the `GameObject` class, which will hold all the various component
    instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来编写`GameObject`类，它将包含所有各种组件实例。
- en: Coding the GameObject class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码GameObject类
- en: 'I am going to go through the code in this class in quite a lot of detail because
    it is key to how all the other classes work. I think you will benefit, however,
    from seeing the code in its entirety and studying it first. With this in mind,
    create a new header file in the `Header Files/GameObjects` filter called `GameObject.h`
    and add the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这个课程中非常详细地讲解代码，因为它对于其他所有课程的工作原理至关重要。然而，我认为你们通过查看整个代码并首先研究它，也会有所收获。考虑到这一点，在`Header
    Files/GameObjects`过滤器中创建一个新的头文件，命名为`GameObject.h`，并添加以下代码：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, be sure to closely examine the variables, types, function
    names, and their parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请务必仔细检查变量、类型、函数名及其参数。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `GameObject.cpp`
    and then study and add the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`过滤器中创建一个新的源文件，命名为`GameObject.cpp`，然后研究并添加以下代码：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to study the preceding code before moving on. The explanations that
    follow assume that you have a basic awareness of variable names and types, as
    well as function names, parameters, and return types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请务必研究前面的代码。以下解释假设你们对变量名和类型、函数名、参数和返回类型有基本了解。
- en: Explaining the GameObject class
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释GameObject类
- en: Let's go through the `GameObject` class one function at a time and reprint the
    code to make it easy to discuss.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个函数地查看`GameObject`类，并重新打印代码，以便于讨论。
- en: Explaining the update function
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释update函数
- en: The `update` function is called once for each frame of the game loop for each
    game object. Like most of our other projects, the current frame rate is required.
    Inside the `update` function, a test is done to see if this `GameObject` instance
    is active and has an update component. A game object does not have to have an
    update component, although it is true that all the game objects in this project
    do.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数在游戏循环的每一帧为每个游戏对象调用一次。像我们的大多数其他项目一样，需要当前帧率。在`update`函数内部，会进行一个测试，以查看这个`GameObject`实例是否处于活动状态并且有一个更新组件。游戏对象不必有更新组件，尽管在这个项目中所有游戏对象确实都有。'
- en: Next, the `update` function loops through all the components it has, starting
    from `m_FirstUpdateComponent` through to `m_FirstUpdateComponent + m_NumberUpdateComponents`.
    This code implies that a game object can have multiple update components. This
    is so that you can design game objects with layers of behavior. This layering
    of behavior is discussed further in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*. All the game objects in this project
    have just one update component, so you could simplify (and speed up) the logic
    in the `update` function, but I suggest leaving it as it is until you have read
    [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445), *Using Game Objects
    and Building a Game*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`update` 函数遍历它拥有的所有组件，从 `m_FirstUpdateComponent` 开始，一直到 `m_FirstUpdateComponent
    + m_NumberUpdateComponents`。这段代码暗示一个游戏对象可以拥有多个更新组件。这样你可以设计具有行为层的游戏对象。这种行为分层在[*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*中进一步讨论。在这个项目中，所有游戏对象只有一个更新组件，因此你可以简化（并加快）`update`
    函数中的逻辑，但我建议在阅读[*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*之前保持原样。
- en: 'It is because a component could be one of many types that we create a temporary
    update-related component (`tempUpdate`), cast the component from the vector of
    components to `UpdateComponent`, and call the `update` function. It doesn''t matter
    about the specific derivation of the `UpdateComponent` class; it will have the
    `update` function implemented, so the `UpdateComponent` type is specific enough:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为一个组件可能是我们创建的许多类型之一，所以我们创建一个临时的更新相关组件（`tempUpdate`），将组件从组件向量转换为 `UpdateComponent`，并调用
    `update` 函数。`UpdateComponent` 类的具体派生并不重要；它将实现 `update` 函数，因此 `UpdateComponent`
    类型足够具体：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we get to the `addComponent` function in a later section, we will see how
    we can initialize the various control variables, such as `m_FirstUpdateComponentLocation`
    and `m_NumberOfUpdateComponents`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在后面的部分到达 `addComponent` 函数时，我们将看到如何初始化各种控制变量，例如 `m_FirstUpdateComponentLocation`
    和 `m_NumberOfUpdateComponents`。
- en: Explaining the draw function
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释绘制函数
- en: 'The `draw` function checks whether the game object is active and that it has
    a graphics component. If it does, then a check is done to see if the graphics
    component is enabled. If all these tests succeed, then the `draw` function is
    called:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数检查游戏对象是否处于活动状态并且它有一个图形组件。如果确实如此，则检查图形组件是否启用。如果所有这些测试都成功，则调用 `draw`
    函数：'
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The structure of the `draw` function implies that not every game object has
    to draw itself. I mentioned in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372),
    *Game Programming Design Patterns – Starting the Space Invaders ++ Game*, that
    you might want game objects that can never be seen to act as invisible trigger
    regions (with no graphics component) that respond when the player passes over
    them or game objects that remain invisible temporarily (temporarily disabled but
    with a graphics component). In this project, all game objects have a permanently
    enabled graphics component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数的结构暗示并非每个游戏对象都必须自己绘制。我在[*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)，*游戏编程设计模式
    – 开始 Space Invaders ++ 游戏*中提到，你可能希望游戏对象作为不可见的触发区域（没有图形组件）来响应玩家经过它们，或者作为暂时不可见的游戏对象（暂时禁用但具有图形组件）。在这个项目中，所有游戏对象都有一个永久启用的图形组件。'
- en: Explaining the getGraphicsComponent function
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释获取图形组件函数
- en: 'This function returns a shared pointer to the graphics component:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个指向图形组件的共享指针：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `getGraphicsComponent` function gives any code that has an instance of the
    contained game object access to the graphics component.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGraphicsComponent` 函数允许任何拥有包含的游戏对象实例的代码访问图形组件。'
- en: Explaining the getTransformComponent function
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释获取变换组件函数
- en: 'This function returns a shared pointer to the transform component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个指向变换组件的共享指针：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `getTransformComponent` function gives any code that has an instance of
    the contained game object access to the transform component.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTransformComponent` 函数允许任何拥有包含的游戏对象实例的代码访问变换组件。'
- en: Explaining the addComponent function
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释添加组件函数
- en: The `addComponent` function will be used by a factory pattern class we will
    code in the next chapter. The function receives a shared pointer to a `Component`
    instance. The first thing that happens inside the function is that the `Component`
    instance is added to the `m_Components` vector. Next, the component is enabled
    using the `enabled` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`addComponent` 函数将在下一章中编写的工厂模式类中使用。该函数接收一个指向 `Component` 实例的共享指针。函数内部首先发生的事情是将
    `Component` 实例添加到 `m_Components` 向量中。接下来，使用 `enabled` 函数启用该组件。'
- en: What follows is a series of `if` and `else if` statements that deal with each
    possible type of component. When the type of a component is identified, the various
    control variables are initialized to enable the logic in the rest of the class
    to work correctly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一系列 `if` 和 `else if` 语句，用于处理每种可能的组件类型。当识别出组件的类型时，各种控制变量被初始化，以使类中其余部分的逻辑能够正确工作。
- en: For example, if an update component is detected, then the `m_HasUpdateComponent`,
    `m_NumberUpdateComponents`, and `m_FirstUpdateComponentLocation` variables are
    initialized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果检测到更新组件，则初始化 `m_HasUpdateComponent`、`m_NumberUpdateComponents` 和 `m_FirstUpdateComponentLocation`
    变量。
- en: 'As another example, if a collider component is detected along with the `rect`
    specific type, then the `m_HasCollider`, `m_NumberRectColliderComponents`, and
    `m_FirstRectColliderComponent` variables are initialized:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，如果检测到具有 `rect` 特定类型的碰撞器组件，则初始化 `m_HasCollider`、`m_NumberRectColliderComponents`
    和 `m_FirstRectColliderComponent` 变量：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the `GameObject` class plays no part in configuring or setting up
    the actual components themselves. It is all handled in the factory pattern class
    we will code in the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GameObject` 类在配置或设置实际组件方面不起作用。所有这些都在下一章中我们将编写的工厂模式类中处理。
- en: Explaining the getter and setter functions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释获取器和设置器函数
- en: 'The following code is a series of very simple getters and setters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一系列非常简单的获取器和设置器：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding getters and setters provide information about a game object, such
    as whether it is active and what its tag is. They also allow you to set the tag
    and tell us whether or not the game object is active.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的获取器和设置器函数提供了有关游戏对象的信息，例如它是否处于活动状态以及它的标签是什么。它们还允许您设置标签并告诉我们游戏对象是否处于活动状态。
- en: Explaining the start function
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `start` 函数
- en: 'The `start` function is an important one. As we saw when we coded all the components,
    the `start` function gives access to any component in any game object the components
    of any other game object. The `start` function is called once all the `GameObject`
    instances have been composed from all their components. In the next chapter, we
    will see how this happens, as well as when the `start` function is called on every
    `GameObject` instance. As we can see, in the `start` function, it loops through
    every component and shares a new class instance, a `GameObjectSharer` instance.
    This `GameObjectSharer` class will be coded in the next chapter and will give
    access to any component from any class. We saw how the invaders need to know where
    the player is and how the `GameObjectSharer` parameter is used when we coded the
    various components. When `start` is called on each component, the `this` pointer
    is also passed in to give each component easy access to its contained `GameObject`
    instance:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 函数非常重要。正如我们在编写所有组件时看到的那样，`start` 函数提供了访问任何游戏对象中任何组件的能力。当所有 `GameObject`
    实例都由其组件组成后，将调用 `start` 函数。在下一章中，我们将看到这是如何发生的，以及 `start` 函数在每一个 `GameObject` 实例上被调用的时机。正如我们所见，在
    `start` 函数中，它遍历每个组件并共享一个新的类实例，一个 `GameObjectSharer` 实例。这个 `GameObjectSharer` 类将在下一章中编写，并将提供从任何类访问任何组件的能力。我们看到了入侵者需要知道玩家的位置以及当编写各种组件时如何使用
    `GameObjectSharer` 参数。当对每个组件调用 `start` 时，也会传入 `this` 指针，以便每个组件可以轻松访问其包含的 `GameObject`
    实例：'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's move on to the `getComponentByTypeAndSpecificType` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 `getComponentByTypeAndSpecificType` 函数。
- en: Explaining the getComponentByTypeAndSpecificType function
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getComponentByTypeAndSpecificType` 函数
- en: 'The `getComponentByTypeAndSpecificType` function has a nested `for` loop that
    looks for a match of a component type to the first `string` parameter and then
    looks for a match of the specific component type in the second `string` parameter.
    It returns a shared pointer to a base class `Component` instance. This implies
    that the calling code needs to know exactly what derived `Component` type is being
    returned so that it can cast it to the required type. This shouldn''t be a problem
    because, of course, they are requesting both a type and a specific type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`getComponentByTypeAndSpecificType` 函数有一个嵌套的 `for` 循环，用于查找与第一个 `string` 参数匹配的组件类型，然后查找第二个
    `string` 参数中特定组件类型的匹配项。它返回一个指向基类 `Component` 实例的共享指针。这意味着调用代码需要确切知道返回的是哪种派生 `Component`
    类型，以便将其转换为所需类型。这不应该是一个问题，因为他们当然请求了类型和特定类型：'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code in this function is quite slow and is therefore intended for use outside
    of the main game loop. At the end of this function, the code writes an error message
    to the console if `debuggingErrors` has been defined. The reason for this is because,
    if execution reaches this point, it means that no matching component was found,
    and the game will crash. The output to the console should make the error easy
    to find. The cause of the crash would be that the function was called for an invalid
    type or specific type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的代码相当慢，因此它打算在主游戏循环之外使用。在函数的末尾，如果已经定义了 `debuggingErrors`，代码将向控制台写入错误信息。这是因为，如果执行到达这个点，意味着没有找到匹配的组件，游戏将会崩溃。控制台输出的信息应该使得错误易于查找。崩溃的原因可能是函数被调用时使用了无效的类型或特定类型。
- en: Explaining the getEncompassingRectCollider function
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getEncompassingRectCollider` 函数
- en: 'The `getEncompassingRectCollider` function checks whether the game object has
    a collider and, if it has, returns it to the calling code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`getEncompassingRectCollider` 函数检查游戏对象是否有碰撞体，如果有，则将其返回给调用代码：'
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is worth noting that, if you extend this project to handle more than one
    type of collider, then this code would need adapting too.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你将此项目扩展以处理多种类型的碰撞体，那么这段代码也需要进行修改。
- en: Explaining the getEncompassingRectColliderTag function
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getEncompassingRectColliderTag` 函数
- en: 'This simple function returns the tag of the collider. This will be useful for
    determining what type of object is being tested for collision:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数返回碰撞体的标签。这将有助于确定正在测试碰撞的对象类型：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have just a few more functions to discuss.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个函数需要讨论。
- en: Explaining the getFirstUpdateComponent function
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getFirstUpdateComponent` 函数
- en: '`getFirstUpdateComponent` uses the `m_FirstUpdateComponent` variable to locate
    the update component and then returns it to the calling code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFirstUpdateComponent` 使用 `m_FirstUpdateComponent` 变量来定位更新组件，并将其返回给调用代码：'
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now we're just going to go over a couple of getters, and then we are done.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将简要介绍几个获取器，然后我们就完成了。
- en: Explaining the final getter functions
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释最终的获取器函数
- en: 'These two remaining functions return a Boolean (each) to tell the calling code
    whether the game object has a collider and/or an update component:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个剩余的函数返回一个布尔值（每个），以告知调用代码游戏对象是否有碰撞体和/或更新组件：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have coded the `GameObject` class in full. We can now look at putting it
    (and all the components it will be composed of) to work.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完整地编写了 `GameObject` 类。现在我们可以看看如何使用它（以及它将包含的所有组件）。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have completed all the code that will draw our game objects
    to the screen, control their behavior, and let them interact with other classes
    through collisions. The most important thing to take away from this chapter is
    not how any of the specific component-based classes work but how flexible the
    Entity-Component system is. If you want a game object that behaves in a certain
    way, create a new update component. If it needs to know about other objects in
    the game, get a pointer to the appropriate component in the `start` function.
    If it needs to be drawn in a fancy manner, perhaps with a shader or an animation,
    code a graphics component that performs the actions in the `draw` function. If
    you need multiple colliders, like we did for Thomas and Bob in the Thomas Was
    Late project, this is no problem: code a new collider-based component.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经完成了所有将游戏对象绘制到屏幕上、控制它们的行为以及通过碰撞让它们与其他类交互的代码。从本章中要吸取的最重要的一点不是任何特定基于组件的类是如何工作的，而是实体-组件系统是多么灵活。如果你想创建一个以某种方式行为的游戏对象，就创建一个新的更新组件。如果它需要了解游戏中的其他对象，可以在`start`函数中获取适当的组件指针。如果它需要以某种花哨的方式绘制，比如使用着色器或动画，就在`draw`函数中编写一个执行这些操作的图形组件。如果你需要多个碰撞器，就像我们在《托马斯迟到了》项目中为托马斯和鲍勃做的，这没有任何问题：编写一个新的基于碰撞器的组件。
- en: In the next chapter, we will code the file input and output system, as well
    as the class that will be the factory that builds all the game objects and composes
    them with components.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写文件输入和输出系统，以及将构建所有游戏对象并将它们与组件组合的工厂类。
