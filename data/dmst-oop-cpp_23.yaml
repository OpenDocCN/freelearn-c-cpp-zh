- en: '*Chapter 19*: Using the Singleton Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第19章*：使用单例模式'
- en: This chapter will continue our goal to expand your C++ programming skills beyond
    core OOP concepts, with the objective of empowering you to solve recurring types
    of coding conundrums utilizing core design patterns. Utilizing design patterns
    in coding solutions can not only provide refined solutions but contribute to easier
    code maintenance and provide potential opportunities for code reuse.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展您的C++编程技能，超越核心面向对象编程概念，旨在让您能够利用核心设计模式解决重复出现的编码难题。在编码解决方案中使用设计模式不仅可以提供精炼的解决方案，还有助于更轻松地维护代码，并为代码重用提供潜在机会。
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Singleton pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在C++中有效实现**单例模式**，这是下一个核心设计模式。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the Singleton pattern and how it contributes to OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单例模式及其对面向对象编程的贡献
- en: Implement the Singleton pattern in C++ (with a simple versus a paired-class
    approach); using a registry to allow many classes to utilize the Singleton pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中实现单例模式（使用简单的对类方法和配对类方法的方法）；使用注册表允许多个类利用单例模式
- en: By the end of this chapter, you will understand the Singleton pattern and how
    it can be used to ensure that only a single instance of a given type can exist.
    Adding an additional core design pattern to your knowledge set will further augment
    your programming skills to help you become a more valuable programmer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解单例模式以及如何使用它来确保给定类型只能存在一个实例。将另一个核心设计模式添加到您的知识体系中，将进一步增强您的编程技能，帮助您成为更有价值的程序员。
- en: Let's increase our programming skillset by examining another common design pattern,
    the Singleton pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究另一个常见的设计模式，单例模式，来增强我们的编程技能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for the full program examples in this chapter can be found at the
    following GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter19` in a file named `Chp19-Ex1.cpp` in the aforementioned GitHub repo.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中完整程序示例的代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与当前章节号对应，后跟当前章节中的示例编号。例如，本章中的第一个完整程序可以在名为`Chp19-Ex1.cpp`的文件中的`Chapter19`子目录中找到上述GitHub存储库中。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f2dKZb](https://bit.ly/3f2dKZb).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/3f2dKZb](https://bit.ly/3f2dKZb)。
- en: Understanding the Singleton pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单例模式
- en: The Singleton pattern is a creational design pattern that guarantees only one
    instance will exist for a class embracing this idiom; two or more instances of
    the type can simply not exist simultaneously. A class embracing this pattern is
    known as a **Singleton**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一种创建型设计模式，它保证了一个类只会存在一个实例；该类型的两个或更多实例根本不可能同时存在。采用这种模式的类被称为**单例**。
- en: A Singleton can be implemented using static data members and static methods.
    This means that a Singleton will have a global point of access to the instance
    at hand. This ramification initially seems dangerous; introducing global state
    information into the code is one criticism that has led the Singleton to sometimes
    be considered an anti-pattern. However, with the appropriate use of access regions
    for the static data members defining the Singleton, we can insist that access
    to the Singleton (other than initialization) only use the appropriate static methods
    of the class at hand (and alleviate this potential pattern concern).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式可以使用静态数据成员和静态方法来实现。这意味着单例将在全局范围内访问当前实例。这一影响起初似乎很危险；将全局状态信息引入代码是对单例模式的一种批评，有时会被认为是一种反模式。然而，通过对定义单例的静态数据成员使用访问区域的适当使用，我们可以坚持只使用当前类的适当静态方法访问单例（除了初始化），从而减轻这种潜在的模式问题。
- en: Another criticism of the pattern is that it is not thread-safe. There may be
    race conditions to enter the segment of code where the Singleton instance is created.
    Without guaranteeing mutual exclusivity to that critical region of code, the Singleton
    pattern will break, allowing multiple such instances. As such, if multi-threaded
    programming will be employed, so must proper locking mechanisms to protect the
    critical region of code where the Singleton is instantiated. A Singleton (implemented
    using static memory) is stored in shared memory between threads in the same process;
    at times Singletons can be criticized for monopolizing resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的另一个批评是它不是线程安全的。可能存在竞争条件，以进入创建单例实例的代码段。如果不保证对该关键代码区域的互斥性，单例模式将会破坏，允许多个这样的实例存在。因此，如果将使用多线程编程，必须使用适当的锁定机制来保护创建单例的关键代码区域。使用静态内存实现的单例存储在同一进程中的线程之间的共享内存中；有时会因为垄断资源而批评单例。
- en: The Singleton pattern can utilize several techniques for implementation. Each
    manner of implementation will inevitably have benefits and drawbacks. We will
    use a pair of related classes, `Singleton` and `SingletonDestroyer`, to robustly
    fulfill the pattern. Whereas there are more simple, straightforward implementations
    (one of which we will briefly review), the simplest techniques leave the possibility
    that the Singleton will not be adequately destructed. Recall, a destructor may
    include important and necessary activities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton模式可以利用多种实现技术。每种实现方式都必然会有利弊。我们将使用一对相关的类`Singleton`和`SingletonDestroyer`来强大地实现该模式。虽然还有更简单、直接的实现方式（我们将简要回顾其中一种），但最简单的技术留下了Singleton可能不会被充分销毁的可能性。请记住，析构函数可能包括重要和必要的活动。
- en: Singletons tend to be long-lived; it is therefore appropriate for a Singleton
    to be destructed just before the application terminates. Many clients may have
    pointers to a Singleton, so that no single client should delete the Singleton.
    We will see that a `Singleton` will be *self-created*, so that it should ideally
    be *self-destructed* (that is, with the help of its `SingletonDestroyer`). As
    such, the paired-class approach, though not as simple, will ensure proper `Singleton`
    destruction. Note that our implementation will also allow the Singleton to be
    directly deleted; this is rare, but our code will also handle this situation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton通常具有长寿命；因此，在应用程序终止之前销毁Singleton是合适的。许多客户端可能有指向Singleton的指针，因此没有一个客户端应该删除Singleton。我们将看到`Singleton`将是*自行创建*的，因此它应该理想地*自行销毁*（即通过其`SingletonDestroyer`的帮助）。因此，配对类方法虽然不那么简单，但将确保正确的`Singleton`销毁。请注意，我们的实现也将允许直接删除Singleton；这是罕见的，但我们的代码也将处理这种情况。
- en: 'The Singleton pattern with the paired-class implementation will include the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带有配对类实现的Singleton模式将包括以下内容：
- en: A **Singleton** class, which represents the core mechanics needed to implement
    the concept of a Singleton.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表实现Singleton概念所需的核心机制的**Singleton**类。
- en: A **SingletonDestroyer** class, which will serve as a helper class to Singleton,
    ensuring that a given Singleton is properly destructed.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**SingletonDestroyer**类，它将作为Singleton的辅助类，确保给定的Singleton被正确销毁。
- en: A class derived from the Singleton, representing the class that we want to ensure
    can only create a single instance of its type at a given time. This will be our
    **Target** class.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Singleton派生的类，代表我们希望确保在特定时间只能创建一个其类型实例的类。这将是我们的**目标**类。
- en: Optionally, the Target class may be both derived from Singleton and another
    class, which may represent existing functionality that we would like to specialize
    or simply encompass (that is, *mix-in*). In this case we will multiply inherit
    from an application specific class and the Singleton class.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，目标类可以既从Singleton派生，又从另一个类派生，这个类可能代表我们想要专门化或简单包含的现有功能（即*混入*）。在这种情况下，我们将从一个特定于应用程序的类和Singleton类中继承。
- en: Optional **Client** classes, which will interact with the Target class(es) to
    fully define the application at hand.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的**客户端**类，它们将与目标类交互，以完全定义手头的应用程序。
- en: Alternatively, the Singleton may also be implemented within a Target class,
    bundling the class functionalities together in a single class.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，Singleton也可以在目标类内部实现，将类的功能捆绑在一个单一类中。
- en: A true Singleton pattern can be expanded to allow for multiple (discrete), but
    not an undetermined number of instances to be made. This is rare.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的Singleton模式可以扩展到允许创建多个（离散的）实例，但不是一个确定数量的实例。这是罕见的。
- en: We will focus on the traditional Singleton pattern that ensures only a single
    instance of a class embracing this pattern will exist at a given time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于传统的Singleton模式，以确保在任何给定时间只存在一个类的实例。
- en: Let's move forward to examine first a simple implementation, then our preferred
    paired-class implementation, of the Singleton pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，首先检查一个简单的实现，然后是我们首选的配对类实现，Singleton模式。
- en: Implementing the Singleton pattern
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Singleton模式
- en: The Singleton pattern will be used to ensure that a given class can only instantiate
    a single instance of that class. However, a true Singleton pattern will also have
    expansion capabilities to allow for multiple (but a well-defined number of) instances
    to be made. This unusual and not well-known caveat of the Singleton pattern is
    rare.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton模式将用于确保给定类只能实例化该类的单个实例。然而，真正的Singleton模式还将具有扩展功能，以允许多个（但数量明确定义的）实例被创建。这种Singleton模式的罕见且不太为人所知的特殊情况。
- en: We will start with a simple Singleton implementation to understand its limitations.
    We will then progress to the more robust paired-class implementation of the Singleton,
    with the most common pattern goal of only allowing one Target class instantiation
    at any given time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的Singleton实现开始，以了解其局限性。然后我们将进一步实现Singleton的更强大的配对类实现，最常见的模式目标是只允许在任何给定时间内实例化一个目标类。
- en: Using the simple implementation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单实现
- en: To implement a very simple Singleton, we will use a straightforward single-class
    specification for the Singleton itself. We will define a class, known as `Singleton`,
    to encapsulate the pattern. We will ensure that our constructor(s) are private,
    so that they cannot be applied more than once. We will also add a static `instance()`
    method to provide the interface for instantiation of the `Singleton` object. This
    method will ensure that the private construction occurs exactly once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个非常简单的Singleton，我们将使用一个简单的单类规范来定义Singleton本身。我们将定义一个名为`Singleton`的类来封装该模式。我们将确保我们的构造函数是私有的，这样它们就不能被应用超过一次。我们还将添加一个静态的`instance()`方法来提供`Singleton`对象的实例化接口。这个方法将确保私有构造只发生一次。
- en: 'Let''s take a look at this straightforward implementation, which can be found
    in our GitHub repository:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一下这个简单的实现，可以在我们的GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice, in the aforementioned class definition, that we include data member
    `static Singleton *theInstance;` to represent the `Singleton` instance itself.
    Our constructor is private so that it cannot be used multiple times to create
    multiple `Singleton` instances. Instead, we add a `static Singleton *instance()`
    method to create the `Singleton`. Within this method, we check if data member
    `theInstance` is `NULL` and if so, we instantiate the one and only `Singleton`
    instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的类定义中，我们注意到包括数据成员`static Singleton *theInstance;`来表示`Singleton`实例本身。我们的构造函数是私有的，这样就不能多次使用它来创建多个`Singleton`实例。相反，我们添加了一个`static
    Singleton *instance()`方法来创建`Singleton`。在这个方法中，我们检查数据成员`theInstance`是否为`NULL`，如果是，我们就实例化唯一的`Singleton`实例。
- en: Outside of the class definition, we see the external variable (and its initialization)
    to support the memory requirements of the static data member with the definition
    of `Singleton *Singleton::theInstance = NULL;`. We also see how, in `main()`,
    we call the static `instance()` method to create a Singleton instance using `Singleton::instance()`.
    The first call to this method will instantiate a `Singleton`, whereas subsequent
    calls to this method will merely return a pointer to the existing `Singleton`
    object. We can verify that the instances are the same by printing the address
    of these objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义之外，我们看到了外部变量（及其初始化）来支持静态数据成员的内存需求，定义为`Singleton *Singleton::theInstance
    = NULL;`。我们还看到在`main()`中，我们调用静态的`instance()`方法来使用`Singleton::instance()`创建一个Singleton实例。对这个方法的第一次调用将实例化一个`Singleton`，而对这个方法的后续调用将仅仅返回指向现有`Singleton`对象的指针。我们可以通过打印这些对象的地址来验证这些实例是相同的。
- en: 'Let''s take a look at the output for this simple program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个简单程序的输出：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned output, we notice something perhaps unexpected – the destructor
    is not called! What if the destructor had crucial tasks to perform?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们注意到了一些意外的事情 - 析构函数没有被调用！如果析构函数有关键的任务要执行怎么办呢？
- en: Understanding a key deficiency with the simple Singleton implementation
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解简单Singleton实现的一个关键缺陷
- en: The destructor is not called for our `Singleton` in the simple implementation
    merely because we have not deleted the dynamically allocated `Singleton` instance
    through either the `s1` or `s2` identifiers. Why not? There clearly may be multiple
    pointers (handles) to a `Singleton` object. Deciding which handle should be responsible
    for removing the `Singleton` is difficult to determine – the handles will minimally
    need to collaborate or employ reference counting.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单实现中，我们的`Singleton`的析构函数没有被调用，仅仅是因为我们没有通过`s1`或`s2`标识符删除动态分配的`Singleton`实例。为什么呢？显然可能有多个指针（句柄）指向一个`Singleton`对象。决定哪个句柄应该负责删除`Singleton`是很难确定的
    - 这些句柄至少需要合作或使用引用计数。
- en: Additionally, a `Singleton` tends to exist for the duration of the application.
    This longevity further suggests that a `Singleton` should be in charge of its
    own destruction. But how? We will soon see an implementation that will allow a
    `Singleton` to control its own destruction with a helper class. With the simple
    implementation, however, we might simply throw our hands in the air and suggest
    that the operating system will reclaim the memory resources when the application
    terminates – including the heap memory for this small `Singleton`. This is true;
    however, what if an important task needs to be completed in the destructor? We
    are running into a limitation within the simple pattern implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Singleton`往往存在于应用程序的整个生命周期。这种长期存在进一步表明，`Singleton`应该负责自己的销毁。但是如何做呢？我们很快将看到一个实现，它将允许`Singleton`通过一个辅助类来控制自己的销毁。然而，使用简单实现，我们可能只能举手投降，并建议操作系统在应用程序终止时回收内存资源
    - 包括这个小`Singleton`的堆内存。这是正确的；然而，如果在析构函数中需要完成重要任务呢？我们在简单模式实现中遇到了限制。
- en: If we need the destructor to be called, shall we resort to allowing one of the
    handles to delete the instance using, for example, `delete s1;`? We have previously
    reviewed issues regarding whether to allow any one handle to perform the deletion,
    but let's now additionally examine potential issues within the destructor itself.
    For example, if our destructor hypothetically only includes `delete theInstance;`,
    we will have a recursive function call. That is, calling `delete s1;` will invoke
    the `Singleton` destructor, yet `delete theInstance;` within the destructor body
    will recognize `theInstance` as a `Singleton` type and again call the `Singleton`
    destructor – *recursively*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要调用析构函数，我们是否应该允许其中一个句柄使用，例如`delete s1;`来删除实例？我们之前已经讨论过是否允许任何一个句柄执行删除的问题，但现在让我们进一步检查析构函数本身可能存在的问题。例如，如果我们的析构函数假设只包括`delete
    theInstance;`，我们将会有一个递归函数调用。也就是说，调用`delete s1;`将调用`Singleton`的析构函数，然后在析构函数体内部调用`delete
    theInstance;`将把`theInstance`识别为`Singleton`类型，并再次调用`Singleton`的析构函数 - *递归*。
- en: Not to worry! Our destructor, as shown, instead manages recursion by first checking
    whether `theInstance` data member is not `NULL`, and then arranges for `temp`
    to point to `theInstance` to save a handle to the instance we need to delete.
    We then make the assignment of `temp->theInstance = NULL;` to prevent recursion
    when we `delete temp;`. Why? Because `delete temp;` will also call the `Singleton`
    destructor. Upon this destructor call, `temp` will bind to `this` and will fail
    the conditional test `if (theInstance != NULL)` on this first recursive function
    call, backing us out of continued recursion. Note that our upcoming implementation
    using a paired-class approach will not have this potential issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心！如所示，我们的析构函数通过首先检查“theInstance”数据成员是否不是“NULL”，然后安排“temp”指向“theInstance”来管理递归，以保存我们需要删除的实例的句柄。然后我们进行“temp->theInstance
    = NULL;”的赋值，以防止在“delete temp;”时递归。为什么？因为“delete temp;”也会调用“Singleton”的析构函数。在这个析构函数调用时，“temp”将绑定到“this”，并且在第一次递归函数调用时不满足条件测试“if
    (theInstance != NULL)”，使我们退出持续的递归。请注意，我们即将使用成对类方法的实现不会有这个潜在问题。
- en: It is important to note that in an actual application, we would not create a
    domain-unspecific `Singleton` instance. Rather, we would factor our application
    into the design to employ the pattern. After all, we want to have a `Singleton`
    instance of a meaningful class type. To do so using our simple `Singleton` class
    as a basis, we simply inherit our Target (application-specific) class from `Singleton`.
    The Target class will also have private constructors – ones that accept the arguments
    necessary to adequately instantiate the Target class. We will then move the static
    `instance()` method from `Singleton` to the Target class and ensure that the argument
    list for `instance()` accepts the necessary arguments to pass to a private Target
    constructor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在实际应用中，我们不会创建一个领域不明确的“Singleton”实例。相反，我们将应用程序分解到设计中以使用该模式。毕竟，我们希望有一个有意义的类类型的“Singleton”实例。要使用我们简单的“Singleton”类作为基础来做到这一点，我们只需将我们的目标（特定于应用程序）类从“Singleton”继承。目标类也将有私有构造函数
    - 接受足以充分实例化目标类的参数。然后，我们将静态的“instance()”方法从“Singleton”移到目标类，并确保“instance()”的参数列表接受传递给私有目标构造函数的必要参数。
- en: To sum up, our simple implementation has the inherent design flaw that there
    is no guaranteed proper destruction for the `Singleton` itself. Letting the operating
    system collect the memory when the application terminates does not call the destructor.
    Choosing one of many handles to the `Singleton` to delete the memory, though possible,
    requires coordination and also defeats the usual application of the pattern to
    allow the `Singleton` to live for the duration of the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们简单的实现存在固有的设计缺陷，即“Singleton”本身没有保证的适当销毁。让操作系统在应用程序终止时收集内存不会调用析构函数。选择一个可以删除内存的“Singleton”句柄虽然可能，但需要协调，也破坏了模式的通常应用，即允许“Singleton”在应用程序的持续时间内存在。
- en: Now, because we understand the limitation of the simple `Singleton` implementation,
    we will instead move onward to the preferred paired-class implementation of the
    Singleton pattern. The paired-class approach will guarantee proper destruction
    of our `Singleton`, whether the application allows the `Singleton` to be destructed
    just prior to the application's termination through our deliberate class pairing
    (the most frequently encountered situation), or in the rare case that a `Singleton`
    is destroyed prematurely in the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们理解了简单的“Singleton”实现的局限性，我们将转而前进到首选的成对类实现Singleton模式。成对类方法将确保我们的“Singleton”在应用程序允许“Singleton”在应用程序终止之前被销毁（最常见的情况）或者在应用程序中罕见地提前销毁“Singleton”时，能够进行适当的销毁。
- en: Using the more robust paired-class implementation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更健壮的成对类实现
- en: To implement the Singleton pattern with a paired-class approach in a nicely
    encapsulated fashion, we will define a Singleton class to purely add the core
    mechanics of creating a single instance. We will name this class `Singleton`.
    We will then add a helper class to `Singleton`, known as `SingletonDestroyer`,
    to ensure that our `Singleton` instance always undergoes proper destruction before
    our application terminates. This pair of classes will be related through aggregation
    and association. More specifically, the `Singleton` class will conceptually contain
    a `SingletonDestroyer` (aggregate), and the `SingletonDestroyer` class will hold
    an association to the (outer) `Singleton` in which it is conceptually embedded.
    Because the implementation of the `Singleton` and `SingletonDestroyer` is through
    static data members, the aggregation is conceptual – static members are stored
    as external variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以一种良好封装的方式实现成对类方法的Singleton模式，我们将定义一个Singleton类，纯粹添加创建单个实例的核心机制。我们将把这个类命名为“Singleton”。然后，我们将添加一个辅助类到“Singleton”，称为“SingletonDestroyer”，以确保我们的“Singleton”实例在应用程序终止之前始终进行适当的销毁。这一对类将通过聚合和关联进行关联。更具体地说，“Singleton”类将在概念上包含一个“SingletonDestroyer”（聚合），而“SingletonDestroyer”类将持有一个关联到（外部）“Singleton”的关联。因为“Singleton”和“SingletonDestroyer”的实现是通过静态数据成员，聚合是概念性的
    - 静态成员被存储为外部变量。
- en: Once these core classes have been defined, we will consider how we may incorporate
    the Singleton pattern into a class hierarchy with which we have familiarity. Let's
    imagine that we would like to implement a class to encapsulate the concept of
    a *president*. Whether it be a president of a nation or the president of a university,
    it is important that there be only one president at a given point in time. `President`
    will be our Target class; `President` is therefore a good candidate to utilize
    our Singleton pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了这些核心类，我们将考虑如何将Singleton模式纳入我们熟悉的类层次结构中。假设我们想要实现一个类来封装“总统”的概念。无论是一个国家的总统还是大学的校长，都很重要的是在特定时间只有一个总统。
    “总统”将是我们的目标类；因此，“总统”是一个很好的候选者来利用我们的Singleton模式。
- en: It is interesting to note that whereas there will only be one president at a
    given point in time, it is possible to replace a president. For example, the term
    of a president in the United States is only four years at a time, with a possible
    re-election for one more term. There may be similar conditions for a university
    president. A president may leave prematurely through resignation, impeachment,
    or death, or may simply leave upon term expiration. Once a sitting president's
    existence is removed, it is then acceptable to instantiate a new, Singleton `President`.
    Hence, our Singleton pattern allows only one Singleton of the Target class at
    a given point in time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管在特定时间只会有一位总统，但是可以替换总统。例如，美国总统的任期一次只有四年，可以连任一届。大学校长可能也有类似的条件。总统可能因辞职、弹劾或死亡而提前离任，或者在任期到期后简单地离任。一旦现任总统的存在被移除，那么实例化一个新的Singleton
    `President`就是可以接受的。因此，我们的Singleton模式在特定时间只允许一个Target类的Singleton。
- en: Reflecting on how we may best implement a `President` class, we realize that
    a `President` *Is-A* `Person` and also needs to *mix-in* `Singleton` capabilities.
    With this in mind, we now have our design. `President` will use multiple inheritance
    to extend the concept of `Person` and to mix-in the functionality of a `Singleton`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 反思我们如何最好地实现`President`类，我们意识到`President` *是* `Person`，并且还需要*混入* `Singleton`的功能。有了这个想法，我们现在有了我们的设计。`President`将使用多重继承来扩展`Person`的概念，并混入`Singleton`的功能。
- en: Certainly, we could have built a `President` class from scratch, but why do
    so when the `Person` components of the `President` class are represented in a
    well-tested and available class? Also, certainly, we could embed the `Singleton`
    class information into our `President` class, rather than inheriting from a separate
    `Singleton` class. Absolutely, this is also an option. However, our application
    will instead encapsulate each piece of the solution. This will enable easier future
    reuse. Nonetheless, the design choices are many.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以从头开始构建一个`President`类，但是当`President`类的`Person`组件在一个经过充分测试和可用的类中表示时，为什么要这样做呢？同样，当然，我们可以将`Singleton`类的信息嵌入到我们的`President`类中，而不是继承一个单独的`Singleton`类。绝对，这也是一个选择。然而，我们的应用程序将封装解决方案的每个部分。这将使未来的重用更容易。尽管如此，设计选择很多。
- en: Specifying the Singleton and the SingletonDestroyer classes
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定Singleton和SingletonDestroyer类
- en: 'Let''s take a look at the mechanics for our Singleton pattern, starting by
    examining the `Singleton` and `SingletonDestroyer` class definitions. These classes
    work cooperatively to implement the Singleton pattern. This example can be found
    as a complete program in our GitHub repository:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的Singleton模式的机制，首先检查`Singleton`和`SingletonDestroyer`类的定义。这些类合作实现Singleton模式。这个例子可以在我们的GitHub存储库中找到完整的程序。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex2.cpp)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex2.cpp
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned code segment, we begin with several forward class declarations,
    such as `class Singleton;`. These declarations allow references to be made to
    these data types before their complete class definitions have been seen by the
    compiler.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码段中，我们从几个前向类声明开始，比如`class Singleton;`。这些声明允许在编译器看到它们的完整类定义之前就可以引用这些数据类型。
- en: Next, let's take a look at our `SingletonDestroyer` class definition. This simple
    class contains a private data member, `Singleton *theSingleton;`, which represents
    the association to the `Singleton` that the `SingletonDestroyer` will one day
    be responsible for deallocating (we will examine the destructor definition for
    `SingletonDestroyer` shortly). Notice that our destructor is not virtual as this
    class is not meant to be specialized.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看我们的`SingletonDestroyer`类定义。这个简单的类包含一个私有数据成员`Singleton *theSingleton;`，表示`SingletonDestroyer`将来将负责释放的`Singleton`的关联（我们将很快检查`SingletonDestroyer`的析构函数定义）。请注意，我们的析构函数不是虚拟的，因为这个类不打算被专门化。
- en: Notice that our constructor has a default value of `0` (`NULL`) specified for
    the `Singleton *`, which is an input parameter. `SingletonDestroyer` also contains
    two member functions, `setSingleton()` and `getSingleton()`, which merely provide
    the means to *set* and *get* the associated `Singleton` member.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的构造函数为`Singleton *`指定了默认值`0`（`NULL`）。`SingletonDestroyer`还包含两个成员函数`setSingleton()`和`getSingleton()`，仅提供了设置和获取相关`Singleton`成员的方法。
- en: Also notice that both the use of the copy constructor and the overloaded assignment
    operator in `SingletonDestroyer` have been disallowed using `=delete` in their
    prototypes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`SingletonDestroyer`中的复制构造函数和重载赋值运算符在其原型中使用`=delete`进行了禁止。
- en: 'Before we examine the destructor for this class, let''s examine the class definition
    for `Singleton`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查这个类的析构函数之前，让我们先看看`Singleton`的类定义。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The aforementioned `Singleton` class contains protected data member `static
    Singleton *theInstance;`, which will represent a pointer to the one and only instance
    allocated for the class employing the Singleton idiom.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Singleton`类包含受保护的数据成员`static Singleton *theInstance;`，它将表示为采用Singleton习惯用法分配给类的唯一实例的指针。
- en: The protected data member `static SingletonDestroyer destroyer`; represents
    a conceptual aggregate or contained member. The containment is truly only conceptual,
    as static data members are not stored within the memory layout for any instance;
    they are instead stored in external memory and *name-mangled* to appear as part
    of the class. This (conceptual) aggregate sub-object, `destroyer`, will be responsible
    for the proper destruction of the `Singleton`. Recall that the `SingletonDestroyer`
    has an association to the one and only `Singleton`, representing the outer object
    in which the `SingletonDestroyer` is conceptually contained. This association
    is how the `SingletonDestroyer` will access the Singleton.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的数据成员`static SingletonDestroyer destroyer`代表一个概念上的聚合或包含成员。这种包含实际上只是概念性的，因为静态数据成员不存储在任何实例的内存布局中；它们实际上存储在外部内存中，并且*name-mangled*以显示为类的一部分。这个（概念上的）聚合子对象`destroyer`将负责正确销毁`Singleton`。请记住，`SingletonDestroyer`与唯一的`Singleton`有关，代表了`SingletonDestroyer`概念上包含的外部对象。这种关联是`SingletonDestroyer`将如何访问Singleton的方式。
- en: When the memory for the external variable that implements the static data member
    `static SingletonDestroyer destroyer;` goes away at the end of the application,
    the destructor for `SingletonDestroyer` (the static, conceptual, sub-object) will
    be called. This destructor will run `delete theSingleton;`, ensuring that the
    outer `Singleton` object (which was dynamically allocated) will have the appropriate
    destructor sequence run on it. Because the destructor in `Singleton` is protected,
    it is necessary that `SingletonDestructor` is specified as a friend class of `Singleton`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现静态数据成员`static SingletonDestroyer destroyer;`的外部变量的内存在应用程序结束时消失时，将调用`SingletonDestroyer`（静态的概念性子对象）的析构函数。这个析构函数将运行`delete
    theSingleton;`，确保外部动态分配的`Singleton`对象将有适当的析构顺序运行。因为`Singleton`中的析构函数是受保护的，所以需要将`SingletonDestructor`指定为`Singleton`的友元类。
- en: Notice that both uses of the copy constructor and the overloaded assignment
    operator in `Singleton` have been disallowed using `=delete` in their prototypes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Singleton`中复制构造函数和重载赋值运算符的使用都已经在它们的原型中使用`=delete`禁止了。
- en: In our implementation, we have assumed that `Singleton` will be mixed-in via
    inheritance to a derived Target class. It will be in the derived class (the one
    that intends to use the Singleton idiom) that we provide the required static `instance()`
    method to create the `Singleton` instance. Note that had `Singleton` been used
    as a standalone class to create Singletons, we would instead add `static Singleton*
    instance()` to the public access region of `Singleton`. We would also then move
    the data members from the protected to the private access region. However, having
    an application-unspecific Singleton is only of use to demonstrate the concept.
    Instead, we will apply the Singleton idiom to an actual type requiring the use
    of this idiom.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们假设`Singleton`将通过继承混入到派生的目标类中。在派生类（打算使用Singleton习惯用法的类）中，我们提供了所需的静态`instance()`方法来创建`Singleton`实例。请注意，如果`Singleton`被用作独立类来创建单例，我们将在`Singleton`的公共访问区域中添加`static
    Singleton* instance()`。然后我们将数据成员从受保护的访问区域移动到私有访问区域。然而，拥有一个与应用程序无关的Singleton只能用来演示概念。相反，我们将把Singleton习惯用法应用到需要使用这种习惯用法的实际类型上。
- en: 'With our `Singleton` and `SingletonDestroyer` class definitions in place, let''s
    next examine the remaining necessary implementation necessities for these classes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的`Singleton`和`SingletonDestroyer`类定义，让我们接下来检查这些类的其余必要实现需求：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code fragment, let's first notice the two external variable
    definitions that provide the memory to support the two static data members within
    the `Singleton` class – that is, `Singleton *Singleton::theInstance = 0;` and
    `SingletonDestroyer Singleton::destroyer;`. Recall, static data members are not
    stored within any instance of their designated class. Rather, they are stored
    in external variables; these two definitions designate the memory. Notice that
    the data members are both labeled as protected. This means that though we may
    define their outer storage directly in this manner, we may not access these data
    members other than through static member functions of `Singleton`. This will give
    us some peace of mind. Though there is a potential global access point to the
    static data members, their levied protected access region requires appropriate
    static methods of the `Singleton` class to be used to properly manipulate these
    important members.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，首先注意两个外部变量定义，提供内存以支持`Singleton`类中的两个静态数据成员——即`Singleton *Singleton::theInstance
    = 0;`和`SingletonDestroyer Singleton::destroyer;`。请记住，静态数据成员不存储在其指定类的任何实例中。相反，它们存储在外部变量中；这两个定义指定了内存。请注意，数据成员都标记为受保护。这意味着虽然我们可以直接定义它们的外部存储，但我们不能通过`Singleton`的静态成员函数以外的方式访问这些数据成员。这将给我们一些安心。虽然静态数据成员有潜在的全局访问点，但它们的受保护访问区域要求使用`Singleton`类的适当静态方法来正确操作这些重要成员。
- en: Next, draw your attention to the destructor for `SingletonDestroyer`. This clever
    destructor first checks whether its association to the `Singleton` for which it
    is responsible is `NULL`. This will be rare and will happen in the very unusual
    situation when a Client released the Singleton object directly with an explicit
    `delete`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意`SingletonDestroyer`的析构函数。这个巧妙的析构函数首先检查它是否与它负责的`Singleton`的关联是否为`NULL`。这将很少发生，并且只会在非常不寻常的情况下发生，即客户端直接使用显式的`delete`释放`Singleton`对象。
- en: The usual destruction scenario in the `SingletonDestroyer` destructor will be
    the execution of the `else` clause in which the `SingletonDestructor`, as a static
    object, will be responsible for the deletion, and hence destruction, of its paired
    `Singleton`. Remember, there will be a contained `SingletonDestroyer` object within
    the `Singleton`. The memory for this static (conceptual) sub-object will not go
    away until the application is ending. Recall that static memory is not actually
    part of any instance. So, when the `SingletonDestroyer` is destructed, its usual
    case will be to `delete theSingleton;`, which will release its paired Singleton's
    memory, allowing the `Singleton` to be properly destructed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonDestroyer`析构函数中的通常销毁场景将是执行`else`子句，其中`SingletonDestructor`作为静态对象将负责删除其配对的`Singleton`，从而销毁它。请记住，`Singleton`中将包含一个`SingletonDestroyer`对象。这个静态（概念上的）子对象的内存不会在应用程序结束之前消失。请记住，静态内存实际上并不是任何实例的一部分。因此，当`SingletonDestroyer`被销毁时，它通常的情况将是`delete
    theSingleton;`，这将释放其配对的Singleton的内存，使得`Singleton`能够被正确销毁。'
- en: The driving design decision behind the Singleton pattern is that a Singleton
    is a long-lived object, and its destruction may most often correctly occur near
    the end of the application. The Singleton is responsible for its own inner Target
    object creation such that the Singleton should not be deleted (and hence destructed)
    by a Client. Rather, the preferred mechanism is that the `SingletonDestroyer`,
    when removed as a static object, deletes its paired `Singleton`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式背后的驱动设计决策是，单例是一个长期存在的对象，它的销毁通常应该在应用程序的最后发生。单例负责创建自己的内部目标对象，因此单例不应该被客户端删除（因此也不会被销毁）。相反，首选的机制是，当作为静态对象移除时，`SingletonDestroyer`会删除其配对的`Singleton`。
- en: Nonetheless, occasionally there are reasonable scenarios for deleting a `Singleton`
    mid-application. Should a replacement `Singleton` never be created, our `SingletonDestroyer`
    destructor will still work correctly, identifying that its paired `Singleton`
    has already been released. However, it is more likely that our `Singleton` will
    be replaced with another `Singleton` instance somewhere in the application. Recall
    our application example where a president may be impeached, resign, or die, but
    will be replaced by another president. In these cases, it is acceptable for a
    `Singleton` to be deleted directly and a new `Singleton` is then created. In this
    case, the `SingletonDestroyer` will now reference the replacement `Singleton`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，偶尔也会有合理的情况需要在应用程序中间删除一个`Singleton`。如果一个替代的`Singleton`从未被创建，我们的`SingletonDestroyer`析构函数仍将正确工作，识别到其配对的`Singleton`已经被释放。然而，更有可能的情况是我们的`Singleton`将在应用程序的某个地方被另一个`Singleton`实例替换。回想一下我们的应用程序示例，总统可能会被弹劾、辞职或去世，但会被另一位总统取代。在这些情况下，直接删除`Singleton`是可以接受的，然后创建一个新的`Singleton`。在这种情况下，`SingletonDestroyer`现在将引用替代的`Singleton`。
- en: Deriving a Target class from Singleton
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Singleton派生目标类
- en: 'Next, let''s take a look at how we can create our Target class, `President`,
    from `Singleton`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何从`Singleton`创建我们的目标类`President`：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our aforementioned Target class, `President`, we merely inherit `President`
    from `Person` using public inheritance and then multiply inherit `President` from
    `Singleton` to *mix-in* the `Singleton` mechanics.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上述的目标类`President`中，我们仅仅使用公共继承从`Person`继承`President`，然后通过多重继承从`Singleton`继承`President`来*混入*`Singleton`机制。
- en: We place our constructor in the private access region. Static method `instance()`
    will utilize this constructor internally to create the one and only `Singleton`
    instance permitted, to adhere to the pattern. There is no default constructor
    (unusual) because we do not wish to allow `President` instances to be created
    without their relevant details. Recall, C++ will not link in a default constructor
    if we have provided an alternate constructor interface. As we do not desire copies
    of a `President` or the assignment of a `President` to another potential `President`,
    we have disallowed copies and assignments using the `=delete` specification in
    the prototypes for these methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构造函数放在私有访问区域。静态方法`instance()`将在内部使用这个构造函数来创建唯一允许的`Singleton`实例，以符合模式。没有默认构造函数（不寻常），因为我们不希望允许创建没有相关细节的`President`实例。请记住，如果我们提供了替代的构造函数接口，C++将不会链接默认构造函数。由于我们不希望复制`President`或将`President`分配给另一个潜在的`President`，我们已经在这些方法的原型中使用`=delete`规范来禁止复制和分配。
- en: Our destructor for `President` is simple, yet crucial. In the case that our
    `Singleton` object will be deleted explicitly, we prepare by setting `destroyer.setSingleton(NULL);`.
    Recall, `President` inherits the protected `static SingletonDestroyer destroyer;`
    data member. Here, we are setting the destroyer's associated `Singleton` to `NULL`.
    This line of code in our `President` destructor then enables the destructor in
    `SingletonDestroyer` to accurately depend on checking for the unusual case where
    its associated `Singleton` has already been deleted before commencing the usual
    deletion of its `Singleton` counterpart.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`President`析构函数很简单，但至关重要。在我们明确删除`Singleton`对象的情况下，我们通过设置`destroyer.setSingleton(NULL);`来做好准备。请记住，`President`继承了受保护的`static
    SingletonDestroyer destroyer;`数据成员。在这里，我们将销毁者的关联`Singleton`设置为`NULL`。然后，我们的`President`析构函数中的这行代码使得`SingletonDestroyer`的析构函数能够准确地依赖于检查其关联的`Singleton`是否已经在开始其`Singleton`对应部分的通常删除之前被删除。
- en: Finally, we have defined a static method to provide the creation interface for
    our `President` as a `Singleton` with `static President *instance(const char *,
    const char *, char, const char *);`. In the definition of `instance()`, we first
    check if the inherited, protected data member `Singleton *theInstance` is `NULL`.
    If we have not yet allocated the `Singleton`, we allocate `President` using the
    aforementioned private constructor and assign this newly allocated `President`
    instance to `theInstance`. This is an upcast from `President *` to `Singleton
    *`, which is no problem across a public inheritance boundary. If, however, in
    the `instance()` method, we find that `theInstance` is not `NULL`, we simply return
    a pointer to the previously allocated `Singleton` object. As users will undoubtedly
    want to use this object as a `President` to enjoy the inherited `Person` features,
    we downcast `theInstance` to `President *` for its return value from this method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个静态方法，为我们的`President`提供`Singleton`的创建接口，使用`static President *instance(const
    char *, const char *, char, const char *);`。在`instance()`的定义中，我们首先检查继承的受保护数据成员`Singleton
    *theInstance`是否为`NULL`。如果我们还没有分配`Singleton`，我们使用上述的私有构造函数分配`President`并将这个新分配的`President`实例分配给`theInstance`。这是从`President
    *`向`Singleton *`的向上转型，在公共继承边界上没有问题。然而，如果在`instance()`方法中，我们发现`theInstance`不是`NULL`，我们只需返回指向先前分配的`Singleton`对象的指针。由于用户无疑会想要将此对象用作`President`来享受继承的`Person`功能，我们将`theInstance`向下转型为`President
    *`，作为此方法的返回值。
- en: Finally, let's consider the logistics of a sample Client in our overall application.
    In its simplest form, our Client will contain a `main()` function to drive the
    application and showcase our Singleton pattern.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一下我们整个应用程序中一个示例客户端的后勤。在其最简单的形式中，我们的客户端将包含一个`main()`函数来驱动应用程序并展示我们的Singleton模式。
- en: Bringing the pattern components together within the Client
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件在客户端中组合在一起
- en: 'Let''s now take a look at our `main()` function to see how our pattern is orchestrated:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的`main()`函数是如何组织我们的模式的：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reviewing our `main()` function in the preceding code, we first allocate a Singleton
    `President` using `President *p1 = President::instance("John", "Adams", 'Q', "President");`.
    We then try to allocate an additional `President` on the next line of code using
    `*p2`. Because we can only have one `Singleton` (a `President` *mixes-in* a `Singleton`),
    a pointer is returned to our existing `President` and stored in `p2`. We verify
    that there is only one `Singleton` by comparing `p1 == p2`; the pointers indeed
    point to the same instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在前面的代码中的`main()`函数，我们首先使用`President *p1 = President::instance("John", "Adams",
    'Q', "President");`分配一个Singleton `President`。然后我们尝试在下一行代码中分配另一个`President`，使用`*p2`。因为我们只能有一个`Singleton`（`President`
    *混入*了一个`Singleton`），一个指针被返回到我们现有的`President`并存储在`p2`中。我们通过比较`p1 == p2`来验证只有一个`Singleton`；指针确实指向同一个实例。
- en: Next, we take advantage of using our `President` instance in its intended manner,
    such as by using some of the inherited member functions from `Person`. As an example,
    we invoke `p1->Print();`. Certainly, our `President` class could have added specialized
    functionality that would be appropriate to utilize in our Client as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们利用我们的`President`实例以其预期的方式使用，比如使用从`Person`继承的一些成员函数。例如，我们调用`p1->Print();`。当然，我们的`President`类可以添加适合在我们的客户端中使用的专门功能。
- en: Now, at the end of `main()`, our static object `SingletonDestroyer Singleton::destroyer;`
    will be appropriately destructed before its memory is reclaimed. As we have seen,
    the destructor for `SingletonDestroyer` will (most often) issue a `delete` to
    its associated `Singleton` (which is actually a `President`) using `delete theSingleton;`.
    This will trigger our `President` destructor, `Singleton` destructor, and `Person`
    destructor to each be called and executed (going from most specialized to most
    general sub-objects). As our destructor in `Singleton` is virtual, we are guaranteed
    to start at the proper level for destruction and to include all destructors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`的末尾，我们的静态对象`SingletonDestroyer Singleton::destroyer;`将在其内存被回收之前被适当地销毁。正如我们所看到的，`SingletonDestroyer`的析构函数（通常）会使用`delete
    theSingleton;`向其关联的`Singleton`（实际上是`President`）发出`delete`。这将触发我们的`President`析构函数、`Singleton`析构函数和`Person`析构函数分别被调用和执行（从最专门的到最一般的子对象）。由于我们的`Singleton`析构函数是虚拟的，我们保证从正确的级别开始销毁并包括所有析构函数。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding output, we can visualize the creation of the Singleton `President`,
    as well as see that the second `instance()` request for a `President` merely returns
    the existing `President`. We then see the details of the `President` that were
    printed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到Singleton `President`的创建，以及第二个`instance()`请求一个`President`只是返回现有的`President`。然后我们看到打印出的`President`的细节。
- en: Most interestingly, we can see the destruction sequence for the `Singleton`,
    which is driven by the static object reclamation of the `SingletonDestroyer`.
    Through proper deletion of the `Singleton` in the `SingletonDestroyer` destructor,
    we see that `President`, `Singleton`, and `Person` destructors are each invoked
    as they contribute to the complete `President` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是，我们可以看到`Singleton`的销毁顺序，这是由`SingletonDestroyer`的静态对象回收驱动的。通过在`SingletonDestroyer`析构函数中正确删除`Singleton`，我们看到`President`、`Singleton`和`Person`的析构函数都被调用，因为它们共同构成了完整的`President`对象。
- en: Examining explicit Singleton deletion and its impact on the SingletonDestroyer
    destructor
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查显式单例删除及其对SingletonDestroyer析构函数的影响
- en: 'Let''s take a look at an alternate version of the Client with an alternate
    `main()` function. Here, we force deletion of our `Singleton`; this is rare. In
    this scenario, our `SingletonDestroyer` will not delete its paired `Singleton`.
    This example can be found as a complete program in our GitHub repository:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户端的另一个版本，其中有一个替代的`main()`函数。在这里，我们强制删除我们的`Singleton`；这是罕见的。在这种情况下，我们的`SingletonDestroyer`不会删除其配对的`Singleton`。这个例子可以在我们的GitHub存储库中找到作为一个完整的程序。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned `main()` function, notice that we explicitly deallocate
    our Singleton `President` using `delete p1;`, versus allowing the instance to
    be reclaimed via static objection deletion as the program ends. Fortunately, we
    have included a test in our `SingletonDestroyer` destructor to let us know if
    the `SingletonDestroyer` must delete its associated `Singleton` or if this deletion
    has already occurred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`main()`函数中，注意我们明确地使用`delete p1;`来释放我们的单例`President`，而不是让实例在程序结束时通过静态对象删除来回收。幸运的是，我们在我们的`SingletonDestroyer`析构函数中包含了一个测试，让我们知道`SingletonDestroyer`是否必须删除其关联的`Singleton`，或者这个删除已经发生。
- en: 'Let''s take a look at the revised output to notice the differences from our
    original `main()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下修改后的输出，注意与我们原来的`main()`函数的区别：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the aforementioned output for our revised Client, we can again visualize
    the creation of the Singleton `President`, the *unsuccessful* creation request
    of a second `President`, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改后的客户端的输出中，我们可以再次看到单例`President`的创建，第二个`President`的*失败*创建请求，等等。
- en: Let's take note of the destruction sequence and how it differs from our first
    Client. Here, the Singleton `President` is explicitly deallocated. We can see
    the proper deletion of the `President` through the call and execution of the destructors
    in `President`, `Singleton`, and `Person` as each is executed. Now, when the application
    is about to end and the static `SingletonDestroyer` is about to have its memory
    reclaimed, we can visualize the destructor called on the `SingletonDestroyer`.
    However, this destructor no longer will delete its associated `Singleton`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注意一下销毁顺序以及它与我们第一个客户端的不同之处。在这里，单例`President`被明确地释放。我们可以看到`President`的正确删除，通过在`President`，`Singleton`和`Person`中的析构函数的调用和执行。现在，当应用程序即将结束并且静态`SingletonDestroyer`即将回收其内存时，我们可以看到`SingletonDestroyer`上的析构函数被调用。然而，这个析构函数不再删除其关联的`Singleton`。
- en: Understanding design advantages and disadvantages
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解设计的优势和劣势
- en: An advantage of the preceding (paired-class) implementation of the Singleton
    pattern (irrespective of which `main()` is employed) is that we have guaranteed
    proper destruction of the `Singleton`. This happens regardless of whether the
    `Singleton` is long-lived and is deleted in its usual fashion by its associated
    `SingletonDestroyer`, or whether it is deleted earlier on in the application directly
    (a rare scenario).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面（成对类）实现的单例模式的一个优点（无论使用哪个`main()`）是，我们保证了`Singleton`的正确销毁。这不管`Singleton`是长寿命的，并且通过其关联的`SingletonDestroyer`以通常方式被删除，还是在应用程序中较早地直接删除（一个罕见的情况）。
- en: A disadvantage of this implementation is inherited from the concept of the `Singleton`.
    That is, there can only be one derived class of `Singleton` that incorporates
    the specific mechanics of the `Singleton` class. Because we have inherited `President`
    from `Singleton`, we are using the Singleton logistics (namely static data members,
    stored in external variables) for `President` and `President` alone. Should another
    class wish to be derived from `Singleton` to embrace this idiom, the internal
    implementation for the `Singleton` has already been utilized for `President`.
    Ouch! That does not seem fair.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的一个缺点是继承自`Singleton`的概念。也就是说，只能有一个派生类`Singleton`包含`Singleton`类的特定机制。因为我们从`Singleton`继承了`President`，我们正在使用`President`和`President`独自使用的单例逻辑（即静态数据成员，存储在外部变量中）。如果另一个类希望从`Singleton`派生以采用这种习惯用法，`Singleton`的内部实现已经被用于`President`。哎呀！这看起来不公平。
- en: Not to worry! Our design can be easily expanded to accommodate multiple classes
    that wish to use our `Singleton` base class. We will augment our design to accommodate
    multiple `Singleton` objects. We will assume, however, that we still intend to
    have only one `Singleton` instance per class type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心！我们的设计可以很容易地扩展，以适应希望使用我们的`Singleton`基类的多个类。我们将扩展我们的设计以容纳多个`Singleton`对象。然而，我们仍然假设每个类类型只有一个`Singleton`实例。
- en: Let's now take a brief look at how we may expand the Singleton pattern to solve
    this issue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要地看一下如何扩展单例模式来解决这个问题。
- en: Using a registry to allow many classes to utilize Singleton
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注册表允许多个类使用单例
- en: Let's more closely examine a shortcoming with our current Singleton pattern
    implementation. Currently, there can only be one derived class of `Singleton`
    that can effectively utilize the `Singleton` class. Why is this? `Singleton` is
    a class that comes with external variable definitions to support the static data
    members within the class. The static data member representing `theInstance` (implemented
    using the external variable `Singleton *Singleton::theInstance`) may only be set
    to one `Singleton` instance. *Not one per class* – there is only one set of external
    variables creating the memory for the crucial `Singleton` data members of `theInstance`
    and `destroyer`. Herein lies the problem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查一下我们当前单例模式实现的一个缺点。目前，只能有一个派生类`Singleton`能有效地利用`Singleton`类。为什么呢？`Singleton`是一个带有外部变量定义的类，用于支持类内的静态数据成员。代表`theInstance`的静态数据成员（使用外部变量`Singleton
    *Singleton::theInstance`实现）只能设置为一个`Singleton`实例。*不是每个类一个* - 只有一组外部变量创建了关键的`Singleton`数据成员`theInstance`和`destroyer`的内存。问题就在这里。
- en: We can, instead, can specify a `Registry` class to keep track of the classes
    applying the Singleton pattern. There are many implementations for a **Registry**,
    and we will review one such implementation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以指定一个`Registry`类来跟踪应用单例模式的类。有许多**Registry**的实现，我们将审查其中一种实现。
- en: In our implementation, `Registry` will be a class that pairs class names (for
    classes employing the Singleton pattern) with `Singleton` pointers to the single
    allowed instance of each registered class. We will still derive each Target class
    from `Singleton` (and from any other class as deemed appropriate by our design).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，`Registry`将是一个类，它将类名（对于使用Singleton模式的类）与每个注册类的单个允许实例的`Singleton`指针配对。我们仍然将每个Target类从`Singleton`派生（以及根据我们的设计认为合适的任何其他类）。
- en: 'Our `instance()` method in each class *derived* from `Singleton` will be revised,
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Singleton`派生的每个类中的`instance()`方法将被修改如下：
- en: Our first check within `instance()` will be to a call to a `Registry` method
    (with the derived class' name) asking if a `Singleton` had previously been created
    for that class. If the `Registry` method determines a `Singleton` for the requested
    derived type has previously been instantiated, a pointer to the existing instance
    will be returned by `instance()`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`instance()`中的第一个检查将是调用`Registry`方法（使用派生类的名称），询问该类是否以前创建过`Singleton`。如果`Registry`方法确定已经为请求的派生类型实例化了`Singleton`，则`instance()`将返回对现有实例的指针。
- en: Instead, if the `Registry` provides permission to allocate the `Singleton`,
    `instance()` will allocate the `Singleton` much as before, setting the inherited
    protected data member of `theInstance` to the allocated derived `Singleton`. The
    static `instance()` method will also set the backlink through the inherited protected
    destroyer data member using `setSingleton()`. We will then pass the newly instantiated
    derived class instance (which is a `Singleton`) to a `Registry` method to `Store()`
    the newly allocated `Singleton` within the `Registry`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，如果`Registry`允许分配`Singleton`，`instance()`将分配`Singleton`，就像以前一样，将`theInstance`的继承受保护数据成员设置为分配的派生`Singleton`。静态`instance()`方法还将通过使用`setSingleton()`设置继承受保护的销毁者数据成员的反向链接。然后，我们将新实例化的派生类实例（即`Singleton`）传递给`Registry`方法，以在`Registry`中`Store()`新分配的`Singleton`。
- en: We notice that four pointers to the same `Singleton` will exist. One will be
    the specialized pointer of our derived class type returned from our derived class
    `instance()` method. This pointer will be handed to our Client for application
    usage. The second `Singleton` pointer will be the pointer stored in our inherited,
    protected data member `theInstance`. The third `Singleton` pointer will be the
    pointer stored in the `SingletonDestroyer`. The fourth pointer to the `Singleton`
    will be a pointer that is stored in the `Registry`. No problem, we can have multiple
    pointers to a `Singleton`. This is one reason the `SingletonDestroyer`, used in
    its traditional destruction capacity, is so important – it will destroy our one
    and only `Singleton` for each type at the end of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到存在四个指向相同`Singleton`的指针。一个是从我们的派生类`instance()`方法返回的派生类类型的专用指针。这个指针将被传递给我们的客户端进行应用使用。第二个`Singleton`指针将是存储在我们继承的受保护数据成员`theInstance`中的指针。第三个`Singleton`指针将是存储在`SingletonDestroyer`中的指针。第四个指向`Singleton`的指针将存储在`Registry`中。没有问题，我们可以有多个指向`Singleton`的指针。这是`SingletonDestroyer`在其传统销毁功能中使用的一个原因-它将在应用程序结束时销毁每种类型的唯一`Singleton`。
- en: Our `Registry` will maintain a pair for each class employing the `Singleton`
    pattern, consisting of a class name and the (eventual) pointer to the specific
    `Singleton` for the corresponding class. The pointer to each specific `Singleton`
    instance will be a static data member and will additionally require an external
    variable to garner its underlying memory. The result is one additional external
    variable per class embracing the Singleton pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Registry`将维护每个使用`Singleton`模式的类的一对，包括类名和相应类的（最终）指针到特定`Singleton`。每个特定`Singleton`实例的指针将是一个静态数据成员，并且还需要一个外部变量来获取其底层内存。结果是每个拥抱Singleton模式的类的一个额外的外部变量。
- en: The idea of the `Registry` can be expanded further still if we choose to additionally
    accommodate the rare use of the Singleton pattern to allow multiple (but a finite
    set of) `Singleton` objects per class type. An example of this extended pattern
    in action might be that we chose to model a high school that has a single principal,
    yet multiple vice-principals. `Principal` would be an expected derived class of
    `Singleton`, yet the multiple vice-principals would represent a fixed number of
    instances of the `Vice-Principal` class (derived from `Singleton`). Our registry
    could be expanded to allow up to `N` registered `Singleton` objects for the `Vice-Principal`
    type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Registry`的想法如果我们选择另外容纳Singleton模式的罕见使用，可以进一步扩展。如果我们选择另外容纳Singleton模式的罕见使用，`Registry`的想法可以进一步扩展。在这种扩展模式中的一个例子可能是，我们选择对一个只有一个校长但有多个副校长的高中进行建模。`Principal`将是`Singleton`的一个预期派生类，而多个副校长将代表`Vice-Principal`类的固定数量的实例（派生自`Singleton`）。我们的注册表可以扩展到允许`Vice-Principal`类型的`N`个注册的`Singleton`对象。'
- en: We have now seen an implementation of the Singleton pattern using a paired-class
    approach. We have folded the classes and concepts of `Singleton`, `SingetonDestroyer`,
    Target, and Client into the framework of classes we are accustomed to seeing,
    namely `Person`, as well as into a descendant class of our `Singleton` and `Person`
    (`President`). Let's now briefly recap what we have learned relating to patterns
    before moving on to our next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了使用成对类方法实现Singleton模式。我们已经将`Singleton`、`SingetonDestroyer`、Target和Client的概念折叠到我们习惯看到的类框架中，即`Person`，以及我们的`Singleton`和`Person`的后代类（`President`）。让我们现在简要回顾一下我们在模式方面学到的东西，然后继续下一章。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have furthered our goal of becoming better C++ programmers
    by expanding our programming repertoire by embracing another design pattern. We
    have explored the Singleton pattern by first employing a simple approach, and
    then a paired-class implementation using `Singleton` and `SingletonDestroyer`.
    Our approach uses inheritance to incorporate our Singleton's implementation into
    our Target class. Optionally, we incorporate a useful, existing base class into
    our Target class using multiple inheritance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过接受另一个设计模式来扩展我们的编程技能，从而实现了成为更好的C++程序员的目标。我们首先采用了一种简单的方法来探讨Singleton模式，然后使用`Singleton`和`SingletonDestroyer`进行了成对类的实现。我们的方法使用继承将Singleton的实现合并到我们的Target类中。可选地，我们使用多重继承将一个有用的现有基类合并到我们的Target类中。
- en: Making use of core design patterns, such as the Singleton pattern, will help
    you more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By employing familiar design patterns, you will be contributing
    to well-understood and reusable solutions with avant-garde programming techniques.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 利用核心设计模式，如Singleton模式，将帮助您更轻松地重用现有的经过充分测试的代码部分，以一种其他程序员理解的方式。通过使用熟悉的设计模式，您将为众所周知和可重用的解决方案做出贡献，采用前卫的编程技术。
- en: We are now ready to continue onward to our final design pattern in [*Chapter
    20*](B15702_20_Final_NM_ePub.xhtml#_idTextAnchor756), *Removing Implementation
    Details Using the pImpl Pattern*. Adding more patterns to our arsenal of programming
    skills makes us more versatile and valued programmers. Let's continue onward!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备继续前往我们的最终设计模式，在[*第20章*](B15702_20_Final_NM_ePub.xhtml#_idTextAnchor756)中，*使用pImpl模式去除实现细节*。将更多的模式添加到我们的编程技能库中，使我们成为更多才多艺和有价值的程序员。让我们继续前进！
- en: Questions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the Singleton pattern examples found in this chapter:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中找到的Singleton模式示例：
- en: a. Implement either an interface for a `President` to `Resign()` or implement
    the interface to `Impeach()` a `President`. Your method should delete the current
    Singleton `President` (and remove that link from the `SingletonDestroyer`). `SingletonDestroyer`
    has a `setSingleton()` that may be useful to aid you in removing the backlink.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实现一个`President`到`辞职()`的接口，或者实现一个接口来`弹劾()`一个`President`。您的方法应删除当前的Singleton`President`（并从`SingletonDestroyer`中删除该链接）。`SingletonDestroyer`有一个`setSingleton()`，可能有助于帮助您删除反向链接。
- en: b. Noting that the former Singleton `President` has been removed, create a new
    `President` using `President::instance()`. Verify that the new `President` has
    been installed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: b. 注意到前任的Singleton“President”已被移除，使用`President::instance()`创建一个新的`President`。验证新的`President`已经安装。
- en: c. (*Optional*) Create a `Registry` to allow `Singleton` to be used effectively
    in multiple classes (not mutually exclusively, as is the current implementation).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: c.（*可选*）创建一个`Registry`，允许在多个类中有效地使用`Singleton`（不是互斥的，而是当前的实现）。
- en: Why can you not label the `static instance()` method as virtual in `Singleton`
    and override it in `President`?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不能将`Singleton`中的`static instance()`方法标记为虚拟，并在`President`中重写它？
- en: What other examples can you imagine that might easily incorporate the Singleton
    pattern?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能想象哪些其他例子可能很容易地融入Singleton模式？
