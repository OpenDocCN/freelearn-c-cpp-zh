["```cpp\n/* nonstrand.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\nglobal_stream_lock.unlock();\n}\n\nvoid Print(int number) {\n  std::cout << \"Number: \" << number << std::endl;\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::this_thread::sleep(boost::posix_time::milliseconds(500));\n\n  io_svc->post(boost::bind(&Print, 1));\n  io_svc->post(boost::bind(&Print, 2));\n  io_svc->post(boost::bind(&Print, 3));\n  io_svc->post(boost::bind(&Print, 4));\n  io_svc->post(boost::bind(&Print, 5));\n\n  worker.reset();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 nonstrand.cpp -o nonstrand -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nNumber: Number: 1\nNumber: 5\nNumber: 3\n2\nNumber: 4\n\n```", "```cpp\nlock object to synchronize the output. This is why we get the output as shown in the preceding screenshot.\n```", "```cpp\nvoid Print(int number) {\n std::cout << \"Number: \" << number << std::endl;\n}\n\n```", "```cpp\n/* strand.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid Print(int number) {\n  std::cout << \"Number: \" << number << std::endl;\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  boost::asio::io_service::strand strand(*io_svc);\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::this_thread::sleep(boost::posix_time::milliseconds(500));\n\n  strand.post(boost::bind(&Print, 1));\n  strand.post(boost::bind(&Print, 2));\n  strand.post(boost::bind(&Print, 3));\n  strand.post(boost::bind(&Print, 4));\n  strand.post(boost::bind(&Print, 5));\n\n  worker.reset();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 strand.cpp -o strand -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nio_svc->post(boost::bind(&Print, 1));\nio_svc->post(boost::bind(&Print, 2));\nio_svc->post(boost::bind(&Print, 3));\nio_svc->post(boost::bind(&Print, 4));\nio_svc->post(boost::bind(&Print, 5));\n\n```", "```cpp\nstrand.post(boost::bind(&Print, 1));\nstrand.post(boost::bind(&Print, 2));\nstrand.post(boost::bind(&Print, 3));\nstrand.post(boost::bind(&Print, 4));\nstrand.post(boost::bind(&Print, 5));\n\n```", "```cpp\nNumber: 1\nNumber: 2\nNumber: 3\nNumber: 4\nNumber: 5\n\n```", "```cpp\n/* strandwrap.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  iosvc->run();\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid Print(int number) {\n  std::cout << \"Number: \" << number << std::endl;\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  boost::asio::io_service::strand strand(*io_svc);\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\" <<  std::endl;\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::this_thread::sleep(boost::posix_time::milliseconds(100));\n  io_svc->post(strand.wrap(boost::bind(&Print, 1)));\n  io_svc->post(strand.wrap(boost::bind(&Print, 2)));\n\n  boost::this_thread::sleep(boost::posix_time::milliseconds(100));\n  io_svc->post(strand.wrap(boost::bind(&Print, 3)));\n  io_svc->post(strand.wrap(boost::bind(&Print, 4)));\n\n  boost::this_thread::sleep(boost::posix_time::milliseconds(100));\n  io_svc->post(strand.wrap(boost::bind(&Print, 5)));\n  io_svc->post(strand.wrap(boost::bind(&Print, 6)));\n\n  worker.reset();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 strandwrap.cpp -o strandwrap -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nNumber: 2\nNumber: 1\nNumber: 3\nNumber: 4\nNumber: 6\nNumber: 5\n\n```", "```cpp\n/* exception.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  try {\n    iosvc->run();\n\n    global_stream_lock.lock();\n    std::cout << \"Thread \" << counter << \" End.\\n\";\n    global_stream_lock.unlock();\n  }\n  catch(std::exception & ex) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n}\n\nvoid ThrowAnException(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Throw Exception \" << counter << \"\\n\" ;\n  global_stream_lock.unlock();\n\n  throw(std::runtime_error(\"The Exception !!!\"));\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=2; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  io_svc->post(boost::bind(&ThrowAnException, io_svc, 1));\n  io_svc->post(boost::bind(&ThrowAnException, io_svc, 2));\n  io_svc->post(boost::bind(&ThrowAnException, io_svc, 3));\n  io_svc->post(boost::bind(&ThrowAnException, io_svc, 4));\n  io_svc->post(boost::bind(&ThrowAnException, io_svc, 5));\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 exception.cpp -o exception -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\n/* exception2.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  try {\n    iosvc->run();\n\n    global_stream_lock.lock();\n    std::cout << \"Thread \" << counter << \" End.\\n\";\n    global_stream_lock.unlock();\n  }\n  catch(std::exception &ex) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n}\n\nvoid ThrowAnException(boost::shared_ptr<boost::asio::io_service> iosvc) {\n  global_stream_lock.lock();\n  std::cout << \"Throw Exception\\n\" ;\n  global_stream_lock.unlock();\n\n  iosvc->post(boost::bind(&ThrowAnException, iosvc));\n\n  throw(std::runtime_error(\"The Exception !!!\"));\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  io_svc->post(boost::bind(&ThrowAnException, io_svc));\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 exception2.cpp -o exception2 -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\niosvc->post(boost::bind(&ThrowAnException, iosvc));\n\n```", "```cpp\nThrowAnException function. Every time the ThrowAnException function is called, it will call itself. Then, it should be an infinite program since there is a recursive function. Let us run the program to prove this by typing the exception2 command in the console window. The output will be like the following:\n```", "```cpp\n/* errorcode.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  boost::system::error_code ec;\n  iosvc->run(ec);\n\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid ThrowAnException(boost::shared_ptr<boost::asio::io_service> iosvc) {\n  global_stream_lock.lock();\n  std::cout << \"Throw Exception\\n\" ;\n  global_stream_lock.unlock();\n\n  iosvc->post(boost::bind(&ThrowAnException, iosvc));\n\n  throw(std::runtime_error(\"The Exception !!!\"));\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  io_svc->post(boost::bind(&ThrowAnException, io_svc));\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 errorcode.cpp -o errorcode -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\niosvc->run(ec);\n\n```", "```cpp\nif(ec)\n\n```", "```cpp\n/* errorcode2.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Error Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Exception Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid ThrowAnException(boost::shared_ptr<boost::asio::io_service> iosvc) {\n  global_stream_lock.lock();\n  std::cout << \"Throw Exception\\n\" ;\n  global_stream_lock.unlock();\n\n  iosvc->post(boost::bind(&ThrowAnException, iosvc));\n\n  throw(std::runtime_error(\"The Exception !!!\"));\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"The program will exit once all work has finished.\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  io_svc->post(boost::bind(&ThrowAnException, io_svc));\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 errorcode2.cpp -o errorcode2 -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nwhile(true) {\n try {\n . . .\n iosvc->run(ec);\n if(ec)\n . . .\n }\n catch(std::exception &ex) {\n . . .\n }\n}\n\n```", "```cpp\n/* timer.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid TimerHandler(const boost::system::error_code & ec) {\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"Error Message: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"You see this line because you have waited for 10 seconds.\\n\";\n    std::cout << \"Now press ENTER to exit.\\n\";\n    global_stream_lock.unlock();\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Wait for ten seconds to see what happen, \";\n  std::cout << \"otherwise press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::asio::deadline_timer timer(*io_svc);\n  timer.expires_from_now(boost::posix_time::seconds(10));\n  timer.async_wait(TimerHandler);\n\n  std::cin.get();\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 timer.cpp -o timer -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nboost::asio::deadline_timer timer(*io_svc);\ntimer.expires_from_now(boost::posix_time::seconds(10));\ntimer.async_wait(TimerHandler);\n\n```", "```cpp\nvoid TimerHandler(const boost::system::error_code & ec) {\n if(ec)\n . . .\n}\nelse {\n global_stream_lock.lock();\n std::cout << \"You see this line because you have waited for 10 seconds.\\n\";\n std::cout << \"Now press ENTER to exit.\\n\";\n global_stream_lock.unlock();\n}\n\n```", "```cpp\n/* timer2.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while( true ) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid TimerHandler(\n  const boost::system::error_code &ec,\n  boost::shared_ptr<boost::asio::deadline_timer> tmr\n)\n{\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"Error Message: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"You see this every three seconds.\\n\";\n    global_stream_lock.unlock();\n\n    tmr->expires_from_now( boost::posix_time::seconds(3));\n    tmr->async_wait(boost::bind(&TimerHandler, _1, tmr));\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::shared_ptr<boost::asio::deadline_timer> timer(\n    new boost::asio::deadline_timer(*io_svc)\n  );\n  timer->expires_from_now( boost::posix_time::seconds(3));\n  timer->async_wait(boost::bind(&TimerHandler, _1, timer));\n\n  std::cin.get();\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 timer2.cpp -o timer2 -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\ntimer->async_wait(boost::bind(&TimerHandler, _1, timer));\n\n```", "```cpp\n/* timer3.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while( true ) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid TimerHandler(\n  const boost::system::error_code &ec,\n  boost::shared_ptr<boost::asio::deadline_timer> tmr,\n  boost::shared_ptr<boost::asio::io_service::strand> strand\n)\n{\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"Error Message: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"You see this every three seconds.\\n\";\n    global_stream_lock.unlock();\n\n    tmr->expires_from_now( boost::posix_time::seconds(1));\n    tmr->async_wait(\n      strand->wrap(boost::bind(&TimerHandler, _1, tmr, strand))\n    );\n  }\n}\n\nvoid Print(int number) {\n  std::cout << \"Number: \" << number << std::endl;\n  boost::this_thread::sleep( boost::posix_time::milliseconds(500));\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n  boost::shared_ptr<boost::asio::io_service::strand> strand(\n    new boost::asio::io_service::strand(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=5; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::this_thread::sleep(boost::posix_time::seconds(1));\n\n  strand->post(boost::bind(&Print, 1));\n  strand->post(boost::bind(&Print, 2));\n  strand->post(boost::bind(&Print, 3));\n  strand->post(boost::bind(&Print, 4));\n  strand->post(boost::bind(&Print, 5));\n\n  boost::shared_ptr<boost::asio::deadline_timer> timer(\n    new boost::asio::deadline_timer(*io_svc)\n  );\n\n  timer->expires_from_now( boost::posix_time::seconds(1));\n  timer->async_wait( \n    strand->wrap(boost::bind(&TimerHandler, _1, timer, strand))\n  );\n\n  std::cin.get();\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 timer3.cpp -o timer3 -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```"]