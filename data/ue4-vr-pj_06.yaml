- en: Interacting with the Virtual World - Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与虚拟世界交互-第二部分
- en: In the last chapter, we set up our hands and learned how to animate them. As
    we mentioned then, this alone can represent a big step toward establishing presence
    in our application. Now, let's take things to the next step and start using them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了我们的手并学习了如何对它们进行动画。正如我们之前提到的，仅仅这一点就可以代表我们的应用程序建立存在感的重要一步。现在，让我们迈出下一步，开始使用它们。
- en: 'In this chapter, we''re going to learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: How to use Blueprint interfaces to add functionality to a variety of Blueprints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用蓝图接口为各种蓝图添加功能
- en: How to use attachments to pick up and drop physics actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用附件来拾取和放下物理角色
- en: How to indicate to players when they can interact with an object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何指示玩家何时可以与物体交互
- en: How to create haptic feedback effects to provide more tactile feedback to the
    user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建触觉反馈效果以提供更多触觉反馈给用户
- en: Creating an object we can pick up
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可以拾取的物体
- en: 'We''ll begin by making a few objects we can pick up. Let''s start with a simple
    cube:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先制作一些可以拾取的物体。让我们从一个简单的立方体开始：
- en: Right-click in your project's `Blueprints` directory in your content browser
    and select Create Basic Asset | Blueprint Class.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击项目的“Blueprints”目录，然后选择“Create Basic Asset | Blueprint Class”。
- en: This time, instead of selecting one of the common classes as its parent class,
    expand the All Classes entry at the bottom of the Pick Parent Class dialog.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，不要选择其中一个常见类作为其父类，而是展开“Pick Parent Class”对话框底部的“All Classes”条目。
- en: 'Select Static Mesh Actor:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“Static Mesh Actor”：
- en: '![](img/6241c46a-6ddd-4d3e-b5d1-b4ab61cea61c.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6241c46a-6ddd-4d3e-b5d1-b4ab61cea61c.png)'
- en: Name it `BP_PickupCube`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为“BP_PickupCube”。
- en: Open up `BP_PickupCube`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_PickupCube”。
- en: You can see that it inherited a `Static Mesh Component`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它继承了一个“Static Mesh Component”。
- en: We could just as easily have created an `Actor` Blueprint and added a `Static
    Mesh` component, but it's a good idea to get in the habit of choosing your parent
    classes appropriately when you're building a new asset. Don't reinvent things
    if you don't have to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个“Actor”蓝图并添加一个“Static Mesh”组件，但是当您构建新资产时，选择适当的父类是一个好习惯。如果不必要，不要重新发明轮子。
- en: Set the Static Mesh property of `Static Mesh Component` to `Engine Content/Basic
    Shapes/Cube1`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Static Mesh Component”的“Static Mesh”属性设置为“Engine Content/Basic Shapes/Cube1”。
- en: Set its Scale to `0.2, 0.2, 0.2`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Scale”设置为“0.2, 0.2, 0.2”。
- en: Set its Materials | Element 0 to `Content/SoulCity/Environment/Materials/Props/MI_Glow`.
    (Or anything else you like, but this one will be easy to see in the map.)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Materials | Element 0”设置为“Content/SoulCity/Environment/Materials/Props/MI_Glow”。（或者您喜欢的其他任何东西，但这个在地图中很容易看到。）
- en: 'Now, we want our cube to simulate physics, so let''s set a few values to make
    this happen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望立方体模拟物理效果，所以让我们设置一些值来实现这一点：
- en: Set its Physics | Simulate Physics flag to `True`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Physics | Simulate Physics”标志设置为“True”。
- en: Set its Collision | Simulation Generates Hit Events to `True`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Collision | Simulation Generates Hit Events”设置为“True”。
- en: Set its Collision | Generate Overlap Events to `True`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Collision | Generate Overlap Events”设置为“True”。
- en: Make sure its Collision | Collision Presets is set to `PhysicsActor`. (This
    should have been set for you automatically when you set Simulate Physics to true.)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保其“Collision | Collision Presets”设置为“PhysicsActor”。（当您将“Simulate Physics”设置为true时，这应该会自动设置。）
- en: Set its Collision | Can Ever Affect Navigation to `False`. (This will be hidden
    in the Collision section's Advanced properties.)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其“Collision | Can Ever Affect Navigation”设置为“False”。（这将在“Collision”部分的高级属性中隐藏。）
- en: We've now created a small glowing cube that will respond naturally to physics,
    but not block our navmesh as it moves around the world.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个小的发光立方体，它会自然地对物理作出反应，但在移动世界时不会阻碍我们的导航网格。
- en: Now, we're going to need to give it the ability to be picked up. There are a
    few ways we could do this. We could simply write `Pickup` and `Drop` methods right
    into blueprint of `BP_PickupCube`, but we're going to need to be able to call
    these functions from outside.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让它具备被拾取的能力。我们可以通过几种方式来实现这一点。我们可以直接在“BP_PickupCube”的蓝图中编写“Pickup”和“Drop”方法，但我们需要能够从外部调用这些函数。
- en: As we saw previously, if you want to call a function from outside its blueprint,
    you have to be sure you're talking to a class that contains that function, which
    we do by casting the reference to that class. This would be fine if we only ever
    anticipated picking up cubes, but what if we want to be able to make other objects
    easy to pick up? We don't want to have to rewrite our `BP_VRHand` blueprint every
    time we add a new type of object that could be picked up, so that's not a great
    solution here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，如果您想从蓝图外部调用一个函数，您必须确保您正在与包含该函数的类进行交流，我们通过将引用转换为该类来实现这一点。如果我们只预期拾取立方体，那么这样做就可以了，但是如果我们希望能够轻松拾取其他对象呢？我们不希望每次添加一个新类型的可拾取物体时都要重写我们的“BP_VRHand”蓝图，所以这不是一个很好的解决方案。
- en: We could derive `BP_PickupCube` from a common parent that implemented the `Pickup`
    and `Drop` methods, and just cast our references to that parent. That's better,
    but still not perfect. `BP_PickupCube` inherits from `StaticMeshActor`, but what
    if we want to make it possible for something that inherits from `SkeletalMeshActor`
    to be picked up? We don't have an easy way to create a common parent class in
    that instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个实现了“Pickup”和“Drop”方法的共同父类派生出“BP_PickupCube”，然后将我们的引用转换为该父类。这样做更好，但仍然不完美。“BP_PickupCube”继承自“StaticMeshActor”，但如果我们想让从“SkeletalMeshActor”继承的物体也能被拾取怎么办？在这种情况下，我们没有简单的方法来创建一个共同的父类。
- en: The answer to this dilemma is a *Blueprint Interface*. An interface is a Blueprint
    object that allows us to define functions that can be called on any object that
    implements the interface, no matter what class that object derives from. It's
    a class you can attach to any object, and it acts as a promise that the object
    to which it's attached will implement each of the functions included in the interface.
    If I create an interface that declares the `Pickup` and `Drop` functions, for
    example, and I apply that interface to my `BP_PickupCube`, I can call the `Pickup`
    and `Drop` methods without having to cast the object first. This is a powerful
    pattern. You can make your code very flexible and easy to extend by using interfaces
    smartly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个困境的答案是*蓝图接口*。接口是一个蓝图对象，允许我们定义可以在实现接口的任何对象上调用的函数，无论该对象从哪个类派生。它是一个可以附加到任何对象的类，并且它作为一个承诺，附加到它的对象将实现接口中包含的每个函数。例如，如果我创建一个声明了“Pickup”和“Drop”函数的接口，并将该接口应用于我的“BP_PickupCube”，我可以在不必先转换对象的情况下调用“Pickup”和“Drop”方法。这是一个强大的模式。通过巧妙地使用接口，您可以使您的代码非常灵活和易于扩展。
- en: Don't worry if this isn't completely clear yet. It's going to make more sense
    once we build it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不完全清楚，不要担心。一旦我们构建它，它会变得更加清晰。
- en: Creating a Blueprint Interface for pickup objects
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为拾取对象创建一个蓝图接口
- en: 'To create a Blueprint Interface, follow the given steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个蓝图接口，请按照给定的步骤进行操作：
- en: 'Right-click in your project''s `Blueprints` directory, and select Create Advanced
    Asset | Blueprints | Blueprint Interface:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的“蓝图”目录中右键单击，选择“创建高级资产|蓝图|蓝图接口”：
- en: '![](img/0f6892a9-d00b-4158-9223-4d6c0676b2bf.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f6892a9-d00b-4158-9223-4d6c0676b2bf.png)'
- en: Name it `BPI_PickupActor`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为“BPI_PickupActor”。
- en: When you open it up, you'll see that it contains a Functions list, and nothing
    else. You'll notice that the graph can't be edited. This is because the interface
    is simply a list of functions that the attached object must implement, but those
    functions don't get written in the interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开它时，你会看到它包含一个函数列表，除此之外什么都没有。你会注意到图表无法编辑。这是因为接口只是一个函数列表，附加对象必须实现这些函数，但这些函数不会在接口中编写。
- en: By default, it's created a new function declaration for you. Name it `Pickup`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，它为您创建了一个新的函数声明。将其命名为“Pickup”。
- en: 'Under the function''s Details | Inputs, add a new input. Set its type to Scene
    Component | Object Reference, and name it `AttachTo`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的详细信息|输入下，添加一个新的输入。将其类型设置为场景组件|对象引用，并将其命名为“AttachTo”：
- en: '![](img/a302c11e-2af7-4586-a1b8-a1a1c1c400ad.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a302c11e-2af7-4586-a1b8-a1a1c1c400ad.png)'
- en: Add another function, and call it `Drop`. This one doesn't need any input.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个函数，并将其命名为“Drop”。这个函数不需要任何输入。
- en: Compile, save, and close the interface.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译、保存并关闭接口。
- en: 'Now, let''s apply this new interface to `BP_PickupCube`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个新接口应用到“BP_PickupCube”上：
- en: Open `BP_PickupCube`, and hit the Class Settings item on the toolbar.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_PickupCube”，并点击工具栏上的“类设置”项。
- en: Under Details | Interfaces, hit the Add button under Implemented Interfaces.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息|接口下，点击“已实现的接口”下的添加按钮。
- en: Select `BPI_PickupActor`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“BPI_PickupActor”。
- en: Implementing the Pickup and Drop functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现拾取和放下函数
- en: 'Now that we''ve added this interface to the `BP_PickupCube` class, we can implement
    the functions we declared in that interface in our event graph. Let''s get started:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将这个接口添加到“BP_PickupCube”类中，我们可以在事件图中实现我们在该接口中声明的函数。让我们开始吧：
- en: In your Event Graph, right-click and select `Event Pickup` to create a Pick
    up event. This event exists on this Blueprint class now because we've attached
    an interface that declares it. You'll see that the event indicates that it's an
    interface event from `BPI_PickupActor`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，右键单击并选择“事件拾取”来创建一个拾取事件。现在，这个蓝图类上存在这个事件，因为我们附加了一个声明它的接口。你会看到这个事件表明它是来自“BPI_PickupActor”的接口事件。
- en: Create a `Drop` event in the same way.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式创建一个“Drop”事件。
- en: Now that we've created handlers for the two events coming from our interface,
    let's make them work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为来自接口的两个事件创建了处理程序，让我们让它们起作用。
- en: When this object is picked up, we want to turn off its physics simulation so
    that it doesn't fall out of our hand, and we want to attach it to a scene component
    on the hand that's picking it up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当拾取这个物体时，我们希望关闭它的物理模拟，这样它就不会从我们的手中掉下来，并且我们希望将它附加到拾取它的手上的一个场景组件上。
- en: Drag a reference to the `Static Mesh Component` onto the Event Graph.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对“静态网格组件”的引用拖动到事件图中。
- en: Call `Set Simulate Physics` on it, setting Simulate to `False`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用“Set Simulate Physics”并将Simulate设置为“False”。
- en: Right-click in the graph and select `Get Root Component`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击并选择“获取根组件”。
- en: 'Drag a connector from the Root Component reference, and select `Attach to Component`.
    You''ll see that there are two options for this. Roll over them and select the
    one whose tooltip reads Target is Scene Component, since we''re going to be attaching
    to a scene component:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根组件引用拖动一个连接器，并选择“附加到组件”。你会看到有两个选项。将鼠标悬停在上面并选择那个工具提示为“目标是场景组件”的选项，因为我们将要附加到一个场景组件上：
- en: '![](img/430b3db9-2269-42d6-9e4b-54f0e9c46095.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/430b3db9-2269-42d6-9e4b-54f0e9c46095.png)'
- en: Drag the Attach To output from `Event Pickup` to the Parent input on the `Attach
    To Component` node.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“事件拾取”的“附加到”输出拖动到“附加到组件”节点上的父级输入。
- en: On your `Attach To Component` node, set the Location, Rotation, and Scale rules
    to `Keep World`, and set Weld Simulated Bodies to `False`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“附加到组件”节点上，将位置、旋转和缩放规则设置为“保持世界”，并将焊接模拟体设置为“False”。
- en: 'Your completed Pickup implementation should look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的拾取实现应该如下所示：
- en: '![](img/9bcdbd11-2638-42b6-98ec-65ae2a89d680.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bcdbd11-2638-42b6-98ec-65ae2a89d680.png)'
- en: When we drop this object, we want to turn its physics back on and detach it
    from the scene component we attached when we picked it up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们放下这个物体时，我们希望将其物理重新打开并将其从我们拾取时附加的场景组件上分离出来。
- en: Select your `Static Mesh Component` reference and the `Set Simulate Physics`
    call, and hit *Ctrl* + *W* to duplicate them.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的“静态网格组件”引用和“Set Simulate Physics”调用，并按下*Ctrl* + *W*进行复制。
- en: Connect execution of Event Drop pin to the copied `Set Simulate Physics` call.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件Drop引脚的执行连接到复制的`Set Simulate Physics`调用。
- en: Set Simulate to True so that we're turning physics back on.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模拟设置为True，以便我们重新开启物理效果。
- en: Right-click and create a `Detach From Actor` node.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并创建一个`Detach From Actor`节点。
- en: Set the Location, Rotation, and Scale rules to `Keep World`, just as we did
    on the Attach node.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位置、旋转和缩放规则设置为`Keep World`，就像我们在Attach节点上所做的那样。
- en: 'Your completed Drop implementation should look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的Drop实现应该如下所示：
- en: '![](img/75e40a5e-6086-496e-a676-0fba59a592f4.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75e40a5e-6086-496e-a676-0fba59a592f4.png)'
- en: That's it for our `Pickup Cube` actor. We can close the blueprint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Pickup Cube`角色的全部内容。我们可以关闭蓝图了。
- en: Setting up VRHand to pick up objects
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置VRHand以拾取物体
- en: Now, we're ready to get our hands grabbing these objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好抓取这些物体了。
- en: Creating a function to find the nearest pickup object
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来查找最近的可拾取对象
- en: 'The next thing we need to do is find out what objects are near enough to our
    hand to be picked up. Let''s create a function to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是找出哪些物体离我们的手足够近，可以被拾取。让我们创建一个函数来完成这个任务：
- en: In `BP_VRHand`, create a new function called `FindNearestPickupObject`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRHand`中，创建一个名为`FindNearestPickupObject`的新函数。
- en: Set its Category to `Grabbing` and its Access Specifier to `Private`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类别设置为`Grabbing`，将其访问限定符设置为`Private`。
- en: In its implementation graph, right-click to create a `Get All Actors with Interface` node,
    and set its Interface value to `BPI_PickupActor`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其实现图中，右键单击创建一个`Get All Actors with Interface`节点，并将其接口值设置为`BPI_PickupActor`。
- en: This is going to give us an array of every actor in the scene that implements
    the `BPI_PickupActor` interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供场景中实现`BPI_PickupActor`接口的每个演员的数组。
- en: 'Drag a connector from the Out Actors output and create a `For Each Loop` node:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Out Actors输出拖出一个连接器并创建一个`For Each Loop`节点：
- en: '![](img/93f533aa-f514-4685-9588-adf98fe18ba8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93f533aa-f514-4685-9588-adf98fe18ba8.png)'
- en: We're going to iterate through the actors that could possibly be picked up,
    ignore any actor that's too far to be considered, and then return the closest
    remaining eligible actor.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历可能被拾取的演员，忽略任何距离太远而无法考虑的演员，然后返回最接近的剩余合格演员。
- en: From the `For Each Loop` Array Element output, drag out a connector and call
    `Get Actor Location` on it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`For Each Loop`的Array Element输出中拖出一个连接器并调用`Get Actor Location`。
- en: Drag a reference to `Hand Mesh` onto your graph and call `Get World Location`
    on it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Hand Mesh`的引用拖到图表上并调用`Get World Location`。
- en: 'Subtract the hand mesh''s world location from the array element''s actor location:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组元素的角色位置中减去手部网格的世界位置：
- en: '![](img/2b1f079b-6e50-42a3-85c4-95fb275647eb.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b1f079b-6e50-42a3-85c4-95fb275647eb.png)'
- en: Get `Vector Length Squared` for the resulting vector.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取结果向量的`Vector Length Squared`。
- en: 'Drag out its result and select Promote to local variable. Name the new variable
    `LocalCurrentActorDistSquared`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出其结果并选择提升为本地变量。将新变量命名为`LocalCurrentActorDistSquared`：
- en: '![](img/4d29b514-f173-4531-91f5-9e9fd8b773e1.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d29b514-f173-4531-91f5-9e9fd8b773e1.png)'
- en: Connect the Loop Body execution line to the local variable's setter.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Loop Body执行线连接到本地变量的设置器。
- en: Drag the output from our local variable setter and create a `<=` test to see
    whether it's equal to or shorter than the value we're going to give it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动本地变量设置器的输出并创建一个`<=`测试，以查看它是否等于或短于我们要给它的值。
- en: The reason why we're creating a local variable here is that we're going to need
    to use this value again if there's more than one grabbable actor in our test radius,
    and we don't want to waste time recalculating the distance, so we're stashing
    it here so that we can use it later if we need it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建一个本地变量的原因是，如果在我们的测试半径内有多个可抓取的角色，我们将需要再次使用此值，并且我们不希望浪费时间重新计算距离，因此我们将其存储在这里以便以后使用。
- en: Create a float variable and name it `GrabRadius`. Compile the Blueprint and
    set its value to 32.0\. (Later on, you can tune this value to whatever feels right
    for you.)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个浮点变量并将其命名为`GrabRadius`。编译蓝图并将其值设置为32.0。 （稍后，您可以根据自己的感觉调整此值。）
- en: Press *Ctrl* + drag `GrabRadius` onto your graph.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将`GrabRadius`拖到图表上。
- en: Drag a connector from its output and `Square` it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出拖出一个连接器并对其进行`Square`操作。
- en: 'Connect the result of the square to the `<=` test''s second input:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平方的结果连接到`<=`测试的第二个输入：
- en: '![](img/2e705634-cc56-4bd7-a55b-81af28f08578.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e705634-cc56-4bd7-a55b-81af28f08578.png)'
- en: Remember when we mentioned that real distance checks are expensive? This is
    a place where it matters because we're going to call this function on the `Tick`
    event. Since we just want to see whether the actor is within the supplied radius,
    but we don't care how far away it really is, it's cheaper to do this test on the
    squared values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们提到实际距离检查很昂贵时？这是一个重要的地方，因为我们将在`Tick`事件上调用此函数。由于我们只想看看演员是否在提供的半径内，但我们不关心它实际上有多远，所以在平方值上进行此测试更便宜。
- en: Create a `Branch` node from our `<=` test's output.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的`<=`测试的输出创建一个`Branch`节点。
- en: If our actor passes the `<=` test, we know it's within the grab range. Now,
    we need to see whether it's the closest object in that range.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的演员通过了`<=`测试，我们就知道它在抓取范围内。现在，我们需要看看它是否是该范围内最近的对象。
- en: In the Local Variables list, create a new local variable named `ClosestRange`,
    and set its Variable Type to `Float`. Set its Default Value to `10000.0`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地变量列表中，创建一个名为`ClosestRange`的新的本地变量，并将其变量类型设置为`Float`。将其默认值设置为`10000.0`。
- en: Local variables are variables that only exist within the function in which they're
    declared. They can't be read from outside the function. It's a good idea to use
    local variables within functions for values that are only used by that function
    so that they don't clutter the surrounding object. Local variables are also reset
    to their default values each time the function is run, so you don't have to worry
    about strange values hanging around from previous function calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量是仅存在于声明它们的函数中的变量。它们不能从函数外部读取。在函数中使用局部变量来存储仅由该函数使用的值是一个好主意，这样它们不会混乱周围的对象。局部变量在每次运行函数时都会重置为其默认值，因此您不必担心来自先前函数调用的奇怪值。
- en: Press *Ctrl* + drag `LocalCurrentActorDistSquared` onto your graph to get its
    value.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将“LocalCurrentActorDistSquared”拖动到图表上以获取其值。
- en: Drag a connector from its output and create a `<` test from it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出处拖动一个连接器，并从中创建一个“<”测试。
- en: Drag the `Closest Range` local variable into the test's second input.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Closest Range”局部变量拖动到测试的第二个输入中。
- en: 'Create a `Branch` using the `<` test result as its condition:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“<”测试结果创建一个Branch：
- en: '![](img/8c110ea9-24eb-4e36-92b0-20436c5f7893.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c110ea9-24eb-4e36-92b0-20436c5f7893.png)'
- en: If this test returns true, we've found a new closest actor. We want to save
    a reference to it and record its distance as the new closest range.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此测试返回true，则表示我们找到了一个新的最近演员。我们想保存对它的引用并将其距离记录为新的最近距离。
- en: Press *Alt* + drag `Closest Range` onto the graph, and drag `LocalCurrentActorDistSquared`
    into its input.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Alt键并将“Closest Range”拖动到图表上，并将“LocalCurrentActorDistSquared”拖动到其输入中。
- en: Set this value from the branch's True output.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支的True输出中设置此值。
- en: Create a new local variable named `NearestPickupActor`, and set its type to
    Actor | Object Reference.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“NearestPickupActor”的新的局部变量，并将其类型设置为Actor | Object Reference。
- en: Press *Alt* + drag it onto the graph to set its value.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Alt键并将其拖动到图表上以设置其值。
- en: Set its value to the `For Each Loop` Array Element. (This is going to be a long
    connection. Consider creating some reroute nodes to make it more readable.)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其值设置为“For Each Loop”的Array Element。（这将是一个很长的连接。考虑创建一些重定向节点以使其更易读。）
- en: 'Connect it to the output from the `Set Closest Range` node:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到“Set Closest Range”节点的输出：
- en: '![](img/bd6496a1-cab8-4094-ac19-8f186c17a12a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd6496a1-cab8-4094-ac19-8f186c17a12a.png)'
- en: Finally, once we've iterated through all of the possible objects and found our
    best pickup candidate if one exists, we want to save that value so that it can
    be used by our pickup method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们遍历了所有可能的对象并找到了最佳的可拾取候选对象（如果存在），我们希望保存该值，以便我们的拾取方法可以使用它。
- en: Create a new variable (not a local variable this time—we want to read this value
    outside), name it `AvailablePickupActor`, and set its type to `Actor > Object
    Reference`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的变量（这次不是局部变量 - 我们希望在外部读取此值），命名为“AvailablePickupActor”，并将其类型设置为“Actor >
    Object Reference”。
- en: Press *Alt* + drag it onto the event graph near the Completed output of the `For
    Each Loop`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Alt键并将其拖动到“For Each Loop”的Completed输出附近的事件图上。
- en: Connect the Completed output of the `For Each Loop` to the Set input of `Available
    Pickup Actor`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“For Each Loop”的Completed输出连接到“Available Pickup Actor”的Set输入。
- en: 'Drag the `Nearest Pickup Actor` local variable onto the setter''s input:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Nearest Pickup Actor”局部变量拖动到setter的输入中：
- en: '![](img/4865f89c-0d42-4cd8-9091-e8b89c5f71d4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4865f89c-0d42-4cd8-9091-e8b89c5f71d4.png)'
- en: What this is going to do is set an externally readable `Available Pickup Actor`
    variable to the actor we found when we iterated through the list of possible actors,
    if we found any. `Nearest Pickup Actor` will be `Null` if we didn't find any.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是将一个可外部读取的“Available Pickup Actor”变量设置为我们在遍历可能的演员列表时找到的演员（如果有的话）。如果我们没有找到任何演员，那么“Nearest
    Pickup Actor”将为“Null”。
- en: Calling Find Nearest Pickup Object on the Tick event
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tick事件上调用Find Nearest Pickup Object
- en: 'Now, it''s time to call our new function so that we know when we''re able to
    pick an object up. We don''t want to do this, however, if we''re already holding
    an object, so we should store a reference to any object we''re already holding.
    Let''s get started:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候调用我们的新函数了，以便我们知道何时能够拾取一个对象。然而，如果我们已经拿着一个对象，我们不希望这样做，所以我们应该存储对任何我们已经拿着的对象的引用。让我们开始吧：
- en: Return to your event graph of `BP_VRHand` and find `Event Tick`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到“BP_VRHand”的事件图中，找到“Event Tick”。
- en: Create a `Sequence` node near `Event Tick`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Event Tick”附近创建一个“Sequence”节点。
- en: We want to update our hand animation only after we've looked for objects we
    could grab, so press *Ctrl* + drag the output from execution pin of Event Tick
    onto the `Sequence` node's Then 1 output.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在查找可以抓取的对象之后才更新手部动画，因此按住Ctrl键并将来自“Event Tick”的执行引脚的输出拖动到Sequence节点的Then
    1输出上。
- en: Connect the execution pin of Event Tick to the Sequence node's input.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Event Tick”的执行引脚连接到Sequence节点的输入。
- en: 'Marquee select the node network connected to the Sequence node''s Then 1 output
    and drag them down to give yourself some room to work:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与Sequence节点的Then 1输出连接的节点网络，并将它们拖动到下方，以便有足够的空间进行操作：
- en: '![](img/948645f5-41bf-4f3d-944c-1742a040e197.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/948645f5-41bf-4f3d-944c-1742a040e197.png)'
- en: Create a new variable, name it `HeldActor`, and set its Variable Type to `Actor
    > Object Reference`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的变量，命名为“HeldActor”，并将其变量类型设置为“Actor > Object Reference”。
- en: Press *Ctrl* + drag `HeldActor` onto your event graph to get its value.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将“HeldActor”拖动到事件图中以获取其值。
- en: Right-click it and select `Convert to Validated Get`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它并选择“Convert to Validated Get”。
- en: 'Drag a call to `Find Nearest Pickup Object` onto the graph, and call it from
    the `Held Actor` getter''s Is Not Valid output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个调用Find Nearest Pickup Object的节点拖动到图表上，并从Held Actor getter的Is Not Valid输出中调用它：
- en: '![](img/7c4c66f1-d743-4cf8-9015-4af48453a5d1.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c4c66f1-d743-4cf8-9015-4af48453a5d1.png)'
- en: This way, we're only bothering to check for pickup actors if we're not already
    holding one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有在我们还没有拿起一个对象时，我们才会检查可拾取的演员。
- en: Picking up an actor
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取一个演员
- en: 'Now that we''re looking for actors we could pick up, let''s make that happen
    when we try to grab them. Let''s get started:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在寻找可以拾取的演员，让我们在尝试抓取它们时实现这一点。让我们开始吧：
- en: Open up your `Grab Actor` function in `BP_VRHand`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_VRHand”中的“Grab Actor”函数。
- en: We don't need the `Print String` node here anymore, so we can delete it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要这里的“Print String”节点，所以我们可以将其删除。
- en: Press *Ctrl* + drag a getter for `HeldActor` onto your graph, right-click it,
    and convert it into a validated get.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并将“HeldActor”的getter拖动到图表上，右键单击它，并将其转换为已验证的获取。
- en: Connect the `bWantsToGrip` setter's execution output to the `HeldActor` getter's
    input.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“bWantsToGrip”setter的执行输出连接到“HeldActor”getter的输入。
- en: Press *Ctrl* + drag a getter for `AvailablePickupActor` onto the graph and make
    this a validated get too.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并将“AvailablePickupActor”的getter拖动到图表上，并将其也设置为已验证的获取。
- en: Connect the Is Not Valid output from the `Held Actor` get to this getter's input,
    since we're only interested in picking up an object if we're not already holding
    one.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Held Actor”获取的Is Not Valid输出连接到此getter的输入，因为我们只对如果我们还没有拿着物体感兴趣。
- en: 'Drag out a connector from `Available Pickup Actor` and call `Pickup (Message)`
    on it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Available Pickup Actor”拖出一个连接器并调用“Pickup (Message)”：
- en: '![](img/5b7a1fbf-1474-4f7b-a4ff-a0fc14c84f34.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b7a1fbf-1474-4f7b-a4ff-a0fc14c84f34.png)'
- en: This is why Blueprint Interfaces are so useful. We didn't need to cast the pickup
    actor to any particular class to call the interface method on it. We can simply
    make the call, and if the object implements the interface and knows what to do
    with it, the call will work. If the object doesn't implement the interface, it
    simply does nothing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么蓝图接口如此有用。我们不需要将拾取角色强制转换为任何特定的类来调用接口方法。我们只需进行调用，如果对象实现了接口并知道如何处理它，调用将起作用。如果对象没有实现接口，它将什么也不做。
- en: If you need to find out whether a given actor implements an interface, call
    `Does Implement Interface` on it. This will return true if the interface is found
    on the object. In this particular case, making this call would be redundant since
    we know that `Available Pickup Actor` will always implement the BPI_PickupActor
    interface. We used that interface as a filter when we were looking for objects
    in the `Find Nearest Pickup Object` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要找出给定的角色是否实现了一个接口，请在其上调用“Does Implement Interface”。如果在对象上找到接口，它将返回true。在这种特殊情况下，进行此调用将是多余的，因为我们知道“Available
    Pickup Actor”将始终实现BPI_PickupActor接口。当我们在“Find Nearest Pickup Object”函数中查找对象时，我们使用该接口作为过滤器。
- en: Drag the Motion Controller component onto your `Pickup` node's Attach To input.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Motion Controller组件拖动到您的Pickup节点的Attach To输入上。
- en: Drag the `Held Actor` variable onto the output of `Available Pickup Actor` to
    set it to that value.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Held Actor”变量拖动到“Available Pickup Actor”的输出上，将其设置为该值。
- en: Add `Return Nodes` to your exit points. (You don't have to do this, but your
    code will be far more readable in the long run if you make this a habit.)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“返回节点”添加到您的退出点。(您不必这样做，但是如果您养成这个习惯，您的代码在长期运行中将更易读。)
- en: 'Your completed `Grab Actor` graph should look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的“Grab Actor”图应如下所示：
- en: '![](img/60d8fcc5-e09b-43dc-b1de-c05f624e1cb5.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60d8fcc5-e09b-43dc-b1de-c05f624e1cb5.png)'
- en: To summarize what's going on here, when `Grab Actor` is called, `bWantsToGrip`
    is set to true, and then we check to see whether we're already holding an object.
    We don't do anything more if we are. If we're not, we check to see whether we
    found an object on `Event Tick` that we could pick up. If we didn't, there's nothing
    more to do. If we did, we send a `Pickup` message to it through its interface,
    with a reference to our `Motion Controller` component as the object it should
    attach to, and we stash it as our `Held Actor`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下这里发生的情况，当调用“Grab Actor”时，将“bWantsToGrip”设置为true，然后我们检查是否已经拿着一个物体。如果是，我们不做任何其他操作。如果不是，我们检查是否在“Event
    Tick”上找到了一个我们可以拾取的对象。如果没有，就没有其他事情要做。如果找到了，我们通过其接口向其发送“Pickup”消息，其中包含对我们的“Motion
    Controller”组件的引用作为它应该附加到的对象，并将其存储为我们的“Held Actor”。
- en: Releasing an actor
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放一个角色
- en: 'Since we can now pick an actor up, we''re also going to want to be able to
    drop it again. Let''s do this now:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以拾取一个角色，我们也希望能够再次放下它。现在让我们来做这个：
- en: Open up the `Release Actor` function.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Release Actor”函数。
- en: Delete the `Print String` node from it—we're done with it.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中删除“Print String”节点-我们已经完成了它。
- en: Press *Ctrl* + drag `Held Actor` onto the graph, right-click it, and convert
    it into a validated get.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并将“Held Actor”拖动到图表上，右键单击它，并将其转换为已验证的获取。
- en: Call the validated get after we set `bWantsToGrip`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置“bWantsToGrip”之后调用已验证的获取。
- en: 'Connect a return node to its Is Not Valid output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将返回节点连接到其Is Not Valid输出：
- en: '![](img/44d80e44-3f0e-47ca-9c83-be8832b4f2ee.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44d80e44-3f0e-47ca-9c83-be8832b4f2ee.png)'
- en: If we're not holding anything, there's nothing more we need to do. If we are,
    we should make sure that the actor still thinks we're the one holding it (since
    we could have grabbed it with the other hand) and drop it if it's still our object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有拿着任何东西，我们不需要做任何其他操作。如果我们拿着东西，我们应该确保演员仍然认为我们是拿着它的人(因为我们可能用另一只手抓住它)，如果它仍然是我们的对象，就将其放下。
- en: Drag a connector from `Held Actor` and get its `Root Component`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Held Actor”拖出一个连接器并获取其“Root Component”。
- en: Call `Get Attach Parent` on the root component.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根组件上调用“Get Attach Parent”。
- en: Drag a connector from Return Value of `Get Attach Parent` and create a `==` test.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Get Attach Parent”的“Return Value”拖出一个连接器并创建一个“==”测试。
- en: Drag the `Motion Controller` component onto the test's other input.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Motion Controller”组件拖动到测试的另一个输入上。
- en: 'Create a `Branch` using this test''s result as its condition:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此测试的结果创建一个“Branch”作为其条件：
- en: '![](img/c6ecad42-83ce-4719-93c8-a62ca4ac567a.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6ecad42-83ce-4719-93c8-a62ca4ac567a.png)'
- en: From the Branch's True output, call `Drop` on the `Held Actor`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分支的True输出中，调用“Drop”在“Held Actor”上。
- en: Press *Alt* + drag `Held Actor` onto the graph to create a setter.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Alt*并将“Held Actor”拖动到图表上以创建一个setter。
- en: 'Connect it to the execution output from the `Drop` call, and to the `Branch`
    node''s False output so that we clear the value in either case:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到“Drop”调用的执行输出和“Branch”节点的False输出，以便在任何情况下都清除该值：
- en: '![](img/e35f0d9b-4de9-4ece-b48a-7f6e118ecfbe.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e35f0d9b-4de9-4ece-b48a-7f6e118ecfbe.png)'
- en: 'Your completed graph should look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的图应如下所示：
- en: '![](img/37bd944a-c500-4aeb-897e-376f18e2d8b5.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37bd944a-c500-4aeb-897e-376f18e2d8b5.png)'
- en: To recap what's going on here, when `Release Actor` is called, we first set
    `bWantsToGrip` to false. We then check to see whether we're currently holding
    anything. If we're not, there's nothing more to do. If we think we are holding
    something, we check to make sure the object we think we're holding still sees
    our motion controller as its parent, since we could have grabbed it with the other
    hand. If we really are holding the object, we drop it and clear out the `Held
    Actor` variable. If it turned out we were no longer holding the object after all,
    we clear out the `Held Actor` variable so that we no longer think we are.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾一下这里发生的情况，当调用“Release Actor”时，我们首先将“bWantsToGrip”设置为false。然后，我们检查是否正在拿着任何东西。如果没有，就没有其他事情要做了。如果我们认为我们正在拿着某个东西，我们检查一下我们认为我们正在拿着的物体是否仍然将我们的动作控制器视为其父级，因为我们可能用另一只手抓住它。如果我们真的拿着这个物体，我们就放下它并清除“Held
    Actor”变量。如果事实证明我们不再拿着这个物体，我们清除“Held Actor”变量，这样我们就不再认为我们在拿着它了。
- en: Test grabbing and releasing
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试抓取和释放
- en: 'Let''s test this in our map:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在地图中测试一下：
- en: From your editor's Modes panel, select Place | Basic | Cube, and drag it into
    your scene. Set its Location to X=-2580, Y=310, Z=40 so that it's sitting near
    the player start.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从编辑器的模式面板中，选择“放置|基本|立方体”，并将其拖入场景中。将其位置设置为X=-2580，Y=310，Z=40，以便它位于玩家起始点附近。
- en: Grab `BP_PickupCube` from your content browser, and place it on the cube you
    just placed. You can use the *End* key to drop it to the surface below it. (`X=-2600,
    Y=340, Z=100` is probably a decent location for it.)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中选择“BP_PickupCube”，并将其放置在刚刚放置的立方体上。您可以使用*End*键将其放到下面的表面上。（`X=-2600，Y=340，Z=100`可能是一个不错的位置。）
- en: 'Press *Alt* + drag a few more of these `BP_PickupCubes` and stack them on the
    cube:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Alt键并拖动更多的“BP_PickupCubes”并将它们堆叠在立方体上：
- en: '![](img/528238fa-1aaf-43f9-9971-90f334e09cef.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/528238fa-1aaf-43f9-9971-90f334e09cef.png)'
- en: Launch a VR Preview. Walk or teleport up to the objects on the cube and use
    the triggers to pick them up, drop them, throw them, and move them from hand-to-hand.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 启动VR预览。走到立方体上的物体旁边，使用扳机来拾取、放下、扔掉和手到手移动它们。
- en: Not bad, but there are a few things we need to fix here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，但是这里有几个问题需要修复。
- en: Fixing cube collision
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复立方体碰撞
- en: 'First, and most importantly, they''re colliding with the VRPawn''s collision
    capsule and throwing us around. We''d better fix that:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的是，它们与VRPawn的碰撞胶囊发生碰撞并将我们推开。我们最好修复一下：
- en: Open the `BP_PickupCube` blueprint and select its `Static Mesh Component`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_PickupCube”蓝图并选择其“Static Mesh Component”。
- en: Under its Details | Collision, change its Collision Presets from `PhysicsActor` to
    `Custom`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息|碰撞下，将其碰撞预设从“PhysicsActor”更改为“Custom”。
- en: 'The individual collision response channels for this object are now editable.
    Set the Pawn collision response to `Overlap` instead of `Block`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个对象的个别碰撞响应通道现在可以编辑了。将Pawn的碰撞响应设置为“Overlap”而不是“Block”：
- en: '![](img/f03374d8-d06f-4f7d-9de2-d9fe79f35efa.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f03374d8-d06f-4f7d-9de2-d9fe79f35efa.png)'
- en: This way, we can still detect collisions with the pawn if we're interested in
    them, but they're not going to prevent the player from moving around.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们仍然可以检测到与Pawn的碰撞，如果我们对它们感兴趣的话，但它们不会阻止玩家四处移动。
- en: Letting players know when they can pick something up
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让玩家知道何时可以拾取物品
- en: Secondly, we're not giving the player any visual indication that they can pick
    something up. Let's improve this.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们没有给玩家任何视觉提示，告诉他们他们可以拾取物品。让我们改进一下。
- en: 'First off, let''s add another state to our `EGripState` enumerator:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的“EGripState”枚举器添加另一个状态：
- en: Open up `EGripState` from your project's `Blueprints` directory.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目的“蓝图”目录中的“EGripState”。
- en: Under its Enumerators list, hit New to add another entry. Name it `CanGrab`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其枚举器列表下，点击“新建”以添加另一个条目。将其命名为“CanGrab”。
- en: Close and save it.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭并保存它。
- en: Now, we need to tell our Animation Blueprint what to do with this.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉我们的动画蓝图该怎么做。
- en: Open the `ABP_MannequinHand_Right` animation blueprint and open its `Event Graph`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“ABP_MannequinHand_Right”动画蓝图并打开其“事件图表”。
- en: 'Under `Event Blueprint Update Animation`, you''ll see that the `Grip State`
    `Select` node has been automatically updated to reflect the new `Can Grab` enumerator
    we added. Set its value to `0.5`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“事件蓝图更新动画”下，您会看到“Grip State”“Select”节点已自动更新以反映我们添加的新的“Can Grab”枚举器。将其值设置为“0.5”：
- en: '![](img/6cdbd564-b00b-479b-a391-f2b9296a3e77.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cdbd564-b00b-479b-a391-f2b9296a3e77.png)'
- en: Try it out by compiling and then changing Grip State in the Anim Preview Editor.
    The hand should go to a halfway-open state when Grip State is set to `Can Grab`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译并在动画预览编辑器中更改Grip State来尝试一下。当Grip State设置为“Can Grab”时，手应该处于半开状态。
- en: Save and close your animation blueprint.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭动画蓝图。
- en: Next, we need to get the `BP_VRHand` blueprint to set `Grip State` to `Can Grab` when
    it detects that the player can grab something. Let's create a pure function to
    determine what our `Grip State` should be.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要让“BP_VRHand”蓝图在检测到玩家可以抓取物体时将“Grip State”设置为“Can Grab”。让我们创建一个纯函数来确定我们的“Grip
    State”应该是什么。
- en: Open Event Graph of `BP_VRHand` and find `Event Tick`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_VRHand”的“事件图表”并找到“事件Tick”。
- en: Select the `bWantsToGrip` reference and the `Select` node connected to it and
    collapse them into a function.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“bWantsToGrip”引用和与其连接的“Select”节点，并将它们折叠成一个函数。
- en: 'Name the function `DetermineGripState`, set its Category to Grabbing, set its
    Access Specifier to Private, and set Pure to True:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为“DetermineGripState”，将其类别设置为“Grabbing”，将其访问限定符设置为“Private”，将纯度设置为“True”：
- en: '![](img/5c7a0977-18fe-4325-a3df-da60e3ef5d1a.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7a0977-18fe-4325-a3df-da60e3ef5d1a.png)'
- en: Open up `DetermineGripState`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“DetermineGripState”。
- en: Press *Ctrl* + drag `Held Actor` onto the graph and convert it into a validated
    get.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将“Held Actor”拖到图表中，并将其转换为已验证的获取。
- en: Connect it to the function input and add a new `Return Node` from its Is Valid
    output.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到函数输入并从其IsValid输出添加一个新的“Return Node”。
- en: 'Set this node''s Return Value to `Gripping`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此节点的返回值设置为“Gripping”：
- en: '![](img/5b424d48-a4b6-43f2-a8d9-f25762d896bd.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b424d48-a4b6-43f2-a8d9-f25762d896bd.png)'
- en: If we're holding an object, we don't care about anything else—we should just
    animate to the Gripping state.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拿着一个物体，我们不会关心其他任何事情-我们只需要将其动画化到抓握状态。
- en: Add a `Branch` node to the graph.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中添加一个“分支”节点。
- en: Drag the `bWantsToGrip` value into its Condition.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bWantsToGrip`的值拖动到其条件中。
- en: Connect its True branch to the `Gripping` `Return Node` we just created.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其True分支连接到我们刚刚创建的“Gripping”“返回节点”。
- en: Press *Ctrl* + drag `AvailablePickupActor` onto the graph and convert it into
    a validated get.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将`AvailablePickupActor`拖动到图表中，并将其转换为已验证的获取。
- en: Add another `Return Node` connected to its Is Valid output, and set its Return
    Value to `Can Grab`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其“合法”输出上添加另一个连接到“返回节点”，并将其返回值设置为“Can Grab”。
- en: 'Add another `Return Node` to its Is Not Valid output, with the value Open:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其“不合法”输出中添加另一个“返回节点”，其值为Open：
- en: '![](img/536a1608-bb13-48fd-a6ec-3b7b2089e5a6.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/536a1608-bb13-48fd-a6ec-3b7b2089e5a6.png)'
- en: Let's test it out. Now, you should see the hand change its pose when it detects
    an object it can grab.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。现在，当检测到可以抓取的物体时，您应该看到手的姿势发生变化。
- en: Adding haptic feedback
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加触觉反馈
- en: There's one other thing we should be doing, which is adding some degree of feedback
    to the hand when the player makes contact with an object. This may seem like a
    small thing, but it's actually significant to the process of evoking presence.
    We don't have many ways at present to simulate physical sensations, but any sensation
    at all that's paired to an event or action can go a long way toward making the
    virtual world feel less "ethereal" and more physical.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事情我们应该做的是，在玩家与物体接触时为手部添加一些反馈。这可能看起来像是一件小事，但实际上对于唤起存在感的过程非常重要。目前我们没有太多的方法来模拟物理感觉，但是任何与事件或动作配对的感觉都可以在很大程度上使虚拟世界感觉不那么“虚幻”而更加真实。
- en: Let's learn how to add a bit of rumble to our controllers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何为我们的控制器添加一点震动。
- en: Creating a Haptic Feedback Effect Curve
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建触觉反馈效果曲线
- en: 'First, we need to create the haptic effect we want to play:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建要播放的触觉效果：
- en: 'Right-click in your project''s `Blueprints` directory and select Create Advanced
    Asset | Miscellaneous | Haptic Feedback Effect Curve:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的“蓝图”目录中右键单击，选择“创建高级资产”|“杂项”|“触觉反馈效果曲线”：
- en: '![](img/d1f14b93-71a3-4087-869f-34b2d4fe91fc.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1f14b93-71a3-4087-869f-34b2d4fe91fc.png)'
- en: Name it `FX_ControllerRumble`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`FX_ControllerRumble`。
- en: Open the Haptic Feedback Effect Curve we just created.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开刚刚创建的触觉反馈效果曲线。
- en: 'You''ll see that you have two curves under Haptic Feedback Effect | Haptic
    Details: Frequency and Amplitude. We''re going to create a very simple effect
    here, but it''s really worth experimenting with these curves and figuring out
    how to create convincing feedback effects.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到在触觉反馈效果|触觉详情下有两个曲线：频率和振幅。我们将在这里创建一个非常简单的效果，但是通过尝试这些曲线并找出如何创建令人信服的反馈效果是非常值得的。
- en: Right-click on your Frequency curve's timeline near the 0.0 time and select
    `Add key to None`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击频率曲线的时间轴附近的0.0时间，并选择“添加关键帧到无”。
- en: 'Fix its Time and Value settings to read `0.0` for each:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其时间和值设置修正为每个都为`0.0`：
- en: '![](img/1e8b2ce2-e5f4-41aa-8206-f41e9a90b243.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e8b2ce2-e5f4-41aa-8206-f41e9a90b243.png)'
- en: Right-click again on the timeline and add another key. Set this one's Time to
    `0.5` and its Value to `1.0`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击时间轴，添加另一个关键帧。将此关键帧的时间设置为`0.5`，值设置为`1.0`。
- en: Create a third key on the curve, with Time as `1.0` and Value as `0.0`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在曲线上创建第三个关键帧，时间为`1.0`，值为`0.0`。
- en: 'Create the same three keys for your Amplitude curve:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为振幅曲线创建相同的三个关键帧：
- en: '![](img/16145565-fb02-4512-aba4-465cd9a261aa.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16145565-fb02-4512-aba4-465cd9a261aa.png)'
- en: Your completed curves should look like what's shown in the preceding screenshot.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的曲线应该看起来像前面的截图所示。
- en: Save and close your new haptic effect curve.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭新的触觉效果曲线。
- en: Playing the haptic effect on command
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按命令播放触觉效果
- en: 'Now that we''ve created a Haptic Feedback Effect Curve, let''s set up a method
    to play it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个触觉反馈效果曲线，让我们设置一个播放它的方法：
- en: Open Event Graph of `BP_VRHand` and right-click. Select Add Event | Add Custom
    Event. Name the new event `RumbleController`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_VRHand`的事件图表，右键单击。选择“添加事件”|“添加自定义事件”。将新事件命名为`RumbleController`。
- en: Create an Input for this event. Name it `Intensity`, and set its type to `Float`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此事件创建一个输入。将其命名为`Intensity`，并将其类型设置为`Float`。
- en: Right-click and create a `Get Player Controller` node.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并创建一个“获取玩家控制器”节点。
- en: Drag a connector out from `GetPlayerController` and create a `Play Haptic Effect`
    node.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetPlayerController`拖动连接器并创建一个“播放触觉效果”节点。
- en: Select the Haptic Effect we just created.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择刚刚创建的触觉效果。
- en: Drag the `Hand` variable into the Hand input.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Hand”变量拖动到Hand输入中。
- en: 'Drag the event''s Intensity output into the Scale input:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件的强度输出拖动到比例输入中：
- en: '![](img/cf89b216-3ece-4f85-870d-1b119b557c34.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf89b216-3ece-4f85-870d-1b119b557c34.png)'
- en: Now, let's call this Gaptic effect whenever we make contact with a new object
    we could pick up.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们接触到一个新的可拾取物体时，让我们调用这个触觉效果。
- en: Open up your `Find Nearest Pickup Object` function of `BP_VRHand`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_VRHand`的“查找最近的拾取物体”函数。
- en: See where we're setting `Available Pickup Actor` to the value we found in `Nearest
    Pickup Actor`? Let's detect when we're putting a new value in there and trigger
    the effect when that happens.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们在`Available Pickup Actor`中设置为`Nearest Pickup Actor`中找到的值吗？让我们在放入新值时检测到，并在发生时触发效果。
- en: Right-click your `Nearest Pickup Actor` getter, and convert it into a validated
    get.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“Nearest Pickup Actor”获取器，并将其转换为已验证的获取。
- en: Press *Ctrl *+ drag the execution input into `Set Available Pickup Actor` onto
    the `Get Nearest Pickup Actor` getter's execution input.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将执行输入拖动到“Set Available Pickup Actor”上，然后将其放在“Get Nearest Pickup Actor”获取器的执行输入上。
- en: Drag a connector from the `Nearest Pickup Actor` getter's value and create a
    `!=` (Not Equal) node.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“最近的拾取物体”获取器的值拖动连接器，并创建一个“！=”（不等于）节点。
- en: Drag a reference to `Available Pickup Actor` from your Variables list into the
    `Not Equal` node's other input.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从变量列表中将对`Available Pickup Actor`的引用拖动到“不等于”节点的另一个输入中。
- en: Create a `Branch` from its output.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出创建一个“分支”。
- en: Drag the Is Valid execution pin from `Nearest Pickup Actor` into the `Branch`
    input.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Nearest Pickup Actor`的Is Valid执行引脚拖动到`Branch`输入中。
- en: Call `Rumble Controller` from its True output and set its Intensity to `0.8`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其True输出调用`Rumble Controller`并将其强度设置为`0.8`。
- en: Drag the output from `Rumble Controller` into your `Available Pickup Actor`
    setter's input.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Rumble Controller`的输出拖动到`Available Pickup Actor`的输入中。
- en: Drag the Is Not Valid output from `Nearest Pickup Actor` into the setter of `Available
    Pickup Actor`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Nearest Pickup Actor`的Is Not Valid输出拖动到`Available Pickup Actor`的setter中。
- en: 'Add return nodes after `Set Available Pickup Actor` and from the `Not Equal`
    test''s `False` branch:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Set Available Pickup Actor`之后和`Not Equal`测试的`False`分支之后添加返回节点：
- en: '![](img/cd15ad1a-8fc6-4fe5-a98a-73e5fcf518ee.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd15ad1a-8fc6-4fe5-a98a-73e5fcf518ee.png)'
- en: To recap what's going on here, once we've completed iterating through the objects
    we could potentially pick up, we need to check whether we've found one. If we
    didn't, we just set `Available Pickup Actor` to the null value so that we're clearing
    it if it previously contained a value. If we did find an object we could pick
    up, we check to see whether it's different from our current `Available Pickup
    Actor`. If it is, we rumble the controller before we set `Available Pickup Actor`
    to the new value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾一下这里发生的情况，一旦我们完成了对可能拾取的对象的迭代，我们需要检查是否找到了一个对象。如果没有找到，我们只需将`Available Pickup
    Actor`设置为null值，以便在先前包含值的情况下清除它。如果我们找到了一个可以拾取的对象，我们检查它是否与当前的`Available Pickup Actor`不同。如果是，我们在设置`Available
    Pickup Actor`为新值之前会使控制器震动。
- en: Going further
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步
- en: 'There are a few ways we could further improve on what we''ve done here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步改进我们在这里所做的几种方法：
- en: First, detecting grabbable objects by distance gives us fuzzy results. It doesn't
    take the object's size into account. Using a sphere to represent our grabbing
    hand and testing for overlaps against this sphere is going to give us more accurate
    results. If you'd like to refactor this code to use that method, the VR Template
    project contains a good example.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，通过距离检测可抓取对象会给我们带来模糊的结果。它没有考虑到对象的大小。使用一个球体来代表我们的抓取手，并针对该球体进行重叠测试将给我们更准确的结果。如果您想重构此代码以使用该方法，VR模板项目中包含一个很好的示例。
- en: Second, our haptic feedback effect feels indistinct. It fades in and out evenly,
    and doesn't provide much of a physical sensation. Editing those curves to provide
    a sharper attack could make the effect more convincing.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们的触觉反馈效果感觉不够明显。它均匀地淡入淡出，并没有提供太多的物理感觉。通过编辑这些曲线以提供更锐利的攻击可以使效果更加令人信服。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter picked up where the last one left off and gave us a chance to start
    picking up objects. We learned how to use Blueprint Interfaces to enable function
    calls to be made on a wide variety of objects and how to detect actors we could
    pick up and use attachments to pick them up and drop them. Finally, we also learned
    how to create haptic feedback effects to indicate to players when they've made
    contact with an object they can pick up.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续上一章的内容，让我们有机会开始拾取物体。我们学会了如何使用蓝图接口来使各种对象能够进行函数调用，以及如何检测我们可以拾取的演员并使用附件来拾取和放下它们。最后，我们还学会了如何创建触觉反馈效果，以指示玩家何时与可以拾取的对象接触。
- en: As we mentioned at the start of the previous chapter, hand presence is an important
    factor in driving an overall sense of presence in VR. We're aware of our hands
    all of the time in real life, and bringing them into the virtual world does a
    lot to make us feel present in the space as well. In addition, the ability to
    use our hands to manipulate objects directly is one of the crucial things we can
    do in VR that we just can't do in any other medium. (For an example of just how
    well this can be done, check out *Vinyl Reality* by **EntroPi Games** ([https://vinyl-reality.com/](https://vinyl-reality.com/))
    and then imagine trying to do the same thing with a gamepad or a keyboard.) Hands
    are important to VR, and they're unique to VR. Take the time to get them right
    in your applications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的开头提到的，手的存在是VR中产生整体存在感的重要因素。在现实生活中，我们始终意识到自己的手，将它们带入虚拟世界也会让我们在空间中感到存在。此外，直接使用手来操纵物体的能力是我们在VR中可以做的关键事情之一，而在其他任何媒介中都无法做到。
    （要了解这一点的一个例子，请查看**EntroPi Games**的*Vinyl Reality*（[https://vinyl-reality.com/](https://vinyl-reality.com/)），然后想象一下尝试使用游戏手柄或键盘做同样的事情。）手在VR中非常重要，它们是VR的独特之处。在您的应用程序中花时间将它们处理正确。
- en: In the next chapter, we're going to learn how to create user interfaces in VR
    to display information and to make it possible for users to interact in 3D space.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在VR中创建用户界面以显示信息，并使用户能够在3D空间中进行交互。
