- en: Scratching the Tip of the Iceberg
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只是冰山一角
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with graphs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理图
- en: Visualizing graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化图
- en: Using a true random number generator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真随机数生成器
- en: Using portable math functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可移植数学函数
- en: Writing test cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: Combining multiple test cases in one test module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个测试用例组合在一个测试模块中
- en: Manipulating images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作图像
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Boost is a huge collection of libraries. Some of these libraries are small and
    meant for everyday use, while others require a separate book to describe all their
    features. This chapter is devoted to some of those big libraries and provides
    a basic understanding of it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Boost是一个庞大的库集合。其中一些库很小，适用于日常使用，而其他一些则需要单独的书来描述它们的所有特性。本章专门介绍了其中一些大型库，并提供了对它的基本理解。
- en: The first two recipes will explain the usage of `Boost.Graph`. It is a big library
    with an insane number of algorithms. We'll see some basics and probably the most
    important part of development--visualization of graphs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前两篇食谱将解释`Boost.Graph`的用法。这是一个拥有大量算法的大型库。我们将看到一些基础知识，也可能是开发中最重要的部分--图的可视化。
- en: We'll also see a very useful recipe for generating true random numbers. This
    is a very important recipe for writing secure cryptography systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到一个非常有用的食谱，用于生成真随机数。这对于编写安全的加密系统非常重要。
- en: Some C++ standard libraries lack math functions. We'll see how that can be fixed
    using Boost. But, the format of this book leaves no space for describing all the
    functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C++标准库缺乏数学函数。我们将看到如何使用Boost来解决这个问题。但是，本书的格式没有空间来描述所有的函数。
- en: Writing test cases is described in the *Writing test cases* and *Combining multiple
    test cases in one test module* recipes. This is important for any production-quality
    system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试用例在*编写测试用例*和*将多个测试用例组合在一个测试模块中*的食谱中有所描述。这对于任何生产质量的系统都很重要。
- en: The last recipe is about a library that helped me in a lot of my course work
    during my university days. Images can be created and modified using it. I personally
    used it to visualize different algorithms, hide data in images, sign images, and
    generate textures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一篇食谱是关于一个在我大学时代的很多课程作业中帮助过我的库。可以使用它来创建和修改图像。我个人用它来可视化不同的算法，隐藏图像中的数据，签名图像和生成纹理。
- en: Unfortunately, even this chapter cannot tell you about all the Boost libraries.
    Maybe someday, I'll write one more book, and then, a few more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使这一章也不能告诉你关于所有的Boost库。也许有一天，我会再写一本书，然后再写几本。
- en: Working with graphs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图
- en: Some tasks require representing data as a graph. The `Boost.Graph` is a library
    that was designed to provide a flexible way of constructing and representing graphs
    in memory. It also contains a lot of algorithms to work with graphs, such as topological
    sort, breadth first search, depth first search, and Dijkstra shortest paths.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有些任务需要将数据表示为图。`Boost.Graph`是一个旨在提供一种灵活的方式在内存中构建和表示图的库。它还包含了许多处理图的算法，如拓扑排序、广度优先搜索、深度优先搜索和Dijkstra最短路径。
- en: Well, let's perform some basic tasks with `Boost.Graph`!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们用`Boost.Graph`执行一些基本任务！
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and templates are required for this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱只需要基本的C++和模板知识。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we'll describe a graph type, create a graph of that type, add
    some vertexes and edges to the graph, and search for a specific vertex. That should
    be enough to start with `Boost.Graph`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将描述一个图类型，创建该类型的图，向图中添加一些顶点和边，并搜索特定的顶点。这应该足以开始使用`Boost.Graph`了。
- en: 'We start by describing the graph type:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先描述图的类型：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we construct it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们构建它：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s carry out some undocumented trick that speeds up graph construction:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行一些未记录的技巧，加快图的构建速度：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we are ready to add vertexes to the graph:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备向图中添加顶点：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is time to connect vertexes with edges:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候用边连接顶点了：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We may make a function that searches for some vertex:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个搜索某个顶点的函数：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next is a code that gets iterators to all vertexes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个获取所有顶点迭代器的代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s time to run a search for the required vertex:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候运行搜索所需的顶点了：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At *step 1*, we are describing what our graph must look like and on what types
    it must be based. The `boost::adjacency_list` is a class that represents graphs
    as two-dimensional structures, where the first dimension contains vertexes and
    the second dimension contains edges for that vertex. The `boost::adjacency_list`
    must be the default choice for representing a graph because it suits most cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们描述了我们的图必须是什么样子，以及它必须基于什么类型。`boost::adjacency_list`是一个表示图为二维结构的类，其中第一维包含顶点，第二维包含该顶点的边。`boost::adjacency_list`必须是表示图的默认选择，因为它适用于大多数情况。
- en: 'The first template parameter, `boost::adjacency_list`, describes the structure
    used to represent the edge list for each of the vertexes. The second one describes
    a structure to store vertexes. We may choose different standard library containers
    for those structures using specific selectors, as listed in the following table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板参数`boost::adjacency_list`描述了用于表示每个顶点的边列表的结构。第二个描述了存储顶点的结构。我们可以使用特定选择器在这些结构中选择不同的标准库容器，如下表所列：
- en: '| Selector | Standard library container |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 选择器 | 标准库容器 |'
- en: '| `boost::vecS` | `std::vector` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `boost::vecS` | `std::vector` |'
- en: '| `boost::listS` | `std::list` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `boost::listS` | `std::list` |'
- en: '| `boost::slistS` | `std::slist` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `boost::slistS` | `std::slist` |'
- en: '| `boost::setS` | `std::set` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `boost::setS` | `std::set` |'
- en: '| `boost::multisetS` | `std::multiset` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multisetS` | `std::multiset` |'
- en: '| `boost::hash_setS` | `std::hash_set` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `boost::hash_setS` | `std::hash_set` |'
- en: The third template parameter is used to make an indirect, directed, or bidirectional
    graph. Use the `boost::undirectedS`, `boost::directedS`, and `boost::bidirectionalS`
    selectors respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个模板参数用于创建一个间接的、有向的或双向的图。分别使用`boost::undirectedS`、`boost::directedS`和`boost::bidirectionalS`选择器。
- en: The fifth template parameter describes the datatype that is used as a vertex.
    In our example we choose `std::string`. We may also support a datatype for edges
    and provide it as a template parameter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个模板参数描述了用作顶点的数据类型。在我们的示例中，我们选择了`std::string`。我们还可以支持边缘的数据类型，并将其作为模板参数提供。
- en: '*Steps 2* and *3* are simple, but in *step 4* you may see some undocumented
    way to speed up graph construction. In our example, we use `std::vector` as a
    container for storing vertexes, so we may force it to reserve memory for the required
    number of vertexes. This leads to less memory allocations/deallocations and copy
    operations during insertion of vertexes into the graph. This step is not very
    portable and may break in one of the future versions of Boost, because the step
    is highly dependent on the current implementation of `boost::adjacency_list` and
    on the chosen container type for storing vertexes.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*和*3*很简单，但在*步骤4*中，您可能会看到一些未记录的加速图表构建的方法。在我们的示例中，我们使用`std::vector`作为存储顶点的容器，因此我们可以强制它为所需数量的顶点保留内存。这会减少插入顶点时的内存分配/释放和复制操作。这一步并不是非常可移植的，可能会在未来的Boost版本中出现问题，因为这一步高度依赖于`boost::adjacency_list`的当前实现和所选的用于存储顶点的容器类型。'
- en: At *step 4*, we see how vertexes can be added to the graph. Note how `boost::graph_traits<graph_type>`
    has been used. The `boost::graph_traits` class is used to get types that are specific
    for a graph type. We'll see its usage and the description of some graph-specific
    types later in this chapter. *Step 5* shows what we need to connect vertexes with
    edges.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们看到了如何向图表中添加顶点。请注意`boost::graph_traits<graph_type>`的使用。`boost::graph_traits`类用于获取特定于图表类型的类型。我们将在本章后面看到它的用法和一些特定于图表的类型的描述。*步骤5*显示了连接顶点和边缘所需的内容。
- en: 'If we had provided some datatype for the edges, adding an edge would look as
    follows: `boost::add_edge(ansic, guru, edge_t(initialization_parameters), graph)`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为边缘提供了一些数据类型，添加边缘将如下所示：`boost::add_edge(ansic, guru, edge_t(initialization_parameters),
    graph)`
- en: In *step 6,* the graph type is a `template` parameter. This is recommended to
    achieve better code re-usability and make this function work with other graph
    types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，图表类型是一个`template`参数。这是为了实现更好的代码重用性，并使此函数适用于其他图表类型。
- en: At *step 7*, we see how to iterate over all the vertexes of the graph. The type
    of vertex iterator is received from `boost::graph_traits`. The function `boost::tie`
    is a part of `Boost.Tuple` and is used for getting values from tuples to the variables.
    So, calling `boost::tie(it, end) = boost::vertices(g)` puts the `begin` iterator
    into the `it` variable and the `end` iterator into the `end` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们看到了如何遍历图表的所有顶点。顶点迭代器的类型是从`boost::graph_traits`中获得的。函数`boost::tie`是`Boost.Tuple`的一部分，用于从元组中获取值到变量中。因此，调用`boost::tie(it,
    end) = boost::vertices(g)`将`begin`迭代器放入`it`变量中，将`end`迭代器放入`end`变量中。
- en: It may come as a surprise to you, but dereferencing a vertex iterator does not
    return vertex data. Instead, it returns the vertex descriptor `desc`, which can
    be used in `boost::get(boost::vertex_bundle, g)[desc]` to get vertex data, just
    as we have done in *step 8*. The vertex descriptor type is used in many of the
    `Boost.Graph` functions. We already saw its use in the edge construction function
    in *step 5*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会感到惊讶，但解引用顶点迭代器并不会返回顶点数据。相反，它返回顶点描述符`desc`，可以在`boost::get(boost::vertex_bundle,
    g)[desc]`中使用，以获取顶点数据，就像我们在*步骤8*中所做的那样。顶点描述符类型在许多`Boost.Graph`函数中使用。我们已经在*步骤5*中看到了它的用法。
- en: As already mentioned, the `Boost.Graph` library contains implementations of
    many algorithms. You may find many search policies implemented, but we won't discuss
    them in this book. We limit this recipe just to the basics of the graph library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Boost.Graph`库包含许多算法的实现。您可能会发现许多搜索策略的实现，但我们不会在本书中讨论它们。我们将此教程限制在图表库的基础知识上。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Graph` library is not a part of C++17 and it won''t be a part of
    the next C++ standard. The current implementation does not support C++11 features
    like rvalue references. If we are using vertexes that are heavy to copy, we may
    gain speed using the following trick:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Graph`库不是C++17的一部分，也不会成为下一个C++标准的一部分。当前的实现不支持C++11的特性，如右值引用。如果我们使用的顶点很难复制，可以使用以下技巧来提高速度：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It avoids copy constructions inside `boost::add_vertex(vertex_data, graph)`
    and uses the default construction with move assignment instead.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它避免了在`boost::add_vertex(vertex_data, graph)`内部进行复制构造，并使用默认构造和移动赋值代替。
- en: The efficiency of `Boost.Graph` depends on multiple factors, such as the underlying
    containers types, graph representation, edge, and vertex datatypes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Graph`的效率取决于多个因素，如底层容器类型、图表表示、边缘和顶点数据类型。'
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Reading the *Visualizing graphs* recipe can help you work easily with graphs.
    You may also consider reading its official documentation at the following link:
    [http://boost.org/libs/graph](http://boost.org/libs/graph)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*可视化图表*的教程可以帮助您轻松处理图表。您还可以考虑阅读其官方文档，链接如下：[http://boost.org/libs/graph](http://boost.org/libs/graph)
- en: Visualizing graphs
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化图表
- en: Making programs that manipulate graphs was never easy because of issues with
    visualization. When we work with standard library containers such as `std::map`
    and `std::vector`, we can always print the container's contents and see what is
    going on inside. But when we work with complex graphs, it is hard to visualize
    the content in a clear way; textual representation is not human friendly because
    it typically contains too many vertexes and edges.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 制作操作图表的程序从来都不容易，因为可视化存在问题。当我们使用标准库容器，如`std::map`和`std::vector`时，我们可以始终打印容器的内容并查看内部情况。但是，当我们使用复杂的图表时，很难以清晰的方式可视化内容；文本表示对人类不友好，因为它通常包含太多的顶点和边缘。
- en: In this recipe, we'll take a look at the visualization of `Boost.Graph` using
    the **Graphviz** tool.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用**Graphviz**工具来可视化`Boost.Graph`。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To visualize graphs, you will need a Graphviz visualization tool. Knowledge
    of the preceding recipe is also required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化图形，您将需要一个Graphviz可视化工具。还需要了解前面的食谱。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Visualization is done in two phases. In the first phase, we make our program
    output the graph's description in a text format suitable for Graphviz. In the
    second phase, we import the output from the first step to the visualization tool.
    The numbered steps in this recipe are all about the first phase.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化分为两个阶段。在第一阶段，我们使我们的程序以适合Graphviz的文本格式输出图形描述。在第二阶段，我们将第一步的输出导入到可视化工具中。本食谱中编号的步骤都是关于第一阶段的。
- en: 'Let''s write the `std::ostream` operator for `graph_type` as done in the preceding
    recipe:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照前面的食谱为`graph_type`编写`std::ostream`运算符：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `detail::vertex_writer` structure, used in the preceding step, must be
    defined as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的步骤中使用的`detail::vertex_writer`结构必须定义如下：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s all. Now, if we visualize the graph from the previous recipe using
    the `std::cout << graph;` command, the output can be used to create graphical
    pictures using the `dot` command-line utility:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，如果我们使用`std::cout << graph;`命令可视化前一个食谱中的图形，输出可以用于使用`dot`命令行实用程序创建图形图片：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command is depicted in the following figure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下图所示：
- en: '![](img/00021.gif)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.gif)'
- en: We may also use the **Gvedit** or **XDot** programs for visualization, if the
    command line frightens you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行让您害怕，我们还可以使用**Gvedit**或**XDot**程序进行可视化。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.Graph` library contains function to output graphs in Graphviz (DOT)
    format. If we write `boost::write_graphviz(out, g)` with two parameters in *step
    1*, the function outputs a graph picture with vertexes numbered from `0`. That's
    not very useful, so we provide an instance of the hand-written `vertex_writer`
    class that outputs vertex names.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Graph`库包含以Graphviz（DOT）格式输出图形的函数。如果我们在*步骤1*中使用两个参数写`boost::write_graphviz(out,
    g)`，该函数将输出一个以`0`为顶点编号的图形图片。这并不是很有用，因此我们提供了一个手写的`vertex_writer`类的实例，用于输出顶点名称。'
- en: As we can see in *step 2*, the Graphviz tool understands DOT format. If you
    wish to output more info for your graph, then you may need to read the Graphviz
    documentation for more info about the DOT format.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*步骤2*中看到的，Graphviz工具理解DOT格式。如果您希望为图形输出更多信息，则可能需要阅读有关DOT格式的Graphviz文档以获取更多信息。
- en: If you wish to add some data to the edges during visualization, we need to provide
    an instance of the edge visualizer as a fourth parameter to `boost::write_graphviz`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在可视化过程中向边添加一些数据，我们需要在`boost::write_graphviz`的第四个参数中提供边可视化器的实例。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++17 does not contain `Boost.Graph` or the tools for graph visualization. But
    you do not need to worry, as there are a lot of other graph formats and visualization
    tools and `Boost.Graph` can work with plenty of them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C++17不包含`Boost.Graph`或用于图形可视化的工具。但是您不必担心，因为还有很多其他图形格式和可视化工具，`Boost.Graph`可以与其中许多工作。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with graphs* recipe contains information about the construction
    of `Boost.Graphs`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用图形*食谱包含有关构建`Boost.Graphs`的信息'
- en: You will find a lot of information about the DOT format and Graphviz at [http://www.graphviz.org/](http://www.graphviz.org/)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[http://www.graphviz.org/](http://www.graphviz.org/)找到有关DOT格式和Graphviz的大量信息
- en: Boost's official documentation of the `Boost.Graph` library contains multiple
    examples and useful information, and can be found at [http://boost.org/libs/graph](http://boost.org/libs/graph)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Graph`库的官方文档包含多个示例和有用信息，可以在[http://boost.org/libs/graph](http://boost.org/libs/graph)找到'
- en: Using a true random number generator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用真正的随机数生成器
- en: I know of many examples of commercial products that use incorrect methods for
    getting random numbers. It's a shame that some companies still use `rand()` in
    cryptography and banking software.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道许多商业产品使用不正确的方法来获取随机数。一些公司仍然在密码学和银行软件中使用`rand()`，这是令人遗憾的。
- en: Let's see how to get a fully random **uniform distribution** using `Boost.Random`
    that is suitable for banking software.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Boost.Random`获取适用于银行软件的完全随机的**均匀分布**。
- en: Getting started
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Basic knowledge of C++ is required for this recipe. Knowledge about different
    types of distributions will also be helpful. The code in this recipe requires
    linking against the `boost_random` library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要基本的C++知识。对于不同类型的分布的了解也将有所帮助。本食谱中的代码需要链接到`boost_random`库。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create a true random number, we need some help from the operating system
    or processor. This is how it can be done using Boost:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建真正的随机数，我们需要操作系统或处理器的帮助。以下是使用Boost的方法：
- en: 'We need to include the following headers:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包括以下头文件：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Advanced random bits providers have different names under different platforms:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级随机位提供程序在不同平台下有不同的名称：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we are ready to initialize the generator with `Boost.Random`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备使用`Boost.Random`初始化生成器：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s get a uniform distribution that returns a value between `1000` and `65535`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们得到一个返回介于`1000`和`65535`之间的均匀分布：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. Now, we may get true random numbers using the `random(device)` call.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们可以使用`random(device)`调用获取真正的随机数。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Why does the `rand()` function not suit banking? Because it generates pseudo-random
    numbers, which means that the hacker may predict the next generated number. This
    is an issue with all pseudo-random number algorithms. Some algorithms are easier
    to predict and some harder, but it's still possible.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`rand()`函数不适用于银行业？因为它生成伪随机数，这意味着黑客可能会预测下一个生成的数字。这是所有伪随机数算法的问题。有些算法更容易预测，有些更难，但仍然是可能的。
- en: That's why, we are using `boost::random_device` in this example (see *step 3*).
    That device gathers **entropy**--information about random events from all around
    the operating system to produce unpredictable uniform random bits. The examples
    of such events are delays between pressed keys, delays between some of the hardware
    interruptions, and the internal CPU's random bits generators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在这个示例中我们使用`boost::random_device`（见*步骤3*）。该设备收集**熵**--来自操作系统各处的随机事件信息，以产生不可预测的均匀随机位。这些事件的例子包括按键之间的延迟、一些硬件中断之间的延迟以及内部CPU的随机位生成器。
- en: Operating systems may have more than one such type of random bit generator.
    In our example for POSIX systems, we used `/dev/urandom` instead of the more secure
    `/dev/random` because the latter remains in a blocked state until enough random
    events have been captured by the OS. Waiting for entropy may take seconds, which
    is usually unsuitable for applications. Use `/dev/random` for the long-lifetime
    **GPG**/**SSL**/**SSH** keys.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可能有多种此类随机位生成器。在我们的POSIX系统示例中，我们使用了`/dev/urandom`，而不是更安全的`/dev/random`，因为后者在操作系统捕获足够的随机事件之前会保持阻塞状态。等待熵可能需要几秒钟，这通常不适用于应用程序。对于长期使用的**GPG**/**SSL**/**SSH**密钥，请使用`/dev/random`。
- en: Now that we are done with generators, it's time to move to *step 4* and talk
    about distribution classes. If the generator just generates uniform distributed
    bits, the distribution class makes a random number from those bits. In *step 4*,
    we made a uniform distribution that returns a random number of `unsigned short`
    type. The parameter `1000` means that distribution must return numbers greater
    or equal to `1000`. We can also provide the maximum number as a second parameter,
    which is by default equal to the maximum value storable in the return type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了生成器，是时候转到*步骤4*并讨论分布类了。如果生成器只生成均匀分布的位，分布类将从这些位生成一个随机数。在*步骤4*中，我们创建了一个返回`unsigned
    short`类型的随机数的均匀分布。参数`1000`表示分布必须返回大于或等于`1000`的数字。我们还可以提供最大数字作为第二个参数，该参数默认等于返回类型中可存储的最大值。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Random` has a huge number of true/pseudo random bit generators and
    distributions for different needs. Avoid copying distributions and generators.
    This may turn out to be an expensive operation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Random`有大量用于不同需求的真/伪随机位生成器和分布。避免复制分布和生成器。这可能是一个昂贵的操作。'
- en: C++11 has support for different distribution classes and generators. You may
    find all the classes from this example in the `<random>` header in the `std::`
    namespace. The `Boost.Random` libraries do not use C++11 features, and they are
    not really required for that library either. Should you use Boost implementation
    or standard library? Boost provides better portability across systems. However,
    some standard libraries may have assembly-optimized implementations and may provide
    some useful extensions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C++11支持不同的分布类和生成器。您可以在`std::`命名空间的`<random>`头文件中找到这个示例中的所有类。`Boost.Random`库不使用C++11特性，而且该库也不真正需要。您应该使用Boost实现还是标准库？Boost在各个系统之间提供更好的可移植性。但是，一些标准库可能具有汇编优化的实现，并且可能提供一些有用的扩展。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The official documentation contains a full list of generators and distributions
    with descriptions. It is available at the following link: [http://boost.org/libs/random.](http://boost.org/libs/random)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档包含了一份带有描述的生成器和分布的完整列表。它可以在以下链接找到：[http://boost.org/libs/random.](http://boost.org/libs/random)
- en: Using portable math functions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可移植数学函数
- en: Some projects require specific trigonometric functions, a library for numerically
    solving ordinary differential equations and working with distributions and constants.
    All those parts of `Boost.Math` will be hard to fit even in a separate book. A
    single recipe definitely won't be enough. So, let's focus on very basic everyday-use
    functions to work with float types.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目需要特定的三角函数、用于数值求解常微分方程和处理分布和常数的库。`Boost.Math`的所有这些部分甚至在一本单独的书中都很难涵盖。单一的示例肯定是不够的。因此，让我们专注于与浮点类型一起使用的非常基本的日常函数。
- en: We'll write a portable function that checks input value for infinity and **Not**-**a**-**Number**
    (**NaN**) values and changes the sign if the value is negative.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个可移植的函数，用于检查输入值是否为无穷大和**非数值**（**NaN**）值，并在值为负时更改符号。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe. Those who know C99 standard
    will find a lot common in this recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要基本的C++知识。熟悉C99标准的人会在这个示例中找到很多共同之处。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to check the input value for infinity and NaN values
    and change the sign if the value is negative:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来检查输入值是否为无穷大和NaN值，并在值为负时更改符号：
- en: 'We need the following headers:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Asserting for infinity and NaN can be done like this:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对无穷大和NaN进行断言可以这样做：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the following code to change the sign:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更改符号：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it! Now, we may check that `check_float_inputs(std::sqrt(-1.0))` and
    `check_float_inputs(std::numeric_limits<double>::max() * 2.0)` will trigger asserts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们可以检查`check_float_inputs(std::sqrt(-1.0))`和`check_float_inputs(std::numeric_limits<double>::max()
    * 2.0)`是否会触发断言。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Real types have specific values that cannot be checked using equality operators.
    For example, if the variable `v` contains NaN, `assert(v != v)` may or may not
    pass depending on the compiler.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实数类型具有特定的值，不能使用相等运算符进行检查。例如，如果变量`v`包含NaN，则`assert(v != v)`可能会通过也可能不会，这取决于编译器。
- en: For such cases, `Boost.Math` provides functions that may reliably check for
    infinity and NaN values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，`Boost.Math`提供了可靠检查无穷大和NaN值的函数。
- en: '*Step 3* contains the `boost::math::signbit` function, which requires clarification.
    This function returns a signed bit, which is `1` when the number is negative and
    `0` when the number is positive. In other words, it returns `true` if the value
    is negative.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*包含`boost::math::signbit`函数，需要澄清。该函数返回一个带符号的位，当数字为负时为`1`，当数字为正时为`0`。换句话说，如果值为负，则返回`true`。'
- en: Looking at *step 3,* some readers may ask, why can't we just multiply by `-1`
    instead of calling `boost::math::changesign`? We can. But, multiplication may
    work slower than `boost::math::changesign` and is not guaranteed at work for special
    values. For example, if your code can work with `nan`, the code in *step 3* is
    able to change the sign of `-nan` and write `nan` to the variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*步骤3*，一些读者可能会问，为什么我们不能只乘以`-1`而不是调用`boost::math::changesign`？我们可以。但是，乘法可能比`boost::math::changesign`慢，并且不能保证对特殊值起作用。例如，如果你的代码可以处理`nan`，*步骤3*中的代码可以改变`-nan`的符号，并将`nan`写入变量。
- en: The `Boost.Math` library maintainers recommend wrapping math functions from
    this example in round parentheses to avoid collisions with C macro. It is better
    to write `(boost::math::isinf)(value)` instead of `boost::math::isinf(value)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Math`库的维护者建议将此示例中的数学函数用圆括号括起来，以避免与C宏发生冲突。最好写成`(boost::math::isinf)(value)`，而不是`boost::math::isinf(value)`。'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C99 contains all the functions described in this recipe. Why do we need them
    in Boost? Well, some compiler vendors think that programmers do not need the full
    support of C99, so you won't find those functions in at least one very popular
    compiler. Another reason is that the `Boost.Math` functions may be used for classes
    that behave like numbers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C99包含了这个配方中描述的所有函数。为什么我们需要它们在Boost中？嗯，一些编译器供应商认为程序员不需要完全支持C99，所以你在至少一个非常流行的编译器中找不到这些函数。另一个原因是`Boost.Math`函数可能被用于行为类似数字的类。
- en: '`Boost.Math` is a very fast, portable, and reliable library. **Mathematical
    special functions** are part of the `Boost.Math` library and some mathematical
    special functions were accepted into C++17\. A `Boost.Math`, however, provides
    more of them and has highly usable recurrent versions that have better complexities
    and better suit some of the tasks (like numerical integrations).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Math`是一个非常快速、便携和可靠的库。**数学特殊函数**是`Boost.Math`库的一部分，一些数学特殊函数已经被接受到C++17中。然而，`Boost.Math`提供了更多的数学特殊函数，并且具有高度可用的递归版本，具有更好的复杂度，更适合一些任务（如数值积分）。'
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation contains lots of interesting examples and tutorials
    that will help you get used to `Boost.Math`. Browse to [http://boost.org/libs/math](http://boost.org/libs/math)
    to read about it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Boost的官方文档包含许多有趣的示例和教程，这些将帮助你熟悉`Boost.Math`。浏览[http://boost.org/libs/math](http://boost.org/libs/math)了解更多信息。
- en: Writing test cases
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'This recipe and the next one are devoted to auto-testing using the `Boost.Test`
    library, which is used by many Boost libraries. Let''s get hands-on with it and
    write some tests for our own class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方和下一个配方都致力于使用`Boost.Test`库进行自动测试，这个库被许多Boost库使用。让我们动手写一些针对我们自己类的测试：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe. To compile code of this
    recipe, define `BOOST_TEST_DYN_LINK` macro and link against the `boost_unit_test_framework`
    and `boost_system` libraries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++知识。要编译这个配方的代码，需要定义`BOOST_TEST_DYN_LINK`宏，并链接`boost_unit_test_framework`和`boost_system`库。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To be honest, there is more than one test library in Boost. We'll take a look
    at the most functional one.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，在Boost中有不止一个测试库。我们将看看最功能强大的一个。
- en: 'To use it, we need to define the macro and include the following header:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用它，我们需要定义宏并包含以下头文件：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each set of tests must be written in the test case:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每组测试必须写在测试用例中：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Checking some function for the `true` result must be done as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查某些函数的`true`结果必须按照以下方式进行：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Checking for nonequality must be implemented in the following way:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查不相等必须以以下方式实现：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Checking for an exception being thrown must look like this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否抛出异常必须像这样：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's it! After compilation and linking, we'll have a binary that automatically
    tests `foo` and outputs test results in a human-readable format.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！编译和链接后，我们将得到一个二进制文件，它会自动测试`foo`并以人类可读的格式输出测试结果。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Writing unit tests is easy. You know how the function works and what result
    it will produce in specific situations. Therefore, you just check if the expected
    result is the same as the function's actual output. That's what we did in *step
    3*. We know that `f1.is_not_null()` returns `true` and we checked it. At *step
    4*, we do know that `f1` is not equal to `f2`, so we checked it too. The call
    to `f1.throws()` produces the `std::logic_error` exception and we check that an
    exception of the expected type is thrown.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试很容易。你知道函数的工作原理以及在特定情况下它会产生什么结果。因此，你只需检查预期结果是否与函数的实际输出相同。这就是我们在*步骤3*中所做的。我们知道`f1.is_not_null()`返回`true`，我们进行了检查。在*步骤4*中，我们知道`f1`不等于`f2`，所以我们也进行了检查。调用`f1.throws()`会产生`std::logic_error`异常，我们检查是否抛出了预期类型的异常。
- en: 'At *step 2*, we are making a test case--a set of checks to validate correct
    behavior of the `foo` structure. We may have multiple test cases in a single source
    file. For example, if we add the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们正在创建一个测试用例--一组检查，以验证`foo`结构的正确行为。我们可以在单个源文件中有多个测试用例。例如，如果我们添加以下代码：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code will run along with the `test_no_1` test case.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将与`test_no_1`测试用例一起运行。
- en: The parameter passed to the `BOOST_AUTO_TEST_CASE` macro is just a unique name
    of the test case that is shown in case of error.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`BOOST_AUTO_TEST_CASE`宏的参数只是测试用例的唯一名称，在出现错误时显示。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is a small difference between the `BOOST_REQUIRE_*` and `BOOST_CHECK_*`
    macros. If the `BOOST_REQUIRE_*` macro check fails, the execution of the current
    test case stops and `Boost.Test` runs the next test case. However, failing `BOOST_CHECK_*`
    does not stop the execution of the current test case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_REQUIRE_*`和`BOOST_CHECK_*`宏之间有一个小差异。如果`BOOST_REQUIRE_*`宏检查失败，当前测试用例的执行将停止，`Boost.Test`将运行下一个测试用例。然而，失败的`BOOST_CHECK_*`不会停止当前测试用例的执行。'
- en: '*Step 1* requires additional care. Note the `BOOST_TEST_MODULE` macro definition.
    This macro must be defined before including the `Boost.Test` headers; otherwise,
    linking the program will fail. More information can be found in the *See also*
    section of this recipe.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*需要额外的注意。请注意`BOOST_TEST_MODULE`宏的定义。这个宏必须在包含`Boost.Test`头文件之前定义；否则，链接程序将失败。更多信息可以在这个配方的*另请参阅*部分找到。'
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some readers may wonder, why did we write `BOOST_CHECK_NE(f1, f2)` in *step
    4* instead of `BOOST_CHECK(f1 != f2)`? The answer is simple: the macro at *step
    4* provides a more readable and verbose output on older versions of `Boost.Test`
    library.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想，为什么在*步骤4*中我们写了`BOOST_CHECK_NE(f1, f2)`而不是`BOOST_CHECK(f1 != f2)`？答案很简单：*步骤4*中的宏在旧版本的`Boost.Test`库上提供了更易读和冗长的输出。
- en: C++17 lacks support for unit testing. However, the `Boost.Test` library can
    be used to test C++17 and pre-C++11 code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: C++17缺乏对单元测试的支持。然而，`Boost.Test`库可以用来测试C++17和C++11之前的代码。
- en: Remember that the more tests you have, the more reliable code you get!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你拥有的测试越多，你得到的可靠代码就越多！
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Combining multiple test cases in one test module* recipe contains more
    information about testing and the `BOOST_TEST_MODULE` macro.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将多个测试用例组合在一个测试模块中*配方包含了更多关于测试和`BOOST_TEST_MODULE`宏的信息。'
- en: Refer to Boost's official documentation at [http://boost.org/libs/test](http://boost.org/libs/test)
    for a full list of test macros and information about advanced features of `Boost.Test`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Boost官方文档 [http://boost.org/libs/test](http://boost.org/libs/test) 以获取关于`Boost.Test`的所有测试宏和高级功能的信息
- en: Combining multiple test cases in one test module
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个测试用例组合在一个测试模块中
- en: Writing auto tests is good for your project. However, managing test cases is
    hard when the project is big and many developers work on it. In this recipe, we'll
    take a look at how to run individual tests and how to combine multiple test cases
    in a single module.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自动测试对你的项目很有好处。然而，当项目很大并且有许多开发人员在上面工作时，管理测试用例是很困难的。在这个配方中，我们将看看如何运行单独的测试以及如何将多个测试用例组合在一个单一模块中。
- en: Let's pretend that two developers are testing the `foo` structure declared in
    the `foo.hpp` header and we wish to give them separate source files to write tests
    to. In that case, both developers won't bother each other and may work in parallel.
    However, the default test run must execute tests of both developers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个开发人员正在测试`foo.hpp`头文件中声明的`foo`结构，我们希望给他们单独的源文件来编写测试。在这种情况下，两个开发人员不会互相打扰，并且可以并行工作。然而，默认的测试运行必须执行两个开发人员的测试。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Basic knowledge of C++ is required for this recipe. This recipe partially reuses
    code from the previous recipe and it also requires the `BOOST_TEST_DYN_LINK` macro
    defined and linkage against the `boost_unit_test_framework` and `boost_system`
    libraries.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++知识。这个配方部分地重用了上一个配方中的代码，还需要定义`BOOST_TEST_DYN_LINK`宏，并链接`boost_unit_test_framework`和`boost_system`库。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: This recipe uses the code from the previous one. This is a very useful recipe
    for testing big projects. Do not underestimate it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了上一个配方中的代码。这是一个非常有用的测试大型项目的配方。不要低估它。
- en: 'Of all the headers in `main.cpp` from the previous recipe, leave only these
    two lines:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个配方的`main.cpp`头文件中，只留下这两行：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s move the test cases from the previous example into two different source
    files:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将上一个示例中的测试用例移动到两个不同的源文件中：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's it! Thus compiling and linking all the sources and both test cases will
    work on program execution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！因此，在程序执行时，编译和链接所有源代码和两个测试用例都将正常工作。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the magic is done by the `BOOST_TEST_MODULE` macro. If it is defined before
    `<boost/test/unit_test.hpp>`, `Boost.Test` thinks that this source file is the
    main one and all the helper testing infrastructure must be placed in it. Otherwise,
    only the test macro is be included from `<boost/test/unit_test.hpp>`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的魔法都是由`BOOST_TEST_MODULE`宏完成的。如果在`<boost/test/unit_test.hpp>`之前定义了它，`Boost.Test`会认为这个源文件是主文件，所有的辅助测试基础设施都必须放在其中。否则，只有测试宏会被包含在`<boost/test/unit_test.hpp>`中。
- en: All the `BOOST_AUTO_TEST_CASE` tests will run if you link them with the source
    file that contains the `BOOST_TEST_MODULE` macro. When working on a big project,
    each developer may enable compilation and linking only of their own sources. That
    gives independence from other developers and increases the speed of development
    - no need to compile alien sources and run alien tests while debugging.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将它们与包含`BOOST_TEST_MODULE`宏的源文件链接，所有的`BOOST_AUTO_TEST_CASE`测试都将运行。在处理大型项目时，每个开发人员可以启用仅编译和链接他们自己的源文件。这样可以独立于其他开发人员，并增加开发速度-在调试时不需要编译外部源文件和运行外部测试。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Test` library is good because of its ability to run tests selectively.
    We may choose what tests to run and pass them as command-line arguments. For example,
    the following command runs only the `test_no_1` test case:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Test`库很好，因为它能够有选择地运行测试。我们可以选择要运行的测试，并将它们作为命令行参数传递。例如，以下命令只运行`test_no_1`测试用例：'
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following command runs two test cases:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令运行两个测试用例：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately, C++17 standard does not have built-in testing support and it
    looks like C++20 also won't adopt the classes and methods of `Boost.Test`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，C++17标准不支持内置的测试支持，而且看起来C++20也不会采用`Boost.Test`的类和方法。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Writing test cases* recipe contains more information about the `Boost.Test`
    library. Read Boost's official documentation at [http://boost.org/libs/test](http://boost.org/libs/test)
    for more information about `Boost.Test`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写测试用例*配方包含了更多关于`Boost.Test`库的信息。阅读Boost官方文档 [http://boost.org/libs/test](http://boost.org/libs/test)
    以获取更多关于`Boost.Test`的信息。'
- en: Brave ones may try to take a look at some of the test cases from the Boost library.
    Those test cases are allocated in the `libs` sub-folder located in the `boost`
    folder. For example, `Boost.LexicalCast` tests cases are allocated at `boost_1_XX_0/libs/lexical_cast/test`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勇敢的人可以尝试查看Boost库中的一些测试用例。这些测试用例位于`boost`文件夹中的`libs`子文件夹中。例如，`Boost.LexicalCast`的测试用例位于`boost_1_XX_0/libs/lexical_cast/test`。
- en: Manipulating images
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作图像
- en: I've left you something really tasty for dessert - Boost's Generic Image Library
    or just `Boost.GIL`, which allows you to manipulate images without worrying too
    much about image formats.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为你留下了一些非常美味的甜点 - Boost的通用图像库或者`Boost.GIL`，它允许你在不太担心图像格式的情况下操作图像。
- en: Let's do something simple and interesting with it. For example, let's make a
    program that negates any picture.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些简单有趣的事情。例如，让我们制作一个对任何图片进行否定的程序。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires basic knowledge of C++, templates, and `Boost.Variant`.
    The example requires linking against the `png` library.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++、模板和`Boost.Variant`的知识。示例需要链接`png`库。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: For simplicity of the example, we'll be working only with PNG images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，我们将只使用PNG图像。
- en: 'Let''s start by including the header files:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含头文件开始：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we need to define the image types that we wish to work with:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们希望使用的图像类型：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Opening an existing PNG image can be implemented like this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开现有的PNG图像可以这样实现：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to apply the operation to the picture as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要按照以下方式对图片进行操作：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code line will help you to write an image:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行将帮助你编写一张图片：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s take a look at the modifying operation:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看修改操作：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The body of `operator()` consists of getting a channel type:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`operator()`的主体包括获取通道类型：'
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It also iterates through pixels:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还遍历像素：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s see the results of our program:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们程序的结果：
- en: '![](img/00022.gif)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.gif)'
- en: 'The previous picture is the negative of the one that follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片是接下来的图片的负片：
- en: '![](img/00023.gif)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.gif)'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: At *step 2*, we are describing the types of images we wish to work with. These
    images are gray images with 8 and 16 bits per pixel and RGB pictures with 8 bits
    per pixel.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们描述了我们希望使用的图像类型。这些图像是每像素8位和16位的灰度图像，以及每像素8位的RGB图片。
- en: The `boost::gil::any_image<img_types>` class is a kind of `Boost.Variant` that
    may hold an image of one of the `img_types` variables. As you may have already
    guessed, `boost::gil::png_read_image` reads images into image variables.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::gil::any_image<img_types>`类是一种可以容纳`img_types`变量之一的图像的`Boost.Variant`。正如你可能已经猜到的那样，`boost::gil::png_read_image`将图像读入图像变量中。'
- en: The `boost::gil::apply_operation` function at *step 4* is almost equal to `boost::apply_visitor`
    from the `Boost.Variant` library. Note the usage of `view(source)`. The `boost::gil::view`
    function constructs a light wrapper around the image that interprets it as a two-dimensional
    array of pixels.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*中的`boost::gil::apply_operation`函数几乎等同于`Boost.Variant`库中的`boost::apply_visitor`。注意`view(source)`的用法。`boost::gil::view`函数构造了一个轻量级的包装器，将图像解释为像素的二维数组。'
- en: Do you remember that for `Boost.Variant` we were deriving visitors from `boost::static_visitor`?
    When we are using GIL's version of variant, we need to make a `result_type` typedef
    inside `visitor`. You can see it in *step 6*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得对于`Boost.Variant`，我们是从`boost::static_visitor`派生访问者的吗？当我们使用GIL的变体版本时，我们需要在`visitor`内部进行`result_type`的typedef。你可以在*步骤6*中看到它。
- en: 'A little bit of theory: images consist of points called **pixels**. One image
    has pixels of the same type. However, pixels of different images may differ in
    channels count and color bits for a single channel. A channel represents a primary
    color. In the case of an RGB image, we have a pixel consisting of three channels
    - red, green, and blue. In the case of a gray image, we have a single channel
    representing gray.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一点理论知识：图像由称为**像素**的点组成。一个图像有相同类型的像素。然而，不同图像的像素可能在通道计数和单个通道的颜色位方面有所不同。通道代表主要颜色。在RGB图像的情况下，我们有一个由三个通道
    - 红色、绿色和蓝色组成的像素。在灰度图像的情况下，我们有一个表示灰度的单个通道。
- en: Back to our image. At *step 2*, we described the types of images we wish to
    work with. At *step 3*, one of those image types is read from file and stored
    in the source variable. At *step 4*, the `operator()` method of the `negate` visitor
    is instantiated for all image types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的图片。在*步骤2*中，我们描述了我们希望使用的图像类型。在*步骤3*中，其中一种图像类型从文件中读取并存储在源变量中。在*步骤4*中，为所有图像类型实例化了`negate`访问者的`operator()`方法。
- en: At *step 7*, we can see how to get the channel type from the image view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们可以看到如何从图像视图中获取通道类型。
- en: At *step 8*, we iterate through pixels and channels and negate them. Negation
    is done via `max_val - source(x, y)[c]` and the result is written back to the
    image view.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8*中，我们遍历像素和通道并对其进行否定。否定是通过`max_val - source(x, y)[c]`来完成的，并将结果写回图像视图。
- en: We write an image back at *step 5*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤5*中将图像写回。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++17 has no built-in methods to work with images. There is ongoing work to
    add 2D drawing to the C++ standard library, though it's a kind of orthogonal functionality.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有内置的方法来处理图像。目前正在进行工作，将2D绘图添加到C++标准库中，尽管这是一种有点正交的功能。
- en: The `Boost.GIL` library is fast and efficient. The compilers optimize its code
    well and we may even help the optimizer using some of the `Boost.GIL` methods
    to unroll loops. But this chapter talks about only some of the library basics,
    so it is time to stop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.GIL`库快速高效。编译器对其代码进行了良好的优化，我们甚至可以使用一些`Boost.GIL`方法来帮助优化器展开循环。但本章仅讨论了库的一些基础知识，所以是时候停下来了。'
- en: See also
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about `Boost.GIL` can be found at Boost's official documentation
    at [http://boost.org/libs/gil](http://boost.org/libs/gil)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.GIL`的更多信息可以在Boost的官方文档[http://boost.org/libs/gil](http://boost.org/libs/gil)中找到
- en: See the *Storing multiple chosen types in a variable/container* recipe in [Chapter
    1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting to Write Your
    Application*, for more information about the `Boost.Variant` library
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)的*存储多种选择的类型在一个变量/容器中*配方中查看更多关于`Boost.Variant`库的信息
- en: See the [https://isocpp.org/](https://isocpp.org/) for more news on C++
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请查看[https://isocpp.org/](https://isocpp.org/)了解更多关于C++的新闻
- en: Take a look at [https://stdcpp.ru/](https://stdcpp.ru/) for discussion of C++
    proposals on Russian
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[https://stdcpp.ru/](https://stdcpp.ru/)讨论关于C++提案的俄语文章
