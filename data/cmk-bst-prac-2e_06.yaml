- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Packaging, Deploying, and Installing a CMake Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包、部署和安装 CMake 项目
- en: Properly packaging software is often overshadowed by the focus on writing and
    building it, yet it is often a significant factor in ensuring the success and
    longevity of any software project. Packaging serves as the bridge between the
    developer’s creation and the end user’s experience, encompassing everything from
    distribution to installation and maintenance. Well-packaged software not only
    streamlines the deployment process but also enhances user satisfaction, fosters
    reliability, and facilitates seamless updates and bug fixes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地打包软件往往被编写和构建软件的过程所掩盖，然而它通常是确保任何软件项目成功和持久性的一个重要因素。打包是开发者创作与最终用户体验之间的桥梁，涵盖了从分发到安装和维护的方方面面。打包得当的软件不仅简化了部署过程，还增强了用户满意度、可靠性，并且便于无缝更新和修复漏洞。
- en: Ensuring that software is packaged in a manner compatible with these diverse
    environments is paramount to its usability and accessibility. Moreover, users
    span a wide spectrum of technical proficiency, ranging from seasoned professionals
    to novices. Consequently, packaging must cater to this spectrum, offering intuitive
    installation processes for less experienced users while providing advanced options
    for the technically adept. Furthermore, adherence to installation standards is
    crucial not only for user convenience but also for maintaining system integrity.
    By following established packaging norms, developers mitigate the risk of cluttering
    target systems with unnecessary files or conflicting dependencies, thus promoting
    system stability and cleanliness. In essence, packaging software is the crucial
    final step that transforms raw code into a polished, accessible product, making
    it as vital as the development process itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 确保软件以与这些不同环境兼容的方式打包，对其可用性和可访问性至关重要。此外，用户的技术能力跨度广泛，从经验丰富的专业人士到新手不等。因此，打包必须迎合这一范围，为经验较少的用户提供直观的安装过程，同时为技术熟练的用户提供高级选项。此外，遵守安装标准对于用户的便利性和系统完整性都至关重要。通过遵循既定的打包规范，开发者可以减少在目标系统中堆积不必要的文件或冲突的依赖关系，从而促进系统的稳定性和整洁性。归根结底，软件打包是将原始代码转化为精致、可访问产品的关键最后一步，和开发过程本身一样至关重要。
- en: CMake has good internal support and tooling to make installing and packaging
    easy. The good side of this is that CMake leverages existing project code to do
    such things. Thus, making a project installable or packaging a project does not
    result in heavy maintenance costs. In this chapter, we’re going to learn how to
    leverage CMake’s existing abilities regarding installing and packaging for deployments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 内部有良好的支持和工具，使得安装和打包变得简单。这一点的好处在于，CMake 利用现有的项目代码来实现这些功能。因此，使项目可安装或打包项目不会带来沉重的维护成本。本章中，我们将学习如何利用
    CMake 在安装和打包方面的现有能力，来支持部署工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Making CMake targets installable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 CMake 目标可安装
- en: Supplying configuration information for others using your project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的项目为他人提供配置信息
- en: Creating an installable package with CPack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CPack 创建可安装包
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you dive into this chapter, you should have a good grasp of targets in
    CMake (covered briefly in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*, and [*Chapter 3*](B30947_03.xhtml#_idTextAnchor054), *Creating a* *CMake*
    *Project*, in detail). This chapter will build on top of that knowledge.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本章之前，你应该对 CMake 中的目标有一个良好的理解（在[*第1章*](B30947_01.xhtml#_idTextAnchor015)《启动
    CMake》和[*第3章*](B30947_03.xhtml#_idTextAnchor054)《创建 CMake 项目》中简要介绍，详细内容见其中）。本章将基于这些知识进行扩展。
- en: Please obtain this chapter’s examples from this book’s GitHub repository at
    [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    This chapter’s exemple content is available in the `chapter04/` subfolder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请从本书的 GitHub 仓库获取本章的示例，地址为 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)。本章的示例内容位于
    `chapter04/` 子文件夹中。
- en: Making CMake targets installable
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 CMake 目标可安装
- en: In the context of CMake, there is a difference between the terms *installing*
    and *packaging* software. Installing software involves copying executable files,
    libraries, and other necessary resources to a predefined location. Packaging,
    on the other hand, involves bundling all necessary files and dependencies into
    a distributable format (such as a tarball, ZIP archive, or installer package)
    for easy distribution and installation on other systems. CMake’s packaging mechanism
    works by first installing a project in a temporary location and then packaging
    the installed files into a suitable format.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 的上下文中，*安装*和*打包*软件是两个不同的概念。安装软件涉及将可执行文件、库和其他必要资源复制到预定的位置。而打包则是将所有必要的文件和依赖项捆绑成一个可分发格式（例如
    tarball、ZIP 压缩包或安装程序包），以便于在其他系统上进行分发和安装。CMake 的打包机制是先将项目安装到临时位置，然后将安装的文件打包成适当的格式。
- en: The most primitive way of supporting deployment in a project is by making it
    *installable*. On the contrary, the end user still must acquire the project’s
    source code and build it from scratch. An installable project has extra build
    system code for installing the runtime or development artifacts on the system.
    The build system will perform the install action here, given that it has proper
    instructions on how to do so. Since we’re using CMake to generate the build system
    files, CMake must generate the relevant install code. In this section, we will
    dive into the basics of how to instruct CMake to generate such code for the CMake
    targets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 支持项目部署的最原始方式是将其设置为*可安装*。相反，最终用户仍然必须获取项目的源代码并从头开始构建它。一个可安装的项目会有额外的构建系统代码，用于在系统上安装运行时或开发工件。如果有适当的安装指令，构建系统将在这里执行安装操作。由于我们使用
    CMake 生成构建系统文件，因此 CMake 必须生成相关的安装代码。在这一节中，我们将深入探讨如何指导 CMake 为 CMake 目标生成此类代码的基础知识。
- en: The install() command
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`install()`命令'
- en: The `install(...)` command is a built-in CMake command that allows you to generate
    build system instructions for installing targets, files, directories, and more.
    CMake will not generate install instructions unless it is explicitly told to do
    so. Therefore, what gets installed is always under your control. Let’s inspect
    its basic usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(...)`命令是一个内置的 CMake 命令，允许您生成安装目标、文件、目录等的构建系统指令。CMake 不会生成安装指令，除非明确告诉它这么做。因此，什么内容被安装始终在您的控制之下。让我们来看一下它的基本用法。'
- en: Installing CMake targets
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 CMake 目标
- en: 'To make a CMake target installable, the `TARGETS` parameter must be specified
    with at least one argument. The command signature for this usage is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 CMake 目标可安装，必须指定`TARGETS`参数，并提供至少一个参数。该用法的命令签名如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `TARGETS` parameter denotes that `install` will accept a set of CMake targets
    to generate the installation code for. In this form, only the output artifacts
    of the target will be installed. The most common output artifacts for a target
    are defined as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGETS`参数表示`install`将接受一组 CMake 目标，生成安装代码。在这种形式下，只有目标的输出工件会被安装。目标的最常见输出工件定义如下：'
- en: '`ARCHIVE` (static libraries, DLL import libraries, and linker import files):'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARCHIVE`（静态库、DLL 导入库和链接器导入文件）：'
- en: Except for targets marked as `FRAMEWORK` in macOS
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在 macOS 中标记为`FRAMEWORK`的目标
- en: '`LIBRARY` (shared libraries):'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIBRARY`（共享库）：'
- en: Except for targets marked as `FRAMEWORK` in macOS
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在 macOS 中标记为`FRAMEWORK`的目标
- en: Except for DLLs (in Windows)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 DLL（在 Windows 中）
- en: '`RUNTIME` (executables and DLLs):'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNTIME`（可执行文件和 DLL）：'
- en: Except for targets marked as `MACOSX_BUNDLE` in macOS
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在 macOS 中标记为`MACOSX_BUNDLE`的目标
- en: 'After making a target installable, CMake will generate the necessary installation
    code to install the output artifacts that will be produced for the target. To
    illustrate this, let’s make a basic executable target installable together. To
    see the `install(...)` command in action, let’s inspect the `CMakeLists.txt` file
    of `Chapter 4`, `example 1`, which can be found in the `chapter04/ex01_executable`
    folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在将目标设置为可安装后，CMake 会生成必要的安装代码，以便安装为该目标生成的输出工件。为了说明这一点，让我们一起将一个基本的可执行目标设置为可安装。要查看`install(...)`命令的实际操作，我们可以查看位于`chapter04/ex01_executable`文件夹中的`Chapter
    4`，`example 1`的`CMakeLists.txt`文件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, an executable target called `ch4_ex01_executable` is
    being defined and its properties are being populated in the subsequent two lines.
    The last line, `install(...)`, is the line we’re interested in. It tells CMake
    to create the required install code for `ch4_ex01_executable`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，定义了一个名为`ch4_ex01_executable`的可执行目标，并在接下来的两行中填充了它的属性。最后一行`install(...)`是我们感兴趣的部分，它告诉CMake为`ch4_ex01_executable`创建所需的安装代码。
- en: 'To check whether `ch4_ex01_executable` can be installed, let’s build the project
    and install it via the CLI from within the root folder of `chapter 4`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查`ch4_ex01_executable`是否可以被安装，让我们在`chapter 4`的根文件夹中通过CLI构建并安装该项目：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of having to specify the `--prefix` parameter for `cmake --install`,
    you can also use the `CMAKE_INSTALL_PREFIX` variable to provide the non-default
    `install` prefix.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为`cmake --install`指定`--prefix`参数，你也可以使用`CMAKE_INSTALL_PREFIX`变量来提供非默认的`install`前缀。
- en: 'Please specify the `--config` argument for the `cmake --build` and `cmake --install`
    commands while using CMake with multi-config generators, such as Ninja multi-config
    and Visual Studio:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CMake与多配置生成器（如Ninja多配置和Visual Studio）时，请为`cmake --build`和`cmake --install`命令指定`--config`参数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s inspect what the `cmake --install` command did:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下`cmake --install`命令的作用：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the last line of the preceding output, we can see the *output artifact* of
    the `ch4_ex01_executable` target – that is, the `ch4_ex01_executable` binary is
    installed. Since that was the only output artifact that the `ch4_ex01_executable`
    target had, we can conclude that our target has indeed become installable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面输出的最后一行中，我们可以看到`ch4_ex01_executable`目标的*输出工件*——也就是说，`ch4_ex01_executable`二进制文件已经被安装。由于这是`ch4_ex01_executable`目标的唯一输出工件，我们可以得出结论，目标确实已经变得可以安装了。
- en: 'Notice that `ch4_ex01_executable` is not directly installed in the `/tmp/install-test`
    (prefix) directory. Instead, the `install` command puts it in the `bin/` subdirectory.
    This is because CMake is smart about what kind of artifact should go where. In
    a traditional UNIX system, binaries go into `/usr/bin`, while libraries go into
    `/usr/lib`. CMake knows that the `add_executable()` command produces an executable
    binary artifact and puts it into the `/bin` subdirectory. These directories are
    provided by CMake by default, depending on the target type. The CMake module that
    provides the default installation path information is known as the `GNUInstallDirs`
    module. The `GNUInstallDirs` module defines various `CMAKE_INSTALL_` paths when
    included. The following table shows the default installation directories for the
    targets:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ch4_ex01_executable`并没有直接安装到`/tmp/install-test`（前缀）目录中。相反，`install`命令将它放入了`bin/`子目录。这是因为CMake智能地判断了应该将什么类型的工件放到哪里。在传统的UNIX系统中，二进制文件通常放在`/usr/bin`，而库文件放在`/usr/lib`。CMake知道`add_executable()`命令会生成一个可执行的二进制工件，并将其放入`/bin`子目录。这些目录是CMake默认提供的，具体取决于目标类型。提供默认安装路径信息的CMake模块被称为`GNUInstallDirs`模块。`GNUInstallDirs`模块在被包含时定义了各种`CMAKE_INSTALL_`路径。下表显示了各个目标的默认安装目录：
- en: '| **Target Type** | **GNUInstallDirs Variable** | **Built-In Default** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **目标类型** | **GNUInstallDirs 变量** | **内置默认值** |'
- en: '| RUNTIME | ${CMAKE_INSTALL_BINDIR} | bin |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| RUNTIME | ${CMAKE_INSTALL_BINDIR} | bin |'
- en: '| LIBRARY | ${CMAKE_INSTALL_LIBDIR} | lib |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| LIBRARY | ${CMAKE_INSTALL_LIBDIR} | lib |'
- en: '| ARCHIVE | ${CMAKE_INSTALL_LIBDIR} | lib |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ARCHIVE | ${CMAKE_INSTALL_LIBDIR} | lib |'
- en: '| PRIVATE_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| PRIVATE_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
- en: '| PUBLIC_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| PUBLIC_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
- en: 'To override the built-in defaults, an additional `<TARGET_TYPE> DESTINATION`
    parameter is required in the `install(...)` command. To illustrate this, let’s
    try to change the default `RUNTIME` install directory to `qbin` instead of `bin`.
    Doing so only requires that we make a small modification to our original `install(...)`
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖内置的默认值，`install(...)`命令中需要一个额外的`<TARGET_TYPE> DESTINATION`参数。为了说明这一点，假设我们要将默认的`RUNTIME`安装目录更改为`qbin`，而不是`bin`。这样做只需要对原始的`install(...)`命令做一个小的修改：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After making this change, we can rerun the `configure`, `build`, and `install`
    commands. We can confirm that the `RUNTIME` destination has changed by inspecting
    the `cmake --install` command’s output. Different from the first time, we can
    observe that the `ch4_ex01_executable` binary is put into `qbin` instead of the
    default (`bin`) directory:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 做出此更改后，我们可以重新运行 `configure`、`build` 和 `install` 命令。我们可以通过检查 `cmake --install`
    命令的输出确认 `RUNTIME` 目标已经更改。与第一次不同，我们可以观察到 `ch4_ex01_executable` 二进制文件被放入 `qbin`
    而不是默认的 (`bin`) 目录：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s look at another example. We will be installing a `STATIC` library
    this time. Let’s look in the `CMakeLists.txt` file of [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Example 2*, which can be found in the `chapter04/ex02_static` folder. Comments
    and the `project(...)` command have been omitted due to space reasons. Let’s start
    inspecting the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看另一个示例。这次我们将安装一个 `STATIC` 库。让我们看看 [*第 4 章*](B30947_04.xhtml#_idTextAnchor071)
    中的 `CMakeLists.txt` 文件，*示例 2*，它位于 `chapter04/ex02_static` 文件夹中。由于篇幅原因，注释和 `project(...)`
    命令已被省略。让我们开始检查文件：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may have noticed, it is a little bit different from our previous example.
    First, there is an additional `install(...)` command with the `DIRECTORY` argument.
    This is required to make the header files of the static library installable. The
    reason for this is that CMake will not install any file that is not an *output
    artifact* and the `STATIC` library target only produces a binary file as an *output
    artifact*. Header files are not considered *output artifacts* and should be installed
    separately.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它与我们之前的示例稍有不同。首先，新增了一个带有 `DIRECTORY` 参数的 `install(...)` 命令。这是为了使静态库的头文件可以被安装。原因是
    CMake 不会安装任何不是 *输出产物* 的文件，而 `STATIC` 库目标只会生成一个二进制文件作为 *输出产物*。头文件不是 *输出产物*，应单独安装。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The trailing slash in the `DIRECTORY` argument causes CMake to copy the folder’s
    content instead of copying the folder by name. CMake handles trailing slashes
    in the same fashion as the Linux `rsync` command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIRECTORY` 参数中的尾随斜杠会导致 CMake 复制文件夹内容，而不是按名称复制文件夹。CMake 处理尾随斜杠的方式与 Linux 的
    `rsync` 命令相同。'
- en: Installing files and directories
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装文件和目录
- en: As we saw in the previous section, the things we mean to install are not always
    part of a target’s *output artifacts*. They may be runtime dependencies of the
    target, such as images, assets, resource files, scripts, and configuration files.
    CMake provides the `install(FILES...)` and `install(DIRECTORY...)` commands for
    installing any specific files or directories. Let’s begin with installing files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前一节中看到的，我们打算安装的内容并不总是目标的 *输出产物*。它们可能是目标的运行时依赖项，例如图像、资源、配置文件、脚本和资源文件。CMake
    提供了 `install(FILES...)` 和 `install(DIRECTORY...)` 命令，用于安装任何特定的文件或目录。让我们从安装文件开始。
- en: Installing files
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装文件
- en: 'The `install(FILES...)` command accepts one or more files as an argument. It
    requires an additional `TYPE` or `DESTINATION` parameter as well. Both parameters
    are used for determining the destination directory of the specified files. The
    `TYPE` parameter is used to indicate which files will use the default path for
    that file type as an installation directory. Defaults can be overridden by setting
    the relevant `GNUInstallDirs` variable. The following table shows the valid `TYPE`
    values, along with their directory mappings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(FILES...)` 命令接受一个或多个文件作为参数。它还需要一个额外的 `TYPE` 或 `DESTINATION` 参数。这两个参数用于确定指定文件的目标目录。`TYPE`
    参数用于指示哪些文件将使用该文件类型的默认路径作为安装目录。通过设置相关的 `GNUInstallDirs` 变量可以覆盖默认值。以下表格显示了有效的 `TYPE`
    值及其目录映射：'
- en: '| **Type** | **GNUInstallDirs Variable** | **Built-In Default** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **GNUInstallDirs 变量** | **内置默认值** |'
- en: '| BIN | ${CMAKE_INSTALL_BINDIR} | bin |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| BIN | ${CMAKE_INSTALL_BINDIR} | bin |'
- en: '| SBIN | ${CMAKE_INSTALL_SBINDIR} | sbin |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| SBIN | ${CMAKE_INSTALL_SBINDIR} | sbin |'
- en: '| LIB | ${CMAKE_INSTALL_LIBDIR} | lib |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| LIB | ${CMAKE_INSTALL_LIBDIR} | lib |'
- en: '| INCLUDE | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| INCLUDE | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
- en: '| SYSCONF | ${CMAKE_INSTALL_SYSCONFDIR} | etc |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| SYSCONF | ${CMAKE_INSTALL_SYSCONFDIR} | etc |'
- en: '| SHAREDSTATE | ${CMAKE_INSTALL_SHARESTATEDIR} | com |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| SHAREDSTATE | ${CMAKE_INSTALL_SHARESTATEDIR} | com |'
- en: '| LOCALSTATE | ${CMAKE_INSTALL_LOCALSTATEDIR} | var |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| LOCALSTATE | ${CMAKE_INSTALL_LOCALSTATEDIR} | var |'
- en: '| RUNSTATE | ${CMAKE_INSTALL_RUNSTATEDIR} | <LOCALSTATE dir>/run |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| RUNSTATE | ${CMAKE_INSTALL_RUNSTATEDIR} | <LOCALSTATE dir>/run |'
- en: '| DATA | ${CMAKE_INSTALL_DATADIR} | <DATAROOT dir> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| DATA | ${CMAKE_INSTALL_DATADIR} | <DATAROOT dir> |'
- en: '| INFO | ${CMAKE_INSTALL_INFODIR} | <DATAROOT dir>/info |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| INFO | ${CMAKE_INSTALL_INFODIR} | <DATAROOT dir>/info |'
- en: '| LOCALE | ${CMAKE_INSTALL_LOCALEDIR} | <DATAROOT dir>/locale |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| LOCALE | ${CMAKE_INSTALL_LOCALEDIR} | <DATAROOT dir>/locale |'
- en: '| MAN | ${CMAKE_INSTALL_MANDIR} | <DATAROOT dir>/man |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| MAN | ${CMAKE_INSTALL_MANDIR} | <DATAROOT dir>/man |'
- en: '| DOC | ${CMAKE_INSTALL_DOCDIR} | <DATAROOT dir>/doc |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| DOC | ${CMAKE_INSTALL_DOCDIR} | <DATAROOT dir>/doc |'
- en: If you don’t wish to use the `TYPE` parameter, you can use the `DESTINATION`
    parameter instead. It lets you provide a custom destination for the specified
    files in the `install(...)` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用 `TYPE` 参数，可以改用 `DESTINATION` 参数。它允许你为 `install(...)` 命令中指定的文件提供自定义的目标位置。
- en: An alternative form of `install(FILES...)` is `install(PROGRAMS...)`, which
    is the same as `install(FILES...)` except it also sets `OWNER_EXECUTE`, `GROUP_EXECUTE`,
    and `WORLD_EXECUTE` permissions for installed files. This makes sense for binaries
    or script files that must be executed by the end user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(FILES...)` 的一种替代形式是 `install(PROGRAMS...)`，它与 `install(FILES...)`
    相同，区别在于它还为已安装的文件设置了 `OWNER_EXECUTE`、`GROUP_EXECUTE` 和 `WORLD_EXECUTE` 权限。对于必须由最终用户执行的二进制文件或脚本文件来说，这样做是有意义的。'
- en: 'To understand `install(FILES|PROGRAMS...)`, let’s look at an example. The example
    we’re going to look at is [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*, Example
    3* (`chapter04/ex03_file`). It essentially contains three files: `chapter04_greeter_content`,
    `chapter04_greeter.py`, and `CMakeLists.txt`. First, let’s look at its `CMakeLists.txt`
    file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `install(FILES|PROGRAMS...)`，让我们看一个例子。我们将要查看的例子是 [*第 4 章*](B30947_04.xhtml#_idTextAnchor071)*，示例
    3*（`chapter04/ex03_file`）。它实际上包含了三个文件：`chapter04_greeter_content`、`chapter04_greeter.py`
    和 `CMakeLists.txt`。首先，让我们看看它的 `CMakeLists.txt` 文件：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s digest what we have seen; in the first `install(...)` command, we’re telling
    CMake to install the `chapter04_greeter_content` file in the current `CMakeLists.txt`
    directory (`chapter04/ex03_file`) in the default `BIN` directory of the system.
    In the second `install(…)` command, we’re telling CMake to install `chapter04_greeter.py`
    in the default `BIN` directory with the name `chapter04_greeter`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们消化一下我们所看到的内容；在第一个 `install(...)` 命令中，我们告诉 CMake 将 `chapter04_greeter_content`
    文件安装到当前 `CMakeLists.txt` 目录（`chapter04/ex03_file`）的系统默认 `BIN` 目录中。在第二个 `install(...)`
    命令中，我们告诉 CMake 将 `chapter04_greeter.py` 文件安装到默认的 `BIN` 目录，并且文件名为 `chapter04_greeter`。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `RENAME` parameter is only valid for single-file `install(...)` calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`RENAME` 参数仅在单文件 `install(...)` 调用时有效。'
- en: 'With these `install(...)` instructions, CMake should install the `chapter04_greeter.py`
    and `chapter04_greeter_content` files in the `${CMAKE_INSTALL_PREFIX}/bin` directory.
    Let’s build and install the project via the CLI:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些 `install(...)` 指令，CMake 应该会将 `chapter04_greeter.py` 和 `chapter04_greeter_content`
    文件安装到 `${CMAKE_INSTALL_PREFIX}/bin` 目录。让我们通过 CLI 构建并安装项目：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s look at what the `cmake --install` command did:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `cmake --install` 命令做了什么：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding output confirms that CMake generated the required installation
    code for the `chapter04_greeter_content` and `chapter04_greeter.py` files. Lastly,
    let’s check whether the `chapter04_greeter` file can be executed since we used
    the `PROGRAMS` parameter to install it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出确认了 CMake 为 `chapter04_greeter_content` 和 `chapter04_greeter.py` 文件生成了所需的安装代码。最后，让我们检查一下
    `chapter04_greeter` 文件是否能够执行，因为我们使用了 `PROGRAMS` 参数来安装它：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, we have concluded the `install(FILES|PROGRAMS...)` section. Let’s
    continue with installing directories.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了 `install(FILES|PROGRAMS...)` 部分的内容。接下来，让我们继续安装目录。
- en: Installing directories
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装目录
- en: 'The `install(DIRECTORY...)` command is useful for installing directories. The
    directory’s structure will be copied as is to the destination. Directories can
    either be installed as a whole or selectively. Let’s begin with the most basic
    directory installation example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(DIRECTORY...)` 命令对于安装目录非常有用。目录的结构将会被原样复制到目标位置。目录可以作为整体安装，也可以选择性地安装。让我们先从最基本的目录安装示例开始：'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding example will install the `dir1` and `dir2` directories in the
    `${CMAKE_INSTALL_PREFIX}/var` directory, along with all of their subfolders and
    files as is. Sometimes, installing the folder’s entire content is not desirable.
    Luckily, CMake allows the `install` command to include or exclude directory content
    based on globbing patterns and regular expressions. Let’s install `dir1`, `dir2`,
    and `dir3` selectively this time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将会把 `dir1` 和 `dir2` 目录安装到 `${CMAKE_INSTALL_PREFIX}/var` 目录中，并且连同它们的所有子文件夹和文件一起原样安装。有时候，安装文件夹的全部内容并不理想。幸运的是，CMake
    允许 `install` 命令根据通配符模式和正则表达式来包含或排除目录内容。让我们这次选择性地安装 `dir1`、`dir2` 和 `dir3`：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we used the `FILES_MATCHING` parameter to define
    criteria for file selection. `FILES_MATCHING` can be followed by either the `PATTERN`
    or `REGEX` argument. `PATTERN` allows you to define a globbing pattern, whereas
    `REGEX` allows you to define a regular expression. By default, these expressions
    are used for including files. If you want to exclude files that match the criteria,
    you can append the `EXCLUDE` argument to the pattern. Note that these filters
    are not applied to subdirectory names because of the `FILES_MATCHING` parameter.
    We also used `PATTERN` in the last `install(...)` command without `FILES_MATCHING`
    prepended, which allows us to filter subdirectories instead of files. This time,
    only the files with the `.x` extension in `dir1`, files that don’t have the `.hpp`
    extension in `dir2`, and all the content except for the `bin` folder in `dir3`
    will be installed. This example is available as [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*,
    Example 4* in the `chapter04/ex04_directory` folder. Let’s compile and install
    it to see whether it does the right thing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`FILES_MATCHING`参数来定义文件选择的标准。`FILES_MATCHING`后面可以跟`PATTERN`或`REGEX`参数。`PATTERN`允许您定义一个通配符模式，而`REGEX`允许您定义一个正则表达式。默认情况下，这些表达式用于包含文件。如果要排除符合标准的文件，可以在模式后添加`EXCLUDE`参数。请注意，这些过滤器不会应用于子目录名称，因为`FILES_MATCHING`参数的限制。我们还在最后一个`install(...)`命令中使用了`PATTERN`而没有加上`FILES_MATCHING`，这使得我们可以过滤子目录而非文件。这一次，只有`dir1`中扩展名为`.x`的文件、`dir2`中没有`.hpp`扩展名的文件以及`dir3`中除`bin`文件夹外的所有内容将被安装。这个示例可以在`chapter04/ex04_directory`文件夹中的[*Chapter
    4*](B30947_04.xhtml#_idTextAnchor071)*，示例4*中找到。让我们编译并安装它，看看它是否执行了正确的操作：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of `cmake --install` should look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake --install`的输出应该如下所示：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`FILES_MATCHING` cannot be used after `PATTERN` or `REGEX` but it can be done
    vice versa.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILES_MATCHING`不能在`PATTERN`或`REGEX`之后使用，但可以反过来使用。'
- en: In the output, we can see that only the files with the `.x` extension are picked
    from `dir1`. This is because of the `FILES_MATCHING PATTERN "*.x"` parameter in
    the first `install(...)` command, causing the `asset2` file to not be installed.
    Also, note that the `dir2/chapter04_hello.dat` file is installed and the `dir2/chapter04_hello.hpp`
    file is skipped. This is due to the `FILES_MATCHING PATTERN "*.hpp" EXCLUDE PATTERN
    "*"` parameters in the second `install(…)` command. Lastly, we can see that the
    `dir3/asset4` file is installed and the `dir3/bin` directory is completely skipped
    since the `PATTERN "bin" EXCLUDE` parameter is specified in the last `install(...)`
    command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到只有扩展名为`.x`的文件被从`dir1`中选取。这是因为在第一个`install(...)`命令中使用了`FILES_MATCHING
    PATTERN "*.x"`参数，导致`asset2`文件没有被安装。同时，注意到`dir2/chapter04_hello.dat`文件被安装，而`dir2/chapter04_hello.hpp`文件被跳过。这是因为第二个`install(…)`命令中的`FILES_MATCHING
    PATTERN "*.hpp" EXCLUDE PATTERN "*"`参数所致。最后，我们看到`dir3/asset4`文件被安装，而`dir3/bin`目录被完全跳过，因为在最后一个`install(...)`命令中指定了`PATTERN
    "bin" EXCLUDE`参数。
- en: With `install(DIRECTORY...)`, we have covered the basics of the `install(...)`
    command. Let’s continue with the `install(…)` command’s other common parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`install(DIRECTORY...)`时，我们已经涵盖了`install(...)`命令的基础知识。接下来，让我们继续了解`install(…)`命令的其他常见参数。
- en: Other common parameters of the install() command
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`install()`命令的其他常见参数'
- en: As we’ve seen, the `install()` command’s first parameter indicates what to install.
    There are additional parameters that allow us to customize the installation. Let’s
    inspect some of the common parameters together.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`install()`命令的第一个参数指示要安装的内容。还有一些额外的参数可以让我们定制安装过程。让我们一起查看一些常见的参数。
- en: The DESTINATION parameter
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DESTINATION 参数
- en: This parameter allows you to specify a target directory for the files specified
    in the `install(...)` command. The directory path can be relative or absolute.
    Relative paths will be relative to the `CMAKE_INSTALL_PREFIX` variable. It is
    recommended to use relative paths to make the installation *relocatable*. Also,
    it is important to use relative paths for packaging since `cpack` requires install
    paths to be relative. It is good practice to use a path that begins with the relevant
    `GNUInstallDirs` variable so that package maintainers can override the install
    destination if needed. The `DESTINATION` parameter can be used together with the
    `TARGETS`, `FILES`, `IMPORTED_RUNTIME_ARTIFACTS`, `EXPORT`, and `DIRECTORY` installation
    types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数允许你为 `install(...)` 命令中指定的文件指定目标目录。目录路径可以是相对路径或绝对路径。相对路径将相对于 `CMAKE_INSTALL_PREFIX`
    变量。建议使用相对路径以使安装*可重定位*。此外，为了打包，使用相对路径也很重要，因为 `cpack` 要求安装路径必须是相对的。最好使用以相关的 `GNUInstallDirs`
    变量开头的路径，这样包维护者可以根据需要覆盖安装目标位置。`DESTINATION` 参数可以与 `TARGETS`、`FILES`、`IMPORTED_RUNTIME_ARTIFACTS`、`EXPORT`
    和 `DIRECTORY` 安装类型一起使用。
- en: The PERMISSIONS parameter
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PERMISSIONS 参数
- en: This parameter allows you to change the installed file permissions on supported
    platforms. The available permissions are `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`,
    `GROUP_READ`, `GROUP_WRITE`, `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`,
    `SETUID`, and `SETGID`. The `PERMISSIONS` parameter can be used with the `TARGETS`,
    `FILES`, `IMPORTED_RUNTIME_ARTIFACTS`, `EXPORT`, and `DIRECTORY` installation
    types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数允许你在支持的平台上更改已安装文件的权限。可用的权限有 `OWNER_READ`、`OWNER_WRITE`、`OWNER_EXECUTE`、`GROUP_READ`、`GROUP_WRITE`、`GROUP_EXECUTE`、`WORLD_READ`、`WORLD_WRITE`、`WORLD_EXECUTE`、`SETUID`
    和 `SETGID`。`PERMISSIONS` 参数可以与 `TARGETS`、`FILES`、`IMPORTED_RUNTIME_ARTIFACTS`、`EXPORT`
    和 `DIRECTORY` 安装类型一起使用。
- en: The CONFIGURATIONS parameter
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CONFIGURATIONS 参数
- en: This allows you to limit a set of parameters to be applied when a specific build
    configuration has been specified.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在指定特定构建配置时限制应用的参数集。
- en: The OPTIONAL parameter
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OPTIONAL 参数
- en: This parameter makes the file to be installed optional so that installation
    does not fail when the file is not present. The `OPTIONAL` parameter can be used
    together with the `TARGETS`, `FILES`, I`MPORTED_RUNTIME_ARTIFACTS`, and `DIRECTORY`
    installation types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数使得文件的安装变为可选，这样当文件不存在时，安装不会失败。`OPTIONAL` 参数可以与 `TARGETS`、`FILES`、`IMPORTED_RUNTIME_ARTIFACTS`
    和 `DIRECTORY` 安装类型一起使用。
- en: In this section, we learned how to make targets, files, and directories installable.
    In the next section, we will learn how to generate configuration information so
    that we can import CMake projects directly into another CMake project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使目标、文件和目录可安装。在下一节中，我们将学习如何生成配置信息，以便可以直接将 CMake 项目导入到另一个 CMake 项目中。
- en: Supplying configuration information for others using your project
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为他人提供项目的配置信息
- en: In the previous section, we learned how to make our project installable so that
    others can consume our project by installing it on their system. But sometimes,
    delivering the artifacts is not enough. For example, if you are delivering a library,
    it must also be easy to import it into a project – especially a CMake project.
    In this section, we will learn how to make this importing process easier for other
    CMake projects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使我们的项目可安装，以便他人可以通过安装它到他们的系统中来使用我们的项目。但有时候，仅仅交付制品并不足够。例如，如果你交付的是一个库，它必须也能方便地导入到另一个项目中——尤其是
    CMake 项目中。在本节中，我们将学习如何让其他 CMake 项目更容易导入你的项目。
- en: There are convenient ways of importing a library, given that the project to
    be imported has the proper configuration files. One of the prominent ways of doing
    so is by utilizing the `find_package()` method (which we will cover in [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries* *and
    Dependency Management*). If you have consumers that use CMake in their workflows,
    they will be happy if they can just write `find_package(your_project_name)` and
    start using your code. In this section, we will learn how to generate the required
    configuration files to make `find_package()` work for your project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被导入的项目具有适当的配置文件，则有一些便捷的方法可以导入库。一个突出的方式是利用 `find_package()` 方法（我们将在[*第 5 章*](B30947_05.xhtml#_idTextAnchor084)中讲解，*集成第三方库*
    和 *依赖管理*）。如果你的消费者在工作流程中使用 CMake，他们会很高兴能够直接写 `find_package(your_project_name)`，并开始使用你的代码。在本节中，我们将学习如何生成所需的配置文件，以使
    `find_package()` 能在你的项目中正常工作。
- en: CMake’s preferred way of consuming dependencies is via packages. Packages convey
    dependency information for CMake-based build systems. Packages can be in the form
    of `Config-file` packages, `Find-module` packages, or `pkg-config` packages. All
    of the package types can be found and consumed via `find_package()`. In the interest
    of efficiency and adherence to best practices, our focus in this section will
    be solely on `Config-file` packages. The other methods, such as `find-modules`
    and `pkg-config` packages, are considered outdated workarounds primarily used
    in the absence of config files and are generally not recommended. Let’s delve
    into the world of `Config-file` packages to understand their benefits and implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 推荐的依赖管理方式是通过包（packages）。包用于传递 CMake 基于构建系统的依赖信息。包可以是 `Config-file` 包、`Find-module`
    包或 `pkg-config` 包的形式。所有这些包类型都可以通过 `find_package()` 查找并使用。为了提高效率并遵循最佳实践，本节将仅关注
    `Config-file` 包。其他方法，如 `find-modules` 和 `pkg-config` 包，通常被视为过时的变通方法，主要在没有配置文件的情况下使用，通常不推荐使用。让我们深入了解
    `Config-file` 包，理解它们的优点和实现方式。
- en: Entering the CMake package world – Config-file packages
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入 CMake 包的世界 —— `Config-file` 包
- en: Config-file packages are based on configuration files that contain package content
    information. This information indicates the package’s content locations, so CMake
    reads this file and uses the package. Thus, discovering only the package configuration
    files is enough to consume the package.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config-file` 包基于包含包内容信息的配置文件。这些信息指示包的内容位置，因此 CMake 会读取此文件并使用该包。因此，仅发现包的配置文件就足够使用该包了。'
- en: 'There are two types of configuration files – a package configuration file and
    an optional package version file. Both files must have a specific naming convention.
    Package configuration files can be named `<ProjectName>Config.cmake` or `<projectname>-config.cmake`,
    depending on personal preference. Both notations will be picked by CMake on `find_package(ProjectName)`/`find_package(projectname)`
    calls. The content of package configuration files looks similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件有两种类型 —— 包配置文件和可选的包版本文件。两个文件都必须遵循特定的命名约定。包配置文件可以命名为 `<ProjectName>Config.cmake`
    或 `<projectname>-config.cmake`，具体取决于个人偏好。在 `find_package(ProjectName)`/`find_package(projectname)`
    调用时，CMake 会自动识别这两种命名方式。包配置文件的内容大致如下：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `${PREFIX}` is the installation prefix of the project. It is a variable
    since the installation prefix can be changed based on the system’s type and can
    also be changed by the user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`${PREFIX}` 是项目的安装前缀。它是一个变量，因为安装前缀可以根据系统类型进行更改，也可以由用户更改。
- en: Like package configuration files, package version files can be named `<ProjectName>ConfigVersion.cmake`
    or `<projectname>-config-version.cmake` as well. CMake expects package configuration
    and package version files to be present in the `find_package(...)` search paths.
    You can create these files with the help of CMake. One of the many places that
    `find_package(...)` looks while searching for packages is the `<CMAKE_PREFIX_PATH>/cmake`
    directory. We’ll be putting our `config-file` package configuration files into
    this folder throughout our examples.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 和包配置文件一样，包版本文件也可以命名为 `<ProjectName>ConfigVersion.cmake` 或 `<projectname>-config-version.cmake`。CMake
    期望在 `find_package(...)` 搜索路径中找到包配置文件和包版本文件。你可以在 CMake 的帮助下创建这些文件。`find_package(...)`
    在查找包时会检查多个位置，其中之一就是 `<CMAKE_PREFIX_PATH>/cmake` 目录。在我们的例子中，我们将把 `config-file`
    包配置文件放到这个文件夹中。
- en: 'To create `config-file` packages, we will need to learn about a few extra things,
    such as `CmakePackageConfigHelpers` module. To learn about these things, let’s
    start diving into an actual example. We’ll be following [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*,
    Example 5* to learn how to structure a CMake project to make it a `chapter04/
    ex05_config_file_package` folder. Let’s start by inspecting the `CMakeLists.txt`
    file in the `chapter04/ex05_config_file_package` directory (comments and project
    commands have been omitted in favor of space; also, note that the lines that are
    not relevant to the topic will not be mentioned):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 `config-file` 包，我们需要了解一些额外的内容，例如 `CmakePackageConfigHelpers` 模块。为了了解这些内容，让我们开始深入探讨一个实际的例子。我们将跟随
    [*第 4 章*](B30947_04.xhtml#_idTextAnchor071)*，示例 5* 来学习如何构建一个 CMake 项目，将其组织成 `chapter04/ex05_config_file_package`
    文件夹。首先，让我们检查 `chapter04/ex05_config_file_package` 目录中的 `CMakeLists.txt` 文件（注释和项目命令已省略以节省空间；另外，请注意，所有与主题无关的行将不被提及）：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `CMakeLists.txt` file is quite similar to `chapter04/ex02_static`. This
    is because it is the same example, except it supports the `config-file` package.
    The first line, `include(GNUInstallDirs)`, is used to include the `GNUInstallDirs`
    module. This provides the `CMAKE_INSTALL_INCLUDEDIR` variable, which will be used
    later. `set(ch4_ex05_lib_INSTALL_CMAKEDIR...)` is a user-defined variable for
    setting the target installation directory of the `config-file` packaging configuration
    files. It is a relative path that should be used in the `install(…)` directives,
    so it is implicitly relative to `CMAKE_INSTALL_PREFIX`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt` 文件与 `chapter04/ex02_static` 非常相似。这是因为它是同一个示例，只是它支持 `config-file`
    包。第一行 `include(GNUInstallDirs)` 用于包含 `GNUInstallDirs` 模块。这个模块提供了 `CMAKE_INSTALL_INCLUDEDIR`
    变量，稍后会用到。`set(ch4_ex05_lib_INSTALL_CMAKEDIR...)` 是一个用户定义的变量，用于设置 `config-file`
    打包配置文件的目标安装目录。它是一个相对路径，应在 `install(…)` 指令中使用，因此它隐式地是相对于 `CMAKE_INSTALL_PREFIX`
    的：'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `target_include_directories(...)` call is quite different than the usual
    calls. It uses `generator expressions` to distinguish between build-time `include`
    directories and install-time `include` directories since the build-time `include`
    path will not be present when the target is imported into another project. The
    following set of commands will make the target installable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_include_directories(...)` 调用与通常的调用非常不同。它使用了 `generator expressions`
    来区分构建时的 `include` 目录和安装时的 `include` 目录，因为构建时的 `include` 路径在目标被导入到另一个项目时将不存在。以下一组命令将使目标可安装：'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`install(TARGETS...)` is a bit different than regular calls as well. It contains
    an extra `EXPORT` parameter. This `EXPORT` parameter is used to create an export
    name from the given `install(…)` targets. These targets can then be exported using
    this export name. The path that’s specified with the `INCLUDES DESTINATION` parameter
    will be used to populate the `INTERFACE_INCLUDE_DIRECTORIES` property of the exported
    target and will be automatically prefixed with the install prefix path. Here,
    the `install(DIRECTORY...)` command is used to install the target’s header files
    and is located in `${PROJECT_SOURCE_DIR}/include/`, in the `${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}`
    directory. The `${CMAKE_INSTALL_INCLUDEDIR}` variable is used to give consumers
    the ability to override the `include` directory for this installation. Now, let’s
    create an export file from the export name we created in the preceding example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(TARGETS...)` 与常规调用稍有不同。它包含了一个额外的 `EXPORT` 参数。这个 `EXPORT` 参数用于从给定的
    `install(…)` 目标创建一个导出名称。然后可以使用这个导出名称来导出这些目标。通过 `INCLUDES DESTINATION` 参数指定的路径将用于填充导出目标的
    `INTERFACE_INCLUDE_DIRECTORIES` 属性，并会自动加上安装前缀路径。在这里，`install(DIRECTORY...)` 命令用于安装目标的头文件，这些文件位于
    `${PROJECT_SOURCE_DIR}/include/`，并安装到 `${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}`
    目录下。`${CMAKE_INSTALL_INCLUDEDIR}` 变量用于为用户提供覆盖此安装的 `include` 目录的能力。现在，让我们从之前示例中创建一个导出文件：'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`install(EXPORT...)` is perhaps the most important piece of code in this file.
    It is the code that does the actual target exporting. It generates a CMake file
    that contains all the exported targets in the given export name. The `EXPORT`
    parameter accepts an existing export name to perform the export. It refers to
    the `ch4_ex05_lib_export` export name that we created with the previous `install(TARGETS...)`
    call. The `FILE` parameter is used to determine the export’s filename and is set
    to `ch4_ex05_lib-config.cmake`. The `NAMESPACE` parameter is used to prefix all
    the exported targets with a namespace. This allows you to connect all the exported
    targets under a common namespace and avoid collisions with packages that have
    similar target names. Lastly, the `DESTINATION` parameter determines the installation
    path of the generated export file. This is set to `${ch4_ex05_lib_INSTALL_CMAKEDIR}`
    to allow `find_package()` to discover it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(EXPORT...)` 可能是这个文件中最重要的代码部分。它执行实际的目标导出。它生成一个包含所有导出目标的 CMake 文件，并使用给定的导出名称。`EXPORT`
    参数接受一个现有的导出名称来执行导出。它引用了我们之前通过 `install(TARGETS...)` 调用创建的 `ch4_ex05_lib_export`
    导出名称。`FILE` 参数用于确定导出的文件名，并设置为 `ch4_ex05_lib-config.cmake`。`NAMESPACE` 参数用于给所有导出的目标添加前缀命名空间。这使得你可以将所有导出的目标放在一个公共的命名空间下，避免与其他有相似目标名称的包发生冲突。最后，`DESTINATION`
    参数确定了生成的导出文件的安装路径。它设置为 `${ch4_ex05_lib_INSTALL_CMAKEDIR}`，以便 `find_package()`
    可以找到它。'
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are not providing any extras other than exported targets, the name
    of the export file is `ch4_ex05_lib-config.cmake`. It is the package configuration
    file name that’s required for this package. We’ve done this because the example
    project does not require any extra dependencies to be satisfied first and can
    be directly imported as is. If any extra action is required, it is recommended
    to have an intermediate package configuration file that satisfies those dependencies
    and includes the exported file after.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们除了导出的目标之外不提供任何额外内容，因此导出文件的名称是`ch4_ex05_lib-config.cmake`。这是此包所需的包配置文件名称。我们这样做是因为示例项目不需要先满足任何额外的依赖关系，可以直接按原样导入。如果需要任何额外的操作，建议先创建一个中间包配置文件，以满足这些依赖关系，然后再包含导出的文件。
- en: 'With the `install(EXPORT...)` command, we obtained the `ch4_ex05_lib-config.cmake`
    file. This means that our target can be consumed via `find_package(..)`. One additional
    step is required to achieve full support for `find_package(…)`, which is obtaining
    the `ch4_ex05_lib-config-version.cmake` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`install(EXPORT...)`命令，我们获得了`ch4_ex05_lib-config.cmake`文件。这意味着我们的目标可以通过`find_package(..)`来使用。为了实现对`find_package(…)`的完全支持，还需要执行一个额外步骤，即获取`ch4_ex05_lib-config-version.cmake`文件：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the last few lines, you can find the code that’s required to generate and
    install the `ch4_ex05_lib-config-version.cmake` file. With the `include(CMakePackageConfigHelpers)`
    line, the `CMakePackageConfigHelpers` module is imported. This module provides
    the `write_basic_package_version_file(…)` function. The `write_basic_package_version_file(…)`
    function is used to automatically generate package version files, depending on
    the given parameters. The first positional argument is the output’s filename.
    The `VERSION` parameter is used to specify the version of the package we’re generating
    in `major.minor.patch` form. It is opted out to allow `write_basic_package_version_file`
    to get it from the project version automatically. The `COMPATIBILITY` parameter
    allows you to specify compatibility policies, depending on the version’s value.
    `SameMajorVersion` denotes that this package is compatible with any version that
    has the same major version value of this package. The other possible values are
    `AnyNewerVersion`, `SameMinorVersion`, and `ExactVersion`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几行中，您可以找到生成并安装`ch4_ex05_lib-config-version.cmake`文件所需的代码。通过`include(CMakePackageConfigHelpers)`这一行，导入了`CMakePackageConfigHelpers`模块。该模块提供了`write_basic_package_version_file(…)`函数。`write_basic_package_version_file(…)`函数用于根据给定的参数自动生成包版本文件。第一个位置参数是输出文件的文件名。`VERSION`参数用于指定我们正在生成的包的版本，格式为`major.minor.patch`。我们选择不显式指定版本，以允许`write_basic_package_version_file`自动从项目版本中获取。`COMPATIBILITY`参数允许根据版本值指定兼容性策略。`SameMajorVersion`表示该包与任何具有相同主版本号的版本兼容。其他可能的值包括`AnyNewerVersion`、`SameMinorVersion`和`ExactVersion`。
- en: 'Now, let’s test whether this works. To test the package configuration, we must
    install the project in the regular way:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下这个是否有效。为了测试包配置，我们必须以常规方式安装项目：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `cmake --install` command’s output should look as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake --install`命令的输出应如下所示：'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we can see that our package configuration files have been successfully
    installed in the `/tmp/install-test/cmake` directory. I’ll leave inspecting the
    content of those files to you as an exercise. So, we have a consumable package
    on our hands. Let’s switch sides and try to consume our freshly baked package.
    To do that, we’ll look at the `chapter04/ex05_consumer` example. Let’s inspect
    the `CMakeLists.txt` file together:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的包配置文件已成功安装到`/tmp/install-test/cmake`目录中。检查这些文件的内容作为练习留给您自己。所以，现在我们手头有一个可消费的包。让我们换个角度，尝试消费我们新创建的包。为此，我们将查看`chapter04/ex05_consumer`示例。让我们一起检查`CMakeLists.txt`文件：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the first few lines, we can see verification regarding whether the project
    is a top-level project or not. Since this example is intended to be an external
    application, it should not be part of the root example project. Thus, we can guarantee
    that we will use the targets that are exported by the package, not the root project’s
    targets. The root project also does not include the `ex05_consumer` folder. Next,
    there’s a `find_package(…)` call, where `ch4_ex05_lib` is given as a package name.
    It is also explicitly requested that the package should have a major version of
    1; `find_package(…)` must only consider `CONFIG` packages and packages specified
    in this `find_package(…)` call are required. In the subsequent lines, a regular
    executable is defined called `ch4_ex05_consumer` that’s linked against `ch4_ex05_lib`
    in the `ch4_ex05_lib` namespace (`ch4_ex05_lib::ch4_ex05_lib`). `ch4_ex05_lib::ch4_ex05_lib`
    is the actual target we have defined in our package. Let’s look at the source
    file, `src/main.cpp`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几行中，我们可以看到关于该项目是否是顶级项目的验证。由于这个示例旨在作为外部应用程序，它不应成为根示例项目的一部分。因此，我们可以保证使用由软件包导出的目标，而不是根项目的目标。根项目也不包括`ex05_consumer`文件夹。接下来，有一个`find_package(…)`调用，其中`ch4_ex05_lib`作为软件包名称给出。还明确要求该软件包的主版本为1；`find_package(…)`只能考虑`CONFIG`软件包，并且此`find_package(…)`调用中指定的软件包是必需的。在接下来的几行中，定义了一个常规可执行文件`ch4_ex05_consumer`，它在`ch4_ex05_lib`命名空间下链接到`ch4_ex05_lib`（`ch4_ex05_lib::ch4_ex05_lib`）。`ch4_ex05_lib::ch4_ex05_lib`就是我们在软件包中定义的实际目标。让我们来看一下源文件`src/main.cpp`：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a simple application that includes `chapter04/ex05/lib.hpp`, creates
    an instance of the `greeter` class, and calls the `greet()` function. Let’s try
    to compile and run the application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的应用程序，它包括`chapter04/ex05/lib.hpp`，创建一个`greeter`类的实例，并调用`greet()`函数。让我们尝试编译并运行该应用程序：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we have installed the package using a custom prefix (`/tmp/install-test`),
    we can indicate this by setting the `CMAKE_PREFIX_PATH` variable. This causes
    `find_package(…)` to search `/tmp/install-test` for packages as well. For default
    prefix installations, this parameter setting is not required. We should see the
    infamous `Hello, world!` message if everything goes well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用自定义前缀（`/tmp/install-test`）安装了软件包，我们可以通过设置`CMAKE_PREFIX_PATH`变量来指示这一点。这将使得`find_package(…)`在`/tmp/install-test`中也查找软件包。对于默认前缀安装，此参数设置是不可选的。如果一切顺利，我们应该看到臭名昭著的`Hello,
    world!`消息：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, our consumers can use our little **greeter** and everybody is happy. Now,
    let’s conclude this section by learning how to package with **CPack**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的消费者可以使用我们的小**欢迎程序**，每个人都很高兴。现在，让我们通过学习如何使用**CPack**打包来结束这一部分。
- en: Creating an installable package with CPack
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CPack 创建可安装软件包
- en: 'So far, we have seen how CMake can structure software projects. Although CMake
    is the star of the show, CMake has some powerful friends too. It is time to introduce
    you to CPack, the packaging tool of CMake. It is shipped with CMake installations
    by default. It allows you to leverage existing CMake code to generate platform-specific
    installations and packages. CPack is similar to CMake in concept. It is based
    on generators that generate packages instead of build system files. The following
    table shows the available CPack generator types as of version 3.21.3:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 CMake 如何构建软件项目。尽管 CMake 是这场演出的主角，但它也有一些强大的朋友。现在是时候向你介绍 CPack——CMake
    的打包工具了。它默认与 CMake 一起安装。它允许你利用现有的 CMake 代码生成特定平台的安装包。CPack 的概念类似于 CMake。它基于生成器，这些生成器生成的是软件包而非构建系统文件。下表展示了截至版本
    3.21.3 的可用 CPack 生成器类型：
- en: '| **Generator Name** | **Description** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **生成器名称** | **描述** |'
- en: '| 7Z | 7-zip archive |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 7Z | 7-zip 压缩档案 |'
- en: '| DEB | Debian package |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| DEB | Debian 软件包 |'
- en: '| External | CPack external package |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| External | CPack 外部软件包 |'
- en: '| IFW | Qt Installer Framework |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| IFW | Qt 安装程序框架 |'
- en: '| NSIS | Null Soft Installer |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| NSIS | Null Soft 安装程序 |'
- en: '| NSIS64 | Null Soft Installer (64-bit) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| NSIS64 | Null Soft 安装程序（64 位） |'
- en: '| NuGet | NuGet packages |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| NuGet | NuGet 软件包 |'
- en: '| RPM | RPM packages |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| RPM | RPM 软件包 |'
- en: '| STGZ | Self-extracting TAR gzip archive |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| STGZ | 自解压 TAR gzip 压缩档案 |'
- en: '| TBZ2 | Tar BZip2 archive |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| TBZ2 | Tar BZip2 压缩档案 |'
- en: '| TGZ | Tar GZip archive |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| TGZ | Tar GZip 压缩档案 |'
- en: '| TXZ | Tar XZ archive |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| TXZ | Tar XZ 压缩档案 |'
- en: '| TZ | Tar Compress archive |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| TZ | Tar 压缩档案 |'
- en: '| TZST | Tar Zstandard archive |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| TZST | Tar Zstandard 压缩档案 |'
- en: '| ZIP | Zip archive |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| ZIP | Zip 压缩档案 |'
- en: 'CPack uses CMake’s installation mechanism to populate the content of the packages.
    CPack uses the configuration details that are present in the `CPackConfig.cmake`
    and `CPackSourceConfig.cmake` files to generate packages. These files can either
    be populated manually or generated automatically by CMake with the help of the
    CPack module. Using CPack on an existing CMake project is as easy as including
    the CPack module, given that the project already has proper `install(…)` commands.
    Including the CPack module will cause CMake to generate the `CPackConfig.cmake`
    and `CPackSourceConfig.cmake` files, which are the CPack configurations that are
    needed to pack the project. Also, an additional `package` target will become available
    for the build step. This step will build the project and run CPack so that it
    starts packaging. CPack can be used when the CPack configuration files have been
    populated properly, either by CMake or the user. The CPack module allows you to
    customize the packaging process. A large amount of CPack variables can be set.
    These variables are separated into two groups – common variables and generator-specific
    variables. Common variables affect all package generators, whereas generator-specific
    variables only affect a specific type of generator. We’ll be inspecting the most
    basic and prominent ones and we will mostly deal with the common variables. The
    following table shows the most common CPack variables we will use in our examples:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CPack使用CMake的安装机制来填充包的内容。CPack使用位于`CPackConfig.cmake`和`CPackSourceConfig.cmake`文件中的配置详情来生成包。这些文件可以手动填充，也可以通过CMake配合CPack模块自动生成。对于一个已有的CMake项目，使用CPack非常简单，只需要包含CPack模块，前提是项目已经有正确的`install(…)`命令。包含CPack模块会使CMake生成`CPackConfig.cmake`和`CPackSourceConfig.cmake`文件，这些文件是打包项目所需的CPack配置。此外，还会生成一个额外的`package`目标，用于构建步骤。这个步骤会构建项目并运行CPack，从而开始打包。当CPack配置文件已经正确填充时，无论是通过CMake还是用户，CPack都可以使用。CPack模块允许你自定义打包过程。可以设置大量的CPack变量，这些变量分为两类——通用变量和生成器特定变量。通用变量影响所有包生成器，而生成器特定变量仅影响特定类型的生成器。我们将检查最基本和最显著的变量，主要处理通用变量。以下表格展示了我们将在示例中使用的最常见的CPack变量：
- en: '| **Variable Name** | **Description** | **Default Value** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **变量名** | **描述** | **默认值** |'
- en: '| CPACK_PACKAGE_NAME | Package name | Project name |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_PACKAGE_NAME | 包名 | 项目名 |'
- en: '| CPACK_PACKAGE_VENDOR | Package vendor name | “Humanity” |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_PACKAGE_VENDOR | 包的供应商名称 | “Humanity” |'
- en: '| CPACK_PACKAGE_VERSION_MAJOR | Package major version | Project major version
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_PACKAGE_VERSION_MAJOR | 包的主版本 | 项目的主版本 |'
- en: '| CPACK_PACKAGE_VERSION_MINOR | Package minor version | Project minor version
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_PACKAGE_VERSION_MINOR | 包的次版本 | 项目的次版本 |'
- en: '| CPACK_PACKAGE_VERSION_PATCH | Package patch version | Project patch version
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_PACKAGE_VERSION_PATCH | 包的补丁版本 | 项目的补丁版本 |'
- en: '| CPACK_GENERATOR | List of CPack generators to use | N/A |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_GENERATOR | 使用的CPack生成器列表 | 无 |'
- en: '| CPACK_THREADS | Number of threads to use when parallelism is supported |
    1 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| CPACK_THREADS | 支持并行时使用的线程数 | 1 |'
- en: 'Any changes that must be made to the variables must be made before you include
    the CPack module. Otherwise, the defaults will be used. Let’s dive into an example
    to see CPack in action. We will be following the [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Example 6* (`chapter04/ex06_pack`) example. This example is structured as a standalone
    project and is not part of the root example project. It is a regular project with
    two subdirectories named `executable` and `library`. The `CMakeLists.txt` file
    of the `executable` directory looks as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在包含CPack模块之前修改变量，否则将使用默认值。让我们通过一个例子来深入了解CPack的实际操作。我们将跟随[*第4章*](B30947_04.xhtml#_idTextAnchor071)，*示例6*（`chapter04/ex06_pack`）进行。这个示例是一个独立的项目，不是根项目的一部分。它是一个常规项目，包含名为`executable`和`library`的两个子目录。`executable`目录的`CMakeLists.txt`文件如下所示：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CMakeLists.txt` file of the `library` directory looks as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`library`目录的`CMakeLists.txt`文件如下所示：'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `CMakeLists.txt` files for these folders do not contain anything out of
    the ordinary. They contain regular, installable CMake targets and declare nothing
    about CPack. Let’s look at the top-level `CMakeLists.txt` file as well:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹的`CMakeLists.txt`文件并没有什么特别之处。它们包含常规的可安装CMake目标，并且没有声明关于CPack的任何内容。让我们也看一下顶级`CMakeLists.txt`文件：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The top-level `CMakeLists.txt` file is pretty much a regular, top-level `CMakeLists.txt`
    file, except for the last four lines. It sets three CPack-related variables and
    then includes the CPack module. These four lines are enough to provide basic CPack
    support. The `CPACK_PACKAGE_NAME` and `CPACK_PACKAGE_VERSION_*` variables are
    not set to let CPack deduce them from the top-level project’s name and version
    parameters. Let’s configure the project to see whether it works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的 `CMakeLists.txt` 文件几乎是一个常规的顶层 `CMakeLists.txt` 文件，唯一不同的是最后四行。它设置了三个与 CPack
    相关的变量，并引入了 CPack 模块。这四行足以提供基本的 CPack 支持。`CPACK_PACKAGE_NAME` 和 `CPACK_PACKAGE_VERSION_*`
    变量没有被设置，让 CPack 从顶层项目的名称和版本参数中推导出来。让我们配置一下项目，看看是否有效：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After configuring the project, the `CpackConfig.cmake` and `CpackConfigSource.cmake`
    files should be generated by the CPack module in the `build/CPack*` directory.
    Let’s check whether they’re present:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 配置项目后，`CpackConfig.cmake` 和 `CpackConfigSource.cmake` 文件应该由 CPack 模块生成，并存放在
    `build/CPack*` 目录下。我们来检查一下它们是否存在：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we can see that the CPack configuration files are automatically generated.
    Let’s build this and try to package the project with CPack:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 CPack 配置文件已自动生成。让我们构建一下，并尝试使用 CPack 打包项目：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `--config` argument is the main input of the CPack command. The `-B` argument
    overrides the default package directory that CPack will write its artifacts to.
    Let’s look at CPack’s output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`--config` 参数是 CPack 命令的主要输入。`-B` 参数覆盖了 CPack 默认的包目录，指定了它将写入工件的路径。我们来看看 CPack
    的输出：'
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we can see that CPack has used the `DEB`, `RPM`, and `TBZ2` generators
    to generate the `ch4_ex06_pack-1.0-Linux.deb`, `ch4_ex06_pack-1.0-Linux.rpm`,
    and `ch4_ex06_pack-1.0-Linux.tar.bz2` packages, respectively. Let’s try to install
    the generated Debian package in a Debian environment:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 CPack 使用了 `DEB`、`RPM` 和 `TBZ2` 生成器分别生成了 `ch4_ex06_pack-1.0-Linux.deb`、`ch4_ex06_pack-1.0-Linux.rpm`
    和 `ch4_ex06_pack-1.0-Linux.tar.bz2` 包。我们来尝试在 Debian 环境中安装生成的 Debian 包：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the packaging was correct, we should be able to invoke `ch4_ex06_executable`
    directly on the command line:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打包正确，我们应该能够在命令行中直接调用 `ch4_ex06_executable`：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It works! As an exercise, try to install the `RPM` and `tar.bz2` packages as
    well. There are generally two approaches to handling packages. One is to create
    small packages that depend on other packages to install the dependencies and the
    other approach is to create installers that contain all the necessary libraries
    to run standalone. Typically, Linux distributions come with a package manager
    that handles these dependencies, while Windows and macOS depend on standalone
    installers by default. Although, in recent years, Chocolatey for Windows and Homebrew
    for macOS have become popular package managers that support dependent packages,
    CPack does not (yet) support them. So far, we have only looked at simple packages
    that require the user to install all the dependencies by themselves. Let’s see
    how we could build a standalone package for easy distribution on Windows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！作为练习，试着安装 `RPM` 和 `tar.bz2` 包。处理包文件通常有两种方式。一种是创建小型包，依赖其他包来安装所需的依赖项；另一种方式是创建包含所有必要库的独立安装包，以便独立运行。通常，Linux
    发行版自带包管理器来处理这些依赖项，而 Windows 和 macOS 默认依赖独立的安装程序。虽然近年来，Windows 上的 Chocolatey 和
    macOS 上的 Homebrew 已成为支持依赖包的流行包管理器，但 CPack 目前（尚未）支持它们。到目前为止，我们只看过需要用户自行安装所有依赖项的简单包。接下来，我们来看一下如何为
    Windows 构建一个便于分发的独立包。
- en: Creating standalone installers for Windows
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Windows 创建独立安装程序
- en: Since Windows does not come with a standard package manager, installers for
    software often must include all necessary libraries. One approach is to include
    premade installers in either NSIS or WIX installers, but that is not always possible,
    so let’s have a look at how to find dependent files. For this, CMake offers the
    optional `RUNTIME_DEPENDENCIES` flag for the `install` command and the `InstallRequiredSystemLibraries`
    module to find dependencies for packaging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows 并没有自带标准的包管理器，软件的安装程序通常需要包含所有必要的库。一种做法是将预制的安装程序打包成 NSIS 或 WIX 安装包，但这并非总是可行的，所以我们来看一下如何查找依赖文件。为此，CMake
    提供了 `install` 命令的可选 `RUNTIME_DEPENDENCIES` 标志和 `InstallRequiredSystemLibraries`
    模块，用于查找打包所需的依赖项。
- en: 'They are used like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的使用方式如下：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous example, the `InstallRequiredSystemLibraries` module is included.
    The module is tailored to work in Windows. Including the module creates install
    instructions for libraries provided by the compiler such as the Visual Studio
    C++ runtime supplied by MSVC. It can be configured to include the debug versions
    of the libraries by setting the `CMAKE_INSTALL_DEBUG_LIBRARIES` variable to true,
    as done in the preceding example. There are further options available to instruct
    CMake to install additional libraries, such as the Windows MFC libraries, OpenMP,
    or the Microsoft Universal CRT libraries for app-local deployment on Windows XP
    or older Windows versions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，包含了 `InstallRequiredSystemLibraries` 模块。该模块是针对 Windows 进行定制的。包含该模块会创建安装编译器提供的库的指令，例如
    MSVC 提供的 Visual Studio C++ 运行时库。通过将 `CMAKE_INSTALL_DEBUG_LIBRARIES` 变量设置为 true（如前面示例中所做），可以配置为包括库的调试版本。还有更多选项可以指示
    CMake 安装额外的库，例如 Windows MFC 库、OpenMP 或用于在 Windows XP 或更早版本的 Windows 上进行应用本地部署的
    Microsoft Universal CRT 库。
- en: 'The full documentation of the module can be found here: [https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html](https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的完整文档可以在这里找到：[https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html](https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html)
- en: 'Including the compiler-provided libraries is one thing, but often software
    projects will depend on other libraries as well. If these are to be shipped in
    the same package, they can be included by using the `RUNTIME_DEPENDENCIES` option
    of the `install()` command like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 包括编译器提供的库是一回事，但通常软件项目还会依赖其他库。如果这些库需要与项目一起打包，可以通过 `install()` 命令的 `RUNTIME_DEPENDENCIES`
    选项来包含它们，如下所示：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will try to find out any shared libraries that the target specified depends
    on. Because of the way that Windows handles DLL resolution, this will most likely
    find a lot more libraries than what is really needed. Specifically, it will most
    likely find libraries starting with *api-ms* or *ext-ms* that are there for compatibility
    reasons and that are not needed. These can be filtered out with the `PRE_EXCLUDE_REGEXES`
    option, which filters before including them. Any file paths that match these regular
    expressions will be excluded from consideration when determining runtime dependencies.
    Alternatively, the `POST_EXCLUDE_REGEXES` option can be used to filter the files
    after they have been found. This can be useful if you want to exclude files from
    a certain location. In the preceding example, this is used to exclude any DLL
    files from the 32-bit `system32` folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试找出目标指定依赖的任何共享库。由于 Windows 处理 DLL 解析的方式，这很可能会找到比实际需要更多的库。具体来说，它很可能会找到以*api-ms*或*ext-ms*开头的库，这些库是为了兼容性原因存在的，并且并不需要。可以通过
    `PRE_EXCLUDE_REGEXES` 选项将这些库过滤掉，该选项会在包含库之前进行过滤。任何与这些正则表达式匹配的文件路径都将在确定运行时依赖时被排除在考虑范围之外。或者，也可以使用
    `POST_EXCLUDE_REGEXES` 选项，在找到文件之后对其进行过滤。如果你想排除来自某个特定位置的文件，这个选项很有用。在前面的示例中，它被用来排除来自
    32 位 `system32` 文件夹的 DLL 文件。
- en: In this section, we learned how to use CPack to pack our project. This is not
    an exhaustive guide. For a complete guide, the official CPack documentation provides
    a lot of information. With that, we’ve successfully reached the end of this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 CPack 打包我们的项目。这不是一本详尽的指南。有关完整指南，官方的 CPack 文档提供了大量的信息。至此，我们成功完成了本章内容。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the basics of making a target installable and how
    to package a project for development and consumer environments. Deployment is
    an important aspect of professional software projects, and with the help of the
    things we have covered in this chapter, you can tackle such deployment requirements
    easily.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使目标可安装的基础知识，以及如何为开发和消费者环境打包项目。部署是专业软件项目中的一个重要方面，借助我们在本章中覆盖的内容，你可以轻松处理这些部署需求。
- en: In the next chapter, we will learn how to integrate third-party libraries into
    CMake projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将第三方库集成到 CMake 项目中。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的理解：
- en: How can we instruct CMake to make a CMake target installable?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何指示 CMake 使 CMake 目标可安装？
- en: Which files are installed when a target is installed via the `install(TARGETS)`
    command?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `install(TARGETS)` 命令安装时，哪些文件会被安装？
- en: For library targets, are header files installed by the `install(TARGETS)` command?
    Why? If not, what can be done to install them as well?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于库目标，`install(TARGETS)` 命令是否会安装头文件？为什么？如果没有，如何安装头文件？
- en: What does the `GNUInstallDirs` CMake module provide?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GNUInstallDirs` CMake 模块提供了什么？'
- en: How can you selectively install a directory’s content in a destination directory?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何选择性地将一个目录的内容安装到目标目录中？
- en: Why should we use relative paths when specifying install destination directories?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在指定安装目标目录时应该使用相对路径？
- en: What are the essential files required for a `config-file` package?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config-file` 包所需的基本文件是什么？'
- en: What does exporting a target mean?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个目标是什么意思？
- en: How can you make a CMake project packageable with CPack?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使 CMake 项目能够通过 CPack 打包？
- en: Answers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following are the answers to the preceding questions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述问题的答案：
- en: It can be achieved via the `install(TARGETS <``target_name>)` command.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过 `install(TARGETS <target_name>)` 命令实现。
- en: The output artifacts of the specified targets.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定目标的输出工件。
- en: No, because header files are not classified as output artifacts of a target.
    They must be installed separately via the `install(DIRECTORY)` command.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不会，因为头文件不被视为目标的输出工件。它们必须通过 `install(DIRECTORY)` 命令单独安装。
- en: The `GNUInstallDirs` CMake module provides system-specific default paths for
    installation, such as `bin`, `lib`, and `include`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GNUInstallDirs` CMake 模块提供了系统特定的默认安装路径，例如 `bin`、`lib` 和 `include`。'
- en: With the help of the `PATTERN` and `FILES_MATCHING` parameters of the `install(DIRECTORY)`
    command.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `install(DIRECTORY)` 命令的 `PATTERN` 和 `FILES_MATCHING` 参数的帮助。
- en: To make the installation relocatable so that the user can change the installation
    directory by specifying an installation prefix.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使安装可迁移，用户可以通过指定安装前缀来更改安装目录。
- en: The `<package-name>-config.cmake` or `<package-name>Config.cmake` file, and
    optionally the `<package-name>-config-version.cmake` or `<``package-name>ConfigVersion.cmake`
    file.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<package-name>-config.cmake` 或 `<package-name>Config.cmake` 文件，另可选择包含 `<package-name>-config-version.cmake`
    或 `<package-name>ConfigVersion.cmake` 文件。'
- en: Exporting a target means creating the required CMake code so that you can import
    it into another CMake project.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个目标意味着创建所需的 CMake 代码，以便将其导入到另一个 CMake 项目中。
- en: This can be achieved by including the CPack module.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过包含 CPack 模块可以实现。
