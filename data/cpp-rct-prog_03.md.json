["```cpp\n//---- Thanks to Dennis Ritchie and Brian Kernighan, this is a norm for all languages\n#include <iostream> \nint main() \n{ \n   std::cout << \"Hello World\\n\"; \n} \n```", "```cpp\n#include <iostream> \n#include <thread> \n#include <string> \n//---- The following function will be invoked by the thread library \nvoid thread_proc(std::string msg) \n{ \n   std::cout << \"ThreadProc msg:\" << msg; \n}  \nint main() \n{ \n   // creates a new thread and execute thread_proc on it. \n   std::thread t(thread_proc, \"Hello World\\n\");  \n   // Waiting for the thread_proc to complete its execution \n   // before exiting from the program \n   t.join(); \n} \n```", "```cpp\nclass parallel_job \n{ \npublic: \nvoid operator() () \n{ \n    some_implementation(); \n} \n};  \nparallel_job job; \nstd::thread t(job); \n```", "```cpp\nstd::thread t(std::move(job)); \n```", "```cpp\nstd::thread t(parallel_job()); \n```", "```cpp\nstd::thread t{ parallel_job() };\n```", "```cpp\nstd::thread t((parallel_job()));\n```", "```cpp\nstd::thread t([]{ \n    some_implementation(); \n}); \n```", "```cpp\nclass parallel_job \n{ \n   int& _iterations; \n\npublic: \n    parallel_job(int& input): _iterations(input) \n    {} \n\n    void operator() () \n    { \n        for (int i = 0; i < _iterations; ++i) \n        { \n            some_implementation(i); \n        } \n    } \n}; \nvoid func() \n{ \n    int local_Val = 10000; \n    parallel_job job(local_Val); \n    std::thread t(job); \n\n    if(t.joinable()) \n        t.join(); \n} \n```", "```cpp\nif(t.joinable()) \n         t.detach(); \n```", "```cpp\nclass Factorial \n{ \nprivate: \n    long long myFact; \n\npublic: \n    Factorial() : myFact(1) \n    { \n    } \n\n    void operator() (int number) \n    { \n        myFact = 1; \n        for (int i = 1; i <= number; ++i) \n        { \n            myFact *= i; \n        } \n        std::cout << \"Factorial of \" << number << \" is \" << myFact; \n    } \n}; \n\nint main() \n{ \n    Factorial fact; \n\n    std::thread t1(fact, 10); \n\n    t1.join(); \n} \n\n```", "```cpp\nvoid thread_proc(std::string msg); \n\nstd::thread t(thread_proc, \"Hello World\\n\"); \n```", "```cpp\nvoid thread_proc(std::string msg); \nvoid func() \n{ \n   char buf[512]; \n   const char* hello = \"Hello World\\n\"; \n   std::strcpy(buf, hello); \n\n   std::thread t(thread_proc, buf); \n   t.detach(); \n} \n```", "```cpp\nstd::thread t(thread_proc, std::string(buf)); \n```", "```cpp\nvoid update_data(shared_data& data);\n\nvoid another_func() \n{ \n   shared_data data; \n   std::thread t(update_data, std::ref(data)); \n   t.join(); \n   do_something_else(data); \n} \n```", "```cpp\nstd::thread t(update_data, data);\n```", "```cpp\nint main() \n{ \n    std::vector<std::thread> threads; \n\n    for (int i = 0; i < 5; ++i) \n    { \n        threads.push_back(std::thread( [i]() { \n            std::cout << \"Thread #\" << i << std::endl; \n        })); \n    } \n\n    std::cout << \"nMain function\"; \n\n    std::for_each(threads.begin(), threads.end(), [](std::thread &t) { \n        t.join(); \n    }); \n} \n```", "```cpp\nThread # Thread # Thread # Thread # Thread #\nMain function\n0\n4\n1\n3\n2\n```", "```cpp\nvoid function1() \n{ \n    std::cout << \"function1()n\"; \n} \n\nvoid function2() \n{ \n    std::cout << \"function2()n\"; \n} \n```", "```cpp\nint main() \n{ \n    std::thread t1(function1); \n\n    // Ownership of t1 is transferred to t2 \n    std::thread t2 = std::move(t1);\n```", "```cpp\n    t1 = std::thread(function2); \n```", "```cpp\n    // thread instance Created without any associated thread execution \n    std::thread t3; \n\n    // Ownership of t2 is transferred to t3 \n    t3 = std::move(t2); \n```", "```cpp\n    // No need to join t1, no longer has any associated thread of execution \n    if (t1.joinable())  t1.join(); \n    if (t3.joinable())  t3.join(); \n\n    return 0; \n} \n```", "```cpp\nt1 = std::move(t3); \n```", "```cpp\nvoid func() \n{ \n    std::cout << \"func()n\"; \n} \n\nstd::thread thread_creator() \n{ \n    return std::thread(func); \n} \n\nvoid thread_wait_func() \n{ \n    std::thread t = thread_creator(); \n\n    t.join(); \n} \n```", "```cpp\n#include <iostream> \n#include <thread> \n#include <mutex> \n#include <vector>  \nstd::mutex m; \nint main() \n{ \n    std::vector<std::thread> threads; \n\n    for (int i = 1; i < 10; ++i) \n    { \n        threads.push_back(std::thread( [i]() { \n            m.lock(); \n            std::cout << \"Thread #\" << i << std::endl; \n            m.unlock();\n        })); \n    }      \n    std::for_each(threads.begin(), threads.end(), [](std::thread &t) { \n        t.join(); \n    }); \n} \n```", "```cpp\nThread #1 \nThread #2 \nThread #3 \nThread #4 \nThread #5 \nThread #6 \nThread #7 \nThread #8 \nThread #9 \n```", "```cpp\nstd::mutex m; \nint main() \n{ \n    std::vector<std::thread> threads;  \n    for (int i = 1; i < 10; ++i) \n    { \n        threads.push_back(std::thread( [i]() { \n            std::lock_guard<std::mutex> local_lock(m); \n            std::cout << \"Thread #\" << i << std::endl; \n        })); \n    }      \n    std::for_each(threads.begin(), threads.end(), [](std::thread &t) { \n        t.join(); \n    }); \n}\n```", "```cpp\n// Global mutexes \nstd::mutex evenMutex; \nstd::mutex oddMutex;  \n// Function to print even numbers \nvoid printEven(int max) \n{ \n    for (int i = 0; i <= max; i +=2) \n    { \n        oddMutex.lock(); \n        std::cout << i << \",\"; \n        evenMutex.lock(); \n        oddMutex.unlock(); \n        evenMutex.unlock(); \n    } \n} \n```", "```cpp\n// Function to print odd numbers \nvoid printOdd(int max) \n{ \n    for (int i = 1; i <= max; i +=2) \n    { \n        evenMutex.lock(); \n        std::cout << i << \",\"; \n        oddMutex.lock(); \n        evenMutex.unlock(); \n        oddMutex.unlock(); \n\n    } \n} \n```", "```cpp\nint main() \n{ \n    auto max = 100; \n\n    std::thread t1(printEven, max); \n    std::thread t2(printOdd, max); \n\n    if (t1.joinable()) \n        t1.join(); \n    if (t2.joinable()) \n        t2.join(); \n} \n```", "```cpp\nvoid printEven(int max) \n{ \n    for (int i = 0; i <= max; i +=2) \n    { \n        evenMutex.lock(); \n        std::cout << i << \",\"; \n        oddMutex.lock(); \n        evenMutex.unlock(); \n        oddMutex.unlock(); \n    } \n}  \nvoid printOdd(int max) \n{ \n    for (int i = 1; i <= max; i +=2) \n    { \n        evenMutex.lock(); \n        std::cout << i << \",\"; \n        oddMutex.lock(); \n        evenMutex.unlock(); \n        oddMutex.unlock(); \n\n    } \n} \n```", "```cpp\nvoid printEven(int max) \n{ \n    for (int i = 0; i <= max; i +=2) \n    { \n        std::lock(evenMutex, oddMutex); \n        std::lock_guard<std::mutex> lk_even(evenMutex, std::adopt_lock); \n        std::lock_guard<std::mutex> lk_odd(oddMutex, std::adopt_lock); \n        std::cout << i << \",\"; \n    } \n}  \nvoid printOdd(int max) \n{ \n    for (int i = 1; i <= max; i +=2) \n    { \n        std::lock(evenMutex, oddMutex); \n        std::lock_guard<std::mutex> lk_even(evenMutex, std::adopt_lock); \n        std::lock_guard<std::mutex> lk_odd(oddMutex, std::adopt_lock); \n\n        std::cout << i << \",\"; \n\n    } \n} \n```", "```cpp\nvoid retrieve_and_process_data(data_params param) \n{ \n   std::unique_lock<std::mutex> local_lock(global_mutex, std::defer_lock); \n   prepare_data(param); \n\n   local_lock.lock(); \n   data_class data = get_data_to_process(); \n   local_lock.unlock(); \n\n   result_class result = process_data(data); \n\n   local_lock.lock(); \n   strore_result(result); \n} \n```", "```cpp\nstd::mutex numMutex; \nstd::condition_variable syncCond; \nauto bEvenReady = false; \nauto bOddReady  = false; \nvoid printEven(int max) \n{ \n    for (int i = 0; i <= max; i +=2) \n    { \n        std::unique_lock<std::mutex> lk(numMutex); \n        syncCond.wait(lk, []{return bEvenReady;}); \n\n        std::cout << i << \",\"; \n\n        bEvenReady = false; \n        bOddReady  = true; \n        syncCond.notify_one(); \n    } \n}\n```", "```cpp\nvoid printOdd(int max) \n{ \n    for (int i = 1; i <= max; i +=2) \n    { \n        std::unique_lock<std::mutex> lk(numMutex); \n        syncCond.wait(lk, []{return bOddReady;}); \n\n        std::cout << i << \",\"; \n\n        bEvenReady = true; \n        bOddReady  = false; \n        syncCond.notify_one(); \n    } \n} \n```", "```cpp\nint main() \n{ \n    auto max = 10; \n    bEvenReady = true; \n\n    std::thread t1(printEven, max); \n    std::thread t2(printOdd, max); \n\n    if (t1.joinable()) \n        t1.join(); \n    if (t2.joinable()) \n        t2.join(); \n\n} \n```", "```cpp\ntemplate <typename T> \nclass Stack \n{ \nprivate: \n    std::stack<T> myData; \n    mutable std::mutex myMutex; \n    std::condition_variable myCond; \n\npublic: \n    Stack() = default; \n    ~Stack() = default; \n    Stack& operator=(const Stack&) = delete; \n\n    Stack(const Stack& that) \n    { \n        std::lock_guard<std::mutex> lock(that.myMutex); \n        myData = that.myData; \n    }\n```", "```cpp\n      void push(T new_value) \n      { \n          std::lock_guard<std::mutex> local_lock(myMutex); \n          myData.push(new_value); \n          myCond.notify_one(); \n      } \n```", "```cpp\n    bool try_pop(T& return_value) \n    { \n        std::lock_guard<std::mutex> local_lock(myMutex); \n        if (myData.empty()) return false; \n        return_value = myData.top(); \n        myData.pop(); \n        return true; \n    }\n```", "```cpp\n    std::shared_ptr<T> try_pop() \n    { \n        std::lock_guard<std::mutex> local_lock(myMutex); \n        if (myData.empty()) return std::shared_ptr<T>(); \n\n        std::shared_ptr<T> return_value(std::make_shared<T>(myData.top())); \n        myData.pop(); \n\n        return return_value;\n    } \n```", "```cpp\n    void wait_n_pop(T& return_value) \n    { \n        std::unique_lock<std::mutex> local_lock(myMutex); \n        myCond.wait(local_lock, [this]{ return !myData.empty(); }); \n        return_value = myData.top(); \n        myData.pop(); \n    }      \n    std::shared_ptr<T> wait_n_pop() \n    { \n        std::unique_lock<std::mutex> local_lock(myMutex); \n        myCond.wait(local_lock, [this]{ return !myData.empty(); }); \n        std::shared_ptr<T> return_value(std::make_shared<T>(myData.top())); \n        return return_value; \n    }   \n}; \n```"]