- en: Debugging and Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和优化
- en: In this final chapter, we are going to discuss two topics that will be helpful
    as you go on to create games using Emscripten and build in WebAssembly. We are
    going to discuss the topics of debugging and optimization. We will debug before
    optimizing, because building your code to output more debuging information prevents
    optimization. We will start by using some basic debugging techniques, such as
    printing a stack trace and defining debug macros that we can remove by changing
    a compile flag. We will then move on to some more advanced debugging techniques,
    such as compiling with Emscripten flags, which allow us to trace through our code
    in Firefox and Chrome. We will also discuss some of the differences between debugging
    using the Firefox and Chrome developer tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将讨论两个话题，这些话题将有助于您继续使用Emscripten创建游戏并构建WebAssembly。我们将讨论调试和优化的话题。我们将在优化之前进行调试，因为构建代码以输出更多调试信息会阻止优化。我们将从一些基本的调试技术开始，比如打印堆栈跟踪和定义调试宏，我们可以通过更改编译标志来删除。然后，我们将转向一些更高级的调试技术，比如使用Emscripten标志进行编译，这允许我们在Firefox和Chrome中跟踪代码。我们还将讨论使用Firefox和Chrome开发者工具进行调试的一些区别。
- en: 'You will need to include several images in your build to make this project
    work. Make sure that you include the `/Chapter16/sprites/` folder from this project''s
    GitHub repository. If you haven''t downloaded the GitHub project yet, you can
    get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目正常工作。确保您从该项目的GitHub存储库中包含`/Chapter16/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: After we have finished discussing debugging, we will move on to optimization.
    We will discuss the optimization flags you can use with Emscripten, as well as
    the use of profilers to determine where your game or app may be having performance
    issues. We will discuss general techniques for optimizing your code for WebAssembly
    deployment. Finally, we will discuss optimizations related to web games and WebGL
    calls made by the WebAssembly module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论调试结束后，我们将转向优化。我们将讨论您可以在Emscripten中使用的优化标志，以及使用性能分析器来确定您的游戏或应用可能存在性能问题的位置。我们将讨论优化代码以进行WebAssembly部署的一般技术。最后，我们将讨论与Web游戏和WebAssembly模块发出的WebGL调用相关的优化。
- en: Debug macro and stack trace
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试宏和堆栈跟踪
- en: 'One way you can start debugging your code is by using `#define` to create a
    debugging macro, which we can activate by passing a flag into the Emscripten compiler.
    However, this will resolve to nothing if we don''t pass that flag. Macros are
    easy to add, and we can create a call that prints a line if we are running with
    our debug flag, but will not slow down performance if we aren''t. If you are not
    familiar with preprocessor commands, they are commands that are issued to the
    compiler that evaluate while the code is compiled instead of at runtime. For instance,
    if I used a `#ifdef PRINT_ME` command, the line of code would only be compiled
    into our source code if the `PRINT_ME` macro is defined either with a `#define
    PRINT_ME` macro on a line earlier in the code, or if we compiled the source with
    the `-DPRINT_ME` flag passed into the compiler when we ran the compiler. Let''s
    say we had the following block of code in our `main` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 调试代码的一种方法是使用`#define`创建调试宏，我们可以通过将标志传递给Emscripten编译器来激活它。但是，如果我们不传递该标志，这将解析为空。宏很容易添加，我们可以创建一个调用，如果我们使用调试标志运行，它将打印一行，但如果我们不运行，它不会减慢性能。如果您不熟悉预处理器命令，它们是在代码编译时而不是在运行时评估的命令。例如，如果我使用了`#ifdef
    PRINT_ME`命令，只有在我们的源代码中定义了`PRINT_ME`宏时，才会将该行代码编译到我们的源代码中，或者如果我们在运行编译器时传递了`-DPRINT_ME`标志。假设我们在`main`函数中有以下代码块：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we did, we would have compiled and ran that code. The web browser''s console
    prints the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做了，我们将编译并运行该代码。Web浏览器的控制台将打印以下内容：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we compiled it with the `-DPRINT_ME` flag and then ran the code at the command
    line, we would see the following printed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`-DPRINT_ME`标志进行编译，然后在命令行上运行代码，我们将看到以下内容被打印出来：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you disassembled the code into WebAssembly text, then you wouldn't see any
    hint of the original `printf` statement that printed "nothing was defined". At
    compile time, the code is removed. This makes preprocessor macros very useful
    when creating code that we want to include during the development phase.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将代码反汇编为WebAssembly文本，那么您将看不到最初打印“未定义任何内容”的`printf`语句的任何迹象。在编译时，代码被移除。这使得预处理宏在创建我们希望在开发阶段包含的代码时非常有用。
- en: If you are using the `-D` flag to include debug macros in your code, make sure
    that you don't include that flag when you are compiling for release, as that will
    continue to include all of your debug macros when you don't want them. You may
    want to consider having a `-DRELEASE` flag that overrides your `-DDEBUG` flag
    when you compile your code for general release.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`-D`标志在代码中包含调试宏，请确保在编译发布时不要包含该标志，因为这将在您不想要它们的情况下继续包含所有调试宏。您可能需要考虑在为一般发布编译代码时，使用`-DRELEASE`标志来覆盖您的`-DDEBUG`标志。
- en: 'Keeping all of your `printf` calls confined to a macro is a good way to make
    sure you removed all the calls to `printf` that will slow down your app when you
    publish it. Let''s try this out by starting with the `webgl-redux.c` file as a
    baseline. From the code we created in the previous chapter, copy and paste `webgl-redux.c`
    into a file called `debug.cpp`. We will add our debug macro at the beginning of
    this file. Immediately after the line that includes `emscripten.h`, but before
    the line of code that defines the canvas width, add the following block of code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的`printf`调用限制在一个宏中是确保在发布应用时删除所有会减慢应用速度的`printf`调用的好方法。让我们通过以`webgl-redux.c`文件作为基准开始尝试一下。从我们在上一章中创建的代码中，将`webgl-redux.c`复制并粘贴到一个名为`debug.cpp`的文件中。我们将在这个文件的开头添加我们的调试宏。在包含`emscripten.h`的行之后，但在定义画布宽度的代码行之前，添加以下代码块：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code will only compile the `run_debug` function if we pass the `-DDEBUG`
    flag to the compiler. The user shouldn''t run the `run_debug` function directly,
    because it will not exist if we don''t use the `-DDEBUG` flag. Instead, we should
    use the `DBG` macro function. This macro exists regardless of whether we use the
    `-DDEBUG` flag. If we use this flag, the function calls the `run_debug` function.
    If we don''t use this flag, the calls to `DBG` magically disappear. The `run_debug`
    function not only uses `printf` to print out a string, but also uses `EM_ASM`
    to dump a stack trace to the JavaScript console. A stack trace logs out every
    function that is currently on the JavaScript stack. Let''s add a few function
    calls that will eventually call our `DBG` macro. These should be added immediately
    before the `main` function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向编译器传递`-DDEBUG`标志，这段代码将只编译`run_debug`函数。用户不应直接运行`run_debug`函数，因为如果我们不使用`-DDEBUG`标志，它将不存在。相反，我们应该使用`DBG`宏函数。无论我们是否使用`-DDEBUG`标志，这个宏都存在。如果我们使用这个标志，该函数调用`run_debug`函数。如果我们不使用这个标志，对`DBG`的调用会神奇地消失。`run_debug`函数不仅使用`printf`打印字符串，还使用`EM_ASM`将堆栈跟踪转储到JavaScript控制台。堆栈跟踪记录当前在JavaScript堆栈上的每个函数。让我们添加一些最终会调用我们的`DBG`宏的函数调用。这些应该在`main`函数之前立即添加：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside our `main` function, we should add a call to `inner_call_3()`, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数内，我们应该添加对`inner_call_3()`的调用，如下所示：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s compile our `debug.cpp` file with the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令编译我们的`debug.cpp`文件：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This compiles the `debug.cpp` file into an `index.html` file. If we serve that
    file from a web server and open it in a browser, we will see the following in
    our JavaScript console:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`debug.cpp`文件编译成一个`index.html`文件。如果我们从Web服务器提供该文件并在浏览器中打开它，我们将在JavaScript控制台中看到以下内容：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice that we have a stack trace, followed by our message, `check
    console log for stack trace`, which was the string we passed into the `DBG` macro.
    One thing you may notice if you look carefully is that this stack trace is not
    very helpful. Most of the functions in the stack trace are labeled `wasm-function`,
    which, from a debugging perspective, is kind of useless. This is because we lose
    the function names in the compilation process. To keep these names, we will need
    to pass the `-g4` flag to Emscripten when we compile. The `-g` flag, followed
    by a number, tells the compiler how much debugging information to preserve in
    the compilation process, with `-g0` being the least amount of information and
    `-g4` being the most. If we want to create source maps that map our WebAssembly
    to the C/C++ source code it was created from, we will need to pass in the `-g4`
    command, and if we want to know the functions called by our stack trace, we are
    going to need `-g4` for that as well. Let''s try recompiling with our `-g4` flag.
    Here is the new version of the `emcc` command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们有一个堆栈跟踪，后面是我们的消息，“检查控制台日志以获取堆栈跟踪”，这是我们传递给`DBG`宏的字符串。如果您仔细观察，您可能会注意到的一件事是，这个堆栈跟踪并不是很有用。堆栈跟踪中的大多数函数都标记为`wasm-function`，从调试的角度来看，这有点无用。这是因为我们在编译过程中丢失了函数名称。为了保留这些名称，我们需要在编译时向Emscripten传递`-g4`标志。`-g`标志后面跟着一个数字，告诉编译器在编译过程中保留多少调试信息，`-g0`表示最少的信息，`-g4`表示最多的信息。如果我们想要创建将我们的WebAssembly映射到创建它的C/C++源代码的源映射，我们需要传入`-g4`命令，如果我们想知道堆栈跟踪调用的函数，我们也需要`-g4`。让我们尝试使用`-g4`标志重新编译。这是`emcc`命令的新版本：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, reload the page and check the console. In the following snippet, we have
    the new stack trace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新加载页面并检查控制台。在下面的片段中，我们有新的堆栈跟踪：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is much more readable. You can see all of the inner call functions we
    defined, as well as the `main` function. But what happened to `run_debug`? It
    came out looking like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更容易阅读。您可以看到我们定义的所有内部调用函数，以及`main`函数。但`run_debug`发生了什么？它看起来像这样：
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What''s happening here is called C++ name mangling, and we discussed it briefly
    in earlier chapters. Because C++ allows for function overloading, the compiler
    *mangles* the names of functions so that each version of the function has a different
    name. We were able to prevent this in our calls to `inner_call_1`, `inner_call_2`,
    and `inner_call_3` by placing them in a block labeled `extern "C"`. This tells
    the compiler not to mangle the names of these functions. It isn''t strictly necessary
    for debugging, but I wanted to demonstrate how adding functions to this block
    can allow for easier recognition of our functions inside a stack trace. Here is
    what that same stack trace looks like if I remove the `extern "C"` block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况被称为C++名称混编，在前几章中我们简要讨论过。因为C++允许函数重载，编译器会对函数的名称进行*混编*，以便每个函数版本都有不同的名称。我们通过将它们放在标记为`extern
    "C"`的块中来防止这种情况发生在对`inner_call_1`、`inner_call_2`和`inner_call_3`的调用中。这告诉编译器不要混编这些函数的名称。这对于调试并不是绝对必要的，但我想演示如何将函数添加到这个块中可以更容易地在堆栈跟踪中识别我们的函数。如果我删除`extern
    "C"`块，那么相同的堆栈跟踪看起来是这样的：
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, all of our inner call functions are mangled. In the next section,
    we will be discussing source maps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们所有的内部调用函数都被搅乱了。在下一节中，我们将讨论源映射。
- en: Source maps
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源映射
- en: Now, let's briefly discuss source maps. Back in the early days of the web, it
    was decided that users should be able to view all of the source code on every
    web page. Early on, this was always HTML, but later, JavaScript was added and
    became something a user could view in an attempt to understand the workings of
    a given web page. Today, this is not possible in most cases. Some code today,
    such as TypeScript, is transpiled into JavaScript from another language. If you
    are writing JavaScript, you may use Babel to convert the latest JavaScript to
    run on older web browsers. Uglify or Minify may be used to remove white space
    and shorten variable names. If you need to debug the original source code, a source
    map is a tool you can use to map the JavaScript running in your browser back to
    the original source.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论源映射。在Web的早期，人们决定用户应该能够查看每个网页上的所有源代码。早期，这总是HTML，但后来添加了JavaScript，并成为用户可以查看以尝试理解给定网页工作原理的内容。今天，在大多数情况下，这是不可能的。今天的一些代码，如TypeScript，是从另一种语言转译为JavaScript。如果您正在编写JavaScript，可以使用Babel将最新的JavaScript转换为在旧的Web浏览器上运行。Uglify或Minify可用于删除空格并缩短变量名。如果您需要调试原始源代码，源映射是您可以使用的工具，将在浏览器中运行的JavaScript映射回原始源代码。
- en: 'A source map is a JSON file that contains data mapping for the machine-generated
    JavaScript output code and points it back to either the handwritten JavaScript
    or in an alternative language, such as TypeScript or CoffeeScript. There are two
    ways that an application can tell the web browser that there is a source map file
    associated with a given piece of code. We can include a comment with the `sourceMappingURL`
    directive in the code, or we could include a `SourceMap` inside the HTTP header
    for that file. If we are using the `sourceMappingURL` comment method, add the
    following line to the end of the output JavaScript file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射是一个包含数据映射的JSON文件，用于将机器生成的JavaScript输出代码指回手写的JavaScript或另一种语言，如TypeScript或CoffeeScript。应用程序可以通过两种方式告诉Web浏览器给定代码有一个源映射文件。我们可以在代码中包含一个带有`sourceMappingURL`指令的注释，或者我们可以在该文件的HTTP标头中包含一个`SourceMap`。如果我们使用`sourceMappingURL`注释方法，请在输出JavaScript文件的末尾添加以下行：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is usually done programmatically during the build process. The alternative
    method would add the following line to the HTTP header:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在构建过程中以编程方式完成的。另一种方法是将以下行添加到HTTP标头中：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will discuss browser-based WebAssembly debugging tools.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论基于浏览器的WebAssembly调试工具。
- en: Browser debugging
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器调试
- en: Debugging WebAssembly in a web browser is still pretty crude. For example, at
    the time of writing, it is still not possible to directly *watch* a variable using
    the debugger. In both Firefox and Chrome, you must occasionally refresh your browser
    to see the CPP source file. Unlike debugging JavaScript, the WebAssembly debuggers
    feel (ironically) buggy. In Chrome, you frequently have to click the step over
    button several times to advance the line of code. In both browsers, breakpoints
    sometimes fail to work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中调试WebAssembly仍然相当粗糙。例如，在撰写本文时，仍然不可能直接使用调试器*观察*变量。在Firefox和Chrome中，您必须偶尔刷新浏览器才能看到CPP源文件。与调试JavaScript不同，WebAssembly调试器感觉（讽刺地）很有bug。在Chrome中，您经常不得不多次单击步进按钮才能推进代码行。在两个浏览器中，断点有时会失效。
- en: I frequently have to remove and then re-add a break point to get them to work
    again. It is still early days for WebAssembly source maps and in-browser debugging,
    so the hope is that the situation will improve soon. Until it does, try combining
    debugging in the browser with the addition debug statements, as I advised earlier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常不得不删除然后重新添加断点才能使它们再次工作。WebAssembly源映射和浏览器调试仍处于早期阶段，因此希望情况很快会有所改善。在这之前，尝试将浏览器中的调试与添加调试语句结合使用，正如我之前建议的那样。
- en: Compiling your code for debugging
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为调试编译您的代码
- en: 'As I mentioned earlier, we will need to compile our app to support source maps
    that we can use for in-browser debugging in Firefox and Chrome. Currently, the
    only browsers that support in-browser debugging are Firefox, Chrome, and Safari.
    I will only be covering Firefox and Chrome in this book. You can compile the `debug.cpp`
    file for use with the WebAssembly debugger using the following `emcc` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们需要编译我们的应用程序以支持我们可以在Firefox和Chrome中进行浏览器调试的源映射。目前，唯一支持浏览器调试的浏览器是Firefox、Chrome和Safari。在本书中，我只会涵盖Firefox和Chrome。您可以使用以下`emcc`命令编译`debug.cpp`文件以供WebAssembly调试器使用：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first new flag is `-g4`, which instructs the compiler to have the highest
    amount of debugging data and create source map files for our WebAssembly. After
    that comes the `--source-map-base http://localhost:8080/` flag, which tells the
    compiler to add the `sourceMappingURL$http://localhost:8080/debug.wasm.map` string
    to the end of the `debug.wasm` file. This allows the browser to find the source
    map file that is associated with the `debug.wasm` file. The last two new flags
    are `-s MAIN_MODULE=1` and `-s WASM=1`. I'm not sure why either of these flags
    are required to make the source mapping work. Both of these flags are explicitly
    telling the compiler to run the default behavior. However, at the time of writing,
    if you don't include these flags, browser debugging will not work. This feels
    like a bug to me, so it is possible that by the time you are reading this, `emcc`
    will not require those final two flags. Compiling with the preceding command will
    allow you to test using the WebAssembly debugger on Chrome and Firefox. If you
    really want to debug on Opera, Edge, or some other debugger that doesn't support
    WebAssembly debugging yet, you do have an alternative.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新标志是`-g4`，它指示编译器生成最多的调试数据，并为我们的WebAssembly创建源映射文件。接下来是`--source-map-base
    http://localhost:8080/`标志，它告诉编译器将`sourceMappingURL$http://localhost:8080/debug.wasm.map`字符串添加到`debug.wasm`文件的末尾。这允许浏览器找到与`debug.wasm`文件关联的源映射文件。最后两个新标志是`-s
    MAIN_MODULE=1`和`-s WASM=1`。我不确定为什么需要这两个标志来使源映射工作。这两个标志都明确告诉编译器运行默认行为。但是，在撰写本文时，如果不包括这些标志，浏览器调试将无法工作。对我来说，这感觉像是一个错误，所以可能在您阅读本文时，`emcc`将不需要这最后两个标志。使用上述命令编译将允许您在Chrome和Firefox上使用WebAssembly调试器进行测试。如果您真的想在Opera、Edge或其他尚不支持WebAssembly调试的调试器上进行调试，您还有另一种选择。
- en: Using asm.js as an alternative for debugging
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asm.js作为调试的替代方法
- en: For whatever reason, you may feel that debugging using Edge or Opera may be
    necessary. If you feel that you must debug in a browser that doesn't have a WebAssembly
    debugger, you could compile for asm.js as an alternative. If so, change the `-s
    WASM=1` flag to `-s WASM=0`, and you will be set. This will create a JavaScript
    file instead of a WASM file, but the two files (in theory) should behave the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某种原因，您可能认为使用Edge或Opera进行调试是必要的。如果您觉得必须在没有WebAssembly调试器的浏览器中进行调试，您可以将编译目标更改为asm.js作为替代方法。如果是这样，将`-s
    WASM=1`标志更改为`-s WASM=0`，然后就可以了。这将创建一个JavaScript文件而不是WASM文件，但是这两个文件（理论上）应该表现相同。
- en: Debugging using Chrome
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chrome进行调试
- en: 'Chrome has some great tools for debugging JavaScript, but is still pretty raw
    when it comes to debugging WebAssembly. After you have built the app, open it
    up in Chrome, and then open up Chrome Developer Tools:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome有一些很好的工具用于调试JavaScript，但在调试WebAssembly方面仍然比较原始。构建应用程序后，将其在Chrome中打开，然后打开Chrome开发者工具：
- en: '![](img/1a11a945-2feb-426c-8ab0-79ce61d0d3ca.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a11a945-2feb-426c-8ab0-79ce61d0d3ca.png)'
- en: 'Figure 16.1: Screenshot of opening Chrome Developer Tools using the menu'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：使用菜单打开Chrome开发者工具的屏幕截图
- en: 'You can open it up using the menu in the top left of the browser, as seen in
    the preceding screenshot, or you can open the developer tools by pressing *Ctrl*
    + *Shift* + *I* on your keyboard. When you load up your `debug.html` file in Chrome,
    you need to click on the Sources tab in the developer window. This is what this
    should look like if you are on the Sources tab:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过浏览器左上角的菜单打开它，就像前面的屏幕截图中所示，或者您可以通过键盘上的*Ctrl* + *Shift* + *I*组合键打开开发者工具。在Chrome中加载您的`debug.html`文件时，您需要在开发者窗口中点击“源”选项卡。如果您在“源”选项卡上，应该看起来像这样：
- en: '![](img/3d5b7fd9-415c-4edb-a9f4-c2e387054c2f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5b7fd9-415c-4edb-a9f4-c2e387054c2f.png)'
- en: 'Figure 16.2: Screenshot using the sources tab in Chrome Developer Tools'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：在Chrome开发者工具中使用源选项卡的屏幕截图
- en: If you don't see `debug.cpp` in the Sources tab, you may need to click the browser's
    reload button next to the URL at the top to reload the page. As I stated earlier,
    the interface feels a little buggy, and sometimes the CPP file doesn't load on
    the first try. Hopefully, this will have changed by the time you read this. Once
    you select the CPP file, you should be able to see the C++ code from our `debug.cpp`
    file in the code window in the center of the Developer Tools window. You can set
    breakpoints in the C++ code by clicking on the line number next to the line of
    code where you would like a breakpoint. You can then step through the code using
    the buttons above the `Watch` variables. Although the watch variables don't work
    at the time of writing, you may want to try it anyway. WebAssembly is improving
    on an almost daily basis, and bug fixes are constantly happening, so by the time
    you read this, things may have changed. If not, you may use the `Local` variables
    to get some idea of what values are changing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在“源”选项卡中看不到`debug.cpp`，可能需要点击顶部URL旁边的浏览器重新加载按钮来重新加载页面。正如我之前所说，界面感觉有点小问题，有时候CPP文件第一次加载不出来。希望在你阅读这篇文章时已经改变了。一旦选择了CPP文件，你应该能够在开发者工具窗口中间的代码窗口中看到我们的`debug.cpp`文件中的C++代码。您可以通过单击代码行旁边的行号来在C++代码中设置断点。然后，您可以使用“观察”变量上方的按钮逐步执行代码。尽管在撰写本文时观察变量不起作用，但您可能还是想尝试一下。WebAssembly几乎每天都在改进，不断进行错误修复，所以在您阅读本文时，情况可能已经发生了变化。如果没有，您可以使用“本地”变量来了解一些值的变化。
- en: 'You can watch these variables get populated as you step through the source
    code, and you can frequently determine which variables are updated by watching
    these values change. Take a look at the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察这些变量在您逐步执行源代码时被填充，经常可以确定哪些变量通过观察这些值的变化而更新。看一下下面的屏幕截图：
- en: '![](img/2194af80-6559-4c96-85cf-a4aa50496525.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2194af80-6559-4c96-85cf-a4aa50496525.png)'
- en: 'Figure 16.3: Screenshot of the debug tools in the Chrome browser'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：Chrome浏览器中调试工具的屏幕截图
- en: At the time of writing, you need to click the step over button more than once
    to get the line to advance in the C++ code window. In Chrome, the step over button
    is advancing one WebAssembly instruction per click instead of one C++ instruction.
    This may have changed by the time you read this, but don't be surprised if you
    need to click step over more than once to advance through the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你需要点击“步过”按钮多次才能使C++代码窗口中的行前进。在Chrome中，“步过”按钮每次点击会前进一个WebAssembly指令，而不是一个C++指令。这可能在你阅读本文时已经改变，但如果你需要多次点击“步过”来前进代码，也不要感到惊讶。
- en: Debugging using Firefox
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firefox进行调试
- en: Firefox has a number of advantages and disadvantages compared to Chrome. On
    the plus side, you can click the step over button once in Firefox per line in
    your C++ code. On the minus side, this makes knowing which local variables are
    changing in response to the line you are executing more difficult to track. These
    `Local` variables are a little like registers in a register-based assembly language
    so that the same variable may get moved in and out of a few of them. It can be
    a little easier to follow along with the values if you have to click the button
    once per assembly instruction. However, if you are more interested in tracing
    through the flow of your code than knowing what values change for each WebAssembly
    instruction, Firefox is much better for that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox与Chrome相比有一些优势和劣势。优势是，在Firefox中，你可以在C++代码中每行点击一次“步过”按钮。劣势是，这使得跟踪响应你执行的行的本地变量更加困难。这些“本地”变量有点像寄存器，因此同一个变量可能会在几个寄存器中移动。如果你更关心跟踪代码流程而不是知道每个WebAssembly指令的值变化，那么Firefox在这方面要好得多。
- en: 'To open up your Firefox Developer Tools, click the menu button in the top right
    corner of the browser window and select Web Developer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开Firefox开发者工具，点击浏览器窗口右上角的菜单按钮，然后选择Web开发者：
- en: '![](img/571431e1-1c13-455c-9300-6d5f00ab92f2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/571431e1-1c13-455c-9300-6d5f00ab92f2.png)'
- en: 'Figure 16.4: Web Developer tools in the Firefox browser'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：Firefox浏览器中的Web开发者工具
- en: 'Once on the Web Developer menu, click the Debugger menu item to open up the
    Debugger window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发者菜单中，点击调试器菜单项打开调试器窗口：
- en: '![](img/ee20cca5-4719-4b79-8de6-4dc4ef3b5887.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee20cca5-4719-4b79-8de6-4dc4ef3b5887.png)'
- en: 'Figure 16.5: Screenshot of opening Debugger in Firefox'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：在Firefox中打开调试器的屏幕截图
- en: 'Instead of selecting the debugger through the menu system, you can use the
    shortcut keys *Ctrl* + *Shift* + *C* to open up the Inspector, and then select
    the Debugger tab from the Web Developer window. Here is what this looks like when
    you are in the Firefox Debugger:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不要通过菜单系统选择调试器，你可以使用快捷键*Ctrl* + *Shift* + *C*来打开检查器，然后从Web开发者窗口中选择调试器选项卡。当你在Firefox调试器中时，它看起来是这样的：
- en: '![](img/a40bc212-12a6-460a-b385-3262e7b75831.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a40bc212-12a6-460a-b385-3262e7b75831.png)'
- en: 'Figure 16.6: Screenshot of using Debugger in the Firefox browser'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：在Firefox浏览器中使用调试器的屏幕截图
- en: Right now, debugging will need to combine the use of debugging macros, as discussed
    in the previous section, with the ability of the browser to fully understand what
    is going on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，调试将需要结合使用调试宏和浏览器完全理解正在发生的情况。
- en: Firefox Developer Edition
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firefox开发者版
- en: 'I am briefly going to mention the Firefox Developer Edition. If you prefer
    to use Firefox as your primary WebAssembly development browser, you may want to
    consider using Firefox Developer Edition. The Developer Edition pushes forward
    updates to the web developer tools faster than the standard version of Firefox.
    Because WebAssembly is so new, updates that improve the development experience
    are likely to show up in the Developer Edition weeks or months earlier than they
    will become available in the standard version. At the time of writing, there is
    no significant difference between the two versions, but if you are interested
    in trying it out, it is available at the following web address: [https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我简要提一下Firefox开发者版。如果你喜欢将Firefox作为你的主要WebAssembly开发浏览器，你可能会考虑使用Firefox开发者版。开发者版比标准版的Firefox更快地推出更新的Web开发者工具。因为WebAssembly是如此新颖，改进开发体验的更新可能会比标准版提前几周甚至几个月出现在开发者版中。在撰写本文时，两个版本之间没有显著差异，但如果你有兴趣尝试，可以在以下网址找到：[https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/)。
- en: Optimizing for WebAssembly
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为WebAssembly进行优化
- en: Optimizing your WebAssembly code is partially about decision making and experimenting.
    It is about discovering what works for your particular game or app. When WebAssembly
    was designed, for instance, a decision was made to have the WebAssembly bytecode
    run on a virtual stack machine. The designers of WebAssembly made this choice
    because they felt that they could justify the small loss of performance with a
    significantly smaller bytecode download size. Every piece of code has a bottleneck
    somewhere. In OpenGL applications that bottleneck will be interfacing with the
    GPU. The bottleneck for your application may be the memory, or it may be CPU-bound.
    Optimizing code, in general, is about determining what the holdup is and deciding
    what trade-off you would like to make to improve things. If you optimize for download
    size, you may lose some runtime performance. If you optimize for runtime performance,
    you may have to increase your memory footprint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 优化你的WebAssembly代码部分取决于决策和实验。它是关于发现对你的特定游戏或应用有效的方法。例如，当设计WebAssembly时，决定让WebAssembly字节码在虚拟堆栈机上运行。WebAssembly的设计者做出了这个选择，因为他们认为可以通过显著减小字节码下载大小来证明性能的小损失。每段代码都有瓶颈。在OpenGL应用程序中，瓶颈将是与GPU的接口。你的应用程序的瓶颈可能是内存，也可能是CPU限制。一般来说，优化代码是关于确定瓶颈在哪里，并决定你想要做出什么权衡来改进事情。如果你优化下载大小，你可能会失去一些运行时性能。如果你优化运行时性能，你可能需要增加内存占用。
- en: Optimization flags
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化标志
- en: Emscripten provides us with a large selection of flags to optimize for different
    potential bottlenecks. All of the optimization flags will result in varying degrees
    of longer compile times, so using any of these flags should come late in the development
    cycle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten为我们提供了大量的标志，以优化不同的潜在瓶颈。所有的优化标志都会导致不同程度的较长编译时间，因此在开发周期的后期才应该使用这些标志。
- en: Optimizing for performance
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化性能
- en: We can use the `-O` flags for general optimization. `-O0`, `-O1`, `-O2`, and
    `-O3` provide different levels of trade-off between compile time and code performance.
    The `-O0` and `-O1` flags provide minimal optimization. The `-O2` flag offers
    most of the optimization you get from the `-O3` flag, but with significantly shorter
    compile times. Finally, `-O3` provides the highest level of optimization, but
    takes substantially longer than any other flag to compile, so it is a good idea
    to wait until you are nearing the end of development to begin using it. In addition
    to the `-O` flags, `-s AGGRESSIVE_VARIABLE_ELIMINATION=1` can be used to increase
    performance, but may result in larger bytecode download sizes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-O`标志进行一般优化。`-O0`、`-O1`、`-O2`和`-O3`提供了不同级别的编译时间和代码性能之间的权衡。`-O0`和`-O1`标志提供了最小的优化。`-O2`标志提供了大部分来自`-O3`标志的优化，但编译时间明显更短。最后，`-O3`提供了最高级别的优化，但编译时间比任何其他标志都要长得多，因此最好在接近开发结束时开始使用它。除了`-O`标志，`-s
    AGGRESSIVE_VARIABLE_ELIMINATION=1`也可以用于增加性能，但可能会导致更大的字节码下载大小。
- en: Optimizing for size
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化大小
- en: There are two other `-O` flags that I didn't mention in the preceding section.
    Those flags are used to optimize for bytecode download size instead of purely
    optimizing for performance. The `-Os` flag takes about as long as `-O3`, and provides
    as much performance optimization as it can, but sacrifices some of the `-O3` optimizations
    in favor of smaller download sizes. `-Oz` is like `-Os`, but prioritizes smaller
    download sizes even further by sacrificing even more performance optimization,
    which results in smaller bytecode. Another way to optimize for size is to include
    the `-s ENVIRONMENT='web'` flag. You should only use this flag if you are compiling
    for the web. It removes any source code that is used to support other environments,
    such as Node.js.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中我没有提到另外两个`-O`标志。这些标志用于优化字节码下载大小，而不是纯粹地优化性能。`-Os`标志所花费的时间大约和`-O3`一样长，并提供尽可能多的性能优化，但是为了更小的下载大小而牺牲了一些`-O3`的优化。`-Oz`类似于`-Os`，但通过牺牲更多的性能优化来进一步优化更小的下载大小，从而导致更小的字节码。另一种优化大小的方法是包括`-s
    ENVIRONMENT='web'`标志。只有在编译网页时才应该使用这个标志。它会删除用于支持其他环境（如Node.js）的任何源代码。
- en: Unsafe flags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的标志
- en: In addition to the safe optimization flags we have been using up until this
    point, Emscripten also allows for two *unsafe* flags that can improve performance,
    but come at the risk of potentially breaking your code. These flags are high risk/high
    reward optimizations that you should only use before the bulk of testing is complete.
    Using the `--closure 1` flag runs the Closure JavaScript compiler, which performs
    very aggressive optimization on the JavaScript in our app. However, you shouldn't
    use the `--closure 1` flag unless you are already familiar with using the closure
    compiler and the effects that compiler could have on JavaScript. The second *unsafe*
    flag is the `--llvm-lto 1` flag, which enables *Link Time Optimization* during
    the LLVM compile step. This process can break your code, so take extreme care
    when using this flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们到目前为止一直在使用的安全优化标志之外，Emscripten还允许使用两个*不安全*标志来提高性能，但可能会破坏您的代码。这些标志是高风险/高回报的优化，只有在大部分测试完成之前才应该使用。使用`--closure
    1`标志会运行Closure JavaScript编译器，它会对我们应用程序中的JavaScript进行非常激进的优化。但是，除非您已经熟悉使用闭包编译器以及该编译器可能对JavaScript产生的影响，否则不应该使用`--closure
    1`标志。第二个*不安全*标志是`--llvm-lto 1`标志，它在LLVM编译步骤中启用*链接时优化*。这个过程可能会破坏您的代码，因此在使用这个标志时要非常小心。
- en: Profiling
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: Profiling is the best way to determine what bottlenecks exist in your source
    code. When you are profiling WebAssembly modules, I recommend that you use the
    `--profiling` flag when compiling. You can profile without it, but all of the
    module functions you call will be labeled `wasm-function`, which can make your
    life more difficult than it needs to be. After compiling your code with the `--profile`
    flag, open up a new *Incognito* window in Chrome.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是确定源代码中存在的瓶颈的最佳方法。当您对WebAssembly模块进行分析时，我建议在编译时使用`--profiling`标志。您也可以不使用它进行分析，但是您调用的所有模块函数都将被标记为`wasm-function`，这可能会使您的生活比必要的更加困难。在使用`--profile`标志编译代码后，在Chrome中打开一个新的*隐身*窗口。
- en: 'You can do this by either pressing the *CTRL + SHIFT + N* keys, or through
    the menu in the top right corner of the browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按下*CTRL + SHIFT + N*键，或者通过浏览器右上角的菜单来执行此操作：
- en: '![](img/1b6fc82e-f25b-4487-87b5-2632a5b32714.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b6fc82e-f25b-4487-87b5-2632a5b32714.png)'
- en: 'Figure 16.7: Opening an Incognito window in the Chrome browser'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：在Chrome浏览器中打开隐身窗口
- en: 'Opening an Incognito window will prevent any Chrome extensions from running
    when profiling your app. This will prevent you from having to wade through the
    code in those extensions to get to the code in your app. Once you have opened
    an Incognito window, press *Ctrl* + *Shift* + *I* to inspect the page. This will
    open up Chrome Developer Tools at the bottom of the browser window. Inside Chrome
    Developer Tools, select the Performance tab, as you can see in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开隐身窗口时，将阻止任何Chrome扩展在分析您的应用程序时运行。这将防止您不得不浏览这些扩展中的代码以找到您应用程序中的代码。打开隐身窗口后，按下*Ctrl*
    + *Shift* + *I*来检查页面。这将在浏览器窗口底部打开Chrome开发者工具。在Chrome开发者工具中，选择性能选项卡，如下面的截图所示：
- en: '![](img/ed201a26-d861-4f07-91b7-29d544bc9195.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed201a26-d861-4f07-91b7-29d544bc9195.png)'
- en: 'Figure 16.8: The Performance tab in the Chrome browser'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：Chrome浏览器中的性能选项卡
- en: 'Now, click the Record button and let it run for a few seconds. After you have
    recorded for five or six seconds, click the Stop button to stop profiling:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击记录按钮，让它运行几秒钟。记录了五六秒钟后，点击停止按钮停止分析：
- en: '![](img/f360963f-d7da-48ee-b60c-4e69981c71d9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f360963f-d7da-48ee-b60c-4e69981c71d9.png)'
- en: 'Figure 16.9: Screenshot of recording performance metrics in the Chrome browser'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：Chrome浏览器中性能指标的录制屏幕截图
- en: After you stop profiling, you will see data within the performance window. This
    is called the Summary tab, and displays data in the form of a pie chart that breaks
    down the number of milliseconds your app is spending on various tasks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 停止分析后，您将在性能窗口中看到数据。这称为摘要选项卡，并以饼图的形式显示应用程序在各种任务上花费的毫秒数。
- en: 'As you can see, the vast majority of the time, our app is idle:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的应用程序绝大部分时间都是空闲的：
- en: '![](img/d8fea306-0daa-4c78-a71c-a1b49c4397cf.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8fea306-0daa-4c78-a71c-a1b49c4397cf.png)'
- en: 'Figure 16.10: Performance overview in the Chrome browser'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：Chrome浏览器中的性能概述
- en: The summary is interesting. It can tell you where your bottleneck is on a very
    high level, but to evaluate our WebAssembly, we will need to look in the Call
    Tree tab. Click on the Call Tree tab, and you will see the following window:￼
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要很有趣。它可以告诉您在非常高的层次上瓶颈在哪里，但要评估我们的WebAssembly，我们需要查看调用树选项卡。点击调用树选项卡，您将看到以下窗口：￼
- en: '![](img/e3aa8cd8-4542-4c9e-bc91-70ecf0f28220.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3aa8cd8-4542-4c9e-bc91-70ecf0f28220.png)'
- en: 'Figure 16.11: Screenshot of the Call Tree in the Chrome browser'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：Chrome浏览器中的调用树屏幕截图
- en: Because our `game_loop` function is being called every frame, we can find the
    call inside the `Animation Frame Fired` tree. Drill down, looking for `game_loop`.
    When we find the function, it is mangled because it is a C++ function. So, instead
    of seeing `_game_loop`, we see `_Z9game_loopv`, although you may see something
    mangled differently. If you would like to prevent this mangling, you can wrap
    this function in an `extern "C"` block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`game_loop`函数在每一帧都被调用，所以我们可以在`Animation Frame Fired`树中找到这个调用。向下钻取，寻找`game_loop`。当我们找到这个函数时，它被搞乱了，因为它是一个C++函数。所以，我们看到的不是`_game_loop`，而是`_Z9game_loopv`，尽管你可能看到的搞乱的形式不同。如果你想要防止这种搞乱，你可以将这个函数包装在一个`extern
    "C"`块中。
- en: You can see that the execution of this function took a total of 3.2% of the
    browser's CPU time. You can also look at each of the OpenGL calls from within
    this function. If you take a look at our game loop, more than half of the CPU
    time is spent in `_glClear`. This is not a problem for this application, because
    the vast majority of the browser CPU time is spent idle. If, however, our game
    loop function was taking up a large percentage of the CPU time, we would need
    to see where in that function we were spending it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个函数的执行总共占据了浏览器CPU时间的3.2%。您还可以查看这个函数中的每个OpenGL调用。如果您看一下我们的游戏循环，超过一半的CPU时间都花在了`_glClear`上。对于这个应用程序来说，这不是问题，因为绝大多数的浏览器CPU时间都是空闲的。然而，如果我们的游戏循环函数占用了大部分CPU时间，我们就需要看看在这个函数中我们花费了多少时间。
- en: Problems with try/catch blocks
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try/catch块的问题
- en: At the time of writing, try/catch blocks are known to cause significant performance
    issues in WebAssembly modules, so only use them if they're absolutely necessary.
    You may want to use them during the development phase, and remove them when building
    for release. Some of the `-O` optimization flags will remove try/catch blocks,
    which you need to be aware of if you plan on using them in production. If you
    want to use try/catch blocks in your production build, you will need to compile
    using the `-s DISABLE_EXCEPTION_CATCHING=0` flag. This will tell the compiler
    not to remove the try/catch blocks from the optimized version of your bytecode.
    If you would like to remove your try/catch blocks from unoptimized development
    code, you can do so by using the `-s DISABLE_EXCEPTION_CATCHING=1` flag.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，已知try/catch块会导致WebAssembly模块的显著性能问题，因此只有在绝对必要时才使用它们。您可能希望在开发阶段使用它们，并在发布时将它们移除。一些`-O`优化标志将删除try/catch块，如果您打算在生产中使用它们，您需要注意这一点。如果您想在生产版本中使用try/catch块，您需要使用`-s
    DISABLE_EXCEPTION_CATCHING=0`标志进行编译。这将告诉编译器不要从优化版本的字节码中删除try/catch块。如果您想从未优化的开发代码中删除try/catch块，您可以使用`-s
    DISABLE_EXCEPTION_CATCHING=1`标志。
- en: Optimizing OpenGL for WebAssembly
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为WebAssembly优化OpenGL
- en: It is important to remember that any calls to OpenGL from WebAssembly are calling
    WebGL using a function table. Part of the reason this is important is because
    any time you use OpenGL ES and OpenGL functionality that is not available in WebGL,
    Emscripten must perform some very slow software emulation on those functions.
    It is also important to remember that WebGL calls are more expensive than OpenGL
    calls on a native platform because WebGL is sandboxed, and various security checks
    are performed by the browser when it calls WebGL. Emscripten provides you with
    several flags that allow you to emulate OpenGL and OpenGL ES calls that are not
    available in WebGL. For performance reasons, however do not use these functions
    unless you absolutely have to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，从WebAssembly调用OpenGL时都是通过函数表调用WebGL的。这很重要的部分原因是因为每当您使用OpenGL ES和WebGL不可用的OpenGL功能时，Emscripten必须对这些功能进行一些非常慢的软件模拟。还要记住，WebGL调用比本地平台上的OpenGL调用更昂贵，因为WebGL是受沙箱保护的，浏览器在调用WebGL时会执行各种安全检查。Emscripten为您提供了几个标志，允许您模拟WebGL中不可用的OpenGL和OpenGL
    ES调用。然而出于性能原因，除非绝对必要，不要使用这些功能。
- en: Using WebGL 2.0 if possible
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽可能使用WebGL 2.0
- en: WebGL 2.0 is faster than WebGL 1.0, but, at the time of writing, it is supported
    on far fewer browsers. Just compiling your WebGL 1.0 code to WebGL 2.0 will give
    you about a 7% performance improvement. However, before you choose to do this,
    you may want to consult [https://caniuse.com/#search=webgl2](https://caniuse.com/#search=webgl2)
    to see whether the browsers you are targeting support WebGL 2.0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2.0比WebGL 1.0更快，但在撰写本文时，支持它的浏览器要少得多。将您的WebGL 1.0代码编译为WebGL 2.0将使您获得约7%的性能提升。但是，在选择这样做之前，您可能希望参考[https://caniuse.com/#search=webgl2](https://caniuse.com/#search=webgl2)来查看您的目标浏览器是否支持WebGL
    2.0。
- en: Minimizing the number of OpenGL calls
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化OpenGL调用次数
- en: Calls to OpenGL from WebAssembly are not as fast as those same calls from a
    natively compiled application. A call to OpenGL from WebAssembly is making a call
    to a WebGL analog. WebGL was built to execute inside a web browser and performs
    some security checks to verify that we are not asking WebGL to do anything malicious.
    This means that we must account for that additional overhead when writing OpenGL
    that's targeting WebAssembly. There are cases where two or three calls to OpenGL
    for a native application would be faster than combining those calls into a single
    OpenGL call. However, that same code in WebAssembly might run faster if you condensed
    it into a single call to OpenGL. When optimizing for WebAssembly, try doing what
    you can to minimize the number of OpenGL calls, and use your profiler to verify
    that the new code is faster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从WebAssembly调用OpenGL不像从本机编译的应用程序中进行相同调用那样快。从WebAssembly调用OpenGL相当于调用WebGL的模拟。WebGL是为在Web浏览器中执行而构建的，并执行一些安全检查以验证我们没有要求WebGL执行任何恶意操作。这意味着在编写针对WebAssembly的OpenGL时，我们必须考虑到额外的开销。有些情况下，本机应用程序对OpenGL的两三次调用可能比将这些调用合并为单个OpenGL调用更快。然而，在WebAssembly中，将相同的代码压缩为单个OpenGL调用可能会更快。在优化WebAssembly时，尽量减少OpenGL调用，并使用分析器验证新代码是否更快。
- en: Emscripten OpenGL flags
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten OpenGL标志
- en: Several Emscripten linker flags can have a significant effect on performance.
    Some of the flags were created to ease porting of code to WebAssembly, but have
    the potential to create performance problems. Others can improve performance under
    the right conditions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 几个Emscripten链接器标志可能会对性能产生重大影响。其中一些标志是为了简化代码移植到WebAssembly，但可能会导致性能问题。其他标志在适当条件下可以提高性能。
- en: The `-s FULL_ES2=1` and `-s FULL_ES3=1` linker flags emulate the entire OpenGL
    ES 2.0/3.0 API. As I mentioned earlier, by default, the OpenGL ES 2/3 implementations
    in WebAssembly only support subsets of OpenGL ES 2/3 that are compatible with
    WebGL. This is because WebGL is doing the rendering in WebAssembly. There may
    be a reason why you absolutely need a feature of OpenGL ES 2/3 that is not available
    by default. If so, you can use the `-s FULL_ES2=1` or `-s FULL_ES3=1` flags to
    emulate that feature in the software. This will come at a price when it comes
    to performance, so take that into consideration if you decide to use it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s FULL_ES2=1`和`-s FULL_ES3=1`链接器标志模拟整个OpenGL ES 2.0/3.0 API。正如我之前提到的，默认情况下，WebAssembly中的OpenGL
    ES 2/3实现仅支持与WebGL兼容的OpenGL ES 2/3的子集。这是因为WebGL在WebAssembly中进行渲染。您可能绝对需要OpenGL
    ES 2/3的某个默认不可用的功能。如果是这样，您可以使用`-s FULL_ES2=1`或`-s FULL_ES3=1`标志在软件中模拟该功能。这将会影响性能，因此在决定使用时要考虑这一点。'
- en: The `-s LEGACY_GL_EMULATION=1` flag is used to emulate old versions of OpenGL
    that use the fixed function pipeline. It is also not recommended that you use
    this flag because of the poor performance that will result. This flag exists for
    people who are looking to port old code to WebAssembly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s LEGACY_GL_EMULATION=1`标志用于模拟使用固定功能管线的旧版本OpenGL。也不建议使用此标志，因为会导致性能不佳。这个标志是为那些希望将旧代码移植到WebAssembly的人准备的。'
- en: If you want to use WebGL 2 to gain the performance increase associated with
    it, use the `-s USE_WEBGL2=1` linker flag. If you have code that was written for
    WebGL 1.0, but would like the performance gains of WebGL 2.0, you can try compiling
    to WebGL 2.0 to see whether you used any code that was not backward compatible
    in WebGL 2.0\. If it doesn't compile with this flag, you can try the `-s WEBGL2_BACKWARDS_COMPATIBILITY_EMULATION=1`
    linker flag, which will allow you to compile your WebGL 1.0 code so that you can
    use it in WebGL 2.0.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用WebGL 2来获得与之相关的性能提升，请使用`-s USE_WEBGL2=1`链接器标志。如果您有为WebGL 1.0编写的代码，但想要获得WebGL
    2.0的性能提升，您可以尝试编译为WebGL 2.0，以查看您是否使用了在WebGL 2.0中不向后兼容的任何代码。如果使用此标志无法编译，则可以尝试`-s
    WEBGL2_BACKWARDS_COMPATIBILITY_EMULATION=1`链接器标志，这将允许您编译您的WebGL 1.0代码，以便您可以在WebGL
    2.0中使用它。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about different strategies we can use to debug and
    optimize our WebAssembly code. We discussed writing C macros, which allow us to
    easily remove calls to print to the console when we move from development into
    production. We talked about source maps, what they are, and how they can help
    us to debug our WebAssembly code from within a browser. We discussed using the
    debugger in both Chrome and Firefox to step through WebAssembly's source code.
    Finally, we discussed optimization in WebAssembly, what compiler options are available
    in Emscripten, and how we can go about improving our WebGL performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同的策略，可以用来调试和优化我们的WebAssembly代码。我们讨论了编写C宏，它们可以让我们在从开发转入生产时轻松地删除对控制台的打印调用。我们谈到了源映射，它们是什么，以及它们如何帮助我们在浏览器中调试我们的WebAssembly代码。我们讨论了如何在Chrome和Firefox中使用调试器来逐步执行WebAssembly的源代码。最后，我们讨论了WebAssembly中的优化，Emscripten中可用的编译器选项，以及我们如何改进WebGL性能。
- en: This is the end
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这就是结尾
- en: 'Congratulations! You should be well on your way to developing your own games
    or apps in WebAssembly. I hope that you enjoyed learning how we can use WebGL
    to build games for the web. If you have any questions, comments, or would just
    like to say hi, you can find me on the following platforms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您应该已经在开发自己的WebAssembly游戏或应用程序的路上了。我希望您喜欢学习如何使用WebGL来构建Web游戏。如果您有任何问题、评论或只是想打个招呼，您可以在以下平台找到我：
- en: '**Twitter**: [https://twitter.com/battagline](https://twitter.com/battagline)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推特**: [https://twitter.com/battagline](https://twitter.com/battagline)'
- en: '**LinkedIn**: [https://www.linkedin.com/in/battagline/](https://www.linkedin.com/in/battagline/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领英**: [https://www.linkedin.com/in/battagline/](https://www.linkedin.com/in/battagline/)'
- en: '**YouTube**: [https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ](https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YouTube**: [https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ](https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ)'
