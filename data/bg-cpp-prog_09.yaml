- en: Using Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串
- en: At some point your application will need to communicate with people, and that
    means using text; such as outputting text, taking in data as text, and then converting
    that data to appropriate types. The C++ Standard Library has a rich collection
    of classes to manipulate strings, convert between strings and numbers, and to
    obtain string values localized for specified languages and cultures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您的应用程序将需要与人们交流，这意味着使用文本；例如输出文本，以文本形式接收数据，然后将该数据转换为适当的类型。C++标准库具有丰富的类集合，用于操作字符串，字符串和数字之间的转换，并获取特定语言和文化的本地化字符串值。
- en: Using the string class as a container
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串类作为容器
- en: 'C++ strings are based on the `basic_string` template class. This class is a
    container, so it uses iterator access and methods to obtain information, and has
    template parameters that contain information about the character type it holds.
    There are different `typedef` for specific character types:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++字符串基于`basic_string`模板类。该类是一个容器，因此它使用迭代器访问和方法来获取信息，并且具有包含有关其保存的字符类型的信息的模板参数。有不同的特定字符类型的`typedef`：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `string` class is based on `char`, `wstring` is based on `wchar_t` wide
    characters, and the `16string` and `u32string` classes are based upon 16-bit and
    32-bit characters, respectively. For the rest of the chapter, we will concentrate
    on just the `string` class, but it equally applies to the other classes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类基于`char`，`wstring`基于`wchar_t`宽字符，`16string`和`u32string`类分别基于16位和32位字符。在本章的其余部分，我们将集中讨论`string`类，但同样适用于其他类。'
- en: Comparing, copying, and accessing characters in a string will require a different
    code for the different-sized characters, while the traits template parameter provides
    the implementations. For `string`, this is the `char_traits` class. When this
    class, for example, copies characters, it will delegate this action to the `char_traits`
    class and its `copy` method. The traits classes are also used by stream classes,
    so they also define an end of file value that is appropriate to the file stream.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 比较，复制和访问字符串中的字符将需要不同大小字符的不同代码，而特性模板参数提供了实现。对于`string`，这是`char_traits`类。例如，当此类复制字符时，它将将此操作委托给`char_traits`类及其`copy`方法。特性类也被流类使用，因此它们还定义了适合文件流的文件结束值。
- en: 'A string is essentially an array of zero or more characters that allocates
    memory when it is needed and deallocates it when a `string` object is destroyed.
    In some respects, it is very similar to a `vector<char>` object. As a container,
    the `string` class gives iterator access through the `begin` and `end` methods:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串本质上是一个零个或多个字符的数组，当需要时分配内存，并在`string`对象被销毁时释放它。在某些方面，它与`vector<char>`对象非常相似。作为容器，`string`类通过`begin`和`end`方法提供迭代器访问：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the `begin` and `end` methods are called to get iterators from the items
    in the `string,` which are passed to the `copy` function from `<algorithm>` to
    copy each character to the console via the `ostream_iterator` temporary object.
    In this respect, the `string` object is similar to a `vector`, so we use the previously
    defined `s` object:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用`begin`和`end`方法以从`string`中的项目获取迭代器，然后将它们传递给`<algorithm>`中的`copy`函数，以通过`ostream_iterator`临时对象将每个字符复制到控制台。在这方面，`string`对象类似于`vector`，因此我们使用先前定义的`s`对象：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This fills the `vector` object using the range of characters provided using
    the `begin` and `end` methods on the `string` object and then prints those characters
    to the console using the `copy` function in exactly the same way as we used previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`string`对象上的`begin`和`end`方法填充`vector`对象，然后使用`copy`函数将这些字符以与之前相同的方式打印到控制台。
- en: Getting information about a string
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取有关字符串的信息
- en: The `max_size` method will give the maximum size of the string of the specified
    character type on your computer architecture and this can be surprisingly large.
    For example, on a 64-bit Windows computer with 2 GB of memory, `max_size` for
    a `string` object will return 4 billion characters, and for a `wstring` object
    the method will return 2 billion characters. This is clearly more than the memory
    in the machine! The other size methods return more meaningful values. The `length`
    method returns the same value as the `size` method, that is, how many items (characters)
    there are in the string. The `capacity` method indicates how much memory is already
    allocated for the string in terms of the number of characters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_size`方法将返回计算机架构上指定字符类型的字符串的最大大小，这可能非常大。例如，在具有2GB内存的64位Windows计算机上，`string`对象的`max_size`将返回40亿个字符，而`wstring`对象的方法将返回20亿个字符。这显然超过了机器上的内存！其他大小方法返回更有意义的值。`length`方法返回与`size`方法相同的值，即字符串中有多少项（字符）。`capacity`方法指示已分配多少内存用于字符串，以字符数表示。'
- en: You can compare a `string` with another by calling its `compare` method. This
    returns an `int` and not a `bool` (but note that an `int` can be converted silently
    to a `bool`), where a return value of `0` means that the two strings are the same.
    If they are not the same, this method returns a negative value if the parameter
    string is greater that the operand string, or a positive value if the parameter
    is less than the operand string. In this respect *greater* and *less than* will
    test the ordering of the strings alphabetically. In addition, there are global
    operators defined for `<`, `<=`, `==`, `>=`, and `>` to compare string objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用其`compare`方法将一个`string`与另一个进行比较。这将返回一个`int`而不是`bool`（但请注意，`int`可以被静默转换为`bool`），其中返回值为`0`表示两个字符串相同。如果它们不相同，此方法将返回负值，如果参数字符串大于操作数字符串，则返回负值，如果参数小于操作数字符串，则返回正值。在这方面，*大于*和*小于*将按字母顺序测试字符串的排序。此外，还为`<`，`<=`，`==`，`>=`和`>`定义了全局运算符，以比较字符串对象。
- en: A `string` object can be used like a C string through the `c_str` method. The
    pointer returned is `const`; you should be aware that the pointer may be invalidated
    if the `string` object is changed, so you should not store this pointer. You should
    not use `&str[0]` to get a C string pointer for the C++ string `str` because the
    internal buffer used by the string classes is not guaranteed to be `NUL` terminated.
    The `c_str` method is provided to return a pointer that *can* be used as a C string,
    and hence `NUL` terminated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`对象可以通过`c_str`方法像C字符串一样使用。返回的指针是`const`；您应该注意，如果更改了`string`对象，指针可能会失效，因此不应存储此指针。您不应该使用`&str[0]`来获取C++字符串`str`的C字符串指针，因为字符串类使用的内部缓冲区不能保证是`NUL`终止的。`c_str`方法用于返回一个可以用作C字符串的指针，因此是`NUL`终止的。'
- en: If you want to copy data from the C++ string to a C buffer you can call the
    `copy` method. You pass the destination pointer and the number of characters to
    copy as parameters (and optionally an offset) and the method will attempt to copy,
    at most, the specified number of characters to the destination buffer: *but without
    a null termination character*. This method assumes that the destination buffer
    is big enough to hold the copied characters (and you should take steps to ensure
    this). If you want to pass the size of the buffer so that the method performs
    this check for you, call the `_Copy_s` method instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将数据从C++字符串复制到C缓冲区，可以调用`copy`方法。您将目标指针和要复制的字符数作为参数传递（以及可选的偏移量），该方法将尝试将最多指定数量的字符复制到目标缓冲区：*但不包括空终止字符*。此方法假定目标缓冲区足够大，可以容纳复制的字符（您应该采取措施来确保这一点）。如果要传递缓冲区的大小，以便该方法为您执行此检查，请调用`_Copy_s`方法。
- en: Altering strings
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改字符串
- en: 'The string classes have standard container access methods, so you can access
    individual characters through a reference (read and write access) with the `at`
    method and `[]` operator. You can replace the entire string using the `assign`
    method, or swap the contents of two string objects with the `swap` method. Further,
    you can insert characters in specified places with the `insert` method, remove
    specified characters with the `erase` method, and remove all characters with the
    `clear` method. The class also allows you to push characters to the end of the
    string (and remove the last character) with the `push_back` and `pop_back` methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类具有标准的容器访问方法，因此您可以通过引用（读写访问）使用`at`方法和`[]`运算符访问单个字符。您可以使用`assign`方法替换整个字符串，或者使用`swap`方法交换两个字符串对象的内容。此外，您可以使用`insert`方法在指定位置插入字符，使用`erase`方法删除指定字符，使用`clear`方法删除所有字符。该类还允许您使用`push_back`和`pop_back`方法将字符推送到字符串的末尾（并删除最后一个字符）：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can add one or more characters to the end of a string using the `append`
    method or the `+=` operator:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`append`方法或`+=`运算符向字符串的末尾添加一个或多个字符：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `<string>` library also defines a global `+` operator that will concatenate
    two strings in a third string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`<string>`库还定义了一个全局`+`运算符，用于将两个字符串连接成第三个字符串。'
- en: 'If you want to change characters in a string you can access the character through
    an index with the `[]` operator, using the reference to overwrite the character.
    You can also use the `replace` method to replace one or more characters at a specified
    position with characters from a C string or from a C++ string, or some other container
    accessed through iterators:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改字符串中的字符，可以使用`[]`运算符通过索引访问字符，并使用引用覆盖字符。您还可以使用`replace`方法在指定位置用来自C字符串或C++字符串的字符替换一个或多个字符，或者使用通过迭代器访问的其他容器：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, you can extract part of a string as a new string. The `substr` method
    takes an offset and an optional count. If the count of characters is omitted,
    then the substring will be from the specified position until the end of the string.
    This means that you can copy a left-hand part of a string by passing an offset
    of 0 and a count that is less than the size of the string, or you can copy a right-hand
    part of the string by passing just the index of the first character.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将字符串的一部分提取为一个新的字符串。`substr`方法接受一个偏移量和一个可选的计数。如果省略了字符的计数，则子字符串将从指定位置到字符串的末尾。这意味着您可以通过传递偏移量为0和小于字符串大小的计数来复制字符串的左侧部分，或者通过仅传递第一个字符的索引来复制字符串的右侧部分。
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code, the first example copies the first three characters into a new
    string. In the second example, the copying starts at the eighth character and
    continues to the end.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，第一个示例将前三个字符复制到一个新字符串中。在第二个示例中，复制从第八个字符开始，一直到末尾。
- en: Searching strings
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索字符串
- en: The `find` method is passed using either a character, a C string, or a C++ string,
    and you can provide an initial search position to start the search. The `find`
    method returns the position (rather than an iterator) to where the search text
    was located, or a value of `npos` if the text cannot be found. The offset parameter,
    and a successful return value from the `find` method, enables you to parse a string
    repeatedly to find specific items. The `find` method searches for the specified
    text in the forward direction, and there is also an `rfind` method that performs
    the search in the reverse direction.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法可以使用字符、C字符串或C++字符串，并且可以提供初始搜索位置来开始搜索。`find`方法返回搜索文本所在的位置（而不是迭代器），如果找不到文本，则返回`npos`值。偏移参数和`find`方法的成功返回值使您能够重复解析字符串以查找特定项。`find`方法在正向方向搜索指定的文本，还有一个`rfind`方法可以在反向方向进行搜索。'
- en: Note that `rfind` is not the complete opposite of the `find` method. The `find`
    method moves the search point forward in the string and at each point compares
    the search string with the characters from the search point forwards (so the first
    search text character, then the second, and so on). The `rfind` method moves the
    search point *backwards*, but the comparisons are still made *forwards*. So, assuming
    the `rfind` method is not given an offset, the first comparison will be made at
    an offset from the end of the string the size of the search text. Then, the comparison
    is made by comparing the first character in the search text with the character
    at the search point in the searched string, and if this succeeds, the second character
    in the search text is compared with the character after the search point. So,
    the comparisons are made in a direction opposite to the direction of the movement
    of the search point.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`rfind`并不是`find`方法的完全相反。`find`方法在字符串中向前移动搜索点，并在每个点上将搜索字符串与从搜索点向前的字符进行比较（因此首先是搜索文本字符，然后是第二个字符，依此类推）。`rfind`方法将搜索点向*后*移动，但比较仍然是*向前*进行的。因此，假设`rfind`方法没有给出偏移量，第一次比较将在字符串末尾的偏移量处进行，大小为搜索文本的大小。然后，通过将搜索文本中的第一个字符与搜索字符串中搜索点后面的字符进行比较来进行比较，如果成功，则将搜索文本中的第二个字符与搜索点之后的字符进行比较。因此，比较是沿着搜索点移动方向的相反方向进行的。
- en: This becomes important because if you want to parse a string using the return
    value from the `find` method as an offset, after each search you should move the
    search offset *forwards**, *and for `rfind` you should move it *backwards*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得重要，因为如果你想使用`find`方法的返回值作为偏移量来解析字符串，在每次搜索后，你应该将搜索偏移量*向前*移动，对于`rfind`，你应该将其向*后*移动。
- en: 'For example, to search for all the positions of `the` in the following string,
    you can call:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在以下字符串中搜索`the`的所有位置，可以调用：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will find the search text at the character positions of 3, 9, and 15\.
    To search the string backwards, you could call:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在字符位置3、9和15找到搜索文本。要向后搜索字符串，可以调用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The highlighted code shows the changes that should be made, showing you that
    you need to search from the end and use the `rfind` method. When you have a successful
    result you need to decrement the position before the next search. Like the `find`
    method, the `rfind` method returns `npos` if it cannot find the search text.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的代码显示了应该进行的更改，告诉你需要从末尾开始搜索并使用`rfind`方法。当你有一个成功的结果时，你需要在下一次搜索之前减少位置。与`find`方法一样，如果无法找到搜索文本，`rfind`方法将返回`npos`。
- en: 'There are four methods that allow you to search for one of several individual
    characters. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法允许你搜索几个单独的字符中的一个。例如：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The search string is `eh` and the `find_first_of` will return when it finds
    either the character `e` or `h` in the string. In this example, the character
    `h` is found first at position 4\. You can provide an offset parameter to start
    the search, so you can use the return value from `find_first_of` to parse through
    a string. The `find_last_of` method is similar, but it searches the string in
    the reverse direction for one of the characters in the search text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索字符串是`eh`，`find_first_of`将在字符串中找到`e`或`h`字符时返回。在这个例子中，字符`h`首先在位置4被找到。你可以提供一个偏移参数来开始搜索，因此你可以使用`find_first_of`的返回值来解析字符串。`find_last_of`方法类似，但它以相反的方向搜索搜索文本中的一个字符。
- en: 'There are also two search methods that will look for a character *other than*
    the characters provided in the search text: `find_first_not_of` and `find_last_not_of`.
    For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种搜索方法，它们将寻找搜索文本中提供的字符*之外*的字符：`find_first_not_of`和`find_last_not_of`。例如：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code looks for a character other than a digit and so it finds the `t` at
    position 3 (the fourth character).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码寻找的是除数字以外的字符，所以它在位置3（第四个字符）找到了`t`。
- en: There is no library function to trim whitespace from a `string`, but you can
    trim spaces on the left and right of strings by using the find functions to find
    non-whitespace and then use this as an appropriate index for the `substr` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有库函数可以从`string`中修剪空白，但你可以通过使用查找函数来查找非空白字符，然后将其作为`substr`方法的适当索引来修剪字符串左右两侧的空格。
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, two new strings are created: one left-trims spaces,
    and the other right-trims spaces. The first forward searches for the first character
    that is not whitespace and uses this as the start index of the substring (no count
    is provided because all of the remaining string is copied). In the second case
    the string is reverse searched for a character that is not whitespace, but the
    location returned will be the last character of `hello`; since we need the substring
    from the first character, we increment this index to get the count of characters
    to copy.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，创建了两个新的字符串：一个左修剪空格，另一个右修剪空格。第一个向前搜索第一个非空白字符，并将其作为子字符串的起始索引（因为没有提供计数，所以将复制所有剩余的字符串）。在第二种情况下，字符串是反向搜索的，寻找第一个非空白字符，但返回的位置将是`hello`的最后一个字符；因为我们需要从第一个字符开始的子字符串，所以我们增加这个索引以获得要复制的字符数。
- en: Internationalization
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: The `<locale>` header contains the classes for localizing how time, dates, and
    currency are formatted, and also to provide localized rules for string comparisons
    and ordering.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`<locale>`头文件包含了用于本地化时间、日期和货币格式化的类，还提供了用于字符串比较和排序的本地化规则。'
- en: The C Runtime Library also has global functions to carry out localization. However,
    it is important in the following discussion that we distinguish between C functions
    and the C locale. The C locale is the default locale, including the rules for
    localization, used in C and C++ programs and it can be replaced with a locale
    for a country or culture. The C Runtime Library provides functions to change the
    locale, as does the C++ Standard Library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时库还具有全局函数来执行本地化。然而，在下面的讨论中，我们需要区分C函数和C语言环境。C语言环境是默认语言环境，包括本地化规则，用于C和C++程序，并且可以用国家或文化的语言环境替换。C运行时库提供了更改语言环境的函数，C++标准库也提供了相同的功能。
- en: Since the C++ Standard Library provides classes for localization, this means
    that you can create more than one object representing a locale. A locale object
    can be created in a function and can only be used there, or it can be applied
    globally to a thread and used only by code running on that thread. This is in
    contrast to the C localization functions, where changing the locale is global,
    so all code (and all threads of execution) will be affected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++标准库提供了本地化的类，这意味着您可以创建多个表示语言环境的对象。语言环境对象可以在函数中创建，并且只能在那里使用，或者可以全局应用到线程，并且只能由在该线程上运行的代码使用。这与C本地化函数形成对比，其中更改语言环境是全局的，因此所有代码（和所有执行线程）都会受到影响。
- en: Instances of the `locale` class are either created through the class constructor
    or through static members of the class. The C++ stream classes will use a locale
    (as explained later), and if you want to change the locale you call the `imbue`
    method on the stream object. In some cases, you will want to access one of these
    rules directly, and you have access to them through the locale object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`locale`类的实例可以通过类构造函数或类的静态成员创建。C++流类将使用语言环境（稍后解释），如果要更改语言环境，则在流对象上调用`imbue`方法。在某些情况下，您可能需要直接访问其中一个规则，并且可以通过语言环境对象访问它们。'
- en: Using facets
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用facets
- en: Internationalization rules are known as **facets**. A locale object is a container
    of facets, and you can test if the locale has a specific facet using the `has_facet`
    function; if it does, you can get a `const` reference to the facet by calling
    the `use_facet` function. There are six types of facets summarized by seven categories
    of class in the following table. A facet class is a subclass of the `locale::facet`
    nested class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化规则称为**facets**。语言环境对象是facets的容器，您可以使用`has_facet`函数测试语言环境是否具有特定的facet；如果有，您可以通过调用`use_facet`函数获得facet的`const`引用。以下表格总结了七类中的六种facet类型。facet类是`locale::facet`嵌套类的子类。
- en: '| **Facet type** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **Facet type** | **描述** |'
- en: '| `codecvt`, `ctype` | Converts between one encoding scheme to another and
    is used to classify characters and convert them to upper or lowercase |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `codecvt`, `ctype` | 在不同编码方案之间转换，并用于对字符进行分类和转换为大写或小写 |'
- en: '| `collate` | Controls the ordering and grouping of characters in a string,
    including comparing and hashing of strings |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `collate` | 控制字符串中字符的排序和分组，包括比较和哈希字符串 |'
- en: '| `messages` | Retrieves localized messages from a catalog |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `messages` | 从目录中检索本地化消息 |'
- en: '| `money` | Converts numbers representing currency to and from strings |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `money` | 将表示货币的数字转换为字符串，反之亦然 |'
- en: '| `num` | Converts numbers to and from strings |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `num` | 将数字转换为字符串，反之亦然 |'
- en: '| `time` | Converts times and dates in numeric form to and from strings |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 将数字形式的时间和日期转换为字符串，反之亦然 |'
- en: The facet classes are used to convert the data to strings and so they all have
    a template parameter for the character type used. The `money`, `num,` and `time`
    facets are represented by three classes each. A class with the `_get` suffix that
    handles parsing strings, while a class with the `_put` suffix handles formatting
    as strings. For the `money` and `num` facets there is a class with the `punct`
    suffix that contains the rules and symbols for punctuation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: facet类用于将数据转换为字符串，因此它们都具有用于字符类型的模板参数。`money`，`num`和`time` facets分别由三个类表示。具有`_get`后缀的类处理解析字符串，而具有`_put`后缀的类处理格式化为字符串。对于`money`和`num`
    facets，还有一个包含标点规则和符号的`punct`后缀的类。
- en: Since the `_get` facets are used to convert sequences of characters into numeric
    types, the classes have a template parameter that you can use to indicate the
    input iterator type that the `get` methods will use to represent a range of characters.
    Similarly, the `_put` facet classes have a template parameter that you can use
    to provide the output iterator type the `put` methods will write the converted
    string to. There are default types provided for both iterators types.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_get` facets用于将字符序列转换为数字类型，因此类具有模板参数，您可以使用它来指示`get`方法将用于表示一系列字符的输入迭代器类型。同样，`_put`
    facet类具有模板参数，您可以使用它来提供`put`方法将转换后的字符串写入的输出迭代器类型。对于这两种迭代器类型都提供了默认类型。
- en: The `messages` facet is used for compatibility with POSIX code. The class is
    intended to allow you to provide localized strings for your application. The idea
    is that the strings in your user interface are indexed and at runtime you access
    the localized string using the index through the `messages` facet. However, Windows
    applications typically use message resource files compiled using the **Message
    Compiler**. It is perhaps for this reason that the `messages` facet provided as
    part of the Standard Library does not do anything, but the infrastructure is there,
    and you can derive your own `messages` facet class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages` facet 用于与POSIX代码兼容。该类旨在允许您为应用程序提供本地化的字符串。其想法是，用户界面中的字符串被索引，并且在运行时，您可以通过`messages`
    facet通过索引访问本地化的字符串。然而，Windows应用程序通常使用使用**消息编译器**编译的消息资源文件。也许正因为这个原因，标准库提供的`messages`
    facet并不起作用，但基础设施已经存在，您可以派生自己的`messages` facet类。'
- en: 'The `has_facet` and `use_facet` functions are templated for the specific type
    of facet that you want. All facet classes are subclasses of the `locale::facet`
    class, but through this template parameter the compiler will instantiate a function
    that returns the specific type you request. So, for example, if you want to format
    time and date strings for the French locale, you can call this code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_facet`和`use_facet`函数是为您想要的特定facet类型进行模板化的。所有facet类都是`locale::facet`类的子类，但通过这个模板参数，编译器将实例化一个返回您请求的特定类型的函数。因此，例如，如果您想要为法语区域设置格式化时间和日期字符串，可以调用以下代码：'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the `french` string identifies the locale, and this is the language string
    used by the C Runtime Library `setlocale` function. The second line obtains the
    facet for converting numeric times into strings, and hence the function template
    parameter is `time_put<char>`. This class has a method called `put` that you can
    call to perform the conversion:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`french`字符串标识了区域，这是C运行时库`setlocale`函数使用的语言字符串。第二行获取了用于将数字时间转换为字符串的facet，因此函数模板参数是`time_put<char>`。这个类有一个叫做`put`的方法，您可以调用它来执行转换：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `time` function (via `<ctime>`) returns an integer with the current time
    and date, and this is converted to a `tm` structure using the `gmtime` function.
    The `tm` structure contains individual members for the year, month, day, hours,
    minutes, and seconds. The `gmtime` function returns the address to a structure
    that is statically allocated in the function, so you do not have to delete the
    memory it occupies. The facet will format the data in the `tm` structure as a
    string through the output iterator passed as the first parameter. In this case,
    the output stream iterator is constructed from the `cout` object and so the facet
    will write the format stream to the console (the second parameter is not used,
    but because it is a reference you have to pass something, so the `cout` object
    is used there too). The third parameter is the separator character (again, this
    is not used). The fifth and (optional) sixth parameters indicate the formatting
    that you require. These are the same formatting characters as used in the C Runtime
    Library function `strftime`, as two single characters rather than the format string
    used by the C function. In this example, `x` is used to get the date and `#` is
    used as a modifier to get the long version of the string.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`函数（通过`<ctime>`）返回一个具有当前时间和日期的整数，并使用`gmtime`函数将其转换为`tm`结构。`tm`结构包含年、月、日、小时、分钟和秒的各个成员。`gmtime`函数返回一个静态分配在函数中的结构的地址，因此您不必删除它占用的内存。facet将`tm`结构中的数据格式化为字符串，通过作为第一个参数传递的输出迭代器。在这种情况下，输出流迭代器是从`cout`对象构造的，因此facet将格式化流写入控制台（第二个参数没有使用，但因为它是一个引用，您必须传递一些东西，所以在那里也使用了`cout`对象）。第三个参数是分隔符字符（同样，这不被使用）。第五和（可选的）第六个参数指示您需要的格式。这些是与C运行时库函数`strftime`中使用的相同格式字符相同的格式字符，作为两个单个字符，而不是C函数使用的格式字符串。在这个例子中，`x`用于获取日期，`#`用作获取字符串的长版本的修饰符。'
- en: 'The  code will give the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将给出以下输出：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the words are not capitalized and there is no punctuation, also
    notice the order: weekday name, day number, month, then year.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单词没有大写，也没有标点符号，还要注意顺序：星期几名称，日期，月份，然后年份。
- en: 'If the `locale` object constructor parameter is changed to `german` then the
    output will be:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`locale`对象构造函数参数更改为`german`，那么输出将是：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The items are in the same order as in French, but the words are capitalized
    and punctuation is used. If you use `turkish` then the result is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的顺序与法语中的顺序相同，但单词是大写的，使用了标点符号。如果使用`turkish`，则结果是：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the day of the week is at the end of the string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，星期几在字符串的末尾。
- en: 'Two countries divided by a common language will give two different strings,
    and the following are the results for `american` and `english-uk`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同一种语言分隔的两个国家将给出两个不同的字符串，以下是`american`和`english-uk`的结果：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Time is used as the example here because there is no stream, an insertion operator
    is used for the `tm` structure, and it is an unusual case. For other types, there
    are insertion operators that put them into a stream, and so the stream can use
    a locale to internationalize how it shows the type. For example, you can insert
    a `double` into the `cout` object and the value will be printed to the console.
    The default locale, American English, uses the period to separate whole numbers
    from the fractional part, but in other cultures a comma is used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里以时间作为示例，因为没有流，所以使用插入运算符来操作`tm`结构，这是一个不寻常的情况。对于其他类型，有插入运算符将它们放入流中，因此流可以使用区域设置来国际化它显示的类型。例如，您可以将`double`插入到`cout`对象中，该值将被打印到控制台。默认区域设置，美国英语，使用句号将整数部分与小数部分分开，但在其他文化中使用逗号。
- en: 'The `imbue` function will change the localization until the method is called
    subsequently:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`imbue`函数将更改本地化，直到随后调用该方法：'
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the stream object is localized to US English and then the floating-point
    number `1.1` is printed on the console. Next, the localization is changed to French,
    and this time the console will show `1,1`. In French, the decimal point is the
    comma. The last line resets the stream object by passing the locale returned from
    the `static classic` method. This returns the so-called **C locale**, which is
    the default in C and C++ and is American English.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，流对象本地化为美国英语，然后浮点数`1.1`被打印到控制台上。接下来，本地化更改为法语，这时控制台将显示`1,1`。在法语中，小数点是逗号。最后一行通过传递从`static
    classic`方法返回的区域重置流对象。这将返回所谓的**C区域**，这是C和C++中的默认区域，是美国英语。
- en: The `static` method `global` can be used to set the locale that will be used
    as the default by each stream object. When an object is created from a stream
    class it calls the `locale::global` method to get the default locale. The stream
    clones this object so that it has its own copy independent of any local subsequently
    set by calling the `global` method. Note that the `cin` and `cout` stream objects
    are created before the `main` function is called, and these objects will use the
    default C locale until you imbue another locale. However, it is important to point
    out that, once a stream has been created, the `global` method has no effect on
    the stream, and `imbue` is the only way to change the locale used by the stream.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`方法`global`可以用来设置每个流对象默认使用的区域设置。当从流类创建对象时，它调用`locale::global`方法来获取默认区域设置。流会克隆这个对象，这样它就有了自己的独立副本，不受调用`global`方法设置的任何本地影响。请注意，`cin`和`cout`流对象是在调用`main`函数之前创建的，并且这些对象将使用默认的C区域设置，直到你使用其他区域设置。然而，重要的是要指出，一旦流被创建，`global`方法对流没有影响，`imbue`是改变流使用的区域设置的唯一方法。'
- en: The `global` method will also call the C `setlocale` function to change the
    locale used by the C Runtime Library functions. This is important because some
    of the C++ functions (for example `to_string`, `stod`, as explained in the following
    text) will use the C Runtime Library functions to convert values. However, the
    C Runtime Library knows nothing about the C++ Standard Library, so calling the
    C `setlocale` function to change the default locale will not affect subsequently
    created stream objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`方法还将调用C `setlocale`函数来改变C运行时库函数使用的区域设置。这很重要，因为一些C++函数（例如`to_string`，`stod`，如下文所述）将使用C运行时库函数来转换值。然而，C运行时库对C++标准库一无所知，因此调用C
    `setlocale`函数来改变默认区域设置不会影响随后创建的流对象。'
- en: 'It is worth pointing out that the `basic_string` class compares strings using
    the character traits class indicated by a template parameter. The `string` class
    uses the `char_traits` class and its version of the `compare` method does a straight
    comparison of the corresponding characters in the two strings. This comparison
    does not take into account cultural rules for comparing characters. If you want
    to do a comparison that uses cultural rules, you can do this through the `collate`
    facet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`basic_string`类使用模板参数指示的字符特性类进行字符串比较。`string`类使用`char_traits`类，它的`compare`方法直接比较两个字符串中对应的字符。这种比较不考虑比较字符的文化规则。如果你想进行使用文化规则的比较，可以通过`collate`
    facet来实现：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Strings and numbers
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和数字
- en: The Standard Library contains various functions and classes to convert between
    C++ strings and numeric values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含各种函数和类，用于在C++字符串和数值之间进行转换。
- en: Converting strings to numbers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: 'The C++ standard library contains functions with names like `stod` and `stoi`
    that convert a C++ `string` object to a numeric value (`stod` converts to a `double`
    and `stoi` converts to an `integer`). For example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库包含了名为`stod`和`stoi`的函数，它们将C++ `string`对象转换为数值（`stod`转换为`double`，`stoi`转换为`integer`）。例如：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will initialize the floating-point variable `d` with a value of `10.5`,
    which is then used in a calculation and the result is printed on the console.
    The input string may have characters that cannot be converted. If this is the
    case then the parsing of the string ends at that point. You can provide a pointer
    to a `size_t` variable, which will be initialized to the location of the first
    character that cannot be converted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用值为`10.5`的浮点变量`d`进行初始化，然后在计算中使用该值，并将结果打印到控制台。输入字符串可能包含无法转换的字符。如果是这种情况，那么字符串的解析将在那一点结束。你可以提供一个指向`size_t`变量的指针，该变量将被初始化为无法转换的第一个字符的位置：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, the `idx` variable will be initialized with a value of
    `4`, indicating that the space between the `5` and `r` is the first character
    that cannot be converted to a `double`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`idx`变量将被初始化为`4`，表示`5`和`r`之间的空格是无法转换为`double`的第一个字符。
- en: Converting numbers to strings
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: The `<string>` library provides various overloads of the `to_string` function
    to convert integer types and floating point types into a `string` object. This
    function does not allow you to provide any formatting details, so for an integer
    you cannot indicate the radix of the string representation (for example, hex),
    and for floating point conversions, you have no control over options like the
    number of significant figures. The `to_string` function is a simple function with
    limited facilities. A better option is to use the stream classes, as explained
    in the following section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<string>`库提供了各种重载的`to_string`函数，用于将整数类型和浮点类型转换为`string`对象。这个函数不允许你提供任何格式化细节，所以对于整数，你不能指定字符串表示的基数（例如，十六进制），对于浮点数转换，你无法控制选项，比如有效数字的数量。`to_string`函数是一个功能有限的简单函数。更好的选择是使用流类，如下一节所述。'
- en: Using stream classes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流类
- en: You can print floating point numbers and integers to the console using the `cout`
    object (an instance of the `ostream` class) or to files with an instance of `ofstream`.
    Both of these classes will convert numbers to strings using member methods and
    manipulators to affect the formatting of the output string. Similarly, the `cin`
    object (an instance of the `istream` class) and the `ifstream` class can read
    data from formatted streams.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`cout`对象（`ostream`类的实例）将浮点数和整数打印到控制台，也可以使用`ofstream`类的实例将它们写入文件。这两个类都会使用成员方法和操作符将数字转换为字符串，并影响输出字符串的格式。同样，`cin`对象（`istream`类的实例）和`ifstream`类可以从格式化的流中读取数据。
- en: Manipulators are functions that take a reference to a stream object and return
    that reference. The Standard Library has various global insertion operators whose
    parameters are a reference to a stream object and a function pointer. The appropriate
    insertion operator will call the function pointer with the stream object as its
    parameter. This means that the manipulator will have access to, and can manipulate,
    the stream it is inserted into. For input streams, there are also extraction operators
    that have a function parameter which will call the function with the stream object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵器是接受流对象引用并返回该引用的函数。标准库具有各种全局插入运算符，其参数是流对象的引用和函数指针。适当的插入运算符将使用流对象作为其参数调用函数指针。这意味着操纵器将可以访问并操作其插入的流。对于输入流，还有具有函数参数的提取运算符，该参数将使用流对象调用函数。
- en: The architecture of C++ streams means that there is a buffer between the stream
    interface that you call in your code and the low-level infrastructure that obtains
    the data. The C++ Standard Library provides stream classes that have string objects
    as the buffer. For an output stream, you access the string after items have been
    inserted in the stream, which means that the string will contain those items formatted
    according to those insertion operators. Similarly, you can provide a string with
    formatted data as the buffer for an input stream, and when you use extraction
    operators to extract the data from the stream you are actually parsing the string
    and converting parts of the string to numbers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++流的架构意味着在您的代码中调用流接口和获取数据的低级基础设施之间有一个缓冲区。C++标准库提供了以字符串对象作为缓冲区的流类。对于输出流，您在流中插入项目后访问字符串，这意味着字符串将包含根据这些插入运算符格式化的项目。同样，您可以提供一个带有格式化数据的字符串作为输入流的缓冲区，当您使用提取运算符从流中提取数据时，实际上是解析字符串并将字符串的部分转换为数字。
- en: In addition, stream classes have a `locale` object and stream objects will call
    the conversion facet of this locale to convert character sequences from one encoding
    to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，流类具有`locale`对象，流对象将调用此区域的转换部分，将字符序列从一种编码转换为另一种编码。
- en: Outputting floating point numbers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出浮点数
- en: 'The `<ios>` library has manipulators that alter how streams handle numbers.
    By default, the output stream will print floating-point numbers in a decimal format
    for numbers in the range `0.001` to `100000,` and for numbers outside this range
    it will use a scientific format with a mantissa and exponent. This mixed format
    is the default behavior of the `defaultfloat` manipulator. If you always want
    to use scientific notation, then you should insert the `scientific` manipulator
    into the output stream. If you want to display floating point numbers using just
    the decimal format (that is the whole number on the left side of a decimal point
    and the factional part on the right side), then modify the output stream with
    the `fixed` manipulator. The number of decimal places can be altered by calling
    the `precision` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ios>`库具有改变流处理数字方式的操纵器。默认情况下，输出流将以十进制格式打印范围在`0.001`到`100000`之间的浮点数，并且对于超出此范围的数字，它将使用具有尾数和指数的科学格式。这种混合格式是`defaultfloat`操纵器的默认行为。如果您总是想使用科学计数法，那么应该在输出流中插入`scientific`操纵器。如果您想使用仅使用十进制格式显示浮点数（即小数点左侧的整数部分和右侧的小数部分），那么可以使用`fixed`操纵器修改输出流。可以通过调用`precision`方法来改变小数位数：'
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output from the preceding code is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line shows that scientific notation is used for large numbers. The
    second line shows the default behavior of `fixed`, which is to give the decimal
    number to 6 decimal places. This is changed in the code by calling the `precision`
    method to give 9 decimal places (the same effect can be achieved by inserting
    the `setprecision` manipulator in the `<iomanip>` library in the stream). Finally,
    the format is switched over to the scientific format with 9 decimal places to
    the mantissa from calling the `precision` method. The default is that the exponent
    is identified by the lowercase `e`. If you prefer, you can make this uppercase
    using the `uppercase` manipulator (and lowercase with `nouppercase`). Notice that
    the way that fractional parts are stored means that in fixed formats with 9 decimal
    places we see that the ninth digit is `8` rather than `1` as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了大数使用科学计数法。第二行显示了`fixed`的默认行为，即给出小数到6位。通过调用`precision`方法来改变代码，以给出9位小数位数（可以通过在流中插入`<iomanip>`库中的`setprecision`操纵器来实现相同的效果）。最后，格式切换到具有9位小数位数的尾数的科学格式。默认情况下，指数由小写`e`标识。如果您愿意，可以使用`uppercase`操纵器（和`nouppercase`）使其大写。请注意，小数部分存储方式意味着在具有9位小数位数的固定格式中，我们看到第九位数字是`8`而不是预期的`1`。
- en: You can also specify whether a `+` symbol is shown for a positive number; the
    `showpos` manipulator will show the symbol, but the default `noshowpos` manipulator
    will not show the symbol. The `showpoint` manipulator will ensure that the decimal
    point is shown even if the floating-point number is a whole number. The default
    is `noshowpoint`, which means that, if there is no fractional part, no decimal
    point is displayed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定正数是否显示`+`符号；`showpos`操纵器将显示该符号，但默认的`noshowpos`操纵器将不显示该符号。`showpoint`操纵器将确保即使浮点数是整数，也会显示小数点。默认值是`noshowpoint`，这意味着如果没有小数部分，则不显示小数点。
- en: 'The `setw` manipulator (defined in the `<iomanip>` header) can be used with
    both integer and floating point numbers. In effect, this manipulator defines the
    minimum width of the space that the next (and only the next) item placed in the
    stream will occupy when printed on the console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`setw`操纵器（在`<iomanip>`头文件中定义）可用于整数和浮点数。实际上，这个操纵器定义了在控制台上打印下一个（仅下一个）放置在流中的项目所占用的最小宽度：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To illustrate the effect of the `setw` manipulator, this code calls `setfill`
    manipulator, which indicates that instead of spaces a hash symbol (`#`) should
    be printed. The rest of the code says that the number should be printed using
    the fixed format (to 6 decimal places by default) in a space 15 characters wide.
    The result is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`setw`操纵器的效果，这段代码调用了`setfill`操纵器，它表示应该打印一个井号(`#`)而不是空格。代码的其余部分表示数字应该使用固定格式打印（默认情况下为6位小数），宽度为15个字符的空格。结果是：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the number is negative (or `showpos` is used), then by default the sign
    will be with the number; if the `internal` manipulator (defined in `<ios>`) is
    used, then the sign will be left-justified in the space set for the number:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字是负数（或使用`showpos`），那么默认情况下符号将与数字一起显示；如果使用`internal`操纵器（在`<ios>`中定义），那么符号将左对齐在为数字设置的空格中：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果如下：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that the `+` sign to the right of the spaces is indicated by the pound
    symbol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空格右侧的`+`符号由井号表示。
- en: 'The `setw` manipulator is typically used to allow you to output tables of data
    in formatted columns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`setw`操纵器通常用于允许您以格式化的列输出数据表：'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This fills a `vector` of pairs with a string and a number. The `vector` is
    initialized with the string values and a zero, then the floating-point number
    is altered in the `for` loop (the actual calculation is irrelevant here; the point
    is to create some numbers with multiple decimal places). The data is printed out
    in two columns with the numbers printed with 6 decimal places. This means that,
    including the leading zero and decimal point, each number will take up 8 spaces.
    The text column is specified as being 6 characters wide and the number column
    is specified as 10 characters wide. By default, when you specify a column width,
    the output will be right justified, meaning that each number is preceded by two
    spaces and the text is padded according to the length of the string. The output
    looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用字符串和数字填充`vector`对。`vector`用字符串值和零初始化，然后在`for`循环中更改浮点数（这里实际计算无关紧要；重点是创建一些具有多位小数的数字）。数据以两列打印出来，数字以6位小数打印。这意味着，包括前导零和小数点，每个数字将占用8个空格。文本列的宽度为6个字符，数字列的宽度为10个字符。默认情况下，当指定列宽时，输出将右对齐，这意味着每个数字前面有两个空格，文本根据字符串的长度进行填充。输出如下：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want the items in a column to be left justified, then you can use the
    `left` manipulator. This will affect all columns until the `right` manipulator
    is used to change the justification to right:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使列中的项目左对齐，则可以使用`left`操纵器。这将影响所有列，直到使用`right`操纵器将对齐方式更改为右对齐：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output from this will be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want different justification for the two columns, then you need to set
    the justification before printing a value. For example, to left justify the text
    and right justify the numbers, use this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望两列具有不同的对齐方式，则需要在打印值之前设置对齐方式。例如，要左对齐文本并右对齐数字，请使用以下方法：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Outputting integers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出整数
- en: Integers can also be printed in columns using the `setw` and `setfill` methods.
    You can insert manipulators to print integers in base 8 (`oct`), base 10 (`dec`),
    and base 16 (`hex`). (You can also use the `setbase` manipulator and pass the
    base you want to use, but the only values allowed are 8, 10, and 16.) The number
    can be printed with the base indicated (prefixed with `0` for octal or `0x` for
    hex) or without using the `showbase` and `noshowbase` manipulators. If you use
    `hex`, then the digits above `9` are the letters `a` to `f`, and by default these
    are lowercase. If you prefer these to be uppercase, then you can use the `uppercase`
    manipulator (and lowercase with `nouppercase`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 整数也可以使用`setw`和`setfill`方法以列的形式打印。您可以插入操纵器以使用8进制（`oct`），10进制（`dec`）和16进制（`hex`）打印整数。数字可以以指定的基数打印（以`0`为前缀表示八进制或以`0x`表示十六进制），也可以使用`showbase`和`noshowbase`操纵器。如果使用`hex`，则大于`9`的数字是字母`a`到`f`，默认情况下这些是小写的。如果您希望这些为大写，则可以使用`uppercase`操纵器（并使用`nouppercase`转换为小写）。
- en: Outputting time and money
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出时间和金钱
- en: 'The `put_time` function in `<iomanip>` is passed a `tm` structure initialized
    with a time and date and a format string. The function returns an instance of
    the `_Timeobj` class. As the name suggests, you are not really expected to create
    variables of this class; instead, the function should be used to insert a time/date
    with a specific format into a stream. There is an insertion operator that will
    print a `_Timeobj` object. The function is used like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<iomanip>`中的`put_time`函数传递了一个用时间和日期初始化的`tm`结构和一个格式字符串。该函数返回`_Timeobj`类的一个实例。正如名称所示，您实际上并不希望创建此类的变量；相反，应该使用该函数将具有特定格式的时间/日期插入流中。有一个插入运算符将打印一个`_Timeobj`对象。该函数的使用方式如下：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output from this is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The function will use the locale in the stream, so if you imbue a locale into
    the stream and then call `put_time`, the time/date will be formatted using the
    format string and the time/date localization rules for the locale. The format
    string uses format tokens for `strftime`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将使用流中的区域设置，因此如果将区域设置为流中，然后调用`put_time`，则时间/日期将使用格式字符串和区域设置的时间/日期本地化规则进行格式化。格式字符串使用`strftime`的格式标记：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出是：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similarly, the `put_money` function returns a `_Monobj` object. Again, this
    is simply a container for the parameters that you pass to this function and you
    are not expected to use instances of this class. Instead, you are expected to
    insert this function into an output stream. The actual work occurs in the insertion
    operator that obtains the money facet on the current locale, which uses this to
    format the number to the appropriate number of decimal places and determine the
    decimal point character; if a thousands separator is used, what character to use,
    before it is inserted it in the appropriate place.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`put_money`函数返回一个`_Monobj`对象。同样，这只是一个容器，用于传递给此函数的参数，您不应该使用此类的实例。相反，您应该将此函数插入到输出流中。实际工作发生在插入运算符中，该运算符获取当前区域设置上的货币facet，使用它来将数字格式化为适当数量的小数位，并确定小数点字符；如果使用千位分隔符，要在适当位置插入它之前使用什么字符。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code is:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You provide the number in either a `double` or a string as Euro cents or cents
    and the `put_money` function formats the number in Euros or dollars using the
    appropriate decimal point (`,` for German, `.` for American) and the appropriate
    thousands separator (`.` for German, `,` for American). Inserting the `showbase`
    manipulator into the output stream means that the `put_money` function will show
    the currency symbol, otherwise just the formatted number will be shown. The second
    parameter to the `put_money` function specifies whether the currency character
    (`false`) or the international symbol (`true`) is used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`double`或字符串提供欧分或美分的数字，`put_money`函数会使用适当的小数点（德国为`,`，美国为`.`）和适当的千位分隔符（德国为`.`，美国为`,`）格式化欧元或美元的数字。将`showbase`操纵器插入输出流意味着`put_money`函数将显示货币符号，否则只会显示格式化后的数字。`put_money`函数的第二个参数指定使用货币字符（`false`）还是国际符号（`true`）。
- en: Converting numbers to strings using streams
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流将数字转换为字符串
- en: Stream buffer classes are responsible for obtaining characters and writing characters
    from the appropriate source (file, console, and so on) and are derived from the
    abstract class `basic_streambuf` from `<streambuf>`. This base class defines two
    virtual methods, `overflow` and `underflow,` which are overridden by the derived
    classes to write and read characters (respectively) to and from the device associated
    with the derived class. The stream buffer class does the basic action of getting
    or putting items into a stream, and since the buffer handles characters, the class
    is templated with parameters for the character type and character traits.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 流缓冲区类负责从适当的源（文件、控制台等）获取字符并写入字符，并且是从`<streambuf>`中的抽象类`basic_streambuf`派生的。这个基类定义了两个虚拟方法，`overflow`和`underflow`，派生类重写这些方法以从与派生类关联的设备中写入和读取字符（分别）。流缓冲区类执行将项目放入流中或从流中取出项目的基本操作，由于缓冲区处理字符，因此该类使用字符类型和字符特性的参数进行模板化。
- en: As the name suggests, if you use a `basic_stringbuf` the stream buffer will
    be a string, so the source for read characters and the destination for written
    characters is that string. If you use this class to provide the buffer for a stream
    object, it means that you can use the insertion or extraction operators written
    for streams to write or read formatted data into or out of a string. The `basic_stringbuf`
    buffer is extendable, so as you insert items in the stream, the buffer will extend
    appropriately. There are `typedef`, where the buffer is a `string` (`stringbuf`)
    or a `wstring` (`wstringbuf`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，如果您使用`basic_stringbuf`，流缓冲区将是一个字符串，因此读取字符的源和写入字符的目的地就是该字符串。如果您使用此类为流对象提供缓冲区，这意味着您可以使用为流编写的插入或提取运算符将格式化数据写入字符串或从字符串中读取。`basic_stringbuf`缓冲区是可扩展的，因此在插入项目时，缓冲区将适当地扩展。有`typedef`，其中缓冲区是`string`（`stringbuf`）或`wstring`（`wstringbuf`）。
- en: 'For example, imagine you have a class that you have defined and you have also
    defined an insertion operator so that you can use this with the `cout` object
    to print the value to the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个已定义的类，并且还定义了插入运算符，以便您可以将其与`cout`对象一起使用来将值打印到控制台：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using this with the `cout` object is simple--consider the following piece of
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`cout`对象一起使用很简单--考虑以下代码片段：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can use the `stringbuf` to direct the formatted output to a string rather
    than the console:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`stringbuf`将格式化的输出定向到字符串而不是控制台：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since the stream object handles the formatting it means that you can insert
    any data type for which there is an insertion operator, and you can use any of
    the `ostream` formatting methods and any of the manipulators. The formatted output
    from all of these methods and manipulators will be inserted into the string object
    in the buffer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流对象处理格式化，这意味着您可以插入任何有插入运算符的数据类型，并且可以使用任何`ostream`格式化方法和任何操纵器。所有这些方法和操纵器的格式化输出将被插入到缓冲区中的字符串对象中。
- en: 'Another option is to use the `basic_ostringstream` class in `<sstream>`. This
    class is templated on the character type of the strings used as the buffer (so
    the `string` version is `ostringstream`). It is derived from the `ostream` class,
    so you can use instances wherever you would use an `ostream` object. The formatted
    results can be accessed through the `str` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`<sstream>`中的`basic_ostringstream`类。这个类是基于用作缓冲区的字符串的字符类型的模板（因此`string`版本是`ostringstream`）。它派生自`ostream`类，因此您可以在任何需要使用`ostream`对象的地方使用实例。格式化的结果可以通过`str`方法访问：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code obtains the value of `42` in hexadecimal (`2a`); this is achieved
    by inserting the `hex` manipulator in the stream and then inserting the integer.
    The formatted string is obtained by calling the `str` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码以十六进制（`2a`）获取`42`的值；这是通过在流中插入`hex`操纵器，然后插入整数来实现的。通过调用`str`方法获取格式化的字符串。
- en: Reading numbers from strings using streams
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流从字符串中读取数字
- en: The `cin` object, an instance of the `istream` class (in the `<istream>` library),
    can input characters from the console and convert them to the numeric form you
    specify. The `ifstream` class (in the `<ifstream>` library) will also allow you
    to input characters from a file and convert them to numeric form. As with outputting
    streams, you can use the stream classes with a string buffer so that you can convert
    from a string object to a numeric value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin`对象是`istream`类的一个实例（在`<istream>`库中），可以从控制台输入字符并将其转换为您指定的数字形式。`ifstream`类（在`<ifstream>`库中）还允许您从文件中输入字符并将其转换为数字形式。与输出流一样，您可以使用流类与字符串缓冲区，以便您可以从字符串对象转换为数字值。'
- en: The `basic_istringstream` class (in the `<sstream>` library) is derived from
    the `basic_istream` class, so you can create stream objects and extract items
    (numbers and strings) from these objects. The class provides this stream interface
    on a string object (the `typedef`s keyword `istringstream` is based on a `string`
    and `wistringstream` is based on a `wstring`). When you construct objects of this
    class you initialize the object with a `string` containing a number and then you
    use the `>>` operator to extract objects for the fundamental built-in types, just
    as you would extract those items from the console using `cin`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic_istringstream`类（在`<sstream>`库中）是从`basic_istream`类派生的，因此您可以创建流对象并从这些对象中提取项目（数字和字符串）。该类在字符串对象上提供了这种流接口（`typedef`关键字`istringstream`基于`string`，`wistringstream`基于`wstring`）。当您构造此类的对象时，您将使用包含数字的`string`初始化对象，然后使用`>>`运算符从中提取基本内置类型的对象，就像您使用`cin`从控制台提取这些项目一样。'
- en: 'It is important to reiterate that the extraction operators treat whitespaces
    as the separators between items in a stream, and hence they will ignore all leading
    whitespaces, read the non-whitespaces characters up to the next whitespaces and
    attempt to convert this substring into the appropriate type as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，提取运算符将空格视为流中项目之间的分隔符，因此它们将忽略所有前导空格，读取直到下一个空格的非空格字符，并尝试将此子字符串转换为适当的类型，如下所示：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will initialize the `d` variable with the value of `-1e-6`. As with `cin,`
    you have to know the format of the item in the stream; so if, instead of extracting
    a `double` from the string in the preceding example, you try to extract an integer,
    the object will stop extracting characters when it comes to the decimal point.
    If some of the string is not converted, you can extract the rest into a string
    object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用值`-1e-6`初始化变量`d`。与`cin`一样，您必须了解流中项目的格式；因此，如果您尝试从前面的示例中的字符串中提取`double`而不是提取整数，则当对象遇到小数点时，它将停止提取字符。如果字符串的一部分未转换，您可以将其余部分提取到一个字符串对象中：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will print the following at the console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印以下内容：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you have more than one number in the string you can extract these with several
    calls to the `>>` operator. The stream also supports some manipulators. For example,
    if the number in the string is in `hex` format you can inform the stream that
    this is the case using the `hex` manipulator as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中有多个数字，则可以通过多次调用`>>`运算符来提取这些数字。流还支持一些操作器。例如，如果字符串中的数字是以`hex`格式表示的，则可以使用`hex`操作器通知流这一点，如下所示：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This says that the number in the string is in hexadecimal format and the variable
    `i` will be initialized with a value of 255\. If the string contains non-numeric
    values, then the stream object will still try to convert the string to the appropriate
    format. In the following snippet you can test if such an extraction fails by calling
    the `fail` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示字符串中的数字以十六进制格式表示，变量`i`将被初始化为255的值。如果字符串包含非数字值，则流对象仍将尝试将字符串转换为适当的格式。在下面的片段中，您可以通过调用`fail`函数来测试此类提取是否失败：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you know that the string contains text, you can extract it into string objects,
    but bear in mind that whitespace characters are treated as delimiters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道字符串包含文本，可以将其提取到字符串对象中，但请记住空格字符将被视为分隔符：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, there are four words before the number, so the code reads a `string`
    four times. If you don''t know where in the string the number is but you know
    there is a number in the string, you can move the internal buffer pointer until
    it points to a digit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字之前有四个单词，因此代码会四次读取`string`。如果您不知道字符串中的数字在哪里，但知道字符串中有一个数字，您可以将内部缓冲区指针移动到指向数字的位置：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `peek` method returns the character at the current position, but does not
    move the buffer pointer. This code checks to see if this character is a digit,
    and if not, the internal buffer pointer is moved by calling the `get` method.
    (This code tests the `eof` method to ensure that there is no attempt to read a
    character after the end of the buffer.) If you know where the number starts then
    you can call the `seekg` method to move the internal buffer pointer to a specified
    position.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek`方法返回当前位置的字符，但不移动缓冲区指针。此代码检查此字符是否为数字，如果不是，则通过调用`get`方法移动内部缓冲区指针。（此代码测试`eof`方法以确保在缓冲区结束后没有尝试读取字符。）如果您知道数字从哪里开始，那么可以调用`seekg`方法将内部缓冲区指针移动到指定位置。'
- en: 'The `<istream>` library has a manipulator called `ws` that removes whitespace
    from a stream. Recall earlier that we said that there is no function to remove
    whitespace from a string. This is true because the `ws` manipulator removes whitespace
    from a *stream* and not from a *string*, but since you can use a string as the
    buffer for a stream it means that you can use this function to remove white space
    from a string indirectly:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`<istream>`库中有一个名为`ws`的操作器，用于从流中删除空格。回想一下我们之前说过，没有函数可以从字符串中删除空格。这是因为`ws`操作器从*流*中删除空格，而不是从*字符串*中删除空格，但由于您可以使用字符串作为流的缓冲区，这意味着您可以间接使用此函数从字符串中删除空格：'
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `ws` function essentially iterates through the items in the input stream
    and returns when a character is not whitespace. If the stream is a file or the
    console stream then the `ws` function will read in the characters from those streams;
    in this case, the buffer is provided by an already-allocated string and so it
    skips over the whitespaces at the beginning of the string. Note that stream classes
    treat subsequent whitespaces as being separators between values in the stream,
    so in this example the stream will read in characters from the buffer until there
    is a whitespace, and will essentially *left-**and right-trim* the string. However,
    this is not necessarily what you want. If you have a string with several words
    padded by whitespace, this code will only provide the first word.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ws`函数本质上是通过输入流中的项进行迭代，并在遇到非空白字符时返回。如果流是文件或控制台流，则`ws`函数将从这些流中读取字符；在这种情况下，缓冲区由已分配的字符串提供，因此它会跳过字符串开头的空白。请注意，流类将后续的空格视为流中值之间的分隔符，因此在此示例中，流将从缓冲区中读取字符，直到遇到空格，并且本质上会*左-**和右-**修剪*字符串。但这不一定是您想要的。如果您有一个由空格填充的多个单词的字符串，此代码将只提供第一个单词。'
- en: 'The `get_money` and `get_time` manipulators in the `<iomanip>` library allow
    you to extract money and time from strings using the money and time facets for
    a locale:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iomanip>`库中的`get_money`和`get_time`操作允许您使用货币和时间facet从字符串中提取货币和时间：'
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding code, the stream is first initialized with a date in the French
    format (day/month/year) and the date is extracted with `get_time` using the locale''s
    standard date representation. The date is parsed into a `tm` structure, which
    is then printed out in standard date representation for the American locale using
    `put_time`. The results is:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，流首先以法国格式（日/月/年）初始化，并使用区域设置的标准日期表示提取日期。日期被解析为`tm`结构，然后使用`put_time`以美国区域设置的标准日期表示打印出来。结果是：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using regular expressions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: Regular expressions are patterns of text that can be used by a regular expression
    parser to search a string for text that matches the pattern, and if required,
    replace the matched items with other text.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是文本模式，可以被正则表达式解析器用来搜索与模式匹配的字符串，并且如果需要，用其他文本替换匹配的项。
- en: Defining regular expressions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义正则表达式
- en: A **regular expression** (**regex**) is made up of characters that define a
    pattern. The expression contains special symbols that are meaningful to the parser,
    and if you want to use those symbols in the search pattern in the expression then
    you can escape them with a backslash (`\`). Your code will typically pass the
    expression as a `string` object to an instance of the `regex` class as a constructor
    parameter. This object is then passed to functions in `<regex>` that will use
    the expression to parse text for sequences that match the pattern.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**（**regex**）由定义模式的字符组成。表达式包含对解析器有意义的特殊符号，如果要在表达式的搜索模式中使用这些符号，则可以用反斜杠（`\`）对其进行转义。您的代码通常将表达式作为`string`对象传递给`regex`类的实例作为构造函数参数。然后将该对象传递给`<regex>`中的函数，该函数将使用表达式来解析文本以匹配模式的序列。'
- en: The following table summarizes *some* of the patterns that you can match with
    the `regex` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了您可以使用`regex`类匹配的*一些*模式。
- en: '| **Pattern** | **Explanation** | **Example** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **解释** | **例子** |'
- en: '| literals | Matches the exact characters | `li` matches `flip` `lip` `plier`
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 文字 | 匹配确切的字符 | `li`匹配`flip` `lip` `plier` |'
- en: '| [group] | Matches a single character in a group | `[at]` matches `cat`, `cat`,
    `top`, `pear` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| [group] | 匹配组中的单个字符 | `[at]`匹配`cat`, `cat`, `top`, `pear` |'
- en: '| [^group] | Matches a single character not in the group | `[^at]` matches
    **c**at, t**o**p, to**p**, **p**ear, p**e**ar, pea**r** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| [^group] | 匹配不在组中的单个字符 | `[^at]`匹配**c**at, t**o**p, to**p**, **p**ear, p**e**ar,
    pea**r** |'
- en: '| [first-last] | Matches any character in the range `first` to `last` | `[0-9]`
    matches digits **1**02, 1**0**2, 10**2** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| [first-last] | 匹配范围在`first`到`last`之间的任何字符 | `[0-9]`匹配数字**1**02, 1**0**2,
    10**2** |'
- en: '| {n} | The element is matched exactly n times | **91{2}** matches **911**
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| {n} | 元素精确匹配n次 | **91{2}**匹配**911** |'
- en: '| {n,} | The element is matched n or more times | `wel{1,}` matches `well`
    and **wel**come |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| {n,} | 元素匹配n次或更多次 | `wel{1,}`匹配`well`和**wel**come |'
- en: '| {n,m} | The element is matched between n and m times | `9{2,4}` matches `99`,
    `999`, `9999`, `9999`9 but not 9 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| {n,m} | 元素匹配n到m次 | `9{2,4}`匹配`99`, `999`, `9999`, `9999`9但不匹配9 |'
- en: '| . | Wildcard, any character except `n` | `a.e` matches `ate` and `are` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| . | 通配符，除了`n`之外的任何字符 | `a.e`匹配`ate`和`are` |'
- en: '| * | The element is matched zero or more times | `d*.d` matches `.1`, `0.1`,
    `10.1` but not 10 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| * | 元素匹配零次或多次 | `d*.d`匹配`.1`, `0.1`, `10.1`但不匹配10 |'
- en: '| + | The element is matched one or more times | `d*.d` matches `0.1`, `10.1`
    but not 10 or .1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| + | 元素匹配一次或多次 | `d*.d`匹配`0.1`, `10.1`但不匹配10或.1 |'
- en: '| ? | The element is matched zero or one time | `tr?ap` matches `trap` and
    `tap` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| ? | 元素匹配零次或一次 | `tr?ap`匹配`trap`和`tap` |'
- en: '| &#124; | Matches any one of the elements separated by the &#124; | `th(e&#124;is&#124;at)`
    matches `the`, `this`, `that` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 匹配由&#124;分隔的元素中的任何一个 | `th(e&#124;is&#124;at)`匹配`the`, `this`, `that`
    |'
- en: '| [[:class:]] | Matches the character class | `[[:upper:]]` matches uppercase
    characters: `I` am `R`ichard |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| [[:class:]] | 匹配字符类 | `[[:upper:]]`匹配大写字符：`I` am `R`ichard |'
- en: '| n | Matches a newline |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| n | 匹配换行符 |  |'
- en: '| s | Matches any single whitespace |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| s | 匹配任何单个空格 |  |'
- en: '| d | Matches any single digit | `d` is `[0-9]` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: 匹配任何单个数字的`d`是`[0-9]`
- en: '| w | Matches a character that can be in a word (upper case and lower case
    characters) |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| w | 匹配可以是单词中的字符（大写和小写字符） |  |'
- en: '| b | Matches at a boundary between alphanumeric characters and non-alphanumeric
    characters | `d{2}b` matches 9`99` and 99`99 bd{2}` matches `99`9 and `99`99 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| b | 在字母数字字符和非字母数字字符之间的边界处匹配 | `d{2}b`匹配9`99`和99`99 bd{2}`匹配`99`9和`99`99 |'
- en: '| $ | End of the line | `s$` matches a single white space at the end of a line
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| $ | 行尾 | `s$` 匹配行尾的单个空格 |'
- en: '| ^ | Start of line | `^d` matches if a line starts with a digit |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 行首 | `^d` 如果一行以数字开头则匹配 |'
- en: You can use regular expressions to define a pattern to be matched--the Visual
    C++ editor allows you to do this in the search dialog (which is a good test bed
    to develop your expressions).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用正则表达式来定义要匹配的模式--Visual C++编辑器允许您在搜索对话框中执行此操作（这是一个很好的测试平台，可以用来开发您的表达式）。
- en: It is much easier to define a pattern to match rather than a pattern *not* to
    match. For example, the expression `w+b<w+>` will match the string `"vector<int>"`,
    because this has one or more word characters followed by a non-word character
    (`<`), followed by one or more word characters followed by `>`. This pattern will
    not match the string `"#include <regex>"` because there is a space after the `include`
    and the `b` indicates that there is a boundary between alphanumeric characters
    and non-alphanumeric characters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 定义要匹配的模式要比定义要*不*匹配的模式容易得多。例如，表达式`w+b<w+>`将匹配字符串`"vector<int>"`，因为它有一个或多个单词字符，后面跟着一个非单词字符（`<`），然后是一个或多个单词字符，后面跟着`>`。这个模式将不会匹配字符串`"#include
    <regex>"`，因为`include`后面有一个空格，而`b`表示字母数字字符和非字母数字字符之间有一个边界。
- en: 'The `th(e|is|at)` example in the table shows that you can use parentheses to
    group patterns when you want to provide alternatives. However, parentheses have
    another use--they allow you to capture groups. So, if you want to perform a replace
    action, you can search for a pattern as a group and then refer to that group as
    a named subgroup later (for example, search for `(Joe)` so that you can replace
    `Joe` with `Tom`). You can also refer to a sub-expression specified by parentheses
    in the expression (called back references):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的`th(e|is|at)`示例表明，当您想要提供替代方案时，可以使用括号来分组模式。然而，括号还有另一个用途--它们允许您捕获组。因此，如果您想要执行替换操作，可以搜索一个模式作为一个组，然后稍后引用该组作为一个命名的子组（例如，搜索`(Joe)`以便您可以用`Tom`替换`Joe`）。您还可以在表达式中引用由括号指定的子表达式（称为反向引用）：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This expression says: *search for words with one or more characters in the
    ranges a to z and A to Z; the word is called 1 so find where it appears twice
    with a space between them*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的意思是：*搜索具有a到z和A到Z范围内一个或多个字符的单词；这个单词称为1，所以找到它出现两次并且中间有一个空格*。
- en: Standard Library classes
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库类
- en: 'To perform matching or replacement you have to create a regular expression
    object. This is an object of the class `basic_regex` that has template parameters
    for the character type and a regular expression traits class. There are two `typedef`s
    for this class: `regex` for `char` and `wregex` for wide chars, which have traits
    described by the `regex_traits` and `wregex_traits` classes.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行匹配或替换，您必须创建一个正则表达式对象。这是一个`basic_regex`类的对象，它具有字符类型和正则表达式特性类的模板参数。对于这个类有两个`typedef`：`regex`用于`char`和`wregex`用于宽字符，它们的特性由`regex_traits`和`wregex_traits`类描述。
- en: 'The traits class determines how the regex class parses the expression. For
    example, recall from previous text that you can use `w` for a word, `d` for a
    digit, and `s` for whitespace. The `[[::]]` syntax allows you to use a more descriptive
    name for the character class: `alnum`, `digit`, `lower`, and so on. And since
    these are text sequences that depend upon a character set, the traits class will
    have the appropriate code to test whether the expression uses a supported character
    class.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 特性类确定了正则表达式类如何解析表达式。例如，从之前的文本中可以看到，您可以使用`w`表示单词，`d`表示数字，`s`表示空白字符。`[[::]]`语法允许您为字符类使用更具描述性的名称：`alnum`，`digit`，`lower`等等。由于这些是依赖于字符集的文本序列，特性类将具有适当的代码来测试表达式是否使用了支持的字符类。
- en: 'The appropriate regex class will parse the expression to enable functions in
    the `<regex>` library to use the expression to identify patterns in some text:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的正则表达式类将解析表达式，以便`<regex>`库中的函数可以使用表达式来识别文本中的模式：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This searches for repeated words using a back reference. Note that the regular
    expression uses `1` for the back reference, but in a string the backslash has
    to be escaped (`\`). If you use character classes such as `s` and `d` then you
    will need to do a lot of escaping. Instead, you can use raw strings (`R"()"`),
    but bear in mind that the first set of parentheses inside the quote marks is part
    of the syntax for raw strings and does not form a regex group:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用反向引用来搜索重复的单词。请注意，正则表达式使用`1`作为反向引用，但在字符串中反斜杠必须转义（`\`）。如果您使用字符类，如`s`和`d`，那么您将需要进行大量的转义。相反，您可以使用原始字符串（`R"()"`），但请记住，引号内的第一组括号是原始字符串的语法的一部分，而不是正则表达式组的一部分：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is entirely up to you as to which is the more readable; both introduce extra
    characters within the double quotes, which has the potential to confuse a quick
    glance-over what the regular expression matches.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种更易读完全取决于您；两者都在双引号内引入了额外的字符，这可能会让人迅速浏览时对正则表达式匹配的内容产生困惑。
- en: Bear in mind that the regular expression is essentially a program in itself,
    so the `regex` parser will determine whether that expression is valid, and if
    it isn't the object, the constructor, will throw an exception of type `regex_error`.
    Exception handling is explained in the next chapter, but it is important to point
    out that if the exception is not caught it will result in the application aborting
    at runtime. The exception's `what` method will return a basic description of the
    error, and the `code` method will return one of the constants in the `error_type`
    enumeration in the `regex_constants` namespace. There is no indication of where
    in the expression the error occurs. You should thoroughly test your expression
    in an external tool (for example Visual C++ search).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正则表达式本质上是一个程序，因此`regex`解析器将确定该表达式是否有效，如果无效，构造函数将抛出`regex_error`类型的异常。异常处理将在下一章中解释，但重要的是要指出，如果未捕获异常，它将导致应用程序在运行时中止。异常的`what`方法将返回错误的基本描述，`code`方法将返回`regex_constants`命名空间中`error_type`枚举中的常量之一。没有指示错误发生在表达式的哪个位置。您应该在外部工具中彻底测试您的表达式（例如Visual
    C++搜索）。
- en: 'The constructor can be called with a string (C or C++) or a pair of iterators
    to a range of characters in a string (or other container), or you can pass an
    initialization list where each item in the list is a character. There are various
    flavors of the language of regex; the default for the `basic_regex` class is **ECMAScript**.
    If you want a different language (basic POSIX, extended POSIX, awk, grep, or egrep),
    you can pass one of the constants defined in the `syntax_option_type` enumeration
    in the `regex_constants` namespace (copies are also available as constants defined
    in the `basic_regex` class) as a constructor parameter. You can only specify one
    language flavor, but you can combine this with some of the other `syntax_option_type`
    constants: `icase` specifies case insensitivity, `collate` uses the locale in
    matches, `nosubs` means you do not want to capture groups, and `optimize` optimizes
    matching.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以接受一个字符串（C或C ++）或一对迭代器，用于字符串（或其他容器）中字符范围，或者您可以传递一个初始化列表，其中列表中的每个项目都是一个字符。正则表达式的语言有各种不同的风格；`basic_regex`类的默认语言是**ECMAScript**。如果您想要不同的语言（基本POSIX，扩展POSIX，awk，grep或egrep），可以将`syntax_option_type`枚举中定义的常量之一（`basic_regex`类中定义的常量的副本也可用）作为构造函数参数。您只能指定一种语言风格，但可以将其与其他`syntax_option_type`常量结合使用：`icase`指定不区分大小写，`collate`使用匹配中的区域设置，`nosubs`表示您不想捕获组，`optimize`优化匹配。
- en: 'The class uses the method `getloc` to obtain the locale used by the parser
    and `imbue` to reset the locale. If you `imbue` a locale, then you will not be
    able to use the `regex` object to do any matching until you reset it with the
    `assign` method. This means there are two ways to use a `regex` object. If you
    want to use the current locale then pass the regular expression to the constructor:
    if you want to use a different locale create an empty `regex` object with the
    default constructor, then call `imbue` with the locale and pass the regular expression
    using the `assign` method. Once a regular expression has been parsed you can call
    the `mark_count` method to get the number of capture groups in the expression
    (assuming you did not use `nosubs`).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用`getloc`方法获取解析器使用的区域设置，并使用`imbue`重置区域设置。如果您`imbue`一个区域设置，那么在使用`assign`方法重置之前，您将无法使用`regex`对象进行任何匹配。这意味着有两种使用`regex`对象的方法。如果要使用当前区域设置，则将正则表达式传递给构造函数：如果要使用不同的区域设置，则使用默认构造函数创建一个空的`regex`对象，然后使用`imbue`方法传递区域设置，并使用`assign`方法传递正则表达式。一旦解析了正则表达式，就可以调用`mark_count`方法获取表达式中捕获组的数量（假设您没有使用`nosubs`）。
- en: Matching expressions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配表达式
- en: 'Once you have constructed a `regex` object you can pass it to the methods in
    the `<regex>` library to search for the pattern in a string. The `regex_match`
    function is passed in a string (C or C++) or iterators to a range of characters
    in a container and a constructed `regex` object. In its simplest form, the function
    will return `true` only if there is an exact match, that is, the expression exactly
    matches the search string:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构造了`regex`对象，就可以将其传递给`<regex>`库中的方法，以在字符串中搜索模式。`regex_match`函数接受一个字符串（C或C
    ++）或容器中字符范围的迭代器，并构造了一个`regex`对象。在其最简单的形式中，该函数仅在存在精确匹配时返回`true`，即表达式与搜索字符串完全匹配：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the previous code, the search expression is for a single character in the
    range given (`a` or `t`), so the first two calls to `regex_match` return `true`
    because the searched string is one character. The last call returns `false` because
    the match is not the same as the searched string. If you remove the `[]` in the
    regular expression, then just the third call returns `true` because you are looking
    for the exact string `at`. If the regular expression is `[at]+` so that you are
    looking for one or more of the characters `a` and `t`, then all three calls return
    `true`. You can alter how the match is determined by passing one or more of the
    constants in the `match_flag_type` enumeration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，搜索表达式是给定范围内的单个字符（`a`或`t`），因此前两次调用`regex_match`返回`true`，因为搜索的字符串是一个字符。最后一次调用返回`false`，因为匹配与搜索的字符串不同。如果在正则表达式中删除`[]`，那么只有第三次调用返回`true`，因为您要查找确切的字符串`at`。如果正则表达式是`[at]+`，以便查找一个或多个字符`a`和`t`，那么所有三次调用都返回`true`。您可以通过传递`match_flag_type`枚举中的一个或多个常量来更改匹配的确定方式。
- en: If you pass a reference to a `match_results` object to this function, then after
    the search the object will contain information about the position and the string
    that matches. The `match_results` object is a container of `sub_match` objects.
    If the function succeeds it means that the entire search string matches the expression,
    and in this case the first `sub_match` item returned will be the entire search
    string. If the expression has subgroups (patterns identified with parentheses)
    then these sub groups will be additional `sub_match` objects in the `match_results`
    object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`match_results`对象的引用传递给此函数，那么在搜索之后，该对象将包含有关匹配位置和字符串的信息。`match_results`对象是`sub_match`对象的容器。如果函数成功，这意味着整个搜索字符串与表达式匹配，在这种情况下，返回的第一个`sub_match`项将是整个搜索字符串。如果表达式有子组（用括号标识的模式），那么这些子组将是`match_results`对象中的其他`sub_match`对象。
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, the expression is the literal `trump` followed by any number of characters.
    The entire string matches this expression and there are two sub groups: the literal
    string `trump` and whatever is left over after the `trump` is removed.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，表达式是字面量`trump`后面跟着任意数量的字符。整个字符串与此表达式匹配，并且有两个子组：字面字符串`trump`和在`trump`被移除后剩下的任何内容。
- en: 'Both the `match_results` class and the `sub_match` class are templated on the
    type of iterator that is used to indicate the matched item. There are `typedef`
    call''s `cmatch` and `wcmatch` where the template parameter is `const char*` and
    `const wchar_t*`, respectively, and `smatch` and `wsmatch` where the parameter
    is the iterator used in `string` and `wstring` objects, respectively (similarly,
    there are submatch classes: `csub_match`, `wcsub_match`, `ssub_match`, and `wssub_match`).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results`类和`sub_match`类都是基于用于指示匹配项的迭代器类型的模板。有`typedef`调用`cmatch`和`wcmatch`，其中模板参数是`const
    char*`和`const wchar_t*`，`smatch`和`wsmatch`，其中参数是在`string`和`wstring`对象中使用的迭代器，分别（类似地，还有子匹配类：`csub_match`，`wcsub_match`，`ssub_match`和`wssub_match`）。'
- en: 'The `regex_match` function can be quite restrictive because it looks for an
    exact match between the pattern and the searched string. The `regex_search` function
    is more flexible because it returns `true` if there is a substring within the
    search string that matches the expression. Note that even if there are multiple
    matches in the search string, the `regex_search` function will only find the first.
    If you want to parse through the string you will have to call the function multiple
    times until it indicates that there are no more matches. This is where the overload
    with iterator access to the search string becomes useful:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_match`函数可能会非常严格，因为它寻找模式和搜索字符串之间的精确匹配。`regex_search`函数更加灵活，因为它在搜索字符串中返回`true`，如果有一个子字符串与表达式匹配。请注意，即使在搜索字符串中有多个匹配，`regex_search`函数也只会找到第一个。如果要解析字符串，必须多次调用该函数，直到指示没有更多匹配为止。这就是迭代器访问搜索字符串的重载变得有用的地方：'
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the expression will match a 2 digit number (`d{2}`) that is surrounded
    by whitespace (the two `b` patterns mean a boundary before and after). The loop
    starts with an iterator pointing to the start of the string, and when a match
    is found this iterator is incremented to that position and then incremented by
    the length of the match. The `regex_iterator` object, explained further, wraps
    this behavior.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，表达式将匹配由空格包围的两位数（`d{2}`），两个`b`模式意味着在`trump`之前和之后的边界。循环从指向字符串开头的迭代器开始，当找到匹配时，该迭代器将增加到该位置，然后增加匹配的长度。`regex_iterator`对象，进一步解释了这种行为。
- en: The `match_results` class gives iterator access to the contained `sub_match`
    objects so you can use ranged `for`. Initially, it appears that the container
    works in an odd way because it knows the position in the searched string of the
    `sub_match` object (through the `position` method, which takes the index of the
    sub match object), but the `sub_match` object appears to only know the string
    it refers to. However, on closer inspection of the `sub_match` class, it shows
    that it derives from `pair`, where both parameters are string iterators. This
    means that a `sub_match` object has iterators specifying the range in the original
    string of the sub string. The `match_result` object knows the start of the original
    string and can use the `sub_match.first` iterator to determine the character position
    of the start of the substring.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results`类提供了对包含的`sub_match`对象的迭代器访问，因此可以使用范围`for`。最初，似乎容器的工作方式有些奇怪，因为它知道`sub_match`对象在搜索字符串中的位置（通过`position`方法，该方法接受子匹配对象的索引），但是`sub_match`对象似乎只知道它所引用的字符串。然而，仔细检查`sub_match`类后，发现它是从`pair`派生而来的，其中两个参数都是字符串迭代器。这意味着`sub_match`对象具有指定原始字符串中子字符串范围的迭代器。`match_result`对象知道原始字符串的起始位置，并且可以使用`sub_match.first`迭代器来确定子字符串的起始字符位置。'
- en: The `match_result` object has a `[]` operator (and the `str` method) that returns
    the substring of the specified group; this will be a string constructed using
    the iterators to the range of characters in the original string. The `prefix`
    method returns the string that precedes the match and the `suffix` method returns
    the string that follows the match. So, in the previous code, the first match will
    be `10`, the prefix will be `1 4`, and the suffix will be `42 100 999`. In contrast,
    if you access the `sub_match` object itself, it only knows its length and the
    string, which is obtained by calling the `str` method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_result`对象具有`[]`运算符（和`str`方法），返回指定组的子字符串；这将是一个使用原始字符串中字符范围的迭代器构造的字符串。`prefix`方法返回匹配之前的字符串，`suffix`方法返回匹配之后的字符串。因此，在前面的代码中，第一个匹配将是`10`，前缀将是`1
    4`，后缀将是`42 100 999`。相比之下，如果访问`sub_match`对象本身，它只知道自己的长度和字符串，这是通过调用`str`方法获得的。'
- en: 'The `match_result` object can also return the results through the `format`
    method. This takes a format string where the matched groups are identified through
    numbered placeholders identified by the `$` symbol (`$1`, `$2`, and so on). The
    output can either be to a stream or returned from the method as a string:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_result`对象还可以通过`format`方法返回结果。这需要一个格式字符串，其中匹配的组通过以`$`符号标识的编号占位符（`$1`、`$2`等）进行识别。输出可以是流，也可以从方法中作为字符串返回：'
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With `regex_match` or `regex_search,` you can use parentheses to identify subgroups.
    If the pattern matches then you can obtain these subgroups using an appropriate
    `match_results` object passed by reference to the function. As shown earlier,
    the `match_results` object is a container for `sub_match` objects. Sub matches
    can be compared with the `<`, `!=`, `==`, `<=`, `>`, and `>=` operators, which
    compare items that the iterators point to (that is, the sub strings). Further,
    `sub_match` objects can be inserted into a stream.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regex_match`或`regex_search`，您可以使用括号标识子组。如果模式匹配，则可以使用适当的`match_results`对象通过引用传递给函数来获取这些子组。如前所示，`match_results`对象是`sub_match`对象的容器。子匹配可以使用`<`、`!=`、`==`、`<=`、`>`和`>=`运算符进行比较，比较迭代器指向的项目（即子字符串）。此外，`sub_match`对象可以插入到流中。
- en: Using iterators
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: 'The library also provides an iterator class for regular expressions, which
    provides a different way to parse strings. Since the class will involve comparisons
    of strings it is templated with the element type and traits. The class will need
    to iterate through strings, so the first template parameter is the string iterator
    type and the element and traits types can be deduced from that. The `regex_iterator`
    class is a forward iterator so it has a `++` operator and it provides a `*` operator
    that gives access to a `match_result` object. In the previous code, you saw that
    a `match_result` object is passed to the `regex_match` and `regex_search` functions,
    which use it to contain their results. This raises the question of what code fills
    the `match_result` object accessed through the `regex_iterator`. The answer lies
    in the iterator''s `++` operator:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还提供了用于正则表达式的迭代器类，它提供了一种不同的解析字符串的方式。由于该类涉及字符串的比较，因此它是使用元素类型和特性进行模板化的。该类需要通过字符串进行迭代，因此第一个模板参数是字符串迭代器类型，元素和特性类型可以从中推导出来。`regex_iterator`类是一个前向迭代器，因此它具有`++`运算符，并且提供了一个`*`运算符，可以访问`match_result`对象。在先前的代码中，您看到`match_result`对象被传递给`regex_match`和`regex_search`函数，它们用它来包含它们的结果。这引发了一个问题，即是什么代码填充了通过`regex_iterator`访问的`match_result`对象。答案在于迭代器的`++`运算符：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this code, a string is searched for words where the second and third letters
    are `at`. The `b` says that the pattern must be at the start of a word (the `.`
    means that the word can start with any letter). There is a capture group around
    these three characters and a second capture group for one or more characters other
    than spaces.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，搜索一个字符串，其中第二个和第三个字母是`at`。`b`表示模式必须位于单词的开头（`.`表示单词可以以任何字母开头）。这三个字符周围有一个捕获组，另一个捕获组是除空格以外的一个或多个字符。
- en: 'The iterator object `next` is constructed with iterators to the string to search
    and the `regex` object. The `++` operator essentially calls the `regex_search`
    function while maintaining the position of the place to perform the next search.
    If the search fails to find the pattern then the operator returns the **end of
    sequence** iterator, which is the iterator that is created by the default constructor
    (the `end` object in this code). This code prints out the full match because we
    use the default parameter for the `str` method (`0`). If you want the actual substring
    matched, use `str(1)` and the result will be:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器对象`next`是使用要搜索的字符串和`regex`对象的迭代器构造的。`++`运算符本质上调用`regex_search`函数，同时保持执行下一个搜索的位置。如果搜索未能找到模式，则运算符将返回**序列结束**迭代器，这是由默认构造函数创建的迭代器（在此代码中为`end`对象）。此代码打印出完整的匹配，因为我们使用了`str`方法的默认参数（`0`）。如果要获取实际匹配的子字符串，请使用`str(1)`，结果将是：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since the `*` (and the `->`) operator gives access to a `match_result` object,
    you can also access the `prefix` method to get the string that precedes the match
    and the `suffix` method will return the string that follows the match.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`*`（和`->`）运算符可以访问`match_result`对象，因此还可以访问`prefix`方法以获取匹配之前的字符串，`suffix`方法将返回匹配后的字符串。
- en: 'The `regex_iterator` class allows you to iterate over the matched substrings,
    whereas the `regex_token_iterator` goes one step further in that it also gives
    you access to all submatches. In use, this class is the same as `regex_iterator,`
    except in construction. The `regex_token_iterator` constructor has a parameter
    to indicate which submatch you wish to access through the `*` operator. A value
    of `-1` means you want the prefix, a value of `0` means you want the whole match,
    and a value of `1` or above means you want the numbered sub match. If you wish,
    you can pass an `int vector` or C array with the submatch types that you want:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_iterator`类允许您迭代匹配的子字符串，而`regex_token_iterator`更进一步，它还可以让您访问所有子匹配项。在使用时，这个类与`regex_iterator`相同，只是在构造时不同。`regex_token_iterator`构造函数有一个参数，指示您希望通过`*`运算符访问哪个子匹配。值为`-1`表示您想要前缀，值为`0`表示您想要整个匹配，值为`1`或更高表示您想要编号的子匹配。如果愿意，可以传递一个带有您想要的子匹配类型的`int
    vector`或C数组：'
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Replacing strings
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换字符串
- en: The `regex_replace` method is similar to the other methods in that it takes
    a string (a C string or C++ `string` object, or iterators to a range of characters),
    a `regex` object, and optional flags. In addition, the function has a format string
    and returns a `string`. The format string is essentially passed to the `format`
    method of each `results_match` object from the result of the matches to the regular
    expression. This formatted string is then used as the replacement for the corresponding
    matched substring. If there are no matches, then a copy of the searched string
    is returned.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_replace` 方法类似于其他方法，它接受一个字符串（C 字符串或 C++ `string` 对象，或字符范围的迭代器）、一个 `regex`
    对象和可选标志。此外，该函数有一个格式字符串并返回一个 `string`。格式字符串基本上传递给正则表达式匹配结果的每个 `results_match` 对象的
    `format` 方法。然后，将此格式化字符串用作相应匹配的替换。如果没有匹配，则返回搜索字符串的副本。'
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code, we say that the entire matched string (which should be
    `list<` followed by some text followed by `>` and a space) should be replaced
    with `vector,` followed by the second sub match (`<` followed by some text followed
    by `>` and a space). The result is that `list<int>` will be replaced with `vector<int>`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们说整个匹配的字符串（应该是 `list<` 后跟一些文本，然后是 `>` 和一个空格）应该被替换为 `vector,`，后跟第二个子匹配（`<`
    后跟一些文本，然后是 `>` 和一个空格）。结果是 `list<int>` 将被替换为 `vector<int>`。
- en: Using strings
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串
- en: 'The example will read in emails as a text file and processed. An email in Internet
    message format will be in two parts: the header and message body. This is simple
    processing, so no attempt is carried out to process MIME email body formatting
    (although this code can be used as a starting point for that). The email body
    will start after the first blank line, and Internet standards say that lines should
    be no longer than 78 characters. If they are longer they must not be longer than
    998 characters. This means that newlines (carriage return, linefeed pairs) are
    used to maintain this rule, and that an end of paragraph is indicated by a blank
    line.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将作为文本文件读取并处理电子邮件。互联网消息格式的电子邮件将分为两部分：头部和消息正文。这是简单的处理，因此不会尝试处理 MIME 电子邮件正文格式（尽管此代码可以用作该处理的起点）。电子邮件正文将在第一个空行之后开始，互联网标准规定行不应超过
    78 个字符。如果超过，它们不得超过 998 个字符。这意味着换行符（回车、换行对）用于保持此规则，并且段落的结束由空行表示。
- en: Headers are more complicated. In their simplest form, a header is on a single
    line and is in the form `name:value`. The header name is separated from the header
    value by a colon. A header may be split over more than one line using a format
    called folded white space, where the newline splitting a header is placed before
    whitespace (space, tab, and so on). This means that a line that starts with whitespace
    is the continuation of the header on the previous line. Headers often contain
    `name=value` pairs separated by semicolons, so it is useful to be able separate
    these subitems. Sometimes these subitems do not have a value, that is, there will
    be a subitem terminated by a semicolon.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 头部更加复杂。在最简单的形式中，头部在单独的一行上，格式为 `name:value`。头部名称与头部值之间由冒号分隔。头部可以使用称为折叠空格的格式分成多行，其中分隔头部的换行符放置在空格（空格、制表符等）之前。这意味着以空格开头的行是前一行头部的延续。头部通常包含由分号分隔的
    `name=value` 对，因此能够分隔这些子项目是有用的。有时这些子项目没有值，也就是说，将由分号终止的子项目。
- en: The example will take an email as a series of strings and using these rules
    will create an object with a collection of headers and a string containing the
    body.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将把电子邮件作为一系列字符串，并使用这些规则创建一个包含头部集合和包含正文的字符串的对象。
- en: Creating the project
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Create a folder for the project and create a C++ file called `email_parser.cpp`.
    Since this application will read files and process strings, add includes for the
    appropriate libraries and add code to take the name of a file from the command-line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目创建一个文件夹，并创建一个名为 `email_parser.cpp` 的 C++ 文件。由于此应用程序将读取文件并处理字符串，因此添加适当库的包含，并添加代码以从命令行获取文件名：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A header will have a name and a body. The body could be a single string, or
    one or more subitems. Create a class to represent the body of a header, and for
    the time being, treat this as a single line. Add the following class above the
    `usage` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 头部将有一个名称和一个正文。正文可以是单个字符串，也可以是一个或多个子项目。创建一个表示头部正文的类，并暂时将其视为单行。在 `usage` 函数之前添加以下类：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This simply wraps the class around a `string`; later on we will add code to
    separate out the subitems in the `body` data member. Now create a class to represent
    the email. Add the following code after the `header_body` class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将类封装在一个 `string` 周围；稍后我们将添加代码来分离 `body` 数据成员中的子项目。现在创建一个表示电子邮件的类。在 `header_body`
    类之后添加以下代码：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `headers` data member holds the headers as name/value pairs. The items are
    stored in a `vector` rather than a `map` because as an email is passed from mail
    server to mail server, headers may be added by each server that already exist
    in the email, so headers are duplicated. We could use a `multimap`, but then we
    will lose the ordering of the headers, since a `multimap` will store the items
    in an order that aids searching for items.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers` 数据成员保存头部作为名称/值对。项目存储在 `vector` 中而不是 `map` 中，因为当电子邮件从邮件服务器传递到邮件服务器时，每个服务器可能会添加已存在于电子邮件中的头部，因此头部是重复的。我们可以使用
    `multimap`，但是我们将失去头部的顺序，因为 `multimap` 将按照有助于搜索项目的顺序存储项目。'
- en: A `vector` keeps the items in the order that they are inserted in the container,
    and since we will parse the e-mail serially, this means that the `headers` data
    member will have the header items in the same order as in the e-mail. Add an appropriate
    include so that you can use the `vector` class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 保持容器中插入的项目的顺序，因此，由于我们将按顺序解析电子邮件，这意味着 `headers` 数据成员将按照电子邮件中的顺序包含头部项目。添加适当的包含以便您可以使用
    `vector` 类。'
- en: There are accessors for the body and the headers as a single string. In addition,
    there are accessors that return iterators from the `headers` data member, so that
    external code can iterate through the `headers` data member (a complete implementation
    of this class would have accessors that allow you to search for a header by name,
    but for the purpose of this example, only iteration is permitted).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正文和标题有单个字符串的访问器。此外，还有访问器从`headers`数据成员返回迭代器，以便外部代码可以遍历`headers`数据成员（此类的完整实现将具有允许您按名称搜索标题的访问器，但在此示例的目的上，只允许迭代）。
- en: The class supports two-stage construction, where most of the work is carried
    out by passing an input stream to the `parse` method. The `parse` method reads
    in the email as a series of lines in a `vector` object and it calls a private
    function, `process_headers`, to interpret these lines as headers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该类支持两阶段构造，其中大部分工作是通过将输入流传递给`parse`方法来完成的。`parse`方法将电子邮件作为`vector`对象中的一系列行读入，并调用一个私有函数`process_headers`来解释这些行作为标题。
- en: 'The `get_headers` method is simple: it just iterates through the headers and
    puts one header on each line in the format `name: value`. Add the inline function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_headers`方法很简单：它只是遍历标题，并以`name: value`的格式将一个标题放在每一行。添加内联函数：'
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, you need to read in the email from a file and extract the body and the
    headers. The `main` function already has the code to open a file, so create an
    `email` object and pass the `ifstream` object for the file to the `parse` method.
    Now print out the parsed email using the accessors. Add the following to the end
    of the `main` function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要从文件中读取电子邮件并提取正文和标题。`main`函数已经有打开文件的代码，因此创建一个`email`对象，并将文件的`ifstream`对象传递给`parse`方法。现在使用访问器打印出解析后的电子邮件。在`main`函数的末尾添加以下内容：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After the `email` class declaration, add the definition for the `parse` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`email`类声明之后，添加`parse`函数的定义：
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This method is simple: it repeatedly calls the `getline` function in the `<string>`
    library to read a `string` until a newline is detected. In the first half of the
    method, the strings are stored in a `vector` and then passed to the `process_headers`
    method. If the string read in is empty, it means a blank line has been read--in
    which case, all of the headers have been read. In the second half of the method,
    the body of the e-mail is read in. The `getline` function will have stripped the
    newlines used to format the email to 78-character line lengths, so the loop merely
    appends the lines as one string. If a blank line is read in, it indicates the
    end of a paragraph, and so a newline is added to the body string.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法很简单：它重复调用`<string>`库中的`getline`函数来读取`string`，直到检测到换行符。在方法的前半部分，字符串存储在`vector`中，然后传递给`process_headers`方法。如果读入的字符串为空，这意味着已读取空行--在这种情况下，所有标题都已读取。在方法的后半部分，读入电子邮件的正文。`getline`函数将剥离用于将电子邮件格式化为78个字符行长度的换行符，因此循环仅将行附加为一个字符串。如果读入空行，则表示段落结束，因此在正文字符串中添加换行符。
- en: 'After the `parse` method, add the `process_headers` method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在`parse`方法之后，添加`process_headers`方法：
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This code iterates through each line in the collection, and when it has a complete
    header it splits the string into the name/body pair on the colon. Within the loop,
    the first line tests to see if the first character is whitespace; if not, then
    the `header` variable is checked to see if it has a value; and if so, the name/body
    pair are stored in the class `headers` data member before clearing the `header`
    and `body` variables.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码遍历集合中的每一行，并在具有完整标题时将字符串拆分为名称/正文对。在循环内，第一行测试第一个字符是否为空格；如果不是，则检查`header`变量是否有值；如果有，则将名称/正文对存储在类`headers`数据成员中，然后清除`header`和`body`变量。
- en: The following code acts upon the line read from the collection. This code assumes
    that this is the start of the header line, so the string is searched for the colon
    and split at this point. the name of the header is before the colon and the body
    of the header (trimmed of leading whitespace) is after the colon. Since we do
    not know if the header body will be folded onto the next line, the name/body is
    not stored; instead, the `while` loop is allowed to repeat another time so that
    the first character of the next line can be tested to see if it is whitespace,
    and if so, it is appended to the body. This action of holding the name/body pair
    until the next iteration of the `while` loop means that the last line will not
    be stored in the loop, and hence there is a test at the end of the method to see
    if the `header` variable is empty, and if not, the name/body pair is stored.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码对从集合中读取的行进行操作。此代码假定这是标题行的开头，因此在该点搜索冒号并在此处拆分字符串。冒号之前是标题的名称，冒号之后是标题的正文（去除了前导空格）。由于我们不知道标题正文是否会折叠到下一行，因此不存储名称/正文；相反，允许`while`循环重复一次，以便测试下一行的第一个字符是否是空格，如果是，则将其附加到正文。将名称/正文对保持到`while`循环的下一次迭代的操作意味着最后一行不会存储在循环中，因此在方法的末尾有一个测试，以查看`header`变量是否为空，如果不是，则存储名称/正文对。
- en: 'You can now compile the code (remember to use the `/EHsc` switch) to test that
    there are no typos. To test the code, you should save an email from your email
    client as a file and then run the `email_parser` application with the path to
    this file. The following is one of the example email messages given in the Internet
    Message Format RFC 5322, which you can put into a text file to test the code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译代码（记得使用`/EHsc`开关）来测试是否有拼写错误。要测试代码，您应该将电子邮件客户端中的电子邮件保存为文件，然后使用该文件的路径运行`email_parser`应用程序。以下是互联网消息格式RFC
    5322中给出的一个示例电子邮件消息，您可以将其放入文本文件中以测试代码：
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You can test the application with an email message to show that the parsing
    has taken into account header formatting, including folding whitespace.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过电子邮件消息测试应用程序，以显示解析已考虑到标题格式，包括折叠空格。
- en: Processing header subitems
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理标题子项
- en: 'The next action is to process the header bodies into subitems. To do this,
    add the following highlighted declaration to the `public` section of the `header_body`
    class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将标题主体处理为子项。为此，请在 `header_body` 类的 `public` 部分添加以下突出声明：
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Each subitem will be a name/value pair, and since the order of a subitem may
    be important, the subitems are stored in a `vector`. Change the `main` function,
    remove the call to `get_headers`, and instead print out each header individually:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子项将是一个名称/值对，由于子项的顺序可能很重要，因此子项存储在 `vector` 中。更改 `main` 函数，删除对 `get_headers`
    的调用，而是逐个打印每个标题：
- en: '[PRE74]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Since the `email` class implements the `begin` and `end` methods, it means that
    the ranged `for` loop will call these methods to get access to the iterators on
    the `email::headers` data member. Each iterator will give access to a `pair<string,header_body>`
    object, so in this code we first print out the header name and then access the
    subitems on the `header_body` object. If there are no subitems, there will still
    be some text for the header, but it won't be split into subitems, so we call the
    `get_body` method to get the string to print. If there are subitems then these
    are printed out. Some items will have a body and some will not. If the item has
    a body then the subitem is printed in the form `name = value`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `email` 类实现了 `begin` 和 `end` 方法，这意味着范围 `for` 循环将调用这些方法以访问 `email::headers`
    数据成员上的迭代器。每个迭代器将提供对 `pair<string,header_body>` 对象的访问，因此在此代码中，我们首先打印出标题名称，然后访问
    `header_body` 对象上的子项。如果没有子项，标题仍将有一些文本，但不会被拆分为子项，因此我们调用 `get_body` 方法获取要打印的字符串。如果有子项，则将其打印出来。某些项目将具有主体，而其他项目则没有。如果项目有主体，则以
    `name = value` 的形式打印子项。
- en: 'The final action is to parse the header bodies to split them into subitems.
    Below the `header_body` class, add the definition of the method to this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的操作是解析标题主体以将其拆分为子项。在 `header_body` 类下面，添加该方法的定义：
- en: '[PRE75]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Since subitems are separated using semicolons there is a simple test to look
    for a semicolon on the `body` string. If there is no semicolon, then an empty
    `vector` is returned.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子项使用分号分隔，因此可以简单地测试 `body` 字符串上的分号。如果没有分号，则返回一个空的 `vector`。
- en: Now the code must repeatedly parse through the string, extracting subitems.
    There are several cases that need to be addressed. Most subitems will be in the
    form `name=value;,` so this subitem must be extracted and split at the equals
    character and the semicolon discarded.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码必须重复解析字符串，提取子项。有几种情况需要解决。大多数子项将采用 `name=value;,` 的形式，因此必须提取此子项并在等号字符处拆分，并丢弃分号。
- en: Some subitems do not have a value and are in the form `name;` in which case,
    the semicolon is discarded and an item is stored with an empty string for the
    subitem value. Finally, the last item in a header may not be terminated with a
    semicolon, so this must be taken into account.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一些子项没有值，其形式为 `name;`，在这种情况下，分号被丢弃，并且为子项值存储了一个空字符串。最后，标题中的最后一个项目可能没有以分号结尾，因此必须考虑这一点。
- en: 'Add the following `while` loop:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下 `while` 循环：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As the name suggests, the `start` variable is the start index of a subitem
    and `end` is the end index of a subitem. The first action is to ignore any whitespace,
    so within the `while` loop add:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，`start` 变量是子项的起始索引，`end` 是子项的结束索引。第一步是忽略任何空格，因此在 `while` 循环中添加：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This simply increments the `start` index while it refers to a whitespace character
    and as long as it has not reached the end of the string. If the end of the string
    is reached, it means there are no more characters and so the loop is finished.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在引用空格字符时递增 `start` 索引，只要它尚未达到字符串的末尾。如果达到字符串的末尾，这意味着没有更多的字符，因此循环结束。
- en: 'Next, add the following to search for the `=` and `;` characters and handle
    one of the search situations:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下内容以搜索 `=` 和 `;` 字符并处理其中一个搜索情况：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `find` method will return the `npos` value if the searched item cannot be
    found. The first call looks for the `=` character and the second call looks for
    a semicolon. If no `=` can be found then the item has no value, just a name. If
    the semicolon cannot be found, then it means that the `name` is the entire string
    from the `start` index until the end of the string. If there is a semicolon, then
    the `name` is from the `start` index until the index indicated by `end` (and hence
    the number of characters to copy is `end-start`). If an `=` character is found
    then the string needs to be split at this point, and that code will be shown in
    a moment. Once the `name` and `value` variables have been given values, these
    are inserted into the `subitems` data member and the `start` index is moved to
    the character after the `end` index. If the `end` index is `npos` then the value
    of the `start` index will be invalid, but this does not matter because the `while`
    loop will test the value of the `end` index and will break the loop if the index
    is `npos`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 方法如果找不到搜索的项目，将返回 `npos` 值。第一次调用查找 `=` 字符，第二次调用查找分号。如果找不到 `=`，则该项目没有值，只有一个名称。如果找不到分号，则意味着
    `name` 是从 `start` 索引到字符串末尾的整个字符串。如果有分号，则 `name` 是从 `start` 索引到 `end` 指示的索引（因此要复制的字符数是
    `end-start`）。如果找到 `=` 字符，则需要在此处拆分字符串，稍后将显示该代码。一旦给定了 `name` 和 `value` 变量的值，它们将被插入到
    `subitems` 数据成员中，并且 `start` 索引将移动到 `end` 索引之后的字符。如果 `end` 索引是 `npos`，则 `start`
    索引的值将无效，但这并不重要，因为 `while` 循环将测试 `end` 索引的值，并且如果索引是 `npos`，则会中断循环。'
- en: 'Finally, you need to add the code for when there is an `=` character in the
    subitem. Add the following highlighted text:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要添加当子项中有 `=` 字符时的代码。添加以下突出显示的文本：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first line tests to see if the search for a semicolon failed. In this case,
    the name is from the `start` index until the character before the equals character,
    and the value is the text following the equals sign until the end of the string.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行测试是否搜索分号失败。在这种情况下，名称是从`start`索引到等号字符之前的字符，值是等号后的文本直到字符串的末尾。
- en: If there are valid indices for the equals and semicolon characters then there
    is one more situation to check for. It is possible that the location of the equals
    character could be after the semicolon, in which case it means that this subitem
    does not have a value, and the equals character will be for a subsequent subitem.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果等号和分号字符有有效的索引，那么还有一种情况需要检查。可能等号字符的位置在分号之后，这种情况下意味着这个子项没有值，等号字符将用于后续子项。
- en: At this point you can compile the code and test it with a file containing an
    email. The output from the program should be the email split into headers and
    a body, and each header split into subitems, which may be a simple string or a
    `name=value` pair.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以编译代码并使用包含电子邮件的文件进行测试。程序的输出应该是电子邮件分成标题和正文，每个标题分成子项，可以是简单的字符串或`name=value`对。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen the various C++ standard library classes that
    support strings. You have seen how to read strings from streams, how to write
    strings to streams, how to convert between numbers and strings, and how to manipulate
    strings using regular expressions. When you write code, you will inevitably spend
    time running your code to check if it works according to your specifications.
    This will involve providing code that checks the results of your algorithms, code
    that logs intermediate code to a debugging device, and, of course, running the
    code under a debugger. The next chapter is all about debugging code!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了支持字符串的各种C++标准库类。您已经了解了如何从流中读取字符串，如何将字符串写入流，如何在数字和字符串之间进行转换，以及如何使用正则表达式来操作字符串。当您编写代码时，您将不可避免地花时间运行代码，以检查它是否符合您的规范。这将涉及提供检查算法结果的代码，将中间代码记录到调试设备的代码，当然还有在调试器下运行代码。下一章将全面讨论调试代码！
