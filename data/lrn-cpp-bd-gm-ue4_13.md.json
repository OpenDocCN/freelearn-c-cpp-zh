["```cpp\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Runtime/Engine/Classes/Particles/ParticleSystemComponent.h\"\n#include \"Spell.generated.h\"\n\nUCLASS()\nclass GOLDENEGG_API ASpell : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ASpell(const FObjectInitializer&amp; ObjectInitializer);\n\n    // box defining volume of damage \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        Spell)\n        UBoxComponent* ProxBox;\n\n    // the particle visualization of the spell \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        Spell)\n        UParticleSystemComponent* Particles;\n\n    // How much damage the spell does per second \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Spell)\n        float DamagePerSecond;\n\n    // How long the spell lasts \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Spell)\n        float Duration;\n\n    // Length of time the spell has been alive in the level \n    float TimeAlive;\n\n    // The original caster of the spell (so player doesn't \n    // hit self) \n    AActor* Caster;\n\n    // Parents this spell to a caster actor \n    void SetCaster(AActor* caster);\n\n    // Runs each frame. override the Tick function to deal damage  \n    // to anything in ProxBox each frame. \n    virtual void Tick(float DeltaSeconds) override;\n};\n```", "```cpp\n#include \"Monster.h\" \n#include \"Kismet/GameplayStatics.h\"\n#include \"Components/CapsuleComponent.h\"\n```", "```cpp\nASpell::ASpell(const FObjectInitializer&amp; ObjectInitializer)\n : Super(ObjectInitializer)\n{\n ProxBox = ObjectInitializer.CreateDefaultSubobject<UBoxComponent>(this,\n TEXT(\"ProxBox\")); \n Particles = ObjectInitializer.CreateDefaultSubobject<UParticleSystemComponent>(this,\n TEXT(\"ParticleSystem\"));\n\n // The Particles are the root component, and the ProxBox \n // is a child of the Particle system. \n // If it were the other way around, scaling the ProxBox \n // would also scale the Particles, which we don't want \n RootComponent = Particles;\n ProxBox->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\n Duration = 3;\n DamagePerSecond = 1;\n TimeAlive = 0;\n\n PrimaryActorTick.bCanEverTick = true;//required for spells to \n // tick! \n}\n```", "```cpp\nvoid ASpell::SetCaster(AActor *caster)\n{\n Caster = caster;\n RootComponent->AttachToComponent(caster->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);\n}\n```", "```cpp\nvoid ASpell::Tick(float DeltaSeconds)\n{\n    Super::Tick(DeltaSeconds);\n\n    // search the proxbox for all actors in the volume. \n    TArray<AActor*> actors;\n    ProxBox->GetOverlappingActors(actors);\n\n    // damage each actor the box overlaps \n    for (int c = 0; c < actors.Num(); c++)\n    {\n        // don't damage the spell caster \n        if (actors[c] != Caster)\n        {\n            // Only apply the damage if the box is overlapping \n            // the actors ROOT component. \n            // This way damage doesn't get applied for simply  \n            // overlapping the SightSphere of a monster \n            AMonster *monster = Cast<AMonster>(actors[c]);\n\n            if (monster &amp;&amp; ProxBox->IsOverlappingComponent(Cast<UPrimitiveComponent>(monster->GetCapsuleComponent())))\n            {\n                monster->TakeDamage(DamagePerSecond*DeltaSeconds,\n                    FDamageEvent(), 0, this);\n            }\n\n            // to damage other class types, try a checked cast  \n            // here.. \n        }\n    }\n\n    TimeAlive += DeltaSeconds;\n    if (TimeAlive > Duration)\n    {\n        Destroy();\n    }\n}\n```", "```cpp\n// inside class APickupItem: \n// If this item casts a spell when used, set it here \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item) \nUClass* Spell;\n```", "```cpp\nstruct Widget \n{ \n  Icon icon; \n  FVector2D pos, size; \n  ///.. and some member functions \n}; \n```", "```cpp\nvoid AAvatar::CastSpell( UClass* bpSpell ) \n{ \n  // instantiate the spell and attach to character \n  ASpell *spell = GetWorld()->SpawnActor<ASpell>(bpSpell,  \n   FVector(0), FRotator(0) ); \n\n  if( spell ) \n  { \n    spell->SetCaster( this ); \n  } \n  else \n  { \n    GEngine->AddOnScreenDebugMessage( 1, 5.f, FColor::Yellow,  \n    FString(\"can't cast \") + bpSpell->GetName() ); } \n} \n```", "```cpp\nASpell *spell = GetWorld()->SpawnActor<ASpell>( bpSpell,  \n   FVector(0), FRotator(0) );\n```", "```cpp\nstruct Widget\n{\n    Icon icon;\n    // bpSpell is the blueprint of the spell this widget casts \n    UClass *bpSpell;\n    FVector2D pos, size;\n    //...\n};\n```", "```cpp\n// From APickupItem::Prox_Implementation(): \navatar->Pickup( this ); // give this item to the avatar \n// delete the pickup item from the level once it is picked up \nDestroy(); \n```", "```cpp\n// Put this in Avatar.h \nTMap<FString, UClass*> Spells; \n```", "```cpp\n// the spell associated with the item \nSpells.Add(item->Name, item->Spell); \n```", "```cpp\n// In AAvatar::ToggleInventory() \nWidget w(Icon(fs, tex));\nw.bpSpell = Spells[it->Key];\nhud->addWidget(w);\n```", "```cpp\nvoid AMyHUD::MouseRightClicked()\n{\n    FVector2D mouse;\n    APlayerController *PController = GetWorld()->GetFirstPlayerController();\n    PController->GetMousePosition(mouse.X, mouse.Y);\n    for (int c = 0; c < widgets.Num(); c++)\n    {\n        if (widgets[c].hit(mouse))\n        {\n            AAvatar *avatar = Cast<AAvatar>(\n                UGameplayStatics::GetPlayerPawn(GetWorld(), 0));\n            if (widgets[c].bpSpell)\n                avatar->CastSpell(widgets[c].bpSpell);\n        }\n    }\n}\n```", "```cpp\nvoid AAvatar::MouseRightClicked() \n{ \n  if( inventoryShowing ) \n  { \n    APlayerController* PController = GetWorld()- \n     >GetFirstPlayerController(); \n    AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() ); \n    hud->MouseRightClicked(); \n  } \n}\n```", "```cpp\n// In AAvatar::SetupPlayerInputComponent(): \nPlayerInputComponent->BindAction(\"MouseClickedRMB\", IE_Pressed, this,\n        &amp;AAvatar::MouseRightClicked);\n```"]