- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: In a C++ Class, Order Must There Be
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++类中，顺序必须存在
- en: '*When law and order* *kill creativity*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*当法律和秩序* *扼杀创造力*'
- en: Ordering items is essential across various domains to ensure organization, efficiency,
    and clarity. Whether in libraries or contact lists through alphabetical ordering,
    customer service queues or data analysis with numerical sorting, timelines or
    appointments by chronology, task management or emergency response prioritization,
    inventory or digital file categorization, competition rankings, clothing size
    arrangement, geographical routing in travel or mail delivery, sequential steps
    in manufacturing or software development, or hierarchical structuring in organizations
    and biological taxonomies, ordering helps streamline processes, improve accessibility,
    and enhance decision-making.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在各个领域对物品进行排序是确保组织、效率和清晰性的关键。无论是在图书馆或通过字母顺序排列的联系人列表，客户服务队列或使用数字排序的数据分析，按时间顺序排列的时间表或预约，任务管理或紧急响应优先级，库存或数字文件分类，比赛排名，服装尺码排列，旅行中的地理路线或邮件投递，制造或软件开发中的顺序步骤，或者在组织机构和生物分类学中的层级结构，排序有助于简化流程，提高可访问性，并增强决策能力。
- en: By applying different criteria, such as alphabetical, numerical, chronological,
    priority, categorical, ranking, size, geographical, sequential, or hierarchical,
    ordering facilitates better management and optimal functioning in diverse contexts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用不同的标准，如字母顺序、数字顺序、时间顺序、优先级、分类、排名、大小、地理顺序、顺序或层级，排序在多种环境中促进更好的管理和最优化的运作。
- en: In this chapter, we will explore why it is important to have a specific order
    for members of a C++ class and what we can gain and lose when properly or improperly
    declaring the members of a class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨为什么C++类成员的特定顺序很重要，以及当我们正确或错误地声明类成员时，我们可以获得什么和失去什么。
- en: Also, we will get a quick overview of what the order of operations is in C++,
    because that is a topic that to some extent can be quite confusing, even for more
    advanced programmers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将快速了解C++中运算符优先级的顺序，因为这是一个在一定程度上可能相当令人困惑的话题，即使是对于更高级的程序员来说也是如此。
- en: 'With this chapter, you will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你将学习以下内容：
- en: The importance of properly declaring class members in a specific order
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确声明类成员的特定顺序的重要性
- en: The importance of initializing your class members in the required order
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照所需顺序初始化类成员的重要性
- en: The proper order of operation executions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确执行运算符的顺序
- en: Size does matter
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小确实很重要
- en: We have learned in school about the alphabet, that puts all letters in a specific
    order, like A, B, C if you are English, or A, Ă, Â if you’re Romanian (yes, there
    are a surprisingly large number of variations to the letter A at the beginning
    of the Romanian alphabet). Not everyone alive today is sure about the reasoning
    of the order, but since todays’ alphabets are based on older ones, such as Α,
    Β, Γ for the Greeks or 𓀀, 𓁐, 𓁣 and even 𓁷 for our Ancient Egyptian ancestors,
    we can’t really be sure why this succession of characters has emerged.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在学校学过关于字母表的知识，它将所有字母按照特定的顺序排列，比如如果你是英语使用者，顺序是A, B, C；如果你是罗马尼亚人，顺序是A, Ă, Â（是的，罗马尼亚字母表中A字母的开头有令人惊讶的大量变体）。但并不是今天所有活着的人都能确定这种顺序的推理，但既然今天的字母表是基于更古老的字母表，比如希腊人的Α,
    Β, Γ，或者我们古埃及祖先的𓀀, 𓁐, 𓁣，甚至还有𓁷，我们实际上无法确定为什么这种字符的顺序会出现。
- en: The alphabet is a very handy thing; it helps us organize and categorize everything
    that can be named. From insects, with ants being categorized before bees, through
    to the spices in your cupboard (except if you organize yours based on color or,
    even better, usage frequency… poor dear Zimbabwean mufushwa, you’ll stay in the
    back for now), it helps us greatly in keeping our daily lives neat and organized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字母表是一个非常方便的工具；它帮助我们组织和分类所有可以命名的物品。从昆虫，蚂蚁的分类在蜜蜂之前，到你的橱柜里的香料（除非你根据颜色或，甚至更好的，使用频率来组织它们……可怜的津巴布韦的mufushwa，你现在会放在后面），它极大地帮助我们保持日常生活整洁有序。
- en: Before we venture too off topic, however, let’s remember that this is a book
    about programming (more specifically, C++ programming), and thus we need to keep
    focused on our subject, and not get distracted talking about the bees and the
    birds (bees come before birds alphabetically, of course).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们离题太远之前，让我们记住，这是一本关于编程的书（更具体地说，是C++编程），因此我们需要专注于我们的主题，不要被谈论蜜蜂和鸟儿（当然，按字母顺序，蜜蜂排在鸟儿之前）所分散注意力。
- en: Organizing C++ concepts can, however, be a very daunting topic. By *concepts*
    , I mean functions, classes, and variables, and not the very handy feature called
    concepts introduced in C++20, which sadly is not the topic of this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 C++ 概念可能是一个非常令人畏惧的话题。在这里，我所说的**概念**是指函数、类和变量，而不是 C++20 中引入的非常实用的**概念**特性，遗憾的是，这并不是本书的主题。
- en: You can’t really do it the way you want, because some functions need to see
    other functions and some blocks of code need to access variables that you have
    to make sure were defined before them. So, carefully crafting a C++ program can
    be very difficult.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上不能按照你想要的方式去做，因为一些函数需要看到其他函数，一些代码块需要访问你确保在它们之前定义的变量。因此，精心构建一个 C++ 程序可能非常困难。
- en: Things change, however, when the discussion turns to C++ classes. You see, in
    a class, these visibility-related annoyances do not really matter. All the methods
    of a class see all the other methods of that class, and all member functions can
    be directly accessed in all the member functions, so life in a class is easy…
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当讨论转向 C++ 类时，情况就变了。你看，在一个类中，这些与可见性相关的问题实际上并不重要。一个类的所有方法都可以看到该类的所有其他方法，所有成员函数都可以在所有成员函数中直接访问，所以在类中的生活很轻松……
- en: 'Now, dear C++ disciple, I hear you cry, “But you should never call the destructor
    or the constructor of a class from within the class!” I mostly agree, but there’s
    nothing stopping me from writing a method such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，亲爱的 C++ 学徒，我听到你喊道：“但你永远不应该在类内部调用类的析构函数或构造函数！”我大部分同意，但没有任何阻止我编写如下方法的事情：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, if you write code like this, dear reader, you will suffer the consequences.
    But back to our initial topic: ordering.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你像这样编写代码，亲爱的读者，你将承担后果。但回到我们最初的主题：排序。
- en: Inherently, the human mind craves order. We need to be able to have an overview
    of what we are working with, where that information is, and how to locate it as
    easily as possible. It is imperative to easily and quickly find the required information,
    even if it is as insignificant as the whereabouts of a member of a class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的大脑天生渴望秩序。我们需要能够对正在处理的内容有一个全面的了解，知道这些信息在哪里，以及如何尽可能容易地找到它们。轻松快速地找到所需信息是至关重要的，即使它像类成员的位置这样微不足道。
- en: 'So, after endless struggles with locating lost members of a class, it came
    as a revelation to one game programmer (let’s call him Joe) who was happily working
    at the BigGameDev company that all the members of the class should be organized
    in alphabetical order. Brilliant, now everyone can easily locate where their required
    member is. And look how beautiful the code is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在无尽地寻找类中丢失的成员之后，一位游戏程序员（让我们称他为 Joe）在 BigGameDev 公司愉快地工作时，突然意识到类中的所有成员都应该按字母顺序组织。太棒了，现在每个人都可以轻松地找到他们需要的成员。看看代码有多漂亮：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is not a particularly complicated use case; it is just a point in some
    game that tells us where a point is, by providing *x* , *y* , and *z* coordinates,
    and it gives a small insight into the workings of the point, to tell us whether
    that specific point is active or not. Life is good. The game runs neatly, and
    the players are happy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个特别复杂的使用场景；它只是游戏中某个点的一个位置，通过提供 *x*、*y* 和 *z* 坐标来告诉我们点的位置，并给出对点工作原理的一些小洞察，告诉我们这个特定的点是否活跃。生活很美好。游戏运行得井井有条，玩家们都很开心。
- en: However, at some point, the lead programmer of the game project thinks that
    some operations on that point take up too much time (I’ll spare you all the quirky
    details of what operations those are and why they need it) and those operations
    should be performed only if the point has recorded a change of values in all three
    coordinates. Joe, our programmer, is a good and very methodic programmer, and
    he knows that one solution would be to store three other **double** values, representing
    the previous *x* , *y* , and *z* coordinates, update those on change, if any,
    and perform the requested operation only if the values differ.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某个时候，游戏项目的首席程序员认为对该点的某些操作花费了太多时间（我将省略所有关于这些操作是什么以及为什么需要它们的奇特细节），并且这些操作只有在该点记录了所有三个坐标值的变化时才应该执行。我们的程序员
    Joe 是一个好人，而且非常有条理，他知道一个解决方案是存储三个其他的 **double** 类型的值，代表之前的 *x*、*y* 和 *z* 坐标，在有任何变化时更新这些值，并且只有在值发生变化时才执行请求的操作。
- en: 'However, he discards that idea and quickly concocts a different one: he will
    keep a **bool** flag for recording the change of each required coordinate, since
    he knows that a **bool** usually takes up only 1 byte, while a double on their
    platform boasts up to 8 bytes. That is a saving of… well, 21 bytes. So, here is
    Joe’s new class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，他放弃了那个想法，迅速想出了另一个主意：他将保留一个用于记录每个所需坐标变化的**布尔**标志，因为他知道**布尔**通常只占用1个字节，而他们平台上的**双精度浮点数**最多占用8个字节。这样节省了……好吧，21个字节。所以，这是乔的新类：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Beautiful – as with all the code he writes, it’s almost like poetry. He submits
    the newly written piece of code to the repository, where it will be built overnight,
    and the freshly baked binary will be delivered for testing the next day. And then
    he does not go on vacation, because he is a diligent programmer; summer is still
    some time away, so he will wait for the testing team to approve the code before
    booking plane tickets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 美丽——就像他写的所有代码一样，它几乎就像诗歌。他将新编写的代码提交到仓库，那里将在夜间构建，第二天将交付新鲜出炉的二进制文件进行测试。然后他不会去度假，因为他是一个勤奋的程序员；夏天还早，所以他将在测试团队批准代码后再预订机票。
- en: Overnight, the automated tests explode, every suite fails, and the entire dashboard
    is red like the flag of some communist country. The next day, the entire testing
    department faces fatal failures, the game crashes, and 99.9% of the errors at
    some point relate to out-of-memory issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那一夜，自动化测试爆炸了，每个测试套件都失败了，整个仪表板像某些共产主义国家的旗帜一样变成了红色。第二天，整个测试部门面临了致命的失败，游戏崩溃了，99.9%的错误在某个时刻都与内存不足问题有关。
- en: The application suddenly consumes almost double the memory it was expected to
    consume, the test machines struggle to keep the desired frame rate, and everything
    is slowed down, except the memory allocation checks, which steadily show that
    the application now uses a lot more than yesterday.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序突然消耗了几乎是其预期消耗量两倍的内存，测试机器努力保持所需的帧率，一切都在变慢，除了内存分配检查，它稳定地显示应用程序现在使用的内存比昨天多得多。
- en: There were not too many changes, besides Joe’s own point class overhaul; some
    other developer had changed the background color in the main menu from dark gray
    to black (sadly, the developer who was supposed to implement the ground-breaking
    change that requested Joe’s change had to stay at home with a sick child that
    day), so the development team gathers to discuss the newly found issue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了乔自己对其点类的全面重写之外，并没有太多变化；有其他开发者将主菜单的背景颜色从深灰色改为了黑色（遗憾的是，本应实施乔所请求的具有里程碑意义的变更的开发者那天不得不在家照顾生病的孩子），因此开发团队聚集在一起讨论新发现的问题。
- en: The lead developer (let’s call him Jimmy for his mastery in the programming
    languages) takes a look at the code and quickly proclaims, “Joe, mate, I really
    appreciate the neatness of your code, and that you organize the members alphabetically,
    but I will have to kindly ask you to change the order of them.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主开发人员（让我们称他为吉米，以表彰他在编程语言方面的精通）看了看代码，并迅速宣布，“乔，伙计，我真的很欣赏你代码的整洁性，以及你按字母顺序组织成员的方式，但我将不得不礼貌地请你改变它们的顺序。”
- en: Joe turns almost as red as the test failure indicators on the continuous integration
    monitoring screen, but since he is a reasonable person, he kindly asks why on
    Earth he should do that. Doesn’t Jimmy see the beauty in the code?!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 乔的脸色几乎和持续集成监控屏幕上的测试失败指示器一样红，但他是一个理性的人，所以他友好地询问为什么他应该那样做。吉米看不到代码中的美吗?!
- en: The response from Jimmy stuns him. This is Jimmy’s explanation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 吉米的回应让他震惊。这是吉米的解释。
- en: The memory layout of a C++ class is determined by several factors, including
    the size and alignment requirements of its members, the inheritance hierarchy,
    and padding added by the compiler to satisfy alignment constraints. When talking
    about size, each data member occupies a certain number of bytes based on its type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C++类的内存布局由多个因素决定，包括其成员的大小和对齐要求、继承层次结构，以及编译器为了满足对齐约束而添加的填充。当谈到大小的时候，每个数据成员根据其类型占用一定数量的字节。
- en: I’m sure Joe was aware of this; however, what he might not have grasped entirely,
    looking at his solution, is the alignment of each member. Each data member must
    be stored at a memory address that is a multiple of its alignment requirement.
    The alignment requirement is typically the size of the type, but it can be adjusted
    with compiler-specific directives.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信Joe意识到了这一点；然而，从他的解决方案来看，他可能并没有完全理解每个成员的对齐方式。每个数据成员必须存储在满足其对齐要求的内存地址上。对齐要求通常是类型的大小，但可以通过编译器特定的指令进行调整。
- en: Now, looking at padding, in order to satisfy these alignment constraints, the
    compiler may insert padding bytes between members, and to ensure the size of the
    class is a multiple of the largest alignment requirement, padding may be added
    at the end of the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来看填充，为了满足这些对齐约束，编译器可能会在成员之间插入填充字节，并且为了确保类的大小是最大对齐要求的倍数，可能需要在类的末尾添加填充。
- en: 'Now, the class that the team had initially might have looked like the following
    when it was set up in memory, knowing that on their architecture, the size of
    a double is 8 bytes long:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当在内存中设置时，团队最初可能看起来如下，考虑到在他们架构上，双精度浮点数的大小是8字节：
- en: '![Figure 5.1 – The initial class layout](img/B22235_05_1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 初始类布局](img/B22235_05_1.jpg)'
- en: Figure 5.1 – The initial class layout
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 初始类布局
- en: 'Using this alignment, the size of the class added up being 32 bytes. But now
    that Joe has have added three more **bool** s, each 1 byte long, the compiler
    might have organized the memory according to the following layout:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种对齐方式，添加的类大小总计为32字节。但现在，由于Joe添加了三个额外的**bool**类型，每个1字节长，编译器可能会根据以下布局组织内存：
- en: '![Figure 5.2 – The class layout with the new members in the wrong order](img/B22235_05_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 新成员顺序错误的类布局](img/B22235_05_2.jpg)'
- en: Figure 5.2 – The class layout with the new members in the wrong order
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 新成员顺序错误的类布局
- en: 'So, each byte of **bool** must have been padded up to 8 bytes, in order to
    allow the placement of the double that follows to the proper memory address. This
    made the size of the class grow to 56, because 4 **bool** s padded up to 8 bytes
    plus 3 **double** values, each of them 8 bytes, so the sum of these takes up a
    total of 56 bytes. Clang, the compiler, has a switch that allows us to inspect
    the memory layout of generated classes: **-fdump-record-layouts** . In order to
    put it into good use for this case, we have created a simple source file with
    the previous class definition and passed it down to the compiler in order to inspect
    it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个**bool**的字节都必须填充到8字节，以便将随后的双精度浮点数放置在正确的内存地址上。这使得类的大小增加到56字节，因为4个填充到8字节的**bool**加上3个8字节的双精度浮点数，这些加起来总共占用56字节。Clang编译器有一个开关允许我们检查生成的类的内存布局：**-fdump-record-layouts**。为了在这个情况下充分利用它，我们创建了一个简单的源文件，其中包含了之前的类定义，并将其传递给编译器以进行检查：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding data clearly denotes what we suspected initially, that is, that
    the **bool** that was supposed to take 1 byte now officially occupies 8 (note
    that behind the scenes, we have created a file called **main.cpp** with the content
    of the **point** structure).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据清楚地表明了我们最初怀疑的情况，即原本应该占用1字节的**bool**现在正式占用了8字节（注意，在幕后，我们创建了一个名为**main.cpp**的文件，其中包含了**point**结构的内容）。
- en: 'Now, in order to straighten out this unfortunate situation, we clearly need
    to take some further actions, so let’s consider the reorganization of the members
    of the class in the following manner:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了纠正这种不幸的情况，我们显然需要采取一些进一步的行动，因此让我们考虑以下方式重新组织类的成员：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is not a huge change, besides hurting Joe’s feelings that the members are
    not organized alphabetically. We have grouped together the **bool** values so
    the class is as compact as possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了伤害Joe的感情，成员没有按字母顺序组织之外，这不是一个巨大的变化。我们已经将**bool**值组合在一起，使类尽可能紧凑。
- en: We have used the preceding information, especially taking into consideration
    the size requirements of each of the types, and concluded that it is always better
    to have small types grouped together (by *small types* , we mean variables whose
    type will take up the smallest number of bytes; for example, we know that the
    size of a **bool** variable is 1, at least for the implementation we are using).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了前面的信息，特别是考虑到每种类型的大小要求，并得出结论，将小型类型组合在一起总是更好的（我们所说的“小型类型”是指类型将占用最少的字节数的变量；例如，我们知道**bool**变量的大小是1，至少对于我们所使用的实现）。
- en: 'By doing this, that is, by reorganizing the order in which the members are
    presented, we have created the following memory layout (or something similar but
    more optimal for our architecture):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，即通过重新组织成员的呈现顺序，我们创建了以下内存布局（或者说是针对我们架构更优化的类似布局）：
- en: '![Figure 5.3 – The class layout with the members in the proper order](img/B22235_05_3.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 成员按正确顺序排列的类布局](img/B22235_05_3.jpg)'
- en: Figure 5.3 – The class layout with the members in the proper order
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 成员按正确顺序排列的类布局
- en: 'Indeed, after checking with Clang again, the memory of the class looks very
    different from the previous version (please again ignore the fact that behind
    the scenes, we have modified our **main.cpp** to contain the preceding structure):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，再次使用Clang检查后，类的内存看起来与之前的版本非常不同（请再次忽略幕后我们修改了**main.cpp**以包含前面的结构的事实）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, as we can see now, the four **bool** values are placed in memory one after
    the other, and there is only one section of padding required to fill up the required
    space, for the **double** values to be aligned on the required memory addresses.
    Hypothetically, if we were to have a field with a size of **4** , we could nicely
    fit it after the last **bool** , before the first **double** , and we would not
    need any padding either.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们现在所看到的，四个**bool**值在内存中依次排列，并且只需要一个填充部分来填充所需的空间，以便**double**值对齐到所需的内存地址。假设我们有一个大小为**4**的字段，我们可以在最后一个**bool**之后、第一个**double**之前很好地放置它，并且不需要任何填充。
- en: Upon hearing Jimmy’s explanation, Joe now understood the issue. He had never
    encountered alignment issues before, but he decided to read up on the subject.
    What he read was very interesting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 听了吉米的解释后，乔现在明白了这个问题。他以前从未遇到过对齐问题，但他决定阅读有关这个主题的内容。他读到的内容非常有趣。
- en: It explained that the alignment of variables in memory is necessary due to a
    combination of hardware requirements, performance optimization, and architectural
    constraints. Most modern processors are designed to access memory more efficiently
    when data is aligned to certain boundaries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它解释说，由于硬件要求、性能优化和架构约束的组合，内存中变量的对齐是必要的。大多数现代处理器设计为当数据对齐到某些边界时，更有效地访问内存。
- en: For example, an 8-byte double is typically best accessed at an address that
    is a multiple of 8, and when data is misaligned, the processor may need to perform
    multiple memory accesses to read or write the data, which can be significantly
    slower.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个8字节的double类型通常最好在8的倍数地址上访问，当数据未对齐时，处理器可能需要执行多次内存访问来读取或写入数据，这可能会显著减慢速度。
- en: 'Some architectures, such as the older generation of ARM processors, PowerPC,
    and older MIPS processors, cannot properly handle misaligned access, and in these
    situations, they generate a **SIGBUS** fault, which results in the early termination
    of the application causing the fault. So, for example, the following application,
    when compiled, and the resulting binary executed on a processor of this generation
    will generate a **SIGBUS** fault:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些架构，例如较老一代的ARM处理器、PowerPC和较老的MIPS处理器，无法正确处理未对齐的访问，在这些情况下，它们会生成一个**SIGBUS**故障，这会导致产生故障的应用程序提前终止。例如，以下应用程序在编译后，在一代处理器的结果二进制文件上执行将生成一个**SIGBUS**故障：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The outcome of this highly unpleasant situation on an operating system not prepared
    to handle a misalignment error very often has quite drastic ramifications, such
    as an application crash. Older systems may even produce a system crash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统没有准备好处理对齐错误的情况下，这种高度不愉快的情况往往会产生相当严重的后果，例如应用程序崩溃。较老的系统甚至可能产生系统崩溃。
- en: '![Figure 5.4 – Older system throwing a tantrum when seeing unaligned data](img/B22235_05_4.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 较老系统在看到未对齐数据时大发雷霆](img/B22235_05_4.jpg)'
- en: Figure 5.4 – Older system throwing a tantrum when seeing unaligned data
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 较老系统在看到未对齐数据时大发雷霆
- en: 'You might ask what **error type 7** means. The answer is simple: 7 is the magic
    number that was assigned to the **SIGBUS** error. On the author’s Linux machine,
    it can be found in **/usr/include/x86_64-linux-gnu/bits/signum-arch.h** , on line
    34:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问**错误类型7**是什么意思。答案是简单的：7是分配给**SIGBUS**错误的魔法数字。在作者的Linux机器上，它可以在**/usr/include/x86_64-linux-gnu/bits/signum-arch.h**文件的第34行找到：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some other processors, such as the newer generation x86_64 processors, or even
    the older 80286 (and everything between, mostly adhering to the specifications
    of the x86 platform and beyond), handle these situations very gracefully, with
    a tiny time penalty concerning performance, but they can be easily convinced with
    the following assembly instructions to turn into a very moody persona of themselves:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他处理器，例如较新的x86_64处理器，或者甚至较老的80286（以及两者之间的所有处理器，大多数遵循x86平台规范以及更远），处理这些情况非常优雅，只是在性能上略有时间损失，但它们可以通过以下汇编指令轻松地被说服，变成一个非常多变的个性：
- en: '| **AT&T (** **64 bit)** | **Intel (** **32 bit)** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **AT&T (** **64 bit)** | **Intel (** **32 bit)** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **pushf****orl $0x40000,(%rsp)****popf** | **pushfd****or dword ptr [** **esp],
    40000h****popfd** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **pushf****orl $0x40000,(%rsp)****popf** | **pushfd****or dword ptr [** **esp],
    40000h****popfd** |'
- en: The code above modifies specific bits in the **EFLAGS** register using a bitwise
    OR operation. Specifically, the hexadecimal value **40000h** corresponds to setting
    the **AC** (which stands for alignment check) flag in the **EFLAGS** register,
    this flag is used to control alignment checking. When this flag is set and the
    **AM** (which stands for alignment mask) bit in the **CR0** register is also set,
    the processor checks whether data is aligned on natural boundaries. If data misalignment
    is detected, a fault is generated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用位或操作修改了**EFLAGS**寄存器中的特定位。具体来说，十六进制值**40000h**对应于设置**EFLAGS**寄存器中的**AC**（代表对齐检查）标志，这个标志用于控制对齐检查。当此标志被设置且**CR0**寄存器中的**AM**（代表对齐掩码）位也被设置时，处理器会检查数据是否对齐在自然边界上。如果检测到数据对齐错误，则会生成一个故障。
- en: The **EFLAGS** register is a special-purpose register used in x86 architecture
    CPUs that contains several flags reflecting the state of the processor. These
    flags can control or indicate various conditions, such as arithmetic conditions,
    control features, and system settings. The Intel developer center [1](B22235_05.xhtml#footnote-018)
    contains a plethora of information concerning these low-level programming features.
    We encourage anyone interested in this subject to go and browse that site for
    further information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**EFLAGS** 寄存器是x86架构CPU中用于特殊目的的寄存器，其中包含反映处理器状态的几个标志。这些标志可以控制或指示各种条件，例如算术条件、控制功能和系统设置。英特尔开发者中心[1](B22235_05.xhtml#footnote-018)包含有关这些低级编程特性的大量信息。我们鼓励对这一主题感兴趣的人去浏览该网站以获取更多信息。'
- en: '[1](B22235_05.xhtml#footnote-018-backlink) [https://www.intel.com/content/www/us/en/resources-documentation/developer.html](https://www.intel.com/content/www/us/en/resources-documentation/developer.html)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_05.xhtml#footnote-018-backlink) [https://www.intel.com/content/www/us/en/resources-documentation/developer.html](https://www.intel.com/content/www/us/en/resources-documentation/developer.html)'
- en: When the previous code is inserted into the source code of an application, we
    can see the **SIGBUS** signal in action. We’ll spare listing that code here, because
    no one should write code that intentionally crashes their application, but instead
    let’s examine another one of our friend Joe’s encounters with the curiously occurring
    ordering of class members.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码被插入到应用程序的源代码中时，我们可以看到**SIGBUS**信号在起作用。我们在这里省略了那段代码，因为没有人应该编写故意使他们的应用程序崩溃的代码，而是让我们来检查一下我们的朋友乔与类成员奇特出现顺序的另一次遭遇。
- en: The order that must be respected
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必须遵守的顺序
- en: 'While working at BigGameDev, Joe was given another task that was vaguely related
    to character development – in-game characters, that is, not his own character.
    The task was an easy one: it just required returning a formatted string that expressed
    the value of life points a character has.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在BigGameDev工作期间，乔被分配了另一个与角色发展略有相关的工作——游戏中的角色，即不是他自己的角色。这项任务很简单：只需要返回一个格式化的字符串，表示角色拥有的生命值。
- en: 'In order to implement this, Joe created the following class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，乔创建了以下类：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is as straightforward as it can be. It just takes the input data and stores
    the result in case one needs to access it again. Joe is very happy; the class
    members are organized nicely by type, but he is not sticking to alphabetical order
    anymore (he learned his lesson from the alignment discussion). He even uses modern
    C++, such as the format library or in-class initialization of members, in case
    some are not initialized (we could argue, though, that the strings are initialized
    to an empty string upon creation with the default constructor, so for them, this
    is not as relevant. This isn’t the case for the **int** s), and he is generally
    happy with the code he has written.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常直接的。它只是接收输入数据并将结果存储起来，以防将来需要再次访问。乔非常高兴；类成员按类型组织得很好，但他不再坚持按字母顺序排列（他从对齐讨论中吸取了教训）。他甚至使用了现代C++，比如格式库或成员的类内初始化，以防某些成员没有被初始化（我们可以争论，字符串在默认构造函数创建时被初始化为空字符串，所以对它们来说，这并不那么相关。对于**int**来说就不是这样了），他对所编写的代码总体上感到满意。
- en: 'He would happily commit these into their repository right away, but common
    sense prevails. He does some quick tests, and after ensuring that everything works
    as expected, he asks his supervisor (the same Jimmy to whom we were introduced
    in the previous section) to do a quick review of the code. The code looks OK;
    it compiles and performs the required operations, and there are just two tiny
    observations that are to be added. Joe is given the following feedback: instead
    of doing the assignment of the members in the body of the constructor, an initializer
    list should be used instead. In addition, since he is going to use initializer
    lists anyway, he should make the members const, for some minor optimizations that
    the compiler might decide to throw in at some stage.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 他本可以直接将这些代码提交到他们的仓库中，但常识占了上风。他进行了一些快速测试，并在确保一切按预期工作后，请他的主管（即我们在上一节中介绍过的Jimmy）快速审查一下代码。代码看起来没问题；它编译并执行了所需的操作，只有两个微小的观察需要添加。乔得到了以下反馈：在构造函数的体内分配成员而不是使用初始化列表。此外，由于他无论如何都要使用初始化列表，所以他应该将成员设置为const，以实现一些编译器可能在某个阶段决定提供的微小优化。
- en: 'So, he should have the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他应该这样做：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In C++, using an initialization list in constructors is generally preferred
    over in-body initialization due to several key advantages: it is more efficient
    since it initializes member variables directly rather than initializing them by
    default and then assigning them. Also, it ensures proper initialization of **const**
    and reference members, which cannot be dealt with properly in the body of the
    constructor.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，由于几个关键优势，通常在构造函数中使用初始化列表而不是体内初始化：它更高效，因为它直接初始化成员变量，而不是先默认初始化然后赋值。此外，它确保了**const**和引用成员的正确初始化，这些在构造函数的体内无法得到妥善处理。
- en: 'Joe happily changes the code, and since not that much has changed, he “forgets”
    to test it. Instead, he quickly submits the following sequence to review:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 乔高兴地修改了代码，由于变化不大，他“忘记”测试它了。相反，他迅速提交了以下序列以供审查：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A response does not take too long to arrive and is surprisingly not the pat
    on the back he expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 响应不会花费太多时间就到达了，而且出人意料地并不是他预期的表扬。
- en: “Joe, did you test this code?”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “乔，你测试过这段代码吗？”
- en: He has to admit that he did not consider it necessary, since not that much had
    changed. He just moved a few lines a bit above their previous positions, changed
    an equal sign to a pair of parentheses, and he was done with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 他不得不承认，他没有认为这是必要的，因为变化不大。他只是将几行代码向上移动了一点，将一个等号改为一对括号，然后他就完成了。
- en: “Oh, I see…” said Jimmy, and he pulled out a fresh hardcopy of the latest available
    C++ standard from his back pocket.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，我明白了……”吉米说，他从后口袋里掏出一份最新可用的C++标准的新版印刷本。
- en: 'The standard says the following, in the **[** **class.base.init]** section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 标准在**[** **class.base.init]**部分中如下所述：
- en: 'In a non-delegating constructor, initialization proceeds in the following order:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在非委托构造函数中，初始化按照以下顺序进行：
- en: First, and only for the constructor of the most derived class, virtual base
    classes are initialized in the order they appear on a depth-first left-to-right
    traversal of the directed acyclic graph of base classes, where “left-to-right”
    is the order of appearance of the base classes in the derived class base-specifier-list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，并且仅对于最派生类的构造函数，虚拟基类将按照在基类指定列表中从深度优先左到右遍历基类有向无环图时出现的顺序进行初始化。
- en: Then, direct base classes are initialized in declaration order as they appear
    in the base-specifier-list (regardless of the order of the mem-initializers).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，直接基类将按照它们在基类指定列表中出现的顺序进行初始化（不考虑初始化器成员的顺序）。
- en: Then, non-static data members are initialized in the order they were declared
    in the class definition (again regardless of the order of the mem-initializers).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，非静态数据成员将按照在类定义中声明的顺序进行初始化（再次不考虑初始化器成员的顺序）。
- en: Finally, the compound-statement of the constructor body is executed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行构造函数体的复合语句。
- en: This in practice means that regardless of the order in which you specified the
    members to be initialized in the initializer list, they still will be initialized
    in the order they were declared in the class, so **m_result** will be the first
    one to be initialized, and since it is using the other two data members, which
    have not been initialized yet, the result in the best case will be undefined behavior.
    In the worst case, during testing, you will get default values, and in production,
    the code will fail spectacularly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中意味着，无论你在初始化列表中指定成员初始化的顺序如何，它们仍然会按照在类中声明的顺序进行初始化，所以**m_result**将是第一个被初始化的，由于它使用了其他两个尚未初始化的数据成员，所以最佳情况下结果将是未定义行为。在最坏的情况下，在测试期间，你将得到默认值，在生产中，代码将失败得非常明显。
- en: 'Now, armed with this knowledge, Joe was finally able to deliver the code that
    was expected of him, on time and to the highest possible standard he could implement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，凭借这些知识，乔终于能够按时并以他能够实现的最高标准交付预期的代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: He learned that while using initializer lists can be a godsend in certain situations,
    it can also throw your code to the mythical depths of the seven circles of compiler
    hell when not taking into consideration some basic rules that are set by the C++
    standard.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 他了解到，虽然使用初始化列表在特定情况下可能是一种神赐，但如果忽略了C++标准设定的某些基本规则，它也可能将你的代码抛入神话般的七个编译器地狱的深渊。
- en: The C++ standard makes it mandatory that member objects are initialized in the
    order they are declared within the class, regardless of the order specified in
    the constructor initializer list, because what happens if there is no initializer
    list, or if only some elements are initialized in it?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准规定，成员对象必须按照在类中声明的顺序进行初始化，无论构造函数初始化列表中指定的顺序如何，因为如果没有初始化列表，或者其中只初始化了部分元素，会发生什么？
- en: This order ensures consistency and predictability in the setup process of an
    object. When an object is constructed, initializing members in declaration order
    helps avoid potential issues that could arise if members were initialized out
    of order, especially if some members depend on others being initialized first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序确保了对象设置过程中的一致性和可预测性。当一个对象被构造时，按照声明顺序初始化成员有助于避免如果成员初始化顺序错误可能出现的潜在问题，特别是如果某些成员依赖于其他成员先被初始化。
- en: This mandated order of initialization directly influences the destruction order,
    which is the reverse of initialization. Ensuring that members are destroyed in
    the reverse order of their initialization guarantees that dependent members are
    still valid when they are needed during the destruction phase. This consistent
    and predictable cleanup process prevents potential errors and maintains the integrity
    of the object’s life cycle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规定的初始化顺序直接影响析构顺序，析构顺序与初始化顺序相反。确保成员以初始化顺序的相反顺序被销毁，确保在析构阶段需要时依赖成员仍然有效。这种一致且可预测的清理过程防止潜在错误并保持对象生命周期的完整性。
- en: 'Building on this requirement of the language, we can easily provide an elegant
    and more concise solution to this problem, by using an interesting feature called
    **designated initializers** , which was introduced in C++20. Let’s simplify our
    structure to look along the lines of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基于语言的这个要求，我们可以通过使用一个有趣的功能——称为**指定初始化器**，来轻松地提供一个优雅且更简洁的解决方案，这个功能是在C++20中引入的。让我们简化我们的结构，使其看起来像以下这样：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These simple structures satisfy the requirements to be used as aggregates,
    which are required for the designated initializer feature to compile, and as you
    can see, the **m_result** member is using the already-initialized **m_player**
    and **m_points** members, during the construction of itself. Now, in the place
    where want to use the class, we just have to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的结构满足用作聚合的要求，这对于编译指定的初始化器特性是必需的，正如你所见，**m_result** 成员在自身构造过程中使用了已经初始化的 **m_player**
    和 **m_points** 成员。现在，在我们想要使用类的位置，我们只需做以下操作：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By adhering to this handy feature, we have explicitly specified which member
    should be initialized to which value (this can be very helpful if, for example,
    there are more than two integers that need to be initialized). Also, the feature
    requires the members to be specified in the order of their declaration, thus increasing
    the readability and maintainability of the code. The only drawback is that we
    had to dumb down our class to an **aggregate** , so no virtual functions, no constructors,
    no encapsulation – none of the good stuff that raises a C++ class to mythical
    fame. But if it’s good enough for Joe, we can live with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个方便的特性，我们明确指定了哪个成员应该初始化为哪个值（如果需要初始化的整数超过两个，这可能会非常有帮助）。此外，该特性要求成员按照其声明的顺序指定，从而提高了代码的可读性和可维护性。唯一的缺点是我们不得不将我们的类简化为
    **聚合体**，因此没有虚拟函数，没有构造函数，没有封装——所有这些将 C++ 类提升到神话般名望的好东西都没有了。但如果这对乔来说足够好，我们可以忍受它。
- en: Deep thoughts about order
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入思考关于秩序
- en: 'The adventures of our friend Joe do not end here, because shortly after learning
    that the proper order of class members is not necessarily an alphabetical one,
    he was given a task that involved executing some code in a parallel manner. Since
    he learned everything about threads and associated features by watching a quick
    introductory tutorial to the subject by some guy on TikTok, he felt he was up
    to the task, and shortly, the following code was committed to the repository (please
    bear with the authors in this case; due to some pathological manifestations of
    copyright and intellectual property litigations, we cannot show the original code
    that took the entire development team two weeks to debug and fix. The example
    code is actually just trying to recreate the scenario that Joe so successfully
    implemented):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的朋友乔的冒险并没有结束，因为在他了解到类成员的正确顺序不一定是字母顺序之后不久，他被分配了一个涉及以并行方式执行一些代码的任务。由于他通过观看 TikTok
    上某个人的快速入门教程学习了有关线程及其相关特性的所有内容，他觉得自己能够胜任这项任务，不久之后，以下代码被提交到仓库中（请在这个问题上宽容作者；由于版权和知识产权诉讼的一些病理表现，我们无法展示整个开发团队花费两周时间调试和修复的原始代码。示例代码实际上只是在尝试重现乔成功实施的场景）：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The given C++ program tries to get as close as possible to the simple multithreaded
    mayhem Joe created, using two friendly structures, named **bar** and **foo** (we
    let **baz** take a rest for a short while, but if you miss him, you can name the
    function **baz** ), creating a meaningful interaction in order to perform a task
    on a separate thread. The **bar** structure manages a dynamically allocated **long
    long** variable, **i** (because what else would we call a variable that has the
    role of an index?), which is continuously incremented in its **serve** method.
    When the increment count reaches **1024768** (let’s just ignore the fact that
    1024x768 is also a screen resolution), then it pauses for 200 milliseconds, resets
    the counter **i** to **0** , and prints a dot to the console (in the real-life
    application, something else happened, but that is out of the scope of this book).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 C++ 程序试图尽可能接近乔创造的简单多线程混乱，使用两个友好的结构，命名为 **bar** 和 **foo**（我们让 **baz** 休息一会儿，但如果你想念他，你可以将函数命名为
    **baz**），为了在单独的线程上执行任务，创建有意义的交互。**bar** 结构管理一个动态分配的 **long long** 变量，**i**（因为我们会叫一个具有索引角色的变量叫什么呢？），它在
    **serve** 方法中不断递增。当递增计数达到 **1024768**（让我们忽略 1024x768 也是一个屏幕分辨率的事实），然后它暂停 200 毫秒，将计数器
    **i** 重置为 **0**，并在控制台打印一个点（在现实生活中的应用程序中，发生了其他事情，但这超出了本书的范围）。
- en: This loop continues indefinitely until **stopRequest** is set to **true** ,
    signaling the thread to exit. The constructor of **bar** initializes the counter
    **i** , and for our sole purpose of debugging, it prints a message, while the
    destructor handles memory cleanup and prints another message, ensuring that resources
    are properly managed. Why Joe does not use a smart pointer is another story, so
    let’s not focus on that part for now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会无限期地继续，直到 **stopRequest** 被设置为 **true**，向线程发出退出信号。**bar** 的构造函数初始化计数器 **i**，并且出于我们唯一的调试目的，它打印一条消息，而析构函数处理内存清理并打印另一条消息，确保资源得到适当管理。至于乔为什么没有使用智能指针，又是另一个故事了，所以我们现在就先不关注那个部分。
- en: The **foo** structure is responsible for starting and stopping the thread that
    runs the **serve** method of a **bar** instance. Upon creation, **foo** initializes
    a **std::jthread** to run its **threadFunc** , which in turn calls the **serve**
    method of its **bar** instance. This setup allows the **serve** method to run
    concurrently with the **main** program. The **foo** destructor sets **stopRequest**
    to **true** , ensuring the thread exits gracefully. Again, it remained a mystery
    why Joe decided to pick this way of gracefully ending the thread, but since it
    worked (after the already-mentioned two weeks of debugging and troubleshooting
    sessions), the engineering team decided not to ever mention this sequence of code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**foo** 结构负责启动和停止运行 **bar** 实例的 **serve** 方法的线程。在创建时，**foo** 初始化一个 **std::jthread**
    来运行其 **threadFunc**，它反过来调用其 **bar** 实例的 **serve** 方法。这种设置允许 **serve** 方法与 **main**
    程序并发运行。**foo** 的析构函数将 **stopRequest** 设置为 **true**，确保线程优雅地退出。再次，乔为什么决定选择这种优雅地结束线程的方式仍然是个谜，但既然它已经工作（在已经提到的两周的调试和故障排除会议之后），工程团队决定永远不再提及这段代码。'
- en: In the **main** function, an instance of **foo** is created, starting the thread
    upon its creation, and the program sleeps for two seconds to allow the thread
    to run. For brevity, let’s just assume that in the original application, there
    was no mention of any kind of sleeping; the real beauty of the solution came from
    some lengthy operations performed in the **main** and **bar** threads.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main** 函数中，创建了一个 **foo** 实例，在创建时启动线程，然后程序休眠两秒钟以允许线程运行。为了简洁起见，我们只需假设在原始应用程序中没有提到任何类型的休眠；解决方案真正的美在于
    **main** 和 **bar** 线程中执行的一些长时间操作。
- en: 'Dear seasoned C++ programmers: please do not focus on how this synthetic piece
    of code is handling the thread synchronization, or the fact that it allocates
    and releases memory, because that is not the purpose of it. The sole purpose of
    this code is to crash. For **std::jthread** , there are plenty of mechanisms to
    properly handle the execution, such as **std::stop_source** and **std::stop_token**
    , so please feel free to read up on them and let Joe suffer with his naive approach
    to threading for now.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的经验丰富的 C++ 程序员：请不要关注这段合成代码是如何处理线程同步的，或者它分配和释放内存的事实，因为那不是它的目的。这段代码的唯一目的是崩溃。对于
    **std::jthread**，有足够的机制来正确处理执行，例如 **std::stop_source** 和 **std::stop_token**，所以请随意阅读它们，让乔现在就忍受他天真地处理线程的方法。
- en: 'When the code is executed, the following is the result, at least on the author’s
    Linux system:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，以下结果是作者在 Linux 系统上至少得到的结果：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, sometimes the output is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时输出如下：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same happened to Joe too. Occasionally, the application would go haywire
    and crash upon exit. Initially, this was not too much of a hassle because, well,
    if the application crashes at the end, that’s not the end of it. However, after
    a while, the code Joe wrote was introduced in a larger module, and that’s where
    chaos, mayhem, and the aforementioned two weeks of debugging sessions materialized.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 乔也遭遇了同样的事情。偶尔，应用程序会在退出时出现混乱并崩溃。最初，这并不是太大的麻烦，因为，嗯，如果应用程序在结束时崩溃，那并不是结束。然而，过了一段时间，乔编写的代码被引入到一个更大的模块中，那里就出现了混乱、混乱，以及前面提到的两周的调试会议。
- en: 'The reason for the misdemeanor is quite simple. Jimmy, the master programmer
    discovered after consulting his pocket version of the C++ standard, specifically
    the **[class.dtor]** section of it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 犯罪的原因相当简单。吉米，这位大师程序员在查阅了他的口袋版 C++ 标准后，特别是它的 **[class.dtor]** 部分：
- en: After executing the body of the destructor and destroying any objects with automatic
    storage duration allocated within the body, a destructor for class X calls the
    destructors for X’s direct non-variant non-static data members, the destructors
    for X’s non-virtual direct base classes and, if X is the most derived class, its
    destructor calls the destructors for X’s virtual base classes. All destructors
    are called as if they were referenced with a qualified name, that is, ignoring
    any possible virtual overriding destructors in more derived classes. Bases and
    members are destroyed in the reverse order of the completion of their constructor.
    A return statement in a destructor might not directly return to the caller; before
    transferring control to the caller, the destructors for the members and bases
    are called. Destructors for elements of an array are called in reverse order of
    their construction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行析构函数的主体并销毁在主体内部分配的任何具有自动存储期的对象之后，类X的析构函数调用X的直接非变体非静态数据成员的析构函数，X的直接非虚基类的析构函数，如果X是最派生类，则其析构函数调用X的虚基类的析构函数。所有析构函数都像使用限定名引用一样被调用，即忽略在更派生类中可能存在的任何可能的虚覆盖析构函数。基和成员的销毁顺序与它们构造完成时的顺序相反。析构函数中的返回语句可能不会直接返回到调用者；在将控制权传递给调用者之前，会调用成员和基的析构函数。数组元素的析构函数以它们构造的相反顺序被调用。
- en: 'The key is that the objects are destroyed in reverse order of their creation,
    just like they would have been pushed onto a stack upon creation and popped off
    with grace in the reverse order upon destruction. The culprits for the erroneous
    behavior were quickly identified as being the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于对象被销毁的顺序与它们被创建的顺序相反，就像它们在创建时被推入栈中，在销毁时以优雅的方式从栈中弹出一样。导致错误行为的罪魁祸首很快就被识别为以下内容：
- en: '**std::jthread thread;**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::jthread thread;**'
- en: '**bar b;**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**bar b;**'
- en: 'So, what happened here upon construction was that the thread was created and
    started running its thread method: **void threadFunc() { b.serve(); }** . Only
    after this unpredictable operation was initiated was the **bar b** object created.
    Then, upon exit, as per the design of the C++ language, the **bar b** object was
    deleted and its resources freed. While the thread was still possibly being blocked
    in the long operation, suddenly it was running on an object that was already deleted.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在构建过程中发生的情况是线程被创建并开始执行其线程方法：**void threadFunc() { b.serve(); }**。只有在不可预测的操作被启动之后，**bar
    b** 对象才被创建。然后，在退出时，根据C++语言的设计，**bar b** 对象被删除并且其资源被释放。当线程仍然可能在长时间操作中被阻塞时，突然它开始在一个已经被删除的对象上运行。
- en: 'The delay between the creation of the thread object, the actual starting of
    the thread routine, and the creation of the **bar b** object is so insignificant
    that catching the error in the creation phase is almost implausible. But let’s
    modify the constructor of **bar** to be along the lines of the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 线程对象创建、实际启动线程例程和**bar b**对象创建之间的延迟如此之小，以至于在创建阶段捕捉到错误几乎是不可能的。但让我们修改**bar**的构造函数，使其大致如下：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In an instant, we can see how the thread is running on an object whose creation
    was not entirely finished by the time the thread started using it. Certainly,
    this specific issue can be resolved easily, by simply switching the order of the
    members:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在一瞬间，我们可以看到线程正在运行一个在其开始使用时创建并未完全完成的对象。当然，这个问题可以通过简单地交换成员的顺序来轻松解决：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Threading is an interesting aspect of C++. While it comes with many benefits,
    it also introduces extra complexity. Properly writing correct and efficient multithreaded
    code requires careful consideration of synchronization and coordination between
    various threads.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是C++的一个有趣方面。虽然它带来了许多好处，但也引入了额外的复杂性。正确编写正确且高效的线程代码需要仔细考虑各种线程之间的同步和协调。
- en: Debugging multithreaded applications can be challenging due to issues such as
    race conditions, deadlocks, and non-deterministic behavior, or the simple fact
    that the thread is stopped by the debugger, so upon inspecting it, no real work
    happens, and sometimes the success or failure of an application really hangs on
    the order in which the class members are declared. But for now, let’s say goodbye
    to Joe and his friends. Let’s hope they have got their AAAA title out on the door,
    and let’s focus our attention on something else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 调试多线程应用程序可能具有挑战性，因为存在诸如竞争条件、死锁和非确定性行为等问题，或者简单的事实是线程被调试器停止，因此在检查时没有实际的工作发生，有时应用程序的成功或失败实际上取决于类成员声明的顺序。但就目前而言，让我们和
    Joe 及他的朋友们说再见。让我们希望他们已经得到了他们的 AAAA 标题，让我们将注意力集中在其他事情上。
- en: The dark orders of C++
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 的黑暗秩序
- en: 'There is one dark corner of the C++ language that is rarely touched by sunlight,
    and if a piece of code from these depths surfaces by any chance, a gang of hardcore
    developers immediately jumps on it and refactors it into digestible bits and bytes.
    Let’s consider, for example, the very simple case of why the **a[2]** and **2[a]**
    expressions are equivalent when in C++, and **a** is an array of objects:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言中有一个很少被阳光照耀的阴暗角落，如果这些深层次中的代码偶然浮出水面，一群核心开发者会立即跳上去，将其重构为可消化的比特和字节。让我们以一个非常简单的例子来考虑一下，为什么在
    C++ 中，**a[2]** 和 **2[a]** 表达式是等价的，并且 **a** 是一个对象数组：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding piece of code, despite the fact that it looks ugly, actually
    compiles. The reason is the following: in C++, the **operator []** array subscript
    is defined in terms of pointer arithmetic. The **a[i]** expression is translated
    by the compiler into ***(a + i)** , where **a** is a pointer to the first element
    of the array and **i** is the index. The **i[a]** expression at the end is also
    translated to the ***(i + a)** expression, where **i** is the index and **a**
    is the pointer to our arrays’ first elements.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码，尽管看起来很丑陋，实际上是可以编译的。原因如下：在 C++ 中，**operator[]** 数组下标是通过指针算术定义的。**a[i]**
    表达式被编译器翻译为 ***(a + i)**，其中 **a** 是数组第一个元素的指针，**i** 是索引。最后的 **i[a]** 表达式也被翻译为 ***(i
    + a)** 表达式，其中 **i** 是索引，**a** 是我们数组第一个元素的指针。
- en: Since addition is commutative for the compiler, it does not really matter which
    comes first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对于编译器来说加法是交换的，所以哪个先来并不重要。
- en: 'So, we have found a specific case where order doesn’t really matter in C++.
    But this works only for old-style C arrays; **std::vector** and **std::array**
    do not accept this kind of out-of-order syntax. There is a very specific reasoning
    for that; the subscript operator for **std::vector** and **std::array** does not
    support the commutative behavior seen in raw arrays, namely the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 C++ 中找到了一个特定的案例，其中顺序并不重要。但这仅适用于旧式 C 数组；**std::vector** 和 **std::array**
    不接受这种无序语法。这有一个非常具体的理由；**std::vector** 和 **std::array** 的下标运算符不支持在原始数组中看到的交换行为，即以下内容：
- en: '**Operator overloading** : The **operator[]** for **std::vector** and **std::array**
    is a member function, meaning it needs to be called on an instance of the class.
    It cannot be invoked with the index first, as member functions require the object
    to be on the left side of the call.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符重载**：对于 **std::vector** 和 **std::array** 的 **operator[]** 是一个成员函数，这意味着它需要在类的实例上调用。它不能通过索引首先调用，因为成员函数要求对象位于调用左侧。'
- en: '**No pointer arithmetic** : The internal implementation of **std::vector**
    and **std::array** does not rely on raw pointer arithmetic for indexing. They
    manage their memory and bounds checking differently, ensuring safer access to
    elements.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无指针算术**：**std::vector** 和 **std::array** 的内部实现不依赖于原始指针算术进行索引。它们以不同的方式管理内存和边界检查，确保对元素的更安全访问。'
- en: 'At the current stage, the closest we can get to emulating the preceding unholy
    syntax for an object of type **std::vector** is the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前阶段，我们能够最接近模拟类型为 **std::vector** 的对象的前述不神圣语法的代码如下：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After a quick examination of it, however, we, the authors (well, not actually
    both the authors, because Alex is innocent, at least concerning this code, so
    please consider this as the royal we), have decided that we are ashamed of it,
    and did not dare implement it for **std::array** or any other containers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经过快速检查后，我们（好吧，实际上并不是两位作者，因为 Alex 至少在这段代码中是无辜的，所以请将此视为皇家我们），我们决定我们对此感到羞愧，不敢将其实现为
    **std::array** 或任何其他容器。
- en: 'But on a second look, we have some interesting code there. Our main goal was
    to recreate the orderless index access for vectors and arrays, but before we indulge
    ourselves in believing that it is possible, a harsh reality check: it is not.
    The reason for this is the following: if we try to compile the expression **2[vec];**
    , we get the following error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但仔细观察后，我们发现那里有一些有趣的代码。我们的主要目标是重新创建向量和数组无序索引访问的顺序，但在我们沉浸于相信这是可能之前，有一个残酷的现实检查：这是不可能的。原因如下：如果我们尝试编译表达式
    **2[vec];**，我们会得到以下错误：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This, translated to plain English, means the compiler cannot find an index operator
    that is applied to integers and takes in as parameter a vector of ints. As long
    as C++ is C++, this will not happen for two major reasons. The first is that **operator[]**
    needs to be a member function in a class. It is not possible to have a freestanding
    **[]** operator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这用普通英语翻译过来，意味着编译器找不到应用于整数并接受整数向量作为参数的索引运算符。只要 C++ 还是 C++，这不会发生，主要有两个原因。第一个原因是
    **operator[]** 必须是一个类的成员函数。不可能有一个独立的 **[]** 运算符。
- en: 'The second is a peculiar thing, called operator precedence. That is not an
    operator called *precedence* , but the following: in C++, the order of operations,
    also known as operator precedence, determines how operators are parsed concerning
    each other. Operators with higher precedence are evaluated before operators with
    lower precedence. When operators have the same precedence, their associativity
    determines the order of evaluation.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是叫做运算符优先级的一个奇特现象。这并不是一个叫做 *优先级* 的运算符，而是以下内容：在 C++ 中，运算顺序，也称为运算符优先级，决定了运算符之间的解析方式。优先级较高的运算符先于优先级较低的运算符进行评估。当运算符具有相同的优先级时，它们的结合性决定了评估的顺序。
- en: While in the latest standard, [*Chapter 7*](B22235_07.xhtml#_idTextAnchor079)
    *, Expressions* (specifically the **[expr.pre]** section), mentions that “The
    precedence of operators is not directly specified, but it can be derived from
    the syntax” there are official sources of information2 [2](B22235_05.xhtml#footnote-017)
    which contain the exact order of them so we really encourage you to go and dedicate
    proper time to study one of those sources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在最新的标准中，[*第 7 章*](B22235_07.xhtml#_idTextAnchor079) *表达式*（特别是 **[expr.pre]**
    部分）提到“运算符的优先级没有直接指定，但可以从语法中推导出来”，但也有一些官方信息来源2 [2](B22235_05.xhtml#footnote-017)，它们包含了它们的精确顺序，所以我们真心鼓励你花时间去研究这些来源之一。
- en: '**[2](B22235_05.xhtml#footnote-017-backlink)** [https://en.cppreference.com/w/cpp/language/operator_precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**[2](B22235_05.xhtml#footnote-017-backlink)** [https://en.cppreference.com/w/cpp/language/operator_precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)'
- en: The most important question
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最重要的问题
- en: And now that you’re back, dear reader, we are pretty sure that you can easily
    answer the following question. What is the output of the following program?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你回来了，亲爱的读者，我们非常确信你可以轻松回答以下问题。以下程序的输出是什么？
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before you rush into feeding the code into your compiler, however, pause, sit
    back, and think thoroughly about what exactly is happening here. This section
    gave you all the hints, directions, and possible clues you needed in order to
    answer this correctly. We intentionally will not give the answer yet, nor a full
    explanation of the code, just a quick breakdown of what’s happening, which should
    be enough to figure it out:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你急忙将代码输入编译器之前，请暂停，坐下来，仔细思考这里到底发生了什么。本节为你提供了所有必要的提示、方向和可能的线索，以便正确回答。我们故意不会立即给出答案，也不会对代码进行完整的解释，只是快速分析一下正在发生的事情，这应该足以让你弄清楚：
- en: In the **auto a = 4;** expression, the **a** variable is declared with the **int**
    type and initialized to **4** . This is just the way **auto** and numbers work
    in modern C++.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **auto a = 4;** 表达式中，变量 **a** 被声明为 **int** 类型并初始化为 **4**。这正是现代 C++ 中 **auto**
    和数字工作的方式。
- en: Now comes the tricky part. Parsing the code in our brain, it is obvious that
    the **sizeof(a)** expression evaluates to a **std::sizeof** type, and typically,
    **sizeof(int)** is 4 bytes on most systems. Certainly, older 16-bit systems have
    **sizeof(int)** as **2** ; some exotic systems can have **sizeof(int)** as **8**
    , but the author of these lines has never seen a system like that.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在来到了棘手的部分。在我们的大脑中解析代码，很明显，**sizeof(a)** 表达式评估为 **std::sizeof** 类型，并且通常情况下，**sizeof(int)**
    在大多数系统中是 4 个字节。当然，较老的 16 位系统中的 **sizeof(int)** 是 **2** 个字节；一些奇特的系统可以将 **sizeof(int)**
    设置为 **8** 个字节，但作者从未见过这样的系统。
- en: 'This is the crucial point where all our deduction has chicaned out. What kicks
    in is the operator precedence of C++. Here’s just a tiny extract from the preceding
    table, where we have kept just the parts relevant to our case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有我们的推理都陷入困境的关键点。起作用的是C++的运算符优先级。以下是从前一个表中提取的微小部分，我们只保留了与我们的案例相关的部分：
- en: '| **Precedence** | **Operator** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **优先级** | **运算符** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | **::** | Scope resolution operator |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **::** | 命名空间解析运算符 |'
- en: '| 2 | **a++ a--** | Postfix increment and decrement |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **a++ a--** | 后缀递增和递减 |'
- en: '|  | **a()** | Function call |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  | **a()** | 函数调用 |'
- en: '|  | **a[]** | Subscript |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | **a[]** | 下标 |'
- en: '| 3 | **++** **a --a** | Prefix increment and decrement |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **++** **a --a** | 前缀递增和递减 |'
- en: '|  | **+** **a -a** | Unary plus and minus |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | **+** **a -a** | 一元加和减 |'
- en: '|  | **! ~** | Logical NOT and bitwise NOT |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  | **! ~** | 逻辑非和位非 |'
- en: '|  | ***a** | Dereference |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  | ***a** | 解引用 |'
- en: '|  | **&a** | Address-of |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  | **&a** | 地址运算符 |'
- en: '|  | **sizeof** | Size of operator |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  | **sizeof** | 大小运算符 |'
- en: Now, we can finally see that in our code, the expression **sizeof(a)** will
    never be evaluated. Due to the way the C++ compiler works, the **[]** operator
    has priority over **sizeof** , so what will be evaluated first is **(** **a)["Hello
    World"];** .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以看到，在我们的代码中，表达式 **sizeof(a)** 永远不会被评估。由于C++编译器的工作方式，**[]** 运算符的优先级高于
    **sizeof**，所以首先会被评估的是 **(** **a)["Hello World"];**。
- en: Since in C++ **(a)** is almost always identical to **a** (except when you are
    dealing with the *most vexing parse* , but more on that at a later stage), the
    expression is identical to **sizeof** **a["Hello World"];** .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在C++中 **(a)** 几乎总是与 **a** 相同（除了当你处理 *最令人头疼的解析* 时，但关于这一点将在稍后讨论），表达式与 **sizeof**
    **a["Hello World"];** 相同。
- en: Now, as we have seen, this yields the same result as **sizeof "Hello World"[a];**
    , which, considering that today, **a** will most likely be **4** , gives us the
    character **'o'** . So, the entire expression is now reduced to **sizeof 'o'**
    , which, considering the way **sizeof** works, will always return **1** .
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们所看到的，这会产生与 **sizeof "Hello World"[a];** 相同的结果，考虑到今天，**a** 很可能为 **4**，这将给我们字符
    **'o'**。因此，整个表达式现在简化为 **sizeof 'o'**，考虑到 **sizeof** 的工作方式，它将始终返回 **1**。
- en: We, the authors, think that at this stage, the answer to our question is obvious.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们，作为作者，认为在这个阶段，我们问题的答案已经很明显了。
- en: When order does not matter
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当顺序不重要时
- en: There is one tiny thing we ought not to forget to mention before closing this
    chapter. Well, actually two. The first one is that in C++, the order in which
    function arguments are evaluated is unspecified. This means that when you call
    a function with multiple arguments, the compiler is free to evaluate the arguments
    in any order it chooses. This can lead to unexpected results if the arguments
    have side effects, such as modifying a variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，我们不应该忘记提到一件小事。实际上，有两件。第一件是，在C++中，函数参数评估的顺序是不确定的。这意味着当你用一个具有多个参数的函数调用时，编译器可以自由地以它选择的任何顺序评估这些参数。如果参数有副作用，如修改变量，这可能会导致意外结果。
- en: 'Let’s take, for example, the following program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下程序为例：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Regardless of what you think the output of this program is, it will be wrong.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你认为这个程序的结果是什么，它都会是错误的。
- en: 'The reason for this is, again, as mentioned previously: the order of evaluation
    of the parameters is not specified. With good reason, you may ask, why? The reasons
    for this are a bit more complex and historical. But before delving deeper into
    that, let’s amuse ourselves with the output that various compilers provide us
    with, courtesy of gcc.godbolt.org and some other sources.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种原因再次是，如前所述：参数评估的顺序没有指定。你可能会问，为什么？这个原因有点复杂且具有历史性。但在深入探讨这一点之前，让我们先娱乐一下，看看各种编译器通过
    gcc.godbolt.org 和其他来源提供的输出。
- en: '| **Compiler** | **Output** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | **输出** |'
- en: '| Microsoft Visual C++ ( after 2005) | **a=1** **b=1 c=1****f=3****i=4** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft Visual C++ ( after 2005) | **a=1** **b=1 c=1****f=3****i=4** |'
- en: '| Microsoft VS.NET 2003 | **a=3** **b=2 c=1****f=6****i=4** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft VS.NET 2003 | **a=3** **b=2 c=1****f=6****i=4** |'
- en: '| Microsoft Visual C++ 6 | **a=1** **b=1 c=1****f=3****i=4** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft Visual C++ 6 | **a=1** **b=1 c=1****f=3****i=4** |'
- en: '| ICC and Clang agree on this… | **f=a=1** **b=2 c=3****6****i=4** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| ICC和Clang对此达成一致… | **f=a=1** **b=2 c=3****6****i=4** |'
- en: '| GCC, after 6.5 | **f=a=3** **b=2 c=1****6****i=4** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| GCC, after 6.5 | **f=a=3** **b=2 c=1****6****i=4** |'
- en: '| GCC, before 6.5 | **a=3** **b=2 c=1****f=6****i=4** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| GCC, before 6.5 | **a=3** **b=2 c=1****f=6****i=4** |'
- en: '| Turbo C Lite and Borland C++55 | **a=3** **b=2 c=1****f=6****i=1** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Turbo C Lite 和 Borland C++55 | **a=3** **b=2 c=1****f=6****i=1** |'
- en: So, we have a plethora of options to choose from, some more straightforward
    and others more exotic. All these weird values claim they are the right one, the
    one to rule them all, regardless of the fact that even different versions of the
    same compiler from the same provider provide different results. And they are all
    right in their belief.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有大量的选项可供选择，一些更直接，一些更奇特。所有这些奇怪值都声称自己是正确的，是统治它们的那个，不管事实是即使是同一供应商的同一编译器的不同版本也会提供不同的结果。而且它们都相信自己的正确性。
- en: Quite simply, the reasoning is that allowing the compiler the freedom to choose
    the order of evaluation enables it to make optimizations that can improve performance
    that we programmers may not notice. The compiler can reorder instructions to take
    advantage of CPU pipelines, minimize register usage, and enhance cache efficiency.
    Specifying a strict order would limit these optimization opportunities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，推理是允许编译器自由选择求值的顺序，使其能够进行优化，从而提高性能，这些性能是我们程序员可能注意不到的。编译器可以重新排序指令以利用CPU流水线，最小化寄存器使用，并提高缓存效率。指定严格的顺序将限制这些优化机会。
- en: Different hardware architectures may have different optimal evaluation strategies.
    By not specifying the order of evaluation, C++ code can be more easily optimized
    for a wide variety of architectures without requiring changes to the code itself.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不同硬件架构可能具有不同的最佳求值策略。由于没有指定求值的顺序，C++代码可以更容易地为各种架构优化，而无需对代码本身进行更改。
- en: Also, by not specifying the order of evaluation, the C++ language specification
    remains simpler. Specifying a strict order for all expressions would add complexity
    to the language definition and increase the burden on compiler developers. Not
    to mention that the current standard is almost 2,000 pages long, so maybe it is
    a good idea not to add several hundred pages detailing the complexities of the
    order of parameter evaluations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于没有指定求值的顺序，C++语言规范保持得更简单。为所有表达式指定严格的顺序会增加语言定义的复杂性，并增加编译器开发者的负担。更不用说当前的标准几乎有2,000页长，所以也许不添加几百页详细说明参数求值顺序的复杂性是个好主意。
- en: 'The second thing we promised to mention at the beginning of this section, however,
    comes up: while operator precedence and associativity dictate how expressions
    are grouped and parsed, they do not dictate the order of evaluation. This means
    that even though you know how expressions will be grouped, the actual order in
    which parts of the expression are evaluated can still vary.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在本节开头承诺提到的第二件事出现了：虽然运算符优先级和结合性决定了表达式如何分组和解析，但它们并不决定求值的顺序。这意味着即使你知道表达式将如何分组，表达式各部分实际求值的顺序仍然可能变化。
- en: 'Let’s consider the following short application:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下简短的应用程序：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is really short – it couldn’t be shorter – and it contains some quite nasty
    code, especially looking at **++i + i++** . That piece of code is so nasty that
    the compilers cannot really agree in which order to execute it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它真的很短——再短也没有了——而且包含了一些相当糟糕的代码，尤其是看那**++i + i++**。这段代码如此糟糕，以至于编译器都无法真正同意执行它的顺序。
- en: Some of them choose to execute **++i** (making **i** be **5** and also using
    it as the left side of the addition) first, and then **i++** (which will be using
    the new value of **i** , which was incremented already, then incrementing it again
    to reach **6** , but due to the way post-increment works, the value of **5** will
    be used for the right-hand side of the addition), and then assigning this value
    back to **i** . So, that’s 5 + 5 = 10.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些人选择先执行**++i**（使**i**变为**5**，并将其用作加法的左侧），然后执行**i++**（这将使用已经增加的新值**i**，然后再次增加它以达到**6**，但由于后增加的工作方式，将使用**5**的值作为加法的右侧），然后将此值赋回**i**。所以，结果是5
    + 5 = 10。
- en: However, other compilers decide to execute **i++** first, thus keeping the value
    **4** on the right-hand side of the operation, while also incrementing the value
    of **i** to **6** . Now, **++i** is evaluated, which already sees the incremented
    value of **6** , decides to use it, and then increments it, thus obtaining **7**
    for the left-hand side of the addition. Thus, this will give 7 + 4 = 11.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他编译器决定先执行**i++**，从而保持操作右侧的值**4**，同时将**i**的值增加到**6**。现在，**++i**被评估，它已经看到了增加的值**6**，决定使用它，然后增加它，从而获得加法左侧的**7**。因此，这将给出7
    + 4 = 11。
- en: 'Now, thinking a bit back, not having the evaluation order specified encourages
    developers aware of this uncanny feature to write code that does not expect specific
    evaluation orders. This can lead to more robust and portable code, as developers
    must avoid unintended dependencies on evaluation order. As such, the correct fix
    for the preceding situation would be some code along the lines of the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，稍微回顾一下，没有指定评估顺序会鼓励开发者意识到这一奇特特性，编写不期望特定评估顺序的代码。这可以导致更健壮和可移植的代码，因为开发者必须避免对评估顺序的不当依赖。因此，对前述情况的正确修复将是一些类似于以下内容的代码：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While this might be a rare situation, because the preceding code is a bit artificial,
    it is an issue, especially still if we are dealing with situations like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是罕见的情况，因为前面的代码有点人为，但这确实是一个问题，尤其是如果我们处理的是以下情况：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The value of **result** will be **3** regardless, but the output, depending
    on how the compiler decides to execute the two function calls, can be either **"fg"**
    or **"gf"** .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**result**的值无论如何都将为**3**，但输出将取决于编译器如何决定执行两个函数调用，可以是**"fg"**或**"gf"**。'
- en: With all this in mind, we may think that we understand everything about ordering
    in C++. While in this chapter we have tried to cover all possible implications,
    we cannot promise that you will not find anything out of order. C++ is a language
    with a very wide scope and peculiar syntax, so if someone really wanted to, they
    could step on the toes of some compilers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们可能会认为我们已经了解了C++中关于顺序的所有内容。虽然在本章中我们试图涵盖所有可能的后果，但我们不能保证您不会发现任何顺序混乱的情况。C++是一种具有非常广泛范围和独特语法的语言，所以如果有人真的想的话，他们可能会触及某些编译器的痛脚。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this chapter, we hope you have grasped the critical importance of following
    the specified order of everything C++-related to ensure predictable and error-free
    code execution. You should also understand the importance of not having a specified
    order of execution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们希望您已经掌握了遵循所有与C++相关内容指定顺序的重要性，以确保代码执行的预测性和无错误。您还应该理解没有指定执行顺序的重要性。
- en: With this in mind, we encourage you to go and experiment with the online playground
    offered by Compiler Explorer. It offers a large collection of compilers. Just
    bear in mind that if two compilers have generated different results for the code
    you wrote, then maybe you have ventured into unspecified/undefined behavior territory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们鼓励您去尝试使用Compiler Explorer提供的在线游乐场。它提供了一大批编译器。只需记住，如果您编写的代码在两个编译器上生成了不同的结果，那么您可能已经进入了未指定/未定义行为的领域。
- en: The next chapter explores the challenges of memory management in C++.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨C++中内存管理的挑战。
