["```cpp\n #include <pthread.h>\n int pthread_create(\n              pthread_t *thread,\n              const pthread_attr_t *attr,\n              void *(*start_routine)(void*),\n              void *arg\n )\n```", "```cpp\nint pthread_join ( pthread_t *thread, void **retval )\n```", "```cpp\nint pthread_exit ( void *retval )\n```", "```cpp\npthread_t pthread_self(void)\n```", "```cpp\n#include <pthread.h>\n#include <iostream>\n\nusing namespace std;\n\nvoid* threadProc ( void *param ) {\n  for (int count=0; count<3; ++count)\n    cout << \"Message \" << count << \" from \" << pthread_self()\n         << endl;\n  pthread_exit(0);\n}\n\nint main() {\n  pthread_t thread1, thread2, thread3;\n\n  pthread_create ( &thread1, NULL, threadProc, NULL );\n  pthread_create ( &thread2, NULL, threadProc, NULL );\n  pthread_create ( &thread3, NULL, threadProc, NULL );\n\n  pthread_join( thread1, NULL );\n  pthread_join( thread2, NULL );\n\n  pthread_join( thread3, NULL );\n\n  return 0;\n\n}\n```", "```cpp\ng++ main.cpp -lpthread\n```", "```cpp\n#include <thread>\nusing namespace std;\nthread instance ( thread_procedure )\n```", "```cpp\nthis_thread::get_id ()\n```", "```cpp\nthread::join()\n```", "```cpp\n#include <thread>\n#include <iostream>\nusing namespace std;\n\nvoid threadProc() {\n  for( int count=0; count<3; ++count ) {\n    cout << \"Message => \"\n         << count\n         << \" from \"\n         << this_thread::get_id()\n         << endl;\n  }\n}\n\nint main() {\n  thread thread1 ( threadProc );\n  thread thread2 ( threadProc );\n  thread thread3 ( threadProc );\n\n  thread1.join();\n  thread2.join();\n  thread3.join();\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -std=c++17 -lpthread\n```", "```cpp\n ps -T -p <process-id>\n```", "```cpp\n top -H -p <process-id>\n```", "```cpp\nps -ef | grep -i <your-application-name>\n```", "```cpp\n#include <sys/types.h>\npid_t gettid(void)\n```", "```cpp\n#include <iostream>\n#include <thread>\nusing namespace std;\n\nclass Thread {\nprivate:\n      thread *pThread;\n      bool stopped;\n      void run();\npublic:\n      Thread();\n      ~Thread();\n\n      void start();\n      void stop();\n      void join();\n      void detach();\n};\n```", "```cpp\n#include \"Thread.h\"\n\nThread::Thread() {\n     pThread = NULL;\n     stopped = false;\n}\n\nThread::~Thread() {\n     delete pThread;\n     pThread = NULL;\n}\n\nvoid Thread::run() {\n\n     while ( ! stopped ) {\n         cout << this_thread::get_id() << endl;\n         this_thread::sleep_for ( 1s );\n     }\n     cout << \"\\nThread \" << this_thread::get_id()\n          << \" stopped as requested.\" << endl;\n     return;\n}\n\nvoid Thread::stop() {\n    stopped = true;\n}\n\nvoid Thread::start() {\n    pThread = new thread( &Thread::run, this );\n}\n\nvoid Thread::join() {\n     pThread->join();\n}\n\nvoid Thread::detach() {\n     pThread->detach();\n}\n```", "```cpp\n#include \"Thread.h\"\n\nint main() {\n\n      Thread thread1, thread2, thread3;\n\n      thread1.start();\n      thread2.start();\n      thread3.start();\n\n      thread1.detach();\n      thread2.detach();\n      thread3.detach();\n\n      this_thread::sleep_for ( 3s );\n\n      thread1.stop();\n      thread2.stop();\n      thread3.stop();\n\n      this_thread::sleep_for ( 3s );\n\n      return 0;\n}\n```", "```cpp\ng++ Thread.cpp main.cpp -std=c++17 -o threads.exe -lpthread\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\nclass Account {\nprivate:\n  double balance;\npublic:\n  Account( double );\n  double getBalance( );\n  void deposit ( double amount );\n  void withdraw ( double amount ) ;\n};\n```", "```cpp\n#include \"Account.h\"\n\nAccount::Account(double balance) {\n  this->balance = balance;\n}\n\ndouble Account::getBalance() {\n  return balance;\n}\n\nvoid Account::withdraw(double amount) {\n  if ( balance < amount ) {\n    cout << \"Insufficient balance, withdraw denied.\" << endl;\n    return;\n  }\n\n  balance = balance - amount;\n}\n\nvoid Account::deposit(double amount) {\n  balance = balance + amount;\n}\n```", "```cpp\n#include <thread>\n#include \"Account.h\"\nusing namespace std;\n\nenum ThreadType {\n  DEPOSITOR,\n  WITHDRAWER\n};\n\nAccount account(5000.00);\n\nvoid threadProc ( ThreadType typeOfThread ) {\n\n  while ( 1 ) {\n  switch ( typeOfThread ) {\n    case DEPOSITOR: {\n      cout << \"Account balance before the deposit is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 2000.00 );\n\n      cout << \"Account balance after deposit is \"\n           << account.getBalance() << endl;\n      this_thread::sleep_for( 1s );\n}\nbreak;\n\n    case WITHDRAWER: {\n      cout << \"Account balance before withdrawing is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 1000.00 );\n      cout << \"Account balance after withdrawing is \"\n           << account.getBalance() << endl;\n      this_thread::sleep_for( 1s );\n    }\n    break;\n  }\n  }\n}\n\nint main( ) {\n  thread depositor ( threadProc, ThreadType::DEPOSITOR );\n  thread withdrawer ( threadProc, ThreadType::WITHDRAWER );\n\n  depositor.join();\n  withdrawer.join();\n\n  return 0;\n}\n```", "```cpp\ng++ Account.cpp main.cpp -o account.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include \"Account.h\"\nusing namespace std;\n\nenum ThreadType {\n  DEPOSITOR,\n  WITHDRAWER\n};\n\nmutex locker;\n\nAccount account(5000.00);\n\nvoid threadProc ( ThreadType typeOfThread ) {\n\n  while ( 1 ) {\n  switch ( typeOfThread ) {\n    case DEPOSITOR: {\n\n      locker.lock();\n\n      cout << \"Account balance before the deposit is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 2000.00 );\n\n      cout << \"Account balance after deposit is \"\n           << account.getBalance() << endl;\n\n      locker.unlock();\n      this_thread::sleep_for( 1s );\n}\nbreak;\n\n    case WITHDRAWER: {\n\n      locker.lock();\n\n      cout << \"Account balance before withdrawing is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 1000.00 );\n      cout << \"Account balance after withdrawing is \"\n           << account.getBalance() << endl;\n\n      locker.unlock();\n      this_thread::sleep_for( 1s );\n    }\n    break;\n  }\n  }\n}\n\nint main( ) {\n  thread depositor ( threadProc, ThreadType::DEPOSITOR );\n  thread withdrawer ( threadProc, ThreadType::WITHDRAWER );\n\n  depositor.join();\n  withdrawer.join();\n\n  return 0;\n}\n```", "```cpp\nvoid threadProc ( ThreadType typeOfThread ) {\n\n  while ( 1 ) {\n  switch ( typeOfThread ) {\n    case DEPOSITOR: {\n\n      locker.lock();\n\n      cout << \"Account balance before the deposit is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 2000.00 );\n\n      cout << \"Account balance after deposit is \"\n           << account.getBalance() << endl;\n\n      locker.unlock();\n      this_thread::sleep_for( 1s );\n}\nbreak;\n\n    case WITHDRAWER: {\n\n      locker.lock();\n\n      cout << \"Account balance before withdrawing is \"\n           << account.getBalance() << endl;\n\n      account.deposit( 1000.00 );\n      cout << \"Account balance after withdrawing is \"\n           << account.getBalance() << endl;\n\n      locker.unlock();\n      this_thread::sleep_for( 1s );\n    }\n    break;\n  }\n  }\n}\n```", "```cpp\n#ifndef __ACCOUNT_H\n#define __ACCOUNT_H\n\n#include <iostream>\nusing namespace std;\n\nclass Account {\nprivate:\n  double balance;\npublic:\n  Account( double balance );\n  double getBalance();\n  void deposit(double amount);\n  void withdraw(double amount);\n};\n\n#endif\n```", "```cpp\n#include \"Account.h\"\n\nAccount::Account(double balance) {\n  this->balance = balance;\n}\n\ndouble Account::getBalance() {\n  return balance;\n}\n\nvoid Account::withdraw(double amount) {\n  if ( balance < amount ) {\n    cout << \"Insufficient balance, withdraw denied.\" << endl;\n    return;\n  }\n\n  balance = balance - amount;\n}\n\nvoid Account::deposit(double amount) {\n  balance = balance + amount;\n}\n```", "```cpp\n#ifndef __THREAD_H\n#define __THREAD_H\n\n#include <iostream>\n#include <thread>\n#include <mutex>\nusing namespace std;\n#include \"Account.h\"\n\nenum ThreadType {\n   DEPOSITOR,\n   WITHDRAWER\n};\n\nclass Thread {\nprivate:\n      thread *pThread;\n      Account *pAccount;\n      static mutex locker;\n      ThreadType threadType;\n      bool stopped;\n      void run();\npublic:\n      Thread(Account *pAccount, ThreadType typeOfThread);\n      ~Thread();\n      void start();\n      void stop();\n      void join();\n      void detach();\n};\n\n#endif\n```", "```cpp\n#include \"Thread.h\"\n\nmutex Thread::locker;\n\nThread::Thread(Account *pAccount, ThreadType typeOfThread) {\n  this->pAccount = pAccount;\n  pThread = NULL;\n  stopped = false;\n  threadType = typeOfThread;\n}\n\nThread::~Thread() {\n  delete pThread;\n  pThread = NULL;\n}\n\nvoid Thread::run() {\n    while(1) {\n  switch ( threadType ) {\n    case DEPOSITOR:\n      locker.lock();\n\n      cout << \"Depositor: current balance is \" << pAccount->getBalance() << endl;\n      pAccount->deposit(2000.00);\n      cout << \"Depositor: post deposit balance is \" << pAccount->getBalance() << endl;\n\n      locker.unlock();\n\n      this_thread::sleep_for(1s);\n      break;\n\n    case WITHDRAWER:\n      locker.lock();\n\n      cout << \"Withdrawer: current balance is \" << \n               pAccount->getBalance() << endl;\n      pAccount->withdraw(1000.00);\n      cout << \"Withdrawer: post withraw balance is \" << \n               pAccount->getBalance() << endl;\n\n      locker.unlock();\n\n      this_thread::sleep_for(1s);\n      break;\n  }\n    }\n}\n\nvoid Thread::start() {\n  pThread = new thread( &Thread::run, this );\n}\n\nvoid Thread::stop() {\n  stopped = true;\n}\n\nvoid Thread::join() {\n  pThread->join();\n}\n\nvoid Thread::detach() {\n  pThread->detach();\n}\n```", "```cpp\n#include \"Account.h\"\n#include \"Thread.h\"\n\nint main( ) {\n\n  Account account(5000.00);\n\n  Thread depositor ( &account, ThreadType::DEPOSITOR );\n  Thread withdrawer ( &account, ThreadType::WITHDRAWER );\n\n  depositor.start();\n  withdrawer.start();\n\n  depositor.join();\n  withdrawer.join();\n\n  return 0;\n}\n```", "```cpp\ng++ Thread.cpp Account.cpp main.cpp -o account.exe -std=c++17 -lpthread\n```", "```cpp\n#ifndef __THREAD_H\n#define __THREAD_H\n\n#include <iostream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <string>\nusing namespace std;\n\nenum ThreadType {\n  READER,\n  WRITER\n};\n\nclass Thread {\nprivate:\n  string name;\n  thread *pThread;\n  ThreadType threadType;\n  static mutex commonLock;\n  static int count;\n  bool stopped;\n  void run( );\npublic:\n  Thread ( ThreadType typeOfThread );\n  ~Thread( );\n  void start( );\n  void stop( );\n  void join( );\n  void detach ( );\n  int getCount( );\n  int updateCount( );\n};\n#endif\n```", "```cpp\n#include \"Thread.h\"\n\nmutex Thread::commonLock;\n\nint Thread::count = 0;\n\nThread::Thread( ThreadType typeOfThread ) {\n  pThread = NULL;\n  stopped = false;\n  threadType = typeOfThread;\n  (threadType == READER) ? name = \"READER\" : name = \"WRITER\";\n}\n\nThread::~Thread() {\n  delete pThread;\n  pThread = NULL;\n}\n\nint Thread::getCount( ) {\n  cout << name << \" is waiting for lock in getCount() method ...\" <<\nendl;\n  lock_guard<mutex> locker(commonLock);\n  return count;\n}\n\nint Thread::updateCount( ) {\n  cout << name << \" is waiting for lock in updateCount() method ...\" << endl;\n  lock_guard<mutex> locker(commonLock);\n  int value = getCount();\n  count = ++value;\n  return count;\n}\n\nvoid Thread::run( ) {\n  while ( 1 ) {\n    switch ( threadType ) {\n      case READER:\n        cout << name<< \" => value of count from getCount() method is \" << getCount() << endl;\n        this_thread::sleep_for ( 500ms );\n      break;\n\n      case WRITER:\n        cout << name << \" => value of count from updateCount() method is\" << updateCount() << endl;\n        this_thread::sleep_for ( 500ms );\n      break;\n    }\n  }\n}\n\nvoid Thread::start( ) {\n  pThread = new thread ( &Thread::run, this );\n}\n\nvoid Thread::stop( ) {\n  stopped = true;\n}\n\nvoid Thread::join( ) {\n  pThread->join();\n}\n\nvoid Thread::detach( ) {\n  pThread->detach( );\n}\n```", "```cpp\n#include <iostream>\nusing namespace std;\n\n#include \"Thread.h\"\n\nint main ( ) {\n\n      Thread reader( READER );\n      Thread writer( WRITER );\n      reader.start( );\n      writer.start( );\n      reader.join( );\n      writer.join( );\n      return 0;\n}\n```", "```cpp\ng++ Thread.cpp main.cpp -o deadlock.exe -std=c++17 -lpthread\n```", "```cpp\nint Thread::getCount() {\n         cout << name << \" is waiting for lock in getCount() method ...\" << endl;\n         lock_guard<mutex> locker(commonLock);\n         cout << name << \" has acquired lock in getCount() method ...\" << endl;\n         return count;\n}\nint Thread::updateCount() {\n        count << name << \" is waiting for lock in updateCount() method ...\" << endl;\n        lock_guard<mutex> locker(commonLock);\n        cout << name << \" has acquired lock in updateCount() method ...\" << endl;\n        int value = getCount();\n        count = ++value;\n        return count;\n}\n```", "```cpp\ng++ main.cpp Thread.cpp -o deadlock.exe -std=c++17 -lpthread -g\n```", "```cpp\nvalgrind --tool=helgrind ./deadlock.exe\n```", "```cpp\nint Thread::updateCount() {\n        int value = getCount();\n\n        count << name << \" is waiting for lock in updateCount() method ...\" << endl;\n        lock_guard<mutex> locker(commonLock);\n        cout << name << \" has acquired lock in updateCount() method ...\" << endl;\n        count = ++value;\n\n        return count;\n}\n```", "```cpp\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nenum ThreadType {\n  PRODUCER,\n  CONSUMER\n};\n\nclass Thread {\nprivate:\n  static mutex locker;\n  static condition_variable untilReady;\n  static bool ready;\n  static queue<int> appQueue;\n  thread *pThread;\n  ThreadType threadType;\n  bool stopped;\n  string name;\n\n  void run();\npublic:\n  Thread(ThreadType typeOfThread);\n  ~Thread();\n  void start();\n  void stop();\n  void join();\n  void detach();\n};\n```", "```cpp\n#include \"Thread.h\"\n\nmutex Thread::locker;\ncondition_variable Thread::untilReady;\nbool Thread::ready = false;\nqueue<int> Thread::appQueue;\n\nThread::Thread( ThreadType typeOfThread ) {\n  pThread = NULL;\n  stopped = false;\n  threadType = typeOfThread;\n  (CONSUMER == typeOfThread) ? name = \"CONSUMER\" : name = \"PRODUCER\";\n}\n\nThread::~Thread( ) {\n  delete pThread;\n  pThread = NULL;\n}\n\nvoid Thread::run() {\n  int count = 0;\n  int data = 0;\n  while ( 1 ) {\n    switch ( threadType ) {\n    case CONSUMER: \n    {\n\n      cout << name << \" waiting to acquire mutex ...\" << endl;\n\n      unique_lock<mutex> uniqueLocker( locker );\n\n      cout << name << \" acquired mutex ...\" << endl;\n      cout << name << \" waiting for conditional variable signal...\" << endl;\n\n      untilReady.wait ( uniqueLocker, [] { return ready; } );\n\n      cout << name << \" received conditional variable signal ...\" << endl;\n\n      data = appQueue.front( ) ;\n\n      cout << name << \" received data \" << data << endl;\n\n      appQueue.pop( );\n      ready = false;\n    }\n      cout << name << \" released mutex ...\" << endl;\n    break;\n\n    case PRODUCER:\n    {\n      cout << name << \" waiting to acquire mutex ...\" << endl;\n      unique_lock<mutex> uniqueLocker( locker );\n      cout << name << \" acquired mutex ...\" << endl;\n      if ( 32000 == count ) count = 0;\n      appQueue.push ( ++ count );\n      ready = true;\n      uniqueLocker.unlock();\n      cout << name << \" released mutex ...\" << endl;\n      untilReady.notify_one();\n      cout << name << \" notified conditional signal ...\" << endl;\n    }\n    break;\n  }\n  }\n}\n\nvoid Thread::start( ) {\n  pThread = new thread ( &Thread::run, this );\n}\n\nvoid Thread::stop( ) {\n  stopped = true;\n}\n\nvoid Thread::join( ) {\n  pThread->join( );\n}\n\nvoid Thread::detach( ) {\n  pThread->detach( );\n}\n```", "```cpp\n#include \"Thread.h\"\n\nint main ( ) {\n\n  Thread producer( ThreadType::PRODUCER );\n  Thread consumer( ThreadType::CONSUMER );\n\n  producer.start();\n  consumer.start();\n\n  producer.join();\n  consumer.join();\n\n  return 0;\n} \n```", "```cpp\ng++ Thread.cpp main.cpp -o conditional_variable.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\nusing namespace std;\n\nvoid sayHello( ) {\n  cout << endl << \"Hello Concurrency support library!\" << endl;\n}\n\nint main ( ) {\n  future<void> futureObj = async ( launch::async, sayHello );\n  futureObj.wait( );\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\nusing namespace std;\n\nvoid sayHello( promise<string> promise_ ) {\n  promise_.set_value ( \"Hello Concurrency support library!\" );\n}\n\nint main ( ) {\n  promise<string> promiseObj;\n\n  future<string> futureObj = promiseObj.get_future( );\n  async ( launch::async, sayHello, move( promiseObj ) );\n  cout << futureObj.get( ) << endl;\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <promise>\n#include <thread>\n#include <functional>\nusing namespace std;\n\nint main ( ) {\n     packaged_task<int (int, int)>\n        addTask ( [] ( int firstInput, int secondInput ) {\n              return firstInput + secondInput;\n     } );\n\n     future<int> output = addTask.get_future( );\n     addTask ( 15, 10 );\n\n     cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n     return 0;\n}\n```", "```cpp\naddTask ( [] ( int firstInput, int secondInput ) {\n              return firstInput + secondInput;\n}); \n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <thread>\n#include <functional>\nusing namespace std;\n\nint add ( int firstInput, int secondInput ) {\n  return firstInput + secondInput;\n}\n\nint main ( ) {\n  packaged_task<int (int, int)> addTask( add);\n\n  future<int> output = addTask.get_future( );\n\n  thread addThread ( move(addTask), 15, 10 );\n\n  addThread.join( );\n\n  cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <string>\nusing namespace std;\n\nint add ( int firstInput, int secondInput ) {\n  return firstInput + secondInput;\n}\n\nint main ( ) {\n\n  packaged_task<int (int,int)> addTask( add );\n  future<int> output = addTask.get_future();\n  thread addThread ( move(addTask), 15, 10);\n  addThread.join();\n  cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <promise>\nusing namespace std;\n\nvoid add ( int firstInput, int secondInput, promise<int> output ) {\n  try {\n         if ( ( INT_MAX == firstInput ) || ( INT_MAX == secondInput ) )\n             output.set_exception( current_exception() ) ;\n        }\n  catch(...) {}\n\n       output.set_value( firstInput + secondInput ) ;\n\n}\n\nint main ( ) {\n\n     try {\n    promise<int> promise_;\n          future<int> output = promise_.get_future();\n    async ( launch::deferred, add, INT_MAX, INT_MAX, move(promise_) );\n          cout << \"The sum of INT_MAX + INT_MAX is \" << output.get ( ) << endl;\n     }\n     catch( exception e ) {\n  cerr << \"Exception occured\" << endl;\n     }\n}\n\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```"]