- en: Designing a 2D Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计2D相机
- en: Camera design is one of those things that is frequently forgotten by novice
    game designers. Up to this point, we have had what is called a *fixed position
    camera*. There is a single screen with no change in perspective. In the 1970s,
    almost all of the early arcade games were designed this way. The oldest game that
    I have found with any sort of camera was Atari's *Lunar Lander*, which was released
    in August 1979\. *Lunar Lander* was an early vector-based game that would zoom
    the camera in as the lander neared the surface of the moon, and would then pan
    the camera out to follow your lander as it approached the surface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 相机设计是新手游戏设计师经常忽视的事情之一。到目前为止，我们一直使用的是所谓的*固定位置相机*。屏幕上没有透视变化。在20世纪70年代，几乎所有早期的街机游戏都是这样设计的。我发现的最古老的带有相机的游戏是Atari的*Lunar
    Lander*，它于1979年8月发布。*Lunar Lander*是一个早期的基于矢量的游戏，当着陆器接近月球表面时，相机会放大，然后在着陆器接近表面时移动相机。
- en: In the early 1980s, more games began experimenting with the idea of a game world
    that was larger than a single game screen would allow. *Rally X* was a *Pac-Man-*like
    maze game released in 1980 by Namco, where the maze was larger than a single display.
    *Rally X* used a *position snap camera* (sometimes called a *locked camera*) that
    always kept the player's car in the center of the game screen no matter what.
    That is the most straightforward form of 2D scrolling camera that you can implement,
    and many novice game designers will create a *2D position snap camera* and then
    call it a day, but there are reasons why you may wish to implement a more sophisticated
    camera in your game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代初，更多的游戏开始尝试一个比单个游戏屏幕更大的游戏世界的想法。*Rally X*是Namco于1980年发布的类似*Pac-Man*的迷宫游戏，其中迷宫比单个显示更大。*Rally
    X*使用了一个*位置捕捉相机*（有时称为*锁定相机*），无论如何都会将玩家的汽车保持在游戏屏幕的中心。这是你可以实现的最简单的2D滚动相机形式，许多新手游戏设计师会创建一个*2D位置捕捉相机*然后就此结束，但是你可能希望在游戏中实现更复杂的相机，这是有原因的。
- en: Midway released the game *Defender* in 1981\. It was a side-scrolling shooter
    that allowed the player to move their spaceship in either direction. Realizing
    that the player needed to see more of the level in the direction that the spaceship
    was facing, *Defender* used the first *dual-forward-focus camera*. This camera
    shifts the viewing area so that two-thirds of the screen is in front of the direction
    the player's spaceship is facing, and one third of the screen is behind. That
    puts more of a focus on what is currently in front of the player. The camera did
    not just snap back and forth between the two positions. That would have been very
    jarring. Instead, when the player switched directions, the camera position would
    smoothly transition to its new position (pretty cool for 1981).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1981年，Midway发布了游戏*Defender*。这是一个横向卷轴射击游戏，允许玩家在任何方向移动他们的太空飞船。意识到玩家需要看到太空飞船面对的方向更多的关卡内容，*Defender*使用了第一个*双向前置焦点相机*。这个相机会移动视野区域，使得屏幕的三分之二在玩家太空飞船面对的方向前面，三分之一在后面。这更加关注了玩家当前面对的内容。相机不会在两个位置之间突然切换，那样会很令人不适。相反，当玩家改变方向时，相机位置会平稳过渡到新的位置（对于1981年来说相当酷）。
- en: During the 1980s, many new camera designs came into use. Konami began using
    an autoscrolling camera in many of their shooter games, including *Scramble*,
    *Gradius*, and *1942*. In 1985, Atari released *Gauntlet*, which was an early
    multi-player game allowing four players to be in the game at the same time. The
    camera in *Gauntlet* positioned itself at the average of all of the player's positions.
    Platformer games, such as *Super Mario Bros.*, would allow the position of the
    user to push the camera forward.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代，许多新的相机设计开始被使用。Konami开始在许多射击游戏中使用自动滚动相机，包括*Scramble*、*Gradius*和*1942*。1985年，Atari发布了*Gauntlet*，这是一个早期的多人游戏，允许四名玩家同时参与游戏。*Gauntlet*中的相机定位在所有玩家位置的平均值处。像*Super
    Mario Bros.*这样的平台游戏允许用户的位置推动相机向前移动。
- en: You will need to include several images in your build to make this project work.
    Make sure you include the `/Chapter11/sprites/` folder from the project's GitHub.
    If you haven't yet downloaded the GitHub project, you can get it online at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在构建中包含几个图像才能使这个项目工作。确保你从项目的GitHub中包含了`/Chapter11/sprites/`文件夹。如果你还没有下载GitHub项目，你可以在[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)上获取它。
- en: There are many great examples of 2D cameras out there if you take the time to
    look. We are going to focus (no pun intended) on a few 2D camera features that
    will be helpful for our game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间寻找，会发现很多出色的2D相机示例。我们将专注（无意冒犯）于一些对我们的游戏有帮助的2D相机特性。
- en: Creating a camera for our game
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的游戏创建相机
- en: We are going to build our camera in several different stages. We will start
    with a bare-bones **locked-on camera** implementation. That will give us a good
    starting point from where we can add new camera features. Later, we will modify
    this camera to be a **projected focus camera**. A projected focus camera looks
    at the velocity of the player's ship and adjusts the camera so that it shows more
    of the gameplay area in front of the player. This technique works off the assumption
    that, in this game, the player is generally more focused on the gameplay in the
    direction the player's ship is moving. For the final version of our camera, we
    will add *camera* *attractors* to our projectiles. The idea behind this modification
    is that, when there are shots fired in the game, the camera should draw attention
    to that area of the game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分几个不同的阶段构建我们的摄像机。我们将从一个基本的**锁定摄像机**实现开始。这将为我们提供一个很好的起点，我们可以在此基础上添加新的摄像机功能。稍后，我们将修改这个摄像机，使其成为一个**投影焦点摄像机**。投影焦点摄像机会关注玩家飞船的速度，并调整摄像机，以便在玩家前方显示更多的游戏区域。这种技术基于这样的假设，即在这个游戏中，玩家通常更关注玩家飞船移动的方向上的游戏内容。对于我们摄像机的最终版本，我们将在我们的抛射物上添加*摄像机吸引器*。这种修改的想法是，当游戏中有射击时，摄像机应该吸引注意力到游戏的那个区域。
- en: Camera for tracking player movement
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于跟踪玩家移动的摄像机
- en: The first implementation of our camera will be a locked-on camera, which will
    lock onto our player and follow them as they move through the area in the level.
    Right now, our level is the same size as our *fixed camera* at that level. Not
    only will we need to make our level larger, but we will also need to modify our
    object wrapping so that it works with our camera. The first thing that we will
    need to do to implement our locked-on camera is to modify our `game.hpp` file.
    We will be creating a `Camera` class as well as a `RenderManager` class, where
    we will move all of our rendering-specific code. We will also need to add some
    `#define` macros than define our level's height and width, because that will now
    be different to the canvas height and width that we have already defined. We will
    also be adding a few additional overloaded operators to our `Vector2D` class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们摄像机的第一个实现将是一个锁定摄像机，它将锁定我们的玩家，并随着他们在关卡中移动而跟随。现在，我们的关卡和该关卡上的*固定摄像机*大小相同。我们不仅需要使我们的关卡更大，还需要修改我们的对象包裹，以使其与我们的摄像机配合。我们需要做的第一件事是修改我们的`game.hpp`文件以实现我们的锁定摄像机。我们将创建一个`Camera`类和一个`RenderManager`类，在其中移动所有我们特定于渲染的代码。我们还需要添加一些`#define`宏来定义我们关卡的高度和宽度，因为这将与我们已经定义的画布高度和宽度不同。我们还将向我们的`Vector2D`类添加一些额外的重载运算符。
- en: Projected focus and camera attractors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影焦点和摄像机吸引器
- en: A locked-on camera is not a terrible thing, but a better camera shows more of
    what the player needs to see. In our game, the player is more likely to be interested
    in what lies ahead in the direction they are moving. A camera that looks ahead
    in the direction of movement is sometimes called a projected focus camera. We
    can look at the velocity at which our ship is currently moving, and offset our
    camera accordingly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定摄像机并不是一件糟糕的事情，但更好的摄像机会显示玩家需要看到的更多内容。在我们的游戏中，玩家更有可能对他们移动方向前方的内容感兴趣。有时被称为投影焦点摄像机的摄像机会关注我们飞船当前移动的速度，并相应地调整我们的摄像机位置。
- en: Another camera technique that we will employ is called **camera attractors**.
    Sometimes in games, there are objects of interest that can be used to pull/attract
    the focus of the camera. These create an attractive force that will pull our camera
    in that direction. One attractive force for our camera is the enemy ship. Another
    attractive force is projectiles. The enemy ship represents potential action, and
    projectiles represent a potential threat to our player. In this section, we will
    combine a projected focus with camera attractors to improve our camera positioning.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用的另一种摄像机技术称为**摄像机吸引器**。有时在游戏中，有一些感兴趣的对象可以用来吸引摄像机的焦点。这些对象会产生一种吸引力，会把我们的摄像机朝着那个方向拉动。我们摄像机的一个吸引力是敌人的飞船。另一个吸引力是抛射物。敌人的飞船代表潜在的行动，而抛射物代表对我们玩家的潜在威胁。在本节中，我们将结合投影焦点和摄像机吸引器来改善我们的摄像机定位。
- en: The last thing I would like to add is an arrow that points the way toward the
    enemy spaceship. Because the play area is now larger than the canvas, we need
    a hint to help us find the enemy. Without this, we may find ourselves wandering
    around aimlessly, which is not very fun. Another way we could have done this is
    with a mini-map, but, because there is only a single enemy, I felt an arrow would
    be easier to implement. Let's walk through the code we need to add to improve
    our camera and add our locating arrow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要添加的最后一件事是一个指向敌人飞船的箭头。因为游戏区域现在比画布大，我们需要一个提示来帮助我们找到敌人。如果没有这个，我们可能会发现自己毫无目的地四处游荡，这并不好玩。我们还可以用小地图来实现这一点，但是因为只有一个敌人，我觉得箭头会更容易实现。让我们逐步了解我们需要添加的代码，以改善我们的摄像机并添加我们的定位箭头。
- en: Modifying our code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的代码
- en: We are going to need to add several new classes for this chapter. Obviously,
    if we want a camera in our game, we will need to add a `Camera` class. In previous
    versions of the code, the rendering was done through direct calls to SDL. Because
    SDL does not have a camera as a part of the API, we will need to add a `RenderManager`
    class that will act as an intermediate step in our rendering process. This class
    will use the position of the camera to determine where on our canvas we will be
    rendering our game object. We will be increasing our gameplay area to four screens
    wide and four screens high. This creates a gameplay problem, because now, we will
    need to be able to find the enemy spaceship when we play. To solve this problem,
    we will need to create a locator **user interface** (**UI**) element that points
    an arrow in the direction of the enemy spaceship.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要为本章添加几个新的类。显然，如果我们想在游戏中有一个摄像头，我们将需要添加一个`Camera`类。在代码的先前版本中，渲染是通过直接调用SDL完成的。因为SDL没有摄像头作为API的一部分，我们将需要添加一个`RenderManager`类，作为我们渲染过程中的中间步骤。这个类将使用摄像机的位置来确定我们在画布上渲染游戏对象的位置。我们将扩大我们的游戏区域，使其为画布的四倍宽和四倍高。这会产生一个游戏问题，因为现在我们需要能够找到敌人飞船。为了解决这个问题，我们需要创建一个指向敌人飞船方向的定位器**用户界面**（**UI**）元素。
- en: Modifying the game.hpp file
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改game.hpp文件
- en: 'Let''s walk through the changes we will make to our `game.hpp` file. We begin
    by adding a few `#define` macros:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将对`game.hpp`文件进行的更改。我们首先添加了一些`#define`宏：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will define the width and height of our level to be four times as large
    as the width and height of our canvas. At the end of our list of classes, we should
    add a `Camera` class, a `Locator` class, and the `RenderManager` class, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义我们的关卡的宽度和高度是画布宽度和高度的四倍。在我们的类列表的末尾，我们应该添加一个`Camera`类，一个`Locator`类和`RenderManager`类，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will notice that the last three lines declare that a class called `Camera`,
    a class called `Locator`, and a class called `RenderManager` will be defined later
    in the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到最后三行声明了一个名为`Camera`的类，一个名为`Locator`的类，以及一个名为`RenderManager`的类将在代码中稍后定义。
- en: The Vector2D class definition
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vector2D类定义
- en: We will be expanding our `Vector2D` class definition to add an `operator+` and
    `operator-` overload for the `+` and `-` operators in our `Vector2D` class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的`Vector2D`类定义，为`Vector2D`类中的`+`和`-`运算符添加`operator+`和`operator-`重载。
- en: If you are not familiar with operator overloading, these are a convenient way
    to allow classes to use C++ operators instead of functions. There is a good tutorial
    that can help if you are looking for more information that is available at [https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉运算符重载，这是允许类使用C++运算符而不是函数的便捷方式。有一个很好的教程可以帮助您获取更多信息，可在[https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)找到。
- en: 'Here is what the new definition of the `Vector2D` class looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Vector2D`类的新定义：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will notice that the last two lines of the definition are new:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到定义的最后两行是新的：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Locator class definition
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Locator类定义
- en: 'The `Locator` class is a new class for a UI element that will be an arrow pointing
    our player in the direction of the enemy spaceship. We require a UI element to
    help the player find the enemy spaceship when it does not appear on the canvas.
    Here is what the class definition looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Locator`类是一个新的UI元素类，将指向玩家指向敌人飞船的箭头。当敌人飞船不出现在画布上时，我们需要一个UI元素来帮助玩家找到敌人飞船。以下是类定义的样子：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first two attributes are Boolean flags that have to do with the active
    state of the locator. The `m_Active` attribute tells us whether the locator is
    currently active and should be rendered. The `m_LastActive` attribute is a Boolean
    flag that tells us whether the locator was active the last time a frame was rendered.
    The next two lines are the sprite texture and the destination rectangle that will
    be used by the render manager to render this game object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性是布尔标志，与定位器的活动状态有关。`m_Active`属性告诉我们定位器当前是否活动并应该被渲染。`m_LastActive`属性是一个布尔标志，告诉我们上一帧渲染时定位器是否活动。接下来的两行是精灵纹理和目标矩形，这将由渲染管理器用于渲染游戏对象：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After that, we have an `x` and `y` positional value in the `m_Position` attribute,
    an integer that represents an RGB color value in `m_ColorFlux`, and a rotation
    value for the sprite in the `m_Rotation` attribute. We will be using the `m_ColorFlux`
    attribute to cause the color of the arrow to be redder when the enemy is close,
    and whiter when the enemy is further away.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`m_Position`属性中有一个`x`和`y`位置值，`m_ColorFlux`中有一个表示RGB颜色值的整数，以及`m_Rotation`属性中的精灵旋转值。我们将使用`m_ColorFlux`属性使箭头的颜色在敌人靠近时更红，敌人远离时更白。
- en: 'The last four lines of this class definition are the class functions. There
    is a constructor, a function that sets the status of the locator to active, and
    `Move` and `Render` functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义的最后四行是类函数。有一个构造函数，一个将定位器状态设置为活动的函数，以及`Move`和`Render`函数：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Camera class definition
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Camera类定义
- en: 'We now need to add the new `Camera` class definition. This class will be used
    to define our `viewport` and the position of our camera. The `Move` function will
    be called for every frame. Initially, `Move` will lock on to the position of our
    player and follow it around the level. Later, we will change this functionality
    to create a more dynamic camera. This is what the `Camera` class will look like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加新的`Camera`类定义。这个类将用于定义我们的`viewport`和摄像机的位置。`Move`函数将在每一帧中调用。最初，`Move`将锁定到我们玩家的位置并跟随其在关卡中移动。稍后，我们将改变这个功能以创建一个更动态的摄像机。`Camera`类将如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The RenderManager class definition
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RenderManager类定义
- en: 'All this time, we have been moving around our level without a background. This
    was fine in previous chapters, where our level fitted exactly onto the canvas
    element. Now, however, we are scrolling around our level with a camera. If nothing
    is moving in the background, it can be hard to tell whether your spaceship is
    moving at all. To create the illusion of movement in our game, we will need to
    add a background renderer. In addition to that, we want all rendering in our game
    to be done using the camera we just created as an offset. Because of this, we
    no longer want our game objects to call `SDL_RenderCopy` or `SDL_RenderCopyEx`
    directly. Instead, we have created a `RenderManager` class that will take responsibility
    for performing the rendering from within our game. We have a `RenderBackground`
    function that will render a starfield as a background, and we have created a `Render`
    function that will render our sprite textures using the camera as an offset. This
    is what the `RenderManager` class definition looks like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间里，我们一直在没有背景的情况下移动我们的关卡。在以前的章节中，我们的关卡恰好适合画布元素。然而，现在我们正在用相机在我们的关卡周围滚动。如果背景中没有任何东西在移动，很难判断你的飞船是否在移动。为了在我们的游戏中创造移动的幻觉，我们需要添加一个背景渲染器。除此之外，我们希望我们游戏中的所有渲染都是使用我们刚刚创建的相机作为偏移量来完成的。因此，我们不再希望我们的游戏对象直接调用`SDL_RenderCopy`或`SDL_RenderCopyEx`。相反，我们创建了一个`RenderManager`类，它将负责在我们的游戏内部执行渲染。我们有一个`RenderBackground`函数，它将渲染星空作为背景，并且我们创建了一个`Render`函数，它将使用相机作为偏移量来渲染我们的精灵纹理。这就是`RenderManager`类定义的样子：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last thing we need to do in the `game.hpp` file is to create an external
    link to two new object pointers of the `Camera` and `RenderManager` types. These
    will be the camera and render manager objects that we will be using in this version
    of our game engine and are external references to variables that we will define
    inside our `main.cpp` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game.hpp`文件中我们需要做的最后一件事是创建`Camera`和`RenderManager`类型的两个新对象指针的外部链接。这些将是我们在这个版本的游戏引擎中使用的相机和渲染管理器对象，并且是我们将在`main.cpp`文件中定义的变量的外部引用：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The camera.cpp file
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: camera.cpp文件
- en: 'There are two functions we have defined in our `Camera` class; a constructor
    for our `camera` object, and the `Move` function, which we will use to follow
    our `player` object. The following is what we have in the `camera.cpp` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Camera`类中我们定义了两个函数；一个是用于我们的`camera`对象的构造函数，另一个是`Move`函数，我们将用它来跟随我们的`player`对象。以下是我们在`camera.cpp`文件中的内容：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Camera` constructor and `Move` functions are pretty bare bones in this
    implementation. The constructor sets the half width and half height of the camera
    based on the width and height that is passed in. The `Move` function sets the
    position of the camera to the position of the player and then shifts the position
    of the camera by half of the canvas width and canvas height to center the player.
    We have just built a starter camera and will add more functionality to it later
    in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`Camera`构造函数和`Move`函数非常简单。构造函数根据传入的宽度和高度设置相机的半宽和半高。`Move`函数将相机的位置设置为玩家的位置，然后将相机的位置移动画布宽度和画布高度的一半来使玩家居中。我们刚刚建立了一个起始相机，并将在本章后面添加更多功能。
- en: The render_manager.cpp file
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: render_manager.cpp文件
- en: 'We will be moving all of the calls we were making to render sprites inside
    our objects to the `RenderManager` class. We need to do this because we will be
    using the position of our camera to decide where on our canvas we will be rendering
    the sprites. We also need a function that will render our background starfield.
    The first few lines of our `render_manager.cpp` file will be including the `game.hpp`
    file and defining the virtual filesystem location of our background image:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们在对象内部进行的所有呼叫渲染精灵的操作移动到`RenderManager`类中。我们需要这样做是因为我们将使用我们相机的位置来决定我们在画布上渲染精灵的位置。我们还需要一个函数来渲染我们的背景星空。我们`render_manager.cpp`文件的前几行将包括`game.hpp`文件，并定义我们背景图像的虚拟文件系统位置：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we will define our constructor. The constructor will be used to
    load our `starfield.png` file as an `SDL_Surface` object, and will then use that
    surface to create an `SDL_Texture` object that we will use to render our background:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将定义我们的构造函数。构造函数将用于将我们的`starfield.png`文件加载为一个`SDL_Surface`对象，然后使用该表面创建一个`SDL_Texture`对象，我们将使用它来渲染我们的背景：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `RenderBackground` function will need to be called at the beginning of
    our `render()` function that we have defined in the `main` loop. Because of this,
    the first two lines of `RenderBackground` will have two functions that we will
    use to clear the renderer that was previously called from the `render()` function
    in `main.cpp` to black:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBackground`函数将需要在我们在`main`循环中定义的`render()`函数的开头被调用。因此，`RenderBackground`的前两行将有两个函数，我们将使用它们来清除之前在`main.cpp`中从`render()`函数调用的渲染器到黑色：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we will set up a background rectangle that will be our rendering
    destination. The size of `starfield.png` matches our canvas size (800 x 600),
    so we will need to render it four times based on the camera''s position. Because
    this is a repeating texture, we can use a modulo operator (`%`) on the position
    of our camera to figure out how we want to offset the starfield. As an example,
    if we had positioned our camera at `*x* = 100`, `*y* = 200`, we would want to
    render the first copy of our starfield background at `-100`, `-200`. If we stopped
    there, we would have 100 pixels of black space on the right, and 200 pixels of
    black space on the bottom of our canvas. Because we would like a background in
    those areas, we will need three additional renders of our background. If we render
    our background a second time at `700`, `-200` (adding canvas width to the previous
    render''s *x* value), we would now have a 200-pixel strip of black at the bottom
    of the canvas. We could then render our starfield at `-100`, `400` (adding canvas
    height to the original render''s *y* value). That would leave us with a 100 x
    200 pixel of black in the bottom corner. The fourth render would need to add the
    canvas width and canvas height to the original render''s *x* and *y* value to
    fill in that corner. That is what is going on in the `RenderBackground` function
    that we use to render the repeating background to the canvas based on the position
    of the camera:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将设置一个背景矩形作为我们的渲染目标。`starfield.png`的大小与我们的画布大小（800 x 600）相匹配，因此我们需要根据摄像头的位置渲染四次。因为这是一个重复的纹理，我们可以使用模运算符（`%`）在摄像头的位置上来确定我们想要如何偏移星空。举个例子，如果我们将摄像头定位在`*x*
    = 100`，`*y* = 200`，我们希望将我们的星空背景的第一份拷贝渲染在`-100`，`-200`。如果我们停在这里，我们会在画布的右侧有100像素的黑色空间，在画布的底部有200像素的黑色空间。因为我们希望在这些区域有一个背景，我们需要额外渲染三次我们的背景。如果我们在`700`，`-200`处再次渲染我们的背景（在原始渲染的*x*值上添加画布宽度），我们现在在画布底部有一个200像素的黑色条。然后我们可以在`-100`，`400`处渲染我们的星空（在原始渲染的*y*值上添加画布高度）。这样会在底角留下一个100
    x 200像素的黑色。第四次渲染需要在原始渲染的*x*和*y*值上添加画布宽度和画布高度来填补那个角落。这就是我们在`RenderBackground`函数中所做的，我们用它来根据摄像头的位置将重复的背景渲染到画布上：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last function we define in `render_manager.cpp` is our `Render` function.
    After defining this function, we will need to find every place where we have previously
    called `SDL_RenderCopy` and `SDL_RenderCopyEx` in our code, and replace those
    calls with calls to our render manager''s `Render` function. This function will
    not only render our sprite based on the position of our camera, but it will also
    be used to set color and alpha channel modifications. Here is the code from the
    `Render` function in its entirety:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`render_manager.cpp`中定义的最后一个函数是我们的`Render`函数。在定义完这个函数之后，我们需要找到我们之前在代码中调用`SDL_RenderCopy`和`SDL_RenderCopyEx`的每个地方，并将这些调用替换为对我们渲染管理器的`Render`函数的调用。这个函数不仅会根据我们摄像头的位置来渲染我们的精灵，还会用于设置颜色和alpha通道的修改。以下是`Render`函数的完整代码：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first thing this function does is create a new `SDL_Rect` object, which
    we will use to modify the values in the `dest` variable passed into the `Render`
    function. Because we have a level that wraps the *x* and *y* coordinates, we will
    want to render objects on the far left of our level to the right if we are on
    the right edge of our level. Likewise, if we are on the far-left side of our level,
    we will want to render objects positioned on the far-right side of our level to
    our right. This allows our spaceship to loop around from the left side of our
    level back to the right side of our level, and vice versa. The following is the
    code that adjusts the camera position for wrapping objects to the left and right
    of the level:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一步是创建一个新的`SDL_Rect`对象，我们将用它来修改传递给`Render`函数的`dest`变量中的值。因为我们有一个包裹*x*和*y*坐标的级别，所以我们希望在级别的最左边渲染对象时，如果我们在级别的最右边，我们将希望将对象渲染到右边。同样，如果我们在级别的最左边，我们将希望将位于级别最右边的对象渲染到右边。这样可以使我们的飞船从级别的左侧环绕到级别的右侧，反之亦然。以下是调整摄像头位置以包裹级别左右对象的代码：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this has been done, we will do something similar to allow for wrapping
    the position of objects at the top and the bottom of our level:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些之后，我们将做类似的事情，以便在级别的顶部和底部包裹对象的位置：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to subtract the camera''s position from the `camera_dest` *x*
    and *y* coordinates, and set the values for our `alpha` and `color` mod:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从`camera_dest`的*x*和*y*坐标中减去摄像头的位置，并设置我们的`alpha`和`color`修改的值：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the end of the function, we will call `SDL_RenderCopyEx` if our sprite is
    rotated, and `SDL_RenderCopy` if it is not:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的结尾，如果我们的精灵被旋转，我们将调用`SDL_RenderCopyEx`，如果没有旋转，我们将调用`SDL_RenderCopy`：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modifying main.cpp
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改main.cpp
- en: To implement our camera, we will need to make several modifications to our `main.cpp`
    file. We will need to add some new global variables for our camera, render manager,
    and locator. We will need to modify our `move` function to include calls to move
    our camera and our locator. We will modify our `render` function to render our
    background and locator. Finally, we will need to add more initialization code
    to our `main` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的摄像头，我们需要对`main.cpp`文件进行一些修改。我们需要为我们的摄像头、渲染管理器和定位器添加一些新的全局变量。我们需要修改我们的`move`函数，以包括移动我们的摄像头和定位器的调用。我们将修改我们的`render`函数来渲染我们的背景和定位器。最后，我们需要在我们的`main`函数中添加更多的初始化代码。
- en: New global variables
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的全局变量
- en: 'We need to create three new global variables near the beginning of our `main.cpp`
    file. We will need object pointers to `RenderManager`, `Camera`, and `Locator`.
    This is what those declarations look like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`main.cpp`文件的开头附近创建三个新的全局变量。我们将需要指向`RenderManager`、`Camera`和`Locator`的对象指针。这是这些声明的样子：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Modifying the move function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改move函数
- en: 'We will need to modify our `move` function to move our camera and our locator
    object. We will need to add the following two lines at the end of our `move` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的`move`函数来移动我们的摄像头和我们的定位器对象。我们需要在我们的`move`函数的结尾添加以下两行：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the `move` function in its entirety:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`move`函数的全部内容：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Modifying the render function
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改渲染函数
- en: 'We will add a new line to the very beginning of the `render` function. This
    line will render the background starfield and move it based on the camera position:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`render`函数的开头添加一行新代码。这行代码将渲染背景星空，并根据摄像机位置移动它：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we will need to add a line to the end of the `render` function.
    This line will need to come immediately before the `SDL_RenderPresent` call, which
    will still need to be the last line in this function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要在`render`函数的末尾添加一行代码。这行代码需要立即出现在`SDL_RenderPresent`调用之前，而`SDL_RenderPresent`调用仍然需要是该函数中的最后一行：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is what the `render()` function looks like in its entirety:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`render()`函数的全部内容：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Modifying the main function
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主函数
- en: 'The final modifications will be to initialization that happens in the `main`
    function. We will need to create new objects for the `camera`, `render_manager`,
    and `locator` pointers we defined earlier:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的修改将是在`main`函数中发生的初始化。我们需要为之前定义的`camera`、`render_manager`和`locator`指针创建新对象：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous version of our code, we had seven calls to `new Asteroid` and
    used `asteroid_list.push_back` to push those seven new asteroids into our list
    of asteroids. We will now need to create far more asteroids than seven, so, instead
    of doing them as individual calls, we will be using a double `for` loop to create
    and spread out our asteroids all over the gameplay area. To do this, we will first
    need to remove all of those earlier calls to create and push asteroids:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码的先前版本中，我们有七个调用`new Asteroid`并使用`asteroid_list.push_back`将这七个新小行星推入我们的小行星列表中。现在我们需要创建比七个更多的小行星，所以我们将使用双重`for`循环来创建并分散我们的小行星遍布整个游戏区域。为此，我们首先需要删除所有那些早期的调用来创建和推入小行星：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you have removed all of the preceding code, we will add the following
    code to create our new asteroids and space them semi-randomly throughout the gameplay
    area:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您删除了所有前面的代码，我们将添加以下代码来创建新的小行星，并在整个游戏区域中将它们半随机地分布：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Modifying asteroid.cpp
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改asteroid.cpp
- en: 'Now that we are using a render manager to render all of our game objects, we
    will need to go through our various game objects and modify them to render through
    the render manager instead of directly. The first file we will modify is `asteroid.cpp`.
    Inside `asteroid.cpp`, we have the `Asteroid::Render()` function. In previous
    chapters, this function would render the asteroid sprite directly through SDL
    using a call to `SDL_RenderCopyEx`. Now that we have the `render_manager` object
    that we defined in our `main.cpp` file, we will be using that render manager to
    render our sprite indirectly. The `RenderManager::Render` function will use the
    camera to adjust the location on the canvas where the sprite will be rendered.
    The first modification we need to make to the `Asteroid::Render()` function is
    to remove the following lines:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用渲染管理器来渲染所有游戏对象，我们需要遍历各种游戏对象并修改它们以通过渲染管理器而不是直接渲染。我们将首先修改`asteroid.cpp`文件。在`asteroid.cpp`中，我们有`Asteroid::Render()`函数。在之前的章节中，这个函数会直接通过SDL渲染小行星精灵，使用`SDL_RenderCopyEx`调用。现在我们有了在`main.cpp`文件中定义的`render_manager`对象，我们将使用该渲染管理器间接地渲染我们的精灵。`RenderManager::Render`函数将使用摄像机来调整在画布上渲染精灵的位置。我们需要对`Asteroid::Render()`函数进行的第一个修改是删除以下行：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After removing the call to `SDL_RenderCopyEX`, we need to add the following
    call to the `Render` function within the `render_manager` object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对`SDL_RenderCopyEX`的调用后，我们需要在`render_manager`对象的`Render`函数中添加以下调用：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The new version of the `Asteroid::Render` function will now look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asteroid::Render`函数的新版本现在看起来像这样：'
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Modifying collider.cpp
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改collider.cpp
- en: 'We will need to modify one function inside the `collider.cpp` file. The previous
    version of the `WrapPosition` function checked to see whether a `Collider` object
    moved off the canvas to one side or another, and, if it did, the function would
    move the collider to the opposite side. This mimicked the behavior of the classic
    Atari arcade game, *Asteroids*. In Atari *Asteroids*, if an asteroid or the player''s
    spaceship moved off the screen on one side, that asteroid (or spaceship) would
    appear on the opposite side of the game screen. Here is the previous version of
    our `wrap` code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`collider.cpp`文件中的一个函数。`WrapPosition`函数的先前版本检查`Collider`对象是否移出画布的一侧，如果是，则该函数将移动碰撞器到相反的一侧。这模仿了经典的Atari街机游戏*Asteroids*的行为。在Atari
    *Asteroids*中，如果一个小行星或玩家的太空船从屏幕的一侧移出，那个小行星（或太空船）将出现在游戏屏幕的对面。这是我们`wrap`代码的先前版本：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because our game now extends beyond a single canvas, we no longer want to wrap
    if an object moves off the canvas. Instead, we want to wrap the object around
    if it falls outside the bounds of the level. Here is the new version of the `WrapPosition`
    function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的游戏现在扩展到超出单个画布，所以我们不再希望在对象移出画布时进行包装。相反，我们希望在对象超出级别的边界时将其包装。这是`WrapPosition`函数的新版本：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Modifying enemy_ship.cpp
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改enemy_ship.cpp
- en: 'A small modification to the `enemy_ship.cpp` file is necessary. The `EnemyShip`
    constructor function will now be setting the `x` and `y` values on the `m_Position`
    attribute. We need to set the position to `810` and `800`, because the level is
    now much larger than the canvas size. We will set the `m_Position` attribute at
    the very top of the `EnemyShip` constructor. This is what the beginning of the
    constructor will look like after the changes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对`enemy_ship.cpp`文件进行一些小修改。`EnemyShip`构造函数现在将设置`m_Position`属性上的`x`和`y`值。我们需要将位置设置为`810`和`800`，因为级别现在比画布大小大得多。我们将在`EnemyShip`构造函数的最顶部设置`m_Position`属性。在更改后，构造函数的开头将如下所示：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Modifying finite_state_machine.cpp
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改finite_state_machine.cpp
- en: 'We will need to make a small change to the `finite_state_machine.cpp` file.
    Inside the `FiniteStateMachine::AvoidForce()` function, there are several references
    to the canvas dimensions that must be changed to reference the level dimensions
    now that the size of our level and the size of our canvas are different. Previously,
    we had set the `x` and `y` attributes of the `star_avoid` variable to the following
    canvas-based values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`finite_state_machine.cpp`文件进行小的修改。在`FiniteStateMachine::AvoidForce()`函数内部，有几个引用画布尺寸的地方必须更改为引用级别尺寸，因为我们的级别尺寸和画布尺寸不同。以前，我们将`star_avoid`变量的`x`和`y`属性设置为以下基于画布的值：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These lines must be changed to reference `LEVEL_WIDTH` and `LEVEL_HEIGHT`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行必须更改为引用`LEVEL_WIDTH`和`LEVEL_HEIGHT`：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We must do the same thing to the `avoid_vec` variable. Here is what we had
    previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对`avoid_vec`变量做同样的事情。这是我们以前的内容：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That must also be changed to reference `LEVEL_WIDTH` and `LEVEL_HEIGHT`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这也必须更改为引用`LEVEL_WIDTH`和`LEVEL_HEIGHT`：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The new version of the `FiniteState::AvoidForce` function in its entirety is
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`FiniteState::AvoidForce`函数的新版本完整内容如下：'
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Modifying particle.cpp
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改particle.cpp
- en: 'We will need to modify the `Render` function inside the `particle.cpp` file
    to render the particle through `render_manager` instead of directly through calls
    to SDL. The old version of the `Particle::Render` function is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`particle.cpp`文件中的`Render`函数，以便通过`render_manager`而不是直接通过调用SDL来渲染粒子。`Particle::Render`函数的旧版本如下：
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The new `Particle::Render` function will make a single call to the `Render`
    function through the `render_manager` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Particle::Render`函数将通过`render_manager`对象对`Render`函数进行一次调用：
- en: '[PRE41]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Modifying player_ship.cpp
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改player_ship.cpp
- en: We will need to make one small modification to the `player_ship.cpp` file. Like
    the change that we made to the `enemy_ship.cpp` file, we will need to add two
    lines to set the `x` and `y` values in the `m_Position` attribute.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`player_ship.cpp`文件进行一些小的修改。与我们对`enemy_ship.cpp`文件所做的更改一样，我们需要添加两行来设置`m_Position`属性中的`x`和`y`值。
- en: 'We will need to remove the first two lines of the `PlayerShip::PlayerShip()`
    constructor function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除`PlayerShip::PlayerShip()`构造函数的前两行：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These are the changes we will need to make to the `PlayerShip::PlayerShip()`
    constructor function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要对`PlayerShip::PlayerShip()`构造函数进行的更改：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Modifying projectile.cpp
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改projectile.cpp
- en: 'We will need to make a small change to the `projectile.cpp` file. As in other
    game objects, the `Render` function previously made calls directly to the SDL
    function to render the game object. Instead of making those calls to SDL, we will
    need to make a call through the `render_manager` object. We will need to remove
    the following lines from the `Projectile::Render()` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`projectile.cpp`文件进行一些小的修改。与其他游戏对象一样，`Render`函数以前直接调用SDL函数来渲染游戏对象。我们需要通过`render_manager`对象进行调用，而不是直接调用SDL。我们需要从`Projectile::Render()`函数中删除以下行：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In place of these lines, we will need to add a call to the `Render` function
    on the `render_manager` object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`render_manager`对象上添加一个对`Render`函数的调用来替换这些行：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is what the new version of the `Projectile::Render()` function will look
    like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Projectile::Render()`函数的新版本将如下所示：'
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Modifying shield.cpp
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改shield.cpp
- en: 'As with many other game objects, the `Shield::Render()` function will need
    to be modified so that it no longer calls SDL directly and instead calls the `Render`
    function from the `render_manager` object. Inside the `Shield::Render()` function,
    we will need to remove the following calls to SDL:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他游戏对象一样，`Shield::Render()`函数将需要修改，以便不再直接调用SDL，而是调用`render_manager`对象的`Render`函数。在`Shield::Render()`函数内部，我们需要删除对SDL的以下调用：
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will be replacing these lines with a single call to `Render`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个对`Render`的单一调用来替换这些行：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is what the new version of the `Shield::Render` function looks like in
    its entirety:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Shield::Render`函数的新版本的完整内容：
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Modifying ship.cpp
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改ship.cpp
- en: 'Modifying the `Render` functions within our game objects is becoming pretty
    routine. As in other objects where we have modified the `Render` function, we
    will need to remove all direct calls to SDL. Here is the code that we will need
    to remove from the `Render` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们游戏对象内的`Render`函数变得相当常规。与我们修改了`Render`函数的其他对象一样，我们需要删除所有直接调用SDL的部分。这是我们需要从`Render`函数中删除的代码：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After removing these lines, we will need to add a line to call the `render_manager->Render`
    function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这些行后，我们需要添加一行调用`render_manager->Render`函数：
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Modifying star.cpp
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改star.cpp
- en: 'We will need to modify two functions inside the `star.cpp` file. First, we
    will need to modify the position of the star in the `Star::Star()` constructor
    function. In the version of the `Star` constructor from the previous chapter,
    we set the position of the star to the middle of the canvas. Now, it must be set
    to the middle of the level. Here are the lines that were in the original version
    of the constructor:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`star.cpp`文件内的两个函数。首先，我们需要修改`Star::Star()`构造函数中星星的位置。在上一章的`Star`构造函数版本中，我们将星星的位置设置为画布的中间。现在，它必须设置为级别的中间。以下是原始版本构造函数中的行：
- en: '[PRE52]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will now change these to positions relative to `LEVEL_WIDTH` and `LEVEL_HEIGHT`
    instead of `CANVAS_WIDTH` and `CANVAS_HEIGHT`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更改这些位置，使其相对于`LEVEL_WIDTH`和`LEVEL_HEIGHT`而不是`CANVAS_WIDTH`和`CANVAS_HEIGHT`：
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After making the preceding change to the `Star::Star` constructor function,
    we will need to make a change to the `Star::Render` function. We will need to
    remove the call to `SDL_RenderCopy` and replace it with a call to the `Render`
    function on the `render_manager` object. This is what the previous version of
    the `Render` function looked like:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`Star::Star`构造函数进行上述更改后，我们需要对`Star::Render`函数进行更改。我们需要删除对`SDL_RenderCopy`的调用，并将其替换为对`render_manager`对象上的`Render`函数的调用。这是以前版本的`Render`函数的样子：
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will modify it to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改为以下内容：
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Modifying vector.cpp
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改vector.cpp
- en: 'We will need to add two new overloaded operators to our `Vector2D` class. We
    will need to override `operator-` and `operator+`. This code is pretty straightforward.
    It will use the already overloaded `operator-=` and `operator+=` to allow us to
    add and subtract vectors from each other. Here is the new code for those overloaded
    operators:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的`Vector2D`类添加两个新的重载运算符。我们需要重载`operator-`和`operator+`。这段代码非常简单。它将使用已经重载的`operator-=`和`operator+=`来允许我们对彼此的向量进行加法和减法。以下是这些重载运算符的新代码：
- en: '[PRE56]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Compiling and playing with a locked-on camera
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译并使用锁定摄像头进行游戏
- en: 'If we compile and test what we have right now, we should be able to move around
    our level and see a camera that directly tracks the player''s position. We should
    have a locator arrow that helps us to find the enemy spaceship. Here is the command-line
    call to Emscripten that we can use to build our project:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译和测试我们所拥有的东西，我们应该能够在我们的关卡中移动并看到一个直接跟踪玩家位置的摄像头。我们应该有一个定位箭头，帮助我们找到敌人的太空船。以下是我们可以用来构建项目的Emscripten的命令行调用：
- en: '[PRE57]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the preceding line on the Windows or Linux command prompt. After running
    this, serve the `index.html` file from a web server and open it in a browser such
    as Chrome or Firefox.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows或Linux命令提示符上运行上述命令。运行后，从Web服务器提供`index.html`文件，并在Chrome或Firefox等浏览器中打开它。
- en: A more advanced camera
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的摄像头
- en: Our current camera is functional, but a little boring. It focuses exclusively
    on the player, which works all right, but could be significantly improved. For
    starters, as the designers of *Defender* realized, it is more important to put
    the focus of the camera in the direction the player is moving, instead of directly
    on the player. To accomplish this, we will add *projected focus* to our camera.
    That will look at the current velocity of the player's ship, and will move the
    camera forward in the direction of that velocity. There are times, however, when
    you may still want the focus of your camera behind the player. To help with this,
    we will add some camera attractors. Camera attractors are objects that draw the
    camera's attention toward them. If the enemy appears behind the player, it may
    be more important to move the camera back somewhat to help keep the enemy on screen.
    If the enemy is shooting at you, it may be more important to draw the cameras
    toward the projectiles that are heading your way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的摄像头是功能性的，但有点无聊。它专注于玩家，这样做还行，但可以显著改进。首先，正如*Defender*的设计者意识到的那样，将摄像头的焦点放在玩家移动的方向上更为重要，而不是直接对准玩家。为了实现这一点，我们将在我们的摄像头中添加*投影焦点*。它将查看玩家飞船的当前速度，并将摄像头向前移动到该速度的方向。然而，有时您可能仍希望摄像头的焦点在玩家后面。为了帮助解决这个问题，我们将添加一些摄像头吸引器。摄像头吸引器是吸引摄像头注意力的对象。如果敌人出现在玩家后面，将摄像头稍微移回以帮助保持敌人在屏幕上。如果敌人向你射击，将摄像头吸引到向你飞来的弹丸可能更为重要。
- en: Changes to games.hpp
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对games.hpp的更改
- en: 'The first change we need to make is to our `games.hpp` file. Having a camera
    follow our player is easy. There is not any snapping or jarring movement of the
    camera because the player''s ship does not move that way. If we are going to use
    more advanced features, such as attractors and forward focus, we will need to
    calculate the desired position of our camera, and then transition smoothly to
    that position. To support this, we will need to add a `m_DesiredPosition` attribute
    to our `Camera` class. The following is the new line we must add:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是修改我们的`games.hpp`文件。让摄像头跟随我们的玩家很容易。摄像头没有任何抖动或突然移动，因为玩家的飞船不是那样移动的。如果我们要使用更高级的功能，比如吸引器和前置焦点，我们需要计算摄像头的期望位置，然后平稳过渡到该位置。为了支持这一点，我们需要在我们的`Camera`类中添加一个`m_DesiredPosition`属性。以下是我们必须添加的新行：
- en: '[PRE58]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is what the `Camera` class in our `games.hpp` file will look like after
    we add it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在添加了期望位置属性后`games.hpp`文件中的`Camera`类的样子：
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Changes to camera.cpp
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对camera.cpp的更改
- en: 'Now that we have added a desired position attribute to the class definition,
    we need to change our `camera.cpp` file. We need to modify the constructor to
    set the position of the camera to the position of the player''s ship. Here are
    the lines we will need to add to our constructor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在类定义中添加了期望位置属性，我们需要更改我们的`camera.cpp`文件。我们需要修改构造函数，将摄像头的位置设置为玩家飞船的位置。以下是我们需要添加到构造函数的行：
- en: '[PRE60]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following is the constructor after we have added those lines:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加了这些行之后，构造函数如下：
- en: '[PRE61]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our `Camera::Move` function will be entirely different. You might as well remove
    all of the lines of code that are in the current version of `Camera::Move`, because
    none of them are useful anymore. Our new desired position attribute will be set
    at the beginning of the `Move` function, the way that the position was set previously.
    To do this, add the following lines to the empty version of `Camera::Move` that
    you created by deleting everything from that function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Camera::Move`函数将完全不同。你可能要删除当前版本的`Camera::Move`中的所有代码行，因为它们都不再有用。我们的新期望位置属性将在`Move`函数的开头设置，就像之前设置位置一样。为此，请在您通过删除该函数中的所有内容创建的空版本的`Camera::Move`中添加以下行：
- en: '[PRE62]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the player is not alive, we will want our camera to settle down on this
    position. After the player is dead, we will not want any attractors to affect
    the position of the camera. Moving the player camera too much after the player
    dies looks a little strange, so add the following lines of code that check whether
    the player''s ship is active and, if not, moves the position of the camera toward
    the desired position and, then returns from the `Move` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家死亡，我们希望我们的摄像头停留在这个位置。玩家死亡后，我们不希望任何吸引器影响摄像头的位置。在玩家死亡后过度移动玩家摄像头看起来有点奇怪，因此添加以下代码行，检查玩家飞船是否活跃，如果不活跃，则将摄像头的位置移向期望位置，然后从`Move`函数返回：
- en: '[PRE63]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are going to make all of the active projectiles in our game attractors.
    If an enemy is shooting at us, it is a threat to our ship and should therefore
    draw the camera''s attention. If we shoot projectiles, that also indicates the
    direction where we are focused. We are going to use a `for` loop to loop over
    all of the projectiles in our game, and, if that projectile is active, we will
    use its position to shift the desired position of our camera. Here is the code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使游戏中的所有活动抛射物成为吸引器。如果敌人向我们射击，它对我们的飞船构成威胁，因此应该吸引摄像头的注意。如果我们射出抛射物，这也表明了我们的关注方向。我们将使用`for`循环来遍历游戏中的所有抛射物，如果该抛射物是活动的，我们将使用它的位置来移动摄像头的期望位置。以下是代码：
- en: '[PRE64]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After using our attractors to shift the desired position of the camera, we
    will modify the `m_DesiredPosition` variable based on the velocity of the player''s
    ship with the following line of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用吸引器来移动摄像头的期望位置后，我们将根据玩家飞船的速度修改`m_DesiredPosition`变量，使用以下代码行：
- en: '[PRE65]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Because our level wraps around, and if you exit from one side of the level
    you reappear on the opposite side, we will need to adjust the desired position
    of our camera to account for this. Without the following lines of code, the camera
    makes a sudden jarring transition when the player moves outside the level bounds
    on one side and reappears on the other:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的关卡是环绕的，如果您从关卡的一侧退出，您会重新出现在另一侧，我们需要调整摄像头的期望位置以适应这一点。如果没有以下代码行，当玩家移出关卡边界并出现在另一侧时，摄像头会突然发生剧烈的转变：
- en: '[PRE66]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we will add a few lines of code to smoothly transition the camera''s
    current position to the desired position. We use `delta_time` to make this transition
    take about a second. Setting our camera position directly instead of using the
    desired position and transitioning results in jerky movements when new attractors
    enter the game. Here is the transition code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加几行代码，使摄像头的当前位置平稳过渡到期望的位置。我们使用`delta_time`使这个过渡大约需要一秒钟。直接设置摄像头位置而不使用期望位置和过渡会导致新吸引器进入游戏时出现抖动。以下是过渡代码：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have seen all of the lines of our `Move` function separately, let''s
    take a look at the completed new version of the function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分别看到了`Move`函数的所有行，让我们来看一下函数的完成新版本：
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compiling and playing with the advanced camera
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译并玩弄高级摄像头
- en: 'When you have built this version, you will notice that the camera moves ahead
    in the direction your ship is moving. If you start shooting, it will move even
    further ahead. When the enemy spaceship approaches, and it shoots at you, the
    camera should also drift in the direction of those projectiles. As before, you
    can compile and test the code by entering the following line on the Windows or
    Linux command prompt:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建了这个版本后，您会注意到摄像头会朝着您的飞船移动的方向前进。如果您开始射击，它会进一步向前移动。当敌方飞船靠近并向您射击时，摄像头也应该朝着这些抛射物的方向漂移。与以前一样，您可以通过在Windows或Linux命令提示符中输入以下行来编译和测试代码：
- en: '[PRE69]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that we have a compiled version of our app, we should run it. The new version
    should look something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们应用程序的编译版本，我们应该运行它。新版本应该看起来像这样：
- en: '![](img/4e7f8642-ae56-40d6-ad9d-4c43bdb3f11c.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e7f8642-ae56-40d6-ad9d-4c43bdb3f11c.png)'
- en: 'Figure 11.1: New camera version with lines added to divide the screen'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：添加了分割屏幕的新摄像头版本
- en: As you can see, the camera is not centering the player's spaceship. The focus
    of the camera is primarily projected in the direction of the player ship's velocity,
    dragged slightly to the right and up because of the enemy ship and the projectile.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，摄像头并没有将玩家的飞船置于中心。摄像头的焦点主要是根据玩家飞船的速度投影在前方，由于敌方飞船和抛射物的原因稍微向右上方拖动。
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要一个Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器上的浏览器打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We began this chapter by learning about the history of cameras in video games.
    The first camera we discussed is the simplest type of camera, sometimes called
    a locked-on camera. That is the kind of camera that tracks the location of the
    player exactly. After that, we learned about alternatives to a locked-on camera
    in 2D space, including cameras that lead the player. We talked about projected
    focus cameras, and how they predict the movement of the player and project the
    position of the camera forward based on the direction in which the player is moving.
    We then discussed camera attractors, and how they can draw the focus of the camera
    toward objects of interest. After discussing the types of cameras, we created
    a camera object and designed it to implement projected focus and camera attractors.
    We implemented a render manager and modified all of our game objects to render
    through the `RenderManager` class. We then created a `locator` object to help
    us find the enemy spaceship when it no longer appears on the canvas.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始本章是通过了解视频游戏中摄像头的历史。我们讨论的第一个摄像头是最简单的摄像头类型，有时被称为锁定摄像头。这是一种精确跟踪玩家位置的摄像头。之后，我们了解了2D空间中锁定摄像头的替代方案，包括引导玩家的摄像头。我们谈到了投影焦点摄像头，以及它们如何预测玩家的移动并根据玩家移动的方向向前投影摄像头的位置。然后我们讨论了摄像头吸引器，以及它们如何吸引摄像头的焦点到感兴趣的对象。在讨论了摄像头类型之后，我们创建了一个摄像头对象，并设计它来实现投影焦点和摄像头吸引器。我们实现了一个渲染管理器，并修改了所有的游戏对象，使其通过`RenderManager`类进行渲染。然后我们创建了一个`locator`对象，以帮助我们在画布上找到敌方飞船。
- en: In the next chapter, we will learn how to add sound effects to our game.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为我们的游戏添加音效。
