["```cpp\n#include <thread> \n\nvoid worker() { \n   // Business logic. \n} \n\nint main () { \n   std::thread t(worker);\n   return 0; \n} \n\n```", "```cpp\n#include <thread> \n\nvoid worker() { \n   // Business logic. \n} \n\nint main () { \n   std::thread t(worker); \n   t.join(); \n   return 0; \n} \n\n```", "```cpp\n#include <thread> \n#include <string> \n\nvoid worker(int n, std::string t) { \n   // Business logic. \n} \n\nint main () { \n   std::string s = \"Test\"; \n   int i = 1; \n   std::thread t(worker, i, s); \n   t.join(); \n   return 0; \n} \n\n```", "```cpp\n#include <thread> \n#include <string> \n#include <utility> \n\nvoid worker(int n, string t) { \n   // Business logic. \n} \n\nint main () { \n   std::string s = \"Test\"; \n   std::thread t0(worker, 1, s); \n   std::thread t1(std::move(t0)); \n   t1.join(); \n   return 0; \n} \n\n```", "```cpp\n#include <iostream>\n #include <thread>\n #include <chrono>\n #include <mutex>\n\n std::mutex display_mutex;\n\n void worker() {\n     std::thread::id this_id = std::this_thread::get_id();\n\n     display_mutex.lock();\n     std::cout << \"thread \" << this_id << \" sleeping...\\n\";\n     display_mutex.unlock();\n\n     std::this_thread::sleep_for(std::chrono::seconds(1));\n }\n\n int main() {\n    std::thread t1(worker);\n    std::thread::id t1_id = t1.get_id();\n\n    std::thread t2(worker);\n    std::thread::id t2_id = t2.get_id();\n\n    display_mutex.lock();\n    std::cout << \"t1's id: \" << t1_id << \"\\n\";\n    std::cout << \"t2's id: \" << t2_id << \"\\n\";\n    display_mutex.unlock();\n\n    t1.join();\n    t2.join();\n\n    return 0;\n } \n\n```", "```cpp\nt1's id: 2\nt2's id: 3\nthread 2 sleeping...\nthread 3 sleeping...\n\n```", "```cpp\n#include <iostream> \n#include <chrono> \n#include <thread> \n        using namespace std::chrono_literals;\n\n        typedef std::chrono::time_point<std::chrono::high_resolution_clock> timepoint; \nint main() { \n         std::cout << \"Starting sleep.\\n\"; \n\n         timepoint start = std::chrono::high_resolution_clock::now(); \n\n         std::this_thread::sleep_for(2s); \n\n         timepoint end = std::chrono::high_resolution_clock::now(); \n         std::chrono::duration<double, std::milli> elapsed = end - \n         start; \n         std::cout << \"Slept for: \" << elapsed.count() << \" ms\\n\"; \n} \n\n```", "```cpp\n#include <iostream> \n#include <thread> \n#include <chrono> \n\nvoid worker() { \n   std::this_thread::sleep_for(std::chrono::seconds(1)); \n} \n\nint main() { \n         std::thread t1(worker); \n         std::thread t2(worker); \n\n         std::cout << \"thread 1 id: \" << t1.get_id() << \"\\n\"; \n         std::cout << \"thread 2 id: \" << t2.get_id() << \"\\n\"; \n\n         std::swap(t1, t2); \n\n         std::cout << \"Swapping threads...\" << \"\\n\"; \n\n         std::cout << \"thread 1 id: \" << t1.get_id() << \"\\n\"; \n         std::cout << \"thread 2 id: \" << t2.get_id() << \"\\n\"; \n\n         t1.swap(t2); \n\n         std::cout << \"Swapping threads...\" << \"\\n\"; \n\n         std::cout << \"thread 1 id: \" << t1.get_id() << \"\\n\"; \n         std::cout << \"thread 2 id: \" << t2.get_id() << \"\\n\"; \n\n         t1.join(); \n         t2.join(); \n} \n\n```", "```cpp\nthread 1 id: 2\nthread 2 id: 3\nSwapping threads...\nthread 1 id: 3\nthread 2 id: 2\nSwapping threads...\nthread 1 id: 2\nthread 2 id: 3\n\n```", "```cpp\n#include <iostream> \n#include <thread> \n\nvoid worker(int i) { \n         std::cout << \"Outputting this from thread number: \" << i << \"\\n\"; \n} \n\nint main() { \n         std::thread t1(worker, 1);\n         std::thread t2(worker, 2); \n\n         t1.join(); \n   t2.join(); \n\n   return 0; \n} \n\n```", "```cpp\n#include <iostream> \n#include <thread> \n#include <mutex> \n\nstd::mutex globalMutex; \n\nvoid worker(int i) { \n   globalMutex.lock(); \n         std::cout << \"Outputting this from thread number: \" << i << \"\\n\"; \n   globalMutex.unlock(); \n} \n\nint main() { \n         std::thread t1(worker, 1);\n         std::thread t2(worker, 2); \n\n         t1.join(); \n   t2.join(); \n\n   return 0; \n} \n\n```", "```cpp\n#include <chrono> \n#include <mutex> \n#include <thread> \n#include <iostream> \n\nstd::chrono::milliseconds interval(50); \n\nstd::mutex mutex; \nint shared_counter = 0;\nint exclusive_counter = 0; \n\nvoid worker0() { \n   std::this_thread::sleep_for(interval);\n\n         while (true) { \n               if (mutex.try_lock()) { \n                     std::cout << \"Shared (\" << job_shared << \")\\n\"; \n                     mutex.unlock(); \n                     return; \n               } \n         else { \n                     ++exclusive_counter; \n                           std::cout << \"Exclusive (\" << exclusive_counter << \")\\n\"; \n                           std::this_thread::sleep_for(interval); \n               } \n         } \n} \n\nvoid worker1() { \n   mutex.lock(); \n         std::this_thread::sleep_for(10 * interval); \n         ++shared_counter; \n         mutex.unlock(); \n} \n\nint main() { \n         std::thread t1(worker0); \n         std::thread t2(worker1); \n\n         t1.join(); \n         t2.join(); \n}\n\n```", "```cpp\nExclusive (1)\nExclusive (2)\nExclusive (3)\nShared (1)\nExclusive (4)\n\n```", "```cpp\n#include <thread> \n#include <mutex> \n#include <iostream> \n\nint counter = 0; \nstd::mutex counter_mutex; \n\nvoid worker() { \n         std::lock_guard<std::mutex> lock(counter_mutex); \n   if (counter == 1) { counter += 10; } \n   else if (counter >= 10) { counter += 15; } \n   else if (counter >= 50) { return; } \n         else { ++counter; } \n\n   std::cout << std::this_thread::get_id() << \": \" << counter << '\\n'; \n} \n\nint main() { \n    std::cout << __func__ << \": \" << counter << '\\n'; \n\n    std::thread t1(worker); \n    std::thread t2(worker); \n\n    t1.join(); \n    t2.join(); \n\n    std::cout << __func__ << \": \" << counter << '\\n'; \n} \n\n```", "```cpp\nstd::mutex m1, m2, m3; \nstd::unique_lock<std::mutex> lock1(m1, std::defer_lock); \nstd::unique_lock<std::mutex> lock2(m2, std::try_lock); \nstd::unique_lock<std::mutex> lock3(m3, std::adopt_lock); \n\n```", "```cpp\n#include <mutex>\nstd::mutex my_mutex\nint count = 0;\nint function() {\n         std::unique_lock<mutex> lock(my_mutex);\n   count++;\n}  \n\n```", "```cpp\n #include \"abstract_request.h\"\n\n #include <condition_variable>\n #include <mutex> \n\nusing namespace std;\n\n class Worker {\n    condition_variable cv;\n    mutex mtx;\n    unique_lock<mutex> ulock;\n    AbstractRequest* request;\n    bool running;\n    bool ready;\n    public:\n    Worker() { running = true; ready = false; ulock = unique_lock<mutex>(mtx); }\n    void run();\n    void stop() { running = false; }\n    void setRequest(AbstractRequest* request) { this->request = request; ready = true; }\n    void getCondition(condition_variable* &cv);\n }; \n\n```", "```cpp\n#include <chrono>\nusing namespace std;\nvoid Worker::run() {\n    while (running) {\n        if (ready) {\n            ready = false;\n            request->process();\n            request->finish();\n        }\n        if (Dispatcher::addWorker(this)) {\n            while (!ready && running) {\n                if (cv.wait_for(ulock, chrono::seconds(1)) == \n                cv_status::timeout) {\n                    // We timed out, but we keep waiting unless the \n                    worker is\n                    // stopped by the dispatcher.\n                }\n            }\n        }\n    }\n} \n\n```", "```cpp\nvoid Dispatcher::addRequest(AbstractRequest* request) {\n    workersMutex.lock();\n    if (!workers.empty()) {\n          Worker* worker = workers.front();\n          worker->setRequest(request);\n          condition_variable* cv;\n          worker->getCondition(cv);\n          cv->notify_one();\n          workers.pop();\n          workersMutex.unlock();\n    }\n    else {\n          workersMutex.unlock();\n          requestsMutex.lock();\n          requests.push(request);\n          requestsMutex.unlock();\n    }\n          } \n\n```", "```cpp\nvoid Worker::getCondition(condition_variable* &cv) {\n    cv = &(this)->cv;\n } \n\n```", "```cpp\n#include <mutex> \n#include <thread> \n#include <condition_variable> \nusing namespace std; \n\nmutex m; \ncondition_variable cv;\nbool ready = false; \nThreadLocal result;\n\nvoid worker() { \n   unique_lock<mutex> ulock(m); \n   result = thread_local_method(); \n         ready = true; \n         std::notify_all_at_thread_exit(cv, std::move(ulock)); \n} \n\nint main() { \n         thread t(worker); \n         t.detach(); \n\n         // Do work here. \n\n         unique_lock<std::mutex> ulock(m); \n         while(!ready) { \n               cv.wait(ulock); \n         } \n\n         // Process result \n} \n\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <chrono>\n\nbool is_prime (int x) {\n  for (int i = 2; i < x; ++i) if (x%i==0) return false;\n  return true;\n}\n\nint main () {\n  std::future<bool> fut = std::async (is_prime, 444444443);\n  std::cout << \"Checking, please wait\";\n  std::chrono::milliseconds span(100);\n  while (fut.wait_for(span) == std::future_status::timeout) {               std::cout << '.' << std::flush;\n   }\n\n  bool x = fut.get();\n  std::cout << \"\\n444444443 \" << (x?\"is\":\"is not\") << \" prime.\\n\";\n  return 0;\n}\n\n```", "```cpp\n#include <iostream> \n#include <functional>\n#include <thread> \n#include <future> \n\nvoid print_int (std::future<int>& fut) {\n  int x = fut.get();\n  std::cout << \"value: \" << x << '\\n';\n}\n\nint main () {\n  std::promise<int> prom;\n  std::future<int> fut = prom.get_future();\n  std::thread th1 (print_int, std::ref(fut));\n  prom.set_value (10);                            \n  th1.join();\n  return 0;\n\n```", "```cpp\nstd::promise<void> promise1; \nstd::shared_future<void> sFuture(promise1.get_future()); \n\n```", "```cpp\n#include <iostream> \n#include <future> \n#include <chrono>\n#include <thread>\n\nusing namespace std; \n\nint countdown (int from, int to) { \n   for (int i = from; i != to; --i) { \n         cout << i << '\\n'; \n         this_thread::sleep_for(chrono::seconds(1)); \n   } \n\n   cout << \"Finished countdown.\\n\"; \n   return from - to; \n} \n\nint main () { \n   packaged_task<int(int, int)> task(countdown);\n   future<int> result = task.get_future();\n   thread t (std::move(task), 10, 0);\n\n   //  Other logic. \n\n   int value = result.get(); \n\n   cout << \"The countdown lasted for \" << value << \" seconds.\\n\"; \n\n   t.join(); \n   return 0; \n} \n\n```", "```cpp\n#include <iostream>\n#include <future>\n\nusing namespace std; \n\nbool is_prime (int x) { \n   cout << \"Calculating prime...\\n\"; \n   for (int i = 2; i < x; ++i) { \n         if (x % i == 0) { \n               return false; \n         } \n   } \n\n   return true; \n} \n\nint main () { \n   future<bool> pFuture = std::async (is_prime, 343321); \n\n   cout << \"Checking whether 343321 is a prime number.\\n\"; \n\n   // Wait for future object to be ready. \n\n   bool result = pFuture.get(); \n   if (result) {\n         cout << \"Prime found.\\n\"; \n   } \n   else { \n         cout << \"No prime found.\\n\"; \n   } \n\n   return 0; \n} \n\n```", "```cpp\n* launch::async \n* launch::deferred \n\n```"]