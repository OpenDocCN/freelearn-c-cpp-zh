- en: Configure-time and Build-time Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置时间和构建时间操作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using platform-independent file operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台无关的文件操作
- en: Running a custom command at configure time
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置时间运行自定义命令
- en: 'Running a custom command at build time: I. Using `add_custom_command`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时间运行自定义命令：I. 使用 `add_custom_command`
- en: 'Running a custom command at build time: II. Using `add_custom_target`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时间运行自定义命令：II. 使用 `add_custom_target`
- en: Running custom commands for specific targets at build time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时间对特定目标运行自定义命令
- en: Probing compilation and linking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测编译和链接
- en: Probing compiler flags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测编译器标志
- en: Probing execution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测执行
- en: Fine-tuning configuration and compilation with generator expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表达式微调配置和编译
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'In this chapter, we will learn how to perform custom operations at configure
    time and build time.  Let us briefly recall the notion of *times* as related to
    the workflow of a project managed by CMake:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在配置时间和构建时间执行自定义操作。让我们简要回顾一下与由CMake管理的项目工作流程相关的*时间*概念：
- en: '**CMake time** or **configure time**: This is when CMake is running and processing
    the `CMakeLists.txt` files in your project.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CMake时间**或**配置时间**：这是当CMake正在运行并处理项目中的`CMakeLists.txt`文件时。'
- en: '**Generation time**: This is when the files for the native build tool, such
    as Makefiles or Visual Studio project files, are generated.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成时间**：这是当生成用于本地构建工具的文件，如Makefiles或Visual Studio项目文件时。'
- en: '**Build time**: This is when the native build tools are invoked on the platform-
    and tool-native build scripts previously generated by CMake. At this point, the
    compiler will be invoked and the targets (executables and libraries) will be built
    in a specific build directory.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建时间**：这是当平台和工具本地的构建工具被调用时，在之前由CMake生成的平台和工具本地的构建脚本上。此时，编译器将被调用，目标（可执行文件和库）将在特定的构建目录中被构建。'
- en: '**CTest time** or **test time**: When we run the test suite to check whether
    the targets perform as intended.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CTest时间**或**测试时间**：当我们运行测试套件以检查目标是否按预期执行时。'
- en: '**CDash time** or **report time:** When the results of testing the project
    are uploaded to a dashboard to be shared with other developers.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CDash时间**或**报告时间**：当测试项目的结果上传到一个仪表板以与其他开发者共享时。'
- en: '**Install-time**: When the targets, source files, executables, and libraries
    are installed from the build directory to an install location.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装时间**：当从构建目录到安装位置安装目标、源文件、可执行文件和库时。'
- en: '**CPack time** or **packaging time**: When we package our project for distribution,
    either as source code or binary.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CPack时间**或**打包时间**：当我们打包我们的项目以供分发，无论是作为源代码还是二进制。'
- en: '**Package install time**: When the newly minted package is installed system-wide.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**包安装时间**：当新制作的包被系统全局安装时。'
- en: 'The complete workflow and the corresponding times are depicted in the following
    figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的流程及其对应的时间在下图中描述：
- en: '![](img/6d8d214c-69fb-43b4-8769-20a5770453bb.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8d214c-69fb-43b4-8769-20a5770453bb.jpg)'
- en: 'This chapter is concerned with customizing the behavior at configure time and
    build time. We will learn how to use these commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关注于在配置时间和构建时间自定义行为。我们将学习如何使用这些命令：
- en: '`execute_process` to execute arbitrary processes from within CMake and retrieve
    their outputs'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute_process` 以从CMake内部执行任意进程并检索其输出'
- en: '`add_custom_target` to create targets that will execute custom commands'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_custom_target` 以创建将执行自定义命令的目标'
- en: '`add_custom_command` to specify commands that have to be executed to generate
    files or at specific build events of other targets'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_custom_command` 以指定必须执行以生成文件或在其他目标的特定构建事件上的命令'
- en: Using platform-independent file operations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台无关的文件操作
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01)
    获取，并包含一个C++示例。该食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: When building some projects, we may need to interact with the host platform
    filesystem. The interaction with the files might be simply checking whether a
    file exists, creating a new file to store temporary information, creating or extracting
    an archive, and so forth. With CMake, we are not only able to generate the build
    system on different platforms, we are also able to perform these operations without
    complicated logic to abstract away the different operating systems. This recipe
    will show how to extract a previously downloaded archive in a portable way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建某些项目时，我们可能需要与主机平台文件系统进行交互。与文件的交互可能只是检查文件是否存在，创建一个新文件来存储临时信息，创建或提取存档等等。使用CMake，我们不仅能够在不同的平台上生成构建系统，还能够执行这些操作，而不需要复杂的逻辑来抽象不同的操作系统。本节将展示如何以可移植的方式提取先前下载的存档。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will show how to extract the archive bundling the Eigen library and use the
    extracted source files to compile our project. In this recipe, we will reuse the
    linear algebra example `linear-algebra.cpp` from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, Recipe 7, *Detecting the Eigen library*.
    The recipe also assumes that the archive containing the source code for Eigen
    has been downloaded in the same directory as the project itself.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何提取包含Eigen库的存档，并使用提取的源文件来编译我们的项目。在本节中，我们将重用来自[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第7节，*检测Eigen库*的线性代数示例`linear-algebra.cpp`。本节还假设包含Eigen源代码的存档已下载在与项目本身相同的目录中。
- en: How to do it
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'The project needs to unpack the Eigen archive and set the include directories
    for the target accordingly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 项目需要解包Eigen存档，并相应地设置目标的包含目录：
- en: 'Let us first declare a C++11 project:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先声明一个C++11项目：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We add a custom target to our build system. The custom target will extract
    the archive inside the build directory:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向构建系统添加一个自定义目标。该自定义目标将在构建目录内提取存档：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We add an executable target for our source file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为源文件添加一个可执行目标：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the compilation of our source file depends on the Eigen header files,
    we need to explicitly specify the dependency of the executable target on the custom
    target:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的源文件的编译依赖于Eigen头文件，我们需要明确指定可执行目标对自定义目标的依赖：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we can specify which include directories we need to compile our source
    file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以指定我们需要编译源文件的包含目录：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Let us take a closer look at the invocation of `add_custom_target`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`add_custom_target`的调用：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are introducing a target called `unpack-eigen` into our build system. The
    target will always be executed since we passed the `ALL` argument. The `COMMAND`
    argument lets you specify what commands to execute. In this example, we wish to
    extract the archive and rename the extracted directory to `eigen-3.3.4`. This
    is achieved with these two commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向构建系统引入一个名为`unpack-eigen`的目标。由于我们传递了`ALL`参数，该目标将始终被执行。`COMMAND`参数允许您指定要执行的命令。在本例中，我们希望提取存档并将提取的目录重命名为`eigen-3.3.4`。这是通过这两个命令实现的：
- en: '`${CMAKE_COMMAND} -E tar xzf ${CMAKE_CURRENT_SOURCE_DIR}/eigen-eigen-5a0156e40feb.tar.gz`'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`${CMAKE_COMMAND} -E tar xzf ${CMAKE_CURRENT_SOURCE_DIR}/eigen-eigen-5a0156e40feb.tar.gz`'
- en: '`${CMAKE_COMMAND} -E rename eigen-eigen-5a0156e40feb eigen-3.3.4`'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`${CMAKE_COMMAND} -E rename eigen-eigen-5a0156e40feb eigen-3.3.4`'
- en: 'Notice how we are calling the CMake command itself, with the `-E` flag, to
    execute the actual work. For many common operations, CMake implements an interface
    common to all the operating systems it runs on. This allows the build system generation
    to be largely independent of the specific platform. The next argument in the `add_custom_target`
    command is the working directory, which in our example corresponds to the build
    directory: `CMAKE_CURRENT_BINARY_DIR`. The last argument, `COMMENT`,  is used
    to specify what message CMake should print out when executing the custom target.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何调用CMake命令本身，使用`-E`标志来执行实际的工作。对于许多常见操作，CMake实现了一个在它运行的所有操作系统上都通用的接口。这使得构建系统的生成在很大程度上独立于特定的平台。`add_custom_target`命令中的下一个参数是工作目录，在我们的例子中对应于构建目录：`CMAKE_CURRENT_BINARY_DIR`。最后一个参数`COMMENT`用于指定在执行自定义目标时CMake应该打印出什么消息。
- en: There is more
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: The command `add_custom_target` can be used whenever a series of custom commands
    with no output has to be executed during the build. As we have shown in this recipe,
    the custom target can be specified as a dependency of other targets in the project.
    Moreover, custom targets can also depend on other targets, thus offering the possibility
    to set up the order of execution in our build.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_target` 命令可用于在构建过程中执行一系列没有输出的自定义命令。正如我们在本食谱中所展示的，自定义目标可以被指定为项目中其他目标的依赖项。此外，自定义目标也可以依赖于其他目标，从而提供了在我们的构建中设置执行顺序的可能性。'
- en: 'Using the `-E` flag to CMake, we can run many common operations in an operating
    system-agnostic fashion. The full list on the specific operating system can be
    obtained by running `cmake -E` or `cmake -E help`. For example, this is the summary
    of commands on a Linux system:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CMake 的 `-E` 标志，我们可以以操作系统无关的方式运行许多常见操作。在特定操作系统上可以运行的完整命令列表可以通过运行 `cmake -E`
    或 `cmake -E help` 获得。例如，这是一个在 Linux 系统上的命令摘要：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running a custom command at configure time
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置时运行自定义命令
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在 [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02)
    获取。该食谱适用于 CMake 版本 3.5（及以上），并在 GNU/Linux、macOS 和 Windows 上进行了测试。
- en: Running CMake generates the build system, thus specifying what commands the
    native build tools will have to execute to get your project built, and in which
    order. We have already seen how CMake runs many subtasks at configure time in
    order to find out the working compiler and necessary dependencies. In this recipe,
    we will discuss how to run custom commands at configure time by using the `execute_process`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 CMake 会生成构建系统，从而指定本地构建工具必须执行哪些命令来构建您的项目，以及以什么顺序执行。我们已经看到 CMake 在配置时运行许多子任务，以找出工作编译器和必要的依赖项。在本食谱中，我们将讨论如何在配置时通过使用
    `execute_process` 命令来运行自定义命令。
- en: How to do it
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We have already shown the use of `execute_process` when trying to find the
    NumPy Python module in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, Recipe 3, *Detecting Python modules
    and packages*. In this example, we will use the `execute_process` command to find
    out whether a particular Python module (in this case, Python CFFI) is present,
    and if it is, we will discover its version:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，食谱 3，*检测 Python
    模块和包*中，我们已经展示了在尝试查找 NumPy Python 模块时使用 `execute_process` 的情况。在这个例子中，我们将使用 `execute_process`
    命令来检查特定的 Python 模块（在这种情况下，Python CFFI）是否存在，如果存在，我们将发现其版本：
- en: 'For this simple example, we will not require any language support:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个简单的示例，我们将不需要任何语言支持：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will require the Python interpreter to execute a short Python snippet, and
    for this we discover the interpreter using `find_package`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要求 Python 解释器执行一个简短的 Python 代码片段，为此我们使用 `find_package` 来发现解释器：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then invoke `execute_process` to run a short Python snippet; we will discuss
    this command in more detail in the next section:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用 `execute_process` 来运行一个简短的 Python 代码片段；我们将在下一节中更详细地讨论这个命令：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we print the result:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印结果：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An example configuration yields the following (assuming the Python CFFI package
    is installed in the corresponding Python environment):'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个示例配置产生以下结果（假设 Python CFFI 包已安装在相应的 Python 环境中）：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `execute_process` command will spawn one or more child processes from within
    the currently executing CMake process, thus providing a powerful and convenient
    way of running arbitrary commands when configuring your project. It is possible
    to execute more than one command within one invocation of `execute_process`. Notice,
    however, that the output of each command will be piped into the next. The command
    accepts a number of arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_process` 命令会在当前执行的 CMake 进程中产生一个或多个子进程，从而提供了一种强大且方便的方式来在配置项目时运行任意命令。在一次
    `execute_process` 调用中可以执行多个命令。然而，请注意，每个命令的输出将被管道传输到下一个命令。该命令接受多个参数：'
- en: '`WORKING_DIRECTORY` lets you specify in which directory the commands should
    be executed.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKING_DIRECTORY` 允许您指定在哪个目录中执行命令。'
- en: '`RESULT_VARIABLE` will contain the result of running the processes. This is
    either an integer to signal successful execution or a string with the error condition
    incurred.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESULT_VARIABLE`将包含运行进程的结果。这要么是一个整数，表示成功执行，要么是一个包含错误条件的字符串。'
- en: '`OUTPUT_VARIABLE` and `ERROR_VARIABLE` will contain the standard output and
    standard error of the executed commands. Keep in mind that since the outputs of
    commands are piped, only the standard output of the last command will be saved
    into `OUTPUT_VARIABLE`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OUTPUT_VARIABLE`和`ERROR_VARIABLE`将包含执行命令的标准输出和标准错误。请记住，由于命令的输出被输入，只有最后一个命令的标准输出将被保存到`OUTPUT_VARIABLE`中。'
- en: '`INPUT_FILE`, `OUTPUT_FILE`, and `ERROR_FILE` specify filenames for the standard
    input and standard output of the last command, and the standard error for all
    commands.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INPUT_FILE`、`OUTPUT_FILE`和`ERROR_FILE`指定最后一个命令的标准输入和标准输出文件名，以及所有命令的标准错误文件名。'
- en: By setting `OUTPUT_QUIET` and `ERROR_QUIET`, CMake will silently ignore the
    standard output and the standard error, respectively.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`OUTPUT_QUIET`和`ERROR_QUIET`，CMake将分别忽略标准输出和标准错误。
- en: Any trailing whitespace in the standard output and standard error for the running
    commands can be stripped by setting `OUTPUT_STRIP_TRAILING_WHITESPACE` and `ERROR_STRIP_TRAILING_WHITESPACE`,
    respectively.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`OUTPUT_STRIP_TRAILING_WHITESPACE`和`ERROR_STRIP_TRAILING_WHITESPACE`，可以分别去除标准输出和标准错误中运行命令的尾随空格。
- en: 'With these explanations, we can return to our example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些解释，我们可以回到我们的示例：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command checks the output of `python -c "import cffi; print(cffi.__version__)"`.
    If the module is not found, `_stderr` will contain `ModuleNotFoundError`, which
    we check for in the if-statement, and in this case we would print `Module cffi
    not found`. If the import is successful, the Python code will print the version
    of the module, which is piped into `_stdout` so that we can print the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令检查`python -c "import cffi; print(cffi.__version__)"`的输出。如果找不到模块，`_stderr`将包含`ModuleNotFoundError`，我们在if语句中对此进行检查，在这种情况下，我们会打印`找不到cffi模块`。如果导入成功，Python代码将打印模块版本，该版本被输入到`_stdout`，以便我们可以打印以下内容：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is more
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: In this example, we have only printed the result, but in a real project we could
    warn, abort the configuration, or set variables that could be queried to toggle
    certain configuration options.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们仅打印了结果，但在实际项目中，我们可以警告、中止配置或设置可以查询以切换某些配置选项的变量。
- en: It would be an interesting exercise to extend the code example to multiple Python
    modules, such as Cython, avoiding code repetition. One option could be to loop
    over the module names using `foreach`; another approach could be to abstract the
    code into a function or macro. We will discuss such abstractions in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml),
    *Structuring Projects*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码示例扩展到多个Python模块，如Cython，避免代码重复，这将是一个有趣的练习。一种选择可能是使用`foreach`循环遍历模块名称；另一种方法可能是将代码抽象为函数或宏。我们将在[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构化*中讨论此类抽象。
- en: In [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, we will use Python CFFI and Cython, and the present recipe can serve
    as a useful and reusable code snippet to detect whether these packages are present.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*中，我们将使用Python CFFI和Cython，而本节内容可以作为一个有用且可复用的代码片段，用于检测这些包是否存在。
- en: 'Running a custom command at build time: I. Using add_custom_command'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建时运行自定义命令：I. 使用`add_custom_command`
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03)找到，并包含一个C++示例。本节内容适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'Build targets for your projects might depend on the results of commands that
    can only be executed at build time, after the build system generation has been
    completed. CMake offers three options to execute custom commands at build time:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 项目构建目标可能依赖于只能在构建时执行的命令的结果，即在构建系统生成完成后。CMake提供了三种选项来在构建时执行自定义命令：
- en: Using `add_custom_command` to generate output files to be compiled within a
    target.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`add_custom_command`生成要在目标内编译的输出文件。
- en: Using `add_custom_target` to execute commands with no output.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add_custom_target` 执行没有输出的命令。
- en: Using `add_custom_command` to execute commands with no output, before or after
    a target has been built.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add_custom_command` 执行没有输出的命令，在目标构建之前或之后。
- en: These three options enforce specific semantics and are not interchangeable.
    The next three recipes will clarify their use cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个选项强制特定的语义，并且不可互换。接下来的三个配方将阐明它们的使用案例。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will reuse the C++ example from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*, to illustrate the use of the first variant of `add_custom_command`.
    In that code sample, we probed for existing BLAS and LAPACK libraries and compiled
    a tiny C++ wrapper library to call the Fortran implementation of the linear algebra
    routines we needed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用 [第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第4个配方，*检测
    BLAS 和 LAPACK 数学库* 中的 C++ 示例，以说明 `add_custom_command` 第一种变体的使用。在该代码示例中，我们探测现有的
    BLAS 和 LAPACK 库，并编译了一个微小的 C++ 包装器库，以调用我们需要的线性代数例程的 Fortran 实现。
- en: We will split the code into two portions. The source file for `linear-algebra.cpp` is
    unchanged compared to [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*, and will include headers from the linear algebra wrappers library
    and link against the compiled library. The sources of the library will, however,
    be packaged into a zipped tar archive shipped alongside the example project. The
    archive will be extracted at build time and the linear algebra wrapper library
    compiled before the executable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码分成两部分。`linear-algebra.cpp` 的源文件与 [第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第4个配方，*检测
    BLAS 和 LAPACK 数学库* 相比没有变化，并将包含线性代数包装器库的头文件并链接到编译库。然而，该库的源文件将被打包成一个与示例项目一起交付的压缩
    tar 存档。该存档将在构建时提取，并在可执行文件之前编译线性代数包装器库。
- en: How to do it
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Our `CMakeLists.txt` will have to contain a custom command to extract the sources
    for the linear algebra wrapper library. Let us look at it in detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CMakeLists.txt` 将不得不包含一个自定义命令来提取线性代数包装器库的源文件。让我们详细看一下：
- en: 'We start with a familiar definition of the minimum CMake version, project name,
    and supported language:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从熟悉的 CMake 版本、项目名称和支持的语言的定义开始：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We pick the C++11 standard, as usual:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们一如既往地选择 C++11 标准：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is then time to look for the BLAS and LAPACK libraries on our system:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是时候在我们的系统上寻找 BLAS 和 LAPACK 库了：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We declare a variable, `wrap_BLAS_LAPACK_sources`, to hold the names of the
    source files contained in the `wrap_BLAS_LAPACK.tar.gz` archive:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个变量 `wrap_BLAS_LAPACK_sources`，用于保存 `wrap_BLAS_LAPACK.tar.gz` 存档中包含的源文件的名称：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We declare the custom command to extract the `wrap_BLAS_LAPACK.tar.gz` archive
    and update the timestamps of the extracted files. Notice that the contents of
    the `wrap_BLAS_LAPACK_sources` variable are the expected outputs of the custom
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明自定义命令以提取 `wrap_BLAS_LAPACK.tar.gz` 存档并更新提取文件的时间戳。请注意，`wrap_BLAS_LAPACK_sources`
    变量的内容是自定义命令的预期输出：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we add a library target whose sources are the freshly extracted files:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个库目标，其源文件是新提取的文件：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `linear-algebra` executable target is added. This executable target
    links against the wrapper library:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加了 `linear-algebra` 可执行目标。此可执行目标链接到包装器库：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this, we can configure, build, and execute the example:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以配置、构建和执行示例：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Let us have a closer look at the invocation of `add_custom_command`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下 `add_custom_command` 的调用：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`add_custom_command` adds rules to targets so that they know how to generate
    the output by executing the commands.  *Any target* declared within the same directory
    of `add_custom_command`, that is, in the same `CMakeLists.txt`, and that uses
    *any file* in the output as its source file, will be given a rule to generate
    those files at build time. Dependencies between targets and custom commands are
    thus automatically handled at build system generation, while the actual generation
    of source files happens at build time.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_command` 向目标添加规则，以便它们知道如何通过执行命令来生成输出。*任何目标* 在 `add_custom_command`
    的同一目录中声明，即在同一个 `CMakeLists.txt` 中，并且使用输出中的 *任何文件* 作为其源文件，将在构建时被赋予生成这些文件的规则。目标和自定义命令之间的依赖关系在构建系统生成时自动处理，而源文件的实际生成发生在构建时。'
- en: In our specific case, the outputs are the sources contained in the zipped tar
    archive. To retrieve and use those files, the archive will have to be extracted
    at build time. This is achieved by using the CMake command itself with the `-E`
    flag, to achieve platform independence. The next command updates the timestamps
    of the extracted files. We do this to make sure we are not dealing with stale
    source files. `WORKING_DIRECTORY` specifies where to execute the commands. In
    our case, this is `CMAKE_CURRENT_BINARY_DIR`, which is the build directory currently
    being processed. The argument to the `DEPENDS` keyword lists dependencies to the
    custom command. In our case, the zipped tar archive is a dependency. The `COMMENT`
    field will be used by CMake to print status messages at build  time. Finally,
    `VERBATIM` tells CMake to generate the right command for the specific generator
    and platform, thus ensuring full platform independence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们特定的情况下，输出是包含在压缩的tar存档中的源文件。为了检索和使用这些文件，必须在构建时解压缩存档。这是通过使用CMake命令本身与`-E`标志来实现的，以实现平台独立性。下一个命令更新提取文件的时间戳。我们这样做是为了确保我们不会处理陈旧的源文件。`WORKING_DIRECTORY`指定执行命令的位置。在我们的例子中，这是`CMAKE_CURRENT_BINARY_DIR`，即当前正在处理的构建目录。`DEPENDS`关键字后面的参数列出了自定义命令的依赖项。在我们的例子中，压缩的tar存档是一个依赖项。`COMMENT`字段将由CMake用于在构建时打印状态消息。最后，`VERBATIM`告诉CMake为特定的生成器和平台生成正确的命令，从而确保完全的平台独立性。
- en: 'Let us also have a closer look at the way the library with the wrappers is
    created:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也仔细看看创建带有包装器的库的方式：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We declare a library target with no sources. This is because we then use `target_sources`
    to populate the sources of the target. This achieves the very important task of
    letting dependents on this target know what include directories and header files
    they need, in order to successfully use the library. The C++ source files are
    `PRIVATE` to the target, and hence only used in building the library. The header
    files are `PUBLIC` because both the target and its dependents will need to use
    them to successfully compile. The include directories are specified using `target_include_directories` with `wrap_BLAS_LAPACK` declared
    as `INTERFACE`, since only dependents on the `math` target will need it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个没有源文件的库目标。这是因为我们随后使用`target_sources`来填充目标的源文件。这实现了非常重要的任务，即让依赖于此目标的其他目标知道它们需要哪些包含目录和头文件，以便成功使用该库。C++源文件对于目标是`PRIVATE`，因此仅用于构建库。头文件是`PUBLIC`，因为目标及其依赖项都需要使用它们来成功编译。使用`target_include_directories`指定包含目录，并将`wrap_BLAS_LAPACK`声明为`INTERFACE`，因为只有`math`目标的依赖项才需要它。
- en: 'This form of the `add_custom_command` has two limitations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_command`的这种形式有两个限制：'
- en: It will only be valid if all of the targets depending on its output are specified
    in the same `CMakeLists.txt`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当所有依赖于其输出的目标都在同一个`CMakeLists.txt`中指定时，它才有效。
- en: Using the same output as `add_custom_command` for different, independent targets
    might re-execute the custom commands rule. This may cause conflicts and should
    be avoided.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不同的独立目标使用相同的输出，`add_custom_command`可能会重新执行自定义命令规则。这可能导致冲突，应予以避免。
- en: The second limitation can be avoided by carefully introducing dependencies with
    `add_dependencies`, but the proper approach to circumvent both would be to use
    the `add_custom_target` command, as we will detail in the next recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个限制可以通过仔细使用`add_dependencies`引入依赖关系来避免，但为了规避这两个问题，正确的方法是使用`add_custom_target`命令，我们将在下一个示例中详细说明。
- en: 'Running a custom command at build time: II. Using add_custom_target'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建时运行自定义命令：II. 使用 add_custom_target
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04)找到，并包含一个C++示例。该示例适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: As we discussed in the previous recipe, `add_custom_command` has some limitations
    that can be circumvented by using `add_custom_target`. This CMake command will
    introduce new targets in the build system. These targets, in turn, execute commands
    that do not return an output, in contrast to `add_custom_command`. The commands `add_custom_target`
    and `add_custom_command` can be combined. With this, the custom target can be
    specified in a directory different than the one where its dependents are, and
    this can be very helpful when designing a modular CMake infrastructure for your
    project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个配方中讨论的，`add_custom_command`有一些局限性，可以通过使用`add_custom_target`来规避。这个CMake命令将在构建系统中引入新的目标。这些目标反过来执行不返回输出的命令，与`add_custom_command`相反。命令`add_custom_target`和`add_custom_command`可以结合使用。这样，自定义目标可以在与其依赖项不同的目录中指定，这在为项目设计模块化CMake基础设施时非常有用。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will reuse the source code sample from the previous recipe.
    We will, however, modify the layout of the sources slightly. In particular, instead
    of storing the zipped tar archive in the top-level directory, we will place it
    inside a subdirectory called `deps`. This subdirectory contains its own `CMakeLists.txt`,
    which will be included by the main `CMakeLists.txt`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将重用前一个配方的源代码示例。然而，我们将稍微修改源文件的布局。特别是，我们不再将压缩的tar存档存储在顶层目录中，而是将其放置在一个名为`deps`的子目录中。这个子目录包含自己的`CMakeLists.txt`，它将被主`CMakeLists.txt`包含。
- en: How to do it
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will start with the main `CMakeLists.txt` and later move to `deps/CMakeLists.txt`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主`CMakeLists.txt`开始，然后转到`deps/CMakeLists.txt`：
- en: 'As before, we declare a C++11 project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，我们声明一个C++11项目：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, we move on to `deps/CMakeLists.txt`. This is achieved with the
    `add_subdirectory` command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们转到`deps/CMakeLists.txt`。这是通过`add_subdirectory`命令实现的：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside `deps/CMakeLists.txt`, we first locate the necessary libraries (BLAS
    and LAPACK):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`deps/CMakeLists.txt`内部，我们首先定位必要的库（BLAS和LAPACK）：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we collect the contents of the tarball archive into a variable, `MATH_SRCS`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将tarball存档的内容收集到一个变量`MATH_SRCS`中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Having listed the sources that are to be extracted, we define a custom target
    and a custom command. This combination extracts the archive in `${CMAKE_CURRENT_BINARY_DIR}`.
    However, here we are in a different scope and refer to `deps/CMakeLists.txt`,
    and therefore the tarball will be extracted into a `deps` subdirectory below the
    main project build directory:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出要提取的源文件后，我们定义一个自定义目标和一个自定义命令。这种组合在`${CMAKE_CURRENT_BINARY_DIR}`中提取存档。然而，我们现在处于不同的作用域，并引用`deps/CMakeLists.txt`，因此tarball将被提取到主项目构建目录下的`deps`子目录中：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we add our `math` library as a target and specify corresponding sources,
    include directories, and link libraries:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`math`库作为目标添加，并指定相应的源文件、包含目录和链接库：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the execution of the commands in `deps/CMakeLists.txt` is done, we move
    back to the parent scope, define the executable target, and link it against the
    `math` library that we have defined one directory below:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`deps/CMakeLists.txt`中的命令执行完毕，我们返回到父作用域，定义可执行目标，并将其与我们在下一目录定义的`math`库链接：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: With `add_custom_target`, users can execute custom commands within targets.
    This is subtly different from the `add_custom_command` recipe we have discussed
    previously. The target added by `add_custom_target` has no output and is thus
    always executed. It is thus possible to introduce a custom target in subdirectories,
    and still be able to refer to it in the top-level `CMakeLists.txt`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_custom_target`，用户可以在目标内部执行自定义命令。这与我们之前讨论的`add_custom_command`配方有所不同。通过`add_custom_target`添加的目标没有输出，因此总是被执行。因此，可以在子目录中引入自定义目标，并且仍然能够在顶层的`CMakeLists.txt`中引用它。
- en: In this example, we have extracted an archive of source files using a combination
    of `add_custom_target` and `add_custom_command`.  These source files were later
    used to compile a library that we managed to link against in a different (parent)
    directory scope. In the construction of the `CMakeLists.txt` files, we briefly
    commented that the tarball is extracted under `deps`, one subdirectory below the
    build directory of the project. This is because in CMake, the structure of the
    build tree mimics the hierarchy of the source tree.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们通过结合使用`add_custom_target`和`add_custom_command`提取了一个源文件归档。随后，这些源文件被用来编译一个库，我们设法在不同的（父）目录范围内将其链接起来。在构建`CMakeLists.txt`文件时，我们简要注释了tarball在`deps`下被提取，即项目构建目录的下一级子目录。这是因为，在CMake中，构建树的结构模仿了源树的层次结构。
- en: 'A remarkable detail in this recipe, which we should discuss, is the curious
    fact that we have marked the math library sources as `PRIVATE`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，有一个值得注意的细节，我们应该讨论的是，我们将数学库源文件标记为`PRIVATE`的奇特事实：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although these sources are `PRIVATE`, we compiled `linear-algebra.cpp` in the
    parent scope and this source code includes `CxxBLAS.hpp` and `CxxLAPACK.hpp`.
    Why is `PRIVATE` used here, and how was it possible to compile `linear-algebra.cpp`
    and build the executable? Had we marked the header files as `PUBLIC`, CMake would
    have stopped at CMake time with an error, "Cannot find source file", since the
    to-be-generated (extracted) source files do not exist in the file tree yet.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些源文件是`PRIVATE`，我们在父作用域中编译了`linear-algebra.cpp`，并且该源代码包含了`CxxBLAS.hpp`和`CxxLAPACK.hpp`。为什么在这里使用`PRIVATE`，以及如何可能编译`linear-algebra.cpp`并构建可执行文件？如果我们将头文件标记为`PUBLIC`，CMake会在CMake时停止并报错，“找不到源文件”，因为尚未在文件树中生成（提取）的源文件不存在。
- en: This is a known limitation (see [https://gitlab.kitware.com/cmake/cmake/issues/14633](https://gitlab.kitware.com/cmake/cmake/issues/14633),
    as well as a related blog post: [https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands](https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands)).
    We have worked around this limitation by declaring the sources `PRIVATE`. By doing
    this, we did not get any file dependencies on non-existent sources at CMake time.
    However, the CMake built-in C/C++ file dependency scanner picked them up at build
    time and the sources compiled and linked.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已知的限制（参见[https://gitlab.kitware.com/cmake/cmake/issues/14633](https://gitlab.kitware.com/cmake/cmake/issues/14633)，以及相关博客文章：[https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands](https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands)）。我们通过将源文件声明为`PRIVATE`来规避这个限制。这样做，我们在CMake时没有得到任何对不存在源文件的文件依赖。然而，CMake内置的C/C++文件依赖扫描器在构建时识别了它们，并且源文件被编译和链接。
- en: Running custom commands for specific targets at build time
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建时为特定目标运行自定义命令
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05)
    and has a Fortran example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05)找到，并包含一个Fortran示例。该配方适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows（使用MSYS
    Makefiles）上进行了测试。
- en: This recipe will show how to use the second signature of `add_custom_command`
    to perform custom operations without output. This is useful to perform certain
    operations right before or right after a specific target is built or linked. Since
    the custom commands are only executed if the target itself has to be built, we
    achieve target-level control over their execution. We will demonstrate this with
    an example where we print the link line of a target right before it is built,
    and then we measure the static size allocation of the compiled executable right
    after it has been compiled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将展示如何使用`add_custom_command`的第二个签名来执行无输出的自定义操作。这对于在特定目标构建或链接之前或之后执行某些操作非常有用。由于自定义命令仅在目标本身需要构建时执行，我们实现了对它们执行的目标级控制。我们将通过一个示例来演示这一点，在该示例中，我们在目标构建之前打印其链接行，然后在编译后的可执行文件之后测量其静态大小分配。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will work with the following example Fortran code (`example.f90`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用以下示例Fortran代码（`example.f90`）：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The fact that this is Fortran code does not matter much for the discussion that
    will follow, but we have chosen Fortran since there is a lot of legacy Fortran
    code out there where static size allocations are an issue.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是Fortran的事实对后续讨论影响不大，但我们选择Fortran是因为那里有很多遗留的Fortran代码，其中静态大小分配是一个问题。
- en: In this code, we define an array holding 20,000,000 double precision floats,
    and we expect this array to occupy 160 MB of memory. What we have done here is
    not recommended programming practice, since in general this memory will be consumed
    independently of whether it is used in the code. A much better approach would
    have been to allocate the array dynamically only when it is needed and deallocate
    it right afterwards.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们定义了一个包含20,000,000个双精度浮点的数组，我们期望这个数组占用160MB内存。我们在这里所做的并不是推荐的编程实践，因为在一般情况下，无论代码中是否使用，都会消耗内存。更好的方法是在需要时动态分配数组，并在使用后立即释放。
- en: 'The example code fills the array with random numbers and computes their sum
    - this was done to make sure that the array is really used and the compiler does
    not optimize the allocation away. We will measure the size of static allocation
    of the example binary with a Python script (`static-size.py`) wrapping around
    the `size` command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码用随机数填充数组并计算它们的总和 - 这是为了确保数组确实被使用，编译器不会优化分配。我们将使用一个Python脚本（`static-size.py`）来测量示例二进制文件的静态分配大小，该脚本围绕
    `size` 命令：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To print the link line, we will use a second Python helper script (`echo-file.py`)
    to print the contents of a file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印链接行，我们将使用第二个Python辅助脚本（`echo-file.py`）来打印文件内容：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let us have a look at our `CMakeLists.txt`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们的 `CMakeLists.txt`：
- en: 'We first declare a Fortran project:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明一个Fortran项目：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This example depends on the Python interpreter so that we can execute the helper
    scripts in a portable fashion:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个例子依赖于Python解释器，以便我们可以以可移植的方式执行辅助脚本：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this example, we default to the `"Release"` build type so that CMake adds
    optimization flags so that we have something to print later:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们默认使用 `"Release"` 构建类型，以便CMake添加优化标志，以便我们稍后有东西可以打印：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we define the executable target:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义可执行目标：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then define a custom command to print the link line before the `example`
    target is linked:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个自定义命令，在链接 `example` 目标之前打印链接行：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we define a custom command to print the static size of the executable
    after it has been successfully built:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个自定义命令，在成功构建后打印可执行文件的静态大小：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let us test it out. Observe the printed link line and static size of executable:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来测试一下。观察打印出的链接行和可执行文件的静态大小：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Once a library or executable target has been declared, one can latch additional
    commands onto the target by using `add_custom_command`. As we have seen, these
    commands will be executed at specific times, contextually to the execution of
    the target they are attached to. CMake understands the following options for the
    execution order of custom commands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了库或可执行目标，就可以通过使用 `add_custom_command` 将附加命令附加到目标上。正如我们所见，这些命令将在特定时间执行，与它们所附加的目标的执行上下文相关。CMake理解以下选项，用于自定义命令的执行顺序：
- en: '`PRE_BUILD`: For commands to be executed before any other rules pertaining
    to the target are executed. This is however only supported for Visual Studio 7
    or later.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_BUILD`：用于在执行与目标相关的任何其他规则之前执行的命令。但是，这只支持Visual Studio 7或更高版本。'
- en: '`PRE_LINK`: With this option, commands are executed after the target has been
    compiled but before the linker or archiver are invoked. Using `PRE_BUILD` with
    generators other than Visual Studio 7 or later will be interpreted as `PRE_LINK`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_LINK`：使用此选项，命令将在目标编译后但在链接器或归档器调用之前执行。使用 `PRE_BUILD` 与Visual Studio 7或更高版本以外的生成器将被解释为
    `PRE_LINK`。'
- en: '`POST_BUILD`: As already explained, the commands will be run after all the
    rules for the given target have been executed.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST_BUILD`：如前所述，命令将在执行给定目标的所有规则之后运行。'
- en: 'In this example, we have bolted on two custom commands to the executable target.
    The `PRE_LINK` command prints the content of `${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/example.dir/link.txt`
    to the screen. This file contains the link command and in our example, the link
    line turned out to be this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向可执行目标添加了两个自定义命令。`PRE_LINK` 命令将屏幕上打印出 `${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/example.dir/link.txt`
    的内容。该文件包含链接命令，在我们的例子中，链接行结果如下：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have used a Python wrapper for this to not depend on shell commands, which
    might not be portable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此使用了一个Python包装器，以不依赖于可能不具有可移植性的shell命令。
- en: 'In the second step, the `POST_BUILD` custom command called the Python helper
    script `static-size.py` with the generator expression `$<TARGET_FILE:example>`
    as argument. CMake will expand the generator expression to the target file path
    at *generation time*, that is, when the build system is generated. The Python
    script `static-size.py` in turn uses the size command to obtain the size of static
    allocation of the executable file, converts it to MB, and prints the result. In
    our case, we obtained the expected 160 MB:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，`POST_BUILD`自定义命令调用了Python辅助脚本`static-size.py`，其参数为生成器表达式`$<TARGET_FILE:example>`。CMake将在*生成时间*，即构建系统生成时，将生成器表达式扩展为目标文件路径。Python脚本`static-size.py`反过来使用`size`命令来获取可执行文件的静态分配大小，将其转换为MB，并打印结果。在我们的例子中，我们得到了预期的160
    MB：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Probing compilation and linking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探究编译和链接
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06) and
    has a C++ example. The recipe is valid with CMake version 3.9 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows. The code repository also contains
    an example compatible with CMake 3.5.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06)找到，并提供了一个C++示例。该食谱适用于CMake版本3.9（及以上），并在GNU/Linux、macOS和Windows上进行了测试。代码仓库还包含了一个与CMake
    3.5兼容的示例。
- en: 'One of the most common operations during build system generation is to assess
    what kind of system we are trying to build our project on. That means trying to
    find out which functionality works and which does not, and adapting the compilation
    of our project accordingly, either by signaling that dependencies are unmet or
    by enabling proper workarounds in our codebase. The next few recipes will show
    how to perform these operations with CMake. In particular, we will consider the
    following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建系统生成过程中最常见的操作之一是评估我们试图在哪种系统上构建项目。这意味着尝试找出哪些功能有效，哪些无效，并相应地调整项目的编译，无论是通过发出依赖项未满足的信号，还是在我们的代码库中启用适当的变通方法。接下来的几个食谱将展示如何使用CMake执行这些操作。特别是，我们将考虑以下内容：
- en: How to make sure that specific code snippets compile successfully into executables.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保特定的代码片段能够成功编译成可执行文件。
- en: How to make sure that the compiler understands desired flags.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保编译器理解所需的标志。
- en: How to make sure that specific code snippets compile successfully into *running
    executables*.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保特定的代码片段能够成功编译成*运行的可执行文件*。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe will show how to use the `check_<lang>_source_compiles` function from
    the corresponding `Check<LANG>SourceCompiles.cmake` standard module, in order
    to assess whether the given compiler can compile a predefined code snippet into
    an executable. The command can help you ascertain whether:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示如何使用相应的`Check<LANG>SourceCompiles.cmake`标准模块中的`check_<lang>_source_compiles`函数，以评估给定的编译器是否能够将预定义的代码片段编译成可执行文件。该命令可以帮助您确定：
- en: Your compiler supports desired features.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的编译器支持所需的功能。
- en: The linker works properly and understands specific flags.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器工作正常并理解特定的标志。
- en: Include directories and libraries found using `find_package` are usable.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`find_package`找到的包含目录和库是可用的。
- en: In this recipe, we will show how to detect the task loop feature of the OpenMP
    4.5 standard for its use in a C++ executable. We will use a sample C++ source
    file to probe whether the compiler supports such a feature. CMake offers an additional
    command,  `try_compile`, to probe compilation. This recipe will show how to use
    both approaches.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示如何检测OpenMP 4.5标准中的任务循环功能，以便在C++可执行文件中使用。我们将使用一个示例C++源文件来探测编译器是否支持这样的功能。CMake提供了一个额外的命令`try_compile`来探测编译。本食谱将展示如何使用这两种方法。
- en: You can use the CMake command-line interface to get documentation about specific
    modules (`cmake --help-module <module-name>`) and commands (`cmake --help-command
    <command-name>`). In our example, `cmake --help-module CheckCXXSourceCompiles`
    will output the documentation for the `check_cxx_source_compiles` function to
    screen, while `cmake --help-command try_compile` will do the same for the `try_compile`
    command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用CMake命令行界面来获取特定模块（`cmake --help-module <module-name>`）和命令（`cmake --help-command
    <command-name>`）的文档。在我们的例子中，`cmake --help-module CheckCXXSourceCompiles`将输出`check_cxx_source_compiles`函数的文档到屏幕，而`cmake
    --help-command try_compile`将做同样的事情，为`try_compile`命令。
- en: How to do it
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will use both `try_compile` and `check_cxx_source_compiles` and compare
    how the two commands work:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同时使用`try_compile`和`check_cxx_source_compiles`，并比较这两个命令的工作方式：
- en: 'We first create a C++11 project:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个C++11项目：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We find OpenMP support for the compiler:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到编译器的OpenMP支持：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If OpenMP was found, we move forward and probe whether the desired feature
    is available. To this end, we set a scratch directory. This will be used by `try_compile`
    to generate its intermediate files. We place this inside the if-clause introduced
    in the previous step:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了OpenMP，我们继续前进并探测所需功能是否可用。为此，我们设置一个临时目录。这将由`try_compile`用于生成其中间文件。我们将这个放在前一步引入的if子句中：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We call `try_compile` to generate a small project to attempt compiling the
    source file `taskloop.cpp`. Success or failure will be saved into the `omp_taskloop_test_1` variable.
    We need to set appropriate compiler flags, include directories, and link libraries
    for this small sample compilation. Since we are using the *imported target* `OpenMP::OpenMP_CXX`,
    this is simply done by setting the `LINK_LIBRARIES` option to `try_compile`. If
    compilation succeeds, then the task loop feature is available and we print a message
    for the user:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`try_compile`来生成一个小项目，尝试编译源文件`taskloop.cpp`。成功或失败将被保存到`omp_taskloop_test_1`变量中。我们需要为这个小样本编译设置适当的编译器标志、包含目录和链接库。由于我们使用的是*导入的目标*
    `OpenMP::OpenMP_CXX`，这只需通过设置`LINK_LIBRARIES`选项为`try_compile`来简单完成。如果编译成功，那么任务循环功能是可用的，我们向用户打印一条消息：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To use the `check_cxx_source_compiles` function, we need to include the `CheckCXXSourceCompiles.cmake`
    module file. This is distributed with CMake, alongside similar files for C (`CheckCSourceCompiles.cmake`)
    and Fortran (`CheckFortranSourceCompiles.cmake`):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用`check_cxx_source_compiles`函数，我们需要包含`CheckCXXSourceCompiles.cmake`模块文件。这是随CMake一起分发的，与C（`CheckCSourceCompiles.cmake`）和Fortran（`CheckFortranSourceCompiles.cmake`）的类似文件一起：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We copy the contents of the source file we are attempting to compile and link
    into a CMake variable by reading its contents with the `file(READ ...)` command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`file(READ ...)`命令读取其内容，将我们尝试编译和链接的源文件的内容复制到CMake变量中：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We set `CMAKE_REQUIRED_LIBRARIES`. This is needed for the correct invocation
    of the compiler in the next step. Note the use of the *imported* `OpenMP::OpenMP_CXX`
    target, which will set also the proper compiler flags and include directories:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`CMAKE_REQUIRED_LIBRARIES`。这是为了在下一步中正确调用编译器所必需的。注意使用了*导入的* `OpenMP::OpenMP_CXX`目标，这将同时设置适当的编译器标志和包含目录：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We invoke the `check_cxx_source_compiles` function with our code snippet. The
    result of the check will be saved into the `omp_taskloop_test_2` variable:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`check_cxx_source_compiles`函数并传入我们的代码片段。检查的结果将被保存到`omp_taskloop_test_2`变量中：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We unset the variables defined before calling `check_cxx_source_compiles` and
    print a message to the user:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`check_cxx_source_compiles`之前，我们取消设置之前定义的变量，并向用户打印一条消息：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we test the recipe:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测试这个配方：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Both `try_compile` and `check_cxx_source_compiles` will compile and link a
    source file into an executable. If those operations succeed, then the output variable,
    `omp_task_loop_test_1` for the former and `omp_task_loop_test_2` for the latter,
    will be set to `TRUE`. The way this task is achieved is slightly different between
    the two commands, however. The `check_<lang>_source_compiles` family of commands
    is a simplified wrapper to the `try_compile` command. As such, it offers a minimal
    interface:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_compile`和`check_cxx_source_compiles`都将编译并链接一个源文件到一个可执行文件。如果这些操作成功，那么输出变量，对于前者是`omp_task_loop_test_1`，对于后者是`omp_task_loop_test_2`，将被设置为`TRUE`。这两个命令完成任务的方式略有不同，然而。`check_<lang>_source_compiles`系列命令是`try_compile`命令的一个简化包装。因此，它提供了一个最小化的接口：'
- en: The code snippet to be compiled has to be passed in as a CMake variable. Most
    of the time this means that files have to be read in using `file(READ ...)`, as
    we have done in our example. The snippet is then saved to a file in the `CMakeFiles/CMakeTmp`
    subdirectory of the build directory.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译的代码片段必须作为CMake变量传递。大多数情况下，这意味着必须使用 `file(READ ...)` 读取文件，正如我们在示例中所做的那样。然后，该片段将保存到构建目录的
    `CMakeFiles/CMakeTmp` 子目录中的文件中。
- en: 'Fine-tuning compilation and linking has to be done by setting the following
    CMake variables before calling the function:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在调用函数之前设置以下CMake变量来微调编译和链接：
- en: '`CMAKE_REQUIRED_FLAGS` to set the compiler flags'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_FLAGS` 用于设置编译器标志'
- en: '`CMAKE_REQUIRED_DEFINITIONS` to set preprocessor macros'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_DEFINITIONS` 用于设置预处理器宏'
- en: '`CMAKE_REQUIRED_INCLUDES` to set the list of include directories'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_INCLUDES` 用于设置包含目录列表'
- en: '`CMAKE_REQUIRED_LIBRARIES` to set the list of libraries to link into the executable'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_LIBRARIES` 用于设置链接到可执行文件的库列表'
- en: These variables have to be manually unset after calling the `check_<lang>_compiles_function`,
    to guarantee that further uses of the same variables does not have spurious contents.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `check_<lang>_compiles_function` 后，必须手动取消设置这些变量，以确保同一变量的后续使用不会包含虚假内容。
- en: 'OpenMP imported targets were introduced with CMake 3.9, but the current recipe
    can also be made to work with earlier versions of CMake by manually setting the
    required flags and libraries for `check_cxx_source_compiles` as: `set(CMAKE_REQUIRED_FLAGS
    ${OpenMP_CXX_FLAGS})` and `set(CMAKE_REQUIRED_LIBRARIES ${OpenMP_CXX_LIBRARIES})`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake 3.9中引入了OpenMP导入目标，但当前的方案也可以通过手动设置所需的标志和库，使其与早期版本的CMake兼容，方法如下：`set(CMAKE_REQUIRED_FLAGS
    ${OpenMP_CXX_FLAGS})` 和 `set(CMAKE_REQUIRED_LIBRARIES ${OpenMP_CXX_LIBRARIES})`。
- en: In the case of Fortran, CMake assumes the sample snippet to be in fixed-form
    format, which might not always be the case. To overcome false negatives, one needs
    to set the `-ffree-form` compiler flag for `check_fortran_source_compiles`. This
    can be achieved with `set(CMAKE_REQUIRED_FLAGS "-ffree-form")`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fortran，CMake假定样本片段采用固定格式，但这并不总是正确的。为了克服假阴性，需要为 `check_fortran_source_compiles`
    设置 `-ffree-form` 编译器标志。这可以通过 `set(CMAKE_REQUIRED_FLAGS "-ffree-form")` 实现。
- en: This minimal interface reflects the fact that the test compilation is carried
    out by generating and executing build and link commands directly within the CMake
    invocation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最小接口反映了测试编译是通过在CMake调用中直接生成和执行构建和链接命令来进行的。
- en: 'The command `try_compile` offers a more complete interface and two different
    modes of operation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_compile` 命令提供了更完整的接口和两种不同的操作模式：'
- en: The first one takes a full-fledged CMake project as input and will configure,
    build, and link it based on its `CMakeLists.txt`. This mode of operation offers
    more flexibility, since the project to be compiled can be arbitrarily complex.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方式接受一个完整的CMake项目作为输入，并根据其 `CMakeLists.txt` 配置、构建和链接它。这种操作模式提供了更多的灵活性，因为要编译的项目可以任意复杂。
- en: The second one, which we have used, where a source file is provided together
    with configuration options for include directories, link libraries, and compiler
    flags.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方式，我们使用的方式，提供了一个源文件以及用于包含目录、链接库和编译器标志的配置选项。
- en: '`try_compile` is thus based on invoking CMake on a project, either one where
    the `CMakeLists.txt` is already existing (in the first mode of operation) or one
    where the file is generated on the fly based on the arguments passed to the `try_compile`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_compile` 因此基于调用CMake的项目，要么是已经存在 `CMakeLists.txt` 的项目（在第一种操作模式下），要么是根据传递给
    `try_compile` 的参数动态生成的项目。'
- en: There is more
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Checks of the type outlined in this recipe are not always bulletproof and can
    generate both false positives and false negatives. As an example, you can try
    to comment out the lines containing `CMAKE_REQUIRED_LIBRARIES` and the example
    will still report "Success". The reason for this is that OpenMP pragmas will then
    be ignored by the compiler.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本方案中概述的检查类型并不总是万无一失的，可能会产生假阳性和假阴性。例如，你可以尝试注释掉包含 `CMAKE_REQUIRED_LIBRARIES` 的行，示例仍将报告“成功”。这是因为编译器将忽略OpenMP指令。
- en: What should you do when you suspect that a wrong result is being returned? The
    `CMakeOutput.log` and `CMakeError.log `files in the `CMakeFiles` subdirectory of
    the build directory offer clues as to what went wrong. They report the standard
    output and standard error for operations run by CMake. If you suspect false positives,
    you should check the former, by searching for the variable set to hold the result
    of the compilation check. If you suspect false negatives, you should check the
    latter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你怀疑返回了错误的结果时，应该怎么办？`CMakeOutput.log`和`CMakeError.log`文件位于构建目录的`CMakeFiles`子目录中，它们提供了出错线索。它们报告了CMake运行的操作的标准输出和标准错误。如果你怀疑有误报，应该检查前者，通过搜索设置为保存编译检查结果的变量。如果你怀疑有漏报，应该检查后者。
- en: 'Debugging `try_compile` will require some care. CMake erases all files generated
    by that command, even if the check was unsuccessful. Fortunately, `--debug-trycompile` will
    prevent CMake from cleaning up. If there are multiple calls to `try_compile` in
    your code, you will only be able to debug them one at a time:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 调试`try_compile`需要小心。CMake会删除该命令生成的所有文件，即使检查不成功。幸运的是，`--debug-trycompile`将阻止CMake进行清理。如果你的代码中有多个`try_compile`调用，你将只能一次调试一个：
- en: Run CMake once, without `--debug-trycompile`. All `try_compile` commands will
    be run and their execution directories and files cleaned up.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一次CMake，不带`--debug-trycompile`。所有`try_compile`命令都将运行，并且它们的执行目录和文件将被清理。
- en: 'Erase the variable holding the result of the check from the CMake cache. The
    cache is saved into the `CMakeCache.txt` file. To clear the contents of a variable,
    you can use the `-U` CLI switch followed by the name of the variable, which will
    be interpreted as a globbing expression and may thus use `*` and `?`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从CMake缓存中删除保存检查结果的变量。缓存保存在`CMakeCache.txt`文件中。要清除变量的内容，可以使用`-U`CLI开关，后跟变量的名称，该名称将被解释为全局表达式，因此可以使用`*`和`?`：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Run CMake once more, with `--debug-trycompile`. Only the check for which the
    cache was cleared up will be rerun. Its execution directories and files will not
    be cleaned up this time.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行CMake，使用`--debug-trycompile`选项。只有清除缓存的检查会被重新运行。这次执行目录和文件不会被清理。
- en: '`try_compile` offers more flexibility and a cleaner interface, especially when
    the code to be compiled is not a short snippet of code. We recommend to use `check_<lang>_source_compiles`
    whenever a small, self-contained snippet of code that does not need extensive
    configuration has to be test-compiled. In all other cases, `try_compile` is to
    be considered a superior alternative.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_compile`提供了更多的灵活性和更清晰的接口，特别是当要编译的代码不是简短的代码片段时。我们建议在需要测试编译的代码是简短、自包含且不需要广泛配置的情况下，使用`check_<lang>_source_compiles`。在所有其他情况下，`try_compile`被认为是更优越的替代方案。'
- en: Probing compiler flags
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测编译器标志
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07)获取，并包含一个C++示例。本节适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Setting compiler flags is critical to make sure that your code is compiled correctly.
    Different compiler vendors implement different flags for similar tasks. Even different
    compiler versions from the same vendor might present slight differences in the
    available flags. Sometimes, new flags are introduced that are extremely convenient
    to use for debugging or optimization purposes. In this recipe, we will show how
    to check that certain flags are available for the selected compiler.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 设置编译器标志至关重要，以确保代码正确编译。不同的编译器供应商为相似的任务实现不同的标志。即使是同一供应商的不同编译器版本，也可能在可用的标志上略有差异。有时，会引入新的标志，这些标志对于调试或优化目的极为方便。在本节中，我们将展示如何检查所选编译器是否支持某些标志。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Sanitizers (refer to [https://github.com/google/sanitizers](https://github.com/google/sanitizers))
    have become incredibly useful tools for static and dynamic code analysis. By simply
    recompiling your code with the appropriate flags and linking against the necessary
    libraries, you can investigate and debug problems related to memory errors (address
    sanitizer), uninitialized reads (memory sanitizer), thread safety (thread sanitizer),
    and undefined behavior (undefined behavior sanitizer). Compared to similar analysis
    tools, sanitizers typically introduce a much smaller performance penalty and tend
    to give more detailed information on the problems detected. The drawback is that
    your code, and possibly parts of your toolchain, need to be recompiled with the
    additional flags.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 消毒器（参考[https://github.com/google/sanitizers](https://github.com/google/sanitizers)）已经成为静态和动态代码分析的极其有用的工具。只需使用适当的标志重新编译代码并链接必要的库，您就可以调查和调试与内存错误（地址消毒器）、未初始化读取（内存消毒器）、线程安全（线程消毒器）和未定义行为（未定义行为消毒器）相关的问题。与类似的分析工具相比，消毒器通常引入的性能开销要小得多，并且往往提供更详细的问题检测信息。缺点是您的代码，可能还有部分工具链，需要使用额外的标志重新编译。
- en: In this recipe, we will set up a project to compile code with the different
    sanitizers activated and show how to check that the correct compiler flags are
    available.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将设置一个项目以使用激活的不同消毒器编译代码，并展示如何检查正确的编译器标志是否可用。
- en: How to do it
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: Sanitizers have been available for a while with the Clang compiler and were
    later also introduced into the GCC toolset. They were designed for use with C
    and C++ programs, but recent versions of Fortran will understand the same flags
    and produce correctly instrumented libraries and executables. This recipe will
    however focus on a C++ example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 消毒器已经有一段时间与Clang编译器一起可用，并且后来也被引入到GCC工具集中。它们是为C和C++程序设计的，但最近的Fortran版本将理解相同的标志并生成正确检测的库和可执行文件。然而，本教程将重点介绍一个C++示例。
- en: 'As usual, we first declare a C++11 project:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们首先声明一个C++11项目：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We declare a list, `CXX_BASIC_FLAGS`, containing the compiler flags to be always
    used when building the project, `-g3` and `-O1`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个列表`CXX_BASIC_FLAGS`，包含构建项目时始终使用的编译器标志，`-g3`和`-O1`：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We include the CMake module `CheckCXXCompilerFlag.cmake`. A similar module
    is available also for C (`CheckCCompilerFlag.cmake`) and Fortran (`CheckFortranCompilerFlag.cmake`,
    since CMake 3.3):'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含CMake模块`CheckCXXCompilerFlag.cmake`。类似的模块也可用于C（`CheckCCompilerFlag.cmake`）和Fortran（`CheckFortranCompilerFlag.cmake`，自CMake
    3.3起）：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We declare an `ASAN_FLAGS` variable, which holds the flags needed to activate
    the address sanitizer, and set the `CMAKE_REQUIRED_FLAGS` variable, used internally
    by the `check_cxx_compiler_flag` function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个`ASAN_FLAGS`变量，它包含激活地址消毒器所需的标志，并设置`CMAKE_REQUIRED_FLAGS`变量，该变量由`check_cxx_compiler_flag`函数内部使用：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We call `check_cxx_compiler_flag` to ensure that the compiler understands the
    flags in the `ASAN_FLAGS` variable. After calling the function, we unset `CMAKE_REQUIRED_FLAGS`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`check_cxx_compiler_flag`以确保编译器理解`ASAN_FLAGS`变量中的标志。调用函数后，我们取消设置`CMAKE_REQUIRED_FLAGS`：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If the compiler understands the options, we transform the variable into a list
    by replacing the spaces with semicolons:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编译器理解这些选项，我们将变量转换为列表，方法是替换空格为分号：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We add an executable target for our code sample with the address sanitizer:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的代码示例添加一个带有地址消毒器的可执行目标：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We set the compiler flags for the executable to contain the basic and address
    sanitizer flags:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将可执行文件的编译器标志设置为包含基本和地址消毒器标志：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we add the address sanitizer flags also to the set of flags used by
    the linker. This closes the `if(asan_works)` block:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将地址消毒器标志也添加到链接器使用的标志集中。这关闭了`if(asan_works)`块：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The full recipe source code also shows how to compile and link sample executables
    for the thread, memory, and undefined behavior sanitizers. These are not discussed
    in detail here, since we use the same pattern for the compiler flag checking.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的教程源代码还展示了如何为线程、内存和未定义行为消毒器编译和链接示例可执行文件。这些在这里没有详细讨论，因为我们使用相同的模式来检查编译器标志。
- en: 'A custom CMake module for finding support for sanitizers on your system is
    available on GitHub: [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于在您的系统上查找消毒器支持的自定义CMake模块可在GitHub上获得：[https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake)。
- en: How it works
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `check_<lang>_compiler_flag` functions are simply wrappers around the `check_<lang>_source_compiles`
    function, which we discussed in the previous recipe. These wrappers provide a
    shortcut for the common use case where it is not important to check whether a
    specific code snippet compiles, but whether the compiler understands a set of
    flags.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_<lang>_compiler_flag`函数只是`check_<lang>_source_compiles`函数的包装器，我们在上一节中讨论过。这些包装器为常见用例提供了一个快捷方式，即不重要检查特定的代码片段是否编译，而是检查编译器是否理解一组标志。'
- en: Compiler flags for sanitizers are a special case, in that they also need to
    be passed on to the linker. To achieve this with the `check_<lang>_compiler_flag`
    functions, we need to set the `CMAKE_REQUIRED_FLAGS` variable prior to the call.
    The flags passed as the first argument would otherwise only be used in the call
    to the compiler, resulting in a false negative.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于sanitizer的编译器标志来说，它们还需要传递给链接器。为了使用`check_<lang>_compiler_flag`函数实现这一点，我们需要在调用之前设置`CMAKE_REQUIRED_FLAGS`变量。否则，作为第一个参数传递的标志只会在调用编译器时使用，导致错误的否定结果。
- en: One more point to notice in the current recipe is the use of string variables
    and lists to set compiler flags. Using string variables with the `target_compile_options`
    and `target_link_libraries` functions will result in a compiler and/or linker
    error. CMake will pass these options quoted, resulting in parsing errors. This
    justifies the need to express these options in terms of lists and the ensuing
    string manipulations, to replace spaces in string variables with semicolons. We
    recall, in fact, that lists in CMake are semicolon-separated strings.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中还有一个要点需要注意，那就是使用字符串变量和列表来设置编译器标志。如果在`target_compile_options`和`target_link_libraries`函数中使用字符串变量，将会导致编译器和/或链接器错误。CMake会将这些选项用引号括起来，导致解析错误。这就解释了为什么需要以列表的形式表达这些选项，并进行后续的字符串操作，将字符串变量中的空格替换为分号。我们再次提醒，CMake中的列表是分号分隔的字符串。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We will revisit and generalize the pattern for testing and setting compiler
    flags in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, Recipe 3, *Writing a function to test and set compiler flags*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构化*，第3节，*编写测试和设置编译器标志的函数*中重新审视并概括测试和设置编译器标志的模式。
- en: Probing execution
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测执行
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08)
    and has a C/C++ example. The recipe is valid with CMake version 3.6 (and higher)
    and has been tested on GNU/Linux and macOS. The code repository also contains
    an example compatible with CMake 3.5.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08)找到，并提供了一个C/C++示例。本节适用于CMake版本3.6（及以上），并在GNU/Linux和macOS上进行了测试。代码仓库还包含了一个与CMake
    3.5兼容的示例。
- en: We have so far shown how to check that a given source snippet can be compiled
    by the chosen compiler and how to make sure that the desired compiler and linker
    flags are available. This recipe will show how to check whether a code snippet
    can be compiled, linked, and run on the current system.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何检查给定的源代码片段是否能被选定的编译器编译，以及如何确保所需的编译器和链接器标志可用。本节将展示如何检查代码片段是否可以在当前系统上编译、链接和运行。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The code sample for this recipe is a slight variation of [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 9, *Detecting external libraries: I.
    Using* `pkg-config`. There, we showed how to find the ZeroMQ library on your system
    and link it into a C program. In this recipe, we will check that a small C program
    using the system UUID library on GNU/Linux can actually run, before generating
    the actual C++ program.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码示例是对[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第9节，*检测外部库：I.
    使用`pkg-config`*的轻微变体。在那里，我们展示了如何在系统上找到ZeroMQ库并将其链接到C程序中。在本节中，我们将检查使用GNU/Linux系统UUID库的小型C程序是否可以实际运行，然后再生成实际的C++程序。
- en: How to do it
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We wish to check whether the UUID system library on GNU/Linux can be linked
    against, before embarking on building our own C++ project. This can be achieved
    with the following series of steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望检查GNU/Linux上的UUID系统库是否可以链接，然后再开始构建我们自己的C++项目。这可以通过以下一系列步骤实现：
- en: 'We start by declaring a mixed C and C++11 program. This is needed since the
    test code snippet we want to compile and run is in the C language:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明一个混合 C 和 C++11 程序。这是必要的，因为我们要编译和运行的测试代码片段是用 C 语言编写的：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We need to find the UUID library on our system. This is achieved by using `pkg-config`.
    We ask for the search to return a CMake imported target using the `IMPORTED_TARGET`
    argument:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的系统上找到 UUID 库。这可以通过使用 `pkg-config` 来实现。我们要求搜索返回一个 CMake 导入目标，使用 `IMPORTED_TARGET`
    参数：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we include the `CheckCSourceRuns.cmake` module. There is a similar `CheckCXXSourceRuns.cmake`
    module for C++. No such module is available for the Fortran language as of CMake
    3.11, however:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们包含 `CheckCSourceRuns.cmake` 模块。对于 C++ 有一个类似的 `CheckCXXSourceRuns.cmake`
    模块。然而，对于 Fortran 语言，在 CMake 3.11 中没有这样的模块：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We declare an `_test_uuid` variable containing the C code snippet to compile
    and run:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个包含要编译和运行的 C 代码片段的 `_test_uuid` 变量：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We declare the `CMAKE_REQUIRED_LIBRARIES` variable to fine-tune the call to
    the `check_c_source_runs` function. Next, we issue a call to `check_c_source_runs` with
    the test snippet as the first argument and the `_runs` variable as the second
    argument, to hold the result of the check performed. We also unset the `CMAKE_REQUIRED_LIBRARIES`
    variable:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明 `CMAKE_REQUIRED_LIBRARIES` 变量以微调对 `check_c_source_runs` 函数的调用。接下来，我们使用测试代码片段作为第一个参数和对
    `_runs` 变量作为第二个参数调用 `check_c_source_runs`，以保存执行的检查结果。我们还取消设置 `CMAKE_REQUIRED_LIBRARIES`
    变量：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the check did not succeed, either because the snippet didn''t compile or
    because it didn''t run, we stop the configuration with a fatal error:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果检查未成功，可能是因为代码片段未编译或未运行，我们以致命错误停止配置：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Otherwise, we move on and add the C++ executable as a target and link against
    UUID:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们继续添加 C++ 可执行文件作为目标并链接到 UUID：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `check_<lang>_source_runs` functions for C and C++ operate with the same
    general principles as `check_<lang>_source_compiles`, but add an extra step where
    the produced executable is actually run. As for `check_<lang>_source_compiles`,
    the execution of  `check_<lang>_source_runs` can be directed by the following
    variables:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_<lang>_source_runs` 函数对于 C 和 C++ 的操作原理与 `check_<lang>_source_compiles`
    相同，但在实际运行生成的可执行文件时增加了额外步骤。与 `check_<lang>_source_compiles` 一样，`check_<lang>_source_runs`
    的执行可以通过以下变量进行指导：'
- en: '`CMAKE_REQUIRED_FLAGS` to set the compiler flags'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_FLAGS` 用于设置编译器标志'
- en: '`CMAKE_REQUIRED_DEFINITIONS` to set preprocessor macros'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_DEFINITIONS` 用于设置预处理器宏'
- en: '`CMAKE_REQUIRED_INCLUDES` to set the list of include directories'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_INCLUDES` 用于设置包含目录列表'
- en: '`CMAKE_REQUIRED_LIBRARIES` to set the list of libraries to link into the executable'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_LIBRARIES` 用于设置链接到可执行文件的库列表'
- en: Since we used the imported target as produced by `pkg_search_module`, it was
    only necessary to set `CMAKE_REQUIRES_LIBRARIES` to `PkgConfig::UUID`, to also
    get the include directories correctly set.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了由 `pkg_search_module` 生成的导入目标，因此只需将 `CMAKE_REQUIRES_LIBRARIES` 设置为 `PkgConfig::UUID`，即可正确设置包含目录。
- en: 'Just as `check_<lang>_source_compiles` is a wrapper to `try_compile`, `check_<lang>_source_runs`
    is a wrapper to another, more powerful command in CMake: `try_run`. It is thus
    possible to write a `CheckFortranSourceRuns.cmake` module that offers the same
    functionality as the C and C++ modules by appropriately wrapping `try_run`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `check_<lang>_source_compiles` 是 `try_compile` 的包装器，`check_<lang>_source_runs`
    是 CMake 中另一个更强大的命令 `try_run` 的包装器。因此，可以通过适当地包装 `try_run` 来编写一个提供与 C 和 C++ 模块相同功能的
    `CheckFortranSourceRuns.cmake` 模块。
- en: '`pkg_search_module` learned how to define imported targets only with CMake
    3.6, but the current recipe can be made to work also with earlier versions of
    CMake by manually setting the required include directories and libraries for `check_c_source_runs`
    as follows: `set(CMAKE_REQUIRED_INCLUDES ${UUID_INCLUDE_DIRS})` and `set(CMAKE_REQUIRED_LIBRARIES
    ${UUID_LIBRARIES})`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg_search_module` 仅在 CMake 3.6 中学会了如何定义导入目标，但当前的配方也可以通过手动设置 `check_c_source_runs`
    所需的包含目录和库来与早期版本的 CMake 一起工作，如下所示：`set(CMAKE_REQUIRED_INCLUDES ${UUID_INCLUDE_DIRS})`
    和 `set(CMAKE_REQUIRED_LIBRARIES ${UUID_LIBRARIES})`。'
- en: Fine-tuning configuration and compilation with generator expressions
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器表达式微调配置和编译
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09)
    and has a C++ example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09)获取，并包含一个C++示例。该配方适用于CMake版本3.9（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: CMake offers a domain-specific language to describe how to configure and build
    a project. It is natural that variables describing particular conditions are introduced
    and conditional statements based on this are included in `CMakeLists.txt`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了一种特定于领域的语言来描述如何配置和构建项目。自然地，描述特定条件的变量被引入，并且基于这些变量的条件语句被包含在`CMakeLists.txt`中。
- en: In this recipe, we will revisit generator expressions, which we used throughout
    [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running
    Tests*, to compactly refer to explicit test executable paths. Generator expressions
    offer a powerful and compact pattern for logical and informational expressions
    that are evaluated during build system generation and produce information specific
    to each build configuration. In other words, generator expressions are useful
    to refer to information that is only known at generation time, but not known or
    difficult to know at configure time; this is particularly the case for filenames,
    file locations, and library file suffixes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将重新审视生成器表达式，我们在[第四章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*中广泛使用它们，以紧凑地引用明确的测试可执行路径。生成器表达式提供了一个强大而紧凑的模式，用于逻辑和信息表达，这些表达在构建系统生成期间被评估，并产生特定于每个构建配置的信息。换句话说，生成器表达式对于引用仅在生成时已知的信息非常有用，但在配置时未知或难以知道；这在文件名、文件位置和库文件后缀的情况下尤其如此。
- en: In this example, we will employ generator expressions to conditionally set a
    preprocessor definition and conditionally link to a message passing interface
    (MPI) library and allow us to build the same source code either sequentially or
    using MPI parallelism.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用生成器表达式来有条件地设置预处理器定义，并有条件地链接消息传递接口（MPI）库，使我们能够构建相同的源代码，无论是顺序执行还是使用MPI并行性。
- en: In this example, we will use an imported target to link to MPI, which is only
    available starting with CMake 3.9\. However, the generator expression aspect is
    transferable to CMake 3.0 or later versions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用一个导入的目标来链接MPI，该功能仅从CMake 3.9开始提供。然而，生成器表达式的方面可以转移到CMake 3.0或更高版本。
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will compile the following example source code (`example.cpp`):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编译以下示例源代码（`example.cpp`）：
- en: '[PRE74]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The code contains preprocessor statements (`#ifdef HAVE_MPI` ... `#else` ...
    `#endif`) so that we can compile either a sequential or a parallel executable
    with the same source code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含预处理器语句（`#ifdef HAVE_MPI` ... `#else` ... `#endif`），以便我们可以使用相同的源代码编译顺序或并行可执行文件。
- en: How to do it
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'When composing the `CMakeLists.txt` file, we will reuse some of the building
    blocks we encountered in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 6, *Detecting the MPI parallel environment*:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`CMakeLists.txt`文件时，我们将重用我们在[第三章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第6个配方，*检测MPI并行环境*中遇到的构建块：
- en: 'We declare a C++11 project:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++11项目：
- en: '[PRE75]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we introduce an option, `USE_MPI`, to select MPI parallelization and
    set it `ON` by default. If it is `ON`, we use `find_package` to locate the MPI
    environment:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们引入一个选项`USE_MPI`，以选择MPI并行化，并默认设置为`ON`。如果它是`ON`，我们使用`find_package`来定位MPI环境：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We then define the executable target and conditionally set the corresponding
    library dependency (`MPI::MPI_CXX`) and preprocessor definition (`HAVE_MPI`),
    which we will explain in a moment:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义可执行目标，并根据条件设置相应的库依赖项（`MPI::MPI_CXX`）和预处理器定义（`HAVE_MPI`），我们将在稍后解释：
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If MPI is found, we also print the `INTERFACE_LINK_LIBRARIES` exported by `FindMPI.cmake`
    to demonstrate the very handy `cmake_print_properties()` function:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到MPI，我们还打印由`FindMPI.cmake`导出的`INTERFACE_LINK_LIBRARIES`，以演示非常方便的`cmake_print_properties()`函数：
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let us first configure the code with the default MPI paralellization switched
    `ON`. Observe the output from `cmake_print_properties()`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用默认的MPI并行化开关`ON`配置代码。观察`cmake_print_properties()`的输出：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We compile and run the parallel example:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编译并运行并行示例：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, let us step one directory up, create a new build directory, and this time
    build the sequential version:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向上移动一个目录，创建一个新的构建目录，这次构建顺序版本：
- en: '[PRE81]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The build system for a project is generated by CMake in two phases: a configuration
    phase, where `CMakeLists.txt` is parsed, and a generation phase, where the build
    environment is actually generated. Generator expressions are evaluated in this
    second phase and can be used to tweak the build system with information that can
    only be known at generation time. Generator expressions are thus particularly
    useful when cross-compiling, where some of the information is only available after
    the `CMakeLists.txt` has been parsed, or in multi-configuration projects, where
    the build system is generated at once for all the different configurations the
    project can have, such as `Debug` and `Release`.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的构建系统由CMake在两个阶段生成：配置阶段，其中解析`CMakeLists.txt`，生成阶段，实际生成构建环境。生成器表达式在这个第二阶段评估，并可用于使用只能在生成时知道的信息调整构建系统。因此，生成器表达式在交叉编译时特别有用，其中一些信息只有在解析`CMakeLists.txt`后才可用，或者在多配置项目中，构建系统为项目的所有不同配置（如`Debug`和`Release`）一次性生成。
- en: 'In our case, we will use generator expressions to conditionally set a link
    dependency and compile definition. For this, we can focus on these two expressions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用生成器表达式来有条件地设置链接依赖和编译定义。为此，我们可以关注这两个表达式：
- en: '[PRE82]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If `MPI_FOUND` is true, then `$<BOOL:${MPI_FOUND}>` will evaluate to 1\. In
    this case, `$<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX>` will evaluate to `MPI::MPI_CXX`
    and the second generator expression will evaluate to `HAVE_MPI`. If we set `USE_MPI`
    to `OFF`, `MPI_FOUND` is false and both generator expressions evaluate to empty
    strings, and thus no link dependency is introduced and no preprocessor definition
    is set.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MPI_FOUND`为真，那么`$<BOOL:${MPI_FOUND}>`将评估为1。在这种情况下，`$<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX>`将评估为`MPI::MPI_CXX`，第二个生成器表达式将评估为`HAVE_MPI`。如果我们设置`USE_MPI`为`OFF`，`MPI_FOUND`为假，两个生成器表达式都将评估为空字符串，因此不会引入链接依赖，也不会设置预处理器定义。
- en: 'We could have achieved the same effect by introducing an if-statement:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入if语句来实现相同的效果：
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This solution is a bit less compact but possibly a bit more readable. We can
    often re-express if-statements using generator expressions and the choice is often
    a matter of taste. However, generator expressions particularly shine when we need
    to access or manipulate explicit file paths, since these can be difficult to construct
    using variables and if-clauses, and in this case we clearly favor generator expressions
    for readability. This was the case in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, where we used generator expressions to resolve the file path
    of a particular target. We will also appreciate generator expressions in [Chapter
    11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging Projects*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可能不那么紧凑，但可能更易读。我们经常可以使用生成器表达式重新表达if语句，选择通常是个人喜好的问题。然而，生成器表达式在需要访问或操作显式文件路径时特别有用，因为这些路径使用变量和if子句构造起来可能很困难，在这种情况下，我们明显倾向于使用生成器表达式以提高可读性。在[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*中，我们使用生成器表达式来解析特定目标的文件路径。在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*中，我们也会欣赏生成器表达式。
- en: There is more
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'CMake offers three types of generator expression:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了三种类型的生成器表达式：
- en: Logical expressions, with the basic pattern `$<condition:outcome>`. The basic
    conditions are `0` for false and `1` for true, but any Boolean can be used as
    a condition, provided that the correct keywords are used.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑表达式，基本模式为`$<condition:outcome>`。基本条件是`0`表示假，`1`表示真，但任何布尔值都可以用作条件，只要使用正确的关键字即可。
- en: Informational expression, with the basic pattern `$<information>` or `$<information:input>`.
    These expressions evaluate to some build system information, for example, include
    directories, target properties, and so forth. The input parameter to these expressions
    might be the name of a target, as in the expression `$<TARGET_PROPERTY:tgt,prop>`,
    where the information obtained will be the `prop` property on the `tgt` target.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息表达式，基本模式为`$<information>`或`$<information:input>`。这些表达式评估为某些构建系统信息，例如，包含目录，目标属性等。这些表达式的输入参数可能是目标的名称，如表达式`$<TARGET_PROPERTY:tgt,prop>`，其中获取的信息将是`tgt`目标的`prop`属性。
- en: Output expressions, with the basic pattern `$<operation>` or `$<operation:input>`.
    These expressions generate an output, possibly based on some input parameters.
    Their output can be used directly inside CMake commands or combined with other
    generator expressions. For example, `-I$<JOIN:$<TARGET_PROPERTY:INCLUDE_DIRECTORIES>,
    -I>` will generate a string containing the include directories for the target
    being processed, each prependend by `-I`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出表达式，基本模式为`$<operation>`或`$<operation:input>`。这些表达式生成输出，可能基于某些输入参数。它们的输出可以直接在CMake命令中使用，也可以与其他生成器表达式结合使用。例如，`-I$<JOIN:$<TARGET_PROPERTY:INCLUDE_DIRECTORIES>,
    -I>`将生成一个包含正在处理的目标的包含目录的字符串，每个目录前都添加了`-I`。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a full list of generator expressions, please consult [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如需查看生成器表达式的完整列表，请查阅[https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)。
