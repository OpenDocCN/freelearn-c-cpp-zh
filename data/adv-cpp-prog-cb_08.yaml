- en: Creating and Implementing Your Own Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现自己的容器
- en: In this chapter, you will learn how to create your own custom container in C++
    by leveraging an existing container that the C++ Standard Template Library already
    provides. This chapter is important because, in a lot of cases, your code will
    have common operations that are performed on a Standard Template Library container
    that are duplicated throughout the code (as is the case with implementing thread
    safety). The recipes in this chapter will teach you how to easily encapsulate
    this duplicated code into a custom container without having to write your own
    container from scratch or littering your code with duplicated logic that is hard
    to test and validate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过利用C++标准模板库已经提供的现有容器来创建自己的自定义容器。这一章很重要，因为在很多情况下，你的代码将对标准模板库容器执行常见操作，这些操作在整个代码中都是重复的（比如实现线程安全）。本章的食谱将教你如何将这些重复的代码轻松地封装到一个自定义容器中，而无需从头开始编写自己的容器，也不会在代码中散布难以测试和验证的重复逻辑。
- en: Throughout this chapter, you will learn the skills needed to implement a custom
    wrapper container, capable of ensuring that `std::vector` is maintained in sorted
    order at all times. The first recipe will teach you the basics of how to create
    this wrapper. The second recipe will expand upon the first, teaching you how to
    redefine the interface of a container based on how the container operates. In
    this case, since the container is always in sorted order, you will learn why providing
    a `push_back()` function doesn't make sense, even though all we are doing is creating
    a wrapper (the addition of the wrapper changes the concept of the container itself).
    In the third recipe you will learn the skills to work with iterators and why,
    in this example, `const` iterators can only be supported. Finally, we will add
    several additional APIs to our container to provide a complete implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，你将学习实现自定义包装器容器所需的技能，能够确保`std::vector`始终保持排序顺序。第一个食谱将教你如何创建这个包装器的基础知识。第二个食谱将在第一个基础上展开，教你如何根据容器的操作方式重新定义容器的接口。在这种情况下，由于容器始终是有序的，你将学习为什么提供`push_back()`函数是没有意义的，即使我们只是创建一个包装器（包装器的添加改变了容器本身的概念）。在第三个食谱中，你将学习使用迭代器的技能，以及为什么在这个例子中只能支持`const`迭代器。最后，我们将向我们的容器添加几个额外的API，以提供完整的实现。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱如下：
- en: Using a simple wrapper around std::vector
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的std::vector包装器
- en: Adding the relevant parts of the std::set API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加std::set API的相关部分
- en: Working with iterators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: Adding the relevant parts of the std::vector API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加std::vector API的相关部分
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, the reader must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, the reader must install the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，读者必须具有对运行Ubuntu 18.04的计算机的管理访问权限，并且有一个正常的互联网连接。在运行这些示例之前，读者必须安装以下内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08)找到。
- en: Using a simple wrapper around std::vector
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单的std::vector包装器
- en: In this recipe, we will learn how to create our own custom container by wrapping
    an existing Standard Template Library container to provide custom functionality
    as needed. In the later recipes, we will build upon this custom container to eventually
    create a complete container based on `std::vector`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何通过包装现有的标准模板库容器来创建自己的自定义容器，以提供所需的自定义功能。在后续的食谱中，我们将在这个自定义容器的基础上构建，最终创建一个基于`std::vector`的完整容器。
- en: This recipe is important because oftentimes, code that leverages an existing
    container is accompanied by common logic that is duplicated each time the container
    is used. This recipe (and this entire chapter) will teach you how to encapsulate
    this duplicated logic into your own container so that it can be independently
    tested.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱很重要，因为经常情况下，利用现有容器的代码伴随着每次使用容器时都会重复的常见逻辑。这个食谱（以及整个章节）将教会你如何将这些重复的逻辑封装到你自己的容器中，以便可以独立测试。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a terminal window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本食谱中示例的必要工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through the following steps to try out the recipe:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本食谱：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，你可以通过运行以下命令来执行本食谱中的每个示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each one does and how it relates to the lessons being taught in this recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步介绍每个示例，并解释每个示例的作用以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will learn how to create a simple wrapper container around
    `std::vector`. Most of the time, the **Standard Template Library** (**STL**) containers
    are sufficient to perform the tasks that your applications might need, and, in
    general, creating your own containers should be avoided as they are complicated
    to get right.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在`std::vector`周围创建一个简单的包装容器。大多数情况下，**标准模板库**（**STL**）容器足以执行应用程序可能需要的任务，通常应避免创建自己的容器，因为它们很难正确实现。
- en: From time to time, however, you might find yourself repeatedly performing the
    same actions on a container. When this occurs, it is often helpful to wrap these
    common operations into a wrapper container that can be independently unit tested
    to ensure that the container works as expected. For example, the STL containers
    are not thread safe. If you need a container to function with thread safety each
    time you access the container, you will first need to ensure that you have exclusive
    access to the container (for example, by locking a `std::mutex`) before the container
    operation can take place. This pattern will be repeated throughout your code,
    increasing the chances of entering deadlock. This issue can be prevented by creating
    a container wrapper that adds a `std::mutex` to each public member of the container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能会发现自己在容器上重复执行相同的操作。当发生这种情况时，将这些常见操作封装到一个包装容器中通常是有帮助的，可以独立进行单元测试，以确保容器按预期工作。例如，STL容器不是线程安全的。如果您需要一个容器在每次访问时都能够与线程安全一起使用，您首先需要确保您对容器有独占访问权限（例如，通过锁定`std::mutex`），然后才能进行容器操作。这种模式将在您的代码中重复出现，增加了进入死锁的机会。通过创建一个容器包装器，为容器的每个公共成员添加一个`std::mutex`，可以避免这个问题。
- en: 'In this recipe, let''s consider an example where we create a vector (that is,
    an array of elements in contiguous memory that you must have direct access to)
    that must remain in sorted order at all times. To start, we will need some headers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，让我们考虑一个例子，我们创建一个向量（即，在连续内存中有直接访问权限的元素数组），它必须始终保持排序状态。首先，我们需要一些头文件：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To implement our container, we will leverage `std::vector`. Although we could
    implement our own container from scratch, most of the time this is not needed,
    and should be avoided, as such a task is extremely time consuming and complicated.
    We will need the `algorithm` header for `std::sort` and `iostream` for testing.
    So let''s add this as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的容器，我们将利用`std::vector`。虽然我们可以从头开始实现自己的容器，但大多数情况下这是不需要的，应该避免，因为这样的任务非常耗时和复杂。我们将需要`algorithm`头文件用于`std::sort`和`iostream`用于测试。因此让我们添加如下内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The container's definition will start with its template definition, which is
    the same as the definition of the `std::vector` with an added `Compare` type that
    will be used to define the order in which we would like our container to be sorted.
    By default, the container will be sorted in ascending order, but this can be changed
    as needed. Finally, the container will have one private member variable that is
    an instance of the `std::vector` that this container is wrapping.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的定义将从其模板定义开始，与`std::vector`的定义相同，增加了一个`Compare`类型，用于定义我们希望容器排序的顺序。默认情况下，容器将按升序排序，但可以根据需要进行更改。最后，容器将有一个私有成员变量，即该容器包装的`std::vector`的实例。
- en: 'For the container to function properly with C++ utilities, template functions,
    and even some key language features, the container will need to define the same
    aliases as `std::vector`, shown as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使容器能够与C++工具、模板函数甚至一些关键语言特性正常工作，容器需要定义与`std::vector`相同的别名，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, there is no need to manually define the aliases ourselves. Instead,
    we can simply forward the declaration of the aliases from the `std::vector` itself.
    The exception to this is the `compare_type` alias, as this is an alias that we
    are adding to our wrapper container that represents the type used by the template
    class for the comparison operation that will ultimately be given to `std::sort`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们无需手动定义别名。相反，我们可以简单地从`std::vector`本身转发别名的声明。唯一的例外是`compare_type`别名，因为这是我们添加到包装容器中的一个别名，表示模板类用于比较操作的类型，最终将提供给`std::sort`。
- en: We also do not include the non-const versions of the reference aliases. The
    reason for this is that our container must keep the `std::vector` in sorted order
    at all times. If we provide the user with direct write access to the elements
    stored within `std::vector`, the user could put `std::vector` into an unordered
    state without our custom container having the ability to reorder as needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不包括引用别名的非const版本。原因是我们的容器必须始终保持`std::vector`处于排序状态。如果我们为用户提供对`std::vector`中存储的元素的直接写访问权限，用户可能会使`std::vector`处于无序状态，而我们的自定义容器无法按需重新排序。
- en: Next, let's define our constructors (which map to the same constructors that
    `std::vector` provides).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们的构造函数（与`std::vector`提供的相同构造函数相对应）。
- en: Default constructor
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: 'The following defines our default constructor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的默认构造函数的定义：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the default constructor for `std::vector` produces an empty vector, there
    is no additional logic that we must add as an empty vector is sorted by default.
    Next, we must define a constructor that takes a custom allocator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::vector`的默认构造函数产生一个空向量，我们不需要添加额外的逻辑，因为空向量默认是排序的。接下来，我们必须定义一个接受自定义分配器的构造函数。
- en: Custom allocator constructor
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义分配器构造函数
- en: 'Our custom allocator constructor is defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义分配器构造函数定义如下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with the previous constructor, this constructor creates an empty vector,
    but with an allocator that already exists.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个构造函数一样，这个构造函数创建一个空向量，但使用已经存在的分配器。
- en: Count constructors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数构造函数
- en: 'The next two constructors allow the user of the API to set the minimum size
    of the vector as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个构造函数允许API的用户设置向量的最小大小如下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first constructor will create the vector of `count` elements, all initialized
    with a value of `value`, while the second creates the elements with their default
    values (for example, a vector of integers would be initialized to zero).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数将创建一个包含`count`个元素的向量，所有元素都用`value`的值初始化，而第二个构造函数将使用它们的默认值创建元素（例如，整数向量将被初始化为零）。
- en: Copy/move constructors
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制/移动构造函数
- en: 'To support the ability to copy and move our container, we will need to implement
    a copy and move constructor as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复制和移动容器的能力，我们需要实现一个复制和移动构造函数，如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since our custom wrapper container must always remain in sorted order, copying
    or moving one container to another doesn't change the order of the elements in
    the container, meaning that no sort operation is needed for these constructors
    either. We do, however, take special care to ensure that a copy and a move occur
    properly by copying or moving the internal `std::vector` that our container encapsulates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的自定义包装容器必须始终保持排序顺序，因此将一个容器复制或移动到另一个容器不会改变容器中元素的顺序，这意味着这些构造函数也不需要进行排序操作。然而，我们需要特别注意确保通过复制或移动我们的容器封装的内部`std::vector`来正确进行复制或移动。
- en: 'For completeness, we also provide a move constructor that allows us, just like
    the `std::vector`, to move while providing a custom allocator, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还提供了一个移动构造函数，允许我们像`std::vector`一样在提供自定义分配器的同时移动。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will provide a constructor that takes an initializer list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供一个接受初始化列表的构造函数。
- en: Initializer list constructor
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化列表构造函数
- en: 'Finally, we will also add a constructor that takes an initializer list, as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将添加一个接受初始化列表的构造函数，如下所示：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown in the preceding code, the initializer list could provide the initial
    elements for the `std::vector` in any order. As a result, we must sort the list
    after the vector is initialized.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，初始化列表可以以任何顺序为`std::vector`提供初始元素。因此，我们必须在向量初始化后对列表进行排序。
- en: Usage
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: 'Let''s test this container to ensure that each constructor works as expected:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个容器，以确保每个构造函数都按预期工作：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As shown in the preceding code block, we test our constructors by calling each
    one, which results in the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码块所示，我们通过调用每个构造函数来测试它们，结果如下：
- en: '![](img/d05b7686-5517-4965-80e9-17420fc8564b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05b7686-5517-4965-80e9-17420fc8564b.png)'
- en: As you can see, each constructor was successfully executed as expected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个构造函数都成功按预期执行。
- en: Adding elements to our container
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向容器添加元素
- en: With our constructors in place, we will also need to provide the ability to
    manually add data to our container (for example, if we initially created our container
    using the default constructor).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数就位后，我们还需要提供手动向容器添加数据的能力（例如，如果我们最初使用默认构造函数创建了容器）。
- en: 'To start, let''s focus on the `push_back()` function that `std::vector` provides:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们专注于`std::vector`提供的`push_back()`函数：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the preceding code snippet, the `push_back()` function has the same
    function signatures as the version `std::vector` provides, allowing us to simply
    forward the function call to `std::vector`. The problem is, pushing a value to
    the end of `std::vector` could result in `std::vector` entering an unordered state,
    requiring us to reorder `std::vector` on every single push (the result of requiring
    `std::vector` to remain in sorted order at all times).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`push_back()`函数具有与`std::vector`提供的版本相同的函数签名，允许我们简单地将函数调用转发到`std::vector`。问题是，向`std::vector`的末尾添加值可能导致`std::vector`进入无序状态，需要我们在每次推送时重新排序`std::vector`（要求`std::vector`始终保持排序状态的结果）。
- en: One way to resolve this issue is by adding another member variable to the container
    wrapper that tracks when the `std::vector` is tainted. Another way to implement
    these functions is to add the elements in a sorted order (that is, traverse the
    vector sorted order and place the element in the proper position, shifting the
    remaining elements as needed). If elements are rarely added to the `std::vector`,
    then this approach might outperform a call to `std::sort`. If, however, elements
    are added to the `std::vector` a lot, then the tainted approach might perform
    better.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是向容器包装器添加另一个成员变量，用于跟踪`std::vector`何时被污染。实现这些函数的另一种方法是按排序顺序添加元素（即按照排序顺序遍历向量并将元素放在适当的位置，根据需要移动剩余元素）。如果很少向`std::vector`添加元素，那么这种方法可能比调用`std::sort`更有效。然而，如果向`std::vector`频繁添加元素，那么污染的方法可能表现更好。
- en: One of the key benefits of creating a container wrapper is that these types
    of optimizations can be implemented and tested without changing the code that
    relies on the container itself. Both implementations (or others) can be implemented,
    tested, and compared to determine which optimization is best suited to your particular
    needs, while the code that uses the container never changes. Not only does this
    declutter the code, but this added encapsulation strikes at the heart of object-oriented
    design, ensuring that each object in your code has only one purpose. In the case
    of the container wrapper, the purpose is to encapsulate the operation of maintaining `std::vector`
    in sorted order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建容器包装器的一个关键优势是，可以实现和测试这些类型的优化，而不必更改依赖于容器本身的代码。可以实现、测试和比较这两种实现（或其他实现），以确定哪种优化最适合您的特定需求，而使用容器的代码永远不会改变。这不仅使代码更清晰，而且这种增加的封装打击了面向对象设计的核心，确保代码中的每个对象只有一个目的。对于容器包装器来说，其目的是封装维护`std::vector`的排序顺序的操作。
- en: 'For completeness, we will also add the `emplace_back()` version of `push_back()`,
    just like `std::vector`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还将添加`push_back()`的`emplace_back()`版本，就像`std::vector`一样：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The difference with the `emplace_back()` function compared to the `std::vector`
    equivalent is that our version does not return a reference to the element created.
    This is because of the fact that the sort would invalidate the reference, making
    it impossible to return a valid reference.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::vector`等效的`emplace_back()`函数的区别在于，我们的版本不返回对创建的元素的引用。这是因为排序会使引用无效，从而无法返回有效的引用。
- en: Usage of push/emplace
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: push/emplace的用法
- en: 'Finally, let''s test our `push_back()` and `emplace` functions to ensure that
    they are called properly, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试我们的`push_back()`和`emplace`函数，以确保它们被正确调用，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the preceding code snippet, we call each version of `push_back()`
    as well as the `emplace_back()` function to ensure that they are properly called
    as expected, which results in the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们调用了`push_back()`的每个版本以及`emplace_back()`函数，以确保它们被正确调用，结果如下：
- en: '![](img/51e13fb0-f3e4-460b-8109-137c99e246ed.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e13fb0-f3e4-460b-8109-137c99e246ed.png)'
- en: 'We can take this a step further and add better test data to our test container,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步添加更好的测试数据到我们的测试容器，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As shown in the preceding code snippet, we add the integers `4`, `42`, `15`,
    `8`, `23`, and `16` to our vector. In the next recipe, we will steal APIs from
    `std::set` to provide better `push` and `emplace` APIs to our container, as well
    as an output function to get a better idea of what `std::vector` contains and
    the order in which it contains its elements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们向我们的向量添加整数`4`、`42`、`15`、`8`、`23`和`16`。在下一个示例中，我们将从`std::set`中窃取API，以提供更好的`push`和`emplace`API给我们的容器，以及一个输出函数，以更好地了解`std::vector`包含的内容以及其包含元素的顺序。
- en: Adding the relevant parts of the std::set API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向std::set API添加相关部分
- en: In this recipe, we will learn how to add APIs from `std::set` to the custom
    container we created in the first recipe. Specifically, we will learn why `std::vector::push_back()`
    and `std::vector::emplace_back()` do not make sense when used with our custom
    container that always maintains its internal elements in sorted order.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何从`std::set`中添加API到我们在第一个示例中创建的自定义容器。具体来说，我们将学习为什么`std::vector::push_back()`和`std::vector::emplace_back()`在与始终保持内部元素排序顺序的自定义容器一起使用时是没有意义的。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a terminal window:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Go through the following steps to try out the recipe:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试这个示例：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To compile the source code, run the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码，运行以下命令：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步介绍每个示例，并解释每个示例程序的作用，以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first recipe of this chapter, we created a custom container wrapper that
    mimics a `std::vector`, but which ensures that elements in the vector remain in
    sorted order at all times, including the addition of the `std::vector::push_back()`
    function and the `std::vector::emplace_back()` function. In this recipe, we will
    add the `std::set::insert()` and `std::set::emplace()` functions to our custom
    container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个示例中，我们创建了一个自定义容器包装器，模拟了`std::vector`，但确保向量中的元素始终保持排序顺序，包括添加`std::vector::push_back()`函数和`std::vector::emplace_back()`函数。在本示例中，我们将向我们的自定义容器添加`std::set::insert()`和`std::set::emplace()`函数。
- en: Since our container wrapper always ensures that `std::vector` is in sorted order,
    there is no difference between adding an element to the front, back, or middle
    of the vector. No matter which position an element is added to the vector, it
    must be sorted prior to the vector being accessed, which means that the order
    in which the element is added will likely change regardless of which position
    it is added in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的容器包装器始终确保`std::vector`处于排序状态，因此无论将元素添加到向量的前端、后端还是中间，都没有区别。无论将元素添加到向量的哪个位置，都必须在访问向量之前对其进行排序，这意味着无论将元素添加到哪个位置，其添加顺序都可能会发生变化。
- en: 'This lack of concern for where an element is added is similar to that of `std::set`.
    The `std::set` adds elements to a set, and then later returns `true` or `false`,
    depending on whether the element being tested is a member of the set. The `std::set`
    provides the `insert()` and `emplace()` functions for adding elements to the set.
    Let''s add these same APIs to our custom container, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于添加元素的位置，我们不必担心，这与`std::set`类似。`std::set`向集合添加元素，然后根据被测试的元素是否是集合的成员，稍后返回`true`或`false`。`std::set`提供了`insert()`和`emplace()`函数来向集合添加元素。让我们向我们的自定义容器添加这些API，如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see in the preceding code snippet, we have added an `insert()` function
    (both the copy and the move), as well as an `emplace()` function, which does nothing
    more than call their `push_back()` and `emplace_back()` equivalents, ensuring
    that the parameters passed to these functions are properly forwarded. The only
    difference between these APIs and the APIs that we added in the previous recipe, *Using
    a simple wrapper around std::vector*, is the name of the function itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们添加了一个`insert()`函数（包括复制和移动），以及一个`emplace()`函数，它们只是调用它们的`push_back()`和`emplace_back()`等效函数，确保正确转发传递给这些函数的参数。这些API与我们在上一个教程中添加的API之间唯一的区别是函数本身的名称。
- en: Although such a change might seem trivial, this is important as it redefines
    the concept between the container's APIs with the user. The `push_back()` and
    `emplace_back()` functions suggest that the element is added to the back of the
    vector when, in fact, it is not. Instead, they are simply added to the `std::vector`,
    and the order of the `std::vector` is changed based on the value of the element
    added. For this reason, the `push_back()` and `emplace_back()` functions are needed,
    but should either be renamed or marked as private to ensure that the user only
    uses the `insert()` and `emplace()` versions to properly manage expectations.
    When writing your own containers (even for wrappers), it is important that you
    adhere to the principle of least surprise, which ensures that the APIs that a
    user is using will work the way that the APIs might suggest.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样的改变可能看起来微不足道，但这对于重新定义容器的API与用户之间的概念是很重要的。`push_back()`和`emplace_back()`函数表明元素被添加到向量的末尾，但实际上并非如此。相反，它们只是简单地添加到`std::vector`中，并且`std::vector`的顺序会根据添加的元素值而改变。因此，需要`push_back()`和`emplace_back()`函数，但应将它们重命名或标记为私有，以确保用户只使用`insert()`和`emplace()`版本来正确管理期望。在编写自己的容器时（即使是包装器），重要的是要遵循最少惊讶原则，以确保用户使用的API将按照API可能暗示的方式工作。
- en: Working with iterators
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: In this recipe, we will learn how to add iterator support to the custom container
    we started in the first recipe, which wraps a `std::vector`, ensuring that its
    contents remain in sorted order at all times.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何为我们在第一个教程中开始的自定义容器添加迭代器支持，该容器包装了一个`std::vector`，确保其内容始终保持排序顺序。
- en: To add iterator support, we will learn how to forward the iterators already
    provided by the `std::vector` (we will not be implementing iterators from scratch
    as that is a topic way outside the scope of this book, as implementing a container
    from scratch is incredibly difficult).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加迭代器支持，我们将学习如何转发`std::vector`已提供的迭代器（我们不会从头开始实现迭代器，因为这超出了本书的范围，从头开始实现容器非常困难）。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a terminal window:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的正确工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'You need to go through the following steps to try out this recipe:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本教程，需要按照以下步骤进行：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新终端运行以下命令以下载源代码：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To compile the source code, run the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: The `std::vector` that our custom container wraps already provides an efficient
    implementation of iterators that can be used to work with our container. We will,
    however, need to forward specific parts of the APIs that `std::vector` provides
    to ensure the iterators work properly, including key C++ features, such as range-based
    for loops.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义容器包装的`std::vector`已经提供了一个有效的迭代器实现，可以用于处理我们的容器。但是，我们需要转发`std::vector`提供的特定部分API，以确保迭代器正常工作，包括关键的C++特性，如基于范围的for循环。
- en: 'To start, let''s add the last remaining constructor that `std::vector` provides
    to our custom container:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的自定义容器添加`std::vector`提供的最后一个剩余构造函数：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As shown in the preceding code snippet, the iterator type that we are given
    is not defined. The iterator could come from another instance of our container
    or it could come from `std::vector` directly, which does not store its elements
    in sorted order. Even if the iterator came from an instance of our custom container,
    the order in which the iterator stores elements might not be the same as the order
    of the container elements. As a result, we must sort `std::vector` after it is
    initialized.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们得到的迭代器类型未定义。迭代器可以来自我们容器的另一个实例，也可以直接来自`std::vector`，后者不会按排序顺序存储其元素。即使迭代器来自我们自定义容器的一个实例，迭代器存储元素的顺序可能与容器元素的顺序不同。因此，我们必须在初始化后对`std::vector`进行排序。
- en: 'In addition to construction, it is important that our custom container also
    includes the iterator-based alias that `std::vector` provides, as these aliases
    are required for the container to properly work with C++ APIs. The following is
    an example code snippet for it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造之外，我们的自定义容器还必须包括`std::vector`提供的基于迭代器的别名，因为这些别名对于容器与C++ API的正确工作是必需的。以下是一个示例代码片段：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As shown in the preceding code snippet, like the aliases defined in the first
    recipe, we only need to forward declare the aliases that the `std::vector` already
    provided so that our custom container can leverage them as well. The difference
    is that we do not include the non-const versions of these iterator aliases. Since
    our custom container must leave the data in sorted order at all times, we must
    restrict the user's ability to modify the iterator's contents directly as this
    could result in changing the order of the container's elements, without the ability
    for our container to reorder as needed. Instead, modifications to the container
    should be made through the use of `insert()`, `emplace()`, and `erase()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的代码片段所示，与第一个示例中定义的别名一样，我们只需要前向声明`std::vector`已经提供的别名，以便我们的自定义容器也可以利用它们。不同之处在于，我们不包括这些迭代器别名的非const版本。由于我们的自定义容器必须始终保持有序，我们必须限制用户直接修改迭代器内容的能力，因为这可能导致更改容器元素的顺序，而我们的容器无法根据需要重新排序。相反，对容器的修改应通过使用`insert()`、`emplace()`和`erase()`来进行。
- en: C++ template-based functions rely on these aliases to properly implement their
    features, which also include range-based for loops.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基于C++模板的函数依赖于这些别名来正确实现它们的功能，这也包括基于范围的for循环。
- en: 'Finally, there are a series of member functions, based on iterators, that `std::vector`
    provides that should also be forwarded through our custom container. The following
    code depicts this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一系列基于迭代器的成员函数，`std::vector`提供了这些函数，也应该通过我们的自定义容器进行转发。以下代码描述了这一点：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first set of member functions are the `begin()` functions, which provide
    an iterator representing the first element in the `std::vector`. As with the aliases,
    we do not forward the non-const versions of these member functions. In addition,
    we include the `c` versions of these functions for completeness. In C++17, these
    are optional, as you can use `std::as_const()` instead if preferred. The next
    set of iterators is the `end()` iterators, which provide an iterator that represents
    the end of the `std::vector` (not to be confused with the iterator that represents
    the last element in the `std::vector`). The following code shows this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组成员函数是`begin()`函数，它提供表示`std::vector`中第一个元素的迭代器。与别名一样，我们不转发这些成员函数的非const版本。此外，出于完整性考虑，我们包括这些函数的`c`版本。在C++17中，这些是可选的，如果愿意，可以使用`std::as_const()`代替。接下来的迭代器是`end()`迭代器，它提供表示`std::vector`末尾的迭代器（不要与表示`std::vector`中最后一个元素的迭代器混淆）。以下代码显示了这一点：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in the preceding code snippet, and as with most of these member functions,
    we simply need to forward the APIs to the private `std::vector` that our custom
    container encapsulates. This same process can be repeated for `rbegin()`, and
    `rend()`, which provide the same APIs as earlier, but return a reverse iterator,
    which traverses the `std::vector` in reverse order.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的代码片段所示，与大多数这些成员函数一样，我们只需要将API转发到我们的自定义容器封装的私有`std::vector`。这个过程也可以重复用于`rbegin()`和`rend()`，它们提供与之前相同的API，但返回一个反向迭代器，以相反的顺序遍历`std::vector`。
- en: 'Next, we implement the iterator-based `emplace()` function, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现基于迭代器的`emplace()`函数，如下所示：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although providing the `emplace()` API provides a more complete implementation,
    it should be noted that it would only be useful if further optimizations were
    made to take advantage of the intended position in the way the element is added
    to the container. This is in combination with a better approach to sorting the
    `std::vector`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管提供`emplace()` API提供了更完整的实现，但应该注意的是，只有在进一步优化以利用元素添加到容器的预期位置的方式时，它才会有用。这与更好地排序`std::vector`的方法相结合。
- en: Although the preceding implementation works, it is likely to perform similarly
    to the version of `emplace()` we implemented in the first recipe. Since the custom
    container always remains in sorted order, where the element is inserted into the
    `std::vector` is irrelevant as the new order of the `std::vector` will change
    the position of the element being added. This is, of course, unless the addition
    of the position argument provides some additional support to the API to better
    optimize the addition, which our implementation doesn't do. For this reason, unless
    the `pos` argument is used for optimizations, the preceding function is likely
    redundant and unnecessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的实现是有效的，但它可能与我们在第一个示例中实现的`emplace()`版本表现类似。由于自定义容器始终保持排序顺序，因此将元素插入`std::vector`的位置是无关紧要的，因为`std::vector`的新顺序将改变添加元素的位置。当然，除非位置参数的添加提供了一些额外的支持来更好地优化添加，而我们的实现没有这样做。因此，除非使用`pos`参数进行优化，前面的函数可能是多余且不必要的。
- en: Like the previous `emplace()` functions, we do not attempt to return the iterator
    that represents the element that was added to the container, as this iterator
    becomes invalid after the sort, and there isn't enough information about what
    was added to the `std::vector` to relocate the iterator (for example, if duplicates
    exist, there is no way to know which element was actually just added).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的`emplace()`函数一样，我们不尝试返回表示添加到容器的元素的迭代器，因为在排序后，此迭代器将变为无效，并且关于添加到`std::vector`的内容的信息不足以重新定位迭代器（例如，如果存在重复项，则无法知道实际添加的是哪个元素）。
- en: 'Finally, we implement the `erase` functions, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了`erase`函数，如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Unlike the `emplace()` function, removing an element from the `std::vector`
    does not change the order of the `std::vector`, so no sort is needed. It should
    also be noted that our version of the `erase()` functions return the `const` versions.
    Once again, this is because we cannot support the non-const versions of the iterators.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与`emplace()`函数不同，从`std::vector`中移除元素不会改变`std::vector`的顺序，因此不需要排序。还应该注意的是，我们的`erase()`函数版本返回`const`版本。再次强调，这是因为我们无法支持迭代器的非const版本。
- en: 'Finally, now that we have the ability to access the elements stored in the
    container, let''s create some test logic to ensure that our container works as
    expected:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们有能力访问容器中存储的元素，让我们创建一些测试逻辑，以确保我们的容器按预期工作：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To start, we will create a container from an initializer list that contains
    integers with no order. After this container is created, the `std::vector` that
    is storing these elements should be in sorted order. To prove this, let''s loop
    through the container and output the results:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从不带顺序的整数初始化列表创建一个容器。创建完容器后，存储这些元素的`std::vector`应该是有序的。为了证明这一点，让我们循环遍历容器并输出结果：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As shown in the preceding code snippet, we start by outputting a label to `stdout`
    and then we use a ranged-based for loop to iterate over our container, outputting
    each element one at a time. Finally, we output a new line after all of the elements
    have been outputted to `stdout`, which results in the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们首先向`stdout`输出一个标签，然后使用范围for循环遍历我们的容器，逐个输出每个元素。最后，在所有元素都输出到`stdout`后，我们输出一个新行，导致以下输出：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This output is in sorted order, as expected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出按预期的顺序排序。
- en: 'It should be noted that our ranged for loop must define each element as `const`.
    This is because we do not support the non-const versions of the iterators. Any
    attempt to use the non-const versions of these iterators would result in a compiler
    error, as in the following example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们的范围for循环必须将每个元素定义为`const`。这是因为我们不支持迭代器的非const版本。任何尝试使用这些迭代器的非const版本都会导致编译错误，如下例所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code results in the following compiler error (which is intended):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致以下编译错误（这是预期的）：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The reason that this compiler error occurs is because the ranged for loop can
    also be written as the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这种编译错误的原因是因为范围for循环也可以写成以下形式：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown in the preceding code snippet, the element is not labeled as `const`,
    as the ranged for loop uses the `begin()` and `end()` member functions, resulting
    in a read-write iterator (unless you explicitly state `const`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，元素未标记为`const`，因为范围for循环使用`begin()`和`end()`成员函数，导致读写迭代器（除非您明确声明为`const`）。
- en: 'We can also create a test for our new `emplace()` function, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的新`emplace()`函数创建一个测试，如下所示：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This results in the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in the preceding output, the number `1` was added to our container
    in sorted order, even though we told the container to add our element to the end
    of the `std::vector`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，数字`1`按预期的顺序被添加到我们的容器中，即使我们告诉容器将我们的元素添加到`std::vector`的末尾。
- en: 'We can also reverse the preceding operation and validate that our `erase()`
    functions work properly, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以反转上述操作并验证我们的`erase()`函数是否正常工作，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This results in the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the newly added `1` has successfully been removed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新添加的`1`已成功被移除。
- en: Adding the relevant parts of the std::vector API
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加std::vector API的相关部分
- en: In this recipe, we will complete the custom container that we have been building
    in the first three recipes of this chapter by adding the remaining APIs that the
    `std::vector` already provides. Along the way, we will remove the APIs that do
    not make sense, or that we cannot support because our custom container must keep
    the elements in the `std::vector` in sorted order.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将通过添加`std::vector`已经提供的剩余API来完成我们在本章前三个示例中构建的自定义容器。在此过程中，我们将删除不合理的API，或者我们无法支持的API，因为我们的自定义容器必须保持`std::vector`中的元素有序。
- en: This recipe is important as it will show you how to properly create a wrapper
    container that can be used to encapsulate an existing container with logic that
    is needed from the container (for example, thread-safety, or in our case, element
    order).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本文很重要，因为它将向您展示如何正确创建一个包装容器，该容器可用于封装现有容器的逻辑（例如，线程安全，或者在我们的情况下，元素顺序）。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a terminal window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本文示例所需的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through the following steps to try out the recipe:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本文：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令来下载源代码：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To compile the source code, run the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本文中的每个示例：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将逐个介绍每个示例，并解释每个示例程序的作用以及它与本文教授的课程的关系。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Currently, our custom container is capable of being constructed, added to,
    iterated over, and erased. The container does not, however, support the ability
    to directly access the container or support simple operations, such as a `std::move()`
    or comparison. To address these issues, let''s start by adding the `operator=()`
    overloads that are missing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的自定义容器能够被构建、添加、迭代和擦除。然而，该容器不支持直接访问容器或支持简单操作，比如`std::move()`或比较。为了解决这些问题，让我们首先添加缺失的`operator=()`重载：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first `operator=()` overload provides support for a copy assignment, while
    the second overload provides support for a move assignment. Since we only have
    a single private member variable that already provides proper copy and move semantics,
    we do not need to worry about self assignment (or moving), as the `std::vector` function's
    implementation of copy and move will handle this for us.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`operator=()`重载支持复制赋值，而第二个重载支持移动赋值。由于我们只有一个提供适当复制和移动语义的私有成员变量，我们不需要担心自赋值（或移动），因为`std::vector`函数的复制和移动实现会为我们处理这个问题。
- en: 'If your own custom containers have additional private elements, self-assignment
    checks are likely needed. For example, consider the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己的自定义容器有额外的私有元素，可能需要进行自赋值检查。例如，考虑以下代码：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The remaining `operator=()` overload takes an initializer list, shown as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的`operator=()`重载接受一个初始化列表，如下所示：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As shown in the preceding code snippet, like the initializer list constructor,
    we must reorder the `std::vector` after the assignment, as the initializer list
    could be provided in any order.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，与初始化列表构造函数一样，我们必须在赋值后重新排序`std::vector`，因为初始化列表可以以任何顺序提供。
- en: 'The next member functions to implement are the `assign()` functions. The following
    code snippet shows this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现的下一个成员函数是`assign()`函数。以下代码片段显示了这一点：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'These functions are similar to the `operator=()` overloads, but do not provide
    return values or support additional functionality. Let''s see how:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数类似于`operator=()`重载，但不提供返回值或支持其他功能。让我们看看：
- en: The first `assign()` function fills the `std::vector` with a specific `value` count
    number of times. Since the value never changes, the `std::vector` will always
    be in sorted order, in which case there is no need to sort the list.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`assign()`函数用特定的`value`次数填充`std::vector`。由于值永远不会改变，`std::vector`将始终按排序顺序排列，在这种情况下，不需要对列表进行排序。
- en: The second `assign()` function takes an iterator range similar to the constructor
    version of this function. Like that function, the iterator that is passed to this
    function could come from a raw `std::vector` or another instance of our custom
    container, but with a different sort order. For this reason, we must sort the
    `std::vector` after assignment.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`assign()`函数接受与构造函数版本相似的迭代器范围。与该函数类似，传递给此函数的迭代器可以来自原始`std::vector`或我们自定义容器的另一个实例，但排序顺序不同。因此，我们必须在赋值后对`std::vector`进行排序。
- en: Finally, the `assign()` function also provides an initializer list version that
    is the same as our `operator=()` overload.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`assign()`函数还提供了与我们的`operator=()`重载相同的初始化列表版本。
- en: It should also be noted that we have added `constexpr` to each of our functions.
    This is because most of the functions in our custom container do nothing more
    than forward a call from the custom container to the `std::vector`, and, in some
    cases, make a call to `std::sort()`. The addition of `constexpr` tells the compiler
    to treat the code as a compile-time expression, enabling it to optimize out the
    additional function call when optimizations are enabled (if possible), ensuring
    that our custom wrapper has the smallest possible overhead.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意到，我们已经为每个函数添加了`constexpr`。这是因为我们自定义容器中的大多数函数只是将调用从自定义容器转发到`std::vector`，并且在某些情况下调用`std::sort()`。添加`constexpr`告诉编译器将代码视为编译时表达式，使其能够在启用优化时（如果可能）优化掉额外的函数调用，确保我们的自定义包装器具有尽可能小的开销。
- en: In the past, this type of optimization was performed using the `inline` keyword.
    The `constexpr`, which was added in C++11, is not only capable of providing `inline`
    hints to the compiler, but it also tells the compiler that this function can be
    used at compile time instead of runtime (meaning that the compiler can execute
    the function while the code is being compiled to perform custom compile-time logic).
    In our example here, however, the runtime use of a `std::vector` is not possible
    as allocations are needed. As a result, the use of `constexpr` is simply for optimizations,
    and, on most compilers, the `inline` keyword would provide a similar benefit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，这种优化是使用`inline`关键字执行的。在C++11中添加的`constexpr`不仅能够向编译器提供`inline`提示，还告诉编译器这个函数可以在编译时而不是运行时使用（这意味着编译器可以在代码编译时执行函数以执行自定义的编译时逻辑）。然而，在我们的例子中，`std::vector`的运行时使用是不可能的，因为需要分配。因此，使用`constexpr`只是为了优化，在大多数编译器上，`inline`关键字也会提供类似的好处。
- en: 'There are a number of additional functions that the `std::vector` also supports,
    such as `get_allocator()`, `empty()`, `size()`, and `max_size()`, all of which
    are just direct forwards. Let''s focus on the accessors that, until now, have
    been missing from our custom container:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`还支持许多其他函数，例如`get_allocator()`、`empty()`、`size()`和`max_size()`，所有这些都只是直接转发。让我们专注于直到现在为止从我们的自定义容器中缺失的访问器：'
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first function that we provide to access the `std::vector` directly is the
    `at()` function. As with most of our member functions, this is a direct forward.
    Unlike a `std::vector`, however, we have no plans to add the `operator[]()` overloads
    that a `std::vector` provides. The difference between the `at()` function and
    the `operator[]()` overload is that the `operator[]()` does not check to ensure
    that the index that is provided is in bounds (that is, that it does not access
    elements outside the bounds of the `std::vector`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的第一个直接访问`std::vector`的函数是`at()`函数。与我们的大多数成员函数一样，这是一个直接转发。但与`std::vector`不同的是，我们没有计划添加`std::vector`提供的`operator[]()`重载。`at()`函数和`operator[]()`重载之间的区别在于，`operator[]()`不会检查提供的索引是否在范围内（也就是说，它不会访问`std::vector`范围之外的元素）。
- en: The `operator[]()` overload is designed to function similarly to a standard
    C array. The problem with this operator (called the subscript operator) is that
    the lack of a bounds check opens the door for reliability and security bugs to
    make their way into your program. For this reason, the C++ core guidelines discourage
    the use of the subscript operator or any other forms of pointer arithmetic (anything
    that attempts to calculate the position of data through the use of a pointer without
    an explicit bounds check).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator[]()`重载的设计类似于标准C数组。这个运算符（称为下标运算符）的问题在于缺乏边界检查，这为可靠性和安全性错误进入程序打开了大门。因此，C++核心指南不鼓励使用下标运算符或任何其他形式的指针算术（任何试图通过指针计算数据位置而没有显式边界检查的东西）。'
- en: To prevent the use of the `operator[]()` overload from being used, we do not
    include it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止使用`operator[]()`重载，我们不包括它。
- en: 'Like `std::vector`, we can also add the `front()` and `back()` accessors as
    follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 像`std::vector`一样，我们也可以添加`front()`和`back()`访问器，如下所示：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding additional accessors provide support for getting the first and
    last elements in our `std::vector`. As with the `at()` function, we only support
    the use of the `const_reference` versions of these functions that the `std::vector`
    already provides.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的额外访问器支持获取我们的`std::vector`中的第一个和最后一个元素。与`at()`函数一样，我们只支持`std::vector`已经提供的这些函数的`const_reference`版本的使用。
- en: 'Let''s now see the code snippet `data()` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`data()`函数的代码片段：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The same goes for the `data()` function. We can only support the `const` versions
    of these member functions, as providing the non-const versions of these functions
    would provide the user direct access to the `std::vector`, allowing them to insert
    unordered data without the container having the ability to reorder as needed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`函数也是一样的。我们只能支持这些成员函数的`const`版本，因为提供这些函数的非const版本将允许用户直接访问`std::vector`，从而使他们能够插入无序数据，而容器无法重新排序。'
- en: Let's now focus on the comparison operators. We start by defining the comparison
    operator's prototypes as friends of our container. This is needed as the comparison
    operators are typically implemented as non-member functions, and, as a result,
    will need private access to the container to compare the instances of `std::vector` that
    they contain.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于比较运算符。我们首先定义比较运算符的原型，作为我们容器的友元。这是必要的，因为比较运算符通常被实现为非成员函数，因此需要对容器进行私有访问，以比较它们包含的`std::vector`实例。
- en: 'For example, consider the following code snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码片段：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we implement the comparison operators as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式实现比较运算符：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As with the member functions, we only need to forward the calls to the `std::vector`,
    as there is no need to implement custom logic. The same applies to the remaining
    comparison operators.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与成员函数一样，我们只需要将调用转发到`std::vector`，因为没有必要实现自定义逻辑。剩下的比较运算符也是一样。
- en: 'For example, we can implement the `>`, `<`, `>=`, and `<=` comparison operators
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以按照以下方式实现`>`、`<`、`>=`和`<=`比较运算符：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That is it! That is how you implement your own container by leveraging an existing
    container.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这就是通过利用现有容器来实现自己的容器的方法。
- en: As we saw, in most cases, there is no need to implement a container from scratch
    unless the container you need cannot be implemented using one of the containers
    that the C++ Standard Template Library already provides.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在大多数情况下，除非你需要的容器无法使用C++标准模板库已经提供的容器来实现，否则没有必要从头开始实现一个容器。
- en: Using this approach, it is possible to not only create your own containers,
    but, more importantly, it is possible to encapsulate functionality that is duplicated
    throughout your code into a single container that can be independently tested
    and verified. This not only improves the reliability of your applications, but
    it makes them easier to read and maintain as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，不仅可以创建自己的容器，更重要的是可以将代码中重复的功能封装到一个单独的容器中，这样可以独立测试和验证。这不仅提高了应用程序的可靠性，而且还使其更易于阅读和维护。
- en: In the next chapter, we will explore how to use smart pointers in C++.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在C++中使用智能指针。
