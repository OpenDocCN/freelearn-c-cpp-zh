["```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter09\n```", "```cpp\n> cmake .\n> make recipe01_examples\n```", "```cpp\n> ./recipe01_example01 \n1\n0\n```", "```cpp\nint array[10];\nmemset(array, 0, sizeof(array));\n```", "```cpp\nvoid *memset(void *ptr, int value, size_t num)\n{\n    size_t i;\n    for (i = 0; i < num; i++) {\n        ((char *)ptr)[i] = value;    \n    }\n\n    return ptr;\n}\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int) const\n    {\n        return x == 0 ? true : false;\n    }\n};\n```", "```cpp\nclass captain_america\n{\npublic:\n    bool attack(int, int y) const\n    {\n        return y == 0 ? true : false;\n    }\n};\n```", "```cpp\n    for (const auto &h : heroes) {\n        std::cout << h->attack(0, 42) << '\\n';\n    }\n```", "```cpp\nclass hero\n{\npublic:\n    virtual ~hero() = default;\n    virtual bool attack(int, int) const = 0;\n};\n```", "```cpp\nclass spiderman : public hero\n{\npublic:\n    bool attack(int x, int) const override\n    {\n        return x == 0 ? true : false;\n    }\n};\n\nclass captain_america : public hero\n{\npublic:\n    bool attack(int, int y) const override\n    {\n        return y == 0 ? true : false;\n    }\n};\n```", "```cpp\nint main(void)\n{\n    std::array<std::unique_ptr<hero>, 2> heros {\n        std::make_unique<spiderman>(),\n        std::make_unique<captain_america>()\n    };\n\n    for (const auto &h : heros) {\n        std::cout << h->attack(0, 42) << '\\n';\n    }\n\n    return 0;\n}\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter09\n```", "```cpp\n> cmake .\n> make recipe02_examples\n```", "```cpp\n> ./recipe02_example01 \nhero won fight\nhero lost the fight :(\n```", "```cpp\ntemplate<typename T>\nT pow2(T t)\n{\n    return t * t;\n}\n```", "```cpp\nstd::cout << pow2(42U) << '\\n'\nstd::cout << pow2(-1) << '\\n'\n```", "```cpp\nunsigned pow2(unsigned t)\n{\n    return t * t;\n}\n\nint pow2(int t)\n{\n    return t * t;\n}\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int) const\n    {\n        return x == 0 ? true : false;\n    }\n};\n\nclass captain_america\n{\npublic:\n    bool attack(int, int y) const\n    {\n        return y == 0 ? true : false;\n    }\n};\n```", "```cpp\ntemplate<typename T>\nauto attack(const T &t, int x, int y)\n{\n    if (t.attack(x, y)) {\n        std::cout << \"hero won fight\\n\";\n    }\n    else {\n        std::cout << \"hero lost the fight :(\\n\";\n    }\n}\n```", "```cpp\nint main(void)\n{\n    attack(spiderman{}, 0, 42);\n    attack(captain_america{}, 0, 42);\n\n    return 0;\n}\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter09\n```", "```cpp\n> cmake .\n> make recipe03_examples\n```", "```cpp\n> ./recipe03_example01 \n1\n0\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int) const\n    {\n        return x == 0 ? true : false;\n    }\n};\n\nclass captain_america\n{\npublic:\n    bool attack(int, int y) const\n    {\n        return y == 0 ? true : false;\n    }\n};\n```", "```cpp\nfor (const auto &h : heros) {\n    // something\n}\n```", "```cpp\n    std::array<void *, 2> heros {\n        new spiderman,\n        new captain_america\n    };\n\n    for (const auto &h : heros) {\n        if (ptr = dynamic_cast<spiderman>(ptr)) {\n            // something\n        }\n\n        if (ptr = dynamic_cast<captain_america>(ptr)) {\n            // something\n        }\n    }\n```", "```cpp\nclass base\n{\npublic:\n    virtual ~base() = default;\n    virtual bool attack(int, int) const = 0;\n};\n```", "```cpp\ntemplate<typename T>\nclass wrapper :\n    public base\n{\n    T m_t;\n\npublic:\n    bool attack(int x, int y) const override\n    {\n        return m_t.attack(x, y);\n    }\n};\n```", "```cpp\n    std::array<std::unique_ptr<base>, 2> heros {\n        std::make_unique<wrapper<spiderman>>(),\n        std::make_unique<wrapper<captain_america>>()\n    };\n```", "```cpp\n    for (const auto &h : heros) {\n        std::cout << h->attack(0, 42) << '\\n';\n    }\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter09\n```", "```cpp\n> cmake .\n> make recipe04_examples\n```", "```cpp\n> ./recipe04_example01\n1\n0\n\n> ./recipe04_example02\n1\n0\n\n> ./recipe04_example03\n1\n0\n\n> ./recipe04_example04\n0\n1\n0\n```", "```cpp\nint main(void)\n{\n    spiderman s;\n    captain_america c;\n\n    std::array<delegate<bool(int, int)>, 3> heros {\n        delegate(attack),\n        delegate(&s, &spiderman::attack),\n        delegate(&c, &captain_america::attack)\n    };\n\n    for (auto &h : heros) {\n        std::cout << h(0, 42) << '\\n';\n    }\n\n    return 0;\n}\n```", "```cpp\ntemplate<\n    typename RET,\n    typename... ARGS\n    >\nclass base\n{\npublic:\n    virtual ~base() = default;\n    virtual RET func(ARGS... args) = 0;\n};\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\nclass wrapper :\n    public base<RET, ARGS...>\n{\n    T m_t{};\n    RET (T::*m_func)(ARGS...);\n\npublic:\n\n    wrapper(RET (T::*func)(ARGS...)) :\n        m_func{func}\n    { }\n\n    RET func(ARGS... args) override\n    {\n        return std::invoke(m_func, &m_t, args...);\n    }\n};\n```", "```cpp\ntemplate<\n    typename RET,\n    typename... ARGS\n    >\nclass delegate\n{\n    std::unique_ptr<base<RET, ARGS...>> m_wrapper;\n\npublic:\n\n    template<typename T>\n    delegate(RET (T::*func)(ARGS...)) :\n        m_wrapper{\n            std::make_unique<wrapper<T, RET, ARGS...>>(func)\n        }\n    { }\n\n    RET operator()(ARGS... args)\n    {\n        return m_wrapper->func(args...);\n    }\n};\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int)\n    {\n        return x == 0 ? true : false;\n    }\n};\n\nclass captain_america\n{\npublic:\n    bool attack(int, int y)\n    {\n        return y == 0 ? true : false;\n    }\n};\n```", "```cpp\nint main(void)\n{\n    std::array<delegate<bool, int, int>, 2> heros {\n        delegate(&spiderman::attack),\n        delegate(&captain_america::attack)\n    };\n\n    for (auto &h : heros) {\n        std::cout << h(0, 42) << '\\n';\n    }\n\n    return 0;\n}\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\ndelegate(RET(T::*)(ARGS...)) -> delegate<RET(ARGS...)>;\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int)\n    {\n        return x == 0 ? true : false;\n    }\n};\n```", "```cpp\nclass spiderman\n{\npublic:\n    bool attack(int x, int) const\n    {\n        return x == 0 ? true : false;\n    }\n};\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\nclass wrapper_const :\n    public base<RET, ARGS...>\n{\n    T m_t{};\n    RET (T::*m_func)(ARGS...) const;\n\npublic:\n\n    wrapper_const(RET (T::*func)(ARGS...) const) :\n        m_func{func}\n    { }\n\n    RET func(ARGS... args) override\n    {\n        return std::invoke(m_func, &m_t, args...);\n    }\n};\n```", "```cpp\n    template<typename T>\n    delegate(RET (T::*func)(ARGS...) const) :\n        m_wrapper{\n            std::make_unique<wrapper_const<T, RET, ARGS...>>(func)\n        }\n    { }\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\ndelegate(RET(T::*)(ARGS...) const) -> delegate<RET(ARGS...)>;\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\nclass wrapper :\n    public base<RET, ARGS...>\n{\n    const T *m_t{};\n    RET (T::*m_func)(ARGS...);\n\npublic:\n\n    wrapper(const T *t, RET (T::*func)(ARGS...)) :\n        m_t{t},\n        m_func{func}\n    { }\n\n    RET func(ARGS... args) override\n    {\n        return std::invoke(m_func, m_t, args...);\n    }\n};\n```", "```cpp\n    template<typename T>\n    delegate(const T *t, RET (T::*func)(ARGS...)) :\n        m_wrapper{\n            std::make_unique<wrapper<T, RET, ARGS...>>(t, func)\n        }\n    { }\n```", "```cpp\ntemplate<\n    typename T,\n    typename RET,\n    typename... ARGS\n    >\ndelegate(const T *, RET(T::*)(ARGS...)) -> delegate<RET(ARGS...)>;\n```", "```cpp\nint main(void)\n{\n    spiderman s;\n    captain_america c;\n\n    std::array<delegate<bool(int, int)>, 2> heros {\n        delegate(&s, &spiderman::attack),\n        delegate(&c, &captain_america::attack)\n    };\n\n    for (auto &h : heros) {\n        std::cout << h(0, 42) << '\\n';\n    }\n\n    return 0;\n}\n```", "```cpp\nbool attack(int x, int y)\n{\n    return x == 42 && y == 42 ? true : false;\n}\n```", "```cpp\ntemplate<\n    typename RET,\n    typename... ARGS\n    >\nclass fun_wrapper :\n    public base<RET, ARGS...>\n{\n    RET (*m_func)(ARGS...);\n\npublic:\n\n    fun_wrapper(RET (*func)(ARGS...)) :\n        m_func{func}\n    { }\n\n    RET func(ARGS... args) override\n    {\n        return m_func(args...);\n    }\n};\n```", "```cpp\n    delegate(RET (func)(ARGS...)) :\n        m_wrapper{\n            std::make_unique<fun_wrapper<RET, ARGS...>>(func)\n        }\n    { }\n```", "```cpp\ntemplate<\n    typename RET,\n    typename... ARGS\n    >\ndelegate(RET(*)(ARGS...)) -> delegate<RET(ARGS...)>;\n```", "```cpp\nint main(void)\n{\n    spiderman s;\n    captain_america c;\n\n    std::array<delegate<bool(int, int)>, 3> heros {\n        delegate(attack),\n        delegate(&s, &spiderman::attack),\n        delegate(&c, &captain_america::attack)\n    };\n\n    for (auto &h : heros) {\n        std::cout << h(0, 42) << '\\n';\n    }\n\n    return 0;\n}\n```"]