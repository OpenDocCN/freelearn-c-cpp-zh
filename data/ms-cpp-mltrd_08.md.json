["```cpp\ntype __sync_fetch_and_add (type *ptr, type value, ...) \ntype __sync_fetch_and_sub (type *ptr, type value, ...) \ntype __sync_fetch_and_or (type *ptr, type value, ...) \ntype __sync_fetch_and_and (type *ptr, type value, ...) \ntype __sync_fetch_and_xor (type *ptr, type value, ...) \ntype __sync_fetch_and_nand (type *ptr, type value, ...) \n\n```", "```cpp\ntype __sync_add_and_fetch (type *ptr, type value, ...) \ntype __sync_sub_and_fetch (type *ptr, type value, ...) \ntype __sync_or_and_fetch (type *ptr, type value, ...) \ntype __sync_and_and_fetch (type *ptr, type value, ...) \ntype __sync_xor_and_fetch (type *ptr, type value, ...) \ntype __sync_nand_and_fetch (type *ptr, type value, ...) \n\n```", "```cpp\nbool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...) \ntype __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...) \n\n```", "```cpp\n__sync_synchronize (...) \n\n```", "```cpp\ntype __sync_lock_test_and_set (type *ptr, type value, ...) \n\n```", "```cpp\nvoid __sync_lock_release (type *ptr, ...) \n\n```", "```cpp\ntype __atomic_load_n (type *ptr, int memorder) \nvoid __atomic_load (type *ptr, type *ret, int memorder) \nvoid __atomic_store_n (type *ptr, type val, int memorder) \nvoid __atomic_store (type *ptr, type *val, int memorder) \ntype __atomic_exchange_n (type *ptr, type val, int memorder) \nvoid __atomic_exchange (type *ptr, type *val, type *ret, int memorder) \nbool __atomic_compare_exchange_n (type *ptr, type *expected, type desired, bool weak, int success_memorder, int failure_memorder) \nbool __atomic_compare_exchange (type *ptr, type *expected, type *desired, bool weak, int success_memorder, int failure_memorder) \n\n```", "```cpp\ntype __atomic_add_fetch (type *ptr, type val, int memorder) \ntype __atomic_sub_fetch (type *ptr, type val, int memorder) \ntype __atomic_and_fetch (type *ptr, type val, int memorder) \ntype __atomic_xor_fetch (type *ptr, type val, int memorder) \ntype __atomic_or_fetch (type *ptr, type val, int memorder) \ntype __atomic_nand_fetch (type *ptr, type val, int memorder) \n\n```", "```cpp\ntype __atomic_fetch_add (type *ptr, type val, int memorder) \ntype __atomic_fetch_sub (type *ptr, type val, int memorder) \ntype __atomic_fetch_and (type *ptr, type val, int memorder) \ntype __atomic_fetch_xor (type *ptr, type val, int memorder) \ntype __atomic_fetch_or (type *ptr, type val, int memorder) \ntype __atomic_fetch_nand (type *ptr, type val, int memorder) \n\n```", "```cpp\nbool __atomic_test_and_set (void *ptr, int memorder) \n\n```", "```cpp\nvoid __atomic_clear (bool *ptr, int memorder) \n\n```", "```cpp\nvoid __atomic_thread_fence (int memorder) \n\n```", "```cpp\nvoid __atomic_signal_fence (int memorder) \n\n```", "```cpp\nbool __atomic_always_lock_free (size_t size, void *ptr) \n\n```", "```cpp\nbool __atomic_is_lock_free (size_t size, void *ptr) \n\n```", "```cpp\n#include <iostream> \n#include <thread> \n#include <atomic> \n\nstd::atomic<long long> count; \nvoid worker() { \n         count.fetch_add(1, std::memory_order_relaxed); \n} \n\nint main() { \n         std::thread t1(worker); \n         std::thread t2(worker); \n         std::thread t3(worker); \n         std::thread t4(worker); \n         std::thread t5(worker); \n\n         t1.join(); \n         t2.join(); \n         t3.join(); \n         t4.join(); \n         t5.join(); \n\n         std::cout << \"Count value:\" << count << '\\n'; \n} \n\n```", "```cpp\n#include <string> \n#include <thread> \n#include <vector> \n#include <iostream> \n#include <atomic> \n#include <numeric> \n\nconst int N = 10000; \nstd::atomic<int> cnt; \nstd::vector<int> data(N); \n\nvoid reader(int id) { \n         for (;;) { \n               int idx = atomic_fetch_sub_explicit(&cnt, 1, std::memory_order_relaxed); \n               if (idx >= 0) { \n                           std::cout << \"reader \" << std::to_string(id) << \" processed item \" \n                                       << std::to_string(data[idx]) << '\\n'; \n               }  \n         else { \n                           std::cout << \"reader \" << std::to_string(id) << \" done.\\n\"; \n                           break; \n               } \n         } \n} \n\nint main() { \n         std::iota(data.begin(), data.end(), 1); \n         cnt = data.size() - 1; \n\n         std::vector<std::thread> v; \n         for (int n = 0; n < 10; ++n) { \n               v.emplace_back(reader, n); \n         } \n\n         for (std::thread& t : v) { \n               t.join(); \n         } \n} \n\n```", "```cpp\nenum memory_order { \n    memory_order_relaxed, \n    memory_order_consume, \n    memory_order_acquire, \n    memory_order_release, \n    memory_order_acq_rel, \n    memory_order_seq_cst \n}; \n\n```"]