- en: Virtual Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟现实
- en: '**Virtual Reality** (**VR**) is a very popular topic in game development these
    days. In this chapter, we will take a look at how the power of C++ can be leveraged
    to create an immersive VR experience. It should be noted that while the SDK used
    for the example integration is available for macOS, the hardware and example code
    presented in this chapter has not been tested on macOS and is not guaranteed to
    be supported. It should also be noted that you will need a VR headset and a significantly
    powerful PC and graphics card to run this chapter''s closing example. It is recommend
    that you have a CPU that matches or exceeds an Intel i5-4590 or AMD FX 8350, and
    a GPU that matches or exceeds an NVIDIA GeForce GTX 960 or AMD Radeon R9 290\.
    In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟现实**（**VR**）是当今游戏开发中非常热门的话题。在本章中，我们将看看如何利用C++的强大功能来创建沉浸式的VR体验。需要注意的是，虽然用于示例集成的SDK可用于macOS，但本章中介绍的硬件和示例代码尚未在macOS上进行测试，也不能保证支持。还需要注意的是，您需要一台VR头戴式显示器和一台性能强大的PC和显卡来运行本章的示例。建议您拥有与英特尔i5-4590或AMD
    FX 8350相匹配或超过的CPU，以及与NVIDIA GeForce GTX 960或AMD Radeon R9 290相匹配或超过的GPU。在本章中，我们将涵盖以下主题：'
- en: Current VR hardware
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前VR硬件
- en: VR rendering concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VR渲染概念
- en: Headset SDKs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头戴式显示器SDK
- en: Implementing VR support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施VR支持
- en: Quick VR overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速VR概述
- en: VR is a computer technology that uses various forms of hardware to generate
    a simulation of the user's physical presence in a reconstructed or imaginary environment
    through the use of realistic imagery, sounds, and other sensations. A user that
    is in a VR environment is able to look around the artificial world, and with new
    advances in VR technology, move around in it and interact with virtual items or
    objects. While VR technology can date back to the 1950s, with recent advancements
    in computer graphics, processing, and power, VR has seen a resurgence. Well-known
    technology giants such as Facebook, Sony, Google, and Microsoft have bet big on
    virtual and augmented reality technologies. Not since the invention of the mouse
    has the way users interact with computers had such potential for innovation. Use
    cases for VR stretch beyond just game development. Many other fields are looking
    to VR technologies as a way to expand their own unique interactions. Healthcare,
    education, training, engineering, social sciences, marketing, and of course cinema
    and entertainment all hold promising opportunities for developers that possess
    the skill sets learned throughout this book and in game development in general.
    I often recommend that game developers looking for a change of pace, or a new
    challenge, look to the emerging VR development scene as an alternative use for
    their knowledge and skills base.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: VR是一种计算机技术，利用各种形式的硬件通过逼真的图像、声音和其他感觉来生成用户在重建或虚构环境中的物理存在的模拟。处于VR环境中的用户能够环顾周围的人工世界，并且随着VR技术的新进展，还能在其中移动并与虚拟物品或对象进行交互。虽然VR技术可以追溯到20世纪50年代，但随着计算机图形、处理和性能的最新进展，VR技术已经出现了复苏。著名的科技巨头，如Facebook、索尼、谷歌和微软，都在虚拟和增强现实技术上进行了大笔投资。自鼠标发明以来，用户与计算机的交互方式从未有过如此大的创新潜力。VR的用例不仅限于游戏开发。许多其他领域都希望利用VR技术来扩展他们自己独特的交互方式。医疗保健、教育、培训、工程、社会科学、营销，当然还有电影和娱乐，都为具有本书和游戏开发中学到的技能集的开发人员提供了有前途的机会。我经常建议寻求改变步调或新挑战的游戏开发人员，将目光投向新兴的VR开发领域，作为他们知识和技能基础的替代用途。
- en: Current VR hardware
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前VR硬件
- en: As developers, we are in a very fortunate time period of VR hardware development.
    There are many different options when it comes to VR hardware, including projected
    systems such as the **Cave Automatic Virtual Environment** (**CAVE**), **head-mounted
    displays** (**HMDs**), and even mobile phone based systems such as the Google
    Daydream and Cardboard. Here we will focus on immersive PC and console driven
    HMDs. Most of the technologies behind these HMDs are very similar. Each of the
    HMDs listed here have at least **s****ix degrees of freedom** (**6DOF**) in terms
    of movement, head tracking in 3D space, and some even have basic spatial awareness,
    often referred to as *room sense*. Development for each of these headsets can,
    at a high level, be approached in much the same way, but it is good to have a
    general understanding of each of these different devices. Next, we will take a
    quick look at some of the most common headsets currently available to the consumer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们正处于VR硬件开发的非常幸运的时期。在VR硬件方面有许多不同的选择，包括投影系统，如**CAVE**，**头戴式显示器**（**HMDs**），甚至基于手机的系统，如Google
    Daydream和Cardboard。在这里，我们将重点关注沉浸式PC和主机驱动的HMDs。这些HMD背后的大部分技术都非常相似。这里列出的每个HMD在运动方面至少有**六个自由度**（**6DOF**），即在3D空间中的头部跟踪，并且一些甚至具有基本的空间意识，通常称为*房间感知*。对于这些头戴式显示器的开发，从高层次上来说，可以以类似的方式进行，但了解每个不同设备的基本情况是很有必要的。接下来，我们将快速浏览目前消费者可以获得的一些最常见的头戴式显示器。
- en: Oculus Rift CV1
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oculus Rift CV1
- en: 'Originally starting out as a crowd funded project, the Oculus Rift has become
    one of the most popular headsets currently available. The Oculus Rift has seen
    a few iterations. The first and second hardware releases were geared towards developers
    (the DK1 and DK2). Upon purchase of the Oculus startup by Facebook, the social
    media giant released the first commercial version of the hardware known as the
    **Consumer Version 1** (**CV1**). While supported on the **Steam** gaming platform,
    the Oculus is very much tied to its own launcher and software platform. The headset
    currently only supports PC development:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最初作为众筹项目开始，Oculus Rift已成为目前最受欢迎的头戴式显示器之一。Oculus Rift已经推出了几个版本。最初的两个硬件发布是面向开发人员的（DK1和DK2）。在Facebook收购Oculus后，这家社交媒体巨头发布了硬件的第一个商用版本，称为**消费者版本1**（**CV1**）。虽然在**Steam**游戏平台上受到支持，但Oculus与自己的启动器和软件平台紧密相连。该头戴式显示器目前仅支持PC开发：
- en: '![](img/233cdd18-da4f-49ba-aaf2-df46b2c88dad.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/233cdd18-da4f-49ba-aaf2-df46b2c88dad.png)'
- en: 'The following are the features of Oculus Rift CV1:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Oculus Rift CV1的特点：
- en: '**Screen type**: AMOLED'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕类型**：AMOLED'
- en: '**Resolution**: 1080 x 1200 per eye'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：每只眼睛1080 x 1200'
- en: '**Field of view**: ~110⁰'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：~110⁰'
- en: '**Head tracking**: IMU (compass, accelerometer, gyroscope), IR optical tracing'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部跟踪**：IMU（指南针、加速计、陀螺仪），红外光学跟踪'
- en: 'The minimum recommended PC specifications are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最低推荐的PC规格如下：
- en: '**GPU**: NVIDIA GeForce GTX 970 or AMD Radeon R9 290'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU**：NVIDIA GeForce GTX 970或AMD Radeon R9 290'
- en: '**CPU**: Intel i5-4590 or AMD FX 8350'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：Intel i5-4590或AMD FX 8350'
- en: '**RAM**: 8 GB'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：8 GB'
- en: '**OS**: Windows 7'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：Windows 7'
- en: HTC Vive
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTC Vive
- en: 'Arguably the most popular headset currently available, the HTC Vive was created
    by HTC (a smartphone and tablet manufacturer) and the Valve corporation (a gaming
    company, best known for the Steam game platform). Often compared directly to the
    Oculus Rift, the HTC Vive does share many similarities in design, with slight
    differences that, in many developers'' minds, make the HTC Vive the superior piece
    of hardware:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说是目前最受欢迎的头戴式显示器，HTC Vive是由HTC（一家智能手机和平板电脑制造商）和Valve公司（一家以Steam游戏平台闻名的游戏公司）共同创建的。与Oculus
    Rift直接比较，HTC Vive在设计上有许多相似之处，但在许多开发人员看来，略有不同之处使HTC Vive成为更优秀的硬件：
- en: '![](img/7c31b745-88c6-4288-b02e-d2871d5f1be2.jpg)![](img/520be352-da41-4fa4-9afe-90559bc7d79b.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c31b745-88c6-4288-b02e-d2871d5f1be2.jpg)![](img/520be352-da41-4fa4-9afe-90559bc7d79b.jpg)'
- en: 'The following are the features of HTC Vive:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTC Vive的特点：
- en: '**Screen type**: AMOLED'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕类型**：AMOLED'
- en: '**Resolution**: 1080 x 1200 per eye'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：每只眼睛1080 x 1200'
- en: '**Field of view**: 110⁰'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：110⁰'
- en: '**Head tracking**: IMU (compass, accelerometer, gyroscope), 2 IR base stations'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部跟踪**：IMU（指南针、加速计、陀螺仪），2个红外基站'
- en: 'The minimum recommended PC specifications are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最低推荐的PC规格如下：
- en: '**GPU**: NVIDIA GeForce GTX 970 or AMD Radeon R9 290'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU**：NVIDIA GeForce GTX 970或AMD Radeon R9 290'
- en: '**CPU**: Intel i5-4590 or AMD FX 8350'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：Intel i5-4590或AMD FX 8350'
- en: '**RAM**: 4 GB'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：4 GB'
- en: '**OS**: Windows 7, Linux'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：Windows 7，Linux'
- en: Open Source Virtual Reality (OSVR) development kit
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源虚拟现实（OSVR）开发套件
- en: 'Another very interesting hardware option is the OSVR kit, developed by Razer
    and Sensics. What makes the OSVR unique is that it is an open licensed, non-proprietary
    hardware platform and ecosystem. This gives developers lots of freedom when designing
    their AR/VR experiences. OSVR is also a software framework, which we will cover
    shortly. The framework, like the hardware, is open licence and designed to be
    cross-platform:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的硬件选择是由雷蛇和Sensics开发的OSVR套件。 OSVR的独特之处在于它是一个开放许可、非专有硬件平台和生态系统。这使得开发人员在设计其AR/VR体验时有很大的自由度。OSVR也是一个软件框架，我们很快会介绍。该框架与硬件一样，是开放许可的，旨在跨平台设计：
- en: '![](img/1155357a-8f9e-40d5-af16-a4ce34315a52.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1155357a-8f9e-40d5-af16-a4ce34315a52.jpg)'
- en: 'The following are the features of OSVR:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是OSVR的特点：
- en: '**Screen type**: AMOLED'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕类型：AMOLED
- en: '**Resolution**: 960 x 1080 per eye'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：每只眼睛960 x 1080'
- en: '**Field of view**: 100⁰'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：100⁰'
- en: '**Head tracking**: IMU (compass, accelerometer, gyroscope), IR optical tracing'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部跟踪**：IMU（指南针、加速计、陀螺仪），红外光学跟踪'
- en: 'The minimum recommended PC specifications are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最低推荐的PC规格如下：
- en: '**GPU**: NVIDIA GeForce GTX 970 or AMD Radeon R9 290'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU**：NVIDIA GeForce GTX 970或AMD Radeon R9 290'
- en: '**CPU**: Intel i5-4590 or AMD FX 8350'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：Intel i5-4590或AMD FX 8350'
- en: '**RAM**: 4 GB'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：4 GB'
- en: '**OS**: Cross-platform support'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：跨平台支持'
- en: Sony PlayStation VR
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索尼 PlayStation VR
- en: 'Originally referred to as **Project Morpheus**, the Sony PlayStation VR is
    the Sony corporation''s entry to the VR space. Unlike the other headsets in this
    list, the Sony PlayStation VR headset is not driven by a PC, but instead connects
    to the Sony PlayStation 4 gaming console. While not the highest fidelity or most
    technically advanced, by using the PS4 as its platform, the Sony PlayStation VR
    headset has a 30 million plus console base available:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最初被称为**Project Morpheus**，索尼 PlayStation VR是索尼公司进入VR领域的产品。与此列表中的其他头戴式显示器不同，索尼
    PlayStation VR头戴式显示器不是由PC驱动，而是连接到索尼PlayStation 4游戏主机。通过使用PS4作为其平台，索尼PlayStation
    VR头戴式显示器有3000多万的游戏主机用户：
- en: '![](img/38bde5a4-a6e8-407b-b44f-30801ab071cf.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38bde5a4-a6e8-407b-b44f-30801ab071cf.jpg)'
- en: 'The following are the features of Sony PlayStation VR:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是索尼 PlayStation VR的特点：
- en: '**Screen type**: AMOLED'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕类型**：AMOLED'
- en: '**Resolution**: 960 x 1080 per eye'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：每只眼睛960 x 1080'
- en: '**Field of view**: ~100⁰'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：~100⁰'
- en: '**Head tracking**: IMU (compass, accelerometer, gyroscope), IR optical tracing'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部跟踪**：IMU（指南针、加速计、陀螺仪），红外光学跟踪'
- en: '**Console hardware**: Sony PlayStation 4'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台硬件**：索尼 PlayStation 4'
- en: Windows Mixed Reality headsets
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Mixed Reality头戴式显示器
- en: 'One of the newest entries into the VR hardware space is the Windows Mixed Reality
    enabled group of headsets. While not a single headset design, Windows Mixed Reality
    has a set of specifications and software support that enables VR from the Windows
    10 desktop. Referred to as **Mixed Reality** (**MR**), the unique feature of these
    headsets is their built-in spatial awareness or room sense. Other headsets, such
    as the Oculus Rift and the HTC Vive, support similar features, but unlike the
    Windows MR devices, they require extra hardware to support tracking. This lack
    of extra hardware means that the Windows MR headsets should be simpler to set
    up and have the potential to make PC-powered VR experiences more portable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最新进入VR硬件领域的是Windows Mixed Reality启用的一组头戴式显示器。虽然不是单一的头戴式显示器设计，但Windows Mixed
    Reality具有一套规格和软件支持，可以从Windows 10桌面实现VR。被称为**混合现实**（**MR**），这些头戴式显示器的独特功能是其内置的空间感知或房间感知。其他头戴式显示器，如Oculus
    Rift和HTC Vive，支持类似的功能，但与Windows MR设备不同，它们需要额外的硬件来支持跟踪。这种缺乏额外硬件意味着Windows MR头戴式显示器应该更容易设置，并有可能使PC供电的VR体验更加便携：
- en: '![](img/7b8ab8b2-99a6-4c0a-a83a-8a28695a7fb8.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b8ab8b2-99a6-4c0a-a83a-8a28695a7fb8.jpg)'
- en: 'The following are the features of Windows MR headsets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Windows MR头戴式显示器的特点：
- en: '**Screen type**: Various'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕类型**：各种'
- en: '**Resolution**: Various'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：各种'
- en: '**Field of view**: Various'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：各种'
- en: '**Head tracking**: 9DoF inside out headset-based tracking system'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部跟踪**：基于头戴式内部9DoF追踪系统'
- en: 'The minimum recommended PC specifications are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最低推荐的PC规格如下：
- en: '**GPU**: NVIDIA GeForce GTX 960, AMD Radeon RX 460 or integrated Intel HD Graphics
    620'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU**：NVIDIA GeForce GTX 960，AMD Radeon RX 460或集成的Intel HD Graphics 620'
- en: '**CPU**: Intel i5-4590 or AMD FX 8350'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：Intel i5-4590或AMD FX 8350'
- en: '**RAM**: 8 GB'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：8 GB'
- en: '**OS**: Windows 10'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：Windows 10'
- en: VR rendering concepts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR渲染概念
- en: Looking at VR from a rendering point of view, it quickly becomes apparent that
    VR poses some unique challenges. This is due in part to some necessary performance
    benchmarks that need to be achieved and the current limitations of rendering hardware.
    When rendering VR content, it is necessary to render at a higher resolution than
    standard high definition, often twice or more. The rendering also needs to be
    extremely quick, with frame rates of 90 fps or higher per eye being the benchmark.
    This, combined with the use of anti-aliasing and sampling techniques, means that
    rendering a VR scene requires upwards of five times the computation power of a
    standard game running at 1080p with 60 fps. In the upcoming sections, we will
    cover some of the key differences when rendering VR content, and touch on some
    concepts that you can implement to retain performance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从渲染的角度来看VR，很快就会发现VR提出了一些独特的挑战。这部分是由于需要达到一些必要的性能基准和当前渲染硬件的限制。在渲染VR内容时，需要以比标准高清更高的分辨率进行渲染，通常是两倍或更多。渲染还需要非常快速，每只眼睛的帧率达到90帧或更高是基准。这，再加上抗锯齿和采样技术的使用，意味着渲染VR场景需要比以1080p分辨率以60帧每秒运行的标准游戏多五倍的计算能力。在接下来的章节中，我们将介绍在渲染VR内容时的一些关键区别，并涉及一些你可以实施以保持性能的概念。
- en: Working with frusta
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视锥体
- en: 'The biggest difference when developing a VR ready engine is understanding how
    to build a proper, clipped, view frustum when dealing with more than one viewpoint.
    In a typical non-VR game, you have a single view point (camera), from which you
    create a view frustum. Refer back to earlier in the book if you need a complete
    refresher, but this view frustum determines what will be rendered and ultimately
    displayed on screen to the user. The following is a diagram depicting a typical
    view frustum:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发VR就绪引擎时最大的区别在于理解如何在处理多个视点时构建适当的、裁剪的视锥体。在典型的非VR游戏中，你有一个单一的视点（摄像头），从中创建一个视锥体。如果需要完整的复习，请参考本书早些时候的内容，但这个视锥体决定了将被渲染并最终显示在屏幕上给用户的内容。以下是一个典型视锥体的图示：
- en: '![](img/09ce5ebe-8a4b-42a3-9907-400cfc948b74.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09ce5ebe-8a4b-42a3-9907-400cfc948b74.png)'
- en: 'When rendering in VR, you have at least one frustum per eye, commonly displaying
    to single HMD in stereoscopic, meaning there are a pair of images displayed on
    a single screen, allowing for the illusion of depth. Often these images are depicting
    the left and right eye view of the scene. What this means is that we must take
    into consideration the position of both *eye* frusta and produce a final view
    frustum for rendering by combining them both. The following is a diagram depiction
    of these view frusta:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR渲染时，每只眼睛至少有一个视锥体，通常显示在单个头戴式显示器上，意味着在单个屏幕上显示一对图像，从而产生深度的错觉。通常这些图像描绘了场景的左眼和右眼视图。这意味着我们必须考虑两只眼睛的位置，并通过结合它们来产生最终的渲染视锥体。以下是这些视锥体的图示：
- en: '![](img/7feba28c-0c2e-47e8-8980-0bd056436155.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7feba28c-0c2e-47e8-8980-0bd056436155.png)'
- en: 'When it comes to the creation of a single frustum that combines both the left
    and right eye frusta, it is actually quite easy. As depicted in the following
    diagram, you need to place the vertex of the new frustum between both of the eyes
    and slightly behind them. You then move the near clipping plane position so that
    it is aligned with either of the eye frustum''s clipping planes. This is important
    for the final display **frustum culling**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个结合了左右眼视锥体的单个视锥体时，实际上是非常容易的。如下图所示，你需要将新视锥体的顶点放在两只眼睛之间并略微向后移动。然后移动近裁剪平面的位置，使其与任一眼睛视锥体的裁剪平面对齐。这对于最终的显示**视锥体剔除**是很重要的。
- en: '![](img/820bfde5-6d8c-4ea7-9574-32035e768475.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/820bfde5-6d8c-4ea7-9574-32035e768475.png)'
- en: 'You can calculate this frustum with some simple math using the **interpupillary
    distance** (**IPD**), as demonstrated perfectly in the following diagram by Cass
    Everitt from the Oculus Rift team:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些简单的数学计算来计算这个视锥体，使用**瞳距**（**IPD**）来演示，正如Oculus Rift团队的Cass Everitt在以下图示中所展示的：
- en: '![](img/e8cbe7fd-05cc-48cb-862d-f9af0cf32b60.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8cbe7fd-05cc-48cb-862d-f9af0cf32b60.png)'
- en: We could also simplify this procedure by simply culling against the shared eye
    frusta top and bottom planes. While not technically forming a perfect frustum,
    using a culling algorithm that tests a single plane at a given time will produce
    the desired effect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过简单地对共享眼睛视锥体的顶部和底部平面进行剔除来简化这个过程。虽然在技术上并不形成完美的视锥体，但使用一个测试单个平面的剔除算法将产生期望的效果。
- en: The good news is most of this can be abstracted away, and in many headset SDKs
    there are methods to help you. It is, however, important to understand the difference
    between how frusta is used when compared to standard non-VR scene rendering.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是大部分可以被抽象化，而且在许多头戴式显示器SDK中都有方法来帮助你。然而，重要的是要理解在非VR场景渲染中，视锥体的使用方式与VR中的不同。
- en: Increasing rendering performance
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高渲染性能
- en: When working with a single camera and view point, as with most non-VR games,
    we can simply treat the rendering process as one step within our engine. When
    working with multiple view points, this is different. We could, of course, just
    treat each view point as a single rendering task, processing one after the other,
    but this is would result in a slow-performing renderer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单个摄像头和视点时，就像大多数非VR游戏一样，我们可以简单地将渲染过程视为引擎内的一个步骤。但是当使用多个视点时，情况就不同了。当然，我们可以将每个视点视为一个单独的渲染任务，依次处理，但这会导致渲染速度慢。
- en: 'As shown in the previous section, there is quite an overlap between what each
    *eye* sees. This provides us with the perfect opportunity to optimize our rendering
    process by sharing and reusing data. To do this, we can implement the concept
    of **data context**. Using this concept, we can classify which elements exist
    uniquely for a single eye, and which elements can be shared. Let''s take a look
    at these data contexts and how we can use them to speed up our rendering:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，每只眼睛看到的内容有很大的重叠。这为我们提供了通过共享和重用数据来优化我们的渲染过程的绝佳机会。为此，我们可以实现**数据上下文**的概念。使用这个概念，我们可以对哪些元素是唯一适用于单只眼睛进行分类，哪些元素可以共享进行分类。让我们看看这些数据上下文以及如何使用它们来加快我们的渲染速度：
- en: '**Frame context**: Simply put, the frame context is used for any element that
    needs to be rendered and is view-orientation independent. This would include elements
    such as skyboxes, global reflections, water textures, and so on. Anything that
    can be shared across view points can be placed in this context.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧上下文**：简而言之，帧上下文用于任何需要被渲染且与视角无关的元素。这将包括诸如天空盒、全局反射、水纹理等元素。任何可以在视点之间共享的东西都可以放在这个上下文中。'
- en: '**Eye context**: This is the context for elements that cannot be shared between
    view points. This would include any element that needs stereo disparity when rendering.
    It is also in this context that we could store per eye data that would be used
    in our shader computations.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**眼睛上下文**：这是不能在视点之间共享的元素的上下文。这将包括在渲染时需要立体视差的任何元素。我们还可以在这个上下文中存储每只眼睛的数据，这些数据将在我们的着色器计算中使用。'
- en: 'Using this simple separation of data into different contexts, we could then
    reorganize our rendering process to look similar to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据简单地分成不同的上下文，我们可以重新组织我们的渲染过程，使其看起来类似于以下内容：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this appears on the surface to be basic, it is a very powerful concept.
    By separating the rendering in this manner and sharing what we can, we are greatly
    increasing the performance of our renderer overall. This is one of the simplest
    optimizations with one of the biggest returns. We can also carry this over to
    how we set up our shader uniforms, breaking them into context pieces:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在表面上看起来很基本，但这是一个非常强大的概念。通过以这种方式分离渲染并共享我们可以的内容，我们大大提高了整体渲染器的性能。这是最简单的优化之一，但回报却很大。我们还可以将这种方法应用到如何设置我们的着色器统一变量上，将它们分成上下文片段：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This division of data works great from a conceptual point of view, and each
    of these data pieces can be updated at different times, providing more performance
    overall.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，数据的这种分割非常有效，每个数据片段都可以在不同的时间更新，从而提供更好的性能。
- en: That basically describes, at a high level, the performant way to handle the
    rendering of multiple view points for VR. As mentioned before, a large amount
    of the setup involved with getting the hardware and pipeline connected is abstracted
    away for us in the SDKs being developed. In the next section, we will look at
    some of these SDKs, and close out the chapter by looking at the implementation
    of an SDK in our example engine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上描述了以高层次处理多个视点的VR渲染的高效方法。如前所述，在开发中，与硬件和管道连接相关的大部分设置都在我们开发的SDK中被抽象掉了。在下一节中，我们将看一些这些SDK，并通过查看在我们的示例引擎中实现SDK来结束本章。
- en: Headset SDKs
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头显SDK
- en: 'There are many SDKs available for implementing the various headsets and supporting
    hardware, with most manufactures supplying their own in some form. In the upcoming
    sections, we will quickly look at three of the most commonly used SDKs when developing
    PC driven HMD VR experiences:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多SDK可用于实现各种头显和支持硬件，大多数制造商以某种形式提供自己的SDK。在接下来的章节中，我们将快速查看开发PC驱动HMD VR体验时最常用的三个SDK：
- en: '**Oculus PC SDK** ([https://developer.oculus.com/downloads/package/oculus-sdk-for-windows/](https://developer.oculus.com/downloads/package/oculus-sdk-for-windows/)):
    This SDK was specifically created for use when developing Oculus Rift HMD experiences
    and games in C++. The core SDK supplies everything developers need to gain access
    to rendering, tracking, input, and other core hardware functionalities. The core
    SDK is sublimated by other supporting SDKs for audio, platform, and avatar.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus PC SDK（[https://developer.oculus.com/downloads/package/oculus-sdk-for-windows/](https://developer.oculus.com/downloads/package/oculus-sdk-for-windows/)）：此SDK专为在C++中开发Oculus
    Rift HMD体验和游戏而创建。核心SDK提供了开发人员访问渲染、跟踪、输入和其他核心硬件功能所需的一切。核心SDK由其他支持音频、平台和头像的SDK支持。
- en: '**OpenVR** ([https://github.com/ValveSoftware/openvr](https://github.com/ValveSoftware/openvr)): This
    is the SDK provided by the Valve corporation as the default API and runtime for
    the SteamVR platform. This is also the default SDK for HTC Vive HMD development,
    but is designed to have multiple vendor support. This means you have the ability
    to target multiple HMDs without having to know exactly which HMD is connected.
    This will be the SDK we implement for our example engine.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenVR**（[https://github.com/ValveSoftware/openvr](https://github.com/ValveSoftware/openvr)）：这是由Valve公司提供的默认API和SteamVR平台的运行时的SDK。这也是HTC
    Vive HMD开发的默认SDK，但设计为支持多个供应商。这意味着您可以在不知道连接了哪个HMD的情况下，针对多个HMD进行开发。这将是我们在示例引擎中实现的SDK。'
- en: '**OSVR** ([http://osvr.github.io/](http://osvr.github.io/)): The OSVR SDK,
    like its name states, is an open source SDK designed to work with multiple hardware
    vendors. This SDK is the default SDK for the HMD of the same name, the OSVR headset.
    The project is spearheaded by Razer and Sensics, with many large gaming partners
    signing on. The OSVR SDK is available for Microsoft Windows, Linux, Android, and
    macOS.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OSVR**（[http://osvr.github.io/](http://osvr.github.io/)）：OSVR SDK，正如其名称所示，是一个设计用于与多个硬件供应商配合使用的开源SDK。这个SDK是同名头显OSVR的默认SDK。该项目由雷蛇和Sensics领导，许多大型游戏合作伙伴也加入了。OSVR
    SDK可用于Microsoft Windows、Linux、Android和macOS。'
- en: Implementing VR support
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现VR支持
- en: As with many other systems we have looked at throughout the book, implementing
    VR support from scratch can be a very challenging and time-consuming process.
    However, much like those other systems, libraries and SDKs exist to help ease
    and simplify the process. In the next section, we will cover how we can add VR
    rendering support to our example engine using the OpenVR SDK provided by the Valve
    corporation. We will cover only the main points in full. To see a more complete
    overview of each method, refer to the comments in the example code, and visit
    the OpenVR SDK Wiki for more SDK-specific information ([https://github.com/ValveSoftware/openvr/wiki](https://github.com/ValveSoftware/openvr/wiki)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中讨论过的许多其他系统一样，从头开始实现VR支持可能是一个非常具有挑战性和耗时的过程。然而，就像其他系统一样，存在着可以帮助简化和简化过程的库和SDK。在下一节中，我们将介绍如何使用Valve公司提供的OpenVR
    SDK向我们的示例引擎添加VR渲染支持。我们将只完整地介绍主要要点。要查看每种方法的更完整概述，请参考示例代码中的注释，并访问OpenVR SDK Wiki获取更多SDK特定信息（[https://github.com/ValveSoftware/openvr/wiki](https://github.com/ValveSoftware/openvr/wiki)）。
- en: Verifying HMD
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证HMD
- en: To start out, we need to do a few things to set up our hardware and environment.
    We need to first test if a headset is attached to the computer. Then we need check
    if the OpenVR runtime has been installed. We can then initialize the hardware
    and finally ask it a few questions about its capability. To do this, we will add
    some code to our `GameplayScreen` class; for brevity's sake we will skip over
    some sections. The full code can be found in the example project in the `Chapter11`
    folder of the code repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要做一些事情来设置我们的硬件和环境。我们需要首先测试一下计算机上是否连接了头显。然后我们需要检查OpenVR运行时是否已安装。然后我们可以初始化硬件，最后询问一些关于其功能的问题。为此，我们将向我们的`GameplayScreen`类添加一些代码；为简洁起见，我们将跳过一些部分。完整的代码可以在代码存储库的`Chapter11`文件夹中的示例项目中找到。
- en: 'Let''s begin by checking to see if a VR headset has been attached to the computer
    and if the OpenVR (SteamVR) runtime has been installed. To do this, we will add
    the following to the `Build()` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查一下计算机是否连接了VR头显，以及OpenVR（SteamVR）运行时是否已安装。为此，我们将在`Build()`方法中添加以下内容：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we throw an exception to be handled and logged if either of these checks
    fail. Now that we know we have some hardware and the required software, we can
    initialize the framework. To do this, we call the `InitVR` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果这些检查中的任何一个失败，我们会抛出一个异常来处理和记录。现在我们知道我们有一些硬件和所需的软件，我们可以初始化框架。为此，我们调用`InitVR`函数：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `InitVR` function''s main purpose is to, in turn, call the `VR_Init` method
    of the OpenVR SDK. In order to do that, it needs to first create and set up an
    error handler. It will also require us to define what type of application this
    will be. In our case, we are stating that this will be a scene application, `vr::VRApplication_Scene`.
    This means we are creating a 3D application that will be drawing an environment.
    There are other options, such as creating a utility or overlay only applications.
    Finally, once we have the HMD initialized, with no errors, we ask the headset
    to tell us a little about itself. We do this using the `GetTrackedDeviceString`
    method that we will look at shortly. The whole `InitVR` method then looks like
    the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitVR`函数的主要目的是依次调用OpenVR SDK的`VR_Init`方法。为了做到这一点，它需要首先创建和设置一个错误处理程序。它还需要我们定义这将是什么类型的应用程序。在我们的情况下，我们声明这将是一个场景应用程序，`vr::VRApplication_Scene`。这意味着我们正在创建一个将绘制环境的3D应用程序。还有其他选项，比如创建实用程序或仅覆盖应用程序。最后，一旦HMD初始化完成，没有错误，我们要求头显告诉我们一些关于它自身的信息。我们使用`GetTrackedDeviceString`方法来做到这一点，我们很快就会看到。整个`InitVR`方法看起来像下面这样：'
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `HandleVRError` method is just a simple helper method that takes the error
    passed in and throws an error to be handled and logged while providing an English
    translation of the error being thrown. The following is the method in its entirety:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleVRError`方法只是一个简单的辅助方法，它接受传入的错误并抛出一个要处理和记录的错误，同时提供错误的英文翻译。以下是该方法的全部内容：'
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The other method that the `InitVR` function calls is the `GetTrackedDeviceString`
    function. This is a function provided as part of the OpenVR example code, which
    allows us to return some information about the attached device. In our case, we
    are asking for the system name and the serial number properties, if available,
    for the attached device:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitVR`函数调用的另一个方法是`GetTrackedDeviceString`函数。这是OpenVR示例代码的一部分，允许我们返回有关附加设备的一些信息的函数。在我们的情况下，我们要求返回附加设备的系统名称和序列号属性（如果可用）：'
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, back in our `Build` method, now that we have completed the initialization
    steps, we can check that all went well by asking the system if the `VRCompositor`
    function is set to a value other than NULL. If it is, that means everything is
    ready to go and we can then ask our HMD what it would like our rendering target
    size to be and display that as a string output in our console window:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`Build`方法中，现在我们已经完成了初始化步骤，我们可以通过询问系统`VRCompositor`函数是否设置为NULL以外的值来检查一切是否顺利。如果是，那意味着一切准备就绪，我们可以询问我们的HMD希望我们的渲染目标大小是多少，并在控制台窗口中显示为字符串输出：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last thing we need to do is make sure we clean up on our program''s completion.
    Here, in the `Destroy` method of the `GamplayScreen`, we are first checking to
    see if the HMD was initialized; if it was we call the `VR_Shutdown` method and
    set the `m_hmd` variable to NULL. It is very important to call the `VR_Shutdown`
    on application closing, as if you do not, the OpenVR/SteamVR may hang and could
    require a reboot before it is operational again:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是确保在程序完成时进行清理。在`GamplayScreen`的`Destroy`方法中，我们首先检查HMD是否已初始化；如果是，我们调用`VR_Shutdown`方法并将`m_hmd`变量设置为NULL。在应用程序关闭时调用`VR_Shutdown`非常重要，因为如果不这样做，OpenVR/SteamVR可能会挂起，并且可能需要重新启动才能再次运行：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now if we go ahead and run this example, in the console window you should see
    something similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们继续运行这个示例，在控制台窗口中，您应该看到类似以下的内容：
- en: '**![](img/3587d745-2294-4081-b48f-3a57744be739.png)**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/3587d745-2294-4081-b48f-3a57744be739.png)**'
- en: Rendering
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: Now that we have the HMD set up and talking with our engine, the next step is
    to render to it. The process is actually not that complicated; as mentioned before,
    a great deal is handled for us by the SDK. To keep things as simple as possible,
    this example is just a simple rendering example. We are not handling head tracking
    or input, we are simply just going to display a different color in each eye. As
    with the previous example, in order to save time and space, we are only going
    to cover the important elements for you to grasp the concept. The full code can
    be found in the example project in the `Chapter11` folder of the code repository.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了HMD并与我们的引擎进行了通信，下一步是对其进行渲染。实际上，这个过程并不复杂；如前所述，SDK已经为我们处理了很多事情。为了尽可能简单，这个示例只是一个简单的渲染示例。我们不处理头部跟踪或输入，我们只是简单地在每只眼睛中显示不同的颜色。与之前的示例一样，为了节省时间和空间，我们只会涵盖重要的元素，让您掌握概念。完整的代码可以在代码库的`Chapter11`文件夹中的示例项目中找到。
- en: 'As we discussed before, when rendering in stereoscopic, you are often rendering
    a single display that has been divided in half. We then pass the appropriate data
    to the half, depending on what is viewable in that eye. Look back to the *Working
    with frusta* section for a refresher on why this is. What this boils down to is
    that we need to create a framebuffer for each eye. To do this, we have a `RenderTarget`
    class that creates the framebuffer, attaches the texture, and finally creates
    the needed viewport (which is half of the total display width). To save space,
    I won''t print out the `RenderTarget` class; it is fairly straightforward and
    nothing we haven''t seen before. Instead, let''s move on to setup and the actual
    functions that will handle the displaying of the scene in the HMD. To start with,
    we need to connect our `RenderTarget` to our texture, and for proper implementation
    clear and set the buffers. To do this we add the following to our `OnEntry` method
    of `GameplayScreen`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，在立体视觉渲染时，通常会渲染一个被分成两半的单个显示器。然后我们将适当的数据传递给每半部分，取决于在该眼睛中可见的内容。回顾一下*使用视锥*部分，了解为什么会这样。这归结为我们需要为每只眼睛创建一个帧缓冲。为此，我们有一个`RenderTarget`类，它创建帧缓冲，附加纹理，最后创建所需的视口（即总显示宽度的一半）。为了节省空间，我不会打印出`RenderTarget`类；它非常简单，我们以前已经见过。相反，让我们继续设置和实际处理在HMD中显示场景的函数。首先，我们需要将我们的`RenderTarget`连接到我们的纹理，并且为了正确实现清除和设置缓冲区。为此，我们将以下内容添加到`GameplayScreen`的`OnEntry`方法中：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I will not go through the previous code line by line since we have seen all
    this done before. Now, with our buffers and textures set, we can move onto adding
    the drawing call.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会逐行讲解之前的代码，因为我们以前已经看过了。现在，我们的缓冲区和纹理已经设置好，我们可以继续添加绘图调用了。
- en: The OpenVR SDK provides the needed methods to handle the complex pieces of displaying
    VR scenes. The majority of this complex work is done by the compositor system.
    As stated by Valve, *"The compositor simplifies the process of displaying images
    to the user by taking care of distortion, prediction, synchronization, and other
    subtle issues that can be a challenge to get operating properly for a solid VR
    experience."*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: OpenVR SDK提供了处理显示VR场景复杂部分所需的方法。大部分这些复杂工作是由合成器系统完成的。正如Valve所说的那样，*“合成器通过处理失真、预测、同步和其他细微问题，简化了向用户显示图像的过程，这些问题可能对于获得良好的VR体验而言是一个挑战。”*
- en: 'To connect to the compositor subsystem, we have created a simple method called
    `SubmitFrames`. This method takes three arguments—a texture for each eye and a
    Boolean value to specify whether the color space should be `linear`. At the time
    of writing, we always want to specify that the color space should be `Gamma` for
    `OpenGL`. Inside the method, we get the device we wish to render to, set the color
    space, convert the texture, and then submit these textures to the `VRCompositor`,
    which then, under the hood, handles the displaying of the textures to the correct
    eye. The entire method looks like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到合成器子系统，我们创建了一个名为`SubmitFrames`的简单方法。这个方法接受三个参数——每只眼睛的纹理和一个布尔值，用于指定颜色空间是否应该是`线性`。在撰写本文时，我们总是希望指定颜色空间应该是`Gamma`，适用于`OpenGL`。在方法内部，我们获取希望渲染到的设备，设置颜色空间，转换纹理，然后将这些纹理提交给`VRCompositor`，然后在幕后处理将纹理显示到正确的眼睛上。整个方法看起来像下面这样：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With our `SubmitFrames` function in place, we can then call the method form
    inside of the GameplayScreen update, right after the `glClear` function call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的`SubmitFrames`函数，我们可以在`GameplayScreen`更新中调用该方法，就在`glClear`函数调用之后：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you now run the example project, provided you have the necessary SteamVR
    framework installed, you should see different colors being shown in each eye of
    the headset.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行示例项目，并且已经安装了必要的SteamVR框架，您应该会看到头戴显示器的每只眼睛显示不同的颜色。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While this was a quick introduction to the world of VR development, it should
    provide you with a great testing bed for your experience ideas. We learned how
    to handle multiple view frusta, learned about various hardware options, and finally
    looked at how we could add VR support to our example engine using the OpenVR SDK.
    As advancements in hardware progress, VR will continue to gain momentum and will
    continue to push into new fields. Understanding how VR rendering works as a whole
    provides a new level of depth to your development knowledge pool.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是对VR开发世界的快速介绍，但它应该为您的体验创意提供了一个很好的测试基础。我们学习了如何处理多个视图截头体，了解了各种硬件选项，最后看了一下我们如何使用OpenVR
    SDK为我们的示例引擎添加VR支持。随着硬件的进步，VR将继续获得动力，并将继续向新领域推进。全面了解VR渲染的工作原理将为您的开发知识储备提供新的深度水平。
