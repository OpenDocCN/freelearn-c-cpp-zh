- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating Menus, Making Enemies, and Using Autoloads
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单、制作敌人和使用自动加载
- en: Although it was a lot of fun setting up all the current systems, the game is
    still kind of boring. There is no real adversary, nothing to stop the player from
    just picking up all the gold coins they desire. Let’s bring some challenge into
    the mix by creating enemies that attack the player and try to stop their road
    to glory and fame!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置所有当前系统很有趣，但游戏本身还是有点无聊。没有真正的对手，没有阻止玩家捡起他们想要的全部金币。让我们通过创建攻击玩家并试图阻止他们通往荣耀和名声之路的敌人来增加一些挑战吧！
- en: 'Next to that, we’ll also create a little menu to start our game from. We’ll
    do this with Godot’s **user interface** (**UI**) system, which makes use of **Control**
    nodes. In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将创建一个小菜单，从那里开始我们的游戏。我们将使用 Godot 的**用户界面**（**UI**）系统来完成这项工作，该系统使用**控制**节点。在本章中，我们将讨论以下主题：
- en: Creating a menu
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单
- en: Making enemies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作敌人
- en: Shooting projectiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击弹体
- en: Scoring highscores in autoloads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动加载中得分
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As for every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一章，你都可以在 GitHub 仓库的子文件夹中找到本章的最终代码：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10)。
- en: Creating a menu
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单
- en: 'The most exciting part of developing a game is, of course, making the game
    itself! Making things move, fight, jump, shoot, interact, and so forth. But there
    is another part that is just as important: the UI. A UI binds everything together.
    It informs the player of what is happening and lets them navigate from menu to
    menu with ease and without having to think about how to get from one interface
    to the other.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发游戏最激动人心的部分当然是制作游戏本身！让事物移动、战斗、跳跃、射击、交互等等。但还有另一个同样重要的部分：用户界面（UI）。UI 将一切联系在一起。它向玩家告知正在发生的事情，并让他们轻松地在菜单之间导航，而无需思考如何从一个界面切换到另一个界面。
- en: Good user experience, UI, or human-computer interaction design is hard! But
    it all starts with learning how to make the UI in the first place. So, let’s have
    a look at how we can create menus and interfaces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的用户体验、UI 或人机交互设计很难！但一切始于学习如何首先制作 UI。所以，让我们看看我们如何创建菜单和界面。
- en: Control nodes
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制节点
- en: 'The Godot engine comes with an extensive library of interface nodes. We already
    made use of one, the **Label** node, in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411).
    These nodes are called **Control nodes** and get labeled by the color green:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎附带了一个广泛的界面节点库。我们已经在[*第 6 章*](B19358_06.xhtml#_idTextAnchor411)中使用了一个，那就是**标签**节点。这些节点被称为**控制节点**，并以绿色进行标记：
- en: '![Figure 10.1 – Some Control nodes can be recognized by their green color](img/B19358_10_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 一些控制节点可以通过其绿色颜色识别](img/B19358_10_1.jpg)'
- en: Figure 10.1 – Some Control nodes can be recognized by their green color
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 一些控制节点可以通过其绿色颜色识别
- en: If you go and open the **Create New Node** menu, you’ll see there are a lot
    of these **Control** nodes. We could categorize these into three different groups.
    Let’s go over some of the nodes and what they can do for us in each group.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开**创建新节点**菜单，你会看到有很多这些**控制**节点。我们可以将这些节点分为三个不同的组。让我们来看看一些节点以及它们在每个组中能为我们做什么。
- en: Nodes showing information
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示信息的节点
- en: 'The first group of nodes shows information. In this group, you would find the
    **Label** node we used in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411), but
    also the **ColorRect** and **TextureRect** nodes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组节点显示信息。在这个组中，你会找到我们在[*第 6 章*](B19358_06.xhtml#_idTextAnchor411)中使用的**标签**节点，还有**ColorRect**和**TextureRect**节点：
- en: '**Label**: Shows a short string of text.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Label**：显示一段简短的文本字符串。'
- en: '**RichTextLabel**: Shows a longer piece of text that can be formatted in specific
    ways.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RichTextLabel**：显示一段较长的文本，可以以特定的方式格式化。'
- en: '**ColorRect**: Shows a solid rectangle in one color.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ColorRect**：显示一个单色的矩形。'
- en: '**TextureRect**: Shows a texture in a rectangle. This node is similar to the
    **Sprite2D** node in that they are both used to show a texture but in different
    contexts.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TextureRect**：在一个矩形中显示纹理。这个节点与**Sprite2D**节点类似，它们都用于显示纹理，但在不同的上下文中使用。'
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到这些节点在编辑器中的样子：
- en: '![Figure 10.2 – Examples of Control nodes that show information](img/B19358_10_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 控制节点示例，显示信息](img/B19358_10_2.jpg)'
- en: Figure 10.2 – Examples of Control nodes that show information
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 显示信息的控制节点示例
- en: These nodes all show something to the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点都向用户显示某些内容。
- en: Nodes taking input
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收输入的节点
- en: 'Any good UI can also take input, with – for example – buttons. Here are some
    of the input nodes that the Godot engine UI nodes provide:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的UI都可以接收输入，例如按钮。以下是一些Godot引擎UI节点提供的输入节点：
- en: '**Button**: A simple button that can be clicked.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**：一个可以点击的简单按钮。'
- en: '**CheckBox**: A checkbox that can be turned on and off.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框**：一个可以打开和关闭的复选框。'
- en: '**CheckButton**: The same as a checkbox, but just with a different aesthetic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框按钮**：与复选框相同，但外观不同。'
- en: '**LineEdit**: A simple node that can take a single line of text input and provide
    it as a string.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本输入框**：一个简单的节点，可以接收单行文本输入并将其作为字符串提供。'
- en: '**HSlider** and **VSlider**: Sliders that are used to input a number. **HSlider**
    slides horizontally while **VSlider** slides vertically.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平滑块**和**垂直滑块**：用于输入数字的滑块。**水平滑块**水平滑动，而**垂直滑块**垂直滑动。'
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到这些节点在编辑器中的样子：
- en: '![Figure 10.3 – Examples of Control nodes that take input](img/B19358_10_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 接收输入的控制节点示例](img/B19358_10_3.jpg)'
- en: Figure 10.3 – Examples of Control nodes that take input
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 接收输入的控制节点示例
- en: These nodes all take input in one way or another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点都以某种方式接收输入。
- en: Nodes containing other nodes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含其他节点的节点
- en: Lastly, there are the nodes that you don’t see but that are very important because
    they make sure all the other UI elements are placed correctly. These nodes form
    the skeleton in which the other **Control** nodes can find their place.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些你看不见但非常重要的节点，因为它们确保了所有其他UI元素都被正确放置。这些节点构成了一个骨架，其他**控制**节点可以在其中找到它们的位置。
- en: '**Container** nodes help us to lay out the UI as we want. This type of node
    can display elements nicely next to each other, add some spacing between nodes,
    and so forth.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**节点帮助我们以我们想要的方式布局UI。这种类型的节点可以很好地显示相邻的元素，在节点之间添加一些间距，等等。'
- en: These containers can also help keep the interface usable and beautiful when
    we resize the screen. This does not happen often, but games can be played on so
    many different screen sizes and aspect ratios these days. Just think about the
    difference between a computer screen and a phone screen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器还可以帮助我们保持界面在调整屏幕大小时仍然可用且美观。这种情况并不常见，但如今的游戏可以在许多不同的屏幕尺寸和宽高比下运行。只需想想电脑屏幕和手机屏幕之间的区别。
- en: 'Some interesting container nodes are the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有趣的容器节点如下：
- en: '**VBoxContainer** and **HBoxContainer**: Organize all their child nodes nicely,
    vertically or horizontally'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VBox容器**和**HBox容器**：垂直或水平地很好地组织所有子节点'
- en: '**CenterContainer**: Centers its child nodes'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**居中容器**：居中其子节点'
- en: '**GridContainer**: Organizes all its child nodes in a tidy grid'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格容器**：以整洁的网格组织所有子节点'
- en: '**MarginContainer**: Adds spacing around its child nodes so that they have
    some room to breathe'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边距容器**：在其子节点周围添加间距，以便它们有足够的空间呼吸'
- en: '**Panel**: Provides a background that shows this part of the UI logically belongs
    together'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板**：提供一个背景，显示这部分UI逻辑上属于一起'
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到这些节点在编辑器中的样子：
- en: '![Figure 10.4 – Examples of Control nodes that can contain other nodes](img/B19358_10_4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 可以包含其他节点的控制节点示例](img/B19358_10_4.jpg)'
- en: Figure 10.4 – Examples of Control nodes that can contain other nodes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 可以包含其他节点的控制节点示例
- en: '**Container** nodes all contain and place their child nodes in a specific way.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**节点都以特定的方式包含和放置它们的子节点。'
- en: The lists of nodes in this section are not exhaustive; a quick glance in the
    **Control** node category while adding a node makes this pretty obvious. But these
    are the most important nodes that you will likely use first. The others are more
    specialized.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的节点列表并不全面；在添加节点时快速查看**控制**节点类别，这很明显。但这些都是你可能会首先使用的重要节点。其他节点更为专业。
- en: The cool thing is that the complete Godot editor itself is constructed out of
    these Control nodes, just to show how flexible and powerful they are for building
    out UIs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 惊人的是，完整的Godot编辑器本身也是由这些Control节点构建的，这只是为了展示它们在构建UI时的灵活性和强大功能。
- en: Now that we have a basic knowledge of the different **Control** nodes, we can
    start making a menu with them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对不同的**控制**节点有了基本了解，我们可以开始使用它们制作菜单。
- en: Creating a basic start menu
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本的启动菜单
- en: 'Let’s create a start menu that displays when we start up the game. This menu
    should simply display the game’s name, a button to start playing, a button to
    exit the game, and lastly, we could add some information on who created the game:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个在启动游戏时显示的启动菜单。这个菜单应简单地显示游戏名称、一个开始播放的按钮、一个退出游戏的按钮，最后，我们还可以添加一些关于谁创建了游戏的信息：
- en: '![Figure 10.5 – This is what our start menu will look like](img/B19358_10_5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 这就是我们的启动菜单将看起来](img/B19358_10_5.jpg)'
- en: Figure 10.5 – This is what our start menu will look like
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 这就是我们的启动菜单将看起来
- en: 'Let’s go over the steps to create a start menu, as shown in *Figure 10**.5*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下创建启动菜单的步骤，如图*图10.5*所示：
- en: Create a new scene called `menu.tscn` under a new `screens/ui` folder.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`screens/ui`文件夹下创建一个名为`menu.tscn`的新场景。
- en: 'Select **User Interface** as the root node’s type:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**用户界面**作为根节点类型：
- en: '![Figure 10.6 – Choosing User Interface as the root node for our menu](img/B19358_10_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 将用户界面作为菜单的根节点](img/B19358_10_6.jpg)'
- en: Figure 10.6 – Choosing User Interface as the root node for our menu
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 将用户界面作为菜单的根节点
- en: Rename the root node `Menu`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根节点重命名为`Menu`。
- en: Let’s start by adding a **ColorRect** node to the menu; this will be our background
    color.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向菜单添加一个**ColorRect**节点开始；这将是我们背景颜色。
- en: 'Now, to stretch the **ColorRect** node to cover the whole screen, **Control**
    nodes have a handy dandy little menu in the top bar. Select the **ColorRect**
    node in the scene tree and select **Full Rect** from the **Anchor** **preset**
    list:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了将**ColorRect**节点拉伸以覆盖整个屏幕，**控制**节点在顶部栏中有一个方便的小菜单。在场景树中选择**ColorRect**节点，并从**锚点****预设**列表中选择**全矩形**：
- en: '![Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full
    screen](img/B19358_10_7.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 选择全矩形以使ColorRect节点覆盖整个屏幕](img/B19358_10_7.jpg)'
- en: Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 选择全矩形以使ColorRect节点覆盖整个屏幕
- en: Now, add a `MainUIContainer`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个`MainUIContainer`。
- en: 'Now, add a `TitleLabel`. This label will show the title of our game:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个`TitleLabel`。这个标签将显示我们游戏的标题：
- en: '![Figure 10.8 – The scene tree of our menu until now](img/B19358_10_8.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 我们菜单到目前为止的场景树](img/B19358_10_8.jpg)'
- en: Figure 10.8 – The scene tree of our menu until now
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 我们菜单到目前为止的场景树
- en: Think of a good title for the game and put it in the text field of the **TitleLabel**
    node.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为游戏想一个合适的标题，并将其放入**TitleLabel**节点的文本字段中。
- en: 'Now, go to `60` px:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`60` px移动到：
- en: '![Figure 10.9 – You can change the font size of a label in Theme Overrides](img/B19358_10_9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 您可以在主题覆盖中更改标签的字体大小](img/B19358_10_9.jpg)'
- en: Figure 10.9 – You can change the font size of a label in Theme Overrides
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 您可以在主题覆盖中更改标签的字体大小
- en: This was just to create a title label for our game UI. It might seem like a
    lot of steps, but some of the nodes we used will make it easy to extend the UI
    in the next few steps.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了为我们的游戏UI创建一个标题标签。这可能看起来步骤很多，但我们使用的某些节点将使在接下来的几个步骤中扩展UI变得容易。
- en: 'Let’s add a panel with buttons and a credit line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个带有按钮和信用行的面板：
- en: Add a **PanelContainer** node to the **MainUIContainer** node.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**PanelContainer**节点添加到**MainUIContainer**节点中。
- en: 'Now, create the following structure in this panel container:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个面板容器中创建以下结构：
- en: '![Figure 10.10 – The scene tree structure from the PanelContainer node](img/B19358_10_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 从PanelContainer节点查看的场景树结构](img/B19358_10_10.jpg)'
- en: Figure 10.10 – The scene tree structure from the PanelContainer node
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 从PanelContainer节点查看的场景树结构
- en: Rename the first button `PLAY`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个按钮重命名为`PLAY`。
- en: Rename the second button `EXIT`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个按钮重命名为`EXIT`。
- en: Rename the label **CreditLabel** and change its text to whatever you would like
    it to say!
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签**CreditLabel**重命名，并将其文本更改为您希望显示的内容！
- en: Now, go into the first `50` px.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入第一个`50` px。
- en: Change the `20` px.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`20` px更改为。
- en: Lastly, set the `200` px.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`200` px设置。
- en: 'Great work – the UI layout is finished. The complete scene tree should look
    like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好 – UI布局已完成。完整的场景树应如下所示：
- en: '![Figure 10.11 – The complete scene tree of our menu](img/B19358_10_11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 我们菜单的完整场景树](img/B19358_10_11.jpg)'
- en: Figure 10.11 – The complete scene tree of our menu
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 我们菜单的完整场景树
- en: 'The only thing left to do is to make the buttons functional! Let us do that
    real quick:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是让按钮变得可用！让我们快速完成它：
- en: Add an empty script to the root `menu.gd`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个空脚本添加到根`menu.gd`。
- en: Now, connect the pressed signal of the **PlayButton** node to this node.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将**PlayButton**节点的按下信号连接到这个节点。
- en: 'The body of the connected function is quite simple:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接的函数体相当简单：
- en: '[PRE0]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, connect the pressed signal of the **ExitButton** node.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，连接**ExitButton**节点的按下信号。
- en: 'The body of this function is even simpler:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数体甚至更简单：
- en: '[PRE1]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippets, we reached out to the root of the scene tree
    with `get_tree()`. This function returns `SceneTree`, the object that manages
    the whole hierarchy of nodes while the game is running.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`get_tree()`函数到达场景树的根。这个函数返回`SceneTree`对象，它在游戏运行时管理整个节点层次结构。
- en: In the function that is connected to the `change_scene_to_file()` function on
    this object, which switches out the current running scene to the one that is specified
    by the path we provide to the function. So, to start the main game scene, we just
    give it the path, starting from the root of the project, to the `main.tscn` scene.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到`change_scene_to_file()`函数的该对象上的函数中，该函数将当前运行的场景切换到我们提供给函数的路径指定的场景。因此，要启动主游戏场景，我们只需给它从项目根目录开始的路径，到`main.tscn`场景。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s good to note that from the moment it is called, `change_scene_to file()`
    will also load the scene file it is supposed to switch to. This means that the
    game will block or freeze for this loading duration. This is not great when we
    are switching to a big scene, which we luckily are not doing in our case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，从它被调用的那一刻起，`change_scene_to file()`也会加载它应该切换到的场景文件。这意味着游戏将在加载这段时间内阻塞或冻结。当我们切换到大型场景时，这并不是很好，幸运的是，在我们的案例中我们没有这样做。
- en: In the function that is connected to the `quit()` function, which simply shits
    down the runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到`quit()`函数的函数中，该函数简单地关闭运行时。
- en: You can now try out the menu by running it!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过运行它来尝试菜单！
- en: Setting the main scene
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置主场景
- en: 'To make sure our menu is the main scene that boots up the game, we’ll quickly
    need to step into the project settings to declare this. In the project settings,
    under `menu.tscn` is the main scene:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的菜单是启动游戏的主体场景，我们很快需要进入项目设置来声明这一点。在项目设置中，`menu.tscn`下是主场景：
- en: '![Figure 10.12 – Setting the main scene in the project settings](img/B19358_10_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 在项目设置中设置主场景](img/B19358_10_12.jpg)'
- en: Figure 10.12 – Setting the main scene in the project settings
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 在项目设置中设置主场景
- en: This will make sure that when we run the game, using the `menu.tscn` scene is
    the scene that gets launched by default.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保当我们运行游戏时，使用`menu.tscn`场景是默认启动的场景。
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that when there is no main scene set and we run the game through the
    aforementioned methods, Godot will ask us if we want to use the currently opened
    scene as the main scene.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果没有设置主场景，并且我们通过上述方法运行游戏，Godot会询问我们是否想使用当前打开的场景作为主场景。
- en: We learned a lot about **Control** nodes and how to use them to quickly construct
    UIs. Let’s go and make some enemies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了很多关于**控制**节点以及如何快速构建UI的知识。让我们去制作一些敌人。
- en: Making enemies
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作敌人
- en: In real life, making enemies is never a good idea. But in the context of video
    game development, it is often a great way to challenge the player and put them
    against some opposition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，制造敌人从来不是一个好主意。但在视频游戏开发的情况下，这通常是一种挑战玩家并让他们面对一些反对派的极好方式。
- en: The enemy that we will be creating is fairly simple and straightforward. But
    we will still learn a lot along the way – for example, how to let enemies navigate
    toward the player to attack them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的敌人相当简单直接。但我们在过程中仍然会学到很多——例如，如何让敌人向玩家导航以攻击他们。
- en: Like I said, we’ll keep the enemy simple. We’ll be making an enemy that spawns
    at a random time in a random spot of the arena and starts charging toward the
    player. From the moment the enemy touches the player, we’ll deduct one health
    point from the player’s life and remove the enemy from the game. This way, the
    player has some adversaries but should not get overwhelmed by a horde of enemies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，我们将保持敌人简单。我们将制作一个在竞技场随机位置随机时间生成的敌人，并开始向玩家冲锋。从敌人接触到玩家的那一刻起，我们将从玩家的生命值中扣除一个健康点，并将敌人从游戏中移除。这样，玩家有一些对手，但不应被一群敌人所淹没。
- en: In the following section, *Shooting projectiles*, we’ll develop a way for the
    player to defend themselves. But for now, we’ll solely focus on the enemy and
    its behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节“射击弹丸”中，我们将开发一种让玩家进行防御的方法。但到目前为止，我们将只关注敌人和它的行为。
- en: Constructing the base scene
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基础场景
- en: 'As with any new part of our game, let’s start by creating the base structure
    in a scene tree for the enemy and add code and other interesting things later
    in the section:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的游戏中的任何新部分一样，让我们首先在场景树中为敌人创建基础结构，然后在后面的章节中添加代码和其他有趣的东西：
- en: Create a `parts/enemy` folder, and within it, create a new scene called `enemy.tscn`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`parts/enemy`文件夹，并在其中创建一个名为`enemy.tscn`的新场景。
- en: 'Recreate the following scene tree. Note that the root is a **CharacterBody**
    node:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建以下场景树。注意，根节点是一个**CharacterBody**节点：
- en: '![Figure 10.13 – The scene tree of our Enemy scene](img/B19358_10_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 我们敌人场景的场景树](img/B19358_10_13.jpg)'
- en: Figure 10.13 – The scene tree of our Enemy scene
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 我们敌人场景的场景树
- en: 'Choose a sprite from the `assets/sprites/enemies` folder as the texture for
    the **Sprite2D** node:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`assets/sprites/enemies`文件夹中选择一个精灵作为**Sprite2D**节点的纹理：
- en: '![Figure 10.14 – The Enemy scene in the 2D editor](img/B19358_10_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 2D编辑器中的敌人场景](img/B19358_10_14.jpg)'
- en: Figure 10.14 – The Enemy scene in the 2D editor
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 2D编辑器中的敌人场景
- en: Make sure you set the scale of the sprite node to `(``3, 3)`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已将精灵节点的比例设置为`(``3, 3)`.
- en: For the moment, the `Enemy` scene is very simple. Let’s look into how we could
    do navigation to complexify it a little bit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Enemy`场景非常简单。让我们看看我们如何进行导航来稍微复杂化它。
- en: Navigating enemies
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航敌人
- en: We can easily make enemies move directly toward the player. The problem with
    this is that they will get stuck behind walls and bump into boulders, which doesn’t
    feel very natural and makes them look quite dumb.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地让敌人直接向玩家移动。问题是它们会卡在墙壁后面，撞到巨石，这感觉很不自然，也让它们看起来相当愚蠢。
- en: Luckily, the Godot engine comes with a **NavigationServer** property that calculates
    a path around all these obstacles and makes enemy movement more natural and fluent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Godot引擎自带一个**NavigationServer**属性，它可以计算绕过所有这些障碍物的路径，使敌人移动更加自然流畅。
- en: 'To accomplish this, we will look at two new nodes: `NavigationRegion2D` and
    `NavigationAgent2D`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将查看两个新的节点：`NavigationRegion2D`和`NavigationAgent2D`。
- en: Creating a NavigationRegion2D node
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个NavigationRegion2D节点
- en: 'Firstly, we need to define in what region of the level our enemy can move around,
    then we want to cut out spots where a wall or boulder is situated from this region.
    This is exactly what the `NavigationRegion2D` node does! Let’s define one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义敌人可以在关卡中的哪个区域移动，然后我们希望从这个区域中移除墙壁或巨石所在的位置。这正是`NavigationRegion2D`节点所做的事情！让我们定义一个：
- en: Go to the `main.tscn` game scene.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`main.tscn`游戏场景。
- en: In the root node called `Main`, add a `NavigationRegion2D` node.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`Main`的根节点中添加一个`NavigationRegion2D`节点。
- en: 'Click on the empty **Navigation Polygon** property and select **New NavigationPolygon**:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击空的**Navigation Polygon**属性并选择**New NavigationPolygon**：
- en: '![Figure 10.15 – Clicking on New NavigationPolygon](img/B19358_10_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 点击新建导航多边形](img/B19358_10_15.jpg)'
- en: Figure 10.15 – Clicking on New NavigationPolygon
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 点击新建导航多边形
- en: 'Now, we’ll first define the outer bounds of where enemies will be able to move.
    Draw a polygon shape by clicking in the editor. Try to trace the outside of the
    arena closely. Don’t forget to close the shape by clicking the first point you
    placed:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将首先定义敌人可以移动的外部边界。在编辑器中点击绘制多边形形状。尽量紧密地追踪竞技场的边缘。别忘了通过点击放置的第一个点来闭合形状：
- en: '![Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node](img/B19358_10_16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 创建NavigationRegion2D节点的边界](img/B19358_10_16.jpg)'
- en: Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 创建NavigationRegion2D节点的边界
- en: 'Press **Bake NavigationPolygon** at the top of the window to create a navigation
    polygon:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口顶部点击**烘焙NavigationPolygon**以创建导航多边形：
- en: '![Figure 10.17 – Pressing Bake NavigationPolygon](img/B19358_10_17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 点击Bake NavigationPolygon](img/B19358_10_17.jpg)'
- en: Figure 10.17 – Pressing Bake NavigationPolygon
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 点击Bake NavigationPolygon
- en: 'After following these steps, the `NavigationRegion2D` node should look like
    this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤操作后，`NavigationRegion2D`节点应该看起来像这样：
- en: '![Figure 10.18 – The NavigationRegion2D node after baking the polygon for the
    first time](img/B19358_10_18.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 首次烘焙多边形后的NavigationRegion2D节点](img/B19358_10_18.jpg)'
- en: Figure 10.18 – The NavigationRegion2D node after baking the polygon for the
    first time
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 首次烘焙多边形后的NavigationRegion2D节点
- en: The blue/greenish area is where enemies will be able to navigate and move in.
    But you can already see a problem – this region also spans over our walls and
    boulders. We don’t want enemies to think that they can walk through them because,
    well, they can’t; they are static physics bodies. Luckily, Godot has the functionality
    to automatically detect these and bake the `NavigationPolygon` property in such
    a way that it takes them into account.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿色区域是敌人能够导航和移动的区域。但你已经可以看到一个问题——这个区域也跨越了我们的墙壁和巨石。我们不希望敌人认为他们可以穿过它们，因为，嗯，他们不能；它们是静态物理体。幸运的是，Godot具有自动检测这些并以考虑它们的方式烘焙`NavigationPolygon`属性的功能。
- en: 'Unfold the `NavigationRegion2D` node by clicking on it and configure it as
    follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击`NavigationRegion2D`节点来展开它，并按以下方式配置：
- en: Set **Geometry** | **Parsed Geometry Type** to **Static Colliders**. We do this
    to only consider static colliders in the automatic generation.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**几何** | **解析几何类型**设置为**静态碰撞体**。我们这样做是为了在自动生成时只考虑静态碰撞体。
- en: Set **Geometry** | **Source Geometry Mode** to **Group With Children**. This
    way, the automatic generation will scan through the children of nodes to find
    the static colliders.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**几何** | **源几何模式**设置为**与子节点组合**。这样，自动生成将扫描节点的子节点以查找静态碰撞体。
- en: 'Set `40` px. With this, we define the radius of the agents we want to use in
    the `NavigationRegion2D` node, and the automatic generation can take this into
    account so that agents don’t bump into obstacles they should be able to avoid:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`40` px。通过这种方式，我们定义了在`NavigationRegion2D`节点中要使用的代理的半径，并且自动生成可以考虑到这一点，以便代理不会撞到它们应该能够避免的障碍物：
- en: '![Figure 10.19 – Configuring the NavigationPolygon property](img/B19358_10_19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – 配置NavigationPolygon属性](img/B19358_10_19.jpg)'
- en: Figure 10.19 – Configuring the NavigationPolygon property
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – 配置NavigationPolygon属性
- en: 'Select the `Arena` node and switch to the **Node** tab, next to the **Inspector**
    tab:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Arena`节点并切换到**节点**标签页，它位于**检查器**标签页旁边：
- en: '![Figure 10.20 – Going to the Node tab](img/B19358_10_20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – 转到节点标签页](img/B19358_10_20.jpg)'
- en: Figure 10.20 – Going to the Node tab
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 转到节点标签页
- en: 'Switch to the **Groups** tab, which is next to the **Signals** tab:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**组**标签页，它位于**信号**标签页旁边：
- en: '![Figure 10.21 – Switching to the Groups tab](img/B19358_10_21.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – 切换到组标签页](img/B19358_10_21.jpg)'
- en: Figure 10.21 – Switching to the Groups tab
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – 切换到组标签页
- en: 'Paste `navigation_polygon_source_geometry_group` into the text field and press
    **Add**:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`navigation_polygon_source_geometry_group`粘贴到文本框中并按**添加**：
- en: '![Figure 10.22 – Adding the navigation_polygon_source_geometry_group group](img/B19358_10_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22 – 添加navigation_polygon_source_geometry_group组](img/B19358_10_22.jpg)'
- en: Figure 10.22 – Adding the navigation_polygon_source_geometry_group group
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22 – 添加navigation_polygon_source_geometry_group组
- en: Now, select the `NavigationRegion2D` node again and press **Bake** **NavigationPolygon**
    again.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次选择`NavigationRegion2D`节点并再次按**烘焙** **NavigationPolygon**。
- en: 'When you are done, the navigation region should look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，导航区域应该看起来像这样：
- en: '![Figure 10.23 – The resulting NavigationRegion2D node](img/B19358_10_23.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图10.23 – 生成的NavigationRegion2D节点](img/B19358_10_23.jpg)'
- en: Figure 10.23 – The resulting NavigationRegion2D node
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – 生成的NavigationRegion2D节点
- en: The blue/greenish region now nicely avoids walls and boulders. You can also
    see that there is some margin between obstacles and where the region begins. This
    is what we set up when defining the **Radius** property of the agents. This margin
    makes sure the pathfinding doesn’t come too close to obstacles, making enemies
    avoid colliding with them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的蓝绿色区域很好地避开了墙壁和巨石。你还可以看到障碍物和区域开始处之间有一些空白。这是我们定义代理的**半径**属性时设置的。这个空白确保路径查找不会太靠近障碍物，使敌人避免与之碰撞。
- en: In *steps 2* to *4*, we added the `Arena` node to a `navigation_polygon_source_geometry_group`
    node group and consider the static bodies within them. Let’s take a small detour
    to talk about node groups.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤2**到**步骤4**中，我们将`Arena`节点添加到`navigation_polygon_source_geometry_group`节点组中，并考虑其中的静态物体。让我们稍微偏离一下，来谈谈节点组。
- en: What are node groups?
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是节点组？
- en: '**Groups** or **node groups** in the Godot engine are like tags in other pieces
    of software. You can add any number of groups to a node. We can simply do this
    through the **Groups** tab, just like we did in the steps of the last section.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 引擎中，**组**或**节点组**就像其他软件中的标签。您可以为节点添加任意数量的组。我们可以通过**组**选项卡简单地做到这一点，就像我们在上一节步骤中所做的那样。
- en: 'Groups are extremely useful because you can, for example, do the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 组非常有用，因为例如，您可以执行以下操作：
- en: Check if a node is part of a group.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查一个节点是否属于一个组。
- en: Get all nodes within a group from the tree.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从树中获取组内的所有节点。
- en: Call methods on all nodes within a group.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组内调用所有节点的函数。
- en: We’ll use groups some more later on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会再次使用组。
- en: The `NavigationRegion2D` node is ready, so now, let’s take a look at the process
    of adding a `NavigationAgent2D` node to the `Enemy` scene.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigationRegion2D`节点已经准备好了，所以现在，让我们看看将`NavigationAgent2D`节点添加到`Enemy`场景的过程。'
- en: Adding a NavigationAgent2D node to the Enemy scene
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将NavigationAgent2D节点添加到敌人场景
- en: The last thing we need to add to the `enemy.tscn` scene from within the editor
    before starting to write code is a `NavigationAgent2D` node. This node handles
    pathfinding and navigation within the `NavigationRegion2D` node that we created
    in the previous section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，我们需要在编辑器中添加一个`NavigationAgent2D`节点到`enemy.tscn`场景中。这个节点处理`NavigationRegion2D`节点内的路径查找和导航，这是我们上一节中创建的。
- en: 'Just add a `NavigationAgent2D` node in the root `Enemy` node. We don’t have
    to do any other setup:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在根`Enemy`节点中添加一个`NavigationAgent2D`节点。我们不需要进行任何其他设置：
- en: '![Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene](img/B19358_10_24.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图10.24 – 将NavigationAgent2D节点添加到敌人场景](img/B19358_10_24.jpg)'
- en: Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24 – 将NavigationAgent2D节点添加到敌人场景
- en: Now, we can start writing the code for our enemy!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写我们的敌人代码了！
- en: Writing the enemy script
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写敌人脚本
- en: The code for our enemy is going to be very similar to the code for our player.
    They both walk around based on the physics of an accelerating velocity. The only
    difference is that for the enemy, the position where it wants to move is defined
    by the `NavigationServer` property. This server looks at the `NavigationRegion2D`
    node and the current position of the `NavigationAgent2D` node to calculate the
    best route with the point on the map we choose to go to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敌人的代码将非常类似于我们玩家的代码。他们都是根据加速速度的物理特性移动。唯一的区别是，对于敌人，它想要移动的位置由`NavigationServer`属性定义。这个服务器查看`NavigationRegion2D`节点和`NavigationAgent2D`节点的当前位置，以计算到达地图上我们选择去的目的地的最佳路线。
- en: 'Let’s start out by writing some boilerplate code that defines some of our enemy’s
    movement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一些样板代码开始，这些代码定义了我们敌人的一些移动：
- en: '[PRE2]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In general, this code is very similar to the movement code that we wrote for
    the `player.gd` script. The only difference is that we now use the `NavigationAgent2D`
    node to say where we need to go:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这段代码与我们为`player.gd`脚本编写的移动代码非常相似。唯一的区别是，我们现在使用`NavigationAgent2D`节点来说明我们需要去哪里：
- en: '[PRE3]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we are going toward the global position of the `player` variable.
    We’ll define this `player` variable in a bit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正朝着`player`变量的全局位置前进。我们将在稍后定义这个`player`变量。
- en: Position and global_position
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 位置和global_position
- en: The `position` variable of a `global_position` variable, on the other hand,
    is the position of the node in world space, relative to the root of the scene
    tree. Both get automatically updated when the node moves in 2D space; it is basically
    the same data but with a different point of reference.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`global_position`变量的`position`属性是节点在世界空间中的位置，相对于场景树根。当节点在2D空间中移动时，两者都会自动更新；这基本上是相同的数据，但参考点不同。
- en: We need to use the `global_position` variable here because the target position
    of a `NavigationAgent2D` node has to be a global position.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里使用`global_position`变量，因为`NavigationAgent2D`节点的目标位置必须是一个全局位置。
- en: 'Then, we need to check whether we need to move or not:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检查是否需要移动：
- en: '[PRE4]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we need to move, we ask the `NavigationAgent2D` node what the next position
    we should move to is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要移动，我们会询问`NavigationAgent2D`节点下一个我们应该移动到的位置：
- en: '[PRE5]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, all we need to do is calculate the direction from our current position
    to this next position, and the rest of the code is exactly the same as for the
    `Player` scene from [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要计算从当前位置到下一个位置的方向，其余的代码与 [*第 7 章*](B19358_07.xhtml#_idTextAnchor523)
    中的 `Player` 场景的代码完全相同。
- en: 'To select the `Player` node, we are going to use node groups by adding this
    `_ready()` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择 `Player` 节点，我们将使用节点组，通过添加这个 `_ready()` 函数来实现：
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get the player from within the scene tree, we do something new. We ask the
    current scene tree for all nodes that are in the `player` group. This function
    will return an array with nodes that belong to this group. So, we’ll have to take
    the first element, if there is any.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要从场景树中获取玩家，我们做了一些新的操作。我们要求当前场景树返回所有在 `player` 组中的节点。此函数将返回一个包含属于此组的节点的数组。所以，如果有的话，我们将取第一个元素。
- en: Important note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It might look weird to ask for all the player nodes in the scene while there
    is only one. We do this so that we can use roughly the same code to target more
    players when we deal with multiple players in the next chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景中只有一个玩家节点时，要求所有玩家节点可能看起来有些奇怪。我们这样做是为了在下一章处理多个玩家时，可以使用大致相同的代码来针对更多玩家。
- en: These node groups are a useful feature of the Godot engine because the engine
    will keep track of all nodes within a group so that we can easily query them or
    check if a node belongs to a certain group.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点组是 Godot 引擎的一个有用特性，因为引擎会跟踪组内所有节点，这样我们就可以轻松查询它们或检查一个节点是否属于某个组。
- en: 'Now, this code will not work yet because, well, the player is actually not
    yet in the `player` group! To add them to this group, we need to alter the `Player`
    scene a little:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码还不能工作，因为，嗯，玩家实际上还没有被添加到 `player` 组中！为了将它们添加到这个组中，我们需要稍微修改一下 `Player`
    场景：
- en: Go to the `player.tscn` scene.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `player.tscn` 场景。
- en: Select the root node.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择根节点。
- en: 'In the window that contains the node’s signals, there is a button called **Groups**.
    Press it, and you will see the **Groups** window:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含节点信号的窗口中，有一个名为 **Groups** 的按钮。按下它，你会看到 **Groups** 窗口：
- en: '![Figure 10.25 – Adding the player’s root node to the node group called player](img/B19358_10_25.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25 – 将玩家的根节点添加到名为 player 的节点组中](img/B19358_10_25.jpg)'
- en: Figure 10.25 – Adding the player’s root node to the node group called player
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – 将玩家的根节点添加到名为 player 的节点组中
- en: Here, type `player` into the line input and press **Add**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，在行输入中输入 `player` 并按下 **Add**。
- en: Put an enemy in the main scene, and you will see that it starts moving toward
    the player! This is great. But enemies should be able to damage the player, so
    let’s work on that next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在主场景中放置一个敌人，你会看到它开始向玩家移动！这很棒。但是敌人应该能够伤害玩家，所以让我们接下来处理这个问题。
- en: Damaging the player in a collision
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在碰撞中伤害玩家
- en: 'To detect if an enemy is close enough to the player to deal damage, we are
    going to use an **Area2D** node, as we did for collectibles in [*Chapter 9*](B19358_09.xhtml#_idTextAnchor590):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测敌人是否足够接近玩家以造成伤害，我们将使用一个 **Area2D** 节点，就像我们在 [*第 9 章*](B19358_09.xhtml#_idTextAnchor590)
    中为可收集物品所做的那样：
- en: 'Let’s start by adding a `get``_hit()` function to the `player.gd` script. This
    function will get called when the player is hit by an enemy and lower the health
    of the player:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向 `player.gd` 脚本中添加一个 `get_hit()` 函数开始。当玩家被敌人击中时，此函数将被调用，并降低玩家的生命值：
- en: '[PRE7]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add an `enemy.tscn` scene and call it `PlayerDetectionArea`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `enemy.tscn` 的场景，并将其命名为 `PlayerDetectionArea`。
- en: 'Under this area, add a **CollisionShape2D** node:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个区域下添加一个 **CollisionShape2D** 节点：
- en: '![Figure 10.26 – Adding an Area2D node to the Enemy scene](img/B19358_10_26.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.26 – 将 Area2D 节点添加到敌人场景中](img/B19358_10_26.jpg)'
- en: Figure 10.26 – Adding an Area2D node to the Enemy scene
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26 – 将 Area2D 节点添加到敌人场景中
- en: 'Make this collision shape a **CircleShape2D** node that is a little bigger
    than the enemy’s sprite:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个碰撞形状设置为比敌人精灵稍大的 **CircleShape2D** 节点：
- en: '![Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D
    node](img/B19358_10_27.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.27 – 使用 CollisionShape2D 节点覆盖整个敌人及其周围一些空间](img/B19358_10_27.jpg)'
- en: Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D
    node
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 – 使用 CollisionShape2D 节点覆盖整个敌人及其周围一些空间
- en: Connect the `body_entered` signal to the root node of the enemy.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `body_entered` 信号连接到敌人的根节点。
- en: 'Now, use the next snippet of code as the body of the connected function in
    the enemy’s script:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用下一个代码片段作为敌人脚本中连接函数的主体：
- en: '[PRE8]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code of this function is straightforward. First, we check if the body that
    entered the area actually is the player. We can do this simply with the following
    check:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码很简单。首先，我们检查进入该区域的身体是否确实是玩家。我们可以简单地通过以下检查来完成：
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, we can check whether a certain node is in a certain group. If this
    body is not in the `player` group, we return out of the function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以检查某个节点是否属于某个组。如果这个身体不在`player`组中，我们就从函数中返回。
- en: But if the body is a player node, then we remove one point from its health and
    free the enemy that made contact.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果身体是一个玩家节点，那么我们就从它的健康值中减去一点，并释放与之接触的敌人。
- en: 'Great – our enemy can now damage the player when it comes close enough. There
    is only one more problem: there are only as many enemies as we can drag and drop
    into the scene. Enemies should be able to spawn automatically and constantly!
    Otherwise, the game would be over very quickly. Let’s make an automatic spawner
    that spawns enemies but also health potions.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了 – 我们现在可以让敌人在我们足够接近时伤害玩家。只有一个问题：敌人的数量只有我们能够拖放到场景中的数量。敌人应该能够自动且持续地生成！否则，游戏会很快结束。让我们创建一个自动生成器，它可以生成敌人，还可以生成健康药水。
- en: Spawning enemies and collectibles
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人和可收集物品
- en: To automatically spawn enemies or collectibles in our playfield is actually
    harder than it looks at first sight. We can randomly pick a location and spawn
    something there. Doing this, however, could spawn an enemy or a collectible within
    a wall or boulder. Even worse, the enemy or collectible could spawn miles away
    from the arena and the navigation region, rendering them useless.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏场中自动生成敌人或可收集物品实际上比乍一看要难。我们可以随机选择一个位置并在那里生成一些东西。然而，这样做可能会在墙壁或巨石内生成敌人或可收集物品。更糟糕的是，敌人或可收集物品可能会在竞技场和导航区域数英里之外生成，使它们变得无用。
- en: We could solve this in many smart and abstract ways, but often, the simplest
    way is the best to start out with. That is why we’ll construct our own entity
    spawner that can spawn different kinds of entities, enemies, collectibles, or
    anything else.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多聪明和抽象的方法解决这个问题，但通常，最简单的方法是最好的起点。这就是为什么我们将构建自己的实体生成器，它可以生成不同类型的实体，敌人、可收集物品或任何其他东西。
- en: Creating the scene structure
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建场景结构
- en: 'An easier way of solving the problem of the location of enemy spawning is by
    defining certain points within the arena at which we are sure the enemy can safely
    spawn. So, that is what we are going to do in the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解决敌人生成位置问题的更简单的方法是在竞技场内定义某些点，在这些点上我们可以确保敌人可以安全生成。所以，这就是我们在以下步骤中要做的：
- en: Create a new scene that derives from the `EntitySpawner`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，它从`EntitySpawner`派生。
- en: Save this scene as `entity_spawner.tscn` under `parts/entity_spawner`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此场景保存为`entity_spawner.tscn`，位于`parts/entity_spawner`下。
- en: 'Under `EntitySpawner`, add another `Positions`. Here we’ll later define all
    positions where we can spawn something:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EntitySpawner`下添加另一个`Positions`。在这里，我们稍后会定义所有可以生成东西的位置：
- en: '![Figure 10.28 – The structure for our EntitySpawner scene](img/B19358_10_28.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图10.28 – 我们EntitySpawner场景的结构](img/B19358_10_28.jpg)'
- en: Figure 10.28 – The structure for our EntitySpawner scene
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28 – 我们EntitySpawner场景的结构
- en: Drag and drop an instance of `EntitySpawner` into the `main.tscn` scene and
    rename it `EnemySpawner`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EntitySpawner`的一个实例拖放到`main.tscn`场景中，并将其重命名为`EnemySpawner`。
- en: 'Now, right-click `EnemySpawner` and select **Editable Children**:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击`EnemySpawner`并选择**可编辑子项**：
- en: '![Figure 10.29 – Enabling Editable Children to directly edit the children of
    an instanced scene](img/B19358_10_29.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图10.29 – 启用可编辑子项以直接编辑实例化场景的子项](img/B19358_10_29.jpg)'
- en: Figure 10.29 – Enabling Editable Children to directly edit the children of an
    instanced scene
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29 – 启用可编辑子项以直接编辑实例化场景的子项
- en: 'You will see the `EnemySpawner` scene:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到`EnemySpawner`场景：
- en: '![Figure 10.30 – Adding Marker2D nodes that will be used to position enemies](img/B19358_10_30.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图10.30 – 添加用于定位敌人的Marker2D节点](img/B19358_10_30.jpg)'
- en: Figure 10.30 – Adding Marker2D nodes that will be used to position enemies
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30 – 添加用于定位敌人的Marker2D节点
- en: 'Now, under this **Positions** node, add multiple **Marker2D** nodes and place
    them at locations where you want enemies to be able to spawn:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**位置**节点下，添加多个**Marker2D**节点，并将它们放置在你想要敌人能够生成的地方：
- en: '![Figure 10.31 – The different positions at which I wanted enemies to spawn](img/B19358_10_31.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图10.31 – 我想要敌人生成的不同位置](img/B19358_10_31.jpg)'
- en: Figure 10.31 – The different positions at which I wanted enemies to spawn
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31 – 我想要敌人生成的不同位置
- en: The `EnemySpawner` node was pretty simple to set up until now, but we did use
    some new things. Firstly, we enabled **Editable Children** on a node that is a
    complete scene. This exposes that whole scene’s structure to us and makes it easy
    for us to edit the individual nodes within. This is very useful for reusing scenes
    very directly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`EnemySpawner` 节点的设置相当简单，但我们确实使用了一些新事物。首先，我们在一个完整的场景节点上启用了 **可编辑子节点**。这使我们能够访问整个场景的结构，并使我们能够轻松地编辑其中的单个节点。这对于直接重用场景非常有用。
- en: Note that the nodes under the `EnemySpawner` node are grayed out. This means
    that we can edit them, move them around, and such, just like when we inherited
    from the collectible scene to make the health potion, but we cannot delete these
    grayed-out nodes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`EnemySpawner` 节点下的节点被灰色显示。这意味着我们可以编辑它们，移动它们，等等，就像我们从收集场景继承来制作生命药水时一样，但我们不能删除这些灰色节点。
- en: 'Next to editing the children, we used a new node type: **Marker2D**. This is
    a node that actually does nothing special during the game, but in the editor,
    it will display a little cross to mark the location it is positioned at. This
    node gets used if you need to mark a position like we are doing here.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑子节点旁边，我们使用了一种新的节点类型：**Marker2D**。这是一个在游戏过程中实际上并不做任何特殊操作的节点，但在编辑器中，它将显示一个小十字来标记其位置。当你需要标记一个位置，就像我们在这里做的那样时，会使用这个节点。
- en: Writing the base code
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写基础代码
- en: 'For the code, we’ll do something pretty simple and provide a `spawn_entity()`
    function that spawns a new entity, be it an enemy or a health potion, at one of
    the defined positions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码，我们将做一些相当简单的事情，提供一个 `spawn_entity()` 函数，该函数在定义的位置之一生成一个新实体，无论是敌人还是生命药水：
- en: '[PRE10]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first new thing that we encounter is an exported variable of the `PackedScene`
    type. This `PackedScene` variable is basically the definition of any scene – a
    scene file. Any scene file can fill this variable.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一件新事物是 `PackedScene` 类型的导出变量。这个 `PackedScene` 变量基本上是任何场景的定义——一个场景文件。任何场景文件都可以填充这个变量。
- en: Difference between a PackedScene variable and a Node variable
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackedScene` 变量和 `Node` 变量的区别'
- en: A `PackedScene` variable represents a scene file, such as the `enemy.tscn` file.
    It is a template that we can use to create new nodes from.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackedScene` 变量代表一个场景文件，例如 `enemy.tscn` 文件。它是一个模板，我们可以用它来创建新的节点。'
- en: A `Node` variable, on the other hand, is a building block of the scene tree
    and can be an instance of a `PackedScene` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，`Node` 变量是场景树的构建块，可以是 `PackedScene` 变量的实例。
- en: You could see a `PackedScene` variable as a class, while a `Node` variable is
    an instanced object of that class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `PackedScene` 变量视为一个类，而 `Node` 变量是这个类的实例化对象。
- en: 'Then, later, we can use this packed scene to instantiate a new entity:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，稍后，我们可以使用这个打包的场景来实例化一个新的实体：
- en: '[PRE11]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last thing we need to do to make this new instanced entity a part of the
    scene tree is to add it to an existing node within the tree because if we don’t
    add it somewhere within the scene tree, it is not used within the game or its
    execution.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个新实例化的实体成为场景树的一部分，我们需要将其添加到树中的现有节点上，因为如果我们不在场景树中添加它，它就不会在游戏中或其执行中使用。
- en: 'We can add a new node as a child to another node by calling the `add_child()`
    function on any node within the tree with this new entity node as the parameter.
    The entity will then get added as a child to that node. Here, we add the entity
    node to `EntitySpawner`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在树中的任何节点上调用 `add_child()` 函数并将这个新实体节点作为参数来将一个新节点作为另一个节点的子节点添加。实体随后将被添加为该节点的子节点。在这里，我们将实体节点添加到
    `EntitySpawner`：
- en: '[PRE12]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, the entity is truly put into the tree and thus within the game.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实体真正地被放入了树中，因此也位于游戏中。
- en: 'To select a random position, we also do something new. First, we get an array
    of children from the `get_children()`, which is an array of position markers.
    Then, to pick a random element from this array, we can make use of the `pick_random()`
    function to easily select one random position marker:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择一个随机位置，我们也做了一些新的操作。首先，我们从 `get_children()` 获取一个子节点数组，这是一个位置标记的数组。然后，为了从这个数组中随机选择一个元素，我们可以使用
    `pick_random()` 函数轻松地选择一个随机位置标记：
- en: '[PRE13]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will provide us with a **Marker2D** node at random that we can use to spawn
    the enemy.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个随机的 **Marker2D** 节点，我们可以用它来生成敌人。
- en: 'To make our `EnemySpawner` node that is in the `main.tscn` scene spawn enemies,
    we just need to drag and drop the `enemy.tscn` scene on top of the `EnemySpawner`
    node:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要使位于 `main.tscn` 场景中的 `EnemySpawner` 节点生成敌人，我们只需将 `enemy.tscn` 场景拖放到 `EnemySpawner`
    节点上即可：
- en: '![Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity
    Scene property](img/B19358_10_32.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图10.32 – 将enemy.tscn文件拖放到实体场景属性中](img/B19358_10_32.jpg)'
- en: Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene
    property
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32 – 将enemy.tscn文件拖放到实体场景属性中
- en: With this set up, we can start spawning entities at a fixed time interval.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，我们可以以固定的时间间隔开始生成实体。
- en: Automatically spawning entities
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动生成实体
- en: Now that we have a function that can spawn an entity, we still need to trigger
    it at some point. To do this, we are going to make use of the `timeout` signal
    when the timer runs out.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以生成实体的函数，我们仍然需要在某个时刻触发它。为此，我们将利用定时器耗尽时的`timeout`信号。
- en: 'Let’s add a `EntitySpawner` scene:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`EntitySpawner`场景：
- en: Add a `entity_spawner.tscn` scene file and call it `SpawnTimer`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`entity_spawner.tscn`的场景文件，并将其命名为`SpawnTimer`。
- en: Now, connect the timeout signal to the `EntitySpawner` root node.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将超时信号连接到`EntitySpawner`根节点。
- en: 'In the connected function, just call the `spawn_entity()` function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接函数中，只需调用`spawn_entity()`函数：
- en: '[PRE14]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a reference to the `SpawnTimer` node and an `export` variable that will
    represent the interval at which we’ll spawn entities at the top of the script:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加对`SpawnTimer`节点和一个表示我们将要生成实体的间隔的`export`变量的引用：
- en: '[PRE15]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can add two extra functions that help us start and stop the timer:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加两个额外的函数来帮助我们开始和停止定时器：
- en: '[PRE16]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lastly, to autostart the timer at the start of the game, add this `_ready()`
    function to the `EntitySpawner` script:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了在游戏开始时自动启动定时器，将此`_ready()`函数添加到`EntitySpawner`脚本中：
- en: '[PRE17]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember – when we talk about a scene, we talk about a whole scene file, such
    as the `entity_spawner.tscn` file. When we talk about a node, we are talking about
    a specific node within the scene file, such as the `EntitySpawner` node.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——当我们谈论一个场景时，我们是在谈论一个整个场景文件，例如`entity_spawner.tscn`文件。当我们谈论一个节点时，我们是在谈论场景文件中的特定节点，例如`EntitySpawner`节点。
- en: The start and stop functions will help when we want to stop enemies from spawning
    when the player dies, for example. In the body, they just start and stop `_spawn_timer`
    directly. You can see that when starting a timer, we can give a time in seconds
    that will be used as the amount of time before the timer runs out.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和停止函数将有助于我们在玩家死亡时停止生成敌人，例如。在主体中，它们只是直接开始和停止`_spawn_timer`。你可以看到，当启动定时器时，我们可以给出一个以秒为单位的时间，这将作为定时器耗尽前的时间量。
- en: Running the game now, we’ll get a new enemy every 1.5 seconds. Great! Now that
    we have a stream of enemies coming in, let’s spawn some potions so that the player
    can heal themselves.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏，我们每1.5秒就会得到一个新的敌人。太棒了！现在我们有一连串的敌人进入，让我们生成一些药水，以便玩家可以治疗自己。
- en: Spawning health potions
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成生命药水
- en: 'To spawn health potion collectibles, we can easily use the same `EntitySpawner`
    node that we just constructed! Here’s how:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成生命药水收集品，我们可以轻松地使用我们刚刚构建的相同的`EntitySpawner`节点！下面是如何做的：
- en: Add a new `EntitySpawner` node to the `main.tscn` scene and call it `HealthPotionSpawner`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tscn`场景中添加一个新的`EntitySpawner`节点，并将其命名为`HealthPotionSpawner`。
- en: 'Make this spawner’s children editable and add **Marker2D** nodes to the **Positions**
    node at which you want to spawn health potions:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这个生成器的子节点可编辑，并在你想要生成生命药水的**Positions**节点上添加**Marker2D**节点：
- en: '![Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions](img/B19358_10_34.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图10.33 – 在我想生成生命药水的地方添加Marker2D节点](img/B19358_10_34.jpg)'
- en: Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33 – 在我想生成生命药水的地方添加Marker2D节点
- en: Drag and drop the `health_potion.tscn` scene into the `Entity Scene` property
    of the spawner.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`health_potion.tscn`场景拖放到生成器的`Entity Scene`属性中。
- en: 'Set the **Spawn Interval** value of the spawner to a bigger number, such as
    20, so that we don’t spawn too many health potions:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成器的**Spawn Interval**值设置为更大的数字，例如20，这样我们就不会生成太多的生命药水：
- en: '![Figure 10.34 – Setting the Spawn Interval value to 20 seconds](img/B19358_10_35.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图10.34 – 将Spawn Interval值设置为20秒](img/B19358_10_35.jpg)'
- en: Figure 10.34 – Setting the Spawn Interval value to 20 seconds
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34 – 将Spawn Interval值设置为20秒
- en: That is it! Spawning new things is easy if we create a scene, `EntitySpawner`,
    that is easily reusable for it, isn’t it?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果我们创建一个场景，`EntitySpawner`，它很容易被重复使用，生成新事物就变得简单了，不是吗？
- en: Making a Game Over screen
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作一个游戏结束屏幕
- en: Now that enemies can damage the player and the player’s health goes down, we
    need to account for the scenario where the player’s health reaches 0\. This would
    mean the end of the game. We’ll add a little `Game Over` screen that gives the
    player the option to retry or go back to the main menu after dying.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人可以伤害玩家，玩家的生命值下降，我们需要考虑玩家生命值达到0的情况。这意味着游戏的结束。我们将添加一个“游戏结束”屏幕，玩家在死亡后可以选择重试或返回主菜单。
- en: Creating the base scene
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基本场景
- en: 'As always, we’ll start off by creating the scene structure:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从创建场景结构开始：
- en: Create a new scene that has a `GameOverMenu`, and save the scene as `game_over_menu.tscn`
    in `parts/game_over_scene`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，其中包含`GameOverMenu`，并将场景保存为`parts/game_over_scene`中的`game_over_menu.tscn`。
- en: 'Recreate the following scene structure:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建以下场景结构：
- en: '![Figure 10.35 – The scene tree for the Game Over menu](img/B19358_10_36.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图10.35 – 游戏结束菜单的场景树](img/B19358_10_36.jpg)'
- en: Figure 10.35 – The scene tree for the Game Over menu
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35 – 游戏结束菜单的场景树
- en: 'Fill each element with the right text, enlarge the `GameOverLabel` node, and
    add some separation to the **VBoxContainer** node that holds the two buttons.
    Make it so that the UI looks like this:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个元素填充为正确的文本，放大`GameOverLabel`节点，并为包含两个按钮的`VBoxContainer`节点添加一些间隔。使UI看起来像这样：
- en: '![Figure 10.36 – What the Game Over menu will look like](img/B19358_10_37.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图10.36 – 游戏结束菜单的外观](img/B19358_10_37.jpg)'
- en: Figure 10.36 – What the Game Over menu will look like
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36 – 游戏结束菜单的外观
- en: 'Now, select the `GameOverMenu` root node and set its **Anchor preset** type
    to **Full Rect**:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择`GameOverMenu`根节点并将其**锚点预设**类型设置为**全矩形**：
- en: '![Figure 10.37 – Choosing Full Rect from the Anchor presets list](img/B19358_10_38.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图10.37 – 从锚点预设列表中选择全矩形](img/B19358_10_38.jpg)'
- en: Figure 10.37 – Choosing Full Rect from the Anchor presets list
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37 – 从锚点预设列表中选择全矩形
- en: 'Now that we have a little menu, let’s add it to the `main.tscn` scene:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个小菜单，让我们将其添加到`main.tscn`场景中：
- en: In the `main.tscn` scene, add a `CanvasLayer` node.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tscn`场景中，添加一个`CanvasLayer`节点。
- en: 'Under this `CanvasLayer` node, add our freshly created `GameOverMenu` node:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此`CanvasLayer`节点下，添加我们刚刚创建的`GameOverMenu`节点：
- en: '![Figure 10.38 – The GameOverMenu node added to the scene tree](img/B19358_10_39.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图10.38 – 已添加到场景树中的GameOverMenu节点](img/B19358_10_39.jpg)'
- en: Figure 10.38 – The GameOverMenu node added to the scene tree
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38 – 已添加到场景树中的GameOverMenu节点
- en: 'Now, hide the `GameOverMenu` node by clicking the eye symbol next to the name
    of the node. We only want to show this menu when the player is dead:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击节点名称旁边的眼睛符号隐藏`GameOverMenu`节点。我们只想在玩家死亡时显示此菜单：
- en: '![Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next
    to its name](img/B19358_10_40.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图10.39 – 通过点击节点名称旁边的眼睛符号隐藏GameOverMenu节点](img/B19358_10_40.jpg)'
- en: Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next
    to its name
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39 – 通过点击节点名称旁边的眼睛符号隐藏GameOverMenu节点
- en: We use a `CanvasLayer` node to display our menu here because this node makes
    sure that all its children are displayed on top of everything else. The `CanvasLayer`
    node does not adhere to the display order that is determined by the scene tree
    order of the nodes. Within the `CanvasLayer` node, its children do again adhere
    to this order. This makes the `CanvasLayer` node very suitable for UIs within
    the game itself.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CanvasLayer`节点来显示我们的菜单，因为这个节点确保其所有子节点都显示在其他所有内容之上。`CanvasLayer`节点不遵循由节点在场景树中的顺序确定的显示顺序。在`CanvasLayer`节点内部，其子节点再次遵循此顺序。这使得`CanvasLayer`节点非常适合游戏内的UI。
- en: That was it for the base scene structure; now, we should add some logic to the
    menu.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基本场景结构已经完成；现在，我们应该向菜单添加一些逻辑。
- en: Adding logic to the Game Over menu
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加游戏结束菜单的逻辑
- en: The script for the `GameOverMenu` node is very simple. All we want to do is
    add functionality when the buttons are pressed. When the **Play** button is pressed,
    we reload the main game scene, and when the menu button is pressed, we go back
    to the main menu.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameOverMenu`节点的脚本非常简单。我们只想在按钮被按下时添加功能。当**播放**按钮被按下时，我们重新加载主游戏场景，当菜单按钮被按下时，我们返回主菜单。'
- en: 'So, connect both buttons and load the right scene in each of their connected
    functions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接两个按钮，并在它们连接的函数中加载正确的场景：
- en: '[PRE18]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that we used a new function, `reload_current_scene()`, on the tree. This
    function is very similar to `change_scene_to_file()`, except it will just change
    to the same scene as we are currently in, and we don’t have to load the scene
    file as it is obviously already loaded.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在树上使用了一个新函数`reload_current_scene()`。这个函数与`change_scene_to_file()`非常相似，但它只会切换到我们当前所在的场景，我们不需要加载场景文件，因为它显然已经加载了。
- en: The **Game Over** menu is ready; now, we just need to make use of it within
    the game.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏结束**菜单已经准备好了；现在，我们只需要在游戏中使用它。'
- en: Showing the Game Over menu when the player dies
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当玩家死亡时显示游戏结束菜单
- en: 'We have seen how we can connect to signals that nodes throw. But we can also
    make and throw our own signals! We’ll make use of this to detect when the player
    dies:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何连接到节点抛出的信号。但我们可以创建并抛出自己的信号！我们将利用这一点来检测玩家何时死亡：
- en: 'In the `player.gd` script, right under the line that carries the `extends`
    keyword, add our new signal:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`player.gd`脚本中，在包含`extends`关键字的行下面添加我们新的信号：
- en: '[PRE19]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'set(new_value):'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'set(new_value):'
- en: 'var new_health: int = clamp(new_value, 0, MAX_HEALTH)'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var new_health: int = clamp(new_value, 0, MAX_HEALTH)'
- en: 'if health > 0 and new_health == 0:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if health > 0 and new_health == 0:'
- en: died.emit()
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: died.emit()
- en: set_physics_process(false)
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(false)
- en: health = new_health
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: health = new_health
- en: update_health_label()
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: update_health_label()
- en: '[PRE20]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that to define a new signal, we just need to use the `signal` keyword,
    followed by the name of the signal.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，要定义一个新的信号，我们只需要使用`signal`关键字，后跟信号名称。
- en: Then, later on, we can just emit this signal by calling the `emit()` function
    on it. In a way, a signal is also a variable.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，稍后，我们只需通过在它上面调用`emit()`函数来发出这个信号。从某种意义上说，信号也是一个变量。
- en: To check whether the player died, we check whether the current `health` value
    is greater than 0 and the `new_health` value is 0\. This way, we are sure that
    we only trigger the `died` signal once, when the player goes from a living to
    a dead state. We don’t want this signal thrown multiple times because that would
    signal the game that the player died more than once and create unwanted side effects.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查玩家是否死亡，我们检查当前的`health`值是否大于0，以及`new_health`值是否为0。这样，我们就可以确保我们只在玩家从活着的状态变为死亡状态时触发一次`died`信号。我们不希望这个信号被多次抛出，因为这会向游戏发出信号，表明玩家死亡了不止一次，并产生不希望出现的副作用。
- en: Then, we also use the `set_physics_process()` function and give it `false` as
    the only parameter. This tells the node if it should stop executing the `_physics_process()`
    function and will effectively stop the player from moving because that is where
    all our movement code lives.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还使用`set_physics_process()`函数，并给它`false`作为唯一参数。这告诉节点是否应该停止执行`_physics_process()`函数，并将有效地阻止玩家移动，因为所有我们的移动代码都生活在这里。
- en: 'Now that the `Player` node throws a signal when it dies, we can hook into this
    with the `main.tscn` scene:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当`Player`节点在死亡时抛出信号，我们可以通过`main.tscn`场景来连接到这个信号：
- en: 'In the `main.tscn` scene, select the `Player` node. You’ll see that a new signal
    has appeared – the `died` signal that we defined in the `player.gd` script:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tscn`场景中，选择`Player`节点。你会看到出现了一个新的信号——我们在`player.gd`脚本中定义的`died`信号：
- en: '![Figure 10.40 – The signal we defined in the player’s script also turns up
    in the signal menu](img/B19358_10_41.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图10.40 – 我们在玩家脚本中定义的信号也出现在信号菜单中](img/B19358_10_41.jpg)'
- en: Figure 10.40 – The signal we defined in the player’s script also turns up in
    the signal menu
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40 – 我们在玩家脚本中定义的信号也出现在信号菜单中
- en: Add an empty script to the `Main` node of the `main.tscn` scene and connect
    the `died` signal to it.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tscn`场景的`Main`节点中添加一个空的脚本，并将`died`信号连接到它。
- en: 'In the connected function, we should show the `GameOverMenu` node and stop
    the `EnemySpawner` node and `HealthPotionSpawner`:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接函数中，我们应该显示`GameOverMenu`节点并停止`EnemySpawner`节点和`HealthPotionSpawner`：
- en: '[PRE21]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This script is pretty simple because it just needs to handle the menu and stop
    some spawners.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本相当简单，因为它只需要处理菜单并停止一些生成器。
- en: We covered a lot of ground in this section. We learned about how we can use
    the `NavigationRegion2D` and `NavigationAgent2D` nodes to make enemies navigate
    toward the player character. We used `PackedScene` variables to instance scenes
    from within the code. We used the `CanvasLayer` node to show a **Game Over** menu
    on top of the game. We created a custom signal and hooked into it. We had a lot
    of fun, and now it is time for the player to learn how to defend themselves!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们覆盖了大量的内容。我们学习了如何使用`NavigationRegion2D`和`NavigationAgent2D`节点使敌人向玩家角色导航。我们使用`PackedScene`变量在代码中实例化场景。我们使用`CanvasLayer`节点在游戏上方显示**游戏结束**菜单。我们创建了一个自定义信号并连接到它。我们玩得很开心，现在是玩家学习如何自卫的时候了！
- en: Shooting projectiles
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击投射物
- en: We’ve sent enough enemies at the player without them being able to defend themselves.
    Let’s change that in this section! We’ll be creating projectiles the player character
    automatically shoots at enemies to kill them off. To keep it simple, we’ll make
    the projectile hone in on the target we are trying to hit; this way, it never
    misses.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向玩家发送了足够的敌人，但他们无法自卫。让我们在本节中改变这一点！我们将创建玩家角色自动向敌人射击以将其消灭的投射物。为了保持简单，我们将使投射物专注于我们试图击中的目标；这样，它永远不会错过。
- en: Creating the base scene
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本场景
- en: 'Before we can shoot the projectiles, we’ll have to construct the base scene
    we’ll work from. Let’s do that right now with the following steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以射击投射物之前，我们必须构建我们将从中工作的基本场景。让我们现在按照以下步骤进行：
- en: Create a new scene that has a `Projectile`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，其中包含一个`Projectile`。
- en: 'Create a scene structure as shown next:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建如图所示的场景结构：
- en: '![Figure 10.41 – The scene tree of the projectile scene](img/B19358_10_42.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图10.41 – 投射物场景的场景树](img/B19358_10_42.jpg)'
- en: Figure 10.41 – The scene tree of the projectile scene
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41 – 投射物场景的场景树
- en: 'Use one of the textures from `assets/sprites/projectils/` as the texture for
    the sprite. Remember to set the scale of the sprite to `(``3, 3)`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`assets/sprites/projectils/`中的一个纹理作为精灵的纹理。请记住将精灵的缩放设置为`(``3, 3)`：
- en: '![Figure 10.42 – The projectile](img/B19358_10_43.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图10.42 – 投射物](img/B19358_10_43.jpg)'
- en: Figure 10.42 – The projectile
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42 – 投射物
- en: 'Now, use a `CapsuleShape2D` node for the `CollisionShape2D` node’s shape and
    make sure it covers the sprite:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`CapsuleShape2D`节点作为`CollisionShape2D`节点的形状，并确保它覆盖了精灵：
- en: '![Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D
    node](img/B19358_10_44.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图10.43 – 使用CollisionShape2D节点覆盖投射物的精灵](img/B19358_10_44.jpg)'
- en: Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43 – 使用CollisionShape2D节点覆盖投射物的精灵
- en: We’ll use the `EnemyDetectionArea`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`EnemyDetectionArea`。
- en: To detect the `Enemy` node entering the `EnemyDetectionArea` area node, name
    the third **2D Physics** layer **Projectile**.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检测`Enemy`节点进入`EnemyDetectionArea`区域节点，将第三个**2D物理**层命名为**投射物**。
- en: 'Set the `EnemyDetectionArea` area node’s **Collision Mask** property to detect
    the **Projectile** layer:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EnemyDetectionArea`区域节点的**碰撞掩码**属性设置为检测**投射物**层：
- en: '![Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea
    area node](img/B19358_10_45.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图10.44 – EnemyDetectionArea区域节点的碰撞层配置](img/B19358_10_45.jpg)'
- en: Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea
    area node
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.44 – EnemyDetectionArea区域节点的碰撞层配置
- en: 'In the `enemy.tscn` scene, set the `Enemy` node’s **Collision Layer** property
    to be on the **Projectile** layer too:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`enemy.tscn`场景中，将`Enemy`节点的**碰撞层**属性设置为与**投射物**层相同：
- en: '![Figure 10.45 – The Collision layer configuration for the enemy](img/B19358_10_46.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图10.45 – 敌人的碰撞层配置](img/B19358_10_46.jpg)'
- en: Figure 10.45 – The Collision layer configuration for the enemy
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.45 – 敌人的碰撞层配置
- en: This is all we need in terms of the scene structure, so let’s get to writing
    the behavior of the projectile.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景结构方面，我们只需要这些，所以让我们开始编写投射物的行为。
- en: Writing the logic of the projectile
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写投射物的逻辑
- en: 'Next up is the code that steers the projectile toward a target, destroys it
    on impact, and notifies the enemy it has been hit. We’ll make the projectile always
    go straight toward its target; this makes it easy for us code-wise:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是引导投射物向目标移动、在碰撞时销毁它并通知敌人它已被击中的代码。我们将使投射物始终直奔其目标；这使得我们在代码上更容易实现：
- en: 'Attach a script called `projectile.gd` to the `Projectile` root node and fill
    it with the following code to move it:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`projectile.gd`的脚本附加到`Projectile`根节点，并填充以下代码以移动它：
- en: '[PRE22]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve seen most of this code already, except for the `look_at()` function. This
    function rotates a node to orient itself toward a point in space that we provide
    it. So, here, it rotates the projectile node toward the position of the target.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到了大部分代码，除了`look_at()`函数。这个函数将一个节点旋转到我们提供的空间点，使其朝向该点。所以在这里，它将弹丸节点旋转到目标位置。
- en: 'Now, connect the `body_entered` signal from the `EnemyDetectionArea` node to
    the projectile’s script. All we need to do in the connected function is to notify
    the enemy that it got hit and destroy the projectile itself:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`EnemyDetectionArea`节点的`body_entered`信号连接到弹丸的脚本。在连接的函数中，我们只需要通知敌人它被击中，并销毁弹丸本身：
- en: '[PRE23]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, in the `enemy.gd` script, add this `get_hit()` function that we want
    to use when the projectile hits the enemy:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`enemy.gd`脚本中，添加我们希望在弹丸击中敌人时使用的`get_hit()`函数：
- en: '[PRE24]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is all we need code-wise on the side of the projectile itself.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹丸本身这一侧，我们需要的代码就这些。
- en: Spawning projectiles
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成弹丸
- en: 'We want the projectile to be shot automatically every so often. To achieve
    this, we’ll need to make some changes in the `Player` and `Enemy` scenes:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望弹丸能够每隔一段时间自动发射。为了实现这一点，我们需要在`Player`和`Enemy`场景中做一些修改：
- en: Add a `Timer` node to the `Player` scene and call this new node `ShootTimer`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`场景中添加一个`Timer`节点，并将其命名为`ShootTimer`。
- en: 'Set the time of this `ShootTimer` node to `0.5` and enable **Autostart**:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个`ShootTimer`节点的时间设置为`0.5`并启用**自动启动**：
- en: '![Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene](img/B19358_10_47.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图10.46 – 将名为ShootTimer的Timer节点添加到Player场景](img/B19358_10_47.jpg)'
- en: Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46 – 将名为ShootTimer的Timer节点添加到Player场景
- en: 'Next, in the player’s script, preload the projectile scene at the top:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在玩家脚本中，在顶部预加载弹丸场景：
- en: '[PRE25]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While the `Player` node is selected, drag and drop the `projectile.tscn` file
    into the **Projectile Scene** property in the **Inspector** tab.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择`Player`节点时，将`projectile.tscn`文件拖放到**Inspector**选项卡中的**Projectile Scene**属性。
- en: Just like with the `EntitySpawner` node, we export a variable of the `PackedScene`
    type that we can fill from the editor and instantiate later on when we need it.
    This time, though, we directly fill it with the `projectile.tscn` scene. The `preload()`
    function loads this scene and puts it in the `projectile_scene` variable, ready
    to be used. But this variable is also exported, which means that if, someday,
    we want the player to shoot a different kind of projectile, we can drag and drop
    this scene in the **Inspector** tab of the player.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`EntitySpawner`节点一样，我们导出一个`PackedScene`类型的变量，我们可以从编辑器中填充它，并在需要时实例化它。这次，我们直接用`projectile.tscn`场景填充它。`preload()`函数加载这个场景并将其放入`projectile_scene`变量中，以便使用。但这个变量也是导出的，这意味着如果有一天我们想让玩家发射不同类型的弹丸，我们可以在玩家的**Inspector**选项卡中拖放这个场景。
- en: 'We’ll now add the logic that actually spawns the projectile:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加实际生成弹丸的逻辑：
- en: 'In the `enemy.tscn` scene, add the root node to the `enemy` group as we did
    for the player. This will make sure we can access all enemy nodes later:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`enemy.tscn`场景中，将根节点添加到`enemy`组中，就像我们对玩家所做的那样。这将确保我们以后可以访问所有敌人节点：
- en: '![Figure 10.47 – Adding the enemy node to the enemy group](img/B19358_10_48.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图10.47 – 将敌人节点添加到敌人组](img/B19358_10_48.jpg)'
- en: Figure 10.47 – Adding the enemy node to the enemy group
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47 – 将敌人节点添加到敌人组
- en: 'Add a new `export` variable to the top of the `player.gd` script. This variable
    will represent how far the player can shoot in pixels:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`player.gd`脚本顶部添加一个新的`export`变量。这个变量将代表玩家可以射击多远的像素：
- en: '[PRE26]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, connect the timeout signal of the `ShootTimer` node to the `Player` node’s
    script.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`ShootTimer`节点的超时信号连接到`Player`节点的脚本。
- en: 'This should be the body for the connected signal:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该是连接信号的代码体：
- en: '[PRE27]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should also stop the `ShootTimer` node when the player dies, cache the `ShootTimer`
    node at the top of the player script, and stop it when the player’s health reaches
    0:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该在玩家死亡时停止`ShootTimer`节点，在玩家脚本顶部缓存`ShootTimer`节点，并在玩家的生命值达到0时停止它：
- en: '[PRE28]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The high-level explanation of this function’s body is that we first get a list
    of all enemies, using the group functionality. Then, we go over every single one
    of them to see how far away they are from the player. While doing this loop, we
    always keep the enemy that is the closest along with that distance. This way,
    we know that we’ll end up with the enemy that is nearest to the player character.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数体的高级解释是，我们首先使用分组功能获取所有敌人的列表。然后，我们逐一检查它们与玩家之间的距离。在执行这个循环的过程中，我们始终保留距离最近的敌人及其距离。这样，我们就知道最终会得到距离玩家角色最近的敌人。
- en: The result of this algorithm can result in no enemy being selected. That is
    why we need to make sure `closest_enemy` is not accidentally empty and need to
    return from the function if it is.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的结果可能导致没有敌人被选中。这就是为什么我们需要确保`closest_enemy`不会意外为空，并且如果它是空的，我们需要从函数中返回。
- en: After all this, we create a new projectile, set its target, add it to the scene
    tree, and put its position to the position of the player.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，我们创建一个新的投射物，设置其目标，将其添加到场景树中，并将其位置设置为玩家的位置。
- en: That was it for creating projectiles! You can now run the game and start trying
    to survive as long as possible. We also saw some more intricate code with an algorithm
    to find the closest node from any other node and how to preload a scene within
    a script.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 投射物的创建就到这里了！你现在可以运行游戏，并开始尝试尽可能长时间地生存。我们还看到了一些更复杂的代码，包括一个从任何其他节点找到最近节点的算法，以及如何在脚本中预加载场景。
- en: Storing highscores in autoloads
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自动加载节点中存储高分
- en: Now that the player can fight back and survive, we might need to give the player
    a goal to attain – something that will make them play again and again. We could
    add a highscore – for example, the amount of time the player was able to survive.
    The player can then try to better their own time or compare times with their friends.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以反击并生存下来，我们可能需要给玩家一个目标去实现——这会让他们一次又一次地玩游戏。我们可以添加一个高分——例如，玩家能够生存的时间。然后，玩家可以尝试改善自己的时间或与朋友比较时间。
- en: To achieve this, we will be using an autoload. This is a node that gets initialized
    at the start of the game and will exist throughout the complete execution of the
    game.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用一个自动加载节点。这是一个在游戏开始时初始化并在整个游戏执行过程中存在的节点。
- en: Using an autoload
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自动加载
- en: The survival time should be stored somewhere so that it is easily accessible
    from anywhere within the game. This way, we can change it after the player dies
    but also display the score on the main menu, for example.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 生存时间应该存储在某个地方，这样就可以在游戏中的任何地方轻松访问。这样，我们可以在玩家死亡后更改它，也可以在主菜单上显示分数，例如。
- en: 'Normal nodes and scenes have to be managed by us, the programmer. But there
    is another kind of node that we could use: autoloads. An autoload is a scene or
    script that is always loaded. The Godot engine initiates this scene for us anytime
    we run the game.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 正常节点和场景必须由我们程序员来管理。但还有一种我们可能使用的节点：自动加载节点。自动加载节点是指始终被加载的场景或脚本。Godot 引擎在我们运行游戏时，会为我们初始化这个场景。
- en: A node or script that is autoloaded will exist as long as the game is running.
    Earlier, when using `get_tree().change_scene_to_file()` to change scenes, everything
    of the current scene gets removed from the scene tree and switched out for the
    new scene. However, autoloads do not share the same faith; they stay put and retain
    the values of all their variables.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被自动加载的节点或脚本将存在于游戏运行期间。之前，当使用`get_tree().change_scene_to_file()`来更改场景时，当前场景的所有内容都会从场景树中移除，并替换为新的场景。然而，自动加载节点并不共享相同的命运；它们保持原位，并保留所有变量的值。
- en: Important note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although autoloads are great, they should not be misused or overused. They should
    only be used for systems that are truly global, such as the `HighscoreManager`
    autoload we are going to create in this section.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动加载节点很棒，但不应该误用或过度使用。它们应该仅用于真正全局的系统，例如我们将在本节中创建的`HighscoreManager`自动加载节点。
- en: We are not going to store the highscore autoload in a file just yet; we’ll do
    this in [*Chapter 15*](B19358_15.xhtml#_idTextAnchor740). For now, we just want
    to save and load the highscore autoload while the game is running.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会将高分自动加载节点存储在文件中；我们将在[*第15章*](B19358_15.xhtml#_idTextAnchor740)中这样做。现在，我们只想在游戏运行时保存和加载高分自动加载节点。
- en: Creating a HighscoreManager autoload
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 HighscoreManager 自动加载节点
- en: 'To create an autoload, we first need to create a normal scene or script. Because
    we don’t really need a whole scene to keep track of a highscore, which is basically
    just a number, we are going to write a script. When the Godot engine initiates
    our game, it will create a node and attach our script to it. The following steps
    illustrate the process of creating an autoload:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自动加载，我们首先需要创建一个正常的场景或脚本。因为我们实际上不需要一个完整的场景来跟踪分数，分数基本上只是一个数字，我们将编写一个脚本。当
    Godot 引擎初始化我们的游戏时，它将创建一个节点并将我们的脚本附加到它上。以下步骤说明了创建自动加载的过程：
- en: Create a new `autoloads/` folder in the root of the project.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个新的 `autoloads/` 文件夹。
- en: Add a new script in this folder called `highscore_manager.gd`.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中添加一个名为 `highscore_manager.gd` 的新脚本。
- en: 'The `HighscoreManager` script is going to be pretty simple and straightforward:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HighscoreManager` 脚本将会非常简单直接：'
- en: '[PRE29]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code defined a `highscore` variable and a `set_new_highscore()`.
    function. This function checks if the new score is bigger than the current highscore.
    If it is, we save this new, higher score; otherwise, we don’t need to bother.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 `highscore` 变量和一个 `set_new_highscore()` 函数。此函数检查新分数是否大于当前最高分。如果是，我们保存这个新的更高分数；否则，我们不需要麻烦。
- en: 'Now, let’s set this script up as an autoload:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此脚本设置为自动加载：
- en: Open the project settings and navigate to the **Autoload** tab.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目设置并导航到 **自动加载** 选项卡。
- en: 'Select the file icon button to search for a file:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件图标按钮以搜索文件：
- en: '![Figure 10.48 – Pressing the folder icon to select a file that you want to
    load as an autoload](img/B19358_10_49.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.48 – 点击文件夹图标以选择要作为自动加载加载的文件](img/B19358_10_49.jpg)'
- en: Figure 10.48 – Pressing the folder icon to select a file that you want to load
    as an autoload
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.48 – 点击文件夹图标以选择要作为自动加载加载的文件
- en: Navigate to the `autoloads/highscore_manager.gd` script.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `autoloads/highscore_manager.gd` 脚本。
- en: Select it and press **Open**.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并按 **打开**。
- en: Now, back in on the **Autoload** panel within the project settings, press the
    **Add** button.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到项目设置中的 **自动加载** 面板，点击 **添加** 按钮。
- en: 'That is all for setting up our autoload. You’ll see that the **Highscore**
    autoload is now displayed within the list of autoloads:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的自动加载就到这里了。你会看到 **Highscore** 自动加载现在显示在自动加载列表中：
- en: '![Figure 10.49 – The highscore_manager.gd script is loaded as an autoload](img/B19358_10_50.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.49 – highscore_manager.gd 脚本作为自动加载被加载](img/B19358_10_50.jpg)'
- en: Figure 10.49 – The highscore_manager.gd script is loaded as an autoload
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.49 – highscore_manager.gd 脚本作为自动加载被加载
- en: Next to seeing the script in the list of autoloads, there is another way we
    can check whether the autoload is there.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在自动加载列表中看到脚本外，我们还有另一种方法可以检查自动加载是否存在。
- en: Using a scene as an autoload
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景作为自动加载
- en: Both scripts and full scenes can be autoloads. To use a scene, load the scene
    just like we did for the script just now.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本和完整场景都可以作为自动加载。要使用场景，就像我们现在为脚本做的那样加载场景。
- en: Autoloads in the remote tree
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程树中的自动加载
- en: As said earlier, autoloads get instantiated by the Godot engine when the game
    starts running. So, we can’t see them present in separate scenes, but they should
    be there in the remote tree when we run the game.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，自动加载在游戏开始运行时由 Godot 引擎实例化。因此，我们无法在单独的场景中看到它们，但当我们运行游戏时，它们应该在远程树中。
- en: Run the game using the **Run Project** button or any scene of the game using
    the **Run Current Scene** button. Open the remote tree, and you will see a node
    called **HighscoreManager**. This is our **HighscoreManager** autoload!
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **运行项目** 按钮或使用 **运行当前场景** 按钮运行游戏。打开远程树，你会看到一个名为 **HighscoreManager** 的节点。这是我们
    **HighscoreManager** 自动加载！
- en: '![Figure 10.50 – We can see the HighscoreManager node in the remote tree](img/B19358_10_51.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.50 – 我们可以在远程树中看到 HighscoreManager 节点](img/B19358_10_51.jpg)'
- en: Figure 10.50 – We can see the HighscoreManager node in the remote tree
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.50 – 我们可以在远程树中看到 HighscoreManager 节点
- en: Now that we set up our **HighscoreManager** autoload, let’s use it within the
    game and keep some highscores!
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 **HighscoreManager** 自动加载，让我们在游戏中使用它并保存一些高分吧！
- en: Adding a UI in the main menu and game scene
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主菜单和游戏场景中添加 UI
- en: 'First, we’ll need to make sure the player knows what their score is while playing
    the game. Because we said that the score would be the amount of time the player
    is able to survive, we’ll show this score by adding a timer on the screen:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保玩家在玩游戏时知道他们的分数。因为我们说分数将是玩家能够生存的时间，我们将通过在屏幕上添加计时器来显示这个分数：
- en: In the `main.tscn` scene, under the existing `CanvasLayer` node, add a `TimerUI`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.tscn`场景中，在现有的`CanvasLayer`节点下添加一个`TimerUI`。
- en: 'For the `TimerUI` node, select the **Top Wide** anchor so that it stays on
    the top of the screen:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`TimerUI`节点，选择**顶部宽**锚点，以便它保持在屏幕顶部：
- en: '![Figure 10.51 – Selecting Top Wide from the Anchor preset list](img/B19358_10_52.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图10.51 – 从锚点预设列表中选择“顶部宽”选项](img/B19358_10_52.jpg)'
- en: Figure 10.51 – Selecting Top Wide from the Anchor preset list
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.51 – 从锚点预设列表中选择“顶部宽”选项
- en: 'Add a `TimerUI` and call it `TimeLabel`:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`TimerUI`并命名为`TimeLabel`：
- en: '![Figure 10.52 – The scene structure for our timer](img/B19358_10_53.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图10.52 – 我们计时器的场景结构](img/B19358_10_53.jpg)'
- en: Figure 10.52 – The scene structure for our timer
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.52 – 我们计时器的场景结构
- en: Let’s fill this label with a fake time of `"123"` so that we can see how the
    score will look when it is filled.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用假时间`"123"`填充这个标签，这样我们就可以看到当它被填充时分数会看起来怎样。
- en: Change the font size of this label to something larger, such as `30` px.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个标签的字体大小改为更大，例如`30` px。
- en: 'Now, we’ll need to account for the timer in the `main.gd` game script:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`main.gd`游戏脚本中考虑计时器：
- en: 'First cache a reference to the `TimeLabel` node at the top of the script and
    add a variable in which we’ll keep the current elapsed time:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，缓存脚本顶部的`TimeLabel`节点引用，并添加一个变量来保存当前已过时间：
- en: '[PRE30]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, all we need to do is update the value of this `_time` variable. We’ll
    do this in the `_process()` function by adding the delta to the current time:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要更新这个`_time`变量的值。我们将在`_process()`函数中通过添加delta到当前时间来完成这个操作：
- en: '[PRE31]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lastly, we’ll need to submit this time whenever the player dies and stop the
    game from counting more time. So, change the function that is connected to the
    `died` signal from the player to include the following two lines:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当玩家死亡时，我们需要提交这次时间并停止游戏计时。因此，更改与玩家`died`信号连接的函数，包括以下两行：
- en: '[PRE32]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s it to get the highscore linked within the game itself. Now, we’ll tackle
    showing the highscore in the main menu too.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将高分链接到游戏本身的方法。现在，我们将解决在主菜单中显示高分的问题。
- en: Using the highscore in the main menu
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主菜单中使用高分
- en: 'Now that we can make new highscores, let’s display the highest score within
    the menu:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建新的高分，让我们在菜单中显示最高分：
- en: Open the `menu.tscn` scene.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`menu.tscn`场景。
- en: Add a new `HighscoreLabel`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`HighscoreLabel`。
- en: 'Now, in the `menu.gd` script, add the following code:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`menu.gd`脚本中添加以下代码：
- en: '[PRE33]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is that the menu will now show the current highscore:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，菜单现在将显示当前最高分：
- en: '![Figure 10.53 – The main menu with an added Highscore label](img/B19358_10_54.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图10.53 – 添加了Highscore标签的主菜单](img/B19358_10_54.jpg)'
- en: Figure 10.53 – The main menu with an added Highscore label
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.53 – 添加了Highscore标签的主菜单
- en: None of this code is new to us. First, we save the `highscore_label`. Next,
    when the menu scene is ready, we populate the **HighscoreLabe**l with a string
    that contains the current highest score.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这段代码并不陌生。首先，我们保存`highscore_label`。接下来，当菜单场景准备就绪时，我们用包含当前最高分的字符串填充**HighscoreLabe**l。
- en: That was our venture into autoloads. We saw how easy it is to add a script or
    scene as a node that is always loaded at the start of our game without having
    to manage this node ourselves. Then, we made use of this autoload through its
    global variable to save information between different scenes.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对自动加载的探索。我们看到了如何轻松地将脚本或场景作为节点添加，这个节点在游戏开始时总是被加载，而不需要我们自行管理这个节点。然后，我们通过其全局变量使用这个自动加载来在不同场景之间保存信息。
- en: Additional exercises – Sharpening the axe
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外练习 – 锋利斧头
- en: 'Enemies get spawned at a slow, fixed rate. This can get a little boring because
    the difficulty never really increases. Make it so that enemies get spawned faster
    and faster after every round. For a simple way of doing this, you could follow
    the next steps:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 敌人以缓慢、固定的速率生成。这可能会有些无聊，因为难度从未真正增加。让敌人在每一轮之后更快地生成。为了简单起见，你可以按照以下步骤操作：
- en: 'Add `start_interval`, `end_interval`, and `time_delta` as export variables
    to the `EntitySpawner` node. The `start_interval` variable will be the time we
    use between spawning entities at the start of the game, `end_interval` will be
    the final value, and `time_delta` is the increment at which we will go from the
    `start_interval` variable to the `end_interval` variable:'
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`start_interval`、`end_interval`和`time_delta`作为导出变量添加到`EntitySpawner`节点。`start_interval`变量将是游戏开始时生成实体之间使用的时间，`end_interval`将是最终值，而`time_delta`是我们将从`start_interval`变量增加到`end_interval`变量的增量：
- en: '![Figure 10.54 – The new exported variables for the EntitySpawner node](img/B19358_10_55.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图10.54 – EntitySpawner节点的新的导出变量](img/B19358_10_55.jpg)'
- en: Figure 10.54 – The new exported variables for the EntitySpawner node
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.54 – EntitySpawner节点的新的导出变量
- en: Now, track in a separate variable, `_current_spawn_interval`, the time for the
    next enemy to spawn. Set `_current_spawn_interval` equal to the `start_interval`
    variable at the start of the game. This variable replaces the old `spawn_interval`
    variable.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在单独的变量 `_current_spawn_interval` 中跟踪下一个敌人生成的间隔时间。在游戏开始时将 `_current_spawn_interval`
    设置为 `start_interval` 变量。此变量取代了旧的 `spawn_interval` 变量。
- en: Every time we spawn an entity in the `spawn_entity` function, add the `time_delta`
    variable to the `_current_spawn_interva``l` variable. Make sure to not go past
    the `end_interval` variable, though.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们在 `spawn_entity` 函数中生成实体时，都将 `time_delta` 变量添加到 `_current_spawn_interva`
    变量中。不过，请确保不要超过 `end_interval` 变量。
- en: 'Then, still in the `spawn_entity()` function, start `_spawn_timer` again but
    with the new `_current_spawn_interval` variable: by calling `start_timer()` again.
    For the `HealthPotionSpawner` node, you’ll have to set `time_delta` to `0.0`.'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，仍然在 `spawn_entity()` 函数中，重新启动 `_spawn_timer`，但使用新的 `_current_spawn_interval`
    变量：再次调用 `start_timer()`。对于 `HealthPotionSpawner` 节点，您需要将 `time_delta` 设置为 `0.0`。
- en: The menu that shows up when the player dies is quite lacking in information.
    Add a nice label to show the score the player just achieved.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家死亡时出现的菜单信息相当匮乏。添加一个漂亮的标签来显示玩家刚刚获得的分数。
- en: Summary
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned and created so many different things within this chapter. First,
    we learned all about `NavigationServer` property. To let the player have a chance
    to defend themselves, we created projectiles that get shot automatically on a
    timer. Lastly, we added a small high-score system that stores the current highscore
    within an autoload so that the player is incentivized to replay the game and try
    to beat their own best time.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习和创建了如此多的不同事物。首先，我们学习了有关 `NavigationServer` 属性的所有内容。为了给玩家提供自卫的机会，我们创建了自动定时发射的弹体。最后，我们添加了一个小的得分系统，将当前最高分存储在自动加载中，这样玩家就有动力重玩游戏并尝试打破自己的最佳成绩。
- en: 'In the next chapter, we’ll do something very interesting: make our game multiplayer!'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将做一些非常有趣的事情：使我们的游戏成为多人游戏！
- en: Quiz time
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验时间
- en: '**Control** nodes are used to create UIs such as menus. For each of the following
    scenarios, give a **Control** node that could do the job:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**节点用于创建菜单等UI。对于以下每个场景，给出一个可以完成任务的**控制**节点：'
- en: Showing a long piece of text
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一段长文本
- en: Grouping other **Control** nodes to the center of the screen
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其他**控制**节点组合到屏幕中心
- en: Showing a button to start the game
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个按钮以开始游戏
- en: Which node did we add to the `Enemy` scene to make it find a path to the player?
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `Enemy` 场景中添加了哪个节点来使其找到玩家的路径？
- en: 'Let’s say that we have this piece of code where we define a signal called `shot`
    to indicate that we shot a projectile:'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一段代码，其中定义了一个名为 `shot` 的信号，用来指示我们发射了一个弹体：
- en: '[PRE34]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Write the line of code that is needed to emit this signal.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写发出此信号的所需代码行。
- en: How do you load a scene from within the code into a variable?
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在代码中从场景加载到变量中？
- en: How can we make a script globally accessible?
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使脚本全局可用？
