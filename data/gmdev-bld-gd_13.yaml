- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Finishing with Sound and Animation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以声音和动画结束
- en: We’re in the home stretch. The effort we started back in [*Chapter 9*](B17473_09.xhtml#_idTextAnchor146),
    *Designing the Level*, was resumed by making the level look more exciting in [*Chapter
    10*](B17473_10.xhtml#_idTextAnchor165), *Making Things Look Better with Lights
    and Shadows*, which led us to implement a basic user interface in [*Chapter 11*](B17473_11.xhtml#_idTextAnchor186),
    *Creating the User Interface*. We built new mechanics in [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206),
    *Interacting with the World through Camera and Character Controllers*, so we could
    interact with the world we have created. As a result, Clara is now able to press
    the parchment left by her uncle, and she can also walk around. This is all very
    nice, and we can take it a step further by refining some rough edges.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进入冲刺阶段。我们最初在[*第 9 章*](B17473_09.xhtml#_idTextAnchor146)，*设计关卡*中开始的努力，通过使关卡在[*第
    10 章*](B17473_10.xhtml#_idTextAnchor165)，*使用光影使事物看起来更好*中看起来更有趣，这使我们能够在[*第 11 章*](B17473_11.xhtml#_idTextAnchor186)，*创建用户界面*中实现基本用户界面。我们在[*第
    12 章*](B17473_12.xhtml#_idTextAnchor206)，*通过摄像头和角色控制器与世界交互*中构建了新的机制，这样我们就可以与我们创建的世界进行交互。因此，克拉拉现在能够按下她叔叔留下的羊皮纸，她也可以四处走动。这一切都很不错，我们可以通过细化一些粗糙的边缘来更进一步。
- en: It’s all quiet in here! As she’s walking, we should trigger an audio file that
    will simulate her footsteps. While we are at it, we will also add background music
    and effects that will better reflect the qualities of the environment Clara is
    in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里很安静！当她走动时，我们应该触发一个音频文件，以模拟她的脚步声。在此同时，我们还将添加背景音乐和效果，以更好地反映克拉拉所在环境的特性。
- en: You must have noticed that, as Clara walks around, sconces and candles around
    the level illuminate her. Can she do the same with the torch she is holding in
    her hand? Of course! It might help her see the backpack behind the cart. In fact,
    she’s going to have to use her torch to see better because we’ll turn off all
    of the light sources in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，当克拉拉四处走动时，周围级别的壁炉和蜡烛会照亮她。她能否用她手中持有的火炬做到同样的效果？当然可以！这可能会帮助她看到推车后面的背包。事实上，她将不得不使用火炬来更好地看清楚，因为我们将在本章中关闭所有的光源。
- en: We’ll discover a new node in Godot to know whether a player character entered
    an area. Via this method, game designers usually trigger in-game events such as
    traps, a conversation with a quest giver, and so on. Our event choice will be
    Clara lighting the sconces and candles as she goes near them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Godot 中发现一个新的节点，以了解玩家角色是否进入了一个区域。通过这种方法，游戏设计师通常会触发游戏中的事件，如陷阱、与任务提供者的对话等。我们的事件选择将是克拉拉在靠近壁炉和蜡烛时点亮它们。
- en: Eventually, she’ll reach the backpack where she’ll pick up the key. We are not
    concerned with an inventory system in this game, yet we will consider this key
    object as a requirement for opening the door. So, once the condition is satisfied,
    we need that door to open for us. However, the door did not come into Godot with
    its animation set up in Blender. This is our chance to see how basic animations
    can be created inside Godot.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，她将到达背包那里，她会拿起钥匙。我们在这个游戏中不关心库存系统，但我们将考虑这个钥匙对象作为打开门的必要条件。因此，一旦条件满足，我们需要那扇门为我们打开。然而，这扇门并没有在
    Blender 中设置好动画就进入了 Godot。这是我们看看如何在 Godot 内部创建基本动画的机会。
- en: When all of the conditions are in place, including the door opening that simulates
    a clear path upstairs, we’ll swap our current level with another one. That particular
    moment will signify the conclusion of our little game, but you can take it wherever
    you want to take it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有条件都满足时，包括打开门以模拟清晰的楼梯路径，我们将用另一个关卡替换当前关卡。那个特定的时刻将标志着我们小游戏结束的标志，但你可以将它带到你想去的地方。
- en: 'This is going to be another chapter with lots of distinct topics used together.
    Speaking of which, the following are the titles under which you’ll find us executing
    the plan we’ve presented so far:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将又是一个包含许多不同主题的章节。说到这一点，以下是我们执行到目前为止所提出的计划的标题：
- en: Playing music and sound effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音乐和音效
- en: Creating reaction spots
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建反应点
- en: Building simple animations in Godot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Godot 中构建简单的动画
- en: Loading another level
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载另一个关卡
- en: By the end of this chapter, you’ll have finished the core mechanics of our point-and-click
    adventure game. Not only will you construct and work with new systems, but you’ll
    also make these systems conditional on world or character events.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将完成我们点按式冒险游戏的核心理念。你不仅将构建并使用新的系统，而且还将使这些系统根据世界或角色事件进行条件化。
- en: Good luck and enjoy!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运，享受吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It’s perfectly fine if you would like to continue where you left off in the
    previous chapter. However, there are some extra resources you will need to finish
    the work in this chapter. You can merge these assets with the rest of your project
    files. They are in the `Resources` folder next to the `Finish` folder in this
    book’s repository that can be found at [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意继续在上一章结束的地方继续，那完全没问题。然而，你需要一些额外的资源来完成本章的工作。你可以将这些资源与你的项目文件合并。它们位于本书仓库中的`Finish`文件夹旁边的`Resources`文件夹中，该仓库可在[https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot)找到。
- en: Playing music and sound effects
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐和音效
- en: Music and sound effects sometimes can make or break the enjoyment people get
    out of movies, theatre plays, and of course, video games. When done right, they
    will definitely add to the immersion. In this section, we’ll tackle the use of
    music and sound effects from a technical point of view. In your own free time,
    we suggest you investigate the artistic aspects of sound design in multimedia
    for which we’ll mention a few resources later on in the *Further reading* section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐和音效有时可以决定人们从电影、戏剧和当然，电子游戏中获得的乐趣。当做得正确时，它们肯定会增加沉浸感。在本节中，我们将从技术角度探讨音乐和音效的使用。在你的空闲时间，我们建议你调查多媒体中声音设计的艺术方面，我们将在*进一步阅读*部分提到一些资源。
- en: 'In [*Chapter 8*](B17473_08.xhtml#_idTextAnchor129), *Adding Sound Assets*,
    we discussed different nodes Godot uses to play sound in different dimensions,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17473_08.xhtml#_idTextAnchor129) *添加声音资源*中，我们讨论了Godot用于在不同维度播放声音的不同节点，如下所示：
- en: '**AudioStreamPlayer3D** for conveying 3D positional information to the player.
    It’s most commonly used in FPS games where not only front and back directions
    matter, but an audio stream coming from an elevated place is important as well.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AudioStreamPlayer3D** 用于向玩家传达3D位置信息。它最常用于FPS游戏中，不仅前后方向很重要，而且来自高处音频流也很重要。'
- en: '**AudioStreamPlayer2D** for games in which the direction the sound is coming
    from doesn’t need to have depth information. Most platformer games are a good
    example of this kind.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AudioStreamPlayer2D** 用于那些不需要声音来源方向具有深度信息的游戏。大多数平台游戏是这种类型的良好例子。'
- en: '**AudioStreamPlayer** for background music since it may be considered one-dimensional.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AudioStreamPlayer** 用于背景音乐，因为它可能被认为是一维的。'
- en: Out of these three, two types seem to be the right candidates for our purposes.
    We want to play background music, so we will use **AudioStreamPlayer**. Then,
    when Clara is walking around, it makes sense to use **AudioStreamPlayer3D**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种类型中，两种似乎是我们目的的正确候选人。我们想要播放背景音乐，所以我们将使用**AudioStreamPlayer**。然后，当克拉拉四处走动时，使用**AudioStreamPlayer3D**是有意义的。
- en: The latter case may not seem obvious, and we can certainly use the regular **AudioStreamPlayer**
    as well for the footsteps, but we will cross that bridge when we come to it. Our
    most immediate concern is to set up the ambient music.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种情况可能不太明显，我们当然也可以使用常规的**AudioStreamPlayer**来播放脚步声，但当我们到达那里时再解决它。我们最紧迫的任务是设置环境音乐。
- en: Setting background music
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置背景音乐
- en: In the *Understanding the camera system* section of [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206),
    *Interacting with the World through Camera and Character Controllers*, we showed
    the use of an outer scene structure, such as `Game.tscn`, to hold the level we
    built in [*Chapter 9*](B17473_09.xhtml#_idTextAnchor146), *Designing the Level*.
    A wrapper structure such as ours is also a good place to place more global-scale
    constructs, such as audio streamers. Yet, we would like to discuss an alternative
    before we move on with our initial plan.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B17473_12.xhtml#_idTextAnchor206) *通过摄像头和角色控制器与世界交互*的*理解摄像头系统*部分，我们展示了如何使用外部场景结构，如`Game.tscn`，来保存我们在[*第9章*](B17473_09.xhtml#_idTextAnchor146)
    *设计关卡*中构建的水平。像我们这样的包装结构也是放置更多全局规模结构的好地方，例如音频流。然而，在我们继续我们的初步计划之前，我们想讨论一个替代方案。
- en: Although a player character is part of the game world, we decided to place it
    inside the level via a `Level-01.tscn` scene. If you place it inside `Game.tscn`,
    for the sake of keeping things separate and sanitized, then you will have to figure
    out a way to connect both the `Game.tscn`. This would not be impossible, but it
    would make things less convenient.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然玩家角色是游戏世界的一部分，但我们决定通过`Level-01.tscn`场景将其放置在关卡内。如果你将其放置在`Game.tscn`中，为了保持事物的分离和清洁，你将不得不想出一种方法来连接两个`Game.tscn`。这并非不可能，但会使事情变得不那么方便。
- en: Similarly, where should you place the node that will play the background music?
    Although we may want every level to play its own thematic music, and this would
    guide us in the direction of using an `Game.tscn`. When we attack the topic of
    loading different levels in the *Loading another level* section, hopefully, the
    scheme we are suggesting will make more sense.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你应该将播放背景音乐的节点放在哪里？虽然我们可能希望每个关卡都播放其主题音乐，这会引导我们使用`Game.tscn`。当我们讨论*加载另一个关卡*部分中的加载不同关卡的话题时，我们希望我们提出的方案会更有意义。
- en: 'Let’s see how we can execute the original plan. Open the `Game.tscn` scene
    and perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行原始计划。打开`Game.tscn`场景并执行以下步骤：
- en: Add an **AudioStreamPlayer** node to the root and rename it as **BackgroundMusic**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点处添加一个**AudioStreamPlayer**节点，并将其重命名为**BackgroundMusic**。
- en: Drag `Native Dream.mp3` from **FileSystem** to the **Stream** property of this
    new node.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Native Dream.mp3`从**FileSystem**拖动到新节点的**Stream**属性。
- en: Turn on the **Autoplay** option in the **Inspector** panel.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中打开**自动播放**选项。
- en: Press *F5* and relax.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F5*键并放松。
- en: The piece of music we are using is about 2 minutes long and it will be automatically
    looped by Godot. Thus, it won’t feel too repetitive while Clara or the player
    is discovering the level.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的音乐片段大约2分钟长，并且将由Godot自动循环。因此，当克拉拉或玩家探索关卡时，不会感觉过于重复。
- en: 'Speaking of placing a background music structure at a higher level, there is
    one more approach you can use: **singletons**, also known as **AutoLoad**. For
    absolute beginners, these are the ultimate top-level structures you can use in
    your project. These will always be present when you launch your game and loaded
    in the order you define them in the **AutoLoad** tab of **Project Settings**.
    Via this method, you can use a dedicated scene as a single source of music. You
    can read more about it at [https://docs.godotengine.org/en/3.4/tutorials/scripting/singletons_autoload.xhtml](https://docs.godotengine.org/en/3.4/tutorials/scripting/singletons_autoload.xhtml).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 说到在更高层次放置背景音乐结构，你还可以使用另一种方法：**单例**，也称为**AutoLoad**。对于绝对初学者来说，这些是在你的项目中可以使用的最高级别的结构。当你启动游戏时，它们总是存在，并且按照你在**项目设置**的**AutoLoad**选项卡中定义的顺序加载。通过这种方法，你可以使用一个专门的场景作为音乐的单个来源。你可以在[https://docs.godotengine.org/en/3.4/tutorials/scripting/singletons_autoload.xhtml](https://docs.godotengine.org/en/3.4/tutorials/scripting/singletons_autoload.xhtml)了解更多信息。
- en: Some players turn off game music for the sake of focusing on sound effects.
    In the following section, we’ll introduce our first sound effect. We expect Clara’s
    walking to trigger a suitable sound effect, namely footsteps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些玩家关闭游戏音乐是为了专注于音效。在接下来的部分，我们将介绍我们的第一个音效。我们期望克拉拉的走路会触发一个合适的音效，即脚步声。
- en: Conditionally playing a sound
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件播放声音
- en: Let’s see how we can play a sound file conditionally in this section. There
    is actually nothing magical nor special in the way of achieving this goal. It’s
    similar to knowing when Clara walks or stands idly. In the *Playing the right
    action for Clara* section of [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206),
    *Interacting with the World through Camera and Character Controllers*, we implemented
    two extra lines of code inside the `move_along` function to trigger the correct
    actions for Clara to show, animation-wise, the state she is currently in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在本文档中条件性地播放声音文件。实际上，实现这个目标并没有什么神奇或特别的方法。这与知道克拉拉是走路还是静止不动相似。在[*第12章*](B17473_12.xhtml#_idTextAnchor206)的*通过摄像头和角色控制器与世界交互*部分，我们在`move_along`函数中实现了两行额外的代码，以触发克拉拉显示的正确动作，从动画上展示她当前的状态。
- en: We could still take advantage of the same function by enabling the execution
    of the sound file for her footsteps. That being said, now might be a good moment
    to discuss some of our practices. It would seem that we are overloading the meaning
    of the `move_along` function. You might consider our current efforts still a phase
    of building a prototype similar to, as is often said during a writing exercise,
    writing a draft, then focusing on edits later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启用声音文件播放功能来利用相同的函数。话虽如此，现在可能是讨论我们的一些实践的好时机。看起来我们过度使用了 `move_along` 函数的含义。你可能会认为我们目前的努力仍然是一个类似于写作练习中写作草稿的阶段，然后专注于后续的编辑。
- en: Sometimes, good architecture might be deduced before you start the bulk of the
    work, perhaps because you’ve done something similar before. Often, though, this
    may not be the case, and your discoveries, thus your decisions into coming up
    with an efficient architecture, might have to wait for later. As soon as you notice
    there are common parts you can extract out of the current structures, you should.
    However, concerning yourself with the fine details of creating the most efficient
    code structure and information flow might not be the best use of your time while
    you are still deciding on gameplay.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在开始大量工作之前，你可能就能推断出良好的架构，可能是因为你之前做过类似的事情。然而，通常情况下，情况可能并非如此，你的发现以及你为了提出一个高效的架构所做的决策可能需要等待以后。一旦你注意到你可以从当前结构中提取出共同的部分，你应该这样做。然而，在决定游戏玩法时，过分关注创建最有效的代码结构和信息流的细节可能不是最好的时间利用方式。
- en: 'So, for now, we’ll add the footsteps sound as an extra element inside the `move_along`
    function until we need a much more efficient way, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们将脚步声添加为 `move_along` 函数内的一个额外元素，直到我们需要一个更高效的方法，如下所示：
- en: Open the `Player.tscn` scene and add `FootSteps`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Player.tscn` 场景并添加 `FootSteps`。
- en: 'Select `FootSteps.wav` and switch to the **Import** panel. Then do as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `FootSteps.wav` 并切换到**导入**面板。然后按照以下步骤操作：
- en: Turn on both the **Loop** and **Normalize** options.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**循环**和**归一化**选项。
- en: Press **Reimport**.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**重新导入**。
- en: Drag `Footsteps.wav` from **FileSystem** to the **Stream** field in the **Inspector**
    panel.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Footsteps.wav` 从**文件系统**拖动到**检查器**面板中的**流**字段。
- en: Turn on both the **Autoplay** and **Stream Paused** properties.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**自动播放**和**流暂停**属性。
- en: 'In the `Clara.gd` script, do as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Clara.gd` 脚本中，按照以下步骤操作：
- en: Type `$FootSteps.stream_paused = false` after you trigger her walk action.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触发她的行走动作后，输入 `$FootSteps.stream_paused = false`。
- en: Type `$FootSteps.stream_paused = true` after you trigger her idle action.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触发她的空闲动作后，输入 `$FootSteps.stream_paused = true`。
- en: The method we are using here was discussed in the *Playing a sound effect on
    demand* section of [*Chapter 8*](B17473_08.xhtml#_idTextAnchor129), *Adding Sound
    Assets*, when repeatedly triggering a sound file in a loop might sound like the
    sound is jammed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的方法在[*第8章*](B17473_08.xhtml#_idTextAnchor129)的*按需播放声音效果*部分进行了讨论，*添加声音资产*，当重复触发声音文件时，可能会听起来像声音被卡住。
- en: Additionally, we turned on the loop feature and normalized the volume. The loop
    is self-explanatory since we will want her footsteps to repeat ceaselessly as
    long as she’s walking. The **Normalize** option deserves a few more words, though.
    The sound files we are using in this project have been collected from multiple
    sources. This makes it hard to have all these files have a similar level of volume.
    Some will be louder, some will be quieter. The feature we turned on adjusts the
    volume of the sound file, so it would be at a similar level to the other files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还打开了循环功能并归一化了音量。循环功能是显而易见的，因为我们希望她的脚步声在她行走时不断重复。然而，**归一化**选项值得多说几句。我们在这个项目中使用的声音文件是从多个来源收集的。这使得所有这些文件具有相似的音量水平变得困难。有些会响亮，有些会安静。我们打开的功能调整了声音文件的音量，使其与其他文件处于相似的水平。
- en: When you run the game now, you’ll hear the background music as usual. Then,
    click around and wait for Clara to walk to the desired spot. Do you hear her footsteps?
    Most likely just barely. We’ll look into adjusting audio volume later in the *Understanding
    the volume through decibels* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行游戏时，你会听到背景音乐，然后四处点击并等待克拉拉走到指定的地点。你听到她的脚步声了吗？很可能是刚刚听到。我们将在*通过分贝理解音量*部分稍后调整音频音量。
- en: For the time being, it might be better if we presented a handy feature in Godot.
    There might come a time when you would like to apply special effects to some of
    the sound files you are playing. Godot offers multiple audio channels, also known
    as an **audio bus**, via which you can decide which files will play on a specific
    channel so you can apply a particular effect only on select channels.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果在 Godot 中展示一个实用的功能可能更好。可能会有这样的时候，您希望对正在播放的一些声音文件应用特殊效果。Godot 提供了多个音频通道，也称为**音频总线**，通过它可以决定哪些文件将在特定通道上播放，以便您可以在选定的通道上应用特定的效果。
- en: 'We’ll now pretend that there is a situation like this and play the footsteps
    sound in its own audio channel. Let’s see how it is done as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在假设存在这种情况，并将脚步声在它自己的音频通道上播放。让我们看看如何操作，如下所示：
- en: Expand the **Audio** panel at the bottom section of Godot Engine. Click on the
    **Add Bus** button in the top right corner of the **Audio** panel.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Godot 引擎底部部分展开**音频**面板。在**音频**面板右上角点击**添加总线**按钮。
- en: Rename this `SFX`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此`SFX`重命名。
- en: Select the **FootSteps** node and choose the **SFX** option in the drop-down
    options for **Bus**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**FootSteps**节点，并在**Bus**的下拉选项中选择**SFX**。
- en: The footsteps sound will now be played on a different audio channel in Godot.
    The interface that’s reflecting the changes we have made is shown in *Figure 13.1*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 中，脚步声现在将在不同的音频通道上播放。显示我们所做更改的界面在*图 13.1*中。
- en: '![Figure 13.1 – We are playing the sound effect on its own bus ](img/Figure_13.1_B17473.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 我们正在自己的总线上播放声音效果](img/Figure_13.1_B17473.jpg)'
- en: Figure 13.1 – We are playing the sound effect on its own bus
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 我们正在自己的总线上播放声音效果
- en: Via this method, a dedicated audio channel will play the sound you want. As
    you can see at the bottom of the **SFX** bus in the **Audio** panel in *Figure
    13.1*, the audio is sent to the **Master** channel. When all the audio sources
    are merged and processed, it’s delivered to **Speakers**. Furthermore, by using
    the **Add Effect** dropdown for an audio bus, you can apply and stack effects
    that go through this channel.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，一个专门的音频通道将播放您想要的声音。如您在*图 13.1*中底部**SFX**总线在**音频**面板中看到的那样，音频被发送到**主**通道。当所有音频源合并并处理完毕后，它会被送到**扬声器**。此外，通过使用音频总线的**添加效果**下拉菜单，您可以应用并堆叠通过此通道的效果。
- en: Although you hear both pieces of audio, they might be competing volume-wise.
    In the following section, we’ll get a bit technical about how audio volume works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您能听到两段音频，但它们在音量上可能存在竞争。在下一节中，我们将稍微深入探讨音频音量是如何工作的。
- en: Understanding the volume through decibels
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过分贝理解音量
- en: Every vocation has its trade secrets and unique practices, and this is also
    true for sound engineers. When they talk about volume as how loud a sound is,
    they use a unit called **decibel**, marked as **dB**. If you are used to the metric
    system, this is one-tenth of a bel, similar to a decimeter as one-tenth of a meter.
    However, what exactly is a bel?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个行业都有其商业机密和独特的实践，声音工程师也是如此。当他们谈论声音的响度时，他们使用一个称为**分贝**的单位，标记为**dB**。如果您习惯了公制系统，这相当于十分之一贝尔，类似于分米是米十分之一。然而，贝尔究竟是什么？
- en: Wikipedia has a page that provides a decent amount of technical information
    for the decibel. Therefore, we’ll provide you with the practical aspects and/or
    pitfalls of working with decibels in your projects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有一个页面，提供了关于分贝的相当数量的技术信息。因此，我们将向您提供在项目中使用分贝的实际方面和/或潜在问题。
- en: Similar to how earthquake magnitude is measured, a decibel is a relative scale
    where every time you increase the sound level by 6 dB, you double the amplitude
    of the sound. Consequently, -6 dB means you are halving the amplitude. As far
    as values go, 0 dB is the maximum amplitude a digital audio system will use. Anything
    above this value, which means positive values, will be clipped. So, you might
    still hear something above 0 dB, but it will be distorted the higher you go in
    decibels. Thus, you’ll be using the negative range when it comes to picking values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与地震震级测量类似，分贝是一个相对的刻度，每次您将声音级别提高 6 dB，声音的振幅就会加倍。因此，-6 dB 意味着您将振幅减半。就数值而言，0 dB
    是数字音频系统将使用的最大振幅。任何高于此值的值，即正值，都会被截断。所以，您可能仍然能在 0 dB 以上听到一些声音，但随着分贝的增加，声音会失真。因此，在挑选值时，您将使用负数范围。
- en: Moreover, there are physical limits to human hearing. Sound is no longer audible
    between -60 dB and -80 dB. So, in the end, you have from -60 dB to 0 dB as a workable
    range. If all of this is confusing, there is perhaps one important fact you might
    want to keep in mind about decibels. 0 dB denotes the normal amplitude of the
    sound when it was exported from an audio application. If the base level at 0 dB
    is too quiet, you might have to fix it at the source rather than messing with
    it by choosing a higher dB value in Godot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人类听觉有物理限制。声音在-60 dB到-80 dB之间不再可闻。因此，最终，你的工作范围是从-60 dB到0 dB。如果所有这些都令人困惑，关于分贝可能有一个重要的事实你需要记住。0
    dB表示声音从音频应用程序导出时的正常振幅。如果0 dB的基线太安静，你可能需要在源头上进行修复，而不是在Godot中选择更高的dB值来调整。
- en: 'That being said, we can decrease the amplitude easily. This is indeed what
    we are going to do with the background music as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以轻松地降低振幅。这正是我们打算对背景音乐所做的那样：
- en: Open `Game.tscn` and select the **BackgroundMusic** node.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Game.tscn`并选择**BackgroundMusic**节点。
- en: Adjust `-12`, or even `-18`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`-12`，甚至`-18`。
- en: Since you are now able to discern the footsteps from the background music better,
    did you notice how Clara’s footsteps get louder as she approaches the camera and
    quieter as she walks toward the end of the cave? This is thanks to the **AudioStreamPlayer3D**
    node’s behavior of processing audio in 3D. If you want to perceive this effect
    more clearly, feel free to temporarily turn off the background music and focus
    on the directionality of Clara’s footsteps.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你现在能够更好地从背景音乐中辨别脚步声，你是否注意到克拉拉的脚步声在她靠近摄像机时变响，在她走向洞穴尽头时变轻？这要归功于**AudioStreamPlayer3D**节点的3D音频处理行为。如果你想更清楚地感知这种效果，可以随时暂时关闭背景音乐，专注于克拉拉脚步声的方向性。
- en: Who is listening?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 谁在听？
- en: The **Camera** node has a built-in **Listener** construct that makes it possible
    for us to identify from which direction the sound is coming. In some cases, we
    may want the camera to be in one corner of the world and the listener in another
    corner. Thus, creating a separate **Listener** node is not only possible, but
    it will also be beneficial when you want to simulate a situation where a microphone
    is placed away from the camera.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Camera**节点内置了一个**Listener**构造，这使得我们可以确定声音是从哪个方向传来的。在某些情况下，我们可能希望摄像机位于世界的某个角落，而监听器位于另一个角落。因此，创建一个单独的**Listener**节点不仅可能，而且当你想要模拟麦克风远离摄像机放置的情况时，这将非常有用。'
- en: If you would like to practice more on playing sound files, we suggest you add
    a sound effect to the `ButtonPress.wav` in the `Audio` folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多练习播放声音文件，我们建议你在`Audio`文件夹中添加一个声音效果到`ButtonPress.wav`。
- en: It seems the world is reacting to our actions by playing animations and sound
    files, which is nice. In all of these efforts, we’ve had a direct involvement
    mainly by a mouse click. In the following section, we’ll discover how the world
    can react to our player character without the player’s direct intervention.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来世界正在通过播放动画和声音文件对我们的行动做出反应，这很好。在这些努力中，我们主要通过鼠标点击直接参与。在下一节中，我们将发现世界如何在没有玩家直接干预的情况下对玩家角色做出反应。
- en: Creating reaction spots
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建反应点
- en: When the player clicks on the parchment, the game shows the content written
    on that parchment via a user interface. When the player clicks on a particular
    location in the world, Clara walks to that spot by playing a walking animation
    and playing a footsteps sound. These are all direct interactions at the player’s
    end, which brings us to discuss cases when the game should react to indirect events.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击羊皮纸时，游戏通过用户界面显示羊皮纸上写的内容。当玩家点击世界中的特定位置时，克拉拉通过播放行走动画和脚步声走到那个地方。这些都是玩家端的直接交互，这让我们讨论游戏应该对间接事件做出反应的情况。
- en: Although not lit, Clara is holding a torch. You already know how to use the
    **Light** nodes in Godot. So, it’s easy to place **OmniLight** near the torch
    mesh inside the **Clara** node. Our basic expectation is that, when she walks
    by the candles on the floor and the sconces on the walls, she’ll be lighting those
    up using her torch. Thus, the game needs to know when she’s near some objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有点亮，克拉拉手持火炬。你已经知道如何在Godot中使用**Light**节点。因此，在**Clara**节点内放置**OmniLight**靠近火炬网格很容易。我们的基本预期是，当她走过地板上的蜡烛和墙上的壁灯时，她会用火炬点亮它们。因此，游戏需要知道她靠近某些物体时的情况。
- en: 'Let’s first give Clara a torch she can carry around, then we can proceed to
    discuss how this torch can affect other objects in the level, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先给克拉拉一个可以携带的火炬，然后我们可以讨论这个火炬如何影响关卡中的其他对象，如下所示：
- en: Create a scene out of `Clara.glb` and place an **OmniLight** node under **Torch002**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Clara.glb`创建一个场景，并在**Torch002**下放置一个**OmniLight**节点。
- en: Position `0.75` on the **Y** axis might be enough.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Y**轴上的`0.75`可能就足够了。'
- en: Select `d6d58e` for **Color** and turn on **Enable** in the **Shadow** section.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`d6d58e`用于**颜色**，并在**阴影**部分开启**启用**。
- en: Since **OmniLight** is a child of the torch mesh, whenever the **AnimationPlayer**
    node controls the torch, the light will follow along. This is also a nice example
    of taking Blender animations and enhancing them with Godot nodes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**OmniLight**是火炬网格的子节点，每当**AnimationPlayer**节点控制火炬时，灯光会随之移动。这也是一个很好的例子，展示了如何使用Blender动画并通过Godot节点增强它们。
- en: We have a dedicated `Clara.tscn` scene, but the `Player.tscn` scene is still
    unaware of this new development. It’s still using the old model reference. Therefore,
    you must delete the `Player.tscn` and instance `Clara.tscn` instead. The **Scene**
    panel won’t look that much different but it’s now going to have Clara holding
    a lit torch. Test your scene and have Clara walk around, especially near the door.
    The torchlight will synchronize with her walking cycle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门的`Clara.tscn`场景，但`Player.tscn`场景仍然不知道这个新进展。它仍然使用旧的模式引用。因此，你必须删除`Player.tscn`并实例化`Clara.tscn`。**场景**面板看起来不会有太大的不同，但现在它将会有克拉拉手持点燃的火炬。测试你的场景，让克拉拉四处走动，尤其是在门口附近。火炬的光线将与她的行走周期同步。
- en: Clara seems to be carrying the right tool in her hand to light those candles
    and sconces. It’s time we added the trigger zones so that the world can react
    to her presence. That’s what’s coming up next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 克拉拉似乎手里拿着正确的工具来点亮那些蜡烛和壁灯。是时候添加触发区域，让世界能够对她的存在做出反应了。这就是接下来要发生的事情。
- en: Placing trigger points in the world
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在世界中放置触发点
- en: We made use of a **StaticBody** node to detect user clicks in the *Preparing
    a clickable area for raycasting* section of [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206),
    *Interacting with the World through Camera and Character Controllers*, so we could
    deduce where to move Clara. This is useful when you know that an agent, most likely
    the player, will directly trigger a system. There are cases when game objects
    act freely on their own and they should also initiate a response from systems
    that are waiting to be triggered. This section will cover this kind of situation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第12章*](B17473_12.xhtml#_idTextAnchor206)的*通过摄像头和角色控制器与世界交互*部分的*为射线投射准备可点击区域*中使用了一个**StaticBody**节点来检测用户点击，这样我们就可以推断出克拉拉应该移动到哪里。当你知道一个代理，很可能是玩家，会直接触发一个系统时，这很有用。有些情况下，游戏对象会自由地自行行动，并且它们也应该从等待被触发的系统中引发响应。本节将涵盖这种情况。
- en: By now, you may have noticed an odd behavior regarding pathfinding and the player’s
    destination. **StaticBody** that we set up goes as far as where the floor pieces
    meet the wall pieces. Therefore, it successfully captures the clicks on the floor
    tiles. However, if you click anywhere far away or along the walls, the pathfinding
    may give you an unexpected result. If you extend **StaticBody** further out, similar
    to how it covers the water, it will be alright. You can refer to *Figure 12.11*
    of [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206), *Interacting with the World
    through Camera and Character Controllers*, to observe the placement of **StaticBody**
    and adjust it to account for extra space to catch faraway clicks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到了关于路径查找和玩家目的地的一个奇怪行为。我们设置的**StaticBody**延伸到地板块与墙块相交的地方。因此，它成功地捕捉到了地板上的点击。然而，如果你点击任何远离或沿着墙壁的地方，路径查找可能会给你一个意外的结果。如果你将**StaticBody**进一步延伸，类似于它覆盖水的方式，那就没问题了。你可以参考[*第12章*](B17473_12.xhtml#_idTextAnchor206)的*图12.11*，*通过摄像头和角色控制器与世界交互*，来观察**StaticBody**的放置并调整它以捕捉远处的点击。
- en: Once the destination is determined, Clara will move toward it by getting closer
    to the props. Some of these objects are good candidates to trigger certain events.
    For this, we’ll use the **Area** node, which is inheriting from the same internal
    structure as **StaticBody**. These are similar nodes since they both originate
    from the same place but provide different results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了目的地，克拉拉将通过靠近道具来向它移动。其中一些物体是触发某些事件的理想选择。为此，我们将使用**Area**节点，它继承自与**StaticBody**相同的内部结构。这些节点是相似的，因为它们都源自同一个地方，但提供不同的结果。
- en: 'Although we could place and position an **Area** node per trigger zone in the
    level just as we did with many other nodes, keeping in mind that we want to do
    this for lighting the sconces and candles, it makes more sense to open the dedicated
    scenes we already have for these. To that end, you will do as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在关卡中为每个触发区域放置和定位一个 **Area** 节点，就像我们在许多其他节点中所做的那样，但考虑到我们想要为壁灯和蜡烛做这件事，打开我们已有的专门场景似乎更有意义。为此，你将按照以下步骤操作：
- en: Open `Candles_1.tscn` and place an **Area** node under the root.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Candles_1.tscn` 并在根节点下放置一个 **Area** 节点。
- en: 'Bring up the **Node** panel and double-click the **body_entered(body: Node)**
    item.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开 **Node** 面板，并双击 **body_entered(body: Node)** 项。'
- en: 'Press the `LightSwitch.gd` script. Change it as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 `LightSwitch.gd` 脚本。按照以下方式更改它：
- en: '[PRE0]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Place a **CollisionShape** node under the **Area** node you have just added.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚添加的 **Area** 节点下放置一个 **CollisionShape** 节点。
- en: Define **New BoxShape** for the **Shape** property in the **Inspector** panel.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 面板中为 **Shape** 属性定义 **New BoxShape**。
- en: The number from the `print` statement might look different in your machine,
    but you’ll see something like **StaticBody:[StaticBody:2025]** in the **Output**
    panel when you run the game. We’ve just got a collision result from the **Area**
    node we’ve added, but what is it that it hit? It is detecting the catch-all area
    that covered all of the floor pieces and some portion of the water.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 语句中的数字可能在你机器上看起来不同，但当你运行游戏时，你将在 **Output** 面板中看到类似 **StaticBody:[StaticBody:2025]**
    的内容。我们刚刚从添加的 **Area** 节点得到了一个碰撞结果，但它撞击了什么？它正在检测覆盖所有地板块和一些水面区域的通用区域。'
- en: 'We need to exclude all unwanted candidates so that this trigger zone only responds
    to our player’s activities. There are multiple ways to do this. We’ll explain
    an elaborate version right after we present a very simple method. For now, swap
    the function you just saw with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要排除所有不需要的候选者，以便这个触发区域只对我们的玩家活动做出响应。有多种方法可以做到这一点。在介绍一个非常简单的方法之后，我们将详细解释一个更复杂的方法。现在，用以下代码替换你刚刚看到的函数：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The changes we are making are in `Candles_1.tscn`, which holds the candle group
    by the barrel when Clara turns right after she clears the docking area. So, press
    *F5* to run the game and move her near the candles as described. You’ll see the
    **Output** area display the print message only when she enters the space of those
    candles. *Figure 13.2* will help you see what’s expected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改在 `Candles_1.tscn` 中，当克拉拉在清除对接区域后向右转时，它将蜡烛组固定在桶上。因此，按 *F5* 运行游戏，并按照描述将她移到蜡烛附近。你会看到
    **Output** 区域仅在进入那些蜡烛的空间时显示打印消息。*图 13.2* 将帮助你看到预期的效果。
- en: '![Figure 13.2 – It’s as if the candles sensed Clara coming nearby and welcomed
    her ](img/Figure_13.2_B17473.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 仿佛蜡烛感知到克拉拉靠近并欢迎她](img/Figure_13.2_B17473.jpg)'
- en: Figure 13.2 – It’s as if the candles sensed Clara coming nearby and welcomed
    her
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 仿佛蜡烛感知到克拉拉靠近并欢迎她
- en: With this method, we are only interested in knowing whether `name` of the body
    that entered the `Player`. If so, we can trigger the next chain of events. However,
    before we start tackling our initial intentions, the following are a few words
    about a more advanced detection method we mentioned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们只关心是否知道进入 `Player` 的 **body** 的 `name`。如果是这样，我们可以触发下一系列事件。然而，在我们开始处理我们的初始意图之前，以下是一些关于我们提到的更高级检测方法的说明。
- en: Getting to know a better collision detection method
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解更好的碰撞检测方法
- en: Godot’s **PhysicsServer**, a system that’s responsible for undertaking all of
    the calculations for the objects that should be affected by physical rules (such
    as gravity, collision, intersection, and so on) uses a layer system to keep track
    of where objects reside. This is not a visual layer as you might see in a graphics
    editing application such as Adobe Photoshop. Nevertheless, it’s similar because
    if the objects are on separate layers, then you can define how these layers will
    interact with each other. Aptly so, the structure that allows this kind of functionality
    is called **Layer** in Godot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 的 **PhysicsServer**，这是一个负责执行所有应受物理规则（如重力、碰撞、相交等）影响的对象的计算的系统，使用层系统来跟踪对象的位置。这不像你可能在图形编辑应用程序（如
    Adobe Photoshop）中看到的视觉层。尽管如此，它很相似，因为如果对象位于不同的层上，那么你可以定义这些层如何相互交互。因此，允许这种功能的结构被称为
    Godot 中的 **Layer**。
- en: Moreover, if all objects are always in the same layer, then you would have to
    resort to solutions such as name checking. It’s simple and effective, but it could
    easily get unwieldy because who would want to pick a unique name for each game
    object? Unquestionably, that `if` block we wrote earlier would get longer and
    longer to filter which particular object entered the area. To eliminate such situations,
    Godot has another construct that is called **Mask**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果所有对象始终处于同一层，那么您可能不得不求助于诸如名称检查之类的解决方案。这很简单且有效，但它可能会很容易变得难以控制，因为谁会想为每个游戏对象选择一个独特的名称？毫无疑问，我们之前编写的`if`块会变得越来越长，以过滤哪个特定的对象进入了区域。为了消除这种情况，Godot还有一个称为**遮罩**的结构。
- en: Through a clever way of creating multiple `if` blocks where you check what’s
    colliding with what. In a way, that sort of check will be done for you in `if`
    checks for controlling other less trivial cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一种巧妙的方式创建多个`if`块，检查什么与什么相撞。从某种意义上说，这种检查将在控制其他不太复杂情况的`if`检查中为您完成。
- en: 'The following figure shows where you can find the **Layer** and **Mask** options
    for the **Area** node we are currently configuring:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了您可以在当前配置的**区域**节点中找到的**层**和**遮罩**选项：
- en: '![Figure 13.3 – Using collision layers might be another detection method ](img/Figure_13.3_B17473.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 使用碰撞层可能是一种另一种检测方法](img/Figure_13.3_B17473.jpg)'
- en: Figure 13.3 – Using collision layers might be another detection method
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 使用碰撞层可能是一种另一种检测方法
- en: While this method is effective and valuable, setting it up in our current situation
    and explaining it via the pages of this book would be inefficient. Instead, we
    will use the available space to present other practical applications. Still, it
    is a vital architectural choice you might have to rely on in your future projects.
    So, we suggest you read about this by visiting the *Collision layers and masks*
    section at [https://docs.godotengine.org/en/3.4/tutorials/physics/physics_introduction.xhtml](https://docs.godotengine.org/en/3.4/tutorials/physics/physics_introduction.xhtml).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有效且有价值，但在我们当前的情况下设置它并通过本书的页面进行解释将是不高效的。相反，我们将利用可用空间来展示其他实际应用。尽管如此，这仍然是一个在您未来的项目中可能必须依赖的重要架构选择。因此，我们建议您通过访问[https://docs.godotengine.org/en/3.4/tutorials/physics/physics_introduction.xhtml](https://docs.godotengine.org/en/3.4/tutorials/physics/physics_introduction.xhtml)中的*碰撞层和遮罩*部分来了解这一点。
- en: Our more immediate concern is what we do when Clara goes near those candles.
    Let’s see her influence on the world.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更紧迫的问题是，当克拉拉靠近那些蜡烛时我们会做什么。让我们看看她对世界的影响。
- en: Lighting the candles and sconces
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点亮蜡烛和壁灯
- en: We’ve been laying the groundwork for Clara to interact with the world around
    her. Our latest effort involved proximity detection by `Candles_1.tscn` through
    the use of an `print` statement, but we are at a good spot to make it more interesting.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在为克拉拉与她周围的世界互动奠定基础。我们最新的努力是通过`Candles_1.tscn`中的`print`语句进行近距离检测，但我们正处于一个使其更有趣的好位置。
- en: 'To truly appreciate Clara’s impact on the world, we should start by turning
    off some of the lights on the level. Switch to the `Level-01.tscn` scene and perform
    the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解克拉拉对世界的影响，我们应该先从关闭该层的部分灯光开始。切换到`Level-01.tscn`场景并执行以下步骤：
- en: Select all instances of `Candles_1.tscn` and `Candles_2.tscn`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有`Candles_1.tscn`和`Candles_2.tscn`实例。
- en: Turn off the **Is Lit** property in the **Inspector** panel.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中关闭**已点燃**属性。
- en: Repeat the first two steps for all sconces in the level.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对关卡中的所有壁灯重复前两个步骤。
- en: Press *F5* to run the game and move Clara around.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F5*运行游戏并移动克拉拉。
- en: 'Atmospheric, isn’t it? When Clara goes to the same spot that triggered the
    message in the **Output** panel, the level will look like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大气效果，对吧？当克拉拉走到触发**输出**面板消息的同一位置时，关卡将看起来如下：
- en: '![Figure 13.4 – Clara is depending on the torch she’s holding in her hand ](img/Figure_13.4_B17473.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 克拉拉依赖她手中的火炬](img/Figure_13.4_B17473.jpg)'
- en: Figure 13.4 – Clara is depending on the torch she’s holding in her hand
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 克拉拉依赖她手中的火炬
- en: 'The torch she’s holding is enough for her to see where she’s going. However,
    it would be nice to light those candles she’s just standing by. We’ve already
    done the hard work in `Candles_1.tscn` so all there is left to do is to turn on
    **OmniLight** internally as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 她手中的火炬足以让她看到去往的方向。然而，点亮她旁边的那些蜡烛会更好。我们已经在`Candles_1.tscn`中完成了艰苦的工作，所以剩下的只是如下内部开启**OmniLight**：
- en: Open the `LightSwitch.gd` script.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LightSwitch.gd`脚本。
- en: 'Replace the `print` statement in the `_on_Area_body_entered` function by typing
    `is_lit = true`. The function will look like the following example after your
    changes:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`_on_Area_body_entered`函数中的`print`语句替换为`is_lit = true`。修改后函数将如下所示：
- en: '[PRE2]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Press *F5* to run the game and move Clara first to the same area, then to a
    different location.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F5*运行游戏，并将克拉拉首先移动到相同区域，然后移动到不同位置。
- en: 'When Clara goes near the same candles this time, those candles will be lit.
    It might be a bit difficult to see the effect depending on exactly where she’s
    standing. So, when she walks away from those candles, you’ll truly feel her mark
    on the world, as seen in *Figure 13.5*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当克拉拉这次靠近相同的蜡烛时，那些蜡烛将会被点燃。具体效果可能因她站立的位置而异，可能有点难以看到。所以，当她离开那些蜡烛时，你将真正感受到她对世界的印记，如*图13.5*所示：
- en: '![Figure 13.5 – Clara is getting some help from those candles she just lit
    ](img/Figure_13.5_B17473.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 克拉拉正在从她刚刚点燃的蜡烛中获得一些帮助](img/Figure_13.5_B17473.jpg)'
- en: Figure 13.5 – Clara is getting some help from those candles she just lit
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 克拉拉正在从她刚刚点燃的蜡烛中获得一些帮助
- en: 'This was just one candle game object Clara interacted with. We have another
    candle scene, `Candles_2.tscn`, and a separate scene for the sconces, `Sconce.tscn`.
    We could easily replicate what we have done to this point for these other scenes,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是克拉拉互动的一个蜡烛游戏对象。我们还有一个蜡烛场景，`Candles_2.tscn`，以及一个独立的烛台场景，`Sconce.tscn`。我们可以轻松地复制到目前为止所做的工作到这些其他场景中，如下所示：
- en: Open `Candles_1.tscn` first, then right-click the **Area** node, and select
    **Copy** in the context menu.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`Candles_1.tscn`，然后右键点击**区域**节点，并在上下文菜单中选择**复制**。
- en: Open `Candles_2.tscn` next, then right-click the root node, and select **Paste**
    in the context menu.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来打开`Candles_2.tscn`，然后右键点击根节点，并在上下文菜单中选择**粘贴**。
- en: 'Bring up the **Node** panel and then do as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**节点**面板，然后按照以下步骤操作：
- en: Right-click the **body_entered** item in the list and select the **Disconnect
    All** option. Press the **OK** button on the upcoming confirmation screen.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击列表中的**body_entered**项，并选择**断开所有连接**选项。在即将出现的确认屏幕上按下**确定**按钮。
- en: Double-click the **body_entered** item in the list. Press the **Connect** button
    on the upcoming screen.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中双击**body_entered**项。在即将出现的屏幕上按下**连接**按钮。
- en: Normally, we shouldn’t have to do the third step. When you copy and paste nodes
    between scenes, the signals are not transferred. So, we had to manually remove
    what seemed to be an active signal and rebind it. Luckily, both candle scenes
    are using the same script and we already have the event handler. That’s why we
    didn’t have to write the programming parts. When you transfer nodes between scenes
    as we did, keep in mind to reconnect the signals. Godot 4 might have a fix for
    this behavior.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不需要进行第三步。当你在不同场景之间复制粘贴节点时，信号不会传递。因此，我们必须手动移除看似活跃的信号并重新绑定它。幸运的是，这两个蜡烛场景都使用相同的脚本，我们已经有事件处理程序。这就是为什么我们不需要编写编程部分。当你像我们这样在不同场景之间传输节点时，请记住重新连接信号。Godot
    4可能已经修复了这种行为。
- en: 'So, run the game and have Clara walk by all of the candles. They will be lit
    one after another as she gets close, and the following is what you’ll experience
    when she does so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行游戏，让克拉拉走过所有的蜡烛。当她靠近时，蜡烛会依次被点燃，以下是她这样做时的体验：
- en: '![Figure 13.6 – All of the candles were lit after Clara walked by them ](img/Figure_13.6_B17473.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 克拉拉走过蜡烛后，所有的蜡烛都亮了](img/Figure_13.6_B17473.jpg)'
- en: Figure 13.6 – All of the candles were lit after Clara walked by them
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 克拉拉走过蜡烛后，所有的蜡烛都亮了
- en: We suggest you apply the same procedure to the `Sconce.tscn` scene. This time
    around though, alter the `2`, but you might want to adjust it to something that
    suits your conditions. Alternatively, you could move the whole **Area** node a
    bit forward to line it up with the two extensions of the sconce that connect to
    a wall. As long as there is enough area extended out of sconces, Clara will trigger
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你将相同的程序应用到`Sconce.tscn`场景中。这次，虽然要改变`2`，但你可能想要调整到适合你条件的东西。或者，你可以将整个**区域**节点稍微向前移动，使其与连接到墙的两个烛台扩展对齐。只要烛台延伸出足够的空间，克拉拉就会触发它。
- en: So, where else can you take this idea? A simple case might be to introduce traps
    or enemies reacting to the player’s position. In the case of enemies, they can
    also take advantage of pathfinding via the same **Navigation** node we placed
    in the level. Also, it’s common, in a case like this, when enemies give up after
    following the player for a certain period of time. If the distance is not getting
    any shorter and the player is getting away fast enough, the enemy will usually
    return to their designated patrol zone instead of trying to catch up with the
    player.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你还能将这个想法应用到哪里呢？一个简单的例子可能是引入陷阱或敌人对玩家的位置做出反应。在敌人的情况下，他们也可以利用我们在关卡中放置的相同**导航**节点进行路径查找。此外，在这种情况下，如果敌人跟随玩家一段时间后放弃，这是常见的。如果距离没有缩短，而玩家逃跑得足够快，敌人通常会返回他们指定的巡逻区域，而不是试图追赶玩家。
- en: We aren’t going to introduce such mechanics in this game. However, it might
    be something you can pursue as a more advanced game feature. If you are really
    interested in enemy versus player behavior, then we suggest you read a few **artificial
    intelligence** books on game development. There are a plethora of options out
    there and we’ll give you a brief list in the *Further reading* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这个游戏中引入这种机制。然而，这可能是你可以追求的更高级游戏功能之一。如果你对敌对玩家行为真的感兴趣，那么我们建议你阅读一些关于游戏开发的**人工智能**书籍。市面上有很多选择，我们将在*进一步阅读*部分为你提供一个简要列表。
- en: There are two more trigger zones we should create. One is for the backpack behind
    the cart when Clara goes near that area. The other one is when she approaches
    the door that leads upstairs. Let’s start with the backpack.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建两个额外的触发区域。一个是在克拉拉靠近该区域时，位于购物车后面的背包。另一个是她接近通往楼上的门时。让我们从背包开始。
- en: Adding the trigger for the backpack
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加背包的触发器
- en: This effort will be similar to the way we did it for the candles and sconces.
    Since you already know that by using an **Area** node you can introduce interactivity,
    we’ll present something slightly new.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种努力将与我们在蜡烛和烛台上的做法相似。既然你已经知道通过使用**区域**节点可以引入交互性，我们将展示一些稍微新颖的内容。
- en: When players interact with the world, more specifically with the game objects,
    they feel that they have agency over these items. For example, players have just
    discovered that walking near candles will light them. This is part of the fun
    besides the narrative and story elements a game can have. At this point, it’s
    up to the game designer to interweave another layer of complexity. Perhaps, being
    close to the candles is only a precondition and the player is also expected to
    click on the candles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家与世界互动，特别是与游戏对象互动时，他们会感觉到自己对这些物品有控制权。例如，玩家刚刚发现靠近蜡烛会使它们亮起。这不仅是游戏可以有的叙事和故事元素的一部分乐趣。在这个时候，游戏设计师需要交织另一层复杂性。也许，靠近蜡烛只是先决条件，玩家还应该点击蜡烛。
- en: Regardless of the conditions a game designer will expect the player to satisfy,
    giving feedback to the player is quintessential. When players try things on their
    own, they will get negative or positive feedback. This kind of harmless trial
    and error could easily be used in lieu of a tutorial. An easy and reliable way
    to provide feedback is something we’ve already looked at. It is playing sound.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论游戏设计师期望玩家满足什么条件，向玩家提供反馈是至关重要的。当玩家自己尝试时，他们会得到负面或正面的反馈。这种无害的试错法可以很容易地用来代替教程。提供反馈的一种简单可靠的方法是我们已经看过的。那就是播放声音。
- en: 'For the backpack exercise, we’ll combine both playing an audio file and reacting
    to an area effect. Once Clara approaches the backpack as she did with the candles,
    the backpack will play a sound file that will inform the player that she picked
    up the key. The following steps show you how you do it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背包练习，我们将结合播放音频文件和响应区域效果。一旦克拉拉像对待蜡烛一样靠近背包，背包将播放一个声音文件，通知玩家她已经捡起了钥匙。以下步骤显示了如何操作：
- en: Create a scene out of `Backpack.glb` and save it as `Backpack.tscn` in its original
    folder.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Backpack.glb`创建一个场景，并将其保存为`Backpack.tscn`，存放在其原始文件夹中。
- en: Place an `CollectItem.wav` to its **Stream** field.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CollectItem.wav`放置到**流**字段中。
- en: Add an `-2` on both the **X** and **Z** axes. You may want to pick values that
    make sense in your scene. As long as there is ample room for Clara to reach this
    zone, things should be fine. Use *Figure 13.7* as a reference.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**X**和**Z**轴上添加`-2`。你可能想要选择在场景中合理的值。只要克拉拉有足够的空间到达这个区域，事情应该就会顺利。使用*图13.7*作为参考。
- en: 'Create a `Backpack.gd` script for the root node and save it in the same folder.
    Activate the **body_entered** signal for the **Area** node, which will add a boilerplate
    function to the script. Then, change the script as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为根节点创建一个 `Backpack.gd` 脚本，并将其保存在同一文件夹中。激活 **Area** 节点的 **body_entered** 信号，这将向脚本添加一个模板函数。然后，按照以下方式修改脚本：
- en: '[PRE3]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Swap the `Level-01.tscn` with an instance of `Backpack.tscn`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Level-01.tscn` 与 `Backpack.tscn` 的实例进行交换。
- en: We are following the same principles we used in player detection for the candles.
    This time, instead of enabling lights, we are playing a short sound effect. We
    chose the **AudioStreamPlayer** node instead of its 3D version because we don’t
    want this sound effect to be affected by its distance to the camera. However,
    this is a perfect situation for you to swap and try both to see the difference.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遵循与玩家检测蜡烛时使用的相同原则。这次，我们不是启用灯光，而是播放一个短声音效果。我们选择了 **AudioStreamPlayer** 节点而不是其
    3D 版本，因为我们不希望这个声音效果受到其与摄像机的距离的影响。然而，这是一个完美的机会，你可以交换并尝试两者以查看差异。
- en: The sound effect command is followed by the emission of a custom signal. In
    simple terms, we have converted the **body_entered** signal into a **key_collected**
    signal, which will be used in a more advanced scenario in the *Playing the door
    animation on a condition* section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 声音效果命令之后是自定义信号的发射。简单来说，我们将 **body_entered** 信号转换成了 **key_collected** 信号，这将在
    *在条件满足时播放门动画* 部分中用于更高级的场景。
- en: As mentioned in the third step, *Figure 13.7* shows the relative position of
    the **Area** node.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如第三步所述，*图 13.7* 展示了 **Area** 节点的相对位置。
- en: '![Figure 13.7 – The trigger area for the backpack is offset so Clara can reach
    it ](img/Figure_13.7_B17473.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 背包的触发区域偏移，以便克拉拉能够到达](img/Figure_13.7_B17473.jpg)'
- en: Figure 13.7 – The trigger area for the backpack is offset so Clara can reach
    it
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 背包的触发区域偏移，以便克拉拉能够到达
- en: As they are now, the sconces and candles don’t play a sound effect when they
    are lit. This might be a short and nice exercise for which you can use the `TorchWhoosh.ogg`
    file. By default, the file’s **Loop** feature will be on. So, remember to press
    the **Reimport** button after you turn the loop off in the **Import** panel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，壁炉和蜡烛在点亮时不会播放声音效果。这可能是一个简短而有趣的练习，你可以使用 `TorchWhoosh.ogg` 文件。默认情况下，文件的 **Loop**
    功能是开启的。所以，记得在 **Import** 面板中关闭循环后按下 **Reimport** 按钮。
- en: Last on the list of making some of the game objects interactive is the arched
    door. Our workflow will be similar but additionally accounts for that `key_collected`
    signal we defined in this section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作一些游戏对象交互功能的列表中，拱门是最后一个。我们的工作流程将与之前相似，但还会考虑到在本节中定义的 `key_collected` 信号。
- en: Interacting with the door
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与门交互
- en: You’ve been using the **Area** node quite liberally for a while. So, you must
    be used to it by now. In this section, you will use it one last time to complete
    the topic of interactivity. It will be for the door where you’ll also make use
    of that custom signal we have recently created.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经相当自由地使用了 **Area** 节点一段时间了。所以，你现在应该已经习惯了它。在本节中，你将最后一次使用它来完成交互性的主题。这将是用于门的场景，你也将使用我们最近创建的自定义信号。
- en: 'Since some of the steps will be so similar, we will give shorter instructions
    for the sake of focusing on the unique parts, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些步骤将非常相似，我们将给出更简短的说明，以便专注于独特部分，如下所示：
- en: Create a scene out of `Doors_RoundArch.glb` and save it in its original folder.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Doors_RoundArch.glb` 创建一个场景，并将其保存在原始文件夹中。
- en: Attach the `Doors_RoundArch.gd` script from the `Scripts` folder to the root
    node.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Scripts` 文件夹中的 `Doors_RoundArch.gd` 脚本附加到根节点。
- en: Add two `LockFiddling` and `OpenDoor`. For these two nodes, use `LockFiddling.wav`
    and `OpenDoor.wav`, respectively, for their **Stream** property.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个 `LockFiddling` 和 `OpenDoor` 节点。对于这两个节点，分别使用 `LockFiddling.wav` 和 `OpenDoor.wav`
    作为它们的 **Stream** 属性。
- en: Add an **Area** node to the root with its dependencies and requirements, such
    as its collision, signal, and position. *Figure 13.8* should be helpful to show
    where we are placing **Area**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点上添加一个具有其依赖项和要求的 **Area** 节点，例如其碰撞、信号和位置。*图 13.8* 应该有助于展示我们放置 **Area** 的位置。
- en: Swap the existing door asset in the `Level-01.tscn` scene with this new scene.
    Also, assign the backpack asset to the **Backpack** property in **Inspector**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Level-01.tscn` 场景中现有的门资产与这个新场景进行交换。同时，将背包资产分配到 **Inspector** 中的 **Backpack**
    属性。
- en: Press *F5* and have Clara walk directly to the door.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F5* 键，让克拉拉直接走到门口。
- en: We’ll pay closer attention to the script this new scene is using after you see
    how things look in the editor with our most recent changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到编辑器中我们最近更改后的效果后，我们将更仔细地关注这个新场景使用的脚本。
- en: '![Figure 13.8 – This should be enough space in front of the door for Clara
    ](img/Figure_13.8_B17473.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 这应该为克拉拉在门前的空间足够了](img/Figure_13.8_B17473.jpg)'
- en: Figure 13.8 – This should be enough space in front of the door for Clara
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 这应该为克拉拉在门前的空间足够了
- en: The scene layout is pretty similar to the other examples you have created, but
    instead of one, there are two audio stream nodes. Their names indicate the kind
    of functionality we are trying to achieve. This time around, Clara standing in
    front of the door won’t be enough by itself because we expect her to have found
    the key first.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 场景布局与您创建的其他示例非常相似，但不是只有一个，而是有两个音频流节点。它们的名称表明了我们试图实现的功能。这一次，克拉拉站在门前可能不足以单独完成，因为我们预计她首先找到了钥匙。
- en: Let’s analyze the `Doors_RoundArch.gd` script and see how we are working it
    out. You can refer to this code block at [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2013/Resources/Scripts/Doors_RoundArch.gd](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2013/Resources/Scripts/Doors_RoundArch.gd).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下 `Doors_RoundArch.gd` 脚本，看看我们是如何工作的。你可以参考这个代码块，链接为 [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2013/Resources/Scripts/Doors_RoundArch.gd](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2013/Resources/Scripts/Doors_RoundArch.gd)。
- en: We have a flag variable to keep track of whether the key has been collected.
    The value of this variable becomes true only when the `on_key_collected` function
    is run. All of this relies on whether the backpack variable emits the appropriate
    event, which is set up in the `_ready` function. That’s why you are binding the
    backpack object to the door using the **Inspector** panel so that these two can
    communicate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个标志变量来跟踪是否已经收集了钥匙。只有当 `on_key_collected` 函数运行时，这个变量的值才变为真。所有这些都依赖于背包变量是否发出适当的事件，这是在
    `_ready` 函数中设置的。这就是为什么你使用 **检查器** 面板将背包对象绑定到门上，以便这两个对象可以通信。
- en: In the **body_entered** function, we check whether the intruding object is the
    player. This is where the flag variable comes into play. If the condition to open
    the door is satisfied, then we request the door opening sound. Otherwise, the
    game engine will play a sound file that indicates Clara fiddling with the lock.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **body_entered** 函数中，我们检查入侵对象是否是玩家。这就是标志变量发挥作用的地方。如果满足开门的条件，那么我们请求播放开门声音。否则，游戏引擎将播放一个声音文件，表明克拉拉在摆弄锁。
- en: One type of solution may not always cut it
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案可能并不总是适用
- en: The solutions we show you throughout this book may not always be ideal if your
    level or game structure is different. Even the game we are building right now
    might benefit from a drastically and much more efficient architecture. The concept
    of architecture means the hierarchy of game objects you lay out in your scenes,
    how scripts share common variables, and ultimately how your systems talk to each
    other. There is no golden solution, rather best practices that come with more
    exposure to coding, perusing forums, and attending conferences where seasoned
    developers share their battle scars.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本书展示的解决方案可能并不总是理想的，如果你的级别或游戏结构不同。甚至我们现在正在构建的游戏也可能从一种截然不同且更高效的架构中受益。架构的概念意味着你在场景中布局的游戏对象的层次结构，脚本如何共享公共变量，以及最终你的系统如何相互通信。没有金钥匙的解决方案，而是随着更多编码经验的积累、浏览论坛和参加会议（在这些会议中，经验丰富的开发者分享他们的战斗伤痕）而出现的最佳实践。
- en: We suggest you try both cases where Clara walks directly to the door to hear
    the no-go sound. Then, have her pick up the key, which is already notifying the
    player with its pickup sound. Lastly, she can go in front of the door again to
    hear the door creaking. That door sure needs some greasing!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你尝试两种情况，即克拉拉直接走到门前听到禁止声。然后，让她拿起钥匙，钥匙的拾取声已经通知了玩家。最后，她可以再次站在门前听到门吱嘎作响。那扇门确实需要一些润滑！
- en: Even though the squeaking sound makes us think the door is opening with some
    protest, we don’t see it yet. So far, we’ve successfully mixed different disciplines
    we learned in the *Playing music and sound effects* and *Creating reaction spots*
    sections. It’s time we added the missing animation component to our workflow.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管吱嘎声让我们觉得门打开时有些抗议，但我们还没有看到。到目前为止，我们已经成功地将我们在 *播放音乐和音效* 和 *创建反应点* 部分学到的不同学科混合在一起。现在是时候将缺失的动画组件添加到我们的工作流程中。
- en: Building simple animations in Godot
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Godot 中构建简单的动画
- en: Back in [*Chapter 5*](B17473_05.xhtml#_idTextAnchor075), *Setting Up Animation
    and Rigging*, we discussed variances between Blender and Godot Engine for animation
    needs. In summary, we claimed that you’d be better off with Blender for animating
    anything more complex than bouncing balls and simple rotating objects. To drive
    the point home, we **rigged** and animated a snake model. Similarly, we have been
    using a humanoid character, Clara, done in Blender as well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第五章*](B17473_05.xhtml#_idTextAnchor075) *设置动画和绑定* 中，我们讨论了 Blender 和 Godot
    引擎在动画需求方面的差异。总的来说，我们声称，如果你要动画比弹跳球和简单旋转对象更复杂的东西，使用 Blender 会更好。为了强调这一点，我们 **绑定**
    并动画了一个蛇模型。同样，我们一直在使用 Blender 制作的类人角色，克拉拉。
- en: However, there comes a time when it might be suitable to animate some of the
    models in the game engine. The topic we have at hand is the opening animation
    of the arched door Clara is standing in front of. If you prefer so, you could
    still open the model in Blender, implement the necessary steps that represent
    the opening of the door, and reimport your work in Godot. It’ll be no different
    than any other imported model that came with its animation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时在游戏引擎中动画一些模型可能是合适的。我们现在讨论的主题是克拉拉站在其前面的拱形门的开门动画。如果你愿意，你仍然可以在 Blender 中打开模型，实现表示门开启的必要步骤，并将你的工作重新导入
    Godot。这与其他任何带有动画的导入模型没有区别。
- en: For such a simple task, it’s a bit of an overkill, though. We’ll still use **AnimationPlayer**,
    but instead of triggering imported actions, we’ll create our own by manually placing
    keyframes in the timeline to match the creaking sound we play when the door opens.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的任务来说，这有点过度了。我们仍然会使用 **AnimationPlayer**，但不是触发导入的动作，而是通过在时间轴上手动放置关键帧来创建自己的动画，以匹配我们打开门时播放的吱嘎声。
- en: Creating the door animation
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建门动画
- en: Before you start tackling any kind of manual animation in Godot, we suggest
    you take a closer look at the **MeshInstance** nodes the model uses. In our case,
    we are fortunate that there are only two. However, this might also be a problem
    too.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始处理任何类型的手动动画之前，我们建议你仔细查看模型使用的 **MeshInstance** 节点。在我们的例子中，我们很幸运，只有两个。然而，这也可能是一个问题。
- en: The model’s mesh shows metal rings for grabbing and pulling to open such a heavy
    door. Sadly, they are part of the same **MeshInstance** nodes. This means that
    they can’t be individually animated. To be able to do it, you’d have to go to
    Blender and separate those pieces and reexport the model. Then, you’ll have more
    **MeshInstance** nodes you can work with. Keep in mind, though, that any one of
    these options is fine but comes with a trade-off. More individual objects often
    signal freedom, but they also clutter the **Scene** panel if you don’t need them
    in the first place.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的网格显示了用于抓取和拉动以打开这样沉重的大门的金属环。遗憾的是，它们是同一个 **MeshInstance** 节点的一部分。这意味着它们不能单独动画。为了能够做到这一点，你需要在
    Blender 中将这些部分分开并重新导出模型。然后，你将拥有更多可以工作的 **MeshInstance** 节点。记住，尽管任何一种选择都是可行的，但都伴随着权衡。更多的独立对象通常意味着自由，但如果没有必要，它们也会使
    **场景** 面板变得杂乱。
- en: 'We’re not concerned about the rings on the door for the time being. Our goal
    here is to learn the basics of animation in Godot, which starts by opening the
    `Doors_RoundArch.tscn` scene. After that, you will perform the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不太关心门上的环。我们的目标是学习 Godot 的动画基础知识，这从打开 `Doors_RoundArch.tscn` 场景开始。之后，你将执行以下步骤：
- en: Place an **AnimationPlayer** node under the root. This will automatically bring
    up the **Animation** panel at the bottom. If not, press the **Animation** button
    in the bottom menu.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点下放置一个 **AnimationPlayer** 节点。这将自动在底部弹出 **Animation** 面板。如果没有，请按底部菜单中的 **Animation**
    按钮。
- en: Press the **Animation** button in this panel’s top area to bring a context menu
    and select **New** in the options. As a reminder, you used the **Load** option
    in that context menu in [*Chapter 5*](B17473_05.xhtml#_idTextAnchor075), *Setting
    Up Animation and Rigging*.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板顶部区域按下**动画**按钮以显示上下文菜单，并在选项中选择**新建**。提醒一下，你在[*第5章*](B17473_05.xhtml#_idTextAnchor075)中，*设置动画和绑定*部分使用了该上下文菜单中的**加载**选项。
- en: Type `Open` and press the **OK** button to confirm.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Open`并按下**确定**按钮以确认。
- en: Set the animation length to `2.3` by typing it in the area between the clock
    and loop icons on the right side of the panel.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在面板右侧时钟和循环图标之间的区域输入来设置动画长度为`2.3`。
- en: There are a lot of similar named buttons or options in the last set of steps.
    Thus, *Figure 13.9* will help you see what the editor will look like after your
    latest effort.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中有很多类似名称的按钮或选项。因此，*图13.9*将帮助你看到你最新努力后的编辑器外观。
- en: '![Figure 13.9 – Scaffolding for the open animation is done ](img/Figure_13.9_B17473.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 开放动画的脚手架已完成](img/Figure_13.9_B17473.jpg)'
- en: Figure 13.9 – Scaffolding for the open animation is done
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 开放动画的脚手架已完成
- en: 'The animation track is empty, but the groundwork is done. We need to tell **AnimationPlayer**
    how a specific property of an object is changing over time. To that end, you should
    do as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 动画轨迹为空，但基础工作已完成。我们需要告诉**AnimationPlayer**对象的一个特定属性随时间如何变化。为此，你应该这样做：
- en: Select the **Doors_RoundArch_L** node in the **Scene** panel.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板中选择**Doors_RoundArch_L**节点。
- en: Expand the **Transform** section in the **Inspector** panel. Press the key icon
    for the **Rotation Degrees** property. A confirmation popup will appear.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中展开**变换**部分。按下**旋转度数**属性的键图标。将出现一个确认弹出窗口。
- en: Press the **Create** button to accept the proposed changes.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**创建**按钮以接受提出的更改。
- en: Click and drag your mouse over the numbers in the timeline of the `2.3`. Alternatively,
    you can type it in the area above the timeline to move the time marker.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动鼠标到`2.3`的时间轴上的数字上。或者，你也可以在时间轴上方的区域输入它来移动时间标记。
- en: Change the `-60` and press the key icon again. There won’t be a confirmation
    popup this time.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`-60`并再次按下键图标。这次不会出现确认弹出窗口。
- en: If you scrub the timeline back and forth as you did to move the time marker,
    you’ll now see the door pivot around its hinges. Speaking of which, this was covered
    in the *Setting origin points* section of [*Chapter 6*](B17473_06.xhtml#_idTextAnchor092),
    *Exporting Blender Assets*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像移动时间标记那样来回刮擦时间轴，你现在将看到门绕其铰链旋转。说到这一点，这已经在[*第6章*](B17473_06.xhtml#_idTextAnchor092)的*设置原点*部分中讨论过了，*导出Blender资产*。
- en: 'Also, feel free to use the forward and backward play buttons to test the **Open**
    action. We’ll trigger it programmatically soon, but we should take care of the
    other portion of the door first as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以自由使用前进和后退播放按钮来测试**打开**动作。我们很快将程序化触发它，但我们应该首先处理门的另一部分，如下所示：
- en: Select the **Doors_RoundArch_R** node in the **Scene** panel.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板中选择**Doors_RoundArch_R**节点。
- en: Reset the time marker to `0` in the **Animation** panel.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**面板中将时间标记重置为`0`。
- en: Follow *steps 2–5* from the *preceding set of instructions* with only one difference.
    Mark the `60` this time since the directions are reversed.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面的指令集的*步骤2-5*进行，只有一个不同之处。这次标记`60`，因为方向相反。
- en: 'After the two sets of changes, the editor will resemble what you see in *Figure
    13.10*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在两组更改之后，编辑器将类似于你在*图13.10*中看到的样子：
- en: '![Figure 13.10 – Two sections of the door model have been keyframed, hence
    animated ](img/Figure_13.10_B17473.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 门模型的两个部分已经设置了关键帧，因此进行了动画](img/Figure_13.10_B17473.jpg)'
- en: Figure 13.10 – Two sections of the door model have been keyframed, hence animated
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 门模型的两个部分已经设置了关键帧，因此进行了动画
- en: This will add the necessary keyframes to the timeline at points where changes
    occur. Since we want the door to open in one go without any slowing down or stuck
    effect, we are not introducing more keyframes other than those we are using. If
    you fancy more complex scenarios, you can position the time marker along the track
    to where you want to introduce more keyframes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在发生变化的点添加必要的键帧到时间轴上。由于我们希望门一次性打开，没有任何减速或卡住的效果，所以我们没有引入除我们使用的以外的更多键帧。如果你喜欢更复杂的情况，你可以将时间标记沿轨迹移动到你想要引入更多键帧的位置。
- en: The **Open** animation you have just created should run on a condition. We’ve
    already discussed and even implemented the necessary condition to a certain extent.
    However, we didn’t really place the animation part in the door script. Let’s do
    that right away.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建的 **打开** 动画应该在条件下运行。我们已经讨论过，并在一定程度上实现了必要的条件。然而，我们并没有真的在门脚本中放置动画部分。让我们立即这样做。
- en: Playing the door animation on a condition
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在条件下播放门动画
- en: Earlier in the *Interacting with the door* section, we attached a script to
    the door scene. This script had all of the necessary rules to check whether the
    player satisfied the conditions to open this door. We’ve also done a whole bunch
    of other things since then. So, let’s summarize what we’ve got so far.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *与门互动* 部分之前，我们已经将脚本附加到了门场景。这个脚本包含了检查玩家是否满足打开此门条件的所有必要规则。从那时起，我们还做了一大堆其他事情。所以，让我们总结一下到目前为止我们已经做了什么。
- en: 'The arched door scene has an **Area** node that reacts to the player’s presence.
    The door provides an auditory effect either way, but if Clara has already claimed
    the key, we expect the door to open with a creaking sound effect. Aptly named,
    we should trigger the **Open** animation. The change is simple enough, and it
    requires you to do as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 弧形门场景有一个 **区域** 节点，它会响应玩家的存在。门无论哪种情况都会提供听觉效果，但如果克拉拉已经拿到了钥匙，我们期望门会发出嘎吱声打开。恰如其名，我们应该触发
    **打开** 动画。这个变化很简单，你需要做如下操作：
- en: Open the `Doors_RoundArch.gd` script.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Doors_RoundArch.gd` 脚本。
- en: Replace `print(“Open Sesame!”)` with `$AnimationPlayer.play(“Open”)`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `print(“Open Sesame!”)` 替换为 `$AnimationPlayer.play(“Open”)`。
- en: Press *F5* to run the game. Have Clara first go for the key and then stand in
    front of the door.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F5* 运行游戏。让克拉拉先去拿钥匙，然后站在门前。
- en: Voila! A big obstacle in the way of going upstairs has been eliminated.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！通往楼上的一大障碍已经被消除。
- en: 'Although it’s not possible to convey sound and visual effects via a still image,
    nevertheless, the following is the fruit of your hard work in *Figure 13.11*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无法通过静态图像传达声音和视觉效果，但无论如何，以下是你辛勤工作的成果 *图13.11*：
- en: '![Figure 13.11 – Clara opened the door only after she collected the key from
    the backpack ](img/Figure_13.11_B17473.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 克拉拉只在从背包中收集到钥匙后才打开门](img/Figure_13.11_B17473.jpg)'
- en: Figure 13.11 – Clara opened the door only after she collected the key from the
    backpack
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 克拉拉只在从背包中收集到钥匙后才打开门
- en: If you move Clara away and come back near the door, the animation and sound
    will trigger over and over. Coming up with the necessary conditions to execute
    an event is important. However, it might sometimes be equally important to stop
    it from happening again. You might have already noticed a similar, and maybe annoying,
    repeating behavior with the candles as well. Some effects should only fire once.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将克拉拉移开并靠近门，动画和声音会反复触发。提出执行事件的必要条件很重要。然而，有时阻止它再次发生可能同样重要。你可能已经注意到了蜡烛的类似，也许令人烦恼的重复行为。某些效果应该只触发一次。
- en: We still have quite a few things to do in this chapter. That’s why we will give
    you a quick guideline for eliminating this kind of repeating behavior. By nesting
    or combining `if` blocks, not only can you make sure the condition has been met
    just then, but also that it has been met before. For this, you might want to take
    advantage of simple Boolean variables. If the solution doesn’t come to you, you
    can always check the GitHub repository for the finished work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中我们还有许多事情要做。这就是为什么我们将为你提供一个快速指南来消除这种重复行为。通过嵌套或组合 `if` 块，你不仅可以确保条件当时已经满足，而且之前也已经满足。为此，你可能需要利用简单的布尔变量。如果解决方案没有出现在你的脑海中，你总是可以查看GitHub仓库中的成品。
- en: What’s left for Clara to do at this point? Well, she’s currently standing there
    waiting to go upstairs. In this context, upstairs means loading another level,
    which we will discover in the *Loading another level* section later. For the time
    being, we still don’t know exactly when we are supposed to load the next level.
    Let’s see how we can determine that.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，克拉拉还需要做什么？嗯，她现在正站在那里等待上楼。在这个上下文中，上楼意味着加载另一个关卡，我们将在后面的 *加载另一个关卡* 部分发现。目前，我们还不确切知道我们何时应该加载下一级。让我们看看我们如何确定这一点。
- en: Waiting for the door animation to trigger an event
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待门动画触发事件
- en: It’s tempting to load the next level when we start opening the door. That being
    said, you’ve worked hard to keep track of what Clara has been doing as a precondition
    to start the door’s opening animation. If you switch to a new level right away,
    the animation will be for naught.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始打开门时，加载下一级是很诱人的。话虽如此，你已经努力跟踪克拉拉的行为，作为开始门打开动画的先决条件。如果你立即切换到新级别，动画将毫无意义。
- en: 'Instead, we should wait for the **Open** animation to finish. Only after that
    does it make more sense to switch things up. There are two common but equally
    awkward ways to do this. We’ll discuss both, so you get to know them before we
    dismiss them for the sake of a better alternative, and they are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该等待**打开**动画完成。只有在那时，改变事情才更有意义。有两种常见但同样尴尬的方法来做这件事。我们将讨论这两种方法，这样在你我们放弃它们以寻找更好的替代方案之前，你就能了解它们，如下所示：
- en: '`yield`: You can add `yield($AnimationPlayer, “animation_finished”)` after
    you trigger the `yield` line, such as loading a new level, will have to wait for
    the animation to be finished. This is, in a way, like holding the line. Nothing
    else will happen unless, well, the program yields. This concept will change in
    Godot 4 in favor of the **await** command, which is a more permissive architectural
    choice than blocking things during the execution of your code.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`：在触发`yield`行（如加载新级别）之后，你可以添加`yield($AnimationPlayer, “animation_finished”)`，这将使你等待动画完成。从某种意义上说，这就像是在等待。除非程序释放，否则不会发生任何事情。这个概念在Godot
    4中将改变，以支持**await**命令，这是一个比在代码执行期间阻塞事物更宽容的架构选择。'
- en: '`yield` where you are still letting things run is introducing a `2.3` seconds,
    since that’s the length of our **Open** animation. Then, once the time is out,
    this node will fire a **timeout** signal for which you can write a listener.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`表示你仍然让事情继续运行，这引入了`2.3`秒，因为这是我们**打开**动画的长度。然后，一旦时间到了，这个节点将触发一个**超时**信号，你可以为它编写一个监听器。'
- en: This method’s usage in our situation would be to start the timer as soon as
    you initiate the **Open** animation. Since the timer’s **Wait Time** would be
    synced with the action you are playing, it would look like loading a new level
    right after the action is finished.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这种方法的使用是在你开始**打开**动画时立即开始计时器。由于计时器的**等待时间**将与你正在执行的动作同步，所以看起来就像在动作完成后立即加载新级别。
- en: 'We will not use either of these methods because why would you make your life
    more complicated when there is already a way to accomplish something with the
    toolset you are familiar with? Instead of switching gears, we’ll see how **AnimationPlayer**
    can still help us as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用这两种方法，因为当你已经可以用你熟悉的工具集完成某事时，为什么还要让你的生活变得更复杂呢？我们不会改变方向，而是看看**AnimationPlayer**如何仍然能帮助我们，如下所示：
- en: 'Add the following function somewhere in the `Doors_RoundArch.gd` script:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Doors_RoundArch.gd`脚本中添加以下函数：
- en: '[PRE4]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Select the **AnimationPlayer** node and expand a context menu by pressing the
    **Add Track** button.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**AnimationPlayer**节点，并按**添加轨迹**按钮展开上下文菜单。
- en: Choose **Call Method Track** among the options. You’ll be presented with a list
    of nodes to pick from. So, select the root node, **Doors_RoundArch**, on the upcoming
    screen.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选项中选择**调用方法轨迹**。你将看到一个可供选择的节点列表。因此，在即将出现的屏幕上选择根节点，**Doors_RoundArch**。
- en: Move the timeline marker to `2.3` seconds. Right-click where the blue timeline
    marker meets **Functions** for the **Doors_RoundArch** entry in the animation
    tracks. To get a better idea, refer to *Figure 13.12* to see the location we are
    talking about.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间轴标记移动到`2.3`秒。在动画轨道中，右键单击蓝色时间轴标记与**函数**的**Doors_RoundArch**条目相交的地方。为了更好地理解，请参考*图13.12*以查看我们所说的位置。
- en: Search and choose **load_level** from the upcoming list. Press *F5* to run the
    game and follow the necessary steps as before to open the door.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将出现的列表中搜索并选择**load_level**。按*F5*运行游戏，并遵循之前必要的步骤来打开门。
- en: 'Everything will be exactly the same, except when the door animation is finished
    playing the `load_level` function will run too. Since showing the door animation
    won’t make sense, we’d rather show you the editor’s status as mentioned in the
    fourth step:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都将保持不变，除了当门动画播放完毕后，`load_level`函数也会运行。由于显示门动画没有意义，我们宁愿显示编辑器的状态，如第四步所述：
- en: '![Figure 13.12 – The load_level function will be triggered when the timeline
    arrives at the keyframe we set ](img/Figure_13.12_B17473.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 当时间轴到达我们设置的关键帧时，将触发load_level函数](img/Figure_13.12_B17473.jpg)'
- en: Figure 13.12 – The load_level function will be triggered when the timeline arrives
    at the keyframe we set
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – 当时间轴到达我们设置的关键帧时，将触发 load_level 函数
- en: The last frame of the **Open** action is where we are firing the function responsible
    for loading the next level. For now, it’s printing only a statement. We’ll be
    looking into swapping our current level with a new one later in the *Loading another
    level* section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开** 动作的最后一帧是我们调用负责加载下一级的功能的地方。目前，它只打印一条语句。我们将在 *加载另一个关卡* 部分稍后探讨如何交换我们的当前关卡与一个新关卡。'
- en: While we are still working on building simple animations, we could take care
    of the light sources that kind of look static.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仍在构建简单的动画时，我们可以处理那些看起来有点静态的光源。
- en: Let there be flickering lights
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让灯光闪烁
- en: The work we did with the sconces and candles for introducing the **Light** nodes
    to our game in [*Chapter 10*](B17473_10.xhtml#_idTextAnchor165) , *Making Things
    Look Better with Lights and Shadows*, didn’t include animations. Nevertheless,
    we’ve been gradually improving everything else ever since.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 10 章*](B17473_10.xhtml#_idTextAnchor165) 中为介绍 **灯光** 节点到我们的游戏所做的 **工作**，即
    *使用灯光和阴影使事物看起来更好*，并没有包括动画。尽管如此，自从那时起，我们一直在逐步改进其他一切。
- en: 'Consequently, it would be nice to add some oomph to our light sources as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们很乐意按照以下方式为我们的光源添加一些活力：
- en: Open `Sconce.tscn` and add an **AnimationPlayer** node to the root.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Sconce.tscn` 并将一个 **AnimationPlayer** 节点添加到根节点。
- en: Introduce a new action. Choose `Flicker` for its name.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个新的动作。将其命名为 `Flicker`。
- en: Set the length to `2` seconds. Also, turn on **Animation Looping** and **Autoplay
    on Load**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将长度设置为 `2` 秒。同时，打开 **动画循环** 和 **加载时自动播放**。
- en: Press the **Add Track** button and choose **Property Track**. Select **OmniLight**
    from the list that pops up. This will display another list to pick from.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **添加轨道** 按钮，并选择 **属性轨道**。从弹出的列表中选择 **OmniLight**。这将显示另一个列表以供选择。
- en: Pick `0.0`, `0.4`, `1.3`, and `1.9` seconds to open a context menu and select
    **Insert Key**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `0.0`、`0.4`、`1.3` 和 `1.9` 秒来打开上下文菜单并选择 **插入关键帧**。
- en: Select each one of these keyframes and enter `8`, `6`, `7`, and `5`, respectively,
    in their **Value** property in the **Inspector** panel.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个关键帧，并在 **检查器** 面板的 **值** 属性中分别输入 `8`、`6`、`7` 和 `5`。
- en: Press *F5* and have Clara light the sconces. They should start to flicker.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F5* 键，让克拉拉点亮壁炉架。它们应该开始闪烁。
- en: 'Before we discuss a more refined and advanced version of what we have done,
    the following is what we have in the **Animation** panel:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论更精细和高级的版本之前，以下是我们 **动画** 面板中的内容：
- en: '![Figure 13.13 – The Flicker action has been defined for OmniLight in sconces
    ](img/Figure_13.13_B17473.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 在壁炉架中的 OmniLight 上已定义闪烁动作](img/Figure_13.13_B17473.jpg)'
- en: Figure 13.13 – The Flicker action has been defined for OmniLight in sconces
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 在壁炉架中的 OmniLight 上已定义闪烁动作
- en: Things now must look more organic when you light the first sconce. Then, perhaps
    after the second or the third one, the cozy flickering effect will look disturbingly
    repetitive, won’t it? If only there was a delay between different sconces so they
    wouldn’t all fire the **Flicker** action at the same time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点亮第一个壁炉架时，现在看起来必须更加自然。然后，也许在第二个或第三个之后，舒适的闪烁效果看起来会令人不安地重复，不是吗？如果不同壁炉架之间有延迟，它们就不会同时触发
    **闪烁** 动作。
- en: Achieving that will be relatively easy, but we suggest you first copy the `Sconce.tscn`
    and paste it into both the `Candles_01.tscn` and `Candles_02.tscn` scenes. It’ll
    be easier to notice the effect of randomness when we use the animation everywhere.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点相对容易，但我们建议您首先复制 `Sconce.tscn` 并将其粘贴到 `Candles_01.tscn` 和 `Candles_02.tscn`
    场景中。当我们将动画用于每个地方时，更容易注意到随机性的效果。
- en: 'When all of the light sources are lit, the whole level will look like it’s
    pulsing. Let’s see how we can break the unanimity and introduce some randomness
    to what we have, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有光源都点亮时，整个关卡将看起来像是在脉动。让我们看看我们如何打破这种一致性，并按照以下方式在我们的内容中引入一些随机性：
- en: Turn off **AutoPlay on Load** in **AnimationPlayer** for all of the three scenes
    you are using it for.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **AnimationPlayer** 中关闭所有三个场景的 **加载时自动播放**。
- en: 'Open the `LightSwitch.gd` script and alter the `_process` function as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `LightSwitch.gd` 脚本，并按如下方式修改 `_process` 函数：
- en: '[PRE5]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All our light sources share this script. So, the changes will apply to all instances.
    While we were not in favor of using the `yield` command, it was relatively harmless
    to do so in this case. The last three lines tell the engine to create **Timer**
    on the fly and it randomly picks **Wait Time** for it between 0 and 2 seconds.
    When this timer goes off, the **Flicker** action plays.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的光源都共享这个脚本。因此，这些更改将适用于所有实例。虽然我们并不赞成使用`yield`命令，但在这种情况下这样做相对无害。最后三行告诉引擎动态创建**Timer**，并随机在0到2秒之间选择**Wait
    Time**。当这个计时器响起时，**Flicker**动作开始播放。
- en: Although you copied and pasted the same **AnimationPlayer** node that forced
    the light sources to share the same length and keyframes with exactly the same
    values, since the **Flicker** action for each light starts with a delay thanks
    to our latest change, it will induce enough visual differences.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您复制并粘贴了相同的**AnimationPlayer**节点，该节点强制光源与具有完全相同值的长度和关键帧共享，但由于我们的最新更改，每个光源的**Flicker**动作都开始于一个延迟，这将产生足够的视觉差异。
- en: Additionally, if you want to be really fancy, you could add another track such
    as **light_energy** to vary the brightness of the light sources.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想更加精致，可以添加另一个如**light_energy**这样的轨道，以改变光源的亮度。
- en: Wrapping up
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Slowly but surely, you will have a more complete and believable feeling game
    by introducing small variations here and there, either by placing them in the
    world in a non-repeating pattern or by animating some of the game objects’ key
    features.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢但稳定地，通过在这里和那里引入小的变化，无论是将它们放置在世界上形成非重复模式，还是通过动画一些游戏对象的关键特征，您将拥有一个更加完整和逼真的游戏体验。
- en: Sometimes the method to do this will be completely different. For example, the
    shader we are using to simulate the body of water doesn’t use a node such as **AnimationPlayer**,
    but we still have motion. That being said, it’s disillusive to have that boat
    look so still while the water is in motion. With the knowledge you have gained
    in this section, we suggest you turn the boat model into a scene and animate it
    to show an oscillating motion like a boat would do.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候完成这个任务的方法会完全不同。例如，我们用来模拟水面效果的着色器并不使用像**AnimationPlayer**这样的节点，但我们仍然实现了运动效果。尽管如此，当水面在运动时，让那艘船看起来如此静止是令人误解的。在本节中获得的知识基础上，我们建议您将船模型变成一个场景，并为其添加类似船只的摆动动画。
- en: 'While you should feel confident that you know how to animate the basic properties
    of game objects, you have left out something important: Clara was supposed to
    head upstairs. Let’s help her do that.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您应该对自己知道如何动画游戏对象的基本属性感到自信，但您遗漏了一个重要的点：克拉拉本应上楼。让我们帮助她完成这个任务。
- en: Loading another level
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载另一个级别
- en: Before we started to animate the light sources in the *Let there be flickering
    lights* section, we were ready to move Clara upstairs. To that end, we used a
    nifty feature of the `load_level` function, which printed a statement to the **Output**
    panel, a substitution for the real thing. In this section, we’ll investigate how
    to swap the existing level with another.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动画“让那里有闪烁的灯光”部分中的光源之前，我们已经准备好将克拉拉带到楼上。为此，我们使用了`load_level`函数的一个巧妙特性，它在**输出**面板上打印了一条语句，作为真实事物的替代。在本节中，我们将探讨如何交换现有的级别与另一个级别。
- en: Let us remind you that our current level, `Level-01.tscn`, is instanced inside
    the `Game.tscn` scene, which is holding a `change_scene`, that can change the
    current scene to another scene. However, this might be dangerous since it’ll replace
    the entire structure. In our case, this is not `Level-01.tscn` but everything
    in `Game.tscn` because that’s the main scene.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒您，我们当前的水平，`Level-01.tscn`，被实例化在`Game.tscn`场景中，该场景包含一个`change_scene`节点，可以更改当前场景为另一个场景。然而，这可能是危险的，因为它将替换整个结构。在我们的案例中，这不仅仅是`Level-01.tscn`，而是`Game.tscn`中的所有内容，因为那是主场景。
- en: The solution we’ll offer is a process that’s operational at a higher level than
    `Level-01.tscn` itself. Ideally, your scenes should notify a higher authority
    of the changes they would like to introduce to the overall system. As it happens,
    this could very well be the `Game.tscn` scene via which not only can you use it
    to load a new level, but you could also be taking care of other stuff in your
    game such as keeping a log file, contacting a database to store important changes,
    or even reaching to a third-party service to show ads.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的解决方案是一个比`Level-01.tscn`本身操作级别更高的过程。理想情况下，你的场景应该通知更高权威机构它们想要引入的整体系统的变化。实际上，这完全可以是通过`Game.tscn`场景来完成的，不仅可以通过它来加载新关卡，还可以处理游戏中的其他事情，比如保持日志文件，联系数据库存储重要更改，甚至联系第三方服务来展示广告。
- en: Now that we’ve established the importance of the `Game.tscn` taking over the
    task of loading a new level, how are we going to let it know when to do it? You
    have used signals before to facilitate a way between different game objects to
    know each other. This involved placing a reference of an object inside another
    by exposing a script variable to the **Inspector** panel. Although we could still
    try this, there is a better way.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了`Game.tscn`承担加载新关卡任务的重要性，那么我们该如何让它知道何时执行呢？你之前已经使用过信号来促进不同游戏对象之间的相互了解。这涉及到通过将脚本变量暴露给**检查器**面板，在另一个对象内部放置一个对象的引用。尽管我们仍然可以尝试这种方法，但还有更好的方式。
- en: Using an event bus
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件总线
- en: When we expose variables to the **Inspector** panel so that scripts can recognize
    other game objects to be able to connect to their signals, we are coupling things,
    in a sense. When the number of objects and signals grows, this method will be
    difficult to maintain. There is an alternative, a concept called **event bus**,
    that might be helpful in an ever-growing list of dependencies.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将变量暴露给**检查器**面板，以便脚本能够识别其他游戏对象并能够连接到它们的信号时，我们在某种程度上将事物耦合在一起。当对象和信号的数量增加时，这种方法将难以维护。有一种替代方案，称为**事件总线**，这可能有助于不断增长的依赖列表。
- en: 'We’ll revisit this concept in more detail in the *Further reading* section
    since the notion is part of a much bigger family of options available to you.
    For the time being, we’ll be satisfied with a practical application of it. This
    is what it entails:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**进一步阅读**部分更详细地回顾这个概念，因为这个概念是可供你使用的更大选项集的一部分。目前，我们将满足于它的实际应用。以下是它所包含的内容：
- en: 'Create an `EventBus.gd` script in the `Scripts` folder. Add the following line
    to it:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个`EventBus.gd`脚本。向其中添加以下行：
- en: '[PRE6]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open **Project Settings** and switch to the **AutoLoad** tab.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**项目设置**并切换到**AutoLoad**选项卡。
- en: Use the button with the folder icon to find the `EventBus.gd` script.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有文件夹图标的按钮来查找`EventBus.gd`脚本。
- en: Press the **Add** button to add this script to the list underneath.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**添加**按钮，将此脚本添加到下面的列表中。
- en: '*Figure 13.14* shows what the editor will look like.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.14*显示了编辑器将看起来是什么样子。'
- en: '![Figure 13.14 – Our first singleton is set up and ready to use ](img/Figure_13.14_B17473.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 我们的第一个单例已设置并准备好使用](img/Figure_13.14_B17473.jpg)'
- en: Figure 13.14 – Our first singleton is set up and ready to use
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 我们的第一个单例已设置并准备好使用
- en: We have just added a script to the **AutoLoad** list. A **singleton** is also
    another common name that is used in the industry for this concept. It means that
    there can only be one instance of the script. Besides the conventional description,
    in a Godot-specific context, as soon as you introduce it to the **AutoLoad** tab,
    there will always be one and only copy of this script; it will also be loaded
    for you and be made available to all of the constructs in your project.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将一个脚本添加到**AutoLoad**列表中。**单例**也是行业内对这个概念使用的另一个常见名称。这意味着只能有一个脚本实例。除了传统描述之外，在Godot特定的上下文中，一旦你将其引入**AutoLoad**选项卡，就始终只有一个副本；它也会为你加载并可供项目中的所有构造使用。
- en: So, who’s going to make use of this new script since it doesn’t seem to be attached
    to anything? After all, it just exists there, but since **AutoLoad** makes it
    accessible at all times, we can use it when the door animation is finished.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁将利用这个新脚本，因为它似乎没有连接到任何东西？毕竟，它只是存在那里，但由于**AutoLoad**使其始终可用，我们可以在门动画完成后使用它。
- en: 'Let’s reassess our work from the *Waiting for the door animation to trigger
    an event* section. When we run and wait for the `Doors_RoundArch.tscn` scene,
    `load_level` function. There is currently a line of placeholder code in the body
    of that function in the form of printing a short statement: **What level?**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*等待门动画触发事件*部分重新评估我们的工作。当我们运行并等待`Doors_RoundArch.tscn`场景和`load_level`函数时。该函数体中目前有一行占位符代码，形式为打印一条简短的语句：**什么级别？**
- en: 'That’s where we originally intended to load the next level. However, in light
    of the discussion we had in the opening lines of the *Loading another level* section,
    we now want to delegate this to the `Game.tscn` scene. To that end, we have created
    an `EventBus.gd` script that will communicate our request to the relevant recipient.
    Therefore, you will have to make the following change:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们最初打算加载下一级的地方。然而，根据我们在*加载另一个级别*部分的讨论，我们现在希望将此委托给`Game.tscn`场景。为此，我们创建了一个`EventBus.gd`脚本，将我们的请求传达给相关接收者。因此，你必须进行以下更改：
- en: Open the `Doors_RoundArch.tscn` scene.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Doors_RoundArch.tscn`场景。
- en: 'Update the `load_level` function as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`load_level`函数：
- en: '[PRE7]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our earlier efforts, game objects were directly using the `emit_signal` command.
    For example, the backpack was emitting a `key_collected` signal. Here, we generalize
    the idea. We no longer care about knowing which object is emitting. We use a high-level
    construct such as `EventBus` to do this for us. *Figure 13.15* shows a diagram
    of the new architecture we are proposing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们早期的努力中，游戏对象直接使用`emit_signal`命令。例如，背包正在发出一个`key_collected`信号。在这里，我们概括了这个想法。我们不再关心知道哪个对象在发出。我们使用一个高级结构，如`EventBus`，来为我们做这件事。*图13.15*显示了我们所提出的新的架构图。
- en: '![Figure 13.15 – We no longer need to couple structures anymore thanks to EventBus
    ](img/Figure_13.15_B17473.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15 – 由于EventBus，我们不再需要耦合结构](img/Figure_13.15_B17473.jpg)'
- en: Figure 13.15 – We no longer need to couple structures anymore thanks to EventBus
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – 由于EventBus，我们不再需要耦合结构
- en: 'In the backpack example, the emitted signal was directly captured by the door
    so that the game could decide whether the player has completed a necessary condition.
    So, similar to how communication works in real life, there are two main parts
    to an event: an emitter and a receiver. We’ve made updates to the emitting situation.
    Let’s see what we can improve at the receiver’s end.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在背包的例子中，发出的信号被门直接捕获，以便游戏可以决定玩家是否完成了必要条件。因此，类似于现实生活中的通信方式，事件有两个主要部分：一个发射器和接收器。我们对发射情况进行了更新。让我们看看在接收器端我们可以改进什么。
- en: Listening to the EventBus signal
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听EventBus信号
- en: Going back to the relationship the door and the backpack objects had, the backpack
    wasn’t aware of the door, but the door had a field we set in the **Inspector**
    field to reference the backpack. So, when the backpack emitted an event, the door
    was already keeping an eye on the backpack in a manner.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回到门和背包对象之间的关系，背包没有意识到门的存在，但门有一个我们在**检查器**字段中设置的域来引用背包。因此，当背包触发事件时，门已经在某种方式上监视着背包。
- en: We are now trying to stay away from this type of architecture. Instead of directly
    using an object to emit an event, we tell the `EventBus` to do it for us. However,
    who is the door in our new example? In other words, who is listening to our event
    and how? The short answer is the `Game.tscn` scene.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正试图避免这种类型的架构。我们不是直接使用对象来触发事件，而是告诉`EventBus`为我们做这件事。然而，在我们新的例子中，谁是门呢？换句话说，谁在监听我们的事件以及如何监听？简短的答案是`Game.tscn`场景。
- en: 'Let’s implement some code first. Sometimes, it serves the purpose of showing
    instead of telling. Then, we’ll explain the rationale behind it. The following
    steps show what you should do after you open `Game.tscn`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一些代码。有时，它起到展示而非讲述的作用。然后，我们将解释其背后的原因。以下步骤显示了你在打开`Game.tscn`后应该做什么：
- en: Create a new `Level`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Level`。
- en: Drag the **Level-01** node into this new **Level** node.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Level-01**节点拖入这个新的**Level**节点。
- en: 'Make a new script as `Game.gd` and attach it to the root node. You can save
    it alongside the scene file. Then, you type in the following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本作为`Game.gd`，并将其附加到根节点。你可以将它保存与场景文件一起。然后，你输入以下代码：
- en: '[PRE8]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do you see that `_ready` function where we make use of the `EventBus` architecture?
    That’s the sweet part. This way, neither `Game.tscn` nor `Doors_RoundArch.tscn`
    need to know anything about each other. They share and deal with their responsibilities
    through `EventBus`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到那个`_ready`函数了吗？我们在这里使用了`EventBus`架构。这就是美妙的部分。这样，`Game.tscn`和`Doors_RoundArch.tscn`都不需要知道彼此的任何事情。它们通过`EventBus`共享和处理它们的责任。
- en: Somewhere, at some point, a structure may fire a `change_level` signal. That
    is all we care for, and after we express our interest in it, we also prepare ourselves
    for what to do with it, in case the event comes to fruition. If that’s the case,
    we handle it inside the `change_level` function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个地方，在某个时刻，一个结构可能会触发一个`change_level`信号。我们只关心这个，在我们表达了对它的兴趣之后，我们也为自己准备好了如何处理它，以防事件得以实现。如果是那样的话，我们就在`change_level`函数内部处理它。
- en: Naming conventions
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定
- en: Some people keep their signal and event handler (function) names the same for
    the sake of treating the function as an extension of the signal. Godot’s signal
    bindings will add an `_on_` prefix, though. Keeping your own event handlers’ names
    the same as the signal name might help you distinguish them from Godot’s own bindings.
    However, you could always follow Godot’s naming convention in your bindings too.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人为了将函数视为信号的扩展，会保持它们的信号和事件处理程序（函数）名称相同。不过，Godot的信号绑定会添加一个`_on_`前缀。将你自己的事件处理程序名称与信号名称保持一致可能有助于你将它们与Godot的绑定区分开来。然而，你也可以在你的绑定中遵循Godot的命名约定。
- en: 'Let’s now analyze what’s going on in the `change_level` event handler. When
    we fired the signal in the arched door scene, `EventBus` was passed a parameter
    in the form of a string: `Level-02.tscn`. The first line in the `change_level`
    function looks up and loads this string in the project’s `Scenes` folder. After
    finding a match and creating an instance of it, we want to store this new scene
    because we still have some work to do with the current scene. We should dispose
    of it before we add the new scene.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分析`change_level`事件处理程序中正在发生的事情。当我们从拱门场景中触发信号时，`EventBus`以字符串的形式传递了一个参数：`Level-02.tscn`。`change_level`函数的第一行查找并加载这个字符串在项目的`Scenes`文件夹中。在找到匹配项并创建其实例后，我们想要存储这个新场景，因为我们仍然需要与当前场景做一些工作。在我们添加新场景之前，我们应该将其销毁。
- en: Since we’ve made some changes to the `$Level.remove_child($Level.get_child(0))`.
    Only after that do we add the new level.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对`$Level.remove_child($Level.get_child(0))`做了一些更改。只有在之后，我们才添加新的关卡。
- en: There is only one thing left for you to do. Press *F5* and have Clara go through
    all of the steps necessary to trigger the door’s opening. As soon as the door
    is open, the game will take you upstairs to a new level. You should expect to
    see what *Figure 13.16* shows.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你只剩下一件事要做。按下*F5*，让Clara完成触发门开启所需的所有步骤。一旦门打开，游戏就会带你上楼到一个新的关卡。你应该会看到*图 13.16*
    展示的内容。
- en: '![Figure 13.16 – Welcome to our new level ](img/Figure_13.16_B17473.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – 欢迎来到我们的新关卡](img/Figure_13.16_B17473.jpg)'
- en: Figure 13.16 – Welcome to our new level
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 欢迎来到我们的新关卡
- en: Congratulations! You have guided Clara to find her way in the darkness to collect
    a key that unlocked the door to this new level. She can continue her adventures
    from here. Is that a chest over there? There is a trapdoor right in front of it
    though, so watch out for that. Using the tools that we have shown you, you can
    go on and create new conditions and obstacles for the player to tackle. It’s up
    to your imagination.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经引导Clara在黑暗中找到收集钥匙的方法，这把钥匙解锁了这个新关卡的门。她可以从这里继续她的冒险。那里有一个箱子吗？不过，就在它前面有一个陷阱门，所以要注意。使用我们向你展示的工具，你可以继续创建新的条件和障碍，让玩家去克服。这取决于你的想象力。
- en: We’ll now dedicate the rest of this chapter to discussing some of the choices
    you’ve made by following our guidelines and what you could also do differently.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将本章的剩余部分用于讨论你根据我们的指南所做的选择，以及你也可以做的一些不同的事情。
- en: Discussing some of the choices we can all make
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论我们可以做出的某些选择
- en: Our goal in this book is to teach you just the necessary parts of Godot Engine
    to build a simple point-and-click adventure game. It’s a simple statement, and
    yet it entails two separate efforts. On one hand, we should teach you as much
    as possible about the game engine without making it look like you are reading
    documentation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中的目标是教会你构建一个简单的点击冒险游戏所需的Godot引擎的必要部分。这是一个简单的声明，但它包含了两个不同的努力。一方面，我们应该尽可能多地教你关于游戏引擎的知识，而不要让它看起来像是在阅读文档。
- en: On the other hand, the game we planned to build must be advanced enough but
    also simple to the point that you can easily follow its progress by reading as
    little as possible. Also, the fact is that there are only so many pages in a book.
    Thus, some of the choices we made during the production of the game were limited
    by these factors.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们计划构建的游戏必须足够先进，但也要简单到足以通过阅读尽可能少的内容就能轻松跟踪其进展。事实上，一本书的页数是有限的。因此，我们在游戏制作过程中所做的某些选择受到了这些因素的制约。
- en: You might also face similar but different limitations and conundrums in your
    own projects. An early plan, even the worst one, might often be better than not
    having a plan at all. Even then, some cases might be really hard to nail and prepare
    beforehand, such as making your gameplay fun or achieving a decent user experience.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你在自己的项目中也可能面临类似但不同的限制和难题。一个早期的计划，即使是糟糕的，通常也比没有计划要好。即便如此，一些情况可能真的很难提前准备，比如让游戏玩法有趣或实现良好的用户体验。
- en: For example, the level switch is technically done. However, the change is happening
    so abruptly that the player might want to feel a moment of respite to collect
    their thoughts and savor their journey throughout the level. You can easily achieve
    this by extending the animation length and pushing the `load_level` function to
    later frames. It might look like there is a healthy pause between the door animation
    and the loading of the next level.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，关卡切换在技术上已经完成。然而，变化发生得太突然，玩家可能想要一个短暂的休息来整理思绪，回味他们在关卡中的旅程。你可以通过延长动画长度并将`load_level`函数推后到更晚的帧来实现这一点。这可能会看起来在门动画和下一级加载之间有一个健康的暂停。
- en: Even better, having the screen fade out before the switch actually happens might
    be a good idea. In fact, this might even be useful from a technical point of view.
    Our second level is so small, thus it’s easy to load it from the disk. However,
    in more ambitious projects, your levels might be chuck-full of game objects waiting
    to be loaded.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，在切换发生之前让屏幕淡出可能是个好主意。实际上，这可能甚至从技术角度来看也是有益的。我们的第二级非常小，因此很容易从磁盘加载。然而，在更雄心勃勃的项目中，你的关卡可能充满了等待加载的游戏对象。
- en: Furthermore, if your game loads previous sessions, you will have to reset your
    game objects’ states to their last known values. A generic loading screen in between
    switching levels or loading a previous game session might be a much better architecture.
    By following this practice, you’ll most likely find yourself abstracting more
    and more systems from more directly implemented systems.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的游戏加载了之前的会话，你将不得不将游戏对象的状 态重置为其最后已知的值。在切换关卡或加载之前的游戏会话之间有一个通用的加载屏幕可能是一个更好的架构。通过遵循这一实践，你很可能会发现自己越来越多地从直接实现的系统中抽象出更多系统。
- en: 'Thus, this is perhaps the most valuable piece of advice we can offer you: if
    you are feeling stuck or unsure of how to tackle a topic, first focus on the special
    case and its implementation, then try to generalize it if possible and necessary.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这可能是我们能提供的最有价值的建议：如果你感到困惑或不确定如何处理某个主题，首先关注特殊情况及其实现，然后如果可能且必要，尝试将其推广。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was another chapter with a lot of moving parts that incorporated so many
    different aspects of the game engine. Let’s break down some of your activities
    that helped to add the finishing touches on so many things we carried over from
    the previous chapters.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个包含了许多移动部件的章节，它结合了游戏引擎的许多不同方面。让我们分析一下你的活动，这些活动有助于为从上一章继承下来的许多事物添加最后的修饰。
- en: First, you tackled background music and sound effects. You had already seen
    the usage of sound in [*Chapter 8*](B17473_08.xhtml#_idTextAnchor129), *Adding
    Sound Assets*, which covered simple scenarios. In this chapter, you’ve learned
    how to use sound assets in a proper context.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你处理了背景音乐和音效。你已经在[*第8章*](B17473_08.xhtml#_idTextAnchor129)中看到了声音的使用，*添加音效资源*，它涵盖了简单场景。在本章中，你学习了如何在适当的环境中使用音效资源。
- en: Next, you reexamined a topic you saw in [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206),
    *Interacting with the World through Camera and Character Controllers* – player
    detection. This time, you used **Area** nodes as trigger zones since there would
    not be direct player interaction, such as mouse clicks and motion. Instead, Clara
    triggers predetermined events when she’s in the right zone.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你重新审视了你在[*第12章*](B17473_12.xhtml#_idTextAnchor206)中看到的主题，*通过摄像机和角色控制器与世界交互*——玩家检测。这次，你使用了**区域**节点作为触发区域，因为不会有直接的玩家交互，例如鼠标点击和动作。相反，当克拉拉处于正确的区域时，她会触发预定的事件。
- en: You were also able to communicate information between game objects, essentially
    separate and distant systems, when an **Area** node was actively used. For instance,
    when the player reached the backpack, the condition to open the door was satisfied.
    The backpack let the door know what was going on through the use of a custom signal.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个**区域**节点被积极使用时，你也能够在游戏对象之间传递信息，这些对象本质上是在分离和遥远的系统中。例如，当玩家到达背包时，满足打开门的条件。背包通过使用自定义信号让门知道发生了什么。
- en: You symbolized the pickup of the key with a sound effect. Perhaps, a short piece
    of animation would have been used to display a 3D key moving up and fading out.
    Sometimes, an icon appears at the bottom of your monitor and finds its place in
    what’s called a **quickbar** in some games. Both approaches are fine, but we didn’t
    want to do either one of them.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你用一个声音效果来象征钥匙的拾取。也许，一段简短的动画会用来显示一个3D钥匙向上移动并淡出的效果。有时，一个图标会出现在你的显示器底部，并在某些游戏中被称为**快速栏**的位置找到其位置。这两种方法都很好，但我们不想做其中任何一种。
- en: Since this chapter was supposed to teach the creation of animations in Godot,
    we wanted to show off cases that were sufficiently complex, such as flickering
    light sources or opening two sections of an arched door, rather than simply moving
    a key up in the game world. We believe our effort has a more didactic value that
    you can transfer to other simple use cases.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章旨在教授在Godot中创建动画，我们想展示一些足够复杂的案例，例如闪烁的光源或打开拱形门的两个部分，而不仅仅是将钥匙在游戏世界中向上移动。我们相信我们的努力具有更多的教学价值，你可以将其转移到其他简单的用例中。
- en: After finishing simple animations, particularly the door’s opening action, it
    was time for Clara to go upstairs. To achieve that, you looked into swapping the
    current level with a new one. Although you could have achieved this by letting
    game objects pass information between each other, you were introduced to a more
    generic way of doing this via an `EventBus` architecture.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成简单的动画后，尤其是门的开启动作后，是时候让克拉拉上楼了。为了实现这一点，你考虑了用新关卡替换当前关卡。虽然你可以通过让游戏对象之间传递信息来实现这一点，但你被介绍了一种更通用的方法，即通过`EventBus`架构来完成。
- en: Even though there is still one more chapter, this is the moment you should pat
    yourself on the back. You have built a fully functional, however small, point-and-click
    adventure game. The following chapter will show you how to export your game. We’ll
    also discuss what other options you can consider on your game development journey.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 即使还有一章，这也是你应该给自己鼓掌的时刻。你已经构建了一个完全功能性的、尽管规模很小，的点对点冒险游戏。下一章将向你展示如何导出你的游戏。我们还将讨论你在游戏开发旅程中可以考虑的其他选项。
- en: Further reading
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: As promised, we want to share with you a few words on the artistic aspects of
    sound management. Sometimes, a piece of music will have a high tempo. It means
    it’ll have a higher value of **beats per minute** (**BPM**). Depending on the
    game or the level you are building, you might want to select or create your music
    with the most appropriate BPM value to convey the best emotions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们想和你分享一些关于声音管理艺术方面的内容。有时，一段音乐会有很高的节奏。这意味着它的**每分钟节拍数**（**BPM**）会更高。根据你正在制作的游戏或关卡，你可能想要选择或创建具有最合适的BPM值的音乐，以传达最佳的情感。
- en: There are also situations where gameplay will ask for a mix between a higher
    and lower tempo. This is common in role-playing or action games where players
    would like to feel they are under tension when they get involved in a sticky situation.
    For example, it would absolutely break the immersion if your burly, gun-toting
    player character is hiding behind a cover under heavy enemy fire when classic
    or chillout music is playing in the background. Likewise, when all is supposed
    to look calm between two action zones, if the game is playing a piece of high-tempo
    music, you will needlessly stress out and confuse your players.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 也有情况下，游戏玩法会要求在快节奏和慢节奏之间混合。这在角色扮演或动作游戏中很常见，玩家希望在陷入困境时感到紧张。例如，如果您的健壮、持枪的玩家角色在背景中播放经典或轻松音乐时躲在掩护物后面，这将绝对破坏沉浸感。同样，当两个动作区域之间看起来都很平静时，如果游戏播放快节奏音乐，您将无谓地让玩家感到紧张和困惑。
- en: Luckily, there are plenty of courses on this topic on Udemy. Giving a list of
    courses here would do injustice to all of the others we couldn’t mention since
    the list is long. We suggest you look it up on their website by using the **music
    for games** keywords.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Udemy上有许多关于这个主题的课程。在这里列出课程列表会对我们未能提及的其他课程不公平，因为列表很长。我们建议您使用**游戏音乐**关键词在他们的网站上查找。
- en: 'Last in the sound management topic is the use of supplemental technologies.
    Either of the following two will help you create on-the-fly solutions to ever-changing
    circumstances if your game can’t make use of prearranged sound assets:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在声音管理主题的最后，是使用补充技术的使用。如果您的游戏无法使用预先安排的声音资产，以下两种技术中的任何一种都将帮助您为不断变化的情况创建即时解决方案：
- en: FMOD
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FMOD
- en: Wwise
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wwise
- en: 'We also briefly mentioned artificial intelligence in this chapter. This is
    a vast topic, but a pertinent list of books would be the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在本章中简要提到了人工智能。这是一个广泛的话题，但以下是一些相关的书籍列表：
- en: '*AI for Games* by Ian Millington'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI入门*，作者：伊恩·米林顿'
- en: '*Behavioral Mathematics for Game AI* by Dave Mark'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI行为数学*，作者：戴夫·马克'
- en: 'The *Game AI Pro 360* series by Steve Rabin:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 史蒂夫·拉宾的*游戏AI专业360*系列：
- en: '*Game AI Pro 360: Guide to Character Behavior*'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI专业360：角色行为指南*'
- en: '*Game AI Pro 360: Guide to Movement and Pathfinding*'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI专业360：移动和寻路指南*'
- en: '*Game AI Pro 360: Guide to Architecture*'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI专业360：架构指南*'
- en: '*Game AI Pro 360: Guide to Tactics and Strategy*'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏AI专业360：战术和策略指南*'
- en: The `EventBus` solution we presented in this chapter is frequently utilized
    in many programming circles. It’s sometimes called a `EventBus` with the post
    office. When a magazine you are subscribed to has its latest issue coming out,
    the publisher will notify the post office and you’ll be delivered your subscription.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们提出的`EventBus`解决方案在许多编程圈子中经常被使用。有时它被称为带有邮局的`EventBus`。当您订阅的杂志即将出版最新一期时，出版商会通知邮局，您将收到您的订阅。
- en: 'Since the inception of computer science, and more particularly software programming,
    developers have noticed problems that exhibited a particular behavior or nature.
    Solutions to these common problems are called **design patterns**. There are a
    lot of resources out there that deal with this topic in the framework of classic
    software. However, game developers have also gotten some love in recent years.
    Regardless of domain specificity, a few examples are the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 自计算机科学和特别是软件编程的诞生以来，开发者们已经注意到了表现出特定行为或性质的问题。这些常见问题的解决方案被称为**设计模式**。有很多资源处理这个话题，在经典软件的框架下。然而，近年来游戏开发者也得到了一些关注。无论特定领域如何，以下是一些例子：
- en: '[https://gameprogrammingpatterns.com](https://gameprogrammingpatterns.com)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gameprogrammingpatterns.com](https://gameprogrammingpatterns.com)'
- en: '[https://www.udemy.com/course/design-patterns-for-game-programming/](https://www.udemy.com/course/design-patterns-for-game-programming/)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.udemy.com/course/design-patterns-for-game-programming/](https://www.udemy.com/course/design-patterns-for-game-programming/)'
- en: '*Head First Design Patterns: Building Extensible and Maintainable Object-Oriented
    Software* by Eric Freeman'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Head First 设计模式》：构建可扩展和可维护的面向对象软件*，作者：埃里克·弗里曼'
- en: '*Learn Design Patterns with Game Programming* by Philippe-Henri Gosselin'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过游戏编程学习设计模式*，作者：菲利普-亨利·戈塞林'
