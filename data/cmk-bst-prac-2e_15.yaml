- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Cross-Platform-Compiling Custom Toolchains
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译自定义工具链
- en: One of the powerful features of CMake is its support for the cross-platform
    building of software. Simply put, this means that with CMake, a project from any
    platform can be built for any other platform, if the necessary tools are available
    on the system running CMake. When building software, we typically talk about compilers
    and linkers, and they are, of course, essential tools for building software. However,
    if we take a closer look, there are often some other tools, libraries, and files
    involved when building software. Collectively, these are commonly known as toolchains
    in CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的一个强大特性是它对跨平台软件构建的支持。简单来说，这意味着通过CMake，可以将任何平台的项目构建为任何其他平台的软件，只要在运行CMake的系统上提供必要的工具。在构建软件时，我们通常谈论编译器和链接器，它们当然是构建软件的必需工具。然而，如果我们仔细看看，构建软件时通常还涉及一些其他工具、库和文件。统称这些工具、库和文件通常被称为CMake中的工具链。
- en: So far in this book, all the examples were built for the system that CMake was
    running on. In these cases, CMake usually does a pretty good job of finding the
    correct toolchain to use. However, if the software is built for another platform,
    the toolchain usually must be specified by the developer. Toolchain definitions
    might be relatively straightforward and just specify the target platform, or they
    might be as complex as specifying paths to individual tools needed to build the
    software, or specific compiler flags to create binaries for a specific chipset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的所有示例都是针对CMake运行所在的系统构建的。在这些情况下，CMake通常能很好地找到正确的工具链。然而，如果软件是为另一个平台构建的，通常必须由开发者指定工具链。工具链定义可能相对简单，仅指定目标平台，或者可能复杂到需要指定单个工具的路径，甚至是为了为特定芯片组创建二进制文件而指定特定的编译器标志。
- en: In the context of cross-compiling, toolchains are often accompanied by `root`
    folder for finding the necessary libraries and files to compile and link the software
    to the intended target platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉编译的上下文中，工具链通常伴随有`root`文件夹，用于查找编译和链接软件所需的库和文件，以便将软件编译到预期的目标平台。
- en: While cross-compiling might be intimidating at first, it is often not as hard
    as it seems when using CMake properly. In this chapter, we will look at how to
    use toolchain files and how to write them yourself. We will look in detail at
    which tools are involved at particular stages of building software. Finally, we
    will look at how to set up CMake so that it can run tests with an emulator.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然交叉编译一开始可能让人感到害怕，但使用CMake正确配置时，它通常并不像看起来那样困难。本章将介绍如何使用工具链文件以及如何自己编写工具链文件。我们将详细探讨在软件构建的不同阶段涉及哪些工具。最后，我们将介绍如何设置CMake，使其能够通过模拟器运行测试。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Using existing cross-platform toolchain files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的跨平台工具链文件
- en: Creating toolchain files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建工具链文件
- en: Testing cross-compiled binaries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试交叉编译的二进制文件
- en: Testing a toolchain for supported features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工具链的支持特性
- en: By the end of the chapter, you will be proficient in handling existing toolchains
    and in how to build and test software for different platforms, using CMake. We
    will take a deeper look into how to test a compiler for a certain feature to determine
    whether it suits our purposes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将熟练掌握如何处理现有的工具链，并了解如何使用CMake为不同平台构建和测试软件。我们将深入探讨如何测试编译器的某个特性，以确定它是否适合我们的用途。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, the examples are tested with CMake 3.25 and
    are run on either of the following compilers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，示例是用CMake 3.25进行测试的，并在以下任一编译器上运行：
- en: The **GNU Compiler Collection 9** (**GCC 9**) or newer, including the cross-compiler
    for the **arm hard float** (**armhf**) architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU编译器集合9**（**GCC 9**）或更新版本，包括用于**arm硬浮动**（**armhf**）架构的交叉编译器'
- en: Clang 12 or newer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12或更新版本
- en: '**Microsoft Visual Studio C++ 19** (**MSVC 19**) or newer'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Visual Studio C++ 19**（**MSVC 19**）或更新版本'
- en: 'For the Android examples, the **Android Native Development Kit** (**Android
    NDK**) 23b or newer is required. Instructions on installation can be found in
    the official Android developer documentation: [https://developer.android.com/studio/projects/install-ndk](https://developer.android.com/studio/projects/install-ndk).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Android示例，**Android原生开发工具包**（**Android NDK**）23b或更新版本是必需的。安装说明可以在官方的Android开发文档中找到：[https://developer.android.com/studio/projects/install-ndk](https://developer.android.com/studio/projects/install-ndk)。
- en: For the Apple-embedded examples, Xcode 12 or newer and the **iOS Software Development
    Kit 12.4** (**iOS SDK 12.4**) are recommended.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Apple 嵌入式示例，建议使用 Xcode 12 或更新版本，以及**iOS 软件开发工具包 12.4**（**iOS SDK 12.4**）。
- en: 'All examples and source code are available in the GitHub repository for this
    book. If any of the software is missing, the corresponding examples will be excluded
    from the build. The repository can be found here: [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有示例和源代码都可以在 GitHub 仓库中找到。如果缺少任何软件，相应的示例将从构建中排除。仓库地址在这里：[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/)。
- en: Using existing cross-platform toolchain files
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有的跨平台工具链文件
- en: When building software for multiple platforms, the most straightforward way
    to do this is to compile software on the target system itself. The downside of
    that is that each developer has to have a running version of the target system
    to build the software. If these are desktop systems, that might work reasonably
    well, although moving between different installations to develop the software
    also makes the developer workflow quite tedious. Less powerful devices such as
    embedded systems might be very uncomfortable because of the lack of proper development
    tools, or because compiling the software takes very long.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当为多个平台构建软件时，最直接的方法是直接在目标系统上进行编译。其缺点是每个开发者必须有一个正在运行的目标系统来进行构建。如果这些是桌面系统，可能会相对顺利，但在不同的安装环境之间迁移以开发软件也会使开发者的工作流程变得非常繁琐。像嵌入式系统这样不太强大的设备，由于缺乏适当的开发工具，或者因为编译软件非常耗时，可能会非常不方便。
- en: 'Therefore, a much more convenient way from the developer’s perspective is to
    use cross-compiling. This means the software engineer writes code and builds the
    software on their own machine, but the resulting binaries are for a different
    platform. The machine and platform on which the software is built are usually
    called the *host machine* and *host platform*, whereas the platform on which the
    software should run is called the *target platform*. For instance, the developer
    writes code on their *x64* desktop machine running Linux, but the resulting binaries
    are for embedded Linux on an *arm64* processor. So, the host platform is *x64
    Linux* and the target platform is *arm64 Linux*. To cross-compile software, the
    following two things are needed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从开发者的角度来看，更便捷的方式是使用交叉编译。这意味着软件工程师在自己的机器上编写代码并构建软件，但生成的二进制文件是为不同平台的。构建软件的机器和平台通常称为*主机机器*和*主机平台*，而软件应运行的平台称为*目标平台*。例如，开发者在运行
    Linux 的*x64*桌面机器上编写代码，但生成的二进制文件是为运行在*arm64*处理器上的嵌入式 Linux 系统设计的。因此，主机平台是*x64 Linux*，目标平台是*arm64
    Linux*。要进行交叉编译软件，以下两项是必需的：
- en: A toolchain capable of producing binaries in the correct format
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够生成正确格式二进制文件的工具链
- en: Any dependencies of the project compiled for the target system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标系统编译的项目依赖项
- en: The toolchain is a set of tools, such as a compiler, linker, and archiver, to
    produce binaries that run on the host system but produce output for the target
    system. The dependencies are usually collected in a *sysroot* directory. Sysroots
    are directories containing a reduced version of a root filesystem where the needed
    libraries are stored. For cross-compilation, these directories serve as the root
    to search for any dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一组工具，如编译器、链接器和归档器，用于生成在主机系统上运行，但为目标系统生成输出的二进制文件。依赖项通常会收集在一个*sysroot*目录中。Sysroot
    是包含根文件系统精简版的目录，所需的库会存储在其中。对于交叉编译，这些目录作为搜索依赖项的根目录。
- en: 'Some tools, such as the `CMAKE_TOOLCHAIN_FILE` variable or, since CMake 3.21,
    with the `--toolchain` option, like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具，例如 `CMAKE_TOOLCHAIN_FILE` 变量，或者从 CMake 3.21 开始，使用 `--toolchain` 选项，像这样：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These calls are equivalent. If `CMAKE_TOOLCHAIN_FILE` is set as an environment
    variable, CMake will interpret this as well. If you use CMake presets, the configure
    presets may configure a toolchain file with the `toolchainFile` option, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用是等效的。如果 `CMAKE_TOOLCHAIN_FILE` 被设置为环境变量，CMake 也会进行解析。如果使用 CMake 预设，配置预设可能会通过
    `toolchainFile` 选项配置工具链文件，像这样：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `toolchainFile` option supports macro expansion, as described in [*Chapter
    9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build Environments*.
    If the path to the toolchain file is a relative path, CMake will first look relative
    to the `build` directory, and if the file is not found there, it will then search
    from the source directory. As `CMAKE_TOOLCHAIN_FILE` is a cache variable, it only
    needs to be specified for the first run of CMake; subsequent runs will use the
    cached value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolchainFile`选项支持宏扩展，具体描述请参见[*第9章*](B30947_09.xhtml#_idTextAnchor146)，*创建可复现的构建环境*。如果工具链文件的路径是相对路径，CMake会先在`build`目录下查找，如果在那里没有找到文件，它会从源目录开始查找。由于`CMAKE_TOOLCHAIN_FILE`是一个缓存变量，它只需要在第一次运行CMake时指定；之后的运行将使用缓存的值。'
- en: 'On the first run, CMake will perform some internal queries to establish which
    features a toolchain supports. This happens regardless of whether the toolchain
    is specified with a toolchain file or if the default system toolchain is used.
    A more in-depth look at how these tests happen is provided in the *Testing a toolchain
    for supported features* section. CMake will output the results of the tests for
    the various features and properties on the first run, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行时，CMake会执行一些内部查询来确定工具链支持哪些功能。这无论是否使用工具链文件指定工具链，或使用默认系统工具链时，都会发生。有关这些测试是如何执行的更深入的介绍，请参考*测试工具链支持的功能*部分。CMake将在第一次运行时输出各种功能和属性的测试结果，类似如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The detection of the features mostly happens on the first call to `project()`
    in a `CMakeLists.txt` file. However, any later call to `project()` that enables
    a previously disabled language further detection will then be triggered. The same
    happens if `enable_language()` is used to enable an additional programming language
    in a `CMakeLists.txt` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 功能检测通常发生在`CMakeLists.txt`文件中的第一次调用`project()`时。但是，任何启用先前禁用的语言的后续`project()`调用都会触发进一步的检测。如果在`CMakeLists.txt`文件中使用`enable_language()`来启用额外的编程语言，也会发生同样的情况。
- en: As the features and test results of the toolchains are cached, changing the
    toolchain of a configured build directory cannot be done. CMake might detect that
    the toolchain has changed, but usually, the replacement of the cache variables
    is incomplete. Because of this, the build directory should be fully deleted before
    changing the toolchain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工具链的功能和测试结果是被缓存的，因此无法更改已配置构建目录的工具链。CMake可能会检测到工具链已经更改，但通常情况下，替换缓存变量是不完全的。因此，在更改工具链之前，应该完全删除构建目录。
- en: Switching toolchains after configuration
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 配置后切换工具链
- en: Always clear the build directory completely before switching toolchains. Deleting
    only the `CMakeCache.txt` file will not be enough, as toolchain-related things
    might be cached in various locations. If you regularly build projects for multiple
    platforms, using separate build directories for each toolchain can speed up the
    development process considerably.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换工具链之前，请始终完全清空构建目录。仅删除`CMakeCache.txt`文件是不够的，因为与工具链相关的内容可能会被缓存到不同的位置。如果你经常为多个平台构建项目，使用为每个工具链分配的独立构建目录可以显著加快开发过程。
- en: CMake works under the paradigm that a project should use the same toolchain
    for everything. Because of this, using multiple toolchains is not directly supported.
    If this is really needed, the parts of a project that need a different toolchain
    have to be configured as sub-builds, as described in [*Chapter 10*](B30947_10.xhtml#_idTextAnchor158),
    *Handling Distributed Repositories and Dependencies in* *a Super-Build*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的工作方式是一个项目应该使用相同的工具链来进行所有操作。因此，直接支持使用多个工具链的方式并不存在。如果确实需要这样做，那么需要将需要不同工具链的项目部分配置为子构建，具体方法请参见[*第10章*](B30947_10.xhtml#_idTextAnchor158)，*在超构建中处理分布式仓库和依赖关系*。
- en: Toolchains should be kept as small as possible and be completely decoupled from
    any project. Ideally, they are reusable for different projects. Often, toolchain
    files come bundled together, with any SDK or sysroot used for cross-compiling.
    However, they sometimes need to be written manually.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链应尽可能保持精简，并且与任何项目完全解耦。理想情况下，它们可以在不同的项目中复用。通常，工具链文件是与用于交叉编译的任何SDK或sysroot一起捆绑的。然而，有时它们需要手动编写。
- en: Creating toolchain files
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工具链文件
- en: 'Toolchain files might seem intimidating at first, but on closer inspection,
    they are often relatively trivial. The misconception that defining cross-compilation
    toolchains is hard stems from the fact that there are many overly complicated
    examples of toolchain files found on the internet. Many of them were written for
    early versions of CMake and, thus, implemented many additional tests and checks
    that are now part of CMake itself. CMake toolchain files basically do the following
    things:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链文件一开始可能看起来令人害怕，但仔细检查后，它们通常相对简单。定义跨编译工具链很难的误解源于互联网上存在许多过于复杂的工具链文件示例。许多示例是为早期版本的
    CMake 编写的，因此实现了许多额外的测试和检查，而这些现在已经是 CMake 的一部分。CMake 工具链文件基本上做以下几件事：
- en: Define the target system and architecture.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义目标系统和架构。
- en: Provide paths to any tools needed to build the software for the defined platform.
    Often, these are just compilers.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供构建软件所需的任何工具的路径，这些工具通常只是编译器。
- en: Set default flags for the compiler and linkers.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为编译器和链接器设置默认标志。
- en: Point to the sysroot and possibly any staging directory if cross-compiling.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是跨编译，指向 sysroot 并可能指向任何暂存目录。
- en: Set hints for the search order of any `find_` commands of CMake. Changing the
    search order is something the project might define, and it is debatable whether
    this belongs in the toolchain file or should be handled by the project. See [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries and
    Dependency Management*, for details on `find_` commands.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 CMake `find_` 命令的搜索顺序提示。更改搜索顺序是项目可能定义的内容，是否应将其放在工具链文件中或由项目处理是有争议的。有关 `find_`
    命令的详细信息，请参见 [*第 5 章*](B30947_05.xhtml#_idTextAnchor084)，*集成第三方库和依赖管理*。
- en: 'A sample toolchain doing all these things might look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个执行所有这些操作的示例工具链可能如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example would define a toolchain targeting a build for a Linux operating
    system running on an `/usr/bin/` folders on the host system. Then, the compiler
    flags to print all warnings demanded by strict `-pedantic` flag. Next, the sysroot
    to find any required libraries is set to `/home/builder/raspi-sysroot/`, and the
    staging directory to install things when cross-compiling is set to `/home/builder/raspi-sysroot-staging/`.
    Finally, the search behavior for CMake is changed so that programs are searched
    only on the host system but libraries, `include` files, and packages are only
    searched in the sysroot. It is a controversial debate whether a toolchain file
    should influence the search behavior or not. Typically, only the project knows
    what it is trying to find, so making assumptions in the toolchain file might break
    that. However, only the toolchain knows which system root to use and what kinds
    of files are present inside it, so having the toolchain define this might be convenient.
    A good compromise is to use a CMake preset to define the toolchain and the search
    behavior, instead of putting it either in the project or the toolchain file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例会定义一个工具链，目标是为在主机系统的 `/usr/bin/` 文件夹上运行的 Linux 操作系统进行构建。接着，编译器标志设置为打印由严格的
    `-pedantic` 标志要求的所有警告。然后，设置 sysroot 以查找任何所需的库，路径为 `/home/builder/raspi-sysroot/`，并设置跨编译时用于安装内容的暂存目录为
    `/home/builder/raspi-sysroot-staging/`。最后，改变 CMake 的搜索行为，使得程序仅在主机系统上搜索，而库、`include`
    文件和包仅在 sysroot 中搜索。关于工具链文件是否应该影响搜索行为，存在争议。通常，只有项目知道它正在尝试查找什么，因此在工具链文件中做假设可能会破坏这一点。然而，只有工具链知道应该使用哪个系统根目录以及其中包含哪些类型的文件，因此让工具链来定义这一点可能会更方便。一个好的折中方法是使用
    CMake 预设来定义工具链和搜索行为，而不是将其放在项目文件或工具链文件中。
- en: Defining the target system
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义目标系统
- en: The target system for cross-compiling is defined by the following three variables
    – `CMAKE_SYSTEM_NAME`, `CMAKE_SYSTEM_PROCESSOR`, and `CMAKE_SYSTEM_VERSION`. These
    correspond to the `CMAKE_HOST_SYSTEM_NAME`, `CMAKE_HOST_SYSTEM_PROCESSOR`, and
    `CMAKE_HOST_SYSTEM_VERSION` variables, respectively, which describe the platform
    on which the build is performed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 跨编译的目标系统由以下三个变量定义 – `CMAKE_SYSTEM_NAME`、`CMAKE_SYSTEM_PROCESSOR` 和 `CMAKE_SYSTEM_VERSION`。它们分别对应
    `CMAKE_HOST_SYSTEM_NAME`、`CMAKE_HOST_SYSTEM_PROCESSOR` 和 `CMAKE_HOST_SYSTEM_VERSION`
    变量，这些变量描述了构建所在平台的系统信息。
- en: The `CMAKE_SYSTEM_NAME` variable describes the target operating system for which
    the software is to be built. Setting this variable is important, as this will
    cause CMake to set the `CMAKE_CROSSCOMPILING` variable to `true`. Typical values
    are `Linux`, `Windows`, `Darwin`, `Android`, or `QNX`, although you could use
    more specific platform names, such as `WindowsPhone`, `WindowsCE`, or `WindowsStore`.
    For bare-metal embedded devices, the `CMAKE_SYSTEM_NAME` variable is set to `Generic`.
    Unfortunately, at the time of writing, there exists no official list of supported
    systems in the CMake documentation. However, if necessary, the files in the `/Modules/Platform`
    folder in the local CMake installation can be inspected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSTEM_NAME` 变量描述了要构建软件的目标操作系统。设置这个变量很重要，因为它会导致 CMake 将 `CMAKE_CROSSCOMPILING`
    变量设置为 `true`。常见的值有 `Linux`、`Windows`、`Darwin`、`Android` 或 `QNX`，你也可以使用更具体的平台名称，例如
    `WindowsPhone`、`WindowsCE` 或 `WindowsStore`。对于裸机嵌入式设备，`CMAKE_SYSTEM_NAME` 变量设置为
    `Generic`。不幸的是，在写这篇文档时，CMake 文档中没有官方的支持系统列表。然而，如果需要，可以查看本地 CMake 安装中的 `/Modules/Platform`
    文件夹中的文件。'
- en: The `CMAKE_SYSTEM_PROCESSOR` variable is used to describe the hardware architecture
    of the platform. If not specified, the value of the `CMAKE_HOST_SYSTEM_PROCESSOR`
    variable will be assumed. The target processor architecture should also be set
    when cross-compiling to a 32-bit platform from a 64-bit platform, even if the
    processors are of the same type. For Android and Apple platforms, the processor
    is often not specified. When cross-compiling for Apple targets, the actual device
    is defined by the SDK that is used, which is specified by the `CMAKE_OSX_SYSROOT`
    variable. When cross-compiling for Android, specialized variables such as `CMAKE_ANDROID_ARCH_ABI`,
    `CMAKE_ANDROID_ARM_MODE`, and (optionally) `CMAKE_ANDROID_ARM_NEON` are used to
    control the target architecture. Building for Android will be covered in more
    depth in the *Cross-compiling for* *Android* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_SYSTEM_PROCESSOR` 变量用于描述平台的硬件架构。如果未指定，将假定使用 `CMAKE_HOST_SYSTEM_PROCESSOR`
    变量的值。在从 64 位平台交叉编译到 32 位平台时，即使处理器类型相同，也应该设置目标处理器架构。对于 Android 和 Apple 平台，通常不指定处理器。当为
    Apple 目标交叉编译时，实际设备由使用的 SDK 定义，SDK 由 `CMAKE_OSX_SYSROOT` 变量指定。为 Android 交叉编译时，使用诸如
    `CMAKE_ANDROID_ARCH_ABI`、`CMAKE_ANDROID_ARM_MODE` 和（可选的）`CMAKE_ANDROID_ARM_NEON`
    等专用变量来控制目标架构。关于 Android 的构建会在 *为 Android 交叉编译* 部分中详细介绍。'
- en: The last variable to define a target system is `CMAKE_SYSTEM_VERSION`. The content
    of it depends on the system being built. For `WindowsCE`, `WindowsStore`, and
    `WindowsPhone`, it will be used to define which version of the Windows SDK to
    use. On Linux, it is often omitted or might contain the kernel revision of the
    target system if this is relevant.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 定义目标系统的最后一个变量是 `CMAKE_SYSTEM_VERSION`。它的内容取决于构建的系统。对于 `WindowsCE`、`WindowsStore`
    和 `WindowsPhone`，它用于定义使用哪个版本的 Windows SDK。在 Linux 上，通常省略此项，或者如果相关，可能包含目标系统的内核版本。
- en: 'With the `CMAKE_SYSTEM_NAME`, `CMAKE_SYSTEM_PROCESSOR`, and `CMAKE_SYSTEM_VERSION`
    variables, target platforms are usually fully specified. However, some generators
    such as Visual Studio support their native platforms directly. For these, the
    architecture can be set with the `-A` command-line option of CMake, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CMAKE_SYSTEM_NAME`、`CMAKE_SYSTEM_PROCESSOR` 和 `CMAKE_SYSTEM_VERSION` 变量，通常可以完全指定目标平台。然而，一些生成器，如
    Visual Studio，直接支持其本地平台。对于这些平台，可以通过 CMake 的 `-A` 命令行选项来设置架构，方法如下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When using a preset, the `architecture` setting may be used in a configure preset
    for the same effect. Once the target system is defined, the tools to actually
    build the software are defined.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用预设时，`architecture` 设置可以在配置预设中使用，以达到相同的效果。一旦定义了目标系统，就可以定义用于实际构建软件的工具。
- en: Some compilers, such as Clang and `CMAKE_<LANG>_COMPILER_TARGET` variable is
    used. For Clang, the value is a target triple such as `arm-linux-gnueabihf`, and
    for QNX GCC, the compiler name and target have a value such as `gcc_ntoarmv7le`.
    The supported triples for Clang are described in its official documentation at
    [https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器，如 Clang 和 `CMAKE_<LANG>_COMPILER_TARGET` 变量也被使用。对于 Clang，值是目标三元组，如 `arm-linux-gnueabihf`，而对于
    QNX GCC，编译器名称和目标的值如 `gcc_ntoarmv7le`。Clang 的支持三元组在其官方文档中有描述，网址为 [https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html)。
- en: For the available options for QNX, the QNX documentation found at [https://www.qnx.com/developers/docs/](https://www.qnx.com/developers/docs/)
    should be consulted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 QNX 可用的选项，应该参考 QNX 文档，网址为 [https://www.qnx.com/developers/docs/](https://www.qnx.com/developers/docs/)。
- en: 'So, a toolchain file that uses Clang might look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，使用 Clang 的工具链文件可能如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, Clang is used to compile C and C++ code for a Linux system
    running on an ARM processor, with hardware floating-point support. Defining the
    target system often has a direct influence on the build tools that will be used.
    In the next section, we will look at how the compiler and the related tools are
    selected for cross-compilation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Clang 被用来编译运行在 ARM 处理器上的 Linux 系统的 C 和 C++ 代码，并且该系统支持硬件浮点运算。定义目标系统通常会直接影响将使用的构建工具。在下一节中，我们将探讨如何为交叉编译选择编译器及相关工具。
- en: Selecting the build tools
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择构建工具
- en: When building software, the compiler is the tool that often comes to mind, and
    in most cases, it is sufficient to set the compiler in a toolchain file. The path
    to the compiler is set by the `CMAKE_<LANG>_COMPILER` cache variable, which may
    be set in the toolchain file or passed manually to CMake. If the path is absolute,
    it will be used directly; otherwise, the same search order as when using `find_program()`
    will be used, which is one of the reasons why changing the search behavior in
    a toolchain file has to be treated with care. If neither the toolchain file nor
    the user does not specify the compiler, CMake will try to choose one automatically
    based on the target platform and generator specified. Additionally, the compiler
    can be set over an environment variable that is named after `<LANG>`. So, `C`
    will set the C compiler, `CXX` the C++ compiler, `ASM` the assembler, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件时，编译器通常是首先想到的工具，在大多数情况下，仅设置工具链文件中的编译器就足够了。编译器的路径由 `CMAKE_<LANG>_COMPILER`
    缓存变量设置，可以在工具链文件中设置，也可以手动传递给 CMake。如果路径是绝对路径，则会直接使用；否则，将使用与 `find_program()` 相同的搜索顺序，这也是为什么在工具链文件中更改搜索行为时需要谨慎的原因之一。如果工具链文件和用户都没有指定编译器，CMake
    将尝试根据指定的目标平台和生成器自动选择一个编译器。此外，编译器还可以通过与 `<LANG>` 对应的环境变量来设置。所以，`C` 用来设置 C 编译器，`CXX`
    用来设置 C++ 编译器，`ASM` 用来设置汇编器，依此类推。
- en: 'Some generators such as Visual Studio may support their own toolset definition,
    which works differently. They can be set with the `-T` command-line option. The
    following command would tell CMake to generate code for Visual Studio to produce
    binaries for a 32-bit system, but using 64-bit compilers to do so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器，如 Visual Studio，可能支持其自定义的工具集定义，这些定义的工作方式不同。它们可以通过 `-T` 命令行选项进行设置。以下命令将告诉
    CMake 为 Visual Studio 生成代码，以便为 32 位系统生成二进制文件，但使用 64 位编译器进行编译：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The values might also be set with the `CMAKE_GENERATOR_TOOLSET` variable from
    a toolchain file. This should not be set inside a project, as it obviously does
    not conform to the idea of CMake project files being agnostic to the generator
    and platform used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值也可以通过工具链文件中的 `CMAKE_GENERATOR_TOOLSET` 变量进行设置。这个变量不应该在项目中设置，因为它显然不符合 CMake
    项目文件与生成器和平台无关的原则。
- en: For Visual Studio users, it is possible to have multiple competing instances
    of the same Visual Studio version installed by having the preview and official
    release of the same version installed. If this is the case, the `CMAKE_GENERATOR_INSTANCE`
    variable may be set to the absolute installation path of Visual Studio in the
    toolchain file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Visual Studio 用户，通过安装同一版本的预览版和正式版，可以在计算机上同时安装多个相同版本的 Visual Studio 实例。如果是这种情况，可以在工具链文件中将
    `CMAKE_GENERATOR_INSTANCE` 变量设置为 Visual Studio 的绝对安装路径。
- en: By specifying the compiler to use, CMake will choose the default flags for the
    compiler and linker and make them available in the project, by setting `CMAKE_<LANG>_FLAGS`
    and `CMAKE_<LANG>_FLAGS_<CONFIG>`, where `<LANG>` stands for the respective programming
    language and `<CONFIG>` for the build configuration, such as debug or release.
    The default linker flags are set by the `CMAKE_<TARGETTYPE>_LINKER_FLAGS` and
    `CMAKE_<TARGETTYPE>_LINKER_FLAGS_<CONFIG>` variables, where `<TARGETTYPE>` is
    either `EXE`, `STATIC`, `SHARED`, or `MODULE`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定要使用的编译器，CMake 将为编译器和链接器选择默认标志，并通过设置`CMAKE_<LANG>_FLAGS`和`CMAKE_<LANG>_FLAGS_<CONFIG>`使其在项目中可用，其中
    `<LANG>` 代表相应的编程语言，`<CONFIG>` 代表构建配置，如调试或发布。默认的链接器标志由 `CMAKE_<TARGETTYPE>_LINKER_FLAGS`
    和 `CMAKE_<TARGETTYPE>_LINKER_FLAGS_<CONFIG>` 变量设置，其中 `<TARGETTYPE>` 可以是 `EXE`、`STATIC`、`SHARED`
    或 `MODULE`。
- en: 'To add custom flags to the default flags, there exists a variable with `_INIT`
    appended to each of the variables – for example, `CMAKE_<LANG>_FLAGS_INIT`. When
    working with toolchain files, `_INIT` variables are used to set any necessary
    flags. A toolchain file compiling with GCC to a 32-bit target from a 64-bit host
    would look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要向默认标志添加自定义标志，可以使用带有 `_INIT` 后缀的变量—例如，`CMAKE_<LANG>_FLAGS_INIT`。在使用工具链文件时，`_INIT`
    变量用于设置任何必要的标志。一个从 64 位主机为 32 位目标进行 GCC 编译的工具链文件可能如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For simple projects, setting up the target system and the toolchain might be
    already enough to start creating binaries, but for more complex projects, they
    might need access to libraries and headers of the target system. For such cases,
    sysroots can be specified in the toolchain files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的项目，设置目标系统和工具链可能已经足够开始创建二进制文件，但对于更复杂的项目，它们可能需要访问目标系统的库和头文件。对于这种情况，可以在工具链文件中指定
    sysroot。
- en: Setting the sysroot
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 sysroot
- en: When cross-compiling, all linked dependencies obviously have to match the target
    platform as well, and a common way of dealing with this is to create a sysroot,
    which is the root filesystem of the target system in a folder. While sysroots
    may contain full systems, they are often stripped down to just provide what is
    needed. Sysroots are described in detail in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible* *Build Environments*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行交叉编译时，所有链接的依赖项显然也必须与目标平台匹配，一种常见的处理方法是创建一个 sysroot，它是目标系统的根文件系统，存储在一个文件夹中。虽然
    sysroot 可以包含完整的系统，但通常会被精简到仅提供所需内容。sysroot 的详细描述见于 [*第 9 章*](B30947_09.xhtml#_idTextAnchor146)，*创建可重现的*
    *构建环境*。
- en: Setting the sysroot is done by setting `CMAKE_SYSROOT` to its path. If this
    is set, CMake will, by default, look in the sysroot first for libraries and header
    files unless specified differently, as described in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084),
    *Integrating Third-Party Libraries and Dependency Management*. In most cases,
    CMake will also automatically set the necessary compiler and linker flags to make
    the tools work with the sysroot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 sysroot 通过将 `CMAKE_SYSROOT` 设置为其路径来完成。如果设置了该值，CMake 默认会首先在 sysroot 中查找库和头文件，除非另有说明，正如在
    [*第 5 章*](B30947_05.xhtml#_idTextAnchor084)，*集成第三方库和依赖管理* 中所述。在大多数情况下，CMake 还会自动设置必要的编译器和链接器标志，以便工具与
    sysroot 一起工作。
- en: In cases where the build artifacts should not be installed directly in the sysroot,
    the `CMAKE_STAGING_PREFIX` variable can be set to provide an alternative installation
    path. This is often the case when the sysroot should be kept clean or when it
    is mounted as read-only. Note that the `CMAKE_STAGING_PREFIX` setting will not
    add this directory to `CMAKE_SYSTEM PREFIX_PATH`, so things installed in the staging
    directory will only be found with `find_package()` if the `CMAKE_FIND_ROOT_PATH_MODE_PACKAGE`
    variable in the toolchain is set to `BOTH` or `NEVER`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建产物不应直接安装到 sysroot 中，可以设置 `CMAKE_STAGING_PREFIX` 变量以提供替代的安装路径。通常在以下情况时需要这样做：sysroot
    应保持干净或当它被挂载为只读时。请注意，`CMAKE_STAGING_PREFIX` 设置不会将该目录添加到 `CMAKE_SYSTEM_PREFIX_PATH`，因此，只有当工具链中的
    `CMAKE_FIND_ROOT_PATH_MODE_PACKAGE` 变量设置为 `BOTH` 或 `NEVER` 时，暂存目录中安装的内容才能通过 `find_package()`
    找到。
- en: Defining the target system and setting the toolchain configuration, the sysroot,
    and the staging directory are often all that are needed for cross-compiling. Two
    exceptions are cross-compiling for Android and Apple’s iOS, tvOS, or watchOS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义目标系统并设置工具链配置、sysroot 和暂存目录通常是进行交叉编译所需的所有内容。两个例外是针对 Android 和 Apple 的 iOS、tvOS
    或 watchOS 进行交叉编译。
- en: Cross-compiling for Android
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对 Android 进行交叉编译
- en: 'In the past, compatibility between Android’s NDK and various CMake versions
    was sometimes a bit of an unhappy relationship, as new versions of the NDK suddenly
    no longer worked the same way with CMake as previous releases did. However, this
    condition has now been vastly improved, as from the r23 version, the Android NDK
    now uses CMake’s internal support for toolchains. Together with a CMake version
    of 3.21 or higher, building for Android has become reasonably convenient, so using
    these or newer versions is recommended. The official documentation for the Android
    NDK’s integration with CMake can be found here: [https://developer.android.com/ndk/guides/cmake](https://developer.android.com/ndk/guides/cmake).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，Android的NDK与不同CMake版本之间的兼容性有时关系并不顺畅，因为NDK的新版本往往不再以与以前版本相同的方式与CMake协作。然而，从r23版本开始，这一情况得到了极大的改善，因为Android
    NDK现在使用CMake内部对工具链的支持。结合CMake 3.21或更高版本，为Android构建变得相对方便，因此推荐使用这些或更新的版本。关于Android
    NDK与CMake集成的官方文档可以在此处找到：[https://developer.android.com/ndk/guides/cmake](https://developer.android.com/ndk/guides/cmake)。
- en: 'As of r23, the NDK provides its own CMake toolchain file, located at `<NDK_ROOT>/build/cmake/android.toolchain.cmake`,
    which can be used like any regular toolchain file. The NDK also includes all necessary
    tools for a Clang-based toolchain, so usually, no further tools have to be defined.
    To control the target platform, the following CMake variables should be passed
    over the command line or by using a CMake preset:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从r23版本开始，NDK提供了自己的CMake工具链文件，位于`<NDK_ROOT>/build/cmake/android.toolchain.cmake`，可以像任何常规的工具链文件一样使用。NDK还包括所有必要的工具，以支持基于Clang的工具链，因此通常不需要定义其他工具。要控制目标平台，应通过命令行或使用CMake预设传递以下CMake变量：
- en: '`ANDROID_ABI`: Specifies the `armeabi-v7a`, `arm64-v8a`, `x86`, and `x86_64`.
    This should always be set when cross-compiling for Android.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ABI`：指定`armeabi-v7a`、`arm64-v8a`、`x86`和`x86_64`。在为Android进行交叉编译时，这个变量应该始终设置。'
- en: '`ANDROID_ARM_NEON`: Enables NEON support for `armeabi-v7a`. This variable does
    not affect other ABI versions. When using an NDK above version r21, NEON support
    is enabled by default, and this rarely needs to be disabled.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ARM_NEON`：为`armeabi-v7a`启用NEON支持。该变量不会影响其他ABI版本。使用r21版本以上的NDK时，默认启用NEON支持，通常不需要禁用它。'
- en: '`ANDROID_ARM_MODE`: Specifies whether to generate ARM or Thumb instructions
    for `armeabi-v7a`. Valid values are either `thumb` or `arm`. This variable does
    not affect other ABI versions.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ARM_MODE`：指定是否为`armeabi-v7a`生成ARM或Thumb指令。有效值为`thumb`或`arm`。该变量不会影响其他ABI版本。'
- en: '`ANDROID_LD`: Decides whether the default linker or the experimental `lld`
    from `llvm` should be used. Valid values are `default` or `lld`, but this variable
    is usually omitted for production builds because of the experimental state of
    `lld`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_LD`：决定使用默认的链接器还是来自`llvm`的实验性`lld`。有效的值为`default`或`lld`，但由于`lld`处于实验阶段，这个变量通常在生产构建中被省略。'
- en: '`ANDROID_PLATFORM`: Specifies the minimum `$API_LEVEL`, `android-$API_LEVEL`,
    or `android-$API_LETTER` format, where `$API_LEVEL` is a number and `$API_LETTER`
    is the version code of the platform. `ANDROID_NATIVE_API_LEVEL` is a variable
    alias for this. While it is not strictly necessary to set the API level, this
    is usually done.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_PLATFORM`：指定最低的`$API_LEVEL`，`android-$API_LEVEL`，或`android-$API_LETTER`格式，其中`$API_LEVEL`是一个数字，`$API_LETTER`是平台的版本代码。`ANDROID_NATIVE_API_LEVEL`是该变量的别名。虽然设置API级别并非严格必要，但通常会进行设置。'
- en: '`ANDROID_STL`: Specifies which `c++_static` (which is the default), `c++_shared`,
    `none`, or `system`. Either `c++_shared` or `c++_static` are needed for modern
    C++ support. The `system` library only provides `new` and `delete` and C++ wrappers
    for the C library headers, while `none` provides no STL support at all.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_STL`：指定使用哪种`c++_static`（默认值）、`c++_shared`、`none`或`system`。现代C++支持需要使用`c++_shared`或`c++_static`。`system`库仅提供`new`和`delete`以及C库头文件的C++封装，而`none`则完全不提供STL支持。'
- en: 'A call to CMake to configure an Android build could look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调用CMake来配置Android构建的命令可能如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This call would specify a build that requires API level 23 or higher, which
    corresponds to Android 6.0 or higher for a 32-bit ARM **central processing** **unit**
    (**CPU**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将指定需要API级别23或更高的构建，这对应于Android 6.0或更高版本的32位ARM **中央处理** **单元** (**CPU**)。
- en: An alternative to using the toolchain provided by the NDK is to point CMake
    to the location of the Android NDK, which is the recommended way with NDKs newer
    than version r23\. The configuration of the target platform then happens with
    the respective CMake variables. By setting the `CMAKE_SYSTEM_NAME` variable to
    `android` and the `CMAKE_ANDROID_NDK` variable to the location of the Android
    NDK, CMake is told to use the NDK. This can either happen over the command line
    or in a toolchain file. Alternatively, if the `ANDROID_NDK_ROOT` or `ANDROID_NDK`
    *environment variables* are set, they will be used as the value for `CMAKE_ANDROID_NDK`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NDK提供的工具链的替代方案是将CMake指向Android NDK的位置，这对于r23版本之后的NDK是推荐的方式。然后，目标平台的配置通过相应的CMake变量进行。通过将`CMAKE_SYSTEM_NAME`变量设置为`android`，并将`CMAKE_ANDROID_NDK`变量设置为Android
    NDK的位置，CMake会被告知使用NDK。这可以通过命令行或在工具链文件中完成。或者，如果设置了`ANDROID_NDK_ROOT`或`ANDROID_NDK`
    *环境变量*，它们将被用作`CMAKE_ANDROID_NDK`的值。
- en: 'When using the NDK in this way, the configuration is defined instead of the
    `CMAKE_` equivalent of the variables used when invoking the toolchain file of
    the NDK directly, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用NDK时，配置是通过定义变量来实现的，而不是直接调用NDK工具链文件时所用的`CMAKE_`等效变量，如下所示：
- en: '`CMAKE_ANDROID_API` or `CMAKE_SYSTEM_VERSION` is used to specify the minimum
    API level to build for'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_ANDROID_API`或`CMAKE_SYSTEM_VERSION`用于指定要构建的最低API级别'
- en: '`CMAKE_ANDROID_ARCH_ABI` is used to indicate which ABI mode to use'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_ANDROID_ARCH_ABI`用于指示要使用的ABI模式'
- en: '`CMAKE_ANDROID_STL_TYPE` specifies which STL to be used'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_ANDROID_STL_TYPE`指定要使用的STL'
- en: 'A sample toolchain file to configure CMake with the Android NDK might look
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配置CMake与Android NDK的示例工具链文件可能如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When cross-compiling for Android using Visual Studio generators, CMake requires
    either *NVIDIA Nsight Tegra Visual Studio Edition* or *Visual Studio tools for
    Android*, which uses the Android NDK. When using Visual Studio to build Android
    binaries, the built-in support for CMake’s Android NDK can be used by setting
    the `CMAKE_ANDROID_NDK` variable to the location of the NDK.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Visual Studio生成器为Android进行交叉编译时，CMake要求使用*NVIDIA Nsight Tegra Visual Studio
    Edition*或*Visual Studio for Android工具*，它们使用Android NDK。使用Visual Studio构建Android二进制文件时，可以通过将`CMAKE_ANDROID_NDK`变量设置为NDK的位置，利用CMake的内置Android
    NDK支持。
- en: Cross-compiling native code for Android has become much easier with the recent
    versions of the NDK and the CMake versions from 3.20\. Another special case for
    cross-compiling is when targeting Apple’s iOS, tvOS, or watchOS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随着NDK的最近版本和3.20及更高版本的CMake，Android的本地代码交叉编译变得更加简单。交叉编译的另一个特殊情况是当目标是Apple的iOS、tvOS或watchOS时。
- en: Cross-compiling for iOS, tvOS, or watchOS
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为iOS、tvOS或watchOS进行交叉编译
- en: The recommended way to cross-compile for Apple’s iPhone, Apple TV, or Apple
    watches is to use the Xcode generator. Apple is quite restrictive in what you
    can use to build apps for these devices, so using macOS or a **virtual machine**
    (**VM**) running macOS is needed. While using Makefiles or Ninja files is possible,
    they require much more in-depth knowledge of the Apple ecosystem to be configured
    correctly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的为Apple的iPhone、Apple TV或Apple手表进行交叉编译的方式是使用Xcode生成器。苹果对用于这些设备构建应用的工具有相当严格的限制，因此需要使用macOS或运行macOS的**虚拟机**（**VM**）。虽然使用Makefiles或Ninja文件也是可能的，但它们需要更深入的苹果生态系统知识才能正确配置。
- en: 'To cross-compile for any of these devices, the Apple device SDK is needed,
    and the `CMAKE_SYSTEM_NAME` variable is set to `iOS`, `tvOS`, or `watchOS`, as
    in the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些设备进行交叉编译时，需要使用Apple设备的SDK，并将`CMAKE_SYSTEM_NAME`变量设置为`iOS`、`tvOS`或`watchOS`，如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For reasonably modern SDKs and a CMake version of 3.14 or higher, this is usually
    all that is needed. By default, the latest device SDK available on the system
    is used, but different SDKs can be selected by setting the `CMAKE_OSX_SYSROOT`
    variable to the path of the SDK if needed. The minimum target platform version
    can be specified with the `CMAKE_OSX_DEPLOYMENT_TARGET` variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合理现代的SDK和CMake版本为3.14或更高版本时，通常这就是所需要的所有配置。默认情况下，系统上可用的最新设备SDK将被使用，但如果需要，可以通过将`CMAKE_OSX_SYSROOT`变量设置为SDK路径来选择不同的SDK。如果需要，还可以通过`CMAKE_OSX_DEPLOYMENT_TARGET`变量指定最低目标平台版本。
- en: 'When cross-compiling for iPhone, Apple TV, or Apple Watches, the target can
    either be the real devices or the device simulator that comes with different SDKs.
    However, Xcode has built-in support to switch this during the build part, so CMake
    does not have to be run twice. CMake uses the `xcodebuild` command-line tool internally
    if the Xcode generator is selected, which supports the `-sdk` option to select
    the desired SDK. When building through CMake, this option can be passed like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 iPhone、Apple TV 或 Apple Watch 进行交叉编译时，目标可以是实际设备，也可以是随不同 SDK 提供的设备模拟器。然而，Xcode
    内置支持在构建过程中切换目标，因此 CMake 不需要运行两次。如果选择了 Xcode 生成器，CMake 会内部使用 `xcodebuild` 命令行工具，该工具支持
    `-sdk` 选项来选择所需的 SDK。在通过 CMake 构建时，可以像这样传递此选项：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will pass the `-sdk` option with the specified value to `xcodebuild`. The
    allowed values are `iphoneos` or `iphonesimulator` for iOS, `appletvos` or `appletvsimulator`
    for Apple TV devices, and `watchos` or `watchsimulator` for Apple Watches.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把指定的 `-sdk` 选项传递给 `xcodebuild`。允许的值包括 iOS 的 `iphoneos` 或 `iphonesimulator`，Apple
    TV 设备的 `appletvos` 或 `appletvsimulator`，以及 Apple Watch 的 `watchos` 或 `watchsimulator`。
- en: Apple-embedded platforms require the mandatory signing of certain build artifacts.
    For the Xcode generator, the development team `CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM`
    cache variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 嵌入式平台要求对某些构建产物进行强制签名。对于 Xcode 生成器，开发团队 `CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM`
    缓存变量。
- en: When building for Apple-embedded devices, the simulators come in handy to test
    code without the need to deploy to the devices each time. In this case, the testing
    is best done through Xcode or `xcodebuild` itself, but for other platforms, cross-compiled
    code can be tested through CMake and CTest directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Apple 嵌入式设备构建时，模拟器非常有用，可以在无需每次都将代码部署到设备上的情况下进行测试。在这种情况下，测试最好通过 Xcode 或 `xcodebuild`
    本身来完成，但对于其他平台，交叉编译的代码可以直接通过 CMake 和 CTest 进行测试。
- en: Testing cross-compiled binaries
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试交叉编译的二进制文件
- en: Being able to effortlessly cross-compile binaries for different architectures
    adds much convenience to the developer workflows of the people involved, but often,
    these workflows do not stop at building the binaries and also include running
    tests. If the software also compiles on the host toolchain and the tests are generic
    enough, running tests on the host might be the easiest way to test the software,
    although it might cost you some time when switching the toolchains and rebuilding
    frequently. If this is not possible or too time-consuming, one alternative is,
    of course, to run any tests on the real target hardware, but depending on the
    availability of the hardware and the effort of setting up the tests on the hardware,
    this might also be rather cumbersome. Therefore, often, a practicable middle way
    is to run tests inside an emulator for the target platform if this is available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地为不同架构交叉编译二进制文件，为开发者的工作流程带来了极大的便利，但通常这些工作流程不仅仅局限于构建二进制文件，还包括运行测试。如果软件也可以在主机工具链上编译，并且测试足够通用，那么在主机上运行测试可能是测试软件的最简单方式，尽管这可能会在切换工具链和频繁重建时浪费一些时间。如果这不可行或过于耗时，当然可以选择在实际目标硬件上运行测试，但这取决于硬件的可用性和在硬件上设置测试的工作量，这可能会变得相当繁琐。因此，通常可行的折中方法是，如果有模拟器可用，在目标平台的模拟器中运行测试。
- en: To define an emulator to run tests, the `CROSSCOMPILING_EMULATOR` target property
    is used. It can either be set for individual targets or globally by setting the
    `CMAKE_CROSSCOMPILING_EMULATOR` cache variable, which contains a semicolon-separated
    list of the command and arguments to run the emulator. If set globally, the command
    will be prefixed to all commands specified in `add_test()`, `add_custom_command()`,
    and `add_custom_target()`, and it will be used to run any executables generated
    by the `try_run()` commands. This means that all custom commands that are used
    for a build must be accessible and runnable inside the emulator as well. The `CROSSCOMPILING_EMULATOR`
    property does not necessarily have to be an actual emulator – it can be any arbitrary
    program, such as a script that copies the binaries to a target machine and executes
    it there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义用于运行测试的仿真器，使用`CROSSCOMPILING_EMULATOR`目标属性。它可以为单个目标设置，也可以通过设置`CMAKE_CROSSCOMPILING_EMULATOR`缓存变量来全局设置，该变量包含一个用分号分隔的命令和参数列表，用于运行仿真器。如果全局设置，则该命令将被添加到`add_test()`、`add_custom_command()`和`add_custom_target()`中指定的所有命令之前，并且它将用于运行任何由`try_run()`命令生成的可执行文件。这意味着所有用于构建的自定义命令也必须能够在仿真器中访问并运行。`CROSSCOMPILING_EMULATOR`属性不一定必须是一个实际的仿真器——它可以是任何任意程序，例如一个将二进制文件复制到目标机器并在那里执行的脚本。
- en: 'Setting `CMAKE_CROSSCOMPILING_EMULATOR` should either happen over a toolchain
    file, the command line, or a configured prefix. An example toolchain file used
    to cross-compile C++ code for ARM, using the popular open source emulator *QEMU*
    to run the tests, could look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`CMAKE_CROSSCOMPILING_EMULATOR`应该通过工具链文件、命令行或配置的前缀进行。一个用于交叉编译C++代码到ARM的工具链文件示例如下，它使用流行的开源仿真器*QEMU*来运行测试：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition to setting the information of the target system and the toolchain
    to cross-compile the last line in the example, it sets the `emulator` command
    to `qemu-arm -L /path/to/arm/sysroot`. Let’s assume a `CMakeLists.txt` file contains
    a test defined like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置目标系统和工具链的交叉编译信息外，示例中的最后一行将`emulator`命令设置为`qemu-arm -L /path/to/arm/sysroot`。假设一个`CMakeLists.txt`文件中包含如下定义的测试：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When CTest is run instead of running `exampleExe` directly, the `test` command
    is transformed to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行CTest时，不是直接运行`exampleExe`，而是将`test`命令转换为如下形式：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running tests in an emulator can speed up developer workflows quite a bit, as
    it might eliminate the need to switch between the host toolchain and the target
    toolchain and does not require the build artifacts to be moved to the target hardware
    for each superficial test. Using emulators like this also comes in handy for **continuous
    integration** (**CI**) builds where it might be hard to build on the real target
    hardware.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真器中运行测试可以显著加速开发人员的工作流程，因为它可能消除了在主机工具链和目标工具链之间切换的需要，并且不需要将构建产物移动到目标硬件进行每个表面测试。像这样的仿真器也非常适合**持续集成**（**CI**）构建，因为在真实的目标硬件上构建可能会很困难。
- en: A trick regarding `CMAKE_CROSSCOMPILING_EMULATOR` is that it also can be used
    to temporarily wrap tests in a diagnostic utility, such as *valgrind* or similar
    diagnostic tools. As running the specified emulator executable is not dependent
    on the `CMAKE_CROSSCOMPILING` variable that indicates whether a project is cross-compiled
    or not, a common pitfall with this workaround is that setting the `CMAKE_CROSSCOMPILING_EMULATOR`
    variable will impact the `try_run()` command, often used to test for supported
    features of the toolchain or any dependencies, and because a diagnostic utility
    might cause a compiler test to fail, it might be necessary to run it on an already
    cached build where any results of `try_run()` are already cached. Because of this,
    using the `CMAKE_CROSSCOMPILING_EMULATOR` variable to run diagnostic utilities
    should not be done permanently but, rather, in a specific development situation,
    when hunting defects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`CMAKE_CROSSCOMPILING_EMULATOR`的一个技巧是，它也可以用来临时将测试包装在诊断工具中，例如*valgrind*或类似的诊断工具。由于运行指定的仿真器可执行文件并不依赖于`CMAKE_CROSSCOMPILING`变量（该变量指示一个项目是否是交叉编译的），因此使用这个变通方法的一个常见陷阱是，设置`CMAKE_CROSSCOMPILING_EMULATOR`变量会影响`try_run()`命令，该命令通常用于测试工具链或任何依赖项是否支持某些功能，并且由于诊断工具可能导致编译器测试失败，因此可能需要在已经缓存的构建上运行它，其中`try_run()`的任何结果已经被缓存。因此，使用`CMAKE_CROSSCOMPILING_EMULATOR`变量运行诊断工具不应永久进行，而应在特定的开发情况下使用，例如在寻找缺陷时。
- en: In this section, we mentioned CMake’s `try_run()` command, which, along with
    the closely related `try_compile()` command, is used to check for the availability
    of certain features in the compiler or the toolchain. In the next section, we
    will take a closer look at the two commands and feature-testing toolchains.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提到过 CMake 的 `try_run()` 命令，它与密切相关的 `try_compile()` 命令一起，用于检查编译器或工具链中某些功能的可用性。在下一节中，我们将更详细地探讨这两个命令以及功能测试工具链。
- en: Testing a toolchain for supported features
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具链支持的功能
- en: When CMake is run for the first time on a project tree, it performs various
    tests for compiler and language features. Any call to `project()` or `enable_language()`
    will trigger testing again, but the results may be already cached from a previous
    run. Caching is also the reason why switching toolchains on an existing build
    is not recommended.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CMake 在项目树上首次运行时，它会执行各种编译器和语言功能的测试。每次调用 `project()` 或 `enable_language()`
    都会重新触发测试，但测试结果可能已经从之前的运行中缓存。缓存也是为什么在现有构建中切换工具链不推荐的原因。
- en: As we will see in this section, CMake can check for quite a few features out
    of the box. Most of the checks will internally use the `try_compile()` command
    to perform these tests. This command essentially builds a small binary with the
    toolchain that is either detected or supplied by the user. All relevant global
    variables such as `CMAKE_<LANG>_FLAGS` will be forwarded to `try_compile()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本节中看到的，CMake 可以开箱即检查许多功能。大多数检查将内部使用 `try_compile()` 命令来执行这些测试。该命令本质上使用检测到的或由用户提供的工具链构建一个小的二进制文件。所有相关的全局变量，如
    `CMAKE_<LANG>_FLAGS`，都将传递给 `try_compile()`。
- en: Closely related to `try_complie()` is the `try_run()` command, which internally
    calls `try_compile()` and, if that succeeds, will try to run the program. For
    regular compiler checks, `try_run()` is not used, and any calls to it are usually
    defined in the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `try_complie()` 密切相关的是 `try_run()` 命令，它内部调用 `try_compile()`，如果成功，它将尝试运行程序。对于常规的编译器检查，不使用
    `try_run()`，任何调用它的地方通常都在项目中定义。
- en: 'To write custom checks, rather than invoking `try_compile()` and `try_run()`
    directly, it is recommended to use the `CheckSourceCompiles` or `CheckSourceRuns`
    modules and the respective functions’ `check_source_compiles()` and `check_source_runs()`
    commands, which have been available since CMake 3.19\. In most cases, they will
    suffice to produce the necessary information without the need for more complicated
    handling of `try_compile()` or `try_run()`. The signatures of the two commands
    are very similar, as we can see here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写自定义检查，建议使用 `CheckSourceCompiles` 或 `CheckSourceRuns` 模块，而不是直接调用 `try_compile()`
    和 `try_run()`，这两个模块和相应的函数 `check_source_compiles()` 和 `check_source_runs()` 命令自
    CMake 3.19 版本以来就已可用。在大多数情况下，它们足以提供必要的信息，而无需更复杂地处理 `try_compile()` 或 `try_run()`。这两个命令的签名非常相似，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `<lang>` parameter specifies one of the languages supported by Cmake, such
    as `C` or `CXX` for C++. `<code>` is the code as a string to be linked as an executable,
    so it must contain a `main()` function. The result of the compilation will be
    stored as a Boolean value in the `<resultVar>` cache variable. If `FAIL_REGEX`
    is provided for `check_source_compiles`, the output of the compilation will be
    checked against the expressions supplied. The code will be saved in a temporary
    file with the extension matching the language selected; if the file has an extension
    other than the default, it can be specified by the `SRC_EXT` option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<lang>` 参数指定 CMake 支持的语言之一，如 C 或 C++。`<code>` 是作为字符串链接为可执行文件的代码，因此它必须包含一个
    `main()` 函数。编译的结果将作为布尔值存储在 `<resultVar>` 缓存变量中。如果为 `check_source_compiles` 提供了
    `FAIL_REGEX`，则将检查编译输出是否符合提供的表达式。代码将保存在具有与所选语言匹配的扩展名的临时文件中；如果文件的扩展名与默认值不同，则可以通过
    `SRC_EXT` 选项指定。'
- en: 'There are also language-specific versions of the modules called `Check<LANG>SourceCompiles`
    and `Check<LANG>SourceRuns` that provide the respective commands, as illustrated
    in the following example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有语言特定版本的模块，称为 `Check<LANG>SourceCompiles` 和 `Check<LANG>SourceRuns`，它们提供相应的命令，如以下示例所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s assume that there is a C++ project that could either use the atomic functionality
    of the standard library or, if this is not supported, fall back to a different
    implementation. A compiler check for this might look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 C++ 项目，它可能使用标准库的原子功能，或者如果不支持该功能，则回退到其他实现。针对这个功能的编译器检查可能如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After including the module, the `check_source_compiles()` function is called
    with a small program that uses the functionality to be checked. If the code compiles
    successfully, `HAS_STD_ATOMIC` will be set to `true`; otherwise, it will be set
    to `false`. The test is executed during the configuration of the project and will
    print a status message like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含该模块后，`check_source_compiles()` 函数会与一个使用待检查功能的小程序一起调用。如果代码成功编译，`HAS_STD_ATOMIC`
    将被设置为 `true`；否则，将被设置为 `false`。该测试会在项目配置期间执行，并打印类似如下的状态信息：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result will be cached so that any subsequent run of CMake will not perform
    the test again. In a lot of cases, checking whether a program compiles already
    gives enough information about a certain feature of a toolchain, but sometimes,
    the underlying program has to be run to obtain the required information. To do
    this, `check_source_runs()` is analogous to `check_source_compiles()`. One caveat
    of `check_source_runs()` is this – if `CMAKE_CROSSCOMPILING` is set but no emulator
    command is set, then the test will only compile the test but not run it unless
    `CMAKE_CROSSCOMPILING_EMULATOR` is set.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会被缓存，以便后续运行 CMake 时不会再次执行该测试。在很多情况下，检查程序是否编译已经能提供足够的信息，表明工具链的某些特性，但有时需要运行底层程序以获取所需的信息。为此，`check_source_runs()`
    类似于 `check_source_compiles()`。`check_source_runs()` 的一个注意事项是，如果设置了 `CMAKE_CROSSCOMPILING`
    但未设置模拟器命令，那么测试将只编译测试程序，而不会运行，除非设置了 `CMAKE_CROSSCOMPILING_EMULATOR`。
- en: 'There are a number of variables in the form of `CMAKE_REQUIRED_` to control
    how the checks compile the code. Note that these variables lack the language-specific
    part, which needs special care if working on projects that run tests for different
    languages. An explanation of some of these variables is provided here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多以 `CMAKE_REQUIRED_` 开头的变量可以控制检查如何编译代码。请注意，这些变量缺少特定语言的部分，如果在进行跨语言测试时需要特别小心。以下是一些这些变量的解释：
- en: '`CMAKE_REQUIRED_FLAGS` is used to pass additional flags to the compiler after
    any flags specified in the `CMAKE_<LANG>_FLAGS` or `CMAKE_<LANG>_FLAGS_<CONFIG>`
    variable.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_FLAGS` 用于在 `CMAKE_<LANG>_FLAGS` 或 `CMAKE_<LANG>_FLAGS_<CONFIG>`
    变量中指定的任何标志之后，向编译器传递附加标志。'
- en: '`CMAKE_REQUIRED_DEFINITIONS` specifies a number of compiler definitions of
    the form `-DFOO=bar`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_DEFINITIONS` 指定了多个编译器定义，形式为 `-DFOO=bar`。'
- en: '`CMAKE_REQUIRED_INCLUDES` specifies a list of directories to search for additional
    headers.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_INCLUDES` 指定了一个目录列表，用于搜索额外的头文件。'
- en: '`CMAKE_REQUIRED_LIBRARIES` specifies a list of libraries to add when linking
    programs. These can be the filenames of the libraries or imported CMake targets.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_LIBRARIES` 指定在链接程序时要添加的库列表。这些可以是库的文件名或导入的 CMake 目标。'
- en: '`CMAKE_REQUIRED_LINK_OPTIONS` is a list of additional linker flags.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_LINK_OPTIONS` 是一个附加链接器标志的列表。'
- en: '`CMAKE_REQUIRED_QUIET` can be set to `true` to suppress any status messages
    from the checks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_REQUIRED_QUIET` 可以设置为 `true`，以抑制检查时的任何状态信息。'
- en: 'In situations where the checks need to be isolated from each other, the `CMakePushCheckState`
    modules provide the `cmake_push_check_state()`, `cmake_pop_check_state()`, and
    `cmake_reset_check_state()` functions to store the configuration, restore a previous
    configuration, and reset the configuration, as illustrated in the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要将检查彼此隔离的情况下，`CMakePushCheckState` 模块提供了 `cmake_push_check_state()`、`cmake_pop_check_state()`
    和 `cmake_reset_check_state()` 函数，用于存储配置、恢复先前的配置和重置配置，以下例子演示了这一点：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Underlying the commands to check compilation or run the test program are the
    more complicated `try_compile()` and `try_run()` commands, respectively. While
    available for use, they are mainly intended for internal use, and thus we refer
    to the official documentation of the commands instead of explaining them here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查编译或运行测试程序的命令是更复杂的 `try_compile()` 和 `try_run()` 命令。虽然它们可以使用，但主要用于内部，因此我们这里不做解释，而是参考命令的官方文档。
- en: Checking compiler features by compiling and running programs is a very versatile
    approach to checking for toolchain features. Some checks are so common that CMake
    provides dedicated modules and functions for them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译和运行程序来检查编译器特性是一种非常灵活的方法，用于检查工具链特性。有些检查非常常见，CMake 提供了专门的模块和函数来执行这些检查。
- en: Common checks for toolchain and language features
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具链和语言特性的常见检查
- en: For some of the most common feature checks, such as checking whether a compiler
    flag is supported or if a header file exists, CMake provides its own modules for
    convenience. Since CMake 3.19, the general modules that take the language as an
    argument exist, but the corresponding `Check<LANG>...` language-specific modules
    can still be used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些最常见的功能检查，例如检查编译器标志是否支持或头文件是否存在，CMake提供了方便的模块。从CMake 3.19版本开始，提供了通用模块，可以将语言作为参数，但相应的`Check<LANG>...`特定语言模块仍然可以使用。
- en: 'A very basic test to check whether a compiler for a certain language is available
    is done using the `CheckLanguage` module. It can be used to check whether a compiler
    for a certain language is available if the `CMAKE_<LANG>_COMPILER` variable is
    not set. An example to check whether Fortran is available could look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基础的测试，用于检查某个语言的编译器是否可用，可以通过`CheckLanguage`模块来完成。如果未设置`CMAKE_<LANG>_COMPILER`变量，它可以用来检查某个语言的编译器是否可用。例如，检查Fortran是否可用的示例如下：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the check succeeds, the corresponding `CMAKE_<LANG>_COMPILER` variable is
    set. If the variable was set before the check, it has no effect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查成功，则会设置相应的`CMAKE_<LANG>_COMPILER`变量。如果在检查之前该变量已设置，则不会产生任何影响。
- en: '`CheckCompilerFlag` provides the `check_compiler_flag()` function to check
    whether the current compiler supports a certain flag. Internally, a very simple
    program will be compiled, and the output will be parsed for a diagnostic message.
    The check assumes that any compiler flags already present in `CMAKE_<LANG>_FLAGS`
    will run successfully through; otherwise, the `check_compiler_flag()` function
    will always fail. The following example checks whether the C++ compiler supports
    the `-``Wall` flag:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckCompilerFlag`提供了`check_compiler_flag()`函数，用于检查当前编译器是否支持某个标志。在内部，会编译一个非常简单的程序，并解析输出以获取诊断信息。该检查假设`CMAKE_<LANG>_FLAGS`中已存在的任何编译器标志都能成功运行；否则，`check_compiler_flag()`函数将始终失败。以下示例检查C++编译器是否支持`-Wall`标志：'
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the `-Wall` flag is supported, the `WALL_FLAG_SUPPORTED` cache variable will
    be `true`; otherwise, it will be `false`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`-Wall`标志被支持，则`WALL_FLAG_SUPPORTED`缓存变量将为`true`；否则为`false`。
- en: 'The corresponding module to check linker flags is called `CheckLinkerFlag`
    and works similarly to the check for compiler flags, but the linker flag will
    not be passed directly to the linker. As the linker will typically be invoked
    through the compiler, additional flags passed to the linker can use a prefix such
    as `-Wl` or `-Xlinker` to tell the compiler to pass the flag through. As this
    flag is compiler-specific, CMake provides the `LINKER:` prefix to automatically
    substitute the command. For example, to pass a flag to generate statistics about
    execution time and memory consumption to the linker, the following command would
    be used:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查链接器标志的相应模块叫做`CheckLinkerFlag`，其工作方式与检查编译器标志类似，但链接器标志不会直接传递给链接器。由于链接器通常是通过编译器调用的，因此传递给链接器的额外标志可以使用如`-Wl`或`-Xlinker`等前缀，告诉编译器将该标志传递过去。由于该标志是编译器特定的，CMake提供了`LINKER:`前缀来自动替换命令。例如，要向链接器传递生成执行时间和内存消耗统计信息的标志，可以使用以下命令：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the linker supports the `-stats` flag, the `LINKER_STATS_FLAG_SUPPORTED`
    variable will be `true`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接器支持`-stats`标志，则`LINKER_STATS_FLAG_SUPPORTED`变量将为`true`。
- en: Other useful modules to check various things are the `CheckLibraryExists`, `CheckIncludeFile`,
    and `CheckIncludeFileCXX` modules, for checking whether a certain library or include
    file exists in certain locations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的模块用于检查各种内容，包括`CheckLibraryExists`、`CheckIncludeFile`和`CheckIncludeFileCXX`模块，用于检查某个库或包含文件是否存在于某些位置。
- en: CMake offers even more detailed checks that might be very specific to a project
    – for example, the `CheckSymbolExists` and `CheckSymbolExistsCXX` modules check
    whether a certain symbol exists either as a preprocessor definition, a variable,
    or a function. `CheckStructHasMember` will check whether a struct has a certain
    member, while `CheckTypeSize` can check the size of non-user types and the definition
    of C and C++ function prototypes with `CheckPrototypeDefinition`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还提供了更多详细的检查，可能非常特定于某个项目——例如，`CheckSymbolExists`和`CheckSymbolExistsCXX`模块检查某个符号是否存在，无论它是作为预处理器定义、变量还是函数。`CheckStructHasMember`将检查结构体是否具有某个成员，而`CheckTypeSize`可以检查非用户类型的大小，并使用`CheckPrototypeDefinition`检查C和C++函数原型的定义。
- en: As we have seen, CMake offers quite a lot of checks, and the list of available
    checks will probably grow as CMake evolves. While checks are useful in certain
    situations, we should be careful not to carry the number of tests too far. The
    number and complexity of the checks will have quite an impact on the speed of
    the configuration step while sometimes not providing too much benefit. Having
    a lot of checks in a project could also suggest unnecessary complexity in it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，CMake 提供了很多检查，随着 CMake 的发展，可用的检查列表可能会不断增加。虽然在某些情况下检查是有用的，但我们应该小心不要让测试的数量过多。检查的数量和复杂度将对配置步骤的速度产生很大影响，同时有时并不会带来太多好处。在一个项目中有很多检查，也可能意味着该项目存在不必要的复杂性。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Broad support for cross-compiling is one of the striking features of CMake.
    In this chapter, we looked at how to define a toolchain file for cross-compiling
    and how to use sysroots to use libraries for a different target platform. A special
    case of cross-compiling is Android and Apple mobile devices, which rely on their
    specific SDKs. With a brief excursion into using emulators or simulators for testing
    for other platforms, you now have all the essential information to start building
    quality software for various target platforms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 对交叉编译的广泛支持是其显著特点之一。在本章中，我们探讨了如何定义一个用于交叉编译的工具链文件，以及如何使用 sysroot 来使用不同目标平台的库。交叉编译的一个特殊案例是
    Android 和苹果移动设备，它们依赖于各自的 SDK。通过简要介绍使用模拟器或仿真器测试其他平台，现在你已经掌握了所有必要的信息，可以开始为各种目标平台构建优质软件。
- en: The last part of the chapter concerned itself with the advanced topic of testing
    toolchains for certain features. While most projects will not have to concern
    themselves with these details, they are nevertheless useful to know.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分讨论了测试工具链某些特性的高级话题。虽然大多数项目不需要关注这些细节，但了解这些内容依然很有用。
- en: The next chapter will discuss making CMake code reusable across multiple projects,
    without the need to rewrite everything again and again.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论如何让 CMake 代码在多个项目之间可重用，而不需要一遍又一遍地重写所有内容。
- en: Questions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are toolchain files passed to CMake?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工具链文件如何传递给 CMake？
- en: What is usually defined in a toolchain file for cross-compiling?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常在交叉编译的工具链文件中定义了什么？
- en: What is a staging directory in the context of a sysroot?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 sysroot 的上下文中，什么是中间目录？
- en: How can an emulator be passed to CMake for testing?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将模拟器传递给 CMake 进行测试？
- en: What triggers the detection of compiler features?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么触发了编译器特性的检测？
- en: How can the configuration context for compiler checks be stored and restored?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何存储和恢复编译器检查的配置上下文？
- en: What is the effect of the `CMAKE_CROSSCOMPILING` variable on compiler checks?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMAKE_CROSSCOMPILING` 变量对编译器检查有什么影响？'
- en: Why should you fully clear the build directory when switching toolchains and
    not just delete the cache?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在切换工具链时应该完全清除构建目录，而不仅仅是删除缓存？
- en: Answers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Toolchain files are passed either by the `--toolchain` command-line flag, the
    `CMAKE_TOOLCHAIN_FILE` variable, or with the `toolchainFile` option in a CMake
    preset.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工具链文件可以通过 `--toolchain` 命令行标志、`CMAKE_TOOLCHAIN_FILE` 变量，或者通过 CMake 预设中的 `toolchainFile`
    选项传递。
- en: 'Usually, the following things are done in a toolchain file for cross-compiling:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，交叉编译的工具链文件中会做以下几件事：
- en: Defining the target system and architecture
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目标系统和架构
- en: Providing paths to any tools needed to build the software
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供构建软件所需的任何工具的路径
- en: Setting default flags for the compiler and linkers
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为编译器和链接器设置默认标志
- en: Pointing to the sysroot and possibly any staging directory if cross-compiling
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 sysroot 和可能的任何中间目录（如果是交叉编译的话）
- en: Setting hints for the search order for any `find_` commands of CMake
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 CMake 的 `find_` 命令设置搜索顺序的提示
- en: The staging directory is set with the `CMAKE_STAGING_PREFIX` variable and is
    used as a place to install any built artifacts if the sysroot should not be modified.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间目录通过 `CMAKE_STAGING_PREFIX` 变量设置，作为安装任何已构建的工件的地方，如果 sysroot 不应被修改。
- en: The emulator command is passed as a semicolon-separated list in the `CMAKE_CROSSCOMPILING_EMULATOR`
    variable.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟器命令作为分号分隔的列表传递给 `CMAKE_CROSSCOMPILING_EMULATOR` 变量。
- en: Any call to `project()` or `enable_language()` in a project will trigger the
    detection of the features.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中对 `project()` 或 `enable_language()` 的任何调用都会触发特性检测。
- en: The configuration context for compiler checks can be stored with `cmake_push_check_state()`
    and restored to a previous state with `cmake_pop_check_state()`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器检查的配置上下文可以通过`cmake_push_check_state()`存储，并通过`cmake_pop_check_state()`恢复到先前的状态。
- en: If `CMAKE_CROSSCOMPILING` is set, any call to `try_run()` will compile the test
    but not run it, unless an emulator command is set.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了`CMAKE_CROSSCOMPILING`，任何对`try_run()`的调用将会编译测试但不会运行，除非设置了模拟器命令。
- en: Build directories should be fully cleared because the temporary artifacts for
    compiler checks might not be rebuilt properly when just deleting the cache.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建目录应该完全清理，因为仅删除缓存时，编译器检查的临时产物可能不会正确重建。
