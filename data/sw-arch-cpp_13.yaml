- en: Security in Code and Deployment
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和部署中的安全性
- en: After establishing the proper tests, it is necessary to perform a security audit
    to make sure our application will not be used for malicious purposes. This chapter
    describes how to assess the security of the code base, including both the internally
    developed software as well as third-party modules. It will also show how to improve
    existing software both at the code level and at the operating system level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立适当的测试之后，有必要进行安全审计，以确保我们的应用程序不会被用于恶意目的。本章描述了如何评估代码库的安全性，包括内部开发的软件和第三方模块。它还将展示如何在代码级别和操作系统级别改进现有软件。
- en: You'll learn how to design applications with a focus on security at each level,
    starting with code, through to dependencies, architecture, and deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何在每个级别上设计重点放在安全性上的应用程序，从代码开始，通过依赖关系、架构和部署。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Checking the code security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码安全性
- en: Checking whether the dependencies are secure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查依赖项是否安全
- en: Hardening your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固您的代码
- en: Hardening your environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固您的环境
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Some of the examples used in this chapter require the compilers with the minimal
    versions of the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的一些示例需要具有以下最低版本的编译器：
- en: GCC 10+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 10+
- en: Clang 3.1+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 3.1+
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已经放在GitHub上[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10)。
- en: Checking the code security
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查代码安全性
- en: In this chapter, we provide information on how to check your code, your dependencies,
    and your environment for potential threats. Keep in mind, though, that following
    every step outlined within this chapter won't necessarily protect you against
    all possible problems. Our aim is to show you some possible dangers and the ways
    to deal with them. Given this, you should always be conscious of the security
    of your system and make audits a routine event.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了有关如何检查您的代码、依赖项和环境是否存在潜在威胁的信息。但请记住，遵循本章中概述的每个步骤不一定会保护您免受所有可能的问题。我们的目标是向您展示一些可能的危险以及处理它们的方法。鉴于此，您应始终意识到系统的安全性，并使审计成为例行事件。
- en: Before the internet became ubiquitous, software authors weren't too concerned
    about the security of their designs. After all, if the user presented malformed
    data, the user could crash their own computer at most. In order to use software
    vulnerabilities to access protected data, the attacker had to obtain physical
    access to the machines holding the data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网变得无处不在之前，软件作者并不太关心他们设计的安全性。毕竟，如果用户提供了格式不正确的数据，用户最多只能使自己的计算机崩溃。为了利用软件漏洞访问受保护的数据，攻击者必须获得物理访问权限到保存数据的机器。
- en: Even in software that was designed to be used within networks, security was
    often an afterthought. Take the **Hypertext Transfer Protocol** (**HTTP**) as
    an example. Even though it allows the password protection of some assets, all
    of the data is transferred in plain text. This means everyone on the same network
    can eavesdrop on the data being transferred.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是设计用于网络内部使用的软件，安全性也经常被忽视。以**超文本传输协议**（**HTTP**）为例。尽管它允许对某些资产进行密码保护，但所有数据都是以明文传输的。这意味着在同一网络上的每个人都可以窃听正在传输的数据。
- en: Today, we should embrace security right from the first stages of design and
    keep it in mind at every stage of software development, operations, and maintenance.
    Most of the software we produce every day is meant to, in one way or another,
    connect with other existing systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们应该从设计的最初阶段就开始重视安全，并在软件开发、运营和维护的每个阶段都牢记安全性。我们每天生产的大部分软件都意味着以某种方式与其他现有系统连接。
- en: By omitting security measures, we open up not only ourselves but also our partners
    to potential attacks, data leaks, and, eventually, lawsuits. Keep in mind that
    failure to protect personal data can result in a fine of several million US dollars.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过省略安全措施，我们不仅使自己暴露于潜在的攻击、数据泄漏和最终诉讼的风险中，还使我们的合作伙伴暴露于潜在的攻击、数据泄漏和最终诉讼的风险中。请记住，未能保护个人数据可能会导致数百万美元的罚款。
- en: Security-conscious design
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注重安全的设计
- en: How can we design an architecture for security? The best way to do this is to
    think like a potential attacker. There are many ways in which you can break a
    box open but usually, you will look for the cracks where different elements connect.
    (In the case of a box, this may be between the lid and the bottom of the box.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为安全性设计架构？这样做的最佳方式是像潜在的攻击者一样思考。有许多方法可以打开一个盒子，但通常，您会寻找不同元素连接的裂缝。（在盒子的情况下，这可能是盒子的盖子和底部之间。）
- en: In software architecture, connections between elements are called interfaces.
    Since their main role is to interact with the external world, they are the most
    vulnerable part of the entire system. Making sure your interfaces are protected,
    intuitive, and robust will solve the most obvious ways in which your software
    can be broken.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件架构中，元素之间的连接称为接口。由于它们的主要作用是与外部世界进行交互，它们是整个系统中最容易受到攻击的部分。确保您的接口受到保护、直观和稳健将解决软件可能被破坏的最明显的方式。
- en: Making interfaces easy to use and hard to misuse
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使接口易于使用且难以滥用
- en: To design interfaces in a way that would be both easy to use and hard to misuse,
    consider the following exercise. Imagine you are a customer of your interface.
    You want to implement an e-commerce store that uses your payment gateway, or maybe
    you want to implement a VR application that connects with the Customer API of
    the example system we've used throughout this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计接口既易于使用又难以滥用，考虑以下练习。想象一下你是接口的客户。您希望实现一个使用您的支付网关的电子商务商店，或者您希望实现一个连接本书中始终使用的示例系统的客户API的VR应用程序。
- en: 'As a general rule regarding interface design, avoid the following traits:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为关于接口设计的一般规则，避免以下特征：
- en: Too many parameters passed to the function/method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数/方法的参数太多
- en: Ambiguous names of parameters
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名称模糊
- en: Using output parameters
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输出参数
- en: Parameters depending on other parameters
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数取决于其他参数
- en: Why are these traits considered problematic?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些特征被认为是有问题的？
- en: The first one makes it hard to memorize not only the meaning but also the order
    of the parameters. This can lead to errors in usage, which, in turn, may lead
    to crashes and security issues.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个特征不仅使参数的含义难以记忆，而且使参数的顺序也难以记忆。这可能导致使用错误，进而可能导致崩溃和安全问题。
- en: The second trait has similar consequences to the first one. By making it less
    intuitive to use your interface, you make it easier for the user to make mistakes.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个特征与第一个特征有类似的后果。通过使接口使用起来不太直观，您使用户更容易犯错误。
- en: The third trait is a variant of the second one but with an added twist. Not
    only does the user have to remember which parameters are input and which are output,
    but it is also necessary for the user to remember how the output should be treated.
    Who manages the creation and deletion of the resources? How is this achieved?
    What is the memory management model behind it?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个特征是第二个特征的一个变体，但有一个额外的转折。用户不仅需要记住哪些参数是输入，哪些是输出，还需要记住如何处理输出。谁管理资源的创建和删除？这是如何实现的？背后的内存管理模型是什么？
- en: With modern C++, it's easier than ever to return a value that contains all of
    the necessary data. With pairs, tuples, and vectors, there is no excuse to use
    the output parameters. Besides all of this, returning the value helps embrace
    the practice of not modifying the state of an object. This, in turn, reduces concurrency-related
    problems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代C++，返回包含所有必要数据的值比以往任何时候都更容易。通过对成对、元组和向量的使用，没有理由使用输出参数。此外，返回值有助于接受不修改对象状态的做法。这反过来又减少了与并发相关的问题。
- en: Finally, the last trait introduces unnecessary cognitive load, which, as in
    the previous examples, can result in mistakes and eventually failures. Such code
    is also harder to test and maintain as each change introduced has to take into
    account all the possible combinations already available. Failure to properly handle
    any combination is a potential threat to the system.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个特征引入了不必要的认知负荷，就像前面的例子一样，可能导致错误，最终导致失败。这样的代码也更难测试和维护，因为每次引入的更改都必须考虑到已经存在的所有可能的组合。未能正确处理任何组合都是对系统的潜在威胁。
- en: The preceding rules apply to the external part of the interfaces. You should
    also apply similar measures to the internal part by validating the inputs, making
    sure the values are correct and sensible and preventing unwanted use of the services
    the interface provides.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的前述规则适用于接口的外部部分。您还应该通过验证输入、确保值正确和合理，并防止接口提供的服务被不必要地使用来对内部部分应用类似的措施。
- en: Enabling automatic resource management
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用自动资源管理
- en: System instability may also result from memory leaks, data races, and deadlocks.
    All of these symptoms are manifestations of poor resource management. Even though
    resource management is a hard topic, there is a mechanism that can help you reduce
    the number of problems. One such mechanism is automatic resource management.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不稳定也可能是由于内存泄漏、数据竞争和死锁引起的。所有这些症状都是资源管理不善的表现。尽管资源管理是一个难题，但有一种机制可以帮助您减少问题的数量。这样的机制之一是自动资源管理。
- en: In this context, a resource is something you gain access to via the operating
    system and you have to make sure you use it correctly. This may mean using dynamically
    allocated memory, open files, sockets, processes, or threads. All of these require
    specific actions to be taken when you acquire them and when you release them.
    Some of them also require specific actions during their lifetime. Failure to release
    such resources at the right time leads to leaks. Since the resources are usually
    finite, in the long run, leaks will turn to unexpected behavior when no new resources
    can be created.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，资源是通过操作系统获得访问权限的东西，您必须确保正确使用它。这可能意味着使用动态分配的内存、打开文件、套接字、进程或线程。当您获取它们和释放它们时，所有这些都需要采取特定的操作。其中一些在其生命周期内还需要特定的操作。在正确的时间释放这些资源失败会导致泄漏。由于资源通常是有限的，从长远来看，泄漏将导致无法创建新资源时出现意外行为。
- en: Resource management is so important in C++ because, unlike many other high-level
    languages, there is no garbage collection in C++ and the software developers are
    responsible for the life cycle of the resources. Understanding this life cycle
    helps create secure and stable systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理在C++中非常重要，因为与许多其他高级语言不同，C++中没有垃圾回收，软件开发人员负责资源的生命周期。了解这种生命周期有助于创建安全稳定的系统。
- en: The most common idiom of resource management is **Resource Acquisition Is Initialization**
    (**RAII**). Although it originated in C++, it has also been used in other languages,
    such as Vala and Rust. This idiom uses the object's constructor and destructor
    to allocate and free up resources, respectively. This way, we can guarantee that
    the resource in use will be properly freed when the object that holds it goes
    out of scope.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理最常见的习惯用法是**资源获取即初始化**（**RAII**）。尽管它起源于C++，但它也被用于其他语言，如Vala和Rust。这种习惯用法使用对象的构造函数和析构函数来分配和释放资源。这样，我们可以保证在持有资源的对象超出范围时，资源将被正确释放。
- en: Some examples of using this idiom in the standard library are the `std::unique_ptr`
    and `std::shared_ptr` smart pointer types. Other examples include mutexes – `std::lock_guard`,
    `std::unique_lock`, and `std:shared_lock` – or files – `std::ifstream` and `std::ofstream`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中使用此习惯用法的一些示例是`std::unique_ptr`和`std::shared_ptr`智能指针类型。其他示例包括互斥锁-`std::lock_guard`、`std::unique_lock`和`std:shared_lock`-或文件-`std::ifstream`和`std::ofstream`。
- en: The **Guidelines Support Library** (**GSL**), which we'll discuss at length
    shortly, also implements a particularly useful guideline for automated resource
    management. By using the `gsl::finally()` function in our code, we create a `gsl::final_action()`
    object with some code attached to it. This code will be executed when the object's
    destructor is called. This means the code will be executed both upon a successful
    return from the function as well as when the stack unwinding happens during an
    exception.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**指南支持库**（**GSL**），我们将很快讨论，还实现了一项特别有用的自动资源管理指南。通过在我们的代码中使用`gsl::finally()`函数，我们创建了一个附有一些代码的`gsl::final_action()`对象。当对象的析构函数被调用时，这些代码将被执行。这意味着该代码将在成功从函数返回时执行，以及在发生异常期间进行堆栈展开时执行。'
- en: This approach shouldn't be used too often as it is generally a better idea to
    design your classes with RAII in mind. But if you're interfacing with a third-party
    module and you want to ensure the safety of your wrapper, `finally()` can help
    you get there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不应该经常使用，因为通常最好在设计类时考虑RAII。但如果您正在与第三方模块进行接口，并且希望确保包装器的安全性，`finally()`可以帮助您实现这一点。
- en: 'As an example, consider that we have a payment operator that allows only a
    single concurrent login per account. If we don''t want to block the user from
    making future payments, we should always log out as soon as we finish processing
    the transaction. This is not a problem when we are on a happy path and everything
    goes according to our design. But in the event of an exception, we also want to
    be safe and release the resource. Here''s how we could do it using `gsl::finally()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们有一个支付操作员，每个账户只允许一个并发登录。如果我们不想阻止用户进行未来的支付，我们应该在完成交易处理后立即注销。当一切按照我们的设计进行时，这并不是一个问题。但在发生异常时，我们也希望安全地释放资源。以下是我们可以使用`gsl::finally()`来实现的方式：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of what happens during the call to `payment::process()`, we can at
    least guarantee that we log the user out as soon as we go out of `processTransaction()`'s
    scope.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在调用`payment::process()`期间发生了什么，我们至少可以保证在退出`processTransaction()`的范围时注销用户。
- en: In short, using RAII makes you think more about the resource management during
    the class design phase while you have full control of the code and think less
    about when you (or other parties) use the interface when your intentions may no
    longer be as clear.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用RAII使您在类设计阶段更多地考虑资源管理，同时在您完全控制代码并且在您使用接口时不再那么清晰时，您不再那么考虑。
- en: Drawbacks of concurrency and how to deal with it
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发的缺点及如何处理
- en: While concurrency improves performance and resource utilization, it also makes
    your code much harder to design and debug. This is because, unlike in a single-threaded
    flow, the timing of operations cannot be determined upfront. In single-threaded
    code, you either write to the resource or read from it, but you always know the
    order of the operations and can, therefore, predict the state of the object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并发可以提高性能和资源利用率，但也使您的代码更难设计和调试。这是因为，与单线程流程不同，操作的时间无法提前确定。在单线程代码中，您要么写入资源，要么从中读取，但您总是知道操作的顺序，因此可以预测对象的状态。
- en: 'With concurrency, several threads or processes can be either reading from an
    object or modifying it at the same time. If the modifications aren''t atomic,
    we can reach one of the variants of the common update problem. Consider the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 并发时，多个线程或进程可以同时从对象中读取或修改。如果修改不是原子的，我们可能会遇到常见更新问题的变体之一。考虑以下代码：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When calling the `chargeTheAccount` function from a non-concurrent code, everything
    will end up well. Our program will check the account balance and charge it if
    possible. The concurrent execution, however, can lead to a negative balance. This
    is because two threads can one after another call `getAccountBalance()`, which
    will return the same amount, such as `20`. After performing that call, both threads
    check whether the current balance is higher than the available amount. Finally,
    after the check, they modify the account balance. Supposing both transactions
    are for the amount of `10`, each thread will set the balance to be 20 – 10 = 10\.
    After *both* operations, the account has a balance of 10, even though it should
    be 0!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`chargeTheAccount`函数时，从非并发代码中，一切都会顺利进行。我们的程序将检查账户余额，并在可能的情况下进行扣款。然而，并发执行可能会导致负余额。这是因为两个线程可以依次调用`getAccountBalance()`，它将返回相同的金额，比如`20`。在执行完该调用后，两个线程都会检查当前余额是否高于可用金额。最后，在检查后，它们修改账户余额。假设两个交易金额都为`10`，每个线程都会将余额设置为20-10=10。在*两个*操作之后，账户的余额为10，尽管它应该是0！
- en: To mitigate a similar class of problems, we can use solutions such as mutexes
    and critical sections, atomic operations provided by CPU, or concurrency-safe
    data structures.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻类似问题，我们可以使用诸如互斥锁和临界区、CPU提供的原子操作或并发安全数据结构等解决方案。
- en: Mutexes, critical sections, and other similar concurrency design patterns prevent
    more than one thread from modifying (or reading) the data. Even though they are
    useful when designing concurrent applications, there is a trade-off associated
    with them. They effectively make parts of your code single-threaded. This is because
    code guarded by mutexes allows only a single thread to execute it; all of the
    others have to wait until the mutex is released. And since we introduce waiting,
    we can make our code less performant even though our original aim was to make
    it more performant.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁、临界区和其他类似的并发设计模式可以防止多个线程修改（或读取）数据。尽管它们在设计并发应用程序时很有用，但与之相关的是一种权衡。它们有效地使您的代码的某些部分变成单线程。这是因为由互斥锁保护的代码只允许一个线程执行；其他所有线程都必须等待，直到互斥锁被释放。由于我们引入了等待，即使我们最初的目标是使代码更具性能，我们也可能使代码的性能下降。
- en: Atomic operations mean using a single CPU instruction to get the desired effect.
    The term can mean any high-level operation that transforms into a single CPU instruction.
    They are particularly interesting when that single instruction achieves *more*
    than would be normally possible. For example, **compare-and-swap** (**CAS**) is
    an instruction that compares the memory location with a given value and modifies
    the contents of this location to the new value only if the comparison proved successful.
    Since C++11, there's a `<std::atomic>` header available that contains several
    atomic data types and operations. CAS, for instance, is implemented as a `compare_and_exchange_*`
    set of functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作意味着使用单个CPU指令来获得期望的效果。这个术语可以指任何将高级操作转换为单个CPU指令的操作。当单个指令实现的效果*超出*通常可能的范围时，它们特别有趣。例如，**比较和交换**（**CAS**）是一种指令，它将内存位置与给定值进行比较，并仅在比较成功时将该位置的内容修改为新值。自C++11以来，有一个`<std::atomic>`头文件可用，其中包含几种原子数据类型和操作。例如，CAS被实现为一组`compare_and_exchange_*`函数。
- en: Finally, concurrency-safe data structures (also known as concurrent data structures)
    provide safe abstractions for data structures that would otherwise require some
    sort of synchronization. For example, the Boost.Lockfree ([https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html](https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html))
    library provides concurrent queues and stacks for use with multiple producers
    and multiple consumers. libcds ([https://github.com/khizmax/libcds](https://github.com/khizmax/libcds))
    also offers ordered lists, sets, and maps, but it hasn't been updated in a few
    years as of the time of writing this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并发安全的数据结构（也称为并发数据结构）为数据结构提供了安全的抽象，否则这些数据结构将需要某种形式的同步。例如，Boost.Lockfree（[https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html](https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html)）库提供了用于多个生产者和多个消费者的并发队列和栈。libcds（[https://github.com/khizmax/libcds](https://github.com/khizmax/libcds)）还提供了有序列表、集合和映射，但截至撰写本书时，已经有几年没有更新了。
- en: 'Useful rules to keep in mind when designing concurrent processing are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计并发处理时要牢记的有用规则如下：
- en: Consider whether you need concurrency in the first place.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先考虑是否需要并发。
- en: Pass data by value rather than by pointer or reference. This prevents modifications
    of the value when other threads are reading it.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递数据，而不是通过指针或引用。这可以防止其他线程在读取数据时修改该值。
- en: If the size of the data makes it impractical to share by value, use `shared_ptr`.
    This way, it's easier to avoid resource leaks.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据的大小使得按值共享变得不切实际，可以使用`shared_ptr`。这样，更容易避免资源泄漏。
- en: Secure coding, the guidelines, and GSL
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全编码、指南和GSL
- en: The Standard C++ Foundation released a set of guidelines to document the best
    practices for building C++ systems. It is a Markdown document released on GitHub
    under [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
    It is an evolving document without a release schedule (unlike the C++ standard
    itself). The guidelines are aimed at modern C++, which basically means code bases
    that implement at least C++11 features.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++基金会发布了一套指南，记录了构建C++系统的最佳实践。这是一个在GitHub上发布的Markdown文档，网址为[https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)。这是一个不断发展的文档，没有发布计划（不像C++标准本身）。这些指南针对的是现代C++，基本上意味着实现了至少C++11特性的代码库。
- en: Many of the rules presented in the guidelines cover the topics that we present
    in this chapter. For example, there are rules related to interface design, resource
    management, and concurrency. The editors of the guidelines are Bjarne Stroustrup
    and Herb Sutter, both respected members of the C++ community.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 指南中提出的许多规则涵盖了我们在本章中介绍的主题。例如，有关接口设计、资源管理和并发的规则。指南的编辑是Bjarne Stroustrup和Herb Sutter，他们都是C++社区中受尊敬的成员。
- en: We won't go into detail describing the guidelines. We encourage you to read
    them yourself. This book is inspired by many of the rules presented there and
    we follow them in our examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细描述这些指南。我们鼓励您自己阅读。本书受到其中许多规则的启发，并在我们的示例中遵循这些规则。
- en: To ease the use of these rules in various code bases, Microsoft released the
    **Guidelines Support Library** (**GSL**) as an open source project hosted on [https://github.com/microsoft/GSL](https://github.com/microsoft/GSL).
    It is a header-only library that you can include in your project to use the defined
    types. You can either include the whole GSL or selectively use only some of the
    types you plan on using.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在各种代码库中使用这些规则，微软发布了**指南支持库**（**GSL**）作为一个开源项目，托管在[https://github.com/microsoft/GSL](https://github.com/microsoft/GSL)上。这是一个仅包含头文件的库，您可以将其包含在项目中以使用定义的类型。您可以包含整个GSL，也可以选择性地仅使用您计划使用的一些类型。
- en: What's also interesting about the library is the fact that it uses CMake for
    building, Travis for continuous integration, and Catch for unit testing. It is,
    therefore, a good example of the topics we've covered in [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml),
    *Building and Packaging*, and [Chapter 8](160259bc-b601-4854-9aa9-cabe2c4fd691.xhtml),
    *Writing Testable Code*, and [Chapter 9](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml),
    *Continuous Integration and Continuous Deployment*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该库的另一个有趣之处在于它使用CMake进行构建，Travis进行持续集成，以及Catch进行单元测试。因此，它是我们在[第7章](7f997c01-2634-4584-be95-0b068f448312.xhtml)、*构建和打包*，[第8章](160259bc-b601-4854-9aa9-cabe2c4fd691.xhtml)、*可测试代码编写*和[第9章](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml)、*持续集成和持续部署*中涵盖的主题的一个很好的例子。
- en: Defensive coding, validating everything
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御性编码，验证一切
- en: In a previous chapter on testability, we mentioned the method of defensive programming.
    Even though this method is not strictly a security feature, it happens to help
    with creating a robust interface. Such interfaces, in turn, increase the overall
    security of your system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们提到了防御性编程的方法。尽管这种方法并不严格属于安全功能，但它确实有助于创建健壮的接口。这样的接口反过来又增加了系统的整体安全性。
- en: 'As a good heuristic, you can treat all the external data as unsafe. What we
    mean by external data is every input coming to the system via some interface (either
    a programming interface or user interface). To denote this, you can go as far
    as prefixing the appropriate types as `Unsafe`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个很好的启发式方法，您可以将所有外部数据视为不安全。我们所说的外部数据是通过某个接口（编程接口或用户界面）进入系统的每个输入。为了表示这一点，您可以在适当的类型前加上`Unsafe`前缀，如下所示：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have already read the guidelines, you will know that you should generally
    avoid using the C API directly. Some of the functions in the C API can be used
    in an unsafe way and require special care to use them defensively. It is much
    better to instead use respective concepts from C++ that ensure better type safety
    as well as protection (for example, against buffer overflow).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了指南，您将知道通常应避免直接使用C API。C API中的一些函数可能以不安全的方式使用，并需要特别小心地防御性使用它们。最好使用C++中相应的概念，以确保更好的类型安全性和保护（例如，防止缓冲区溢出）。
- en: Another facet of defensive programming is the intelligent reuse of the existing
    code. Each time you try to implement some technique, ensure nobody else has implemented
    it before you. Writing a sorting algorithm yourself may be a fun challenge to
    do when you're learning a new programming language, but for production code, it's
    much better to use the sorting algorithms available in the standard library. The
    same goes for password hashing. No doubt you can find some clever way to calculate
    the password hashes and store them in a database but it is generally wiser to
    go with the tried and true (and don't forget peer-reviewed!) `bcrypt`. Keep in
    mind that intelligent code reuse assumes you check and audit the third-party solutions
    with the same due diligence as you would your own code. We will dive deeper into
    this topic in the next section, *Are my dependencies secure?*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程的另一个方面是智能地重用现有代码。每次尝试实现某种技术时，请确保没有其他人在您之前实现过它。当您学习一种新的编程语言时，自己编写排序算法可能是一种有趣的挑战，但对于生产代码，最好使用标准库中提供的排序算法。对于密码哈希也是一样。毫无疑问，您可以找到一些聪明的方法来计算密码哈希并将其存储在数据库中，但通常更明智的做法是使用经过验证的`bcrypt`。请记住，智能的代码重用假设您以与您自己的代码一样的尽职调查检查和审计第三方解决方案。我们将在下一节“我的依赖项安全吗？”中深入探讨这个话题。
- en: It's worth noting that defensive programming shouldn't turn into paranoid programming.
    Checking user input is a sane thing to do, while asserting whether an initialized
    variable is still equal to the original value just after the initialization is
    going too far. You want to control the integrity of your data and algorithms and
    the integrity of third-party solutions. You don't want to verify the correctness
    of your compiler by embracing language features.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，防御性编程不应该变成偏执的编程。检查用户输入是明智的做法，而在初始化变量后立即断言初始化变量是否仍然等于原始值则有些过分。您希望控制数据和算法的完整性以及第三方解决方案的完整性。您不希望通过采用语言特性来验证编译器的正确性。
- en: In short, it's a good idea from both a security and readability point of view
    to use `Expects()` and `Ensures()` as presented in C++ Core Guidelines and to
    distinguish between unsafe and safe data through typing and conversions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从安全性和可读性的角度来看，使用C++核心指南中提出的`Expects()`和`Ensures()`以及通过类型和转换区分不安全和安全数据是一个好主意。
- en: The most common vulnerabilities
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最常见的漏洞
- en: 'To check whether your code is safe against the most common vulnerabilities,
    you should first learn about the said vulnerabilities. After all, a defense is
    only possible when you know what the offense looks like. The **Open Web Application
    Security Project** (**OWASP**) has cataloged the most common vulnerabilities and
    has published them at [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project).
    At the moment of writing this book, those vulnerabilities are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的代码是否安全防范最常见的漏洞，您应首先了解这些漏洞。毕竟，只有当您知道攻击是什么样子时，防御才有可能。**开放式网络应用安全项目**（**OWASP**）已经对最常见的漏洞进行了分类，并在[https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)上发布了它们。在撰写本书时，这些漏洞如下：
- en: '**Injection**: Commonly known as SQL injection. It is not limited to SQL; this
    vulnerability occurs when untrusted data is passed directly to an interpreter
    (such as a SQL database, NoSQL database, shell, or eval function). The attacker
    may this way gain access to parts of the system that should be protected.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入：通常称为SQL注入。这不仅限于SQL；当不受信任的数据直接传递给解释器（如SQL数据库、NoSQL数据库、shell或eval函数）时，就会出现这种漏洞。攻击者可能以这种方式访问应该受到保护的系统部分。
- en: '**Broken Authentication**: If authentication is improperly implemented, attackers
    may use flaws to either compromise secret data or impersonate other users.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏的身份验证**：如果身份验证实施不当，攻击者可能利用漏洞来获取秘密数据或冒充其他用户。'
- en: '**Sensitive Data Exposure**: The lack of encryption and proper access rights
    may lead to sensitive data being exposed publicly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏感数据暴露**：缺乏加密和适当的访问权限可能导致敏感数据被公开。'
- en: '**XML External Entities** (**XXE**): Some XML processors may disclose the contents
    of the server''s filesystem or allow remote code execution.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML外部实体**（**XXE**）：一些XML处理器可能会泄露服务器文件系统的内容或允许远程代码执行。'
- en: '**Broken Access Control**: When access control is not enforced properly, attackers
    may gain access to files or data that should be restricted.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏的访问控制**：当访问控制未正确执行时，攻击者可能会访问应受限制的文件或数据。'
- en: '**Security Misconfiguration**: Using insecure defaults and improper care with
    configuration are the most common sources of vulnerabilities.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全配置错误**：使用不安全的默认值和不正确的配置是最常见的漏洞来源。'
- en: '**Cross-Site Scripting** (**XSS**): Including and executing untrusted external
    data, especially with JavaScript, that allows control of the user''s web browser.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**（**XSS**）：包括并执行不受信任的外部数据，特别是使用JavaScript，这允许控制用户的网络浏览器。'
- en: '**Insecure Deserialization**: Some flawed parsers may fall prey to denial of
    services attacks or remote code execution.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的反序列化**：一些有缺陷的解析器可能会成为拒绝服务攻击或远程代码执行的牺牲品。'
- en: '**Using Components with Known Vulnerabilities**: A lot of the code in modern
    applications comes as third-party components. These components should be regularly
    audited and updated as known security flaws in a single dependency can result
    in your entire application and data being compromised. Fortunately, there are
    tools that help automate this.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用已知漏洞的组件**：现代应用程序中的许多代码都是第三方组件。这些组件应该定期进行审计和更新，因为单个依赖中已知的安全漏洞可能导致整个应用程序和数据被攻击。幸运的是，有一些工具可以帮助自动化这一过程。'
- en: '**Insufficient Logging & Monitoring**: If your system is under attack and your
    logging and monitoring is not very thorough, the attacker may obtain deeper access
    and still become unnoticed.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和监控不足**：如果你的系统受到攻击，而你的日志和监控不够彻底，攻击者可能会获得更深入的访问权限，而你却没有察觉。'
- en: We won't go into detail regarding each of the mentioned vulnerabilities. What
    we want to highlight here is that you can prevent injection, XML external entities,
    and insecure deserialization by following the defensive programing techniques
    we mentioned before. By treating all external data as unsafe, you can first sanitize
    it by removing all the unsafe content before you start the actual processing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍每个提到的漏洞。我们想要强调的是，通过将所有外部数据视为不安全，你可以首先通过删除所有不安全的内容来对其进行净化，然后再开始实际处理。
- en: When it comes to insufficient logging and monitoring, we will go into detail
    in [Chapter 15](27377621-3532-4513-8045-caa00285fdda.xhtml), *Cloud-Native Design*.
    There we will present some possible approaches to observability, including logging,
    monitoring, and distributed tracing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到日志和监控不足时，我们将在[第15章](27377621-3532-4513-8045-caa00285fdda.xhtml)中详细介绍*云原生设计*。在那里，我们将介绍一些可能的可观察性方法，包括日志记录、监控和分布式跟踪。
- en: Checking whether the dependencies are secure
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查依赖是否安全
- en: 'In the early days of computers, all programs were monoliths without any external
    dependencies. Ever since the dawn of operating systems, any non-trivial software
    is rarely free from dependencies. Those dependencies can come in two forms: external
    dependencies and internal ones:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机早期，所有程序都是单体结构，没有任何外部依赖。自操作系统诞生以来，任何非平凡的软件很少能摆脱依赖。这些依赖可以分为两种形式：外部依赖和内部依赖。
- en: External dependencies are those that should be present in the environment that
    we run our application. Examples can include the aforementioned operating systems,
    dynamically linked libraries, and other applications (such as a database).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖是我们运行应用程序时应该存在的环境。例如，前面提到的操作系统、动态链接库和其他应用程序（如数据库）。
- en: Internal dependencies are modules we want to reuse, so this will usually mean
    static libraries or header-only libraries.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部依赖是我们想要重用的模块，因此通常是静态库或仅包含头文件的库。
- en: Both kinds of dependencies provide potential security risks. As each line of
    code increases the risk of vulnerability, the more components you have, the higher
    the chance your system may be susceptible to attack. In the following sections,
    we'll see how to check whether your software is indeed susceptible to known vulnerabilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两种依赖都提供潜在的安全风险。随着每一行代码增加漏洞的风险，你拥有的组件越多，你的系统可能受到攻击的机会就越高。在接下来的章节中，我们将看到如何检查你的软件是否确实容易受到已知的漏洞攻击。
- en: Common Vulnerabilities and Exposures
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用漏洞和暴露
- en: The first place to check for known security issues within software is the **Common
    Vulnerabilities and Exposures** (**CVE**) list available at [https://cve.mitre.org/](https://cve.mitre.org/).
    The list is constantly updated by several institutions known as **CVE Numbering
    Authorities** (**CNAs**). These institutions include vendors and projects, vulnerability
    researchers, national and industry CERTs, and bug bounty programs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 检查软件中已知的安全问题的第一个地方是**通用漏洞和暴露**（**CVE**）列表，可在[https://cve.mitre.org/](https://cve.mitre.org/)上找到。该列表由几个被称为**CVE编号机构**（**CNAs**）的机构不断更新。这些机构包括供应商和项目、漏洞研究人员、国家和行业CERT以及漏洞赏金计划。
- en: 'The website also presents a search engine. With this, you can use several methods
    to learn about the vulnerabilities:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站还提供了一个搜索引擎。通过这个，你可以使用几种方法了解漏洞：
- en: You can enter the vulnerability number. These are prefixed by `CVE` with examples
    including CVE-2014-6271, the infamous ShellShock, or CVE-2017-5715, also known
    as Spectre).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以输入漏洞编号。这些编号以`CVE`为前缀，例如CVE-2014-6271，臭名昭著的ShellShock，或者CVE-2017-5715，也被称为Spectre。
- en: You can enter the vulnerability common name, such as the previously mentioned
    ShellShock or Spectre.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以输入漏洞的通用名称，比如前面提到的ShellShock或Spectre。
- en: You can enter the name of the software you want to audit, such as Bash or Boost.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以输入你想审计的软件名称，比如Bash或Boost。
- en: For each search result, you can see the description as well as a list of references
    to other bug trackers and related resources. The description usually lists versions
    affected by the vulnerability, so you can check whether the dependency you are
    planning to use has been already patched.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个搜索结果，你可以看到描述以及其他bug跟踪器和相关资源的参考列表。描述通常列出受漏洞影响的版本，因此你可以检查你计划使用的依赖是否已经修补。
- en: Automated scanners
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化扫描器
- en: There are tools that can help you to audit your list of dependencies. One such
    tool is OWASP Dependency-Check ([https://www.owasp.org/index.php/OWASP_Dependency_Check](https://www.owasp.org/index.php/OWASP_Dependency_Check)).
    Although it only supports Java and .NET officially, it has experimental support
    for Python, Ruby, Node.js, and C++ (when used with CMake or `autoconf`). Besides
    working as a standalone tool, it has integrations for **Continuous Integration/Continuous**
    **Deployment** (**CI/CD**) software such as Jenkins, SonarQube, and CircleCI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助您审计依赖项列表。其中一个工具是OWASP Dependency-Check ([https://www.owasp.org/index.php/OWASP_Dependency_Check](https://www.owasp.org/index.php/OWASP_Dependency_Check))。尽管它只正式支持Java和.NET，但它对Python、Ruby、Node.js和C++（与CMake或`autoconf`一起使用时）有实验性支持。除了作为独立工具使用外，它还可以与Jenkins、SonarQube和CircleCI等**持续集成/持续部署**（**CI/CD**）软件集成。
- en: Another tool that allows checking dependencies for known vulnerabilities is
    Snyk. This is a commercial product with several levels of support. It also does
    more than the OWASP Dependency-Check as Snyk can also audit container images and
    license compliance issues. It also offers more integrations with third-party solutions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个允许检查已知漏洞的依赖项的工具是Snyk。这是一个商业产品，有几个支持级别。与OWASP Dependency-Check相比，它还可以执行更多操作，因为Snyk还可以审计容器映像和许可合规性问题。它还提供了更多与第三方解决方案的集成。
- en: Automated dependency upgrade management
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化依赖项升级管理
- en: Monitoring your dependencies for vulnerabilities is only the first step in making
    sure your project is secure. After that, you need to take action and update the
    compromised dependencies manually. As you might have expected, there are also
    automated solutions just for that. One of them is Dependabot, which scans your
    source code repository and issues a pull request whenever there's a security-related
    update available. At the moment of writing this book, Dependabot does not support
    C++ yet. It can, however, be used with other languages that your application may
    use. Other than that, it can scan Docker containers for vulnerabilities found
    in base images.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 监视依赖项的漏洞只是确保项目安全的第一步。之后，您需要采取行动并手动更新受损的依赖项。正如您可能已经预料到的那样，也有专门的自动化解决方案。其中之一是Dependabot，它会扫描您的源代码存储库，并在有安全相关更新可用时发布拉取请求。在撰写本书时，Dependabot尚不支持C++。但是，它可以与您的应用程序可能使用的其他语言一起使用。除此之外，它还可以扫描Docker容器，查找基础映像中发现的漏洞。
- en: Automated dependency management requires mature test support. Switching dependency
    versions without tests may lead to instabilities and bugs. One protection against
    problems related to dependency upgrades is using wrappers to interface with third-party
    code. Such wrappers may have their own suite of tests that instantly tells us
    when an interface is broken during an upgrade.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化依赖项管理需要成熟的测试支持。在没有测试的情况下切换依赖项版本可能会导致不稳定和错误。防止与依赖项升级相关的问题的一种保护措施是使用包装器与第三方代码进行接口。这样的包装器可能有自己的一套测试，可以在升级期间立即告诉我们接口何时被破坏。
- en: Hardening your code
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固您的代码
- en: You can reduce the number of common security vulnerabilities in your own code
    by using modern C++ constructions as opposed to older C equivalents. Yet, there
    are always cases when even more secure abstractions prove to be vulnerable as
    well. It is not enough to choose the more secure implementation and decide you've
    done your best. Most of the time, there are ways to further harden your code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用现代C++构造而不是较旧的C等效构造，可以减少自己代码中常见的安全漏洞数量。然而，即使更安全的抽象也可能存在漏洞。仅仅选择更安全的实现并认为自己已经尽了最大努力是不够的。大多数情况下，都有方法可以进一步加固您的代码。
- en: But what is code hardening? According to the definition, it is the process of
    reducing the system's surface of vulnerability. Often, this means turning off
    the features you won't be using and aiming for a simpler system over a complicated
    one. It may also mean using tools to increase the robustness of the already-available
    functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么是代码加固？根据定义，这是减少系统漏洞表面的过程。通常，这意味着关闭您不会使用的功能，并追求一个简单的系统而不是一个复杂的系统。这也可能意味着使用工具来增加已有功能的健壮性。
- en: Such tools may mean kernel patches, firewalls, and **Intrusion Detection Systems**
    (**IDSes**) when applied at the operating system level. At the application level,
    it may mean various buffer overrun and underflow protection mechanisms, using
    containers and **Virtual Machines** (**VMs**) for privilege separation and process
    isolation, or enforcing encrypted communication and storage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可能意味着在操作系统级别应用内核补丁、防火墙和**入侵检测系统**（**IDSes**）。在应用程序级别，这可能意味着使用各种缓冲区溢出和下溢保护机制，使用容器和**虚拟机**（**VMs**）进行特权分离和进程隔离，或者强制执行加密通信和存储。
- en: In this section, we'll focus on some examples from the application level, while
    the next section will focus on the operating system level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍应用程序级别的一些示例，而下一节将重点介绍操作系统级别。
- en: Security-oriented memory allocator
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向安全的内存分配器
- en: 'If you are serious about protecting your application from heap-related attacks,
    such as heap overflow, use-after-free, or double free, you may consider replacing
    your standard memory allocator with a security-oriented version. Two projects
    that may be of interest are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认真保护应用程序免受与堆相关的攻击，例如堆溢出、释放后使用或双重释放，您可能会考虑用面向安全的版本替换标准内存分配器。可能感兴趣的两个项目如下：
- en: FreeGuard, available at [https://github.com/UTSASRG/FreeGuard](https://github.com/UTSASRG/FreeGuard)
    and described in a paper at [https://arxiv.org/abs/1709.02746](https://arxiv.org/abs/1709.02746)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeGuard，可在[https://github.com/UTSASRG/FreeGuard](https://github.com/UTSASRG/FreeGuard)上找到，并在[https://arxiv.org/abs/1709.02746](https://arxiv.org/abs/1709.02746)的论文中描述
- en: '`hardened_malloc` from the GrapheneOS project, available at [https://github.com/GrapheneOS/hardened_malloc](https://github.com/GrapheneOS/hardened_malloc)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GrapheneOS项目的`hardened_malloc`，可在[https://github.com/GrapheneOS/hardened_malloc](https://github.com/GrapheneOS/hardened_malloc)上找到
- en: FreeGuard was released in 2017 and it hasn't seen much change since then other
    than sporadic bug fixes. `hardened_malloc`, on the other hand, is actively developed.
    Both allocators are designed to act as drop-in replacements for the standard `malloc()`.
    You can use them without modifying your application simply by setting the `LD_PRELOAD`
    environment variable or adding the library to the `/etc/preload.so` configuration
    file. While FreeGuard targets Linux with the Clang compiler on 64-bit x86 systems,
    `hardened_malloc` aims at broader compatibility, though at the moment supports
    mostly Android's Bionic, `musl`, and `glibc`. `hardened_malloc` is also based
    on OpenBSD's `alloc`, with OpenBSD being the security-focused project itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FreeGuard于2017年发布，自那时以来除了零星的错误修复外，没有太多变化。另一方面，`hardened_malloc`正在积极开发。这两个分配器都旨在作为标准`malloc()`的替代品。您可以通过设置`LD_PRELOAD`环境变量或将库添加到`/etc/preload.so`配置文件中，而无需修改应用程序即可使用它们。虽然FreeGuard针对的是64位x86系统上的Linux与Clang编译器，`hardened_malloc`旨在更广泛的兼容性，尽管目前主要支持Android的Bionic，`musl`和`glibc`。`hardened_malloc`也基于OpenBSD的`alloc`，而OpenBSD本身是一个以安全为重点的项目。
- en: Instead of replacing the memory allocator, you can replace the collections you
    use for their safer equivalents. The SaferCPlusPlus ([https://duneroadrunner.github.io/SaferCPlusPlus/](https://duneroadrunner.github.io/SaferCPlusPlus/))
    project provides substitutes for `std::vector<>`, `std::array<>`, and `std::string`
    that can be used as drop-in replacements in the existing code. The project also
    includes substitutes for basic types that guard against uninitialized use or sign
    mismatch, concurrent data types, and replacements for pointers and references.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不要替换内存分配器，可以替换你用于更安全的集合。 SaferCPlusPlus（[https://duneroadrunner.github.io/SaferCPlusPlus/](https://duneroadrunner.github.io/SaferCPlusPlus/)）项目提供了`std::vector<>`，`std::array<>`和`std::string`的替代品，可以作为现有代码中的替代品。该项目还包括用于保护未初始化使用或符号不匹配的基本类型的替代品，并发数据类型的替代品，以及指针和引用的替代品。
- en: Automated checks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化检查
- en: There are tools that can be especially helpful to ensure the security of the
    system you are building. We will cover them in the following section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以特别有助于确保正在构建的系统的安全。我们将在下一节中介绍它们。
- en: Compiler warnings
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器警告
- en: 'While not necessarily a tool in itself, compiler warnings can be used and tweaked
    to achieve even better output from the one tool every C++ developer will be using:
    the C++ compiler.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译器警告本身不一定是一个工具，但可以使用和调整编译器警告，以实现更好的输出，从而使每个C++开发人员都将使用的C++编译器获得更好的输出。
- en: Since the compiler can already do some deeper checks than those required by
    the standard, it is advised to take advantage of this possibility. When using
    a compiler such as GCC or Clang, the recommended setting involves `-Wall -Wextra`
    flags. This will generate much more diagnostics and result in warnings when your
    code doesn't follow the diagnostics. If you want to be really strict, you can
    also enable `-Werror`, which will turn all the warnings into errors and prevent
    the compilation of code that doesn't pass the enhanced diagnostics. If you want
    to keep strictly to the standards, there are the `-pedantic` and `-pedantic-errors`
    flags that will look for conformance against the standards.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器已经可以进行一些比标准要求更深入的检查，建议利用这种可能性。当使用诸如GCC或Clang之类的编译器时，推荐的设置包括`-Wall -Wextra`标志。这将生成更多的诊断，并在代码不遵循诊断时产生警告。如果您想要非常严格，还可以启用`-Werror`，这将把所有警告转换为错误，并阻止不能通过增强诊断的代码的编译。如果您想严格遵循标准，还有`-pedantic`和`-pedantic-errors`标志，将检查是否符合标准。
- en: 'When using CMake for building, you can use the following function to enable
    these flags during compilation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CMake进行构建时，您可以使用以下函数在编译期间启用这些标志：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, the compilation will fail unless you fix all the warnings (turned
    errors) reported by the compiler.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，除非您修复编译器报告的所有警告（转换为错误），否则编译将失败。
- en: You can also find suggested settings for toolchain hardening in these articles
    from OWASP ([https://www.owasp.org/index.php/C-Based_Toolchain_Hardening](https://www.owasp.org/index.php/C-Based_Toolchain_Hardening))
    and Red Hat ([https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/](https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在OWASP（[https://www.owasp.org/index.php/C-Based_Toolchain_Hardening](https://www.owasp.org/index.php/C-Based_Toolchain_Hardening)）和Red
    Hat（[https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/](https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/)）的文章中找到工具链加固的建议设置。
- en: Static analysis
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析
- en: One class of tools that can help with making your code more secure is the so-called
    **Static Application Security Testing** (**SAST**) tools. They are a variant of
    static analysis tools only focused on security aspects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一类可以帮助使您的代码更安全的工具是所谓的**静态应用安全测试**（**SAST**）工具。它们是专注于安全方面的静态分析工具的变体。
- en: SAST tools integrate well into CI/CD pipelines as they are simply reading your
    source code. The output is usually suitable for CI/CD as well since it highlights
    problems found in particular places in the source code. On the other hand, static
    analysis may omit many types of problems that cannot be found automatically or
    cannot be found solely with static analysis. These tools are also oblivious to
    issues related to configuration, as configuration files aren't represented in
    the source code itself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SAST工具很好地集成到CI/CD管道中，因为它们只是读取您的源代码。输出通常也适用于CI/CD，因为它突出显示了源代码中特定位置发现的问题。另一方面，静态分析可能会忽略许多类型的问题，这些问题无法自动发现，或者仅通过静态分析无法发现。这些工具也对与配置相关的问题视而不见，因为配置文件并未在源代码本身中表示。
- en: 'Examples of C++ SAST tools include the following open source solutions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C++ SAST工具的示例包括以下开源解决方案：
- en: Cppcheck ([http://cppcheck.sourceforge.net/](http://cppcheck.sourceforge.net/)),
    which is a general-purpose static analysis tool focused on the low number of false
    positives
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cppcheck（[http://cppcheck.sourceforge.net/](http://cppcheck.sourceforge.net/)）是一个通用的静态分析工具，专注于较少的误报。
- en: Flawfinder ([https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)),
    which doesn't seem to be actively maintained
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flawfinder（[https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)），似乎没有得到积极维护
- en: LGTM ([https://lgtm.com/help/lgtm/about-lgtm](https://lgtm.com/help/lgtm/about-lgtm)),
    supporting several different languages and featuring automated analysis of pull
    requests
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGTM（[https://lgtm.com/help/lgtm/about-lgtm](https://lgtm.com/help/lgtm/about-lgtm)），支持多种不同的语言，并具有对拉取请求的自动化分析功能
- en: SonarQube ([https://www.sonarqube.org/](https://www.sonarqube.org/)), which
    has great CI/CD integration and language coverage, and offers a commercial version
    as well
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube（[https://www.sonarqube.org/](https://www.sonarqube.org/)）具有出色的CI/CD集成和语言覆盖，并提供商业版本
- en: 'There are also commercial solutions available:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有商业解决方案可用：
- en: Checkmarx CxSAST ([https://www.checkmarx.com/products/static-application-security-testing/](https://www.checkmarx.com/products/static-application-security-testing/)),
    which promises zero configuration and road language coverage
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Checkmarx CxSAST（[https://www.checkmarx.com/products/static-application-security-testing/](https://www.checkmarx.com/products/static-application-security-testing/)），承诺零配置和广泛的语言覆盖
- en: CodeSonar ([https://www.grammatech.com/products/codesonar](https://www.grammatech.com/products/codesonar)),
    which focuses on in-depth analysis and finding the most flaws
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeSonar（[https://www.grammatech.com/products/codesonar](https://www.grammatech.com/products/codesonar)），专注于深度分析和发现最多的缺陷
- en: Klocwork ([https://www.perforce.com/products/klocwork](https://www.perforce.com/products/klocwork)),
    which focuses on accuracy
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Klocwork（[https://www.perforce.com/products/klocwork](https://www.perforce.com/products/klocwork)），专注于准确性
- en: Micro Focus Fortify ([https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)),
    with broad language support and integration of other tools by the same manufacturer
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro Focus Fortify（[https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)），支持广泛的语言并集成了同一制造商的其他工具
- en: Parasoft C/C++test ([https://www.parasoft.com/products/ctest](https://www.parasoft.com/products/ctest)),
    which is an integrated solution for static and dynamic analysis, unit testing,
    tracing, and more
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parasoft C/C++test（[https://www.parasoft.com/products/ctest](https://www.parasoft.com/products/ctest)），这是一个集成的静态和动态分析、单元测试、跟踪等解决方案
- en: Polyspace Bug Finder from MathWorks ([https://www.mathworks.com/products/polyspace-bug-finder.html](https://www.mathworks.com/products/polyspace-bug-finder.html)),
    with the integration of Simulink models
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MathWorks的Polyspace Bug Finder（[https://www.mathworks.com/products/polyspace-bug-finder.html](https://www.mathworks.com/products/polyspace-bug-finder.html)），集成了Simulink模型
- en: Veracode Static Analysis ([https://www.veracode.com/products/binary-static-analysis-sast](https://www.veracode.com/products/binary-static-analysis-sast)),
    which is a SaaS solution for static analysis
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Veracode静态分析（[https://www.veracode.com/products/binary-static-analysis-sast](https://www.veracode.com/products/binary-static-analysis-sast)），这是一个用于静态分析的SaaS解决方案
- en: WhiteHat Sentinel Source ([https://www.whitehatsec.com/platform/static-application-security-testing/](https://www.whitehatsec.com/platform/static-application-security-testing/)),
    which also focuses on eliminating false positives
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WhiteHat Sentinel Source（[https://www.whitehatsec.com/platform/static-application-security-testing/](https://www.whitehatsec.com/platform/static-application-security-testing/)），也专注于消除误报
- en: Dynamic analysis
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分析
- en: Just like static analysis is performed on the source code, dynamic analysis
    is performed on the resulting binaries. The "dynamic" in the name refers to the
    observation of the code in action processing the actual data. When focused on
    security, this class of tools can also be called **Dynamic Application Security
    Testing** (**DAST**).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态分析是在源代码上执行的一样，动态分析是在生成的二进制文件上执行的。名称中的“动态”指的是观察代码在处理实际数据时的行为。当专注于安全性时，这类工具也可以被称为**动态应用安全性测试**（**DAST**）。
- en: Their main advantage over their SAST counterparts is that they can find many
    flows that cannot be seen from the source code analysis point of view. This, of
    course, introduces the drawback that you have to run your application in order
    to perform the analysis. And as we know, running an application can be both time-
    and memory-consuming.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相对于SAST工具的主要优势在于，它们可以发现许多从源代码分析角度看不到的流程。当然，这也带来了一个缺点，即您必须运行应用程序才能进行分析。而且我们知道，运行应用程序可能既耗时又耗内存。
- en: DAST tools usually focus on web-related vulnerabilities such as XSS, SQL (and
    other) injection, or disclosed sensitive information. We will focus more on one
    of the more general-purpose dynamic analysis tools, Valgrind, in the next subsection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DAST工具通常专注于与Web相关的漏洞，如XSS、SQL（和其他）注入或泄露敏感信息。我们将在下一小节中更多地关注一个更通用的动态分析工具Valgrind。
- en: Valgrind and Application Verifier
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Valgrind和Application Verifier
- en: Valgrind is mostly known as a memory leak debugging tool. It is, in fact, an
    instrumentation framework that helps to build dynamic analysis tools not necessarily
    related to memory problems. Besides the memory error detector, the suite of tools
    currently consists of a thread error detector, a cache and branch prediction profiler,
    and a heap profiler. It's supported on various platforms on Unix-like operating
    systems (including Android).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind主要以内存泄漏调试工具而闻名。实际上，它是一个帮助构建与内存问题无关的动态分析工具的仪器框架。除了内存错误检测器外，该套工具目前还包括线程错误检测器、缓存和分支预测分析器以及堆分析器。它在类Unix操作系统（包括Android）上支持各种平台。
- en: Essentially, Valgrind acts as a VM, first translating the binary into a simpler
    form called intermediate representation. Instead of running the program on an
    actual processor, it gets executed under this VM so each call can be can be analyzed
    and validated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Valgrind充当虚拟机，首先将二进制文件转换为称为中间表示的简化形式。它不是在实际处理器上运行程序，而是在这个虚拟机下执行，以便分析和验证每个调用。
- en: If you're developing on Windows, you can use **Application Verifier** (**AppVerifier**)
    instead of Valgrind. AppVerifier can help you detect stability and security issues.
    It can monitor running applications and user-mode drivers to look for memory issues
    such as leaks and heap corruption, threading and locking issues, invalid use of
    handles, and more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上开发，可以使用**Application Verifier**（**AppVerifier**）代替Valgrind。AppVerifier可以帮助您检测稳定性和安全性问题。它可以监视运行中的应用程序和用户模式驱动程序，以查找内存问题，如泄漏和堆破坏，线程和锁定问题，句柄的无效使用等。
- en: Sanitizers
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消毒剂
- en: Sanitizers are dynamic testing tools that are based on compile-time instrumentation
    of code. They can help with the overall stability and security of the system,
    as well as avoiding undefined behavior. At [https://github.com/google/sanitizers](https://github.com/google/sanitizers),
    you can find implementations for LLVM (which Clang is based on) and GCC. They
    address problems with memory access, memory leaks, data races and deadlocks, uninitialized
    memory use, and undefined behavior.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 消毒剂是基于代码的编译时仪器的动态测试工具。它们可以帮助提高系统的整体稳定性和安全性，避免未定义的行为。在[https://github.com/google/sanitizers](https://github.com/google/sanitizers)，您可以找到LLVM（Clang基于此）和GCC的实现。它们解决了内存访问、内存泄漏、数据竞争和死锁、未初始化内存使用以及未定义行为的问题。
- en: '**AddressSanitizer** (**ASan**) protects your code against issues related to
    memory addressing, such as global-buffer-overflow, use-after-free, or stack-use-after-return.
    Even though it''s one of the fastest solutions of its kind, it still slows down
    the process about two times. It''s best to use it when running tests and doing
    development but turn it off in production builds. You can turn it on for your
    builds by adding the `-fsanitize=address` flag to Clang.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddressSanitizer**（**ASan**）可保护您的代码免受与内存寻址相关的问题，如全局缓冲区溢出，释放后使用或返回后使用堆栈。尽管它是同类解决方案中最快的之一，但仍会使进程减速约两倍。最好在运行测试和进行开发时使用它，但在生产构建中关闭它。您可以通过向Clang添加`-fsanitize=address`标志来为您的构建启用它。'
- en: '**AddressSanitizerLeakSanitizer** (**LSan**) integrates with ASan to find memory
    leaks. It is enabled by default on x86_64 Linux and x86_64 macOS. It requires
    setting an environment variable, `ASAN_OPTIONS=detect_leaks=1`. LSan performs
    leak detection at the end of the process. LSan can also be used as a standalone
    library without AddressSanitizer, but this mode is much less tested.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddressSanitizerLeakSanitizer**（**LSan**）与ASan集成以查找内存泄漏。它在x86_64 Linux和x86_64
    macOS上默认启用。它需要设置一个环境变量，`ASAN_OPTIONS=detect_leaks=1`。LSan在进程结束时执行泄漏检测。LSan也可以作为一个独立库使用，而不需要AddressSanitizer，但这种模式测试较少。'
- en: '**ThreadSanitizer** (**TSan**), as we previously mentioned, detects problems
    with concurrency such as data races and deadlocks. You can enable it with the
    `-fsanitize=thread` flag to Clang.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**ThreadSanitizer**（**TSan**），正如我们之前提到的，可以检测并发问题，如数据竞争和死锁。您可以使用`-fsanitize=thread`标志启用它到Clang。'
- en: '**MemorySanitizer** (**MSan**) focuses on bugs related to access to uninitialized
    memory. It implements some of the features of Valgrind that we covered in the
    previous subsection. MSan supports 64-bit x86, ARM, PowerPC, and MIPS platforms.
    You can enable it with the `-fsanitize=memory -fPIE -pie` flag to Clang (which
    also turns on position-independent executables, a concept we''ll discuss later
    on).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**MemorySanitizer**（**MSan**）专注于与对未初始化内存的访问相关的错误。它实现了我们在前一小节中介绍的Valgrind的一些功能。MSan支持64位x86、ARM、PowerPC和MIPS平台。您可以通过向Clang添加`-fsanitize=memory
    -fPIE -pie`标志来启用它（这也会打开位置无关可执行文件，这是我们稍后将讨论的概念）。'
- en: '**Hardware-Assisted Address Sanitizer** (**HWASAN**) is similar to the regular
    ASan. The main difference is the use of hardware assistance when possible. This
    feature is, for now, available only on 64-bit ARM architectures.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件辅助地址消毒剂**（**HWASAN**）类似于常规ASan。主要区别在于尽可能使用硬件辅助。目前，此功能仅适用于64位ARM架构。'
- en: '**UndefinedBehaviorSanitizer** (**UBSan**) looks for other possible causes
    of undefined behavior, such as integer overflow, division by zero, or improper
    bit shift operations. You can enable it with the `-fsanitize=undefined` flag to
    Clang.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**UndefinedBehaviorSanitizer**（**UBSan**）寻找未定义行为的其他可能原因，如整数溢出、除以零或不正确的位移操作。您可以通过向Clang添加`-fsanitize=undefined`标志来启用它。'
- en: Even though sanitizers can help you uncover many potential problems, they are
    only as good as the tests that you run them against. When using the sanitizers,
    keep in mind to keep the code coverage of your tests high because otherwise, you
    may get a false sense of security.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管消毒剂可以帮助您发现许多潜在问题，但它们只有在您对其进行测试时才有效。在使用消毒剂时，请记住保持测试的代码覆盖率高，否则您可能会产生一种虚假的安全感。
- en: Fuzz-testing
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模糊测试
- en: A subcategory of DAST tools, fuzz-testing checks the behavior of your application
    when confronted with invalid, unexpected, random, or maliciously formed data.
    Such checks can be especially useful when used against the interfaces that cross
    the trust boundary (such as end user file upload forms or inputs).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为DAST工具的一个子类，模糊测试检查应用程序在面对无效、意外、随机或恶意形成的数据时的行为。在针对跨越信任边界的接口（如最终用户文件上传表单或输入）时，此类检查尤其有用。
- en: 'Some interesting tools from this category include the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别中的一些有趣工具包括以下内容：
- en: 'Peach Fuzzer: [https://www.peach.tech/products/peach-fuzzer/](https://www.peach.tech/products/peach-fuzzer/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Peach Fuzzer：[https://www.peach.tech/products/peach-fuzzer/](https://www.peach.tech/products/peach-fuzzer/)
- en: 'PortSwigger Burp: [https://portswigger.net/burp](https://portswigger.net/burp)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PortSwigger Burp：[https://portswigger.net/burp](https://portswigger.net/burp)
- en: 'The OWASP Zed Attack Proxy project: [https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP Zed Attack Proxy项目：[https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project)
- en: 'Google''s ClusterFuzz: [https://github.com/google/clusterfuzz](https://github.com/google/clusterfuzz)
    (and OSS-Fuzz: [https://github.com/google/oss-fuzz](https://github.com/google/oss-fuzz))'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google的ClusterFuzz：[https://github.com/google/clusterfuzz](https://github.com/google/clusterfuzz)（和OSS-Fuzz：[https://github.com/google/oss-fuzz](https://github.com/google/oss-fuzz)）
- en: Process isolation and sandboxing
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程隔离和沙箱
- en: If you want to run unverified software in your own environment, you may want
    to isolate it from the rest of your system. Some ways to sandbox the executed
    code is via VMs, containers, or micro VMs such as Firecracker ([https://firecracker-microvm.github.io/](https://firecracker-microvm.github.io/))
    used by AWS Lambda.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在自己的环境中运行未经验证的软件，您可能希望将其与系统的其余部分隔离开来。通过虚拟机、容器或AWS Lambda使用的Firecracker（[https://firecracker-microvm.github.io/](https://firecracker-microvm.github.io/)）等微型虚拟机，可以对执行的代码进行沙盒化。
- en: This way, the crashes, leaks, and security problems of one application won't
    propagate to the entire system, rendering it either useless or compromised. As
    each process will have its own sandbox, the worst-case scenario would be the loss
    of only this one service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一个应用程序的崩溃、泄漏和安全问题不会传播到整个系统，使其变得无用或者受到威胁。由于每个进程都有自己的沙盒，最坏的情况就是只丢失这一个服务。
- en: For C and C++ code, there is also **Sandboxed API** (**SAPI**; [https://githu](https://github.com/google/sandboxed-api)[b.com/google/sandboxed-api](https://github.com/google/sandboxed-api)[)
    an open source project led by Google. It allows building sandboxes not for entire
    processes but for libraries. It is used by Google's own Chrome and Chromium web
    browsers, among others.](https://github.com/google/sandboxed-api)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C和C++代码，还有一个由谷歌领导的开源项目**Sandboxed API**（**SAPI**；[https://githu](https://github.com/google/sandboxed-api)[b.com/google/sandboxed-api](https://github.com/google/sandboxed-api)[)，它允许构建沙盒不是为整个进程，而是为库。它被谷歌自己的Chrome和Chromium网页浏览器等使用。](https://github.com/google/sandboxed-api)
- en: Even though VMs and containers can be a part of the process isolation strategy,
    don't confuse them with microservices, which often use similar building blocks.
    Microservices are an architectural design pattern and they don't automatically
    equal better security.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 即使虚拟机和容器可以成为进程隔离策略的一部分，也不要将它们与微服务混淆，后者通常使用类似的构建模块。微服务是一种架构设计模式，它们并不自动等同于更好的安全性。
- en: Hardening your environment
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固您的环境
- en: Even if you take the necessary precautions to ensure that your dependencies
    and code are free from known vulnerabilities, there still exists an area that
    can compromise your security strategy. All applications need an execution environment
    and this can mean either a container, VMs, or an operating system. Sometimes,
    this can also mean the underlying infrastructure as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您采取了必要的预防措施，确保您的依赖项和代码没有已知的漏洞，仍然存在一个可能会危及您的安全策略的领域。所有应用程序都需要一个执行环境，这可能意味着容器、虚拟机或操作系统。有时，这也可能意味着底层基础设施。
- en: It's not enough to make your application hardened to the maximum when the operating
    system it runs on has open access. This way, instead of targeting your application,
    the attacker can gain unauthorized access to the data directly from the system
    or infrastructure level.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序的操作系统具有开放访问权限时，仅仅使应用程序达到最大程度的硬化是不够的。这样，攻击者可以从系统或基础设施级别直接获取未经授权的数据，而不是针对您的应用程序。
- en: This section will focus on some techniques of hardening that you can apply at
    this lowest level of execution.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍一些硬化技术，您可以在执行的最低级别应用这些技术。
- en: Static versus dynamic linking
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态与动态链接
- en: Linking is the process that occurs after compilation when the code you've written
    is brought together with its various dependencies (such as the standard library).
    Linking can occur at build time, at load time (when the operating system executes
    the binary), or at runtime, as is the case with plugins and other dynamic dependencies.
    The last two use cases are only possible with dynamic linking.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是在编译后发生的过程，当您编写的代码与其各种依赖项（如标准库）结合在一起时。链接可以在构建时、加载时（操作系统执行二进制文件时）或运行时发生，如插件和其他动态依赖项的情况。最后两种用例只可能发生在动态链接中。
- en: So, what is the difference between dynamic and static linking? With static linking,
    the contents of all the dependencies are copied to the resulting binary. When
    the program is loaded, the operating system places this single binary in the memory
    and executes it. Static linking is performed by programs called linkers as the
    last step of the build process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，动态链接和静态链接有什么区别呢？使用静态链接，所有依赖项的内容都会被复制到生成的二进制文件中。当程序加载时，操作系统将这个单一的二进制文件放入内存并执行它。静态链接是由称为链接器的程序在构建过程的最后一步执行的。
- en: Because each executable has to contain all the dependencies, statically linked
    programs tend to be big. This has its upside as well; since everything needed
    to execute the problem is already available in a single place, the execution can
    be faster and it always takes the same amount of time to load the program into
    memory. Any changes in the dependencies require recompilation and relinking; there
    is no way to upgrade one dependency without changing the resulting binary.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个可执行文件都必须包含所有的依赖项，静态链接的程序往往体积较大。这也有其好处；因为执行所需的一切都已经在一个地方可用，所以执行速度可能会更快，并且加载程序到内存中所需的时间总是相同的。对依赖项的任何更改都需要重新编译和重新链接；没有办法升级一个依赖项而不改变生成的二进制文件。
- en: In dynamic linking, the resulting binary contains the code you've written, but
    instead of the contents of the dependencies, there are only references to the
    actual libraries that need to be loaded separately. During load time, it is the
    task of the dynamic loader to find the appropriate libraries and load them to
    memory alongside your binary. When several applications are running simultaneously
    and each of them is using similar dependencies (such as a JSON parsing library
    or JPEG processing library), the dynamically liked binaries will result in lower
    memory usage. This is due to the fact that only a single copy of a given library
    can be loaded into memory. In contrast, with statically linked binaries, the same
    libraries would be loaded over and over again as part of the resulting binaries.
    When you need to upgrade one of your dependencies, you can do so without touching
    any other component of your system. The next time your application is loaded into
    memory, it will reference the newly upgraded component automatically.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态链接中，生成的二进制文件包含您编写的代码，但是依赖项的内容被替换为需要单独加载的实际库的引用。在加载时，动态加载器的任务是找到适当的库并将它们加载到内存中与您的二进制文件一起。当多个应用程序同时运行并且它们每个都使用类似的依赖项（例如JSON解析库或JPEG处理库）时，动态链接的二进制文件将导致较低的内存使用率。这是因为只有一个给定库的副本可以加载到内存中。相比之下，使用静态链接的二进制文件中相同的库会作为结果的一部分一遍又一遍地加载。当您需要升级其中一个依赖项时，您可以在不触及系统的任何其他组件的情况下进行。下次加载应用程序到内存时，它将自动引用新升级的组件。
- en: Static and dynamic linking also have security implications. It is easier to
    gain unauthorized access to dynamically linked applications. This can be achieved
    by substituting a compromised dynamic library in place of a regular one or by
    preloading certain libraries into each newly executed process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态链接也具有安全性影响。更容易未经授权地访问动态链接的应用程序。这可以通过在常规库的位置替换受损的动态库或在每次新执行的进程中预加载某些库来实现。
- en: When you combine static linking with containers (explained in detail in a later
    chapter), you get small, secure, sandboxed execution environments. You may even
    go further and use such containers with microkernel-based VMs that reduce the
    attack surface considerably.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将静态链接与容器结合使用时（在后面的章节中详细解释），您将获得小型、安全、沙箱化的执行环境。您甚至可以进一步使用这些容器与基于微内核的虚拟机，从而大大减少攻击面。
- en: Address space layout randomization
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址空间布局随机化
- en: '**Address Space Layout Randomization** (**ASLR**) is a technique used to prevent
    memory-based exploits. It works by replacing the standard memory layout of the
    program and data with a randomized one. This means an attacker cannot reliably
    jump to a particular function that would otherwise be present on a system without
    ASLR.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址空间布局随机化**（**ASLR**）是一种用于防止基于内存的攻击的技术。它通过用随机化的内存布局替换程序和数据的标准布局来工作。这意味着攻击者无法可靠地跳转到在没有ASLR的系统上本来存在的特定函数。'
- en: This technique can be made even more effective when combined with **no-execute**
    (**NX**) bit support. The NX bit marks certain pages in the memory, such as the
    heap and stack, as containing only data that cannot be executed. NX bit support
    has been implemented in most mainstream operating systems and can be used whenever
    hardware supports it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当与**不执行**（**NX**）位支持结合使用时，这种技术可以变得更加有效。NX位标记内存中的某些页面，例如堆和栈，只包含不能执行的数据。大多数主流操作系统都已实现了NX位支持，并且可以在硬件支持时使用。
- en: DevSecOps
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevSecOps
- en: To deliver software increments on a predictable basis, it is best to embrace
    the DevOps philosophy. In short, DevOps means breaking the traditional model by
    encouraging communication between business, software development, software operations,
    quality assurance, and clients. DevSecOps is a form of DevOps that also emphasizes
    the need to design with security in mind at each step of the process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按可预测的方式交付软件增量，最好采用DevOps理念。简而言之，DevOps意味着打破传统模式，鼓励业务、软件开发、软件运营、质量保证和客户之间的沟通。DevSecOps是DevOps的一种形式，它还强调了在每个步骤中考虑安全性的必要性。
- en: This means that the application you are building has observability built-in
    from the beginning, leverages CI/CD pipelines, and is scanned for vulnerabilities
    on a regular basis. DevSecOps gives developers a voice in the design of the underlying
    infrastructure, and it gives operations experts a voice in the design of the software
    packages that make up the application. Since every increment represents a working
    system (albeit not fully functional), security audits are performed regularly
    and therefore take less time than normal. This results in faster and more secure
    releases and allows for quicker reactions to security incidents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您正在构建的应用程序从一开始就具有内置的可观察性，利用CI/CD流水线，并定期扫描漏洞。DevSecOps使开发人员在基础架构设计中发挥作用，并使运营专家在构成应用程序的软件包设计中发挥作用。由于每个增量代表一个可工作的系统（尽管不是完全功能的），因此安全审计定期进行，所需时间比正常情况下少。这导致更快速和更安全的发布，并允许更快地对安全事件做出反应。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed different aspects of a secure system. Since security
    is a complex topic, you cannot approach it only from the angle of your own application.
    All applications nowadays function in some environment and it is important to
    either control this environment and shape it according to your requirements or
    to shield yourself from the environment by sandboxing and isolating the code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了安全系统的不同方面。由于安全性是一个复杂的主题，您不能仅从自己的应用程序的角度来处理它。现在所有的应用程序都在某种环境中运行，要么控制这个环境并根据您的要求塑造它，要么通过沙箱化和隔离代码来保护自己免受环境的影响。
- en: Having read this chapter, you are now ready to search for the vulnerabilities
    in your dependencies and in your own code. You know how to design systems for
    increased security and what tools to use in order to find possible flaws. Maintaining
    security is a constant process but a good design can reduce the work further down
    the road.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您现在可以开始搜索依赖项和自己代码中的漏洞。您知道如何设计增强安全性的系统以及使用哪些工具来发现可能的缺陷。保持安全是一个持续的过程，但良好的设计可以减少未来的工作量。
- en: The next chapter will deal with scalability and the various challenges that
    we may face when growing our system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论可扩展性以及在系统扩展时可能面临的各种挑战。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is security important in modern systems?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么安全在现代系统中很重要？
- en: What are some challenges of concurrency?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发的一些挑战是什么？
- en: What are the C++ Core Guidelines?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++核心指南是什么？
- en: What's the difference between secure coding and defensive coding?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全编码和防御性编码有什么区别？
- en: How can you check whether your software contains known vulnerabilities?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何检查您的软件是否包含已知的漏洞？
- en: What's the difference between static and dynamic analysis?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态分析和动态分析有什么区别？
- en: What's the difference between static and dynamic linking?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态链接和动态链接有什么区别？
- en: How you can use the compiler to fix security problems?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何使用编译器来解决安全问题？
- en: How can you implement security awareness in your CI pipeline?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在CI流程中实施安全意识？
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Cybersecurity in general**:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般的网络安全**：'
- en: '[https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects](https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects](https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects)'
- en: '[https://www.packtpub.com/eu/networking-and-servers/information-security-handbook](https://www.packtpub.com/eu/networking-and-servers/information-security-handbook)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/networking-and-servers/information-security-handbook](https://www.packtpub.com/eu/networking-and-servers/information-security-handbook)'
- en: '[https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page)'
- en: '[https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing](https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing](https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing)'
- en: '**Concurrency**:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**：'
- en: '[https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices)'
- en: '[https://www.packtpub.com/eu/application-development/mastering-c-multithreading](https://www.packtpub.com/eu/application-development/mastering-c-multithreading)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/application-development/mastering-c-multithreading](https://www.packtpub.com/eu/application-development/mastering-c-multithreading)'
- en: '**Operating system hardening**:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统加固**：'
- en: '[https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening](https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening](https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening)'
