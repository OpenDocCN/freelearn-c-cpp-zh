- en: Testing Dashboards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试仪表板
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Deploying tests to the CDash dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试部署到CDash仪表板
- en: Reporting test coverage to the CDash dashboard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向CDash仪表板报告测试覆盖率
- en: Using the AddressSanitizer and reporting memory defects to CDash
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AddressSanitizer并向CDash报告内存缺陷
- en: Using the ThreadSanitizer and reporting data races to CDash
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ThreadSanitizer并向CDash报告数据竞争
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'CDash is a web service used to aggregate the test results reported by CTest
    during a test run or nightly testing, or in a continuous integration setting.
    Reporting to the dashboard is what we refer to as **CDash time**, as illustrated
    by the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: CDash是一个Web服务，用于聚合CTest在测试运行、夜间测试或在持续集成设置中报告的测试结果。向仪表板报告就是我们所说的**CDash时间**，如下图所示：
- en: '![](img/fa7c19ee-f725-4708-b9bc-e12a2f761021.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa7c19ee-f725-4708-b9bc-e12a2f761021.jpg)'
- en: In this chapter, we will demonstrate recipes to report test results to a CDash
    dashboard. We will discuss strategies for reporting test coverage, as well as
    memory defects and data races collected with tools such as the AddressSanitizer
    and the ThreadSanitizer, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何向CDash仪表板报告测试结果。我们将讨论报告测试覆盖率的策略，以及使用AddressSanitizer和ThreadSanitizer等工具收集的内存缺陷和数据竞争。
- en: 'There are two ways to report to CDash: either through the test target of a
    build or by using a CTest script. We will demonstrate the test target route in
    the first two recipes and will use the CTest script route in the last two recipes.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向CDash报告有两种方式：通过构建的测试目标或使用CTest脚本。我们将在前两个食谱中演示测试目标的方法，并在最后两个食谱中使用CTest脚本的方法。
- en: Setting up a CDash dashboard
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CDash仪表板
- en: The installation of CDash requires a web server (Apache, NGINX, or IIS) with
    PHP and SSL enabled, and access to a MySQL or PostgreSQL database server. It is
    outside of the scope of this book to discuss the setup of a CDash web service
    in detail; we refer the reader to its official documentation, at [https://public.kitware.com/Wiki/CDash:Installation](https://public.kitware.com/Wiki/CDash:Installation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CDash的安装需要一个带有PHP和SSL启用的Web服务器（Apache、NGINX或IIS），以及访问MySQL或PostgreSQL数据库服务器的权限。本书不详细讨论CDash
    Web服务的设置；我们建议读者参考其官方文档，网址为[https://public.kitware.com/Wiki/CDash:Installation](https://public.kitware.com/Wiki/CDash:Installation)。
- en: Installing a CDash instance is not a requirement for producing the recipes in
    this chapter since Kitware offers two public dashboards ([https://my.cdash.org](https://my.cdash.org)
    and [https://open.cdash.org](https://open.cdash.org)). We will reference the former
    in the recipes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装CDash实例不是本章食谱的必要条件，因为Kitware提供了两个公共仪表板（[https://my.cdash.org](https://my.cdash.org)和[https://open.cdash.org](https://open.cdash.org)）。我们将在食谱中引用前者。
- en: For readers that decide to install their own CDash instance, we recommend using
    a MySQL backend, since this seems to be the configuration used by [https://my.cdash.org](https://my.cdash.org)
    and [https://open.cdash.org](https://open.cdash.org), and also seems to be better
    tested by the community.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于决定自行安装CDash实例的读者，我们建议使用MySQL后端，因为这似乎是[https://my.cdash.org](https://my.cdash.org)和[https://open.cdash.org](https://open.cdash.org)所使用的配置，并且社区对其进行了更充分的测试。
- en: Docker can also be used to provision a CDash instance without too much effort.
    A request for an official image is currently open on the CDash issue tracker,
    at [https://github.com/Kitware/CDash/issues/562](https://github.com/Kitware/CDash/issues/562).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用Docker来部署CDash实例，而无需太多努力。目前，在CDash问题跟踪器上有一个关于官方镜像的请求，网址为[https://github.com/Kitware/CDash/issues/562](https://github.com/Kitware/CDash/issues/562)。
- en: Deploying tests to the CDash dashboard
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试部署到CDash仪表板
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01),
    and includes a C++ example. The Recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will extend the test example of Recipe 1, *Creating a simple
    unit test,* from [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests,* and deploy the test result to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook),
    which we created for this book on the public dashboard ([https://my.cdash.org](https://my.cdash.org))
    provided to the community by Kitware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将扩展第1个食谱，即“创建一个简单的单元测试”，来自[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，“创建和运行测试”，并将测试结果部署到[https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook)，这是我们在公共仪表板（[https://my.cdash.org](https://my.cdash.org)）上为本书创建的，由Kitware提供给社区。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start by reusing the example source code from Recipe 1, *Creating a
    simple unit test,* in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, which sums integers given as command-line arguments.
    The example consists of three source files: `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp`.
    These sources are unchanged. We will also reuse the file `test.cpp` from [Chapter
    4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running Tests,*
    but will rename it to `test_short.cpp`. We will extend the example with `test_long.cpp`,
    containing the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从重用第1个食谱，即“创建一个简单的单元测试”，来自[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，“创建和运行测试”的示例源代码开始，该示例对作为命令行参数给出的整数求和。示例由三个源文件组成：`main.cpp`、`sum_integers.cpp`和`sum_integers.hpp`。这些源文件保持不变。我们还将重用来自[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，“创建和运行测试”的文件`test.cpp`，但将其重命名为`test_short.cpp`。我们将通过`test_long.cpp`扩展示例，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will then organize these files into the following file tree:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些文件组织成以下文件树：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We will now describe how to configure, build, test, and finally, submit the
    test results for our example project to the dashboard:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述如何配置、构建、测试，最后，将我们示例项目的测试结果提交到仪表板：
- en: 'The source targets are defined in `src/CMakeLists.txt`, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源目标在`src/CMakeLists.txt`中定义，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The tests are defined in `tests/CMakeLists.txt`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试在`tests/CMakeLists.txt`中定义：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The top-level `CMakeLists.txt` file references the two preceding files, and
    the new element in this recipe is the line containing `include(CTest)`, which
    allows us to report to a CDash dashboard:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶级`CMakeLists.txt`文件引用了前面两个文件，本食谱中的新元素是包含`include(CTest)`的行，它允许我们向CDash仪表板报告：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition, we create the file `CTestConfig.cmake` in the same directory as
    the top-level `CMakeLists.txt` file. This new file contains the following lines:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们在顶级`CMakeLists.txt`文件所在的同一目录中创建了文件`CTestConfig.cmake`。这个新文件包含以下行：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are now ready to configure and build the project, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备配置并构建项目，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Having built the code, we can run the test set and report the test results
    to the dashboard:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建代码之后，我们可以运行测试集并将测试结果报告给仪表板：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we can browse the test results in our browser (in this case, the test
    results are reported to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook)))[:](https://my.cdash.org/index.php?project=cmake-cookbook))
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在浏览器中浏览测试结果（在本例中，测试结果被报告给[https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook))[:](https://my.cdash.org/index.php?project=cmake-cookbook))
- en: '![](img/c8d388dc-34e6-4a5f-8fa7-346970897f2f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8d388dc-34e6-4a5f-8fa7-346970897f2f.png)'
- en: How it works
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: A high-level overview of the workflow shows that CTest runs the tests and records
    results locally in XML files. These XML files are then sent to the CDash server,
    where they can be browsed and analyzed. We can obtain more details about the passed
    or failed tests (in this example, there are no failed tests) by clicking on the
    2 under Pass, as shown in the preceding screenshot. The details, as shown in the
    following screenshot, record information about the machine that ran the tests,
    as well as timing information. Again, the test output for individual tests can
    be browsed online.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程的高层次概览显示，CTest运行测试并将结果记录在本地XML文件中。这些XML文件随后被发送到CDash服务器，在那里可以进行浏览和分析。通过点击前面截图中显示的“通过”下的2，我们可以获得关于通过或失败的测试的更多细节（在本例中，没有失败的测试）。如后续截图所示，详细记录了运行测试的机器信息以及时间信息。同样，个别测试的输出可以在网上浏览。
- en: '![](img/3cb76099-2d97-4568-94d3-385789b08490.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cb76099-2d97-4568-94d3-385789b08490.png)'
- en: 'CTest supports three different running submission modes: Experimental, Nightly,
    and Continuous. We have used `ctest --dashboard Experimental`, and thus, the test
    results appear under Experimental. The Experimental mode is useful for testing
    the current state of the code, for debugging a new dashboard script (see Recipes
    3 and 4 in this chapter), or for debugging a CDash server or project. The Nightly
    mode will update (or down-date) the code to the repository snapshot closest to
    the latest nightly start time, which can be set in `CTestConfig.cmake`; it gives
    all nightly tests in a project that receives frequent updates a well-defined reference
    point. For instance, the nightly start time can be set to midnight, Coordinated
    Universal Time, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CTest支持三种不同的运行提交模式：实验性、夜间和连续性。我们使用了`ctest --dashboard Experimental`，因此测试结果出现在实验性下。实验模式适用于测试代码的当前状态，用于调试新的仪表板脚本（参见本章的第3和第4个食谱），或用于调试CDash服务器或项目。夜间模式将更新（或降级）代码到最接近最新夜间开始时间的仓库快照，这可以在`CTestConfig.cmake`中设置；它为接收频繁更新的项目中的所有夜间测试提供了一个定义良好的参考点。例如，可以将夜间开始时间设置为协调世界时午夜，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Continuous mode is useful for a continuous integration workflow and will
    update the code to the latest version.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 连续模式适用于持续集成工作流程，并将更新代码到最新版本。
- en: Building, testing, and submitting to the Experimental dashboard can be done
    with just one command - the `cmake --build . --target Experimental` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个命令即可完成构建、测试并提交到实验仪表板 - 即`cmake --build . --target Experimental`命令。
- en: There is more
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: In this recipe, we deployed to CDash directly from the test target. It is possible
    to use a dedicated CTest script instead, and we will demonstrate this approach
    later in this chapter, in the upcoming Recipes 3 and 4.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们直接从测试目标部署到CDash。也可以使用专门的CTest脚本，我们将在本章稍后的第3和第4个食谱中演示这种方法。
- en: 'CDash allows you to monitor not only whether tests are passing or failing,
    but also the test timing. You can configure margins for test timing: if a test
    takes more time than allotted, it will be marked as failing. This is useful for
    benchmark tests, to automatically detect performance degradation in test timing
    when refactoring code.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CDash不仅允许您监控测试是否通过或失败，还允许您监控测试时间。您可以为测试时间配置边际：如果测试花费的时间超过分配的时间，它将被标记为失败。这对于基准测试很有用，可以自动检测在重构代码时测试时间性能下降的情况。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: See the official CDash documentation for a detailed discussion of CDash definitions
    and configuration settings, at [https://public.kitware.com/Wiki/CDash:Documentation](https://public.kitware.com/Wiki/CDash:Documentation).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CDash定义和配置设置的详细讨论，请参阅官方CDash文档，网址为[https://public.kitware.com/Wiki/CDash:Documentation](https://public.kitware.com/Wiki/CDash:Documentation)。
- en: Reporting test coverage to the CDash dashboard
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向CDash仪表板报告测试覆盖率
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02),
    and it includes a C++ example. The recipe is valid with CMake version 3.5 (and
    higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02)获取，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will measure the test coverage and report it to the CDash
    dashboard, where we will be able to browse the test coverage analysis line-by-line,
    in order to identify untested or unused code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将测量测试覆盖率并将其报告给CDash仪表板，以便我们能够逐行浏览测试覆盖率分析，以识别未测试或未使用的代码。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will extend the source code of the previous recipe with a minor change in `src/sum_integers.cpp`,
    where we will add a function - `sum_integers_unused`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前一个食谱的源代码中添加一个微小的变化，在`src/sum_integers.cpp`中，我们将添加一个函数 - `sum_integers_unused`：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our goal is to detect this unused code with a test coverage analysis, by using
    gcov ([https://gcc.gnu.org/onlinedocs/gcc/Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)).
    Apart from the preceding modification, we will use the unmodified sources of the
    previous recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使用测试覆盖率分析来检测这段未使用的代码，方法是使用gcov（[https://gcc.gnu.org/onlinedocs/gcc/Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)）。除了上述修改外，我们将使用前一个食谱的未修改源代码。
- en: How to do it
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Through the following steps, we will enable coverage analysis and upload the
    results to the dashboard:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将启用覆盖率分析并将结果上传到仪表板：
- en: The top-level `CMakeLists.txt` and `tests/CMakeLists.txt` files are unchanged
    from the previous recipe.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶级`CMakeLists.txt`和`tests/CMakeLists.txt`文件与之前的配方保持不变。
- en: 'We will extend `src/CMakeLists.txt`, with an option to add compile flags for
    code coverage. This option is enabled by default, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`src/CMakeLists.txt`中扩展，添加一个选项以添加代码覆盖率的编译标志。此选项默认启用，如下所示：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will then configure, build, and deploy to CDash:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将配置、构建并部署到CDash：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will produce an output similar to the previous recipe, but in addition,
    the last step will perform a test coverage analysis:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将产生与之前配方类似的输出，但最后一步将执行测试覆盖率分析：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, we can verify the test results in our browser (in this case, the test
    results are reported to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook))[)](https://my.cdash.org/index.php?project=cmake-cookbook))[:](https://my.cdash.org/index.php?project=cmake-cookbook))
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在浏览器中验证测试结果（在本例中，测试结果报告给[https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook)）。
- en: '![](img/e22437a3-f9f6-443d-bd7f-491693d1e7bd.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e22437a3-f9f6-443d-bd7f-491693d1e7bd.png)'
- en: How it works
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The test coverage analysis is summarized with a percentage of 66.67%. To get
    further insights, we can click on the percentage and obtain a coverage analysis
    for the two subdirectories, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率分析以66.67%的百分比进行总结。为了获得更深入的见解，我们可以点击该百分比，并获得两个子目录的覆盖率分析，如下所示：
- en: '![](img/3e4cef79-019f-463a-8842-d147e4218bdb.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e4cef79-019f-463a-8842-d147e4218bdb.png)'
- en: 'By browsing the subdirectory links, we can inspect the test coverage percentage
    for individual files, and can even browse a line-by-line summary (for example, `src/sum_integers.cpp`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览子目录链接，我们可以检查单个文件的测试覆盖率百分比，甚至可以浏览逐行的总结（例如，`src/sum_integers.cpp`）：
- en: '![](img/09b351b7-fae6-49fb-b13d-919aaa31175f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09b351b7-fae6-49fb-b13d-919aaa31175f.png)'
- en: The green lines have been traversed when running the test suite, whereas the
    red lines have not. Through this, we can not only identify unused/untested code
    (with the function `sum_integers_unused`) but can also see how often each line
    has been traversed. For instance, the code line `sum += i` has been visited 1,005
    times (5 times during `test_short`, and 1,000 times during `test_long`). Test
    coverage analysis is an indispensable companion to automated testing, and CDash
    provides us with an interface to browse and analyze the results graphically in
    the browser.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色线条在运行测试套件时已被遍历，而红色线条则没有。通过这一点，我们不仅可以识别未使用/未测试的代码（使用`sum_integers_unused`函数），还可以看到每行代码被遍历的频率。例如，代码行`sum
    += i`已被访问1,005次（`test_short`期间5次，`test_long`期间1,000次）。测试覆盖率分析是自动化测试不可或缺的伴侣，CDash为我们提供了一个在浏览器中浏览和图形化分析结果的界面。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For further reading, we recommend the following blog post, which discusses
    additional coverage features in CDash: [https://blog.kitware.com/additional-coverage-features-in-cdash/](https://blog.kitware.com/additional-coverage-features-in-cdash/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如需进一步阅读，我们推荐以下博客文章，该文章讨论了CDash中的额外覆盖功能：[https://blog.kitware.com/additional-coverage-features-in-cdash/](https://blog.kitware.com/additional-coverage-features-in-cdash/)。
- en: Using the AddressSanitizer and reporting memory defects to CDash
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AddressSanitizer并将内存缺陷报告给CDash
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03),
    and includes a C++ and a Fortran example. The recipe is valid with CMake version
    3.5 (and higher), and has been tested on GNU/Linux and macOS.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03)找到，包括一个C++和一个Fortran示例。本配方适用于CMake版本3.5（及更高版本），并在GNU/Linux和macOS上进行了测试。
- en: AddressSanitizer (ASan) is a memory error detector for C++, C, and Fortran.
    It can find memory defects, such as use after free, use after return, use after
    scope, buffer overflows, initialization order bugs, and memory leaks (see [https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)). AddressSanitizer
    is a part of LLVM, starting with version 3.1, and is a part of GCC, starting with
    version 4.8\. In this recipe, we will fabricate two bugs in our code, which may
    go undetected in a normal test run. To detect these bugs, we will couple CTest
    with dynamic analysis by using AddressSanitizer, and will report the defects to
    CDash.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AddressSanitizer（ASan）是C++、C和Fortran的内存错误检测器。它可以发现内存缺陷，如使用后释放、使用后返回、使用后作用域、缓冲区溢出、初始化顺序错误和内存泄漏（参见[https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)）。AddressSanitizer是LLVM的一部分，从版本3.1开始，也是GCC的一部分，从版本4.8开始。在本菜谱中，我们将在我们的代码中制造两个可能未在正常测试运行中检测到的错误。为了检测这些错误，我们将CTest与使用AddressSanitizer的动态分析相结合，并将缺陷报告给CDash。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we will use two source files and two tests, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用两个源文件和两个测试，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The file `buggy.cpp` contains two buggy functions, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`buggy.cpp`包含两个有问题的函数，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These functions are exposed in the corresponding header file (`buggy.hpp`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在相应的头文件（`buggy.hpp`）中公开：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The test source, `leaky.cpp`, verifies the return code from `function_leaky`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试源码`leaky.cpp`验证`function_leaky`的返回码：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Correspondingly, `use_after_free.cpp` checks the return value of `function_use_after_free`,
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，`use_after_free.cpp`检查`function_use_after_free`的返回值，如下所示：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We need to compile our code with particular flags to take advantage of ASan.
    Then, we will run tests and submit them to the dashboard. Let us take a look at
    how to do this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用特定的标志编译我们的代码以利用ASan。然后，我们将运行测试并将它们提交到仪表板。让我们看看如何做到这一点：
- en: 'The buggy library is defined in `src/CMakeLists.txt`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有问题的库在`src/CMakeLists.txt`中定义：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To the file `src/CMakeLists.txt`, we will add an option and code to sanitize
    using ASan:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于文件`src/CMakeLists.txt`，我们将添加一个选项和代码以使用ASan进行消毒：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The two tests are defined in `tests/CMakeLists.txt` compactly, using a `foreach`
    loop:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个测试在`tests/CMakeLists.txt`中紧凑地定义，使用`foreach`循环：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The top-level `CMakeLists.txt` is essentially unchanged with respect to the
    previous recipes:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶级`CMakeLists.txt`基本上与之前的菜谱保持不变：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, the `CTestConfig.cmake` file is unchanged:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`CTestConfig.cmake`文件保持不变：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this recipe, we will report to CDash using a CTest script; for this, we
    will create a file, `dashboard.cmake` (in the same directory as the main `CMakeLists.txt`
    and `CTestConfig.cmake`), containing the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用CTest脚本向CDash报告；为此，我们将创建一个文件，`dashboard.cmake`（与主`CMakeLists.txt`和`CTestConfig.cmake`在同一目录中），包含以下内容：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will execute the `dashboard.cmake` script directly. Note how we pass the
    generator to use with the `CTEST_CMAKE_GENERATOR` option, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将直接执行`dashboard.cmake`脚本。请注意我们如何使用`CTEST_CMAKE_GENERATOR`选项传递要使用的生成器，如下所示：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result will appear on the CDash site, as shown in the following screenshot:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将出现在CDash站点上，如下面的截图所示：
- en: '![](img/c1e9c27b-1250-42b4-ad1a-1e9afa699d37.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e9c27b-1250-42b4-ad1a-1e9afa699d37.png)'
- en: How it works
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In this recipe, we successfully reported memory bugs to the Dynamic Analysis
    section of the dashboard. We can gain further insights by browsing the defects
    (under Defect Count):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们成功地将内存错误报告到了仪表板的动态分析部分。我们可以通过浏览缺陷（在缺陷计数下）获得更深入的见解：
- en: '![](img/efcbb7fd-4cb6-4843-9b32-6904c5d15419.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efcbb7fd-4cb6-4843-9b32-6904c5d15419.png)'
- en: By clicking on the individual links, it is possible to browse the full output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击各个链接，可以浏览完整输出。
- en: 'Note that it is also possible to generate the AddressSanitizer report locally.
    In this example, we need to set `ENABLE_ASAN`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，也可以在本地生成AddressSanitizer报告。在本例中，我们需要设置`ENABLE_ASAN`，如下所示：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the `leaky` test executable directly produces the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 直接运行`leaky`测试可执行文件产生以下结果：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Correspondingly, we can obtain detailed output by running the `use_after_free`
    executable directly, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，我们可以通过直接运行`use_after_free`可执行文件来获得详细的输出，如下所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we test without the AddressSanitizer (`ENABLE_ASAN` is `OFF` by default),
    no error is reported in the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用AddressSanitizer进行测试（默认情况下`ENABLE_ASAN`为`OFF`），则以下示例不会报告任何错误：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Indeed, `leaky` will just waste memory, whereas `use_after_free` may result
    in non-deterministic failures. One way to debug these failures is to use valgrind
    ([http://valgrind.org](http://valgrind.org/)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，`leaky`只会浪费内存，而`use_after_free`可能导致非确定性失败。调试这些失败的一种方法是使用valgrind（[http://valgrind.org](http://valgrind.org/)）。
- en: 'In contrast to the previous two recipes, we have used a CTest script to configure,
    build, and test the code, and to submit the report to the dashboard. To understand
    how this recipe works, take a closer look at the `dashboard.cmake` script. First,
    we define the project name and set the host reporting and the build name, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个方案不同，我们使用了一个CTest脚本来配置、构建和测试代码，并将报告提交到仪表板。要了解这个方案的工作原理，请仔细查看`dashboard.cmake`脚本。首先，我们定义项目名称并设置主机报告和构建名称，如下所示：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our case, the `CTEST_BUILD_NAME` evaluates to `Linux-x86_64`. In your case,
    you may observe a different result, depending on your operating system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`CTEST_BUILD_NAME`评估为`Linux-x86_64`。在您的例子中，您可能会观察到不同的结果，这取决于您的操作系统。
- en: 'Next, we specify paths for the source and build directories:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为源代码和构建目录指定路径：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We could set the generator to `Unix Makefiles`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将生成器设置为`Unix Makefiles`：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, for a more portable test script, we prefer to provide the generator
    *via* the command line, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了编写更便携的测试脚本，我们更倾向于通过命令行提供生成器，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next code snippet in `dashboard.cmake` figures out the number of available
    cores on the machine and sets the parallel level of the test step to the number
    of available cores, in order to minimize the total test time:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`dashboard.cmake`中的下一个代码片段计算出机器上可用的核心数，并将测试步骤的并行级别设置为可用核心数，以最小化总测试时间：'
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we start the testing step and configure the code, with `ENABLE_ASAN`
    set to `ON`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始测试步骤并配置代码，设置`ENABLE_ASAN`为`ON`：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The remaining commands in `dashboard.cmake` map to the build, test, memcheck,
    and submit steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的`dashboard.cmake`中的命令对应于构建、测试、内存检查和提交步骤：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is more
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: The attentive reader will have noticed that we did not search for the AddressSanitizer
    on our system prior to linking our target against it. A real-world, complete use
    case would have done that, to avoid unpleasant surprises during the linking stage.
    We will remind the reader that we showed a method to probe for the availability
    of sanitizers in Recipe 7, *Probing compiler flags,* in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到，我们在链接目标之前并没有在我们的系统上搜索AddressSanitizer。在现实世界的完整用例中，这样做是为了避免在链接阶段出现不愉快的意外。我们将提醒读者，我们在第7个方案中展示了一种方法来探测sanitizers的可用性，即“探测编译器标志”，在[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)“配置时间和构建时间操作”中。
- en: For more AddressSanitizer documentation and examples, see [https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer).
    AddressSanitizer is not limited to C and C++. For a Fortran example, we refer
    the reader to the code repository at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于AddressSanitizer的文档和示例，请参见[https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)。AddressSanitizer不仅限于C和C++。对于Fortran示例，我们建议读者参考位于[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example)的代码仓库。
- en: CMake utilities to discover sanitizers and adjust compiler flags are available
    at [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake)上可以找到用于发现sanitizers并调整编译器标志的CMake工具。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following blog post discusses examples of how to add support for dynamic
    analysis tools, and it inspired the present recipe: [https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下博客文章讨论了如何添加对动态分析工具的支持的示例，并启发了当前的方案：[https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/)。
- en: Using the ThreadSanitizer and reporting data races to CDash
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ThreadSanitizer并将数据竞争报告给CDash
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04),
    and includes a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux and macOS.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux和macOS上进行了测试。
- en: In this recipe, we will reuse the approach from the previous example, but use
    ThreadSanitizer, or TSan, in combination with CTest and CDash, to identify data
    races and report these to a CDash dashboard. The documentation for ThreadSanitizer
    can be found online, at [https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将重用前一个示例的方法，但结合使用ThreadSanitizer（或TSan）与CTest和CDash，以识别数据竞争并将这些信息报告给CDash仪表板。ThreadSanitizer的文档可以在网上找到，网址为[https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, we will work with the following example code (`example.cpp`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用以下示例代码（`example.cpp`）：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example code, we start 16 threads, and each of these threads calls
    the `increase` function. The `increase` function sleeps for one second, then prints
    and increments an integer, `s`. We anticipate that this example code will manifest
    data races, because all threads read and modify the same address, without any
    explicit synchronization or coordination. In other words, we expect that the final
    `s`, which is printed at the end of the code, may differ from run to run. The
    code is buggy, and we will try to identify the data race with the help of ThreadSanitizer.
    Without running ThreadSanitizer, we may not see any problems with the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，我们启动了16个线程，每个线程都调用了`increase`函数。`increase`函数休眠一秒钟，然后打印并递增一个整数`s`。我们预计这段代码会表现出数据竞争，因为所有线程都在没有明确同步或协调的情况下读取和修改同一地址。换句话说，我们预计最终的`s`，即代码末尾打印的`s`，可能会在每次运行中有所不同。这段代码存在缺陷，我们将尝试借助ThreadSanitizer来识别数据竞争。如果不运行ThreadSanitizer，我们可能不会发现代码中的任何问题：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us go through the necessary steps in detail, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地逐一介绍必要的步骤：
- en: 'The file `CMakeLists.txt` starts by defining a minimum supported version, project
    name, supported languages, and, in this case, a requirement of the C++11 standard:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`文件首先定义了最低支持版本、项目名称、支持的语言，以及在这种情况下，对C++11标准的要求：'
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we locate the Threads library, define the executable, and link it against
    the Threads library:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定位Threads库，定义可执行文件，并将其与Threads库链接：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we offer the option and code to compile and link with support for the
    ThreadSanitizer:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提供选项和代码以支持ThreadSanitizer的编译和链接：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, as a test, we execute the compiled example itself:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，作为测试，我们执行编译后的示例本身：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The file `CTestConfig.cmake` is unchanged with respect to the previous recipes:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CTestConfig.cmake`文件与前一个食谱相比没有变化：'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The corresponding `dashboard.cmake` script is a simple adaptation to TSan from
    the previous recipe:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应的`dashboard.cmake`脚本是对前一个食谱的简单改编，以适应TSan：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let us take this example for a spin. Once again, we will set the generator
    passing the `CTEST_CMAKE_GENERATOR` option:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次为这个示例设置生成器，通过传递`CTEST_CMAKE_GENERATOR`选项：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the dashboard, we will see the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仪表板上，我们将看到以下内容：
- en: '![](img/2fcd3c00-6d80-44c6-b1a5-2b41ba53258d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fcd3c00-6d80-44c6-b1a5-2b41ba53258d.png)'
- en: 'We can see the dynamic analysis in more detail as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以更详细地看到动态分析如下：
- en: '![](img/e8eaa44b-4031-4992-979b-24e772d3b04b.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8eaa44b-4031-4992-979b-24e772d3b04b.png)'
- en: How it works
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The core ingredients for this recipe are in the following section of `CMakeLists.txt`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的核心成分位于以下部分的`CMakeLists.txt`中：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The ingredients are also in the updated steps in `dashboard.cmake`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 成分也包含在`dashboard.cmake`中更新的步骤中：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As in the previous recipe, we can also inspect the output from ThreadSanitizer
    locally:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个食谱一样，我们也可以在本地检查ThreadSanitizer的输出：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There is more
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: It would be a natural step to apply TSan on an OpenMP code, but please note
    that OpenMP is known to generate false positives under TSan, in some cases. For
    the Clang compilers, a workaround would be to recompile the compiler itself, and
    its `libomp`, with `-DLIBOMP_TSAN_SUPPORT=TRUE`. In general, using sanitizers
    in a sensible way may require a recompilation of the entire tool-stack, in order
    to avoid false positives. This will probably be the case for a C++ project using
    pybind11; we would need to recompile Python with the sanitizers enabled to get
    anything meaningful. Alternatively, the Python binding can be left out from the
    sanitizing by using sanitizer suppression, as explained at [https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions](https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions).
    This may not be possible if, for example, a shared library is called by both by
    a sanitized binary and a Python plugin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对OpenMP代码应用TSan是一个自然的步骤，但请注意，在某些情况下，OpenMP在TSan下会产生误报。对于Clang编译器，一个解决办法是重新编译编译器本身及其`libomp`，并使用`-DLIBOMP_TSAN_SUPPORT=TRUE`。通常，合理地使用检测器可能需要重新编译整个工具栈，以避免误报。对于使用pybind11的C++项目，我们可能需要重新编译启用了检测器的Python，以获得有意义的结果。或者，可以通过使用检测器抑制来将Python绑定排除在检测之外，如[https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions](https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions)所述。如果例如一个共享库被一个启用了检测的二进制文件和一个Python插件同时调用，这可能是不可能的。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The following blog post discusses examples of how to add support for dynamic
    analysis tools, and it inspired the present recipe: [https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下博客文章讨论了如何为动态分析工具添加支持的示例，并激发了当前的方案：[https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/)。
