- en: Getting Started with C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++入门
- en: This chapter provides an introduction to **Object-Oriented Programming** (**OOP**)
    in C++. We start by looking into a simple program that rolls a dice. We write
    the code and compile, link, and execute the program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C++中的**面向对象编程**（**OOP**）。我们首先查看一个简单的掷骰子程序。我们编写代码，编译、链接和执行程序。
- en: Then we continue by constructing a simple object-oriented hierarchy, involving
    the `Person` base class and its two subclasses, `Student` and `Employee`. We also
    look into pointers and dynamic binding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续构建一个简单的面向对象层次结构，包括`Person`基类及其两个子类`Student`和`Employee`。我们还探讨了指针和动态绑定。
- en: Finally, we create two simple data types—stack and queue. A **stack** is constituted
    of a set of values ordered in a bottom-to-top manner, where we are interested
    in the top value only. A **queue** is a traditional queue of values, where we
    add values at the rear and inspect values at the front.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了两种简单的数据类型——栈和队列。栈是由一组从底到顶排序的值构成的，我们只对顶部值感兴趣。队列是一个传统的值队列，我们在后面添加值，在前面检查值。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: 'We start by implementing a simple game: rolling the dice. Its main purpose
    is to provide an introduction to the environment and teach you how to set up the
    project, and how to compile, link, and execute the program.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先实现一个简单的游戏：掷骰子。其主要目的是介绍环境，并教你如何设置项目，以及如何编译、链接和执行程序。
- en: Then we start looking at object-oriented programming by writing a class hierarchy
    with `Person` as the base class and `Student` and `Employee` as subclasses. This
    provides an introduction to inheritance, encapsulation, and dynamic binding.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们通过编写以`Person`作为基类和`Student`、`Employee`作为子类的类层次结构来开始面向对象编程的探讨。这为继承、封装和动态绑定提供了介绍。
- en: Finally, we write classes for the abstract data types stack and queue. A stack
    is a structure where we both add and remove values at the top, while a queue is
    more like a traditional queue where we add values at the rear and remove them
    from the front.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们为抽象数据类型栈和队列编写类。栈是一个结构，我们在顶部添加和移除值，而队列更像是一个传统的队列，我们在后面添加值，从前面移除。
- en: Rolling the dice
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掷骰子
- en: 'As an introduction, we start by writing a program that rolls a dice. We use
    the built-in random generator to generate an integer value between one and six,
    inclusive:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为介绍，我们首先编写一个掷骰子的程序。我们使用内置的随机数生成器生成一个介于1到6（包括1和6）之间的整数：
- en: '**Main.cpp**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding program, the initial `include` directives allow us to include
    header files, which mostly hold declarations of the standard library. We need
    the `CStdLib` header file to use the random generator, the `CTime` header file
    to initiate the random generator with the current time, and the `IOStream` header
    file to write the result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，初始的`include`指令允许我们包含头文件，这些头文件主要包含标准库的声明。我们需要`CStdLib`头文件来使用随机数生成器，`CTime`头文件用当前时间初始化随机数生成器，以及`IOStream`头文件来写入结果。
- en: The standard library is stored in a `namespace` called `std`. A `namespace`
    can be considered a container holding code. We gain access to the standard library
    with the `using namespace` directive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库存储在一个名为`std`的`namespace`中。`namespace`可以被认为是一个包含代码的容器。我们通过`using namespace`指令来访问标准库。
- en: Every C++ program holds exactly one `main` function. The execution of the program
    always starts in the `main` function. We use the `srand` and `time` standard functions
    to initialize the random generator, and `rand` to generate the actual random value.
    The percent (`%`) is the modulus operator, which divides two integers and gives
    the remainder of the division. In this way, the value of the `dice` integer variable
    is always at least one and at most six. Finally, we write the value of the `dice`
    variable with `cout`, which is an object used by the standard library to write
    text and values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C++程序恰好包含一个`main`函数。程序的执行总是从`main`函数开始。我们使用`srand`和`time`标准函数来初始化随机数生成器，并使用`rand`生成实际的随机值。百分号（`%`）是取模运算符，它将两个整数相除并给出除法的余数。这样，`dice`整数变量的值总是至少为1，最多为6。最后，我们使用`cout`输出`dice`变量的值，`cout`是标准库中用于写入文本和值的对象。
- en: The programs of the first four chapters were written with Visual Studio, while
    the programs of the remaining chapters are written with Qt Creator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前四章的程序是用Visual Studio编写的，而剩余章节的程序是用Qt Creator编写的。
- en: 'The following are instructions on how to create a project, write the code,
    and execute the application. When we have started Visual Studio, we follow the
    following steps to create our project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建项目、编写代码和执行应用程序的说明。当我们启动 Visual Studio 时，我们按照以下步骤创建我们的项目：
- en: 'First, we select the New and Project items in the File menu, as shown in the
    following screenshot:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在文件菜单中选择“新建”和“项目”，如图所示：
- en: '![](img/3286a2c4-c1ce-451b-b518-300e356a4880.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3286a2c4-c1ce-451b-b518-300e356a4880.png)'
- en: 'We choose the Win32 Console Application type, and name the project `Dice`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们选择 Win32 控制台应用程序类型，并将项目命名为 `Dice`:'
- en: '![](img/6f5ba715-fd89-4045-84ae-59809b91744f.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f5ba715-fd89-4045-84ae-59809b91744f.png)'
- en: 'In the first dialog we just press the Next button:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个对话框中，我们只需按下“下一步”按钮：
- en: '![](img/92382e5d-80ec-45b6-8d03-e65e27d2cf03.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92382e5d-80ec-45b6-8d03-e65e27d2cf03.png)'
- en: 'In the second dialog, we choose the Empty project checkbox and click on the
    Finish button. In this way, a project without files will be created:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个对话框中，我们选择“空项目”复选框，然后单击“完成”按钮。这样，就会创建一个没有文件的空项目：
- en: '![](img/919e66ae-8eb8-418f-bb40-ffac49c8446f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/919e66ae-8eb8-418f-bb40-ffac49c8446f.png)'
- en: 'When we have created our project, we need to add a file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建了自己的项目后，我们需要添加一个文件：
- en: '![](img/e8f2e8ac-3736-4e11-92ea-3d10a8f1c712.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8f2e8ac-3736-4e11-92ea-3d10a8f1c712.png)'
- en: 'We choose a C++ File(.cpp) and name it `Main.cpp`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们选择一个 C++ 文件(.cpp)并命名为 `Main.cpp`:'
- en: '![](img/dbf1c8f0-1c72-40c1-83ff-f3ccbccc114b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbf1c8f0-1c72-40c1-83ff-f3ccbccc114b.png)'
- en: 'Then, we input the code in the `Main.cpp` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `Main.cpp` 文件中输入代码：
- en: '![](img/c2c816f2-d507-42c2-bb96-0deea233f28b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2c816f2-d507-42c2-bb96-0deea233f28b.png)'
- en: 'Finally, we execute the program. The easiest way to do this is to choose the
    Start Debugging or Start Without Debugging menu option. In this way, the program
    is compiled, linked, and executed:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们执行程序。最简单的方法是选择“开始调试”或“不调试启动”菜单选项。这样，程序将被编译、链接和执行：
- en: '![](img/d544cad4-596d-4de1-9746-81edd5feacee.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d544cad4-596d-4de1-9746-81edd5feacee.png)'
- en: 'The output of the execution is displayed in a command window:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行的输出显示在命令窗口中：
- en: '![](img/d041451b-d5b6-443a-9e1a-d7a0a2e9cbbc.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d041451b-d5b6-443a-9e1a-d7a0a2e9cbbc.png)'
- en: Understanding classes – the Car class
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类 - 汽车类
- en: Let's continue by looking at a simple class that handles a car, including its
    speed and direction. A class is a very central feature in object-oriented languages.
    In C++, its specification is made up of two parts—its definition and implementation.
    The definition part is often placed in a header file (with the `.h` suffix), while
    the implementation part is placed in a file with the `.cpp` suffix, as in the `Car.h`
    and `Car.cpp` files. However, template classes, which are introduced in [Chapter
    3](6814bf19-e75b-4083-8447-892dd8416f49.xhtml), *Building a Library Management
    System*, are stored in one file only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看一个简单的类，它处理汽车的速度和方向。在面向对象的语言中，类是一个非常核心的特性。在 C++ 中，其规范由两部分组成——其定义和实现。定义部分通常放在一个带有
    `.h` 后缀的头文件中，而实现部分则放在一个带有 `.cpp` 后缀的文件中，例如 `Car.h` 和 `Car.cpp` 文件。然而，在 [第 3 章](6814bf19-e75b-4083-8447-892dd8416f49.xhtml)
    中引入的模板类，即 [构建图书馆管理系统](6814bf19-e75b-4083-8447-892dd8416f49.xhtml)，只存储在一个文件中。
- en: A class is made up of its members, where a member is a field or a method. A
    **field** holds a value of a specific type. A **method** is a mathematical abstraction
    that may take input values and return a value. The input values of a method are
    called parameters. However, in C++ it is possible to define a function without
    parameters and without return types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类由其成员组成，其中成员是一个字段或方法。**字段**保存特定类型的值。**方法**是一个数学抽象，可能需要输入值并返回一个值。方法输入值被称为参数。然而，在
    C++ 中，可以定义没有参数和没有返回类型的函数。
- en: 'An object is an instance of the class; we can create many objects of one class.
    The methods can be divided into the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是类的实例；我们可以创建一个类的多个对象。方法可以分为以下几类：
- en: '**Constructor**: A constructor is called when the object is created'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**: 当对象被创建时调用构造函数'
- en: '**Inspector**: An inspector inspects the fields of the class'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查员**: 检查员检查类的字段'
- en: '**Modificator**: A modificator modifies the values of the fields'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**: 修饰符修改字段的值'
- en: '**Destructor**: A destructor is called when the object is destroyed'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**析构函数**: 当对象被销毁时调用析构函数'
- en: 'Ideally, the methods of a class don''t give direct access to the fields, as
    this would mean that the method names/types would have to change if the fields
    change. Instead, the methods should give access to a class property. These are
    the conceptual elements of a class that may not map to a single field. Each member
    of the class is `public`, `protected`, or `private`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，类的成员方法不直接访问字段，因为这意味着如果字段发生变化，方法名称/类型也必须改变。相反，方法应该提供对类属性的访问。这些是类的概念元素，可能不映射到单个字段。类的每个成员都是`public`、`protected`或`private`：
- en: A `public` member is accessible by all other parts of the program.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`public`成员可以被程序的其他部分访问。
- en: A `protected` member is accessible only by its own members or members of its
    subclasses, which are introduced in the next section.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`protected`成员只能被其自身的成员或其子类的成员访问，这些将在下一节介绍。
- en: A `private` member is accessible by its own members only. However, that is not
    completely true. A class can invite other classes to become its friends, in which
    case they are given access to its `private` and `protected` members. We will look
    into friends in the next chapter.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`private`成员只能被其自身的成员访问。然而，这并不完全正确。一个类可以邀请其他类成为其友元，在这种情况下，它们被赋予了访问其`private`和`protected`成员的权限。我们将在下一章探讨友元。
- en: The following `Car` class definition has two constructors and one destructor.
    They always have the same name as the `Car` class in this case. The destructor
    is preceded by a tilde (`~`). A constructor without parameters is called the default
    constructor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Car`类的定义有两个构造函数和一个析构函数。在这种情况下，它们总是与`Car`类的名称相同。析构函数前面有一个波浪号（`~`）。没有参数的构造函数被称为默认构造函数。
- en: More than one method can have the same name, as long as they have different
    parameter lists, which is called **overloading**. More specifically, it is called
    context-free overloading. There is also context-dependent overloading, in which
    case two methods have the same name and parameter list, but different return types.
    However, context-dependent overloading is not supported by C++.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 只要方法具有不同的参数列表，就可以有多个具有相同名称的方法，这称为**重载**。更具体地说，它被称为无上下文重载。还有上下文相关重载，在这种情况下，两个方法具有相同的名称和参数列表，但返回类型不同。然而，C++不支持上下文相关重载。
- en: 'Consequently, a class can hold several constructors, as long as they have different
    parameter lists. However, the destructor is not allowed to have parameters. Therefore,
    a class can hold only one destructor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个类可以包含多个构造函数，只要它们的参数列表不同。然而，析构函数不允许有参数。因此，一个类只能包含一个析构函数：
- en: '**Car.h**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Car.h**'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `getSpeed` and `getDirection` methods are inspectors returning the current
    speed and direction of the car. The return values hold the `int` type, which is
    short for integer. They are marked as constant with the `const` keyword since
    they do not change the fields of the class. However, a constructor or destructor
    cannot be constant:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSpeed`和`getDirection`方法都是检查器，返回汽车当前的速度和方向。返回值持有`int`类型，即整数的缩写。由于它们不改变类的字段，因此它们被标记为常量，使用`const`关键字。然而，构造函数或析构函数不能是常量：'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `accelerate`, `decelerate`, `turnLeft`, and `turnRight` methods are modificators,
    setting the current speed and direction of the car. They cannot be marked as constant
    since they change the fields of the class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`accelerate`、`decelerate`、`turnLeft`和`turnRight`方法都是修改器，用于设置汽车当前的速度和方向。由于它们改变类的字段，因此不能标记为常量：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `m_speed` and `m_direction` fields hold the current speed and direction
    of the car. The `-m prefix` indicates that they are members of a class, as opposed
    to fields local to a method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_speed`和`m_direction`字段持有汽车当前的速度和方向。`-m`前缀表示它们是类的成员，而不是方法局部字段：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the implementation file, we must include the `Car.h` header file. The `#include`
    directive is part of the preprocessor and simply causes the content of the `Car.h` file
    to be included in the file. In the previous section, we included system files
    with the angle bracket  characters (`<` and `>`). In this case, we include local
    files with quotes (`"`). The system include files (with angle brackets) include
    system code that are part of the language, while local include files (with quotes)
    include code that we write ourselves, as part of our project. Technically, the
    system include files are often included from a special directory in the file system,
    while the local include files are often included locally in the filesystem:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件中，我们必须包含`Car.h`头文件。`#include`指令是预处理程序的一部分，它只是简单地将`Car.h`文件的内容包含到文件中。在前面的一节中，我们使用尖括号字符(`<`和`>`)包含了系统文件。在这种情况下，我们使用引号包含本地文件。系统包含文件（带有尖括号）包含语言的一部分系统代码，而本地包含文件（带有引号）包含我们自己的代码，作为项目的一部分。技术上，系统包含文件通常从文件系统中的特殊目录中包含，而本地包含文件通常在文件系统中本地包含：
- en: '**Car.cpp**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Car.cpp**'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The default constructor initializes both `speed` and `direction` and set it
    to `0`. The colon (`:`) notation is used to initialize the fields. The text between
    two slashes (`//`) and the end of the line is called a line comment and is ignored:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数初始化`speed`和`direction`并将它们设置为`0`。冒号(`:`)符号用于初始化字段。在两个斜杠(`//`)和行尾之间的文本被称为行注释，会被忽略：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second constructor initializes both `speed` and `direction` to the given
    parameter values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数初始化`speed`和`direction`为给定的参数值：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding constructors, it would be possible to use the assignment operator
    (`=`) instead of the class initialization notation, as in the following code.
    However, that is considered to be inefficient since the code may be optimized
    with the preceding initialization notation. Note that we use one equals sign (`=`)
    for assignments. For the comparison of two values, we use two equals signs (`==`),
    a method which is introduced in [Chapter 2](856debf4-f653-4211-928d-b3296fe56d99.xhtml), *Data
    Structures and Algorithms*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的构造函数中，可以使用赋值运算符(`=`)而不是类初始化符号，就像以下代码所示。然而，这被认为是不高效的，因为代码可以通过前面的初始化符号进行优化。注意，我们使用一个等号(`=`)进行赋值。对于两个值的比较，我们使用两个等号(`==`)，这是一种在[第2章](856debf4-f653-4211-928d-b3296fe56d99.xhtml)中引入的方法，*数据结构和算法*：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The destructor does nothing in this class; it is included only for the sake
    of completeness:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，析构函数不做任何事情；它只为了完整性而包含：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `getSpeed` and `getDirection` methods simply return the current speed and
    direction of the car:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSpeed`和`getDirection`方法只是简单地返回汽车当前的速度和方向：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A plus sign directly followed by an equals sign is called **compound assignment**
    and causes the right value to be added to the left value. In the same way, a minus
    sign directly followed by an equals sign causes the right value to be subtracted
    from the left value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个加号直接跟在等号后面被称为**复合赋值**，它会导致右边的值加到左边的值上。同样，一个减号直接跟在等号后面会导致右边的值从左边的值中减去。
- en: 'The text between a slash (`/`) directly followed by an asterisk (`*`), and
    an asterisk directly followed by a slash, is called a **block comment** and is
    ignored:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个斜杠(`/`)直接跟在一个星号(`*`)之后，以及一个星号直接跟在一个斜杠之后之间的文本被称为**块注释**，会被忽略：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now it is time to test our class. To do so, we include the `Car.h` file, just
    as we did in the `Car.cpp` file. However, we also include the system `IOStream` header
    file. As in the previous section, the system headers are enclosed in arrow brackets
    (`<` and `>`). We also need to use the `namespace std` to use its functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们的类了。为此，我们需要包含`Car.h`文件，就像我们在`Car.cpp`文件中所做的那样。然而，我们还需要包含系统`IOStream`头文件。与前面的章节一样，系统头文件被括在箭头括号(`<`和`>`)中。我们还需要使用`namespace
    std`来使用其功能。
- en: '**Main.cpp**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In C++, a function can be a part of a class or can be free-standing without
    a class. Functions of a class are often called methods. A function is a mathematical
    abstraction. It has input values, which are called parameters, and returns a value.
    However, in C++ a function is allowed to have zero parameters, and it may return
    the special type void, indicating that it does not return a value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个函数可以是类的一部分，也可以是独立于类的。类的函数通常被称为方法。函数是一个数学抽象。它有输入值，这些值被称为参数，并返回一个值。然而，在C++中，一个函数允许没有参数，并且它可以返回特殊类型void，表示它不返回值。
- en: As mentioned in the previous section, the execution of the program always starts
    at the function named `main`, and every program must have exactly one function
    named `main`. Unlike some other languages, it is not necessary to name the file
    `Main`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，程序的执行总是从名为`main`的函数开始，每个程序必须恰好有一个名为`main`的函数。与某些其他语言不同，没有必要将文件命名为`Main`。
- en: 'However, in this book, every file holding the `main` function is named `Main.cpp`
    out of convenience. The `void` keyword indicates that `main` does not return a
    value. Note that while constructors and destructors never return values, and are
    not marked with `void`, other methods and functions that do not return values
    must be marked with `void`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这本书中，出于方便起见，每个包含`main`函数的文件都命名为`Main.cpp`。`void`关键字表示`main`不返回值。请注意，虽然构造函数和析构函数从不返回值，且不标记为`void`，但其他不返回值的函数和方法必须标记为`void`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We create an object of the `Car` class that we call `redVolvo`. An object is
    an instance of the class; `redVolvo` is one of many cars:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`redVolvo`的`Car`类对象。对象是类的实例；`redVolvo`是众多汽车之一：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When writing information, we use the `cout` object (short for console output),
    which normally writes to a text window. The operator made up of two left arrow
    brackets (`<<`) is called the output stream operator. The `endl` directive makes
    the next output start at the beginning of the next line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写信息时，我们使用`cout`对象（代表控制台输出），它通常写入一个文本窗口。由两个左尖括号(`<<`)组成的操作符被称为输出流操作符。`endl`指令使得下一个输出从下一行的开头开始：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A `blueFiat` object is a constant object of the `Car` class. This means that
    it can only be initialized by one of the constructors and then inspected, but
    not modified. More specifically, only constant methods can be called on a constant
    object, and only methods that do not modify the fields of the object can be constant:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`blueFiat`对象是`Car`类的常量对象。这意味着它只能通过其中一个构造函数进行初始化，然后进行检查，但不能修改。更具体地说，只有常量方法可以在常量对象上调用，并且只有不修改对象字段的那些方法可以是常量：'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we execute the code, the output is displayed in a command window:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，输出显示在命令窗口中：
- en: '![](img/01041d1d-7233-4864-95f8-a124b9836463.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01041d1d-7233-4864-95f8-a124b9836463.png)'
- en: Extending the Car class
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展`Car`类
- en: In this section, we modify the `Car` class. In the earlier version, we initialized
    the fields in the constructors. An alternative way to initialize the fields is
    to initialize them directly in the class definition. However, this feature shall
    be used with care since it may result in unnecessary initializations. If the second
    constructor in the `Car` class is called, the fields are initialized twice, which
    is ineffective.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们修改了`Car`类。在早期版本中，我们在构造函数中初始化了字段。初始化字段的一个替代方法是直接在类定义中初始化它们。然而，这个特性应该谨慎使用，因为它可能会导致不必要的初始化。如果调用`Car`类的第二个构造函数，字段会被初始化两次，这是无效的。
- en: '**Car.h**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Car.h**'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While the `Car` class is defined in the `Car.h` file, its methods are defined
    in the `Car.cpp` file. Note that we begin by including the `Car.h` file, in order
    for the definitions of the methods to comply with their declaration in `Car.h`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Car`类定义在`Car.h`文件中，但其方法定义在`Car.cpp`文件中。请注意，我们首先包含`Car.h`文件，以便方法的定义符合其在`Car.h`中的声明：
- en: '**Car.cpp**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Car.cpp**'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Moreover, the `Car` class of the previous section has some limitations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前节中的`Car`类有一些局限性：
- en: It is possible to accelerate the car indefinitely, and it is possible to decelerate
    the car to a negative speed
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以无限加速汽车，也可以减速汽车到负速度
- en: It is possible to turn the car so that the direction is negative or more than
    360 degrees
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将汽车转向，使其方向为负或超过360度
- en: Let's start by setting the maximum speed of the car to `200` miles/hour. If
    the speed exceeds `200` miles per hour we set it to `200` miles/hour. We use the
    `if` statement, which takes a condition, and executes the following statement
    if the condition is true. In the case here, the statement `(m_speed = 200;)` is
    enclosed by brackets. This is not necessary since it is only one statement. However,
    it would be necessary in the case of more than one statement. In this book, we
    always use the brackets for clarity, regardless of the number of statements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将汽车的最高速度设置为`200`英里/小时。如果速度超过`200`英里/小时，我们将它设置为`200`英里/小时。我们使用`if`语句，它接受一个条件，如果条件为真，则执行以下语句。在这种情况下，语句`(m_speed
    = 200;)`被括号包围。这并不是必需的，因为它只包含一个语句。然而，如果有多个语句，则这是必需的。在这本书中，我们总是为了清晰起见使用括号，无论语句的数量多少。
- en: '**Car.cpp**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Car.cpp**'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the speed becomes negative, we change the sign of the speed to make it positive.
    Note that we cannot write `m_speed -= m_speed`. That would set the speed to zero
    since it would subtract the speed from itself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度变为负数，我们改变速度的符号使其变为正数。请注意，我们不能写`m_speed -= m_speed`。那样会将速度设置为零，因为它会从自身减去速度。
- en: Since the value is negative, it becomes positive when we change the sign. We
    also turn the car by `180` degrees to change its direction. Note that we also,
    in this case, must check that the car does not exceed the speed limit.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值是负数，当我们改变符号时，它变为正数。我们还通过旋转`180`度来改变汽车的方向。请注意，在这种情况下，我们也必须检查汽车是否超过速度限制。
- en: 'Also, note that we must check whether the direction is less than 180 degrees.
    If it is, we add `180` degrees; otherwise, we subtract `180` degrees to keep the
    direction in the interval `0` to `360` degrees. We use the `if...else` statement
    to do that. If the condition of the `if` statement is not true, the statement
    after the `else` keyword is executed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们必须检查方向是否小于180度。如果是，我们加上`180`度；否则，我们减去`180`度以保持方向在`0`到`360`度的区间内。我们使用`if...else`语句来完成这个操作。如果`if`语句的条件不为真，则执行`else`关键字后的语句：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When turning the car, we use the modulo (`%`), operator. When dividing by `360`,
    the modulo operator gives the remainder of the division. For instance, when 370
    is divided by `360` the remainder is 10:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当转向汽车时，我们使用取模（`%`）运算符。当除以`360`时，取模运算符给出除法的余数。例如，当`370`除以`360`时，余数是`10`：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `main` function creates one object of the `Car` class—`redVolvo`. We start
    by writing its speed and direction, then we accelerate and turn left and again
    write its speed and acceleration. Finally, we decelerate and turn right and write
    its speed and direction one last time:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建了一个`Car`类的对象——`redVolvo`。我们首先写下它的速度和方向，然后加速并向左转，再次写下它的速度和加速度。最后，我们减速并向右转，最后一次写下它的速度和方向：'
- en: '**Main.cpp**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we execute the code, the output is displayed in a command window as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，输出将如下显示在命令窗口中：
- en: '![](img/c4ae7e52-8fdf-4251-80bd-1de8d8b555ee.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4ae7e52-8fdf-4251-80bd-1de8d8b555ee.png)'
- en: A class hierarchy – the Person, Student, and Employee classes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类层次结构——Person、Student和Employee类
- en: 'Let''s continue with a class hierarchy, where `Person` is the base class with
    `Student` and `Employee` as its subclasses:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用类层次结构，其中`Person`是基类，`Student`和`Employee`是其子类：
- en: '![](img/9bedb9c8-d793-4af2-9526-82118247b200.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bedb9c8-d793-4af2-9526-82118247b200.png)'
- en: 'As a person has a name, we use the C++ standard class string to store the name.
    The `virtual` keyword marks that the `print` method is subject to dynamic binding,
    which we will look into later in this section:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人有一个名字一样，我们使用C++标准库中的`string`类来存储名字。`virtual`关键字标记了`print`方法受动态绑定的影响，我们将在本节稍后探讨这一点：
- en: '**Person.h**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Person.h**'
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We include the `String` header, which allows us to use the `string` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`String`头文件，这允许我们使用`string`类：
- en: '**Person.cpp**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Person.cpp**'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Student` and `Employee` classes are subclasses of `Person`, and they inherit
    `Person` publicly. Sometimes the term extension is used instead of inheritance.
    The inheritance can be `public`, `protected`, or `private`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`和`Employee`类是`Person`的子类，并且以`public`方式继承`Person`。有时术语扩展代替继承。继承可以是`public`、`protected`或`private`：'
- en: With `public` inheritance, all members of the base class have the same access
    to the subclass
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`public`继承中，基类的所有成员在子类中都有相同的访问权限
- en: With `protected` inheritance, all `public` members of the base class become
    protected in the subclass
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`protected`继承中，基类的所有`public`成员在子类中变为`protected`
- en: With `private` inheritance, all `public` and `protected` members of the base
    class become private in the subclass
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在私有继承中，基类的所有 `public` 和 `protected` 成员在子类中变为私有。
- en: 'The `Student` and `Employee` classes have the text fields `m_university` and
    `m_company`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student` 和 `Employee` 类具有文本字段 `m_university` 和 `m_company`：'
- en: '**Student.h**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Student.h**'
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The file `Student.cpp` defines the methods of the `Student` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `Student.cpp` 定义了 `Student` 类的方法：
- en: '**Student.cpp**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Student.cpp**'
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The subclass can call a constructor of the base class by stating its `name`
    with the colon notation (`:`). The constructor of `Student` calls the constructor
    of `Person` with the name as a parameter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以通过使用冒号表示法 (`:`) 来指定其 `name` 来调用基类的构造函数。`Student` 的构造函数使用参数 `name` 调用 `Person`
    的构造函数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We must state that we call `print` in `Person` rather than `Student` by using
    the double colon notation (`::`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须声明，我们通过使用双冒号表示法 (`::`) 在 `Person` 而不是 `Student` 中调用 `print`：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Employee` class is similar to `Student`. However, it holds the field `c_company` instead
    of `m_university`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee` 类与 `Student` 类类似。然而，它持有字段 `c_company` 而不是 `m_university`。'
- en: '**Employee.h**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Employee.h**'
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The file `Employee.cpp` defines the methods of the `Employee` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `Employee.cpp` 定义了 `Employee` 类的方法。
- en: '**Employee.cpp**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Employee.cpp**'
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The constructor initializes the name of the person and the company they are
    employed by:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化人员的姓名和他们受雇的公司：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, the `main` function starts by including the system header files `String`
    and `IOStream`, which hold declarations about string handling and input and output
    streams. Since all standard headers are included in the standard namespace, we
    gain access to the system declaration with the `using` the `namespace` directive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数首先包含系统头文件 `String` 和 `IOStream`，它们包含有关字符串处理和输入输出流的声明。由于所有标准头文件都包含在标准命名空间中，我们可以通过使用
    `using` 命令来访问系统声明。
- en: '**Main.cpp**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We define the three objects, `Monica`, `Demi`, and `Charles`, and we call `print`
    on each of them. In all three cases the `print` method of the class `Person`,
    `Student`, and `Employee` is called:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个对象，`Monica`、`Demi` 和 `Charles`，并且对它们中的每一个都调用了 `print` 方法。在所有三种情况下，都调用了
    `Person`、`Student` 和 `Employee` 类的 `print` 方法：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The asterisk (`*`) marks that `personPtr` is a pointer to an object of `Person`,
    rather than an object of `Person`. A pointer to an object holds the memory address
    of the object, rather than the object itself. However, at the moment it does not
    hold any address at all. We will soon assign it to the address of an object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 星号 (`*`) 标记 `personPtr` 是指向 `Person` 对象的指针，而不是 `Person` 对象本身。指针持有对象的内存地址，而不是对象本身。然而，目前它并没有持有任何地址。我们很快就会将它分配给一个对象的地址：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The ampersand (`&`) is an operator that provides the address of an object, which
    is assigned to the pointer `personPtr`. We assign `personPtr` in turn to the addresses
    of the `Person`, `Student`, and `Employee` objects and call `print` in each case.
    As `print` is marked as virtual in `Person`, `print`, in the class of the object
    the pointer currently points at, is called. Since `print` is marked as virtual
    in the base class `Person`, it is not necessary to mark `print` as virtual in
    the subclasses `Student` and `Employee`. When accessing a member of a pointer
    to an object, we use the arrow (`->`) operator instead of the point operator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 是一个操作符，它提供对象的地址，该地址被分配给指针 `personPtr`。我们依次将 `personPtr` 分配给 `Person`、`Student`
    和 `Employee` 对象的地址，并在每种情况下调用 `print`。由于 `print` 在 `Person` 中被标记为虚拟的，因此调用当前指针指向的对象类的
    `print`。由于 `print` 在基类 `Person` 中被标记为虚拟的，因此不需要在子类 `Student` 和 `Employee` 中将 `print`
    标记为虚拟。在访问对象指针的成员时，我们使用箭头 (`->`) 操作符而不是点操作符。'
- en: 'When `personPtr` points at an object of `Person`, print in `Person` is called:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `personPtr` 指向 `Person` 对象时，调用 `Person` 中的 `print`：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When `personPtr` points at an object of `Student`, `print` in `Student` is
    called:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `personPtr` 指向 `Student` 对象时，调用 `Student` 中的 `print`：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When `personPtr` points at an object of `Employee`, print `Employee` is called:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `personPtr` 指向 `Employee` 对象时，调用 `Employee` 中的 `print`：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This process is called dynamic binding. If we omit the virtual marking in `Person`,
    static binding would occur and print in `Person` would be called in all cases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程称为动态绑定。如果我们省略 `Person` 中的虚拟标记，则会发生静态绑定，并且所有情况下都会调用 `Person` 中的 `print`。
- en: The concept of object-oriented programming is built on the three cornerstones
    of encapsulation, inheritance, and dynamic binding. A language that does not support
    any of these features cannot be called object-oriented.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的概念建立在封装、继承和动态绑定这三个基石之上。不支持这些特性的语言不能被称为面向对象的语言。
- en: A simple data type – the stack
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的数据类型——栈
- en: A **stack** is a simple data type where we add values to the top, remove the
    value on the top, and can only inspect the top value. In this section, we implement
    a stack of integers. In the next chapter, we look into template classes that can
    hold values of arbitrary types. We use a linked list, which is a construction
    where a pointer points at the first cell in the linked list, and each cell holds
    a pointer to the next cell in the linked list. Naturally, the linked list must
    end eventually. We use `nullptr` to mark the end of the linked list, which is
    a C++ standard pointer to a special null address.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种简单的数据类型，我们可以在顶部添加值，移除顶部的值，并且只能检查顶部值。在本节中，我们实现了一个整数栈。在下一章中，我们将探讨可以持有任意类型值的模板类。我们使用链表，这是一种结构，其中指针指向链表中的第一个单元格，每个单元格都持有指向链表中下一个单元格的指针。自然地，链表必须最终结束。我们使用`nullptr`来标记链表的结束，它是C++标准指向特殊空地址的指针。
- en: To begin with, we need a class to hold each cell of the linked list. The cell
    holds an integer value and a pointer to the next cell in the list, or `nullptr`
    if it is the last cell of the list. In the following section, we will look into
    cell classes that hold pointers to both the previous and the next cell.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个类来保存链表中的每个单元格。单元格包含一个整数值和指向列表中下一个单元格的指针，或者如果它是列表的最后一个单元格，则为`nullptr`。在下一节中，我们将探讨同时持有前一个和下一个单元格指针的单元格类。
- en: '**Cell.h**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.h**'
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It is possible to implement methods directly in the class definition; they
    are called inline methods. However, it is usually done for short methods only.
    A rule of thumb is that inline methods shall not exceed one line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接在类定义中实现方法；它们被称为内联方法。然而，这通常只用于短方法。一个经验法则是内联方法不应超过一行：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Each cell holds a value and the address of the next cell in the linked list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格都持有一个值和链表中下一个单元格的地址：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Cell.h**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.h**'
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A cell is initialized with a value and a pointer to the next cell in the linked
    list. Note that `m_next` has the value `nullptr` if the cell is the last cell
    in the linked list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单元格通过一个值和一个指向链表下一个单元格的指针来初始化。注意，如果单元格是链表中的最后一个单元格，则`m_next`的值为`nullptr`：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In a stack, we are in interested in its top value only. The default constructor
    initializes the stack to be empty. Push adds a value at the top of the stack,
    top returns the top value, pop removes the top value, size returns the number
    of values in the stack, and empty returns `true` if the stack is empty. The bool
    type is a logical type that can hold the values `true` or `false`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中，我们只对它的顶部值感兴趣。默认构造函数将栈初始化为空。压栈在栈顶添加一个值，顶部返回顶部值，弹出移除顶部值，大小返回栈中的值的数量，如果栈为空，则返回`true`。布尔类型是一种逻辑类型，可以持有`true`或`false`的值。
- en: '**Stack.h**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stack.h**'
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `m_firstCellPtr` field is a pointer to the first cell of the linked list
    holding the values of the stack. When the stack is empty, `m_firstCellPtr` will
    hold the value `nullptr`. The `m_size` field holds the current size of the stack:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_firstCellPtr`字段是指向包含栈值的链表第一个单元格的指针。当栈为空时，`m_firstCellPtr`将持有值`nullptr`。`m_size`字段持有栈的当前大小：'
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `CAssert` header is included for the assert macro, which is used to test
    whether certain conditions are true. A macro is part of the preprocessor that
    performs certain text replacements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了`CAssert`头文件，用于assert宏，该宏用于测试某些条件是否为真。宏是预处理器的组成部分，它执行某些文本替换。
- en: '**Stack.cpp**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stack.cpp**'
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The default constructor sets the stack to empty by initializing the pointer
    to the first cell to `nullptr` and the size to zero:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数通过将指向第一个单元格的指针初始化为`nullptr`并将大小设置为零来将栈设置为空：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When pushing a new value at the top of the stack, we use the new operator to
    dynamically allocate the memory needed for the cell. If we run out of memory,
    `nullptr` is returned, which is tested by the assert macro. If `m_firstCellPtr`
    equals `nullptr`, the execution is aborted with an error message. The exclamation
    mark (`!`) followed by an equals sign (`=`) constitutes the not-equal operator.
    Two plus signs (`++`) constitute the increments operator, which means that the
    value is increased by one.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当在栈顶压入新值时，我们使用新操作符动态分配单元格所需的内存。如果我们耗尽内存，则返回`nullptr`，这通过assert宏进行测试。如果`m_firstCellPtr`等于`nullptr`，则执行会因错误信息而终止。紧跟在等于号(`=`)后面的感叹号(`!`)构成了不等于操作符。两个加号(`++`)构成了增量操作符，意味着值增加一。
- en: 'The increment operator actually comes in two versions—prefix (`++m_size`) and
    postfix (`m_size++`). In the prefix case, the value is first increased and then
    returned, while in the postfix case the value is increased but the original value
    is returned. However, in this case, it does not matter which version we use since
    we are only interested in the result—that the value of `m_size` is increased by
    one:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 增量操作符实际上有两种版本——前缀(`++m_size`)和后缀(`m_size++`)。在前缀情况下，值首先增加然后返回，而在后缀情况下，值增加但返回原始值。然而，在这种情况下，我们使用哪个版本都无关紧要，因为我们只对结果感兴趣——即`m_size`的值增加一：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When returning the top value of the stack, we must first check that the stack
    is not empty, since it would be illogical to return the top value of an empty
    stack. If the stack is empty, the execution is aborted with an error message.
    The single exclamation mark (`!`) is the logical `not` operator. We return the
    top value, which is stored in the first cell in the linked list:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回栈顶值时，我们必须首先检查栈是否为空，因为返回空栈的顶部值是不合逻辑的。如果栈为空，则执行会因错误信息而终止。单个感叹号(`!`)是逻辑非操作符。我们返回存储在链表第一个单元格中的顶部值：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We must also check that the stack is not empty when popping the top value of
    the stack. We set the pointer to the first cell in the linked list to point at
    the next cell. However, before that, we must store the first pointer, `deleteCellPtr`,
    in order to deallocate the memory of the cell it points at.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当弹出栈顶值时，我们也必须检查栈是否为空。我们将指向链表第一个单元格的指针设置为指向下一个单元格。然而，在那之前，我们必须存储第一个指针，`deleteCellPtr`，以便释放它所指向的单元格的内存。
- en: 'We deallocate the memory with the `delete` operator:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`delete`操作符释放内存：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the same way as the increment operator above, two minus signs (`--`) constitutes
    the `decrement` operator, which decreases the value by one:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面提到的增量操作符一样，两个减号(`--`)构成了`减量`操作符，它将值减一：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `size` method simply returns the value of the `m_size` field:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`方法简单地返回`m_size`字段的值：'
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A stack is empty if the pointer to the first cell pointer equals `nullptr`.
    Informally, we say that the pointer is null if it equals `nullptr`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指向第一个单元格指针的指针等于`nullptr`，则栈为空。非正式地说，如果它等于`nullptr`，则指针为空：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We test the stack by pushing, topping, and popping some values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过压栈、查看顶部和弹出一些值来测试栈。
- en: '**Main.cpp**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When printing a Boolean value, the `stream` operator does not print `true`
    or `false`, but rather one for `true` and zero for `false`. In order to really
    print `true` or `false` we use the `condition` operator. It takes three values,
    separated by a question mark (`?`) and a colon (`:`). If the first value is `true`
    the second value is returned. If the first value is `false` the third value is
    returned:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印布尔值时，`stream`操作符不会打印`true`或`false`，而是为`true`打印一个值，为`false`打印零。为了真正打印`true`或`false`，我们使用条件操作符。它接受三个值，由问号(`?`)和冒号(`:`)分隔。如果第一个值是`true`，则返回第二个值。如果第一个值是`false`，则返回第三个值：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A more advanced data type – the queue
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的数据类型——队列
- en: A queue is a model of a traditional queue; we enter values at the rear, and
    inspect and remove values at the front. It is also possible to decide on the number
    of values it holds and whether it is empty.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个传统队列的模型；我们在队列的尾部输入值，并在队列的前端检查和移除值。还可以决定它所持有的值的数量以及它是否为空。
- en: 'Similar to the stack in the previous section, we implement the queue with a
    linked list. We reuse the `Cell` class; however, in the queue case, we need to
    set the next link of a cell. Therefore, we rename `next` to `getNext` and add
    the new `setNext` method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中的栈类似，我们使用链表来实现队列。我们重用`Cell`类；然而，在队列的情况下，我们需要设置一个单元格的下一个链接。因此，我们将`next`重命名为`getNext`并添加了新的`setNext`方法：
- en: '**Cell.h**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.h**'
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We implement the queue with a linked list in a manner similar to the stack.
    The constructor initializes an empty queue, `enter` enters a value at the rear
    of the queue, `remove` removes the value at its front, `size` return the current
    size of the queue, and `empty` returns `true` if it is empty:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似于栈的方式使用链表实现队列。构造函数初始化一个空队列，`enter` 方法在队列的末尾插入一个值，`remove` 方法从队列的前端删除一个值，`size`
    方法返回队列的当前大小，而 `empty` 方法如果队列为空则返回 `true`：
- en: '**Queue.h**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Queue.h**'
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the stack case, we were only interested in its top, which was stored at
    the beginning of the linked list. In the queue case, we are interested in both
    the front and rear, which means that we need to access both the first and last
    cell of the linked list. Therefore, we have the two pointers, `m_firstCellPtr`
    and `m_lastCellPtr`, pointing at the first and last cell in the linked list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈的情况下，我们只对它的顶部感兴趣，它存储在链表的开始处。在队列的情况下，我们既对前部也对后部感兴趣，这意味着我们需要访问链表的第一和最后一个单元格。因此，我们有两个指针，`m_firstCellPtr`
    和 `m_lastCellPtr`，分别指向链表中的第一个和最后一个单元格：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Queue.cpp**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Queue.cpp**'
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When the queue is created, it is empty; the pointers are null and the size
    is zero. Since there are no cells in the linked list, both the cell pointers points
    at `nullptr`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列被创建时，它是空的；指针是空的，大小为零。由于链表中没有单元格，两个单元格指针都指向 `nullptr`：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When entering a new value at the rear of the queue, we check if the queue is
    empty. If it is empty, both the pointers are set to point at the new cell. If
    it is not empty, the last cell next-pointer is set to point at the new cell, and
    then the last cell pointer is set to be the new cell:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当在队列的末尾输入新值时，我们检查队列是否为空。如果它是空的，两个指针都设置为指向新单元格。如果不为空，最后一个单元格的下一个指针设置为指向新单元格，然后最后一个单元格指针设置为指向新单元格：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first method simply returns the value of the first cell in the linked list:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法简单地返回链表中的第一个单元格的值：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `remove` method sets the first cell to point at the second cell. However,
    first we must store its address in order to deallocate its memory with the C++
    standard `delete` operator:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法将第一个单元格设置为指向第二个单元格。然而，首先我们必须存储它的地址，以便使用 C++ 标准的 `delete` 操作符来释放它的内存：'
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We test the queue by entering and removing a few values. We enter the values
    one, two, and three, which are placed in the queue in that order. We then remove
    the first two values, and enter the value four. Then the queue holds the values
    three and four:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过输入和删除一些值来测试队列。我们输入的值为一、二、三，这些值按照顺序放入队列中。然后我们删除前两个值，并输入值四。此时队列中包含的值为三和四：
- en: '**Main.cpp**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked into the basics of object-oriented programming.
    We have started by creating a project and executing a program for rolling a dice.
    We have also created a class hierarchy, including the base class `Person` and
    its two subclasses `Student` and `Employee`. By defining pointers to the objects,
    we have performed the dynamic binding.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了面向对象编程的基础。我们首先创建了一个项目并执行了一个掷骰子的程序。我们还创建了一个类层次结构，包括基类 `Person` 和它的两个子类
    `Student` 和 `Employee`。通过定义对象的指针，我们执行了动态绑定。
- en: Finally, we have created two data types—stack and queue. A stack is a structure
    where we are interested in the value at the top only. We can add values at the
    top, inspect the top value, and remove the top value. A queue is a traditional
    queue where we enter values at the rear while we inspect and remove values from
    the front.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了两种数据类型——栈和队列。栈是一种结构，我们只对顶部的值感兴趣。我们可以在顶部添加值，检查顶部值，并删除顶部值。队列是一种传统的队列，我们在后面输入值，同时在前面检查和删除值。
- en: In the next chapter, we will continue to create data types, and more advanced
    data types, such as lists and sets. We will also look into to more advanced features
    of C++.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续创建数据类型，以及更高级的数据类型，如列表和集合。我们还将探讨 C++ 的更多高级特性。
