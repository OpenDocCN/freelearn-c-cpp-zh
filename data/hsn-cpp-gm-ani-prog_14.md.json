["```cpp\nstruct DualQuaternion {\n\u00a0\u00a0\u00a0\u00a0union {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat real;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quat dual;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float v[8];\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0inline DualQuaternion() : real(0, 0, 0, 1), dual(0, 0, 0, 0) { }\n\u00a0\u00a0\u00a0\u00a0inline DualQuaternion(const quat& r, const quat& d) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0real(r), dual(d) { }\n};\n```", "```cpp\n    DualQuaternion operator+(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const DualQuaternion &r);\n    DualQuaternion operator*(const DualQuaternion &dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float f);\n    // Multiplication order is left to right\n    // This is the OPPOSITE of matrices and quaternions\n    DualQuaternion operator*(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const DualQuaternion &r);\n    bool operator==(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion &r);\n    bool operator!=(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion &r);\n    ```", "```cpp\n    DualQuaternion operator+(const DualQuaternion &l,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion &r) {\n    \u00a0\u00a0 return DualQuaternion(l.real+r.real,l.dual+r.dual);\n    }\n    DualQuaternion operator*(const DualQuaternion &dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 float f) {\n    \u00a0\u00a0\u00a0\u00a0return DualQuaternion(dq.real * f, dq.dual * f);\n    }\n    bool operator==(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion &r) {\n    \u00a0\u00a0\u00a0\u00a0return l.real == r.real && l.dual == r.dual;\n    }\n    bool operator!=(const DualQuaternion &l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion &r) {\n    \u00a0\u00a0\u00a0\u00a0return l.real != r.real || l.dual != r.dual;\n    }\n    ```", "```cpp\n    // Remember, multiplication order is left to right. \n    // This is the opposite of matrix and quaternion \n    // multiplication order\n    DualQuaternion operator*(const DualQuaternion &l, const DualQuaternion &r) {\n    \u00a0\u00a0\u00a0\u00a0DualQuaternion lhs = normalized(l);\n    \u00a0\u00a0\u00a0\u00a0DualQuaternion rhs = normalized(r);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0return DualQuaternion(lhs.real * rhs.real, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lhs.real * rhs.dual + \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lhs.dual * rhs.real);\n    }\n    ```", "```cpp\n    float dot(const DualQuaternion& l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion& r);\n    DualQuaternion conjugate(const DualQuaternion& dq);\n    DualQuaternion normalized(const DualQuaternion& dq);\n    void normalize(DualQuaternion& dq);\n    ```", "```cpp\n    float dot(const DualQuaternion& l, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const DualQuaternion& r) {\n    \u00a0\u00a0\u00a0\u00a0return dot(l.real, r.real);\n    }\n    ```", "```cpp\n    DualQuaternion conjugate(const DualQuaternion& dq) {\n    \u00a0\u00a0\u00a0\u00a0return DualQuaternion(conjugate(dq.real), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0conjugate(dq.dual));\n    }\n    ```", "```cpp\n    DualQuaternion normalized(const DualQuaternion& dq) {\n    \u00a0\u00a0\u00a0\u00a0float magSq = dot(dq.real, dq.real);\n    \u00a0\u00a0\u00a0\u00a0if (magSq\u00a0\u00a0< 0.000001f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return DualQuaternion();\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0float invMag = 1.0f / sqrtf(magSq);\n    \u00a0\u00a0\u00a0\u00a0return DualQuaternion(dq.real * invMag, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dq.dual * invMag);\n    }\n    ```", "```cpp\n    void normalize(DualQuaternion& dq) {\n    \u00a0\u00a0\u00a0\u00a0float magSq = dot(dq.real, dq.real);\n    \u00a0\u00a0\u00a0\u00a0if (magSq\u00a0\u00a0< 0.000001f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0float invMag = 1.0f / sqrtf(magSq);\n    \u00a0\u00a0\u00a0\u00a0dq.real = dq.real * invMag;\n    \u00a0\u00a0\u00a0\u00a0dq.dual = dq.dual * invMag;\n    }\n    ```", "```cpp\n    DualQuaternion transformToDualQuat(const Transform& t);\n    Transform dualQuatToTransform(const DualQuaternion& dq);\n    ```", "```cpp\n    DualQuaternion transformToDualQuat(const Transform& t) {\n    \u00a0\u00a0\u00a0\u00a0quat d(t.position.x, t.position.y, t.position.z, 0);\n    \u00a0\u00a0\u00a0\u00a0quat qr = t.rotation;\n    \u00a0\u00a0\u00a0\u00a0quat qd = qr * d * 0.5f;\n    \u00a0\u00a0\u00a0\u00a0return DualQuaternion(qr, qd);\n    }\n    ```", "```cpp\n    Transform dualQuatToTransform(const DualQuaternion& dq){\n    \u00a0\u00a0\u00a0\u00a0Transform result;\n    \u00a0\u00a0\u00a0\u00a0result.rotation = dq.real;\n    \u00a0\u00a0\u00a0\u00a0quat d = conjugate(dq.real) * (dq.dual * 2.0f);\n    \u00a0\u00a0\u00a0\u00a0result.position = vec3(d.x, d.y, d.z);\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    vec3 transformVector(const DualQuaternion& dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const vec3& v);\n    vec3 transformPoint(const DualQuaternion& dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const vec3& v);\n    ```", "```cpp\n    vec3 transformVector(const DualQuaternion& dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const vec3& v) {\n    \u00a0\u00a0\u00a0\u00a0return dq.real * v;\n    }\n    ```", "```cpp\n    vec3 transformPoint(const DualQuaternion& dq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const vec3& v) {\n    \u00a0\u00a0\u00a0\u00a0quat d = conjugate(dq.real) * (dq.dual * 2.0f);\n    \u00a0\u00a0\u00a0\u00a0vec3 t = vec3(d.x, d.y, d.z);\n    \u00a0\u00a0\u00a0\u00a0return dq.real * v + t;\n    }\n    ```", "```cpp\nmat4 skin;\nskin\u00a0\u00a0= (pose[joints.x] * invBindPose[joints.x]) * weights.x;\nskin += (pose[joints.y] * invBindPose[joints.y]) * weights.y;\nskin += (pose[joints.z] * invBindPose[joints.z]) * weights.z;\nskin += (pose[joints.w] * invBindPose[joints.w]) * weights.w;\n```", "```cpp\n    class Pose {\n    // Existing functions and interface\n    public: // NEW\n    void GetDualQuaternionPalette(vector<DualQuaternion>& o);\n    DualQuaternion GetGlobalDualQuaternion(unsigned int i); \n    };\n    ```", "```cpp\n    DualQuaternion Pose::GetGlobalDualQuaternion(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0DualQuaternion result = transformToDualQuat(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mJoints[index]);\n    \u00a0\u00a0\u00a0\u00a0for (int p = mParents[index]; p >= 0; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 p = mParents[p]) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DualQuaternion parent = transformToDualQuat(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mJoints[p]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Remember, multiplication is in reverse!\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result * parent;\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    void Pose::GetDualQuaternionPalette(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 vector<DualQuaternion>& out) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (out.size() != size) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out.resize(size);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out[i] = GetGlobalDualQuaternion(i);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    class Skeleton {\n    // Existing functions and interface\n    public: // GetInvBindPose is new\n    \u00a0\u00a0\u00a0\u00a0void GetInvBindPose(vector<DualQuaternion>& pose);\n    };\n    ```", "```cpp\n    void Skeleton::GetInvBindPose(std::vector<DualQuaternion>& \n    \u00a0\u00a0\u00a0\u00a0outInvBndPose) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = mBindPose.Size();\n    \u00a0\u00a0\u00a0\u00a0outInvBndPose.resize(size);\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DualQuaternion world = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mBindPose.GetGlobalDualQuaternion(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0outInvBndPose[i] = conjugate(world);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\ntemplate Uniform<DualQuaternion>;\ntemplate<>\nvoid Uniform<DualQuaternion>::Set(unsigned int slot, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DualQuaternion* inputArray, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int arrayLength) {\n\u00a0\u00a0\u00a0\u00a0glUniformMatrix2x4fv(slot, arrayLength, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 false, inputArray[0].v);\n}\n```", "```cpp\n    #version 330 core\n    uniform mat4 model;\n    uniform mat4 view;\n    uniform mat4 projection;\n    ```", "```cpp\n    in vec3 position;\n    in vec3 normal;\n    in vec2 texCoord;\n    in vec4 weights;\n    in ivec4 joints;\n    ```", "```cpp\n    out vec3 norm;\n    out vec3 fragPos;\n    out vec2 uv;\n    ```", "```cpp\n    uniform mat2x4 pose[120];\n    uniform mat2x4 invBindPose[120];\n    ```", "```cpp\n    vec4 mulQ(vec4 Q1, vec4 Q2) {\n    \u00a0\u00a0\u00a0\u00a0return vec4(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q2.x*Q1.w + Q2.y*Q1.z - Q2.z*Q1.y + Q2.w*Q1.x,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Q2.x*Q1.z + Q2.y*Q1.w + Q2.z*Q1.x + Q2.w*Q1.y,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q2.x*Q1.y - Q2.y*Q1.x + Q2.z*Q1.w + Q2.w*Q1.z,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -Q2.x*Q1.x - Q2.y*Q1.y - Q2.z*Q1.z + Q2.w*Q1.w\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    mat2x4 normalizeDq(mat2x4 dq) {\n    \u00a0\u00a0\u00a0\u00a0float invMag = 1.0 / length(dq[0]);\n    \u00a0\u00a0\u00a0\u00a0dq[0] *= invMag;\n    \u00a0\u00a0\u00a0\u00a0dq[1] *= invMag;\n    \u00a0\u00a0\u00a0\u00a0return dq;\n    }\n    ```", "```cpp\n    mat2x4 combineDq(mat2x4 l, mat2x4 r) {\n    \u00a0\u00a0\u00a0\u00a0l = normalizeDq(l);\n    \u00a0\u00a0\u00a0\u00a0r = normalizeDq(r);\n    \u00a0\u00a0\u00a0\u00a0vec4 real = mulQ(l[0], r[0]);\n    \u00a0\u00a0\u00a0\u00a0vec4 dual = mulQ(l[0], r[1]) + mulQ(l[1], r[0]);\n    \u00a0\u00a0\u00a0\u00a0return mat2x4(real, dual);\n    }\n    ```", "```cpp\n    vec4 transformVector(mat2x4 dq, vec3 v) {\n    \u00a0\u00a0vec4 real = dq[0];\n    \u00a0\u00a0vec3 r_vector = real.xyz;\n    \u00a0\u00a0float r_scalar = real.w;\n\n    \u00a0\u00a0vec3 rotated = r_vector * 2.0f * dot(r_vector, v) +\n    \u00a0\u00a0 v * (r_scalar * r_scalar - dot(r_vector, r_vector))+\n    \u00a0\u00a0 cross(r_vector, v) * 2.0f * r_scalar;\n    \u00a0\u00a0return vec4(rotated, 0);\n    }\n    ```", "```cpp\n    vec4 transformPoint(mat2x4 dq, vec3 v) {\n    \u00a0\u00a0\u00a0\u00a0vec4 real = dq[0];\n    \u00a0\u00a0\u00a0\u00a0vec4 dual = dq[1];\n    \u00a0\u00a0\u00a0\u00a0vec3 rotated = transformVector(dq, v).xyz;\n    \u00a0\u00a0\u00a0\u00a0vec4 conjugate = vec4(-real.xyz, real.w);\n    \u00a0\u00a0\u00a0\u00a0vec3 t = mulQ(conjugate, dual * 2.0).xyz;\n\n    \u00a0\u00a0\u00a0\u00a0return vec4(rotated + t, 1);\n    }\n    ```", "```cpp\n    void main() {\n    \u00a0\u00a0\u00a0\u00a0vec4 w = weights;\n    \u00a0\u00a0\u00a0\u00a0// Neighborhood all of the quaternions correctly\n    \u00a0\u00a0\u00a0\u00a0if (dot(pose[joints.x][0], pose[joints.y][0]) < 0.0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { w.y *= -1.0; }\n    \u00a0\u00a0\u00a0\u00a0if (dot(pose[joints.x][0], pose[joints.z][0]) < 0.0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { w.z *= -1.0; }\n    \u00a0\u00a0\u00a0\u00a0if (dot(pose[joints.x][0], pose[joints.w][0]) < 0.0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { w.w *= -1.0; }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0// Combine\n    \u00a0\u00a0\u00a0\u00a0mat2x4 dq0 = combineDq(invBindPose[joints.x], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pose[joints.x]);\n    \u00a0\u00a0\u00a0\u00a0mat2x4 dq1 = combineDq(invBindPose[joints.y], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pose[joints.y]);\n    \u00a0\u00a0\u00a0\u00a0mat2x4 dq2 = combineDq(invBindPose[joints.z], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pose[joints.z]);\n    \u00a0\u00a0\u00a0\u00a0mat2x4 dq3 = combineDq(invBindPose[joints.w], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 pose[joints.w]);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0mat2x4 skinDq = w.x * dq0 + w.y * dq1 + \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w.z * dq2 + w.w * dq3;\n    \u00a0\u00a0\u00a0\u00a0skinDq = normalizeDq(skinDq);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vec4 v = transformPoint(skinDq, position);\n    \u00a0\u00a0\u00a0\u00a0gl_Position = projection * view * model * v;\n    \u00a0\u00a0\u00a0\u00a0fragPos = vec3(model * v);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vec4 n = transformVector(skinDq, normal);\n    \u00a0\u00a0\u00a0\u00a0norm = vec3(model * n);\n    \u00a0\u00a0\u00a0\u00a0uv = texCoord;\n    }\n    ```", "```cpp\n// For dual quaternion skinning\nstd::vector<DualQuaternion> mDqPosePalette;\nstd::vector<DualQuaternion> mDqInvBindPalette;\n// For linear blend skinning\nstd::vector<mat4> mLbPosePalette;\nstd::vector<mat4> mLbInvBindPalette;\n```", "```cpp\nmCurrentPose = mSkeleton.GetRestPose();\nmCurrentPose.GetDualQuaternionPalette(mDqPosePalette);\nmSkeleton.GetInvBindPose(mDqInvBindPalette);\nmCurrentPose.GetMatrixPalette(mLbPosePalette);\nmLbInvBindPalette = mSkeleton.GetInvBindPose();\n```", "```cpp\nmPlayTime = mClips[mClip].Sample(mCurrentPose, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mPlayTime + dt);\nmCurrentPose.GetDualQuaternionPalette(mDqPosePalette);\nmCurrentPose.GetMatrixPalette(mLbPosePalette);\n```", "```cpp\nif (mSkinningMethod == SkinningMethod::DualQuaternion) {\n\u00a0\u00a0 Uniform<DualQuaternion>::Set(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 shader->GetUniform(\"pose\"), mDqPosePalette);\n\u00a0\u00a0 Uniform<DualQuaternion>::Set(\n\u00a0\u00a0 shader->GetUniform(\"invBindPose\"), mDqInvBindPalette);\n}\nelse {\n\u00a0\u00a0 Uniform<mat4>::Set(shader->GetUniform(\"pose\"), \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mLbPosePalette);\n\u00a0\u00a0 Uniform<mat4>::Set(shader->GetUniform(\"invBindPose\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mLbInvBindPalette);\n}\n```"]