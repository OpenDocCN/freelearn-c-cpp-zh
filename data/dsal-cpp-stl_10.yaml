- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Advanced Container View Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级容器视图使用
- en: At their core, views are non-owning ranges, meaning they provide a view (hence
    the name) of other data structures without taking ownership of the underlying
    data. This makes them incredibly lightweight and versatile. With views, you can
    perform various operations on data without copying it, ensuring efficient code
    that maximizes performance and minimizes overhead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，视图是非拥有范围，这意味着它们提供了对其他数据结构的视图（因此得名），而不拥有底层数据。这使得它们非常轻量级和多功能。使用视图，您可以在不复制数据的情况下对数据进行各种操作，确保高效的代码，最大化性能并最小化开销。
- en: 'This chapter focuses on the following containers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍以下容器：
- en: '`std::span`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span`'
- en: '`std::mdspan`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan`'
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: std::span
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::span
- en: '`std::span` is a template class introduced in C++20 that provides a view of
    a contiguous sequence of elements, similar to a lightweight, non-owning reference.
    It represents a range over some contiguous storage, such as an array or a portion
    of a vector, without owning the underlying data.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`是C++20中引入的一个模板类，它提供对连续元素序列的视图，类似于轻量级、非拥有引用。它表示对某些连续存储的视图，例如数组或向量的部分，而不拥有底层数据。'
- en: The primary purpose of `std::span` is to safely and efficiently pass arrays
    of data to functions without needing to pass the size explicitly, as the size
    information is encapsulated within the `std::span` object. It can be considered
    a safer, more flexible alternative to raw pointer-and-size or pointer-and-length
    parameter passing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`的主要目的是安全且高效地将数据数组传递给函数，而无需显式传递大小，因为大小信息封装在`std::span`对象中。它可以被认为是一个更安全、更灵活的替代方案，用于原始指针和大小或指针和长度参数传递。'
- en: Purpose and suitability
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::span` is a non-owning view of a contiguous sequence, often an array or
    a segment of another container. It is a lightweight, flexible, and safe way to
    refer to such sequences, ensuring no extraneous copies.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`是对连续序列的非拥有视图，通常是一个数组或另一个容器的片段。它是一种轻量级、灵活且安全地引用此类序列的方法，确保没有多余的复制。'
- en: '`std::span` is best suited in the following scenarios:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`最适合以下场景：'
- en: When a temporary view of data is needed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要临时数据视图时
- en: When the underlying data’s ownership is managed elsewhere
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当底层数据的所有权由其他地方管理时
- en: When you want to avoid unnecessary data copying but still need random access
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想避免不必要的数据复制但仍需要随机访问时
- en: Consider using `std::span` to provide functions with access to parts of data
    without granting ownership.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用`std::span`向函数提供对数据部分的访问，而不授予所有权。
- en: Ideal use cases
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想的使用场景
- en: 'The following are some of the ideal use cases of `std::span`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::span`的理想使用场景：
- en: '**Processing data segments**: Parsing a subsegment of a large data block, such
    as processing headers in a networking buffer'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理数据段**：解析大型数据块的一个子段，例如处理网络缓冲区中的头信息'
- en: '**Function interfaces**: Granting functions a view of data without transferring
    ownership or risking resource leaks'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数接口**：授予函数对数据的视图，而不转移所有权或风险资源泄露'
- en: '**Data views**: Quickly and safely offering multiple views on a data source
    without duplicating the source'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据视图**：快速且安全地提供对数据源的多重视图，而不复制源数据'
- en: Performance
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::span` is characterized as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`的算法性能如下所述：'
- en: '`std::span` doesn’t own its data'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span`不拥有其数据'
- en: '**Deletion**: Not applicable'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：不适用'
- en: '**Access**: *O(1)*, just like direct array access'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：*O(1)*，就像直接数组访问一样'
- en: '**Memory overhead**: Minimal, as it essentially holds a pointer and a size'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：最小，因为它本质上只持有指针和大小'
- en: Remember, the performance of `std::span` mainly derives from its non-owning
    characteristic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`std::span`的性能主要源于其非拥有特性。
- en: Memory management
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: No allocations are done by `std::span`. It simply references memory owned elsewhere.
    Thus, concerns about memory behavior primarily relate to the underlying data,
    not the span itself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`不进行任何分配。它只是引用其他地方拥有的内存。因此，关于内存行为的主要关注点与底层数据相关，而不是span本身。'
- en: Thread safety
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Multiple concurrent reads through a span are safe. However, as with any data
    structure, concurrent writes or write-read combinations require synchronization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过范围进行多个并发读取是安全的。然而，与任何数据结构一样，并发写入或写入-读取组合需要同步。
- en: Extensions and variants
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::span` is unique in the `std::string_view` offer a similar view concept,
    they cater to specific data types.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 在 `std::string_view` 中是独特的，它提供了一个类似的观点概念，它们针对特定的数据类型。'
- en: Sorting and searching complexity
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: Sorting isn’t directly applicable to `std::span`, since it doesn’t own its data.
    Searching, however, is *O(n)* for an unsorted sequence and *O(log n)* for sorted
    data using appropriate STL algorithms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 排序不能直接应用于 `std::span`，因为它不拥有其数据。然而，使用适当的 STL 算法进行搜索对于未排序序列是 *O(n)*，对于排序数据是 *O(log
    n)*。
- en: Interface and member functions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Key functions in this category include the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别中的关键函数包括以下内容：
- en: '`size()`: Returns the number of elements'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回元素数量'
- en: '`data()`: Provides access to the underlying data'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data()`: 提供对底层数据的访问'
- en: '`subspan()`: Generates another span from the current one'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subspan()`: 从当前范围生成另一个范围'
- en: Comparisons
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::vector` or `std::array`, `std::span` doesn’t manage or own
    data. It offers a way to safely view sections of these containers (or others)
    without copying.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 或 `std::array` 相比，`std::span` 不管理或拥有数据。它提供了一种安全地查看这些容器（或其他）部分的方法，而不需要复制。
- en: Interactions with algorithms
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: STL algorithms requiring access (and not structure modification) can interact
    with `std::span` seamlessly. Those requiring insertions or deletions should be
    avoided.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要访问（而不是结构修改）的 STL 算法可以无缝地与 `std::span` 交互。那些需要插入或删除的应该避免使用。
- en: Exceptions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Operating beyond the bounds of the span can trigger exceptions. Always ensure
    the underlying data’s validity during the span’s entire lifetime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 超出范围的操作可能会触发异常。在整个生命周期内，始终确保底层数据的有效性。
- en: Customization
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: '`std::span` isn’t typically customized with allocators, comparators, or hash
    functions due to its non-owning nature.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::span` 的非拥有性质，通常不会使用分配器、比较器或哈希函数对其进行自定义。
- en: Example
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: Let’s look at an example demonstrating the use of `std::span` to process the
    headers of a **User Datagram Protocol** (**UDP**) packet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，演示如何使用 `std::span` 来处理 **用户数据报协议**（**UDP**）包的头部。
- en: 'UDP headers typically consist of the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 头通常包括以下内容：
- en: '**Source port**: 2 bytes'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源端口**: 2 字节'
- en: '**Destination port**: 2 bytes'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标端口**: 2 字节'
- en: '**Length**: 2 bytes'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**: 2 字节'
- en: '**Checksum**: 2 bytes'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**校验和**: 2 字节'
- en: 'We’ll create a simple structure representing the header, and then we’ll use
    `std::span` to handle a buffer containing the header and data of a UDP packet.
    Let’s explore the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的结构来表示头部，然后我们将使用 `std::span` 来处理包含 UDP 数据包头部和数据的缓冲区。让我们探索以下代码：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The key points from the preceding code are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的关键点如下：
- en: We define a `UDPHeader` structure to represent the header fields.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个 `UDPHeader` 结构来表示头部字段。
- en: In the `processUDPPacket` function, we use `std::span` to handle the buffer.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `processUDPPacket` 函数中，我们使用 `std::span` 来处理缓冲区。
- en: We then create a `subspan` for the header and reinterpret it as the `UDPHeader`
    structure.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为头部创建一个 `subspan` 并将其重新解释为 `UDPHeader` 结构。
- en: The remaining part of the buffer is the data, which we handle using another
    `subspan`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区的剩余部分是数据，我们使用另一个 `subspan` 来处理。
- en: '`std::span` offers a view of a contiguous sequence of objects, making it suitable
    for safely accessing memory regions, such as networking buffers, without owning
    the underlying data.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 提供了对连续对象序列的视图，使其适合安全地访问内存区域，例如网络缓冲区，而不拥有底层数据。'
- en: Best practices
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::span`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::span` 的最佳实践：
- en: '`std::span` outlives the span itself. This is critical to avoid dangling references.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 的生命周期超过了范围本身。这是避免悬垂引用的关键。'
- en: '`std::span` is not a data-owning container. It only provides a view of the
    data, unlike containers such as `std::vector` that manage their data.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 不是一个拥有数据的容器。它只提供数据的视图，与像 `std::vector` 这样的管理其数据的容器不同。'
- en: '`std::span` view. This joint reflection means data integrity must be maintained
    throughout the span’s life cycle.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 视图。这种联合反映意味着在整个范围的生存周期内必须保持数据完整性。'
- en: '`std::span` judiciously. Always ensure the span’s duration is shorter than
    or equal to the lifetime of the underlying data.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用 `std::span`。始终确保 span 的持续时间短于或等于底层数据的生命周期。
- en: '`std::span` in function interfaces to prevent unnecessary data copying. This
    can optimize performance, especially when working with large data blocks.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接口中使用 `std::span` 以防止不必要的数据复制。这可以优化性能，尤其是在处理大数据块时。
- en: '`std::span`. Utilize functions such as `size()` for bounds verification.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span`。利用 `size()` 等函数进行边界验证。'
- en: '`std::span` over raw pointer and length pairs. It offers a type-safe, more
    readable alternative, reducing the risk of common pointer errors.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 在原始指针和长度对上。它提供了一个类型安全、更易读的替代方案，减少了常见指针错误的风险。'
- en: '`std::span` for abstracting data segments. It’s especially beneficial when
    different components or functions of a program need access to varying data sections
    without full ownership.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 用于抽象数据段。当程序的不同组件或函数需要访问不同的数据部分而没有完整所有权时，特别有益。'
- en: '`std::span` offers random access iterators, it’s compatible with most STL algorithms.
    However, be cautious when using algorithms that might expect data ownership or
    mutation capabilities beyond the scope of `std::span`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 提供随机访问迭代器，与大多数 STL 算法兼容。然而，在使用可能期望数据所有权或超出 `std::span` 范围的突变能力的算法时要小心。'
- en: '`std::span`, given its direct reflection properties.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span`，鉴于其直接的反射属性。'
- en: std::mdspan
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::mdspan
- en: '`std::mdspan`, introduced in the C++23 standard, is a multidimensional span
    template class that extends the concept of `std::span` to multiple dimensions.
    It provides a view of a multidimensional contiguous sequence of elements without
    owning the underlying data. This class is handy for numerical computations and
    algorithms that operate on multidimensional data structures, such as matrices
    and tensors.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan`，在 C++23 标准中引入，是一个多维 span 模板类，它将 `std::span` 的概念扩展到多个维度。它提供了一个多维连续元素序列的视图，而不拥有底层数据。此类对于数值计算和操作多维数据结构的算法（如矩阵和张量）非常有用。'
- en: Purpose and suitability
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::mdspan` is a multidimensional span in the C++ STL. It is a non-owning
    view of a multidimensional array, offering efficient access and manipulation.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan` 是 C++ STL 中的多维 span。它是一个多维数组的非拥有视图，提供高效的访问和操作。'
- en: 'Its strengths are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其优势如下：
- en: Representing and accessing multidimensional data without owning it
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示和访问多维数据而不拥有它
- en: Facilitating interoperability with other languages and libraries that work with
    multidimensional arrays
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进与其他语言和库的互操作性，这些语言和库与多维数组一起工作。
- en: '`std::mdspan` is particularly suitable in the following scenarios:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan` 在以下场景中尤其适用：'
- en: When you must work with multidimensional data from other libraries or APIs without
    copying
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你必须与其他库或 API 中的多维数据一起工作而不进行复制时
- en: When you require flexibility in indexing and slicing through multidimensional
    datasets.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要对多维数据集进行索引和切片的灵活性时。
- en: Ideal use cases
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases of `std::mdspan`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::mdspan` 的理想用例：
- en: '**Image processing**: Accessing pixels in a 2D image or frames in a 3D video
    stream'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像处理**：访问 2D 图像中的像素或 3D 视频流中的帧'
- en: '**Scientific computing**: Manipulating data in matrix formats for mathematical
    computations'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**科学计算**：在矩阵格式中操作数据以进行数学计算'
- en: '**Data wrangling**: Efficiently re-indexing, slicing, or reshaping multidimensional
    datasets'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理**：高效地重新索引、切片或重塑多维数据集'
- en: '**Interoperability**: Interfacing with other languages or libraries that manage
    multidimensional data structures'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：与其他管理多维数据结构的语言或库进行接口'
- en: Performance
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::mdspan` is characterized as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan` 的算法性能如下：'
- en: '**Access**: Typically *O(1)* for any position.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：通常对任何位置为 *O(1)*。'
- en: '`std::mdspan` only provides a view of existing data.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 只提供现有数据的视图。'
- en: '`std::mdspan` itself.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 本身。'
- en: Memory management
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Since `std::mdspan` doesn’t own its data, it does not control memory allocation
    or deallocation. Ensure the underlying data remains valid during the `mdspan`
    lifespan.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::mdspan` 不拥有其数据，它不控制内存分配或释放。确保在 `mdspan` 生命周期内底层数据保持有效。
- en: Thread safety
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Like `std::span`, multiple concurrent reads are safe, but writes or mixed reads
    and writes necessitate external synchronization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::span` 类似，多个并发读取是安全的，但写入或混合读取和写入需要外部同步。
- en: Extensions and variants
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::span` can be seen as a 1D variant. While `std::span` provides a view
    of linear data, `std::mdspan` extends this concept to multidimensional data.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 可以看作是 1D 变体。虽然 `std::span` 提供了线性数据的视图，但 `std::mdspan` 将此概念扩展到多维数据。'
- en: Sorting and searching complexity
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: Sorting and searching are not inherently properties of `std::mdspan`, given
    its nature. External algorithms would need to be adapted to their multidimensional
    characteristics.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其本质，排序和搜索不是 `std::mdspan` 的固有属性。外部算法需要根据其多维特性进行适配。
- en: Special interface and member functions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: '`std::mdspan` offers the following special interface and member functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan` 提供以下特殊接口和成员函数：'
- en: '`extent`: Returns the size in a given dimension'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent`：返回给定维度的尺寸'
- en: '`strides`: Provides the number of elements between successive items in each
    dimension'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strides`：提供每个维度中连续项目之间的元素数量'
- en: '`rank`: Gives the number of dimensions'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rank`：给出维度数'
- en: Comparisons
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Against raw multidimensional arrays or pointers, `std::mdspan` offers a safer
    and more flexible interface, albeit without data ownership.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始多维数组或指针相比，`std::mdspan` 提供了一个更安全、更灵活的接口，尽管没有数据所有权。
- en: Interactions with algorithms
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: While many STL algorithms are designed for linear data structures, specific
    algorithms, especially custom ones for multidimensional data, can be adapted to
    work with `std::mdspan`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多 STL 算法是为线性数据结构设计的，但特定的算法，尤其是针对多维数据的自定义算法，可以适配以与 `std::mdspan` 一起工作。
- en: Exceptions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Given its non-owning nature, accessing data through an invalidated `std::mdspan`
    (if the underlying data is destroyed) is an undefined behavior and won’t throw
    standard exceptions. Always ensure data validity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其非拥有性质，通过已失效的 `std::mdspan`（如果底层数据被销毁）访问数据是未定义的行为，并且不会抛出标准异常。始终确保数据的有效性。
- en: Customization
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制
- en: '`std::mdspan` can be customized using layout policies to define data storage
    patterns.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mdspan` 可以使用布局策略进行定制，以定义数据存储模式。'
- en: Best practices
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::mdspan`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::mdspan` 的最佳实践：
- en: '`std::mdspan` is a non-owning view. Ensure that you never mistakenly treat
    it as a data-owning container. This oversight can introduce dangling references
    and undefined behavior.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 是一个非拥有视图。确保您永远不会错误地将它视为拥有数据的容器。这种疏忽可能会引入悬垂引用和未定义的行为。'
- en: '`std::mdspan`. Understanding and adjusting these aspects can optimize your
    data access patterns, making them more cache-friendly.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan`。理解和调整这些方面可以优化您的数据访问模式，使它们更符合缓存友好。'
- en: '`std::mdspan`’s layout with the expected convention can prevent subtle bugs
    and inefficiencies.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 的布局与预期约定可以防止微妙的错误和低效。'
- en: '`std::mdspan` points remain valid for the span’s entire lifetime. Avoid situations
    where the underlying data could be destroyed or go out of scope while an active
    `std::mdspan` references it.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 指针在整个跨度生命周期内保持有效。避免在 `std::mdspan` 引用底层数据时，底层数据被销毁或超出作用域的情况。'
- en: '**Explicit layout specification**: When working alongside different libraries,
    especially those external to the C++ STL, be overt about the expected data layouts.
    Such clarity prevents ambiguities and ensures consistent data interpretation.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式布局指定**：当与不同的库一起工作时，尤其是与 C++ STL 外部的库一起工作时，明确预期的数据布局。这种清晰度可以防止歧义并确保一致的数据解释。'
- en: '`std::mdspan` as a parameter. This choice offers safety from dangling references
    (compared to raw pointers) and greater expressiveness regarding multidimensional
    data operations.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `std::mdspan` 作为参数。这种选择提供了对悬垂引用（与原始指针相比）的安全性，并且在多维数据操作方面具有更高的表达性。
- en: '`std::mdspan`. While `std::mdspan` offers some level of type safety, out-of-bounds
    access still leads to undefined behavior. Consider using functions such as `extents`
    to ascertain dimensions.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan`。虽然 `std::mdspan` 提供了一定程度的类型安全性，但越界访问仍然会导致未定义的行为。考虑使用 `extents`
    等函数来确认维度。'
- en: '`std::mdspan` interprets the underlying data using layout policies for advanced
    use cases. This flexibility can be particularly valuable when needing non-standard
    data arrangements or optimizing for specific hardware architectures.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mdspan` 使用布局策略来解释底层数据，以用于高级用例。这种灵活性在需要非标准数据排列或针对特定硬件架构进行优化时尤其有价值。'
- en: '`std::span`, `std::mdspan` itself doesn’t guarantee thread safety for the underlying
    data. If multithreaded access is anticipated, ensure the underlying data structure
    or its operations are thread-safe.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::span` 和 `std::mdspan` 本身并不保证底层数据的线程安全性。如果预期会有多线程访问，请确保底层数据结构或其操作是线程安全的。'
- en: '`std::mdspan` doesn’t naturally fit all STL algorithms due to its multidimensional
    nature, you can still use many algorithms on a flattened view or individual slices
    of the data. Being familiar with STL algorithms can help you avoid reinventing
    the wheel.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `std::mdspan` 具有多维性质，它并不自然地适合所有 STL 算法，但您仍然可以在数据的扁平视图或单个切片上使用许多算法。熟悉 STL
    算法可以帮助您避免重复造轮子。
- en: 'Part 3: Mastering STL Algorithms'
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：精通 STL 算法
- en: In this Part, you will acquire a robust understanding of the algorithmic backbone
    of the C++ STL. We establish a foundation with fundamental algorithms, emphasizing
    sorting, searching, and element comparison, essential to efficient data manipulation.
    We then dive into the transformative power of STL through copying, moving, filling,
    and generating operations, revealing techniques for optimal data manipulation
    while underpinning the importance of modern idioms like **Return Value** **Optimization
    (RVO)**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，您将获得对 C++ STL 算法骨架的稳健理解。我们通过基本算法建立基础，强调排序、搜索和元素比较，这些对于高效的数据操作至关重要。然后我们深入
    STL 的变革力量，通过复制、移动、填充和生成操作，揭示最优数据操作的技术，同时强调现代惯用术语如**返回值优化（RVO）**的重要性。
- en: Continuing, we explore numeric operations, from simple summations to complex
    inner products, and extend our focus to range-based operations, underscoring their
    significance in modern C++. The subsequent chapter transitions to the structured
    manipulation of data sets through partitioning, heap operations, and permutations,
    illustrating their pivotal roles in data organization and analysis.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨数值操作，从简单的求和到复杂的内积，并将我们的关注点扩展到基于范围的运算，强调其在现代 C++ 中的重要性。随后的章节转向通过分区、堆操作和排列来结构化地处理数据集，展示了它们在数据组织和分析中的关键作用。
- en: Finally, we conclude by introducing the concept of ranges, an evolution in STL
    that brings a more expressive and efficient approach to algorithmic operations.
    We dissect the advantages and best practices of range-based algorithms for sorting
    and searching, advocating for their adoption in contemporary C++ development.
    Best practices are highlighted throughout, providing you with a clear pathway
    to writing clean, efficient, and maintainable code with STL algorithms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过介绍范围的概念来总结，这是 STL 的一次进化，它为算法操作带来了更丰富和高效的途径。我们分析了基于范围的排序和搜索算法的优势和最佳实践，并倡导在当代
    C++ 开发中采用这些算法。最佳实践贯穿始终，为您提供了使用 STL 算法编写干净、高效和可维护代码的清晰路径。
- en: 'This part has the following chapters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B21945_11.xhtml#_idTextAnchor498)*: Fundamental Algorithms and
    Searching*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21945_11.xhtml#_idTextAnchor498)：基本算法和搜索'
- en: '[*Chapter 12*](B21945_12.xhtml#_idTextAnchor507)*: Manipulation and Transformation*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21945_12.xhtml#_idTextAnchor507)：操作和转换'
- en: '[*Chapter 13*](B21945_13.xhtml#_idTextAnchor530)*: Numeric and Range-Based
    Operations*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21945_13.xhtml#_idTextAnchor530)：数值和基于范围的运算'
- en: '[*Chapter 14*](B21945_14.xhtml#_idTextAnchor542)*: Permutations, Partitions,
    and Heaps*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21945_14.xhtml#_idTextAnchor542)：排列、分区和堆'
- en: '[*Chapter 15*](B21945_15.xhtml#_idTextAnchor563)*: Modern STL with Ranges*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21945_15.xhtml#_idTextAnchor563)：带有范围的现代 STL'
