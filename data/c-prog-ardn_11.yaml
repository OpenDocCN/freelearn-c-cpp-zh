- en: Chapter 11. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 网络通信
- en: In this chapter we are going to talk about linking objects and making them talk
    by creating communication networks. We are going to learn how we can make multiple
    Arduinos and computers communicate using network links and protocols.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论通过创建通信网络来连接对象并使它们通过通信进行交流。我们将学习如何通过网络链路和协议使多个Arduino和计算机进行通信。
- en: After defining what a network is (specifically, a data network), we'll describe
    ways to use wired Ethernet links between Arduinos and computers. This will open
    the Arduino world to the Internet. Then, we'll discover how to create Bluetooth
    communications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了什么是网络（特别是数据网络）之后，我们将描述如何在Arduino和计算机之间使用有线以太网链路。这将使Arduino世界通向互联网。然后，我们将探讨如何创建蓝牙通信。
- en: We will learn how to use Ethernet Wi-Fi in order to connect the Arduino to computers
    or other Arduinos without being tethered by network cables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用以太网Wi-Fi将Arduino连接到计算机或其他Arduino，而无需被网络电缆所束缚。
- en: At last, we will study a couple of examples from the one in which we will fire
    message to the micro-blogging service Twitter, to the one in which we will parse
    and react to data received from the Internet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将研究几个例子，从向微博服务Twitter发送消息的例子，到解析和响应从互联网接收到的数据的例子。
- en: We will also introduce the OSC exchange protocol, widely used in anything related
    to interaction design, music, and multimedia.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍广泛用于与交互设计、音乐和多媒体相关的一切的OSC交换协议。
- en: An overview of networks
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络概述
- en: A network is a system of elements linked together. There are many networks around
    us such as highway systems, electrical grids, and data networks. Data networks
    surround us. They relate to video services networks, phone and global telecommunication
    networks, computer networks, and so on. We are going to focus on these types of
    networks by talking about how we can share data over different types of media
    such as wires transporting electric pulses or electromagnetic waves facilitating
    wireless communication.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是由相互连接的元素组成的系统。我们周围有许多网络，如公路系统、电网和数据网络。数据网络包围着我们。它们与视频服务网络、电话和全球电信网络、计算机网络等相关。我们将通过讨论如何通过不同类型的媒体（如传输电脉冲的电线或促进无线通信的电磁波）共享数据来关注这些类型的网络。
- en: Before we dive into the details of network implementations for Arduino boards,
    we are going to describe a model named the OSI model. It is a very useful representation
    of what a data network is and what it involves.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入Arduino板网络实现细节之前，我们将描述一个名为OSI模型（开放系统互连模型）的模型。这是一个非常有用的表示，说明了数据网络是什么以及它涉及的内容。
- en: Overview of the OSI model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSI模型概述
- en: The **Open** **Systems** **Interconnection** model (**OSI** model) has been
    initiated in 1977 by the International Organization for Standardization in order
    to define prescriptions and requirements around the functions of communication
    systems in terms of abstract layers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放** **系统** **互连**模型（**OSI**模型）于1977年由国际标准化组织发起，旨在定义关于通信系统功能的抽象层的规定和要求。'
- en: 'Basically, this is a layers-based model describing what features are necessary
    to design communicating systems. Here is the OSI model with seven layers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是一个基于层的模型，描述了设计通信系统所需的功能。以下是具有七层的OSI模型：
- en: '![Overview of the OSI model](img/7584_11_001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![OSI模型概述](img/7584_11_001.jpg)'
- en: OSI model describing communication system requirements with seven abstraction
    layers
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 描述通信系统要求的七层抽象的OSI模型
- en: Protocols and communications
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议和通信
- en: 'A communications protocol is a set of message formats and rules providing a
    way of communication between at least two participants. Within each layer, one
    or more entities implements its functionality and each entity interacts directly
    and only with the layer just beneath it and at the same time provides facilities
    for use by the layer above it. A protocol enables an entity in one host to interact
    with a corresponding entity at the same layer in another host. This can be represented
    by the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议是一组消息格式和规则，提供了一种至少两个参与者之间通信的方式。在每一层中，一个或多个实体实现其功能，每个实体直接且仅与下一层交互，同时为上层提供使用设施。协议使一个主机中的一个实体能够与另一个主机中同一层的相应实体进行交互。这可以通过以下图表表示：
- en: '![Protocols and communications](img/7584_11_002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![协议和通信](img/7584_11_002.jpg)'
- en: Protocols helping hosts' layers to communicate together
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 协议帮助主机层之间进行通信
- en: Data encapsulation and decapsulation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据封装和解封装
- en: If the application of one host needs to send data to another application of
    another host, the effective data, also named the payload, is passed down directly
    to the layer beneath it. In order to make the application able to retrieve its
    data, a header and footer are added to this data depending on the protocol used
    at each layer. This is called **encapsulation** and it happens until the lowest
    layer, which is the physical one. At this point, a flow of bits is modulated on
    the medium for the receiver.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个主机的应用程序需要将数据发送到另一个主机的应用程序，有效数据，也称为有效载荷，将直接传递到其下的一层。为了使应用程序能够检索其数据，根据每一层使用的协议，将添加头部和尾部到这些数据。这被称为**封装**，并且一直发生到最低层，即物理层。在这一点，一个比特流被调制到介质上以供接收器使用。
- en: The receiver has to make the data progressively climb the layer stack, passing
    data from a layer to a higher layer and addressing it to the right entities in
    each layer using previously added headers and footers. These headers and footers
    are removed all along the path; this is called **decapsulation**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器必须使数据逐步爬升层堆栈，将数据从一层传递到更高一层，并使用之前添加的头部和尾部将其地址指向每一层的正确实体。这些头部和尾部在整个路径上都被移除；这被称为**解封装**。
- en: 'At the end of the journey, the application of the receiver receives its data
    and can process it. This whole process can be represented by the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅程结束时，接收器的应用程序接收其数据并可以处理它。整个过程可以用以下图表表示：
- en: '![Data encapsulation and decapsulation](img/7584_11_003.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![数据封装和解封装](img/7584_11_003.jpg)'
- en: Encapsulation and decapsulation all along the layers' stack
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在层堆栈中沿层进行封装和解封装
- en: We can also represent these processes as shown in the following figure. The
    small gray rectangle is the data payload for the layer N+1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这些过程表示如下图所示。小灰色矩形是层 N+1 的数据有效载荷。
- en: '![Data encapsulation and decapsulation](img/7584_11_004.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![数据封装和解封装](img/7584_11_004.jpg)'
- en: Adding and removing specific headers and footers according to the protocols
    used
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的协议添加和移除特定的头部和尾部
- en: At each level, two hosts interact using a protocol transmitted, which we call
    **Protocol Data Unit** or **PDU**. We also call **Service Data Unit** or **SDU**,
    a specific unit of data passed down from a layer to a lower layer and that has
    not yet been encapsulated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一级，两个主机使用传输的协议进行交互，我们称之为**协议数据单元**或**PDU**。我们还将从一层传递到下一层且尚未封装的特定数据单元称为**服务数据单元**或**SDU**。
- en: Each layer considers the data received as data for it and adds/removes headers
    and footers according to the protocol used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都将接收到的数据视为自己的数据，并根据所使用的协议添加/移除头部和尾部。
- en: We are now going to illustrate each layer and protocol by examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过示例来阐述每一层和协议。
- en: The roles of each layer
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每一层的角色
- en: We are going to describe the purpose and roles of each layer here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里描述每一层的用途和角色。
- en: Physical layer
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: The physical layer defines electrical and physical specifications required for
    communication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层定义了通信所需的电气和物理规范。
- en: 'Pin layout, voltages and line impedance, signal timing, network adapters, or
    host bus adapters are defined in this layer. Basically, this layer performs three
    major functions/services:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚布局、电压和线路阻抗、信号时序、网络适配器或主机总线适配器在此层定义。基本上，这一层执行三个主要功能/服务：
- en: Initialization and termination of a connection to a communication medium
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和终止与通信介质的连接
- en: Participation in shared resources control processes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与共享资源控制过程
- en: Conversion between the data communicated and the electrical signals which carry
    them
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信数据与携带它们的电气信号之间的转换
- en: 'We can quote some known standards being in this physical layer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引用一些已知的标准，它们位于这一物理层：
- en: ADSL and ISDN (network and phony provider services)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADSL 和 ISDN（网络和模拟服务提供商）
- en: Bluetooth
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙
- en: IEEE 1394 (FireWire)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEEE 1394（FireWire）
- en: USB
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB
- en: IrDA (data transfer over infrared links)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IrDA（通过红外链路的数据传输）
- en: SONET, SDH (wide area optic fiber networks operated by providers)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SONET、SDH（由提供商运营的广域光纤网络）
- en: Data link layer
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据链路层
- en: 'This layer is made of two sublayers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层由两个子层组成：
- en: Logical Link Control (LLC)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑链路控制 (LLC)
- en: Media Access Control (MAC)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体访问控制 (MAC)
- en: 'Both are responsible for transferring data between network entities and to
    detect errors that may occur at the physical layer, and eventually to fix them.
    Basically, this layer provides these functions/services:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都负责在网络实体之间传输数据，并检测物理层可能发生的错误，最终修复它们。基本上，这一层提供以下功能/服务：
- en: Framing
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Physical addressing
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理寻址
- en: Flow control
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流控制
- en: Error control
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误控制
- en: Access control
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Media access control
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体访问控制
- en: 'We can quote some known standards of this data link layer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引用该数据链路层的一些已知标准：
- en: Ethernet
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网
- en: Wi-Fi
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi
- en: PPP
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PPP
- en: I2C
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C
- en: We have to keep in mind that the second layer is also the domain of local area
    networks with only physical addresses. It can be federated using LAN switches.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，第二层也是局域网的领域，只有物理地址。它可以通过局域网交换机进行联邦。
- en: By the way, we often need to segment networks and also communicate wider and
    so we need another addressing concept; this introduces the network layer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们经常需要分段网络并更广泛地通信，因此我们需要另一个寻址概念；这引入了网络层。
- en: Network layer
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: 'This layer provides the way to transfer data sequences between hosts that can
    be in different networks. It provides the following functions/services:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层提供了在不同网络中的主机之间传输数据序列的方法。它提供以下功能/服务：
- en: Routing
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Fragmentation and reassembly
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片和重组
- en: Delivery error reports
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告交付错误
- en: Routing provides a way to make hosts on a different network able to communicate
    by using a network addressing system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 路由提供了一种使不同网络上的主机能够通过使用网络寻址系统进行通信的方法。
- en: 'Fragmentation and reassembly also occur at this level. These provide a way
    to chop data streams into pieces and to be able to reassemble parts after the
    transmission. We can quote some known standards in this layer:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分片和重组也发生在这一级。这些提供了一种将数据流切割成片段并在传输后重新组装部分的方法。我们可以引用这一层的一些已知标准：
- en: ARP (resolving and translating physical MAC address into network address)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP（解析和将物理MAC地址转换为网络地址）
- en: BOOTP (providing a way for the host to boot over the network)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BOOTP（为主机通过网络启动提供一种方式）
- en: BGP, OSPF, RIP, and other routing protocols
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BGP、OSPF、RIP和其他路由协议
- en: IPv4 and IPv6 (Internet Protocol)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4和IPv6（互联网协议）
- en: Routers are usually the gear where the routing occurs. They are connected to
    more than one network and make data going from one network to another. This is
    also the place where we can put some access lists in order to control access based
    on IP addresses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通常是路由发生的地方。它们连接到多个网络，使数据从一个网络传输到另一个网络。这也是我们可以放置一些访问列表以根据IP地址控制访问的地方。
- en: Transport layer
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: 'This layer is in charge of the data transfer between end users, being at the
    crossroads of network layers and application layers. This layer provides the following
    functions/services:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层负责在终端用户之间进行数据传输，位于网络层和应用层的交汇处。这一层提供以下功能/服务：
- en: Flow control to assure reliability of the link used
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流控制以确保链路的可靠性
- en: Segmentation/desegmentation of data units
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据单元的分割/解分割
- en: Error control
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误控制
- en: 'Usually, we order protocols in two categories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将协议分为两类：
- en: State-oriented
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向状态
- en: Connection-oriented
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向连接
- en: This means this layer can keep track of segments emitted and eventually retransmit
    them in case of previously failed transmission.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这一层可以跟踪发出的段，并在之前传输失败的情况下最终重新传输它们。
- en: 'We can quote the two well-known standards of the IP suite in this layer:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一层，我们可以引用IP套件的两个著名标准：
- en: TCP
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP
- en: UDP
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP
- en: TCP is the connection-oriented one. It keeps the communication reliable by checking
    a lot of elements at each transmission or at each x segments transmitted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是面向连接的。它通过在每个传输或每个x个传输的段中检查许多元素来保持通信的可靠性。
- en: UDP is simpler and stateless. It doesn't provide a communication state control
    and thus is lighter. It is more suited for transaction-oriented query/response
    protocol such as DNS (Domain Name System) or NTP (Network Time Protocol). If there
    is something wrong, such as a segment not transmitted well, the above layer has
    to take care of resending a request, for instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: UDP更简单且无状态。它不提供通信状态控制，因此更轻量。它更适合于面向事务的查询/响应协议，如DNS（域名系统）或NTP（网络时间协议）。如果有问题，例如一个分段没有很好地传输，上面的层必须负责重新发送请求，例如。
- en: Application/Host layers
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用/主机层
- en: I grouped the highest three layers under the terms application and host.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将最高三层归类为应用和主机。
- en: Indeed, they aren't considered as network layers, but they are part of OSI model
    because they are often the final purpose of any network communication.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它们不被视为网络层，但它们是OSI模型的一部分，因为它们通常是任何网络通信的最终目的。
- en: 'We find a lot of client/server applications there:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里发现了许多客户端/服务器应用程序：
- en: FTP for basic and light file transfers
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP用于基本和轻量级文件传输
- en: POP3, IMAP, and SMTP for mail services
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POP3、IMAP和SMTP用于邮件服务
- en: SSH for secure remote shell communication
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH用于安全的远程shell通信
- en: HTTP for web server browsing and downloading (and nowadays much more)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP用于网页浏览和下载（以及如今更多）
- en: We also find a lot of standards related to encryption and security such as TLS
    (Transport Layer Security). Our firmware, an executing Processing code, Max 6
    running a patch are in this layer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了许多与加密和安全相关的标准，例如TLS（传输层安全性）。我们的固件，一个正在执行的Processing代码，Max 6运行补丁都在这一层。
- en: If we want to make them communicate through a wide variety of networks, we need
    some OSI stack. I mean, we need a transport and network protocol and a medium
    to transport our data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让它们通过广泛的网络进行通信，我们需要一些OSI栈。我的意思是，我们需要一个传输和网络协议以及一个传输数据的中介。
- en: If our modern computers own the whole network stack ready to use, we have to
    build this later in our Arduino's firmware if we want them to be able to communicate
    with the world. This is what we are going to do in the next subchapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的现代计算机拥有整个网络栈并准备好使用，那么如果我们想让它们能够与世界通信，我们就必须在Arduino的固件中稍后构建这个功能。这就是我们在下一小节将要做的。
- en: Some aspects of IP addresses and ports
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些关于IP地址和端口的方面
- en: One of the protocol stacks we tend to use each day is the TCP/IP one. TCP is
    the layer 4 transport protocol, and IP the layer 3 network.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天倾向于使用的协议栈之一是TCP/IP。TCP是第4层传输协议，IP是第3层网络。
- en: This is the most used network protocol in the world both for end users and for
    companies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是世界上使用最广泛的网络协议，无论是对于终端用户还是对于公司。
- en: We are going to explain a little bit more about the IP addressing system, subnet
    masks, and communication ports. I won't be describing a complete network course.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地解释IP寻址系统、子网掩码和通信端口。我不会描述一个完整的网络课程。
- en: The IP address
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP地址
- en: 'An IP address is a numerical address referenced by any devices wanting to communicate
    over an IP network. IP is currently used in 2 versions: IPv4 and IPv6\. We are
    considering IPv4 here because it is currently the only one used by end users.
    IPv4 addresses are coded over 32 bits. They are often written as a human-readable
    set of 4 bytes separated by a point. 192.168.1.222 is the current IP address of
    my computer. There are 2^(32) possible unique addresses and all aren''t routable
    over the Internet. Some are reserved for private use. Some companies assign Internet-routable
    addresses. Indeed, we cannot use both addresses as this is handled by global organizations.
    Each country has sets of addresses attributed for their own purposes.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址是任何想要通过IP网络通信的设备引用的数值地址。IP目前使用2个版本：IPv4和IPv6。在这里我们考虑IPv4，因为它目前是终端用户唯一使用的版本。IPv4地址由32位编码。它们通常被写成由点分隔的4个字节的易读集合。192.168.1.222是我的计算机当前的IP地址。有2^(32)个可能的唯一地址，并且并不是所有都可以在互联网上路由。一些被保留用于私有用途。一些公司分配可路由互联网地址。实际上，我们不能使用这两个地址，因为这是由全球组织处理的。每个国家都有为自身目的分配的地址集合。
- en: The subnet
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子网
- en: A subnet is a way to segment our network into multiple smaller ones. A device
    network's configuration contains usually the address, the subnet mask, and a gateway.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 子网是一种将我们的网络分割成多个更小网络的方法。设备网络的配置通常包含地址、子网掩码和网关。
- en: The address and the subnet mask define the network range. It is necessary to
    know if a transmitter can communicate directly with a receiver. Indeed, if the
    latter is inside the same network, communication can occur directly; if it is
    on another network, the transmitter has to send its data to the gateway that will
    route data to the correct next node on the networks in order to reach, if possible,
    the receiver.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 地址和子网掩码定义了网络范围。了解发送器是否可以直接与接收器通信是必要的。实际上，如果后者在同一网络内，通信可以直接发生；如果它在另一个网络中，发送器必须将其数据发送到网关，网关将数据路由到正确的下一个节点，以便尽可能到达接收器。
- en: The gateway knows about the networks to which it is connected. It can route
    data across different networks and eventually filter some data according to some
    rules.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 网关了解它所连接的网络。它可以跨不同网络路由数据，并最终根据某些规则过滤一些数据。
- en: Usually, the subnet mask is written as a human-readable set of 4 bytes too.
    There is obviously a bit notation, more difficult for those not used to manipulating
    the numbers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，子网掩码也以人类可读的4字节集合的形式编写。显然，有一个位表示法，对于那些不习惯于操作数字的人来说更难。
- en: The subnet mask of my computer is 255.255.255.0\. This information and my IP
    address defines that my home network begins at 192.168.1.0 (which is the base
    network address) and finish at 192.168.1.255 (which is the broadcast address).
    I cannot use these addresses for my device, but only those from 192.168.1.1 to
    192.168.1.254.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计算机的子网掩码是255.255.255.0。这些信息和我的IP地址定义了我的家庭网络从192.168.1.0（这是基本网络地址）开始，到192.168.1.255（这是广播地址）结束。我不能使用这些地址为我的设备分配，而只能使用从192.168.1.1到192.168.1.254的地址。
- en: The communication port
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通信端口
- en: A communication port is something defined and related to layer 4, the transport
    layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通信端口是定义并相关于第4层，即传输层的某个东西。
- en: Imagine you want to address a message to a host for a particular application.
    The receiver has to be in a listening mode for the message he wants to receive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想向特定应用的主机发送一条消息。接收者必须处于监听模式，以便接收他想要接收的消息。
- en: This means it has to open and reserve a specific socket for the connection,
    and that is a communication port. Usually, applications open specific ports for
    their own purpose, and once a port has been opened and reserved by an application,
    it cannot be used by another application while it is opened by the first one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它必须为连接打开并保留一个特定的套接字，这就是通信端口。通常，应用程序为它们自己的目的打开特定的端口，一旦一个端口被一个应用程序打开并保留，在第一个应用程序打开期间，它就不能被另一个应用程序使用。
- en: This provides a powerful system for data exchange. Indeed, if we want to send
    data to a host for more than one application, we can specifically address our
    messages to this host on a different port to reach different applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种强大的数据交换系统。实际上，如果我们想向一个主机发送超过一个应用的数据，我们可以将我们的消息特别指向这个主机上的不同端口，以到达不同的应用。
- en: Of course, standards had to be defined for global communications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了全球通信，必须定义标准。
- en: TCP port 80 is used for the HTTP protocol related to data exchange with web-servers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: TCP端口80用于与Web服务器数据交换相关的HTTP协议。
- en: UDP port 53 is used for anything related to DNS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: UDP端口53用于与DNS相关的任何事物。
- en: 'If you are curious, you can read the following huge official text file containing
    all declared and reserved port and the related services: [http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt](http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，你可以阅读以下包含所有声明和保留端口及其相关服务的巨大官方文本文件：[http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt](http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt)。
- en: These are conventions. Someone can easily run a web server on a port other than
    80\. Then, the specific clients of this web server would have to know about the
    port used. This is why conventions and standards are useful.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是惯例。有人可以很容易地在非80端口的端口上运行Web服务器。然后，这个Web服务器的特定客户端必须知道使用的端口。这就是为什么惯例和标准是有用的。
- en: Wiring Arduino to wired Ethernet
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Arduino连接到有线以太网
- en: Ethernet is the local area network most used nowadays.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网是现在最常用的局域网。
- en: Usual Arduino boards don't provide Ethernet ability. There is one board named
    Arduino Ethernet that provides native Ethernet and network features. By the way,
    it doesn't provide any USB-native features.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的Arduino板不提供以太网功能。有一个名为Arduino Ethernet的板提供了本地的以太网和网络功能。顺便说一下，它不提供任何USB原生功能。
- en: 'You can find the reference page here: [http://arduino.cc/en/Main/ArduinoBoardEthernet](http://arduino.cc/en/Main/ArduinoBoardEthernet).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到参考页面：[http://arduino.cc/en/Main/ArduinoBoardEthernet](http://arduino.cc/en/Main/ArduinoBoardEthernet)。
- en: '![Wiring Arduino to wired Ethernet](img/7584_11_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![将Arduino连接到有线以太网](img/7584_11_005.jpg)'
- en: Arduino Ethernet board with the Ethernet connector
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 带有以太网连接器的Arduino以太网板
- en: We are going to use the Arduino Ethernet Shield and a 100BASE-T cable with the
    Arduino UNO R3\. It keeps the USB features and adds Ethernet network connectivity
    and provides a nice way to link our computer to the Arduino with a much longer
    cable that USB ones.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arduino以太网盾和一根100BASE-T电缆与Arduino UNO R3连接。它保留了USB功能，并增加了以太网网络连接性，通过比USB更长的电缆，为我们提供了一个将计算机与Arduino连接的便捷方式。
- en: '![Wiring Arduino to wired Ethernet](img/7584_11_006.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![将Arduino连接到有线以太网](img/7584_11_006.jpg)'
- en: The Arduino Ethernet Shield
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino以太网盾
- en: If you look for the Arduino Ethernet module, you must know they are sold either
    with or without the PoE module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你寻找Arduino以太网模块，你必须知道它们是带PoE模块或不带PoE模块销售的。
- en: '**PoE** stands for **Power** **over** **Ethernet** and is a way to supply power
    to devices through Ethernet connections. This requires two parts:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoE**代表**以太网供电**，是一种通过以太网连接为设备供电的方式。这需要两个部分：'
- en: A module on the device that has to be supplied
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备上必须供电的模块
- en: A network equipment able to provide PoE support
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台能够提供PoE支持的网路设备
- en: In our case here, we won't use PoE.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里，我们不会使用PoE。
- en: Making Processing and Arduino communicate over Ethernet
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过以太网使Processing和Arduino通信
- en: Let's design a basic system showing how to set up a communication over Ethernet
    between the Arduino board and a processing applet.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个基本系统，展示如何设置Arduino板和processing小程序之间的以太网通信。
- en: Here, we are going to use an Arduino board wired to our computer using Ethernet.
    We push a button that triggers the Arduino to send a message over UDP to the Processing
    applet on the computer. The applet reacts by drawing something and sends back
    a message to the Arduino, which switches on its built-in LED.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将使用一个通过以太网连接到我们电脑的Arduino板。我们按下一个按钮，触发Arduino通过UDP向电脑上的Processing小程序发送消息。小程序通过绘制某些内容并发送回消息给Arduino，Arduino内置的LED灯就会亮起。
- en: Basic wiring
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本接线
- en: Here, we are wiring a switch and using the built-in LED board. We have to connect
    our Arduino board to our computer using an Ethernet cable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们连接一个开关并使用内置的LED板。我们必须使用以太网线将我们的Arduino板连接到电脑。
- en: This wiring is very similar to the MonoSwitch project in [Chapter 5](ch05.html
    "Chapter 5. Sensing with Digital Inputs") except that we are wiring the Arduino
    Ethernet Shield here instead of the Arduino board itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种接线与第5章中MonoSwitch项目的接线非常相似，除了我们在这里使用的是Arduino以太网屏蔽板而不是Arduino板本身。
- en: '![Basic wiring](img/7584_11_007.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![基本接线](img/7584_11_007.jpg)'
- en: The switch and the pull-down resistor wired to the Arduino Ethernet Shield
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Arduino以太网屏蔽板的开关和下拉电阻
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路图如下：
- en: '![Basic wiring](img/7584_11_008.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![基本接线](img/7584_11_008.jpg)'
- en: The switch and the pull-down resistor wired to the Arduino Ethernet Shield
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Arduino以太网屏蔽板的开关和下拉电阻
- en: Coding network connectivity implementation in Arduino
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Arduino中编码网络连接实现
- en: As we described, if we want to give our Arduino the ability to communicate over
    the Ethernet cable, and more generally over an Ethernet network, we have to implement
    the required standards in the firmware.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们描述的，如果我们想让我们的Arduino能够通过以太网线（更普遍地说，通过以太网网络）进行通信，我们必须在固件中实现所需的标准。
- en: There is a library called `Ethernet` that can provide a great number of features.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Ethernet`的库可以提供大量的功能。
- en: As usual, we have to include this native library itself. You can choose to do
    that by navigating to **Sketch** **|** **Import** **Library**, which includes
    almost everything you need.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们必须包含这个本地库本身。你可以通过导航到**草图** **|** **导入库**来选择这样做，这几乎包含了你需要的一切。
- en: However, since Arduino version 0018, because of the implementation of SPI and
    because the Arduino Ethernet Shield communicates with the Arduino board through
    SPI, we have to include something more. Be careful about that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于Arduino版本0018中SPI的实现，以及Arduino以太网屏蔽板通过SPI与Arduino板通信，我们必须包含一些额外的内容。请注意这一点。
- en: 'For this code, you need:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个代码，你需要：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a example of the Arduino code, followed by an explanation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段Arduino代码的示例，后面将进行解释。
- en: You can find the complete Arduino code at `Chapter11/WiredEthernet`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter11/WiredEthernet`找到完整的Arduino代码。
- en: '[PRE1]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous block of code, at first we include the `Ethernet` library. Then
    we declare the complete set of variables related to switch debouncing and LED
    handling. After these statements, we define some variables related to network
    features.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，首先我们包含`Ethernet`库。然后我们声明与开关去抖动和LED处理相关的完整变量集。在这些语句之后，我们定义了一些与网络功能相关的变量。
- en: At first, we have to set the MAC address related to our own shield. This unique
    identifier is usually indicated on a sticker on your Ethernet shield. Please don't
    forget to put yours in the code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须设置与我们自己的屏蔽板相关的MAC地址。这个唯一的标识符通常标示在你的以太网屏蔽板上的标签上。请务必在代码中放入你的MAC地址。
- en: Then, we set up the IP address of the Arduino. We can use any address as long
    as it respects the IP address schema and as long as it is reachable by our computer.
    That means on the same network or on another network, but with a router between
    both. However, be careful, as the IP address you chose has to be unique on a local
    network segment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置Arduino的IP地址。只要它遵守IP地址方案，并且我们的计算机可以访问，我们就可以使用任何地址。这意味着在同一网络或另一网络，但两者之间有一个路由器。然而，请注意，您选择的IP地址必须在本地网络段中是唯一的。
- en: We also choose a UDP port for our communication. We are using the same definition
    with network parameters related to our computer, the second set of participants
    in the communication.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的通信选择一个UDP端口。我们使用与我们的计算机相关的网络参数相同的定义，这是通信中的第二组参与者。
- en: We declare a buffer to store the current received messages at each time. Notice
    the constant `UDP_TX_PACKET_MAX_SIZE`. It is defined in the Ethernet library.
    Basically, it is defined as 24 bytes in order to save memory. We could change
    that. Then, we instantiate the `EthernetUDP` object in order to receive and send
    datagram over UDP. The `setup()` function block contains statements for switch
    and LED, then for Ethernet itself.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个缓冲区来存储每次接收到的当前消息。注意常量`UDP_TX_PACKET_MAX_SIZE`。它在Ethernet库中定义。基本上，它被定义为24字节，以节省内存。我们可以更改它。然后，我们实例化`EthernetUDP`对象，以便通过UDP接收和发送数据报。`setup()`函数块包含开关和LED的语句，然后是Ethernet本身的语句。
- en: We begin the Ethernet communication using the MAC and IP addresses. Then we
    open and listen at the UDP port defined in the definition, which is 9999 in our
    case. The `loop()` function seems a bit thick, but we can divide it in 2 parts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用MAC和IP地址开始以太网通信。然后我们打开并监听定义中指定的UDP端口，在我们的例子中是9999。`loop()`函数看起来有点复杂，但我们可以将其分为两部分。
- en: In the first part, we check if the Arduino has received a packet. If it has,
    it is checked by calling the `parsePacket()` function of the Ethernet library
    and checking if that one returns a packet size different than zero. We read the
    data and store it into the `packetBuffer` variable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们检查Arduino是否已收到数据包。如果收到了，它将通过调用Ethernet库的`parsePacket()`函数并检查它是否返回一个非零的数据包大小来检查。我们读取数据并将其存储在`packetBuffer`变量中。
- en: Then we check if this variable equals `Light` or `Dark` and act accordingly
    by switching on or off the LED on the Arduino board.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查这个变量是否等于`Light`或`Dark`，并相应地通过在Arduino板上打开或关闭LED来采取行动。
- en: In the second part, we can see the same debouncing structure as we have seen
    in [Chapter 5](ch05.html "Chapter 5. Sensing with Digital Inputs"). At the end
    of this part, we check if the switch is pushed or released and depending on the
    state send a UDP message to the computer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们可以看到与我们在[第5章](ch05.html "第5章. 使用数字输入进行感应")中看到的相同的防抖结构。在这一部分的末尾，我们检查开关是否被按下或释放，并根据状态向计算机发送UDP消息。
- en: Let's check the Processing/Computer part now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查Processing/计算机部分。
- en: Coding a Processing Applet communicating on Ethernet
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个通过以太网通信的Processing Applet
- en: Let's check the code at `Chapter11/WiredEthernetProcessing`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`Chapter11/WiredEthernetProcessing`中的代码。
- en: We need the library hypermedia. We can find it at [http://ubaa.net/shared/processing/udp](http://ubaa.net/shared/processing/udp).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要超媒体库。我们可以在[http://ubaa.net/shared/processing/udp](http://ubaa.net/shared/processing/udp)找到它。
- en: '[PRE2]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import the library first. Then we define the UDP object and a String variable
    for the current received message.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入库。然后我们定义UDP对象和用于当前接收消息的String变量。
- en: Here too, we have to define the IP address of the remote participant, the Arduino.
    We also define the port opened and available for the communication on the Arduino
    side, here it is 9999.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也必须定义远程参与者，即Arduino的IP地址。我们还要定义在Arduino侧打开并可用于通信的端口，这里为9999。
- en: Of course, this has to match the one defined in the Arduino firmware. In the
    `setup()` function, we define some drawing parameters and then instantiate the
    UDP socket on the UDP port 10000 and we set it to listening mode, waiting for
    incoming messages.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这必须与在Arduino固件中定义的相匹配。在`setup()`函数中，我们定义了一些绘图参数，然后实例化UDP端口10000上的UDP套接字，并将其设置为监听模式，等待传入的消息。
- en: In the `draw()` function, we draw a circle. The `receive()` function is a callback
    used by the code when packets are incoming. We test the length of packets in bytes
    because we want to react to only two different messages here (`Pushed` or `Released`),
    so we check if the length is 6 or 8 bytes. All other packets won't be processed.
    We could implement a better checking mechanism, but this one works fine.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，我们画一个圆。`receive()`函数是代码在接收到数据包时调用的回调函数。我们测试数据包的字节数长度，因为我们只想对两种不同的消息做出反应（`Pushed`或`Released`），所以我们检查长度是否为6或8字节。所有其他数据包都不会被处理。我们可以实现一个更好的检查机制，但这个方法已经足够好。
- en: As soon as one of these lengths match, we concatenate each byte into the String
    variable `currentMessage`. This provides an easy way to compare the content to
    any other string.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些长度中的任何一个匹配，我们就将每个字节连接到String变量`currentMessage`中。这提供了一种方便的方法来比较内容与任何其他字符串。
- en: Then, we compare it to `Pushed` and `Released` and act accordingly by sending
    back the message `Light` to the Arduino and filling our drawn circle with white
    color, or by sending back the message `Dark` to the Arduino and filling our drawn
    circle with black color.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将它与`Pushed`和`Released`进行比较，并相应地通过向Arduino发送消息`Light`来填充我们绘制的圆圈为白色，或者通过向Arduino发送消息`Dark`来填充我们绘制的圆圈为黑色。
- en: We just designed our first basic communication protocol using Ethernet and UDP.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用以太网和UDP设计了我们第一个基本的通信协议。
- en: Some words about TCP
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于TCP的一些话
- en: In my own design, I often use UDP for communication between systems. It is much
    lighter than TCP and is quite sufficient for our purposes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的设计中，我经常使用UDP在系统之间进行通信。它比TCP轻得多，并且对我们的目的来说已经足够。
- en: In some cases, you would need to have the flow control provided by TCP. The
    Ethernet library we just used provides TCP features too. You can find the reference
    page at [http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要TCP提供的流控制。我们刚刚使用的以太网库也提供了TCP功能。你可以在[http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet)找到参考页面。
- en: '`Server` and `Client` classes can be used for this purpose especially, implementing
    function testing if a connection has been opened, if it is still valid, and so
    on.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server`和`Client`类可以特别用于此目的，实现功能测试，例如检查是否已打开连接，是否仍然有效等。'
- en: We will learn how to connect our Arduino to some live server on the Internet
    at the end of this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将学习如何将我们的Arduino连接到互联网上的某个实时服务器。
- en: Bluetooth communications
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙通信
- en: Bluetooth is a wireless technology standard. It provides a way to exchange data
    over short distances using short-wavelength radio transmissions in the band 2,400
    to 2,480 MHz.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙是一种无线技术标准。它提供了一种使用2,400到2,480 MHz频段内的短波无线电传输在短距离内交换数据的方法。
- en: It allows to create PANs (Personal Area Networks) with the "correct" level of
    security. It is implemented on various types of devices such as computers, smartphones,
    sound systems that can read digital audio from a remote source, and so on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许创建具有“正确”安全级别的PANs（个人区域网络）。它被应用于各种类型的设备上，例如计算机、智能手机、音响系统等，这些设备可以从远程源读取数字音频。
- en: Arduino BT board natively implements this technology. It is now supplied with
    ATmega328 and a Bluegiga WT11 Bluetooth module. The reference page is `http://www.arduino.cc/en/Main/ArduinoBoardBluetooth`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino BT板原生实现了这项技术。它现在配备了ATmega328和Bluegiga WT11蓝牙模块。参考页面是`http://www.arduino.cc/en/Main/ArduinoBoardBluetooth`。
- en: In my opinion, the best way to proceed in many projects is to keep a general
    purpose board at the core of our designs and to add new features by adding only
    what we need as external modules. Following this, we are going to use the Arduino
    UNO R3 here with an external Bluetooth module.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，在许多项目中，最好的做法是将通用板放在设计的核心，并通过添加外部模块仅添加我们需要的功能。因此，我们将在这里使用Arduino UNO R3和一个外部蓝牙模块。
- en: We are going to make a small project using Processing again. You click somewhere
    over the Processing canvas and the Processing applet sends a message over Bluetooth
    to the Arduino, which reacts by switching its built-in LED on or off.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Processing制作一个小项目。你可以在Processing画布上点击某个位置，Processing应用程序将通过蓝牙向Arduino发送消息，Arduino会通过切换其内置LED的开或关来做出反应。
- en: Wiring the Bluetooth module
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接蓝牙模块
- en: 'Check the following figures:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下图示：
- en: '![Wiring the Bluetooth module](img/7584_11_009.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![连接蓝牙模块](img/7584_11_009.jpg)'
- en: RN41 Bluetooth module wired to the Arduino via a serial link
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: RN41蓝牙模块通过串行链路连接到Arduino
- en: 'The corresponding circuit diagram is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路图如下：
- en: '![Wiring the Bluetooth module](img/7584_11_010.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![连接蓝牙模块](img/7584_11_010.jpg)'
- en: Roving Networks RN41 module wired to the Arduino board
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将Roving Networks RN41模块连接到Arduino板
- en: There is a Roving Networks RN41 Bluetooth module wired to the Arduino board.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Roving Networks RN41蓝牙模块连接到Arduino板。
- en: You can find it at[https://www.sparkfun.com/products/10559](https://www.sparkfun.com/products/10559).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.sparkfun.com/products/10559](https://www.sparkfun.com/products/10559)找到它。
- en: Here we are using the basic serial link communication between the Arduino itself
    and the Bluetooth module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用Arduino本身和蓝牙模块之间的基本串行链路通信。
- en: We suppose our computer has Bluetooth capabilities and that those are activated.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的计算机具有蓝牙功能，并且这些功能已被激活。
- en: Coding the firmware and the Processing applet
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写固件和Processing小程序
- en: The firmware is as follows. You can find it in at `Chapter11/Bluetooth`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 固件如下。您可以在`Chapter11/Bluetooth`中找到它。
- en: '[PRE3]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We basically instantiate the `Serial` communication with the Bluetooth module,
    then we check if any bytes are available from it and parse them. If a message
    is available and equals 1, we switch on the LED; if it equals 0, we switch off
    the LED.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上使用蓝牙模块实例化`Serial`通信，然后检查是否有任何字节从其中可用并解析它们。如果有一个消息可用并且等于1，我们打开LED；如果它等于0，我们关闭LED。
- en: 'The processing code is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 处理代码如下：
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We first include the serial library. In the `setup()` function, we define some
    drawing bits, then we print the list of serial device to the Processing log area.
    This displays a list and we have to find the right Bluetooth module of our computer.
    In my case, this was the third one and I used this to instantiate the `Serial`
    communication in the latest statement of the `setup()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含串行库。在`setup()`函数中，我们定义了一些绘图位，然后我们将串行设备列表打印到Processing日志区域。这显示了一个列表，我们必须找到我们计算机的正确蓝牙模块。在我的情况下，这是第三个，我使用这个在`setup()`函数的最后一条语句中实例化`Serial`通信：
- en: '[PRE5]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `draw()` function only sets up:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数只设置：'
- en: Background color according to the variable `bgcolor`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景颜色根据变量`bgcolor`
- en: Stroke color according to the variable `fgcolor`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮廓颜色根据变量`fgcolor`
- en: Fill color according to the variable `fgcolor`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充颜色根据变量`fgcolor`
- en: Then we draw a square.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们画一个正方形。
- en: The `mousePressed()` and `mouseReleased()` functions are two Processing callbacks
    respectively which are called when a mouse event occurs, when you push a button
    on the mouse and release it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousePressed()`和`mouseReleased()`函数是Processing回调函数，分别在鼠标事件发生时调用，当你按下鼠标按钮并释放它时。'
- en: As soon as the mouse is pressed, we check where the cursor was when it was pressed.
    In my case, I defined the area inside the square.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按下时，我们检查按下时的光标位置。在我的情况下，我定义了正方形内的区域。
- en: If we press the button in the square, a visual feedback occurs in order to tell
    us the order has been received, but the most important thing is the `digitalWrite('1')`
    function of course.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下正方形中的按钮，会出现视觉反馈，以告诉我们已收到命令，但当然最重要的是`digitalWrite('1')`函数。
- en: We write the value 1 to the Bluetooth module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值1写入蓝牙模块。
- en: In the same way, as soon as we release the mouse button, a "0" is written to
    the Bluetooth module of the computer. Of course, these messages are sent to the
    Arduino and the latter switches the LED on or off.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们释放鼠标按钮时，一个“0”被写入计算机的蓝牙模块。当然，这些消息被发送到Arduino，后者打开或关闭LED。
- en: We just checked a nice example of an external module providing wireless Bluetooth
    communication feature to the Arduino.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚检查了一个外部模块提供无线蓝牙通信功能的Arduino的示例。
- en: As we noticed, we don't have to use a particular library for this purpose because
    the module itself is able to connect and send/receive data by itself only if we
    send serial data to it. Indeed, the communication between Arduino and the module
    is a basic serial one.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所注意到的，我们不需要为此目的使用特定的库，因为模块本身只有当我们向它发送串行数据时，才能自行连接和发送/接收数据。确实，Arduino和模块之间的通信是一种基本的串行通信。
- en: Let's improve our data communication over the air using Ethernet Wi-Fi.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以太网Wi-Fi改进我们的空中数据通信。
- en: Playing with Wi-Fi
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转Wi-Fi
- en: We previously learned how to use the Ethernet library. Then, we tested Bluetooth
    for short-range network communications. Now, let's test Wi-Fi for medium range
    communications still without any wire.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学习了如何使用以太网库。然后，我们测试了蓝牙进行短距离网络通信。现在，让我们测试Wi-Fi进行中等距离通信，仍然没有任何线缆。
- en: What is Wi-Fi?
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Wi-Fi？
- en: Wi-Fi is a set of communication protocols wireless driven by standards of IEEE
    802.11\. These standards describe characteristics of Wireless Local Area Networks
    (WLANs).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi 是一套由 IEEE 802.11 标准驱动的无线通信协议。这些标准描述了无线局域网（WLAN）的特性。
- en: Basically, multiple hosts having Wi-Fi modules can communicate using their IP
    stacks without wire. There are multiple networking modes used by Wi-Fi.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，拥有 Wi-Fi 模块的多个主机可以通过它们的 IP 堆栈无线通信。Wi-Fi 使用了多种网络模式。
- en: Infrastructure mode
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施模式
- en: In that mode, Wi-Fi hosts can communicate between each other via an access point.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，Wi-Fi 主机可以通过接入点相互通信。
- en: This access point and hosts have to be set up with the same **Service** **Set**
    **Identifier** (SSID), which is a network name used as a reference.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接入点和主机必须使用相同的**服务集标识符**（SSID），这是一个用作参考的网络名称。
- en: This mode is interesting because it provides security by the fact that each
    host has to pass by the access point in order to access the global network. We
    can configure some access lists in order to control which host can connect and
    which cannot.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很有趣，因为它通过每个主机必须通过接入点才能访问全局网络的事实来提供安全性。我们可以配置一些访问列表来控制哪些主机可以连接，哪些不能。
- en: '![Infrastructure mode](img/7584_11_011.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![基础设施模式](img/7584_11_011.jpg)'
- en: Hosts exchanging data through an access point in infrastructure mode
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础设施模式下通过接入点交换数据的宿主
- en: Ad hoc mode
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时模式
- en: In this mode, each host can connect to each one directly without access points.
    It is very useful to quickly connect two hosts in order to share documents and
    exchange data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，每个主机可以直接连接到另一个主机，而不需要接入点。这对于快速连接两个主机以共享文档和交换数据非常有用。
- en: '![Ad hoc mode](img/7584_11_012.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![临时模式](img/7584_11_012.jpg)'
- en: Two hosts directly connected in ad hoc mode
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在临时模式下直接连接的两个主机
- en: Other modes
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他模式
- en: There are also two other modes. **Bridge** **mode** is a way to link multiple
    access points. We can imagine a work group sparse in two buildings; we could use
    two different access points and connect them together using a bridge mode.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他模式。**桥接模式**是一种连接多个接入点的方式。我们可以想象一个分散在两座建筑中的工作组；我们可以使用两个不同的接入点，并通过桥接模式将它们连接起来。
- en: There is also a trivial mode named **range-extender mode**. It is used to repeat
    the signal and provide a connection between two hosts, two access points or a
    host, and an access point when those are too far.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 **范围扩展模式** 的简单模式。它用于重复信号，并在两个主机、两个接入点或主机和接入点之间提供连接，当它们距离太远时。
- en: The Arduino Wi-Fi shield
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino Wi-Fi 扩展板
- en: 'This shield adds the wireless networking capabilities to the Arduino board.
    The official shield also contains an SD card slot providing storing features too.
    It provides:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展板为 Arduino 板增加了无线网络功能。官方扩展板还包含一个 SD 卡槽，提供存储功能。它提供：
- en: Connection via 802.11b/g networks
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 802.11b/g 网络进行连接
- en: Encryption using WEP or WPA2 personal
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WEP 或 WPA2 个人加密
- en: FTDI connection for serial debugging of the shield itself
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于扩展板本身串行调试的 FTDI 连接
- en: Mini-USB to update the Wi-Fi shield firmware itself
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mini-USB 用于更新 Wi-Fi 扩展板的固件
- en: '![The Arduino Wi-Fi shield](img/7584_11_013.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino Wi-Fi 扩展板](img/7584_11_013.jpg)'
- en: The Arduino Wi-Fi Shield
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Wi-Fi 扩展板
- en: It is based on the HDG104 Wireless LAN 802.11b/g system in-package. A proper
    Atmega 32 UC3 provides the network IP stack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于 HDG104 无线局域网 802.11b/g 系统封装。适当的 Atmega 32 UC3 提供了网络 IP 堆栈。
- en: A dedicated native library named **WiFi library** provides all that we need
    to connect our board wireless to any network. The reference is provided at [http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **WiFi 库** 的专用本地库提供了我们将板子无线连接到任何网络所需的所有功能。参考信息可在[http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi)找到。
- en: 'This shield is available from many distributors as well as from the Arduino
    store: [http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237](http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展板可以从许多分销商以及 Arduino 商店购买：[http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237](http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237)。
- en: Let's try to connect our Arduino to our Wi-Fi network.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将我们的 Arduino 连接到 Wi-Fi 网络。
- en: Basic Wi-Fi connection without encryption
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无加密的基本 Wi-Fi 连接
- en: Here, we don't have to draw any schematic. Basically, we connect the shield
    to the Arduino and upload our code to it. We are going to test a basic connection
    without encrypting anything, at first.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们不需要绘制任何原理图。基本上，我们将盾牌连接到Arduino并上传我们的代码。我们首先将测试一个不进行加密的基本连接。
- en: The Accept Point has to provide a DHCP server; the latter will deliver an IP
    address to our Arduino-based system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接受点必须提供DHCP服务器；后者将为我们的基于Arduino的系统提供一个IP地址。
- en: Let's check the example `ConnectNoEncryption` provided with the `WiFi` library.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`WiFi`库提供的示例`ConnectNoEncryption`。
- en: '[PRE6]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At first, we include the `WiFi` library. Then, we set the name of our network,
    the SSID. Please be careful to change it to your own SSID.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含`WiFi`库。然后，我们设置我们网络的名称，即SSID。请务必将其更改为您自己的SSID。
- en: In the `setup()` function, we instantiate the `Serial` connection. Then, we
    check the presence of the shield by calling the function `WiFi.status()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们实例化`Serial`连接。然后，我们通过调用函数`WiFi.status()`来检查盾牌的存在。
- en: If the latter returns the value `WL_NO_SHIELD` (which is a constant defined
    inside the WiFi library), that means there is no shield. In that case, an infinite
    loop is executed with a `while(true)` statement without the `break` keyword inside.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后者返回的值是`WL_NO_SHIELD`（这是在WiFi库内部定义的一个常量），这意味着没有盾牌。在这种情况下，将执行一个无限循环，使用`while(true)`语句而没有`break`关键字。
- en: If it returns a value different than `WL_CONNECTED`, then we print a statement
    in order to inform that it is trying to connect. Then, `WiFi.begin()` tries to
    connect. This is a usual structure providing a way to try to connect while it
    isn't connected, constantly, and each 10 s considering the `delay()` function
    is called.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它返回的值不同于`WL_CONNECTED`，那么我们将打印一条语句来通知它正在尝试连接。然后，`WiFi.begin()`尝试连接。这是一个常见的结构，提供了一种在不连接时不断尝试连接的方法，并且每10秒调用一次`delay()`函数。
- en: Then, if the connection occurs, the status becomes `WL_CONNECTED`, we exit from
    the `while` loop and continue.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果连接成功，状态变为`WL_CONNECTED`，我们退出`while`循环并继续。
- en: There is something printed to serial too, saying the board has achieved connection
    status.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也会在串行中打印一些信息，表示板子已经达到连接状态。
- en: We also call two functions. These functions print to serial many elements related
    to network parameters and status. I'll let you discover each of them using the
    [http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi) reference
    quoted earlier.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了两个函数。这些函数会打印与网络参数和状态相关的许多元素。我将让您通过之前引用的[http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi)参考来发现每个函数。
- en: After this connection, we can begin to exchange data. As you probably know,
    using Wi-Fi especially without security can lead to problems. Indeed, it is very
    easy to capture packets from an unprotected Wi-Fi network.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此连接之后，我们可以开始交换数据。正如您可能知道的，使用Wi-Fi（尤其是没有安全措施的情况下）可能会导致问题。事实上，从未受保护的Wi-Fi网络捕获数据包非常容易。
- en: Let's use the `WiFi` library with more security.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用更安全的`WiFi`库。
- en: Arduino Wi-Fi connection using WEP or WPA2
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WEP或WPA2的Arduino Wi-Fi连接
- en: If you open both code `ConnectWithWEP` and `ConnectWithWPA`, there are minor
    differences with the preceding example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`ConnectWithWEP`和`ConnectWithWPA`这两个代码，与前面的例子相比只有一些细微的差别。
- en: Using WEP with Wi-Fi library
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用WiFi库中的WEP
- en: If we use a 40-bit WEP, we need a key containing 10 characters that must be
    hexadecimal. If we use 128-bit WEP, we need a key containing 26 characters, also
    hexadecimal. This key must be specified within the code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用40位WEP，我们需要一个包含10个字符的密钥，这些字符必须是十六进制的。如果我们使用128位WEP，我们需要一个包含26个字符的密钥，这些字符也必须是十六进制的。这个密钥必须在代码中指定。
- en: We replaced the call to `WiFi.begin()`, which had only one argument, by two
    new arguments related to WEP encryption. This is the only difference.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两个与WEP加密相关的新参数替换了只带一个参数的`WiFi.begin()`调用。这是唯一的区别。
- en: For many reasons that we won't discuss here, WEP is considered too weak in terms
    of security, so most people and organizations have moved to the more secure WPA2
    alternative.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多我们在这里不会讨论的原因，WEP在安全性方面被认为太弱，因此大多数人和组织已经转向更安全的WPA2替代方案。
- en: Using WPA2 with Wi-Fi library
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用WiFi库中的WPA2
- en: 'Following the same schema, we need only a password here. Then, we call `WiFi.begin()`
    with 2 arguments: the SSID and the password.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的方案，这里我们只需要一个密码。然后，我们用两个参数调用`WiFi.begin()`：SSID和密码。
- en: In both cases we just checked, we only had to pass some additional arguments
    with `WiFi.begin()` in order to secure things a bit more.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查的两种情况下，我们只需要在`WiFi.begin()`中传递一些额外的参数，以便使事情更加安全。
- en: Arduino has a (light) web server
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino有一个（轻量级）网络服务器
- en: Here, we use the code `WifiWebServer` provided with the library.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用库中提供的`WifiWebServer`代码。
- en: In this example, Arduino acts as a web server after having been connected to
    a WEP or WPA Wi-Fi network.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Arduino在连接到WEP或WPA Wi-Fi网络后充当一个网络服务器。
- en: '[PRE7]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's explain the underlying concepts in these statements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这些语句背后的概念。
- en: We explain only the new part of the code, not the autoconnect and encryption
    statements, because we did that earlier.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只解释代码的新部分，而不是自动连接和加密语句，因为我们之前已经做过这些。
- en: The `WiFiServer server(80)` statement instantiates a server on a specific port.
    Here, the TCP port chosen is 80, the standard HTTP server TCP port.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`WiFiServer server(80)`语句在特定端口上实例化一个服务器。在这里，选择的TCP端口是80，这是标准的HTTP服务器TCP端口。'
- en: In the `setup()` function, we auto-connect the Arduino to the Wi-Fi network,
    then we start the server. Basically, it opens a socket on TCP port 80 and begins
    to listen on this port.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们自动将Arduino连接到Wi-Fi网络，然后启动服务器。基本上，它会在TCP端口80上打开一个套接字并开始监听该端口。
- en: In the `loop()` function, we check if there is an incoming client to our web
    server embedded on the Arduino. This is done with `WiFiClient client = server.available();`
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop()`函数中，我们检查是否有客户端连接到Arduino上嵌入的网络服务器。这是通过`WiFiClient client = server.available();`来完成的。
- en: Then, we have a condition on client instance. If there is no client, we basically
    do nothing, and execute the loop again until we have a client.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对客户端实例有一个条件。如果没有客户端，我们基本上什么都不做，并再次执行循环，直到我们有客户端。
- en: As soon as we have one, we print this to serial in order to give feedback. Then,
    we check if the client is effectively connected and if there is data in the reading
    buffer. We then print this data if it is available and answer the client by sending
    the standard HTTP response header. This is done basically by printing bytes to
    the client instance itself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了连接，我们就将其打印到串行端口以提供反馈。然后，我们检查客户端是否真正连接，以及读取缓冲区中是否有数据。如果有数据，我们就将其打印出来，并通过发送标准的HTTP响应头来回答客户端。这基本上是通过将字节打印到客户端实例本身来完成的。
- en: The code includes some dynamic features and sends some values read on the board
    itself like the value coming from the ADC of each analog input.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包括一些动态特性，并发送一些从板上读取的值，如来自每个模拟输入的ADC值。
- en: We could try to connect some sensors and provide values of each of them through
    a webpage directly handled by the Arduino itself. I'll let you check the other
    part of the code. This deals with standard HTTP messages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试连接一些传感器，并通过Arduino直接处理的一个网页直接提供它们的值。我会让你检查代码的其他部分。这部分处理标准的HTTP消息。
- en: Tweeting by pushing a switch
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过按开关来发推文
- en: Connecting the Arduino to networks obviously brings the Internet to mind. We
    could try to create a small system that can send messages over the Internet. I
    choose to use the micro-blogging service Twitter because it provides a nice communication
    API.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将Arduino连接到网络显然让人联想到互联网。我们可以尝试创建一个可以发送互联网消息的小系统。我选择使用微博服务Twitter，因为它提供了一个很好的通信API。
- en: We are going to use the same circuit that we used in the *Wiring Arduino to
    wired Ethernet* section except that here we are using the Arduino MEGA related
    to some memory constraints with a smaller board.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与“将Arduino连接到以太网”部分相同的电路，但在这里我们使用的是与一些内存约束相关的Arduino MEGA，板子更小。
- en: An overview of APIs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API概述
- en: '**API** stands for **Application** **Programming** **Interface**. Basically,
    it defines ways to exchange data with the considered system. We can define APIs
    in our systems in order to make them communicate with others.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**代表**应用程序** **编程** **接口**。基本上，它定义了与考虑的系统交换数据的方式。我们可以在我们的系统中定义API，以便它们可以与其他系统通信。'
- en: For instance, we could define an API in our Arduino firmware that would explain
    how and what to send in order to make the LED on the board switch on and off.
    We won't describe the whole firmware, but we would provide to the world a basic
    document explaining precisely the format and data to send from the Internet, for
    instance, to use it remotely. That would be an API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在我们的Arduino固件中定义一个API，说明如何以及发送什么数据来使板上的LED开关。我们不会描述整个固件，但我们会向世界提供一个基本文档，精确地说明从互联网发送的格式和数据，例如，用于远程使用。那将是一个API。
- en: Twitters API
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter的API
- en: Twitter, as do many other social network-related systems on the Internet, provides
    an API. Other programmers can use it to get data and send data too. All data specifications
    related to Twitters API are available at [https://dev.twitter.com](https://dev.twitter.com).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter，就像互联网上许多其他与社交网络相关的系统一样，提供了一个API。其他程序员可以使用它来获取数据，也可以发送数据。与Twitter API相关的所有数据规范都可以在[https://dev.twitter.com](https://dev.twitter.com)找到。
- en: In order to use the API, we have to create an application on Twitters developer
    website. There are some special security parameters to set up, and we have to
    agree upon some rules of use that respect data requests rate and other technical
    specifications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用API，我们必须在Twitter开发者网站上创建一个应用程序。有一些特殊的设置安全参数，我们必须同意一些使用规则，这些规则尊重数据请求速率和其他技术规范。
- en: We can create an application by going to [https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问[https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new)来创建一个应用程序。
- en: That will provide us with some credential information, in particular an access
    token and a token secret. These are strings of characters that have to be used
    following some protocols to be able to access the API.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一些凭证信息，特别是访问令牌和令牌密钥。这些是必须按照某些协议使用才能访问API的字符字符串。
- en: Using the Twitter library with OAuth support
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用具有OAuth支持的Twitter库
- en: '*Markku Rossi* created a very powerful and reliable library embedding the OAuth
    support and intended for sending tweets directly from the Arduino. The official
    library website is [http://www.markkurossi.com/ArduinoTwitter](http://www.markkurossi.com/ArduinoTwitter).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*马克库·罗西*创建了一个非常强大且可靠的库，它嵌入OAuth支持，并旨在直接从Arduino发送推文。官方库网站是[http://www.markkurossi.com/ArduinoTwitter](http://www.markkurossi.com/ArduinoTwitter)。'
- en: This library needs to be used with a board with more than the usual amount of
    memory. The Arduino MEGA runs it perfectly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库需要与具有比通常更多内存的板子一起使用。Arduino MEGA可以完美运行它。
- en: OAuth is an open protocol to allow secure authorization in a simple and standard
    method from web, mobile, and desktop applications. This is defined at [http://oauth.net](http://oauth.net).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一种开放协议，允许以简单和标准的方法从Web、移动和桌面应用程序进行安全授权。这定义在[http://oauth.net](http://oauth.net)。
- en: Basically, this is a way to enable third-party application to obtain limited
    access to an HTTP service. By sending some specific string of characters, we can
    grant access to a host and make it communicate with the API.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是一种使第三方应用程序能够获得对HTTP服务的有限访问的方法。通过发送一些特定的字符字符串，我们可以授予对主机的访问权限，并使其与API通信。
- en: This is what we are going to do together as a nice example that you could reuse
    for other APIs on the Web.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要一起作为一个很好的示例来做的，你可以将其用于Web上的其他API。
- en: Grabbing credentials from Twitter
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Twitter获取凭证
- en: 'Markku''s library implements the OAuth request signing, but it doesn''t implement
    the OAuth Access Token retrieval flow. We can retrieve our token by using this
    guide on the Twitter website where we created our application: [https://dev.twitter.com/docs/auth/tokens-devtwittercom](https://dev.twitter.com/docs/auth/tokens-devtwittercom).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 马克库的库实现了OAuth请求签名，但没有实现OAuth访问令牌检索流程。我们可以通过使用我们在创建应用程序的Twitter网站上提供的此指南来检索我们的令牌：[https://dev.twitter.com/docs/auth/tokens-devtwittercom](https://dev.twitter.com/docs/auth/tokens-devtwittercom)。
- en: You need to keep handy the Access token and Access token secret, as we are going
    to include them in our firmware.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要随身携带访问令牌和访问令牌密钥，因为我们将它们包含在我们的固件中。
- en: Coding a firmware connecting to Twitter
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写连接到Twitter的固件
- en: Markku's library is easy to use. Here is a possible code connecting the Arduino
    to your Ethernet network so that you can tweet messages directly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 马克库的库易于使用。以下是将Arduino连接到你的以太网网络以便直接发送推文的可能代码。
- en: You can find it at `Chapter11/tweetingButton/`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter11/tweetingButton/`中找到它。
- en: '[PRE8]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s explain things here. Please note, this is a code including many things
    we already discovered and learned together:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里解释一下。请注意，这是一个包含我们已共同发现和学习的许多内容的代码：
- en: Button push with debouncing system
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有去抖动系统的按钮按下
- en: Ethernet connection with the Arduino Ethernet Shield
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arduino以太网盾片的以太网连接
- en: Twitter library example
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter库示例
- en: 'We first include a lot of library headers:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含大量的库头文件：
- en: SPI and Ethernet for network connection
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于网络连接的SPI和以太网
- en: Sha1 for credentials encryption
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sha1用于凭证加密
- en: Time for time and date specific functions used by Twitter library
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter库中用于时间和日期特定功能的时间
- en: EEPROM to store credentials in EEPROM of the board
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EEPROM在板子的EEPROM中存储凭证
- en: Twitter library itself
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter库本身
- en: Then, we include the variable related to the button itself and the debouncing
    system.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们包括与按钮本身和防抖系统相关的变量。
- en: We configure the network parameters. Please notice you have to put your own
    elements here, considering your network and Ethernet shield. Then, we define the
    IP address of Twitter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置网络参数。请注意，您必须根据您的网络和以太网屏蔽器在此处放置自己的元素。然后，我们定义 Twitter 的 IP 地址。
- en: We define the `TWEET_DELTA` constant for further use, with respect to the Twitter
    API use that forbids us from sending too many tweets at a time. Then, we store
    our credentials. Please use yours, related to the application you created on the
    Twitter website for our purpose. At last we create the object twitter.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `TWEET_DELTA` 常量以供以后使用，考虑到 Twitter API 使用禁止我们一次性发送过多推文。然后，我们存储我们的凭据。请使用与您在
    Twitter 网站上创建的应用程序相关的凭据。最后，我们创建对象 twitter。
- en: 'In the `setup()` function, we start the `Serial` connection in order to send
    some feedback to us. We configure the digital pin of the switch and start the
    Ethernet connection. Then, we have all the wizardry about Twitter. We first choose
    the entry point defined by the Twitter API docs itself. We have to put our Access
    token and Token secret here too. Then, we have a compilation condition: `#if TOKEN_IN_MEMORY`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 函数中，我们启动 `Serial` 连接以便向我们发送一些反馈。我们配置开关的数字引脚并启动以太网连接。然后，我们有了关于 Twitter
    的所有魔法。我们首先选择由 Twitter API 文档本身定义的入口点。我们还需要在这里放置我们的访问令牌和令牌密钥。然后，我们有一个编译条件：`#if
    TOKEN_IN_MEMORY`。
- en: '`TOKEN_IN_MEMORY` is defined before as 0 or 1\. Depending on its value, the
    compilation occurs in one manner or another.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`TOKEN_IN_MEMORY` 之前定义为 0 或 1。根据其值，编译以某种方式或另一种方式进行。'
- en: In order to store credentials to the EEPROM of the board, we first have to put
    the value 0\. We compile it and run it on the board. The firmware runs and writes
    the tokens in memory. Then, we change the value to 1 (because tokens are now in
    memory) and we compile it and run it on the board. From now, the firmware will
    read credentials from EEPROM.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将凭据存储到板的 EEPROM 中，我们首先必须将值设置为 0。我们编译它并在板上运行。固件运行并将令牌写入内存。然后，我们将值更改为 1（因为令牌现在在内存中），我们编译它并在板上运行。从现在起，固件将读取
    EEPROM 中的凭据。
- en: Then, the `loop()` function is quite simple considering what we learned before.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，考虑到我们之前学到的内容，`loop()` 函数相当简单。
- en: We first test if the twitter connection to the API is okay. If it is okay, we
    store the time and the time of the last tweet at an initial value. We read the
    debounce value of the digital input.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先测试与 API 的 Twitter 连接是否正常。如果一切正常，我们将时间和最后一条推文的最后时间存储在一个初始值中。我们读取数字输入的防抖值。
- en: If we push the button, we test to see if we did that in less than the `TWEET_DELTA`
    amount of time. If it is the case, we are safe with respect to the Twitter API
    rules and we can tweet.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下按钮，我们会测试是否在 `TWEET_DELTA` 时间内完成。如果是这样，我们就符合 Twitter API 规则，可以发推文。
- en: At last, we store a message in the char array `msg`. And we tweet the message
    by using `twitter.post_status()` function. While using it, we also test what it
    returns. If it returns `1`, it means the tweet occurred. That provides this information
    to the user through serial monitor.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在字符数组 `msg` 中存储一条消息。我们通过使用 `twitter.post_status()` 函数来发推文。在使用它时，我们还测试它返回的内容。如果它返回
    `1`，这意味着推文已成功。通过串行监视器向用户提供此信息。
- en: 'All API providers work in the same way. Here, we were very helped by the Twitter
    library we used, but there are other libraries also for other services on the
    Internet. Also, each service provides the complete documentation to use their
    API. Facebook API resources are available here: [https://developers.facebook.com/](https://developers.facebook.com/).
    Google+ API resources are available here: [https://developers.google.com/+/api/](https://developers.google.com/+/api/).
    Instagram API resources are available here: [http://instagram.com/developer](http://instagram.com/developer).
    And we could find a lot of others.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 API 提供商都以相同的方式工作。在这里，我们得到了我们使用的 Twitter 库的很大帮助，但还有其他库也适用于互联网上的其他服务。每个服务都提供了使用其
    API 的完整文档。Facebook API 资源在此处可用：[https://developers.facebook.com/](https://developers.facebook.com/)。Google+
    API 资源在此处可用：[https://developers.google.com/+/api/](https://developers.google.com/+/api/)。Instagram
    API 资源在此处可用：[http://instagram.com/developer](http://instagram.com/developer)。我们还可以找到很多其他资源。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to extend the area of communication of our Arduino
    boards. We were used to making very local connections; we are now able to connect
    our board to the Internet and potentially communicate with the whole planet.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何扩展我们的Arduino板通信范围。我们以前习惯于进行非常局部的连接；现在我们能够将我们的板连接到互联网，并且有可能与整个地球进行通信。
- en: We described Wired Ethernet, Wi-Fi, Bluetooth connections, and how to use Twitters
    API.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了有线以太网、Wi-Fi、蓝牙连接，以及如何使用Twitter的API。
- en: We could have described the Xbee board, which uses radio frequencies, too, but
    I preferred to describe IP-related stuff because I consider them to be the safest
    way to transmit data. Of course, Xbees shield solution is a very nice one too
    and I used it myself in many projects.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以描述使用无线电频率的Xbee板，但我更倾向于描述与IP相关的内容，因为我认为这是传输数据最安全的方式。当然，Xbee的屏蔽解决方案也是一个非常好的选择，我自己在许多项目中都使用过它。
- en: In the next chapter, we are going to describe and dig into the Max 6 framework.
    This is a very powerful programming tool that can generate and parse data and
    we are going to explain how we can use it with Arduino.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述并深入研究Max 6框架。这是一个非常强大的编程工具，可以生成和解析数据，我们将解释如何将其与Arduino结合使用。
