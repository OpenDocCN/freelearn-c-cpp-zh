- en: '*Chapter 1*: C++, SFML, Visual Studio, and Starting the First Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：C++、SFML、Visual Studio和开始第一个游戏'
- en: Welcome to *Beginning C++ Game Programming*. I will not waste any time in getting
    you started on your journey to writing great games for the PC using C++ and the
    OpenGL powered SFML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*开始C++游戏编程*。我不会浪费时间，将你引入使用C++和OpenGL驱动的SFML编写PC游戏之旅。
- en: 'This is quite a hefty first chapter, but we will learn absolutely everything
    we need so that we have the first part of our first game up and running. Here
    is what we will do in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一章内容相当丰富，但我们将学习我们需要的所有内容，以便我们的第一个游戏的第一部分能够运行起来。以下是本章我们将要做什么：
- en: Find out about the games we will build
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们将要构建的游戏
- en: Meet C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解C++
- en: Find out about Microsoft Visual C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Microsoft Visual C++
- en: Explore SFML and its relationship with C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SFML及其与C++的关系
- en: Setting up the development environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Plan and prepare for the first game project, Timber!!!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第一个游戏项目Timber!!!制定计划和准备
- en: Write the first C++ code of this book and make a runnable game that draws a
    background
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写本书的第一段C++代码，并制作一个可以绘制背景的可运行游戏
- en: The games we will build
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将要构建的游戏
- en: This journey will be smooth as we will learn about the fundamentals of the super-fast
    C++ language one step at a time, and then put this new knowledge to use by adding
    cool features to the five games we are going to build.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段旅程将会很顺利，因为我们将会一步一步地学习超级快速C++语言的基础知识，然后通过为我们将要构建的五个游戏添加酷炫功能来应用这些新知识。
- en: The following are our five projects for this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书的五个项目。
- en: Timber!!!
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Timber!!!
- en: 'The first game is an addictive, fast-paced clone of the hugely successful Timberman,
    which can be found at [http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/).
    Our game, Timber!!!, will introduce us to all the basics of C++ while we build
    a genuinely playable game. Here is what our version of the game will look like
    when we are done and we have added a few last-minute enhancements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个游戏是一个令人上瘾、节奏快速的Timberman克隆版，你可以在[http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/)找到它。我们的游戏，Timber!!!，将在构建一个真正可玩的游戏的同时，让我们了解C++的所有基础知识。以下是完成版本的游戏以及我们添加的一些最后时刻的增强功能将看起来像什么：
- en: '![](img/B14278_01_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_01.jpg)'
- en: Pong
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pong
- en: 'Pong was one of the first video games to be made, and you can find out about
    its history here: [https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong).
    It is an excellent example of how the basics of game object animation and dynamic
    collision detection work. We will build this simple retro game to explore the
    concept of classes and object-oriented programming. The player will use the bat
    at the bottom of the screen and hit the ball back to the top of the screen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pong是首批制作出的视频游戏之一，你可以在[https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong)了解其历史。它是游戏对象动画和动态碰撞检测基础的一个极好例子。我们将构建这个简单的复古游戏来探索类和面向对象编程的概念。玩家将使用屏幕底部的球拍，将球击回屏幕顶部：
- en: '![](img/B14278_01_01b.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_01b.jpg)'
- en: Zombie Arena
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zombie Arena
- en: 'Next, we will build a frantic, zombie survival shooter, not unlike the Steam
    hit *Over 9,000 Zombies!*, which you can find out more about at [http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/).
    The player will have a machine gun and must fight off ever-growing waves of zombies.
    All this will take place in a randomly generated, scrolling world. To achieve
    this, we will learn about how object-oriented programming allows us to have a
    large **code base** (lots of code) that is easy to write and maintain. Expect
    exciting features such as hundreds of enemies, rapid-fire weaponry, pickups, and
    a character that can be “leveled up” after each wave:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将构建一个疯狂、僵尸生存射击游戏，与Steam热门游戏*Over 9,000 Zombies!*非常相似，你可以在[http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/)了解更多信息。玩家将拥有机关枪，必须击退不断增多的僵尸浪潮。所有这一切都将发生在一个随机生成的滚动世界中。为了实现这一点，我们将学习面向对象编程如何使我们拥有一个大型**代码库**（大量代码），易于编写和维护。期待以下令人兴奋的功能：数百个敌人、快速射击武器、拾取物品以及每个波次后可以“升级”的角色：  '
- en: '![](img/B14278_01_02_(1).jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_02_(1).jpg)'
- en: Thomas was late
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托马斯迟到了
- en: 'The fourth game will be a stylish and challenging single-player and co-op puzzle
    platformer. It is based on the very popular game *Thomas was Alone* ([http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/)).
    Expect to learn about cool topics such as particle effects, OpenGL Shaders, and
    split-screen cooperative multiplayer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第四款游戏将是一款时尚且具有挑战性的单人及合作解谜平台游戏。它基于非常受欢迎的游戏 *托马斯一个人* ([http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/))。你将有机会了解一些酷炫的话题，例如粒子效果、OpenGL着色器以及分屏合作多人游戏：
- en: '![](img/B14278_01_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_03.jpg)'
- en: Tip
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to play any of the games now, you can do so from the download bundle
    in the `Runnable Games` folder. Just double-click on the appropriate `.exe` file.
    Note that, in this folder, you can run either the completed games or any game
    in its partially completed state from any chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想玩任何游戏，你可以从“可运行游戏”文件夹中的下载包中进行。只需双击相应的`.exe`文件即可。请注意，在这个文件夹中，你可以运行任何章节中完成的游戏或任何处于部分完成状态的游戏。
- en: Space Invaders ++
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间入侵者++
- en: The final game will be a Space Invaders clone. In some ways, the game itself
    is not what is important about this project. The project will be used to learn
    about game programming patterns. As will become abundantly clear as this book
    progresses, our code keeps getting longer and more complicated. Each project will
    introduce one or more techniques for coping with this, but the complexity and
    length of our code will keep coming back to challenge us, despite these techniques.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的游戏将是一个空间入侵者克隆版。在某种程度上，游戏本身并不是这个项目最重要的部分。这个项目将用于学习游戏编程模式。随着本书的进展，这一点将变得非常明显，我们的代码变得越来越长、越来越复杂。每个项目都将介绍一种或多种应对这种复杂性的技术，但我们的代码的复杂性和长度将持续挑战我们，尽管有这些技术。
- en: The Space Invaders project (called Space Invaders ++) will show us ways in which
    we can radically reorganize our game code also that we can take control of and
    properly manage our code once and for all. This will leave you with all the knowledge
    you need to plan and build deep, complex, and innovative games, without ending
    up in a tangle of code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 空间入侵者项目（称为空间入侵者++）将向我们展示如何彻底重新组织我们的游戏代码，以及我们如何最终控制并妥善管理我们的代码。这将让你拥有计划构建深度、复杂和创新游戏所需的所有知识，而不会陷入代码的混乱之中。
- en: 'The game will also introduce concepts such as screens, input handlers, and
    entity-component systems. It will also allow us to learn how to let the player
    use a gamepad instead of the keyboard and introduce the C++ concepts of smart
    pointers, casts, assertions, breakpoint debugging, and teach us the most important
    lesson from the whole book: how to build your own unique games:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏还将引入屏幕、输入处理器和实体-组件系统等概念。它还将让我们学习如何让玩家使用游戏手柄而不是键盘，并介绍C++的智能指针、类型转换、断言、断点调试等概念，并教给我们整本书最重要的教训：如何构建你自己的独特游戏：
- en: '![](img/B14278_01_36.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_36.jpg)'
- en: Let’s get started by introducing C++, Visual Studio, and SFML!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍C++、Visual Studio和SFML开始吧！
- en: Meet C++
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识C++
- en: Now that we know what games we will be building, let’s get started by introducing
    C++, Visual Studio, and SFML. One question you might have is, *why use the C++
    language at all?* C++ is fast – very fast. What makes this true is the fact that
    the code that we write is directly translated into machine-executable instructions.
    These instructions are what make the game. The executable game is contained within
    a `.exe` file, which the player can simply double-click to run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了我们将要构建的游戏，让我们通过介绍C++、Visual Studio和SFML来开始吧。你可能会有一个问题，*为什么要使用C++语言呢？*
    C++运行速度快——非常快。这背后的原因是，我们编写的代码被直接转换成机器可执行的指令。这些指令就是游戏。可执行的游戏包含在一个`.exe`文件中，玩家只需双击即可运行。
- en: There are a few steps in the process of changing our code into an executable
    file. First, the **preprocessor** looks to see if any *other code* needs to be
    included within our own code and adds it. Next, all the code is **compiled** into
    **object files** by the **compiler** program. Finally, a third program, called
    the **linker**, joins all the object files into the executable file for our game.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的代码转换为可执行文件的过程中有几个步骤。首先，**预处理器**会检查是否需要将任何**其他代码**包含在我们的代码中，并将其添加进去。接下来，所有代码都被**编译器**程序编译成**目标文件**。最后，一个名为**链接器**的第三方程序将所有目标文件连接成我们的游戏的可执行文件。
- en: In addition, C++ is well established at the same time as being extremely up
    to date. C++ is an **object-oriented programming** (**OOP**) language, which means
    we can write and organize our code using well-tested conventions that make our
    games efficient and manageable. The benefits as well as the necessity of this
    will reveal themselves as we progress through this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C++在同时被广泛采用的同时，也极为更新。C++是一种**面向对象编程**（**OOP**）语言，这意味着我们可以使用经过良好测试的约定来编写和组织我们的代码，使我们的游戏高效且易于管理。随着我们阅读本书的进展，这种好处以及必要性将显现出来。
- en: Most of this *other code* that I referred to, as you might be able to guess,
    is SFML, and we will find out more about SFML in just a minute. The preprocessor,
    compiler, and linker programs I have just mentioned are all part of the Visual
    Studio **integrated development environment** (**IDE**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我所提到的这*其他代码*，正如你可能猜到的，大部分是SFML，我们将在下一分钟内了解更多关于SFML的信息。我刚才提到的预处理器、编译器和链接器程序都是Visual
    Studio **集成开发环境**（**IDE**）的一部分。
- en: Microsoft Visual Studio
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio
- en: Visual Studio hides away the complexity of preprocessing, compiling, and linking.
    It wraps it all up into the press of a button. In addition to this, it provides
    a slick user interface for us to type our code into and manage what will become
    a large selection of code files and other project assets as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio隐藏了预处理器、编译和链接的复杂性。它将所有这些封装在一个按钮的按下中。此外，它还提供了一个流畅的用户界面，让我们可以输入代码，并管理将成为大量代码文件和其他项目资产的项目。
- en: While there are advanced versions of Visual Studio that cost hundreds of dollars,
    we will be able to build all five of our games in the free “**Express 2019 for
    Community**” version. This is the latest free version of Visual Studio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有高级版本的Visual Studio，价格高达数百美元，但我们将能够在免费的“**Express 2019 for Community**”版本中构建我们所有的五个游戏。这是Visual
    Studio的最新免费版本。
- en: SFML
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML
- en: '**SFML** is the **Simple Fast Media Library**. It is not the only C++ library
    for games and multimedia. It is possible to make an argument to use other libraries,
    but SFML seems to come through for me every time. Firstly, it is written using
    object-oriented C++. The benefits of object-oriented C++ are numerous, and you
    will experience them as you progress through this book.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFML**是**简单快速媒体库**。它不是唯一的游戏和多媒体C++库。可以争论使用其他库，但SFML似乎每次都能满足我的需求。首先，它使用面向对象的C++编写。面向对象C++的好处很多，你将在阅读本书的过程中体验到它们。'
- en: SFML is also easy to get started with and is therefore a good choice if you
    are a beginner, yet at the same time it has the potential to build the highest-quality
    2D games if you are a professional. So, a beginner can get started using SFML
    and not worry about having to start again with a new language/library as their
    experience grows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SFML也易于入门，因此如果你是初学者，这是一个不错的选择；同时，如果你是专业人士，它也有潜力构建最高质量的2D游戏。所以，初学者可以使用SFML开始，不必担心随着经验的增长需要重新开始使用新的语言/库。
- en: Perhaps the biggest benefit is that most modern C++ programming uses OOP. Every
    C++ beginner’s guide I have ever read uses and teaches OOP. OOP is the future
    (and the now) of coding in almost all languages, in fact. So why, if you’re learning
    C++ from the beginning, would you want to do it any other way?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的好处可能就是，大多数现代C++编程都使用面向对象编程（OOP）。我读过的每一本C++初学者指南都使用并教授OOP。实际上，在几乎所有语言中，OOP都是编程的未来（以及现在）。那么，如果你是从头开始学习C++，你为什么要用其他方式呢？
- en: SFML has a module (code) for just about anything you would ever want to do in
    a 2D game. SFML works using OpenGL, which can also make 3D games. OpenGL is the
    de facto free-to-use graphics library for games when you want it to run on more
    than one platform. When you use SFML, you are automatically using OpenGL.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SFML有一个模块（代码），几乎可以完成你在2D游戏中想要做的任何事情。SFML使用OpenGL，也可以制作3D游戏。当你想在多个平台上运行时，OpenGL是事实上的免费图形库。当你使用SFML时，你自动使用了OpenGL。
- en: 'SFML allows you to create the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SFML允许你创建以下内容：
- en: 2D graphics and animations, including scrolling game worlds.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D图形和动画，包括滚动游戏世界。
- en: Sound effects and music playback, including high-quality directional sound.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音效果和音乐播放，包括高质量的方向性声音。
- en: Input handling with a keyboard, mouse, and gamepad.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘、鼠标和游戏手柄进行输入处理。
- en: Online multiplayer features.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线多人游戏功能。
- en: The same code can be compiled and linked on all major desktop operating systems,
    and mobile as well!.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一段代码可以在所有主要的桌面操作系统上编译和链接，包括移动设备！。
- en: Extensive research has not uncovered any more suitable ways to build 2D games
    for PC, even for expert developers and especially if you are a beginner and want
    to learn C++ in a fun gaming environment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的研究没有发现更多适合为 PC 构建 2D 游戏的方法，即使是对于经验丰富的开发者，尤其是如果你是一个想在一个有趣的游戏环境中学习 C++ 的初学者。
- en: In the sections that follow, we will set up the development environment, beginning
    with a discussion on what to do if you are using Mac or Linux operating systems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将设置开发环境，首先讨论如果你使用的是 Mac 或 Linux 操作系统时应该做什么。
- en: Setting up the development environment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Now that you know a bit more about how we will be making games, it is time to
    set up a development environment so we can get coding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对我们如何制作游戏有了更多了解，是时候设置一个开发环境，以便我们可以开始编码了。
- en: What about Mac and Linux?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么 Mac 和 Linux 呢？
- en: The games that we will be making can be built to run on Windows, Mac, and Linux!
    The code we use will be identical for each platform. However, each version does
    need to be compiled and linked on the platform for which it is intended, and Visual
    Studio will not be able to help us with Mac and Linux.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要制作的游戏可以被构建为在 Windows、Mac 和 Linux 上运行！我们使用的代码在每个平台上都是相同的。然而，每个版本确实需要针对它打算运行的平台进行编译和链接，而
    Visual Studio 将无法帮助我们处理 Mac 和 Linux。
- en: It would be unfair to say, especially for complete beginners, that this book
    is entirely suited for Mac and Linux users. Although, I guess, if you are an enthusiastic
    Mac or Linux user and you are comfortable with your operating system, you will
    likely succeed. Most of the extra challenges you will encounter will be in the
    initial setup of the development environment, SFML, and the first project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，说这本书完全适合 Mac 和 Linux 用户是不公平的。尽管如此，我想，如果你是一个热情的 Mac 或 Linux 用户，并且你对你的操作系统感到舒适，你很可能会成功。你将遇到的绝大多数额外挑战都将出现在开发环境、SFML
    和第一个项目的初始设置中。
- en: To this end, I can highly recommend the following tutorials, which will hopefully
    replace the next 10 pages (approximately), up to the *Planning Timber!!!* section,
    when this book will become relevant to all operating systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我强烈推荐以下教程，希望它们能替代接下来的 10 页（大约），直到 *规划木材!!!* 这一部分，届时这本书将适用于所有操作系统。
- en: 'For Linux, read this to replace the next few sections: [https://www.sfml-dev.org/tutorials/2.5/start-linux.php](https://www.sfml-dev.org/tutorials/2.5/start-linux.php).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux，阅读以下内容以替换接下来的几节：[https://www.sfml-dev.org/tutorials/2.5/start-linux.php](https://www.sfml-dev.org/tutorials/2.5/start-linux.php)。
- en: 'On Mac, read this tutorial to get started: [https://www.sfml-dev.org/tutorials/2.5/start-osx.php](https://www.sfml-dev.org/tutorials/2.5/start-osx.php).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，阅读这篇教程以开始：[https://www.sfml-dev.org/tutorials/2.5/start-osx.php](https://www.sfml-dev.org/tutorials/2.5/start-osx.php)。
- en: Installing Visual Studio 2019 Community edition
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Visual Studio 2019 社区版
- en: To start creating a game, we need to install Visual Studio 2019\. Installing
    Visual Studio can be almost as simple as downloading a file and clicking a few
    buttons. I will walk you through the installation process a step at a time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建游戏，我们需要安装 Visual Studio 2019。安装 Visual Studio 可以几乎像下载一个文件并点击几个按钮一样简单。我将一步一步地引导你完成安装过程。
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that, over the years, Microsoft is likely to change the name, appearance,
    and download page that’s used to obtain Visual Studio. They are likely to change
    the layout of the user interface and make the instructions that follow out of
    date. However, the settings that we configure for each project are fundamental
    to C++ and SFML, so careful interpretation of the instructions that follow in
    this chapter will likely be possible, even if Microsoft does something radical
    to Visual Studio. Anyway, at the time of writing, Visual Studio 2019 has been
    released for just two weeks, so hopefully this chapter will be up to date for
    a while. If something significant does happen, then I will add an up-to-date tutorial
    on [http://gamecodeschool.com](http://gamecodeschool.com) as soon as I find out
    about it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，多年来，微软可能会更改 Visual Studio 的名称、外观和下载页面，用于获取 Visual Studio 的页面。他们可能会更改用户界面的布局，并使接下来的说明过时。然而，我们为每个项目配置的设置对于
    C++ 和 SFML 是基本的，因此，即使微软对 Visual Studio 进行了激进的改变，仔细解读本章接下来的说明也应该是可能的。无论如何，在写作的时候，Visual
    Studio 2019 已经发布了仅仅两周，所以希望这一章会保持更新一段时间。如果发生了重大事件，那么一旦我发现，我就会在 [http://gamecodeschool.com](http://gamecodeschool.com)
    上添加一个最新的教程。
- en: 'Let’s get started with installing Visual Studio:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装 Visual Studio：
- en: 'The first thing you need is a Microsoft account and login details. If you have
    a Hotmail or MSN email address, then you already have one. If not, you can sign
    up for a free one here: [https://login.live.com/](https://login.live.com/).'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要一个 Microsoft 账户和登录详情。如果你有 Hotmail 或 MSN 电子邮件地址，那么你已经有一个了。如果没有，你可以在这里免费注册一个：[https://login.live.com/](https://login.live.com/)。
- en: The next step is to visit [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    and find the download link for **Community 2019**. This is what it looks like
    at the time of writing:![](img/B14278_01_04.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是访问 [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    并找到 **Community 2019** 的下载链接。这是我写作时的样子！![图片 B14278_01_04.jpg](img/B14278_01_04.jpg)
- en: Save the file to your computer.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存到你的电脑上。
- en: When the download completes, run the download by double-clicking on it. My file,
    at the time of writing, was called `vs_community__33910147.1551368984.exe`. Yours
    will be different based on the current version of Visual Studio.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，通过双击它来运行下载文件。在我写作的时候，我的文件被命名为 `vs_community__33910147.1551368984.exe`。你的文件名将根据当前版本的
    Visual Studio 而有所不同。
- en: After giving permission for Visual Studio to make changes to your computer,
    you will be greeted with the following window. Click **Continue**:![](img/B14278_01_05.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在授予 Visual Studio 允许更改你的电脑的权限后，你将看到一个如下所示的窗口。点击 **继续**：![图片 B14278_01_05.jpg](img/B14278_01_05.jpg)
- en: Wait for the installer program to download some files and set up the next stage
    of the installation. Shortly, you will be presented with the following window:![](img/B14278_01_05a.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待安装程序下载一些文件并设置安装的下一阶段。不久，你将看到一个如下所示的窗口：![图片 B14278_01_05a.jpg](img/B14278_01_05a.jpg)
- en: If you want to choose a new location to install Visual Studio, locate the **Change**
    option and configure the install location. The simplest thing to do is leave the
    file at the default location chosen by Visual Studio. When you are ready, locate
    the **Desktop development with C++** option and select it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要选择一个新的位置来安装 Visual Studio，找到 **更改** 选项并配置安装位置。最简单的事情就是将文件留在 Visual Studio
    默认选择的位置。准备好后，找到 **使用 C++ 进行桌面开发** 选项并选择它。
- en: Next, click the **Install** button. Grab some refreshments as this step might
    take a while.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 **安装** 按钮。准备一些小吃，因为这个步骤可能需要一段时间。
- en: When the process completes, you can close all open windows, including any that
    prompt you to start a new project, as we are not ready to start coding until we
    have installed SFML.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当过程完成后，你可以关闭所有打开的窗口，包括任何提示你开始新项目的窗口，因为我们还没有准备好开始编码，直到我们安装了 SFML。
- en: Now, we are ready to turn our attention to SFML.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把注意力转向 SFML。
- en: Setting up SFML
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 SFML
- en: 'This short tutorial will guide you through downloading the SFML files that
    allow us to include the functionality contained in the library in our projects.
    In addition, we will see how we can use the SFML **DLL** files that will enable
    our compiled object code to run alongside SFML. To set up SFML, follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的教程将指导你下载 SFML 文件，这些文件允许我们将库中的功能包含到我们的项目中。此外，我们还将了解如何使用 SFML **DLL** 文件，这将使我们的编译对象代码能够与
    SFML 一起运行。要设置 SFML，请按照以下步骤操作：
- en: 'Visit this link on the SFML website: [http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php).
    Click on the button that says **Latest stable version**, as shown here:![](img/B14278_01_06.jpg)'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 SFML 网站的此链接：[http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)。点击此处所示的
    **最新稳定版本** 按钮![图片 B14278_01_06.jpg](img/B14278_01_06.jpg)
- en: By the time you read this book, the latest version will almost certainly have
    changed. This won’t matter as long as you do the next step just right. We want
    to download the **32-bit version** of **Visual C++ 2017**. This might sound counter-intuitive
    because we have just installed Visual Studio 2019 and you probably (most commonly)
    have a 64-bit PC. The reason we chose to download the 32-bit version is that Visual
    C++ 2017 is part of Visual Studio 2019 (Visual Studio does more than C++) and
    we will be building games in 32-bit so that they can run on *both* 32- and 64-bit
    machines. Click the **Download** button that’s shown in the following screenshot:![](img/B14278_01_07.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到你阅读这本书的时候，最新版本几乎肯定已经改变了。只要你的下一步操作正确，这并不重要。我们想要下载 **32 位版本** 的 **Visual C++
    2017**。这可能听起来有些不合逻辑，因为我们刚刚安装了 Visual Studio 2019，你很可能（最常见的情况）有一个 64 位 PC。我们选择下载
    32 位版本的原因是 Visual C++ 2017 是 Visual Studio 2019 的一部分（Visual Studio 做的不仅仅是 C++），我们将以
    32 位构建游戏，这样它们就可以在 **32 位** 和 **64 位** 机器上运行。点击以下截图所示的 **下载** 按钮![图片 B14278_01_07.jpg](img/B14278_01_07.jpg)
- en: When the download completes, create a folder at the root of the same drive where
    you installed Visual Studio and name it `SFML`. Also, create another folder at
    the root of the drive where you installed Visual Studio and call it `VS Projects`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当下载完成时，在您安装 Visual Studio 的同一驱动器的根目录下创建一个文件夹，并将其命名为`SFML`。同样，在您安装 Visual Studio
    的驱动器的根目录下创建另一个文件夹，并将其命名为`VS Projects`。
- en: 'Finally, unzip the SFML download. Do this on your desktop. When unzipping is
    complete, you can delete the .zip folder. You will be left with a single folder
    on your desktop. Its name will reflect the version of SFML that you downloaded.
    Mine is called `SFML-2.5.1-windows-vc15-32-bit`. Your filename will likely reflect
    a more recent version. Double-click this folder to see its contents, then double-click
    again into the next folder (mine is called `SFML-2.5.1`). The following screenshot
    shows what my `SFML-2.5.1` folder’s content looks like. Yours should look the
    same:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，解压 SFML 下载文件。请在您的桌面上进行此操作。解压完成后，您可以删除.zip 文件夹。您将剩下桌面上的一个单独文件夹。其名称将反映您下载的
    SFML 版本。我的文件夹名为`SFML-2.5.1-windows-vc15-32-bit`。您的文件名可能反映一个更新的版本。双击此文件夹以查看其内容，然后再次双击进入下一个文件夹（我的文件夹名为`SFML-2.5.1`）。以下截图显示了`SFML-2.5.1`文件夹的内容。您的文件夹内容应该相同：
- en: Copy the entire contents of this folder and paste all the files and folders
    into the `SFML` folder that you created in *Step 3*. For the rest of this book,
    I will refer to this folder simply as “your `SFML` folder”.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制此文件夹的全部内容，并将所有文件和文件夹粘贴到您在**步骤 3**中创建的`SFML`文件夹中。在此书余下的部分，我将简单地称这个文件夹为“您的`SFML`文件夹”。
- en: Now, we are ready to start using C++ and SFML in Visual Studio.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好开始在 Visual Studio 中使用 C++ 和 SFML。
- en: Creating a new project
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'As setting up a project is a fiddly process, we will go through it step by
    step so that we can start getting used to it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置项目是一个繁琐的过程，我们将一步一步地进行，以便我们可以开始习惯这个过程：
- en: 'Start Visual Studio in the same way you start any app: by clicking on its icon.
    The default installation options will have placed a **Visual Studio 2019** icon
    in the Windows start menu. You will see the following window:![](img/B14278_01_10.jpg)'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以您启动任何应用程序的方式启动 Visual Studio：通过点击其图标。默认安装选项将在 Windows 开始菜单中放置一个**Visual Studio
    2019**图标。您将看到以下窗口：![img/B14278_01_10.jpg](img/B14278_01_10.jpg)
- en: Click on the **Create a new project** button, as highlighted in the preceding
    screenshot. You will see the **Create a new project** window, as shown in the
    following screenshot:![](img/B14278_01_11.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击前一张截图中所突出的**创建新项目**按钮。您将看到**创建新项目**窗口，如下所示：![img/B14278_01_11.jpg](img/B14278_01_11.jpg)
- en: In the **Create a new project** window, we need to choose the type of project
    we will be creating. We will be creating a console app, so select **Console App**,
    as highlighted in the preceding screenshot, and click the **Next** button. You
    will then see the **Configure your new project** window. This following screenshot
    shows the **Configure your new project** window after the next three steps have
    been completed:![](img/B14278_01_12.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建新项目**窗口中，我们需要选择我们将要创建的项目类型。我们将创建一个控制台应用程序，因此选择**控制台应用程序**，如前一张截图所示，然后点击**下一步**按钮。接下来，您将看到**配置新项目**窗口。以下截图显示了完成接下来的三个步骤后的**配置新项目**窗口：![img/B14278_01_12.jpg](img/B14278_01_12.jpg)
- en: In the `Timber` in the **Project** **name** field. Note that this causes Visual
    Studio to automatically configure the **Solution name** field to the same name.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**字段中输入`Timber`。请注意，这会导致 Visual Studio 自动将**解决方案名称**字段配置为相同的名称。
- en: In the `VS Projects` folder that we created in the previous tutorial. This will
    be the location that all our project files will be kept.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前教程中创建的`VS Projects`文件夹中。这将是我们所有项目文件存放的位置。
- en: Check the option to **Place solution and project in the same directory**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**将解决方案和项目放在同一目录下**的选项。
- en: Note that the preceding screenshot shows what the window looks like when the
    previous three steps have been completed. When you have completed these steps,
    click **Create**. The project will be generated, including some C++ code. This
    following screenshot shows where we will be working throughout this book:![](img/B14278_01_13.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，前一张截图显示了完成前三个步骤后窗口的外观。当您完成这些步骤后，点击**创建**。项目将被生成，包括一些 C++ 代码。以下截图显示了本书余下的工作区域：![img/B14278_01_13.jpg](img/B14278_01_13.jpg)
- en: 'We will now configure the project to use the SFML files that we put in the
    `SFML` folder. From the main menu, select **Project** | **Timber properties…**.
    You will see the following window:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将配置项目以使用我们放在`SFML`文件夹中的SFML文件。从主菜单中选择**项目** | **Timber属性…**。你会看到以下窗口：
- en: '![](img/B14278_01_14.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_01_14.jpg)'
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the preceding screenshot, the **OK**, **Cancel**, and **Apply** buttons are
    not fully formed. This is likely a glitch with Visual Studio not handling my screen
    resolution correctly. Yours will hopefully be fully formed. Whether your buttons
    appear like mine do or not, continuing with the tutorial will be the same.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，**确定**、**取消**和**应用**按钮没有完全显示。这可能是Visual Studio没有正确处理我的屏幕分辨率导致的错误。希望你的按钮能够完全显示。无论你的按钮是否像我的一样，继续教程的步骤将是相同的。
- en: Next, we will begin to configure the project properties. As these steps are
    quite intricate, I will cover them in a new list of steps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始配置项目属性。由于这些步骤相当复杂，我将用新的步骤列表来介绍。
- en: Configuring the project properties
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置项目属性
- en: 'At this stage, you should have the **Timber Property Pages** window open, as
    shown in the preceding screenshot at the end of the previous section. Now, we
    will begin to configure some properties while using the following annotated screenshot
    for guidance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，你应该已经打开了**Timber属性页**窗口，如前一个部分末尾的截图所示。现在，我们将开始配置一些属性，同时使用以下带注释的截图作为指导：
- en: '![](img/B14278_01_15.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_01_15.jpg)'
- en: 'We will add some fairly intricate and important project settings in this section.
    This is the laborious part, but we will only need to do this once per project.
    What we need to do is tell Visual Studio where to find a special type of code
    file from SFML. The special type of file I am referring to is a `.hpp` file extension.
    All this will become clearer when we eventually start adding our own header files
    in the second project. In addition, we need to tell Visual Studio where it can
    find the SFML library files. In the **Timber Property Pages** window, perform
    the following three steps, which are numbered in the preceding screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一些相当复杂且重要的项目设置。这是比较繁琐的部分，但每个项目我们只需要做一次。我们需要做的是告诉Visual Studio在哪里可以找到SFML的特殊类型代码文件。我指的是具有`.hpp`扩展名的特殊文件。当我们最终开始添加自己的头文件时，这一切都会变得清晰起来。此外，我们还需要告诉Visual
    Studio在哪里可以找到SFML的库文件。在**Timber属性页**窗口中，执行以下三个步骤，这些步骤在先前的截图中有编号：
- en: First (**1**), select **All Configurations** from the **Configuration:** drop
    down.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先（**1**），从**配置：**下拉菜单中选择**所有配置**。
- en: Second (**2**), select **C/C++** then **General** from the left-hand menu.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步（**2**），从左侧菜单中选择**C/C++**然后选择**常规**。
- en: Third (`\SFML\include`. The full path to type, if you located your `SFML` folder
    on your D drive, is as shown in the preceding screenshot; that is, `D:\SFML\include`.
    Vary your path if you installed SFML on a different drive.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步（`\SFML\include`。如果你将`SFML`文件夹放在D盘上，需要输入的完整路径，如前面的截图所示；即`D:\SFML\include`。如果你的SFML安装在不同的驱动器上，请相应地更改路径）。
- en: Click **Apply** to save your configurations so far.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Now, still in the same window, perform these steps, which refer to the following
    annotated screenshot. First (**1**), select **Linker** and then **General**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在这个窗口中，执行以下步骤，这些步骤参考以下带注释的截图。首先（**1**），选择**链接器**然后选择**常规**。
- en: Now, find the `SFML` folder is, followed by `\SFML\lib`. So, the full path to
    type if you located your `SFML` folder on your D drive is, as shown in the following
    screenshot, `D:\SFML\lib`. Vary your path if you installed SFML to a different
    drive:![](img/B14278_01_16.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找到`SFML`文件夹的位置，然后是`\SFML\lib`。所以，如果你将`SFML`文件夹放在D盘上，需要输入的完整路径，如以下截图所示，是`D:\SFML\lib`。如果你的SFML安装在不同的驱动器上，请相应地更改路径！![图片](img/B14278_01_16.jpg)
- en: Click **Apply** to save your configurations so far.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Finally, for this stage, still in the same window, perform these steps, which
    refer to the following annotated screenshot. Switch the **Configuration:** drop
    down (**1**) to **Debug** as we will be running and testing our games in debug
    mode.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在这个阶段，仍然在这个窗口中，执行以下步骤，这些步骤参考以下带注释的截图。将**配置：**下拉菜单（**1**）切换到**调试**，因为我们将在调试模式下运行和测试我们的游戏。
- en: Select **Linker** and then **Input** (**2**).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**链接器**然后选择**输入**（**2**）。
- en: Find the `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`
    at the indicated place. Be extra careful to place the cursor exactly in the right
    place and not to overwrite any of the text that is already there.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定位置找到 `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`。务必将光标放在正确的位置，并且不要覆盖任何已经存在的文本。
- en: Click **OK**:![](img/B14278_01_16a.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK**:![](img/B14278_01_16a.jpg)
- en: Click **Apply** and then **OK**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Apply** 然后点击 **OK**。
- en: Phew; that’s it! We have successfully configured Visual Studio and can move
    on to planning the Timber!!! project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 呼；这就结束了！我们已经成功配置了 Visual Studio，可以继续规划 Timber!!! 项目。
- en: Planning Timber!!!
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划木材！！！
- en: Whenever you make a game, it is always best to start with a pencil and paper.
    If you don’t know exactly how your game is going to work on the screen, how can
    you possibly make it work in code?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你制作游戏时，最好从铅笔和纸开始。如果你不知道你的游戏如何在屏幕上工作，你怎么可能用代码让它工作呢？
- en: Tip
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At this point, if you haven’t already, I suggest you go and watch a video of
    Timberman in action so that you can see what we are aiming for. If you feel your
    budget can stretch to it, then grab a copy and give it a play. It is often on
    sale for under $1 on Steam: [http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你还没有的话，我建议你去看一下 Timberman 的视频，这样你就可以看到我们想要达到的目标。如果你觉得你的预算可以扩展到这个程度，那么就抓起一份来试玩一下。它通常在
    Steam 上以低于 1 美元的价格出售：[http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/)。
- en: 'The features and objects of a game that define the gameplay are known as the
    **mechanics**. The basic mechanics of the game are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义游戏玩法的游戏功能和对象被称为 **机制**。游戏的基本机制如下：
- en: Time is always running out.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间总是不够用。
- en: You can get more time by chopping the tree.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过砍伐树木来获得更多时间。
- en: Chopping the tree causes the branches to fall.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 砍伐树木会导致树枝掉落。
- en: The player must avoid the falling branches.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家必须避开掉落的树枝。
- en: Repeat until time runs out or the player is squished.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复进行，直到时间用完或玩家被压扁。
- en: Expecting you to plan the C++ code at this stage is obviously a bit silly. This
    is, of course, the first chapter of a C++ beginner’s guide. We can, however, take
    a look at all the assets we will use and an overview of what we will need to make
    our C++ code do.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段期望你规划 C++ 代码显然有点愚蠢。这当然是 C++ 初学者指南的第一章。然而，我们可以查看我们将要使用的所有资产以及我们将需要让我们的 C++
    代码执行的大致概述。
- en: 'Take a look at this annotated screenshot of the game:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个游戏的标注截图：
- en: '![](img/B14278_01_17.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_17.jpg)'
- en: 'You can see that we have the following features:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们具有以下功能：
- en: '**The player’s score:** Each time the player chops a log, they will get one
    point. They can chop a log with either the left or the right arrow (cursor) key.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家的得分：** 每次玩家砍倒一根木头，他们将得到一分。他们可以用左箭头或右箭头（光标）键砍倒木头。'
- en: '**Player character:** Each time the player chops, they will move to/stay on
    the same side of the tree relative to the cursor key they use. Therefore, the
    player must be careful which side they choose to chop on.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家角色：** 每次玩家砍伐，他们都会移动到/停留在与鼠标键相对的同一侧的树木上。因此，玩家必须小心他们选择砍伐的侧面。'
- en: When the player chops, a simple axe graphic will appear in the player character’s
    hands.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家砍伐时，一个简单的斧头图形会出现在玩家角色的手中。
- en: '**Shrinking time-bar:** Each time the player chops, a small amount of time
    will be added to the ever-shrinking time-bar.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小的计时条：** 每次玩家砍伐，计时条上都会增加一小段时间。'
- en: '**The lethal branches:** The faster the player chops, the more time they will
    get, but also the faster the branches will move down the tree and therefore the
    more likely they are to get squished. The branches spawn randomly at the top of
    the tree and move down with each chop.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**致命的树枝：** 玩家砍伐得越快，他们得到的时间越多，但树枝也会更快地沿着树木向下移动，因此他们被压扁的可能性也越大。树枝在树的顶部随机生成，并且每次砍伐时向下移动。'
- en: When the player gets squished – and they will get squished quite regularly –
    a gravestone graphic will appear.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被压扁——而且他们会被经常压扁——会出现一个墓碑图形。
- en: '**The chopped log:** When the player chops, a chopped log graphic will whiz
    off, away from the player.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**砍伐的木头：** 当玩家砍伐时，一个砍伐的木头图形会飞离玩家。'
- en: '**Just for decoration:** There are three floating clouds that will drift at
    random heights and speeds, as well as a bee that does nothing but fly around.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅作装饰：** 有三朵漂浮的云彩将在随机的高度和速度下移动，还有一只除了飞来飞去什么都不做的蜜蜂。'
- en: '**The background:** All this takes place on a pretty background.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：所有这些都在一个相当漂亮的背景上发生。'
- en: So, in a nutshell, the player must frantically chop to gain points and avoid
    running out of time. As a slightly perverse, but fun consequence, the faster they
    chop, the more likely their squishy demise is.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，玩家必须疯狂地砍伐以获得分数并避免耗尽时间。作为稍微有些古怪但有趣的结果，他们砍伐得越快，他们柔软的死亡可能性就越大。
- en: 'We now know what the game looks like, how it is played, and the motivation
    behind the game mechanics. Now, we can go ahead and start building it. Follow
    these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经知道了游戏的外观、玩法以及游戏机制背后的动机。现在，我们可以开始构建它了。按照以下步骤进行：
- en: Now, we need to copy the SFML `.dll` files into the main project directory.
    My main project directory is `D:\VS Projects\Timber`. It was created by Visual
    Studio in the previous tutorial. If you put your `VS Projects` folder somewhere
    else, then perform this step there instead. The files we need to copy into the
    project folder are located in your `SFML\bin` folder. Open a window for each of
    the two locations and highlight all the files in the `SFML\bin` folder, as shown
    in the following screenshot:![](img/B14278_01_19.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将SFML `.dll`文件复制到主项目目录中。我的主项目目录是`D:\VS Projects\Timber`。这是在前一个教程中由Visual
    Studio创建的。如果你将`VS Projects`文件夹放在其他地方，那么请在这里执行此步骤。我们需要复制到项目文件夹中的文件位于你的`SFML\bin`文件夹中。为这两个位置打开一个窗口，并突出显示`SFML\bin`文件夹中的所有文件，如下面的截图所示！[](img/B14278_01_19.jpg)
- en: Now, copy and paste the highlighted files into the project folder, that is,
    `D:\VS Projects\Timber`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将突出显示的文件复制并粘贴到项目文件夹中，即`D:\VS Projects\Timber`。
- en: 'The project is now set up and ready to go. You will be able to see the following
    screen. I have annotated this screenshot so you can start familiarizing yourself
    with Visual Studio. We will revisit all these areas, and others, soon:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已经设置好并准备就绪。你将能够看到以下屏幕。我已经注释了这个截图，以便你可以开始熟悉Visual Studio。我们很快会重新访问所有这些区域以及其他区域：
- en: '![](img/B14278_01_20.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_20.jpg)'
- en: Your layout might look slightly different to what’s shown in the preceding screenshot
    because the windows of Visual Studio, like most applications, are customizable.
    Take the time to locate the **Solution Explorer** window on the right and adjust
    it to make its content nice and clear, like it is in the previous screenshot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的布局可能看起来与前面的截图略有不同，因为Visual Studio的窗口，像大多数应用程序一样，是可以定制的。花点时间找到右侧的**解决方案资源管理器**窗口，并调整它，使其内容清晰易懂，就像前面的截图一样。
- en: We will be back here soon to start coding. But first, we will explore the project
    assets we will be using.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会回来开始编码。但首先，我们将探索我们将要使用的项目资产。
- en: The project assets
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目资产
- en: 'Assets are anything you need to make your game. In our case, these assets include
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 资产是你制作游戏所需的一切。在我们的例子中，这些资产包括以下内容：
- en: A font for the writing on the screen
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上文字的字体
- en: Sound effects for different actions, such as chopping, dying, and running out
    of time
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同动作的声音效果，例如砍伐、死亡和耗尽时间
- en: Graphics for the character, background, branches, and other game objects
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色图形、背景、分支和其他游戏对象的图形
- en: All the graphics and sounds that are required for this game are included in
    the download bundle for this book. They can be found in the `Chapter 1/graphics`
    and `Chapter 1/sound` folders as appropriate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的全部图形和声音都包含在这本书的下载包中。它们可以在相应的`第1章/graphics`和`第1章/sound`文件夹中找到。
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding the license. This will not cause a problem,
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的字体尚未提供。这是因为我想避免任何可能的版权模糊。尽管如此，这不会造成问题，因为我会向你展示如何精确地选择和下载字体。
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create or acquire them for yourself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我会提供资产本身或获取它们的信息，但你可能喜欢自己创建或获取它们。
- en: Outsourcing the assets
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包资产
- en: There are a number of websites that allow you to contract artists, sound engineers,
    and even programmers. One of the biggest is Upwork ([www.upwork.com](http://www.upwork.com)).
    You can join this site for free and post your jobs. You will need to write a clear
    explanation of your requirements, as well as state how much you are prepared to
    pay. Then, you will probably get a good selection of contractors bidding to do
    the work. Be aware, however, that there are a lot of unqualified contractors whose
    work might be disappointing, but if you choose carefully, you will likely find
    a competent, enthusiastic, and great-value person or company to do the job.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网站允许你雇佣艺术家、声音工程师，甚至程序员。其中最大的一个是Upwork([www.upwork.com](http://www.upwork.com))。你可以免费加入这个网站并发布你的工作。你需要清楚地说明你的要求，以及你愿意支付多少。然后，你可能会得到很多承包商竞标来完成这项工作。然而，要注意的是，有很多不合格的承包商，他们的工作可能会令人失望，但如果你仔细选择，你很可能会找到一个有能力的、热情的、物有所值的人或公司来完成这项工作。
- en: Making your own sound FX
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作自己的声音效果
- en: Sound effects can be downloaded for free from sites such as Freesound ([www.freesound.org](http://www.freesound.org)),
    but often the licence won’t allow you to use them if you are selling your game.
    Another option is to use an open source software called BFXR from [www.bfxr.net](http://www.bfxr.net),
    which can help you generate lots of different sound effects that are yours to
    keep and do with as you like.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 声音效果可以从Freesound([www.freesound.org](http://www.freesound.org))等网站免费下载，但通常许可协议不允许你在销售游戏时使用它们。另一个选择是使用来自[www.bfxr.net](http://www.bfxr.net)的开源软件BFXR，它可以帮你生成大量不同的声音效果，这些效果你可以保留并随意使用。
- en: Adding the assets to the project
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资源添加到项目中
- en: 'Once you have decided which assets you will use, it is time to add them to
    the project. The following instructions will assume you are using all the assets
    that are supplied in this book’s download bundle. Where you are using your own,
    simply replace the appropriate sound or graphic file with your own, using exactly
    the same filename:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定使用哪些资源，就是时候将它们添加到项目中了。以下说明将假设你正在使用本书下载包中提供的所有资源。如果你使用的是自己的资源，只需用你的声音或图形文件替换相应的文件，使用完全相同的文件名：
- en: Browse to the project folder, that is, `D:\VS Projects\Timber`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到项目文件夹，即`D:\VS Projects\Timber`。
- en: Create three new folders within this folder and name them `graphics`, `sound`,
    and `fonts`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹内创建三个新的文件夹，并分别命名为`graphics`、`sound`和`fonts`。
- en: From the download bundle, copy the entire contents of `Chapter 1/graphics` into
    the `D:\VS Projects\Timber\graphics` folder.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 1/graphics`文件夹的全部内容复制到`D:\VS Projects\Timber\graphics`文件夹。
- en: From the download bundle, copy the entire contents of `Chapter 1/sound` into
    the `D:\VS Projects\Timber\sound` folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 1/sound`文件夹的全部内容复制到`D:\VS Projects\Timber\sound`文件夹。
- en: Now, visit [http://www.1001freefonts.com/komika_poster.font](http://www.1001freefonts.com/komika_poster.font)
    in your web browser and download the **Komika Poster** font.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的网络浏览器中访问[http://www.1001freefonts.com/komika_poster.font](http://www.1001freefonts.com/komika_poster.font)并下载**Komika
    Poster**字体。
- en: Extract the contents of the zipped download and add the `KOMIKAP_.ttf` file
    to the `D:\VS Projects\Timber\fonts` folder.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的内容，并将`KOMIKAP_.ttf`文件添加到`D:\VS Projects\Timber\fonts`文件夹。
- en: Let’s take a look at these assets – especially the graphics – so that we can
    visualize what is happening when we use them in our C++ code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些资源——特别是图形资源——这样我们就可以在我们使用它们在C++代码中时可视化它们。
- en: Exploring the assets
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索资源
- en: 'The graphical assets make up the parts of the scene that is our Timber!!! game.
    If you take a look at the graphical assets, it should be clear where in our game
    they will be used:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资源构成了场景的各个部分，也就是我们的Timber!!!游戏。如果你查看图形资源，应该很清楚它们将在我们的游戏中用于何处：
- en: '![](img/B14278_01_21.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_21.jpg)'
- en: 'The sound files are all in `.wav` format. These files contain the sound effects
    that we will play at certain events throughout the game. They were all generated
    using BFXR and are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 声音文件都是`.wav`格式。这些文件包含我们在游戏中的某些事件中要播放的声音效果。它们都是使用BFXR生成的，如下所示：
- en: '`chop.wav`: A sound that is a bit like an axe (a retro axe) chopping a tree'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chop.wav`: 一种类似斧头（复古斧头）砍树的声音'
- en: '`death.wav`: A sound a bit like a retro “losing” sound'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`death.wav`: 一种类似复古“失败”的声音'
- en: '`out_of_time.wav`: A sound that plays when the player loses by running out
    of time, as opposed to being squashed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out_of_time.wav`: 当玩家因时间耗尽而失败时播放的声音，而不是被压扁'
- en: We have seen all the assets, including the graphics, so now we will have a short
    discussion related to the resolution of the screen and how we position the graphics
    on it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了所有资产，包括图形，因此现在我们将简要讨论屏幕的分辨率以及我们如何在上面定位图形。
- en: Understanding screen and internal coordinates
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解屏幕和内部坐标
- en: Before we move on to the actual C++ coding, let’s talk a little about coordinates.
    All the images that we see on our monitors are made out of pixels. Pixels are
    little tiny dots of light that combine to make the images we see.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实际的C++编码之前，让我们先简单谈谈坐标。我们显示器上看到的所有图像都是由像素组成的。像素是组成我们看到的图像的小小光点。
- en: There are many different resolutions of monitor but, as an example, consider
    that a fairly typical gaming monitor might have 1,920 pixels horizontally and
    1,080 pixels vertically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器有许多不同的分辨率，但以一个例子来说，一个相当典型的游戏显示器可能水平有1,920个像素，垂直有1,080个像素。
- en: 'The pixels are numbered, starting from the top left of the screen. As you can
    see from the following diagram, our 1,920 x 1,080 example is numbered from 0 through
    to 1,919 on the horizontal (x) axis and 0 through 1,079 on the vertical (y) axis:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像素是从屏幕左上角开始编号的。正如您可以从以下图表中看到的那样，我们的1,920 x 1,080示例在水平（x）轴上从0编号到1,919，在垂直（y）轴上从0编号到1,079：
- en: '![](img/B14278_01_31.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_31.jpg)'
- en: 'A specific and exact screen location can therefore be identified by an x and
    y coordinate. We create our games by drawing the game objects such as the background,
    characters, bullets, and text to specific locations on the screen. These locations
    are identified by the coordinates of the pixels. Take a look at the following
    hypothetical example of how we might draw at the approximately central coordinates
    of the screen. In the case of a 1,920 x 1080 screen, this would be at the 960,
    540 position:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过x和y坐标来识别一个特定的屏幕位置。我们通过将游戏对象如背景、角色、子弹和文本绘制到屏幕上的特定位置来创建我们的游戏。这些位置由像素坐标来识别。请看以下假设的例子，说明我们如何绘制到屏幕的大约中心坐标。在一个1,920
    x 1080的屏幕上，这将是在960, 540位置：
- en: '![](img/B14278_01_32.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_32.jpg)'
- en: In addition to the screen coordinates, our game objects will each have their
    own similar coordinate system as well. Like the screen coordinate system, their
    **internal** or **local** coordinates start at 0,0 in the top left-hand corner.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了屏幕坐标外，我们的游戏对象各自还将拥有自己的类似坐标系统。就像屏幕坐标系统一样，它们的**内部**或**局部**坐标从左上角的0,0开始。
- en: In the previous image, we can see that 0,0 of the character is drawn at 960,
    540 of the screen.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张图像中，我们可以看到角色的0,0坐标被绘制在屏幕的960, 540位置。
- en: A visual, 2D game object, such as a character or perhaps a zombie, is called
    a **Sprite**. A sprite is typically made from an image file. All sprites have
    what is known as an **origin**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二维的可视游戏对象，如角色或僵尸，被称为**精灵**。精灵通常由图像文件组成。所有精灵都有一个所谓的**原点**。
- en: 'If we draw a sprite to a specific location on the screen, it is the origin
    that will be located at this specific location. The 0,0 coordinates of the sprite
    are its origin. The following image demonstrates this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在屏幕上的特定位置绘制一个精灵，那么原点将位于这个特定位置。精灵的0,0坐标是其原点。以下图像演示了这一点：
- en: '![](img/B14278_01_33.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_33.jpg)'
- en: Therefore, in the image showing the character drawn to the screen, although
    we drew the image at the central position (960, 540), it appears off to the right
    and down a bit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在显示绘制到屏幕上的角色的图像中，尽管我们在中心位置（960, 540）绘制了图像，但它看起来稍微偏右和向下一点。
- en: This is important to know as it will help us understand the coordinates we use
    to draw all the graphics.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点很重要，因为它将帮助我们理解我们用来绘制所有图形的坐标。
- en: Important note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that, in the real world, gamers have a huge variety of screen resolutions,
    and our games will need to work with as many of them as possible. In the third
    project, we will see how we can make our games dynamically adapt to almost any
    resolution. In this first project, we will need to assume that the screen resolution
    is 1,920 x 1,080\. If your screen resolution is higher, this will be fine. Don’t
    worry if your screen is lower than this as I have provided a separate set of code
    for each chapter for the Timber!!! game. The code files are nearly identical apart
    from adding and swapping a few lines of code near the beginning. If you have a
    lower-resolution screen, then simply follow the code in this book, which assumes
    that you have a 1,920 x 1,080 resolution. When it comes to trying out the game,
    you can copy and paste the code files from the `low res` folder in the first five
    chapters as appropriate. In fact, once the extra lines have been added from this
    first chapter, all the rest of the code will be identical, regardless of your
    screen resolution. I have supplied the low-resolution code for each chapter, just
    as a convenience. How the few lines of code work their magic (scale the screen)
    will be discussed in the third project. The alternative code will work on resolutions
    as low as 960 x 540 and so should be OK on almost any PC or laptop.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在现实世界中，游戏玩家有各种各样的屏幕分辨率，我们的游戏需要尽可能多地与它们兼容。在第三个项目中，我们将看到如何使我们的游戏动态适应几乎任何分辨率。在这个第一个项目中，我们需要假设屏幕分辨率为
    1,920 x 1,080。如果你的屏幕分辨率更高，这将是可以的。如果你的屏幕分辨率低于这个值，请不要担心，因为我为 Timber!!! 游戏的每个章节都提供了一套单独的代码。代码文件几乎完全相同，除了在开头添加和交换几行代码。如果你有低分辨率的屏幕，只需遵循本书中的代码即可，它假设你有一个
    1,920 x 1,080 的分辨率。当尝试运行游戏时，你可以从前五章的 `low res` 文件夹中复制并粘贴相应的代码文件。实际上，一旦从本章添加了额外的行，所有其余的代码都将完全相同，无论你的屏幕分辨率如何。我提供了每个章节的低分辨率代码，仅作为便利。这些几行代码如何施展魔法（调整屏幕分辨率）将在第三个项目中讨论。替代代码将适用于低至
    960 x 540 的分辨率，因此应该几乎在任何 PC 或笔记本电脑上都能正常工作。
- en: Now, we can write our first piece of C++ code and see it in action.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们的第一段 C++ 代码并看到它的实际效果。
- en: Getting started with coding the game
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写游戏代码
- en: Open up Visual Studio if it isn’t already open. Open up the Timber!!! project
    by left-clicking it from the **Recent** list on the main Visual Studio window.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Visual Studio 还未打开，请打开它。通过在主 Visual Studio 窗口的**最近**列表中左键单击它来打开 Timber!!!
    项目。
- en: Find the `Timber.cpp` file under the **Source Files** folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在**源文件**文件夹下找到 `Timber.cpp` 文件。
- en: Important note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: .cpp stands for C plus plus.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: .cpp 代表 C++。
- en: 'Delete the entire contents of the code window and add the following code so
    that you have the same code yourself. You can do so in the same way that you would
    with any text editor or word processor; you could even copy and paste it if you
    prefer. After you have made the edits, we can talk about it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 删除代码窗口中的全部内容，并添加以下代码，以便你有相同的代码。你可以像使用任何文本编辑器或文字处理器一样这样做；如果你更喜欢，甚至可以复制并粘贴。在你完成编辑后，我们可以讨论它：
- en: '[PRE0]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple C++ program is a good place to start. Let’s go through it line by
    line.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的 C++ 程序是一个很好的起点。让我们逐行分析它。
- en: Making code clearer with comments
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注释使代码更清晰
- en: 'The first line of code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行如下：
- en: '[PRE1]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any line of code that starts with two forward slashes (`//`)is a comment and
    is ignored by the compiler. As such, this line of code does nothing. It is used
    to leave in any information that we might find useful when we come back to the
    code at a later date. The comment ends at the end of the line, so anything on
    the next line is not part of the comment. There is another type of comment called
    a **multi-line** or **c-style** comment, which can be used to leave comments that
    take up more than a single line. We will see some of them later in this chapter.
    Throughout this book, I will leave hundreds of comments to help add context and
    further explain the code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以两个正斜杠（`//`）开头的代码行都是注释，并且会被编译器忽略。因此，这一行代码没有任何作用。它用于留下任何我们可能在稍后回到代码时可能觉得有用的信息。注释在行尾结束，所以下一行上的内容不属于注释。还有一种注释类型称为**多行**或**C
    风格**注释，可以用来留下超过单行的注释。我们将在本章后面看到一些例子。在整个书中，我将留下数百条注释，以帮助添加上下文并进一步解释代码。
- en: The main function
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主函数
- en: 'The next line we see in our code is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中看到的下一行如下：
- en: '[PRE2]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`int` is an **integer** or whole number. Hold that thought and we will come
    back to it in a minute.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`是一个**整数**或整个数。记住这个想法，我们将在一分钟内回到它。'
- en: The `main()` part is the name of the section of code that follows. The section
    of code is marked out between the opening curly brace (`{`) and the next closing
    curly brace (`}`).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`部分是后续代码部分的名称。代码部分由开括号（`{`）和下一个闭括号（`}`）之间的内容标记。'
- en: So, everything in between these curly braces `{...}` is a part of `main`. We
    call a section of code like this a **function**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些花括号`{...}`之间的所有内容都是`main`的一部分。我们称这样的代码部分为**函数**。
- en: Every C++ program has a `main` function and it is the place where the `main`
    function, and no matter what code we write, our game will always begin execution
    from the first line of code that’s inside the opening curly brace of the `main`
    function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C++程序都有一个`main`函数，它是`main`函数所在的地方。无论我们编写什么代码，我们的游戏都将从`main`函数开括号内的第一行代码开始执行。
- en: For now, don’t worry about the strange brackets that follow the function name
    `()`. We will discuss them further in [*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*,
    Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics*,
    when we get to see functions in a whole new and more interesting light.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要担心函数名后面的奇怪括号。我们将在[*第4章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*，循环、数组、开关、枚举和函数
    – 实现游戏机制*中进一步讨论它们，当我们从全新的、更有趣的角度看待函数时。
- en: Let’s look closely at the one single line of code within our `main` function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`main`函数中的一行代码。
- en: Presentation and syntax
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 呈现和语法
- en: 'Take a look at the entirety of our `main` function again:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的`main`函数的全部内容：
- en: '[PRE3]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that, inside `Main`, there is just one single line of code, `return
    0;`. Before we move on to find out what this line of code does, let’s look at
    how it is presented. This is useful because it can help us prepare to write code
    that is easy to read and distinguished from other parts of our code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`Main`内部，只有一行代码，`return 0;`。在我们继续了解这一行代码的作用之前，让我们看看它是如何呈现的。这很有用，因为它可以帮助我们准备编写易于阅读且与其他代码部分区分开的代码。
- en: First, notice that `return 0;` is indented to the right by one tab. This clearly
    marks it out as being internal to the `main` function. As our code grows in length,
    we will see that indenting our code and leaving white space will be essential
    to maintaining readability.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`return 0;`缩进了一个制表符到右边。这清楚地表明它是在`main`函数内部的。随着我们的代码长度增加，我们会看到缩进代码和留出空白将对于保持可读性至关重要。
- en: Next, notice the punctuation on the end of the line. A semicolon (`;`) tells
    the compiler that it is the end of the instruction and that whatever follows it
    is a new instruction. We call an instruction that’s been terminated by a semicolon
    a `statement`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意行尾的标点符号。分号（`;`）告诉编译器这是指令的结束，并且其后的任何内容都是一个新的指令。我们称由分号终止的指令为`statement`。
- en: Note that the compiler doesn’t care whether you leave a new line or even a space
    between the semicolon and the next statement. However, not starting a new line
    for each statement will lead to desperately hard-to-read code, and missing the
    semicolon altogether will result in a **syntax error** and the game will not compile
    or run.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器并不关心你在分号和下一个语句之间是否留出新行，甚至是否留有空格。然而，每个语句不开始新行会导致代码难以阅读，而完全遗漏分号则会导致**语法错误**，游戏将无法编译或运行。
- en: A section of code together, often denoted by its indentation with the rest of
    the section, is called a **block**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分一起，通常通过其缩进与其他部分区分，被称为**块**。
- en: Now that you’re comfortable with the idea of the `main` function, indenting
    your code to keep it tidy, and putting a semicolon on the end of each statement,
    we can move on to finding out exactly what the `return 0;` statement actually
    does.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了`main`函数的概念，学会了通过缩进保持代码整洁，并在每个语句的末尾放置分号，我们可以继续了解`return 0;`语句实际上做什么。
- en: Returning values from a function
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: Actually, `return 0;` does almost nothing in the context of our game. The concept,
    however, is an important one. When we use the `return` keyword, either on its
    own or followed by a value, it is an instruction for the program execution to
    jump/move back to the code that got the function started in the first place.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`return 0;`在我们的游戏中几乎没有任何作用。然而，这个概念是非常重要的。当我们使用`return`关键字时，无论是单独使用还是后面跟着一个值，它都是程序执行跳转/移动回最初启动函数的代码的指令。
- en: Often, the code that got the function started will be yet another function somewhere
    else in our code. In this case, however, it is the operating system that started
    the `main` function. So, when `return 0;` is executed, the `main` function exits
    and the entire program ends.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，启动函数的代码将是我们代码中其他地方的另一个函数。然而，在这种情况下，是操作系统启动了`main`函数。因此，当执行`return 0;`时，`main`函数退出，整个程序结束。
- en: Since we have a `0` after the `return` keyword, that value is also sent to the
    operating system. We could change the value of 0 to something else and that value
    would be sent back instead.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`return`关键字后面有一个`0`，这个值也会被发送到操作系统。我们可以将0的值更改为其他值，然后这个值将被发送回去。
- en: We say that the code that starts a function **calls** the function and that
    the function **returns** the value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，启动函数的代码**调用**函数，而函数**返回**值。
- en: You don’t need to fully grasp all this function information just yet. It is
    just useful to introduce it here. There’s one last thing on functions that I will
    cover before we move on. Remember the `int` from `int main()`? This tells the
    compiler that the type of value that’s returned from `main` must be an `int` (integer/whole
    number). We can return any value that qualifies as an `int`; perhaps 0, 1, 999,
    6,358, and so on. If we try and return something that isn’t an `int,` perhaps
    12.76, then the code won’t compile, and the game won’t run.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不需要完全掌握所有这些函数信息。这里只是介绍它。在继续之前，我还会提到关于函数的最后一件事。还记得`int main()`中的`int`吗？这告诉编译器从`main`返回的值的类型必须是`int`（整数/整个数字）。我们可以返回任何符合`int`的值；也许0，1，999，6，358等等。如果我们尝试返回不是`int`的值，比如12.76，那么代码将无法编译，游戏将无法运行。
- en: Functions can return a big selection of different types, including types that
    we invent for ourselves! That type, however, must be made known to the compiler
    in the way we have just seen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回一大类不同的类型，包括我们为自己发明的类型！然而，这种类型必须以我们刚才看到的方式让编译器知道。
- en: This little bit of background information on functions will make things smoother
    as we progress.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点关于函数的背景信息将使我们在前进的过程中更加顺利。
- en: Running the game
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'You can even run the game at this point. Do so by clicking the **Local Windows
    Debugger** button in the quick-launch bar of Visual Studio. Alternatively, you
    can use the *F5* shortcut key:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在这一点上运行游戏。通过点击Visual Studio快速启动栏中的**本地Windows调试器**按钮来这样做。或者，你可以使用*F5*快捷键：
- en: '![](img/B14278_01_34.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_01_34.jpg)'
- en: You will just get a black screen. If the black screen doesn’t automatically
    close itself, you can tap any key to close it. This window is the C++ console,
    and we can use this to debug our game. We don’t need to do this now. What is happening
    is that our program is starting, executing from the first line of `main`, which
    is `return 0;`, and then immediately exiting back to the operating system.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你将只看到一个黑色屏幕。如果黑色屏幕没有自动关闭，你可以按任意键来关闭它。这个窗口是C++控制台，我们可以用它来调试我们的游戏。我们现在不需要这样做。正在发生的事情是，我们的程序正在启动，从`main`函数的第一行开始执行，即`return
    0;`，然后立即返回到操作系统。
- en: We now have the simplest program possible coded and running. We will now add
    some more code to open a window that the game will eventually appear in.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了可能的最简单的程序，已经编码并运行。接下来，我们将添加一些代码来打开一个游戏最终会出现在其中的窗口。
- en: Opening a window using SFML
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML打开窗口
- en: Now, let’s add some more code. The code that follows will open a window using
    SFML that Timber!!! will eventually run in. The window will be 1,920 pixels wide
    by 1,080 pixels high, and will be full screen (no border or title).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些更多的代码。接下来的代码将使用SFML打开一个窗口，Timber!!!最终将在其中运行。窗口将宽1,920像素，高1,080像素，并将全屏（没有边框或标题）。
- en: 'Enter the new code that is highlighted here to the existing code and then we
    will examine it. As you type (or copy and paste), try and work out what is going
    on:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将这里突出显示的新代码输入到现有代码中，然后我们将检查它。当你输入（或复制粘贴）时，尽量弄清楚正在发生的事情：
- en: '[PRE4]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#including SFML features'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '#包括SFML功能'
- en: The first thing we will notice in our new code is the `#include` directive.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新代码中首先注意到的是`#include`指令。
- en: The `#include` `.hpp` file extension means it is a **header** file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` `.hpp`文件扩展名意味着它是一个**头文件**。'
- en: Therefore, `#include <SFML/Graphics.hpp>` tells the preprocessor to include
    the contents of the `Graphics.hpp` file that is contained within the folder named
    `SFML.` It is the same folder that we created while setting up the project.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`#include <SFML/Graphics.hpp>`告诉预处理器包含名为`SFML`的文件夹中`Graphics.hpp`文件的內容。这正是我们在设置项目时创建的文件夹。
- en: This line adds code from the aforementioned file, which gives us access to some
    of the features of SFML. Exactly how it achieves this will become clearer when
    we start writing our own separate code files and using `#include` to use them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行添加了上述文件中的代码，它为我们提供了访问SFML一些功能的方法。它究竟是如何实现这一点的，将在我们开始编写自己的独立代码文件并使用`#include`来使用它们时变得更加清晰。
- en: The main files that we will be including throughout this book are the SFML header
    files that give us access to all the cool game-coding features. We will also use
    `#include` to access the **C++ Standard Library** header files. These header files
    give us access to core features of the C++ language itself.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将包含的主要文件是提供我们访问所有酷炫游戏编程功能的SFML头文件。我们还将使用`#include`来访问**C++标准库**头文件。这些头文件为我们提供了访问C++语言本身核心功能的方法。
- en: What matters for now is that we have a whole bunch of new functionalities that
    have been provided by SFML available to use if we add that single line of code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 目前重要的是，我们有一系列由SFML提供的新功能可供使用，如果我们添加这一行代码。
- en: The next new line is `using namespace sf;`. We will come back to what this line
    does soon.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新行是`using namespace sf;`。我们很快就会回到这一行的作用。
- en: OOP, classes, and objects
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）、类和对象
- en: We will fully discuss OOP, classes, and objects as we proceed through this book.
    What follows is a brief introduction so that we can understand what is happening.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后续内容中全面讨论面向对象编程、类和对象。以下是一个简要介绍，以便我们理解正在发生的事情。
- en: We already know that OOP stands for object-oriented programming. OOP is a programming
    paradigm, that is, a *way* of coding. OOP is generally accepted throughout the
    world of programming, in almost every language, as the best, if not the only,
    professional way to write code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道OOP代表面向对象编程。OOP是一种编程范式，即一种编码方式。OOP在编程界被普遍接受，几乎在所有语言中，都被认为是最好的，如果不是唯一的专业编写代码的方式。
- en: OOP introduces a lot of coding concepts, but fundamental to them all are **classes**
    and **objects**. When we write code, whenever possible, we want to write code
    that is reusable, maintainable, and secure. The way we do this is by structuring
    our code as a class. We will learn how to do this in [*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)*,
    Object-Oriented Programming – Starting the Pong Game*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程引入了许多编程概念，但它们的基础是**类**和**对象**。当我们编写代码时，尽可能希望编写可重用、可维护和安全的代码。我们通过将代码结构化为类来实现这一点。我们将在[*第6章*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)*，面向对象编程
    – 开始Pong游戏*中学习如何做到这一点。
- en: All we need to know about classes for now is that once we have coded our class,
    we don’t just execute that code as part of our game; instead, we create usable
    objects *from* the class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要了解关于类的基本知识，那就是一旦我们编写了我们的类，我们不仅仅是将这段代码作为游戏的一部分来执行；相反，我们是从类中创建可用的对象。
- en: For example, if we wanted 100 zombie `Zombie` and then, from that single class,
    create as many zombie objects as we like. Each and every zombie object would have
    the same functionality and internal data types, but each and every zombie object
    would be a separate and distinct entity.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要100个僵尸`Zombie`，然后从单个类中创建尽可能多的僵尸对象。每一个僵尸对象都会有相同的功能和内部数据类型，但每一个僵尸对象都是一个独立且独特的实体。
- en: 'To take the hypothetical zombie example further but without showing any code
    for the `Zombie` class, we might create a new object based on the `Zombie` class,
    like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐述假设的僵尸例子，但不展示`Zombie`类的任何代码，我们可以基于`Zombie`类创建一个新的对象，如下所示：
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `z1` object is now a fully coded and functioning `Zombie` object. We could
    then do this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`z1`对象现在是一个完全编码并可以运行的`Zombie`对象。然后我们可以这样做：'
- en: '[PRE6]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now have five separate `Zombie` `Zombie` class to enable us to use our `Zombie`
    objects, perhaps like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有五个独立的`Zombie`类，使我们能够使用我们的`Zombie`对象，可能如下所示：
- en: '[PRE7]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note again that all this zombie code is hypothetical for the moment. Don’t type
    this code into to Visual Studio – it will just produce a bunch of errors.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，所有这些僵尸代码目前都是假设性的。不要将此代码输入 Visual Studio，它只会产生一堆错误。
- en: We would design our class so that we can use the data and behaviors in the most
    appropriate manner to suit our game’s objectives. For example, we could design
    our class so that we can assign values for the data for each zombie object at
    the time we create it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的类，以便以最合适的方式使用数据和行为来满足游戏目标。例如，我们可以设计我们的类，以便在创建每个僵尸对象时为其数据分配值。
- en: 'Let’s say we need to assign a unique name and speed in meters per second at
    the time we create each zombie. Careful coding of the `Zombie` class could enable
    us to write code like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在创建每个僵尸时分配一个独特的名称和每秒米数。仔细编写 `Zombie` 类可以让我们写出如下代码：
- en: '[PRE8]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The point is that classes are almost infinitely flexible, and once we have coded
    the class, we can go about using them by creating an object/instance *of* them.
    It is through classes and the objects that we create from them that we will harness
    the power of SFML. And yes, we will also write our own classes, including a `Zombie`
    class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，类几乎是无限灵活的，一旦我们编写了类，我们就可以通过创建它们的对象/实例来使用它们。我们将通过类和我们从中创建的对象来利用 SFML 的力量。是的，我们还将编写自己的类，包括一个
    `Zombie` 类。
- en: Let’s get back to the real code we just wrote.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们刚刚编写的真实代码。
- en: Using namespace sf
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间 sf
- en: Before we move on and look more closely at `VideoMode` and `RenderWindow`, which
    as you have probably guessed are classes provided by SFML, we will learn what
    the `using namespace sf;` line of code does.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入了解 `VideoMode` 和 `RenderWindow` 之前，你可能已经猜到了，它们是 SFML 提供的类，我们将学习 `using
    namespace sf;` 这行代码的作用。
- en: When we create a class, we do so in a `VideoMode` class. It is entirely possible
    that, in an environment such as Windows, somebody has already written a class
    called `VideoMode`. By using a namespace, we and the SFML programmers can make
    sure that the names of classes never clash.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个类时，我们是在 `VideoMode` 类中创建的。在像 Windows 这样的环境中，有人可能已经编写了一个名为 `VideoMode`
    的类。通过使用命名空间，我们和 SFML 程序员可以确保类的名称永远不会冲突。
- en: 'The full way of using the `VideoMode` class is like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `VideoMode` 类的完整方式如下：
- en: '[PRE9]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`using namespace sf;` enables us to omit the `sf::` prefix from everywhere
    in our code. Without it, there would be over 100 instances of `sf::` in this simple
    game alone. It also makes our code more readable, as well as shorter.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`using namespace sf;` 允许我们在代码的任何地方省略 `sf::` 前缀。如果没有它，仅在这个简单的游戏中就会有超过 100 个
    `sf::` 实例。它还使我们的代码更易于阅读，更简洁。'
- en: SFML VideoMode and RenderWindow
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML VideoMode 和 RenderWindow
- en: 'Inside the `main` function, we now have two new comments and two new lines
    of actual code. The first line of actual code is this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，我们现在有了两个新的注释和两行实际的代码。第一行实际代码如下：
- en: '[PRE10]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code creates an object called `vm` from the class called `VideoMode` and
    sets up two internal values of `1920` and `1080`. These values represent the resolution
    of the player’s screen.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 `vm` 的对象，它来自名为 `VideoMode` 的类，并设置了两个内部值 `1920` 和 `1080`。这些值代表了玩家的屏幕分辨率。
- en: 'The next new line of code is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新行代码如下：
- en: '[PRE11]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous line of code, we are creating a new object called `window` from
    the SFML-provided class called `RenderWindow`. Furthermore, we are setting up
    some values inside our window object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们创建了一个名为 `window` 的新对象，它是由 SFML 提供的名为 `RenderWindow` 的类。此外，我们在窗口对象内部设置了一些值。
- en: Firstly, the `vm` object is used to initialize part of `window`. At first, this
    might seem confusing. Remember, however, that a class can be as varied and flexible
    as its creator wants to make it. And yes, some classes can contain other instances
    of other classes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`vm` 对象用于初始化 `window` 的一部分。起初，这可能会让人感到困惑。然而，请记住，一个类可以像其创建者想要的那样多样化、灵活。是的，一些类可以包含其他类的其他实例。
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is not necessary to fully understand how this works at this point, as long
    as you appreciate the concept. We code a class and then make useable objects from
    that class – a bit like an architect might draw a blueprint. You certainly can’t
    move all your furniture, kids, and dog into the blueprint, but you could build
    a house (or many houses) from the blueprint. In this analogy, a class is like
    a blueprint and an object is like a house.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你不需要完全理解它是如何工作的，只要你能理解这个概念即可。我们编写一个类，然后从该类中创建可用的对象——有点像建筑师可能会绘制蓝图。你当然不能把所有的家具、孩子和狗都搬到蓝图里，但你可以从蓝图建造房子（或许多房子）。在这个类比中，类就像蓝图，对象就像房子。
- en: Next, we use the `“Timber!!!”` value to give the window a name. Then, we use
    the predefined `Style::FullScreen` value to make our `window` object fullscreen.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `“Timber!!!”` 值给窗口命名。然后，我们使用预定义的 `Style::FullScreen` 值使我们的 `window`
    对象全屏。
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`Style::FullScreen` is a value that’s defined in SFML. It is useful because
    we don’t need to remember the integer number the internal code uses to represent
    a full screen. The coding term for this type of value is `constant`. Constants
    and their close C++ relatives, **variables**, are covered in the next chapter.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style::FullScreen` 是在 SFML 中定义的一个值。它很有用，因为我们不需要记住内部代码用来表示全屏的整数。这种值的编码术语是 `常量`。常量和它们的
    C++ 亲戚 **变量** 将在下一章中介绍。'
- en: Let’s take a look at our window object in action.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的窗口对象在实际操作中的表现。
- en: Running the game
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: You can run the game again at this point. You will see a bigger black screen
    flash on and then disappear. This is the 1,920 x 1,080 fullscreen window that
    we just coded. Unfortunately, what is still happening is that our program is starting,
    executing from the first line of `main`, creating the cool new game window, then
    coming to `return 0;` and immediately exiting back to the operating system.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以再次运行游戏。你会看到一个更大的黑色屏幕闪烁然后消失。这是我们刚刚编写的 1,920 x 1,080 全屏窗口。不幸的是，目前仍在发生的事情是，我们的程序从
    `main` 的第一行开始执行，创建了一个酷炫的新游戏窗口，然后到达 `return 0;` 并立即退回到操作系统。
- en: Next, we will add some code that will form the basic structure of every game
    in this book. This is known as the game loop.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些代码，这些代码将构成本书中每个游戏的基本结构。这被称为游戏循环。
- en: The main game loop
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主游戏循环
- en: We need a way to stay in the program until the player wants to quit. At the
    same time, we should clearly mark out where the different parts of our code will
    go as we progress with Timber!!!. Furthermore, if we are going to stop our game
    from exiting, we had better provide a way for the player to exit when they are
    ready; otherwise, the game will go on forever!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法，让程序保持运行，直到玩家想要退出。同时，我们应该在继续使用 Timber!!! 的过程中，清楚地标记出代码的不同部分。此外，如果我们想阻止游戏退出，我们最好提供一个让玩家在准备好时退出的方法；否则，游戏将永远继续下去！
- en: 'Add the following highlighted code to the existing code and then we will go
    through it and discuss it all:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下高亮显示的代码添加到现有代码中，然后我们将对其进行审查并讨论：
- en: '[PRE12]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While loops
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当循环
- en: 'The very first thing we saw in the new code is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们首先看到的是以下内容：
- en: '[PRE13]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The very last thing we saw in the new code is a closing `}`. We have created
    a `{`) and closing (`}`) brackets of the `while` loop will continue to execute,
    over and over, potentially forever.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们最后看到的是一个闭合的 `}`。我们创建的 `{` 和闭合的 `}` 括号将不断执行，可能永远如此。
- en: 'Look closely between the parentheses `(...)` of the `while` loop, as shown
    here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察 `while` 循环的括号 `(...)` 之间，如下所示：
- en: '[PRE14]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The full explanation of this code will have to wait until we discus loops and
    conditions in [*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*,
    Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics*.
    What is important for now is that when the `window` object is set to closed, the
    execution of the code will break out of the `while` loop and move on to the next
    statement. Exactly how a window is closed is covered soon.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的完整解释将留待我们在 [*第4章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110) 中讨论循环和条件时再进行，即“循环、数组、开关、枚举和函数
    – 实现游戏机制”。目前重要的是，当 `window` 对象设置为关闭状态时，代码的执行将跳出 `while` 循环并继续执行下一个语句。具体如何关闭窗口将在稍后介绍。
- en: The next statement is, of course, `return 0;`, which ends our game.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句当然是 `return 0;`，这标志着我们游戏的结束。
- en: We now know that our `while` loop will whiz round and round, repeatedly executing
    the code within it, until our window object is set to closed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道我们的`while`循环将快速地循环执行其中的代码，直到我们的窗口对象被设置为关闭。
- en: C-style code comments
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C风格代码注释
- en: 'Just inside the `while` loop, we can see what, at first glance, might look
    a bit like ASCII art:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内部，我们可以看到乍一看可能有点像ASCII艺术的代码：
- en: '[PRE15]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'ASCII art is a niche but fun way of creating images with computer text. You
    can read more about it here: [https://en.wikipedia.org/wiki/ASCII_art](https://en.wikipedia.org/wiki/ASCII_art).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII艺术是一种小众但有趣的方式，可以用计算机文本创建图像。您可以在这里了解更多信息：[https://en.wikipedia.org/wiki/ASCII_art](https://en.wikipedia.org/wiki/ASCII_art)。
- en: The previous code is simply another type of comment. This type of comment is
    known as a C-style comment. The comment begins with (`/*`) and ends with (`*/`).
    Anything in between is just for information and is not compiled. I have used this
    slightly elaborate text to make it absolutely clear what we will be doing in each
    part of the code file. And of course, you can now work out that any code that
    follows will be related to handling the player’s input.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是另一种类型的注释。这种类型的注释被称为C风格注释。注释从(`/*`)开始，以(`*/`)结束。其中间的内容只是信息，不会被编译。我使用了这种稍微详细一点的文本，以确保我们清楚地知道代码文件中的每一部分将要做什么。当然，你现在可以推断出接下来的任何代码都将与处理玩家的输入相关。
- en: Skip over a few lines of code and you will see that we have another C-style
    comment, announcing that in that part of the code, we will be updating the scene.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过几行代码，你会看到我们还有另一个C风格注释，宣布在那个代码部分，我们将更新场景。
- en: If you jump to the next C-style comment, it will be clear where we will be drawing
    all the graphics.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳转到下一个C风格注释，就会清楚我们将在哪里绘制所有图形。
- en: Input, update, draw, repeat
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入、更新、绘制、重复
- en: 'Although this first project uses the simplest possible version of a game loop,
    every game will need these phases in the code. Let’s go over the steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个第一个项目使用了最简单的游戏循环版本，但每个游戏都需要代码中的这些阶段。让我们回顾一下步骤：
- en: Get the player’s input (if any).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取玩家的输入（如果有）。
- en: Update the scene based on things such as artificial intelligence, physics, or
    the player’s input.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据人工智能、物理或玩家的输入等更新场景。
- en: Draw the current scene.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制当前场景。
- en: Repeat these steps at a fast-enough rate to create a smooth, animated game world.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以足够快的速度重复这些步骤，以创建一个平滑的动画游戏世界。
- en: Now, let’s look at the code that actually does something within the game loop.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在游戏循环中实际执行某些操作的代码。
- en: Detecting a key press
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测按键
- en: 'Firstly, within the section that’s identifiable by the comment with the `Handle
    the player’s input` text, we have the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在可以通过带有`Handle the player’s input`文本的注释识别的部分，我们有以下代码：
- en: '[PRE16]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code checks whether the *Esc* key is currently being pressed. If it is,
    the highlighted code uses the `window` object to close itself. Now, the next time
    the `while` loop begins, it will see that the `window` object is closed and jump
    to the code immediately after the closing curly brace of the `while` loop and
    the game will exit. We will discuss `if` statements more fully in [*Chapter 2*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)*,
    Variables, Operators, and Decisions – Animating Sprites*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查是否正在按下*Esc*键。如果是的话，高亮显示的代码使用`window`对象来关闭自身。现在，下一次`while`循环开始时，它会看到`window`对象已经关闭，并跳转到`while`循环结束花括号之后的代码，游戏将退出。我们将在[*第二章*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)*中更全面地讨论`if`语句，变量、运算符和决策
    – 动画精灵*。
- en: Clearing and drawing the scene
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除和绘制场景
- en: Currently, there is no code in the `Update the scene` section, so let’s move
    on to the `Draw the scene` section.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在`更新场景`部分没有代码，所以让我们继续到`绘制场景`部分。
- en: 'The first thing we will do is rub out the previous frame of animation using
    the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用以下代码擦除上一帧的动画：
- en: '[PRE17]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we would do now is draw every object from the game. However, we don’t have
    any game objects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的是绘制游戏中的每一个对象。然而，我们没有任何游戏对象。
- en: 'The next line of code is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码如下：
- en: '[PRE18]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we draw all the game objects, we are drawing them to a hidden surface ready
    to be displayed. The `window.display()` code flips from the previously displayed
    surface to the newly updated (previously hidden) one. This way, the player will
    never see the drawing process as the surface has all the sprites added to it.
    It also guarantees that the scene will be complete before it is flipped. This
    prevents a graphical glitch known as **tearing**. This process is called **double
    buffering**.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制所有游戏对象时，我们实际上是在一个隐藏的表面上绘制，这个表面准备被显示。`window.display()` 代码会将之前显示的表面翻转到新更新的（之前隐藏的）一个。这样，玩家将永远不会看到绘制过程，因为表面已经添加了所有精灵。这也保证了场景在翻转之前是完整的。这防止了名为
    **撕裂** 的图形错误。这个过程被称为 **双缓冲**。
- en: Also note that all this drawing and clearing functionality is performed using
    our `window` object, which was created from the SFML `RenderWindow` class.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，所有这些绘制和清除功能都是使用我们的 `window` 对象执行的，该对象是从 SFML 的 `RenderWindow` 类创建的。
- en: Running the game
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: Run the game and you will get a blank, full screen window that remains open
    until you press the *Esc* key.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你将得到一个空白的全屏窗口，直到你按下 *Esc* 键。
- en: That is good progress. At this stage, we have an executing program that opens
    a window and loops around, waiting for the player to press the *Esc* key to exit.
    Now, we are able to move on to drawing the background image of the game.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的进展。在这个阶段，我们有一个正在执行的程序，它打开一个窗口并循环等待玩家按下 *Esc* 键以退出。现在，我们能够继续绘制游戏的背景图像。
- en: Drawing the game’s background
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制游戏背景
- en: Now, we will get to see some graphics in our game. What we need to do is create
    a sprite. The first one we will create will be the game background. We can then
    draw it in between clearing the window and displaying/flipping it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到我们游戏中的图形。我们需要做的是创建一个精灵。我们将首先创建游戏背景。然后我们可以在清除窗口和显示/翻转它之间绘制它。
- en: Preparing the Sprite using a Texture
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理准备精灵
- en: The SFML `RenderWindow` class allowed us to create our `window` object, which
    basically took care of all the functionality that our game’s window needs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 的 `RenderWindow` 类允许我们创建我们的 `window` 对象，它基本上负责了游戏窗口所需的所有功能。
- en: We will now look at two more SFML classes that will take care of drawing sprites
    to the screen. One of these classes, perhaps unsurprisingly, is called `Sprite`.
    The other class is called `Texture`. A texture is a graphic stored in memory,
    on the **graphics processing unit** (**GPU**).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看另外两个负责将精灵绘制到屏幕上的 SFML 类。其中一个类，可能不出所料，被称为 `Sprite`。另一个类被称为 `Texture`。纹理是存储在内存中的图形，在
    **图形处理单元**（**GPU**）上。
- en: 'An object that’s made from the `Sprite` class needs an object made from the
    `Texture` class in order to display itself as an image. Add the following highlighted
    code. Try and work out what is going on as well. Then, we will go through it,
    a line at a time:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `Sprite` 类创建的对象需要一个由 `Texture` 类创建的对象来显示自身作为图像。添加以下突出显示的代码。试着弄清楚发生了什么。然后，我们将逐行分析它：
- en: '[PRE19]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, we create an object called `textureBackground` from the SFML `Texture`
    class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `textureBackground` 的对象，该对象来自 SFML 的 `Texture` 类：
- en: '[PRE20]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once this is done, we can use the `textureBackground` object to load a graphic
    from our `graphics` folder into `textureBackground`, like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以使用 `textureBackground` 对象将我们的 `graphics` 文件夹中的图形加载到 `textureBackground`
    中，如下所示：
- en: '[PRE21]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We only need to specify `graphics/background` as the path is relative to the
    Visual Studio **working directory** where we created the folder and added the
    image.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要指定 `graphics/background` 作为路径，因为它是相对于我们创建文件夹并添加图像的 Visual Studio **工作目录**
    的相对路径。
- en: 'Next, we create an object called `spriteBackground` from the SFML `Sprite`
    class with this code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码创建一个名为 `spriteBackground` 的对象，该对象来自 SFML 的 `Sprite` 类：
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can associate the `Texture` object (`backgroundTexture`) with the
    `Sprite` object (`backgroundSprite`), like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将 `Texture` 对象（`backgroundTexture`）与 `Sprite` 对象（`backgroundSprite`）关联起来，如下所示：
- en: '[PRE23]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can position the `spriteBackground` object in the `window` object
    at the `0,0` coordinates:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `window` 对象中将 `spriteBackground` 对象定位在 `0,0` 坐标上：
- en: '[PRE24]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `background.png` graphic in the graphics folder is 1,920 pixels wide
    by 1,080 pixels high, it will neatly fill the entire screen. Just note that this
    previous line of code doesn’t actually show the sprite. It just sets its position,
    ready for when it is shown.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `graphics` 文件夹中的 `background.png` 图形宽度为 1,920 像素，高度为 1,080 像素，它将整齐地填充整个屏幕。请注意，此前的代码行实际上并没有显示精灵。它只是设置了其位置，以便在显示时使用。
- en: The `backgroundSprite` object can now be used to display the background graphic.
    Of course, you are almost certainly wondering why we had to do things in such
    a convoluted way. The reason is because of the way that graphics cards and OpenGL
    work.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`backgroundSprite`对象现在可以用来显示背景图形。当然，你几乎肯定想知道为什么我们不得不以这种方式做事。原因是由于显卡和OpenGL的工作方式。'
- en: Textures take up graphics memory, and this memory is a finite resource. Furthermore,
    the process of loading a graphic into the GPU’s memory is very slow – not so slow
    that you can watch it happen or that you will see your PC noticeably slow down
    while it is happening, but slow enough that you can’t do it every frame of the
    game loop. So, it is useful to disassociate the actual texture (`textureBackground`)
    from any code that we will manipulate during the game loop.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理占用图形内存，这种内存是有限的资源。此外，将图形加载到GPU内存中的过程非常缓慢——并不那么慢以至于你可以看到它发生，或者你会在它发生时明显感觉到你的电脑变慢，但足够慢以至于你不能在游戏循环的每一帧都这样做。因此，将实际的纹理（`textureBackground`）与我们在游戏循环中将要操作的任何代码解耦是有用的。
- en: As you will see when we start to move our graphics, we will do so using the
    sprite. Any objects that are made from the `Texture` class will sit happily on
    the GPU, just waiting for an associated `Sprite` object to tell it where to show
    itself. In later projects, we will also reuse the same `Texture` object with multiple
    different `Sprite` objects, which makes efficient use of GPU memory.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始移动我们的图形时，我们将使用精灵来这样做。任何由`Texture`类创建的对象都将愉快地坐在GPU上，等待相关的`Sprite`对象告诉它在哪里显示自己。在未来的项目中，我们还将使用相同的`Texture`对象与多个不同的`Sprite`对象一起使用，这使GPU内存的使用更加高效。
- en: 'In summary, we can state the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以陈述以下内容：
- en: Textures are very slow to load onto the GPU.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理加载到GPU上非常慢。
- en: Textures are very fast to access once they are on the GPU.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理一旦在GPU上，访问速度非常快。
- en: We associate a `Sprite` object with a texture.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个`Sprite`对象与一个纹理关联起来。
- en: We manipulate the position and orientation of `Sprite` objects (usually in the
    `Update the scene` section).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们操作`Sprite`对象的位置和方向（通常在`更新场景`部分）。
- en: We draw the `Sprite` object, which, in turn, displays the `Texture` object that
    is associated with it (usually in the `Draw the scene` section). So, all we need
    to do now is use our double buffering system, which is provided by our `window`
    object, to draw our new `Sprite` object (`spriteBackground`), and we should get
    to see our game in action.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制`Sprite`对象，它反过来显示与之关联的`Texture`对象（通常在`绘制场景`部分）。因此，我们现在需要做的就是使用我们的双缓冲系统，这是由我们的`window`对象提供的，来绘制我们的新`Sprite`对象（`spriteBackground`），然后我们应该能看到我们的游戏正在运行。
- en: Double buffering the background sprite
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景精灵的双缓冲
- en: Finally, we need to draw that sprite and its associated texture in the appropriate
    place in the game loop.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在游戏循环的适当位置绘制那个精灵及其关联的纹理。
- en: Tip
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that when I present code that is all from the same block, I don’t add the
    indentations because it lessens the instances of line wraps in the text of the
    book. The indenting is implied. Check out the code file in the download bundle
    to see full use of indenting.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我展示来自同一块的代码时，我不会添加缩进，因为这会减少书中文本的换行实例。缩进是隐含的。请查看下载包中的代码文件以查看缩进的完整使用。
- en: 'Add the following highlighted code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码：
- en: '[PRE25]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new line of code simply uses the `window` object to draw the `spriteBackground`
    object, in between clearing the display and showing the newly drawn scene.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行只是使用`window`对象在清除显示和显示新绘制的场景之间绘制`spriteBackground`对象。
- en: We now know what a sprite is, and that we can associate a texture with it and
    then position it on the screen and finally draw it. The game is ready to be run
    again so that we can see the results of this code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道什么是精灵，我们可以将它与纹理关联起来，然后在屏幕上定位它，最后绘制它。游戏现在可以再次运行，以便我们可以看到这段代码的结果。
- en: Running the game
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'If we run the program now, we will see the first signs that we have a real
    game in progress:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，我们将看到我们有一个真正的游戏正在进行的第一迹象：
- en: '![](img/B14278_01_35.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_01_35.jpg)'
- en: It’s not going to get Indie Game of the Year on Steam in its current state,
    but we are on the way at least!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前不可能在Steam上获得年度独立游戏奖，但至少我们正在这条路上！
- en: Let’s look at some of the things that might go wrong in this chapter and as
    we proceed through this book.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这一章中以及我们继续阅读这本书的过程中可能会出现的一些问题。
- en: Handling errors
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: There will always be problems and errors in every project you make. This is
    guaranteed! The tougher the problem, the more satisfying it is when you solve
    it. When, after hours of struggling, a new game feature finally bursts into life,
    it can cause a genuine high. Without this struggle, it would somehow be less worthwhile.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在你制作的每个项目中，都可能会遇到问题和错误。这是肯定的！问题越困难，当你解决它时就越令人满意。经过数小时的挣扎后，一个新游戏功能终于焕发生机，这可能会引起真正的兴奋。如果没有这种挣扎，它似乎就变得不那么值得了。
- en: At some point in this book, there will probably be some struggle. Remain calm,
    be confident that you will overcome it, and then get to work.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的某个阶段，你可能会遇到一些挑战。保持冷静，对自己有信心，你将能够克服它，然后开始工作。
- en: Remember that, whatever your problem, it is very likely you are **not** the
    first person in the world to have ever had this same problem. Think of a concise
    sentence that describes your problem or error and then type it into Google. You
    will be surprised how quickly, precisely, and often, someone else will have already
    solved your problem for you.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无论你的问题是什么，你很可能不是世界上第一个遇到这种相同问题的人。想一个简洁的句子来描述你的问题或错误，然后将其输入到谷歌搜索中。你会惊讶地发现，其他人解决你的问题的速度有多快、有多精确，以及有多频繁。
- en: Having said that, here are a few pointers (pun intended; see [*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)*,
    Pointers, the Standard Template Library, and Texture Management*) to get you started
    in case you are struggling with making this first chapter work.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这里有一些提示（有意为之；参见[*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)*，指针、标准模板库和纹理管理*)，以防你在使第一章工作时有困难。
- en: Configuration errors
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置错误
- en: The most likely cause of problems in this chapter will be **configuration errors**.
    As you probably noticed during the process of setting up Visual Studio, SFML and
    the project itself, there’s an awful lot of filenames, folders, and settings that
    need to be just right. Just one wrong setting could cause one of a number of errors,
    whose text don’t make it clear exactly what is wrong.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中问题最可能的原因是**配置错误**。正如你可能在设置Visual Studio、SFML和项目本身的过程中注意到的那样，有很多文件名、文件夹和设置需要恰到好处。仅仅一个错误的设置就可能导致一系列错误，其文本并没有清楚地说明具体出了什么问题。
- en: If you can’t get the empty project with the black screen working, it might be
    easier to start again. Make sure all the filenames and folders are appropriate
    for your specific setup and then get the simplest part of the code running. This
    is the part where the screen flashes black and then closes. If you can get to
    this stage, then configuration is probably not the issue.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法让空项目在黑色屏幕上运行，重新开始可能更容易。确保所有文件名和文件夹名都适合你的特定设置，然后运行代码的最简单部分。这是屏幕闪烁黑色然后关闭的部分。如果你能到达这个阶段，那么配置可能不是问题。
- en: Compile errors
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译错误
- en: Compile errors are probably the most common error we will experience going forward.
    Check that your code is identical to mine, especially semicolons on the ends of
    lines and subtle changes in upper and lower case for class and object names. If
    all else fails, open the code files in the download bundle and copy and paste
    it in. While it is always possible that a code typo made it into this book, the
    code files were made from actual working projects – they definitely work!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误可能是我们接下来最常遇到的错误。检查你的代码是否与我的一致，特别是行尾的分号和类名、对象名的大小写微妙变化。如果所有其他方法都失败了，请打开下载包中的代码文件，并复制粘贴进去。虽然总是有可能代码中的打字错误被收录到这本书中，但代码文件是从实际的工作项目中制作的——它们肯定能工作！
- en: Link errors
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接错误
- en: Link errors are most likely caused by missing SFML `.dll` files. Did you copy
    all of them into the project folder?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 链接错误最可能是由于缺少SFML `.dll`文件造成的。你是否已经将它们全部复制到了项目文件夹中？
- en: Bugs
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: Bugs are what happen when your code works, but not as you expect it to. Debugging
    can actually be fun. The more bugs you squash, the better your game and the more
    satisfying your day’s work will be. The trick to solving bugs is to find them
    early! To do this, I recommend running and playing your game every time you implement
    something new. The sooner you find the bug, the more likely the cause will be
    fresh in your mind. In this book, we will run the code to see the results at every
    possible stage.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生在你的代码按预期工作，但并非如你所愿时。调试实际上可以很有趣。你解决的错误越多，你的游戏越好，你一天的工作就越令人满意。解决错误的技巧是尽早找到它们！为此，我建议每次实现新功能时都运行并玩你的游戏。你发现错误越早，越有可能在脑海中清晰地记住原因。在这本书中，我们将运行代码以查看每个可能阶段的输出结果。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was quite a challenging chapter and perhaps a little bit mean to be the
    first one. It is true that configuring an IDE to use a C++ library can be a bit
    awkward and long. Also, the concepts of classes and objects are well known to
    be slightly awkward for people who are new to coding.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容相当具有挑战性，也许作为第一章来说有点苛刻。确实，配置IDE以使用C++库可能有点棘手且耗时。此外，类和对象的概念对于编程新手来说通常被认为有点棘手。
- en: Now that we are at this stage, however, we can totally focus on C++, SFML, and
    games. As we progress with this book, we will learn more and more C++, as well
    as implement increasingly interesting game features. As we do so, we will take
    a further look at things such as functions, classes, and objects to help demystify
    them a little more.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们已经到了这个阶段，我们可以完全专注于C++、SFML和游戏。随着我们继续阅读这本书，我们将学习越来越多的C++，并实现越来越有趣的游戏特性。在这个过程中，我们将进一步探讨函数、类和对象等概念，以帮助大家更好地理解它们。
- en: We have achieved plenty in this chapter, including outlining a basic C++ program
    with the main function, constructing a simple game loop that listens for player
    input and draws a sprite (along with its associated texture) to the screen.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中取得了许多成果，包括概述了一个带有主函数的基本C++程序，构建了一个简单的游戏循环，该循环监听玩家输入并在屏幕上绘制精灵（及其关联的纹理）。
- en: In the next chapter, we will learn about all the C++ we need to draw some more
    sprites and animate them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习所有我们需要用来绘制更多精灵并使它们动画化的C++知识。
- en: FAQ
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here are some questions that might be on your mind:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能出现在你脑海中的问题：
- en: Q) I am struggling with the content that’s been presented so far. Am I cut out
    for programming?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我发现到目前为止的内容有点难以理解。我是不是适合编程？
- en: A) Setting up a development environment and getting your head around OOP as
    a concept is probably the toughest thing you will do in this book. As long as
    your game is functioning (drawing the background), you are ready to proceed with
    the next chapter.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: A) 设置开发环境并理解面向对象编程这个概念可能是你在本书中要做的最困难的事情。只要你的游戏正在运行（绘制背景），你就可以继续进行下一章的学习。
- en: Q) All this talk of OOP, classes, and objects is too much and kind of spoiling
    the whole learning experience.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 所有关于面向对象编程、类和对象的讨论太多了，有点破坏了整个学习体验。
- en: A) Don’t worry. We will keep returning to OOP, classes, and objects constantly.
    In [*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154), *Object-Oriented
    Programming – Starting the Pong Game*, we will really begin getting to grips with
    the whole OOP thing. All you need to understand for now is that SFML have written
    a whole load of useful classes and that we get to use this code by creating usable
    objects from those classes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: A) 别担心。我们会不断地回到面向对象编程（OOP）、类和对象。在[*第6章*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)，“面向对象编程
    – 开始打乒乓球游戏”，我们将真正开始深入理解整个面向对象编程的概念。你现在需要理解的是，SFML已经编写了许多有用的类，我们可以通过从这些类中创建可用的对象来使用这段代码。
- en: Q) I really don’t get this function stuff.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我真的不太懂这个函数的东西。
- en: A) It doesn’t matter; we will be returning to it again constantly and will learn
    about functions more thoroughly. You just need to know that, when a function is
    called, its code is executed, and when it is done (reaches a `return` statement),
    the program jumps back to the code that called it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: A) 没关系；我们将会不断地回到这个话题，并且会更深入地学习函数。你只需要知道，当一个函数被调用时，它的代码会被执行，当它完成（到达`return`语句）时，程序会跳回到调用它的代码处。
