- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Low Latency Application Development in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C++中的低延迟应用开发
- en: Let us kick off our journey with low latency applications by introducing them
    in this first chapter. In this chapter, we will first understand the behavior
    and requirements of latency-sensitive and latency-critical applications. We will
    understand the huge business impact that application latencies have for businesses
    that rely on quick and strict response times.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以低延迟应用为起点，通过在本章中介绍它们来开启我们的旅程。在本章中，我们将首先了解对延迟敏感和对延迟关键的应用的行为和需求。我们将了解应用延迟对依赖快速和严格响应时间的业务产生的巨大商业影响。
- en: We will also discuss why C++ is one of the most preferred programming languages
    when it comes to low latency application development. We will spend a large part
    of this book building an entire low latency electronic trading system from scratch
    in C++. So, this will serve as a good chapter for you to understand the motivation
    for using C++ as well as what makes it the most popular language for low latency
    applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论为什么C++是低延迟应用开发中最受欢迎的编程语言之一。我们将用这本书的大部分篇幅从头开始构建一个完整的低延迟电子交易系统。因此，这将是一个很好的章节，让你了解使用C++的动机以及它为什么是低延迟应用中最流行的语言。
- en: We will also present some of the important low latency applications in different
    business areas. Part of the motivation is to make you understand that latencies
    are indeed very critical in different business areas for use cases that are sensitive
    to response times. The other part of the motivation is to identify the similarities
    in the behavior, expectations, design, and implementation of these applications.
    Even though they solve different business problems, the low latency requirements
    of these applications are often built on similar technical design and implementation
    principles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍不同业务领域的一些重要低延迟应用。部分动机是让你明白，延迟确实在不同业务领域对响应时间敏感的使用案例中非常重要。另一个动机是识别这些应用在行为、期望、设计和实现方面的相似性。尽管它们解决不同的商业问题，但这些应用的低延迟需求通常建立在相似的技术设计和实现原则之上。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the requirements for latency-sensitive applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对延迟敏感的应用的需求
- en: Understanding why C++ is the preferred programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么C++是首选编程语言
- en: Introducing some important low latency applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些重要的低延迟应用
- en: In order to build ultra-low latency applications effectively, we should first
    understand the terms and concepts we will refer to throughout the rest of this
    book. We should also understand why C++ has emerged as the clear choice for most
    low latency application development. It is also important to always keep the business
    impact of low latencies in mind because the aim is to build low latency applications
    to benefit the business’s bottom line. This chapter discusses these ideas so that
    you can build a good foundation before we dive into the technical details in the
    rest of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地构建超低延迟应用，我们首先应该理解我们将在这本书的其余部分中引用的术语和概念。我们还应该了解为什么C++已经成为大多数低延迟应用开发的明确选择。始终牢记低延迟的商业影响也很重要，因为目标是构建低延迟应用以使业务的底线受益。本章讨论了这些想法，以便在我们深入本书其余部分的技术细节之前，你能建立一个良好的基础。
- en: Understanding requirements for latency-sensitive applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对延迟敏感的应用的需求
- en: In this section, we will discuss some concepts that are required to build an
    understanding of what metrics matter for latency-sensitive applications. First,
    let’s define clearly what latency means and what latency-sensitive applications
    are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些概念，这些概念对于理解对延迟敏感的应用的哪些指标很重要。首先，让我们明确地定义延迟的含义和对延迟敏感的应用是什么。
- en: '**Latency** is defined as the time delay between when a task is started to
    the time when the task is finished. By definition, any processing or work will
    incur some overhead or latency – that is, no system has zero latency unless the
    system does absolutely no work. The important detail here is that some systems
    might have latency that is an infinitesimal fraction of a millisecond and the
    tolerance for an additional microsecond there might be low.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟**被定义为任务开始到任务完成之间的时间延迟。根据定义，任何处理或工作都会产生一些开销或延迟——也就是说，除非系统完全不工作，否则没有系统具有零延迟。这里的重要细节是，某些系统可能具有微不足道的毫秒分之一延迟，并且对额外微秒的容忍度可能很低。'
- en: Low latency applications are applications that execute tasks and respond or
    return results as quickly as possible. The point here is that reaction latency
    is an important criterion for such applications where higher latencies can degrade
    performance or even render an application completely useless. On the other hand,
    when such applications perform with the low latencies that are expected of them,
    they can beat the competition, run at maximum speed, achieve maximum throughput,
    or increase productivity and improve the user experience – depending on the application
    and business.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 低延迟应用是指那些尽可能快速执行任务并响应或返回结果的程序。这里的要点是，反应延迟是这类应用的重要标准，因为更高的延迟可能会降低性能，甚至使应用完全无用。另一方面，当这类应用以预期的低延迟运行时，它们可以击败竞争对手，以最大速度运行，实现最大吞吐量，或提高生产力和改善用户体验——具体取决于应用和业务。
- en: Low latency can be thought of as both a quantitative as well as a qualitative
    term. The quantitative aspect is pretty obvious, but the qualitative aspect might
    not necessarily be obvious. Depending on the context, architects and developers
    might be willing to accept higher latencies in some cases but be unwilling to
    accept an extra microsecond in some contexts. For instance, if a user refreshes
    a web page or they wait for a video to load, a few seconds of latency is quite
    acceptable. However, once the video loads and starts playing, it can no longer
    incur a few seconds of latency to render or display without negatively impacting
    the user experience. An extreme example is high-speed financial trading systems
    where a few extra microseconds can make a huge difference between a profitable
    firm and a firm that cannot compete at all.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 低延迟可以被视为一个既定量又定性的术语。定量方面很明显，但定性方面可能并不一定明显。根据上下文，架构师和开发者可能在某些情况下愿意接受更高的延迟，但在某些情况下可能不愿意接受额外的微秒。例如，如果用户刷新网页或等待视频加载，几秒钟的延迟是可以接受的。然而，一旦视频加载并开始播放，就不再能够承受几秒钟的延迟来渲染或显示，而不会对用户体验产生负面影响。一个极端的例子是高速金融交易系统，其中额外的几微秒可能会在盈利公司和无法竞争的公司之间产生巨大的差异。
- en: In the following subsections, we will present some nomenclature that applies
    to low latency applications. It is important to understand these terms well so
    that we can continue our discussion on low latency applications, as we will refer
    to these concepts frequently. The concepts and terms we will discuss next are
    used to differentiate between different latency-sensitive applications, the measurement
    of latencies, and the requirements of these applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将介绍适用于低延迟应用的一些术语。理解这些术语非常重要，这样我们才能继续讨论低延迟应用，因为我们将会频繁地引用这些概念。我们将讨论的概念和术语用于区分不同的延迟敏感型应用、延迟的测量以及这些应用的要求。
- en: Understanding latency-sensitive versus latency-critical applications
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解延迟敏感型与延迟关键型应用
- en: There is a subtle but important difference between the terms **latency-sensitive
    applications** and **latency-critical applications**. A latency-sensitive application
    is one in which, as performance latencies are reduced, it improves the business
    impact or profitability. So, the system might still be functional and possibly
    profitable at higher performance latencies but can be significantly more profitable
    if latencies are reduced. Examples of such applications would be operating systems
    (OSes), web browsers, databases, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟敏感型应用**和**延迟关键型应用**之间存在微妙但重要的区别。延迟敏感型应用是指，随着性能延迟的降低，它提高了业务影响或盈利能力。因此，系统可能在较高的性能延迟下仍然功能正常，甚至可能盈利，但如果降低延迟，则可能获得更高的盈利能力。这类应用的例子包括操作系统（OSes）、网络浏览器、数据库等。'
- en: A latency-critical application, on the other hand, is one that fails completely
    if performance latency is higher than a certain threshold. The point here is that
    while latency-sensitive applications might only lose part of their profitability
    at higher latencies, latency-critical applications fail entirely at high enough
    latencies. Examples of such applications are traffic control systems, financial
    trading systems, autonomous vehicles, and some medical appliances.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，延迟关键的应用程序是指当性能延迟高于某个阈值时，会完全失败的应用程序。这里的要点是，虽然延迟敏感的应用程序在更高的延迟下可能会损失部分盈利能力，但延迟关键的应用程序在足够高的延迟下会完全失败。这类应用的例子包括交通控制系统、金融交易系统、自动驾驶汽车和一些医疗设备。
- en: Measuring latency
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量延迟
- en: In this section, we will discuss different methods of measuring latency. The
    real difference between these methods comes down to what is considered the beginning
    of the processing task and what is the end of the processing task. Another approach
    would be the units of what we are measuring – time is the most common one but
    in some cases, CPU clock cycles can also be used if it comes down to instruction-level
    measurements. Let’s look at the different measurements next, but first, we present
    a diagram of a generic server-client system without diving into the specifics
    of the use case or transport protocols. This is because measuring latency is generic
    and applies to many different applications with this kind of server-client setup.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论不同的测量延迟的方法。这些方法之间的真正区别在于，我们考虑的处理任务的开始和结束是什么。另一种方法是我们测量的单位——时间是其中最常见的一个，但在某些情况下，如果涉及到指令级测量，也可以使用CPU时钟周期。接下来，我们将查看不同的测量方法，但首先，我们展示一个通用服务器-客户端系统的图，而不深入使用案例或传输协议的具体细节。这是因为测量延迟是通用的，适用于具有这种服务器-客户端设置的许多不同应用程序。
- en: '![Figure 1.1 – A general server-client system with timestamps between different
    hops ](img/Figure_1.1_B19434.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 具有不同跳数时间戳的通用服务器-客户端系统](img/Figure_1.1_B19434.jpg)'
- en: Figure 1.1 – A general server-client system with timestamps between different
    hops
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 具有不同跳数时间戳的通用服务器-客户端系统
- en: We present this diagram here because, in the next few subsections, we will define
    and understand latencies between the different hops on the round-trip path from
    the server client and back to the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示这个图是因为，在接下来的几个小节中，我们将定义并理解服务器到客户端以及返回服务器的往返路径上不同跳数之间的延迟。
- en: Time to first byte
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首字节到达时间
- en: '**Time to first byte** is measured as the time elapsed from when the sender
    sends the first byte of a request (or response) to the moment when the receiver
    receives the first byte. This typically (but not necessarily) applies to network
    links or systems where there are data transfer operations that are latency-sensitive.
    In *Figure 1**.1*, time to first byte would be the difference between ![](img/Formula_1.1.png)
    and ![](img/Formula_1.2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**首字节到达时间**是指从发送者发送请求（或响应）的第一个字节到接收者接收第一个字节所经过的时间。这通常（但不一定）适用于具有数据传输操作且对延迟敏感的网络链路或系统。在*图1*.1中，首字节到达时间将是
    ![](img/Formula_1.1.png) 和 ![](img/Formula_1.2.png) 之间的差异'
- en: Round-trip time
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 往返时间
- en: '**Round-trip time** (**RTT**) is the sum of the time it takes for a packet
    to travel from one process to another and then the time it takes for the response
    packet to reach the original process. Again, this is typically (but not necessarily)
    used for network traffic going back and forth between server and client processes,
    but can also be used for two processes communicating in general.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**往返时间**（**RTT**）是指数据包从一个进程传输到另一个进程所需的时间，以及响应数据包返回原始进程所需的时间。同样，这通常（但不一定）用于服务器和客户端进程之间的网络流量往返，但也可以用于一般情况下的两个进程之间的通信。'
- en: 'RTT, by default, includes the time taken by the server process to read, process,
    and respond to the request sent by the sender – that is, RTT generally includes
    server processing times. In the context of electronic trading, the true RTT latency
    is based on three components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RTT包括服务器进程读取、处理和响应发送者发送的请求所需的时间——也就是说，RTT通常包括服务器处理时间。在电子交易的情况下，真正的RTT延迟基于三个组成部分：
- en: First, the time it takes for information from the exchange to reach the participant
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，交易所信息到达参与者所需的时间
- en: Second, the time it takes for the execution of the algorithms to analyze the
    information and make a decision
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，算法分析信息和做出决策所需的时间
- en: Finally, the time it take for the decision to reach the exchange and get processed
    by the matching engine
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，决策从达到交易所并经过撮合引擎处理所需的时间
- en: We will discuss this more in the last section of this book, *Analyzing and*
    *improving performance*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的最后一节，*分析和改进性能*中进一步讨论这个问题。
- en: Tick-to-trade
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易计时
- en: '**Tick-to-trade** (**TTT**) is similar to RTT and is a term most commonly used
    in electronic trading systems. TTT is defined as the time from when a packet (usually
    a market data packet) first hits a participant’s infrastructure (trading server)
    to the time when the participant is done processing the packet and sends a packet
    out (order request) to the trading exchange. So, TTT includes the time spent by
    the trading infrastructure to read the packet, process it, calculate trading signals,
    generate an order request in reaction to that, and *put it on the wire*. **Putting
    it on the wire** typically means writing something to a network socket. We will
    revisit this topic and explore it in greater detail in the last section of this
    book, *Analyzing and improving performance*. In *Figure 1**.1*, TTT would be the
    difference between ![](img/Formula_1.2.png) and ![](img/Formula_1.4.png).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**交易计时**（**TTT**）与RTT类似，是电子交易系统中最常用的术语。TTT被定义为从数据包（通常是市场数据包）首次击中参与者的基础设施（交易服务器）到参与者完成处理该数据包并发送数据包（订单请求）到交易交易所的时间。因此，TTT包括交易基础设施读取数据包、处理数据包、计算交易信号、根据该信号生成订单请求并将其*发送出去*所需的时间。**发送出去**通常意味着将数据写入网络套接字。我们将在本书的最后一节，*分析和改进性能*中重新审视这个主题，并对其进行更详细的探讨。在*图1.1*中，TTT将是![](img/Formula_1.2.png)和![](img/Formula_1.4.png)之间的差异。'
- en: CPU clock cycles
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU时钟周期
- en: '**CPU clock cycles** are basically the smallest increment of work that can
    be done by the CPU processor. In reality, they are the amount of time between
    two pulses of the oscillator that drives the CPU processor. Measuring CPU clock
    cycles is typically used to measure latency at the instruction level – that is,
    at an extremely low level at the processor level. C++ is both a low-level as well
    as a high-level language; it lets you get as close to the hardware as needed and
    also provides higher-level abstractions such as classes, templates, and so on.
    But generally, C++ developers do not spend a lot of time dealing with extremely
    low-level or possibly assembly code. This means that the compiled machine code
    might not be exactly what a C++ developer expects. Additionally, depending on
    the compiler versions, the processor architectures, and so on, there may be even
    more sources of differences. So, for extremely performance-sensitive low latency
    code, it is often not uncommon for engineers to measure how many instructions
    are executed and how many CPU clock cycles are required to do so. This level of
    optimization is typically the highest level of optimization possible, alongside
    kernel-level optimizations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU时钟周期**基本上是CPU处理器可以完成的最低工作量增量。实际上，它们是驱动CPU处理器的振荡器两次脉冲之间的时间间隔。测量CPU时钟周期通常用于测量指令级别的延迟——即在处理器级别的极低级别。C++既是一种低级语言，也是一种高级语言；它允许你根据需要接近硬件，同时也提供了诸如类、模板等高级抽象。但通常，C++开发者不会花很多时间处理极低级别的或可能是汇编语言。这意味着编译后的机器代码可能并不完全符合C++开发者的预期。此外，根据编译器版本、处理器架构等因素，可能还有更多差异的来源。因此，对于极高性能敏感的低延迟代码，工程师通常测量执行了多少条指令以及完成这些指令所需的CPU时钟周期数。这种级别的优化通常是可能达到的最高优化级别，与内核级别的优化并列。'
- en: Now that we have seen some different methods of measuring latencies in different
    applications, in the next section, we will look at some latency summary metrics
    and how each one of them can be important under different scenarios.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些不同应用中测量延迟的不同方法，在下一节中，我们将探讨一些延迟汇总指标以及它们在不同场景下的重要性。
- en: Differentiating between latency metrics
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分延迟指标
- en: The relative importance of a specific latency metric over the other depends
    on the application and the business itself. As an example, a latency-critical
    application such as an autonomous vehicle software system cares about peak latency
    much more than the mean latency. Low latency electronic trading systems typically
    care more about mean latency and smaller latency variance than they do about peak
    latency. Video streaming and playback applications might generally prioritize
    high throughput over lower latency variance due to the nature of the application
    and the consumers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 特定延迟指标相对于其他指标的重要性取决于应用和业务本身。例如，一个延迟关键的应用，如自动驾驶软件系统，比平均延迟更关心峰值延迟。低延迟电子交易系统通常比峰值延迟更关心平均延迟和更小的延迟方差。由于应用和消费者的性质，视频流和播放应用可能通常优先考虑高吞吐量而不是较低的延迟方差。
- en: Throughput versus latency
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 吞吐量与延迟
- en: Before we look at the metrics themselves, first, we need to clearly understand
    the difference between two terms – **throughput** and **latency** – which are
    very similar to each other and often used interchangeably but should not be. Throughput
    is defined as how much work gets done in a certain period of time, and latency
    is how quickly a single task is completed. To improve throughput, the usual approach
    is to introduce parallelism and add additional computing, memory, and networking
    resources. Note that each individual task might not be processed as quickly as
    possible, but overall, more tasks will be completed after a certain amount of
    time. This is because, while being processed individually, each task might take
    longer than in a low latency setup, but the parallelism boosts throughput over
    a set of tasks. Latency, on the other hand, is measured for each individual task
    from beginning to finish, even if fewer tasks are executed overall.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些指标本身之前，首先，我们需要清楚地理解两个术语之间的区别——**吞吐量**和**延迟**——这两个术语非常相似，经常被互换使用，但不应如此。吞吐量定义为在特定时间内完成的工作量，而延迟是单个任务完成的速度。为了提高吞吐量，通常的方法是引入并行性并添加额外的计算、内存和网络资源。请注意，每个单独的任务可能不会以尽可能快的速度处理，但总体上，在一段时间后，将完成更多任务。这是因为，虽然每个任务单独处理时可能需要更长的时间，但并行性提高了任务集的吞吐量。另一方面，延迟是对每个单独的任务从开始到结束进行测量的，即使总体上执行的任务较少。
- en: Mean latency
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平均延迟
- en: '**Mean latency** is basically the expected average response time of a system.
    It is simply the average of all the latency measurement observations. This metric
    includes large outliers, so can be a noisy metric for systems that experience
    a large range of performance latencies.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均延迟**基本上是系统的预期平均响应时间。它只是所有延迟测量观测值的平均值。这个指标包括大异常值，因此对于经历大范围性能延迟的系统来说可能是一个嘈杂的指标。'
- en: Median latency
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中值延迟
- en: '**Median latency** is typically a better metric for the expected response time
    of a system. Since it is the median of the latency measurement observations, it
    excludes the impact of large outliers. Due to this, it is sometimes preferred
    over the mean latency metric.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**中值延迟**通常是衡量系统预期响应时间的更好指标。由于它是延迟测量观测值的中间值，因此排除了大异常值的影响。因此，有时它比平均延迟指标更受欢迎。'
- en: Peak latency
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 峰值延迟
- en: '**Peak latency** is an important metric for systems where a single large outlier
    in performance can have a devastating impact on the system. Large values of peak
    latency can also significantly influence the mean latency metric of the system.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**峰值延迟**是对于系统来说一个重要的指标，因为单个大的异常性能可能会对系统产生灾难性的影响。峰值延迟的大值也可能显著影响系统的平均延迟指标。'
- en: Latency variance
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟方差
- en: For systems that require a latency profile that is as deterministic as possible,
    the actual **variance** of the performance latency is an important metric. This
    is typically important where the expected latencies are quite predictable. For
    systems with low latency variance, the mean, median, and peak latencies are all
    expected to be quite close to each other.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要尽可能确定性的延迟配置文件的系统，性能延迟的实际**方差**是一个重要的指标。这通常在预期的延迟相当可预测的情况下很重要。对于低延迟方差的系统，平均延迟、中值延迟和峰值延迟都预计会非常接近。
- en: Requirements of latency-sensitive applications
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对延迟敏感的应用需求
- en: In this section, we will formally describe the behavior of latency-sensitive
    applications and the performance profile that these applications are expected
    to adhere to. Obviously, latency-sensitive applications need low latency performance,
    but here we will try to explore minor subtleties in the term *low latency* and
    discuss some different ways of looking at it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将正式描述对延迟敏感型应用程序的行为以及这些应用程序预期遵守的性能配置文件。显然，延迟敏感型应用程序需要低延迟性能，但在这里我们将尝试探索“低延迟”一词的细微差别，并讨论一些不同的看待方式。
- en: Correctness and robustness
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确性和鲁棒性
- en: When we think of latency-sensitive applications, it is often the case that we
    think low latency is the single most important aspect of such applications. But
    in reality, a huge requirement of such applications is correctness and we mean
    very high levels of robustness and fault tolerance. Intuitively, this idea should
    make complete sense; these applications require very low latency to be successful,
    which then should tell you that these applications also have very high throughput
    and need to process huge amounts of inputs and produce a large number of outputs.
    Hence, the system needs to achieve very close to 100% correctness and be very
    robust as well for the application to be successful in their business area. Additionally,
    the correctness and robustness requirements need to be maintained as the application
    grows and changes during its lifetime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考延迟敏感型应用程序时，通常认为低延迟是这类应用程序最重要的单一方面。但在现实中，这类应用程序的一个巨大需求是正确性，我们指的是非常高的鲁棒性和容错性。直观上，这个想法应该完全合理；这些应用程序需要非常低的延迟才能成功，这应该告诉你这些应用程序也有非常高的吞吐量，需要处理大量的输入并产生大量的输出。因此，系统需要非常接近100%的正确性，并且非常鲁棒，以便在业务领域取得成功。此外，随着应用程序在其生命周期中的增长和变化，正确性和鲁棒性要求也需要保持。
- en: Low latencies on average
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平均低延迟
- en: This is the most obvious requirement when we think about latency-sensitive applications.
    The expected reaction or processing latency needs to be as low as possible for
    the application or business overall to succeed. Here, we care about the mean and
    median performance latency and need it to be as low as possible. By design, this
    means the system cannot have too many outliers or very high peaks in performance
    latency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是思考延迟敏感型应用程序时最明显的要求。预期的反应或处理延迟需要尽可能低，以便应用程序或业务整体能够成功。在这里，我们关注平均和中值性能延迟，并希望它尽可能低。按设计，这意味着系统不能有太多的异常值或性能延迟的高峰。
- en: Capped peak latency
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 峰值延迟上限
- en: We use the term **capped peak latency** to refer to the requirement that there
    needs to be a well-defined upper threshold for the maximum possible latency the
    application can ever encounter. This behavior is important for all latency-sensitive
    applications, but most important for latency-critical applications. But even in
    the general case, applications that have extremely high-performance latency for
    a handful of cases will typically destroy the performance of the system. What
    this really means is that the application needs to handle any input, scenario,
    or sequence of events and do so within a low latency period. Of course, the performance
    to handle a very rare and specific scenario can possibly be much higher than the
    most likely case, but the point here is that it cannot be unbounded or unacceptable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“峰值延迟上限”这个术语来指代必须为应用程序可能遇到的最大延迟设定一个明确的上限。这种行为对所有延迟敏感型应用程序都很重要，但对于延迟关键型应用程序来说尤为重要。即使在一般情况下，对于少数几个案例具有极高性能延迟的应用程序通常会破坏系统的性能。这实际上意味着应用程序需要处理任何输入、场景或事件序列，并在低延迟期内完成。当然，处理非常罕见和特定场景的性能可能远高于最可能的情况，但这里的重点是它不能是无界的或不可接受的。
- en: Predictable latency – low latency variance
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可预测的延迟 - 低延迟变化
- en: Some applications prefer that the expected performance latency is predictable,
    even if that means sacrificing latency a little bit if the average latency metric
    is higher than it could be. What this really means is that such applications will
    make sure that the expected performance latency for all kinds of different inputs
    or events has as little variance as possible. It is impossible to achieve zero
    latency variance, but some choices can be made in data structures, algorithms,
    code implementation, and setup to try to minimize this as much as possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序更喜欢预期的性能延迟是可预测的，即使这意味着如果平均延迟指标高于可能的情况，需要牺牲一点延迟。这实际上意味着此类应用程序将确保所有不同输入或事件的预期性能延迟尽可能小地变化。实现零延迟变化是不可能的，但可以在数据结构、算法、代码实现和设置方面做出一些选择，以尽可能最大限度地减少这种变化。
- en: High throughput
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高吞吐量
- en: As mentioned before, low latency and throughput are related but not identical.
    For that reason, sometimes some applications that need the highest throughput
    possible might have some differences in design and implementation to maximize
    throughput. The point is that maximizing throughput might come at the cost of
    sacrificing average performance latencies or increasing peak latencies to achieve
    that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，低延迟和吞吐量相关但并不相同。因此，有时一些需要尽可能高吞吐量的应用程序在设计实现上可能有所不同，以最大化吞吐量。关键是最大化吞吐量可能需要牺牲平均性能延迟或增加峰值延迟以实现这一点。
- en: In this section, we introduced the concepts that apply to low latency application
    performance and the business impact of those metrics. We will need these concepts
    in the rest of the book when we refer to the performance of the applications we
    build. Next, we will move the conversation forward and explore the programming
    languages available for low latency application development. We will discuss the
    characteristics of the languages that support low latency applications and understand
    why C++ has risen to the top of the list when it comes to developing and improving
    latency-sensitive applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了适用于低延迟应用程序性能和这些指标业务影响的概念。当我们讨论我们构建的应用程序的性能时，我们将在本书的其余部分需要这些概念。接下来，我们将继续讨论，并探索用于低延迟应用程序开发的编程语言。我们将讨论支持低延迟应用程序的语言特性，并了解为什么
    C++ 在开发和提高对延迟敏感的应用程序时位居榜首。
- en: Understanding why C++ is the preferred programming language
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么 C++ 是首选编程语言
- en: There are several high-level language choices when it comes to low latency applications
    – Java, Scala, Go, and C++. In this section, we will discuss why C++ is one of
    the most popular languages when it comes to low latency applications. We will
    discuss several characteristics of the C++ language that support the high-level
    language constructs to support large code bases. The power of C++ is that it also
    provides very low-level access, similar to the C programming language, to support
    a very high level of control and optimization.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在低延迟应用程序方面，有几种高级语言选择——Java、Scala、Go 和 C++。在本节中，我们将讨论为什么 C++ 是低延迟应用程序中最受欢迎的语言之一。我们将讨论
    C++ 语言的一些特性，这些特性支持高级语言结构以支持大型代码库。C++ 的强大之处在于它还提供了类似于 C 编程语言的非常低级别的访问权限，以支持非常高级的控制和优化。
- en: Compiled language
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译型语言
- en: C++ is a compiled language and not an interpreted language. A **compiled language**
    is a programming language where the source code is translated into a machine code
    binary that is ready to run on a specific architecture. Examples of compiled languages
    are C, C++, Erlang, Haskell, Rust, and Go. The alternative to compiled languages
    is interpreted languages. **Interpreted languages** are different in the sense
    that the program is run by an interpreter, which runs through the source line
    by line and executes each command. Some examples of interpreted languages are
    Ruby, Python, and JavaScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一种编译型语言，而不是解释型语言。编译型语言是一种编程语言，其中源代码被翻译成机器码二进制文件，该文件可以在特定架构上运行。编译型语言的例子有
    C、C++、Erlang、Haskell、Rust 和 Go。编译型语言的替代品是解释型语言。解释型语言的不同之处在于程序是由解释器运行的，解释器逐行运行源代码并执行每个命令。解释型语言的例子包括
    Ruby、Python 和 JavaScript。
- en: Interpreted languages are inherently slower than compiled languages because,
    unlike compiled languages where the translation into machine instructions is done
    at compile time, here the interpretation to machine instructions is done at runtime.
    However, with the development of just-in-time compilation, interpreted languages
    are not tremendously slower. For compiled languages, the code is already pre-built
    for the target hardware so there is no extra interpretation step at runtime. Since
    C++ is a compiled language, it gives the developers a lot of control over the
    hardware. This means competent developers can optimize things such as memory management,
    CPU usage, cache performance, and so on. Additionally, since compiled languages
    are converted into machine code for specific hardware at compile time, it can
    be optimized to a large degree. Hence, compiled languages in general, and especially
    C++, are faster and more efficient to execute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解释性语言本质上比编译性语言慢，因为与编译性语言在编译时就将代码翻译成机器指令不同，这里的解释到机器指令是在运行时完成的。然而，随着即时编译技术的发展，解释性语言的性能并没有慢很多。对于编译性语言，代码在编译时已经为特定硬件预先构建，因此在运行时没有额外的解释步骤。由于C++是一种编译性语言，它为开发者提供了对硬件的大量控制。这意味着有能力的开发者可以优化诸如内存管理、CPU使用、缓存性能等方面。此外，由于编译性语言在编译时就已经转换为特定硬件的机器代码，因此它可以进行大量的优化。因此，一般来说，编译性语言，尤其是C++，执行速度更快，效率更高。
- en: Closer to hardware – low-level language
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更接近硬件——低级语言
- en: Compared to other popular programming languages such as Python, Java, and so
    on, C++ is low level so it’s extremely close to the hardware. This is especially
    useful when the software is tightly coupled with the target hardware it runs on
    and possibly even in cases where low-level support is required. Being extremely
    close to the hardware also means that there is a significant speed advantage when
    building systems in C++. Especially in low latency applications such as **high-frequency
    trading** (**HFT**) where a few microseconds can make a huge difference, C++ is
    generally the established gold standard in the industry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流行的编程语言，如Python、Java等相比，C++是低级语言，因此它与硬件非常接近。这在软件与运行其上的目标硬件紧密耦合，甚至需要低级支持的情况下特别有用。与硬件非常接近也意味着在用C++构建系统时，存在显著的速度优势。特别是在低延迟应用，如**高频交易**（**HFT**）中，几微秒的差距可能造成巨大的差异，C++通常是行业中的黄金标准。
- en: We will discuss an example of how being closer to the hardware helps boost C++
    performance over another language such as Java. A C/C++ pointer is the actual
    address of an object in memory. So, the software can access memory and objects
    in memory directly without needing extra abstractions that would slow it down.
    This, however, does mean that the application developer will often have to explicitly
    manage the creation, ownership, destruction, and lifetime of objects instead of
    relying on the programming language to manage things for you as in Python or Java.
    An extreme case of C++ being close to the hardware is that it is possible to call
    assembly instructions straight from C++ statements – we will see an example of
    this in later chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一个例子，说明更接近硬件如何帮助C++性能超过另一种语言，如Java。C/C++指针是内存中对象的实际地址。因此，软件可以直接访问内存和内存中的对象，而无需额外的抽象，这些抽象会减慢速度。然而，这也意味着应用程序开发者通常必须显式地管理对象的创建、所有权、销毁和生命周期，而不是像Python或Java那样依赖编程语言为您管理这些事情。C++接近硬件的一个极端例子是，可以直接从C++语句中调用汇编指令——我们将在后面的章节中看到这个例子。
- en: Deterministic usage of resources
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源的确定性使用
- en: It is critical for low latency applications to use resources very efficiently.
    Embedded applications (which are also often used in real-time applications) are
    especially limited in time and memory resources. In languages such as Java and
    Python that rely on automatic garbage collection, there is an element of non-determinism
    – that is, the garbage collector can introduce large latencies in performance
    unpredictably. Additionally, for systems that are very limited in memory, low-level
    languages such as C and C++ can do special things such as placing data at custom
    sections or addresses in memory through pointers. In languages such as C and C++,
    the programmer is in charge of explicit creation, management, and deallocation
    of memory resources, allowing for deterministic and efficient use of resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低延迟应用来说，高效使用资源至关重要。嵌入式应用（这些应用也常用于实时应用）在时间和内存资源上尤其有限。在像Java和Python这样的依赖自动垃圾回收的语言中，存在非确定性的因素——也就是说，垃圾回收器可能会在性能不可预测的情况下引入较大的延迟。此外，对于内存非常有限的系统，使用C和C++这样的低级语言可以做一些特殊的事情，比如通过指针将数据放置在内存中的自定义部分或地址。在C和C++这样的语言中，程序员负责显式创建、管理和释放内存资源，从而允许资源的确定性和高效使用。
- en: Speed and high performance
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速度和高效性能
- en: C++ is faster than most other programming languages for the reasons we have
    already discussed. It also provides excellent concurrency and multithreading support.
    Obviously, this is another good feature when it comes to developing low latency
    applications that are latency-sensitive or even latency-critical. Such requirements
    are also often found in applications around servers that are under heavy load
    such as web servers, application servers, database servers, trading servers, and
    so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++比大多数其他编程语言都要快，原因我们已经讨论过了。它还提供了出色的并发和多线程支持。显然，这对于开发对延迟敏感甚至对延迟至关重要的低延迟应用来说，又是一个很好的特性。这样的需求也常常出现在服务器负载很重的应用中，如Web服务器、应用服务器、数据库服务器、交易服务器等。
- en: Another advantage of C++ is due to its compile-time optimization ability. C
    and C++ support features such as macros or pre-processor directives, a `constexpr`
    specifier, and template metaprogramming. These allow us to move a large part of
    the processing from runtime to compile time. Basically, this means we minimize
    the work done during runtime on the critical code path by moving a lot of the
    processing to the compilation step when building the machine code binary. We will
    discuss these features heavily in later chapters when we build a complete electronic
    trading system, and their benefits will become very clear at that point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C++的另一个优点是由于其编译时优化能力。C和C++支持宏或预处理器指令、`constexpr`指定符和模板元编程等功能。这些功能使我们能够将大量处理从运行时移动到编译时。基本上，这意味着我们通过在构建机器代码二进制时将大量处理移动到编译步骤，最小化了在关键代码路径上运行时的工作量。我们将在后续章节中详细讨论这些功能，当我们在构建一个完整的电子交易系统时，它们的益处将变得非常明显。
- en: Language constructs and features
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言构造和特性
- en: The C++ language itself is a perfect combination of flexibility and feature
    richness. It allows a lot of freedom for the developers, who can leverage it to
    tune applications down to a very low level. However, it also provides a lot of
    higher-level abstractions, which can be used to build very large, feature-rich,
    versatile, and scalable applications, while still being extremely low latency
    when required. In this section, we will explore some of those C++-specific language
    features that put it in a unique position of low-level control and high-level
    abstraction features.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言本身是灵活性和功能丰富的完美结合。它为开发者提供了很多自由度，他们可以利用它将应用调整到非常低的级别。然而，它也提供了很多高级抽象，可以用来构建非常大型、功能丰富、通用和可扩展的应用，同时在需要时仍能保持极低的延迟。在本节中，我们将探讨一些C++特有的语言特性，这些特性使其处于独特的低级控制和高级抽象功能的位置。
- en: Portability
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植性
- en: First off, C++ is highly portable and can build applications that can be compiled
    for a lot of different operating systems, platforms, CPU architecture, and so
    on. Since it does not require a runtime interpreter that differs for different
    platforms, all that is required to do is build the correct binaries at compile
    time, which is relatively straightforward, and the final deployed binary can just
    run on any platform. Additionally, some of the other features we have already
    discussed (such as the ability to run in low-memory and weaker CPU architectures
    combined with the lack of garbage collection requirements) make it even more portable
    than some of the other high-level languages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，C++高度可移植，可以构建适用于许多不同操作系统、平台、CPU架构的应用程序。由于它不需要针对不同平台的不同运行时解释器，所需要做的就是编译时构建正确的二进制文件，这相对简单，最终部署的二进制文件可以在任何平台上运行。此外，我们之前已经讨论的一些其他特性（例如，在低内存和较弱的CPU架构上运行的能力，以及不需要垃圾回收的要求）使得它比其他一些高级语言更加可移植。
- en: Compiler optimizations
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器优化
- en: We have discussed that C++ is a compiled language, which makes it inherently
    faster than interpreted languages since it does not incur additional runtime costs.
    Since the developer’s complete source code is compiled into the final executable
    binary, compilers have an opportunity to holistically analyze all the objects
    and code paths. This leads to the possibility of very high levels of optimization
    at compile times. Modern compilers work closely with modern hardware to produce
    some surprisingly optimized machine code. The point here is that developers can
    focus on solving business problems and, assuming the C++ developers are competent,
    the compiled program is still extremely optimized without requiring a lot of the
    developer’s time and effort. Since C++ allows you to directly inline assembly
    code as well, it gives the developers an even greater chance to work with the
    compiler and produce highly optimized executables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过C++是一种编译型语言，这使得它从本质上比解释型语言更快，因为它不会产生额外的运行时成本。由于开发者的完整源代码被编译成最终的执行二进制文件，编译器有机会全面分析所有对象和代码路径。这导致了在编译时实现非常高的优化水平的可能性。现代编译器与现代硬件紧密合作，生成一些令人惊讶的优化机器代码。这里的要点是，开发者可以专注于解决业务问题，并且假设C++开发者是合格的，编译程序仍然可以非常优化，而不需要开发者投入大量的时间和精力。由于C++还允许你直接内联汇编代码，这给了开发者更大的机会与编译器合作，生成高度优化的可执行文件。
- en: Statically typed
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型
- en: When it comes to type systems in programming languages, there are two options
    – **statically typed language** and **dynamically typed language**. A statically
    typed language performs checks around data types (integers, floats, doubles, structures,
    and classes) and interactions between these types during the compilation process.
    A dynamically typed language performs these type checks at runtime. Examples of
    statically typed languages are C++ and Java, and examples of dynamically typed
    languages are Python, Perl, and JavaScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到编程语言中的类型系统时，有两种选择——**静态类型语言**和**动态类型语言**。静态类型语言在编译过程中对数据类型（整数、浮点数、双精度浮点数、结构体和类）以及这些类型之间的交互进行检查。动态类型语言在运行时执行这些类型检查。静态类型语言的例子有C++和Java，动态类型语言的例子有Python、Perl和JavaScript。
- en: One big benefit of statically typed languages is that since all the type-checking
    is done at compile time, it gives us the opportunity to find and eliminate many
    bugs before the program is even run. Obviously, type checking alone cannot find
    all possible bugs, but the point we’re trying to make here is that statically
    typed languages do a significantly better job at finding errors and bugs related
    to types at compile time. This is especially true for low latency applications
    that are highly numerical in nature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言的一个重大好处是，由于所有类型检查都是在编译时完成的，这给了我们机会在程序运行之前找到并消除许多错误。显然，仅类型检查本身不能找到所有可能的错误，但我们试图说明的是，静态类型语言在编译时发现与类型相关的错误和错误方面做得更好。这对于高度数值化的低延迟应用程序尤其如此。
- en: Another huge benefit of statically typed languages, especially when it comes
    to low latency applications, is that since the type-checking is done at compile
    time, there is an additional opportunity for the compiler to optimize the types
    and type interactions at compile time. In fact, a large part of the reason that
    compiled languages are much faster is due to the static versus dynamic type-checking
    system itself. This is also a big reason why, for a dynamically typed language
    such as Python, high-performance libraries such as NumPy require types when creating
    arrays and matrices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言的一个巨大好处，尤其是在低延迟应用方面，是由于类型检查是在编译时进行的，这为编译器提供了额外的机会，在编译时优化类型和类型交互。事实上，编译语言之所以运行得更快，很大程度上是因为静态类型检查系统与动态类型检查系统本身的差异。这也是为什么对于像Python这样的动态类型语言，高性能库如NumPy在创建数组和矩阵时需要类型的原因。
- en: Multiple paradigms
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多范式
- en: Unlike some other languages, C++ does not force the developer to follow a specific
    programming paradigm. It supports a lot of different programming paradigms such
    as monolithic, procedural, **object-oriented programming** (**OOP**), generic
    programming, and so on. This makes it a good fit for a wide range of applications
    because it gives the developer the flexibility to design their program in a way
    that facilitates maximum optimization and lowest latencies instead of forcing
    a programming paradigm onto that application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些语言不同，C++并不强迫开发者遵循特定的编程范式。它支持许多不同的编程范式，如单体、过程式、**面向对象编程**（**OOP**）、泛型编程等。这使得它非常适合广泛的用途，因为它允许开发者以有利于最大优化和最低延迟的方式设计程序，而不是将编程范式强加给该应用。
- en: Libraries
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库
- en: 'Out of the box, C++ already comes with a large C and C++ library, which provides
    a lot of data structures, algorithms, and abstractions for tasks such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++本身就附带了一个大型的C和C++库，它提供了大量的数据结构、算法和抽象，用于以下任务：
- en: Network programming
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程
- en: Dynamic memory management
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存管理
- en: Numeric operations
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值操作
- en: Error and exception handling
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误和异常处理
- en: String operations
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Commonly needed algorithms
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用算法
- en: '**Input/output** (**I/O**) operations including file operations'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入/输出**（**I/O**）操作包括文件操作'
- en: Multithreading support
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程支持
- en: Additionally, the huge community of C++ developers has built and open-sourced
    a lot of the libraries; we will discuss some of the most popular ones in the following
    subsections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，庞大的C++开发者社区已经构建并开源了许多库；我们将在以下小节中讨论其中一些最受欢迎的库。
- en: Standard Template Library
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准模板库
- en: '**Standard Template Library** (**STL**) is a very popular and widely used templatized
    and header-only library containing data structures and containers, iterators and
    allocators for these containers, and algorithms for tasks such as sorting, searching,
    algorithms for the containers, and so on.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准模板库**（**STL**）是一个非常流行且广泛使用的模板化和仅包含头文件的库，它包含数据结构和容器、这些容器的迭代器和分配器，以及用于排序、搜索等任务的算法。'
- en: Boost
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Boost
- en: '**Boost** is a large C++ library that provides support for multithreading,
    network operations, image processing, **regular expressions** (**regex**), linear
    algebra, unit testing, and so on.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost**是一个大型C++库，它提供了对多线程、网络操作、图像处理、**正则表达式**（**regex**）、线性代数、单元测试等方面的支持。'
- en: Asio
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Asio
- en: '**Asio** (**asynchronous input/output**) is another well-known and widely used
    library that comes in two versions: **non-Boost** and one that is part of the
    Boost library. It provides support for multithreading concurrency and for implementing
    and using the asynchronous I/O model and is portable to all major platforms.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Asio**（**异步输入/输出**）是另一个广为人知且广泛使用的库，它有两个版本：**非Boost**版本和作为Boost库一部分的版本。它提供了对多线程并发、实现和使用异步I/O模型的支持，并且可移植到所有主要平台。'
- en: GNU Scientific Library
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GNU科学库
- en: '**GNU Scientific Library** (**GSL**) provides support for a wide range of mathematical
    concepts and operations such as complex numbers, matrices, and calculus, and manages
    other functions.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU科学库**（**GSL**）为各种数学概念和操作提供支持，如复数、矩阵和微积分，并管理其他函数。'
- en: Active Template Library
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 活动模板库
- en: '**Active Template Library** (**ATL**) is a template-heavy C++ library to help
    program the **Component Object Model** (**COM**). It replaces the previous **Microsoft
    Foundation Classes** (**MFC**) library and improves upon it. It is developed by
    Microsoft and is open source and heavily uses an important low latency C++ feature,
    the **Curiously Recurring Template Pattern** (**CRTP**), which we will also explore
    and use heavily in this book. It supports COM features such as dual interfaces,
    ActiveX controls, connection points, tear-off interfaces, COM enumerator interfaces,
    and a lot more.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Active Template Library**（**ATL**）是一个模板丰富的C++库，用于帮助编程**组件对象模型**（**COM**）。它取代了之前的**Microsoft
    Foundation Classes**（**MFC**）库，并对其进行了改进。它由微软开发，是开源的，并且大量使用了重要的低延迟C++特性，即**奇特重复模板模式**（**CRTP**），我们也将在此书中深入探讨并大量使用它。它支持COM功能，如双接口、ActiveX控件、连接点、可拆卸接口、COM枚举接口等，还有更多。'
- en: Eigen
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Eigen
- en: '**Eigen** is a powerful C++ library for mathematical and scientific applications.
    It has functions for linear algebra, numerical methods and solvers, numeric types
    such as complex numbers, features and operations for geometry, and much more.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eigen**是一个用于数学和科学应用的强大C++库。它提供了线性代数、数值方法和求解器、复数等数值类型、几何特征和操作等功能。'
- en: LAPACK
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LAPACK
- en: '**Linear Algebra Package** (**LAPACK**) is another large and extremely powerful
    C++ library specifically for linear algebra and linear equations and to support
    routines for large matrices. It implements a lot of functionality such as solving
    simultaneous linear equations, least squares methods, eigenvalues, **singular
    value decomposition** (**SVD**), and many more applications.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性代数包**（**LAPACK**）是另一个专门用于线性代数、线性方程以及支持大矩阵例程的强大C++库。它实现了许多功能，如求解联立线性方程、最小二乘法、特征值、**奇异值分解**（**SVD**）以及更多应用。'
- en: OpenCV
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OpenCV
- en: '**Open Source Computer Vision** (**OpenCV**) is one of the most well-known
    C++ libraries when it comes to computer graphics and vision-related applications.
    It is also available for Java and Python and provides many algorithms for face
    and object recognition, 3D models, machine learning, deep learning, and more.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Open Source Computer Vision**（**OpenCV**）是计算机图形和视觉相关应用中最知名的C++库之一。它也适用于Java和Python，并提供了许多用于人脸和物体识别、3D模型、机器学习、深度学习等的算法。'
- en: mlpack
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: mlpack
- en: '**mlpack** is a super-fast, header-only C++ library for a wide variety of machine
    learning models and the mathematical operations related to them. It also has support
    for other languages such as Go, Julia, R, and Python.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**mlpack**是一个超级快速、仅包含头文件的C++库，用于广泛的各种机器学习模型及其相关的数学运算。它还支持Go、Julia、R和Python等其他语言。'
- en: QT
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QT
- en: '**QT** is by far the most popular library when it comes to building cross-platform
    graphical programs in C++. It works on Windows, Linux, macOS, and even platforms
    such as Android and embedded systems. It is open source and is used to build GUI
    widgets.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**QT**是构建跨平台图形程序时最流行的库之一。它支持Windows、Linux、macOS，甚至Android和嵌入式系统等平台。它是开源的，用于构建GUI小部件。'
- en: Crypto++
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Crypto++
- en: '**Crypto++** is a free open source C++ library to support algorithms, operations,
    and utilities for cryptography. It has many cryptographic algorithms, random number
    generators, block ciphers, functions, public-key operations, secret sharing, and
    more across many platforms such as Linux, Windows, macOS, iOS, and Android.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Crypto++**是一个免费的开源C++库，用于支持密码学算法、操作和实用工具。它拥有许多密码学算法、随机数生成器、块加密、函数、公钥操作、秘密共享等，跨越Linux、Windows、macOS、iOS和Android等多个平台。'
- en: Suitable for big projects
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适合大型项目
- en: In the previous section, we discussed the design and a lot of features of C++
    that make it a great fit for low latency applications. Another aspect of C++ is
    that because of the flexibility it provides to the developer and all the high-level
    abstractions it allows you to build, it is actually very well suited to very large
    real-world projects. Huge projects such as compilers, cloud processing and storage
    systems, and **OSes** are built in C++ for these reasons. We will dive into these
    and many other applications that try to strike a balance between low latency performance,
    feature richness, and different business cases, and quite often, C++ is the perfect
    fit for developing such systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了C++的设计和众多特性，使其非常适合低延迟应用。C++的另一个方面是，由于它为开发者提供的灵活性和允许构建的所有高级抽象，它实际上非常适合非常大的现实世界项目。像编译器、云处理和存储系统以及**操作系统**这样的大型项目就是出于这些原因用C++编写的。我们将深入探讨这些以及其他许多试图在低延迟性能、功能丰富性和不同的业务案例之间取得平衡的应用，而且很多时候，C++是开发此类系统的完美选择。
- en: Mature and large community support
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成熟且庞大的社区支持
- en: The C programming language was originally created in 1972, and then C++ (originally
    referred to as C with classes) was created in 1983\. C++ is a very mature language
    and is embedded extensively into many applications in many different business
    areas. Some examples are the Unix operating system, Oracle MySQL, the Linux kernel,
    Microsoft Office, and Microsoft Visual Studio – these were all written in C++.
    The fact that C++ has been around for 40 years means that most software problems
    have been encountered and solutions have been designed and implemented. C++ is
    also very popular and taught as part of most computer science degrees and, additionally,
    has a huge library of developer tools, third-party components, open source projects,
    libraries, manuals, tutorials, books, and so on dedicated to it. The bottom line
    is that there is a large amount of documentation, examples, and community support
    backing up new C++ developers and new C++ projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C编程语言最初是在1972年创建的，然后C++（最初被称为带类的C）在1983年创建。C++是一种非常成熟的语言，并且被广泛嵌入到许多不同业务领域的许多应用中。一些例子包括Unix操作系统、Oracle
    MySQL、Linux内核、Microsoft Office和Microsoft Visual Studio——这些都是在C++中编写的。C++存在了40年意味着大多数软件问题都已经遇到，并且已经设计和实现了解决方案。C++也非常受欢迎，并且作为大多数计算机科学学位的一部分进行教授，此外，还有一个庞大的开发者工具、第三方组件、开源项目、库、手册、教程、书籍等库，专门针对它。总之，有大量的文档、示例和社区支持支持新的C++开发者和新的C++项目。
- en: Language under active development
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在积极开发的语言
- en: 'Even though C++ is 40 years old, it is still very much under active development.
    Ever since the first C++ version was commercially released in 1985, there have
    been multiple improvements and enhancements to the C++ standard and the language.
    In chronological order, C++ 98, C++ 03, C++ 0X, C++ 11, C++ 14, C++ 17, and C++
    20 have been released, and C++ 23 is being developed. Each version comes with
    improvements and new features. So, C++ is a powerful language and is constantly
    evolving with time and adding modern features. Here is a diagram showing the evolution
    of C++ over the years:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++已经40岁了，但它仍然处于积极开发中。自从1985年第一个C++版本商业发布以来，C++标准和语言已经经历了多次改进和增强。按时间顺序，发布了C++
    98、C++ 03、C++ 0X、C++ 11、C++ 14、C++ 17和C++ 20，C++ 23正在开发中。每个版本都带来了改进和新特性。因此，C++是一种强大的语言，并且随着时间的推移不断进化，添加现代特性。以下是一个展示C++多年演变的图表：
- en: '![Figure 1.2 – Evolution of C++ ](img/Figure_1.2_B19434.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – C++的演变](img/Figure_1.2_B19434.jpg)'
- en: Figure 1.2 – Evolution of C++
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – C++的演变
- en: Given the already mature state of the C++ programming language, super-fast speed,
    perfect combination of high-level abstractions and low-level hardware access and
    control, huge knowledge base, and developer community along with best practices,
    libraries, and tools, C++ is a clear pick for low latency application development.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到C++编程语言已经非常成熟，超快的速度，高级抽象与低级硬件访问和控制的完美结合，庞大的知识库，以及开发者社区以及最佳实践、库和工具，C++是低延迟应用开发的明显选择。
- en: In this section, we looked at the choice of the C++ programming language for
    low latency application development. We discussed the various characteristics,
    features, libraries, and community support that make it a great fit for these
    applications. It is no surprise that C++ is deeply embedded into most applications
    that have strict performance requirements. In the next section, we will look at
    a lot of different low latency applications in different business areas with the
    goal of understanding the similarities that such applications share.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了为低延迟应用开发选择 C++ 编程语言的原因。我们讨论了使其成为这些应用极佳选择的各项特性、功能、库和社区支持。C++ 深度嵌入到大多数具有严格性能要求的程序中，这并不令人惊讶。在下一节中，我们将探讨不同商业领域的许多不同低延迟应用，目标是理解这些应用共享的相似之处。
- en: Introducing some important low latency applications
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍一些重要的低延迟应用
- en: In this section, we will explore some common low latency applications in different
    business areas in order to familiarize ourselves with different kinds of latency-sensitive
    applications and how latency plays an important part in their performance. Additionally,
    discussing these applications will reveal some similarities in the nature and
    design of these applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同商业领域的一些常见低延迟应用，以便我们熟悉不同类型的低延迟应用以及延迟如何在它们的性能中扮演重要角色。此外，讨论这些应用将揭示这些应用在性质和设计上的相似之处。
- en: Lower-level low latency applications
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低级低延迟应用
- en: First, we will start with applications that would be considered extremely low-level,
    meaning very close to the hardware. Note that all low latency applications have
    at least some portion of the application that is low-level since, by definition,
    that is how low latency performance is achieved. These applications, however,
    have large portions of the entire application dealing with mostly low-level details;
    let us discuss those next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从被认为是极低级的应用开始，这意味着非常接近硬件。请注意，所有低延迟应用至少有一部分是低级的，因为按照定义，这就是实现低延迟性能的方式。然而，这些应用的大部分处理的是主要与低级细节相关的整个应用；让我们接下来讨论这些。
- en: Telecommunications
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电信
- en: We already discussed that C++ is one of the fastest programming languages out
    there. It is used a lot in building telephone switches, routers, internet, space
    probes, and various other parts of telecommunications infrastructure. These applications
    are required to handle a large number of simultaneous connections and facilitate
    communication between them. These applications need to perform these tasks with
    speed and efficiency, making them a good example of low latency applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，C++ 是最快的编程语言之一。它在构建电话交换机、路由器、互联网、太空探测器以及电信基础设施的各个部分中得到了广泛应用。这些应用需要处理大量的并发连接，并促进它们之间的通信。这些应用需要以速度和效率执行这些任务，使它们成为低延迟应用的优秀例子。
- en: Embedded systems
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入式系统
- en: Since C++ is closer to the hardware compared to other high-level programming
    languages, it is used in latency-sensitive embedded systems. Some examples of
    these would be machines used in the field of medicine, surgical tools, smart watches,
    and so on. C++ is usually the language of choice for medical applications such
    as MRI machines, lab testing systems, and systems to manage patient information.
    Additionally, there are use cases to model medical data, run simulations for research,
    and so on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C++ 与其他高级编程语言相比更接近硬件，因此它被用于低延迟敏感的嵌入式系统。这些应用的例子包括用于医学领域的机器、手术工具、智能手表等。C++
    通常是医疗应用的优选语言，例如 MRI 机器、实验室测试系统以及管理患者信息的系统。此外，还有用于建模医疗数据、进行研究模拟等用例。
- en: Compilers
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器
- en: Interestingly, compilers for various programming languages use C and C++ to
    build the compilers for those languages. The reason for this is, again, that C
    and C++ are low-level languages closer to the hardware and can build these compilers
    efficiently. The compiler applications themselves are able to optimize the code
    for the programming language to a very large degree and produce low latency machine
    code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，各种编程语言的编译器使用 C 和 C++ 来构建这些语言的编译器。原因再次是，C 和 C++ 是接近硬件的低级语言，可以有效地构建这些编译器。编译器应用程序本身能够非常大地优化编程语言的代码，并生成低延迟的机器代码。
- en: Operating systems
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作系统
- en: From Microsoft Windows to macOS to Linux itself, all the major OSes are built
    in C++ – yet again, another example of a low latency application where the fact
    that C++ is a low-level language makes it an ideal fit. OSes are extremely large
    and extremely complex. In addition to that, they have to have low latency and
    be highly performant to be a competitive modern OS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从微软Windows到macOS再到Linux本身，所有主要的操作系统都是用C++编写的——这又是C++作为低级语言使其成为低延迟应用理想选择的一个例子。操作系统极其庞大且极其复杂。除此之外，它们还必须具有低延迟和高度性能，才能成为具有竞争力的现代操作系统。
- en: For instance, Linux is typically the OS of choice for many high-load servers
    as well as servers designed for low latency applications, so the OS itself needs
    to have very high performance. In addition to traditional OSes, C and C++ are
    also heavily used to build mobile OSes such as iOS, Android, and Windows phone
    kernels. In summary, OSes need to be extremely fast and efficient at managing
    all the system and hardware resources. C++ developers building OSes can leverage
    the language’s abilities to build super-low-latency OSes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Linux通常是许多高负载服务器以及为低延迟应用设计的服务器的首选操作系统，因此操作系统本身需要非常高的性能。除了传统的操作系统之外，C和C++也被广泛用于构建移动操作系统，如iOS、Android和Windows手机内核。总的来说，操作系统需要在管理所有系统和硬件资源方面非常快速和高效。构建操作系统的C++开发者可以利用语言的能力来构建超低延迟的操作系统。
- en: Cloud/distributed systems
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云/分布式系统
- en: Organizations that develop and use cloud and distributed storage and processing
    systems have very low latency requirements. For this reason, they rely heavily
    on a programming language such as C++. Distributed storage systems have to support
    very fast and very efficient filesystem operations, so need to be close to the
    hardware. Additionally, distributed processing generally means high levels of
    concurrency, reliance on low latency multithreading libraries, as well as high
    load tolerance and scalability optimization requirements.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和使用云和分布式存储及处理系统的组织对低延迟有非常高的要求。因此，它们严重依赖像C++这样的编程语言。分布式存储系统必须支持非常快速和高效的文件系统操作，因此需要接近硬件。此外，分布式处理通常意味着高并发级别，依赖低延迟的多线程库，以及高负载容忍和可扩展性优化要求。
- en: Databases
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库
- en: Databases are another good example of applications that need low latencies and
    high levels of concurrency and parallelism. Databases are also critical components
    in many different applications in many different business areas. Postgres, MySQL,
    and MongoDB (which are by far the most popular database systems right now) are
    written in C and C++ – yet another example of why C++ is the preferred language
    for low latency applications. C++ is also ideal for designing and structuring
    databases to optimize storage efficiency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是另一类需要低延迟、高并发和并行性的应用的好例子。数据库也是许多不同商业领域许多不同应用中的关键组件。Postgres、MySQL和MongoDB（目前最受欢迎的数据库系统）都是用C和C++编写的——这又是为什么C++是低延迟应用首选语言的一个例子。C++也是设计和构建数据库以优化存储效率的理想选择。
- en: Flight software and traffic control
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 飞行软件和交通控制
- en: Flight software for commercial airplanes and military aircraft is a class of
    latency-critical applications. Here, not only is it important that the code follow
    very strict guidelines, be extremely robust, and be very well tested but the applications
    also need to respond and react to events predictably and within strict latency
    thresholds.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 商用飞机和军用飞机的飞行软件是具有低延迟关键应用的一类。在这里，代码不仅需要遵循非常严格的指南，非常健壮，并且经过非常彻底的测试，而且应用程序还需要可预测地响应和反应事件，并在严格的延迟阈值内。
- en: Traffic control software depends on many sensors, which need to monitor the
    speed, location, and volume of vehicles and transmit them to the central software.
    The software then uses the information to control traffic signs, maps, and traffic
    lights. Obviously, for such real-time applications, there is a requirement for
    it to be low latency and easily able to handle the large volume of data quickly
    and efficiently.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 交通控制软件依赖于许多传感器，这些传感器需要监控车辆的速度、位置和流量，并将这些信息传输到中央软件。软件随后使用这些信息来控制交通标志、地图和交通灯。显然，对于这种实时应用，它需要具有低延迟并且能够快速高效地处理大量数据。
- en: Higher-level low latency applications
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级低延迟应用
- en: In this subsection, we will discuss what many might consider slightly higher-level
    low latency applications. These are the applications people typically think of
    when trying to solve business problems; however, one thing to keep in mind is
    that these applications still have to implement and use lower-level optimization
    techniques to provide the performance that is required of them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将讨论许多人可能认为稍微高级一点的低延迟应用。这些是人们在尝试解决商业问题时通常会想到的应用；然而，需要注意的是，这些应用仍然需要实现和使用低级优化技术，以提供所需性能。
- en: Graphics and video game applications
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形和视频游戏应用
- en: Graphics applications require super-fast rendering performance and serve as
    another example of a low latency application. Graphics software employs techniques
    from computer vision, image processing, and so on, which typically involves a
    lot of very fast and very efficient matrix operations on numerous large matrices.
    When it comes to graphics rendering in video games, there are even more stringent
    requirements for low latency performance since these are interactive applications,
    and speed and responsiveness are critical to the user experience. Nowadays, video
    games are typically made available on multiple platforms to reach a larger target
    audience. What this means is that these applications, or slightly stripped-down
    versions of these applications, need to run on low-end devices, which might not
    have a lot of computation and memory resources available. Video games overall
    have a lot of resource-intensive operations – rendering graphics, handling multiple
    players simultaneously, fast responsiveness to user inputs, and so on. C++ is
    a very good fit for all these applications and has been used to create a lot of
    well-known games such as Counter-Strike, Starcraft, and Warcraft, and game engines
    such as Unreal Engine. C++ is also a good fit for different gaming platforms –
    Windows PCs, Nintendo Switch, Xbox, and PlayStation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图形应用需要超快的渲染性能，这又是一个低延迟应用的例子。图形软件采用计算机视觉、图像处理等技术，通常涉及在众多大型矩阵上进行大量非常快且非常高效的矩阵运算。当涉及到视频游戏中的图形渲染时，对低延迟性能的要求更为严格，因为这些是交互式应用，速度和响应性对用户体验至关重要。如今，视频游戏通常在多个平台上提供，以覆盖更广泛的受众。这意味着这些应用，或者这些应用的简化版本，需要在低端设备上运行，这些设备可能没有很多计算和内存资源。总体而言，视频游戏有很多资源密集型操作——渲染图形、同时处理多个玩家、快速响应用户输入等。C++非常适合所有这些应用，并被用于创建许多知名游戏，如《反恐精英》、《星际争霸》和《魔兽世界》，以及游戏引擎如虚幻引擎。C++也适合不同的游戏平台——Windows
    PC、任天堂Switch、Xbox和PlayStation。
- en: Augmented reality and virtual reality applications
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强现实和虚拟现实应用
- en: '**Augmented reality** (**AR**) and **virtual reality** (**VR**) are both technologies
    that augment and enhance a real-life environment or create a whole new virtual
    environment. While AR just augments the environment by adding digital elements
    to our live view, VR creates a completely new simulated environment. So, these
    applications take graphics rendering and video game applications to a whole new
    level.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强现实**（**AR**）和**虚拟现实**（**VR**）都是增强和增强现实生活环境或创建全新虚拟环境的技术。虽然AR只是通过向我们的实时视图添加数字元素来增强环境，但VR则创建了一个完全新的模拟环境。因此，这些应用将图形渲染和视频游戏应用提升到了一个新的水平。'
- en: AR and VR technology has found a lot of different business use cases, such as
    design and construction, maintenance and repairs, training and education, healthcare,
    retail and marketing, and even in the field of technology itself. AR and VR applications
    have similar requirements as video game applications and need to handle large
    amounts of data from various sources in real time, as well as handle user interactions
    seamlessly and smoothly. The technical challenges for these applications are handling
    limited processing capability and available memory, possibly limited mobile bandwidth,
    and maintaining low latency and real-time performance to not hurt the user experience.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实（AR）和虚拟现实（VR）技术已经找到了许多不同的商业应用场景，例如设计和建筑、维护和修理、培训和教学、医疗保健、零售和营销，甚至是在技术本身领域。AR和VR应用与视频游戏应用有类似的要求，需要实时处理来自各种来源的大量数据，并且需要无缝且平滑地处理用户交互。这些应用的技术挑战在于处理有限的处理能力和可用内存，可能有限的移动带宽，以及保持低延迟和实时性能，以免影响用户体验。
- en: Browsers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器
- en: Web browsers are often more complicated than they might appear. There are rendering
    engines in a web browser that require low latencies and efficient processing.
    Additionally, there are often interactions with databases and interactive rendering
    code so that users do not have to wait a long time for the content to update or
    for interactive content to respond. Due to the low latency requirements of web
    browsers, it is no surprise that C++ is often the preferred language for this
    application as well. In fact, some of the most popular web browsers (Google Chrome,
    Mozilla Firefox, Safari, Opera, etc.) heavily employ C++.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器通常比它们看起来要复杂。网络浏览器中包含渲染引擎，这些引擎需要低延迟和高效的处理。此外，通常还需要与数据库和交互式渲染代码进行交互，以便用户不必等待很长时间才能更新内容或响应交互式内容。由于网络浏览器的低延迟要求，C++经常被选为这种应用的优先语言也就不足为奇了。实际上，一些最受欢迎的网络浏览器（如Google
    Chrome、Mozilla Firefox、Safari、Opera等）都大量使用了C++。
- en: Search engines
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索引擎
- en: Search engines are another use case that requires low latency and highly efficient
    data structures, algorithms, and code bases. Modern search engines such as Google
    use techniques such as internet crawling technology, indexing infrastructures,
    page rank algorithms, and other complex algorithms including machine learning.
    Google’s search engine relies on C++ to implement all these requirements in a
    highly low latency and efficient fashion.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎是另一个需要低延迟和高度高效的数据结构、算法和代码库的应用场景。现代搜索引擎，如Google，使用诸如网络爬虫技术、索引基础设施、页面排名算法以及其他复杂算法（包括机器学习）等技术。Google的搜索引擎依赖于C++以高度低延迟和高效的方式实现所有这些要求。
- en: Libraries
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库
- en: Many high-level libraries often have stringent performance requirements and
    can be regarded as low latency applications themselves but usually, they are key
    components in larger low latency applications and businesses. These libraries
    cover different areas – network programming, data structures, faster algorithms,
    databases, multithreading, mathematical libraries (for example, machine learning),
    and many more. Such libraries require very low latency and high-performance processing
    such as computations that involve many matrix operations on a large number of
    matrices, a lot of which can also be very large in size.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级库通常有严格的功能要求，并且可以被视为低延迟应用本身，但通常，它们是更大低延迟应用和业务的关键组件。这些库涵盖了不同的领域——网络编程、数据结构、更快的算法、数据库、多线程、数学库（例如，机器学习）等等。这些库需要非常低的延迟和高性能处理，例如涉及大量矩阵运算的计算，其中许多矩阵也可能非常大。
- en: It should be clear here that performance is critical in such applications –
    another area where C++ is often used quite heavily. Even though a lot of these
    libraries such as TensorFlow are available in Python, under the hood, the core
    machine learning mathematical operations are actually implemented in C++ to power
    these machine learning methods on huge datasets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在这里清楚的是，在这些应用中性能是至关重要的——C++经常被大量使用的另一个领域。尽管像TensorFlow这样的许多库在Python中可用，但实际上，这些库的核心机器学习数学运算实际上是用C++实现的，以支持在大型数据集上运行这些机器学习方法。
- en: Banking and financial applications
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 银行和金融应用程序
- en: Banking applications are another class of low latency applications that need
    to process millions of transactions every day and require low latency, high concurrency,
    and robustness. Large banks have millions of clients and hundreds of millions
    of transactions that all need to be executed correctly and quickly and be able
    to scale up to handle the client load and thus database and server loads. C++
    is automatically the choice here for a lot of these banking applications for the
    reasons we have discussed before.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 银行应用程序是另一类需要每天处理数百万笔交易的低延迟应用，需要低延迟、高并发性和健壮性。大型银行有数百万客户和数十亿笔交易，所有这些都需要正确且快速地执行，并且能够扩展以处理客户负载，从而数据库和服务器负载。正如我们之前讨论的那样，C++自动成为许多这些银行应用程序的选择。
- en: When it comes to applications such as financial modeling, electronic trading
    systems, and trading strategies, low latency is more critical than in any other
    field. The speed and deterministic performance of C++ make it ideal for processing
    billions of market updates. sending millions of orders, and transacting at the
    exchange, especially when it comes to HFT. Since markets update very quickly,
    trading applications need the right data very quickly to execute trades extremely
    quickly. Large latencies in this system can cause losses that destroy a significant
    amount of trading profits, or worse. On the research and development side of things,
    simulations over many trading instruments across multiple exchanges also need
    large-scale low latency distributed processing to be done quickly and efficiently.
    The quantitative development and research and risk analysis libraries are also
    written in C++ because they need to process massive amounts of data as quickly
    as possible. One of the best examples of this would be the pricing and risk libraries
    that calculate fair trading prices for options products and run many simulations
    to assess options risk, as the search space is enormous.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到金融建模、电子交易系统和交易策略等应用时，低延迟比其他任何领域都更为关键。C++的速度和确定性性能使其非常适合处理数十亿的市场更新、发送数百万订单以及在交易所进行交易，尤其是在高频交易（HFT）方面。由于市场更新非常快，交易应用程序需要非常快速地获取正确数据以执行交易，否则会导致损失，这些损失可能会破坏大量的交易利润，甚至更糟。在研究和开发方面，跨多个交易所的多种交易工具的模拟也需要进行大规模的低延迟分布式处理，以便快速高效地完成。定量开发和研究以及风险分析库也用C++编写，因为它们需要尽可能快地处理大量数据。其中一个最好的例子是定价和风险库，它计算期权产品的公平交易价格并运行许多模拟以评估期权风险，因为搜索空间是巨大的。
- en: Mobile phone applications
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动电话应用程序
- en: Modern mobile phone applications are quite feature-rich. Additionally, they
    have to run on platforms with very limited hardware resources. This makes it even
    more important that the implementation of these applications be very low latency
    and highly efficient in how they use the limited resources they have. However,
    these applications still need to be extremely quick to respond to user interactions,
    possibly handle backend connectivity, and render high-quality graphics on mobile
    devices. Mobile platforms such as Android and the Windows OS, browsers such as
    Google Chrome and Firefox, and apps such as YouTube have a lot of C++ involvement.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动应用程序功能丰富。此外，它们必须在具有非常有限的硬件资源的平台上运行。这使得这些应用程序的实现必须具有非常低的延迟，并且在使用它们有限的资源时必须非常高效。然而，这些应用程序仍然需要非常快速地响应用户交互，可能需要处理后端连接，并在移动设备上渲染高质量的图形。Android和Windows
    OS等移动平台、Google Chrome和Firefox等浏览器以及YouTube等应用程序都有大量的C++参与。
- en: Internet of Things and machine-to-machine applications
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物联网和机器对机器应用
- en: '**Internet of Things** (**IoT**) and **machine-to-machine** (**M2M**) applications
    are based on connecting devices to collect, store and exchange data with each
    other automatically. Overall, while IoT and M2M are similar in nature, there are
    some differences around aspects such as networks, scalability, interoperability,
    and human interactions.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**物联网**（**IoT**）和**机器对机器**（**M2M**）应用基于连接设备自动收集、存储和交换数据。总体而言，虽然物联网和M2M在本质上相似，但在网络、可扩展性、互操作性和人机交互等方面存在一些差异。'
- en: IoT is a broad term that refers to connecting different physical devices together.
    IoT devices are generally actuators and sensors that are embedded inside other
    larger devices such as smart thermostats, refrigerators, doorbells, cars, smart
    watches, TVs, and medical devices. These devices operate on platforms with limited
    computing resources, power requirements, and minimal available memory resources.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）是一个广泛的概念，指的是将不同的物理设备连接在一起。物联网设备通常是嵌入在其他更大设备中的执行器和传感器，例如智能恒温器、冰箱、门铃、汽车、智能手表、电视和医疗设备。这些设备在具有有限计算资源、电源需求和最小可用内存资源的平台上运行。
- en: M2M is a communication method where multiple machines interact with each other
    using wired or wireless connections without any human oversight or interaction.
    The point here is that internet connectivity is not necessary for M2M. So IoT
    is a subset of M2M, but M2M is a broader universe of M2M communication-based systems.
    M2M technology is used in different applications such as security, tracking and
    tracing, automation, manufacturing, and facility management.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: M2M是一种通信方法，其中多个机器通过有线或无线连接相互交互，无需任何人为监督或交互。这里的关键点是互联网连接对于M2M不是必需的。因此，物联网是M2M的一个子集，但M2M是一个更广泛的基于M2M通信系统的宇宙。M2M技术被应用于不同的应用中，如安全、追踪和追溯、自动化、制造和设施管理。
- en: We have already discussed these applications before, but to summarize again
    here, IoT and M2M technology are used in applications such as telecommunications,
    medical and healthcare, pharmaceuticals, automotive and aerospace industries,
    retail and logistics and supply chain management, manufacturing, and military
    satellite data analysis systems.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过这些应用，但在此再次总结，物联网和M2M技术被应用于电信、医疗和保健、制药、汽车和航空航天工业、零售和物流及供应链管理、制造以及军事卫星数据分析系统等应用中。
- en: This section was all about different business areas and use cases where low
    latency applications thrive and, in some cases, are a necessity for the business.
    Our hope is that you understand that low latency applications are used in many
    different areas, even though it might not be immediately obvious. The other objective
    here was to establish similarities that these applications share, even though
    they are designed to solve different business problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要介绍了不同商业领域和用例，在这些领域中低延迟应用蓬勃发展，在某些情况下，低延迟应用对业务来说是必需的。我们的希望是您能理解低延迟应用被应用于许多不同的领域，尽管这可能并不立即明显。本节的另一个目标是确定这些应用之间共享的相似之处，尽管它们被设计来解决不同的商业问题。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided an introduction to low latency applications. First,
    we defined latency-sensitive and latency-critical applications and different measures
    of latency. We then discussed different metrics that are important in low latency
    applications and other considerations that define the requirements of low latency
    applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了低延迟应用。首先，我们定义了延迟敏感型和延迟关键型应用以及不同的延迟度量。然后，我们讨论了在低延迟应用中重要的不同指标以及其他定义低延迟应用要求的考虑因素。
- en: We spent a section of this chapter understanding why C++ is most frequently
    chosen for low latency applications across different businesses. Specifically,
    we discussed the features of the language itself and also the flexibility and
    low-level nature of the language, which makes C++ a perfect fit when it comes
    to low latency applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的一节中探讨了为什么C++是跨不同业务领域低延迟应用中最常选择的语言。具体来说，我们讨论了语言本身的特点以及语言的灵活性和底层性质，这使得C++在低延迟应用中成为完美的选择。
- en: Finally, we looked at many different examples of low latency applications across
    different businesses and the similarities they share. The point of that discussion
    is that even though the business cases are different, these applications share
    a lot of common requirements and features. Again, here, C++ is a good fit for
    most (if not all) of these low latency applications in different business areas.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考察了不同业务领域中的许多低延迟应用的例子以及它们共享的相似之处。这次讨论的要点是，尽管业务案例不同，但这些应用共享许多共同的要求和特性。再次强调，在这里，C++对于大多数（如果不是所有）这些不同业务领域的低延迟应用都是一个很好的选择。
- en: In the next chapter, we will discuss some of the most popular low latency applications
    in much greater detail. In this book, we will be using low latency electronic
    trading as a case study to understand and apply C++ low latency techniques. However,
    before we do that, we will explore other low latency applications such as real-time
    video streaming, real-time offline and online video gaming applications, and IoT
    applications as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论一些最受欢迎的低延迟应用。在本书中，我们将使用低延迟电子交易作为一个案例研究来理解和应用C++低延迟技术。然而，在我们这样做之前，我们将探讨其他低延迟应用，例如实时视频流、实时离线和在线视频游戏应用，以及物联网应用。
