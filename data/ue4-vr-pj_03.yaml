- en: Hello World - Your First VR Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好世界 - 你的第一个VR项目
- en: It's time to start building! Back in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, we learned what VR is and what it can do, and we learned a number
    of best practices for its design. Then, in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting up Your Development Environment*, we set up our development environment.
    Now we're ready to start building.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建了！在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中，我们学习了什么是VR以及它能做什么，我们还学习了一些关于VR设计的最佳实践。然后，在[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中，我们设置了开发环境。现在我们准备好开始构建了。
- en: In this chapter, we're going to build a VR project in Unreal from the ground
    up. We're going to take a different approach, though, from most tutorials. Rather
    than just give you a list of steps to follow, for each thing we do we're going
    to talk a bit about what's going on under the hood and why we're doing it this
    way. This is what's really important. If you understand a bit about how these
    systems work, you'll be much better equipped to understand what to do when you
    build your own projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始在虚幻中构建一个VR项目。然而，我们将采取与大多数教程不同的方法。我们不仅仅给你一系列要遵循的步骤，对于我们所做的每一件事，我们都会谈一谈在幕后发生了什么，以及为什么我们要以这种方式做。这才是真正重要的。如果你对这些系统的工作原理有一些了解，你在构建自己的项目时将更加有能力知道该做什么。
- en: As we build our first VR project, we're going to learn a bit about its structure,
    and we'll learn about the specific project settings that apply most to VR development.
    We'll also look at those settings and choices that specifically affect mobile
    VR, and show you what you need to know there. From here, we'll bring a detailed
    scene into our project and learn a bit about how to move assets safely between
    projects and how to manage a project's content. Finally, we'll set up the game
    mode and pawn blueprints we'll need to run a VR project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的第一个VR项目时，我们将了解一些关于其结构的知识，并了解适用于VR开发的特定项目设置。我们还将查看那些特别影响移动VR的设置和选择，并向您展示在这方面需要了解的内容。从这里开始，我们将在项目中引入一个详细的场景，并学习如何在项目之间安全地移动资产以及如何管理项目的内容。最后，我们将设置游戏模式和角色蓝图，以便运行VR项目。
- en: 'This chapter will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating a project for VR from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建一个VR项目
- en: Understanding important settings and choices you need to make when you start
    your project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在开始项目时需要做出的重要设置和选择
- en: Setting up a project for mobile VR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动VR设置项目
- en: Moving content safely between projects and managing content within your project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目之间安全地移动内容和管理项目内的内容
- en: Setting up the basic blueprints you'll need for VR development in Unreal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻中设置你在VR开发中所需的基本蓝图
- en: Creating a new project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: All right, let's start creating!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始创建！
- en: The first thing we need to do is create a new project. We created a few quick
    throwaway projects in the previous chapter just to make sure everything was working,
    but now we're ready to begin building for real.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新项目。在上一章中，我们创建了一些快速的临时项目，只是为了确保一切正常工作，但现在我们准备好开始真正的构建了。
- en: Open your **Epic Games Launcher** if it isn't already open, head to the Library
    tab, and where you see your **Engine Versions**, hit Launch on your most current
    engine version. (You can do this from the Launch button on the left side of the
    launcher as well.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的**Epic Games Launcher**还没有打开，请打开它，转到“库”选项卡，在“引擎版本”下找到你最新的引擎版本，点击“启动”。（你也可以从启动器左侧的启动按钮进行操作。）
- en: The Unreal Project Browser will appear. Select the New Project tab, and let's
    select the Blueprint tab and the Blank template to create an empty Blueprint project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻项目浏览器将出现。选择“新项目”选项卡，让我们选择“蓝图”选项卡和“空白”模板来创建一个空的蓝图项目。
- en: '**Templates** are very useful starting points for Unreal projects. They contain
    simple and useful working foundations of many game types, and much of the time
    when you''re starting a new project, you''ll want to use them. We''re beginning
    with a blank project here so you can see each element as it goes in. You''ll probably
    most commonly use the First Person, Third Person, and VR templates as starting
    points for most projects.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**是虚幻引擎项目的非常有用的起点。它们包含了许多游戏类型的简单和有用的工作基础，当你开始一个新项目时，你通常会想要使用它们。我们从一个空白项目开始，这样你就可以看到每个元素的添加过程。对于大多数项目，你可能最常用的是第一人称、第三人称和VR模板作为起点。'
- en: 'We have a few more choices to make on this dialog, and we should understand
    what they mean:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对话框上我们还有一些选择要做，并且我们应该了解它们的含义：
- en: '![](img/f5bc6ebe-5313-4412-9fff-3a203ab665bd.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5bc6ebe-5313-4412-9fff-3a203ab665bd.png)'
- en: Setting your hardware target
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬件目标
- en: 'The Hardware Target selector gives you two options:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件目标选择器提供了两个选项：
- en: Desktop / Console
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面/主机
- en: Mobile / Tablet
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动/平板
- en: Ordinarily, you should choose the correct option for your target platform, but
    when developing for VR, it can be a good idea to select the Mobile / Tablet option
    even if you're developing for desktop, as that option will turn off a few rendering
    options that can be expensive in VR.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该选择适合目标平台的正确选项，但是在开发VR时，即使你是为桌面开发，选择移动/平板选项也是一个好主意，因为该选项会关闭一些在VR中可能很昂贵的渲染选项。
- en: 'Specifically, choosing the mobile target rather than the desktop target will
    turn off the following rendering options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，选择移动目标而不是桌面目标将关闭以下渲染选项：
- en: Separate Translucency
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离半透明度
- en: Bloom
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛光
- en: Ambient Occlusion
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境遮蔽
- en: Setting your graphics target
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置图形目标
- en: 'The next choice you need to make is your **Graphics Target**. Again, you have
    two choices here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做出的下一个选择是你的**图形目标**。同样，在这里你有两个选择：
- en: Maximum Quality
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高质量
- en: Scalable 3D or 2D
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的3D或2D
- en: Selecting Maximum Quality will turn on all of the default high-end rendering
    options Unreal Engine offers. As we've mentioned previously, however, in VR, meeting
    your target framerate is far more important than including detail in your scene.
    For VR development, it's always a good idea to select the Scalable option.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最高质量将打开Unreal Engine提供的所有默认高端渲染选项。然而，如前所述，在VR中，达到目标帧率比在场景中包含细节更重要。对于VR开发，选择可扩展选项总是一个好主意。
- en: You're better off beginning with everything turned off and turning things on
    as you need them. If you start the other way, with everything turned on, it can
    be difficult to figure out what's killing your framerate and figure out what you
    need to turn off. It's a much better practice to start with your project running
    at a reasonable speed and keep it running quickly than to build something that
    runs poorly and hope that you're somehow going to get it running faster later
    on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是从关闭所有内容开始，根据需要逐渐打开它们。如果你从一开始就打开了所有内容，很难弄清楚是什么导致了帧率下降，并找出需要关闭的内容。最好的做法是从项目以合理的速度运行开始，并保持快速运行，而不是构建一个运行效果差的项目，并希望以后能够更快地运行。
- en: Settings summary
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置摘要
- en: 'For our project, we''re going to go with the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将选择以下内容：
- en: 'Project Template: Blueprint - Blank'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：蓝图-空白
- en: 'Hardware Target: Mobile / Tablet'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件目标：移动设备/平板电脑
- en: 'Graphics Target: Scalable 2D or 3D'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形目标：可扩展的2D或3D
- en: No Starter Content
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有起始内容
- en: We can leave the Starter Content turned off for now, since we can easily add
    that stuff later when we need it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将Starter Content关闭，因为我们可以在需要时轻松添加这些内容。
- en: Choose where you'd like to save your project and hit Create Project to set it
    up.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想保存项目的位置，然后点击创建项目来设置它。
- en: Taking a quick look at your project's structure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速查看项目的结构
- en: We've now created an empty project. Let's take a brief moment to take a look
    at what that actually means.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个空项目。让我们花点时间来看看这实际上意味着什么。
- en: 'If you navigate Windows Explorer to the location where you saved your project,
    you''ll see that Unreal has created a file there with your project''s name and
    the `.uproject` extension, along with four directories:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows资源管理器中导航到保存项目的位置，你会看到Unreal在那里创建了一个带有项目名称和`.uproject`扩展名的文件，以及四个目录：
- en: '**Config**: Configuration files such as `DefaultEngine.ini` and `DefaultGame.ini`
    live here and hold settings for your engine and project.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config**：配置文件，如`DefaultEngine.ini`和`DefaultGame.ini`，存放在这里，保存了引擎和项目的设置。'
- en: '**Content**: This is where your project''s assets, such as models, textures,
    materials, and blueprints will live. This is the bulk of your project.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Content**：这是你的项目的资产所在的地方，如模型、纹理、材质和蓝图。这是你项目的主要部分。'
- en: '**Intermediate**: Temporary files created when your project''s assets are compiled
    go here. Everything in here is temporary and will be regenerated if you delete
    it.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intermediate**：当编译项目资产时创建的临时文件存放在这里。这里的所有内容都是临时的，如果你删除它，它们将被重新生成。'
- en: '**Saved**: Log files, screenshots, and save games land in this directory.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saved**：日志文件、截图和保存的游戏存档保存在这个目录中。'
- en: 'If you''ve generated a C++ project, you''ll see three additional directories:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你生成了一个C++项目，你会看到另外三个目录：
- en: '**Binaries**: Your project''s built executable and supporting files live here.
    When you build your project in Visual Studio, this is where the resulting executable
    is saved.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binaries**：项目的构建可执行文件和支持文件存放在这里。当你在Visual Studio中构建项目时，生成的可执行文件就保存在这里。'
- en: '**Build**: Files related to building for specific targets, such as Windows
    64 or Android, live here. These include logs are generated as you build, and certain
    supporting resources such as application icons. You''ll rarely touch the contents
    of this directory.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Build**：与特定目标构建相关的文件，如Windows 64或Android，存放在这里。这些包括在构建过程中生成的日志，以及某些支持资源，如应用程序图标。你很少会接触到这个目录的内容。'
- en: '**Source**: Your C++ files and the C# scripts that govern building them live
    here.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Source**：C++文件和管理构建它们的C#脚本存放在这里。'
- en: The Content directory
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容目录
- en: For the most part, when you work with an Unreal project, you'll be working with
    the contents of the `Content` directory and the `Config` directory. Generally,
    you should do all your management of the Content directory from within Unreal
    Editor, since it can otherwise be easy to break references between objects. We'll
    talk about ways to do this shortly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当你使用Unreal项目时，你将使用`Content`目录和`Config`目录中的内容。通常情况下，你应该在Unreal Editor中管理Content目录的所有内容，因为否则很容易破坏对象之间的引用关系。我们将很快讨论如何做到这一点。
- en: The Config directory
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置目录
- en: We should, however, take a moment to look at the `Config` directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该花点时间来看一下`Config`目录。
- en: Inside this directory are the config files containing the settings for your
    project. All of your engine-related project settings, such as choices about rendering
    quality, are written to the `DefaultEngine.ini` file. When you chose your hardware
    and graphic targets in the Create Project dialog, you were actually just choosing
    which default options to write to that file. Similarly, when you change your project
    settings from the editor, those settings are also written to `DefaultEngine.ini`
    (or `DefaultGame.ini` for certain game-related settings.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，包含了包含项目设置的配置文件。所有与引擎相关的项目设置，如渲染质量选择，都写入到`DefaultEngine.ini`文件中。当你在创建项目对话框中选择硬件和图形目标时，实际上只是选择将默认选项写入该文件。同样，当你从编辑器中更改项目设置时，这些设置也会写入`DefaultEngine.ini`（或`DefaultGame.ini`用于某些与游戏相关的设置）。
- en: 'Your `Config` directory will always contain the following two files:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Config`目录将始终包含以下两个文件：
- en: '`DefaultEngine.ini`: This contains your rendering settings, startup map setting,
    physics settings, and other options that govern how the engine runs.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultEngine.ini`：这个文件包含了你的渲染设置、启动地图设置、物理设置和其他控制引擎运行方式的选项。'
- en: '`DefaultGame.ini`: This, for the most part, contains information about your
    game and copyright information, but it also holds information about how your application
    will be packaged when you prepare it for release on different platforms'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultGame.ini`：大部分包含有关游戏和版权信息的内容，但也包含了关于应用程序在不同平台上发布时如何打包的信息'
- en: When you make changes to your project settings from within the editor, you're
    mostly writing changes to these two files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在编辑器中更改项目设置时，您主要是将更改写入这两个文件。
- en: 'Other `Config` files may be created depending on what settings you change as
    you build your project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在构建项目时更改的设置，可能会创建其他`Config`文件：
- en: '`DefaultInput.ini`: This contains input mappings and settings related to using
    input devices.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultInput.ini`：这包含与使用输入设备相关的输入映射和设置。'
- en: '`DefaultEditor.ini`: This contains settings governing how your editor behaves.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultEditor.ini`：这包含了控制编辑器行为的设置。'
- en: '`DefaultDeviceProfiles.ini`: This contains specific settings for the different
    platforms to which you might release your application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultDeviceProfiles.ini`：这包含了您可能发布应用程序的不同平台的特定设置。'
- en: You don't have to know about this to use the engine. It's perfectly fine to
    manage your settings entirely from within the editor, but this is another one
    of the great things about Unreal Engine - it doesn't scatter important information
    in weird places. If at some point you do need to figure out what you've set somewhere,
    you know where to look. It's going to be in one of these files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必了解这些内容就可以使用引擎。完全可以在编辑器内部管理设置，但这也是虚幻引擎的另一个伟大之处之一-它不会将重要信息散布在奇怪的地方。如果您在某个时刻需要弄清楚您在哪里设置了什么，您知道该去哪里找。它将在这些文件中的一个中。
- en: If you're not seeing file extensions such as `.ini` in your Windows explorer,
    open your File Explorer Options control panel, and turn off Hide extensions for
    known file types. It's on by default in Windows, but it will hide useful information
    from you when you're developing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Windows资源管理器中看不到`.ini`等文件扩展名，请打开文件资源管理器选项控制面板，并关闭隐藏已知文件类型的扩展名。在Windows中，默认情况下是打开的，但在开发时会隐藏有用的信息。
- en: The Source directory
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源目录
- en: If you've created a C++ project, your project directory will also contain a
    `Source` sub directory. Your C++ source files live here.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个C++项目，您的项目目录还将包含一个`Source`子目录。您的C++源文件存放在这里。
- en: The Project file
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目文件
- en: 'We should take a quick look at your project''s `.uproject` file as well. It''s
    actually really just a simple text file with a few bits of information about your
    project, but if you right-click it in Explorer, you''re given three useful options:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该快速查看一下项目的`.uproject`文件。实际上，它只是一个包含有关项目的一些信息的简单文本文件，但如果您在资源管理器中右键单击它，您将获得三个有用的选项：
- en: '**Launch Game**: This will just open up your project in Unreal Editor. Double-clicking
    the `.uproject` file will do this too.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动游戏**：这只是在虚幻编辑器中打开您的项目。双击`.uproject`文件也可以做到这一点。'
- en: '**Generate Visual Studio project files**: This only applies if you''ve created
    a C++ project. You''ll generally only need to do this if you''ve cleared the Intermediates
    directory, which holds your VS project files, or if you''ve added new source code
    files from outside the editor.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成Visual Studio项目文件**：仅适用于创建了C++项目的情况。通常情况下，只有在清除了保存VS项目文件的Intermediates目录，或者从编辑器外部添加了新的源代码文件时，才需要执行此操作。'
- en: '**Switch Unreal Engine version**: This changes the engine version associated
    with your project. Generally, it''s safer and more advisable to copy and update
    your project in the launcher when going to a new engine version, but if you already
    know it''s safe to do, you can switch it here.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换虚幻引擎版本**：这会更改与您的项目关联的引擎版本。通常情况下，当您要切换到新的引擎版本时，最安全和最可取的方法是在启动器中复制并更新您的项目，但如果您已经知道可以安全执行此操作，您可以在此处切换。'
- en: A summary of an Unreal project structure
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个虚幻项目结构的概述
- en: Now that we've taken a quick look at the structure of an Unreal project, we
    should keep it in the back of our minds as we work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速了解了虚幻项目的结构，我们应该在工作时将其牢记在心。
- en: 'Again, at its bare minimum, an Unreal project consists of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个虚幻项目的最基本结构包括以下内容：
- en: 'The `Project` directory:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Project`目录：'
- en: The `Project` file
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Project`文件'
- en: The `Content` directory
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`目录'
- en: The `Config` directory
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Config`目录'
- en: (C++ only) The `Source` directory
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限C++）`Source`目录
- en: If you need to share a Blueprint-based Unreal project with someone, you only
    need to share the `.uproject` file, the `Content` directory, and the `Config`
    directory. All the rest are dynamically generated when the project runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要与他人共享基于蓝图的虚幻项目，您只需要共享`.uproject`文件、`Content`目录和`Config`目录。其余的内容都是在项目运行时动态生成的。
- en: Depending on what you do with your project, other directories may be created
    automatically.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对项目的操作，可能会自动创建其他目录。
- en: That's really all we wanted to do here—just have a quick look around and see
    the lay of the land before we start adding a lot of content to our project. It
    can make your life easier later on to know where things are.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里想要做的一切-只是快速查看一下并了解一下我们开始向项目中添加大量内容之前的情况。知道东西在哪里可以在以后让您的生活更轻松。
- en: Setting your project's settings for VR
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目的VR设置
- en: Let's jump back into the editor and continue setting up our project. Before
    we do anything else, we have a few settings we should take a look at.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编辑器中，继续设置我们的项目。在做其他任何事情之前，我们应该查看一下一些设置。
- en: 'All of these settings we''re about to discuss affect the way your scene is
    *rendered*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将讨论的所有这些设置都会影响场景的*渲染*方式：
- en: '![](img/791f2913-9a29-4f8e-8203-371275ccbe1f.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/791f2913-9a29-4f8e-8203-371275ccbe1f.png)'
- en: Rendering is the process of taking the 3D geometry in your scene, looking at
    it through a virtual camera, and turning that geometry into an image that can
    be displayed on your screen or in your headset.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染是将场景中的3D几何图形通过虚拟摄像机观察并将该几何图形转换为可以在屏幕或头戴式显示器上显示的图像的过程。
- en: As we mentioned in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, VR places much heavier demands on the rendering pipeline than
    traditional flat-screen rendering. Even the lowest-resolution headsets on the
    current market display quite a lot of pixels and have to update extremely quickly.
    As if this weren't challenging enough, we also have two eyes to think about, and
    the views they see aren't exactly the same. This means we're rendering two separate
    views. That's quite a lot to do and not a lot of time in which to do it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中提到的，*在VR中思考*，与传统的平面屏幕渲染相比，VR对渲染管线提出了更高的要求。即使是当前市场上分辨率最低的头戴设备也显示了相当多的像素，并且需要非常快速地更新。如果这还不够具有挑战性，我们还需要考虑到两只眼睛，它们看到的视图并不完全相同。这意味着我们要渲染两个独立的视图。这是一项相当繁重的任务，而时间却不多。
- en: Because of this, it's important for a VR developer to understand a bit about
    the rendering options Unreal makes available. Good choices here can get you a
    long way toward your goal of having something that both looks great and runs fast.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于VR开发人员来说，了解Unreal提供的渲染选项是很重要的。在这里做出良好的选择可以让您在实现既好看又快速的目标方面走得更远。
- en: Instanced Stereo
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Instanced Stereo
- en: Remember when we mentioned a moment ago that we needed to render two separate
    views simultaneously in VR? Back in the bad old days (before Unreal 4.11), this
    was literally true. The engine simply ran the entire rendering process twice –
    once for each eye. This was hugely wasteful, since the only real difference between
    the two views was a small shift in the location of the eye looking at it. The
    full cost of a second render pass was being spent to draw something almost identical
    to what had just been drawn.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们刚才提到过需要同时渲染两个独立视图吗？在不好的旧日子里（在Unreal 4.11之前），这是真的。引擎只是简单地运行整个渲染过程两次 - 每次为一个眼睛。这是非常浪费的，因为两个视图之间唯一的真正区别是眼睛位置的微小偏移。第二次渲染的全部成本都被用来绘制几乎与刚刚绘制的相同的东西。
- en: '**Instanced Stereo** rendering improves on this by allowing the scene to be
    rendered in a single pass. The rendered view is then given to the video hardware
    along with the information it needs to adjust the view for each eye. It''s dramatically
    faster than running the entire pass twice, and you want to make sure you turn
    it on. Let''s do this now.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Instanced Stereo**渲染通过允许在单个传递中渲染场景来改进这一点。然后，渲染的视图与视频硬件一起传递，以及每个眼睛调整视图所需的信息。它比运行整个传递两次要快得多，您需要确保打开它。现在让我们来做这个。'
- en: If you create a project using the VR template, Instanced Stereo will already
    be turned on for you, but if you're creating a project from scratch, or taking
    an existing project and modifying it to work in VR, you need to remember to do
    this yourself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用VR模板创建项目，Instanced Stereo将已经为您打开，但如果您从头开始创建项目，或者修改现有项目以适应VR，您需要记住自己执行此操作。
- en: 'From the editor, open your Project Settings either by hitting the Settings
    button on the editor toolbar and selecting Project Settings..., or by selecting
    Edit | Project Settings:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从编辑器中打开项目设置，可以通过点击编辑器工具栏上的设置按钮并选择项目设置...，或者选择编辑 | 项目设置来打开：
- en: '![](img/1a0b1bc3-be0e-43c8-9319-f31ab6767c03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a0b1bc3-be0e-43c8-9319-f31ab6767c03.png)'
- en: 'In Project Settings, find the Rendering item in the Engine section. In the
    Rendering page, find the Instanced Stereo option in the VR section and turn it
    on:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置中，找到引擎部分的渲染项。在渲染页面中，找到VR部分的Instanced Stereo选项并打开它：
- en: '![](img/30fdccdc-6501-45a2-917a-0040bbb33c75.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30fdccdc-6501-45a2-917a-0040bbb33c75.png)'
- en: You'll be asked to restart the engine after you do this. This is going to take
    a little while because your shaders are going to need to recompile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作后，将要求您重新启动引擎。这将需要一些时间，因为您的着色器将需要重新编译。
- en: Round Robin Occlusions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询遮挡
- en: 'Because we don''t have a lot of time available to get our frame on to the headset,
    we don''t want to waste any of it drawing anything we don''t need to draw. The
    engine chooses which objects to draw through a process called **culling**. It
    uses four main methods to do this, in order, from the fastest and simplest to
    the most complex:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有太多时间将帧传输到头戴设备上，所以我们不想浪费任何时间来绘制我们不需要绘制的东西。引擎通过一个称为**剔除**的过程选择要绘制的对象。它使用四种主要方法来进行剔除，按顺序从最快和最简单到最复杂：
- en: '**Distance** **culling** simply ignores any object beyond a certain distance
    from the camera. This is inexpensive.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离剔除**只是忽略相机距离一定距离之外的任何对象。这是廉价的。'
- en: '**View frustum** **culling** ignores objects that aren''t in the camera''s
    current view. This is more expensive than distance culling but still pretty cheap.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视锥剔除**会忽略不在相机当前视图中的对象。这比距离剔除更昂贵，但仍然相对便宜。'
- en: '**Precomputed visibility** allows designers to set up volumes to tell the engine
    explicitly what can be seen from certain locations and what can''t. For instance,
    if you know that a player inside a room can''t possibly see anything outside,
    you can use precomputed visibility volumes to tell the engine that it doesn''t
    even need to bother checking.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预计算可见性**允许设计师设置体积，明确告诉引擎从某些位置可以看到什么，不能看到什么。例如，如果您知道房间内的玩家不可能看到外面的任何东西，您可以使用预计算可见性体积告诉引擎甚至不需要检查。'
- en: '**Dynamic Occlusion** tests in real-time to see whether an actor in the scene
    is blocking another actor. This is relatively expensive, so it''s done only with
    those objects that haven''t been culled by the cheaper methods.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态遮挡**实时测试场景中的一个角色是否遮挡了另一个角色。这相对昂贵，因此只对那些没有被更便宜的方法剔除的对象进行测试。'
- en: For VR projects, Unreal offers an optimized dynamic occlusion culling method
    called **Round Robin Occlusion**, which only tests occlusion for one eye per frame,
    rather than both. This saves a considerable amount of time, especially in scenes
    with a lot of objects, and works well since the views from each eye are nearly
    identical. The system switches which eye it tests on each frame, which is where
    the name comes from.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VR项目，虚幻引擎提供了一种名为**Round Robin Occlusion**的优化动态遮挡剔除方法，每帧只测试一个眼睛的遮挡，而不是两个眼睛。这在有很多对象的场景中节省了大量时间，并且由于每只眼睛的视图几乎相同，所以效果很好。系统在每帧切换测试的眼睛，这就是名称的由来。
- en: 'Let''s turn it on:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开它：
- en: 'In Project Settings | Engine | Rendering | VR, check Round Robin Occlusion
    Queries:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置 | 引擎 | 渲染 | VR中，勾选Round Robin Occlusion Queries：
- en: '![](img/aa9d6904-8586-4825-9704-8c851f1d736e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa9d6904-8586-4825-9704-8c851f1d736e.png)'
- en: Forward and deferred shading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向渲染和延迟渲染
- en: We now need to make an important choice about the rendering method we want to
    use for our project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要对我们项目中要使用的渲染方法做出重要选择。
- en: Broadly, there are two ways of drawing a scene, and the difference between them
    mostly boils down to how the objects in the scene are lit. These two methods are
    called **forward** **shading** and **deferred shading**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上讲，绘制场景有两种方式，它们之间的区别主要取决于场景中的物体如何受光照。这两种方法被称为**前向渲染**和**延迟渲染**。
- en: You'll sometimes see these as **forward rendering** and **deferred rendering**,
    or you'll hear people talk about a **forward renderer** or a **deferred renderer**.
    Epic uses the terms interchangeably in its documentation, but they all refer to
    the same things. For our purposes here, we'll stick with the term **forward shading**,
    since that's what the option is called in the editor and it most accurately describes
    what's really different between the two approaches.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会看到这些称为**前向渲染**和**延迟渲染**，或者你会听到人们谈论**前向渲染器**或**延迟渲染器**。Epic在其文档中可互换使用这些术语，但它们都指的是同样的东西。在这里，我们将坚持使用术语**前向渲染**，因为这是编辑器中的选项名称，并且最准确地描述了这两种方法之间的真正区别。
- en: '**Shading** is the process of applying light to geometry. This includes highlights,
    surface reflections, shadows, and all the various things light does when it hits
    a material:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色**是将光应用于几何体的过程。这包括高光、表面反射、阴影和光线击中材质时产生的各种效果：'
- en: '![](img/71263ea8-b98f-4419-b3f2-49c605cb6c39.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71263ea8-b98f-4419-b3f2-49c605cb6c39.png)'
- en: The preceding screenshot shows the same mesh without shading applied, and then
    with shading applied. In the left-hand image, you can see the shape of the object
    and its base color (also commonly called **albedo**), but no shadows, reflections,
    or highlights. The right image has been shaded, so highlights, shadows, and reflections
    are visible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了相同的网格，没有应用着色，然后应用了着色。在左侧的图像中，你可以看到物体的形状和基本颜色（通常称为**反射率**），但没有阴影、反射或高光。右侧的图像已经着色，所以可以看到高光、阴影和反射。
- en: We're simplifying things a bit in the descriptions that follow, but, for our
    purposes, this is fine. You really don't need to know every detail of how a rendering
    pipeline works to make good decisions about how to use it. It's just important
    to understand enough to make the right choice for what you need to do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的描述中，我们稍微简化了一些事情，但对于我们的目的来说，这是可以的。你真的不需要了解渲染管线的每个细节，以便做出关于如何使用它的正确选择。只需要了解足够的信息，以便为你需要做的事情做出正确的选择即可。
- en: '**Forward shading **was the original way of drawing 3D scenes through most
    of the history of real-time 3D rendering. In forward shading, each geometric object
    in the scene is shaded as it''s rendered, and each light in the scene is checked
    to see how it might affect it. If you have a lot of objects in your scene and
    a lot of lights, this can turn into a lot of operations. This is why most lighting
    tended to be baked into static lightmaps, and dynamic lights tended to be so rare
    in games in the 1990s and early 2000s. Each dynamic light dramatically added to
    the cost of the scene.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向渲染**是实时3D渲染历史上绘制3D场景的最初方式。在前向渲染中，场景中的每个几何对象在渲染时进行着色，并检查场景中的每个光源对其的影响。如果场景中有很多对象和很多光源，这将导致大量的操作。这就是为什么大多数光照倾向于嵌入到静态光照贴图中，而动态光照在20世纪90年代和21世纪初的游戏中很少见的原因。每个动态光源都会大大增加场景的成本。'
- en: '**Deferred shading**, on the other hand, draws every object in the view, but
    instead of lighting and shading it right then, it writes out a series of images
    that contain information about the materials in the scene, the depth of each pixel,
    and other factors that would affect how the scene is lit. Shading is then performed
    only once, after all this information has been assembled. This is where the name
    comes from—the shading pass has been deferred until after the base pass is complete.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**延迟渲染**绘制视图中的每个对象，但不是立即进行光照和着色，而是写出一系列包含场景中材质信息、每个像素的深度以及其他影响场景光照的因素的图像。只有在所有这些信息被组装完毕后，才进行着色。这就是名称的由来——着色通道被推迟到基础通道完成之后。
- en: This collection of buffers is called the **geometric buffer**, or **G-buffer**,
    and the process of building them is called the **base pass**. If you're using
    deferred shading in Unreal Engine (which is the default setting for a new project),
    you can see the contents of the G-buffer by selecting View Mode | Buffer Visualization
    | Overview.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓冲区的集合被称为**几何缓冲区**，或者**G缓冲区**，构建它们的过程被称为**基础通道**。如果你在虚幻引擎中使用延迟渲染（这是新项目的默认设置），你可以通过选择视图模式
    | 缓冲区可视化 | 概览来查看G缓冲区的内容。
- en: 'Take a look at the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的截图：
- en: '![](img/5bb61418-d4cf-40de-b9e5-7eab637a3df9.png)![](img/cb218924-b241-4bb7-ab11-ecbf42a47927.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bb61418-d4cf-40de-b9e5-7eab637a3df9.png)![](img/cb218924-b241-4bb7-ab11-ecbf42a47927.png)'
- en: Since the lighting pass happens only once, this is much faster for scenes with
    a lot of dynamic lights, and also allows screen-space effects such as ambient
    occlusion to be handled efficiently. It doesn't, however, do as good a job as
    forward shading with objects that are partially transparent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于光照通道只发生一次，所以对于有很多动态光的场景来说，这比使用延迟渲染要快得多，而且还可以高效地处理屏幕空间效果，如环境遮蔽。然而，对于部分透明的物体来说，它的效果不如前向渲染好。
- en: Choosing the right rendering method for your project
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适合你项目的渲染方法
- en: So, sounds like a no-brainer then, right? Deferred shading seems to offer a
    lot of advantages. For rendering outside of VR, this is mostly true, and by the
    late 2000s, deferred shading became the default for pretty much every game engine
    including Unreal.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，听起来很简单，对吧？延迟渲染似乎提供了很多优势。对于非VR渲染来说，这基本上是正确的，在2000年代后期，延迟渲染成为了包括虚幻引擎在内的几乎所有游戏引擎的默认选择。
- en: VR, however, is a different story. The problem with deferred shading is that
    because of the way it handles information, it's difficult to turn off individual
    aspects of the rendering process. For the most part, it's an all-or-nothing deal.
    This wasn't generally a problem on flat screens—developers were pretty much always
    going to want everything the deferred shader had to offer. Some of these processes,
    though, are just too expensive to run efficiently in VR, or they're calculated
    in screen-space and look bad when they don't match up between the two eyes. In
    VR, you're often going to want the freedom to turn them off.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在VR中情况就不同了。延迟渲染的问题在于，由于它处理信息的方式，很难关闭渲染过程的各个方面。在很大程度上，它是全有或全无的。这在平面屏幕上通常不是问题——开发者几乎总是希望使用延迟渲染器所提供的一切。然而，其中一些过程在VR中运行效率太低，或者在屏幕空间计算时看起来不匹配。在VR中，你通常会希望有自由关闭它们的能力。
- en: When you hear the term *screen-space* what this means is that instead of doing
    the calculations on the object in 3D space, the part of the scene containing the
    object is rendered to 2D (this process is called **rasterization**), and then
    the calculations are performed on the 2D image. This can create a problem in VR,
    because many screen-space calculations won't match between the eyes. You'll usually
    want to avoid using screen-space effects in VR.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到术语“屏幕空间”时，这意味着计算不是在3D空间中的对象上进行，而是在包含该对象的场景的2D图像上进行（这个过程称为**光栅化**），然后在2D图像上执行计算。这在VR中可能会产生问题，因为许多屏幕空间计算在两只眼睛之间不匹配。你通常会希望避免在VR中使用屏幕空间效果。
- en: In Unreal 4.14, Epic added forward shading as an option specifically designed
    for VR projects. They also introduced a clustering system that reduced the cost
    of processing lights in the base pass, so it's not nearly as costly as it used
    to be. For most VR projects, it's a good idea to use forward shading.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻4.14中，Epic添加了前向渲染作为专门为VR项目设计的选项。他们还引入了一种聚类系统，降低了基本通道中处理灯光的成本，所以它的成本不再像以前那样高昂。对于大多数VR项目来说，使用前向渲染是个好主意。
- en: There are cases where you may still want to stick with deferred rendering in
    VR—if your scene needs to support a lot of movable lights, or if you know you'll
    need very complicated reflections—but you should seriously consider using forward
    shading for most VR projects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果你的场景需要支持大量可移动的灯光，或者你知道你将需要非常复杂的反射，你可能仍然希望坚持使用延迟渲染，但你应该认真考虑在大多数VR项目中使用前向渲染。
- en: You'll almost always want to use forward shading for VR projects. It gives you
    much greater control over which parts of the rendering process you want to do,
    and which ones you want to skip; it handles transparency more easily, and supports
    better anti-aliasing options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是希望在VR项目中使用前向渲染。它可以让你更好地控制渲染过程中你想要做的部分和你想要跳过的部分；它更容易处理透明度，并支持更好的抗锯齿选项。
- en: Let's turn it on for our project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中打开它。
- en: 'From your Project Settings | Engine | Rendering, find the Forward Renderer
    section, and turn on Forward Shading. You''ll have to restart the editor after
    you do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目设置 | 引擎 | 渲染中，找到前向渲染器部分，打开前向渲染。你需要在这样做后重新启动编辑器：
- en: '![](img/bf3e21b6-01ec-4efe-b1ab-3bdf1c6bc093.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf3e21b6-01ec-4efe-b1ab-3bdf1c6bc093.png)'
- en: When using forward shading, many expensive material features that would normally
    be included by default need to be turned on explicitly. This is a good thing in
    VR, as it gives you the freedom to use expensive features only where they'll be
    seen. We'll talk later on about doing this when we start creating and modifying
    materials for VR.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用前向渲染时，许多昂贵的材质特性通常需要显式地打开。在VR中，这是一件好事，因为它让你可以自由地在只有在需要时使用昂贵的特性。我们稍后会讨论在为VR创建和修改材质时如何做到这一点。
- en: While you can turn forward shading on or off later in your project's development,
    you'll generally want to make a choice and stick with it, as your project's lighting,
    materials, and reflections can differ greatly between the two methods. You don't
    want to put a lot of effort into developing your look, and then make a change
    like this late in development. You'll wind up redoing a lot of work.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在项目开发的后期可以随时打开或关闭前向渲染，但你通常会希望做出一个选择并坚持下去，因为两种方法在项目的光照、材质和反射方面可能会有很大的差异。你不希望在开发的后期花费大量精力来开发你的外观，然后做出这样的改变。你最终会不得不重新做很多工作。
- en: Choosing your anti-aliasing method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的抗锯齿方法
- en: One major advantage of using forward shading is that **anti-aliasing** is much
    easier to achieve than it is when using deferred shading. Let's talk about what
    this means and why it matters to us in VR.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前向渲染的一个主要优势是**抗锯齿**比使用延迟渲染要容易得多。让我们谈谈这意味着什么，以及为什么这对我们在VR中很重要。
- en: 'When the renderer draws a scene onto a flat screen, whether it''s a monitor
    or a VR headset, that display actually consists of a grid of tiny squares, called
    **pixels** (short for **picture elements**), and the renderer has to decide what
    color each of them is going to be. This turns into a problem when an object in
    the 3D scene only partly fills a pixel in the 2D space to which it''s going to
    be drawn. The renderer then has to decide whether the pixel should be filled with
    the color of the object or the color of the background. There''s no in-between—it
    has to pick one or the other. What this means in practice is that objects can
    wind up appearing to have jagged edges, especially along diagonal lines that cross
    over a lot of pixel borders. We call this problem **aliasing**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染器将场景绘制到平面屏幕上（无论是显示器还是VR头显）时，该显示实际上由一组称为**像素**（照片元素）的小方块组成，渲染器必须决定每个像素的颜色。当3D场景中的对象只部分填充2D空间中的像素时，这就成为一个问题。然后，渲染器必须决定像素应该填充对象的颜色还是背景的颜色。没有中间状态-它必须选择其中之一。实际上，这意味着对象可能会出现锯齿状边缘，特别是沿着跨越许多像素边界的对角线。我们称之为**走样**问题：
- en: '![](img/0f71119d-7182-49fb-8f52-d19b572cdc83.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f71119d-7182-49fb-8f52-d19b572cdc83.png)'
- en: A scene rendered with no anti-aliasing
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 没有抗锯齿渲染的场景
- en: Note the **jaggies** all around the windows in the scene rendered without anti-aliasing.
    These look bad here and will look worse in VR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有抗锯齿渲染的场景中窗户周围的**锯齿**。它们在这里看起来很糟糕，在VR中看起来会更糟糕。
- en: 'The way we solve this is through a process unsurprisingly called **anti-aliasing**.
    Different anti-aliasing methods use a variety of techniques to figure out how
    to soften jagged edges by finding the right color for a pixel to appear to blend
    between the foreground and background colors. This has the effect of smoothing
    jagged edges and removing stair-steps from diagonal lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个不出所料被称为**抗锯齿**的过程来解决这个问题。不同的抗锯齿方法使用各种技术来找到像素的正确颜色，以使其在前景色和背景色之间呈现混合效果，从而软化锯齿边缘。这样可以平滑锯齿边缘并消除对角线上的阶梯状线条：
- en: '![](img/24a6989b-bc5b-4898-a6de-8bc3e9eedcd2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24a6989b-bc5b-4898-a6de-8bc3e9eedcd2.png)'
- en: A scene rendered using multisampling anti-aliasing (MSAA)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重采样抗锯齿（MSAA）渲染的场景
- en: See how much smoother the windows look when this scene is rendered using multisampling
    anti-aliasing?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看使用多重采样抗锯齿渲染时窗户看起来更加平滑的效果？
- en: This is especially important in VR since headset resolutions are still fairly
    limited, so users can generally see the individual pixels. Aliasing that would
    be acceptable on a flat screen may look awful in VR as the user looks around the
    scene and jagged edges crawl and shimmer all over the place. You want to avoid
    this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这在VR中尤为重要，因为头显的分辨率仍然相对有限，所以用户通常可以看到单个像素。在平面屏幕上可以接受的走样在VR中可能看起来很糟糕，因为用户在场景中观察时，锯齿状边缘会爬行和闪烁。您应该避免这种情况。
- en: 'Fortunately, Unreal Engine gives you three **anti-aliasing methods** to address
    this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虚幻引擎提供了三种**抗锯齿方法**来解决这个问题：
- en: '**FXAA** stands for **Fast Approximate Anti-Aliasing**. It looks for edges
    in the scene and blends the colors at those edges, and it is smart enough to avoid
    processing areas that don''t have contrasting edges, so it looks great and runs
    pretty quickly. This should be your default choice if you''re using deferred shading
    in VR.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FXAA**代表**快速近似抗锯齿**。它寻找场景中的边缘并混合这些边缘的颜色，并且足够智能以避免处理没有对比较边缘的区域，因此看起来很棒并且运行速度相对较快。如果您在VR中使用延迟渲染，这应该是您的默认选择。'
- en: '**Temporal AA** (**TAA**) works by looking at the previous few frames to make
    decisions about how to anti-alias the current frame. This generally makes it a
    poor choice for VR as the user''s view tends to move quite a lot, and temporal
    AA can create "smearing" effects on fast movements. Even where smearing isn''t
    apparent, it can appear too blurry to be acceptable on a VR headset. Temporal
    AA tends to do a fantastic job on flat screens, but it isn''t a great choice for
    VR.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时域抗锯齿**（**TAA**）通过查看前几帧来决定如何对当前帧进行抗锯齿处理。这通常使其在VR中成为一个糟糕的选择，因为用户的视图往往会移动很多，时域抗锯齿可能会在快速移动时产生“模糊”效果。即使在没有模糊的情况下，它在VR头显上可能看起来太模糊而无法接受。时域抗锯齿通常在平面屏幕上表现出色，但对于VR来说并不是一个很好的选择。'
- en: '**MSAA** stands for **Multisampling Anti-Aliasing**. This method is only available
    when using forward shading, and will give you sharper, better results than FXAA.
    If you''re using forward shading in your project, and you almost always should
    be, this is the anti-aliasing method you should use.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSAA**代表**多重采样抗锯齿**。此方法仅在使用正向渲染时可用，并且会比FXAA提供更清晰、更好的结果。如果您在项目中使用正向渲染（通常应该使用），这是您应该使用的抗锯齿方法。'
- en: 'Let''s take care of this in our project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中处理这个问题：
- en: 'From your Project Settings | Engine | Rendering, find the Default Settings
    section, and set the Anti-Aliasing Method to MSAA:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目设置 | 引擎 | 渲染中，找到默认设置部分，并将抗锯齿方法设置为MSAA：
- en: '![](img/13b2165c-a4b6-4d12-989c-db835950042c.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b2165c-a4b6-4d12-989c-db835950042c.png)'
- en: Most of the time, you won't need to change anything about how your anti-aliasing
    method works, but if you do, read on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您不需要改变抗锯齿方法的任何设置，但如果需要，继续阅读。
- en: Modifying MSAA settings
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改MSAA设置
- en: 'This bit is optional. Making adjustments to your anti-aliasing settings is
    an advanced topic, and for most projects you don''t need to do this. If you do
    wind up needing to adjust your MSAA settings, here''s a good way to do it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是可选的。调整抗锯齿设置是一个高级主题，对于大多数项目来说，您不需要这样做。如果您确实需要调整MSAA设置，以下是一个很好的方法：
- en: 'Select Window | Developer Tools | Device Profiles to open the Device Profiles
    window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 选择窗口 | 开发者工具 | 设备配置文件以打开设备配置文件窗口：
- en: '![](img/cd0a435f-0528-4662-8151-5415bf79b47f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd0a435f-0528-4662-8151-5415bf79b47f.png)'
- en: From this panel, hit the CVars button in the Windows row.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从此面板中，点击Windows行中的CVars按钮。
- en: 'From within the resulting dialog, open Console Variables | Rendering. From
    here, you can see all the rendering-related console variables you''re currently
    specifying. If you hit the + sign beside Rendering, you can type `msaa` in the
    search window that appears, and add a value for r.MSAACount. By default, this
    value is set to 4\. Reducing it to 3 or 2 will lower the quality of your anti-aliasing
    but speed it up a bit. Setting it to 1 turns it off. Setting it to 0 turns it
    off and falls back to temporal anti-aliasing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的对话框中，打开控制台变量|渲染。从这里，您可以看到您当前指定的所有与渲染相关的控制台变量。如果您点击Rendering旁边的+号，您可以在出现的搜索窗口中键入`msaa`，并为r.MSAACount添加一个值。默认情况下，此值设置为4。将其减少到3或2将降低抗锯齿的质量，但会加快速度。将其设置为1将关闭抗锯齿。将其设置为0将关闭抗锯齿并回退到时间抗锯齿：
- en: '![](img/1e1cb2ef-f796-47d9-adba-088f353a2fbe.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e1cb2ef-f796-47d9-adba-088f353a2fbe.png)'
- en: If you've made changes here, hit Save as Default on your Device Profiles window
    to save these settings. They'll be written to a new config file in your project's
    `Configs` directory called `DefaultDeviceProfiles.ini`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这里进行了更改，请在设备配置窗口上点击“保存为默认值”以保存这些设置。它们将被写入项目的`Configs`目录中的一个名为`DefaultDeviceProfiles.ini`的新配置文件中。
- en: Again, changing these values is an advanced topic. We don't advise that you
    modify these until you're comfortable that you understand what they do.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次更改这些值是一个高级主题。我们建议您在确保理解其功能之前不要修改这些值。
- en: Starting in VR
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR中开始
- en: It's also important to tell our project to start in VR when we run it. You do
    have the option, if you want to build a project that could be run both in VR and
    on a flat screen, to leave this turned off and use the `-vr` command line argument
    when you launch it. Our project is a VR-only project, though, so we want to turn
    this on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们的项目在运行时启动VR也很重要。如果您想构建一个既可以在VR中运行又可以在平面屏幕上运行的项目，您可以选择关闭此选项，并在启动时使用`-vr`命令行参数。但是，我们的项目只能在VR中运行，所以我们想打开它。
- en: Head to Project Settings | Project | Description | Settings, and set Start in VR
    to True**.**
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 转到项目设置|项目|描述|设置，并将“在VR中启动”设置为True**。**
- en: Turning off other stray settings you don't need
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭其他不需要的杂项设置
- en: In your Rendering | Default Settings, turn off Ambient Occlusion Static Fraction.
    Ambient occlusion is a method for creating those subtle shadows that appear where
    objects touch each other, but they're expensive to calculate and can look awful
    in VR because they're calculated in screen-space. We're not going to go into depth
    on this topic here. You already turned off ambient occlusion when you set your
    project to mobile, scalable 2D/3D, so this is just a stray setting you should
    clear.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的渲染|默认设置中，关闭环境遮挡静态分数。环境遮挡是一种用于创建物体接触处出现的微妙阴影的方法，但是计算它们的成本很高，并且在VR中可能看起来很糟糕，因为它们是在屏幕空间中计算的。我们不会在这里深入讨论这个主题。当您将项目设置为移动、可扩展的2D/3D时，您已经关闭了环境遮挡，所以这只是一个您应该清除的杂项设置。
- en: Turning off default touch interface (Oculus Go/Samsung Gear)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭默认触摸界面（Oculus Go/Samsung Gear）
- en: If you're developing for Oculus Go or Samsung gear, you need to turn off the
    default touch interface. Mobile apps ordinarily assume that you'll operate them
    by touching the screen, but of course this isn't going to happen inside your headset.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发Oculus Go或Samsung Gear的应用程序，您需要关闭默认的触摸界面。移动应用程序通常假设您将通过触摸屏幕来操作它们，但是在头戴式显示器中当然不会发生这种情况。
- en: 'Navigate to Project Settings | Engine | Input, and from within the Mobile section,
    grab the drop-down beside Default Touch Interface and clear it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到项目设置|引擎|输入，并从移动部分中获取Default Touch Interface旁边的下拉菜单并清除它：
- en: '![](img/065232e8-8ad9-4ea0-8644-fd59ef932768.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/065232e8-8ad9-4ea0-8644-fd59ef932768.png)'
- en: Configuring your project for Android (Oculus Go/Samsung Gear)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Android配置您的项目（Oculus Go/Samsung Gear）
- en: We now need to configure the project to use the Android SDK. We went through
    this process in the last chapter—we just need to set the same settings for this
    project. Here's a quick reminder of what we need to do.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置项目使用Android SDK。我们在上一章中已经完成了这个过程，我们只需要为这个项目设置相同的设置。这里是我们需要做的事情的快速提醒。
- en: 'From Project Settings | Platforms | Android, find the APK Packaging section,
    and hit Configure Now. If you already accepted the SDK license in the previous
    chapter, that button will be disabled – you only have to accept it once:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目设置|平台|Android中，找到APK打包部分，然后点击“立即配置”。如果您在上一章中已经接受了SDK许可证，那么该按钮将被禁用-您只需要接受一次：
- en: '![](img/c6bec65a-a0ca-428c-a121-9df26a39efb0.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6bec65a-a0ca-428c-a121-9df26a39efb0.png)'
- en: 'Then set these settings (as we mentioned in the previous chapter, most guides
    will tell you to use SDK Version 19 as your minimum. This is OK for Samsung Gear,
    but use version 21 for Go):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置这些设置（正如我们在上一章中提到的，大多数指南会告诉您将SDK版本19作为最低版本。这对于Samsung Gear来说是可以的，但对于Go，请使用版本21）
- en: 'Minumum SDK Version: 21'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低SDK版本：21
- en: 'Target SDK Version: 21'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标SDK版本：21
- en: 'Enable FullScreen Immersive on KitKat and above devices: True'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在KitKat及以上设备上启用全屏沉浸式：True
- en: 'Scroll down to the Advanced APKPackaging section and set this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动到高级APK打包部分，并设置如下：
- en: Configure the AndroidManifest for deployment to Oculus Mobile to True.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AndroidManifest配置为部署到Oculus Mobile的True。
- en: Verifying your SDK locations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的SDK位置
- en: Select Project Settings | Platforms | Android SDK, and make sure your SDK locations
    are properly set. If you ran through the instructions in the previous chapter,
    they should be. If not, jump back there and set them up now.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项目设置|平台|Android SDK，并确保正确设置SDK位置。如果您按照上一章的说明进行操作，它们应该已经设置好了。如果没有，请返回那里并进行设置。
- en: Making sure Mobile HDR is turned off (Oculus Go/Samsung Gear)
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保关闭移动HDR（Oculus Go/Samsung Gear）
- en: Check your Project Settings | Engine | Rendering | Mobile, and ensure that Mobile
    HDR is turned off.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的项目设置|引擎|渲染|移动，并确保关闭移动HDR。
- en: Mobile Multi-View (Oculus Go/Samsung Gear)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动多视图（Oculus Go/Samsung Gear）
- en: Remember back in the section on Instanced Stereo rendering when we discussed
    how wasteful it is to render the entire scene for each eye? The mobile headsets
    have a solution for this too, called **Mobile Multi-View**. Mobile Multi-View
    works pretty much the same way Instanced Stereo rendering does – by rendering
    the scene once for the left eye, and then shifting and adjusting the image for
    the right eye. We want to turn this on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在关于实例化立体渲染的部分中，我们讨论了为每只眼睛渲染整个场景是多么浪费吗？移动头戴设备也有一个解决方案，称为**移动多视图**。移动多视图的工作原理与实例化立体渲染基本相同-先为左眼渲染场景，然后将图像移动和调整为右眼。我们想要打开它。
- en: 'In Project Settings | Engine | Rendering | VR, set Mobile Multi-View to true,
    and turn on Mobile Multi-View Direct as well. Oculus doesn''t recommend or support
    using Mobile Multi-View without the Direct option. Turn them both on:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置 | 引擎 | 渲染 | VR中，将移动多视图设置为true，并同时打开移动多视图直接选项。Oculus不建议或支持在没有直接选项的情况下使用移动多视图。将它们都打开：
- en: '![](img/8f91aa20-f013-4f16-8334-4fe64eae3e67.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8f91aa20-f013-4f16-8334-4fe64eae3e67.png)
- en: Monoscopic Far Field Rendering (Oculus Go / Samsung Gear)
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单眼远场渲染（Oculus Go / Samsung Gear）
- en: Here's the thing about stereo depth perception – we can only see it up to a
    certain distance. Beyond that distance, there's no visible difference between
    a stereo image and a flat image. They look the same to us. We may as well use
    that to our advantage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于立体深度感知的问题是，我们只能在一定距离内看到它。超过这个距离，立体图像和平面图像之间没有可见的区别。它们对我们来说看起来是一样的。我们可以利用这一点。
- en: 'If we set Project Settings | Engine | Rendering | VR | Monoscopic Far Field
    to true, the engine will render any object beyond a specified distance only once,
    which can save significant time on the right sorts of scenes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将项目设置 | 引擎 | 渲染 | VR | 单眼远场设置为true，引擎将只渲染指定距离之外的任何物体一次，这可以在适当的场景中节省大量时间：
- en: '![](img/119a0269-3307-4722-ae95-ec1f7ea4e89e.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/119a0269-3307-4722-ae95-ec1f7ea4e89e.png)
- en: By default, the split between mono and stereo rendering happens at 7.5 meters,
    but this is set individually on each map. (The location of this split is called
    the **culling plane**.) This culling plane's distance from the camera is set individually
    for each map. To adjust it, open Window | World Settings, and look for the VR
    section on the settings panel that appears. Adjusting the Mono Culling Distance
    will shift the location of the culling plane.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，单眼和立体渲染之间的分割发生在7.5米处，但这在每个地图上都是单独设置的。（这个分割的位置称为**裁剪平面**。）这个裁剪平面与摄像机的距离在每个地图上都是单独设置的。要进行调整，请打开窗口
    | 世界设置，并在出现的设置面板上查找VR部分。调整单眼裁剪距离将改变裁剪平面的位置。
- en: For certain objects in your scene, especially large objects, you may need to
    force them to render in mono, if their bounds extend close to the camera even
    though they only ever actually appear far away. In these instances, open the object's
    details and set Rendering | Render in Mono to true. (This option is hidden in
    the Rendering section's advanced options.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于场景中的某些对象，特别是大型对象，如果它们的边界靠近摄像机，即使它们实际上只出现在远处，您可能需要强制它们以单眼模式渲染。在这些情况下，打开对象的详细信息，并将渲染
    | 渲染为单眼设置为true。（此选项在渲染部分的高级选项中隐藏。）
- en: Project Settings cheat-sheet
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置备忘单
- en: 'We just ran through a number of settings you should modify when setting up
    your project for VR along with a bit of background for each of them. Just to recap,
    here''s a cheat-sheet of what we changed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了一些在为VR设置项目时应该修改的设置，以及每个设置的一些背景知识。为了回顾一下，这是我们所更改的备忘单：
- en: 'Project Settings | Engine | Rendering | VR | Instanced Stereo: True'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 实例化立体：True
- en: 'Project Settings | Engine | Rendering | VR | Round Robin Occlusion Queries:
    True'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 轮询遮挡查询：True
- en: 'Project Settings | Engine | Rendering | Forward Renderer | Forward Shading:
    True'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 正向渲染器 | 正向着色：True
- en: Project Settings | Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: 'Project Settings | Engine | Rendering | Default Settings | Ambient Occlusion
    Static Fraction: False'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 默认设置 | 环境遮蔽静态分数：False
- en: 'Project Settings | Project | Description | Settings | Start in VR: True'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 项目 | 描述 | 设置 | 启动VR：True
- en: 'This is the mobile VR version:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是移动VR版本：
- en: 'Project Settings | Engine | Input | Mobile | Default Touch Interface: None'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 输入 | 移动 | 默认触摸界面：无
- en: Project Settings | Platforms | Android | APK Packaging: Configure and set the
    settings mentioned
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 平台 | Android | APK打包：配置和设置所提到的设置
- en: 'Project Settings | Platforms | Android SDK: Verify that your SDK locations
    are set.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 平台 | Android SDK：验证您的SDK位置是否设置正确。
- en: Project Settings | Engine | Rendering | Mobile | Mobile HDR: False
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 移动 | 移动HDR：False
- en: 'Project Settings | Engine | Rendering | VR | Mobile Multi-View: True'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 移动多视图：True
- en: Project Settings | Engine | Rendering | VR | Mobile Multi-View Direct: True
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 移动多视图直接：True
- en: Project Settings | Engine | Rendering | VR | Monoscopic Far Field: True
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 单眼远场：True
- en: Again, don't just follow these blindly. For most VR projects, these are the
    settings you're going to want, but that doesn't mean they'll apply to every project
    you ever do.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要盲目地遵循这些设置。对于大多数VR项目，这些是您想要的设置，但这并不意味着它们适用于您所做的每个项目。
- en: Decorating our project
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰我们的项目
- en: Now that we've set up our project's basic settings, let's add some environment
    art so we have something interesting to look at while we work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目的基本设置，让我们添加一些环境艺术，这样我们在工作时就有一些有趣的东西可以看。
- en: Migrating content into a project
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内容迁移到项目中
- en: 'From your **Epic Games Launcher**, open the Learn tab, and search for the `Sun
    Temple` example environment. Hit the Create Project button, and choose a location
    where you''d like to save it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的**Epic Games Launcher**中打开Learn选项卡，并搜索`Sun Temple`示例环境。点击创建项目按钮，并选择一个您想保存的位置：
- en: '![](img/6d20f1d4-3bf5-4fd5-b832-dbeee5f6a55e.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d20f1d4-3bf5-4fd5-b832-dbeee5f6a55e.png)'
- en: Let it download. Once the project has finished downloading, open it up. It should
    open up to the Sun Temple map. Now we're going to migrate this map into our existing
    project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让它下载。项目下载完成后，打开它。它应该打开到太阳神庙地图。现在我们要将这个地图迁移到我们现有的项目中。
- en: We could just as easily have downloaded the Sun Temple project and then set
    it up to run in VR. We're doing it this way to give you an opportunity to learn
    about the Migrate... tool. When you need to get assets from one project to another,
    the Migrate tool is the best way to do it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以下载太阳神庙项目，然后设置它以在VR中运行。我们这样做是为了给您一个学习“迁移...”工具的机会。当您需要将资产从一个项目迁移到另一个项目时，“迁移”工具是最好的方法。
- en: 'In your content browser, select Content | Maps | Sun Temple. Right-click it
    and select Asset Actions | Migrate...:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容浏览器中，选择“内容”|“地图”|“太阳神庙”。右键单击它，然后选择“资产操作”|“迁移...”：
- en: '![](img/0a3d8ce6-095f-4ecc-a669-1ca60caad6de.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a3d8ce6-095f-4ecc-a669-1ca60caad6de.png)'
- en: 'You''re now going to be presented with a list of everything that will be copied
    if you migrate this map. This is the power of the Migrate... tool and is why you
    should use it. When you migrate an asset to another project, Unreal checks for
    everything else that would be needed for that asset to work, and includes it in
    the list of assets to be copied. So, for example, if you''re migrating a mesh,
    the materials and textures used by that mesh will be found automatically and migrated
    too. In our case here, we''re migrating a map, so Unreal will bring everything
    the map relies on into the new project:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将看到一个列表，其中列出了如果迁移此地图将被复制的所有内容。这就是“迁移...”工具的强大之处，也是为什么您应该使用它的原因。当您将资产迁移到另一个项目时，虚幻会检查该资产工作所需的其他所有内容，并将其包含在要复制的资产列表中。因此，例如，如果您迁移一个网格，该网格使用的材质和纹理也将被自动找到并迁移。在我们的例子中，我们正在迁移一个地图，所以虚幻将把地图所依赖的所有内容带入新项目中：
- en: '![](img/586e8055-c901-4df5-9087-e28f5e09b09e.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/586e8055-c901-4df5-9087-e28f5e09b09e.png)'
- en: Now you need to choose where you're going to put your migrated content. The
    destination for a migrate operation always has to be the `Content` directory of
    the target project. Navigate to that location and select it. (This is why we mentioned
    at the start of this chapter that it's important to understand the structure of
    an Unreal project directory. You will occasionally need to know where things live
    in it.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要选择你要放置迁移内容的位置。迁移操作的目标始终必须是目标项目的“Content”目录。导航到该位置并选择它。（这就是为什么我们在本章开始时提到了了解虚幻项目目录结构的重要性。您偶尔需要知道其中的内容存放位置。）
- en: Once the migration is complete, let's close this project and re-open the project
    to which we just added this map.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移完成后，让我们关闭这个项目，重新打开刚刚添加了这个地图的项目。
- en: You should now see a Sun Temple map in a Maps directory in your Content browser.
    Let's open it up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在内容浏览器的“Maps”目录中看到一个太阳神庙地图。让我们打开它。
- en: Unreal will probably need to compile lots of shaders if this is the first time
    you've opened this map. (This is one of the reasons why we set up a derived data
    cache in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml), *Setting Up
    Your Development Environment*—once you've compiled your shaders, they'll be stored
    in this cache so you won't have to re-compile them when you open other projects.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次打开此地图，虚幻可能需要编译大量着色器。（这是为什么我们在[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中设置了派生数据缓存的原因之一——一旦编译了着色器，它们将存储在此缓存中，因此当您打开其他项目时，无需重新编译它们。）
- en: There's a little bit of extra stuff that came across when we migrated this map.
    We're going to get rid of it now so we can focus on the new assets we're creating.
    While we're at it, we're going to take this opportunity to show you a few things
    about managing assets to the content browser that will be important to you as
    you continue developing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移此地图时，还有一些额外的内容。我们现在要摆脱它，以便我们可以专注于我们正在创建的新资产。顺便说一下，我们还将利用这个机会向您展示一些关于管理内容浏览器中的资产的重要内容，这对您的继续开发非常重要。
- en: Cleaning up migrated content
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理迁移内容
- en: 'With the Sun Temple map open, open Window | World Settings, and find GameMode
    Override. (We''re going to talk about Game Modes shortly.) Clear it by hitting
    the yellow Reset to Default arrow beside the property:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打开太阳神庙地图，打开“窗口”|“世界设置”，找到“游戏模式覆盖”。（我们将很快讨论游戏模式。）通过点击属性旁边的黄色“重置为默认”箭头来清除它：
- en: Any time you see a yellow Reset to Default arrow, hitting it will restore the
    property to its standard setting.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您看到一个黄色的“重置为默认”箭头时，点击它将恢复属性的标准设置。
- en: '![](img/0d9b7db8-d5e7-4d45-9c5f-4d45f4e19fd7.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d9b7db8-d5e7-4d45-9c5f-4d45f4e19fd7.png)'
- en: Save the map.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 保存地图。
- en: Deleting assets safely
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全删除资产
- en: Now select the `Blueprints` folder inside your content browser. We're going
    to make our own blueprints in a moment, so we don't need these. Delete this folder,
    but pay attention to the confirmation dialog that appears.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在内容浏览器中选择“蓝图”文件夹。我们马上要创建自己的蓝图，所以我们不需要这些。删除此文件夹，但要注意出现的确认对话框。
- en: 'If you see a Force Delete button with a warning, this means the thing you''re
    trying to delete is still in use somewhere. You should almost never just delete
    something that''s still being referenced. (We say *almost* here because once you
    really know what the engine is doing, there are certain circumstances where you
    can push it around a bit, but don''t do this until you''re really sure you know
    what''s going on under the hood.) Instead, find out where the asset is still in
    use, and either change the reference to point to something else, or delete the
    object that''s referencing it, or leave it alone:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到一个带有警告的“强制删除”按钮，这意味着您要删除的内容仍然在某个地方使用中。您几乎永远不应该删除仍然被引用的内容。（我们在这里说“几乎”是因为一旦您真正了解引擎在做什么，就有某些情况可以稍微推动它，但在您确切知道底层发生了什么之前，请不要这样做。）相反，找出资产仍在使用的位置，并将引用更改为指向其他内容，或者删除引用它的对象，或者保持不变：
- en: '![](img/4317e44d-90d3-4db7-9b5e-6aed95be82d9.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4317e44d-90d3-4db7-9b5e-6aed95be82d9.png)'
- en: 'If it''s safe to delete an object, the dialog will just display a Delete button.
    This means that getting rid of it won''t break anything else:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以安全删除对象，对话框将只显示一个删除按钮。这意味着删除它不会破坏其他内容：
- en: '![](img/c99701ac-7519-45e1-a8c8-4da461772ed2.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c99701ac-7519-45e1-a8c8-4da461772ed2.png)'
- en: In this case, a force delete warning would mean that you either hadn't cleared
    out the GameMode Override from the map's World Settings, or that you hadn't saved
    the map after you did. If you're looking at a simple Delete button, hit it to
    get rid of the folder and its contents.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果出现强制删除警告，意味着您可能没有清除地图的世界设置中的GameMode Override，或者您在此之后没有保存地图。如果只有一个简单的删除按钮，点击它以删除文件夹及其内容。
- en: Moving assets and fixing up redirectors
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动资产并修复重定向器
- en: Now let's organize what remains. From within your content browser, create a
    new folder for your project. We can call this folder `HelloVR`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们整理剩下的内容。在内容浏览器中，为您的项目创建一个新文件夹。我们可以将此文件夹命名为“HelloVR”。
- en: It's a good idea always to create a folder for your project inside the content
    browser. This way, as you migrate more content into your project from other sources,
    or add assets from the marketplace, you'll never be confused about which assets
    belong to your project and which arrived from outside. Similarly, if you migrate
    assets somewhere else, they'll all appear together in the new project's content
    browser. Most developers don't do this. Everybody should. The first time you migrate
    in a plugin and have it dump assets all over existing folders in your contents,
    you'll see why. You can prevent a lot of mess by keeping your own project organized.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容浏览器中为您的项目创建一个文件夹是一个好主意。这样，当您从其他来源迁移更多内容到项目中，或者从市场添加资产时，您将永远不会困惑于哪些资产属于您的项目，哪些是外部来源的。同样，如果将资产迁移到其他位置，它们将全部出现在新项目的内容浏览器中。大多数开发者不这样做，但每个人都应该这样做。当您第一次迁移插件并让其将资产散落在现有文件夹中时，您就会明白为什么。通过保持自己的项目有组织，您可以避免很多混乱。
- en: Since we've gotten rid of our `Blueprints` folder, we still have two other folders
    from our migrated content that are just sitting out at the content root. Let's
    move them inside our project folder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经删除了“Blueprints”文件夹，我们仍然有另外两个从迁移内容中遗留在内容根目录的文件夹。让我们将它们移动到我们的项目文件夹中。
- en: Grab the `Maps` folder and drag it into your `HelloVR` folder. When asked whether
    you'd like to move or copy it, choose to move it. Now grab the `Assets` folder
    and do the same.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将“Maps”文件夹拖动到“HelloVR”文件夹中。当询问是否移动或复制时，选择移动。现在将“Assets”文件夹也进行同样的操作。
- en: But what's this? We've moved the folder but the folder in the old location hasn't
    gone away. Why? The reason for this is that Unreal has left behind a collection
    of **Redirectors**. You should know about these. Let's make them visible.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是什么？我们已经移动了文件夹，但旧位置的文件夹并没有消失。为什么？原因是虚幻引擎留下了一组**重定向器**。您应该了解这些。让我们将它们显示出来。
- en: 'From the Filters drop-down beside the search bar, select Filters | Other Filters
    | Show Redirectors:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索栏旁边的筛选器下拉菜单中，选择筛选器 | 其他筛选器 | 显示重定向器：
- en: '![](img/da04931e-2050-4bb3-9af8-8e0189a29eea.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da04931e-2050-4bb3-9af8-8e0189a29eea.png)'
- en: Now let's navigate inside that left-behind `Assets` folder, and jump into its
    `Blueprints` folder. There's a **Redirector** in there with the name of a BP_Godray
    blueprint that we moved to a new location. Double-click this redirector, and it
    will take you to the asset's new location. This is what redirectors do. When you
    move assets in Unreal, it's very likely that something else in your project is
    using the asset and pointing to it. Rather than force you to change every asset
    that refers to the thing you're moving right then, Unreal allows you to move it
    without changing the references, and when other objects try to find it in its
    old location, the redirector will just point them to the new location, and you
    can change the location the reference points to later. It's a good system and
    can save you a lot of hassle on a large project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入那个被遗留的“Assets”文件夹，并进入其中的“Blueprints”文件夹。里面有一个名为BP_Godray的**重定向器**，我们将其移动到了新位置。双击此重定向器，它将带您到资源的新位置。这就是重定向器的作用。当您在虚幻引擎中移动资源时，很可能项目中的其他内容正在使用该资源并指向它。虚幻引擎允许您在不更改引用的情况下移动资源，当其他对象尝试在旧位置找到它时，重定向器将把它们指向新位置，您可以稍后更改引用指向的位置。这是一个很好的系统，可以在大型项目中节省很多麻烦。
- en: 'You don''t want to leave redirectors lying around if you don''t need them,
    however. To clean up a redirector, right-click on it, and select Fix Up:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您不需要重定向器，您不希望将其留在那里。要清理重定向器，请右键单击它，并选择“修复”：
- en: '![](img/cb6a39ad-6dd5-4367-92c4-9c4964c5733c.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb6a39ad-6dd5-4367-92c4-9c4964c5733c.png)'
- en: What this is going to do is find every asset that's referring to this asset
    in its old location, and replace the references to point to the new location.
    Once this has been done, it deletes the redirector since it's no longer needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到所有引用该资源的资源，并将引用指向新位置。完成后，删除重定向器，因为它不再需要。
- en: This can also be done to every redirector in a folder at once. Let's do this
    next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以同时对文件夹中的每个重定向器执行。接下来我们来做这个。
- en: 'First, we''ll make it easier to see our content browser''s folder structure.
    Hit the Sources Panel button beside your Filters drop-down to open your Sources
    panel:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使内容浏览器的文件夹结构更易于查看。点击筛选器下拉菜单旁边的“Sources Panel”按钮，打开“Sources panel”：
- en: '![](img/69157991-72a5-43fc-8122-8ec7ccff26fa.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69157991-72a5-43fc-8122-8ec7ccff26fa.png)'
- en: 'This toggles a tree view of your project''s content directory, which can make
    getting around and moving assets much more convenient:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将切换到项目内容目录的树状视图，可以更方便地浏览和移动资源：
- en: '![](img/eb0e25ef-327f-4471-b3c9-1edb3c6a78ac.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb0e25ef-327f-4471-b3c9-1edb3c6a78ac.png)'
- en: 'Now that we can see what we''re doing, let''s select the old `Assets` folder
    that contains all the redirectors, right-click it, and select Fix Up Redirectors
    in Folder:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们正在做什么了，让我们选择包含所有重定向器的旧的“Assets”文件夹，右键单击它，然后选择“修复文件夹中的重定向器”：
- en: '![](img/dd042d5c-4931-42d9-823c-52c2bd1f7970.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd042d5c-4931-42d9-823c-52c2bd1f7970.png)'
- en: Once the operation is complete, you can delete the old `Assets` folder, since
    it's now empty.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 操作完成后，您可以删除旧的“Assets”文件夹，因为它现在是空的。
- en: A good way to verify that a folder is empty before you delete it is to right-click
    the folder in your content browser, select Show in Explorer, and from within Explorer,
    select the folder and hit *Alt* + *Enter* to bring up its properties. If it shows
    0 files, it's empty. If there's anything in it, you can dig in and find out what's
    there and whether it's anything you want to keep.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除文件夹之前，验证文件夹是否为空的一个好方法是在内容浏览器中右键单击文件夹，选择在资源管理器中显示，并在资源管理器中选择文件夹，按下*Alt* +
    *Enter*以显示其属性。如果显示为0个文件，则为空。如果有任何内容，您可以深入了解其中的内容以及是否需要保留。
- en: Our `Content` directory now should be pretty well-organized, with everything
    we're using consolidated under our `HelloVR` folder. If you get into the habit
    of keeping your `Content` directory clean while your project is small, you'll
    have a much easier time once it gets large.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Content”目录现在应该非常有条理，我们使用的所有内容都集中在我们的“HelloVR”文件夹下。如果您在项目较小的时候就养成了保持“Content”目录整洁的习惯，那么一旦项目变得庞大，您将会更容易处理。
- en: Setting a default map
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置默认地图
- en: Now that we've brought in our map and cleaned up the extra Blueprints that came
    with it, let's set up our project to load Sun Temple as its default map.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了地图并清理了附带的额外蓝图，让我们设置项目以将Sun Temple作为默认地图加载。
- en: 'Under Project Settings | Project | Maps & Modes | Default Maps, use the drop-down
    to set Sun Temple as your Editor Startup Map and your Game Default Map:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置|项目|地图和模式|默认地图下，使用下拉菜单将Sun Temple设置为您的编辑器启动地图和游戏默认地图：
- en: '![](img/6b96639e-8031-4e18-accc-c6d2a5672bef.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b96639e-8031-4e18-accc-c6d2a5672bef.png)'
- en: This way, when you start your editor or launch the game as a standalone executable,
    it will load directly into this map.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当您启动编辑器或启动游戏作为独立可执行文件时，它将直接加载到这个地图中。
- en: Testing our map on desktop
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在桌面上测试我们的地图
- en: 'Let''s take a look at what we''ve got so far. If we''re working on desktop
    VR, we can launch the map in VR and look around. Select the drop-down to the right
    of the Play button on your editor toolbar. Select VR Preview (if VR Preview is
    dimmed, check to be sure that your VR headset is hooked up and its software is
    running):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们目前所拥有的。如果我们正在开发桌面VR，我们可以在VR中启动地图并四处查看。在编辑器工具栏上，选择播放按钮右侧的下拉菜单。选择VR预览（如果VR预览变暗，请确保您的VR头显已连接并且其软件正在运行）：
- en: '![](img/8e95638a-0ff0-4373-b483-e589c60c9982.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e95638a-0ff0-4373-b483-e589c60c9982.png)'
- en: Kinda nice in here, right?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里感觉还不错，对吧？
- en: We can't do much yet, and we're not at the right height relative to the floor,
    but it's running and we're ready to begin setting things up.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能做太多事情，而且相对于地板来说我们的高度也不正确，但它正在运行，我们准备开始设置事物。
- en: Testing our map on mobile (Oculus Go/Samsung Gear)
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在移动设备上测试我们的地图（Oculus Go/Samsung Gear）
- en: If we'd like to test the map on mobile, there are a few other things we need
    to do.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在移动设备上测试地图，我们还需要做一些其他的事情。
- en: Assuming that we've already set up our project to run on mobile as described,
    let's check first that our mobile device is connected and can be seen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经按照说明设置好了在移动设备上运行项目，让我们首先检查我们的移动设备是否已连接并可见。
- en: 'Important: If you update your Unreal Engine version, be sure you re-run the
    **CodeWorks for Android** installer at `<Engine Install Location>\Engine\Extras\AndroidWorks\Win64`.
    Building with newer Unreal code and out-of-date Android SDK code can create difficult-to-debug
    errors when you try to run in mobile VR. Remember to keep your CodeWorks up-to-date.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果您更新了Unreal Engine版本，请确保在“<Engine Install Location>\Engine\Extras\AndroidWorks\Win64”下重新运行**CodeWorks
    for Android**安装程序。使用更新的Unreal代码和过时的Android SDK代码构建可能会在尝试在移动VR中运行时创建难以调试的错误。记得保持您的CodeWorks更新。
- en: 'Open Windows PowerShell and navigate to the `platform-tools` directory in your
    Android SDK directory. By default, this will be `C:\NVPACK\android-sdk-windows\platform-tools`.
    From here, type `./adb devices`. You should see the serial number of your connected
    device here with the word `device` beside it. If this reads *unauthorized* instead,
    you need to accept the connection to your PC from within the headset. If this
    reads *offline*, you may need to restart your `adb` server. Type `./adb kill-server`,
    and then run `./adb devices` again:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Windows PowerShell并导航到Android SDK目录中的“platform-tools”目录。默认情况下，这将是“C:\NVPACK\android-sdk-windows\platform-tools”。从这里，键入“./adb
    devices”。您应该在这里看到您连接的设备的序列号，并在旁边带有“device”一词。如果显示为“unauthorized”，则需要在头显内部接受与PC的连接。如果显示为“offline”，则可能需要重新启动您的“adb”服务器。键入“./adb
    kill-server”，然后再次运行“./adb devices”：
- en: '![](img/b72805c4-0bca-407d-aca0-92289a726f27.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b72805c4-0bca-407d-aca0-92289a726f27.png)'
- en: If you're working on mobile devices, there's no way around the reality that
    you're going to spend a lot of time in PowerShell talking to the device. Take
    the time to learn about ADB especially. When something goes wrong, you're going
    to use ADB to figure out what's happening. Learn more about it here: [https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用移动设备进行开发，无论如何，您都将花费大量时间在PowerShell中与设备进行通信。花时间学习ADB尤为重要。当出现问题时，您将使用ADB来找出问题所在。在此处了解更多信息：[https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb)。
- en: If your `./adb` devices looks good, you should be ready to launch the project
    to the device.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的“./adb”设备看起来不错，您应该准备好将项目发布到设备上了。
- en: From your launch drop-down on the editor toolbar, select the Android entry that
    matches the serial number of your device.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器工具栏上的启动下拉菜单中，选择与您设备的序列号匹配的Android条目。
- en: The launch process should begin. As we mentioned in the [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting Up Your Development Environment*, expect it to take a while the first
    time you do this.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程应该开始了。正如我们在[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中提到的*设置开发环境*，第一次执行可能需要一些时间。
- en: Setting up a game mode and player pawn
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置游戏模式和玩家角色
- en: Now that we've set up a basic scene and verified that it runs on the platform,
    let's get to work on building in some functionality.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个基本场景并验证了它在平台上运行，让我们开始构建一些功能。
- en: Creating a VR pawn
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个VR角色
- en: The first thing we're going to need to do is create a **pawn** to represent
    the player. Pawns are a type of actor that can be controlled by a player or by
    AI. In our case, we're going to create a pawn that our player can control.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是创建一个代表玩家的**角色**。角色是一种可以由玩家或AI控制的演员类型。在我们的情况下，我们将创建一个玩家可以控制的角色。
- en: Unreal Engine is an **object-oriented** system. This means that the engine is
    organized around discrete items called **objects**. An object consists of **properties**,
    which you can generally see by looking at the Details panel of an item you select
    in the map, and **functions**, which you can often see in the blueprint editor.
    Objects often **inherit** from one another, so a new class of object might be
    created using another class as its parent. This means that the new class would
    take on the attributes and behavior of its parent, but could then change these
    attributes and behaviors or add new ones. An actor, therefore, is a child of the
    object class that adds the capability to be placed in the world. A pawn is a type
    of actor that adds the ability to be controlled by a player or AI. When we create
    our own class using a pawn as a parent, we're setting up that class to take on
    everything a pawn can do, and then changing its behaviors or adding our own.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎是一个**面向对象**的系统。这意味着引擎是围绕称为**对象**的离散项组织的。一个对象由**属性**组成，你可以通过查看地图中选择的项目的详细面板来看到这些属性，以及**函数**，你通常可以在蓝图编辑器中看到这些函数。对象经常从彼此**继承**，因此一个新的对象类可能使用另一个类作为其父类来创建。这意味着新类将继承其父类的属性和行为，但可以更改这些属性和行为或添加新的属性和行为。因此，一个演员是对象类的子类，它添加了在世界中放置的能力。角色是一种可以由玩家或AI控制的演员类型。当我们使用角色作为父类创建自己的类时，我们正在设置该类来承担角色的所有功能，然后更改其行为或添加我们自己的功能。
- en: 'Let''s navigate to our `Content/HelloVR/Assets/Blueprints` folder in the content
    browser, right-click on any empty space in the folder, and select Create Basic
    Asset | Blueprint Class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在内容浏览器中导航到我们的`Content/HelloVR/Assets/Blueprints`文件夹，在文件夹中的任何空白处右键单击，然后选择创建基本资产
    | 蓝图类：
- en: '![](img/858848aa-7bc0-4fe4-97db-a6856ca98ff6.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/858848aa-7bc0-4fe4-97db-a6856ca98ff6.png)'
- en: 'In the dialog that follows, we''ll be asked to select our new blueprint''s
    parent class. Select Pawn:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的对话框中，我们将被要求选择我们新蓝图的父类。选择Pawn：
- en: '![](img/4bb20538-4d6a-4874-91f4-81d56ace839f.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bb20538-4d6a-4874-91f4-81d56ace839f.png)'
- en: A new blueprint asset will be created in our `Blueprints` directory. Let's name
    it `BP_VRPawn`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Blueprints`目录中将创建一个新的蓝图资产。让我们将其命名为`BP_VRPawn`。
- en: It's a good idea to get into the habit of following a **naming convention**
    when you name your assets. A naming convention is a set of rules you follow when
    thinking up a name for a new thing you're creating. By following rules when you
    name objects, you can make it much easier to see what an object is, or to remember
    what you called it. In this instance, we're using the `BP_ prefix` as a reminder
    that our pawn is a blueprint class. A particularly thorough and well-thought-out
    naming convention lives here: [https://github.com/Allar/ue4-style-guide](https://github.com/Allar/ue4-style-guide).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给你的资产命名时，遵循一个**命名约定**是一个好习惯。命名约定是在你思考为你正在创建的新事物命名时遵循的一组规则。通过在命名对象时遵循规则，你可以更容易地看到一个对象是什么，或者记住你给它起的名字。在这种情况下，我们使用`BP_前缀`作为提醒，我们的角色是一个蓝图类。一个特别全面和深思熟虑的命名约定在这里：[https://github.com/Allar/ue4-style-guide](https://github.com/Allar/ue4-style-guide)。
- en: In a moment, we're going to start modifying our pawn, but, first, we need to
    tell our map to use it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一会儿，我们将开始修改我们的角色，但是首先，我们需要告诉地图使用它。
- en: Creating a game mode
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个游戏模式
- en: Whenever Unreal loads up a map, the first thing it does is check to see what
    rules govern the behavior of the map. These rules can specify a number of things,
    but the one we care about right now is what sort of pawn is going to spawn from
    a `Player Start` object. This collection of rules lives in a class called the
    **Game Mode**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每当虚幻加载一个地图时，它首先检查规定地图行为的规则。这些规则可以指定许多事情，但我们现在关心的是从`Player Start`对象生成什么样的角色。这些规则的集合存在于一个称为**游戏模式**的类中。
- en: Let's create a game mode. Right-click in empty space, create a Blueprint Class,
    and select Game Mode Base as its parent. We'll name it `BP_VRGameMode`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个游戏模式。在空白处右键单击，创建一个蓝图类，并选择Game Mode Base作为其父类。我们将其命名为`BP_VRGameMode`。
- en: 'Double-click our new game mode to open it up, and in its Details section, select
    the Classes | Default Pawn Class drop-down, and select the `BP_VRPawn` class we
    just created:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 双击我们的新游戏模式以打开它，在其详细信息部分，选择Classes | Default Pawn Class下拉菜单，并选择我们刚刚创建的`BP_VRPawn`类：
- en: '![](img/dcc1d54e-2e3d-446a-b123-1eed8b15b2d1.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcc1d54e-2e3d-446a-b123-1eed8b15b2d1.png)'
- en: For our purposes right now, this is all we need to do with our game mode. We're
    just using it to specify the pawn class we'd like to load. Compile it and save
    it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们现在的目的，这就是我们需要做的关于游戏模式的一切。我们只是使用它来指定我们想要加载的角色类。编译并保存它。
- en: Blueprint is a **compiled** language. Before the code you write can be run by
    the CPU, it needs to be translated into a language the CPU understands. There
    are two main ways this can happen. **Interpreted** languages are translated on-the-fly
    while they're running. This comes with a cost though, since the interpreter needs
    to be running alongside your code and trying to translate it while it runs. It's
    much faster to translate everything offline in a separate process so it's ready
    to go when the CPU needs to run it. This is how compiled languages handle things,
    and when you compile your blueprints, this is what you're doing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图是一种**编译**语言。在您编写的代码可以由CPU运行之前，需要将其转换为CPU可以理解的语言。这可以通过两种主要方式实现。**解释**语言在运行时即时翻译。然而，这样做会带来一些成本，因为解释器需要在您的代码旁边运行并尝试在运行时进行翻译。将所有内容离线翻译为准备好在CPU需要运行时运行的单独进程中，这样处理速度更快。这是编译语言处理事物的方式，当您编译蓝图时，这就是您所做的事情。
- en: By default, when blueprints are compiled, they're compiled to a format that's
    then used by a virtual machine that hosts the blueprint code while your application
    is running. This system runs fast, but if you want to squeeze even more speed
    out of it, you have the option to convert them to native C++, which then allows
    them to be compiled to machine code. At this point, they can run as fast as code
    written directly in C++.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当蓝图被编译时，它们被编译为一种格式，然后由虚拟机使用该蓝图代码托管您的应用程序运行时。这个系统运行速度很快，但如果您想从中挤出更多的速度，您可以选择将它们转换为本机C++，然后允许它们编译为机器代码。此时，它们可以像直接在C++中编写的代码一样快速运行。
- en: Assigning the game mode
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配游戏模式
- en: Now we need to tell our project to use this game mode as its default.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉我们的项目使用这个游戏模式作为默认模式。
- en: 'Open Project Settings, and under Project | Maps & Modes | Default Modes, set
    our Default GameMode to our newly-created game mode:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目设置，并在项目|地图和模式|默认模式下，将我们的默认游戏模式设置为我们新创建的游戏模式：
- en: '![](img/902a3a02-d8b9-449c-b4ad-08e8b521d672.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/902a3a02-d8b9-449c-b4ad-08e8b521d672.png)'
- en: Now any level that loads in our project will use this GameMode to decide what
    to spawn and what rules to follow when running the scene.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们项目中加载的任何关卡都将使用此游戏模式来决定生成什么以及运行场景时遵循什么规则。
- en: Overriding a GameMode for a specific map
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为特定地图覆盖游戏模式
- en: What if we wanted one of our maps to use a different GameMode? For instance,
    if we set up an entry menu scene, we might want to spawn a pawn designed to interact
    with the menus in place of our default player pawn. Fortunately, this is easy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要其中一个地图使用不同的游戏模式怎么办？例如，如果我们设置了一个入口菜单场景，我们可能希望生成一个专门用于与菜单交互的棋子，以替代默认的玩家棋子。幸运的是，这很容易实现。
- en: 'If it isn''t already visible, select Window | World Settings to open up our
    World Settings tab. In World Settings, under Game Mode, set the GameMode Override
    to the new BP_VRGameMode we just created:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未可见，请选择窗口|世界设置以打开我们的世界设置选项卡。在世界设置中，在游戏模式下，将游戏模式覆盖设置为我们刚刚创建的新BP_VRGameMode：
- en: '![](img/66c36f81-840c-4225-abba-4c17be89ae79.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66c36f81-840c-4225-abba-4c17be89ae79.png)'
- en: We've just told the engine to use our new game mode when this map loads up,
    regardless of what GameMode was specified in the project settings.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚告诉引擎在加载此地图时使用我们的新游戏模式，而不管项目设置中指定了什么游戏模式。
- en: 'There are four places where we can specify what game mode to use:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个地方可以指定要使用的游戏模式：
- en: You can set it in Project Settings | Maps & Modes | Default Modes | Default
    GameMode. A GameMode specified here will load by default anywhere in your project
    unless something else overrides it.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在项目设置|地图和模式|默认模式|默认游戏模式中设置它。在项目中，除非有其他覆盖，否则此处指定的游戏模式将默认加载。
- en: You can set the GameMode Override in an individual map as we've done here. This
    will override the global default game mode from your project settings if it's
    set.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在单个地图中设置游戏模式覆盖，就像我们在这里所做的那样。如果设置了全局默认游戏模式，它将覆盖项目设置中的全局默认游戏模式。
- en: You can specify a game mode using the *command-line argument* `?game=MyGameMode`
    when you launch your executable. This, in turn, will override your default game
    mode, and any override set in your map.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动可执行文件时，您可以使用命令行参数`?game=MyGameMode`来指定游戏模式。这将覆盖默认游戏模式以及地图中设置的任何覆盖。
- en: In your `DefaultEngine.ini`, you can specify specific game modes to load when
    maps with specific prefixes are loaded. This will override any other specification
    if it's set.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`DefaultEngine.ini`中，您可以指定在加载具有特定前缀的地图时要加载的特定游戏模式。如果设置了此项，它将覆盖任何其他规定。
- en: Placing a pawn directly in the world
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个棋子直接放在世界中
- en: While it's generally preferable to use a game mode and a player start object
    to get your player pawn into the world, you don't have to do it this way, and
    you'll occasionally run across existing projects, such as the default VR Template
    project, that don't use a GameMode to set the player pawn.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常最好使用游戏模式和玩家起始对象将玩家棋子放入世界中，但您不必这样做，有时您会遇到一些现有项目，例如默认的VR模板项目，不使用游戏模式来设置玩家棋子。
- en: In these cases, instead of placing a player start object in your scene where
    you want the player to spawn, drag your pawn blueprint directly into the scene.
    If your scene has an existing player start, get rid of it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，不要在您希望玩家生成的场景中放置玩家起始对象，而是直接将您的棋子蓝图拖放到场景中。如果场景中已经有一个现有的玩家起始点，请将其删除。
- en: 'Remember that we said pawns could be controlled by players or AI? You need
    to put your pawn under player control since you don''t have a GameMode doing the
    job for you. Select the pawn you just placed in the level, and in its Details,
    find Pawn | Auto Possess Player, and set the value to Player 0\. This will put
    the pawn under the player''s control when it spawns into the world:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们说过棋子可以由玩家或AI控制吗？由于没有游戏模式来完成这项工作，您需要将您的棋子置于玩家控制之下。选择刚刚放置在关卡中的棋子，在其详细信息中找到Pawn
    | Auto Possess Player，并将值设置为Player 0。这将在生成到世界中时将棋子置于玩家控制之下：
- en: '![](img/3bccef52-3c9b-4b50-a711-3201d9af0812.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bccef52-3c9b-4b50-a711-3201d9af0812.png)'
- en: In general, it's better practice to use a GameMode to specify the player pawn
    class, but you should know that this method exists, because you will see some
    projects use it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好使用GameMode来指定玩家角色类，但你应该知道这种方法的存在，因为你会看到一些项目使用它。
- en: Setting up the VR pawn
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置VR角色
- en: Now that we've created a VR pawn and set up the game mode to use it, let's modify
    this pawn to set it up appropriately for use in VR. We're going to do this from
    scratch here. Quite often, you'll use the pawn class supplied with the VR template
    when you create a simple VR application, but we don't want you to use this as
    a crutch. It's much better to understand how a pawn is built for VR, so you can
    build it appropriately for what you need it to do.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个VR角色并设置了游戏模式来使用它，让我们修改这个角色以适当地在VR中使用。我们将从头开始做这个。通常情况下，当你创建一个简单的VR应用程序时，你会使用VR模板提供的角色类，但我们不希望你把它当作一个支撑。更好的做法是了解如何为VR构建角色，这样你就可以根据需要适当地构建它。
- en: The first thing we're going to do is open up our pawn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是打开我们的角色。
- en: Adding a camera
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加相机
- en: 'In the upper-left corner of the blueprint editor view, you should see a Components
    tab. Hit the green +Add Component button, and in the drop-down that appears, select
    Scene to create a Scene Component. Name it `Camera Root`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图编辑器视图的左上角，你应该看到一个组件选项卡。点击绿色的+Add Component按钮，在下拉菜单中选择Scene创建一个场景组件。将其命名为`Camera
    Root`：
- en: '![](img/b85f1d89-f8a6-42ec-9fd1-04c96caa1d83.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b85f1d89-f8a6-42ec-9fd1-04c96caa1d83.png)'
- en: '**Components** are additional elements that can be added to blueprint objects.
    There''s a wide variety of components available to you, and they all do different
    jobs. Components are organized into a hierarchy, allowing you to attach components
    to other components. You can do quite a lot with this.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是可以添加到蓝图对象中的附加元素。有各种各样的组件可供选择，它们都有不同的功能。组件按层次结构组织，允许你将组件附加到其他组件上。你可以通过这种方式做很多事情。'
- en: Now, create a new Camera component. If the Camera Root scene component was still
    selected when you did this, the Camera component will be created as a child of
    Camera Root. If it isn't, drag it on to Camera Root to set Camera Root as its
    parent.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的相机组件。如果在创建相机组件时仍然选择了Camera Root场景组件，则相机组件将作为Camera Root的子组件创建。如果没有选择，将其拖动到Camera
    Root上，将Camera Root设置为其父组件。
- en: It's often a good idea to set a separate root component as we've done here.
    This gives you much more flexibility to change the structure of the actor later,
    or to change rotations or positions of components such as cameras without having
    to adjust the position of the object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，像我们在这里做的这样设置一个单独的根组件是一个好主意。这样可以更灵活地更改角色的结构，或者更改组件（如相机）的旋转或位置，而无需调整对象的位置。
- en: Adding motion controllers
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加运动控制器
- en: Next, select the `DefaultSceneRoot` component, and create a `Motion Controller`
    component. For this one, use the Search Components bar at the top of the Add Component
    menu and type `mot` to narrow the search to the motion-controller component. You
    can save yourself a lot of time by using this search bar. Name this new component
    `MotionController_L` and make sure it's a child of the `DefaultSceneRoot`, and
    not a child of the CameraRoot or the Camera.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择`DefaultSceneRoot`组件，并创建一个`Motion Controller`组件。对于这个组件，在添加组件菜单的顶部使用搜索组件栏，输入`mot`以缩小搜索范围到运动控制器组件。使用这个搜索栏可以节省很多时间。将这个新组件命名为`MotionController_L`，确保它是`DefaultSceneRoot`的子组件，而不是CameraRoot或Camera的子组件。
- en: 'Select `DefaultSceneRoot` and do this again to create a second motion-controller
    component. Name this one `MotionController_R` and again make sure it''s a child
    of the `DefaultSceneRoot`, and not any other component:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`DefaultSceneRoot`，再次执行上述步骤创建第二个运动控制器组件。将其命名为`MotionController_R`，并确保它是`DefaultSceneRoot`的子组件，而不是任何其他组件：
- en: '![](img/c87daa50-4b12-4171-9445-371387149001.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c87daa50-4b12-4171-9445-371387149001.png)'
- en: Your component hierarchy should now look like the preceding screenshot.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的组件层次结构应该看起来像上面的截图。
- en: 'Before we move on, we need to set a few properties on our motion-controller
    components. Select the `MotionController_R` component, and in its Details panel,
    find the Motion Controller | Motion Source entry. Set it to Right to allow the
    controller to be moved by the right-hand Oculus or Vive controller. While we''re
    at it, ensure that `MotionController_L` is still set to use Left as its motion
    source. It should be this by default:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要设置一些运动控制器组件的属性。选择`MotionController_R`组件，在其详细面板中找到Motion Controller
    | Motion Source条目。将其设置为Right，以允许右手的Oculus或Vive控制器移动控制器。顺便说一下，确保`MotionController_L`仍然设置为使用Left作为其运动源。默认情况下应该是这样的：
- en: '![](img/12f5f1df-ffd0-4bf6-9097-c97bf016ac50.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12f5f1df-ffd0-4bf6-9097-c97bf016ac50.png)'
- en: 'Let''s also make both of these controllers visible so we can verify that they''re
    working. From each motion-controller component''s Details panel, select Visualization
    | Display Device Model. Turn this on, and verify that Display Model Source is
    still set to Default, which will simply display the model for the motion-controller
    hardware you''re using. We''ll replace our motion-controller display later on,
    but for now, we just want to see them so we can verify that we''ve set them up
    correctly:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将这两个控制器设置为可见，以便我们可以验证它们是否正常工作。从每个运动控制器组件的详细面板中，选择可视化|显示设备模型。打开此选项，并验证显示模型源是否仍设置为默认值，这将简单地显示你正在使用的运动控制器硬件的模型。我们稍后会替换我们的运动控制器显示，但现在，我们只是想看到它们，以便我们可以验证我们已经正确设置它们：
- en: '![](img/a733241e-7736-4a47-ba93-d1621998bf12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a733241e-7736-4a47-ba93-d1621998bf12.png)'
- en: Setting our tracking origin.
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的跟踪原点。
- en: 'Now we need to tell our pawn how it should interpret the location of the headset
    in the tracked space. Look for the My Blueprint tab underneath your pawn''s Components
    tab, and if your EventGraph panel isn''t already visible in the main editing window,
    double-click Graphs | EventGraph in the My Blueprint tab to display it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉我们的角色如何解释追踪空间中头戴设备的位置。在您的角色的组件选项卡下方寻找“我的蓝图”选项卡，如果您的事件图面板在主编辑窗口中尚不可见，请在“我的蓝图”选项卡中双击“图表|事件图”以显示它：
- en: '![](img/33fb67b1-f07e-4d2d-8626-e4234c1fc9f2.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33fb67b1-f07e-4d2d-8626-e4234c1fc9f2.png)'
- en: Once you're in your EventGraph, find the BeginPlay event, or right-click anywhere
    in the graph editor and type `beginplay` in the search dialog that appears to
    find or create a BeginPlay event. Drag an execution line from the BeginPlay event
    and right-click to create a new node. Find Input | Head Mounted Display | Set
    Tracking Origin, or begin typing in the search box to find it. Create a `Set Tracking
    Origin` node, and set its origin to Floor Level if you're using a room-scale VR
    system such as the HTC Vive or Oculus Rift with Touch controllers, or Eye Level if
    you're using a non-room-scale system such as the Oculus Go or older single-camera
    Oculus Rift.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入事件图，找到BeginPlay事件，或者在图形编辑器中右键单击任意位置并在出现的搜索对话框中键入“beginplay”以查找或创建BeginPlay事件。从BeginPlay事件拖动执行线并右键单击以创建一个新节点。找到输入|头戴显示器|设置跟踪原点，或者开始在搜索框中键入以找到它。创建一个“设置跟踪原点”节点，并将其原点设置为地板高度，如果您使用的是房间规模的VR系统，如HTC
    Vive或带有触摸控制器的Oculus Rift，或者将其原点设置为眼睛高度，如果您使用的是非房间规模的系统，如Oculus Go或较旧的单摄像头Oculus
    Rift。
- en: Adjusting our Player Start location to the map.
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整我们的玩家起始位置到地图中。
- en: 'Finally, we need to adjust our Player Start position in the map. Find it in
    your World Outliner (you can use the search bar to find it quicker, and then select
    it and drag it down in the scene until its center intersects the floor (this is
    a bit of a hacky way to align our pawn, and we''ll do a better job of this later,
    but for now it will work):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整地图中的玩家起始位置。在您的世界大纲中找到它（您可以使用搜索栏更快地找到它，然后选择它并将其拖动到场景中，直到其中心与地板相交（这是一种不太正式的对齐角色的方法，我们稍后会更好地完成这个工作，但现在它可以工作）：
- en: '![](img/b8ecafd1-d289-4fd7-8517-f7ebb7f8e834.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8ecafd1-d289-4fd7-8517-f7ebb7f8e834.png)'
- en: Testing in the headset.
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在头戴设备中进行测试。
- en: We now have the building blocks we're going to need to create VR experiences
    in Unreal. We have a project that's been properly set-up to run efficiently in
    VR, and a pawn that may not do much yet, but is ready to be used as a foundation
    for the things we really want to do.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了在虚幻中创建VR体验所需的基本组件。我们有一个已经正确设置为在VR中高效运行的项目，以及一个可能还没有太多功能的角色，但已经准备好作为我们真正想要做的事情的基础。
- en: Let's test it. Launch the map using VR preview, and verify that your view seems
    to be at the right height, and that you can see your motion controllers when you
    move your hands. Framerate should be acceptable as well.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行测试。使用VR预览启动地图，并验证您的视图是否位于正确的高度，并且在移动手时是否可以看到您的动作控制器。帧率也应该是可以接受的。
- en: Packaging a standalone build
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包独立构建
- en: When we distribute an Unreal application to other users, we generally don't
    give them the source files for the editor. Instead, we package the project into
    a stand-alone executable that can be run on the target platform.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将虚幻应用程序分发给其他用户时，通常不会给他们编辑器的源文件。相反，我们将项目打包成一个可以在目标平台上运行的独立可执行文件。
- en: Let's create a Windows standalone executable.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Windows独立可执行文件。
- en: 'Select File | Package Project | Windows | Windows (64-bit) to kick off a packaging
    process. You''ll be asked where to put it. Choose a location that makes sense.
    (Often, creating a `Packaged` directory inside your project directory can be reasonable.
    You can put your packaged build wherever you want.) When the build status dialog
    appears, hit Show Output Log so you can see what it''s doing:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 选择文件|打包项目|Windows|Windows（64位）以启动打包过程。将被问到放置的位置。选择一个有意义的位置。（通常，在项目目录中创建一个“打包”目录是合理的。您可以将打包的构建放在任何您想要的地方。）当构建状态对话框出现时，点击“显示输出日志”以查看它正在做什么：
- en: '![](img/5053a3c9-dbca-47d3-a898-74827501f3b7.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5053a3c9-dbca-47d3-a898-74827501f3b7.png)'
- en: Expect this process to take a while.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 预计这个过程会花费一些时间。
- en: Once the process completes, close the editor and check the location where you
    told the system to build your executable. You should see a `WindowsNoEditor` folder
    inside it. Inside that, you should see an executable with your project's name.
    Launch the executable. If you set the Start in VR flag in your Project Settings,
    it should launch directly to your headset.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进程完成，关闭编辑器并检查您告诉系统构建可执行文件的位置。您应该在其中看到一个`WindowsNoEditor`文件夹。在其中，您应该看到一个带有项目名称的可执行文件。启动可执行文件。如果在项目设置中设置了在VR中启动标志，它应该直接启动到您的头戴设备。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Congratulations! We covered a lot of ground. In this chapter. We went through
    the process of creating a starting VR project and set it up properly to run well
    on the target hardware. We learned how to decide what settings to use when setting
    up a new project for VR, and how to find our way around inside an Unreal project
    directory. We also learned about a number of important Unreal Engine features
    used in VR development:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们涵盖了很多内容。在本章中，我们经历了创建起始VR项目并正确设置其在目标硬件上运行的过程。我们学会了在设置新的VR项目时如何决定使用哪些设置，以及如何在虚幻项目目录中找到我们的方式。我们还了解了在VR开发中使用的一些重要虚幻引擎功能：
- en: Instanced Stereo
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化立体
- en: Round Robin Occlusions
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环轮询遮挡
- en: Forward Shading
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染
- en: Multisampling Anti-Aliasing (MSAA)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重采样抗锯齿（MSAA）
- en: '[Mobile] Mobile Multi-View'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[移动]移动多视图'
- en: '[Mobile] Monoscopic Far Field Rendering'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[移动]单眼远场渲染'
- en: We learned how to migrate content from one project to another, and how to clean
    up our `Content` directory once it arrives.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何从一个项目迁移内容到另一个项目，并在其到达后如何清理我们的“内容”目录。
- en: Finally, we set up a basic VR pawn and set up a game mode to instruct the map
    to load it. In working with the pawn, we learned about how we can use components
    to build complex objects out of simple parts, adding a camera and tracked motion
    controllers. Finally, we set up the first elements of our pawn's blueprint to
    set our tracking origin appropriately for our VR hardware, and tested our map.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了一个基本的VR棋子，并设置了一个游戏模式来指示地图加载它。在使用棋子时，我们了解了如何使用组件来将简单的部件组装成复杂的对象，添加了相机和跟踪运动控制器。最后，我们设置了我们棋子蓝图的第一个元素，以适应我们的VR硬件的跟踪原点，并测试了我们的地图。
- en: In the next chapter, we're going to make it possible for the pawn we created
    in this chapter to move through the world. We'll use Blueprints to create a teleport
    movement scheme, and learn how to set up the environment to support it, and then
    we'll move on from there to implement a range of immersive movement schemes as
    well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使在本章中创建的棋子能够在世界中移动。我们将使用蓝图来创建一个传送移动方案，并学习如何设置环境来支持它，然后我们将继续实现一系列沉浸式移动方案。
