- en: Chapter 12. Playing with Max 6 Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 玩转Max 6框架
- en: This chapter will teach us some tips and techniques that we can use with the
    Max 6 graphical programming framework and Arduino boards.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会我们一些可以在Max 6图形编程框架和Arduino板上使用的技巧和技术。
- en: We introduced this amazing framework in [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sense the World – Feeling with Analog
    Inputs*, while we learned about Arduino analog input handling. Reading the previous
    chapter is a requirement to better understand and learn the techniques developed
    in this chapter. I even suggest you read the Max 6 introduction part again.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.html "第6章. 感知世界 – 使用模拟输入感受")中介绍了这个令人惊叹的框架，当我们学习Arduino模拟输入处理时。阅读上一章是更好地理解和学习本章中开发的技术的要求。我甚至建议你再次阅读Max
    6简介部分。
- en: In this chapter, we will learn how to send data to Arduino from Max 6\. We will
    also describe how we can handle and parse the data being received from Arduino.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从Max 6向Arduino发送数据。我们还将描述如何处理和解析从Arduino接收到的数据。
- en: Arduino adds a lot of features to your Max 6 programs. Indeed, it provides a
    way to plug Max 6 into the real physical world. Through two examples, we are going
    to understand a nice way of working with Arduino, the computer and most advanced
    programming framework ever.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino为你的Max 6程序添加了许多功能。实际上，它提供了一种将Max 6插入真实物理世界的方法。通过两个示例，我们将了解一种与Arduino、计算机和最先进的编程框架一起工作的好方法。
- en: Let's go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Communicating easily with Max 6 – the [serial] object
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Max 6轻松通信 – `[serial]`对象
- en: As we already discussed in [Chapter 6](ch06.html "Chapter 6. Sensing the World
    – Feeling with Analog Inputs"), *Sensing the World – Feeling with Analog Inputs*,
    the easiest way to exchange data between your computer running a Max 6 patch and
    your Arduino board is via the serial port. The USB connector of our Arduino boards
    includes the FTDI integrated circuit EEPROM FT-232 that converts the RS-232 plain
    old serial standard to USB.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ch06.html "第6章. 感知世界 – 使用模拟输入感受")中已经讨论过的，*感知世界 – 使用模拟输入感受*，在运行Max
    6补丁的计算机和Arduino板之间交换数据的最简单方法是使用串行端口。我们的Arduino板上的USB连接器包括FTDI集成电路EEPROM FT-232，它将RS-232标准串行转换为USB。
- en: We are going to use again our basic USB connection between Arduino and our computer
    in order to exchange data here.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Arduino和我们的计算机之间的基本USB连接来在此处交换数据。
- en: The [serial] object
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`[serial]`对象'
- en: We have to remember the `[serial]` object's features. It provides a way to send
    and receive data from a serial port. To do this, there is a basic patch including
    basic blocks. We are going to improve it progressively all along this subchapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住`[serial]`对象的特点。它提供了一种从串行端口发送和接收数据的方式。为此，有一个包括基本模块的基本补丁。我们将在这个子章节中逐步改进它。
- en: The `[serial]` object is like a buffer we have to poll as much as we need. If
    messages are sent from Arduino to the serial port of the computer, we have to
    ask the `[serial]` object to pop them out. We are going to do this in the following
    pages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`[serial]`对象就像一个我们需要频繁轮询的缓冲区。如果从Arduino向计算机的串行端口发送消息，我们必须要求`[serial]`对象将它们弹出。我们将在接下来的页面中这样做。'
- en: '![The [serial] object](img/7584_12_001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![The [serial] object](img/7584_12_001.jpg)'
- en: You can find it in the `Chapter12` folder; the patch is named `serialObject.maxpat`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter12`文件夹中找到它；补丁文件名为`serialObject.maxpat`。
- en: Of course, this chapter is also a pretext for me to give you some of my tips
    and tricks in Max 6 itself. Take them and use them; they will make your patching
    life easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本章也是我向您提供一些我在Max 6本身的一些技巧和窍门的序言。接受并使用它们；它们会让你的补丁生活变得更轻松。
- en: Selecting the right serial port
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的串行端口
- en: In [Chapter 6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog
    Inputs"), *Sense the World – Feeling with Analog Inputs*, we used the message
    `(print)` sent to `[serial]` in order to list all the serial ports available on
    the computer. Then we checked the Max window. That was not the smartest solution.
    Here, we are going to design a better one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章. 感知世界 – 使用模拟输入感受")中，*感知世界 – 使用模拟输入感受*，我们使用发送到`[serial]`的消息`(print)`来列出计算机上可用的所有串行端口。然后我们检查了Max窗口。这并不是最聪明的解决方案。在这里，我们将设计一个更好的方案。
- en: We have to remember the `[loadbang]` object. It fires a bang, that is, a `(print)`
    message to the following object as soon as the patch is loaded. It is useful to
    set things up and initialize some values as we could inside our `setup()` block
    in our Arduino board's firmware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住 `[loadbang]` 对象。它在补丁加载时触发一个撞击，即一个 `(print)` 消息发送到后续对象。这有助于设置和初始化一些值，就像我们在
    Arduino 板的固件中的 `setup()` 块内做的那样。
- en: Here, we do that in order to fill the serial port selector menu. When the `[serial]`
    object receives the `(print)` message, it pops out a list of all the serial ports
    available on the computer from its right outlet prepended by the word `port`.
    We then process the result by using `[route port]` that only parses lists prepended
    with the word `port`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们这样做是为了填充串行端口选择菜单。当 `[serial]` 对象接收到 `(print)` 消息时，它会从其右侧出口弹出计算机上所有可用的串行端口列表，并在前面加上单词
    `port`。然后我们通过使用 `[route port]` 处理结果，该对象只解析以单词 `port` 开头的列表。
- en: 'The `[t]` object is an abbreviation of `[trigger]`. This object sends the incoming
    message to many locations, as is written in the documentation, if you assume the
    use of the following arguments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`[t]` 对象是 `[trigger]` 的缩写。根据文档所述，如果假设使用以下参数：'
- en: '`b` means bang'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` 表示撞击'
- en: '`f` means float number'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` 表示浮点数'
- en: '`i` means integer'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 表示整数'
- en: '`s` means symbol'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 表示符号'
- en: '`l` means list (that is, at least one element)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l` 表示列表（即至少有一个元素）'
- en: We can also use constants as arguments and as soon as the input is received,
    the constant will be sent as it is.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用常量作为参数，一旦接收到输入，常量就会以原样发送。
- en: 'At last, the `[trigger]` output messages in a particular order: from the rightmost
    outlet to the leftmost one.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以特定顺序输出 `[trigger]` 的消息：从最右侧出口到最左侧出口。
- en: So here we take the list of serial ports being received from the `[route]` object;
    we send the `clear` message to the `[umenu]` object (the list menu on the left
    side) in order to clear the whole list. Then the list of serial ports is sent
    as a list (because of the first argument) to `[iter]`. `[iter]` splits a list
    into its individual elements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们取从 `[route]` 对象接收到的串行端口列表；我们将 `clear` 消息发送到 `[umenu]` 对象（左侧的列表菜单），以清除整个列表。然后，将串行端口列表作为列表（由于第一个参数）发送到
    `[iter]`。`[iter]` 将列表分割成其各个元素。
- en: '`[prepend]` adds a message in front of the incoming input message.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`[prepend]` 在传入的输入消息前添加一个消息。'
- en: 'That means the global process sends messages to the `[umenu]` object similar
    to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着全局过程将消息发送到 `[umenu]` 对象，类似于以下内容：
- en: append `xxxxxx`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `xxxxxx`
- en: append `yyyyyy`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `yyyyyy`
- en: Here `xxxxxx` and `yyyyyy` are the serial ports that are available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `xxxxxx` 和 `yyyyyy` 是可用的串行端口。
- en: This creates the serial port selector menu by filling the list with the names
    of the serial ports. This is one of the typical ways to create some helpers, in
    this case the menu, in our patches using UI elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过填充串行端口的名称来创建串行端口选择菜单。这是在补丁中使用 UI 元素创建一些辅助工具（在这种情况下是菜单）的典型方法之一。
- en: As soon as you load this patch, the menu is filled, and you only have to choose
    the right serial port you want to use. As soon as you select one element in the
    menu, the number of the element in the list is fired to its leftmost outlet. We
    prepend this number by port and send that to `[serial]`, setting it up to the
    right-hand serial port.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载此补丁，菜单就会填充，你只需选择你想要使用的正确串行端口。一旦在菜单中选择了一个元素，列表中该元素的编号就会触发到其最左侧出口。我们在这个数字前加上
    `port` 并将其发送到 `[serial]`，将其设置为右侧的串行端口。
- en: Polling system
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询系统
- en: One of the most used objects in Max 6 to send regular bangs in order to trigger
    things or count time is `[metro]`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6 中最常使用的对象之一 `[metro]` 用于发送定期的撞击以触发事物或计时。
- en: We have to use one argument at least; this is the time between two bangs in
    milliseconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少需要使用一个参数；这是两个撞击之间的时间间隔（以毫秒为单位）。
- en: Banging the `[serial]` object makes it pop out the values contained in its buffer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 撞击 `[serial]` 对象使其弹出其缓冲区中的值。
- en: If we want to send data continuously from Arduino and process them with Max
    6, activating the `[metro]` object is required. We then send a regular bang and
    can have an update of all the inputs read by Arduino inside our Max 6 patch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从 Arduino 连续发送数据并使用 Max 6 处理它们，则需要激活 `[metro]` 对象。然后我们发送一个定期的撞击，并可以在 Max
    6 补丁中更新所有由 Arduino 读取的输入。
- en: Choosing a value between 15 ms and 150 ms is good but depends on your own needs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 15 ms 到 150 ms 之间的值是好的，但取决于你的需求。
- en: Let's now see how we can read, parse, and select useful data being received
    from Arduino.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何读取、解析和选择从 Arduino 接收的有用数据。
- en: Parsing and selecting data coming from Arduino
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析和选择来自 Arduino 的数据
- en: First, I want to introduce you to a helper firmware inspired by the *Arduino2Max*
    page on the Arduino website but updated and optimized a bit by me. It provides
    a way to read all the inputs on your Arduino, to pack all the data read, and to
    send them to our Max 6 patch through the `[serial]` object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想向您介绍一个辅助固件，它灵感来源于 Arduino 网站上的 *Arduino2Max* 页面，但经过我的更新和优化。它提供了一种读取 Arduino
    上所有输入的方法，打包读取的所有数据，并通过 `[serial]` 对象将它们发送到我们的 Max 6 补丁。
- en: The readAll firmware
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReadAll 固件
- en: 'The following code is the firmware. You can find it in `Chapter12/ReadAll`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是固件。您可以在 `Chapter12/ReadAll` 中找到它：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For starters, we begin the serial communication at 9600 bauds in the `setup()`
    block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `setup()` 块中以 9600 波特率开始串行通信。
- en: As usual with serial communication handling, we check if there is something
    in the serial buffer of Arduino at first by using the `Serial.available()` function.
    If something is available, we check if it is the character `r`. Of course, we
    can use any other character. `r` here stands for read, which is basic. If an `r`
    is received, it triggers the read of both analog and digital ports. Each value
    (the `val` variable) is passed to the `sendValue()`function; this basically prints
    the value into the serial port and adds a space character in order to format things
    a bit to provide an easier parsing by Max 6\. We could easily adapt this code
    to only read some inputs and not all. We could also remove the `sendValue()` function
    and find another way of packing data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理串行通信一样，我们首先使用 `Serial.available()` 函数检查 Arduino 的串行缓冲区中是否有内容。如果有内容，我们检查它是否是字符
    `r`。当然，我们可以使用任何其他字符。这里的 `r` 代表读取，这是基本的。如果收到一个 `r`，它将触发读取模拟和数字端口。每个值（`val` 变量）都传递给
    `sendValue()` 函数；这基本上将值打印到串行端口，并添加一个空格字符以提供一些格式化，以便 Max 6 更容易解析。我们可以轻松地修改此代码以只读取一些输入而不是所有输入。我们还可以删除
    `sendValue()` 函数并找到另一种打包数据的方法。
- en: At the end, we push a carriage return to the serial port by using `Serial.println()`.
    This creates a separator between each pack of data that is sent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `Serial.println()` 将回车符推送到串行端口。这会在发送的每个数据包之间创建分隔符。
- en: Now, let's improve our Max 6 patch to handle this pack of data being received
    from Arduino.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改进我们的 Max 6 补丁，以处理从 Arduino 接收到的数据包。
- en: The ReadAll Max 6 patch
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReadAll Max 6 补丁
- en: 'The following screenshot is the `ReadAll` Max patch that provides a way to
    communicate with our Arduino:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是 `ReadAll` Max 补丁，它提供了一种与我们的 Arduino 通信的方法：
- en: '![The ReadAll Max 6 patch](img/7584_12_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![The ReadAll Max 6 patch](img/7584_12_002.jpg)'
- en: You can find this patch in the `Chapter12` folder. It is named `ReadAll.maxpat`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter12` 文件夹中找到此补丁。它命名为 `ReadAll.maxpat`。
- en: We added a couple of more things to the basic building blocks in the previous
    patch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的补丁中添加了一些基本构建块。
- en: Requesting data from Arduino
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Arduino 请求数据
- en: First, we will see a `[t b b]` object. It is also a trigger, ordering bangs
    provided by the `[metro]` object. Each bang received triggers another bang to
    another `[trigger]` object, then another one to the `[serial]` object itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到一个 `[t b b]` 对象。它也是一个触发器，由 `[metro]` 对象提供的 bang 信号。每个接收到的 bang 信号都会触发另一个
    bang 信号发送到另一个 `[trigger]` 对象，然后发送到 `[serial]` 对象本身。
- en: The `[t 13 r]` object can seem tricky. It just triggers a character `r` and
    then the integer `13`. The character `r` is sent to `[spell]` that converts it
    to ASCII code and then sends the result to `[serial]`. `13` is the ASCII code
    for a carriage return.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`[t 13 r]` 对象可能看起来有些复杂。它只是触发一个字符 `r` 然后整数 `13`。字符 `r` 被发送到 `[spell]`，它将其转换为
    ASCII 码，然后将结果发送到 `[serial]`。`13` 是回车符的 ASCII 码。'
- en: This structure provides a way to fire the character `r` to the `[serial]` object,
    which means to Arduino, each time that the metro bangs. As we already see in the
    firmware, it triggers Arduino to read all its inputs, then to pack the data, and
    then to send the pack to the serial port for the Max 6 patch.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构提供了一种将字符 `r` 发送到 `[serial]` 对象的方法，这意味着每次 `metro` 发出信号时，都会发送给 Arduino。正如我们在固件中已经看到的，它触发
    Arduino 读取所有输入，然后打包数据，最后将数据包发送到 Max 6 补丁的串行端口。
- en: 'To summarize what the metro triggers at each bang, we can write this sequence:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结 `metro` 在每个 bang 信号时触发的操作，我们可以写出以下序列：
- en: Send the character `r` to Arduino.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符 `r` 发送到 Arduino。
- en: Send a carriage return to Arduino.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 Arduino 发送回车符。
- en: Bang the `[serial]` object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发 `[serial]` 对象。
- en: This triggers Arduino to send back all its data to the Max patch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会触发 Arduino 将所有数据发送回 Max 补丁。
- en: Parsing the received data
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析接收到的数据
- en: Under the `[serial]` object, we can see a new structure beginning with the `[sel
    10 13]` object. This is an abbreviation for the `[select]` object. This object
    selects an incoming message and fires a bang to the specific output if the message
    equals the argument corresponding to the specific place of that output. Basically,
    here we select `10` or `13`. The last output pops the incoming message out if
    that one doesn't equal any argument.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[serial]` 对象下，我们可以看到一个以 `[sel 10 13]` 对象开始的新结构。这是 `[select]` 对象的缩写。此对象选择一个传入的消息，并在消息等于对应输出位置的参数时向特定输出发送一个
    bang 信号。基本上，这里我们选择了 `10` 或 `13`。最后一个输出如果传入的消息不等于任何参数，就会弹出该消息。
- en: Here, we don't want to consider a new line feed (ASCII code `10`). This is why
    we put it as an argument, but we don't do anything if that's the one that has
    been selected. It is a nice trick to avoid having this message trigger anything
    and even to not have it from the right output of `[select]`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不希望考虑新的换行符（ASCII代码 `10`）。这就是为什么我们将其作为参数，但如果选中的是这个，我们就不做任何事情。这是一个很好的技巧，可以避免这个消息触发任何事情，甚至从
    `[select]` 的右侧输出中消除它。
- en: Here, we send all the messages received from Arduino, except `10` or `13`, to
    the `[zl group 78]` object. The latter is a powerful list for processing many
    features. The `group` argument makes it easy to group the messages received in
    a list. The last argument is to make sure we don't have too many elements in the
    list. As soon as `[zl group]` is triggered by a bang *or* the list length reaches
    the length argument value, it pops out the whole list from its left outlet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从 Arduino 收到的所有消息（除了 `10` 或 `13`）发送到 `[zl group 78]` 对象。后者是一个强大的列表，用于处理许多功能。`group`
    参数使得将接收到的消息分组到列表中变得容易。最后一个参数是为了确保列表中元素的数量不会太多。一旦 `[zl group]` 被一个 bang 信号或列表长度达到长度参数值触发，它就会从其左侧出口弹出整个列表。
- en: Here, we "accumulate" all the messages received from Arduino, and as soon as
    a carriage return is sent (remember we are doing that in the last rows of the
    `loop()` block in the firmware), a bang is sent and all the data is passed to
    the next object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们“累积”从 Arduino 收到的所有消息，一旦发送了回车符（记住我们在固件 `loop()` 块的最后几行中做这件事），就会发送一个 bang
    信号，并将所有数据传递到下一个对象。
- en: We currently have a big list with all the data inside it, with each value being
    separated from the other by a space character (the famous ASCII code 32 we added
    in the last function of the firmware).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有一个包含所有数据的列表，每个值之间由一个空格字符（我们在固件中添加的著名的ASCII代码 32）分隔。
- en: This list is passed to the `[itoa]` object. **itoa** stands for *integer to
    ASCII*. This object converts integers to ASCII characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表被传递到 `[itoa]` 对象。**itoa** 代表 *整数到ASCII*。此对象将整数转换为ASCII字符。
- en: The `[fromsymbol]` object converts a symbol to a list of messages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`[fromsymbol]` 对象将符号转换为消息列表。'
- en: Finally, after this `[fromsymbol]` object we have our big list of values separated
    by spaces and totally readable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个 `[fromsymbol]` 对象之后，我们得到了一个由空格分隔的、完全可读的大值列表。
- en: We then have to unpack the list. `[unpack]` is a very useful object that provides
    a way to cut a list of messages into individual messages. We can notice here that
    we implemented exactly the opposite process in the Arduino firmware while we packed
    each value into a big message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须解包列表。`[unpack]` 是一个非常有用的对象，它提供了一种将消息列表切割成单个消息的方法。我们可以注意到，在这里，我们在 Arduino
    固件中实现了与打包每个值到一个大消息相反的过程。
- en: '`[unpack]` takes as many arguments as we want. It requires knowing about the
    exact number of elements in the list sent to it. Here we send 12 values from Arduino,
    so we put 12 `i` arguments. `i` stands for *integer*. If we send a float, `[unpack]`
    would cast it as an integer. It is important to know this. Too many students are
    stuck with troubleshooting this in particular.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`[unpack]` 可以接受我们想要的任意数量的参数。它需要知道发送给它的列表中确切元素的数量。这里我们发送了来自 Arduino 的 12 个值，所以我们放置了
    12 个 `i` 参数。`i` 代表 *整数*。如果我们发送一个浮点数，`[unpack]` 会将其转换为整数。了解这一点很重要。太多学生在这个问题上卡住了，特别是当他们在调试时。'
- en: We are only playing with the integer here. Indeed, the ADC of Arduino provides
    data from 0 to 1023 and the digital input provides 0 or 1 only.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只处理整数。实际上，Arduino 的 ADC 提供从 0 到 1023 的数据，而数字输入只提供 0 或 1。
- en: We attached a number box to each output of the `[unpack]` object in order to
    display each value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数字框连接到 `[unpack]` 对象的每个输出，以便显示每个值。
- en: Then we used a `[change]` object. This latter is a nice object. When it receives
    a value, it passes it to its output only if it is different from the previous
    value received. It provides an effective way to avoid sending the same value each
    time when it isn't required.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了 `[change]` 对象。这个对象很棒。当它接收到一个值时，只有当它与之前接收到的值不同时，它才会将其传递到其输出。它提供了一种有效的方法，以避免在不需要时每次都发送相同的值。
- en: Here, I chose the argument `-1` because this is not a value sent by the Arduino
    firmware, and I'm sure that the first element sent will be parsed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择了参数 `-1`，因为这不是Arduino固件发送的值，并且我确信发送的第一个元素将被解析。
- en: So we now have all our values available. We can use them for different jobs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以访问所有我们的值。我们可以用它们来完成不同的任务。
- en: But I propose to use a smarter way, and this will also introduce a new concept.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我建议使用一种更智能的方法，这也会引入一个新概念。
- en: Distributing received data and other tricks
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分发接收到的数据和其它技巧
- en: Let's introduce here some other tricks to improve our patching style.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里介绍一些其他技巧来改进我们的补丁风格。
- en: Cordless trick
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无线技巧
- en: We often have to use some data in our patches. The same data has to feed more
    than one object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在我们的补丁中使用一些数据。相同的数据需要为多个对象提供。
- en: A good way to avoid messy patches with a lot of cord and wires everywhere is
    to use the `[send]` and `[receive]` objects. These objects can be abbreviated
    with `[s]` and `[r]`, and they generate communication buses and provide a wireless
    way to communicate inside our patches.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 避免到处都是电线和电缆的杂乱无章的好方法是用 `[send]` 和 `[receive]` 对象。这些对象可以用 `[s]` 和 `[r]` 简写，并且它们生成通信总线，为我们提供在补丁内部无线通信的方式。
- en: '![Cordless trick](img/7584_12_003.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![无线技巧](img/7584_12_003.jpg)'
- en: These three structures are equivalent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个结构是等价的。
- en: The first one is a basic cord. As soon as we send data from the upper number
    box, it is transmitted to the one at the other side of the cord.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是基本的线缆。一旦我们从上面的数字框发送数据，它就会传输到线缆另一端。
- en: The second one generates a data bus named `busA`. As soon as you send data into
    `[send busA]`, each `[receive busA]` object in your patch will pop out that data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个生成一个名为 `busA` 的数据总线。一旦你将数据发送到 `[send busA]`，你的补丁中每个 `[receive busA]` 对象都会弹出该数据。
- en: The third example is the same as the second one, but it generates another bus
    named `busB`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子与第二个例子相同，但它生成另一个名为 `busB` 的总线。
- en: This is a good way to distribute data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种分发数据的好方法。
- en: I often use this for my master clock, for instance. I have one and only one
    master clock banging a clock to `[send masterClock]`, and wherever I need to have
    that clock, I use `[receive masterClock]` and it provides me with the data I need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常用它来作为我的主时钟，例如。我有一个且仅有一个主时钟在 `[send masterClock]` 上敲击时钟，无论我需要在哪里有那个时钟，我都使用
    `[receive masterClock]`，它为我提供所需的数据。
- en: If you check the global patch, you can see that we distribute data to the structures
    at the bottom of the patch. But these structures could also be located elsewhere.
    Indeed, one of the strengths of any visual programming framework such as Max 6
    is the fact that you can visually organize every part of your code exactly as
    you want in your patcher. And please, do that as much as you can. This will help
    you to support and maintain your patch all through your long development months.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查全局补丁，你可以看到我们将数据分发到补丁底部的结构。但这些结构也可以位于其他地方。实际上，任何视觉编程框架（如Max 6）的一个优势是，你可以在补丁器中直观地组织代码的每一部分，就像你想要的那样。请尽可能这样做。这将帮助你支持并维护你的补丁，在整个开发过程中。
- en: '![Cordless trick](img/7584_12_004.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![无线技巧](img/7584_12_004.jpg)'
- en: Check the previous screenshot. I could have linked the `[r A1]` object at the
    top left corner to the `[p process03]` object directly. But maybe this will be
    more readable if I keep the process chains separate. I often work this way with
    Max 6.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的截图。我本可以将左上角的 `[r A1]` 对象直接链接到 `[p process03]` 对象。但也许如果我将处理链保持分离，这将更容易阅读。我经常以这种方式使用Max
    6。
- en: This is one of the multiple tricks I teach in my Max 6 course. And of course,
    I introduced the `[p]` object, that is the `[patcher]` abbreviation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我Max 6课程中教授的多个技巧之一。当然，我也介绍了 `[p]` 对象，它是 `[patcher]` 的缩写。
- en: Let's check a couple of tips before we continue with some good examples involving
    Max 6 and Arduino.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续一些涉及Max 6和Arduino的好例子之前，让我们检查一些小贴士。
- en: Encapsulation and subpatching
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 封装和子补丁
- en: When you open Max 6 and go to **File** | **New Patcher**, it opens a blank patcher.
    The latter, if you recall, is the place where you put all the objects. There is
    another good feature named **subpatching** . With this feature, you can create
    new patchers inside patchers, and embed patchers inside patchers as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 Max 6 并转到 **文件** | **新建补丁器** 时，它会打开一个空白补丁器。如果你还记得，那里是你放置所有对象的地方。还有一个名为
    **子补丁** 的优秀功能。使用这个功能，你可以在补丁器内部创建新的补丁器，也可以在补丁器内部嵌入补丁器。
- en: A patcher contained inside another one is also named a subpatcher.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在其他补丁器内部的补丁器也被称为子补丁器。
- en: Let's see how it works with the patch named `ReadAllCutest.maxpat`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看名为 `ReadAllCutest.maxpat` 的补丁是如何工作的。
- en: '![Encapsulation and subpatching](img/7584_12_005.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_005.jpg)'
- en: There are four new objects replacing the whole structures we designed before.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个新的对象取代了我们之前设计的整个结构。
- en: These objects are subpatchers. If you double-click on them in **patch lock mode**
    or if you push the *command* key (or *Ctrl* for Windows), double-click on them
    in **patch edit mode** and you'll open them. Let's see what is there inside them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是子补丁器。如果你在 **补丁锁定模式** 中双击它们，或者如果你按住 *命令* 键（或 Windows 中的 *Ctrl*），在 **补丁编辑模式**
    中双击它们，你就可以打开它们。让我们看看里面有什么。
- en: '![Encapsulation and subpatching](img/7584_12_006.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_006.jpg)'
- en: The `[requester]` subpatcher contains the same architecture that we designed
    before, but you can see the brown **1** and **2** objects and another blue **1**
    object. These are inlets and outlets. Indeed, they are required if you want your
    subpatcher to be able to communicate with the patcher that contains it. Of course,
    we could use the `[send]` and `[receive]` objects for this purpose too. We are
    going to see that in the following pages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`[requester]` 子补丁器包含我们之前设计的相同架构，但你可以看到棕色 **1** 和 **2** 对象以及另一个蓝色 **1** 对象。这些是输入口和输出口。实际上，如果你想让你的子补丁器能够与包含它的补丁器通信，这些是必需的。当然，我们也可以使用
    `[send]` 和 `[receive]` 对象来达到这个目的。我们将在接下来的页面中看到这一点。'
- en: The position of these inlets and outlets in your subpatcher matters. Indeed,
    if you move the **1** object to the right of the **2** object, the numbers get
    swapped! And the different inlets in the upper patch get swapped too. You have
    to be careful about that. But again, you can organize them exactly as you want
    and need.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输入口和输出口在你子补丁器中的位置很重要。实际上，如果你将 **1** 对象移动到 **2** 对象的右边，数字就会交换！上补丁中的不同输入口也会交换。你必须小心这一点。但再次强调，你可以按照你想要的和需要的组织它们。
- en: 'Check the next screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 检查下一张截图：
- en: '![Encapsulation and subpatching](img/7584_12_006b.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_006b.jpg)'
- en: And now, check the root patcher containing this subpatcher. It automatically
    inverts the inlets, keeping things relevant.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查包含此子补丁器的根补丁器。它会自动反转输入口，保持相关。
- en: '![Encapsulation and subpatching](img/7584_12_006c.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_006c.jpg)'
- en: 'Let''s now have a look at the other subpatchers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看其他子补丁器：
- en: '![Encapsulation and subpatching](img/7584_12_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_007.jpg)'
- en: The [p portHandler] subpatcher
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[p portHandler] 子补丁器'
- en: '![Encapsulation and subpatching](img/7584_12_008.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_008.jpg)'
- en: The [p dataHandler] subpatcher
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[p dataHandler] 子补丁器'
- en: '![Encapsulation and subpatching](img/7584_12_009.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子补丁](img/7584_12_009.jpg)'
- en: The [p dataDispatcher] subpatcher
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[p dataDispatcher] 子补丁器'
- en: In the last figure, we can see only one inlet and no outlets. Indeed, we just
    encapsulated the global data dispatcher system inside the subpatcher. And this
    latter generates its data buses with `[send]` objects. This is an example where
    we don't need and even don't want to use outlets. Using outlets would be messy
    because we would have to link each element requesting this or that value from
    Arduino with a lot of cords.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一张图中，我们可以看到一个输入口而没有输出口。实际上，我们只是在子补丁器内部封装了全局数据分发系统。这个系统使用 `[send]` 对象生成其数据总线。这是一个我们不需要甚至不想使用输出口的例子。使用输出口会变得混乱，因为我们不得不使用很多电线将每个请求这个或那个值的
    Arduino 元素连接起来。
- en: In order to create a subpatcher, you only have to type `n` to create a new object,
    and type `p`, a space, and the name of your subpatcher.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个子补丁器，你只需输入 `n` 来创建一个新的对象，然后输入 `p`，一个空格，以及你的子补丁器名称。
- en: While I designed these examples, I used something that works faster than creating
    a subpatcher, copying and pasting the structure on the inside, removing the structure
    from the outside, and adding inlets and outlets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我设计这些示例时，我使用了一些比创建子补丁器、复制粘贴内部结构、从外部移除结构并添加输入口和输出口更快的方法。
- en: This feature is named encapsulate and is part of the **Edit** menu of Max 6.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能名为封装，是 Max 6 的 **编辑** 菜单的一部分。
- en: You have to select the part of the patch you want to encapsulate inside a subpatcher,
    then click on **Encapsulate**, and voilà! You have just created a subpatcher including
    your structures that are connected to inlets and outlets in the correct order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须选择要封装在子模块内的模块部分，然后点击 **封装**，哇！您已经创建了一个包含与输入和输出正确连接的结构子模块。
- en: '![Encapsulation and subpatching](img/7584_12_010.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![封装和子模块](img/7584_12_010.jpg)'
- en: Encapsulate and de-encapsulate features
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和解封装功能
- en: You can also de-encapsulate a subpatcher. It would follow the opposite process
    of removing the subpatcher and popping out the whole structure that was inside
    directly outside.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以解封装一个子模块。这将遵循与移除子模块和直接弹出内部整个结构相反的过程。
- en: Subpatching helps to keep things well organized and readable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块化有助于保持事物井然有序且易于阅读。
- en: We can imagine that we have to design a whole patch with a lot of wizardry and
    tricks inside it. This one is a processing unit, and as soon as we know what it
    does, after having finished it, *we don't want to know how it does it* but only
    *use it*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象，我们必须设计一个包含许多魔法和技巧的整个模块。这个是一个处理单元，一旦我们知道它做什么，完成之后，*我们不想知道它是如何做到的*，只想 *使用它*。
- en: This provides a nice abstraction level by keeping some processing units closed
    inside boxes and not messing the main patch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将一些处理单元保持在盒子内并不过度混乱主模块，提供了一个很好的抽象级别。
- en: You can copy and paste the subpatchers. This is a powerful way to quickly duplicate
    process units if you need to. But each subpatcher is totally independent of the
    others. This means that if you need to modify one because you want to update it,
    you'd have to do that individually in each subpatcher of your patch.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以复制和粘贴子模块。如果您需要快速复制处理单元，这是一个强大的方法。但每个子模块与其他子模块完全独立。这意味着，如果您需要修改一个以更新它，您必须在每个模块的子模块中单独进行。
- en: This can be really hard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能真的很难。
- en: Let me introduce you to the last pure Max 6 concept now named abstractions before
    I go further with Arduino.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我进一步介绍 Arduino 之前，让我先向您介绍最后一个纯 Max 6 概念，现在命名为抽象。
- en: Abstractions and reusability
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抽象和可重用性
- en: Any patch created and saved can be used as a new object in another patch. We
    can do this by creating a new object by typing `n` in a patcher; then we just
    have to type the name of our previously created and saved patch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任何创建并保存的模块都可以用作另一个模块中的新对象。我们可以通过在模块中键入 `n` 来创建一个新对象；然后我们只需键入之前创建并保存的模块的名称。
- en: A patch used in this way is called an **abstraction**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用的模块称为 **抽象**。
- en: In order to call a patch as an abstraction in a patcher, the patch has to be
    in the Max 6 *path* in order to be found by it. You can check the path known by
    Max 6 by going to **Options** | **File Preferences**. Usually, if you put the
    main patch in a folder and the other patches you want to use as abstractions in
    that same folder, Max 6 finds them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在模块中调用模块作为抽象，该模块必须位于 Max 6 的 *路径* 中，以便被找到。您可以通过转到 **选项** | **文件首选项** 来检查 Max
    6 所知的路径。通常，如果您将主模块放在一个文件夹中，并将您想要用作抽象的其他模块放在同一个文件夹中，Max 6 就能找到它们。
- en: The concept of abstraction in Max 6 itself is very powerful because it provides
    **reusability**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6 自身的抽象概念非常强大，因为它提供了 **可重用性**。
- en: Indeed, imagine you need and have a lot of small (or big) patch structures that
    you are using every day, every time, and in almost every project. You can put
    them into a specific folder on your disk included in your Max 6 path and then
    you can call (we say *instantiate*) them in every patch you are designing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，想象一下，您需要并且每天都在使用很多（或很大）的模块结构，几乎在每个项目中都会用到。您可以将它们放入您的磁盘上的一个特定文件夹中，该文件夹包含在您的
    Max 6 路径中，然后您可以在您设计的每个模块中调用（我们称之为 *实例化*）它们。
- en: Since each patch using it has only a reference to the one patch that was instantiated
    itself, you just need to improve your abstraction; each time you load a patch
    using it, the patch will have up-to-date abstractions loaded inside it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个使用它的模块只引用了实例化的那个模块，因此您只需改进您的抽象；每次您加载使用它的模块时，该模块将包含最新的抽象。
- en: It is really easy to maintain all through the development months or years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这在整个开发月份或年份中维护起来非常容易。
- en: Of course, if you totally change the abstraction to fit with a dedicated project/patch,
    you'll have some problems using it with other patches. You have to be careful
    to maintain even short documentation of your abstractions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您完全改变抽象以适应一个专用项目/补丁，您在使用其他补丁时可能会遇到一些问题。您必须小心，即使是非常简短的文档也要保持您的抽象。
- en: Let's now continue by describing some good examples with Arduino.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续描述一些与Arduino相关的良好示例。
- en: Creating a sound-level meter with LEDs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LED创建声音水平计
- en: This small project is a typical example of a Max 6/Arduino hardware and software
    collaboration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型项目是Max 6/Arduino硬件和软件协作的典型例子。
- en: Max can easily listen for sounds and convert them from the analog to the digital
    domain.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Max可以轻松监听声音并将它们从模拟域转换为数字域。
- en: We are going to build a small sound level visualizer using Arduino, some LEDs,
    and Max 6.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arduino、一些LED和Max 6构建一个小型声音水平可视化器。
- en: The circuit
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路
- en: We are going to use the same circuit we designed in [Chapter 8](ch08.html "Chapter 8. Designing
    Visual Output Feedback"), *Designing Visual Output Feedbacks*, while we multiplexed
    LEDs with a daisy chain of shift registers of the type 595.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第8章](ch08.html "第8章。设计视觉输出反馈")中设计的相同电路，*设计视觉输出反馈*，同时我们使用595类型移位寄存器的菊花链来多路复用LED。
- en: 'The following figure shows the circuit:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了电路：
- en: '![The circuit](img/7584_12_011.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![电路](img/7584_12_011.jpg)'
- en: Our double series of eight LEDs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的八LED双串
- en: '![The circuit](img/7584_12_012.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![电路](img/7584_12_012.jpg)'
- en: Our double series of eight LEDs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的八LED双串
- en: 'The basic idea is to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基本想法是：
- en: Use each series of eight LEDs for each sound channel (left and right)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每个声音通道（左和右）的每串八个LED
- en: Display the sound level all along the LED series
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在LED串中显示声音水平
- en: For each channel, the greater the number of LEDs switched on, the higher the
    sound level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个通道，开着的LED数量越多，声音水平就越高。
- en: Let's now check how we can handle this in Max 6 first.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何在Max 6中处理这个问题。
- en: The Max 6 patch for calculating sound levels
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算声音水平的Max 6补丁
- en: 'Have a look at the following figure showing the `SoundLevelMeters` patch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图，显示了 `SoundLevelMeters` 补丁：
- en: '![The Max 6 patch for calculating sound levels](img/7584_12_013.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![计算声音水平的Max 6补丁](img/7584_12_013.jpg)'
- en: Generating sounds and measuring sound levels
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 生成声音和测量声音水平
- en: We are using the MSP part of the Max 6 framework here that is related to sound
    signals. We have two sources (named `source 1` and `source 2`) in the patch. Each
    one generates two signals. I connected each one to one of the `[selector~ ]` objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用Max 6框架的MSP部分，这部分与声音信号相关。在补丁中，我们有两个源（命名为 `source 1` 和 `source 2`）。每个源生成两个信号。我将每个源连接到一个
    `[selector~ ]` 对象。
- en: Those latter are switches for signals. The source selector at the top left provides
    a way to switch between `source 1` and `source 2`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是用于信号的开关。左上角的源选择器提供了一个在 `source 1` 和 `source 2` 之间切换的方法。
- en: I won't describe the cheap wizardry of sound sources; it would involve having
    a knowledge of synthesis and that would be out of the scope of this topic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会描述声音源的低成本魔法；这将涉及对合成技术的了解，而这超出了本主题的范围。
- en: Then, we have a connection between each `[selector~ ]` output and a small symbol
    like a speaker. This is related to the sound output of your audio interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个连接到每个 `[selector~ ]` 输出和一个小符号，比如一个扬声器的连接。这与您音频接口的声音输出有关。
- en: I also used the `[meter~]` object to display the level of each channel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我还使用了 `[meter~]` 对象来显示每个通道的级别。
- en: At last, I added a `[flonum]` object to display the current value of the level
    each time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我添加了一个 `[flonum]` 对象来显示每次的级别当前值。
- en: These are the numbers we are going to send to Arduino.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要发送给Arduino的数字。
- en: Let's add the serial communication building blocks we already described.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们之前描述的串行通信构建块。
- en: '![The Max 6 patch for calculating sound levels](img/7584_12_014.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![计算声音水平的Max 6补丁](img/7584_12_014.jpg)'
- en: Sending data to Arduino
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 向Arduino发送数据
- en: We have our serial communication setup ready.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了串行通信设置。
- en: We also have the `[zmap 0\. 1\. 0 255]` objects. These take a value intended
    to be between `0\. 1`, as was set up in the arguments, and scale it to the range
    `0 255`. This provides a byte of data for each channel.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `[zmap 0\. 1\. 0 255]` 对象。这些对象接受一个值，该值旨在在 `0\. 1` 之间，正如在参数中设置的那样，并将其缩放到
    `0 255` 的范围。这为每个通道提供了一个字节数据。
- en: We are using two data buses to send a value from each channel to a `[pak]` object.
    The latter collects the incoming messages and creates a list with them. The difference
    between `[pack]` and `[pak]` is that `[pak]` sends data as soon as it receives
    a message in one of its inputs, not only when it receives a message of its left
    input, as with `[pack]`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个数据总线将每个通道的值发送到 `[pak]` 对象。后者收集传入的消息并创建一个包含它们的列表。`[pak]` 与 `[pack]` 的区别在于
    `[pak]` 在其任一输入接收到消息时就会发送数据，而不仅仅是当它接收到其左侧输入的消息时，就像 `[pack]` 一样。
- en: Thus, we have lists of messages that are popped out from the computer to Arduino
    as soon as the level values change.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了当电平值改变时，从计算机弹出到Arduino的消息列表。
- en: The firmware for reading bytes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于读取字节的固件
- en: 'Let''s see how to handle this in Arduino:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Arduino中处理这个问题：
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the same firmware as the one in [Chapter 8](ch08.html "Chapter 8. Designing
    Visual Output Feedback"), *Designing Visual Output Feedback*, except here we are
    pitreading real values and not generating random ones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[第8章](ch08.html "第8章. 设计视觉输出反馈")中的固件相同，*设计视觉输出反馈*，但在这里我们正在读取真实值而不是生成随机值。
- en: We are doing that with `Serial.parseInt()` in the `Serial.available()` test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Serial.parseInt()` 在 `Serial.available()` 测试中做这件事。
- en: This means that as soon as the data is in the Arduino serial buffer, we'll read
    it. Actually, we are reading two values and storing them, after a byte conversion,
    in `LeftChannel` and `RightChannel`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦数据进入Arduino串行缓冲区，我们就会读取它。实际上，我们正在读取两个值，并在字节转换后，将它们存储在`LeftChannel`和`RightChannel`中。
- en: We then process the data to the shift register to light the LEDs according to
    the value sent by the Max 6 patch.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将数据处理到移位寄存器中，根据Max 6补丁发送的值点亮LED。
- en: Let's take another example of playing with sound files and a distance sensor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个与声音文件和距离传感器玩耍的例子。
- en: Pitch shift effect controlled by hand
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手部控制的音调转换效果
- en: '**Pitch shifting** is a well-known effect in all fields related to sound processing.
    It changes the pitch of an incoming sound. Here we are going to implement a very
    cheap pitch shifter with Max 6, but we will focus on how to control this sound
    effect. We will control it by moving our hand over a distance sensor.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**音调转换**是所有与声音处理相关的领域都熟知的效果。它改变传入声音的音调。在这里，我们将使用Max 6实现一个非常便宜的音调转换器，但我们将关注如何控制这个声音效果。我们将通过在距离传感器上移动我们的手来控制它。'
- en: We are going to use the same circuit as the one in [Chapter 6](ch06.html "Chapter 6. Sensing
    the World – Feeling with Analog Inputs"), *Sense the World – Feeling with Analog
    Inputs*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[第6章](ch06.html "第6章. 感知世界 – 使用模拟输入进行感知")中相同的电路，即*感知世界 – 使用模拟输入进行感知*。
- en: The circuit with the sensor and the firmware
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有传感器和固件的电路
- en: 'The following circuit shows the Arduino board connected to a sensor:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下电路显示了Arduino板连接到传感器：
- en: '![The circuit with the sensor and the firmware](img/7584_12_015.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![带有传感器和固件的电路](img/7584_12_015.jpg)'
- en: The Sharp distance sensor connected to Arduino
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Arduino的Sharp距离传感器
- en: The firmware is almost the same too. I removed the part about the distance calculation
    because, indeed, we don't care about the distance itself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 固件几乎也是相同的。我移除了关于距离计算的部分，因为我们确实不关心距离本身。
- en: The ADC of Arduino provides a resolution of 10 bits, which will give numbers
    from 0 to 1023\. We are going to use this value to calibrate our system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino的ADC提供10位的分辨率，这将给出从0到1023的数字。我们将使用这个值来校准我们的系统。
- en: 'The following code is the firmware. You can find it in the `Chapter12/PitchShift`
    folder:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是固件。您可以在`Chapter12/PitchShift`文件夹中找到它：
- en: '[PRE2]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As soon as Arduino runs this firmware, it sends values to the serial port.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Arduino运行此固件，它就会向串行端口发送值。
- en: The patch for altering the sound and parsing Arduino messages
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于改变声音和解析Arduino消息的补丁
- en: I cannot describe the whole pitch shifter itself. By the way, you can open the
    related subpatch to see how it has been designed. Everything is open.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法描述整个音调转换器本身。顺便说一句，您可以打开相关的子补丁来查看它是如何设计的。一切都是开放的。
- en: '![The patch for altering the sound and parsing Arduino messages](img/7584_12_017.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![用于改变声音和解析Arduino消息的补丁](img/7584_12_017.jpg)'
- en: The pitch shifter controlled by your hand over the distance sensor
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过距离传感器控制的手部音调转换
- en: As we described before, we have to choose the right serial port and then bang
    the `[serial]` object in order to make it pop out the values in its buffer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前描述的，我们必须选择正确的串行端口，然后敲击 `[serial]` 对象，以便使其弹出其缓冲区中的值。
- en: Here, we are using the `[scale]` object. It is similar to `[zmap]`, which we
    already used, because it maps a range to another one but it can also work with
    inverted range and doesn't clip values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `[scale]` 对象。它与我们已经使用过的 `[zmap]` 类似，因为它可以将一个范围映射到另一个范围，但它也可以与反转范围一起工作，并且不会截断值。
- en: Here, I'm mapping values being received from the ADC of Arduino from 0 to 1023
    to something fitting our need from 12.0 to 0.5.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将从 Arduino 的 ADC 接收到的值从 0 到 1023 映射到适合我们需求的 12.0 到 0.5。
- en: If we place our hand close to the sensor, the distance is small, and if we move
    our hand further away, the distance changes and the effect is modulated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将手靠近传感器，距离就小，如果我们把手移远，距离就会改变，效果也会被调制。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us how to deal with Arduino using Max 6.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教我们如何使用 Max 6 处理 Arduino。
- en: We learnt a bit more about some usual techniques in Max 6, and we practiced
    some concepts previously learnt in this book. Obviously, there is more to learn
    in Max 6, and I'd like to give you some good pointers for better learning.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Max 6 中的一些常用技术有了更多的了解，并且我们练习了一些在这本书中学到的概念。显然，Max 6 中还有更多东西可以学习，我很乐意给你一些更好的学习指南。
- en: 'Firstly, I''d suggest you read *all* the tutorials, beginning with those about
    Max, then about MSP, and then about digital sound, and at last about Jitter if
    you are interested in visuals and OpenGL. That sounds obvious but I still have
    two or three persons a day asking me where to begin Max 6 from. The answer is:
    tutorials.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我建议你阅读 *所有* 的教程，从 Max 的教程开始，然后是 MSP，然后是数字声音，最后是如果你对视觉效果和 OpenGL 感兴趣的话，是 Jitter。听起来很明显，但我每天还是有两三个人问我从哪里开始学习
    Max 6。答案是：教程。
- en: Then, I'd suggest you design a small system. Less is definitely more. A small
    system provides easy ways to maintain, modify, and support. Using comments is
    also a nice way to quickly remember what you tried to do in this or that part.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我建议你设计一个小型系统。少即是多。小型系统提供了易于维护、修改和支持的便捷方式。使用注释也是一种快速记住你在这一部分或那一部分尝试做什么的好方法。
- en: Lastly, patching a bit everyday is the real key to success. It takes time, but
    don't we want to become masters?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每天稍微修补一下是成功的关键。这需要时间，但我们不是都想成为大师吗？
