- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Character Class Components and Blueprint Setup
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色类组件和蓝图设置
- en: In the previous chapter, we learned how to create empty projects and import
    files, which folder structure to use, and how to work with animations. In this
    chapter, we’ll explore some other key tools and functionality that you will work
    with when using Unreal Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建空项目、导入文件、使用哪种文件夹结构以及如何处理动画。在本章中，我们将探讨一些其他关键工具和功能，这些工具和功能是您在使用虚幻引擎时将与之合作的内容。
- en: Game developers often need to use certain tools that save them time and energy
    when building game functionality. Unreal Engine’s powerful object inheritance
    capabilities give developers the edge they need to be more efficient. Developers
    can also work with both C++ and Blueprints interchangeably and use them to their
    benefit when developing games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者经常需要使用某些工具，这些工具在构建游戏功能时可以节省他们时间和精力。虚幻引擎强大的对象继承功能为开发者提供了他们需要的优势，使他们更加高效。开发者还可以在
    C++ 和蓝图之间自由切换，并在游戏开发中充分利用它们。
- en: Another value-added benefit developers gain is the ability to extend code for
    use later in a project. Let’s say your client has new requirements that build
    upon the old ones (as is the case in most game studios). Now, to extend functionality,
    developers can just inherit a class and add more functionality to it to get results
    quickly. This is very powerful, and it comes in handy in many situations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者获得的其他增值好处之一是能够扩展代码以供项目后期使用。假设您的客户有新的需求，这些需求建立在旧需求的基础上（这在大多数游戏工作室中很常见）。现在，为了扩展功能，开发者只需继承一个类，并添加更多功能以快速获得结果。这非常强大，并且在许多情况下都很有用。
- en: This chapter will focus on the `Character` class in C++. You will be shown how
    to extend the `Character` class in C++ and then extend this newly created `Character`
    class further in Blueprints via inheritance. You will also work with player input
    and some movement logic. We will discuss the Unreal `Character` class, create
    C++ code, and then extend it in Blueprints, before finally using it to create
    an in-game character.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 C++ 中的 `Character` 类。您将学习如何扩展 C++ 中的 `Character` 类，然后通过继承在蓝图进一步扩展这个新创建的
    `Character` 类。您还将处理玩家输入和一些移动逻辑。我们将讨论虚幻引擎的 `Character` 类，创建 C++ 代码，然后在蓝图中进行扩展，最后使用它来创建游戏中的角色。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Unreal `Character` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚幻 `Character` 类
- en: Extending the C++ class with Blueprints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝图扩展 C++ 类
- en: By the end of this chapter, you will understand how class inheritance works
    in UE5 and how to utilize it to your advantage. You will also be able to work
    with Axis Mappings and Action Input Mappings, which are key in driving player-related
    input logic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 UE5 中类继承的工作原理以及如何利用它来获得优势。您还将能够处理轴映射和动作输入映射，这些在驱动玩家相关输入逻辑中至关重要。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Unreal Engine 5 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚幻引擎 5 已安装
- en: Visual Studio 2019 installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019 已安装
- en: The complete code for this chapter can be downloaded from GitHub at [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以从 GitHub 下载，网址为 [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: The Unreal Character class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻角色类
- en: Before we talk about the Unreal `Character` class, let’s briefly touch on the
    concept of inheritance. If you’re used to working with C++ or another similar
    language, you should already be familiar with this concept. Inheritance is the
    process whereby a class derives characteristics and behavior from another class.
    A C++ class can be extended to create a new class – a derived class – that retains
    properties of the base class and allows these properties to be modified or new
    characteristics to be added. An example of this is the `Character` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论虚幻引擎的 `Character` 类之前，让我们简要地谈谈继承的概念。如果您习惯于使用 C++ 或其他类似的语言，您应该已经熟悉这个概念。继承是一个类从另一个类继承特性和行为的过程。一个
    C++ 类可以被扩展以创建一个新的类——一个派生类——它保留了基类的属性，并允许修改这些属性或添加新特性。`Character` 类就是一个例子。
- en: The `Character` class is a special type of pawn and is a descendant of the Unreal
    `Pawn` class. Extending upon the `Pawn` class, the `Character` class has some
    movement capabilities by default, along with some inputs that add movement to
    the character. As standard, the `Character` class gives users the ability to get
    a character to walk, run, jump, fly, and swim within the created world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`类是一种特殊的pawn类型，是Unreal `Pawn`类的后代。在`Pawn`类的基础上扩展，`Character`类默认具有一些运动能力，以及一些为角色添加运动的输入。按照标准，`Character`类为用户提供在创建的世界中使角色行走、奔跑、跳跃、飞行和游泳的能力。'
- en: Since the `Character` class is an extension of the `Pawn` class, it contains
    all the code/logic of the pawn, and developers can extend this class to add more
    functionality to it. When extending the `Character` class, its existing components
    get carried over to the extended class as inherited components (in this case,
    the Capsule, Arrow, and Mesh components).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Character`类是`Pawn`类的扩展，它包含所有pawn的代码/逻辑，开发者可以扩展此类以添加更多功能。当扩展`Character`类时，其现有组件作为继承组件（在这种情况下，是胶囊、箭头和网格组件）被带到扩展类中。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Inherited components cannot be removed. Their settings may be changed, but a
    component that’s added to a base class will always be present in the extended
    class. In this case, the base class is the `Pawn` class, while the extended (or
    child) class is the `Character` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的组件不能被删除。它们的设置可以更改，但添加到基类的组件将始终存在于扩展类中。在这种情况下，基类是`Pawn`类，而扩展（或子）类是`Character`类。
- en: 'The `Character` class provides the following inherited components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`类提供了以下继承组件：'
- en: '**Capsule component**: This is the root component that serves as the “origin”
    that other components get attached to within the hierarchy. This component can
    also be used for collisions and takes the form of a capsule that logically outlines
    many character forms (especially humanoid ones).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胶囊组件**：这是作为其他组件在层次结构中附加到的“原点”的根组件。此组件也可以用于碰撞，并以胶囊的形式逻辑上概述许多角色形式（尤其是人类角色）。'
- en: '`hide` when the game starts, but it can be tweaked to be visible. This component
    can be useful for debugging and adjusting game logic if required.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时`hide`，但可以进行调整以使其可见。如果需要，此组件对于调试和调整游戏逻辑可能很有用。
- en: '`Character` class. The Skeletal Mesh, which is the form the character will
    take, can be set up here, along with all the relevant variables, including animations,
    collisions, and so on.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character`类。在这里可以设置角色将采取的骨骼网格形式，以及所有相关变量，包括动画、碰撞等。'
- en: Most developers usually prefer to code the game and character logic in C++ and
    extend that class to Blueprints so that they can perform other simple tasks, such
    as connecting assets to the class. So, for example, a developer may create a C++
    class that inherits from the `Character` class, write all the movement and jumping
    logic within that class, and then extend this class with a Blueprint, in which
    the developer updates the components with the required assets (such as the Skeletal
    Mesh and animation blueprint), and optionally code additional functionality into
    blueprints.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者通常更喜欢用C++编写游戏和角色逻辑，并将该类扩展到蓝图，以便他们可以执行其他简单任务，例如将资产连接到类。例如，开发者可能创建一个从`Character`类继承的C++类，在该类中编写所有运动和跳跃逻辑，然后使用蓝图扩展此类，其中开发者更新组件以使用所需的资产（如骨骼网格和动画蓝图），并且可选地在蓝图中添加额外的功能。
- en: Extending the Character class
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展`Character`类
- en: The `Character` class is extended when it is inherited by either C++ or Blueprints.
    This extended `Character` class will be a child of the `Character` class (*which
    will be called its parent*). Extending classes is a powerful part of object-oriented
    programming, and classes can be extended to great depths and hierarchies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Character`类被C++或蓝图继承时，它会被扩展。这个扩展的`Character`类将是`Character`类的子类（它将被称为其父类）。扩展类是面向对象编程的强大功能之一，类可以被扩展到很深的层次和层级。
- en: Exercise 3.01 – creating and setting up a third-person Character C++ class
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3.01 – 创建和设置第三人称`Character` C++类
- en: In this exercise, you will create a C++ class based on a `Character` class.
    You will also initialize the variables that will be set in the default values
    for the class that will extend this `Character` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个基于`Character`类的C++类。你还将初始化将设置在扩展此`Character`类的类的默认值中的变量。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Launch Unreal Engine, select the **Games** category, and click the **Next**
    button.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Unreal Engine，选择 **游戏** 类别，然后点击 **下一步** 按钮。
- en: Select **Blank** and click the **Next** button.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **空白** 并点击 **下一步** 按钮。
- en: Choose `MyThirdPerson`, choose a suitable project directory, and click the **Create
    Project** button.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `MyThirdPerson`，选择一个合适的项目目录，然后点击 **创建项目** 按钮。
- en: Right-click in the **Content Browser** area and click the **New C++ Class**
    button.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容浏览器** 区域右键单击，然后点击 **新建C++类** 按钮。
- en: In the dialog box that opens, select `Character` as the class type and click
    the **Next** button.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，选择 `Character` 作为类类型，然后点击 **下一步** 按钮。
- en: Name it `MyThirdPersonChar` and click the **Create Class** button.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为 `MyThirdPersonChar` 并点击 **创建类** 按钮。
- en: Upon doing so, Visual Studio will open the `MyThirdPersonChar.cpp` and `MyThirdPersonChar.h`
    tabs.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作后，Visual Studio 将打开 `MyThirdPersonChar.cpp` 和 `MyThirdPersonChar.h` 选项卡。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On some systems, you might be required to run the Unreal Engine editor with
    administrator privileges to automatically open the Visual Studio solution with
    the newly created C++ files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，您可能需要以管理员权限运行 Unreal Engine 编辑器，以自动打开包含新创建的 C++ 文件的 Visual Studio 解决方案。
- en: 'Open the `MyThirdPersonChar.h` tab and add the following code under the `GENERATED_BODY()`
    text:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MyThirdPersonChar.h` 选项卡，并在 `GENERATED_BODY()` 文本之下添加以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we’re declaring two components: the `Camera` component
    itself and `Camera boom`, which acts as the placeholder for the camera at a certain
    distance from the player. These components will be initialized in the constructor
    in *step 11*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了两个组件：`Camera` 组件本身和 `Camera boom`，它作为距离玩家一定距离的相机占位符。这些组件将在构造函数中的
    *第11步* 初始化。
- en: 'Add the following `#include` statements under `#include “CoreMinimal.h”`, in
    the `MyThirdPersonChar.h` file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyThirdPersonChar.h` 文件中，在 `#include “CoreMinimal.h”` 之下添加以下 `#include` 语句：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, go to the `MyThirdPersonChar.cpp` tab and add the following `#include`
    statements after the `#include MyThirdPersonChar.h` code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 `MyThirdPersonChar.cpp` 选项卡，并在 `#include MyThirdPersonChar.h` 代码之后添加以下
    `#include` 语句：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code adds the relevant classes to the class, which means we now
    have access to its methods and definitions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将相关类添加到类中，这意味着我们现在可以访问其方法和定义。
- en: 'In the `AMyThirdPersonChar::AMyThirdPersonChar()` function, add the following
    lines:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AMyThirdPersonChar::AMyThirdPersonChar()` 函数中，添加以下行：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last line of the preceding code snippet will set up the camera to bind its
    rotation with the pawns’. This means that the camera should, in turn, rotate based
    on the rotation of the player controller that’s associated with this pawn.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的最后一行将设置相机，使其旋转与 pawns 的旋转绑定。这意味着相机应该根据与该 pawn 关联的玩家控制器的旋转进行旋转。
- en: 'Head back to the Unreal Engine project and click the **Compile** icon button
    on the top bar:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unreal Engine 项目并点击顶部栏上的 **编译** 图标按钮：
- en: '![Figure 3.1 – The Compile button on the top bar of Unreal Editor ](img/Figure_3.01_B18531.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Unreal Editor 顶部栏上的编译按钮](img/Figure_3.01_B18531.jpg)'
- en: Figure 3.1 – The Compile button on the top bar of Unreal Editor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Unreal Editor 顶部栏上的编译按钮
- en: A Live coding succeeded message should appear at the bottom right.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在右下角出现一个“Live coding succeeded”消息。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the completed exercise code files on GitHub, in the `Chapter03`
    | `Exercise3.01` directory, at [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上的 `Chapter03` | `Exercise3.01` 目录中找到完成的练习代码文件，网址为 [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01)。
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` so that it can
    build the necessary intermediate files, after which it should open the project
    in Unreal Editor automatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 `.rar` 文件后，双击 `.uproject` 文件。您将看到一个提示，询问“您现在要重建吗？”点击 **是** 以便它构建必要的中间文件，之后它应该自动在
    Unreal Editor 中打开项目。
- en: By completing this exercise, you’ve learned how to extend the `Character` class.
    You have also learned how to initialize the default components of the `Character`
    class and how to compile the updated code from within Unreal Editor. Next, you
    will learn how to extend the C++ class you created in Blueprints and why that
    is feasible in many situations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经学会了如何扩展“Character”类。你还学会了如何初始化“Character”类的默认组件以及如何在Unreal编辑器内编译更新后的代码。接下来，你将学习如何扩展在蓝图中所创建的C++类，以及为什么这在许多情况下是可行的。
- en: Extending the C++ class with Blueprints
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝图扩展C++类
- en: As mentioned earlier, most developers extend the C++ code logic to blueprints
    to link this with the assets they will use. This is done to achieve easy asset
    assignment compared to finding and setting up the asset in code. Furthermore,
    it allows developers to use powerful blueprint features such as Timelines, Events,
    and ready-to-use macros, in combination with their C++ code, to achieve the maximum
    benefit of developing with both C++ and Blueprints.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数开发者将C++代码逻辑扩展到蓝图，以便将其与将要使用的资产链接起来。这样做是为了实现与在代码中查找和设置资产相比的简单资产分配。此外，它允许开发者使用诸如时间轴、事件和可用的宏等强大的蓝图功能，与他们的C++代码结合使用，以实现使用C++和蓝图开发的最佳效益。
- en: So far, we have made a C++ `Character` class. In it, we have set up components
    and movement capabilities. Now, we want to specify the assets that are going to
    be used in our class, as well as add input and movement ability. For this, it
    is easier to extend with Blueprint and set up the options there. This is what
    we will be doing in the next exercise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个C++ `Character`类。在其中，我们设置了组件和运动能力。现在，我们想要指定我们将在类中使用的资产，以及添加输入和运动能力。为此，使用蓝图扩展并设置选项会更简单。这就是我们将在下一个练习中要做的。
- en: Exercise 3.02 – extending C++ with Blueprints
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3.02 – 使用蓝图扩展C++
- en: In this exercise, you will learn how to extend the C++ class you created with
    Blueprints to add Blueprint code on top of the pre-existing C++ code. You will
    also be adding input key bindings, which will be responsible for moving the character.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何使用蓝图扩展你创建的C++类，以在现有的C++代码之上添加蓝图代码。你还将添加输入键绑定，这将负责移动角色。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Download and extract the contents of the `Chapter03/Exercise3.02/ExerciseFiles`
    directory, which can be found on GitHub.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压GitHub上可找到的`Chapter03/Exercise3.02/ExerciseFiles`目录的内容。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ExerciseFiles` directory can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “ExerciseFiles”目录可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles)。
- en: Browse to the `Content` folder inside the **MyThirdPerson** project we created
    in *Exercise 3.01 – creating and setting up a third-person Character C++ class*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到我们在“3.01 – 创建和设置第三人称Character C++类”练习中创建的**MyThirdPerson**项目内的“Content”文件夹。
- en: Copy the `MixamoAnimPack` folder we created in *step 1* and paste it into the
    `Content` folder directory we opened in *step 2*, as shown in the following screenshot:![Figure
    3.2 – MixamoAnimPack placed in the project directory ](img/Figure_3.02_B18531.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在*步骤1*中创建的`MixamoAnimPack`文件夹复制并粘贴到我们在*步骤2*中打开的“Content”文件夹目录中，如图所示：![图3.2
    – MixamoAnimPack放置在项目目录中](img/Figure_3.02_B18531.jpg)
- en: Figure 3.2 – MixamoAnimPack placed in the project directory
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – MixamoAnimPack放置在项目目录中
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `MixamoAnimPack` assets were obtained from the Epic marketplace via the
    following link: [https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack](https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixamoAnimPack`资产是通过以下链接从Epic市场获得的：[https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack](https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack)。'
- en: Open the project. Right-click inside the `Blueprint Class`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目。在“蓝图类”内部右键点击。
- en: 'In the `GameMode`, right-click the class matching the name, and click the **Select**
    button. Have a look at the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“GameMode”中，右键点击与名称匹配的类，然后点击**选择**按钮。查看以下截图：
- en: '![Figure 3.3 – Creating the GameMode class ](img/Figure_3.03_B18531.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 创建GameMode类](img/Figure_3.03_B18531.jpg)'
- en: Figure 3.3 – Creating the GameMode class
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 创建GameMode类
- en: Name the blueprint we created in *step 6* `BP_GameMode`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在*步骤6*中创建的蓝图命名为`BP_GameMode`。
- en: Now, repeat *step 5*.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重复*步骤5*。
- en: In the `MyThirdPersonChar`, select the class, and then right-click on the **Select**
    button.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyThirdPersonChar`中，选择类，然后右键点击**选择**按钮。
- en: Name the blueprint we created in *step 9* `BP_MyTPC`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在*步骤9*中创建的蓝图命名为`BP_MyTPC`。
- en: 'In the **World Settings** tab, click the **None** option next to **GameMode
    Override** and select **BP_GameMode**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**世界设置**选项卡中，点击**GameMode Override**旁边的**None**选项，并选择**BP_GameMode**：
- en: '![Figure 3.4 – Specifying Game Mode in World Settings](img/Figure_3.04_B18531.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 在世界设置中指定游戏模式](img/Figure_3.04_B18531.jpg)'
- en: Figure 3.4 – Specifying Game Mode in World Settings
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 在世界设置中指定游戏模式
- en: 'Set `BP_MyTPC`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`BP_MyTPC`：
- en: '![Figure 3.5 – Specifying Default Pawn Class in Game Mode ](img/Figure_3.05_B18531.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 在游戏模式中指定默认Pawn类](img/Figure_3.05_B18531.jpg)'
- en: Figure 3.5 – Specifying Default Pawn Class in Game Mode
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 在游戏模式中指定默认Pawn类
- en: Open **BP_MyTPC** and click on the **Mesh (Inherited)** component in the hierarchy
    of the **Components** tab on the left-hand side.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**BP_MyTPC**，并在左侧**组件**选项卡的层次结构中点击**Mesh (Inherited)**组件。
- en: In the **Details** tab, find the **Mesh** section and set **Skeletal Mesh**
    to **Maximo_Adam**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**选项卡中，找到**网格**部分，并将**骨骼网格**设置为**Maximo_Adam**。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Meshes and Animations will be covered in depth in [*Chapter 11*](B18531_11.xhtml#_idTextAnchor222)*,
    Working with Blend Space 1D, Key Bindings, and State Machines*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B18531_11.xhtml#_idTextAnchor222)*，使用1D混合空间、按键绑定和状态机*中将对网格和动画进行深入探讨。
- en: 'In the `_C` when selected. This is the instance of the blueprint that was created
    by UE5\. Blueprints, in a working project/build, usually get suffixed this way
    to differentiate between a Blueprint class and an instance of that class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选中时，这是由UE5创建的蓝图实例。在正常的项目/构建中，蓝图通常以这种方式添加后缀，以区分蓝图类和该类的实例：
- en: '![Figure 3.6 – Setting up Anim Class and Skeletal Mesh ](img/Figure_3.06_B18531.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 设置动画类和骨骼网格](img/Figure_3.06_B18531.jpg)'
- en: Figure 3.6 – Setting up Anim Class and Skeletal Mesh
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 设置动画类和骨骼网格
- en: From the top-most menu, go to the **Edit** drop-down and click **Project Settings**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最顶部的菜单中，转到**编辑**下拉菜单并点击**项目设置**。
- en: 'Click on the **Input** section, which can be found in the **Engine** section:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**输入**部分，它位于**引擎**部分：
- en: '![Figure 3.7 – The Input section of Project Settings ](img/Figure_3.07_B18531.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 项目设置的输入部分](img/Figure_3.07_B18531.jpg)'
- en: Figure 3.7 – The Input section of Project Settings
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 项目设置的输入部分
- en: In the **Bindings** section, click the **+** icon next to **Axis Mappings**
    and expand the section.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**绑定**部分，点击**Axis Mappings**旁边的**+**图标并展开该部分。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`jump`, `dash`, or `run`, while **Axis Mappings** are float values that are
    assigned that will return a floating-point value based on the keypress of the
    user. This is more relevant in the case of gamepad controllers or VR controllers,
    where the analog thumb stick comes into play. In that case, it would return the
    floating value of the state of the thumb stick, which is very important for managing
    player movement or related functionalities.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump`、`dash`或`run`，而**轴映射**是浮点值，根据用户的按键返回一个浮点值。这在游戏手柄控制器或VR控制器的情况下更为相关，其中模拟拇指杆发挥作用。在这种情况下，它将返回拇指杆状态的浮点值，这对于管理玩家移动或相关功能非常重要。'
- en: Rename `MoveForward`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名`MoveForward`。
- en: In the `W`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`W`。
- en: Click the **+** icon next to the **MoveForward** icon to add another field.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**图标，它在**MoveForward**图标旁边，以添加另一个字段。
- en: Set the new field to `S`. Set its scale to `-1.0` (since we want to move backward
    with the `S` key).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新字段设置为`S`。将其比例设置为`-1.0`（因为我们想通过`S`键向后移动）。
- en: 'Create another axis mapping by repeating *step 18*, name it `MoveRight`, and
    add two fields – `A` with `-1.0` for the scale and `D` with `1.0` for the scale:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重复*步骤18*创建另一个轴映射，将其命名为`MoveRight`，并添加两个字段 – `A`的比例为`-1.0`，`D`的比例为`1.0`：
- en: '![Figure 3.8 – Movement Axis Mappings ](img/Figure_3.08_B18531.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 移动轴映射](img/Figure_3.08_B18531.jpg)'
- en: Figure 3.8 – Movement Axis Mappings
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 移动轴映射
- en: 'Open **BP_MyTPC** and click the **Event Graph** tab:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**BP_MyTPC**并点击**事件图**选项卡：
- en: '![Figure 3.9 – The Event Graph tab ](img/Figure_3.09_B18531.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 事件图选项卡](img/Figure_3.09_B18531.jpg)'
- en: Figure 3.9 – The Event Graph tab
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 事件图选项卡
- en: 'Right-click anywhere inside the graph, type `MoveForward`, and select the first
    node option:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中任何地方右键单击，输入“MoveForward”，并选择第一个节点选项：
- en: '![Figure 3.10 – The MoveForward Axis Event ](img/Figure_3.10_B18531.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 前进轴事件](img/Figure_3.10_B18531.jpg)'
- en: Figure 3.10 – The MoveForward Axis Event
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 前进轴事件
- en: Right-click inside the graph, search for **Get Control Rotation**, and select
    the first node option.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中右键单击，搜索“**Get Control Rotation**”，并选择第一个节点选项。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Since the camera associated with a player can choose not to show the pawn’s
    yaw, roll, or pitch, `Get Control Rotation` gives the pawn full aim rotation.
    This is useful in many calculations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与玩家关联的摄像头可以选择不显示骰子的偏航、翻滚或俯仰，`Get Control Rotation`提供了骰子的完整瞄准旋转。这在许多计算中很有用。
- en: Left-click and drag from **Return Value** of the **Get Control Rotation** node,
    search for **Break Rotator**, and select it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**Get Control Rotation**”节点的“**返回值**”上左键单击并拖动，搜索“**Break Rotator**”，然后选择它。
- en: Right-click inside the graph, search for **Make Rotator**, and select the first
    node option.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中右键单击，搜索“**Make Rotator**”，并选择第一个节点选项。
- en: Connect the `Z` (*yaw*) node from `Z` (*yaw*) node of **Make Rotator**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“**Make Rotator**”的“Z（偏航）”节点连接到“**Make Rotator**”的“Z（偏航）”节点。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '**Make Rotator** creates a rotator with the pitch, roll, and yaw values, while
    the break rotator splits a rotator into its components (roll, pitch, and yaw).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建旋转器**创建一个具有俯仰、翻滚和偏航值的旋转器，而断开旋转器将旋转器分解为其组件（翻滚、俯仰和偏航）。'
- en: Left-click and drag from **Return Value** of the **Make Rotator** node, search
    for **Get Forward Vector**, and select it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**Make Rotator**”节点的“**返回值**”上左键单击并拖动，搜索“**Get Forward Vector**”，然后选择它。
- en: Left-click and drag from **Return Value** of the **Get Forward Vector** node,
    search for **Add Movement Input**, and select it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**获取前向向量**”节点的“**返回值**”上左键单击并拖动，搜索“**添加运动输入**”，然后选择它。
- en: Connect the **Axis Value** node from the **InputAxis MoveForward** node to the
    **Scale Value** node in the **Add Movement Input** node.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“**InputAxis MoveForward**”节点的**轴值**节点连接到“**添加运动输入**”节点中的**缩放值**节点。
- en: Finally, connect the white **Execution** pin from the **InputAxis MoveForward**
    node to the **Add Movement Input** node.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“**InputAxis MoveForward**”节点的白色**执行**引脚连接到**添加运动输入**节点。
- en: Right-click inside the graph, search for **InputAxis MoveRight**, and select
    the first node option.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中右键单击，搜索“**InputAxis MoveRight**”，并选择第一个节点选项。
- en: Left-click and drag from **Return Value** of the **Make Rotator** node, search
    for **Get Right Vector**, and select it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**Make Rotator**”节点的“**返回值**”上左键单击并拖动，搜索“**Get Right Vector**”，然后选择它。
- en: Left-click and drag from **Return Value** of the **Get Right Vector** node,
    search for **Add Movement Input**, and select it.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**获取右向量**”节点的“**返回值**”上左键单击并拖动，搜索“**添加运动输入**”，然后选择它。
- en: Connect the **Axis Value** pin from the **InputAxis MoveRight** node to the
    **Scale Value** pin in the **Add Movement Input** node we created in the previous
    step.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“**InputAxis MoveRight**”节点的**轴值**引脚连接到我们在上一步中创建的**添加运动输入**节点中的**缩放值**引脚。
- en: 'Finally, connect the **white Execution** pin from the **InputAxis MoveRight**
    node to the **Add Movement Input** node we added in *step 36*:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“**InputAxis MoveRight**”节点的白色**执行**引脚连接到我们在*步骤 36*中添加的**添加运动输入**节点：
- en: '![Figure 3.11 – Movement logic ](img/Figure_3.11_B18531.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 运动逻辑](img/Figure_3.11_B18531.jpg)'
- en: Figure 3.11 – Movement logic
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 运动逻辑
- en: 'Now, head to the `Mesh` component and select the object translation node located
    at the top of the viewport. Then, drag the arrows on the Mesh to adjust it so
    that the feet align with the bottom of the capsule component and the Mesh is rotated
    to point toward the arrow:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到“**网格**”组件，选择视图中顶部的对象平移节点。然后，拖动网格上的箭头以调整它，使脚与胶囊组件的底部对齐，并将网格旋转以指向箭头：
- en: '![Figure 3.12 – The Translation Rotation and Scale Selector section](img/Figure_3.12_B18531.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 翻译旋转和缩放选择器部分](img/Figure_3.12_B18531.jpg)'
- en: Figure 3.12 – The Translation Rotation and Scale Selector section
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 翻译旋转和缩放选择器部分
- en: 'Once the character is aligned in the capsule, it will look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦角色在胶囊内对齐，它将如下所示：
- en: '![Figure 3.13 – Mesh adjusted within the capsule component ](img/Figure_3.13_B18531.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 胶囊组件内的网格调整](img/Figure_3.13_B18531.jpg)'
- en: Figure 3.13 – Mesh adjusted within the capsule component
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 胶囊组件内的网格调整
- en: In the **Toolbar** menu, press the **Compile** button and then **Save**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具栏**菜单中，按**编译**按钮，然后**保存**。
- en: Go back to the map tab and press the **Play** button to view your character
    in-game. Use the *W*, *A*, *S*, and *D* keys to move around.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回地图标签页并按下**播放**按钮以查看游戏中的角色。使用 *W*、*A*、*S* 和 *D* 键进行移动。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the completed exercise code files on GitHub, in the `Chapter03`
    | `Exercise3.02` directory, at [https://packt.live/3keGxIU](https://packt.live/3keGxIU).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上的 `Chapter03` | `Exercise3.02` 目录中找到完成的练习代码文件，网址为 [https://packt.live/3keGxIU](https://packt.live/3keGxIU)。
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 `.rar` 文件后，双击 `.uproject` 文件。你将看到一个提示要求“现在要重建吗？”。点击提示中的“是”，以便它构建必要的中间文件，之后它应该会自动在
    Unreal 编辑器中打开项目。
- en: By completing this exercise, you know how to extend C++ code with Blueprints,
    and why that is favorable in many situations for developers. You also learned
    how to add input mappings and how they are used to drive player-related input
    logic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你将了解如何使用蓝图扩展 C++ 代码，以及为什么这在许多情况下对开发者来说是有利的。你还学习了如何添加输入映射以及它们是如何用来驱动与玩家相关的输入逻辑的。
- en: In the activity for this chapter, you will be combining the skills you have
    gained from the previous exercises of this chapter and extending the project you
    completed in *Activity 2.01 – linking animations to a character* of [*Chapter
    2*](B18531_02.xhtml#_idTextAnchor043), *Working with Unreal Engine*. This will
    allow you to build on your own Blueprint and see how that maps to real-world scenarios.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的活动中，你将结合从本章之前练习中获得的技术，扩展你在 *活动 2.01 – 将动画链接到角色* 中完成的 *第 2 章*（[B18531_02.xhtml#_idTextAnchor043]）*使用
    Unreal Engine 工作时* 的项目。这将使你能够基于自己的蓝图并看到它是如何映射到现实世界场景的。
- en: Activity 3.01 – extending the C++ Character class with Blueprints in the Animation
    project
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动三.01 – 在动画项目中使用蓝图扩展 C++ 字符类
- en: Now that you’ve created a C++ class and extended it with Blueprints, it is time
    to bring both concepts together in a real-world scenario. In this activity, you
    will be making our character from *Activity 2.01 – linking animations to a character*,
    which can be found in [*Chapter 2*](B18531_02.xhtml#_idTextAnchor043), *Working
    with Unreal Engine*, jump using the spacebar key on your keyboard. However, you
    need to create the `Character` class from scratch in C++ and then later extend
    it with Blueprint to reach the final goal.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个 C++ 类并使用蓝图扩展了它，现在是时候将这两个概念在一个现实世界场景中结合起来。在这个活动中，你将使 *活动 2.01 – 将动画链接到角色*
    中的角色跳跃，该活动可以在 *第 2 章*（[B18531_02.xhtml#_idTextAnchor043]）*使用 Unreal Engine 工作时*
    中找到。然而，你需要从头开始在 C++ 中创建 `Character` 类，然后稍后使用蓝图扩展以达到最终目标。
- en: 'Follow these steps to complete this activity:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Open the project from *Activity 2.01– linking animations to a character*.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *活动 2.01–将动画链接到角色* 打开项目。
- en: Create a `Character` class in C++ that will initialize the character variables,
    including the camera associated with the player.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C++ 中创建一个 `Character` 类，该类将初始化角色变量，包括与玩家关联的摄像头。
- en: Map the `Jump` input to the spacebar key in the project settings.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中将 `Jump` 输入映射到空格键。
- en: Extend the created C++ class with a blueprint to add the associated assets and
    jump functionality.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用蓝图扩展创建的 C++ 类以添加相关资源和跳跃功能。
- en: '**Expected Output**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**'
- en: 'The character should be able to jump when you press the spacebar key. The level
    should use the Blueprint that extends the C++ `Character` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下空格键时，角色应该能够跳跃。该关卡应使用扩展 C++ `Character` 类的蓝图：
- en: '![Figure 3.14 – Ganfault jump activity expected output ](img/Figure_3.14_B18531.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – Ganfault 跳跃活动预期输出](img/Figure_3.14_B18531.png)'
- en: Figure 3.14 – Ganfault jump activity expected output
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – Ganfault 跳跃活动预期输出
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: By completing this activity, you’ve understood scenarios where C++ code is extended
    in Blueprints to implement functionalities and logic. This combination of C++
    and Blueprints is the most powerful tool game developers possess to create masterful
    and unique games within Unreal Engine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你已经理解了在蓝图（Blueprints）中扩展 C++ 代码以实现功能和逻辑的场景。这种 C++ 和蓝图的组合是游戏开发者拥有创建在虚幻引擎（Unreal
    Engine）中精湛且独特游戏的最强大工具。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a C++ `Character` class, add initializer
    code to it, and then use Blueprints to extend it to set up assets and add additional
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个 C++ `Character` 类，向其中添加初始化代码，然后使用蓝图（Blueprints）来扩展它以设置资产并添加额外的代码。
- en: The result obeys the C++ code, as well as the Blueprint code, and can be used
    in any purposeful scenario.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果遵循 C++ 代码以及蓝图代码，可以在任何有意义的场景中使用。
- en: You also learned how to set up Axis Mappings that have been mapped to the *W*,
    *A*, *S*, and *D* keys to move players (which is the default movement mapping
    in many games). You also learned how to make the character jump within the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何设置映射到 *W*、*A*、*S* 和 *D* 键的轴映射（Axis Mappings），以移动玩家（这是许多游戏中的默认移动映射）。你还学习了如何在游戏中使角色跳跃。
- en: In the next chapter, you will explore Input Mappings in more depth and how to
    use the Mobile Previewer within Unreal Editor. This will help you create games
    with solid inputs mapped to game and player logic. It will also allow you to quickly
    test what your game will look and feel like on a mobile, all within Unreal Editor.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更深入地探索输入映射（Input Mappings）以及如何在虚幻编辑器（Unreal Editor）中使用移动预览器（Mobile Previewer）。这将帮助你创建具有稳固输入映射到游戏和玩家逻辑的游戏。它还将允许你在虚幻编辑器中快速测试你的游戏在移动设备上的外观和感觉。
