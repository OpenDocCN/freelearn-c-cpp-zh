- en: Building Gameplay Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏系统
- en: 'We have come to the point on our journey where we are able to start piecing
    together the various systems that we will be using to drive our games and tools.
    These systems are the parts of the engine that power the interactions with all
    the amazing assets we are now able to import into our game:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了我们的旅程中的一个节点，我们能够开始将我们将用来驱动我们的游戏和工具的各种系统逐步拼凑在一起。这些系统是引擎的一部分，它们为我们现在能够导入游戏中的所有惊人资产提供互动的动力：
- en: Understanding states
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解状态
- en: Designing camera systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计摄像机系统
- en: Working with physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理
- en: Understanding states
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解状态
- en: We use states in many different ways. They can be used for controlling the game
    flow, handling the different ways characters can act and react, even for simple
    menu navigation. Needless to say, states are an important requirement for a strong
    and manageable code base.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以许多不同的方式使用状态。它们可以用于控制游戏流程，处理角色行为和反应的不同方式，甚至用于简单的菜单导航。不用说，状态是强大且可管理的代码基础的重要要求。
- en: There are many different types of states machines; the one we will focus on
    in this section is the **Finite State Machine (FSM)** pattern. Observant readers
    among you will have noticed that we have already seen an FSM pattern in the function
    of the screen system that has been implemented. In fact, what we will be creating
    here is very similar to what was created for that system with some key differences
    that will make this a more generic and flexible state machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的状态机；我们将在本节中重点关注**有限状态机（FSM）**模式。你们中的敏锐读者可能已经注意到，我们已经在实现的屏幕系统的功能中看到了FSM模式。事实上，我们将在这里创建的东西与为该系统创建的东西非常相似，只是有一些关键的区别，这将使其成为一个更通用和灵活的状态机。
- en: 'There are a few ways we can implement a simple state machine in our game. One
    way would be to simply use a switch case set up to control the states and an `enum`
    structure for the state types. An example of this would be as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏中实现简单状态机的几种方式。一种方式是简单地使用switch case来控制状态，并使用`enum`结构来表示状态类型。一个例子如下：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using a switch/case like this can be effective for a lot of situations, but
    it does have some strong drawbacks. What if we decide to add a few more states?
    What if we decide to add branching and more `if` conditionals?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用switch/case对于许多情况来说是有效的，但它确实有一些强大的缺点。如果我们决定添加一些新的状态怎么办？如果我们决定添加分支和更多的“if”条件呢？
- en: The simple switch/case we started out with has suddenly become very large and
    undoubtedly unwieldy. Every time we want to make a change or add some functionality,
    we multiply the complexity and introduce more chances for bugs to creep in. We
    can help mitigate some of these issues and provide more flexibility by taking
    a slightly different approach and using classes to represent our states. Through
    the use of inheritance and polymorphism, we can build a structure that will allow
    us to chain together states and provide the flexibility to reuse them in many
    situations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始时使用的简单switch/case突然变得非常庞大，无疑难以控制。每当我们想要进行更改或添加一些功能时，我们就会增加复杂性，并引入更多的错误机会。通过采用稍微不同的方法并使用类来表示我们的状态，我们可以帮助减轻一些这些问题，并提供更多的灵活性。通过继承和多态性的使用，我们可以构建一个结构，允许我们将状态链接在一起，并提供在许多情况下重用它们的灵活性。
- en: 'Let''s walk through how we can implement this in our demo examples, starting
    with the base class we will inherit from in the future, `IState`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解如何在我们的演示示例中实现这一点，从我们将来将继承的基类`IState`开始：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, this is just a very simple class that has a constructor, a
    virtual destructor, and three completely virtual functions that each inherited
    state must override. `OnEntry`, which will be called as the state is first entered,
    will only execute once per state change. `OnExit`, like `OnEntry`, will only be
    executed once per state change and is called when the state is about to be exited.
    The last function is the `Update` function; this will be called once per game
    loop and will contain much of the state''s logic. Although this seems very simple,
    it gives us a great starting point to build more complex states. Now let''s implement
    this basic `IState` class in our examples and see how we can use it for one of
    the common needs of a state machine: creating game states.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这只是一个非常简单的类，它有一个构造函数，一个虚拟析构函数，以及三个完全虚拟的函数，每个继承的状态都必须重写。`OnEntry`将在状态首次进入时调用，每次状态更改时只执行一次。`OnExit`和`OnEntry`一样，每次状态更改时只执行一次，并在状态即将退出时调用。最后一个函数是`Update`函数；这将在每个游戏循环中调用，并包含大部分状态的逻辑。虽然这看起来非常简单，但它给了我们一个很好的起点来构建更复杂的状态。现在让我们在我们的示例中实现这个基本的`IState`类，并看看我们如何将其用于状态机的一个常见需求：创建游戏状态。
- en: 'First, we will create a new class called `GameState` that will inherit from
    `IState`. This will be the new base class for all the states our game will need.
    The `GameState.h` file consists of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`GameState`的新类，它将继承自`IState`。这将是我们的游戏所需的所有状态的新基类。`GameState.h`文件包括以下内容：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `GameState` class is very much like the `IState` class it inherits from,
    except for one key difference. In this class, we add a new virtual method `Draw()`
    that all classes will now inherit from `GameState` will be implemented. Each time
    we use `IState` and create a new specialized base class, player state, menu state,
    and so on, we can add these new functions to customize it to the requirements
    of the state machine. This is how we use inheritance and polymorphism to create
    more complex states and state machines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameState`类非常类似于它继承的`IState`类，除了一个关键的区别。在这个类中，我们添加了一个新的虚拟方法`Draw()`，所有继承自`GameState`的类现在都将实现它。每次我们使用`IState`并创建一个新的专门的基类，比如玩家状态、菜单状态等，我们可以添加这些新函数来根据状态机的要求进行定制。这就是我们如何使用继承和多态性来创建更复杂的状态和状态机。'
- en: 'Continuing with our example, let''s now create a new `GameState`. We start
    by creating a new class called `GameWaiting` that inherits from `GameState`. To
    make it a little easier to follow, I have grouped all of the new `GameState` inherited
    classes into one set of files `GameStates.h` and `GameStates.cpp`. The `GamStates.h`
    file will look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的示例，现在让我们创建一个新的`GameState`。我们首先创建一个名为`GameWaiting`的新类，它继承自`GameState`。为了更容易跟踪，我将所有新的`GameState`继承类分组到一个名为`GameStates.h`和`GameStates.cpp`的文件集中。`GamStates.h`文件将如下所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Nothing new here; we are just declaring the functions for each of our `GameState`
    classes. Now, in our `GameStates.cpp` file, we can implement each individual state''s
    functions as described in the preceding code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新东西；我们只是声明了每个`GameState`类的函数。现在，在我们的`GameStates.cpp`文件中，我们可以按照前面的代码实现每个单独状态的函数。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the sake of page space, I am only showing the `GameWaiting` implementation,
    but the same goes for the other states. Each one will have its own unique implementation
    of these functions, which allows you to control the code flow and implement more
    states as necessary without creating a hard-to-follow maze of code paths.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 出于页面空间的考虑，我只显示了`GameWaiting`的实现，但其他状态也是一样的。每个状态都将有其自己独特的这些函数实现，这使您能够控制代码流程并根据需要实现更多状态，而不会创建一个难以遵循的代码路径迷宫。
- en: 'Now that we have our states defined, we can implement them in our game. Of
    course, we could go about this in many different ways. We could follow the same
    pattern that we did with our screen system and implement a `GameState` list class,
    a definition of which could look like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的状态，我们可以在游戏中实现它们。当然，我们可以以许多不同的方式进行。我们可以遵循与屏幕系统相同的模式，并实现一个`GameState`列表类，其定义可能如下所示：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Or we could simply use the `GameState` classes we created with a simple `enum`
    and a switch case. The use of the state pattern allows for this flexibility. In
    the examples case, I chose to follow the same design as the screen system; you
    can see the full implementation of the `GameStateExample` project in the source
    code repository. It's worth going through the source code, as we will continue
    to use these state designs throughout the book. Try to modify the example; add
    a new state that creates a different print out on the screen than the others.
    You could even try nesting states within states to create even more powerful code
    branching abilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以简单地使用我们创建的`GameState`类与一个简单的`enum`和一个switch case。状态模式的使用允许这种灵活性。在示例中，我选择了与屏幕系统相同的设计；您可以在源代码存储库中看到`GameStateExample`项目的完整实现。值得浏览源代码，因为我们将在整本书中继续使用这些状态设计。尝试修改示例；添加一个创建与其他状态不同的屏幕打印的新状态。您甚至可以尝试在状态内部嵌套状态，以创建更强大的代码分支能力。
- en: Working with cameras
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: 'At this point, we have discussed a good amount about the structure of systems
    and have now been able to move on to designing ways of interacting with our game
    and 3D environment. This brings us to an important topic: the design of virtual
    camera systems. A camera is what provides us with a visual representation of our
    3D world. It is how we immerse ourselves and it provides us with feedback on our
    chosen interactions. In this section, we are going to go over the concept of a
    virtual camera in computer graphics.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了系统结构的很多内容，现在我们已经能够继续设计与我们的游戏和3D环境交互的方式。这将我们带到一个重要的话题：虚拟相机系统的设计。相机是为我们提供3D世界的视觉表示的东西。这是我们如何沉浸自己，并为我们选择的交互提供反馈。在本节中，我们将讨论计算机图形学中虚拟相机的概念。
- en: 'Before we dive into writing the code for our camera, it is important to have
    a strong understanding of how, exactly, it all works. Let''s start with the idea
    of being able to navigate around the 3D world. In order to do this, we need to
    use what is referred to as a transformation pipeline. A transformation pipeline
    can be thought of as the steps that are taken to transform all objects and points
    relative to the position and orientation of a camera viewpoint. The following
    is a simple diagram that details the flow of a transformation pipeline:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写相机代码之前，了解它的工作原理非常重要。让我们从能够在3D世界中导航的想法开始。为了做到这一点，我们需要使用所谓的变换管道。变换管道可以被认为是相对于相机视点的位置和方向来转换所有对象和点所采取的步骤。以下是一个详细说明变换管道流程的简单图表：
- en: '![](img/3452a528-196c-4721-87af-496f5aca1405.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3452a528-196c-4721-87af-496f5aca1405.png)'
- en: 'Beginning with the first step in the pipeline, local space, when a mesh is
    created it has a local origin 0 x, 0 y, 0 z. This local origin is typically located
    in either the center of the object or in the case of some player characters, the
    center of the feet. All points that make up that mesh are then based on that local
    origin. When talking about a mesh that has not been transformed, we refer to it
    as being in local space:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道的第一步开始，局部空间，当一个网格被创建时，它有一个局部原点0 x，0 y，0 z。这个局部原点通常位于对象的中心，或者在一些玩家角色的情况下，位于脚的中心。构成该网格的所有点都是基于该局部原点的。当谈论一个尚未转换的网格时，我们称之为处于局部空间中。
- en: '![](img/39326e41-9c69-40b2-af8d-ee369ac280a0.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39326e41-9c69-40b2-af8d-ee369ac280a0.png)'
- en: The preceding image pictures the gnome mesh in a model editor. This is what
    we would consider local space.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了在模型编辑器中的侏儒网格。这就是我们所谓的局部空间。
- en: In the next step, we want to bring a mesh into our environment, the world space.
    In order to do this, we have to multiply our mesh points by what is referred to
    as a model matrix. This will then place the mesh in world space, which sets all
    the mesh points to be relative to a single world origin. It's easiest to think
    of world space as being the description of the layout of all the objects that
    make up your game's environment. Once meshes have been placed in world space,
    we can start to do things such as compare distances and angles. A great example
    of this step is when placing game objects in a world/level editor; this is creating
    a description of the model's mesh in relation to other objects and a single world
    origin (0,0,0). We will discuss editors in more detail in the next chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想将一个网格带入我们的环境，即世界空间。为了做到这一点，我们必须将我们的网格点乘以所谓的模型矩阵。然后将网格放置在世界空间中，这将使所有网格点相对于单个世界原点。最容易将世界空间想象为描述构成游戏环境的所有对象的布局。一旦网格被放置在世界空间中，我们就可以开始做一些事情，比如比较距离和角度。这一步的一个很好的例子是在世界/关卡编辑器中放置游戏对象；这是在与其他对象和单个世界原点（0,0,0）相关的模型网格的描述。我们将在下一章更详细地讨论编辑器。
- en: Next, in order to navigate this world space, we have to rearrange the points
    so that they are relative to the camera's position and orientations. To accomplish
    this, we perform a few simple operations. The first is to translate the objects
    to the origin. First, we would move the camera from its current world coordinates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了在这个世界空间中导航，我们必须重新排列点，使它们相对于摄像机的位置和方向。为了实现这一点，我们进行了一些简单的操作。首先是将对象平移到原点。首先，我们会将摄像机从其当前的世界坐标移动。
- en: 'In the following example figure, there is **20** on the *x* axis, **2** on
    the *y* axis, and **-15** on the *z* axis, to the world origin or **0,0,0**. We
    can then map the objects by subtracting the camera''s position, the values used
    to translate the camera object, which in this case would be **-20**, **-2**, **15**.
    So if our game object started out at **10.5** on the *x* axis, **1** on the *y*
    axis, and **-20** on the *z* axis, the newly translated coordinates would be **-9.5**,
    **-1**, **-5**. The last operation is to rotate the camera to face the desired
    direction; in our current case, that would be pointing down the -*z* axis. For
    the following example, that would mean rotating the object points by **-90** degrees,
    making the example game object''s new position **5**, **-1**, **-9.5**. These
    operations combine into what is referred to as the view matrix:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例图中，*x*轴上有**20**，*y*轴上有**2**，*z*轴上有**-15**，相对于世界原点或**0,0,0**。然后我们可以通过减去摄像机的位置来映射对象，即用于平移摄像机对象的值，这种情况下为**-20**，**-2**，**15**。因此，如果我们的游戏对象在*x*轴上开始为**10.5**，在*y*轴上为**1**，在*z*轴上为**-20**，则新的平移坐标将是**-9.5**，**-1**，**-5**。最后一个操作是将摄像机旋转到所需的方向；在我们当前的情况下，这意味着指向-*z*轴。对于下面的示例，这意味着将对象点旋转**-90**度，使示例游戏对象的新位置为**5**，**-1**，**-9.5**。这些操作组合成所谓的视图矩阵：
- en: '![](img/a47e37f1-60e7-46d4-93c7-82d8ce00cbb5.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47e37f1-60e7-46d4-93c7-82d8ce00cbb5.png)'
- en: 'Before we go any further, I want to briefly cover some important details when
    it comes to working with matrices, in particular, handling matrix multiplication
    and the order of operations. When working with OpenGL, all matrices are defined
    in a column-major layout. The opposite being row-major layout, found in other
    graphics libraries such as Microsoft''s DirectX. The following is the layout for
    column-major view matrices, where U is the unit vector pointing up, F is our vector
    pointing forward, R is the right vector, and P is the position of the camera:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想简要介绍一些重要的细节，当涉及到处理矩阵时，特别是处理矩阵乘法和操作顺序。在使用OpenGL时，所有矩阵都是以列主布局定义的。相反的是行主布局，在其他图形库中可以找到，比如微软的DirectX。以下是列主视图矩阵的布局，其中U是指向上的单位向量，F是我们指向前方的向量，R是右向量，P是摄像机的位置：
- en: '![](img/21b8ec10-e037-4bb2-b309-2fb5b85d7d33.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b8ec10-e037-4bb2-b309-2fb5b85d7d33.png)'
- en: 'When constructing a matrix with a combination of translations and rotations,
    such as the preceding view matrix, you cannot, generally, just stick the rotation
    and translation values into a single matrix. In order to create a proper view
    matrix, we need to use matrix multiplication to combine two or more matrices into
    a single final matrix. Remembering that we are working with column-major notations,
    the order of the operations is therefore right to left. This is important since,
    using the orientation (R) and translation (T) matrices, if we say V = T x R, this
    would produce an undesired effect because this would first rotate the points around
    the world origin and then move them to align to the camera position as the origin.
    What we want is V = R x T, where the points would first align to the camera as
    the origin and then apply the rotation. In a row-major layout, this is the other
    way around of course:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个矩阵时，其中包含平移和旋转的组合，比如前面的视图矩阵，通常不能简单地将旋转和平移值放入单个矩阵中。为了创建一个正确的视图矩阵，我们需要使用矩阵乘法将两个或多个矩阵组合成一个最终的矩阵。记住我们使用的是列主记法，因此操作的顺序是从右到左。这很重要，因为使用方向（R）和平移（T）矩阵，如果我们说
    V = T x R，这将产生一个不希望的效果，因为这首先会将点围绕世界原点旋转，然后将它们移动到与摄像机位置对齐。我们想要的是 V = R x T，其中点首先与摄像机对齐，然后应用旋转。在行主布局中，当然是相反的：
- en: '![](img/1a829f1e-437e-43fb-b03c-e69e8fdbf898.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a829f1e-437e-43fb-b03c-e69e8fdbf898.png)'
- en: The good news is that we do not necessarily need to handle the creation of the
    view matrix manually. Older versions of OpenGL and most modern math libraries,
    including GLM, have an implementation of a `lookAt()` function. Most take a version
    of camera position, target or look position, and the up direction as parameters,
    and return a fully created view matrix. We will be looking at how to use the GLM
    implementation of the `lookAt()` function shortly, but if you want to see the
    full code implementation of the ideas described just now, check out the source
    code of GLM which is included in the project source repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们不一定需要手动处理视图矩阵的创建。OpenGL的旧版本和大多数现代数学库，包括GLM，都有一个`lookAt()`函数的实现。大多数函数需要相机位置、目标或观察位置以及上方向作为参数，并返回一个完全创建好的视图矩阵。我们将很快看到如何使用GLM的`lookAt()`函数的实现，但如果你想看到刚才描述的想法的完整代码实现，请查看项目源代码库中包含的GLM的源代码。
- en: Continuing through the transformation pipeline, the next step is to convert
    from eye space to homogeneous clip space. This stage will construct a projection
    matrix. The projection matrix is responsible for a few things.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过变换管线，下一步是从眼空间转换为齐次裁剪空间。这个阶段将构建一个投影矩阵。投影矩阵负责一些事情。
- en: First is to define the near and far clipping planes. This is the visible range
    along the defined forward axis (usually *z*). Anything that falls in front of
    the near distance and anything that falls past the far distance is considered
    out of range. Any geometrical objects that are on the outside of this range will
    be *clipped* (removed) from the pipeline in a later step.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是定义近裁剪平面和远裁剪平面。这是沿着定义的前向轴（通常为*z*）的可见范围。任何落在近距离前面或者远距离后面的物体都被视为超出范围。在后续步骤中，处于此范围之外的任何几何对象都将被*裁剪*（移除）。
- en: Second is to define the **Field of View** (**FOV**). Despite the name, the field
    of view is not a field but an angle. For the FOV, we actually only specify the
    vertical range; most modern games use 66 or 67 degrees for this. The horizontal
    range will be calculated for us by the matrix once we provide the aspect ratio
    (how wide compared to how high). To demonstrate, a 67 degree vertical angle on
    a display with a 4:3 aspect ratio would have a FOV of 89.33 degrees (*67 * 4/3
    = 89.33*).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是定义**视野**（**FOV**）。尽管名字是视野，但实际上是一个角度。对于FOV，我们实际上只指定了垂直范围；大多数现代游戏使用66或67度。水平范围将由矩阵根据我们提供的宽高比（宽度相对于高度）来计算。举例来说，在4:3宽高比的显示器上，67度的垂直角度将有一个FOV为89.33度（*67
    * 4/3 = 89.33*）。
- en: These two steps combine to create a volume that takes the shape of a pyramid
    with the top chopped off. This created volume is referred to as the view frustum.
    Any of the geometry that falls outside of this frustum is considered to be out
    of view.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤结合起来创建了一个形状类似于被截去顶部的金字塔的体积。这个创建的体积被称为视锥体。任何落在这个视锥体之外的几何体都被视为不可见。
- en: 'The following diagram illustrates what the view frustum looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了视锥体的外观：
- en: '![](img/8f7c74c5-f2d2-4d17-86f8-d91a3f38037e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f7c74c5-f2d2-4d17-86f8-d91a3f38037e.png)'
- en: You might note that there is more visible space available at the end of the
    frustum than in the front. In order to properly display this on a 2D screen, we
    need to tell the hardware how to calculate the perspective. This is the next step
    in the pipeline. The larger, far end of the frustum will be pushed together creating
    a box shape. The collection of objects visible at this wide end will also be squeezed
    together; this will provide us with a perspective view. To understand this, imagine
    the phenomenon of looking along a straight stretch of railway tracks. As the tracks
    continue into the distance, they appear to get smaller and closer together.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到在视锥体的末端有更多的可见空间。为了在2D屏幕上正确显示这一点，我们需要告诉硬件如何计算透视。这是管线中的下一步。视锥体的较大、远端将被推在一起，形成一个盒子形状。在这个宽端可见的物体也将被挤在一起；这将为我们提供一个透视视图。要理解这一点，想象一下看着一条笔直的铁轨。随着铁轨延伸到远处，它们看起来会变得更小、更接近。
- en: The next step in the pipeline, after defining the clipping space, is to use
    what is called the perspective division to normalize the points into a box shape
    with the dimensions of (-1 to 1, -1 to 1, -1 to 1). This is referred to as the
    **normalized device space**. By *normalizing* the dimensions into unit size, we
    allow the points to be multiplied to scale up or down to any viewport dimensions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义裁剪空间之后，管线中的下一步是使用所谓的透视除法将点归一化为一个具有尺寸为(-1到1，-1到1，-1到1)的盒子形状。这被称为**归一化设备空间**。通过将尺寸归一化为单位大小，我们允许点被乘以以缩放到任何视口尺寸。
- en: The last major step in the transformation pipeline is to create the 2D representation
    of the 3D that will be displayed. To do this, we flatten the normalized device
    space with the objects further away being drawn behind the objects that are closer
    to the camera (draw depth). The dimensions are scaled from the *X* and *Y* normalized
    values into actual pixel values of the viewport. After this step, we have a 2D
    space referred to as the **Viewport space**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 变换管线中的最后一个重要步骤是创建将要显示的3D的2D表示。为了做到这一点，我们将归一化设备空间中的远处物体绘制在靠近摄像机的物体后面（绘制深度）。尺寸从*X*和*Y*的归一化值被缩放为视口的实际像素值。在这一步之后，我们有了一个称为**视口空间**的2D空间。
- en: 'That completes the transformation pipeline stages. With that theory covered,
    we can now shift to implementation and write some code. We are going to start
    by looking at the creation of a basic, first person 3D camera, which means we
    are looking through the eyes of the player''s character. Let''s start with the
    camera''s header file, `Camera3D.h`, which can be found in the `Chapter05` project
    folder in the source code repository:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了转换管道阶段。有了这个理论，我们现在可以转向实现并编写一些代码。我们将从创建一个基本的第一人称3D摄像机开始，这意味着我们是通过玩家角色的眼睛观察。让我们从摄像机的头文件`Camera3D.h`开始，它可以在源代码库的`Chapter05`项目文件夹中找到。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start with the necessary includes. As I just mentioned, GLM includes support
    for working with matrices, so we include both `glm.hpp` and the `matrix_transform.hpp`
    to gain access to GLM''s `lookAt()` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从必要的包含开始。正如我刚提到的，GLM包括支持使用矩阵，所以我们包括`glm.hpp`和`matrix_transform.hpp`来获得GLM的`lookAt()`函数的访问权限。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we have the public accessible functions for our Camera3D class. The first
    two are just the standard constructor and destructor. We then have the `Init()`
    function. We declare this function with a few defaults provided for the parameters;
    this way if no values are passed in, we will still have values to calculate our
    matrices in the first update call. That brings us to the next function declared,
    the `Update()` function. This is the function that the game engine will call each
    loop to keep the camera updated:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有Camera3D类的公共可访问函数。前两个只是标准的构造函数和析构函数。然后是`Init()`函数。我们声明这个函数时提供了一些默认值，这样如果没有传入值，我们仍然有值可以在第一次更新调用中计算我们的矩阵。这将带我们到下一个声明的函数，`Update()`函数。这是游戏引擎每次循环调用以保持摄像机更新的函数。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the `Update()` function, there is a set of five getter functions to return
    both the View and Projection matrices, as well as the camera''s forward, up, and
    right vectors. To keep the implementation clean and tidy, we can simply declare
    and implement these *getter* functions right in the header file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数之后，有一组五个获取函数，用于返回视图和投影矩阵，以及摄像机的前向、向上和向右向量。为了保持实现的整洁，我们可以在头文件中简单地声明和实现这些*getter*函数。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Directly after the set of getter functions, we have two setter functions. The
    first will set the horizontal angle, the second will set the vertical angle. This
    is useful for when the screen size or aspect ratio changes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取函数集之后，我们有两个设置函数。第一个将设置水平角度，第二个将设置垂直角度。当屏幕大小或纵横比发生变化时，这是很有用的。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last public function in the Camera3D class is the `MoveCamera()` function.
    This simple function takes in a vector 3, then cumulatively adds that vector to
    the `m_position` variable, which is the current camera position:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Camera3D类中的最后一个公共函数是`MoveCamera()`函数。这个简单的函数接收一个向量3，然后将该向量累加到`m_position`变量中，这是当前摄像机的位置。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the private declarations of the class, we start with two `glm::mat4` variables.
    A `glm::mat4` is the datatype for a 4x4 matrix. We create one for the view or
    camera matrix and one for the projection matrix:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类的私有声明，我们从两个`glm::mat4`变量开始。`glm::mat4`是4x4矩阵的数据类型。我们创建一个用于视图或摄像机矩阵，一个用于投影矩阵。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we have a single vector 3 variable to hold the position of the camera,
    followed by three float values—one for the horizontal and one for the vertical
    angles, as well as a variable to hold the field of view:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个单一的三维向量变量来保存摄像机的位置，然后是三个浮点值——一个用于水平角度，一个用于垂直角度，以及一个用于保存视野的变量。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We then have three more vector 3 variable types that will hold the right, up,
    and forward values for the camera object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有另外三个向量3变量类型，它们将保存摄像机对象的右、上和前向值。
- en: 'Now that we have the declarations for our 3D camera class, the next step is
    to implement any of the functions that have not already been implemented in the
    header file. There are only two functions that we need to provide, the `Init()`
    and the `Update()` functions. Let''s begin with the `Init()` function, found in
    the `Camera3D.cpp` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了我们的3D摄像机类，下一步是实现头文件中尚未实现的任何函数。我们只需要提供两个函数，`Init()`和`Update()`函数。让我们从`Init()`函数开始，它位于`Camera3D.cpp`文件中。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our `Init()` function is straightforward; all we are doing in the function
    is taking in the provided values and setting them to the corresponding variable
    we declared. Once we have set these values, we simply call the `Update()` function
    to handle the calculations for the newly created camera object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Init()`函数很简单；在函数中，我们只是接收提供的值并将它们设置为我们声明的相应变量。一旦我们设置了这些值，我们只需调用`Update()`函数来处理新创建的摄像机对象的计算。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Update()` function is where all of the heavy lifting of the classes is
    done. It starts out by calculating the new forward for our camera. This is done
    with a simple formula leveraging GLM's cosine and sine functions. What is occurring
    is that we are converting from spherical coordinates to cartesian coordinates
    so that we can use the value in the creation of our view matrix.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`函数是类的所有繁重工作都在做的地方。它首先计算摄像机的新前向。这是通过利用GLM的余弦和正弦函数的简单公式来完成的。正在发生的是，我们正在从球坐标转换为笛卡尔坐标，以便我们可以在创建我们的视图矩阵中使用该值。'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After we calculate the new forward, we then calculate the new right vector
    for our camera, again using a simple formula that leverages GLM''s sine and cosine
    functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了新的前向之后，我们然后使用一个简单的公式计算摄像机的新右向量，再次利用GLM的正弦和余弦函数。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have the forward and up vectors calculated, we can use GLM''s cross-product
    function to calculate the new up vector for our camera. It is important that these
    three steps happen every time the camera changes position or rotation, and before
    the creation of the camera''s view matrix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算出了前向和向上的向量，我们可以使用GLM的叉积函数来计算摄像机的新向上向量。这三个步骤在摄像机改变位置或旋转之前，以及在创建摄像机的视图矩阵之前发生是很重要的。
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we specify the FOV. Currently, I am just setting it back to the initial
    FOV specified when initializing the camera object. This would be the place to
    recalculate the FOV if the camera was, say, zoomed in or out (hint: mouse scroll
    could be useful here):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定视野。目前，我只是将其设置回初始化摄像机对象时指定的初始视野。如果摄像机被放大或缩小，这将是重新计算视野的地方（提示：鼠标滚轮可能在这里很有用）：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we have the field of view specified, we can then calculate the projection
    matrix for our camera. Luckily for us, GLM has a very handy function called `glm::perspective()`,
    which takes in a field of view in radians, an aspect ratio, the near clipping
    distance, and a far clipping distance, which will then return a created projection
    matrix for us. Since this is an example, I have specified a 4:3 aspect ratio (4.0f/3.0f)
    and a clipping space of 0.1 units to 100 units directly. In production, you would
    ideally move these values to variables that could be changed during runtime:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了视野，我们就可以计算摄像机的投影矩阵。幸运的是，GLM有一个非常方便的函数叫做`glm::perspective()`，它接受弧度制的视野、宽高比、近裁剪距离和远裁剪距离，然后返回一个创建好的投影矩阵。由于这只是一个示例，我指定了一个4:3的宽高比（4.0f/3.0f）和一个直接的裁剪空间从0.1单位到100单位。在生产中，你理想情况下会将这些值移动到可以在运行时更改的变量中：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the last thing we do in the `Update()` function is to create the view
    matrix. As I mentioned before, we are fortunate that the GLM library supplies
    a `lookAt()` function to abstract all the steps we discussed earlier in the section.
    This `lookAt()` function takes three parameters. The first is the position of
    the camera. The second is a vector value of where the camera is pointed, or *looking
    at*, which we provide by doing a simple addition of the camera's current position
    and it's calculated forward. The last parameter is the camera's current up vector
    which, again, we calculated previously. Once finished, this function will return
    the newly updated view matrix to use in our graphics pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Update()`函数中我们要做的是创建视图矩阵。正如我之前提到的，我们很幸运，GLM库提供了一个`lookAt()`函数，用于抽象我们在本节前面讨论的所有步骤。这个`lookAt()`函数接受三个参数。第一个是摄像机的位置。第二个是摄像机指向的矢量值，或者*看向*的位置，我们通过简单地将摄像机当前位置和计算出的前向矢量相加来提供。最后一个参数是摄像机当前的上矢量，同样，我们之前计算过。完成后，这个函数将返回新更新的视图矩阵，供我们在图形管线中使用。
- en: That is a simple 3D camera class in a nutshell. Go ahead and run the CameraDemo
    project to see the system in action. You can move the camera around with the WASD
    keys and change the viewing angle with the mouse. Next, we will move onto another
    important game engine system, physics!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个简单的3D摄像机类。继续运行CameraDemo项目，看看系统是如何运作的。你可以用WASD键移动摄像机，用鼠标改变视角。接下来，我们将转向另一个重要的游戏引擎系统，物理！
- en: Working with physics
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理物理
- en: Nowadays, it tends to be very rare that a game does not implement at least some
    basic form of physics. The topic of game physics is rather large and complex and
    could easily fill a few volumes before you could consider it well covered. It's
    because of this that entire teams are dedicated to the creation of the *physics
    engines* and it can take years of development to build production-level systems.
    Since this is the case, we won't attempt to cover all aspects here, but instead
    take a higher-level approach. We will cover some of the more commonly needed aspects
    of physics systems, specifically basic collision detection. For more advanced
    needs, such as the support for gravity, friction, and advanced collision detection,
    we will cover the implementation of a third-party physics library. At the end
    of this section, our demo engine will have advanced physics support.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，很少有游戏不实现至少一些基本形式的物理。游戏物理的话题相当庞大和复杂，很容易填满几卷书才能算是全面覆盖。正因为如此，整个团队都致力于创建*物理引擎*，并且可能需要数年的开发才能构建生产级系统。因为情况如此，我们不会尝试在这里覆盖所有方面，而是采取更高层次的方法。我们将覆盖一些更常见的物理系统方面，特别是基本的碰撞检测。对于更高级的需求，比如支持重力、摩擦和高级碰撞检测，我们将覆盖第三方物理库的实现。在本节结束时，我们的演示引擎将具有高级的物理支持。
- en: Point in AABB
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AABB中的点
- en: 'To start, let''s take a look at one of the easier collision checks you can
    perform in 3D, finding out whether a point is inside or outside an **Axis Aligned
    Bounding Box** (**AABB**). AABBs are very easy to create. You can basically think
    of these as non-rotatable cubes or boxes. The following image depicts an AABB
    and point—collision:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看在3D中可以执行的较简单的碰撞检查之一，即找出一个点是否在**轴对齐边界框**（**AABB**）内或外。AABB非常容易创建。你可以基本上将其想象成不可旋转的立方体或盒子。以下图像描述了AABB和点之间的碰撞：
- en: '![](img/c502b9d4-9123-486a-b50f-59304240a90f.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c502b9d4-9123-486a-b50f-59304240a90f.png)'
- en: 'To create a bounding box, you can specify a max point and a min point in vector
    format or by having a center point and then specifying a height, width, and depth.
    For this example, we will create our AABB''s with the min and max points approach:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个边界框，你可以指定一个向量格式的最大点和最小点，或者通过指定一个中心点，然后指定高度、宽度和深度。在这个例子中，我们将使用最小点和最大点的方法创建我们的AABB：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code is a simple example struct for an AABB.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个简单的AABB结构的示例。
- en: 'Now that we have an AABB, we can develop a way to check if a single point falls
    inside of the AABB. This check is very simple; all we need to do is check if all
    its values, x, y, and z, are greater than the AABB''s min values and less than
    the AABB''s max values. This check in the code would look something like the following,
    in its simplest form:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个AABB，我们可以开发一种方法来检查单个点是否落在AABB内。这个检查非常简单；我们只需要检查它的所有值，x、y和z，是否大于AABB的最小值并且小于AABB的最大值。在代码中，这个检查看起来会像下面这样，以最简单的形式：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: AABB to AABB
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AABB到AABB
- en: 'Now that we have seen how to test if a point is within a certain AABB, the
    next very useful collision check we will look at is the AABB to AABB check—a quick
    test to find out if two AABBs are colliding. The following image depicts this
    collision check:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何测试一个点是否在某个AABB内，接下来我们将看到的非常有用的碰撞检查是AABB到AABB的检查——一个快速测试，以找出两个AABB是否发生碰撞。以下图像描述了这个碰撞检查：
- en: '![](img/8e4f7aad-e66f-4e3a-8635-cc8f2162973e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4f7aad-e66f-4e3a-8635-cc8f2162973e.png)'
- en: The collision check between two AABBs is very simple and fast. It is a very
    common choice for most objects that need a form of collision detection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个AABB之间的碰撞检查非常简单和快速。这是大多数需要一种碰撞检测形式的对象的常见选择。
- en: The bad thing about AABBs is that they can't be rotated. Once they are rotated,
    they stop being AABBs since they are not aligned to the *x*, *y*, and *z* axes
    anymore. For objects that rotate, a better option would be to use spheres, capsules,
    or even **oriented bounding boxes** (**OBBs**).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AABB的不好之处在于它们不能旋转。一旦它们旋转，它们就不再是AABB，因为它们不再与*x*、*y*和*z*轴对齐。对于旋转的对象，更好的选择是使用球体、胶囊体，甚至是**定向包围盒**（**OBBs**）。
- en: 'To check if two AABBs are colliding, we just need to check that the first AABB''s
    max point is greater than the second one''s min point and that the first one''s
    min point is less than the second one''s max point. The following is what this
    check would look like in code, in its simplest form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查两个AABB是否发生碰撞，我们只需要检查第一个AABB的最大点是否大于第二个AABB的最小点，并且第一个AABB的最小点是否小于第二个AABB的最大点。以下是这个检查在代码中的简单形式：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course, the order of the boxes, which one is first and which one is the second,
    doesn't matter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，盒子的顺序，哪一个是第一个，哪一个是第二个，都无关紧要。
- en: Since this check contains a lot of  `&&` comparisons, if the first check is
    false, it will not continue to check the rest; this is what allows for a very
    fast test.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个检查包含很多`&&`比较，如果第一个检查是假的，它将不会继续检查其余的；这就是允许非常快速测试的原因。
- en: Sphere to sphere
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球到球
- en: 'The last simple collision check I want to touch on here is the test to find
    out if two spheres are colliding with each other. Testing collisions between spheres
    is very simple and easy to perform. An advantage that spheres have over things
    such as AABBs is that it doesn''t matter if the object rotates, the sphere will
    remain the same. The following is an image that depicts the collision check between
    two spheres:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里谈论的最后一个简单的碰撞检查是测试两个球体是否相互碰撞。测试球体之间的碰撞非常简单且易于执行。球体相对于AABB等物体的优势在于，不管物体是否旋转，球体都将保持不变。以下是描述两个球体之间碰撞检查的图像：
- en: '![](img/ee43bc1c-46b3-4415-8767-a9bd4b83e28d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee43bc1c-46b3-4415-8767-a9bd4b83e28d.png)'
- en: 'To perform the check, we simply need to calculate the distance between the
    centers of the spheres and compare it to the sum of their radii. If this distance
    is less than the sum of their radii, then the spheres are overlapping. If it''s
    the same, then the spheres are just touching. The following is how this collision
    test would look like in code, in its simplest form:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行检查，我们只需要计算球心之间的距离，并将其与它们的半径之和进行比较。如果这个距离小于它们的半径之和，那么球体重叠。如果相同，那么球体只是接触。以下是这个碰撞测试在代码中的简单形式：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To get the distance between the centers of the spheres, we need to create a
    vector between their center points:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到球心之间的距离，我们需要创建一个连接它们中心点的向量：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then calculate the length of that vector with the sum of the radii:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以计算该向量与半径之和的长度：
- en: There is a more efficient way to do this. Since the dot product of a vector
    with itself equals the squared length of that vector, we could just calculate
    the squared length of the vector against the square of the sum of the radii. If
    we do it this way, we don't need to calculate the length of the vector, which
    is an expensive operation in itself.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更有效的方法。由于向量与自身的点积等于该向量的平方长度，我们可以只计算该向量的平方长度与半径之和的平方。如果我们这样做，就不需要计算向量的长度，这本身就是一个昂贵的操作。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we can perform the collision check. If the distance squared is less
    than or equal to the square sum, then the spheres have collided, otherwise, the
    object has not collided and we return false.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进行碰撞检查。如果距离的平方小于或等于平方和，那么球体已经碰撞，否则，物体没有碰撞，我们返回false。
- en: Armed with these simple checks, most basic collision detection can be handled.
    In fact, as we will see in the next section, most advanced checks are comprised
    of many smaller checks. However, there will come a point when you will find yourself
    needing more advanced or optimized ways of handling physics; this is when you
    can turn to a third-party library to provide this support. In the next section,
    we will look at the implementation of one of these third-party libraries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些简单的检查，大多数基本的碰撞检测都可以处理。事实上，正如我们将在下一节中看到的，大多数高级检查都由许多较小的检查组成。然而，总会有一个时刻，你会发现自己需要更高级或优化的物理处理方式；这时你可以求助于第三方库来提供支持。在下一节中，我们将看一下其中一个第三方库的实现。
- en: Implementing the Bullet physics library.
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Bullet物理库。
- en: Bullet is a physics engine that simulates collision detection and soft and rigid
    body dynamics. It has been used in many released video games as well as for visual
    effects in movies. The Bullet physics library is free and open-source software
    subject to the terms of the zlib License.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Bullet是一个模拟碰撞检测和软体和刚体动力学的物理引擎。它已经被用于许多发布的视频游戏以及电影中的视觉效果。Bullet物理库是免费的开源软件，受zlib许可证的条款约束。
- en: 'Some of the features Bullet has to offer include:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Bullet提供的一些功能包括：
- en: Rigid body and soft body simulation with discrete and continuous collision detection
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体和软体模拟，使用离散和连续碰撞检测
- en: 'Collision shapes: sphere, box, cylinder, cone, convex hull using GJK, non-convex,
    and triangle mesh'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞形状：球、盒子、圆柱、锥体、使用GJK的凸壳、非凸和三角网格
- en: 'Soft body support: cloth, rope, and deformable objects'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软体支持：布料、绳索和可变形物体
- en: A rich set of rigid body and soft body constraints with constraint limits and
    motors
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 具有约束限制和电机的丰富的刚体和软体约束集。
- en: You can find the source code link and more information at: [http://bulletphysics.org](http://bulletphysics.org).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到源代码链接和更多信息：[http://bulletphysics.org](http://bulletphysics.org)。
- en: Let's take a look at how you can incorporate Bullet into your own game project.
    I am not going to spend the time going over how to link the libraries to our demo
    project since we have covered this a few times now. If you do need a refresher,
    flip back a few chapters to see how. What we are going to do is incorporate the
    Bullet engine into our demo engine and then use the Bullet engine's calculations
    to position our game objects in real time. In this example, we are going to create
    a simple ground plane and then a ball (sphere) to fall and collide with the ground.
    We will be using Bullet's built-in types to support this, including gravity to
    give it a realistic effect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将Bullet引入到你自己的游戏项目中。我不打算花时间讲解如何将库链接到我们的演示项目，因为我们已经讲解了几次了。如果你需要复习，请翻回几章看看。我们要做的是将Bullet引擎整合到我们的演示引擎中，然后使用Bullet引擎的计算来实时定位我们的游戏对象。在这个例子中，我们将创建一个简单的地面平面，然后一个球（球体）下落并与地面碰撞。我们将使用Bullet的内置类型来支持这一点，包括重力以给它一个真实的效果。
- en: 'Beginning with the Ground `GameObject`, we set up variables to hold some of
    our needed physics values. The first is of type `btCollisionShape`. This is a
    Bullet type that allows the definition of simple shapes to use when creating bounding
    objects for the physics tests. The next is of type `btDefaultMotionState`, which
    again is a Bullet datatype that describes the way the object should behave when
    in motion. The last variable we need is of type `btRigidBody`, which is a Bullet
    datatype that will hold all the physical properties of the object that our physics
    engine would be concerned with:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从地面`GameObject`开始，我们设置了一些需要的物理值的变量。第一个是`btCollisionShape`类型。这是一个Bullet类型，允许在创建物理测试的边界对象时定义简单的形状。接下来是`btDefaultMotionState`类型，这也是一个Bullet数据类型，描述了物体在运动时的行为方式。我们需要的最后一个变量是`btRigidBody`类型，这是一个Bullet数据类型，将保存我们的物理引擎关心的物体的所有物理属性：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have these variables defined, we can then construct the physics representation
    of the ground object in its `Init()` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这些变量，我们就可以在`Init()`函数中构建地面对象的物理表示：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start by setting our `groundShape` variable to be a `btStaticPlanShape`.
    This is a Bullet object that specifies a simple plane object, which is perfect
    for our needs and a simple ground object. Next, we set the `groundMotionState`.
    We do this by using the `btDefaultMotionState` Bullet object. The `btDefaultMotionState`
    is the type used for specifying the way an object will behave in motion. When
    creating a new `btDefaultMotionState`, we need to pass in some information about
    the object''s transform, that is the rotation and position of the object. To do
    this we pass a `btTransform` object with its own parameters of a rotation in quaternion
    format (`btQuaternion(0, 0, 0, 1)`) and a position in vector 3 format (`btVector3(m_position.x,
    m_position.y, m_position.z)`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将我们的`groundShape`变量设置为`btStaticPlanShape`。这是一个指定简单平面对象的Bullet对象，非常适合我们的需要和一个简单的地面对象。接下来，我们设置`groundMotionState`。我们通过使用`btDefaultMotionState`
    Bullet对象来实现这一点。`btDefaultMotionState`是用于指定物体在运动中的行为方式的类型。创建一个新的`btDefaultMotionState`时，我们需要传入一些关于物体变换的信息，即物体的旋转和位置。为此，我们传入一个`btTransform`对象，其自身参数为四元数格式的旋转（`btQuaternion(0,
    0, 0, 1)`）和三维向量格式的位置（`btVector3(m_position.x, m_position.y, m_position.z)`）：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, with the `groundShape` and `groundMotionState` set, we can move on to creating
    and setting the rigid body info. First we define a holder `btRigidBodyConstuctionInfo`
    variable for the construction information called `groundRigidBodyCI`. This object
    takes in a few parameter values, a scaler value to specify mass, the motion state
    of the object, the collision shape, and a vector 3 to specify the local Inertia
    value. Inertia is the resistance of any physical object to any change in its state
    of motion. It is basically the tendency of objects to keep moving in a straight
    line at constant velocity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`groundShape`和`groundMotionState`设置好了，我们可以继续创建和设置刚体信息。首先，我们为构造信息定义了一个`btRigidBodyConstuctionInfo`变量，名为`groundRigidBodyCI`。这个对象接受一些参数值，一个标量值来指定质量，物体的运动状态，碰撞形状，以及一个三维向量来指定局部惯性值。惯性是任何物体对其运动状态的任何改变的抵抗力。基本上是物体保持以恒定速度直线运动的倾向。
- en: Since our ground object is static and does not require any changes based on
    the physics input, we can forego an  `Update()` function and move on to the Ball
    object that we will be using to test out the system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的地面对象是静态的，不需要根据物理输入进行任何更改，我们可以跳过`Update()`函数，继续进行我们将用来测试系统的Ball对象。
- en: 'Moving into the `BallObject.h` file, we define some variables that we need,
    much like we did for our ground object. We create a motion state, a scalar (an
    integer) value for mass, collision shape, and, finally, a rigid body:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`BallObject.h`文件，我们定义了一些我们需要的变量，就像我们为地面对象做的那样。我们创建了一个运动状态，一个标量（整数）值用于质量，碰撞形状，最后是一个刚体：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, moving into the `BallObject.cpp` file, we assign some values to the variables
    we have just defined:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入`BallObject.cpp`文件，我们为刚刚定义的变量分配一些值：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First, we set our collision shape. In this case, we are going to use the type
    `btSphereShape`. This is the default shape for spheres and takes in a parameter
    to set the radius for the sphere. Next, we create a vector 3 holder for the sphere''s
    inertia. We are setting this to be all zeros since we want this ball to fall freely
    with no resistance based on the mass of the object and a gravity value we will
    set shortly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置碰撞形状。在这种情况下，我们将使用类型`btSphereShape`。这是球体的默认形状，并接受一个参数来设置球体的半径。接下来，我们创建一个三维向量来保存球体的惯性。我们将其设置为全零，因为我们希望这个球体根据物体的质量和我们即将设置的重力值自由下落，没有阻力：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we set the ball''s motion state, just like we did for the ground object.
    We set the rotation to be 0 and the position to the current position of the ball
    object:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置球的运动状态，就像我们为地面物体做的一样。我们将旋转设置为0，位置设置为球对象的当前位置：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We then calculate the local inertia value using the handy `calculateLocalInertia()`
    function, passing in the mass and `fallInertia` values. This will set the falling
    vector for our ball object to be used in the first tick of the physics engine.
    Finally, we end with setting up the rigid body object, exactly like we did previously
    with the ground object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用方便的`calculateLocalInertia()`函数计算局部惯性值，传入质量和`fallInertia`值。这将设置我们的球对象的下落向量，用于物理引擎的第一个tick。最后，我们以与之前地面对象完全相同的方式设置刚体对象。
- en: 'With the ball object, we do expect the physics engine output to affect the
    ball object. It''s because of this that we need to make some adjustments in the
    `Update()` function of the ball object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于球对象，我们确实希望物理引擎的输出会影响球对象。正因为如此，我们需要在球对象的`Update()`函数中进行一些调整：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first step in the update loop for the ball object is to get the physics
    object's transform from the rigid body. Once we have this transform object, we
    can then set the ball object's mesh (the visible object) to make the position
    of the physics transform object. That's it for the object itself. The ball and
    ground objects now house all the needed physics information. We can now implement
    the physics engine loop into our game loop and get the ball rolling, no pun intended!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于球对象的更新循环中的第一步是从刚体获取物理对象的变换。一旦我们有了这个变换对象，我们就可以将球对象的网格（可见对象）设置为物理变换对象的位置。这就是对象本身的全部内容。球和地面对象现在包含了所有所需的物理信息。现在我们可以将物理引擎循环实现到我们的游戏循环中，并让球滚动，不是在开玩笑！
- en: 'For the implementation of the physics engine into our existing game engine''s
    loop, we need to set up a few values first. Jumping into our `Gameplayscreen.h,`
    we define the variables to hold these values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将物理引擎实现到我们现有的游戏引擎循环中，我们首先需要设置一些值。进入我们的`Gameplayscreen.h`，我们定义变量来保存这些值：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First is a definition of a `btBroadphaseInterface` class object, which provides
    a Bullet interface to detect AABB-overlapping object pairs. In this case, we are
    setting it to a `btDbvtBroadphase`, which implements a `btBroadphase` using two
    dynamic AABB bounding volume hierarchies/trees. This tends to be the best broadphase
    when working with many moving objects; its insertion/addition and removal of objects
    is generally faster than the sweep and prune broad phases found in the `btAxisSweep3`
    and `bt32BitAxisSweep3`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`btBroadphaseInterface`类对象的定义，它提供了一个Bullet接口来检测AABB重叠的对象对。在这种情况下，我们将其设置为`btDbvtBroadphase`，它使用两个动态AABB边界体积层次/树来实现`btBroadphase`。当处理许多移动对象时，这往往是最好的广相位；它的对象插入/添加和移除通常比在`btAxisSweep3`和`bt32BitAxisSweep3`中找到的扫描和修剪广相位更快：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we have defined for the collision configuration, collision dispatcher,
    and sequential impulse constraint solver. We won''t go too deep on each of these,
    but the main points are that the collision configuration sets up some Bullet internal
    values, such as collision detection stack allocators and pool memory allocators.
    The collision dispatcher is the definition of how the collisions will be handled.
    It supports algorithms that handle *ConvexConvex* and *ConvexConcave* collision
    pairs, time of impact, closest points, and penetration depth. Finally, the sequential
    impulse constraint solver, which defines what can be thought of as the algorithm,
    will determine how to solve the collisions between objects. For those wishing
    to know, it is a **Single Instruction, Multiple Data** (**SIMD**) implementation
    of the Projected Gauss-Seidel (iterative LCP) method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们已经为碰撞配置、碰撞分发器和顺序脉冲约束求解器定义了。我们不会深入讨论每一个，但主要观点是碰撞配置设置了一些Bullet内部值，比如碰撞检测堆栈分配器和池内存分配器。碰撞分发器是处理碰撞的定义。它支持处理*凸凸*和*凸凹*碰撞对的算法，时间的影响，最近的点和穿透深度。最后，顺序脉冲约束求解器定义了可以被认为是算法，将决定如何解决物体之间的碰撞。对于那些希望了解的人，这是一种**单指令，多数据**（**SIMD**）实现的投影高斯-塞德尔（迭代LCP）方法：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The last variable we need to define is for our dynamics world object. A `btDiscreteDynamicsWorld`
    provides a discrete rigid body simulation. This can be thought of as the environment
    or *world* in which the physics simulation occurs. Once we have this defined,
    we have all the pieces in place to start our physics simulation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的最后一个变量是我们的动态世界对象。`btDiscreteDynamicsWorld`提供了离散刚体模拟。这可以被认为是发生物理模拟的环境或*世界*。一旦我们定义了这个，我们就有了开始物理模拟的所有要素。
- en: 'Let''s jump into the `GameplayScreen.cpp` file and look at the `OnEntry()`
    function that we will use to initialize the physics simulation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到`GameplayScreen.cpp`文件，看看我们将用来初始化物理模拟的`OnEntry()`函数：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first thing we set is our gravity vector. In our simple example, we are
    setting this to be `-1` on the *y* axis. Next, we add the two created rigid bodies
    to the simulation environment, one for the ground and one for the ball. That handles
    the initialization of our physics engine; now we need to handle updating it on
    each engine tick:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的第一件事是重力向量。在我们的简单示例中，我们将其设置为*y*轴上的`-1`。接下来，我们将两个创建的刚体添加到模拟环境中，一个用于地面，一个用于球。这处理了我们物理引擎的初始化；现在我们需要在每个引擎tick上更新它：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Inside of the `GameplayScreen::Update()` function, we first check the input,
    then call the update on the physics engine, before finally calling the update
    on the game objects themselves. It is important to note this order. We want to
    accept the user's input first, but we want to make sure we have updated the physics
    engine before the objects. The reason is that the physics calculations should
    have some effect on the objects and we don't want to cause a case where our drawing
    loop is ahead of the physics loop, as this would definitely cause some unwanted
    effects. You will also notice the physics update function, `stepSimulation`, takes
    in two parameters. The first is the amount of time to step the simulation by.
    This is typically the time since you last called it. In this case, we are setting
    this to 1/60 of a second, or 60 FPS. The second parameter is the maximum number
    of steps that Bullet is allowed to take each time you call it. If you pass a very
    large value as the first parameter, say, something like five times the size of
    the fixed internal time step or game clock, then you must increase the number
    of  `maxSubSteps` to compensate for this; otherwise, your simulation is *losing* time,
    which will again result in some unwanted physics calculation output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameplayScreen::Update()`函数中，我们首先检查输入，然后调用物理引擎的更新，最后调用游戏对象本身的更新。重要的是要注意这个顺序。我们首先要接受用户的输入，但我们要确保在对象之前已经更新了物理引擎。原因是物理计算应该对对象产生一些影响，我们不希望出现绘图循环领先于物理循环的情况，因为这肯定会导致一些不需要的效果。您还会注意到物理更新函数`stepSimulation`接受两个参数。第一个是要按时间步长模拟的时间量。这通常是自上次调用它以来的时间。在这种情况下，我们将其设置为1/60秒，或60
    FPS。第二个参数是Bullet允许每次调用它执行的最大步数。如果您将一个非常大的值作为第一个参数传递，比如，是固定内部时间步长或游戏时钟大小的五倍，那么您必须增加`maxSubSteps`的数量来补偿这一点；否则，您的模拟将*丢失*时间，这将再次导致一些不需要的物理计算输出。
- en: 'That''s it! We now have a physics engine running its simulation and effecting
    the objects in our world that we are drawing on the screen. You can see this in
    action by running the `PhysicsDemo` example project in the `Chapter05` GitHub
    repository. The output will look something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在有一个物理引擎在运行其模拟，并影响我们在屏幕上绘制的世界中的对象。您可以通过在`Chapter05` GitHub存储库中运行`PhysicsDemo`示例项目来看到这一点。输出将类似于以下内容：
- en: '![](img/587278a9-af53-427b-b6bc-759b806a024a.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/587278a9-af53-427b-b6bc-759b806a024a.png)'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of ground and made strong progress in developing
    the core game systems needed for developing professional-grade projects. We now
    have our own custom game state system that can be adopted by many of the other
    components in the game engine itself. We developed our own custom camera system
    while building an understanding of how cameras work at a lower level. Finally,
    we looked at how we can add complete third-party game systems to our projects
    by adding the Bullet physics engine to our example engine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，并在开发专业级项目所需的核心游戏系统方面取得了良好的进展。我们现在拥有自己的自定义游戏状态系统，可以被游戏引擎中的许多其他组件采用。我们在构建对摄像机的工作原理的理解的同时，开发了自己的自定义摄像机系统。最后，我们看了一下如何通过将Bullet物理引擎添加到我们的示例引擎中，可以向我们的项目添加完整的第三方游戏系统。
