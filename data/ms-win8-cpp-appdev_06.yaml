- en: Chapter 6. Components, Templates, and Custom Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。组件、模板和自定义元素
- en: In the previous chapters, we looked at the fundamentals of building a user interface
    by looking at the way layout and elements work hand in hand to create flexible
    UIs. Data binding provides a detached way of writing and reading data to and from
    controls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们通过查看布局和元素如何携手合作来创建灵活的用户界面的基础知识。数据绑定提供了一种分离的方式来写入和读取数据到控件中。
- en: In this chapter, we'll explore ways to customize controls in a fundamental and
    powerful way using control templates. This is useful when a control's functionality
    is what's needed, but its looks are not. In other cases, the built-in controls
    may not have the required behavior; in these cases, custom and user controls can
    be created for application-specific needs. But first we should consider the more
    general concept of components built using C++, and how these can be used in C++
    and non-C++ projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用控件模板以一种基本而强大的方式来自定义控件的方法。当需要控件的功能而不是外观时，这是很有用的。在其他情况下，内置控件可能没有所需的行为；在这些情况下，可以为特定应用程序需求创建自定义和用户控件。但首先，我们应该考虑使用C++构建组件的更一般概念，以及如何在C++和非C++项目中使用这些组件。
- en: Windows Runtime Components
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Runtime组件
- en: As we've seen in [Chapter 2](ch02.html "Chapter 2. COM and C++ for Windows 8
    Store Apps"), *COM and C++ for Windows 8 Store Apps*, the Windows Runtime is based
    on COM classes implementing COM interfaces. Any such class that is also written
    to metadata (a `winmd` file) can be exported from a DLL and thus used by any other
    WinRT-compliant language or environment; the ones currently supported are C++,
    .NET languages (C# and VB), and JavaScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章。用于Windows 8商店应用的COM和C++")中所看到的，*用于Windows 8商店应用的COM和C++*，Windows
    Runtime是基于实现COM接口的COM类。任何这样的类，如果也写入了元数据（一个`winmd`文件），就可以从DLL中导出，并且可以被任何其他符合WinRT标准的语言或环境使用；目前支持的语言有C++、.NET语言（C#和VB）和JavaScript。
- en: Such components must only use WinRT types in their public interface. For C++,
    this means that STL-based classes can only be used in the nonpublic area of a
    WinRT class. When passed in public methods or properties, these must be converted
    to WinRT types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件必须只在其公共接口中使用WinRT类型。对于C++来说，这意味着基于STL的类只能在WinRT类的非公共区域中使用。在公共方法或属性中传递时，这些类必须转换为WinRT类型。
- en: One typical scenario is an existing C++ type, perhaps written sometime in the
    past, and needs to be used in WinRT for data binding purposes, or at least exposed
    to WinRT clients beyond the current project. Let's see how this transition can
    be achieved.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的场景是一个现有的C++类型，可能是在过去的某个时候编写的，并且需要在WinRT中用于数据绑定的目的，或者至少需要暴露给当前项目之外的WinRT客户端使用。让我们看看如何实现这种过渡。
- en: Converting C++ to WinRT
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将C++转换为WinRT
- en: 'Let''s take a concrete example, and then discuss things more generally. Suppose
    we have the following standard C++ classes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个具体的例子，然后更广泛地讨论。假设我们有以下标准的C++类：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simply stated, a `book` class is defined and has a name, an author, and a collection
    of reviews (`book_review` class). Each review consists of a name, the review content,
    and a numeric rating.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，一个`book`类被定义，并且有一个名称，一个作者，以及一系列的评论（`book_review`类）。每个评论包括一个名称，评论内容和一个数字评分。
- en: These classes are written in standard C++ and have no knowledge of WinRT (or
    C++/CX for that matter).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是用标准C++编写的，对WinRT（或者说C++/CX）一无所知。
- en: As these stand, they can only be used internally in a C++ project. They cannot
    be exported to other WinRT environments (for example, .NET), and even in a C++
    project they cannot benefit from features such as data binding, as these are not
    WinRT classes in any way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些类只能在C++项目中内部使用。它们不能被导出到其他WinRT环境（例如.NET），即使在C++项目中，它们也不能从数据绑定等功能中受益，因为它们在任何方面都不是WinRT类。
- en: These (and similar) classes need to be wrapped in a WinRT class. With C++, this
    can be done in two ways. The first is by using WRL; the benefit is that standard
    C++ is being used (and not Microsoft-specific extensions), but this benefit is
    somewhat diminished, as WinRT is Microsoft specific anyway (at least at the time
    of writing). The second possible benefit is more control of the resulting WinRT
    types. Although this may sound appealing, it's also much harder to do, and unnecessary
    for most cases, so most of the time we'll take the easier approach by leveraging
    C++/CX.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（以及类似的）类需要包装在一个WinRT类中。对于C++来说，可以通过两种方式来实现。第一种是使用WRL；好处是使用标准的C++（而不是微软特定的扩展），但这个好处在一定程度上减弱了，因为WinRT本身就是微软特定的（至少在撰写本文时是这样）。第二个可能的好处是更多地控制生成的WinRT类型。虽然这听起来很吸引人，但这样做也更难，对于大多数情况来说是不必要的，所以大部分时间我们会采用更简单的方法，利用C++/CX。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using WRL to create a WinRT component is sometimes necessary. One example is
    when a single class needs to implement a WinRT interface and a native COM interface.
    For instance, a media encoder or decoder must be COM/WinRT classes that must implement
    not only the `Windows::Media::IMediaExtension` interface, but also the Media Foundation
    non-WinRT interface, `IMFTransform`. WRL is the only way to achieve this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WRL创建WinRT组件有时是必要的。一个例子是当一个单一的类需要实现一个WinRT接口和一个本地的COM接口时。例如，媒体编码器或解码器必须是实现COM/WinRT类，不仅要实现`Windows::Media::IMediaExtension`接口，还要实现媒体基金非WinRT接口`IMFTransform`。WRL是实现这一点的唯一方法。
- en: 'To wrap the book-related classes, we''ll create a Windows Runtime Component
    project (we''ll call it `BookLibrary`). Then, we''ll add a C++/CX WinRT class
    to wrap `book` and `book_review`. Let''s start with the `book_review` wrapper:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包装与书籍相关的类，我们将创建一个Windows Runtime组件项目（我们将其称为`BookLibrary`）。然后，我们将添加一个C++/CX
    WinRT类来包装`book`和`book_review`。让我们从`book_review`包装器开始：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A few things to note:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几点：
- en: The `Bindable` attribute is applied to the class so that proper code is generated
    for data binding to work.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bindable`属性被应用到类上，以便为数据绑定生成适当的代码。'
- en: All the public stuff is WinRT only. The `book_review` wrapped instance is in
    the private section of the class. Any attempt to make it public would cause a
    compilation error. The error states, "**a non-value type cannot have any public
    data members**"; that's the first issue—since WinRT is based on COM, and COM is
    based on interfaces, which are defined by virtual tables, they can only contain
    methods (functions) and not data members.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有公共内容都是WinRT专用的。`book_review`包装实例位于类的私有部分。任何尝试将其公开都将导致编译错误。错误说明，"**非值类型不能有任何公共数据成员**"；这是第一个问题—因为WinRT基于COM，而COM基于接口，接口由虚表定义，它们只能包含方法（函数），而不能包含数据成员。
- en: 'If the data member would turn into a method that returns a non-WinRT type,
    the compiler would issue a different error, "**(MethodName): signature of public
    member contains native type ''book_review''**". The net result is that only WinRT
    types can be used in public members.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据成员转换为返回非WinRT类型的方法，编译器将发出不同的错误，"**(MethodName)：公共成员的签名包含本机类型'book_review'**"。最终结果是只有WinRT类型可以在公共成员中使用。
- en: Standard C++ has no concept of properties. Data members are sometimes wrapped
    by getters and/or setters. These should be turned into WinRT properties, as was
    done with `Name`, `Content`, and `Rating` in the preceding code.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准C++没有属性的概念。数据成员有时会被getter和/或setter包装。这些应该被转换为WinRT属性，就像在前面的代码中对`Name`、`Content`和`Rating`所做的那样。
- en: WinRT coding conventions are to use Pascal casing for class and member names,
    so these may need to change slightly to reflect this (for example, `name` in `book_review`
    is changed to `Name` in `BookReview`, and so on).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT 编码约定是对类和成员名称使用帕斯卡命名法，因此这些可能需要稍微更改以反映这一点（例如，在`book_review`中的`name`被更改为`BookReview`中的`Name`，依此类推）。
- en: One thing that's missing from the `BookReview` class is implementation of `INotifyPropertyChanged`,
    as described in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*.
    This is needed because the `Rating` property can be changed after a `BookReview`
    is constructed. The implementation was omitted for easier focus on the fundamentals,
    but should be implemented in a real scenario.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookReview` 类中缺少的一件事是实现`INotifyPropertyChanged`，如[第5章](ch05.html "第5章 数据绑定")*数据绑定*中所述。这是因为`Rating`属性可以在构造`BookReview`之后更改。该实现被省略，以便更轻松地专注于基本知识，但在实际情况下应该实现。'
- en: 'The header file does not implement the constructor and the properties `Name`
    and `Content`. Here''s the constructor (implemented in the corresponding CPP file):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件没有实现构造函数和属性`Name`和`Content`。这是构造函数（在相应的CPP文件中实现）：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructor (like any other method) must accept WinRT types, using `Platform::String^`
    for any string that's required. This is used to initialize the wrapped `book_review`
    instance (which requires a standard `std::wstring`) by using the `Data` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（就像任何其他方法一样）必须接受WinRT类型，对于任何需要的字符串都要使用`Platform::String^`。这用于初始化包装的`book_review`实例（它需要一个标准的`std::wstring`）通过使用`Data`方法。
- en: 'The `Name` and `Content` properties are read only, but must return WinRT types—a
    `Platform::String^` in this case (which as you may recall wraps a WinRT `HSTRING`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name`和`Content`属性是只读的，但必须返回WinRT类型—在这种情况下是`Platform::String^`（你可能还记得它包装了WinRT的`HSTRING`）：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation is straightforward, this time going in the other direction,
    by using a `Platform::String` constructor that accepts a `const wchar_t*`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单，这次是通过使用接受`const wchar_t*`的`Platform::String`构造函数来进行的。
- en: 'Next, we need to take a look at the wrapper created for the `book` class. This
    is a bit more complicated, as a book holds a `std::vector` of `book_review` objects;
    `std::vector` is not a WinRT type, so it must be projected with another type,
    representing a collection:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要看一下为`book`类创建的包装器。这有点复杂，因为一本书持有`book_review`对象的`std::vector`；`std::vector`不是WinRT类型，因此必须使用另一种类型来投影，表示一个集合：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Name` and `Author` properties are straightforward, and implemented inline.
    The constructor initializes these, and they remain read only throughout the lifetime
    of the object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name`和`Author`属性很简单，并且是内联实现的。构造函数初始化这些属性，并且它们在对象的整个生命周期内保持为只读。'
- en: The original `book` class has a `std::vector<book_review>` instance. In WinRT,
    a collection such as vector should be projected as a `Windows::Foundation::Collections::IVector<BookReview>`
    or `IVectorView<BookReview>` (in the same namespace, the latter being a read-only
    view of the former).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`book`类有一个`std::vector<book_review>`实例。在WinRT中，诸如vector之类的集合应该被投影为`Windows::Foundation::Collections::IVector<BookReview>`或`IVectorView<BookReview>`（在相同的命名空间中，后者是前者的只读视图）。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The namespace prefixes may be a bit confusing. Why is `IVector<T>` in `Windows::Foundation::Collections`
    but `Vector<T>` is in `Platform::Collections`? The rule is simple. WinRT types
    go into the `Windows::*` namespaces, while the specific C++ implementation go
    into the `Platform::*` namespace. Generally speaking, `Platform::*` types cannot
    be exported in WinRT types, as they are C++-specific implementations of WinRT
    interfaces (mostly). The notable exceptions are `Platform::String` and `Platform::Object`,
    which are understood as the replacement for `HSTRING` and `IInspectable` pointers
    respectively, and so are used in public methods and properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间前缀可能有点令人困惑。为什么`IVector<T>`在`Windows::Foundation::Collections`中，而`Vector<T>`在`Platform::Collections`中？规则很简单。WinRT类型放在`Windows::*`命名空间中，而特定的C++实现放在`Platform::*`命名空间中。一般来说，`Platform::*`类型不能导出为WinRT类型，因为它们是WinRT接口的C++特定实现（大多数情况下）。值得注意的例外是`Platform::String`和`Platform::Object`，它们被理解为`HSTRING`和`IInspectable`指针的替代品，因此在公共方法和属性中使用。
- en: 'The `Book` class provides the `Reviews` read-only property as `IVectorView<BookReview^>^`.
    It can return any object implementing this interface. The `Platform::Collections::Vector<T>`
    provides an implementation of `IVector<T>`. `IVector<T>` provides the `GetView`
    method, returning `IVectorView<T>`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book`类提供了`Reviews`只读属性作为`IVectorView<BookReview^>^`。它可以返回任何实现此接口的对象。`Platform::Collections::Vector<T>`提供了`IVector<T>`的实现。`IVector<T>`提供了`GetView`方法，返回`IVectorView<T>`：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The property implementation tries to optimize by caching the `IVectorView<BookReview>`
    result if no new reviews are added, or the property is never called (indicated
    by a `nullptr` in `_reviews`). Otherwise, `Vector<BookReview>` is created, and
    `BookReview` objects are added with `IVector<BookReview>::Append`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 属性实现尝试通过缓存`IVectorView<BookReview>`的结果来优化，如果没有添加新评论，或者从未调用属性（在`_reviews`中表示为`nullptr`）。否则，将创建`Vector<BookReview>`，并使用`IVector<BookReview>::Append`添加`BookReview`对象。
- en: 'The last interesting method to implement is `AddReview`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现的最后一个有趣的方法是`AddReview`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `_reviews` data member is set to `nullptr` to force future calls to the
    `Reviews` property to regenerate the returned collection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将`_reviews`数据成员设置为`nullptr`，以强制将来调用`Reviews`属性时重新生成返回的集合。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When working with collections such as `std::vector` and its WinRT wrappers (such
    as `Vector<T>`), try to use `std::vector` as much as possible. Only use `Vector<T>`
    when exporting from a WinRT class. Make all collection manipulations on native
    C++ types as they have less overhead than WinRT types (because of the WinRT interface
    based nature).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理诸如`std::vector`及其WinRT包装器（如`Vector<T>`）之类的集合时，尽量使用`std::vector`。仅在从WinRT类导出时使用`Vector<T>`。对本机C++类型进行所有集合操作，因为它们的开销比WinRT类型小（因为基于WinRT接口的性质）。
- en: Crossing the ABI
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨ABI
- en: The **Application Binary Interface** (**ABI**) is the boundary between standard
    C++ and WinRT. Any C++ class that is not implemented as a WinRT class cannot cross
    the ABI. The previously used types `std::wstring` and `std::vector<>` are perfect
    examples of types that require projection when crossing the ABI. The compiler
    will not allow non-WinRT types to be used in public sections in `public ref class`
    declarations. See [Chapter 2](ch02.html "Chapter 2. COM and C++ for Windows 8
    Store Apps"), *COM and C++ for Windows 8 Store Apps* for further discussions on
    mapping native C++ types to WinRT types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序二进制接口**（**ABI**）是标准C++和WinRT之间的边界。任何未实现为WinRT类的C++类都不能跨越ABI。先前使用的类型`std::wstring`和`std::vector<>`是需要在跨越ABI时进行投影的完美示例。编译器不允许在`public
    ref class`声明的公共部分中使用非WinRT类型。有关将本机C++类型映射到WinRT类型的进一步讨论，请参见[第2章](ch02.html "第2章。Windows
    8商店应用的COM和C++")，“Windows 8商店应用的COM和C++”。'
- en: Consuming Windows Runtime Components
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Windows Runtime组件
- en: 'Once a Windows Runtime Component is built, a metadata file (`.winmd`) is created
    that indicates which types, interfaces, enums, and so on are exported from the
    library. For example, our `BookLibrary` component DLL produces `BookLibrary.winmd`.
    Opening it in `ILDASM` shows this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Windows Runtime组件后，将创建一个指示从库中导出的类型、接口、枚举等的元数据文件（`.winmd`）。例如，我们的`BookLibrary`组件DLL会生成`BookLibrary.winmd`。在`ILDASM`中打开它会显示如下：
- en: '![Consuming Windows Runtime Components](img/5022_06_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用Windows Runtime组件](img/5022_06_01.jpg)'
- en: 'This clearly shows the exported types, `Book` and `BookReview`. The strange
    interface names represent the internal WinRT implementation provided by the compiler—WinRT
    is all about interfaces. The `*Factory` interfaces exist if there are any non-default
    constructors. For example, opening `__IBookFactory` shows this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地显示了导出的类型，`Book`和`BookReview`。奇怪的接口名称代表编译器提供的内部WinRT实现——WinRT都是关于接口的。如果存在任何非默认构造函数，则存在`*Factory`接口。例如，打开`__IBookFactory`显示如下：
- en: '![Consuming Windows Runtime Components](img/5022_06_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用Windows Runtime组件](img/5022_06_02.jpg)'
- en: Note the `CreateInstance` method, modelled after the single constructor of `Book`.
    This interface is implemented by the activation factory that creates `Book` instances
    (implemented behind the scenes by C++/CX for any `public ref class`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`CreateInstance`方法，该方法是根据`Book`的单个构造函数建模的。这个接口是由创建`Book`实例的激活工厂实现的（由C++/CX在任何`public
    ref class`的后台实现）。
- en: 'The `__IBookPublicNonVirtuals` interface is the one implemented by the `Book`
    class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`__IBookPublicNonVirtuals`接口是由`Book`类实现的接口：'
- en: '![Consuming Windows Runtime Components](img/5022_06_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用Windows Runtime组件](img/5022_06_03.jpg)'
- en: 'Consuming the resulting DLL is possible from any WinRT compliant environment.
    In a C++ project, a reference to the `winmd` file needs to be added. For that
    right-click on the project node in Solution Explorer and select **References…**.
    And then select **Add New Reference** in the **Common Properties** or **Framework
    and References** node (or get to the same location from the project properties):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何符合WinRT的环境中使用生成的DLL。在C++项目中，需要添加对`winmd`文件的引用。为此，请在“解决方案资源管理器”中右键单击项目节点，然后选择**引用…**。然后在**常规属性**或**框架和引用**节点中选择**添加新引用**（或者从项目属性中进入相同位置）：
- en: '![Consuming Windows Runtime Components](img/5022_06_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用Windows Runtime组件](img/5022_06_04.jpg)'
- en: 'After the reference is added (by selecting the `BookLibrary` project, or browsing
    for a `winmd` file in the general case), all exported types can be used immediately,
    just like any other WinRT type. Here''s an example of creating a `Book` with some
    reviews:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引用添加后（通过选择`BookLibrary`项目，或在一般情况下浏览`winmd`文件），所有导出类型都可以立即使用，就像任何其他WinRT类型一样。以下是创建带有一些评论的`Book`的示例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Consuming the `BookLibrary` DLL from other environments, such as .NET can be
    similarly accomplished, as demonstrated in [Chapter 2](ch02.html "Chapter 2. COM
    and C++ for Windows 8 Store Apps"), *COM and C++ for Windows 8 Store Apps*. Each
    environment performs whatever projection is needed, all based on the metadata
    (`winmd`) file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他环境（如.NET）使用`BookLibrary` DLL可以通过类似的方式完成，如[第2章](ch02.html "第2章。Windows 8商店应用的COM和C++")，“Windows
    8商店应用的COM和C++”中所示。每个环境都执行所需的投影，都基于元数据（`winmd`）文件。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WinRT components created with C++ are the only ones that guarantee not involving
    the .NET CLR. Components created by C# will always require the CLR, even if used
    from a C++ client.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++创建的WinRT组件是唯一保证不涉及.NET CLR的组件。由C#创建的组件始终需要CLR，即使从C++客户端使用也是如此。
- en: Other C++ library projects
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他C++库项目
- en: 'Looking at the available project types in Visual Studio 2012 shows two more
    options for creating reusable libraries:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中提供的可用项目类型中，还有两个选项用于创建可重用库：
- en: '![Other C++ library projects](img/5022_06_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![其他C++库项目](img/5022_06_05.jpg)'
- en: The outlined projects create a classic DLL or static library, but do not, by
    default, generate a `winmd` file. These components can only be consumed by other
    C++ Store projects (WinRT components or other Store-enabled libraries). What's
    the difference in relation to a regular, classic C++ DLL, or static library? First,
    any usage of a forbidden Win32 API will cause a compiler error. Second, these
    projects cannot use C++/CX unless specific steps are performed, such as adding
    a reference to the `platform.winmd` and `windows.winmd` files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 概述的项目创建了一个经典的DLL或静态库，但默认情况下不会生成`winmd`文件。这些组件只能被其他C++ Store项目（WinRT组件或其他支持商店的库）使用。与常规的经典C++
    DLL或静态库相比，有什么区别？首先，任何使用被禁止的Win32 API都会导致编译器错误。其次，除非执行特定步骤（例如添加对`platform.winmd`和`windows.winmd`文件的引用），否则这些项目不能使用C++/CX。
- en: Custom control templates
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义控件模板
- en: 'In [Chapter 4](ch04.html "Chapter 4. Layout, Elements, and Controls"), *Layout,
    Elements, and Controls*, we discussed various elements and controls provided by
    WinRT. Customizing the appearance of elements and controls can be done using the
    following levels (from simple to complex). Of course, not all elements/controls
    support all levels:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。布局、元素和控件")中，我们讨论了WinRT提供的各种元素和控件。可以使用以下级别（从简单到复杂）来自定义元素和控件的外观。当然，并非所有元素/控件都支持所有级别：
- en: Change property values; by far the simplest customizations are achieved by changing
    properties. Common examples are the font-related properties (`FontSize`, `FontFamily`,
    and so on), `Foreground` and `Background`, and many others.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改属性值；到目前为止，最简单的自定义是通过更改属性来实现的。常见的例子是与字体相关的属性（`FontSize`，`FontFamily`等），`Foreground`和`Background`，以及许多其他属性。
- en: For content controls (those deriving from `ContentControl`), the `Content` property
    can be set to any element, as complex as required. For example, this can make
    a `Button` show images, text, and anything else that's required, while still maintaining
    the expected button behavior.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内容控件（派生自`ContentControl`），`Content`属性可以设置为任何所需的元素。例如，这可以使`Button`显示图像、文本和其他任何所需的内容，同时仍保持预期的按钮行为。
- en: Data templates may be used for properties that support it, to display data objects
    in a rich and meaningful way. `ContentControl::Content` supports this, as it's
    typed as `Platform::Object^`, meaning it can accept anything. If this is a derived
    type that is not `UIElement`, the `DataTemplate` is used if provided (in this
    case through the `ContentControl::ContentTemplate` property). This is also used
    by all `ItemsControl` derivatives through the `ItemTemplate` property.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模板可以用于支持它的属性，以丰富和有意义的方式显示数据对象。`ContentControl::Content`支持此功能，因为它的类型为`Platform::Object^`，这意味着它可以接受任何东西。如果这是一个不是`UIElement`的派生类型，则如果提供了`DataTemplate`，则会使用它（在这种情况下，通过`ContentControl::ContentTemplate`属性）。这也适用于所有`ItemsControl`派生类，通过`ItemTemplate`属性。
- en: Types derived from `ItemsControl` have the `ItemContainerStyle` and `ItemsPanel`
    properties that can further customize the way data is presented.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ItemsControl`派生的类型具有`ItemContainerStyle`和`ItemsPanel`属性，可以进一步自定义数据的呈现方式。
- en: Although the preceding list is impressive, there are times when these customizations
    are not enough. For example, a `Button` is always rectangular; and although it
    can contain anything (it's a `ContentControl`), it can never be elliptic. Some
    things are just "baked" into the control's appearance. This is where control templates
    come in.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的列表令人印象深刻，但有时这些自定义还不够。例如，`Button`始终是矩形的；尽管它可以包含任何东西（它是一个`ContentControl`），但它永远不可能是椭圆形的。有些东西就是“固定”在控件的外观中。这就是控件模板发挥作用的地方。
- en: The fundamental difference between elements and controls is the existence of
    the `Control::Template` property that defines the way the control appears. Elements
    don't have this property. For example, an `Ellipse` is an ellipse, it cannot look
    like anything else, because that would violate its very definition. Thus, an `Ellipse`
    is an element and not a control.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 元素和控件之间的根本区别在于`Control::Template`属性的存在，它定义了控件的外观方式。元素没有这个属性。例如，椭圆是一个椭圆，它不能看起来像其他任何东西，因为那将违反它的定义。因此，椭圆是一个元素而不是一个控件。
- en: Controls (deriving from `Control`) can change their `Template` property and
    have a different look (but preserve functionality). In fact, all controls have
    default templates that WinRT provides (otherwise, controls would have no "look").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 控件（派生自`Control`）可以更改它们的`Template`属性并具有不同的外观（但保留功能）。实际上，所有控件都有WinRT提供的默认模板（否则，控件将没有“外观”）。
- en: Building a control template
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建控件模板
- en: A control template is of the type `ControlTemplate` . It's very similar to a
    `DataTemplate` (both derive from `FrameworkTemplate`), and can contain a single
    `UIElement` (typically a `Panel`) that comprises the control's look.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 控件模板的类型是`ControlTemplate`。它与`DataTemplate`非常相似（两者都派生自`FrameworkTemplate`），可以包含一个`UIElement`（通常是一个`Panel`），构成控件的外观。
- en: As an example, we'll build an alternate control template for the `ProgressBar`
    control. We'll start with simple steps, and add features as we go along.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为`ProgressBar`控件构建一个替代的控件模板。我们将从简单的步骤开始，然后逐步添加功能。
- en: 'A control template is typically created as a resource, so it can be reused
    more easily. Here''s a first simple attempt:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控件模板通常被创建为资源，这样可以更容易地重用。这是一个简单的尝试：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To use the template, we simply set it to the `Template` property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模板，我们只需将其设置为`Template`属性：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The idea here is to create a dark blue rectangle on top of which another rectangle
    (with rounded corners) will show the current progress. The result, however, is
    less than ideal (the top `ProgressBar` is using the default template):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是在一个深蓝色的矩形上面创建另一个矩形（带有圆角），用来显示当前的进度。然而，结果并不理想（顶部的`ProgressBar`正在使用默认模板）：
- en: '![Building a control template](img/5022_06_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![构建控件模板](img/5022_06_06.jpg)'
- en: 'The `ProgressBar` doesn''t seem to show any progress (`Value="30"` should have
    shown 30 percent filled `ProgressBar`, as the default `Maximum` is `100`, just
    like the top `ProgressBar`). And why would it? We just created a `Rectangle`,
    which has a default `Width` of `0`. One way to get around this is to bind the
    `Width` property of the second `Rectangle` to the `Value` property of the `ProgressBar`.
    Here''s one way to do it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`似乎没有显示任何进度（`Value="30"`应该显示30%填充的`ProgressBar`，因为默认的`Maximum`是`100`，就像顶部的`ProgressBar`一样）。为什么会这样呢？我们只是创建了一个`Rectangle`，它的默认`Width`是`0`。解决这个问题的一种方法是将第二个`Rectangle`的`Width`属性绑定到`ProgressBar`的`Value`属性。以下是一种方法：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`TemplateBinding` is a markup extension that binds to the control being templated.
    This is necessary, as we can''t use the `Source` or `ElementName` with a regular
    `Binding`. Here''s the result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateBinding`是一个绑定到正在被模板化的控件的标记扩展。这是必要的，因为我们不能使用`Source`或`ElementName`与常规的`Binding`。以下是结果：'
- en: '![Building a control template](img/5022_06_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![构建控件模板](img/5022_06_07.jpg)'
- en: This is certainly better, but the progress indicator seems small compared to
    the reference `ProgressBar` at the top. The reason is simple, `Value` is taken
    as `Width`, but it really should be proportional to the width of the entire `ProgressBar`.
    We can solve this by using a value converter, but there is a better way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然更好，但与顶部的参考`ProgressBar`相比，进度指示器似乎很小。原因很简单，`Value`被视为`Width`，但实际上应该与整个`ProgressBar`的宽度成比例。我们可以通过使用值转换器来解决这个问题，但有一个更好的方法。
- en: 'The `ProgressBar` already has the smarts to set the `Width` property of some
    elements to the required proportional value. We just need to tell it which element
    it should be. It turns out this element must have a specific name, in this case
    `ProgressBarIndicator`. All we need to do is set the `x:Name` property to this
    value on the relevant element, our second `Rectangle`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`已经具备智能功能，可以将某些元素的`Width`属性设置为所需的比例值。我们只需要告诉它应该是哪个元素。事实证明，这个元素必须有一个特定的名称，在这种情况下是`ProgressBarIndicator`。我们只需要在相关元素上将`x:Name`属性设置为这个值，即我们的第二个`Rectangle`：'
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '![Building a control template](img/5022_06_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![构建控件模板](img/5022_06_08.jpg)'
- en: Now it looks exactly right. Where did that special name come from? The secret
    is looking at the control's default template, looking for specially named parts.
    All the default control templates can be found in the file `C:\Program Files (x86)\Windows
    Kits\8.0\Include\WinRT\Xaml\Design\Generic.xaml` (on 32-bit Windows systems, the
    directory starts with `C:\Program Files`). The control templates are part of the
    default styles for the controls.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来完全正确。这个特殊的名称是从哪里来的？秘密在于查看控件的默认模板，寻找特别命名的部分。所有默认控件模板都可以在文件`C:\Program Files
    (x86)\Windows Kits\8.0\Include\WinRT\Xaml\Design\Generic.xaml`中找到（在32位Windows系统上，目录以`C:\Program
    Files`开头）。控件模板是控件的默认样式的一部分。
- en: Looking at the `ProgressBar` control template, most elements are named with
    uninteresting names, for example, `e1`, `e2`, and so on—`ProgressBarIndicator`
    stands out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`ProgressBar`控件模板，大多数元素都以无趣的名称命名，例如`e1`，`e2`等等——`ProgressBarIndicator`脱颖而出。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In WPF and Silverlight, the `TemplatePart` attribute placed on controls indicate
    which named parts are looked up by the control and what their type should be.
    Although WinRT defines the `TemplatePart` attribute, it doesn't seem to be used
    in the current version of WinRT, so we resign ourselves to doing some "guesswork".
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF和Silverlight中，放置在控件上的`TemplatePart`属性指示控件查找的命名部分以及它们的类型应该是什么。尽管WinRT定义了`TemplatePart`属性，但在当前版本的WinRT中似乎没有使用，所以我们不得不做一些“猜测”。
- en: Using the control's properties
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用控件的属性
- en: 'The template now functions correctly (or so it seems). Changing properties,
    such as `Foreground` or `Background`, has no effect when using our new template.
    That''s because the template doesn''t use them in any way. Sometimes, this is
    what we want, but typical templates want to provide ways to customize their own
    appearance; one way is to leverage existing properties on the control. This was
    already briefly demonstrated with `TemplateBinding` to the `Value` property, but
    here''s a more interesting template, which uses several properties from `ProgressBar`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模板现在正常运行（或看起来是这样）。更改属性，例如`Foreground`或`Background`，在使用我们的新模板时没有任何效果。这是因为模板没有以任何方式使用它们。有时，这就是我们想要的，但典型的模板希望提供自定义外观的方法；一种方法是利用控件上的现有属性。这已经在`TemplateBinding`到`Value`属性中简要演示过，但这里有一个更有趣的模板，它使用了`ProgressBar`的几个属性：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, there are several interesting things to note.
    The `TemplateBinding` markup extension is used to bind to the templated control's
    properties (`Background` and `Foreground`); `TemplateBinding` works for one-way
    bindings only (source to target, but not the other way around). For two-way binding
    properties, the longer syntax must be used, that is, a `Binding` expression with
    the `RelativeSource` property set to another markup extension, named `RelativeSource`
    (which should not be confused with the `Binding::RelativeSource` property name),
    which accepts `Mode` (also as a constructor parameter) that can be either `Self`
    (target and source are the same object, not useful here) or `TemplatedParent`,
    which means the control that is being templated, which is exactly what we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有几件有趣的事情需要注意。`TemplateBinding`标记扩展用于绑定到模板控件的属性（`Background`和`Foreground`）；`TemplateBinding`仅适用于单向绑定（源到目标，但反之则不行）。对于双向绑定属性，必须使用更长的语法，即`Binding`表达式，其中`RelativeSource`属性设置为另一个标记扩展，名为`RelativeSource`（不应与`Binding::RelativeSource`属性名称混淆），它接受`Mode`（也作为构造函数参数），可以是`Self`（目标和源是相同的对象，在这里没有用）或`TemplatedParent`，这意味着正在被模板化的控件，这正是我们想要的。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`TemplateBinding` should have worked here as well, as we''re only interested
    in the one-way binding. But, since `Value` can be bound two way, `TemplateBinding`
    fails. This seems to be a bug in the current WinRT implementation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用控件的属性](img/5022_06_09.jpg)'
- en: 'Here''s a `ProgressBar` that uses this template:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上很难捕捉到静态图像，因为“ProgressBar”显示了由小圆圈组成的有趣的非线性动画。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '![Using the control''s properties](img/5022_06_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: 这是结果：
- en: Handling state changes
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TemplateBinding`在这里也应该起作用，因为我们只对单向绑定感兴趣。但是，由于`Value`可以进行双向绑定，`TemplateBinding`失败了。这似乎是当前WinRT实现中的一个错误。'
- en: 'A `ProgressBar` normally shows the progress of an operation. Sometimes, however,
    the application doesn''t know the progress of an operation—it only knows that
    it''s underway. A `ProgressBar` can indicate this by setting its `IsIndeterminate`
    property to `true`. Here''s how a standard `ProgressBar` appears in this mode:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`通常显示操作的进度。然而，有时应用程序并不知道操作的进度——它只知道正在进行中。`ProgressBar`可以通过将其`IsIndeterminate`属性设置为`true`来指示这一点。以下是标准`ProgressBar`在此模式下的外观：'
- en: '![Handling state changes](img/5022_06_10.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![处理状态变化](img/5022_06_10.jpg)'
- en: It's actually difficult to capture a static image of that, as the `ProgressBar`
    shows an interesting nonlinear animation consisting of small circles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![处理状态变化](img/5022_06_11.jpg)'
- en: Setting `IsIndeterminate` to `true` on the `ProgressBar` that uses our template
    has no effect on the way the `ProgressBar` is shown. That's because our control
    didn't take into account this property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将`IsIndeterminate`设置为`true`的`ProgressBar`对使用我们的模板显示`ProgressBar`的方式没有影响。这是因为我们的控件没有考虑到这个属性。
- en: How can we solve that? One way would be to add something to the control template
    that would be hidden by default, but if `IsIndeterminate` turns to `true`, something
    will become visible and indicate that the `ProgressBar` is in that special mode
    (with a value converter, for instance). Although this is technically possible,
    that's not the way it's typically done. One of the reasons is that some state
    changes can be difficult to monitor with just bindings and value converters—for
    example, if the mouse cursor hovers over the control (not relevant for a `ProgressBar`,
    but relevant for many other controls), a property may not be enough. And how would
    we start an animation?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决这个问题？一种方法是向控件模板添加一些默认情况下隐藏的内容，但如果`IsIndeterminate`变为`true`，则会显示出来，并指示`ProgressBar`处于特殊模式（例如使用值转换器）。尽管从技术上讲这是可能的，但这通常不是通常的做法。其中一个原因是，有些状态变化只通过绑定和值转换器可能很难监控——例如，如果鼠标光标悬停在控件上（对于`ProgressBar`来说不相关，但对于许多其他控件来说是相关的），一个属性可能不足够。那么我们如何开始动画呢？
- en: All these state changes and reactions are handled through an auxiliary object,
    known as `VisualStateManager`. A control transitions between states; these states
    and their transitions can be captured by the `VisualStateManager`. For each change,
    a set of `Storyboard` objects can be provided; these `Storyboard` objects represent
    animations in the general case, or simple state changes in a particular case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些状态变化和反应都是通过一个辅助对象`VisualStateManager`处理的。控件在各个状态之间转换；这些状态及其转换可以被`VisualStateManager`捕获。对于每个变化，可以提供一组`Storyboard`对象；这些`Storyboard`对象代表一般情况下的动画，或者特定情况下的简单状态变化。
- en: 'Here''s an extended template that deals with the effects of the `IsIndeterminate`
    property:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理`IsIndeterminate`属性效果的扩展模板：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `VisualStateManager` has one interesting property, which is an attached
    property, `VisualStateGroups`. For each group, one state is always active; this
    means a control can be in several states at once. For example, a button can be
    in a pressed state and in a keyboard-focused state. The `VisualStateGroups` property
    must be set on the top-level `Panel` comprising the control template (a `Grid`
    in our case).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度正在进行动画，淡入淡出这个矩形。
- en: 'Each `VisualStateGroup` consists of `VisualState` objects that indicate what
    to do (which animations to run) for each state. The state names must be the correct
    names, as the control changes to these states based on its internal logic. How
    did we know which state groups exist and which states are in each group? This
    is done by looking at the default control template. This can be done by looking
    in the aforementioned file, but can also be achieved with Visual Studio 2012 by
    right-clicking on a control, and selecting **Edit Template** | **Edit a Copy…**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`VisualStateGroup`由`VisualState`对象组成，指示每个状态要执行的操作（要运行哪些动画）。状态名称必须是正确的名称，因为控件根据其内部逻辑转换到这些状态。我们如何知道存在哪些状态组以及每个组中有哪些状态？这是通过查看默认控件模板来完成的。可以通过查看前面提到的文件来完成这项工作，也可以通过在Visual
    Studio 2012中右键单击控件，然后选择**编辑模板** | **编辑副本...**来实现：
- en: '![Handling state changes](img/5022_06_11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: 处理状态变化
- en: 'In the control template, a third rectangle named `IndetRect` was created with
    an initial opacity of zero, making it invisible. When the `ProgressBar` moves
    into the `Indeterminate` state, an animation is executed using the `DoubleAnimation`
    class (animating a property of the type `double`) that changes the opacity of
    that rectangle to `1` (fully shown) in one second (the `Duration` property), with
    auto reverse (`AutoReverse="true"`) and animating forever (`RepeatBehavior="Forever"`).
    Here''s the result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在控件模板中，创建了一个名为`IndetRect`的第三个矩形，其初始不透明度为零，使其不可见。当`ProgressBar`进入`Indeterminate`状态时，将使用`DoubleAnimation`类（对`double`类型的属性进行动画处理）执行动画，将该矩形的不透明度在一秒钟内更改为`1`（完全显示），并具有自动反转（`AutoReverse="true"`）和永久动画（`RepeatBehavior="Forever"`）。这是结果：
- en: '![Handling state changes](img/5022_06_12.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: 这是一个使用此模板的“ProgressBar”：
- en: And the opacity is animating, fading in and out of this rectangle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![处理状态变化](img/5022_06_12.jpg)'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`VisualStateManager`有一个有趣的属性，即一个附加属性`VisualStateGroups`。对于每个组，始终有一个状态处于活动状态；这意味着控件可以同时处于多个状态。例如，按钮可以处于按下状态和键盘焦点状态。`VisualStateGroups`属性必须设置在包含控件模板的顶层“Panel”上（在我们的情况下是一个“Grid”）。'
- en: Complete cover of animations is beyond the scope of this book, but this should
    give you a sense of it. A `Storyboard` represents a time line, in which animation
    objects are played, in this case a `DoubleAnimation` object, but there are many
    others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完全覆盖动画超出了本书的范围，但这应该让你对它有所了解。`Storyboard`表示一个时间线，在其中播放动画对象，本例中是一个`DoubleAnimation`对象，但还有许多其他对象。
- en: How does the state actually change? The control, with its own logic, calls the
    static `VisualStateManager::GoToState` method, setting the new state within a
    particular group. For a control template's author, that does not matter; the only
    thing that matters is setting the required animations according to the expected
    state changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 状态实际上是如何改变的？控件通过其自己的逻辑调用静态的`VisualStateManager::GoToState`方法，设置特定组内的新状态。对于控件模板的作者来说，这并不重要；唯一重要的是根据预期的状态更改设置所需的动画。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `VisualStateManager` also allows specifying the actual transition to take
    place when state changes occur. This is in contrast to the actual state itself.
    What this means is that a transition can be temporary when moving to a particular
    state, but the state itself may have different animations. For further information,
    refer to the MSDN documentation, starting with the `VisualStateGroup::Transitions`
    property and the `VisualTransition` class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualStateManager`还允许指定状态更改发生时要进行的实际过渡。这与实际状态本身相反。这意味着当移动到特定状态时，过渡可以是临时的，但状态本身可能具有不同的动画。有关更多信息，请参阅MSDN文档，从`VisualStateGroup::Transitions`属性和`VisualTransition`类开始。'
- en: Customizing using attached properties
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用附加属性进行自定义
- en: The `ProgressBar` template created thus far used properties set on the `ProgressBar`
    itself using the `TemplateBinding` markup extension, or a regular `Binding` with
    a `Source` specified with the `RelativeSource` markup extension and with `TemplatedParent`
    as its `Mode`. What about adding properties that only make sense for our template?
    For example, in the preceding template definition, the `ProgressBar` shows a text
    string of its value. What if we wanted to allow the template user to hide the
    text or change its color?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的`ProgressBar`模板使用`TemplateBinding`标记扩展或使用`Binding`和`RelativeSource`标记扩展指定`Source`，并将`TemplatedParent`作为其`Mode`设置在`ProgressBar`本身上设置的属性。那么如何添加仅对我们的模板有意义的属性呢？例如，在前面的模板定义中，`ProgressBar`显示其值的文本字符串。如果我们想允许模板用户隐藏文本或更改其颜色呢？
- en: The `ProgressBar` was not created with all this in mind. And why would it? It
    was created with the needed properties for some customization level; this is acceptable
    for the default `ProgressBar` template.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`并没有考虑到所有这些。为什么要考虑呢？它是为一些自定义级别所需的属性而创建的；这对于默认的`ProgressBar`模板是可以接受的。'
- en: One way to get around this is to create a new class that derives from `ProgressBar`
    and add the required properties. Although this works (and we'll discuss custom
    controls in the next section), this is somewhat inelegant—we don't need any new
    functionality from the `ProgressBar`, rather we need some properties to tweak
    its template.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是创建一个从`ProgressBar`派生的新类，并添加所需的属性。虽然这样可以解决问题（我们将在下一节讨论自定义控件），但这有点不够优雅——我们不需要`ProgressBar`的任何新功能，而是需要一些属性来调整其模板。
- en: A more elegant solution is to use attached properties, which are defined on
    one class, but can be used by any other class (it must be derived from `DependencyObject`,
    though). Technically, we can look for appropriate attached properties defined
    elsewhere in WinRT, but it's better to create a new class that defines these attached
    properties and use them in the `ProgressBar` template.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更优雅的解决方案是使用附加属性，它们在一个类上定义，但可以被任何其他类使用（尽管它必须派生自`DependencyObject`）。从技术上讲，我们可以在WinRT中寻找适当的附加属性，但最好创建一个新类来定义这些附加属性，并在`ProgressBar`模板中使用它们。
- en: Defining an attached property
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义一个附加属性
- en: 'Attached properties are dependency properties (which we''ll discuss in detail
    in the next section) that are registered by calling the static `DependencyProperty::RegisterAttached`
    method. This sets up a static field that manages this property for all objects
    using it. Two static methods accompany the registration that actually sets and
    gets the attached property value on an object. Here''s the declaration of a class,
    `ProgressBarProperties` that defines a single attached property, `ShowText`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 附加属性是依赖属性（我们将在下一节详细讨论）通过调用静态的`DependencyProperty::RegisterAttached`方法注册的。这将设置一个静态字段，为所有使用它的对象管理此属性。注册附带两个静态方法，实际上在对象上设置和获取附加属性的值。这里是一个类`ProgressBarProperties`的声明，它定义了一个单独的附加属性`ShowText`：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The static field must be initialized and this is done in the CPP file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段必须在CPP文件中初始化：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `RegisterAttached` method accepts the property name, its type (as a `TypeName`
    structure), the type of its owner, and a `PropertyMetadata` instance that can
    accept the default value of the property (if not set on an actual object and that
    property is queried). A more detailed explanation of `PropertyMetadata` can be
    found in the next section, where dependency properties are described; for now,
    we'll focus on the attached property usage in control templates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterAttached`方法接受属性名称，其类型（作为`TypeName`结构），其所有者的类型，以及可以接受属性的默认值的`PropertyMetadata`实例（如果未在实际对象上设置并且查询该属性）。有关`PropertyMetadata`的更详细解释可以在下一节找到，那里描述了依赖属性；现在，我们将专注于控件模板中的附加属性的使用。'
- en: 'The `TextBlock` inside the `ProgressBar` template can use the attached property
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`模板中的`TextBlock`可以使用附加属性如下：'
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The parenthesis around the property path is required, otherwise the XAML parser
    fails to understand the expression correctly, which results in a runtime binding
    failure. The converter used is for converting a `Boolean` to a `Visibility` enumeration,
    as was demonstrated in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data
    Binding*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 属性路径周围的括号是必需的，否则XAML解析器无法正确理解表达式，导致运行时绑定失败。所使用的转换器是将`Boolean`转换为`Visibility`枚举，就像在[第5章](ch05.html
    "第5章。数据绑定")中演示的那样，*数据绑定*。
- en: 'Clearly, defining and registering an attached property is simple, yet verbose.
    One solution would be to define macros to automate this boilerplate code. The
    downloadable source for this chapter has some macros for defining and registering
    dependency and attached properties that should make these easier to work with
    (in a file called `DPHelper.h`). Here''s an example of another attached property,
    defined using the aforementioned macros. First, inside the `ProgressBarProperties`
    class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，定义和注册附加属性是简单而冗长的。一个解决方案是定义宏来自动化这些样板代码。本章的可下载源代码中有一些用于定义和注册依赖属性和附加属性的宏，这应该使得这些更容易使用（在一个名为`DPHelper.h`的文件中）。这是另一个附加属性的示例，使用上述宏进行定义。首先，在`ProgressBarProperties`类内部：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And in the implementation file (to initialize the static field):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在实现文件中（初始化静态字段）：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This property can be used inside the template on the `TextBlock` as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性可以在模板中的`TextBlock`上使用，如下所示：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Custom elements
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义元素
- en: Control templates provide a powerful and complete way to change the control's
    appearance. But that's just appearance—the control still behaves in the same way.
    If a new functionality is required, templates are not enough, and a new class
    should be created. This is where custom elements come in.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 控件模板提供了改变控件外观的强大和完整的方式。但这只是外观 - 控件仍然以相同的方式行为。如果需要新的功能，模板是不够的，需要创建一个新的类。这就是自定义元素的用武之地。
- en: There are several ways of authoring custom elements in WinRT, we'll take a look
    at the two most frequently used controls—user controls and custom controls. Then,
    we'll briefly discuss how to create custom panels and custom shapes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinRT中，有几种编写自定义元素的方法，我们将看一下两种最常用的控件 - 用户控件和自定义控件。然后，我们将简要讨论如何创建自定义面板和自定义形状。
- en: User controls
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户控件
- en: A user control is typically used to group related elements and controls together,
    for the purpose of re-use. Appropriate properties and events are exposed from
    this control, providing easy access to its functionality. As an added bonus, Visual
    Studio supports user control UI design, just as it does for a regular page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户控件通常用于将相关元素和控件组合在一起，以便重复使用。从此控件中公开适当的属性和事件，以便轻松访问其功能。作为额外的奖励，Visual Studio支持用户控件UI设计，就像对常规页面一样。
- en: User controls derive from the `UserControl` class. The UI design is effectively
    the `Content` property of the control, just like a `ContentControl` . They are
    typically placed in their own Windows Runtime Component project so that they can
    be used in any WinRT project, using C++ or another language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用户控件派生自`UserControl`类。UI设计实际上是控件的`Content`属性，就像`ContentControl`一样。它们通常放在自己的Windows
    Runtime组件项目中，以便可以在任何WinRT项目中使用C++或其他语言。
- en: Creating a color picker user control
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建颜色选择器用户控件
- en: 'As an example of a user control, we''ll create a color picker control, which
    allows for selecting a solid color by manipulating three sliders for the red,
    green, and blue color components (RGB). To begin, after creating a Windows Runtime
    Component project, we can add a new item of the type **User Control** to the project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户控件的一个示例，我们将创建一个颜色选择器控件，它允许通过操作红色、绿色和蓝色三个滑块来选择纯色（RGB）。首先，在创建Windows Runtime组件项目后，我们可以向项目添加一个新项目类型为**用户控件**的项目：
- en: '![Creating a color picker user control](img/5022_06_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![创建颜色选择器用户控件](img/5022_06_13.jpg)'
- en: A design surface is opened with the usual pair of files created, `ColorPicker.h`
    and `ColorPicker.cpp`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开设计表面，并创建了通常的一对文件，`ColorPicker.h`和`ColorPicker.cpp`。
- en: The first thing we want to do is define properties that would provide easy access
    to the user control's functionality. Most of the time, these will not be simple
    properties that wrap some private field, but rather dependency properties.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是定义属性，以便轻松访问用户控件的功能。大多数情况下，这些属性不会是简单的包装某个私有字段的属性，而是依赖属性。
- en: Dependency properties
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖属性
- en: 'Simple properties that wrap a field (perhaps with some validation in the setter)
    lack certain features that are desirable when working with a UI framework. Specifically,
    WinRT dependency properties have the following characteristics:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的属性包装了一个字段（可能在setter中进行了一些验证），缺少在使用UI框架时希望的某些功能。具体来说，WinRT依赖属性具有以下特点：
- en: Change notifications when the property's value is changed.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性的值发生变化时，进行更改通知。
- en: Various providers can attempt to set the property's value, but only one such
    provider wins at a time. Nevertheless, all values are retained. If the winning
    provider goes away, the property's value is set to the next winner in the line.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种提供程序可以尝试设置属性的值，但一次只有一个这样的提供程序获胜。尽管如此，所有值都会被保留。如果获胜的提供程序消失，属性的值将设置为下一个获胜者。
- en: Property value inheritance down the visual tree (for some predefined set of
    properties).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性值在可视树中向下继承（对于一些预定义的属性）。
- en: No memory is allocated for a property's value if that value is never changed
    from its default
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性的值从其默认值中未发生更改，则不会为该属性的值分配内存
- en: These features provide the basis of some of WinRT's powerful capabilities, such
    as data binding, styles, and animation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性为WinRT的一些强大功能提供了基础，例如数据绑定、样式和动画。
- en: On the surface, these properties look the same as any other property—a getter
    and a setter. But no private fields are involved. Instead, a static field manages
    the property values for all instances using that property.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面上，这些属性看起来与任何其他属性一样 - 有一个getter和一个setter。但没有涉及私有字段。相反，一个静态字段管理着所有实例使用该属性的属性值。
- en: Defining dependency properties
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义依赖属性
- en: 'Here''s the way to define a dependency property (must be done in a class that
    derives from `DependencyObject`, which is always the case with `UserControl`).
    A private static field manages the property, which is exposed publicly as a read-only
    property. A setter and getter exist as easy access to the actual `set` and `get`
    methods, implemented in the `DependencyObject` base class. The following code
    demonstrates the creation of a dependency property of the type `Windows::UI::Color`
    named `SelectedColor` that is exposed by the `ColorPicker` user control:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义依赖属性的方法（必须在从`DependencyObject`派生的类中完成，这总是与`UserControl`一样的情况）。一个私有的静态字段管理属性，该属性公开为只读属性。存在一个setter和getter作为实际`set`和`get`方法的简单访问，这些方法在`DependencyObject`基类中实现。以下代码演示了创建一个名为`SelectedColor`的`Windows::UI::Color`类型的依赖属性，该属性由`ColorPicker`用户控件公开：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A few things to note:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几件事：
- en: The `GetValue` and `SetValue` properties are inherited from `DependencyObject`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetValue`和`SetValue`属性是从`DependencyObject`继承的。'
- en: The static property's name should be suffixed with `Property`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态属性的名称应该以`Property`结尾。
- en: It's never a good idea to add more code to the `get()` or `set()` parts of the
    property, because these are sometimes not used and one can call the `GetValue`
    and `SetValue` methods directly; this is done by the XAML parser, for example.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`get()`或`set()`部分添加更多代码从来都不是一个好主意，因为有时这些部分不会被使用，可以直接调用`GetValue`和`SetValue`方法；例如，XAML解析器就是这样做的。
- en: 'The missing part is the initialization of the static field, typically done
    in the `.cpp` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的部分是静态字段的初始化，通常在`.cpp`文件中完成：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A **dependency property** (**DP**) is registered by calling the static `DependencyProperty::Register`
    method, passing the property name, its type (as a `TypeName` structure), the containing
    type, and the `PropertyMetadata` object, which can accept the property's default
    value (`Colors::Black` in this case) and an optional callback to invoke when the
    property changes. This will be useful in the `ColorPicker` case.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用静态的`DependencyProperty::Register`方法注册**依赖属性**（**DP**），传递属性名称、其类型（作为`TypeName`结构）、包含类型和`PropertyMetadata`对象，该对象可以接受属性的默认值（在本例中为`Colors::Black`）和在属性更改时调用的可选回调。这将在`ColorPicker`的情况下很有用。
- en: 'This code can repeat numerous times, once for each DP. This clearly calls out
    for some helper macros. Here are three other properties defined on the `ColorPicker`
    using the macros. First, in the header file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以重复多次，每个DP都要重复一次。这显然需要一些辅助宏。以下是使用宏在`ColorPicker`上定义的另外三个属性。首先，在头文件中：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the `.cpp` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`.cpp`文件：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is considerably shorter (and less error prone) than the verbose version.
    These macros can be found in the `DPHelper.h` file, available with the downloadable
    source code for this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这比冗长的版本要短得多（也更少出错）。这些宏可以在`DPHelper.h`文件中找到，该文件可在本章的可下载源代码中找到。
- en: 'The next thing to do is implement the change notification methods, if they
    exist. In this case, `Red`, `Green`, and `Blue` should reflect the `SelectedColor`
    property color components, and vice versa. First, if `Red`, `Green`, or `Blue`
    changes, use the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是实现更改通知方法（如果存在的话）。在这种情况下，`Red`、`Green`和`Blue`应该反映`SelectedColor`属性的颜色组件，反之亦然。首先，如果`Red`、`Green`或`Blue`发生变化，使用以下代码片段：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the registered handler must be static, it's easier to delegate the actual
    work to an instance method (`OnRGBChangedInternal` in the preceding code). The
    code updates the `SelectedColor` property based on the changed RGB property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注册的处理程序必须是静态的，将实际工作委托给实例方法（在前面的代码中为`OnRGBChangedInternal`）更容易。该代码根据更改的RGB属性更新`SelectedColor`属性。
- en: 'The other direction implementation is along the same lines:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方向的实现也是类似的：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code snippets may seem to create an infinite loop—if `Red` changes,
    `SelectedColor` changes, which changes `Red` again, and so on. Fortunately, this
    is handled automatically by the dependency property mechanism, which invokes the
    callback if the property value actually changes; setting to the same value does
    not invoke the callback.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段似乎会创建一个无限循环 - 如果`Red`改变，`SelectedColor`改变，这又会改变`Red`，依此类推。幸运的是，依赖属性机制会自动处理这个问题，如果属性值实际上发生变化，它会调用回调；设置为相同的值不会调用回调。
- en: Building the UI
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建UI
- en: 'The next step is to create the actual UI of the user control using regular
    XAML. Binding expressions can be used to bind to properties exposed by the control
    (since these are DPs, they provide automatic change notification for bindings).
    Here''s a UI for the `ColorPicker` with the sliders bound to the `Red`, `Green`,
    and `Blue` properties and a `Rectangle` that binds to the `SelectedColor` property
    of the control (default XAML namespaces are omitted):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用常规XAML创建用户控件的实际UI。可以使用绑定表达式绑定到控件公开的属性（因为这些是DP，它们为绑定提供自动更改通知）。以下是`ColorPicker`的UI，滑块绑定到`Red`、`Green`和`Blue`属性，以及一个`Rectangle`绑定到控件的`SelectedColor`属性（默认XAML命名空间被省略）：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding events
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加事件
- en: 'Events can be added to the user control to notify interested parties of interesting
    events. Here''s an event added in the header file of the control:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向用户控件添加事件，以通知感兴趣的方。以下是在控件的头文件中添加的一个事件：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The event uses the `EventHandler<T>` delegate that requires the client to provide
    a method that accepts a `Platform::Object^` and a `T` (`Color` in this case).
    We''ll raise the event when the `SelectedColor` property changes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件使用`EventHandler<T>`委托，该委托要求客户端提供一个接受`Platform::Object^`和`T`（在本例中为`Color`）的方法。当`SelectedColor`属性改变时，我们将触发该事件：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the ColorPicker
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ColorPicker
- en: 'Now we can use the `ColorPicker` in another project, by adding a reference
    in the usual way and adding an XML namespace mapping. Then just use the control
    like any other. Here''s an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过通常的方式在另一个项目中使用`ColorPicker`，并添加XML命名空间映射。然后就像使用其他控件一样使用该控件。以下是一个例子：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The control is placed inside a border and its `SelectedColorChanged` event
    is handled as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 控件放置在边框内，其`SelectedColorChanged`事件处理如下：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This changes the `TextBlock` at the bottom of the control. This is how it looks
    at runtime:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了控件底部的`TextBlock`。这是运行时的样子：
- en: '![Using the ColorPicker](img/5022_06_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用ColorPicker](img/5022_06_14.jpg)'
- en: Custom controls
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义控件
- en: User controls are great for encapsulating a piece of UI functionality that can
    be easily reused. Their potential disadvantage is the lack of deep customization.
    Suppose in the `ColorPicker` example, we would like to have the sliders placed
    vertically rather than horizontally, or we want an ellipse rather than a rectangle.
    Although it's possible to add properties that would allow some customization,
    there's no way we can anticipate everything.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用户控件非常适合封装可以轻松重用的UI功能。它们的潜在缺点是缺乏深度定制。假设在`ColorPicker`示例中，我们希望将滑块垂直放置而不是水平放置，或者我们想要一个椭圆而不是一个矩形。虽然可以添加一些允许一些定制的属性，但我们无法预料到一切。
- en: The solution is to create a custom control with a default control template that
    can be changed completely as desired, while still retaining the original functionality.
    This is exactly how the regular WinRT controls are built.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个具有默认控件模板的自定义控件，可以根据需要完全更改，同时保留原始功能。这正是常规WinRT控件的构建方式。
- en: Creating a ColorPicker custom control
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个ColorPicker自定义控件
- en: 'A custom (also known as templated) control derives from the `Control` class.
    A good starting point is the Visual Studio Templated Control template:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义（也称为模板化）控件派生自`Control`类。一个很好的起点是Visual Studio模板化控件模板：
- en: '![Creating a ColorPicker custom control](img/5022_06_15.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![创建ColorPicker自定义控件](img/5022_06_15.jpg)'
- en: 'The result is a pair of files, `ColorPicker.h` and `ColorPicker.cpp`, and an
    XAML file named `Generic.xaml` that holds the default style for the `ColorPicker`
    that includes the default template as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一对文件，`ColorPicker.h`和`ColorPicker.cpp`，以及一个名为`Generic.xaml`的XAML文件，其中包含了`ColorPicker`的默认样式，包括默认模板，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All custom control styles must reside in the same `Generic.xaml` file. Its name
    and origin lie in WPF, which supports different styles for different Windows UI
    Themes. This is not relevant to WinRT, but the convention remains.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自定义控件样式必须驻留在同一个`Generic.xaml`文件中。它的名称和来源在WPF中，支持不同的样式适用于不同的Windows UI主题。这与WinRT无关，但惯例仍然存在。
- en: Practically, when authoring multiple custom controls, using the same file is
    inconvenient at best. This can be remedied by using the `ResourceDictionary::MergedDictionaries`
    property to include other XAML files into `Generic.xaml`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当编写多个自定义控件时，使用同一个文件最不方便。可以通过使用`ResourceDictionary::MergedDictionaries`属性将其他XAML文件包含到`Generic.xaml`中来解决这个问题。
- en: 'The default template looks much the same as the default UI created for the
    user control, with one important difference; no data binding expressions. The
    reason is that if there were bindings, a custom template would have to duplicate
    those to maintain functionality and this puts an unreasonable burden on custom
    template authors; the alternative is binding in code. Here''s the revised markup
    for the default template of `ColorPicker`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板看起来与为用户控件创建的默认UI非常相似，但有一个重要的区别；没有数据绑定表达式。原因是，如果有绑定，自定义模板将不得不复制这些绑定以保持功能，这对自定义模板作者来说是一个不合理的负担；另一种选择是在代码中进行绑定。以下是`ColorPicker`的默认模板的修订标记：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The interesting parts of the template are assigned names. These names will be
    looked up by the control and bound in code. These are the named parts discussed
    at the beginning of this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的有趣部分被分配了名称。这些名称将被控件查找并在代码中绑定。这些是本章开头讨论的命名部分。
- en: Binding in code
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中进行绑定
- en: Defining the dependency properties and events in a custom control is exactly
    the same as with a user control.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义控件中定义依赖属性和事件与用户控件完全相同。
- en: When a template is applied to a control, the virtual `Control::OnApplyTemplate`
    method is called. This is the best opportunity for the control to hunt down its
    named parts and connect to them using bindings, or event handlers, as appropriate.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板应用于控件时，将调用虚拟的`Control::OnApplyTemplate`方法。这是控件寻找其命名部分并使用绑定或事件处理程序连接到它们的最佳机会。
- en: 'To bind the three sliders, a helper method is created as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绑定这三个滑块，创建了一个辅助方法，如下所示：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The method uses `GetTemplateChild()` to get a named element. If that element
    does not exist, `nullptr` is returned. A typical control simply moves on and does
    not throw an exception.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用`GetTemplateChild()`来获取命名元素。如果该元素不存在，则返回`nullptr`。一个典型的控件简单地继续执行，不会抛出异常。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the code casts to `RangeBase` rather than `Slider`. This is possible
    because the required property is `Value` defined on `RangeBase`. This means that
    this can be something other than a `Slider`, as long as it derives from `RangeBase`
    (for example,. `ScrollBar` or `ProgressBar`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码将`RangeBase`转换而不是`Slider`。这是可能的，因为所需的属性是在`RangeBase`上定义的`Value`。这意味着这可以是除`Slider`之外的其他东西，只要它是从`RangeBase`派生的（例如，`ScrollBar`或`ProgressBar`）。
- en: Next, a binding is created in code by instantiating a `Binding` object, setting
    the source object (the `Source` and `Path` properties), binding mode (the `Mode`
    property), and converter (if needed, using the `Converter` property), and then
    finally calling `BindingOperations::SetBinding` with the target object, the target
    DP, and the binding instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在代码中创建一个绑定，通过实例化一个`Binding`对象，设置源对象（`Source`和`Path`属性），绑定模式（`Mode`属性）和转换器（如果需要，使用`Converter`属性），最后调用`BindingOperations::SetBinding`与目标对象，目标DP和绑定实例。
- en: 'The complete `OnApplyTemplate` would be as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`OnApplyTemplate`如下：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The three potential sliders (actually the controls derived from `RangeBase`)
    are bound, and then the `SolidColorBrush` is bound, if it exists. This means it
    can be the `Fill` of a `Rectangle`, an `Ellipse`, or the `BorderBrush` of a `Border`—as
    long as it's a `SolidColorBrush`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 三个可能的滑块（实际上是从`RangeBase`派生的控件）被绑定，然后如果存在`SolidColorBrush`，则被绑定。这意味着它可以是`Rectangle`的`Fill`，`Ellipse`的`Fill`，或者`Border`的`BorderBrush`——只要它是`SolidColorBrush`。
- en: Using the custom control is the same as using the user control. But, it's possible
    to replace the control template (as was done at the beginning of this chapter
    with the `ProgressBar`) to create a `ColorPicker` that looks different, yet has
    the same functionality, all with no code at all—just XAML.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义控件与使用用户控件相同。但是，可以替换控件模板（就像本章开头对`ProgressBar`所做的那样），以创建一个外观不同但具有相同功能的`ColorPicker`，而且完全不需要代码——只需XAML。
- en: Custom panels
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义面板
- en: WinRT provides the standard panels deriving from `Panel`. It's possible to create
    new panels that arrange their children in unique ways, such as a radial panel,
    whose children are arranged along the circumference of an ellipse.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT提供了从`Panel`派生的标准面板。可以创建新的面板，以独特的方式排列其子元素，例如径向面板，其子元素沿椭圆的周长排列。
- en: The layout process is a two-step process—measure and arrange. This is modelled
    precisely by the methods of `Panel` to override two methods for this exact purpose,
    `MeasureOverride` and `ArrangeOverride`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 布局过程是一个两步过程——测量和排列。这正是`Panel`的方法精确地建模了这两个方法的目的，`MeasureOverride`和`ArrangeOverride`。
- en: '`MeasureOverride` asks the panel (or any element that overrides it for that
    matter) what size it requires. For a panel, the main concern is the requirements
    of its child elements. The panel should call `UIElement::Measure` for each child
    element, causing its own `MeasureOverride` to be called (and this may go on if
    that child is a panel, or acts like a panel, in itself).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeasureOverride`询问面板（或任何覆盖它的元素）需要多大的尺寸。对于面板来说，主要关注的是其子元素的要求。面板应该为每个子元素调用`UIElement::Measure`，导致其自己的`MeasureOverride`被调用（如果该子元素是一个面板，或者像一个面板一样行事）。'
- en: The panel needs to decide what size it requires based on its children's requirements
    and the layout logic it wants to employ. The parameter sent to `MeasureOverride`
    is the available size provided by that panel's container. This can be an infinite
    size in either one or both dimensions (for example, a `ScrollViewer` indicates
    it has infinite space in directions where scrolling is available). It's important
    to return a finite size; otherwise WinRT has no way of knowing how much space
    to leave for the panel and throws an exception.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 面板需要根据其子元素的要求和其想要使用的布局逻辑来决定所需的大小。发送到`MeasureOverride`的参数是该面板容器提供的可用大小。这可以是一个或两个维度的无限大小（例如，`ScrollViewer`指示在可滚动的方向上有无限空间）。重要的是返回有限大小；否则WinRT无法知道为面板留多少空间，并抛出异常。
- en: '`ArrangeOverride` is a more interesting method that actually implements a special
    layout logic, for which the panel was created. The panel calls `UIElement::Arrange`
    on each element that forces that element to be placed within a specific rectangle.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrangeOverride`是一个更有趣的方法，它实际上实现了特殊的布局逻辑，为此面板被创建。面板对每个元素调用`UIElement::Arrange`，强制该元素放置在特定的矩形内。'
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This procedure is almost identical to the way it's done in WPF or Silverlight;
    many such examples are on the web, and can be converted to WinRT with little difficulty.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程几乎与在WPF或Silverlight中完成的方式完全相同；网上有许多这样的例子，可以很容易地转换为WinRT。
- en: Custom drawn elements
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义绘制元素
- en: Custom drawn elements can be created in WinRT by deriving them from the `Windows::UI::Xaml::Path`
    class, which is a kind of `Shape`. A `Path` is based on a `Geometry`—a mathematical
    abstraction of a 2D layout that can be a `PathGeometry` , which in itself can
    be built from various `PathSegment` objects. These shapes are beyond the scope
    of this book, but, again, they are similar to the ones existing in Silverlight,
    so a lot of information about them is available.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从`Windows::UI::Xaml::Path`类派生它们来在WinRT中创建自定义绘制元素，这是一种`Shape`。`Path`基于`Geometry`——2D布局的数学抽象，可以是`PathGeometry`，它本身可以由各种`PathSegment`对象构建。这些形状超出了本书的范围，但是它们与Silverlight中存在的形状相似，因此有很多关于它们的信息可用。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WinRT currently does not support WPF's `OnRender` method that uses `DrawingContext`
    to do free-style drawing of various kinds. Hopefully, this will be supported in
    a future version.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT目前不支持WPF的`OnRender`方法，该方法使用`DrawingContext`进行各种自由风格的绘制。希望这将在将来的版本中得到支持。
- en: Many new controls exist as part of the WinRT XAML toolkit, available for free
    on Microsoft's CodePlex site at [http://winrtxamltoolkit.codeplex.com/](http://winrtxamltoolkit.codeplex.com/).
    The problem with the toolkit is that it's written as a .NET class library, and
    so can only be used by .NET projects.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新控件作为WinRT XAML工具包的一部分存在，可以免费在微软的CodePlex网站上获得[http://winrtxamltoolkit.codeplex.com/](http://winrtxamltoolkit.codeplex.com/)。工具包的问题在于它是作为.NET类库编写的，因此只能被.NET项目使用。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Components are the backbone of module re-use. True WinRT components use WinRT
    types only and so can be exported to any WinRT-compatible environment, such as
    C++/CX, .NET, and JavaScript.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是模块重用的支柱。真正的WinRT组件只使用WinRT类型，因此可以导出到任何兼容WinRT的环境，如C++/CX、.NET和JavaScript。
- en: Control templates provide the ultimate control customization mechanism that
    can be done in XAML alone, with little or no code (code may be needed if value
    converters are used). Templates are appropriate if the control's appearance needs
    to change, but its functionality should remain intact, and is what's needed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 控件模板提供了可以仅使用XAML完成的最终控件定制机制，几乎不需要代码（如果使用值转换器，则可能需要代码）。如果控件的外观需要更改，但其功能应保持完整，并且是所需的，那么模板是合适的。
- en: Custom and user controls are used when new functionality is needed that is not
    provided by any built-in control. By deriving from `UserControl` and `Control`,
    dependency properties and events can be added to create a new reusable control.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义和用户控件用于在没有任何内置控件提供的情况下需要新功能时使用。通过从`UserControl`和`Control`派生，可以添加依赖属性和事件以创建新的可重用控件。
- en: User controls and custom controls should be packaged in such WinRT components
    for easy re-use by C++ and other projects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 用户控件和自定义控件应该打包在这样的WinRT组件中，以便C++和其他项目轻松重用。
- en: In the next chapter, we'll take a look at some of the special features of Windows
    Store apps, such as Live Tiles and Push Notifications. These (and other) capabilities
    can make your Store app unique and appealing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些Windows Store应用程序的特殊功能，例如动态磁贴和推送通知。这些（以及其他）功能可以使您的商店应用程序独特而吸引人。
