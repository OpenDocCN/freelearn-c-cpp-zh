- en: Shaders and 2D Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器和2D光照
- en: We have already touched on shaders in [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml),
    *Introduction to WebGL*. SDL, unfortunately, doesn't allow the user to customize
    its shaders without digging into the source code of the library and modifying
    them there. Those kinds of modifications are beyond the
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中介绍了着色器，*WebGL简介*。不幸的是，SDL不允许用户在不深入库的源代码并在那里修改的情况下自定义其着色器。这种修改超出了本书的范围。
- en: scope of this book. It is not uncommon to use SDL in combination with OpenGL.
    SDL can be used to render the user interface for the game while OpenGL renders
    the game objects. This chapter will deviate from many of the earlier chapters
    in that we will not be mixing SDL and OpenGL directly in the game we have been
    writing. Updating the game to support an OpenGL 2D rendering engine would require
    a complete redesign of the game up to this point. However, I would like to provide
    a chapter for those interested in creating a more advanced 2D rendering engine
    to get their feet wet with combining OpenGL and SDL and writing shaders for that
    engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围。在使用SDL与OpenGL的组合是很常见的。SDL可用于渲染游戏的用户界面，而OpenGL则渲染游戏对象。本章将与之前的许多章节有所不同，因为我们将不会直接在我们一直在编写的游戏中混合SDL和OpenGL。更新游戏以支持OpenGL
    2D渲染引擎将需要对游戏进行完全的重新设计。然而，我想为那些有兴趣创建更高级的2D渲染引擎的人提供一个章节，让他们尝试结合OpenGL和SDL，并为该引擎编写着色器。
- en: 'You will need to include several images in your build to make this project
    work. Make sure that you include the `/Chapter15/sprites/` folder from this project''s
    GitHub repository. If you haven''t downloaded the GitHub project yet, you can
    get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使这个项目工作。确保您包含了这个项目的GitHub存储库中的`/Chapter15/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Recreate the app we made in [Chapter 3](https://cdp.packtpub.com/hands_on_game_development_with_webassembly/wp-admin/post.php?post=38&action=edit#post_26),
    *Introduction to WebGL*, using a combination of SDL and OpenGL for WebAssembly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SDL和OpenGL为WebAssembly重新创建我们在[第3章](https://cdp.packtpub.com/hands_on_game_development_with_webassembly/wp-admin/post.php?post=38&action=edit#post_26)中制作的应用程序，*WebGL简介*。
- en: Learn how to create a new shader that loads and renders multiple textures to
    a quad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建一个新的着色器，加载并渲染多个纹理到一个四边形
- en: Learn about normal maps and how they can be used to create the illusion of depth
    on a 2D game object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解法向图以及它们如何用于在2D游戏对象上创建深度的错觉
- en: Learn how to approximate the Phong lighting model in 2D using normal maps in
    OpenGL and WebAssembly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在OpenGL和WebAssembly中使用法向图来近似2D中的冯氏光照模型
- en: Using OpenGL with WebAssembly
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL和WebAssembly
- en: Emscripten is capable of compiling C/C++ code that uses either OpenGL ES 2.0
    or OpenGL ES 3.0 by mapping those calls to WebGL or WebGL 2 calls, respectively.
    Because of this, Emscripten only supports a subset of the OpenGL ES commands that
    correspond to the commands available inside of the WebGL library you use. For
    instance, if you would like to use OpenGL ES 3.0, you will need to include WebGL
    2 when compiling by passing the `-s USE_WEBGL2=1` parameter to the Emscripten
    compiler. In this chapter, we will be using OpenGL ES 2.0 in combination with
    SDL to render sprites using shaders, and later we will be using SDL to render
    an icon that represents the location of a light source in our application. SDL
    provides many features that are absent from OpenGL, such as an audio library,
    an image loading library, and mouse and keyboard input libraries. In many ways,
    SDL is better suited to rendering the game's user interface as it renders objects
    to screen coordinates instead of to the OpenGL clip space. Behind the scenes,
    the WebAssembly version of SDL is also using the Emscripten OpenGL ES implementation,
    which relies on WebGL. So, having a better understanding of WebAssembly's OpenGL
    implementation can help us to take our game development skills to the next level,
    even if we will not be using those skills in the game we have developed for this
    book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten能够编译使用OpenGL ES 2.0或OpenGL ES 3.0的C/C++代码，通过将这些调用映射到WebGL或WebGL 2调用来实现。因此，Emscripten只支持与您使用的WebGL库内可用的OpenGL
    ES命令的子集。例如，如果您想使用OpenGL ES 3.0，您需要在编译时通过向Emscripten编译器传递`-s USE_WEBGL2=1`参数来包含WebGL
    2。在本章中，我们将使用OpenGL ES 2.0与SDL结合使用着色器来渲染精灵，稍后我们将使用SDL来渲染代表应用程序中光源位置的图标。SDL提供了许多OpenGL所没有的功能，如音频库、图像加载库以及鼠标和键盘输入库。在许多方面，SDL更适合于渲染游戏的用户界面，因为它将对象渲染到屏幕坐标而不是OpenGL剪辑空间。在幕后，WebAssembly版本的SDL也使用了Emscripten的OpenGL
    ES实现，依赖于WebGL。因此，更好地了解WebAssembly的OpenGL实现可以帮助我们将游戏开发技能提升到更高的水平，即使我们在本书中开发的游戏中不会使用这些技能。
- en: More about shaders
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于着色器的知识
- en: We briefly introduced the concept of shaders back in [Chapter 2](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml),
    *HTML5 and WebAssembly*. Shaders are a critical part of modern 3D graphics rendering.
    Back in the early days of computer and video games, graphics were all 2D, and
    how fast graphics could render was a function of how fast the system could move
    pixels from one data buffer to another. This process is called *blitting*. One
    significant advance in these early days came when Nintendo added a **Picture Processing
    Unit** (**PPU**) to their Nintendo Entertainment System. This was an early piece
    of hardware that was designed to speed up graphics processing by moving pixels
    without using the game system's CPU. The Commodore Amiga was also a pioneer in
    these early 2D graphics coprocessors, and by the mid-1990s, hardware for blitting
    became a standard in the computer industry. In 1996, games such as Quake began
    to create a demand for consumer 3D graphics processing, and early graphics cards
    began to provide GPUs that had fixed function pipelines. This allowed applications
    to load geometry data and execute non-programmable texturing and lighting functions
    on that geometry. In the early 2000s, Nvidia introduced the GeForce 3\. This was
    the first GPU that supported a programmable pipeline. Eventually, these programmable
    pipeline GPUs began to standardize around a *unified shader model*, which allows
    programmers to write in a shading language such as GLSL for all graphics cards
    that support that language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《HTML5和WebAssembly》的[第2章](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml)中简要介绍了着色器的概念。着色器是现代3D图形渲染的关键部分。在计算机和视频游戏的早期，图形都是2D的，图形渲染的速度取决于系统能够将像素从一个数据缓冲区移动到另一个数据缓冲区的速度。这个过程称为*blitting*。在早期，一个重要的进步是任天堂在他们的任天堂娱乐系统中添加了一个**图片处理单元**（**PPU**）。这是一个早期的硬件，旨在通过在不使用游戏系统CPU的情况下移动像素来加速图形处理。康柏Amiga也是这些早期2D图形协处理器的先驱，到了20世纪90年代中期，blitting的硬件成为了计算机行业的标准。1996年，像《奇兵》这样的游戏开始对消费者3D图形处理提出需求，早期的图形卡开始提供具有固定功能管线的GPU。这允许应用程序加载几何数据并在该几何体上执行不可编程的纹理和光照功能。在21世纪初，Nvidia推出了GeForce
    3。这是第一个支持可编程管线的GPU。最终，这些可编程管线的GPU开始围绕*统一着色器模型*进行标准化，这允许程序员为支持该语言的所有图形卡编写GLSL等着色器语言。
- en: GLSL ES 1.0 and 3.0
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLSL ES 1.0和3.0
- en: The language we will be using to write our shaders is a subset of the GLSL shader
    language called GLSL ES. This shader language happens to work with WebGL and so
    is supported by the version of OpenGL ES that has been ported to WebAssembly.
    The code we are writing will run on both GLSL ES 1.0 and 3.0, which are the two
    versions of GLSL ES supported by WebAssembly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的语言来编写我们的着色器是GLSL着色器语言的一个子集，称为GLSL ES。这个着色器语言恰好适用于WebGL，因此受到了被移植到WebAssembly的OpenGL
    ES版本的支持。我们编写的代码将在GLSL ES 1.0和3.0上运行，这是WebAssembly支持的GLSL ES的两个版本。
- en: If you are wondering why there is no support for GLSL ES 2.0, it's because it
    doesn't exist. OpenGL ES 1.0 used a fixed function pipeline and so it had no shader
    language associated with it. When the Khronos Group created OpenGL ES 2.0, they
    created GLSL ES 1.0 as the shader language to go with it. When they released OpenGL
    ES 3.0, they decided that they wanted the version number of the shader language
    to be the same number as the API. Therefore, all the new versions of OpenGL ES
    will come with a version of GLSL that bears the same version number.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么不支持GLSL ES 2.0，那是因为它根本不存在。OpenGL ES 1.0使用了固定功能管线，因此没有与之相关的着色器语言。当Khronos
    Group创建了OpenGL ES 2.0时，他们创建了GLSL ES 1.0作为与之配套的着色器语言。当他们发布了OpenGL ES 3.0时，他们决定希望着色器语言的版本号与API的版本号相同。因此，所有新版本的OpenGL
    ES都将配备与之版本号相同的GLSL版本。
- en: 'GLSL is a language that is very similar to C. Each shader has a `main` function
    that is its entry point. GLSL ES 2.0 only supports two shader types: *vertex shaders*
    and *fragment shaders*. The execution of these shaders is highly parallel. If
    you are used to thinking along single—threaded lines, you will need to reorder
    your brain. Shaders are frequently processing thousands of vertices and pixels
    at the same time.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL是一种非常类似于C的语言。每个着色器都有一个`main`函数作为其入口点。GLSL ES 2.0只支持两种着色器类型：*顶点着色器*和*片段着色器*。这些着色器的执行是高度并行的。如果你习惯于单线程思维，你需要调整你的思维方式。着色器通常同时处理成千上万个顶点和像素。
- en: I briefly discussed the definition of a vertex and a fragment in [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml),
    *Introduction to WebGL*. A vertex is a point in space, and a collection of vertices
    define the geometry that our graphics card uses to render to the screen. A fragment
    is a pixel candidate. Multiple fragments usually go into determining the pixel
    output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在《WebGL入门》的[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中简要讨论了顶点和片段的定义。顶点是空间中的一个点，一组顶点定义了我们的图形卡用来渲染屏幕的几何形状。片段是像素候选。通常需要多个片段来确定像素输出。
- en: Each vertex of the geometry that's passed to a vertex shader is processed by
    that shader. Values are then passed using a *varying variable* to a large number
    of threads that are processing individual pixels through a fragment shader. The
    fragment shader receives a value that is interpolated between the output of more
    than one of the vertex shaders. A fragment shader's output is a *fragment*, which
    is a pixel candidate. Not all fragments become pixels. Some fragments are dropped,
    which means they won't render at all. Other fragments are blended to form a completely
    different pixel color. We created one vertex and one fragment shader in [Chapter
    3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml), *Introduction to WebGL*, for our
    WebGL application. Let's walk through converting that application into an OpenGL/WebAssembly
    app. Once we have a working application, we can further discuss shaders and new
    ways we can write those shaders to improve our 2D WebAssembly game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给顶点着色器的几何图形的每个顶点都由该着色器处理。然后使用*varying变量*传递值给大量处理单个像素的线程，通过片段着色器。片段着色器接收一个值，该值在多个顶点着色器的输出之间进行插值。片段着色器的输出是一个*片段*，它是一个像素候选。并非所有片段都成为像素。有些片段被丢弃，这意味着它们根本不会渲染。其他片段被混合以形成完全不同的像素颜色。在[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中，*WebGL简介*中，我们为我们的WebGL应用程序创建了一个顶点着色器和一个片段着色器。让我们开始将该应用程序转换为一个OpenGL/WebAssembly应用程序。一旦我们有一个工作的应用程序，我们可以进一步讨论着色器和我们可以编写这些着色器的新方法，以改进我们的2D
    WebAssembly游戏。
- en: WebGL app redux
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL应用程序重现
- en: 'We will now walk through what it takes to rewrite the WebGL app we made in
    [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml), *Introduction to WebGL*,
    using SDL and OpenGL. If you don''t remember, this was a very simple app that
    drew a spaceship to our canvas and moved it 2 pixels to the left and one pixel
    up every frame. The reason we made this app was that it was about the simplest
    thing I could think to do in WebGL that was more interesting than drawing a triangle.
    For this same reason, it will be the first thing we will do with OpenGL for WebAssembly.
    Go ahead and create a new file called `webgl-redux.c` and open it up. Now, let''s
    go ahead and start adding some code. The first chunk of code we need is our `#include`
    commands to pull in all of the libraries we will need for this app:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步介绍如何重写我们在[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中制作的WebGL应用程序，使用SDL和OpenGL。如果你不记得了，这是一个非常简单的应用程序，每帧都在我们的画布上绘制一艘飞船，并将其向左移动2个像素，向上移动一个像素。我们制作这个应用程序的原因是，这是我能想到的在WebGL中做的比绘制一个三角形更有趣的最简单的事情。出于同样的原因，这将是我们将使用OpenGL进行WebAssembly的第一件事情。现在，创建一个名为`webgl-redux.c`的新文件并打开它。现在，让我们开始添加一些代码。我们需要的第一部分代码是我们的`#include`命令，以引入我们这个应用程序所需的所有库：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line includes the standard SDL2 library. The second library, `SDL_image.h`,
    is the library we are using to load our image files. The third line in this file
    that includes `SDL_opengl.h`, and is the library that will allow us to mix our
    SDL and OpenGL calls. Including `GLES2/gl2.h` gives us access to all of the OpenGL
    commands that we can use with OpenGL ES 2.0\. As always, we include `stdlib.h`
    to let us use the `printf` command, and `emscripten.h` provides us with the functions
    we need for compiling to target WebAssembly using the Emscripten compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包括标准的SDL2库。第二个库`SDL_image.h`是我们用来加载图像文件的库。这个文件的第三行包括`SDL_opengl.h`，这是一个允许我们混合SDL和OpenGL调用的库。包括`GLES2/gl2.h`让我们可以使用OpenGL
    ES 2.0的所有OpenGL命令。和往常一样，我们包括`stdlib.h`让我们可以使用`printf`命令，`emscripten.h`为我们提供了使用Emscripten编译器编译为WebAssembly目标所需的函数。
- en: 'After our `#include` commands, we have a series of `#define` macros that define
    the constants we need for our game:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`#include`命令之后，我们有一系列`#define`宏，用于定义我们游戏所需的常量：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two define our canvas width and canvas height. The remaining `#define`
    calls are used to set up values we will be using when we define our vertex buffers.
    After these `#define` macros, we define the code for our shaders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个定义了我们画布的宽度和高度。其余的`#define`调用用于设置我们在定义顶点缓冲区时将要使用的值。在这些`#define`宏之后，我们定义了我们着色器的代码。
- en: Shader code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器代码
- en: 'The following few blocks of code I am about to show you will define the shaders
    we need to create our 2D lighting effect. Here is the vertex shader code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将要展示的几个代码块将定义我们需要创建2D光照效果的着色器。以下是顶点着色器代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the same shader code that we used when we created the WebGL version
    of this app. It looks a little different in C because JavaScript can use a multiline
    string that makes reading the code a little more clear. Like in the WebGL version,
    we use the precision call to set the floating-point precision to medium. We set
    up attributes to receive the position and UV texture coordinate data as vectors.
    We will pass in these vectors using a vertex buffer object. We define a uniform
    translate variable that will be the same value used for all vertices, which in
    general is not the way we would do this for a game, but will work just fine for
    this app. Finally, we define a varying `v_texcoord` variable. This variable will
    represent the texture coordinate value we pass from the vertex shader into the
    fragment shader. The `main()` function in this vertex shader is very simple. It
    adds the `u_translate` uniform variable translation value that's passed into the
    vertex shader to the attribute position of the vertex passed in via `a_position`,
    to get the final vertex position we set using the `gl_Position` variable. After
    that, we pass the texture coordinate of the vertex to the fragment shader by setting
    the `v_texcoord` varying variable to `a_texcoord`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建WebGL版本应用时使用的相同着色器代码。它在C中看起来有点不同，因为JavaScript可以使用多行字符串，使得代码更加清晰易读。与WebGL版本一样，我们使用精度调用将浮点精度设置为中等。我们设置属性来接收位置和UV纹理坐标数据作为向量。我们将使用顶点缓冲对象传递这些向量。我们定义一个uniform变量`translate`，它将是所有顶点使用的相同值，这通常不是我们在游戏中做的方式，但对于这个应用来说完全可以。最后，我们定义一个varying
    `v_texcoord`变量。这个变量将代表我们从顶点着色器传递到片段着色器的纹理坐标值。这个顶点着色器中的`main()`函数非常简单。它将`u_translate`
    uniform变量传递到顶点着色器中，将通过`a_position`传递的顶点属性位置添加到最终顶点位置，然后使用`gl_Position`变量设置。之后，通过将`v_texcoord`
    varying变量设置为`a_texcoord`，我们将顶点的纹理坐标传递到片段着色器中。
- en: After defining our vertex shader, we create the string that defines our fragment
    shader. The fragment shader receives an interpolated version of `v_texcoord`,
    which is the varying variable that's passed out of our vertex shader. You will
    need to put on your parallel processing hat for a moment to understand how this
    works. When the GPU is processing our vertex shader and fragment shader, it is
    not doing this one at a time, but is likely processing thousands of vertices and
    fragments at once. The fragment shader is also not receiving the output from a
    single one of these threads, but a value that is mixed from more than one of the
    vertices that are currently being processed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的顶点着色器之后，我们创建了定义我们片段着色器的字符串。片段着色器接收到了`v_texcoord`的插值版本，这是从我们的顶点着色器传递出来的varying变量。你需要暂时戴上并行处理的帽子来理解这是如何工作的。当GPU处理我们的顶点着色器和片段着色器时，它不是一次处理一个，而是可能一次处理成千上万个顶点和片段。片段着色器也不是接收来自单个线程的输出，而是来自当前正在处理的多个顶点的混合值。
- en: For example, if your vertex shader has a varying variable as output called X,
    and your fragment is halfway between a vertex where X is 0 and a vertex where
    X is 10, then the value in the varying variable coming into your fragment will
    be 5\. This is because 5 is halfway between the two vertex values of 0 and 10\.
    Likewise, if the fragment is 30% of the way between your two points, the value
    in X will be 3.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的顶点着色器有一个名为X的varying变量作为输出，并且你的片段着色器处于X为0和X为10的两个顶点之间的中间位置，那么进入片段的varying变量中的值将是5。这是因为5是0和10两个顶点值之间的中间值。同样，如果片段在两个点之间的30%位置，X中的值将是3。
- en: 'Here is the definition of our fragment shader code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们片段着色器代码的定义：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with our vertex shader, we start out by setting the precision. After that,
    we have a varying variable, which is an interpolated value for our texture coordinate.
    This value is stored in `v_texcoord` and will be used to map our texture to a
    pixel color. The last variable is a uniform variable of type `sampler2D`. This
    is a block of memory where we have loaded our texture. The only thing that the
    main function of this fragment shader does is use the built-in `texture2D` function
    to grab a pixel color out of our texture using the texture coordinates we passed
    into the fragment shader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的顶点着色器一样，我们首先设置精度。之后，我们有一个varying变量，这是我们纹理坐标的插值值。这个值存储在`v_texcoord`中，并将用于将纹理映射到像素颜色上。最后一个变量是一个`sampler2D`类型的uniform变量。这是一个内存块，我们在其中加载了我们的纹理。这个片段着色器的主要功能是使用内置的`texture2D`函数，使用我们传递到片段着色器中的纹理坐标来获取纹理中的像素颜色。
- en: OpenGL global variables
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL全局变量
- en: 'After defining our shaders, we need to define several variables in C that we
    will use to interact with them:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的着色器之后，我们需要在C中定义几个变量，用于与它们进行交互：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OpenGL uses reference variables to interact with the GPU. The first two of these
    variables are of type `GLuint`. A `GLuint` is an unsigned integer, and using the
    `GLuint` type is just an OpenGL type. Seeing `GLuint` instead of `unsigned int`
    is a nice way to give someone reading your code a hint that you are using this
    variable to interact with OpenGL. The program variable will eventually hold a
    reference to a program that will be defined by your shaders, and the texture variable
    will hold a reference to a texture that's been loaded into the GPU. After the
    references to program and texture, we have two variables that will be used to
    reference shader program attributes. The `a_texcoord_location` variable will be
    a reference to the `a_texcoord` shader attribute, and the `a_position_location`
    variable will be a reference to the `a_position` shader attribute value. The attribute
    references are followed up by two uniform variable references. If you are wondering
    what the difference between a uniform and attribute variable is, a uniform variable
    remains the same value for all vertices, whereas an attribute variable is vertex-specific.
    Finally, we have a reference to our vertex texture buffer in the `vertex_texture_buffer`
    variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL使用引用变量与GPU进行交互。这些变量中的前两个是`GLuint`类型。`GLuint`是无符号整数，使用`GLuint`类型只是OpenGL类型的一种。看到`GLuint`而不是`unsigned
    int`是给阅读你的代码的人一个提示，表明你正在使用这个变量与OpenGL进行交互。程序变量最终将保存一个由你的着色器定义的程序的引用，而纹理变量将保存一个已加载到GPU中的纹理的引用。在对程序和纹理的引用之后，我们有两个变量，用于引用着色器程序属性。`a_texcoord_location`变量将是对`a_texcoord`着色器属性的引用，而`a_position_location`变量将是对`a_position`着色器属性值的引用。属性引用后面是两个统一变量引用。如果你想知道统一变量和属性变量之间的区别，统一变量对于所有顶点保持相同的值，而属性变量是特定于顶点的。最后，我们在`vertex_texture_buffer`变量中有一个对顶点纹理缓冲区的引用。
- en: 'After we define these values, we need to define our quad. As you may remember,
    our quad is made up of six vertices. This is because it is made up of two triangles.
    I talked about why we set the vertex data this way in [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml),
    *Introduction to WebGL*. If you find this confusing, you may want to go back to
    that chapter for a little review. Here is the definition of the `vertex_texture_data`
    array:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这些值之后，我们需要定义我们的四边形。你可能还记得，我们的四边形由六个顶点组成。这是因为它由两个三角形组成。我在[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中讨论了为什么我们以这种方式设置顶点数据，*WebGL入门*。如果你觉得这很困惑，你可能需要回到那一章进行一些复习。以下是`vertex_texture_data`数组的定义：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SDL global variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDL全局变量
- en: 'We are still going to be using SDL to initialize our canvas for OpenGL rendering.
    We will also be using SDL to load our image data from the virtual filesystem.
    Because of this, we have the following SDL related global variables we need to
    define:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然将使用SDL来初始化我们的OpenGL渲染画布。我们还将使用SDL从虚拟文件系统加载图像数据。因此，我们需要定义以下与SDL相关的全局变量：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we need variables to hold our sprite width and height values when
    we load an image using SDL:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们使用SDL加载图像时，我们需要变量来保存我们的精灵宽度和高度值：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we draw the ship to the canvas, we will need `x` and `y` coordinates for
    that ship, so we will create a few global variables to hold those values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将飞船绘制到画布上时，我们将需要该飞船的`x`和`y`坐标，因此我们将创建一些全局变量来保存这些值：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we are going to create a function prototype for our game loop. I want
    to define our game loop after we define our main function because I would like
    to step through our initialization first. Here is the function prototype for our
    game loop:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个游戏循环的函数原型。我想在定义主函数之后定义我们的游戏循环，因为我想先逐步进行初始化。以下是我们游戏循环的函数原型：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The main function
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Now, we have come to our `main` function. There is quite a bit of initialization
    that we will need to do. We are not only initializing SDL, like we did when we
    were creating our game. We will also need to do several initialization steps for
    OpenGL. Here is the `main` function in its entirety:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了我们的`main`函数。我们需要做一些初始化工作。我们不仅需要像创建游戏时那样初始化SDL，还需要对OpenGL进行几个初始化步骤。以下是完整的`main`函数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let me break this into some more digestible pieces. The first thing we need
    to do in our `main` function is the standard SDL initialization stuff. We need
    to initialize the video module, create a renderer, and set the draw and clear
    colors. By now, this code should look pretty familiar to you:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我把它分成一些更容易理解的部分。在我们的`main`函数中，我们需要做的第一件事是标准的SDL初始化工作。我们需要初始化视频模块，创建一个渲染器，并设置绘制和清除颜色。到现在为止，这段代码应该对你来说已经很熟悉了：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to create and compile our vertex shader. This requires several
    steps. We need to create our shader, load the source code into the shader, compile
    the shader, then check to make sure there weren''t any errors when compiling.
    Basically, these steps take your code, compile it, and then load the compiled
    code into the video card to execute it later. Here are all the steps you need
    to perform to compile your vertex shader:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建和编译我们的顶点着色器。这需要几个步骤。我们需要创建我们的着色器，将源代码加载到着色器中，编译着色器，然后检查编译时是否出现错误。基本上，这些步骤将你的代码编译，然后将编译后的代码加载到视频卡中以便以后执行。以下是编译顶点着色器所需执行的所有步骤：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After compiling the vertex shader, we need to compile the fragment shader.
    This is the same process. We start by calling `glCreateShader` to create a fragment
    shader. We then load our fragment shader source code using `glShaderSource`. After
    that, we call `glCompileShader` to compile our fragment shader. Finally, we call
    `glGetShaderiv` to see whether a compiler error occurred when we attempted to
    compile our fragment shader:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译顶点着色器之后，我们需要编译片段着色器。这是相同的过程。我们首先调用`glCreateShader`来创建一个片段着色器。然后，我们使用`glShaderSource`加载我们的片段着色器源代码。之后，我们调用`glCompileShader`来编译我们的片段着色器。最后，我们调用`glGetShaderiv`来查看在尝试编译我们的片段着色器时是否发生了编译器错误：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For simplicity, I kept the error message vague for when of the shaders failed
    to compile. It only tells you which shader failed to compile. Later in this chapter,
    I will show you how to get a more detailed error message from the shader compiler.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，当着色器编译失败时，我保持了错误消息的模糊性。它只告诉你哪个着色器编译失败了。在本章的后面，我将向你展示如何从着色器编译器中获取更详细的错误消息。
- en: Now that we have our shaders compiled, we need to link our shaders into a program,
    and then tell OpenGL that this is the program we want to use. If you are writing
    a game using OpenGL, there is a good chance you will be using more than one program.
    For example, you may want to have lighting effects on some objects in your game,
    but not others. Some game objects may require rotation and scaling, while others
    may not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了我们的着色器，我们需要将我们的着色器链接到一个程序中，然后告诉OpenGL这是我们想要使用的程序。如果你正在使用OpenGL编写游戏，很有可能你会使用多个程序。例如，你可能希望在游戏中的某些对象上使用光照效果，而在其他对象上不使用。一些游戏对象可能需要旋转和缩放，而其他对象可能不需要。
- en: As you will learn in the next chapter, using multiple programs with WebGL has
    a significantly higher CPU hit than it does in a native OpenGL app. This has to
    do with the web browser's security checks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章中学到的那样，在WebGL中使用多个程序比在本机OpenGL应用程序中有更高的CPU负担。这与Web浏览器的安全检查有关。
- en: 'For this application, we will be using a single program, and we will use the
    following code to attach our shaders and link them to the program:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将使用一个单独的程序，并使用以下代码来附加我们的着色器并将它们链接到程序中：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `glCreateProgram` function creates a new program and returns a reference
    ID for it. We will store that reference ID in our program variable. We make two
    calls to `glAttachShader` that will attach our vertex and fragment shader to the
    program we just created. We then call `glLinkProgram` to link the program shaders
    together. We call `glGetProgramiv` to verify that the program linked successfully.
    Finally, we call `glUseProgram` to tell OpenGL that this is the program we would
    like to use.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`glCreateProgram`函数创建一个新的程序并返回一个引用ID。我们将把这个引用ID存储在我们的程序变量中。我们调用`glAttachShader`两次，将我们的顶点着色器和片元着色器附加到我们刚刚创建的程序上。然后我们调用`glLinkProgram`将程序着色器链接在一起。我们调用`glGetProgramiv`来验证程序成功链接。最后，我们调用`glUseProgram`告诉OpenGL这是我们想要使用的程序。'
- en: 'Now that we are using a specific program, we can retrieve the references to
    the attribute and uniform variables inside of that program with the following
    lines of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用一个特定的程序，我们可以使用以下代码来检索该程序中属性和统一变量的引用：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line retrieves a reference to the `u_texture` uniform variable, and
    the second line retrieves a reference to the `u_translate` uniform variable. We
    can use these references later to set these values inside of our shader. The two
    lines after that are used to retrieve references to the `a_position` position
    attribute and the `a_texcoord` texture coordinate attribute inside of our shaders.
    Like the uniform variables, we will be using these references to set the values
    in our shaders later on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检索到`u_texture`统一变量的引用，第二行检索到`u_translate`统一变量的引用。我们可以稍后使用这些引用在我们的着色器中设置这些值。之后的两行用于检索到我们着色器中的`a_position`位置属性和`a_texcoord`纹理坐标属性的引用。像统一变量一样，我们稍后将使用这些引用来设置着色器中的值。
- en: Now, we will need to create and load data into a vertex buffer. The vertex buffer
    holds all of the attribute data for each vertex we will render. If we were rendering
    a 3D model, we would need to load it with model data that we retrieved externally.
    Luckily for us, all we need to render are some two-dimensional quads. Quads are
    simple enough that we were able to define them in an array earlier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建并加载数据到一个顶点缓冲区。顶点缓冲区保存了我们将要渲染的每个顶点的属性数据。如果我们要渲染一个3D模型，我们需要用从外部检索到的模型数据加载它。幸运的是，对于我们来说，我们只需要渲染一些二维的四边形。四边形足够简单，我们之前能够在一个数组中定义它们。
- en: 'Before we can load that data into a buffer, we will need to generate that buffer
    with a call to `glGenBuffers`. We will then need to *bind* the buffer using `glBindBuffer`.
    Binding a buffer is just the way you tell OpenGL which buffers you are currently
    working on. Here is the code to generate and then bind our vertex buffer:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将数据加载到缓冲区之前，我们需要使用`glGenBuffers`来生成该缓冲区。然后我们需要使用`glBindBuffer`来*绑定*缓冲区。绑定缓冲区只是告诉OpenGL你当前正在处理哪些缓冲区。以下是生成然后绑定我们的顶点缓冲区的代码：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have a buffer selected, we can put data into that buffer using
    a call to `glBufferData`. We will pass in `vertex_texture_data` that we defined
    earlier. It defines both the `x` and `y` coordinates of our quad''s vertices and
    the UV mapping data for those vertices:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了一个缓冲区，我们可以使用`glBufferData`来向缓冲区中放入数据。我们将传入我们之前定义的`vertex_texture_data`。它定义了我们四边形顶点的`x`和`y`坐标以及这些顶点的UV映射数据。
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After buffering our data, we will use SDL to load a sprite surface. Then, we
    will create a texture from that surface, which we can use to find the width and
    height of the image we just loaded. After that, we call `glTexImage2D` to create
    an OpenGL texture from that SDL surface. Here is the code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲我们的数据之后，我们将使用SDL来加载一个精灵表面。然后，我们将从该表面创建一个纹理，我们可以用它来找到刚刚加载的图像的宽度和高度。之后，我们调用`glTexImage2D`从SDL表面创建一个OpenGL纹理。以下是代码：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Most of the previous code should have looked pretty familiar. We have been using
    `IMG_Load` to load an SDL surface from the virtual filesystem for a while now.
    We then used `SDL_CreateTextureFromSurface` to create an SDL texture. Once we
    had the texture, we used `SDL_QueryTexture` to figure out what the image width
    and height are, and we stored those values in `sprite_width` and `sprite_height`.
    The next function call is new. The `GlTexImage2D` function is used to create a
    new OpenGL texture image. We pass in `sprite_surface` as our image data, which
    we had loaded a few lines earlier. The last line frees the surface using `SDL_FreeSurface`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分之前的代码应该看起来很熟悉。我们已经使用`IMG_Load`一段时间从虚拟文件系统中加载SDL表面。然后我们使用`SDL_CreateTextureFromSurface`创建了一个SDL纹理。一旦我们有了纹理，我们使用`SDL_QueryTexture`来找出图像的宽度和高度，并将这些值存储在`sprite_width`和`sprite_height`中。下一个函数调用是新的。`GlTexImage2D`函数用于创建一个新的OpenGL纹理图像。我们将`sprite_surface`作为我们的图像数据传入，这是我们几行前加载的图像数据。最后一行使用`SDL_FreeSurface`释放表面。
- en: 'We then add two lines that enable alpha blending in our game:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了两行代码在游戏中启用alpha混合：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After enabling alpha blending, we have several lines that set up the attributes
    in our shaders:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启用alpha混合后，我们有几行代码在着色器中设置属性：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first two lines enable the `a_position` and `a_texcoord` attributes in our
    shaders. After that, we have two calls to `glVertexAttribPointer`. The calls to
    `glVertexAttribPointer` are used to tell our shader where the data that's assigned
    to each specific attribute is located in our vertex buffer. We filled our vertex
    buffer with 32-bit floating point variables. The first call to `glVertexAttribPointer`
    sets the location of the values assigned to the `a_position` attribute using the
    reference variable we created in `a_position_location`. We then pass in the number
    of values we use for this attribute. In the case of position, we pass in an `x`
    and a `y` coordinate, so this value is 2\. We pass in the data type for our buffer
    array, which is a floating-point data type. We tell the function we are not normalizing
    the data. The `stride` value is the second to last parameter. This is the number
    of bytes that are used for a vertex in this buffer. Because each vertex in the
    buffer is using four floating-point values, we pass in `4 * sizeof( float )` for
    our stride. Finally, the last value we pass in is the offset in bytes to the data
    we are using to populate this attribute. For the `a_position` attribute, this
    value is `0` because the position comes at the beginning. For the `a_texcoord`
    attribute, this value is `2 * sizeof(float)` because there are two floating-point
    values that we used for `a_position` that precede our `a_texcoord` data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的前两行启用了着色器中的`a_position`和`a_texcoord`属性。之后，我们调用了两次`glVertexAttribPointer`。这些调用用于告诉着色器每个特定属性分配的数据在顶点缓冲区中的位置。我们用32位浮点变量填充了顶点缓冲区。第一次调用`glVertexAttribPointer`设置了`a_position`属性分配的值的位置，使用了我们在`a_position_location`中创建的引用变量。然后我们传入了用于此属性的值的数量。在位置的情况下，我们传入了`x`和`y`坐标，所以这个值是2。我们传入了缓冲区数组的数据类型，即浮点数据类型。我们告诉函数我们不对数据进行归一化。`stride`值是倒数第二个参数。这是在此缓冲区中用于一个顶点的字节数。因为缓冲区中的每个顶点都使用了四个浮点值，所以我们传入了`4
    * sizeof(float)`作为我们的stride。最后，我们传入的最后一个值是字节偏移量，用于填充此属性的数据。对于`a_position`属性，这个值是`0`，因为位置位于开头。对于`a_texcoord`属性，这个值是`2
    * sizeof(float)`，因为在我们的`a_texcoord`数据之前使用了两个浮点值来填充`a_position`。
- en: 'The final line in the `main` function sets the game loop callback:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数中的最后一行设置了游戏循环回调：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The game loop
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: 'Our game loop is pretty simple. In our game loop, we will use OpenGL to clear
    the canvas, move our ship, and render our ship to the canvas. Here is the code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环非常简单。在游戏循环中，我们将使用OpenGL清除画布，移动我们的飞船，并将我们的飞船渲染到画布上。以下是代码：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first two lines of the game loop clear the canvas:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的前两行清除画布：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we have several lines that update the ship''s `x` and `y` coordinates,
    and then set the new coordinates in the shader:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有几行代码更新飞船的`x`和`y`坐标，然后在着色器中设置新的坐标：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the game loop uses `glDrawArrays` to draw our spaceship to the canvas:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，游戏循环使用`glDrawArrays`将我们的飞船绘制到画布上：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compiling and running our code
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行我们的代码
- en: 'You will want to download the sprites folder from the GitHub project so that
    you can include the image files that we need to compile and run this project.
    Once you have those images and have saved the code we just wrote into the `webgl-redux.c`
    file, we can compile and test this new application. If it is successful, it should
    look just like the [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml), *Introduction
    to WebGL*, WebGL version. Run the following `emcc` command to compile the app:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从GitHub项目中下载sprites文件夹，以便包含我们编译和运行此项目所需的图像文件。一旦您拥有这些图像并将我们刚刚编写的代码保存到`webgl-redux.c`文件中，我们就可以编译和测试这个新应用程序。如果成功，它应该看起来就像[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml)中的*WebGL简介*，WebGL版本。运行以下`emcc`命令来编译应用程序：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the app runs successfully, you should have a spaceship that is moving from
    left to right and up the HTML canvas. Here is a screenshot of a working version
    of the app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序成功运行，您应该会看到一艘飞船从左到右并上升到HTML画布上。以下是应用程序的工作版本的屏幕截图：
- en: '![](img/57930775-44b4-4d64-a0ff-01e41f2688e0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57930775-44b4-4d64-a0ff-01e41f2688e0.png)'
- en: 'Figure 15.1: Screenshot of the OpenGL and SDL app'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：OpenGL和SDL应用程序的屏幕截图
- en: In the next section, we will learn how to blend textures from within a shader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在着色器中混合纹理。
- en: Mixing textures for a glow effect
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合纹理以产生发光效果
- en: Now, we will spend some time learning how to load more than one texture into
    our program. We will add the colors of those two textures to create a pulsing
    glow effect. To do this, we will need to modify our fragment shader to receive
    a second texture and a time uniform variable. We will pass that variable into
    a sine wave function, which will use it to calculate the strength of our glowing
    engines. We will need to add some code to keep track of the time that has passed,
    as well as some new initialization code to load the second texture. We can begin
    by copying `webgl-redux.c` to a new file called `glow.c`. Now that we have the
    new `glow.c` file, we can walk through the changes we will need to make our glowing
    engine effect. The first code change is the addition of a new `#define` macro
    to define a value for `2π`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将花一些时间学习如何将多个纹理加载到我们的程序中。我们将添加这两个纹理的颜色以创建脉动的光晕效果。为此，我们需要修改我们的片段着色器，以接收第二个纹理和一个时间统一变量。我们将把该变量传递给一个正弦波函数，该函数将用它来计算我们发光引擎的强度。我们需要添加一些代码来跟踪经过的时间，以及一些新的初始化代码来加载第二个纹理。我们可以通过将`webgl-redux.c`复制到一个名为`glow.c`的新文件来开始。现在我们有了新的`glow.c`文件，我们可以逐步了解我们需要做的更改，以实现我们发光引擎的效果。第一个代码更改是添加一个新的`#define`宏，用于定义`2π`的值。
- en: 'We will use a value that cycles from `0` to `2π` and feeds it into a sine wave
    function to create the pulsing effect on our engine glow. Here is the `#define`
    we should add near the beginning of our `glow.c` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个从`0`到`2π`循环的值，并将其输入正弦波函数，以在我们的引擎光晕上创建脉动效果。以下是我们应该在`glow.c`文件开头附近添加的`#define`：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Fragment shader changes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器更改
- en: 'After that new macro, we will need to make some changes to our fragment shader
    code. Our vertex shader code will remain the same because the process of determining
    the position of our vertex will not be any different than it was in the previous
    version of the app. Here is the updated version of the fragment shader:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新的宏之后，我们需要对我们的片段着色器代码进行一些更改。我们的顶点着色器代码将保持不变，因为确定顶点位置的过程与应用程序先前版本中的过程没有任何不同。以下是片段着色器的更新版本：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added a new uniform variable called `u_time` that will be used to pass
    in a time-based variable that will cycle between `0` and `2π`. We have also added
    a second `sampler2D` uniform variable called `u_glow` that will hold our new glow
    texture. The first line of our `main` function calculates a value between `0.0`
    and `1.0` based on the value in `u_time`. We retrieve the sampled values out of
    `u_texture` and `u_glow` using the built-in `texture2D` function. This time, instead
    of storing a value from the texture directly into `gl_FragColor`, we save those
    two values into `vec4` variables called `tex` and `glow`. We are going to be adding
    those two values together, so to keep things from getting too bright everywhere,
    we multiply the `rgb` (red green and blue) values in our `glow` sample color by
    the alpha channel. After that, we multiply all the values in our `glow` color
    by the `cycle` value we computed earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`u_time`的新统一变量，用于传递一个基于时间的变量，该变量将在`0`和`2π`之间循环。我们还添加了第二个`sampler2D`统一变量，称为`u_glow`，它将保存我们的新光晕纹理。`main`函数的第一行根据`u_time`中的值计算出`0.0`到`1.0`之间的值。我们使用内置的`texture2D`函数从`u_texture`和`u_glow`中检索采样值。这一次，我们不是直接将纹理的值存储到`gl_FragColor`中，而是将这两个值保存到名为`tex`和`glow`的`vec4`变量中。我们将这两个值相加，为了避免所有地方都变得太亮，我们将`glow`样本颜色中的`rgb`（红绿蓝）值乘以alpha通道。之后，我们将`glow`颜色中的所有值乘以我们之前计算的`cycle`值。
- en: The value in `cycle` will follow a sine wave oscillating between the values
    `0.0` and `1.0`. That will cause our `glow` value to cycle up and down over time.
    We then compute our fragment color by adding the `tex` color to the `glow` color.
    Then, we store the output value in `gl_FragColor`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle`中的值将遵循一个正弦波，在`0.0`和`1.0`之间振荡。这将导致我们的`glow`值随时间上下循环。然后，我们通过将`tex`颜色添加到`glow`颜色来计算我们的片段颜色。然后，我们将输出值存储在`gl_FragColor`中。'
- en: OpenGL global variable changes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL全局变量更改
- en: 'Next, we will need to update our OpenGL-related variables so that we can add
    three new global variables. We will need a new variable called `glow_tex`, which
    we will use to store a reference to the glow texture. We also need two new reference
    variables for our two new uniform variables in our shader, called `u_time_location`
    and `u_glow_location`. Here is what the new block of OpenGL variables will look
    like once we have added those three new lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新与OpenGL相关的变量，以便我们可以添加三个新的全局变量。我们需要一个名为`glow_tex`的新变量，我们将用它来存储对光晕纹理的引用。我们还需要两个新的引用变量，用于我们着色器中的两个新的统一变量，称为`u_time_location`和`u_glow_location`。一旦我们添加了这三行，新的OpenGL变量块将如下所示：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Other global variable changes
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他全局变量更改
- en: 'After our OpenGL global variables, we will need to add a new block of time-related
    global variables. We need them to have our shader cycle through values for our
    engine glow. These time-related variables should look pretty familiar. We have
    used techniques similar to the one we are about to use in the game we have been
    developing. Here are those global time variables:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的OpenGL全局变量之后，我们需要添加一个新的与时间相关的全局变量块。我们需要它们来使我们的着色器循环通过值来实现引擎光晕。这些与时间相关的变量应该看起来很熟悉。我们在开发的游戏中使用了类似于我们即将在游戏中使用的技术。以下是这些全局时间变量：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to add one more SDL-related global surface variable, which we will
    use to load our glow texture. Add the following line near the block of global
    variables that precedes the `main` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个与SDL相关的全局表面变量，我们将用它来加载我们的光晕纹理。在`main`函数之前的全局变量块附近添加以下行：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Changes to main()
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`函数的更改'
- en: 'We will be making some significant modifications to the initialization we are
    doing in our `main` function. Let me start by showing you the entire function.
    Then, we will walk through all of the changes, one at a time:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们在`main`函数中进行的初始化进行一些重大修改。让我先展示整个函数。然后，我们将逐一讲解所有的更改：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first line in our `main` function is new. We use that line to set `last_frame_time`
    and `last_time` to the system time, which we retrieve using `SDL_GetTicks()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`main`函数中的第一行是新的。我们使用该行将`last_frame_time`和`last_time`设置为系统时间，我们使用`SDL_GetTicks()`来获取系统时间：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, we will not make any changes until we get to the section of code
    where we retrieve our uniform locations. We will need to retrieve two more uniform
    locations from our program, so right under our call to `glUseProgram`, we should
    make the following calls to get the uniform locations for `u_glow` and `u_time`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，直到我们到达检索统一位置的代码部分之前，我们将不进行任何更改。我们需要从我们的程序中检索另外两个统一位置，因此在我们调用`glUseProgram`之后，我们应该进行以下调用以获取`u_glow`和`u_time`的统一位置：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following block of code must come after we call `SDL_FreeSurface` to free
    the `sprite_surface` variable. This code block will generate a new texture, activate
    it, bind it, and load the `glow.png` image into that texture. It will then free
    the SDL surface and generate mipmaps for our texture. Finally, we set the uniform
    locations for our textures using `glUniform1i`. Here is the code we use to load
    our new texture:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`SDL_FreeSurface`释放`sprite_surface`变量之后必须添加以下代码块。此代码块将生成一个新的纹理，激活它，绑定它，并将`glow.png`图像加载到该纹理中。然后释放SDL表面并为我们的纹理生成mipmaps。最后，我们使用`glUniform1i`设置纹理的统一位置。以下是我们用来加载新纹理的代码：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are not familiar with Mipmaps, you may be wondering what the `glGenerateMipmap(GL_TEXTURE_2D);`
    line does. When you scale textures using OpenGL, those textures take time to generate.
    Mipmaps are a way to speed up scaling by performing some power of two scaled versions
    of your images while the game is initializing. This will reduce the amount of
    time it will take to scale these images at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Mipmaps不熟悉，您可能会想知道`glGenerateMipmap(GL_TEXTURE_2D);`这一行是做什么的。当您使用OpenGL缩放纹理时，这些纹理需要时间来生成。
    Mipmaps是一种通过在游戏初始化时执行一些二次幂缩放版本的图像来加速缩放的方法。这将减少在运行时缩放这些图像所需的时间。
- en: Updating game_loop()
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新game_loop()
- en: 'To cycle the glow effect on our spaceship''s engines, we will need to add some
    code to our game loop that will cycle from `0.0` through `2π`. We will then pass
    this value into the shader as the `u_time` uniform variable. We need to add this
    new block of code to the beginning of the game loop function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了循环飞船引擎的发光效果，我们需要在我们的游戏循环中添加一些代码，该代码将从`0.0`循环到`2π`。然后，我们将这个值作为`u_time`统一变量传递到着色器中。我们需要将这个新的代码块添加到游戏循环函数的开头：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first line uses `SDL_GetTicks()` to retrieve the current clock time. We
    then subtract the last time from the current time to get a value for the `diff_time`
    variable. This will tell us the number of milliseconds between this frame and
    the previous frame generated. After that, we calculate `delta_time`, which will
    be the fraction of a second between this frame and the previous frame. After we
    have calculated `diff_time` and `delta_time`, we set the `last_time` variable
    to `current_time`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`SDL_GetTicks()`来检索当前时钟时间。然后我们从当前时间中减去上次时间以获得`diff_time`变量的值。这将告诉我们在此帧和上一帧之间生成的毫秒数。之后，我们计算`delta_time`，这将是此帧和上一帧之间的秒数。在我们计算出`diff_time`和`delta_time`之后，我们将`last_time`变量设置为`current_time`。
- en: 'We do this so that the next time we go through the game loop, we will have
    the time this frame ran. All of those lines have been in previous iterations of
    our code. Now, let''s get a value for `time_cycle`, which we will pass into the
    `u_time` uniform variable in our fragment shader. First, add `delta-time * 4`
    to time cycle with the following line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了在下次循环游戏时，我们将知道此帧的运行时间。所有这些行都在我们代码的先前版本中。现在，让我们获取`time_cycle`的值，然后将其传递到我们的片段着色器中的`u_time`统一变量中。首先，使用以下行将`delta-time
    * 4`添加到时间周期中：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You may be wondering why I multiply it by `4`. Initially, I hadn't added a multiple,
    which meant the engine glow cycled roughly every 6 seconds. This felt like the
    cycle was taking too long. Playing with the number, a multiple of 4 just felt
    right to me, but there is no reason you need to stick with this specific multiple
    if you would prefer your engines to cycle either faster or slower.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我要将其乘以`4`。最初，我没有添加倍数，这意味着引擎的发光大约每6秒循环一次。这感觉循环时间太长。尝试不同的数字，4的倍数对我来说感觉刚刚好，但如果您希望引擎的循环速度更快或更慢，您无需坚持使用这个特定的倍数。
- en: 'Because we are using a sine function to cycle our glow level, we need to make
    sure that when our time cycle hits `TWOPI`, we subtract `TWOPI` from our `time_cycle`
    variable:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用正弦函数来循环我们的发光级别，所以当我们的时间周期达到`TWOPI`时，我们需要从我们的`time_cycle`变量中减去`TWOPI`：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have calculated the value for our cycle, we set that value using
    the `u_time_location` reference variable using a call to `glUniform1f`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算出周期的值，我们使用`u_time_location`引用变量通过调用`glUniform1f`来设置该值：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Compiling and running our code
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行我们的代码
- en: 'Now that we have made all of the code changes we need, we can go ahead and
    compile and run the new version of our app. Compile the `glow.c` file by running
    the following `emcc` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了所有需要的代码更改，我们可以继续编译和运行我们应用的新版本。通过运行以下`emcc`命令来编译`glow.c`文件：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the build is successful, running `glow.html` in your web browser should
    show the spaceship moving as it was before. However, now, there will be a glow
    effect on the engines. This glow will cycle up and down and look as follows when
    the engine is at maximum glow:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，在Web浏览器中运行`glow.html`应该显示飞船移动的方式与之前相同。但是现在，引擎上会有一个发光效果。这种发光会上下循环，并在引擎达到最大发光时如下所示：
- en: '![](img/b7146f36-42c8-4a69-860d-7d08556afe4f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7146f36-42c8-4a69-860d-7d08556afe4f.png)'
- en: 'Figure 15.2: Screenshot of the glow shader app'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：发光着色器应用的屏幕截图
- en: In the next section, we will discuss the Phong 3D lighting model.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Phong 3D光照模型。
- en: 3D lighting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D光照
- en: I would like to briefly discuss 3D lighting because we will be approximating
    it with 2D lighting effects. The Phong lighting model is the standard for three-dimensional
    lighting models in computer graphics. It was a model for lighting created by Bui
    Tuong Phong at the University of Utah in 1975, but it was not until the late 1990s
    that desktop computers became fast enough to implement the model in games. Since
    then, the lighting model has become the standard for 3D game development. It combines
    ambient, diffuse, and specular lighting to render geometry. We won't be able to
    implement a proper version of the lighting model because we aren't writing a 3D
    game. However, we can implement an approximation of the model by using 2D sprites
    and normal maps to go along with those sprites.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要讨论一下3D光照，因为我们将用2D光照效果来近似它。冯氏光照模型是计算机图形学中三维光照模型的标准。它是由Bui Tuong Phong于1975年在犹他大学创建的光照模型，但直到20世纪90年代末，台式电脑才足够快速地实现该模型在游戏中的应用。自那时起，这种光照模型已成为3D游戏开发的标准。它结合了环境光、漫反射光和镜面光来渲染几何图形。我们无法实现光照模型的正确版本，因为我们不是在写一个3D游戏。然而，我们可以通过使用2D精灵和法线贴图来近似该模型。
- en: Ambient light
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境光
- en: 'In the real world, there is a certain amount of light that''s randomly reflected
    off of the surrounding surfaces. This creates lighting that will illuminate everything
    evenly. If it weren''t for ambient lighting, an object in the shadow of another
    object would be completely black. The amount of ambient lighting varies based
    on the environment. In a game, the amount of ambient lighting is usually decided
    based on the mood and look a game designer is attempting to achieve. For 2D games,
    ambient lighting may be effectively the only kind of lighting we have. In 3D games,
    relying entirely on ambient light produces models that look flat:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，有一定量的光会随机地反射到周围的表面上。这会产生均匀照亮一切的光线。如果没有环境光，一个物体在另一个物体的阴影下会完全变黑。环境光的数量根据环境而异。在游戏中，环境光的数量通常是根据游戏设计师试图实现的情绪和外观来决定的。对于2D游戏，环境光可能是我们唯一有效的光照。在3D游戏中，完全依赖环境光会产生看起来平坦的模型：
- en: '![](img/312e7693-39ef-4252-9d53-dc284d0a7f31.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/312e7693-39ef-4252-9d53-dc284d0a7f31.png)'
- en: 'Figure 15.3: A sphere with only ambient lighting'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：只有环境光的球
- en: Diffuse light
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射光
- en: 'Diffuse lighting is light that comes from a specific direction. If you look
    at a three-dimensional object in the real world, the side facing a light source
    will look brighter than the side facing away from that light source. This gives
    objects in a 3D environment an actual 3D appearance. In many 2D games, diffuse
    lighting is not created with a shader, but is included in the sprite by the artist
    that created it. In a platformer game, for instance, the artist may assume that
    there is a light source that comes from above the game objects. The artist would
    design the game objects to have a kind of diffuse lighting by changing the colors
    of the pixels in the artwork. For many 2D games, this will work perfectly fine.
    If you would, however, like to have a torch in your game that changes the look
    of the game objects as they move by, you need to design shaders that are capable
    of doing that work:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射光是来自特定方向的光。如果你在现实世界中看一个三维物体，朝向光源的一面会比背对光源的一面看起来更亮。这给了3D环境中的物体一个真正的3D外观。在许多2D游戏中，漫反射光不是通过着色器创建的，而是由创建精灵的艺术家包含在精灵中。例如，在平台游戏中，艺术家可能会假设游戏对象上方有一个光源。艺术家会通过改变艺术作品中像素的颜色来设计游戏对象具有一种漫反射光。对于许多2D游戏来说，这样做完全没问题。然而，如果你想在游戏中加入一个火炬，让它在移动时改变游戏对象的外观，你需要设计能够完成这项工作的着色器：
- en: '![](img/26581e91-5ca6-408c-9fb6-319303979dee.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26581e91-5ca6-408c-9fb6-319303979dee.png)'
- en: 'Figure 15.4: Sphere with diffuse lighting'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：有漫反射光的球
- en: Specular light
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜面光
- en: 'Some objects are shiny and have reflective patches that create bright highlights.
    When light hits a surface, it has a reflective vector based on the angle that
    the light hits the surface, relative to the normal of the surface it is hitting.
    The intensity of specular highlights is based on the reflectivity of the surface,
    combined with the angle of view, relative to the reflected light angle. A specular
    highlight on a game object can make it appear smooth or polished. Not all game
    objects require this kind of lighting, but it looks great on objects you want
    to shine:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物体是有光泽的，并且有反射区域，会产生明亮的高光。当光线照射到表面上时，会有一个基于光线照射表面的角度相对于表面法线的反射向量。镜面高光的强度取决于表面的反射性，以及相对于反射光角度的视角。游戏对象上的镜面高光可以使其看起来光滑或抛光。并非所有游戏对象都需要这种类型的光照，但它在你想要发光的物体上看起来很棒：
- en: '![](img/2e8a12b9-f654-49cb-b1bf-ce46a269680d.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e8a12b9-f654-49cb-b1bf-ce46a269680d.png)'
- en: 'Figure 15.5: Sphere with specular lighting'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：有镜面光的球
- en: In the next section, we will discuss normal maps and how they are used in modern
    games.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论法线贴图及其在现代游戏中的应用。
- en: Normal maps
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法线贴图
- en: Normal mapping is a method that's used for creating very detailed models using
    relatively low polygon counts in 3D games. The idea is that rather than creating
    a surface with a huge number of polygons, a game engine could use a low polygon
    model that had a normal map where each pixel in the normal map would contain the
    x, y, and z values of a normal using the red, green, and blue colors of the image.
    Inside of a shader, we could then sample the normal map texture in the same way
    we sample other texture maps. However, we could use the normal data to help us
    calculate the lighting effects on our sprites. If, in our game, we wanted our
    spaceships to always be lit relative to the star in the center of the gameplay
    area, we could create a normal map for our spaceships and create a light source
    in the center of our game. We will now create an app to demonstrate the use of
    normal maps for 2D lighting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图是一种在3D游戏中使用相对较低的多边形数量创建非常详细模型的方法。其思想是，游戏引擎可以使用一个法线贴图的低多边形模型，其中法线贴图中的每个像素都包含使用图像的红色、绿色和蓝色值的法线的x、y和z值，而不是创建一个具有大量多边形的表面。在着色器内部，我们可以像对其他纹理贴图进行采样一样采样法线贴图纹理。然而，我们可以使用法线数据来帮助我们计算精灵的光照效果。如果在我们的游戏中，我们希望我们的太空飞船始终相对于游戏区域中心的星星照亮，我们可以为我们的太空飞船创建一个法线贴图，并在游戏中心创建一个光源。我们现在将创建一个应用程序来演示2D照明中法线贴图的使用。
- en: Creating a 2D lighting demo app
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个2D照明演示应用程序
- en: 'We can start our lighting app by creating a new C file called `lighting.c`.
    The macros at the beginning of `lighting.c` are the same macros we used in `glow.c`,
    but we can remove the `#define TWOPI` macro because it is no longer needed. Here
    are the macros we will have in our `lighting.c` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个名为`lighting.c`的新C文件来启动我们的照明应用程序。`lighting.c`开头的宏与我们在`glow.c`中使用的宏相同，但我们可以删除`#define
    TWOPI`宏，因为它不再需要。以下是我们将在`lighting.c`文件中使用的宏：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The vertex shader code in this file will be very similar to the vertex shader
    code we had in our `glow.c` file. The one change we will make is done by removing
    the `u_translate` uniform variable. We are doing this because we will be centering
    our shaded sprite image, and we will allow the user to move the light around the
    canvas. Here is the new version of the vertex shader:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的顶点着色器代码将与我们在`glow.c`文件中的顶点着色器代码非常相似。我们将做出的一个改变是删除`u_translate`统一变量。我们这样做是因为我们将把我们的阴影精灵图像居中，并允许用户在画布上移动光源。以下是顶点着色器的新版本：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Fragment shader updates
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器更新
- en: 'Now, we will need to create a new version of our fragment shader. This shader
    will load a normal map in addition to the original texture loaded. This normal
    map will be used to calculate lighting normals on our game object. This version
    of the shader will use a 2D form of the Phong lighting model, in that we will
    be calculating ambient, diffuse, and normal lighting for the sprite we are rendering.
    Here is the code for our new fragment shader:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的片段着色器的新版本。这个着色器将加载一个法线贴图以及原始加载的纹理。这个法线贴图将用于计算我们游戏对象的光照法线。这个着色器版本将使用Phong光照模型的2D形式，我们将计算我们正在渲染的精灵的环境、漫反射和法线光照。以下是我们新片段着色器的代码：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s break down what is going on inside of the new version of the fragment
    shader. The first thing you will notice is that we have two `sampler2D` uniform
    variables; the second one is called `u_normal` and is used to sample the normal
    map for our image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下新版本片段着色器内部发生的事情。你会注意到的第一件事是，我们有两个`sampler2D`统一变量；第二个称为`u_normal`，用于对我们图像的法线贴图进行采样：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After our samplers, we need a `uniform vec3` variable that holds the position
    of our light. We we call this `u_light_pos`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的采样器之后，我们需要一个`uniform vec3`变量，它保存我们光源的位置。我们称之为`u_light_pos`：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will be using several constants in our new fragment shader. We will need
    factors for ambient and specular lighting, as well as the view position and the
    light color. We will be defining those constants in the following four lines of
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新片段着色器中，我们将使用几个常量。我们将需要环境和镜面光照的因子，以及视图位置和光颜色。我们将在以下四行代码中定义这些常量：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Inside of our `main` function, the first thing we will need to do is get the
    ambient fragment color. Determining the ambient color is pretty easy. All you
    need to do is multiply the texture color by the ambient factor, then multiply
    it again by the light color. Here is the code that computes the value for the
    ambient component of the fragment:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数内，我们需要做的第一件事是获取环境片段颜色。确定环境颜色非常容易。你只需要将纹理颜色乘以环境因子，然后再乘以光颜色。以下是计算片段环境分量值的代码：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After calculating our ambient color component, we need to calculate the normal
    of our fragment from the normal map texture that we passed into the shader. The
    texture uses the red color to represent the normal''s `x` value. The green represents
    the `y` value. Finally, blue represents the `z` value. The colors are all floating
    points that go from `0.0` to `1.0`, so we will need to modify the normal''s `x`,
    `y`, and `z` components to go from `-1.0` to `+1.0`. Here is the code we use to
    define the normals:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 计算完我们的环境颜色分量后，我们需要计算我们片段的法线，从我们传递到着色器的法线贴图纹理中。纹理使用红色表示法线的`x`值。绿色表示`y`值。最后，蓝色表示`z`值。颜色都是从`0.0`到`1.0`的浮点数，所以我们需要修改法线的`x`、`y`和`z`分量，使其从`-1.0`到`+1.0`。以下是我们用来定义法线的代码：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To convert the values in the `norm` vector from `0.0` into `1.0`, `-1.0`, and
    `+1.0`, we need to multiply the values in the normal vector by 2, and then subtract
    one. After calculating the value of the normal, we need to find the direction
    of our light source:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`norm`向量中的值从`0.0`转换为`1.0`，`-1.0`和`+1.0`，我们需要将法线向量中的值乘以2，然后减去1。计算法线值后，我们需要找到我们光源的方向：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are normalizing the value with the normalize GLSL function because we won''t
    have any light falloff in this app. If you had a game with a torch, you might
    want a sharp falloff based on the square of the distance from the light source.
    For this app, we are assuming that the light source has an infinite range. For
    our specular lighting, we will need to calculate our view direction:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用normalize GLSL函数对值进行归一化，因为在这个应用程序中我们不会有任何光线衰减。如果你有一个带火炬的游戏，你可能希望基于与光源距离的平方的尖锐衰减。对于这个应用程序，我们假设光源具有无限范围。对于我们的镜面光照，我们需要计算我们的视图方向：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We set the `view_pos` vector to the center of our canvas, so our specular lighting
    should be the greatest when our light source is in the center of our canvas as
    well. You will be able to test this out when you compile the app. After calculating
    the view direction, we will need to calculate the reflection vector, which we
    will also use in our specular lighting calculation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`view_pos`向量设置为画布的中心，因此当我们的光源也在画布的中心时，我们的镜面光照应该最大。当您编译应用程序时，您将能够测试这一点。在计算视图方向之后，我们需要计算反射向量，这也将用于我们的镜面光照计算：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then calculate the dot product of these two vectors, and raise them
    to the power of our specular factor (defined as 32 earlier) to calculate the amount
    of specular lighting we will need for this fragment:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以计算这两个向量的点积，并将它们提升到我们的镜面因子（之前定义为32）的幂，以计算我们需要为这个片段的镜面光照的数量：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After that, we calculate the diffuse component for the fragment using the dot
    product of the normal and the light direction. We combine that with the light
    color to get our diffuse component value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用法线和光线方向的点积来计算片段的漫反射分量。我们将其与光颜色结合以获得我们的漫反射分量值：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we add all of those values together to find our fragment value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些值相加以找到我们的片段值：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: OpenGL global variables
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL全局变量
- en: 'After defining our fragment shader, we need to define a series of OpenGL-related
    global variables. These variables should be familiar to you from the previous
    two versions of this app. There are a few new variables that we should take note
    of. We will no longer have just one program ID. SDL uses its own program, and
    we will need an ID for that program as well. We will call this variable `sdl_program`.
    We will also need new references for our textures. In addition, we will need new
    references for the uniform variables that we pass into our shader. Here is the
    new version of our OpenGL global variable code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的片段着色器之后，我们需要定义一系列与OpenGL相关的全局变量。这些变量应该对你来说是熟悉的，因为它们来自这个应用程序的前两个版本。有一些新变量需要注意。我们将不再只有一个程序ID。SDL使用自己的程序，我们也需要一个该程序的ID。我们将称这个变量为`sdl_program`。我们还需要新的纹理引用。此外，我们还需要新的引用传递给我们的着色器的统一变量。以下是我们的OpenGL全局变量代码的新版本：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: SDL global variables
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDL全局变量
- en: 'Some of the SDL variables were the same as the ones we used in the previous
    apps we created for this chapter. The other variables for lighting and normals
    are new to this section. Here are the SDL-related global variables we will need
    for this app:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些SDL变量与我们在本章为此创建的先前应用程序中使用的变量相同。用于光照和法线的其他变量是这一部分的新内容。以下是我们在这个应用程序中需要的与SDL相关的全局变量：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We need to declare an `SDL_Texture` variable called `light_texture`, which we
    will use to hold the SDL texture for our light icon. We will be using SDL to draw
    our light icon instead of drawing it using OpenGL. We will use one surface pointer
    variable to load all of our textures, freeing that surface immediately after we
    create the texture. We need the width and height value to keep track of the width
    and height of our light icon. We will also need values to keep track of the `x`,
    `y`, and `z` coordinates of our light source.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明一个名为`light_texture`的`SDL_Texture`变量，我们将使用它来保存我们光标图标的SDL纹理。我们将使用SDL来绘制我们的光标图标，而不是使用OpenGL来绘制它。我们将使用一个表面指针变量来加载所有的纹理，然后立即释放该表面。我们需要宽度和高度值来跟踪我们光标图标的宽度和高度。我们还需要值来跟踪我们光源的`x`、`y`和`z`坐标。
- en: Function prototypes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数原型
- en: 'Because I would like to put the code for the `main` function before the code
    for our other functions, we will need a few function prototypes. In this app,
    we will have a game loop function, a function to retrieve mouse input through
    SDL, and a function to draw our light icon using SDL. Here is what those function
    prototypes look like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我想把`main`函数的代码放在其他函数之前，我们需要一些函数原型。在这个应用程序中，我们将有一个游戏循环函数，一个通过SDL检索鼠标输入的函数，以及一个使用SDL绘制我们的光标图标的函数。以下是这些函数原型的样子：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The main function
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Like in the other apps we have created in this chapter, our `main` function
    will need to initialize both SDL and OpenGL variables. The beginning of the `main`
    function is the same as it was at the beginning of our glow app. It initializes
    SDL, then compiles and links the OpenGL shaders and creates a new OpenGL program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章中创建的其他应用程序一样，我们的`main`函数将需要初始化SDL和OpenGL变量。`main`函数的开头与我们的glow应用程序的开头相同。它初始化SDL，然后编译和链接OpenGL着色器并创建一个新的OpenGL程序：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After initializing SDL and creating the OpenGL shader program, we need to get
    uniform variable references for our OpenGL shader program. Two of these references
    are new to this version of the program. The `u_normal_location` variable will
    be a reference to the `u_normal` sampler uniform variable, and the `u_light_pos_location`
    variable will be a reference to the `u_light_pos` uniform variable. Here is the
    new version of our references:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化SDL并创建OpenGL着色器程序之后，我们需要获取我们的OpenGL着色器程序的统一变量引用。其中两个引用是这个程序版本的新内容。`u_normal_location`变量将是对`u_normal`采样器统一变量的引用，`u_light_pos_location`变量将是对`u_light_pos`统一变量的引用。这是我们引用的新版本：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After grabbing the references to our uniform variables, we need to do the same
    for our attributes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取了我们统一变量的引用之后，我们需要对我们的属性做同样的事情：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then need to generate the vertex buffer, bind it, and buffer the data from
    the array we created earlier. This should be the same code that we had in the
    `glow.c` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要生成顶点缓冲区，绑定它，并缓冲我们之前创建的数组中的数据。这应该是我们在`glow.c`文件中的相同代码：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we will need to set up all of our textures. Two of them will be rendered
    using OpenGL, while the other will be rendered using SDL. Here is the initialization
    code for all three of the textures:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置所有的纹理。其中两个将使用OpenGL进行渲染，而另一个将使用SDL进行渲染。以下是这三个纹理的初始化代码：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is a fairly large block of code, so let me walk through it a piece at
    a time. The first three lines generate, activate, and bind the circle texture
    so that we can begin to update it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的代码块，让我一步一步地解释。前三行生成、激活和绑定圆形纹理，以便我们可以开始更新它：
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that we have the circle texture ready to update, we can load the image
    file using SDL:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好更新圆形纹理，我们可以使用SDL加载图像文件：
- en: '[PRE64]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to load that data into our bound texture:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据加载到我们绑定的纹理中：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we can activate that texture, generate mipmaps, and free the surface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以激活该纹理，生成mipmaps，并释放表面：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After doing this for our circle texture, we need to do the same series of steps
    for our normal map:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的圆形纹理做完这些之后，我们需要为我们的法线贴图做同样一系列的步骤：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will handle the final texture differently because it will only be rendered
    using SDL. This should be pretty familiar to you by now. We need to load the surface
    from the image file, create a texture from the surface, query the size of that
    texture, and then free the original surface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以不同的方式处理最终的纹理，因为它只会使用SDL进行渲染。现在你应该对这个很熟悉了。我们需要从图像文件加载表面，从表面创建纹理，查询该纹理的大小，然后释放原始表面：
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now that we have created our textures, we should set up our alpha blending:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的纹理，我们应该设置我们的alpha混合：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The last line of our `main` function uses Emscripten to call the game loop:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一行使用Emscripten调用游戏循环：'
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The game_loop function
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环函数
- en: 'Now that we have our `main` function defined, we need to define our `game_loop`.
    Because the `game_loop` function is rendering using both SDL and OpenGL, we need
    to set our vertex attribute pointers each time through the loop before we render
    in OpenGL. We will also need to switch between more than one OpenGL program because
    SDL uses a different program for shading than the one we are using for OpenGL.
    Let me begin by showing you the entire function, and then we can walk through
    it one piece at a time:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`main`函数，我们需要定义我们的`game_loop`。因为`game_loop`函数同时使用SDL和OpenGL进行渲染，所以我们需要在每次循环之前设置顶点属性指针，然后在OpenGL中进行渲染。我们还需要在多个OpenGL程序之间切换，因为SDL使用的着色程序与我们用于OpenGL的着色程序不同。让我先向您展示整个函数，然后我们可以一步一步地解释它：
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The first line of the game loop calls the `input` function. This function will
    use input from the mouse to set the light position. The second and third lines
    retrieve the SDL shader program and save it to the `sdl_program` variable. Then,
    it switches to the custom OpenGL shaders with a call to `glUseProgram`. Here are
    the two lines of code we call to save the current program and set a new one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的第一行调用了`input`函数。这个函数将使用鼠标输入来设置光源位置。第二和第三行检索SDL着色程序并将其保存到`sdl_program`变量中。然后，它通过调用`glUseProgram`切换到自定义的OpenGL着色程序。以下是我们调用以保存当前程序并设置新程序的两行代码：
- en: '[PRE72]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After that, we call OpenGL to clear the canvas:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用OpenGL来清除画布：
- en: '[PRE73]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we need to set our geometry:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的几何形状：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We then use a call to `glUniform3f` to set the `vec3 uniform u_light_pos` variable
    to the `light_x`, `light_y`, and `light_z` global variables we defined earlier.
    These light positions can be moved using the mouse. The code that allows the user
    to move the light will be defined later when we write the `input` function. After
    we set the values for our light positions, we can draw our triangles using OpenGL:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`glUniform3f`调用将`vec3 uniform u_light_pos`变量设置为我们之前定义的`light_x`、`light_y`和`light_z`全局变量。这些光源位置可以通过鼠标移动。允许用户移动光源的代码将在我们编写`input`函数时定义。设置完光源位置的值后，我们可以使用OpenGL绘制我们的三角形：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, we need to switch back to our SDL program and call the `draw_light_icon`
    function, which will draw our light icon using SDL:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要切换回我们的SDL程序并调用`draw_light_icon`函数，这将使用SDL绘制我们的光标图标：
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The input function
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入函数
- en: 'Now that we have defined our game loop, we will need to write a function to
    capture our mouse input. I want to be able to click our canvas and have the light
    icon and light source move to the location I just clicked. I would also like to
    be able to hold the mouse button down and drag the light icon around the canvas
    to see how the shading works when the light is in different locations on the canvas.
    Most of this code will look very familiar. We use `SDL_PollEvent` to retrieve
    an event and look to see if the left mouse button is down, or if the user has
    moved the scroll wheel. If the user has turned the scroll wheel, the `light_z`
    variable is changed, which will, in turn, change the `z` position of our light
    source. We use the `static int mouse_down` variable to track whether or not the
    user pressed the mouse button. If the user pressed the mouse button, we would
    call `SDL_GetMouseState` to retrieve the `light_x` and `light_y` variables, which
    will modify the x and y positions of our light source. Here is the code for the
    input function in its entirety:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的游戏循环，我们需要编写一个函数来捕获鼠标输入。我希望能够点击我们的画布，让光标图标和光源移动到我刚刚点击的位置。我还希望能够按住鼠标按钮并拖动光标图标在画布上移动，以查看光源在画布上不同位置时阴影的效果。大部分代码看起来都很熟悉。我们使用`SDL_PollEvent`来检索事件，并查看左鼠标按钮是否按下，或用户是否移动了滚轮。如果用户转动了滚轮，`light_z`变量会改变，进而改变我们光源的`z`位置。我们使用`static
    int mouse_down`变量来跟踪用户是否按下了鼠标按钮。如果用户按下了鼠标按钮，我们将调用`SDL_GetMouseState`来检索`light_x`和`light_y`变量，这将修改我们光源的x和y位置。以下是输入函数的完整代码：
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The draw_light_icon function
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制光标图标函数
- en: 'The last function we need to define in our `lighting.c` file is the `draw_light_icon`
    function. This function will use SDL to draw our light icon based on the values
    in the `light_x` and `light_y` variables. We create an `SDL_Rect` variable called
    `dest` and set the `x`, `y`, `w`, and `h` attributes of that structure. We then
    call `SDL_RenderCopy` to render our light icon in the proper location. Here is
    the code for that function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`lighting.c`文件中定义的最后一个函数是`draw_light_icon`函数。该函数将使用SDL根据`light_x`和`light_y`变量的值来绘制我们的光源图标。我们创建一个名为`dest`的`SDL_Rect`变量，并设置该结构的`x`、`y`、`w`和`h`属性。然后，我们调用`SDL_RenderCopy`在适当的位置渲染我们的光源图标。以下是该函数的代码：
- en: '[PRE78]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Compiling and running our lighting app
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行我们的照明应用
- en: 'When we compile and run our lighting app, we should be able to click and drag
    our light around the canvas. We have a small circle that is associated with a
    normal map. Together with our shading and lighting, it should make that circle
    look more like a shiny button. Execute the following command on the command line
    to compile the `lighting.html` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译和运行我们的照明应用时，我们应该能够在画布上单击并拖动我们的光源。我们有一个与法线贴图相关联的小圆圈。结合我们的着色和照明，它应该使得该圆圈看起来更像一个闪亮的按钮。在命令行上执行以下命令来编译`lighting.html`文件：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, you should be able to serve the `lighting.html` file from a web server,
    or emrun. Here is what the app should look like if everything went well:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够从Web服务器或emrun中提供`lighting.html`文件。如果一切顺利，应用程序应该如下所示：
- en: '![](img/aade1966-f9f3-46d9-a525-75605d4672ca.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aade1966-f9f3-46d9-a525-75605d4672ca.png)'
- en: 'Figure 15.6: Screenshot of the 2D lighting app'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：2D照明应用的屏幕截图
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a closer look at shaders after introducing the concept
    back in [Chapter 3](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml), *Introduction
    to WebGL*, when we built a WebGL app. It is helpful to have an understanding of
    WebGL when you are using OpenGL for WebAssembly because each call to OpenGL from
    WebAssembly is internally calling the corresponding WebGL functions. We started
    by rebuilding that WebGL app using a combination of OpenGL ES and SDL in C++ and
    compiled it to WebAssembly. We then learned how we could use OpenGL and shaders
    to mix different textures in interesting ways. We used this knowledge to create
    a pulsing glow around the spaceship's engines. Finally, we discussed 3D lighting
    and normal maps, and then developed a 2D lighting model and created an app that
    allows us to light a simple circle with that lighting model. This app demonstrates
    the possibilities in 2D lighting by allowing us to move our light around a 2D
    circle with a normal map, which is used to give that 2D surface the appearance
    of depth.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在[第3章](dd4517c5-291a-49f5-9c7d-4070bb1fd062.xhtml) *WebGL简介*中介绍了着色器的概念后，更深入地研究了着色器。当我们构建了一个WebGL应用时，了解WebGL是有帮助的。当您在使用OpenGL
    for WebAssembly时，因为每次从WebAssembly调用OpenGL时，内部都会调用相应的WebGL函数。我们首先使用OpenGL ES和C++中的SDL重新构建了该WebGL应用，并将其编译为WebAssembly。然后，我们学习了如何使用OpenGL和着色器以有趣的方式混合不同的纹理。我们利用这些知识创建了一个围绕飞船引擎的脉动发光效果。最后，我们讨论了3D照明和法线贴图，然后开发了一个2D照明模型，并创建了一个允许我们使用该照明模型照亮简单圆圈的应用程序。该应用程序通过允许我们在2D圆圈上移动光源并使用法线贴图来展示2D照明的可能性，法线贴图用于赋予该2D表面深度的外观。
- en: In the next chapter, we will discuss debugging our WebAssembly application and
    the tools we can use for performance testing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论调试我们的WebAssembly应用程序以及我们可以用于性能测试的工具。
