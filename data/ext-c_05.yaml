- en: Chapter 05
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: Stack and Heap
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和堆
- en: 'In the previous chapter, we ran an investigation of the memory layout of a
    running process. System programming without knowing enough about the memory structure
    and its various segments is like doing surgery without knowing the anatomy of
    the human body. The previous chapter just gave us the basic information regarding
    the different segments in the process memory layout, but this chapter wants us
    to just focus on the most frequently used segments: Stack and Heap.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们对正在运行的进程的内存布局进行了调查。如果不了解足够的内存结构和其各个段，进行系统编程就像在不知道人体解剖学的情况下进行手术一样。前一章只是提供了关于进程内存布局中不同段的基本信息，但本章希望我们只关注最常用的段：栈和堆。
- en: As a programmer, you are mostly busy working with Stack and Heap segments. Other
    segments such as Data or BSS are less in use, or you have less control over them.
    That's basically because of the fact that the Data and BSS segments are generated
    by the compiler, and usually, they take up a small percentage of the whole memory
    of a process during its lifetime. This doesn't mean that they are not important,
    and, in fact, there are issues that directly relate to these segments. But as
    you are spending most of your time with Stack and Heap, most memory issues have
    roots in these segments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你大部分时间都在忙于处理栈和堆段。其他段，如数据或BSS段，使用较少，或者你对它们控制较少。这基本上是因为数据和BSS段是由编译器生成的，通常，在进程的生命周期中，它们只占用整个内存的一小部分。这并不意味着它们不重要，实际上，有一些问题直接与这些段相关。但因为你大部分时间都在处理栈和堆，所以大多数内存问题都源于这些段。
- en: 'As part of this chapter, you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，你将学习：
- en: How to probe the Stack segment and the tools you need for this purpose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何探测栈段以及为此目的所需的工具
- en: How memory management is done automatically for the Stack segment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈段是如何自动进行内存管理的
- en: The various characteristics of the stack segment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈段的各项特性
- en: The guidelines and best practices on how to use the Stack segment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何使用栈段的指南和最佳实践
- en: How to probe the Heap segment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何探测堆段
- en: How to allocate and deallocate a Heap memory block
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何分配和释放堆内存块
- en: The guidelines and best practices regarding the usage of the Heap segment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于堆段使用的指南和最佳实践
- en: Memory-constrained environments and tuning memory in performant environments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存受限环境和性能环境中的内存调整
- en: Let's begin our quest by discussing the Stack segment in more detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更详细地讨论栈段来开始我们的探索之旅。
- en: Stack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A process can continue working without the Heap segment but not without the
    Stack segment. This says a lot. The Stack is the main part of the process metabolism,
    and it cannot continue execution without it. The reason is hiding behind the mechanism
    driving the function calls. As briefly explained in the previous chapter, calling
    a function can only be done by using the Stack segment. Without a Stack segment,
    no function call can be made, and this means no execution at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以在没有堆段的情况下继续工作，但不能在没有栈段的情况下工作。这说明了很多。栈是进程代谢的主要部分，没有它就无法继续执行。原因隐藏在驱动函数调用的机制背后。正如前一章简要解释的，调用函数只能通过使用栈段来完成。没有栈段，就无法进行函数调用，这意味着根本无法执行。
- en: With that said, the Stack segment and its contents are engineered carefully
    to result in the healthy execution of the process. Therefore, messing with the
    Stack content can disrupt the execution and halt the process. Allocation from
    the Stack segment is fast, and it doesn't need any special function call. More
    than that, the deallocation and all memory management tasks happen automatically.
    All these facts are all very tempting and encourage you to overuse the Stack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，栈段及其内容被精心设计，以确保过程的健康执行。因此，干扰栈内容可能会破坏执行并停止进程。从栈段分配内存速度快，且不需要任何特殊函数调用。更重要的是，释放内存和所有内存管理任务都是自动发生的。所有这些事实都非常诱人，并鼓励你过度使用栈。
- en: 'You should be careful about this. Using the Stack segment brings its own complications.
    The stack is not very big, therefore you cannot store large objects in it. In
    addition, incorrect use of the Stack content can halt the execution and result
    in a crash. The following piece of code demonstrates this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对此保持警惕。使用栈段会带来自己的复杂性。栈并不大，因此你无法在其中存储大对象。此外，栈内容的错误使用可能导致执行中断并引发崩溃。以下代码片段展示了这一点：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 5-1: A buffer overflow situation. The strcpy function will overwrite
    the content of the Stack'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 5-1：缓冲区溢出情况。strcpy 函数将覆盖栈的内容
- en: When running the preceding code, the program will most likely crash. That's
    because the `strcpy` is overwriting the content of the Stack, or as it is commonly
    termed, *smashing* the stack. As you see in *Code Box 5-1*, the `str` array has
    `10` characters, but the `strcpy` is writing way more than 10 characters to the
    `str` array. As you will see shortly, this effectively writes on the previously
    pushed variables and stack frames, and the program jumps to a wrong instruction
    after returning from the `main` function. And this eventually makes it impossible
    to continue the execution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码时，程序很可能会崩溃。这是因为`strcpy`正在覆盖栈的内容，或者如通常所说的，*破坏*栈。正如你在*代码框 5-1*中看到的，`str`数组有`10`个字符，但`strcpy`正在向`str`数组写入超过10个字符。正如你很快就会看到的，这实际上是在写入之前推入的变量和栈帧，程序在从`main`函数返回后会跳转到错误的指令。这最终使得程序无法继续执行。
- en: I hope that the preceding example has helped you to appreciate the delicacy
    of the Stack segment. In the first half of this chapter, we are going to have
    a deeper look into the Stack and examine it closely. We first start by probing
    into the Stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的例子已经帮助你理解了栈段的微妙之处。在本章的前半部分，我们将更深入地研究栈，并对其进行仔细检查。我们首先从探测栈开始。
- en: Probing the Stack
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探测栈
- en: Before knowing more about the Stack, we need to be able to read and, probably,
    modify it. As stated in the previous chapter, the Stack segment is a private memory
    that only the owner process has the right to read and modify. If we are going
    to read the Stack or change it, we need to become part of the process owning the Stack.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解更多关于栈的信息之前，我们需要能够读取它，也许还能修改它。正如前一章所述，栈段是只有所有者进程才有权读取和修改的私有内存。如果我们打算读取栈或更改它，我们需要成为拥有栈的进程的一部分。
- en: 'This is where a new set of tools come in: *debuggers*. A debugger is a program
    that attaches to another process in order to *debug* it. One of the usual tasks
    while debugging a process is to observe and manipulate the various memory segments.
    Only when debugging a process are we able to read and modify the private memory
    blocks. The other thing that can be done as part of debugging is to control the
    order of the execution of the program instructions. We give examples on how to
    do these tasks using a debugger shortly, as part of this section.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一套新工具的用武之地：*调试器*。调试器是一种程序，它可以附加到另一个进程上以对其进行*调试*。在调试进程时，一个常见的任务就是观察和操作各种内存段。只有在调试进程时，我们才能读取和修改私有内存块。作为调试的一部分，还可以控制程序指令的执行顺序。在本节中，我们将通过示例展示如何使用调试器来完成这些任务。
- en: 'Let''s start with an example. In *example 5.1*, we show how to compile a program
    and make it ready for debugging. Then, we demonstrate how to use `gdb`, the GNU
    debugger, to run the program and read the Stack memory. This example declares
    a character array allocated on top of the Stack and populates its elements with
    some characters, as can be seen in the following code box:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。在*示例 5.1*中，我们展示了如何编译程序并使其准备好进行调试。然后，我们演示了如何使用`gdb`（GNU调试器）来运行程序并读取栈内存。此示例声明了一个在栈顶分配的字符数组，并用一些字符填充其元素，如下面的代码框所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 5-2 [ExtremeC_examples_chapter5_1.c]: Declaration of an array allocated
    on top of the Stack'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 5-2 [ExtremeC_examples_chapter5_1.c]：在栈顶分配的数组声明
- en: The program is simple and easy to follow, but the things that are happening
    inside the memory are interesting. First of all, the memory required for the `arr`
    array is allocated from the Stack simply because it is not allocated from the
    Heap segment and we didn't use the `malloc` function. Remember, the Stack segment
    is the default place for allocating variables and arrays.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 程序简单易懂，但内存内部发生的事情很有趣。首先，`arr`数组所需的内存是从栈中分配的，因为它不是从堆段分配的，我们没有使用`malloc`函数。记住，栈段是分配变量和数组的默认位置。
- en: In order to have some memory allocated from the Heap, one should acquire it
    by calling `malloc` or other similar functions, such as `calloc`. Otherwise, the
    memory is allocated from the Stack, and more precisely, on top of the Stack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从堆中分配一些内存，应该通过调用`malloc`或其他类似函数来获取它，例如`calloc`。否则，内存将从栈中分配，更确切地说，是在栈顶。
- en: In order to be able to debug a program, the binary must be built for debugging
    purposes. This means that we have to tell the compiler that we want a binary that
    contains *debug* *symbols*. These symbols will be used to find the code lines
    that have been executing or those that caused a crash. Let's compile *example
    5.1* and create an executable object file that contains debugging symbols.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够调试一个程序，二进制文件必须为调试目的而构建。这意味着我们必须告诉编译器我们想要一个包含*调试* *符号*的二进制文件。这些符号将用于找到正在执行的代码行或导致崩溃的代码行。让我们编译*example
    5.1*并创建一个包含调试符号的可执行目标文件。
- en: 'First, we build the example. We''re doing our compilation in a Linux environment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构建示例。我们在Linux环境中进行编译：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 5-1: Compiling the example 5.1 with debug option -g'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-1：使用调试选项-g编译example 5.1
- en: 'The `-g` option tells the compiler that the final executable object file must
    contain the debugging information. The size of the binary is also different when
    you compile the source with and without the debug option. Next, you can see the
    difference between the sizes of the two executable object files, the first one
    built without the `-g` option and the second one with the `-g` option:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`选项告诉编译器最终的可执行目标文件必须包含调试信息。当使用和不使用调试选项编译源代码时，二进制文件的大小也会不同。接下来，你可以看到两个可执行目标文件大小的差异，第一个是未使用`-g`选项构建的，第二个是使用`-g`选项构建的：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 5-2: The size of the output executable object file with and without
    the -g option'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-2：带有和不带有`-g`选项的输出可执行目标文件的大小
- en: 'Now that we have an executable file containing the debug symbols, we can use
    the debugger to run the program. In this example, we are going to use `gdb` for
    debugging *example 5.1*. Next, you can find the command to start the debugger:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含调试符号的可执行文件，我们可以使用调试器来运行程序。在这个例子中，我们将使用`gdb`来调试*example 5.1*。接下来，你可以找到启动调试器的命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 5-3: Starting the debugger for the example 5.1'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-3：启动example 5.1的调试器
- en: '**Note**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: '`gdb` is usually installed as part of the `build-essentials` package on Linux
    systems. In macOS systems, it can be installed using the `brew` package manager
    like this: `brew install gdb`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`通常作为`build-essentials`包的一部分安装在Linux系统上。在macOS系统上，可以使用`brew`包管理器安装，如下所示：`brew
    install gdb`。'
- en: 'After running the debugger, the output will be something similar to the following
    shell box:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行调试器后，输出将类似于以下Shell Box：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 5-4: The output of the debugger after getting started'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-4：启动调试器后的输出
- en: 'As you may have noticed, I''ve run the preceding command on a Linux machine.
    `gdb` has a command-line interface that allows you to issue debugging commands.
    Enter the `r` (or `run`) command in order to execute the executable object file,
    specified as an input to the debugger. The following shell box shows how the `run` command
    executes the program:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我已在Linux机器上运行了前面的命令。`gdb`有一个命令行界面，允许你发出调试命令。输入`r`（或`run`）命令以执行调试器指定的可执行目标文件。以下Shell
    Box显示了`run`命令如何执行程序：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 5-5: The output of the debugger after issuing the run command'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-5：发出`run`命令后调试器的输出
- en: In the preceding shell box, after issuing the `run` command, `gdb` has started
    the process, attached to it, and let the program execute its instructions and
    exit. It did not interrupt the program because we have not set a *breakpoint*.
    A breakpoint is an indicator that tells `gdb` to pause the program execution and
    wait for further instructions. You can have as many breakpoints as you want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Shell Box中，在发出`run`命令后，`gdb`已经启动了进程，附加到它上面，并让程序执行其指令并退出。它没有中断程序，因为我们没有设置*断点*。断点是一个指示器，告诉`gdb`暂停程序执行并等待进一步的指令。你可以设置任意多的断点。
- en: 'Next, we set a breakpoint on the `main` function using the `b` (or `break`)
    command. After setting the breakpoint, `gdb` pauses the execution when the program
    enters the `main` function. You can see how to set a breakpoint on the `main`
    function in the following shell box:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`b`（或`break`）命令在`main`函数上设置断点。设置断点后，当程序进入`main`函数时，`gdb`会暂停执行。以下Shell
    Box显示了如何在`main`函数上设置断点：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 5-6: Setting a breakpoint on the main function in gdb'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-6：在gdb中设置main函数的断点
- en: 'Now, we run the program again. This creates a new process, and `gdb` attaches
    to it. Next, you can find the result:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次运行程序。这会创建一个新的进程，并且`gdb`会附加到它上面。接下来，你可以找到结果：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 5-7: Running the program again after setting the breakpoint'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-7：设置断点后再次运行程序
- en: As you can see, the execution has paused at line 3, which is just the line of
    the `main` function. Then, the debugger waits for the next command. Now, we can
    ask `gdb` to run the next line of code and pause again. In other words, we run
    the program step by step and line by line. This way, you have enough time to look
    around and check the variables and their values inside the memory. In fact, this
    is the method we are going to use to probe the Stack and the Heap segments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，执行暂停在第 3 行，这正是 `main` 函数的行。然后，调试器等待下一个命令。现在，我们可以要求 `gdb` 运行下一行代码并再次暂停。换句话说，我们逐行逐行地运行程序。这样，你有足够的时间四处查看并检查内存中变量及其值。实际上，这是我们用来探测堆栈和堆段的技巧。
- en: 'In the following shell box, you can see how to use the `n` (or `next`) command
    to run the next line of code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Shell Box 中，你可以看到如何使用 `n`（或 `next`）命令来运行下一行代码：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 5-8: Using the n (or next) command to execute upcoming lines of code'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-8：使用 n（或 next）命令执行即将到来的代码行
- en: 'Now, if you enter the `print arr` command in the debugger, it will show the
    content of the array as a string:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在调试器中输入 `print arr` 命令，它将显示数组的内容作为一个字符串：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 5-9: Printing the content of the arr array using gdb'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-9：使用 gdb 打印 arr 数组的内容
- en: 'To get back to the topic, we introduced `gdb` to be able to see inside the
    Stack memory. Now, we can do it. We have a process that has a Stack segment, and
    it is paused, and we have a `gdb` command line to explore its memory. Let''s begin
    and print the memory allocated for the `arr` array:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回到主题，我们介绍了 `gdb` 以能够查看堆栈内存。现在，我们可以做到了。我们有一个具有堆栈段的进程，它是暂停的，并且我们有一个 `gdb` 命令行来探索其内存。让我们开始并打印
    `arr` 数组分配的内存：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shell Box 5-10: Printing bytes of memory starting from the arr array'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-10：从 arr 数组开始打印内存字节
- en: The first command, `x/4b`, shows 4 bytes from the location that `arr` is pointing
    to. Remember that `arr` is a pointer that actually is pointing to the first element
    of the array, so it can be used to move along the memory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令 `x/4b` 显示了从 `arr` 所指向的位置开始的 4 个字节。记住，`arr` 是一个指针，实际上它指向数组的第一个元素，因此它可以用来在内存中移动。
- en: The second command, `x/8b`, prints 8 bytes after `arr`. According to the code
    written for *example 5.1*, and found in *Code Box 5-2*, the values `A`, `B`, `C`,
    and `D` are stored in the array, `arr`. You should know that ASCII values are
    stored in the array, not the real characters. The ASCII value for `A` is `65`
    decimal or `0x41` hexadecimal. For `B`, it is `66` or `0x42`. As you can see,
    the values printed in the `gdb` output are the values we just stored in the `arr`
    array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条命令 `x/8b` 在 `arr` 之后打印 8 个字节。根据为 *example 5.1* 编写的代码，并在 *Code Box 5-2* 中找到，值
    `A`、`B`、`C` 和 `D` 存储在数组 `arr` 中。你应该知道，ASCII 值存储在数组中，而不是真正的字符。`A` 的 ASCII 值是十进制的
    `65` 或十六进制的 `0x41`。对于 `B`，它是 `66` 或 `0x42`。正如你所看到的，`gdb` 输出中打印的值就是我们刚刚存储在 `arr`
    数组中的值。
- en: What about the other 4 bytes in the second command? They are part of the Stack,
    and they probably contain data from the recent Stack frame put on top of the Stack
    while calling the `main` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条命令中的其他 4 个字节是什么？它们是堆栈的一部分，并且它们可能包含在调用 `main` 函数时放在堆栈顶部的最近堆栈帧中的数据。
- en: Note that the Stack segment is filled in an opposite fashion in comparison to
    other segments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与其他段相比，堆栈段是以相反的方式填充的。
- en: Other memory regions are filled starting from the smaller addresses and they
    move forward to bigger addresses, but this is not the case with the Stack segment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内存区域是从较小的地址开始填充，并向前移动到较大的地址，但堆栈段的情况并非如此。
- en: The Stack segment is filled from the bigger addresses and moves backward to
    the smaller addresses. Some of the reasons behind this design lie in the development
    history of modern computers, and some in the functionality of the Stack segment,
    which behaves like a stack data structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈段是从较大的地址开始填充，并向后移动到较小的地址。这种设计背后的原因部分在于现代计算机的开发历史，部分在于堆栈段的功能，它表现得像一个堆栈数据结构。
- en: With all that said, if you read the Stack segment from an addresses toward the
    bigger addresses, just like we did in *Shell Box 5-10*, you are effectively reading
    the already pushed content as part of the Stack segment, and if you try to change
    those bytes, you are altering the Stack, and this is not good. We will demonstrate
    why this is dangerous and how this can be done in future paragraphs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，如果你像我们在*Shell Box 5-10*中做的那样，从地址段向更大的地址读取Stack段，你实际上是在将已推入的内容作为Stack段的一部分来读取，如果你尝试更改这些字节，你就是在更改Stack，这是不好的。我们将在未来的段落中演示为什么这是危险的以及如何做到这一点。
- en: Why are we able to see more than the size of the `arr` array? Because `gdb`
    goes through the number of bytes in the memory that we have requested. The `x`
    command doesn't care about the array's boundary. It just needs a starting address
    and the number of bytes to print the range.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们能看到比`arr`数组大小更多的内容？因为`gdb`会遍历我们请求的内存中的字节数。`x`命令不关心数组的边界。它只需要一个起始地址和要打印的字节数。
- en: 'If you want to change the values inside the Stack, you have to use the `set`
    command. This allows you to modify an existing memory cell. In this case, the
    memory cell refers to an individual byte in the `arr` array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改Stack中的值，你必须使用`set`命令。这允许你修改现有的内存单元。在这种情况下，内存单元指的是`arr`数组中的单个字节：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 5-11: Changing an individual byte in the array using the set command'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-11：使用set命令更改数组中的单个字节
- en: As you can see, using the `set` command, we have set the second element of the
    `arr` array to `F`. If you are going to change an address that is not in the boundaries
    of your arrays, it is still possible through `gdb`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用`set`命令，我们已经将`arr`数组的第二个元素设置为`F`。如果你打算更改不在你的数组边界内的地址，仍然可以通过`gdb`来实现。
- en: 'Please observe the following modification carefully. Now, we want to modify
    a byte located in a far bigger address than `arr`, and as we explained before,
    we will be altering the already pushed content of the Stack. Remember, the Stack
    memory is filled in an opposite manner compared to other segments:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细观察以下修改。现在，我们想要修改一个位于比`arr`大得多的地址的字节，正如我们之前解释的，我们将更改Stack中已推入的内容。记住，Stack内存的填充方式与其他段相反：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Shell Box 5-12: Changing an individual byte outside of the array''s boundary'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-12：在数组边界之外更改单个字节
- en: That is all. We just wrote the value `0xff` in the `0x7fffffffcaed` address,
    which is out of the boundary of the `arr` array, and probably a byte within the
    stack frame pushed before entering the `main` function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部。我们只是在`0x7fffffffcaed`地址中写入了值`0xff`，这个地址超出了`arr`数组的边界，可能是在进入`main`函数之前推入的栈帧中的某个字节。
- en: 'What will happen if we continue the execution? If we have modified a critical
    byte in the Stack, we expect to see a crash or at least have this modification
    detected by some mechanism and have the execution of the program halted. The command
    `c` (or `continue`) will continue the execution of the process in `gdb`, as you
    can see next:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续执行会发生什么？如果我们修改了Stack中的关键字节，我们预计会看到崩溃，或者至少通过某种机制检测到这种修改，并使程序执行停止。`c`（或`continue`）命令将在`gdb`中继续进程的执行，正如你接下来可以看到的：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 5-13: Having a critical byte changed in the Stack terminates the
    process'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-13：在Stack中更改关键字节会终止进程
- en: As you can see in the preceding shell box, we've just smashed the Stack! Modifying
    the content of the Stack in addresses that are not allocated by you, even by 1
    byte, can be very dangerous and it usually leads to a crash or a sudden termination.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的shell box所示，我们刚刚破坏了Stack！在未分配给你的地址中修改Stack的内容，即使只修改1个字节，也可能非常危险，通常会导致崩溃或突然终止。
- en: As we have said before, most of the vital procedures regarding the execution
    of a program are done within the Stack memory. So, you should be very careful
    when writing to Stack variables. You should not write any values outside of the
    boundaries defined for variables and arrays simply because the addresses grow
    backward in the Stack memory, which makes it likely to overwrite the already written
    bytes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，与程序执行相关的许多重要过程都是在Stack内存中完成的。因此，你在写入Stack变量时应该非常小心。你不应该在变量和数组的定义边界之外写入任何值，仅仅因为Stack内存中的地址是向后增长的，这使得覆盖已写入的字节变得很可能会发生。
- en: When you're done with debugging, and you're ready to leave the `gdb`, then you
    can simply use the command `q` (or `quit`). Now, you should be out of the debugger
    and back in the terminal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成调试，准备离开`gdb`时，你可以简单地使用命令`q`（或`quit`）。现在，你应该已经离开了调试器，回到了终端。
- en: As another note, writing unchecked values into a *buffer* (another name for
    a byte or character array) allocated on top of the Stack (not from the Heap) is
    considered a vulnerability. An attacker can carefully design a byte array and
    feed it to the program in order to take control of it. This is usually called
    an *exploit* because of a *buffer overflow* attack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的是，将未经检查的值写入在栈顶（而非堆）分配的*缓冲区*（字节数组或字符数组的另一种称呼）被视为一个漏洞。攻击者可以精心设计一个字节数组并将其提供给程序，以控制程序。这通常被称为*漏洞利用*，因为它涉及到*缓冲区溢出*攻击。
- en: 'The following program shows this vulnerability:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了这个漏洞：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 5-3: A program showing the buffer overflow vulnerability'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 5-3：展示缓冲区溢出漏洞的程序
- en: The preceding code does not check the `argv[1]` input for its content and its
    size and copies it directly into the `str` array, which is allocated on top of
    the Stack.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有检查`argv[1]`输入的内容和大小，直接将其复制到在栈顶分配的`str`数组中。
- en: If you're lucky, this can lead to a crash, but in some rare but dangerous cases,
    this can lead to an exploit attack.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很幸运，这可能导致崩溃，但在一些罕见但危险的情况下，这可能导致漏洞利用攻击。
- en: Points on using the Stack memory
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用栈内存的要点
- en: Now that you have a better understanding of the Stack segment and how it works,
    we can talk about the best practices and the points you should be careful about.
    You should be familiar with the *scope* concept. Each Stack variable has its own
    scope, and the scope determines the lifetime of the variable. This means that
    a Stack variable starts its lifetime in one scope and dies when that scope is
    gone. In other words, the scope determines the lifetime of a Stack variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对栈段及其工作原理有了更好的理解，我们可以讨论最佳实践和你应该注意的要点。你应该熟悉*作用域*的概念。每个栈变量都有自己的作用域，作用域决定了变量的生命周期。这意味着栈变量在其生命周期开始于一个作用域，并在该作用域消失时结束。换句话说，作用域决定了栈变量的生命周期。
- en: We also have automatic memory allocation and deallocation for Stack variables,
    and it is only applicable to the Stack variables. This feature, automatic memory
    management, comes from the nature of the Stack segment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对栈变量也有自动的内存分配和释放，这仅适用于栈变量。这个特性，自动内存管理，来源于栈段的本质。
- en: Whenever you declare a Stack variable, it will be allocated on top of the Stack
    segment. Allocation happens automatically, and this can be marked as the start
    of its lifetime. After this point, many more variables and other stack frames
    are put on top of it inside the Stack. As long as the variable exists in the Stack
    and there are other variables on top of it, it survives and continues living.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你声明一个栈变量时，它都会被分配在栈段顶部。分配是自动发生的，这可以标记为其生命周期的开始。在此之后，许多更多的变量和其他栈帧被放在栈的顶部。只要变量存在于栈中，并且有其他变量在其上方，它就会存活并继续存在。
- en: Eventually, however, this stuff will get popped out of the Stack because at
    some point in the future the program has to be finished, and the stack should
    be empty at that moment. So, there should be a point in the future when this variable
    is popped out of the stack. So, the deallocation, or getting popped out, happens
    automatically, and that can be marked as the end of the variable's lifetime. This
    is basically the reason why we say that we have automatic memory management for
    the Stack variables that is not controlled by the programmer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些内容最终会从栈中弹出，因为将来某个时刻程序必须结束，此时栈应该是空的。因此，在未来的某个时刻，这个变量应该从栈中弹出。因此，释放或弹出是自动发生的，这可以标记为变量生命周期的结束。这基本上是我们说我们对栈变量具有自动内存管理，这种管理不由程序员控制的原因。
- en: 'Suppose that you have defined a variable in the `main` function, as we see
    in the following code box:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在`main`函数中定义了一个变量，如下面的代码框所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 5-4: Declaring a variable on top of the Stack'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 5-4：在栈上声明变量
- en: This variable will stay in the Stack until the `main` function returns. In other
    words, the variable exists until its scope (the `main` function) is valid. Since
    the `main` function is the function in which all the program runs, the lifetime
    of the variable is almost like a global variable that is declared throughout the
    runtime of the program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将保留在栈中，直到`main`函数返回。换句话说，变量存在直到其作用域（`main`函数）有效。由于`main`函数是所有程序运行的函数，因此变量的生命周期几乎像一个在整个程序运行期间声明的全局变量。
- en: It is like a global variable, but not exactly one, because there will be a time
    that the variable is popped out from the Stack, whereas a global variable always
    has its memory even when the main function is finished and the program is being
    finalized. Note that there are two pieces of code that are run before and after
    the `main` function, bootstrapping and finalizing the program respectively. As
    another note, global variables are allocated from a different segment, Data or
    BSS, that does not behave like the Stack segment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它像一个全局变量，但又不完全一样，因为变量会在某个时刻从栈中弹出，而全局变量即使在`main`函数完成并且程序正在最终化时，其内存仍然存在。请注意，在`main`函数之前和之后运行了两段代码，分别是程序的引导和最终化。作为另一个注意事项，全局变量是从不同的段分配的，如数据或BSS段，它不像栈段那样表现。
- en: Let's now look at an example of a very common mistake. It usually happens to
    an amateur programmer while writing their first C programs. It is about returning
    an address to a local variable inside a function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一个非常常见的错误的例子。这通常发生在编写第一个C程序时的业余程序员身上。它涉及到在函数内部返回局部变量的地址。
- en: 'The following code box shows *example 5.2*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了*示例5.2*：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 5-5 [ExtremeC_examples_chapter5_2.c]: Declaring a variable on top
    of the Stack'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框5-5 [ExtremeC_examples_chapter5_2.c]：在栈顶声明一个变量
- en: 'The `get_integer` function returns an address to the local variable, `var`,
    which has been declared in the scope of the `get_integer` function. The `get_integer`
    function returns the address of the local variable. Then, the `main` function
    tries to dereference the received pointer and access the memory region behind.
    The following is the output of the `gcc` compiler while compiling the preceding
    code on a Linux system:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_integer`函数返回一个指向在`get_integer`函数作用域内声明的局部变量`var`的地址。`get_integer`函数返回局部变量的地址。然后，`main`函数尝试解引用接收到的指针并访问其后的内存区域。以下是在Linux系统上编译上述代码时`gcc`编译器的输出：'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 5-14: Compiling the example 5.2 in Linux'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-14：在Linux中编译示例5.2
- en: 'As you can see, we have received a warning message. Since returning the address
    of a local variable is a common mistake, compilers already know about it, and
    they show a clear warning message like `warning: function returns address of a local
    variable`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们收到了一个警告消息。由于返回局部变量的地址是一个常见的错误，编译器已经知道这一点，并且会显示一个清晰的警告消息，如`warning: function
    returns address of a local variable`。'
- en: 'And this is what happens when we execute the program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序执行时发生的情况：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 5-15: Executing the example 5.2 in Linux'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-15：在Linux中执行示例5.2
- en: As you can see in *Shell Box 5-15*, a segmentation fault has happened. It can
    be translated as a crash. It is usually because of invalid access to a region
    of memory that had been allocated at some point, but now it is deallocated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*Shell Box 5-15*中看到的那样，发生了段错误。它可以被翻译为崩溃。这通常是因为对某个在某个时刻已分配但现在已经取消分配的内存区域的无效访问。
- en: '**Note**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Some warnings should be treated as errors. For example, the preceding warning
    should be an error because it usually leads to a crash. If you want to make all
    warning to be treated as errors, it is enough to pass the `-Werror` option to
    `gcc` compiler. If you want to treat only one specific warning as an error, for
    example, the preceding warning, it is enough to pass the `-Werror=return-local-addr`
    option.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将一些警告视为错误。例如，前面的警告应该是一个错误，因为它通常会导致崩溃。如果您想将所有警告都视为错误，只需将`-Werror`选项传递给`gcc`编译器即可。如果您只想将一个特定的警告视为错误，例如前面的警告，只需传递`-Werror=return-local-addr`选项即可。
- en: If you run the program with `gdb`, you will see more details regarding the crash.
    But remember, you need to compile the program with the `-g` option otherwise `gdb`
    won't be that helpful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`gdb`运行程序，您将看到有关崩溃的更多详细信息。但请记住，您需要使用`-g`选项编译程序，否则`gdb`不会那么有帮助。
- en: 'It is always mandatory to compile the sources with `-g` option if you are about
    to debug the program using `gdb` or other debugging tools such as `valgrind`.
    The following shell box demonstrates how to compile and run *example 5.2* in the debugger:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用`gdb`或其他调试工具（如`valgrind`）来调试程序，那么始终必须使用`-g`选项编译源代码。以下shell窗口演示了如何在调试器中编译和运行*示例5.2*：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 5-16: Running the example 5.2 in the debugger'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-16：在调试器中运行示例5.2
- en: As is clear from the `gdb` output, the source of the crash is located at line
    8 in the `main` function, exactly where the program tries to write to the returned
    address by dereferencing the returned pointer. But the `var` variable has been
    a local variable to the `get_integer` function and it doesn't exist anymore, simply
    because at line 8 we have already returned from the `get_integer` function and
    its scope, together with all variables, have vanished. Therefore, the returned
    pointer is a *dangling pointer*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如`gdb`输出所示，崩溃的来源位于`main`函数的第8行，正好是程序尝试通过解引用返回的指针来写入返回地址的地方。但是，`var`变量已经成为`get_integer`函数的局部变量，并且它不再存在，仅仅因为我们在第8行已经从`get_integer`函数及其作用域返回，以及所有变量，都已经消失。因此，返回的指针是一个*悬垂指针*。
- en: It is usually a common practice to pass the pointers addressing the variables
    in the current scope to other functions but not the other way around, because
    as long as the current scope is valid, the variables are there. Further function
    calls only put more stuff on top of the Stack segment, and the current scope won't
    be finished before them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将指向当前作用域内变量的指针传递给其他函数，而不是相反，是一种常见的做法，因为只要当前作用域有效，变量就在那里。进一步的函数调用只会将更多东西放在栈段顶部，并且当前作用域不会在它们之前结束。
- en: Note that the above statement is not a good practice regarding concurrent programs
    because in the future, if another concurrent task wants to use the received pointer
    addressing a variable inside the current scope, the current scope might have vanished
    already.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述关于并发程序的说法并不是一个好的实践，因为在将来，如果另一个并发任务想要使用指向当前作用域内变量的接收到的指针，当前作用域可能已经不存在了。
- en: 'To end this section and have a conclusion about the Stack segment, the following
    points can be extracted from what we have explained so far:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一节，并对栈段得出结论，我们可以从到目前为止所解释的内容中提取以下要点：
- en: Stack memory has a limited size; therefore, it is not a good place to store
    big objects.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈内存的大小有限；因此，它不是存储大对象的好地方。
- en: The addresses in Stack segment grow backward, therefore reading forward in the
    Stack memory means reading already pushed bytes.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈段的地址向后增长，因此，在栈内存中向前读取意味着读取已经推入的字节。
- en: Stack has automatic memory management, both for allocation and deallocation.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈具有自动内存管理，包括分配和释放。
- en: Every Stack variable has a scope and it determines its lifetime. You should
    design your logic based on this lifetime. You have no control over it.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个栈变量都有一个作用域，它决定了其生命周期。你应该根据这个生命周期来设计你的逻辑。你无法控制它。
- en: Pointers should only point to those Stack variables that are still in a scope.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针应该只指向那些仍然在作用域内的栈变量。
- en: Memory deallocation of Stack variables is done automatically when the scope
    is about to finish, and you have no control over it.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当作用域即将结束时，栈变量的内存释放是自动完成的，你无法控制它。
- en: Pointers to variables that exist in the current scope can be passed to other
    functions as arguments only when we are sure that the current scope will be still
    in place when the code in the called functions is about to use that pointer. This
    condition might break in situations when we have concurrent logic.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当我们确信当前作用域在调用函数中的代码即将使用该指针时仍然存在时，才能将指向当前作用域内变量的指针作为参数传递给其他函数。在具有并发逻辑的情况下，这种条件可能会被打破。
- en: In the next section, we will talk about the Heap segment and its various features.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论堆段及其各种特性。
- en: Heap
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: Almost any code, written in any programming language, uses Heap memory in some
    way. That's because the Heap has some unique advantages that cannot be achieved
    by using the Stack.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何编程语言编写的代码都会以某种方式使用堆内存。这是因为堆有一些独特的优势，这些优势是使用栈无法实现的。
- en: On the other hand, it also has some disadvantages; for example, it is slower
    to allocate a region of Heap memory in comparison to a similar region in Stack
    memory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它也有一些缺点；例如，与栈内存中的类似区域相比，分配堆内存区域要慢。
- en: In this section, we are going to talk more about the Heap itself and the guidelines
    we should keep in mind when using Heap memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地讨论堆本身以及在使用堆内存时应注意的指南。
- en: Heap memory is important because of its unique properties. Not all of them are
    advantageous and, in fact, some of them can be considered as risks that should
    be mitigated. A great tool always has good points and some bad points, and if
    you are going to use it properly, you are required to know both sides very well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存之所以重要，是因为它具有独特的属性。并非所有这些属性都是有益的，事实上，其中一些可以被视为应该减轻的风险。一个伟大的工具总有优点和缺点，如果你要正确使用它，你必须非常了解这两方面。
- en: 'Here, we are going to list these features and see which ones are beneficial
    and which are risky:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将列出这些特性，并看看哪些是有益的，哪些是有风险的：
- en: '**The Heap doesn''t have any memory blocks that are allocated automatically**.
    Instead, the programmer must use `malloc` or similar functions to obtain Heap
    memory blocks, one by one. In fact, this could be regarded as a weak point for
    Stack memory that is resolved by Heap memory. Stack memory can contain stack frames,
    which are not allocated and pushed by the programmer but as a result of function
    calls, and in an automatic fashion.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆中没有自动分配的内存块**。相反，程序员必须使用`malloc`或类似函数逐个获取堆内存块。实际上，这可以被视为栈内存的弱点，而堆内存则解决了这个问题。栈内存可以包含栈帧，这些栈帧不是由程序员分配和推送的，而是由于函数调用以自动方式产生的。'
- en: '**The Heap has a large memory size**. While the size of the Stack is limited
    and it is not a good choice for keeping big objects, the Heap allows the storing
    of very big objects even tens of gigabytes in size. As the Heap size grows, the
    allocator needs to request more heap pages from the operating system, and the
    Heap memory blocks are spread among these pages. Note that, unlike the Stack segment,
    the allocating addresses in the Heap memory move forward to bigger addresses.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆具有很大的内存大小**。虽然栈的大小有限，并且不适合存储大对象，但堆允许存储非常大的对象，甚至可以存储数十个GB大小的对象。随着堆大小的增长，分配器需要从操作系统请求更多的堆页面，堆内存块在这些页面之间分散。请注意，与栈段不同，堆内存中的分配地址是向前移动到更大的地址。'
- en: '**Memory allocation and deallocation inside Heap memory are managed by the
    programmer**. This means that the programmer is the sole responsible entity for
    allocating the memory and then freeing it when it is not needed anymore. In many
    recent programming languages, freeing allocated Heap blocks is done automatically
    by a parallel component called *garbage collector*. But in C and C++, we don''t
    have such a concept and freeing the Heap blocks should be done manually. This
    is indeed a risk, and C/C++ programmers should be very careful while using heap
    memory. Failing to free the allocated Heap blocks usually leads to *memory leaks*,
    which can be fatal in most cases.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆内存中的内存分配和释放由程序员管理**。这意味着程序员是唯一负责分配内存并在不再需要时释放它的实体。在许多现代编程语言中，释放分配的堆块是由一个称为垃圾回收器的并行组件自动完成的。但在C和C++中，我们没有这样的概念，释放堆块应该手动完成。这确实是一种风险，C/C++程序员在使用堆内存时应该非常小心。未能释放分配的堆块通常会导致**内存泄漏**，这在大多数情况下都是致命的。'
- en: '**Variables allocated from the Heap do not have any scope**, unlike variables
    in the Stack.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从堆中分配的变量没有作用域**，这与栈中的变量不同。'
- en: This is a risk because it makes memory management much harder. You don't know
    when you need to deallocate the variable, and you have to come up with some new
    definitions for the *scope* and the *owner* of the memory block in order to do
    the memory management effectively. Some of these methods are covered in the upcoming
    sections.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一种风险，因为它使得内存管理变得更加困难。你不知道何时需要释放变量，你必须提出一些新的定义来有效地进行内存管理，包括内存块的**作用域**和**所有者**。一些这些方法将在接下来的章节中介绍。
- en: '**We can only use pointers to address a Heap memory block**. In other words,
    there is no such concept as a Heap variable. The Heap region is addressed via
    pointers.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们只能使用指针来访问堆内存块**。换句话说，没有所谓的堆变量。堆区域是通过指针来访问的。'
- en: '**Since the Heap segment is private to its owner process, we need to use a
    debugger to probe it**. Fortunately, C pointers work with the Heap memory block
    exactly the same as they work with Stack memory blocks. C does this abstraction
    very well, and because of this, we can use the same pointers to address both memories.
    Therefore, we can use the same methods that we used to examine the Stack to probe
    the Heap memory.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**由于堆段对其所有者进程是私有的，我们需要使用调试器来探测它**。幸运的是，C指针与堆内存块的工作方式与与栈内存块的工作方式完全相同。C在这方面做得很好，因此我们可以使用相同的指针来访问这两种内存。因此，我们可以使用检查栈的方法来探测堆内存。'
- en: In the next section, we are going to discuss how to allocate and deallocate
    a heap memory block.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何分配和释放堆内存块。
- en: Heap memory allocation and deallocation
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆内存分配和释放
- en: As we said in the previous section, Heap memory should be obtained and released
    manually. This means that the programmer should use a set of functions or API
    (the C standard library's memory allocation functions) in order to allocate or
    free a memory block in the Heap.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中说的，堆内存应该手动获取和释放。这意味着程序员应该使用一组函数或API（C标准库的内存分配函数）来在堆中分配或释放内存块。
- en: These functions do exist, and they are defined in the header, `stdlib.h`. The
    functions used for obtaining a Heap memory block are `malloc`, `calloc`, and `realloc`,
    and the sole function used for releasing a Heap memory block is `free`. *Example
    5.3* demonstrates how to use some of these functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数确实存在，并且它们在头文件`stdlib.h`中定义。用于获取堆内存块的函数有`malloc`、`calloc`和`realloc`，而用于释放堆内存块的唯一函数是`free`。*示例
    5.3* 展示了如何使用这些函数中的一些。
- en: '**Note**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In some texts, dynamic memory is used to refer to Heap memory. *Dynamic memory
    allocation* is a synonym for Heap memory allocation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些文本中，动态内存被用来指代堆内存。*动态内存分配*是堆内存分配的同义词。
- en: 'The following code box shows the source code of *example 5.3*. It allocates
    two Heap memory blocks, and then it prints its own memory mappings:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了 *示例 5.3* 的源代码。它分配了两个堆内存块，然后打印出其内存映射：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 5-6 [ExtremeC_examples_chapter5_3.c]: Example 5.3 showing the memory
    mappings after allocating two Heap memory blocks'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 5-6 [ExtremeC_examples_chapter5_3.c]: 分配两个堆内存块后的内存映射示例 5.3'
- en: The preceding code is cross-platform, and you can compile it on most Unix-like
    operating systems. But the `print_mem_maps` function only works on Linux since
    the `__linux__` macro is only defined in Linux environments. Therefore, in macOS,
    you can compile the code, but the `print_mem_maps` function won't do anything.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是跨平台的，您可以在大多数类Unix操作系统上编译它。但是，`print_mem_maps`函数仅在Linux上工作，因为`__linux__`宏仅在Linux环境中定义。因此，在macOS上，您可以编译代码，但`print_mem_maps`函数不会做任何事情。
- en: 'The following shell box is the result of running the example in a Linux environment:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell框是Linux环境中运行示例的结果：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 5-17: Output of example 5.3 in Linux'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: shell框 5-17：Linux环境中示例 5.3 的输出
- en: The preceding output has a lot to say. The program prints the addresses of the
    pointers `ptr1` and `ptr2`. If you find the memory mapping of the Stack segment,
    as part of the printed memory mappings, you see that the Stack region starts from
    `0x7ffe0ad57000` and ends at `0x7ffe0ad78000`. The pointers are within this range.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出有很多要说的。程序打印了指针`ptr1`和`ptr2`的地址。如果您在打印的内存映射中找到栈段的内存映射，您会看到栈区域从`0x7ffe0ad57000`开始，到`0x7ffe0ad78000`结束。指针位于这个范围内。
- en: This means that the pointers are allocated from the Stack, but they are pointing
    to a memory region outside of the Stack segment, in this case, the Heap segment.
    It is very common to use a Stack pointer to address a Heap memory block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着指针是从栈中分配的，但它们指向栈段之外的一个内存区域，在这种情况下，是堆段。使用栈指针来访问堆内存块是非常常见的。
- en: Keep in mind that the `ptr1` and `ptr2` pointers have the same scope and they
    will be freed when the `main` function returns, but there is no scope to the Heap
    memory blocks obtained from the Heap segment. They will remain allocated until
    the program frees them manually. You can see that before returning from the `main`
    function, both memory blocks are freed using the pointers pointing to them and
    using the `free` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`ptr1`和`ptr2`指针具有相同的范围，它们将在`main`函数返回时被释放，但堆内存块没有范围。它们将保留分配状态，直到程序手动释放它们。您可以看到，在从`main`函数返回之前，使用指向它们的指针和`free`函数释放了两个内存块。
- en: As a further note regarding the above example, we can see that the addresses
    returned by the `malloc` and `calloc` functions are located inside the Heap segment.
    This can be investigated by comparing the returned addresses and the memory mapping
    described as `[heap]`. The region marked as heap starts from `0x564c03977000`
    and ends at `0x564c03998000`. The `ptr1` pointer points to the address `0x564c03977260`
    and the `ptr2 p`ointer points to the address `0x564c03977690`, which are both
    inside the heap region.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述示例的进一步说明，我们可以看到`malloc`和`calloc`函数返回的地址位于堆段内部。这可以通过比较返回的地址和描述为`[heap]`的内存映射来调查。标记为堆的区域从`0x564c03977000`开始，到`0x564c03998000`结束。`ptr1`指针指向地址`0x564c03977260`，而`ptr2`指针指向地址`0x564c03977690`，它们都在堆区域内部。
- en: Regarding the Heap allocation function, as their names imply, `calloc` stands
    for **clear and allocate** and `malloc` stands for **memory allocate**. So, this
    means that `calloc` clears the memory block after allocation, but `malloc` leaves
    it uninitialized until the program does it itself if necessary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于堆分配函数，正如它们的名称所暗示的，`calloc`代表**清除并分配**，而`malloc`代表**内存分配**。这意味着`calloc`在分配后清除内存块，而`malloc`则将其保留为未初始化状态，直到程序在必要时自行初始化。
- en: '**Note**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In C++, the `new` and `delete` keywords do the same as `malloc` and `free` respectively.
    Additionally, new operator infers the size of the allocated memory block from
    the operand type and also converts the returned pointer to the operand type automatically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`new`和`delete`关键字分别与`malloc`和`free`相同。此外，新操作符从操作数类型推断分配的内存块的大小，并自动将返回的指针转换为操作数类型。
- en: 'But if you look at the bytes in the two allocated blocks, both of them have
    zero bytes. So, it seems that `malloc` has also initialized the memory block after
    the allocation. But based on the description of `malloc` in the C Specification,
    `malloc` doesn''t initialize the allocated memory block. So, why is that? To move
    this further, let''s run the example in a macOS environment:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你查看两个分配的块中的字节，它们都有零字节。所以，看起来`malloc`在分配后也初始化了内存块。但根据C规范中`malloc`的描述，`malloc`不会初始化分配的内存块。那么，这是为什么？为了进一步探讨，让我们在macOS环境中运行示例：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Shell Box 5-18: Output of example 5.3 on macOS'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框5-18：在macOS上示例5.3的输出
- en: If you look carefully, you can see that the memory block allocated by `malloc`
    has some non-zero bytes, but the memory block allocated by `calloc` is all zeros.
    So, what should we do? Should we assume that the memory block allocated by `malloc`
    in Linux is always zeros?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你可以看到`malloc`分配的内存块中有一些非零字节，但`calloc`分配的内存块全部为零。那么，我们应该怎么做？我们应该假设Linux中`malloc`分配的内存块总是零吗？
- en: If you are going to write a cross-platform program, always be aligned with the
    C specification. The specification says `malloc` does not initialize the allocated
    memory block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算编写一个跨平台程序，始终要与C规范保持一致。规范说明`malloc`不会初始化分配的内存块。
- en: Even when you are writing your program only for Linux and not for other operating
    systems, be aware that future compilers may behave differently. Therefore, according
    to the C specification, we must always assume that the memory block allocated
    by the `malloc` is not initialized and it should be initialized manually if necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只为Linux编写程序，而不是为其他操作系统编写，也要注意未来的编译器可能会有不同的行为。因此，根据C规范，我们必须始终假设由`malloc`分配的内存块未初始化，如果需要，应手动初始化。
- en: Note that since `malloc` doesn't initialize the allocated memory, it is usually
    faster than `calloc`. In some implementations, `malloc` doesn't actually allocate
    the memory block and defer the allocation until when the memory block is accessed
    (either read or write). This way, memory allocations happen faster.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`malloc`不会初始化分配的内存，它通常比`calloc`更快。在某些实现中，`malloc`实际上不会分配内存块，而是在内存块被访问（无论是读取还是写入）时才延迟分配。这样，内存分配会更快。
- en: 'If you are going to initialize the memory after `malloc`, you can use the `memset`
    function. Here is an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在`malloc`之后初始化内存，可以使用`memset`函数。以下是一个示例：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 5-7: Using the memset function to initialize a memory block'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框5-7：使用`memset`函数初始化内存块
- en: 'The `realloc` function is another function that is introduced as part of the
    Heap allocation functions. It was not used as part of *example 5.3*. It actually
    reallocates the memory by resizing an already allocated memory block. Here is
    an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`函数是作为堆分配函数的一部分引入的另一个函数。它没有在*example 5.3*中使用。实际上，它通过调整已分配内存块的大小来重新分配内存。以下是一个例子：'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 5-8: Using the realloc function to change the size of an already allocated
    block'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框5-8：使用realloc函数改变已分配块的尺寸
- en: The `realloc` function does not change the data in the old block and only expands
    an already allocated block to a new one. If it cannot expand the currently allocated
    block because of *fragmentation*, it will find another block that's large enough
    and copy the data from the old block to the new one. In this case, it will also
    free the old block. As you can see, reallocation is not a cheap operation in some
    cases because it involves many steps, hence it should be used with care.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`函数不会更改旧块中的数据，而只是将已分配的块扩展到新块。如果由于*碎片化*无法扩展当前分配的块，它将找到另一个足够大的块，并将旧块中的数据复制到新块中。在这种情况下，它也会释放旧块。正如你所看到的，在某些情况下，重新分配并不是一个便宜的操作，因为它涉及许多步骤，因此应该谨慎使用。'
- en: The last note about *example 5.3* is on the `free` function. In fact, it deallocates
    an already allocated Heap memory block by passing the block's address as a pointer.
    As it is said before, any allocated Heap block should be freed when it is not
    needed. Failing to do so leads to *memory leakage*. Using a new example, *example
    5.4*, we are going to show you how to detect memory leaks using the `valgrind` tool.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*example 5.3*的最后一点是关于`free`函数的。实际上，它通过传递块地址作为指针来释放已经分配的堆内存块。正如之前所说，任何已分配的堆块在不再需要时都应该被释放。未能这样做会导致*内存泄漏*。使用一个新的例子，*example
    5.4*，我们将向您展示如何使用`valgrind`工具检测内存泄漏。
- en: 'Let''s first produce some memory leaks as part of *example 5.4*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在*example 5.4*中产生一些内存泄漏：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 5-9: Producing a memory leak by not freeing the allocated block when
    returning from the main function'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框5-9：在从main函数返回时未释放分配的块产生内存泄漏
- en: The preceding program has a memory leak because when the program ends, we have
    `16` bytes of Heap memory allocated and not freed. This example is very simple,
    but when the source code grows and more components are involved, it would be too
    hard or even impossible to detect it by sight.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序存在内存泄漏，因为当程序结束时，我们分配了`16`字节堆内存但没有释放。这个例子非常简单，但当源代码增长并且涉及更多组件时，通过肉眼检测它就会变得非常困难，甚至不可能。
- en: Memory profilers are useful programs that can detect the memory issues in a running
    process. The famous `valgrind` tool is one of the most well knowns.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器是有用的程序，可以检测运行中的进程中的内存问题。著名的`valgrind`工具是最为人所知的之一。
- en: In order to use `valgrind` to analyze *example 5.4*, first we need to build
    the example with the debug option, `-g`. Then, we should run it using `valgrind`.
    While running the given executable object file, `valgrind` records all of the
    memory allocations and deallocations. Finally, when the execution is finished
    or a crash happens, `valgrind` prints out the summary of allocations and deallocations
    and the amount of memory that has not been freed. This way, it can let you know
    how much memory leak has been produced as part of the execution of the given program.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`valgrind`分析*example 5.4*，首先我们需要使用调试选项`-g`构建示例。然后，我们应该使用`valgrind`运行它。在运行给定的可执行目标文件时，`valgrind`记录所有的内存分配和释放。最后，当执行完成或发生崩溃时，`valgrind`会打印出分配和释放的摘要以及未释放的内存量。这样，它可以让你知道在给定程序的执行过程中产生了多少内存泄漏。
- en: 'The following shell box demonstrates how to compile and use `valgrind` for
    *example 5.4*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的shell box演示了如何编译和使用`valgrind`来分析*example 5.4*：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 5-19: Output of valgrind showing the 16-byte memory leak as part
    of the execution of example 5.4'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-19：valgrind输出的输出，显示了作为example 5.4执行一部分的16字节内存泄漏
- en: If you look into the `HEAP SUMMARY` section in *Shell Box 5-19*, you can see
    that we had `1` allocation and `0` frees, and `16` bytes remained allocated while
    exiting. If you come down a bit to the `LEAK SUMMARY` section, it states that
    `16` bytes are definitely lost, and this means a memory leak!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看*Shell Box 5-19*中的`HEAP SUMMARY`部分，你可以看到我们进行了`1`次分配和`0`次释放，并且在退出时还保留了`16`字节的分配。如果你向下滚动一点到`LEAK
    SUMMARY`部分，它指出`16`字节肯定丢失了，这意味着存在内存泄漏！
- en: 'If you want to know exactly at which line the mentioned leaking memory block
    has been allocated, you can use `valgrind` with a special option designed for
    this. In the following shell box, you will see how to use `valgrind` to find the
    lines responsible for the actual allocation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确切知道提到的泄漏内存块是在哪一行分配的，您可以使用专门为此设计的`valgrind`特殊选项。在下面的shell框中，您将看到如何使用`valgrind`找到实际分配的责任行：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Shell Box 5-20: Output of valgrind showing the line that is responsible for
    the actual allocation'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-20：valgrind输出的实际分配责任行的输出
- en: As you can see, we have passed the `--leak-check=full` option to `valgrind`,
    and now it shows the line of code that is responsible for the leaking Heap memory.
    It clearly shows that line 4 in *Code Box 5-9*, which is a `malloc` call, is where
    the leaking Heap block has been allocated. This can help you to trace it further
    and find the right place that the mentioned leaking block should be freed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将`--leak-check=full`选项传递给了`valgrind`，现在它显示了负责泄漏堆内存的代码行。它清楚地显示了*代码框5-9*中的第4行，这是一个`malloc`调用，泄漏的堆块就是在这里分配的。这可以帮助您进一步追踪并找到应该释放提到的泄漏块的正确位置。
- en: 'OK, let''s change the preceding example so that it frees the allocated memory.
    We just need to add the `free(ptr)` instruction before the `return` statement,
    as we can see here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们修改前面的示例，使其释放分配的内存。我们只需要在`return`语句之前添加`free(ptr)`指令，就像我们在这里看到的那样：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 5-10: Freeing up the allocated memory block as part of example 5.4'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框5-10：作为示例5.4的一部分释放分配的内存块
- en: 'Now with this change, the only allocated Heap block is freed. Let''s build
    and run `valgrind` again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在经过这个修改，唯一的分配堆块已经被释放。让我们再次构建并运行`valgrind`：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Shell Box 5-20: Output of valgrind after freeing the allocated memory block'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 5-20：释放分配的内存块后的valgrind输出
- en: As you can see, `valgrind` says that `All Heap blocks were freed`, and this
    effectively means that we have no further memory leakage in our program. Running
    programs with `valgrind` can slow them down noticeably by a factor of 10 to 50,
    but it can help you to spot the memory issues very easily. It's a good practice
    to let your written programs run inside a memory profiler and catch memory leaks
    as soon as possible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`valgrind`表示“所有堆块都已释放”，这实际上意味着我们的程序中没有进一步的内存泄漏。使用`valgrind`运行程序可能会将它们的速度降低10到50倍，但它可以帮助您非常容易地发现内存问题。让您的程序在内存分析器中运行并尽快捕获内存泄漏是一个好习惯。
- en: Memory leaks can be considered both as *technical debts*, if you have a bad
    design that causes the leaks, or as *risks*, where it's known that we have a leak,
    but we don't know what will happen if the leak continues to grow. But in my opinion,
    they should be treated as *bugs*; otherwise, it will take a while for you to look
    back at them. Usually, in teams, memory leaks are treated as bugs that should
    be fixed as soon as possible.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏可以被视为*技术债务*，如果您有一个导致泄漏的糟糕设计，或者作为*风险*，我们知道我们有一个泄漏，但我们不知道如果泄漏继续增长会发生什么。但在我看来，它们应该被视为*错误*；否则，您需要一段时间才能回顾它们。通常，在团队中，内存泄漏被视为应该尽快修复的错误。
- en: 'There are other memory profilers other than `valgrind`. **LLVM Address Sanitizer**
    (or **ASAN**) and **MemProf** are also other well-known memory profilers. Memory
    profilers can profile memory usage and allocations using various methods. Next,
    we discuss some of them:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`valgrind`之外，还有其他内存分析器。**LLVM Address Sanitizer**（或**ASAN**）和**MemProf**也是其他知名的内存分析器。内存分析器可以使用各种方法来分析内存使用和分配。接下来，我们将讨论其中的一些：
- en: Some profilers can behave like a sandbox, running the target program inside
    and monitoring all their memory activities. We've used this method to run *example
    5.4* inside a `valgrind` sandbox. This method does not require you to recompile
    your code.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些分析器可以像沙盒一样运行，在沙盒内运行目标程序并监控所有内存活动。我们已经使用这种方法在`valgrind`沙盒中运行了*示例5.4*。这种方法不需要您重新编译代码。
- en: Another method is to use the libraries provided by some memory profilers, which
    wrap memory-related system calls. This way, the final binary will contain all
    of the logic required for the profiling task.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是使用一些内存分析器提供的库，这些库包装了内存相关的系统调用。这样，最终的二进制文件将包含用于分析任务的全部逻辑。
- en: '`valgrind` and ASAN can be linked to the final executable object file as a
    memory profiler library. This method requires the recompilation of your target
    source code and even making some modifications to your source code as well.'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`valgrind`和ASAN可以作为内存分析库链接到最终的可执行对象文件。这种方法需要重新编译你的目标源代码，甚至需要对源代码进行一些修改。'
- en: Programs can also *preload* different libraries instead of the default C standard
    libraries, which contain memory *function interpositions* of the C library's standard
    memory allocation functions. This way, you are not required to compile your target
    source code. You just need to specify the libraries of such profilers in the `LD_PRELOAD`
    environment variable to be preloaded instead of the default `libc` libraries.
    `MemProf` uses this method.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序也可以*预加载*不同的库，而不是默认的C标准库，这些库包含C库标准内存分配函数的*函数替换*。这样，你不需要编译你的目标源代码。你只需要在`LD_PRELOAD`环境变量中指定这样的分析库，以便预加载，而不是默认的`libc`库。`MemProf`使用这种方法。
- en: '**Note**:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: A *function interposition* is a wrapper function defined in a dynamic library
    loaded before the target dynamic library, which propagates calls to the target
    function. Dynamic libraries can be preloaded using the `LD_PRELOAD` environment
    variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数替换*是在目标动态库之前加载的动态库中定义的包装函数，它将调用传播到目标函数。可以使用`LD_PRELOAD`环境变量预加载动态库。'
- en: Heap memory principles
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆内存原则
- en: As pointed out before, Heap memory is different from Stack memory in several
    ways. Therefore, heap memory has its own guidelines regarding memory management.
    In this section, we are going to focus on these differences and come up with some
    dos and don'ts that we should consider when working with the Heap space.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，堆内存与栈内存有几个不同之处。因此，堆内存有自己的内存管理指南。在本节中，我们将关注这些差异，并提出一些我们在处理堆空间时应考虑的“应该做”和“不应该做”的事项。
- en: Every memory block (or a variable) in the Stack has a scope. So, it is an easy
    task to define the lifetime of a memory block based on its scope. Whenever we
    are out of scope, all of the variables in that scope are gone. But this is different
    and much more complex with Heap memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的每个内存块（或变量）都有一个作用域。因此，根据其作用域定义内存块的生存期是一个简单的任务。每次我们超出作用域时，该作用域中的所有变量都会消失。但是这与堆内存不同，并且更加复杂。
- en: A Heap memory block doesn't have any scope, so its lifetime is unclear and should
    be redefined. This is the reason behind having manual deallocation or *generational*
    *garbage collection* in modern languages such as Java. The Heap lifetime cannot
    be determined by the program itself or the C libraries used, and the programmer
    is the sole person who defines the lifetime of a Heap memory block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存块没有作用域，因此其生存期不明确，应该重新定义。这就是为什么在像Java这样的现代语言中，有手动释放或*代际* *垃圾回收*的原因。堆的生存期不能由程序本身或使用的C库来确定，程序员是唯一定义堆内存块生存期的人。
- en: When the discussion comes to the programmer's decision, especially in this case,
    it is complicated and hard to propose a universal silver bullet solution. Every
    opinion is debatable and can lead to a trade-off.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论到程序员的决策时，尤其是在这种情况下，情况变得复杂，很难提出一个通用的银弹解决方案。每个观点都是可辩论的，并且可能导致权衡。
- en: One of the best proposed strategies to overcome the complexity of the Heap lifetime,
    which of course is not a complete solution, is to define an *owner* for a memory
    block instead of having a scope that encompasses the memory block.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决堆生存期复杂性的最佳策略之一，当然这不是一个完整的解决方案，是为内存块定义一个*所有者*，而不是让作用域包含内存块。
- en: The owner is the sole entity responsible for managing the lifetime of a Heap
    memory block and is the one who allocates the block in the first place and frees
    it when the block is not needed anymore.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者是唯一负责管理堆内存块生存期的实体，也是最初分配该块并在不再需要时释放它的人。
- en: 'There are many classic examples of how to use this strategy. Most of the well-known
    C libraries use this strategy to handle their Heap memory allocations. *Example
    5.5* is a very simple implementation of this method that is used to manage the
    lifetime of a queue object written in C. The following code box tries to demonstrate
    the *ownership* strategy:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多经典的例子展示了如何使用这种策略。大多数知名的C库都使用这种策略来处理它们的堆内存分配。*示例5.5* 是这种方法的一个非常简单的实现，用于管理用C编写的队列对象的生存期。下面的代码框试图展示*所有权*策略：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Code Box 5-11 [ExtremeC_examples_chapter5_5.c]: The example 5.5 demonstrating
    the ownership strategy for Heap lifetime management'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 5-11 [ExtremeC_examples_chapter5_5.c]：演示堆生命周期管理所有权策略的例子 5.5
- en: The preceding example contains two different ownerships each of which owning
    a specific object. The first ownership is about the Heap memory block addressed
    by the `arr` pointer in the `queue_t` structure that is owned by the queue object.
    As long as the queue object exists, this memory block must remain in place and
    allocated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子包含两种不同的所有权，每种所有权都拥有一个特定的对象。第一种所有权是关于由`queue_t`结构中的`arr`指针指向的堆内存块，该内存块由队列对象拥有。只要队列对象存在，这个内存块就必须保持在原地并分配。
- en: The second ownership is regarding the Heap memory block acquired by the `main`
    function as a placeholder for the queue object, `q`, that is owned by the `main`
    function itself. It is very important to distinguish between the Heap memory blocks
    owned by the queue object and the Heap memory blocks owned by the `main` function
    because releasing one of them doesn't release another.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种所有权是关于由`main`函数获取的堆内存块，作为队列对象`q`的占位符，该对象由`main`函数本身拥有。区分队列对象拥有的堆内存块和`main`函数拥有的堆内存块非常重要，因为释放其中一个并不会释放另一个。
- en: To demonstrate how a memory leak can happen in the preceding code, suppose that
    you forget to call the `destroy` function on the queue object. It will definitely
    lead to a memory leak because the Heap memory block acquired inside the `init`
    function would be still allocated and not freed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在前面代码中内存泄漏是如何发生的，假设你忘记在队列对象上调用`destroy`函数。这肯定会引起内存泄漏，因为`init`函数内部获取的堆内存块仍然会被分配，而不会被释放。
- en: Note that if an entity (an object, function, and so on) owns a Heap memory block,
    it should be expressed in the comments. Nothing should free a Heap memory block
    if it does not own the block.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果一个实体（一个对象、函数等）拥有一个堆内存块，应该在注释中表达出来。如果没有拥有该内存块，则不应该有任何东西释放堆内存块。
- en: Note that multiple deallocations of the same Heap memory block will lead to
    a *double free* situation. A double-free situation is a memory corruption issue
    and like any other memory corruption issue, it should be dealt with and resolved
    soon after detection. Otherwise, it can have serious consequences like sudden
    crashes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对同一堆内存块进行多次释放会导致*双重释放*的情况。双重释放是一个内存损坏问题，就像任何其他内存损坏问题一样，应该在检测到后尽快处理和解决。否则，它可能会产生严重的后果，如突然崩溃。
- en: Other than the ownership strategy, one could use a garbage collector. The garbage
    collector is an automatic mechanism that is embedded in a program and tries to
    collect memory blocks that have no pointer addressing them. One of the old well-known
    garbage collectors for C is the *Boehm-Demers-Weiser Conservative Garbage Collector*,
    which provides a set of memory allocation functions that should be called instead
    of `malloc` and other standard C memory allocation functions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有权策略之外，还可以使用垃圾回收器。垃圾回收器是一种嵌入到程序中的自动机制，它试图收集没有任何指针指向它们的内存块。C语言中一个老牌且广为人知的垃圾回收器是*Boehm-Demers-Weiser保守垃圾回收器*，它提供了一组内存分配函数，应该代替`malloc`和其他标准C内存分配函数来调用。
- en: '**Further Reading**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**：'
- en: 'More informatio[n about the Boehm-Demers-Weise](http://www.hboehm.info/gc/)r
    garbage collector can be found here: [http://www.hboehm.info/gc/](http://www.hboehm.info/gc/).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Boehm-Demers-Weiser垃圾回收器的信息可以在这里找到：[http://www.hboehm.info/gc/](http://www.hboehm.info/gc/)。
- en: Another technique to manage the lifetime of a Heap block is using a RAII object.
    **RAII** stands for **Resource Acquisition Is Initialization**. It means that
    we can bind the lifetime of a resource, possibly a Heap allocated memory block,
    to the lifetime of an object. In other words, we use an object that upon its construction
    initializes the resource, and upon its destruction frees the resource. Unfortunately,
    this technique cannot be used in C because we are not notified about the destruction
    of an object. But in C++, using destructors, this technique can be used effectively.
    In RAII objects, resource initialization happens in the constructor and the code
    required to de-initialize the resource is put into the destructor. Note that in
    C++, the destructor is invoked automatically when an object is going out of scope
    or being deleted.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 管理堆块生命周期的另一种技术是使用RAII对象。**RAII**代表**资源获取即初始化**。这意味着我们可以将资源的生命周期（可能是一个堆分配的内存块）绑定到对象的生命周期。换句话说，我们使用一个对象，在它的构造时初始化资源，在它的销毁时释放资源。不幸的是，这种技术在C语言中不能使用，因为我们没有得到关于对象销毁的通知。但在C++中，使用析构函数，这种技术可以有效地使用。在RAII对象中，资源初始化发生在构造函数中，而用于反初始化资源的代码被放入析构函数中。请注意，在C++中，当对象超出作用域或被删除时，析构函数会自动调用。
- en: 'As a conclusion, the following guidelines are important when working with Heap
    memory:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结论，当与堆内存一起工作时，以下指南非常重要：
- en: Heap memory allocation is not free, and it has its own costs. Not all memory
    allocation functions have the same cost and, usually, `malloc` is the cheapest
    one.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存分配不是免费的，它有自己的成本。并非所有内存分配函数的成本相同，通常`malloc`是最便宜的。
- en: All memory blocks allocated from the Heap space must be freed either immediately
    when they are not needed anymore or just before ending the program.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从堆空间分配的所有内存块都必须在不再需要时立即释放，或者在程序结束前释放。
- en: Since Heap memory blocks have no scope, the program must be able to manage the
    memory in order to avoid any possible leakage.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于堆内存块没有作用域，程序必须能够管理内存，以避免任何可能的泄漏。
- en: Sticking to a chosen memory management strategy for each Heap memory block seems
    to be necessary.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个堆内存块坚持使用所选的内存管理策略似乎是必要的。
- en: The chosen strategy and its assumptions should be documented throughout the
    code wherever the block is accessed so that future programmers will know about
    it.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所选策略及其假设应该在代码中记录下来，无论在何处访问该块，以便未来的程序员了解它。
- en: In certain programming languages like C++, we can use RAII objects to manage
    a resource, possibly a Heap memory block.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在像C++这样的某些编程语言中，我们可以使用RAII对象来管理资源，可能是一个堆内存块。
- en: So far, we have considered that we have enough memory to store big objects and
    run any kind of program. But in the following section, we are going to put some
    constraints on the available memory and discuss the environments where the memory
    is low, or it is costly (in terms of money, time, performance, and so on) to add
    further memory storage. In such cases, we need to use the available memory in
    the most efficient way.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设我们有足够的内存来存储大对象并运行任何类型的程序。但在下一节中，我们将对可用的内存施加一些限制，并讨论内存低或增加额外内存存储（在金钱、时间、性能等方面）成本高的环境。在这种情况下，我们需要以最有效的方式使用可用的内存。
- en: Memory management in constrained environments
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限环境中的内存管理
- en: There are environments in which memory is a precious resource, and it is often
    limited. There are also other environments in which performance is a key factor
    and programs should be fast, no matter how much memory we have. Regarding memory
    management, each of these environments requires a specific technique to overcome
    the memory shortage and performance degradation. First, we need to know what a
    constrained environment is.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，内存是一种宝贵的资源，而且通常有限。也有其他环境，其中性能是一个关键因素，程序应该快速运行，不管我们有多少内存。关于内存管理，每个这样的环境都需要特定的技术来克服内存短缺和性能下降。首先，我们需要知道什么是受限环境。
- en: A constrained environment does not necessarily have a low memory capacity. There
    are usually some *constraints* that limit the memory usage for a program. These
    constraints can be your customer's hard limits regarding memory usage, or it could
    be because of a hardware that provides the low memory capacity, or it can be because
    of an operating system that does not support a bigger memory (for example, MS-DOS).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 限制性环境不一定具有低内存容量。通常有一些*限制*会限制程序的内存使用。这些限制可以是客户对内存使用的硬性限制，也可能是由于提供低内存容量的硬件，或者可能是由于不支持更大内存的操作系统（例如，MS-DOS）。
- en: Even if there are no constraints or hardware limitations, we as programmers
    try our best to use the least possible amount of memory and use it in an optimal
    way. Memory consumption is one of the key *non-functional requirements* in a project
    and should be monitored and tuned carefully.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有限制或硬件限制，我们作为程序员也会尽力使用尽可能少的内存，并以最优的方式使用它。内存消耗是一个项目中关键的*非功能性需求*之一，应该被仔细监控和调整。
- en: In this section, we'll first introduce the techniques used in low memory environments
    for overcoming the shortage issue, and then we will talk about the memory techniques
    usually used in performant environments in order to boost the performance of the
    running programs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先介绍在低内存环境中用于克服短缺问题的技术，然后我们将讨论在性能环境中通常使用的内存技术，以提升运行程序的性能。
- en: Memory-constrained environments
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存受限环境
- en: In these environments, limited memory is always a constraint, and algorithms
    should be designed in a way in order to cope with memory shortages. Embedded systems
    with a memory size of tens to hundreds of megabytes are usually in this category.
    There are a few tips about memory management in such environments, but none of
    them work as well as having a nicely tuned algorithm. In this case, algorithms
    with a low memory complexity are usually used. These algorithms usually have a
    higher *time complexity*, which should be traded off with their low memory usage.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些环境中，有限的内存总是个约束，算法应该设计成能够应对内存短缺。具有数十到数百兆字节内存大小的嵌入式系统通常属于这一类。关于这种环境下的内存管理有一些小贴士，但它们都不如有一个调校得很好的算法来得有效。在这种情况下，通常使用内存复杂度低的算法。这些算法通常具有更高的*时间复杂度*，需要与它们的低内存使用进行权衡。
- en: To elaborate more on this, every algorithm has specific *time* and *memory*
    complexities. Time complexity describes the relationship between the input size
    and the time that the algorithm takes to complete. Similarly, memory complexity
    describes the relationship between the input size and the memory that the algorithm
    consumes to complete its task. These complexities are usually denoted as *Big-O
    functions*, which we don't want to deal with in this section. Our discussion is
    qualitative, so we don't need any math to talk about memory-constrained environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明这一点，每个算法都有特定的*时间*和*内存*复杂度。时间复杂度描述了输入大小与算法完成所需时间之间的关系。同样，内存复杂度描述了输入大小与算法完成任务所消耗的内存之间的关系。这些复杂度通常用*大O函数*表示，我们不想在本节中处理这些。我们的讨论是定性的，因此我们不需要任何数学来讨论内存受限环境。
- en: An algorithm should ideally have a low time complexity and also a low memory
    complexity. In other words, having a fast algorithm consuming a low amount of
    memory is highly desirable, but it is unusual to have this "best of both worlds"
    situation. It is also unexpected to have an algorithm with high memory consumption
    while not performing well
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法理想情况下应该具有低时间复杂度和低内存复杂度。换句话说，拥有一个快速且内存消耗低的算法是非常理想的，但这种“两者兼得”的情况很少见。同时，一个内存消耗高但性能不佳的算法也是令人意外的。
- en: Most of the time, we have a trade-off between memory and speed, which represents
    time. As an example, a sorting algorithm that is faster than another algorithm
    usually consumes more memory than the other, despite the fact that both of them
    do the same job.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们在内存和速度之间进行权衡，这代表了时间。例如，一个比另一个算法更快的排序算法通常会消耗比另一个更多的内存，尽管这两个算法都完成了相同的工作。
- en: It is a good but conservative practice, especially when writing a program, to
    assume that we are writing code for a memory-constrained system, even if we know
    that we will have more than enough memory in the final production environment.
    We make this assumption because we want to mitigate the risk of having too much
    memory consumption.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，即使我们知道最终的生产环境将有足够的内存，假设我们正在为内存受限的系统编写代码，这是一种很好的但保守的做法。我们做出这个假设是因为我们希望减轻过度消耗内存的风险。
- en: Note that the driving force behind this assumption should be controlled and
    adjusted based on a fairly accurate guess about the average memory availability,
    in terms of size, as part of the final setup. Algorithms designed for memory-constrained
    environments are intrinsically slower, and you should be careful about this trap.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，推动这个假设的动力应根据对最终设置中平均内存可用性的相当准确的估计进行控制和调整，包括大小。为内存受限环境设计的算法本质上较慢，您应该小心这个陷阱。
- en: In the upcoming sections, we will cover some techniques that can help us to
    collect some wasted memory or to use less memory in memory-constrained environments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些可以帮助我们收集一些浪费的内存或在使用内存受限环境中使用更少内存的技术。
- en: Packed structures
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩结构
- en: One of the easiest ways to use less memory is to use packed structures. Packed
    structures discard the memory alignment and they have a more compact memory layout
    for storing their fields.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩结构是减少内存消耗的最简单方法之一。压缩结构放弃了内存对齐，并且它们有更紧凑的内存布局来存储它们的字段。
- en: Using packed structures is actually a trade-off. You consume less memory because
    you discard memory alignments and eventually end up with more memory read time
    while loading a structure variable. This will result in a slower program.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩结构实际上是一种权衡。你消耗更少的内存，因为你放弃了内存对齐，最终在加载结构变量时会有更多的内存读取时间。这将导致程序运行速度变慢。
- en: This method is simple but not recommended for all programs. For more information
    regarding this method, you can read the *Structures* section found in *Chapter
    1*, *Essential Features*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单，但不适用于所有程序。有关此方法的更多信息，您可以阅读*第一章*，*基本特性*中找到的*结构*部分。
- en: Compression
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩
- en: This is an effective technique, especially for programs working with a lot of
    textual data that should be kept inside the memory. Textual data has a high *compression
    ratio* in comparison to binary data. This technique allows a program to store
    the compressed form instead of the actual text data with a huge memory return.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种有效的技术，尤其是对于需要在内存中保留的大量文本数据的程序。与二进制数据相比，文本数据具有很高的*压缩比*。这种技术允许程序存储压缩形式而不是实际的文本数据，从而获得巨大的内存回报。
- en: However, saving memory is not free; since compression algorithms are *CPU-bound*
    and computation-intensive, the program would have worse performance in the end.
    This method is ideal for programs that keep textual data that is not required
    often; otherwise, a lot of compression/decompression operations are needed, and
    the program would be almost unusable eventually.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，节省内存并非没有代价；由于压缩算法是*CPU密集型*的，程序最终的性能会变差。这种方法对于需要保存不常使用的文本数据的程序来说很理想；否则，需要大量的压缩/解压缩操作，程序最终几乎无法使用。
- en: External data storage
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部数据存储
- en: Using external data storage in the forms of a network service, a cloud infrastructure,
    or simply a hard drive is a very common and useful technique for resolving low
    memory issues. Since it is usually considered that a program might be run in a
    limited or low memory environment, there are a lot of examples that use this method
    to be able to consume less memory even in environments in which enough memory
    is available.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络服务、云基础设施或简单的硬盘作为外部数据存储形式，是一种非常常见且有用的技术，用于解决内存不足的问题。由于通常认为程序可能在有限的或内存较低的环境中运行，因此有很多示例使用这种方法，即使在有足够内存的环境中也能消耗更少的内存。
- en: This technique usually assumes that memory is not the main storage, but it acts
    as *cache* memory. Another assumption is that we cannot keep the whole data in
    the memory and at any moment, only a portion of data or a *page* of data can be
    loaded into the memory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常假设内存不是主要存储，而是作为*缓存*内存。另一个假设是我们不能将所有数据都保存在内存中，在任何时刻，只能将部分数据或一个*页面*的数据加载到内存中。
- en: 'These algorithms are not directly addressing the low memory problem, but they
    are trying to solve another issue: slow external data storage. External data storage
    is always too slow in comparison to the main memory. So, the algorithms should
    balance the reads from the external data store and their internal memory. All
    database services, such as PostgreSQL and Oracle, use this technique.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法并不是直接解决低内存问题，而是在尝试解决另一个问题：慢速的外部数据存储。与主内存相比，外部数据存储总是太慢。因此，算法应该平衡从外部数据存储的读取和它们的内部内存。所有数据库服务，如PostgreSQL和Oracle，都使用这种技术。
- en: In most projects, it is not very wise to design and write these algorithms from
    scratch because these algorithms are not that trivial and simple to write. The
    teams behind famous libraries such as SQLite have been fixing bugs for years.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数项目中，从头开始设计和编写这些算法并不是一个非常明智的选择，因为这些算法并不那么简单和容易编写。SQLite等著名库背后的团队已经修复了多年的错误。
- en: If you need to access an external data storage such as a file, a database, or
    a host on the network while having a low memory footprint, there are always options
    out there for you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在具有低内存占用的情况下访问外部数据存储，如文件、数据库或网络上的主机，总有适合你的选择。
- en: Performant environments
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能环境
- en: As we have explained in the previous sections about the time and memory complexities
    of an algorithm, it is usually expected to consume more memory when you want to
    have a faster algorithm. In this section, we therefore expect to consume more
    memory for the sake of increased performance.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前几节关于算法的时间和内存复杂度的解释中所述，通常期望在想要获得更快的算法时消耗更多的内存。因此，在本节中，我们期望为了提高性能而消耗更多的内存。
- en: An intuitive example of this statement can be using a cache in order to increase
    the performance. Caching data means consuming more memory, but we could expect
    to get better performance if the cache is used properly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陈述的一个直观例子是使用缓存来提高性能。缓存数据意味着消耗更多的内存，但如果缓存使用得当，我们预计可以获得更好的性能。
- en: But adding extra memory is not always the best way to increase performance.
    There are other methods that are directly or indirectly related to memory and
    can have a substantial impact on the performance of an algorithm. Before jumping
    to these methods, let's talk about caching first.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但增加额外的内存并不总是提高性能的最佳方式。还有其他直接或间接与内存相关的方法，可以对算法的性能产生重大影响。在跳到这些方法之前，让我们先谈谈缓存。
- en: Caching
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching is a general term for all similar techniques utilized in many parts
    of a computer system when two data storages with different read/write speeds are
    involved. For example, the CPU has a number of internal registers that perform
    quickly in terms of reading and writing operations. In addition, the CPU has to
    fetch data from the main memory, which is many times slower than its registers.
    A caching mechanism is needed here; otherwise, the lower speed of the main memory
    becomes dominant, and it hides the high computational speed of the CPU.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是计算机系统中涉及不同读写速度的两个数据存储时使用的所有类似技术的通用术语。例如，CPU有几个内部寄存器，在读写操作方面速度很快。此外，CPU还需要从主内存中获取数据，其速度比寄存器慢得多。这里需要一个缓存机制；否则，主内存的较低速度将占主导地位，并掩盖CPU的高计算速度。
- en: Working with database files is another example. Database files are usually stored
    on an external hard disk, which is far slower than the main memory, by orders
    of magnitude. Definitely, a caching mechanism is required here; otherwise, the
    slowest speed becomes dominant, and it determines the speed of the whole system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库文件一起工作是另一个例子。数据库文件通常存储在外部硬盘上，其速度比主内存慢得多。毫无疑问，这里需要一个缓存机制；否则，最慢的速度将占主导地位，并决定整个系统的速度。
- en: Caching and the details around it deserve to have a whole dedicated chapter
    since there are abstract models and specific terminology that should be explained.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存及其相关细节值得有一个专门的章节，因为这里有一些抽象模型和特定的术语需要解释。
- en: Using these models, one can predict how well a cache would behave and how much
    *performance gain* could be expected after introducing the cache. Here, we try
    to explain caching in a simple and intuitive manner.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模型，可以预测缓存的表现如何以及引入缓存后可以期望获得多少*性能提升*。在这里，我们试图以简单直观的方式解释缓存。
- en: Suppose that you have slow storage that can contain many items. You also have
    another fast storage, but it can contain a limited number of items. This is an
    obvious tradeoff. We can call the faster but smaller storage a *cache*. It would
    be reasonable if you bring items from the slow storage into the fast one and process
    them on the fast storage, simply because it is faster.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一种可以包含许多项目的慢速存储。你还有一个快速的存储，但它只能包含有限数量的项目。这是一个明显的权衡。我们可以将更快但更小的存储称为*缓存*。如果你将项目从慢速存储带入快速存储并在此处理它们，这将是合理的，因为这样可以更快。
- en: From time to time, you have to go to slow storage in order to bring over more
    items. It is obvious that you won't bring only one item over from the slow storage,
    as this would be very inefficient. Rather, you will bring a *bucket* of items
    into the faster storage. Usually, it is said that the items are cached into the
    faster storage.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地，你必须前往慢速存储以带来更多的项目。显然，你不会只从慢速存储中带来一个项目，因为这会非常低效。相反，你将一桶项目带入更快的存储中。通常，人们会说项目被缓存到更快的存储中。
- en: Suppose that you are processing an item that requires you to load some other
    item from the slow storage. The first thing that comes to mind is to search for
    the required item inside the recently brought bucket, which is in the cache storage
    at the moment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理一个需要从慢速存储中加载其他项目的项目。首先想到的事情是在当前缓存存储中的最近带来的桶内搜索所需的项目。
- en: If you could find the item in the cache, there is no need to retrieve it from
    the slow storage, and this is called a *hit*. If the item is missing from the
    cache storage, you have to go to the slow storage and read another bucket of items
    into the cache memory. This is called a *miss*. It is clear that the more hits
    you observe, the more performance you get.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在缓存中找到项目，就没有必要从慢速存储中检索它，这被称为*命中*。如果项目缺失于缓存存储中，你必须前往慢速存储并读取另一个桶中的项目到缓存内存中。这被称为*未命中*。很明显，你观察到的命中越多，你获得的表现就越好。
- en: The preceding description can be applied to the CPU cache and the main memory.
    The CPU cache stores recent instructions and data read from the main memory, and
    the main memory is slow compared to the CPU cache memory.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述可以应用于CPU缓存和主存储。CPU缓存存储从主存储中读取的最近指令和数据，而与CPU缓存内存相比，主存储较慢。
- en: In the following section, we discuss cache-friendly code, and we observe why
    cache-friendly code can be executed faster by the CPU.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们讨论缓存友好代码，并观察为什么缓存友好代码可以由CPU更快地执行。
- en: Cache-friendly code
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存友好代码
- en: When the CPU is executing an instruction, it has to fetch all required data
    first. The data is located in the main memory at a specific address that is determined
    by the instruction.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU执行指令时，它必须首先获取所有所需的数据。数据位于由指令确定的特定地址的主存储中。
- en: The data has to be transferred to the CPU registers before any computation.
    But the CPU usually brings more blocks than are expected to be fetched and puts
    them inside its cache.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何计算之前，数据必须被传输到CPU寄存器。但CPU通常携带比预期要获取的更多块，并将它们放入其缓存中。
- en: Next time, if a value is needed in the *proximity* of the previous address,
    it should exist in the cache, and the CPU can use the cache instead of the main
    memory, which is far faster than reading it from the main memory. As we explained
    in the previous section, this is a *cache hit*. If the address is not found in
    the CPU cache, it is a *cache miss*, and the CPU has to access the main memory
    to read the target address and bring required data which is quite slow. In general,
    higher hit rates result in faster executions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下次，如果需要在先前地址的*附近*的值，它应该存在于缓存中，CPU可以使用缓存而不是主存储，这比从主存储中读取要快得多。正如我们在上一节中解释的，这被称为*缓存命中*。如果地址未在CPU缓存中找到，则称为*缓存未命中*，CPU必须访问主存储以读取目标地址并带来所需的数据，这相当慢。一般来说，更高的命中率会导致更快的执行。
- en: But why does the CPU fetch the neighboring addresses (the proximity) around
    an address? It is because of the *principle of locality*. In computer systems,
    it is usually observed that the data located in the same neighborhood is more
    frequently accessed. So, the CPU behaves according to this principle and brings
    more data from a local reference. If an algorithm can exploit this behavior, it
    can be executed faster by the CPU. This is why we refer to such algorithm as a
    *cache-friendly* algorithm.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么 CPU 会从地址周围的相邻地址（邻近性）中获取数据？这是因为 *局部性原理*。在计算机系统中，通常观察到位于相同区域的数据被更频繁地访问。因此，CPU
    根据这个原理行事，并从局部引用中获取更多数据。如果一个算法可以利用这种行为，它就可以被 CPU 更快地执行。这就是我们为什么称这样的算法为 *缓存友好算法*。
- en: '*Example 5.6* demonstrates the difference between the performances of cache-friendly
    code and non-cache-friendly code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5.6* 展示了缓存友好代码和非缓存友好代码性能的差异：'
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Code Box 5-12 [ExtremeC_examples_chapter5_6.c]: Example 5.6 demonstrates the
    performance of cache-friendly code and non-cache-friendly code'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 5-12 [ExtremeC_examples_chapter5_6.c]: 示例 5.6 展示了缓存友好代码和非缓存友好代码的性能'
- en: The preceding program computes and prints the sum of all elements in a matrix,
    but it also does more than that.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序计算并打印矩阵中所有元素的总和，但它做的不仅仅是这些。
- en: 'The user can pass options to this program, which alters its behavior. Suppose
    that we want to print a 2 by 3 matrix that is initialized by an algorithm written
    in the `fill` function. The user has to pass the `print` option with the desired
    number of rows and columns. Next, you can see how these options are passed to
    the final executable binary:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以向此程序传递选项，这会改变其行为。假设我们想打印一个由 `fill` 函数编写的算法初始化的 2 行 3 列矩阵。用户必须传递 `print`
    选项以及所需的行数和列数。接下来，你可以看到这些选项是如何传递给最终的可执行二进制文件的：
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 5-21: Output of example 5.6 showing a 2 by 3 matrix'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 5-21: 示例 5.6 的输出，显示一个 2 行 3 列的矩阵'
- en: The output consists of two different prints for the matrix. The first is the
    2D representation of the matrix and the second is the *flat* representation of
    the same matrix. As you can see, the matrix is stored as a *row-major order* in
    memory. This means that we store it row by row. So, if something from a row is
    fetched by the CPU, it is probable that all of the elements in that row are fetched
    too. Hence, it would be better to do our summation in row-major order and not
    *column-major* order.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括矩阵的两个不同打印。第一个是矩阵的二维表示，第二个是相同矩阵的 *扁平* 表示。正如你所看到的，矩阵在内存中按 *行主序顺序* 存储。这意味着我们按行存储它。所以，如果
    CPU 获取了某行的数据，那么该行中的所有元素很可能也会被获取。因此，我们最好按行主序而不是 *列主序* 进行求和。
- en: 'If you look at the code again, you can see that the summation done in the `friendly_sum`
    function is row-major, and the summation performed in the `not_friendly_sum` function
    is column-major. Next, we can compare the time it takes to perform the summation
    of a matrix with 20,000 rows and 20,000 columns. As you can see, the difference
    is very clear:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看代码，你可以看到在 `friendly_sum` 函数中执行的是行主序求和，而在 `not_friendly_sum` 函数中执行的是列主序求和。接下来，我们可以比较执行
    20,000 行和 20,000 列矩阵求和所需的时间。正如你所看到的，差异非常明显：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 5-22: Demonstration of the time difference between the column-major
    and row-major matrix summation algorithms'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 5-22: 列主序和行主序矩阵求和算法的时间差异演示'
- en: The difference between the measured times is about 10 seconds! The program is
    compiled on a macOS machine using the `clang` compiler. The difference means that
    the same logic, using the same amount of memory, can take much longer – just by
    selecting a different order of accessing the matrix elements! This example clearly
    shows the effect of cache-friendly code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 测量时间的差异大约是 10 秒！程序是在 macOS 机器上使用 `clang` 编译器编译的。这种差异意味着相同的逻辑，使用相同数量的内存，可能需要更长的时间——仅仅是通过选择不同的矩阵元素访问顺序！这个例子清楚地展示了缓存友好代码的影响。
- en: '**Note**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The `time` utility is available in all Unix-like operating systems. It can be
    used to measure the time a program takes to finish.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 工具在所有类 Unix 操作系统中都可用。它可以用来测量程序完成所需的时间。'
- en: Before continuing to the next technique, we should talk a bit more about the
    allocation and deallocation cost.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一个技术之前，我们应该更多地讨论一下分配和释放成本。
- en: Allocation and deallocation cost
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配和释放成本
- en: Here, we want to specifically talk about the cost of Heap memory allocation
    and deallocation. This might be a bit of a surprise if you realize that Heap memory
    allocation and deallocation operations are time-and memory-consuming and are usually
    expensive, especially when you need to allocate and deallocate Heap memory blocks
    many times per second.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想特别谈谈堆内存分配和释放的成本。如果你意识到堆内存分配和释放操作既耗时又耗内存，并且通常很昂贵，特别是当你需要每秒多次分配和释放堆内存块时，这可能会让你感到有些惊讶。
- en: Unlike Stack allocation, which is relatively fast and the allocation itself
    requires no further memory, Heap allocation requires finding a free block of memory
    with enough size, and this can be costly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与相对快速且分配本身不需要额外内存的栈分配不同，堆分配需要找到足够大小的空闲内存块，这可能很昂贵。
- en: There are many algorithms designed for memory allocation and deallocation, and
    there is always a tradeoff between the allocation and deallocation operations.
    If you want to allocate quickly, you have to consume more memory as part of the
    allocation algorithm and vice versa if you want to consume less memory you can
    choose to spend more time with a slower allocation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 设计了许多用于内存分配和释放的算法，并且在分配和释放操作之间总是存在权衡。如果你想快速分配，就必须在分配算法中消耗更多的内存；反之，如果你想减少内存消耗，可以选择花费更多时间进行较慢的分配。
- en: There are memory allocators for C other than those provided by the default C
    standard library through the `malloc` and `free` functions. Some of these memory
    allocator libraries are `ptmalloc`, `tcmalloc`, `Haord`, and `dlmalloc`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过`malloc`和`free`函数提供的默认C标准库之外，还有其他用于C语言的内存分配器。这些内存分配器库包括`ptmalloc`、`tcmalloc`、`Haord`和`dlmalloc`。
- en: Going through all allocators here is beyond the scope of this chapter, but it
    would be good practice for you to go through them and give them a try for yourself.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里详细介绍所有分配器超出了本章的范围，但对你来说，亲自尝试它们并体验一下是一个好的实践。
- en: 'What is the solution to this silent problem? It is simple: allocate and deallocate
    less frequently. This may seem impossible in some programs that are required to
    have a high rate of Heap allocations. These programs usually allocate a big block
    of the Heap memory and try to manage it themselves. It is like having another
    layer of allocation and deallocation logic (maybe simpler than implementations
    of `malloc` and `free`) on top of a big block of the Heap memory.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个无声问题的解决方案是什么？很简单：减少分配和释放的频率。在某些程序中，这可能看起来是不可能的，因为这些程序需要以高频率进行堆内存分配。这些程序通常分配一大块堆内存，并尝试自行管理它。这就像在堆内存的大块上又增加了一层分配和释放逻辑（可能比`malloc`和`free`的实现简单）。
- en: There is also another method, which is using *memory pools*. We'll briefly explain
    this technique before we come to the end of this chapter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法，即使用*内存池*。在我们结束本章之前，我们将简要解释这项技术。
- en: Memory pools
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存池
- en: As we described in the previous section, memory allocation and deallocation
    are costly. Using a pool of preallocated fixed-size Heap memory blocks is an effective
    way to reduce the number of allocations and gain some performance. Each block
    in the pool usually has an identifier, which can be acquired through an API designed
    for pool management. Also, the block can be released later when it is not needed.
    Since the amount of allocated memory remains almost fixed, it is an excellent
    choice for algorithms willing to have deterministic behavior in memory-constrained
    environments.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中描述的，内存分配和释放是昂贵的。使用预先分配的固定大小堆内存块池是一种有效的方法来减少分配次数并提高一些性能。池中的每个块通常都有一个标识符，可以通过为池管理设计的API获取。此外，当不再需要时，块也可以被释放。由于分配的内存量几乎保持不变，这对于希望在内存受限环境中具有确定性行为的算法来说是一个极佳的选择。
- en: Describing memory pools in further detail is beyond the scope of this book;
    many useful resources on this topic exist online if you wish to read more about
    it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述内存池超出了本书的范围；如果您想了解更多关于这个主题的信息，网上有许多有用的资源。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As part of this chapter, we mainly covered the Stack and Heap segments and the
    way they should be used. After that, we briefly discussed memory-constrained environments
    and we saw how techniques like caching and memory pools can increase the performance.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们主要介绍了栈和堆段以及它们的使用方式。之后，我们简要讨论了内存受限环境，并看到了缓存和内存池等技术如何提高性能。
- en: 'In this chapter:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: We discussed the tools and techniques used for probing both Stack and Heap segments.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了用于探测栈和堆段的工具和技术。
- en: We introduced debuggers and we used `gdb` as our main debugger to troubleshoot
    memory-related issues.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了调试器，并使用 `gdb` 作为我们的主要调试器来排查与内存相关的问题。
- en: We discussed memory profilers and we used `valgrind` to find memory issues such
    as leakages or dangling pointers happening at runtime.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了内存分析器，并使用 `valgrind` 来查找运行时发生的内存问题，如泄漏或悬垂指针。
- en: We compared the lifetime of a Stack variable and a Heap block and we explained
    how we should judge the lifetime of such memory blocks.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们比较了栈变量和堆块的生存期，并解释了如何判断此类内存块的生存期。
- en: We saw that memory management is automatic regarding Stack variables, but it
    is fully manual with Heap blocks.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到，栈变量的内存管理是自动的，但堆块的内存管理是完全手动的。
- en: We went through the common mistakes that happen when dealing with Stack variables.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了处理栈变量时常见的错误。
- en: We discussed the constrained environments and we saw how memory tuning can be
    done in these environments.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了受限环境，并展示了在这些环境中如何进行内存调优。
- en: We discussed the performant environments and what techniques can be used to
    gain some performance.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了高效的环境以及可以使用哪些技术来提高性能。
- en: The next four chapters together cover object orientation in C. This might at
    first glance seem to be unrelated to C, but in fact, this is the correct way to
    write object-oriented code in C. As part of these chapters, you will be introduced
    to the proper way of designing and solving a problem in an object-oriented fashion,
    and you will get guidance through writing readable and correct C code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四章一起涵盖了 C 语言中的面向对象。乍一看，这似乎与 C 语言无关，但实际上，这是在 C 语言中编写面向对象代码的正确方式。作为这些章节的一部分，你将了解如何以面向对象的方式设计和解决问题，并且你将通过编写可读且正确的
    C 代码获得指导。
- en: The next chapter covers encapsulation and the basics of object-oriented programming
    by providing the required theoretical discussion and examples to explore the topics
    discussed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章通过提供必要的理论讨论和示例来探讨所讨论的主题，涵盖了封装和面向对象编程的基础。
