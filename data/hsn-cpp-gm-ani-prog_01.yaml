- en: '*Chapter 1*: Creating a Game Window'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：创建游戏窗口'
- en: In this chapter, you will set up a simple Win32 window and bind an OpenGL context
    to it. You will be using OpenGL 3.3 Core throughout this book. The actual OpenGL
    code is going to be very minimal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置一个简单的Win32窗口，并将一个OpenGL上下文绑定到它上。本书中将始终使用OpenGL 3.3核心。实际的OpenGL代码将非常少。
- en: Most OpenGL-specific code will be abstracted into helper objects and functions,
    which will allow you to focus on animation rather than any specific graphics APIs.
    You will write the abstraction layer in [*Chapter 6*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104)*,
    Building an Abstract Renderer*, but for now, it's important to create a window
    ready to be drawn to.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分特定于OpenGL的代码将被抽象成辅助对象和函数，这将使你能够专注于动画而不是任何特定的图形API。你将在[*第6章*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104)*，构建一个抽象渲染器*中编写抽象层，但现在，重要的是创建一个可以绘制的窗口。
- en: 'By the end of this chapter, you should be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够做到以下几点：
- en: Open a Win32 window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个Win32窗口
- en: Create and bind an OpenGL 3.3 Core context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并绑定一个OpenGL 3.3核心上下文
- en: Use glad to load OpenGL 3.3 Core functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用glad加载OpenGL 3.3核心函数
- en: Enable vsynch for the created window
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为创建的窗口启用垂直同步
- en: Understand the downloadable samples for this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解本书的可下载示例
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the code in this book, you will need a computer running
    Windows 10 with a recent version of Visual Studio installed. All of the downloadable
    code samples are built using Visual Studio 2019\. You can download Visual Studio
    from [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书中的代码，你需要一台安装了最新版本的Windows 10的计算机，并安装了Visual Studio。所有可下载的代码示例都是使用Visual
    Studio 2019构建的。你可以从[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)下载Visual
    Studio。
- en: You can find all of the sample code for the book on GitHub at [https://github.com/PacktPublishing/Game-Animation-Programming](https://github.com/PacktPublishing/Game-Animation-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本书的所有示例代码[https://github.com/PacktPublishing/Game-Animation-Programming](https://github.com/PacktPublishing/Game-Animation-Programming)。
- en: Creating an empty project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个空项目
- en: 'Throughout this book, you will be creating code from scratch as much as possible.
    Because of this, there will be very few external dependencies. To get started,
    follow these steps to create a new blank C++ project in Visual Studio:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将尽可能地从头开始创建代码。因此，外部依赖将会很少。要开始，请按照以下步骤在Visual Studio中创建一个新的空白C++项目：
- en: 'Open Visual Studio and create a new project by going to **File**|**New**|**Project**:![Figure
    1.1: Creating a new Visual Studio project'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，通过**文件**|**新建**|**项目**创建一个新项目：![图1.1：创建一个新的Visual Studio项目
- en: '](img/Figure_1.1_B16191.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16191.jpg)'
- en: 'Figure 1.1: Creating a new Visual Studio project'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：创建一个新的Visual Studio项目
- en: 'You will see your project templates on the left-hand side of the window that
    pops up. Navigate to **Installed**|**Visual C++**|**Other**. Then, select **Empty
    Project**:![Figure 1.2: Creating an empty C++ project'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在弹出窗口的左侧看到项目模板。导航到**已安装**|**Visual C++**|**其他**。然后，选择**空项目**：![图1.2：创建一个空的C++项目
- en: '](img/Figure_1.2_B16191.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16191.jpg)'
- en: 'Figure 1.2: Creating an empty C++ project'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：创建一个空的C++项目
- en: Enter a project name and select a project location. Finally, click **Create**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称并选择项目位置。最后，点击**创建**。
- en: '![Figure 1.3: Specifying a new project name'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：指定新项目名称'
- en: '](img/Figure_1.3_B16191.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16191.jpg)'
- en: 'Figure 1.3: Specifying a new project name'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：指定新项目名称
- en: If you have followed the preceding steps, you should have a new blank project.
    Throughout the rest of this chapter, you will add an application framework and
    an OpenGL-enabled window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照前面的步骤操作，你应该有一个新的空白项目。在本章的其余部分，你将添加一个应用程序框架和一个启用了OpenGL的窗口。
- en: Creating the application class
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序类
- en: It would be difficult to maintain a cluttered window entry function. Instead,
    you need to create an abstract `Application` class. This class will contain some
    basic functions, such as `Initialize`, `Update`, `Render`, and `Shutdown`. All
    of the code samples provided for this book will be built on top of the `Application`
    base class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 维护杂乱的窗口入口函数将会很困难。相反，你需要创建一个抽象的`Application`类。这个类将包含一些基本函数，比如`Initialize`、`Update`、`Render`和`Shutdown`。本书提供的所有代码示例都将构建在`Application`基类之上。
- en: 'Create a new file, `Application.h`. The declaration of the `Application` class
    is provided in the following code sample. Add this declaration to the newly created
    `Application.h` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`Application.h`。`Application`类的声明在以下代码示例中提供。将这个声明添加到新创建的`Application.h`文件中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Initialize`, `Update`, `Render`, and `Shutdown` functions are the life
    cycle of an application. All these functions will be called directly from the
    Win32 window code. `Update` and `Render` take arguments. To update a frame, the
    delta time between the current and last frame needs to be known. To render a frame,
    the aspect ratio of the window must be known.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize`、`Update`、`Render`和`Shutdown`函数是应用程序的生命周期。所有这些函数将直接从Win32窗口代码中调用。`Update`和`Render`需要参数。要更新一个帧，需要知道当前帧和上一帧之间的时间差。要渲染一个帧，需要知道窗口的宽高比。'
- en: The life cycle functions are virtual. Each chapter in the downloadable materials
    for this book has an example that is a subclass of the `Application` class that
    demonstrates a concept from that chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期函数是虚拟的。本书可下载材料中的每一章都有一个示例，它是`Application`类的子类，演示了该章节的概念。
- en: Next, you will be adding an OpenGL loader to the project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将向项目添加一个OpenGL加载器。
- en: Adding an OpenGL loader
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个OpenGL加载器
- en: There is some external code that this chapter depends on, called `glad`. When
    you create a new OpenGL context on Windows, it's created with a legacy OpenGL
    context. The extension mechanism of OpenGL will let you use this legacy context
    to create a new modern context.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于一些外部代码，称为`glad`。在Windows上创建一个新的OpenGL上下文时，它将使用一个传统的OpenGL上下文。OpenGL的扩展机制将允许你使用这个传统上下文来创建一个新的现代上下文。
- en: Once the modern context is created, you will need to get function pointers to
    all OpenGL functions. The functions need to be loaded with `wglGetProcAdress`,
    which returns a function pointer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦现代上下文被创建，您将需要获取所有 OpenGL 函数的函数指针。这些函数需要使用 `wglGetProcAdress` 加载，它返回一个函数指针。
- en: Loading every OpenGL function in this fashion would be very time-consuming.
    This is where having an OpenGL loader comes in; `glad` will do all this work for
    you. An OpenGL loader is a library or some code that calls `wglGetProcAdress`
    on the functions that the OpenGL API defines.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式加载每个 OpenGL 函数将非常耗时。这就是使用 OpenGL 加载器的地方；`glad` 将为您完成所有这些工作。OpenGL 加载器是一个库或一些代码，调用
    `wglGetProcAdress` 来定义 OpenGL API 的函数。
- en: There are several OpenGL loaders available on Windows.; this book will use `glad`.
    `glad` is a small library that consists of only a few files. It has a simple API;
    you call one function and get access to all the OpenGL functions. `glad` has a
    web-based interface; you can find it at [https://glad.dav1d.de/](https://glad.dav1d.de/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上有几个 OpenGL 加载器可用；本书将使用 `glad`。`glad` 是一个只包含几个文件的小型库。它有一个简单的 API；您调用一个函数就可以访问所有的
    OpenGL 函数。`glad` 有一个基于 web 的界面；您可以在 [https://glad.dav1d.de/](https://glad.dav1d.de/)
    找到它。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using an X Windows system, such as many popular Linux distributions, the
    function to load OpenGL functions is `glXGetProcAddress`. As with Windows, there
    are OpenGL loaders available for Linux as well. Not all OSes need an OpenGL loader;
    for example, macOS, iOS, and Android don't need a loader. Both iOS and Android
    run on OpenGL ES.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 X 窗口系统（例如许多流行的 Linux 发行版）时，加载 OpenGL 函数的函数是 `glXGetProcAddress`。与 Windows
    一样，Linux 也有可用的 OpenGL 加载器。并非所有操作系统都需要 OpenGL 加载器；例如，macOS、iOS 和 Android 不需要加载器。iOS
    和 Android 都运行在 OpenGL ES 上。
- en: Getting glad
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 glad
- en: 'You can get `glad` from [https://glad.dav1d.de/](https://glad.dav1d.de/), a
    web-based generator:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://glad.dav1d.de/](https://glad.dav1d.de/) 获取 `glad`，这是一个基于 web 的生成器：
- en: 'Go to the site, select **Version 3.3** from the **gl** dropdown, and select
    **Core** from the **Profile** dropdown:![Figure 1.4: Configuring glad'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到该网站，从 **gl** 下拉菜单中选择 **Version 3.3**，从 **Profile** 下拉菜单中选择 **Core**：![图 1.4：配置
    glad
- en: '](img/Figure_1.4_B16191.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B16191.jpg)'
- en: 'Figure 1.4: Configuring glad'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：配置 glad
- en: Scroll to the bottom and hit the **Generate** button. This should start downloading
    a ZIP file that contains all of the required code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到底部，点击 **Generate** 按钮。这应该开始下载一个包含所有所需代码的 ZIP 文件。
- en: The code presented in this book is forward compatible with OpenGL version 3.3
    or a more recent version. If you want to use a newer OpenGL version, such as 4.6,
    change the gl dropdown under API to the desired version. You will be adding the
    contents of this ZIP file to your main project in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中提供的代码与 OpenGL 版本 3.3 或更高版本向前兼容。如果要使用更新的 OpenGL 版本，例如 4.6，将 API 下拉菜单下的 gl
    更改为所需的版本。在下一节中，您将向主项目添加此 ZIP 文件的内容。
- en: Adding glad to the project
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 glad 添加到项目
- en: 'Once `glad.zip` is downloaded, extract its contents. Add the following files
    from the ZIP file to your project. The directory structure does not need to be
    maintained; all of these files can be placed next to each other:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了 `glad.zip`，解压其内容。将 ZIP 文件中的以下文件添加到您的项目中。不需要维护目录结构；所有这些文件都可以放在一起：
- en: '`src/glad.c`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/glad.c`'
- en: '`include/glad/glad.h`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include/glad/glad.h`'
- en: '`include/KHR/khrplatform.h`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include/KHR/khrplatform.h`'
- en: 'These files will be included as normal project files—you don''t have to set
    up `include` paths—but that does mean that the contents of the files need to be
    edited:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件将被包含为普通项目文件——您不需要设置 `include` 路径——但这意味着文件的内容需要被编辑：
- en: 'Open `glad.c` and find the following #include:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开 `glad.c`，并找到以下 #include：'
- en: '`#include <glad/glad.h>`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include <glad/glad.h>`'
- en: 'Replace the `include` path with the relative path of `glad.h`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 `glad.h` 的相对路径替换 `include` 路径：
- en: '`#include "glad.h"`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include "glad.h"`'
- en: 'Similarly, open `glad.h` and find the following #include:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '同样，打开 `glad.h`，并找到以下 #include：'
- en: '`#include <KHR/khrplatform.h>`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include <KHR/khrplatform.h>`'
- en: 'Replace the `include` path with the relative path of `khrplatform.h`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 `khrplatform.h` 的相对路径替换 `include` 路径：
- en: '`#include "khrplatform.h"`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include "khrplatform.h"`'
- en: '`glad` should now be added to the project and there should be no compilation
    errors. In the next section, you will start implementing the Win32 window.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`glad` 现在应该已经添加到项目中，不应该有编译错误。在下一节中，您将开始实现 Win32 窗口。'
- en: Creating a window
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口
- en: In this section, you will create a window. This means you will be using Win32
    API calls directly to open a window and control its life cycle from code. You
    will also set up a debug console that can run alongside the window, which is useful
    for viewing logs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个窗口。这意味着您将直接使用 Win32 API 调用来打开窗口并从代码中控制其生命周期。您还将设置一个调试控制台，可以与窗口一起运行，这对于查看日志非常有用。
- en: Important note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An in-depth discussion of the Win32 API is beyond the scope of this book. For
    additional information on any of the Win32 APIs, refer to the Microsoft Developers
    Network (MSDN) at [https://docs.microsoft.com/en-us/windows/win32/api/](https://docs.microsoft.com/en-us/windows/win32/api/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 深入讨论 Win32 API 超出了本书的范围。有关任何 Win32 API 的其他信息，请参阅微软开发者网络（MSDN）[https://docs.microsoft.com/en-us/windows/win32/api/](https://docs.microsoft.com/en-us/windows/win32/api/)。
- en: To make logging a bit easier, two windows will be open at the same time in debug
    mode. One will be the standard Win32 window, and the other will be a console window
    for viewing logs. This can be achieved by setting the linker conditionally. In
    debug mode, the application should link to the console subsystem. In release mode,
    it should link to the window subsystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使日志记录变得更容易，在调试模式下将同时打开两个窗口。一个是标准的 Win32 窗口，另一个是用于查看日志的控制台窗口。这可以通过条件设置链接器来实现。在调试模式下，应用程序应链接到控制台子系统。在发布模式下，应链接到窗口子系统。
- en: Setting the linker subsystem can be done through the project's properties or
    in code using a `#pragma` comment. Once the subsystem is set to the console, the
    `WinMain` function can be called from `main`, which will launch a window that
    is attached to the console.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过项目的属性或使用`#pragma`注释在代码中设置链接器子系统。一旦子系统设置为控制台，`WinMain`函数就可以从`main`中调用，这将启动一个附加到控制台的窗口。
- en: Additional linker actions, such as linking to external libraries, can be done
    from code, too. You will be using a `#pragma` command to link with OpenGL.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过代码执行其他链接器操作，例如链接到外部库。您将使用`#pragma`命令与OpenGL进行链接。
- en: 'Start the window implementation by creating a new file, `WinMain.cpp`. This
    file will contain all of the window logic. Then, do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新文件`WinMain.cpp`来开始窗口实现。该文件将包含所有窗口逻辑。然后，执行以下操作：
- en: 'Add the following code to the beginning of the file. It creates `#define` constants
    that reduce the amount of code that is brought in by including `<windows.h>`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件开头。它创建了`#define`常量，减少了通过包含`<windows.h>`引入的代码量：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The window entry function and the window event processing function both need
    to be forward declared. These are the two Win32 functions that we will need to
    open a new window:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要提前声明窗口入口函数和窗口事件处理函数。这是我们需要打开一个新窗口的两个Win32函数：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use a `#pragma` comment to link to `OpenGL32.lib` in code, rather than going
    through the project''s properties window. Add the following code to `WinMain.cpp`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`#pragma`注释在代码中链接到`OpenGL32.lib`，而不是通过项目的属性窗口。将以下代码添加到`WinMain.cpp`中：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, a few OpenGL functions need to be declared. Creating a modern OpenGL context
    is done through `wglCreateContextAttribsARB`, but there is no reference to this
    function. This is one of the functions that needs to be loaded through `wglGetProcAddress`,
    as it's an extension function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要声明一些OpenGL函数。通过`wglCreateContextAttribsARB`创建现代OpenGL上下文，但是没有引用此函数。这是需要通过`wglGetProcAddress`加载的函数之一，因为它是一个扩展函数。
- en: The function signature of `wglCreateContextAttribsARB` can be found in `wglext.h`.
    The `wglext.h` header is hosted by Khronos and can be found online in the OpenGL
    registry at [https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`wglCreateContextAttribsARB`的函数签名可以在`wglext.h`中找到。`wglext.h`头文件由Khronos托管，并且可以在OpenGL注册表的[https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php)上找到。'
- en: 'There is no need to include the entire `wglext.h` header file; you will only
    need the function relevant to creating a modern context. The following code is
    directly copied from the file. It contains the declarations for the relevant `#define`
    constants and the function pointer types:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无需包含整个`wglext.h`头文件；您只需要与创建现代上下文相关的函数。以下代码直接从文件中复制。它包含了相关`#define`常量和函数指针类型的声明：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code defines a function pointer type for `wglCreatecontextAttribsARB`.
    In addition to this, there are `#define` constants that are needed to make an
    OpenGL 3.3 Core context. The samples for this book will have `vsynch` enabled,
    which can be done through `wglSwapIntervalEXT`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了一个`wglCreatecontextAttribsARB`的函数指针类型。除此之外，还有一些`#define`常量，用于创建OpenGL
    3.3核心上下文。本书的示例将启用`vsynch`，可以通过`wglSwapIntervalEXT`来实现。
- en: 'As you will guess, this function needs to be loaded using OpenGL''s extension
    mechanism, too. It also needs two additional support functions: `wglGetExtensionStringEXT`
    and `wglGetSwapIntervalEXT`. All three of these functions are found in `wgl.h`,
    which is hosted by Khronos in the OpenGL registry linked previously.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您猜到的那样，这个函数也需要使用OpenGL的扩展机制加载。它还需要两个额外的支持函数：`wglGetExtensionStringEXT`和`wglGetSwapIntervalEXT`。这三个函数都可以在`wgl.h`中找到，该文件由Khronos在先前链接的OpenGL注册表中托管。
- en: 'Instead of including `wgl.h`, add the following code to `WinMain.cpp`. The
    code defines function pointer signatures for `wglGetExtensionStringEXT`, `wglSwapIntervalEXT`,
    and `wglGetSwapIntervalEXT`, copied out of `wgl.h`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不要包含`wgl.h`，而是将以下代码添加到`WinMain.cpp`中。该代码定义了`wglGetExtensionStringEXT`、`wglSwapIntervalEXT`和`wglGetSwapIntervalEXT`的函数指针签名，从`wgl.h`中复制出来：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is required to work with OpenGL. It's common to copy the
    code instead of including these headers directly. In the next section, you will
    begin working on the actual window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是必须的，用于与OpenGL一起工作。通常会复制代码，而不是直接包含这些头文件。在下一节中，您将开始处理实际的窗口。
- en: Global variables
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'Two global variables are required for easy window cleanup: a pointer to the
    currently running application and a handle to the global OpenGL **Vertex Array
    Object** (**VAO**). Instead of each draw call having its own VAO, one will be
    bound for the entire duration of the sample.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两个全局变量以便轻松清理窗口：指向当前运行应用程序的指针和全局OpenGL **顶点数组对象**（**VAO**）的句柄。不是每个绘制调用都有自己的VAO，整个示例的持续时间将绑定一个VAO。
- en: 'To do this, create the following global variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请创建以下全局变量：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Throughout the rest of this book, there will be no other global variables. Global
    variables can make the program state harder to track. The reason these two exist
    is to easily reference them when the application is shutting down later. Next,
    you will start implementing the `WinMain` function to open a new window.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，将不会有其他全局变量。全局变量可能会使程序状态更难以跟踪。这两个存在的原因是稍后在应用程序关闭时轻松引用它们。接下来，您将开始实现`WinMain`函数以打开一个新窗口。
- en: Opening a window
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开一个窗口
- en: 'Next, you need to implement the window entry function, `WinMain`. This function
    will be responsible for creating a window class, registering the window class,
    and opening a new window:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要实现窗口入口函数`WinMain`。此函数将负责创建窗口类，注册窗口类并打开一个新窗口：
- en: 'Start the definition of `WinMain` by creating a new instance of the `Application`
    class and storing it in the global pointer:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`Application`类的新实例并将其存储在全局指针中来开始定义`WinMain`的定义：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, an instance of `WNDCLASSEX` needs to be filled out. There isn''t anything
    special that goes into this; it''s just a standard window definition. The only
    thing to look out for is whether the `WndProc` function is set correctly:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要填写`WNDCLASSEX`的一个实例。这里没有什么特别的，它只是一个标准的窗口定义。唯一需要注意的是`WndProc`函数是否设置正确：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new application window should launch in the center of the monitor. To do
    this, find the width and height of the screen using `GetSystemMetrics`. Then,
    adjust `windowRect` to the desired size around the center of the screen:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的应用程序窗口应该在监视器的中心启动。为此，使用`GetSystemMetrics`来找到屏幕的宽度和高度。然后，调整`windowRect`到屏幕中心的所需大小：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To figure out the size of the window, not just the client area, the style of
    the window needs to be known. The following code sample creates a window that
    can be minimized or maximized but not resized. To resize the window, use a bitwise
    OR (`|`) operator with the `WS_THICKFRAME` defined:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定窗口的大小，不仅仅是客户区域，需要知道窗口的样式。以下代码示例创建了一个可以最小化或最大化但不能调整大小的窗口。要调整窗口的大小，使用位或(`|`)运算符与`WS_THICKFRAME`定义：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the desired window style is defined, call the `AdjustWindowRectEx` function
    to adjust the size of the client rectangle to include all the window dressing
    in its size as well. When the final size is known, `CreateWindowEx` can be used
    to create the actual window. Once the window is created, store a reference to
    its device context:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了所需的窗口样式，调用`AdjustWindowRectEx`函数来调整客户区矩形的大小，以包括所有窗口装饰在其大小中。当最终大小已知时，可以使用`CreateWindowEx`来创建实际的窗口。窗口创建完成后，存储对其设备上下文的引用：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the window is created, you will next create an OpenGL context. To
    do this, you first need to find the correct pixel format, and then apply it to
    the device context of the window. The following code shows you how to do this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在窗口已经创建，接下来你将创建一个OpenGL上下文。为此，你首先需要找到正确的像素格式，然后将其应用到窗口的设备上下文中。以下代码向你展示了如何做到这一点：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the pixel format set, create a temporary OpenGL context using `wglCreateContext`.
    This temporary context is only needed to get a pointer to `wglCreateContextAttribsARB`,
    which will be used to create a modern context:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了像素格式后，使用`wglCreateContext`创建一个临时的OpenGL上下文。这个临时上下文只是用来获取指向`wglCreateContextAttribsARB`的指针，它将用于创建一个现代上下文：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A temporary OpenGL context exists and is bound, so call the `wglCreateContextAttribsARB`
    function next. This function will return an OpenGL 3.3 Core context profile, bind
    it, and delete the legacy context:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在并绑定了一个临时的OpenGL上下文，所以下一步是调用`wglCreateContextAttribsARB`函数。这个函数将返回一个OpenGL
    3.3 Core上下文配置文件，绑定它，并删除旧的上下文：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With an OpenGL 3.3 Core context active, `glad` can be used to load all the
    OpenGL 3.3 Core functions. Call `gladLoadGL` to do this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在激活OpenGL 3.3 Core上下文后，可以使用`glad`来加载所有OpenGL 3.3 Core函数。调用`gladLoadGL`来实现这一点：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An OpenGL 3.3 Core context should now be initialized, with all of the core
    OpenGL functions loaded. Next, you will enable `vsynch` on the window. `vsynch`
    is not a built-in function; it''s an extension and, as such, support for it needs
    to be queried with `wglGetExtensionStringEXT`. The extension string for `vsynch`
    is `WGL_EXT_swap_control`. Check whether this is in the list of extension strings:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该已经初始化了一个OpenGL 3.3 Core上下文，并加载了所有核心OpenGL函数。接下来，你将在窗口上启用`vsynch`。`vsynch`不是一个内置函数；它是一个扩展，因此需要使用`wglGetExtensionStringEXT`来查询对它的支持。`vsynch`的扩展字符串是`WGL_EXT_swap_control`。检查它是否在扩展字符串列表中：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the `WGL_EXT_swap_control` extension is available, it needs to be loaded.
    The actual function is `wglSwapIntervalEXT`, which can be found in `wgl.h`. Passing
    an argument to `wglSwapIntervalEXT` turns on `vsynch`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`WGL_EXT_swap_control`扩展可用，需要加载它。实际的函数是`wglSwapIntervalEXT`，可以在`wgl.h`中找到。向`wglSwapIntervalEXT`传递参数可以打开`vsynch`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is just a little bit more housekeeping to do to finish setting up an
    OpenGL-enabled window. OpenGL 3.3 Core requires a VAO to be bound for all draw
    calls. Instead of creating a VAO for each draw call, you will create one global
    VAO that is bound in `WinMain` and never unbound until the window is destroyed.
    The following code creates this VAO and binds it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一点小事情要做，以完成OpenGL启用窗口的设置。OpenGL 3.3 Core要求在所有绘制调用中绑定一个VAO。你将创建一个全局VAO，在`WinMain`中绑定它，并在窗口被销毁之前永远不解绑。以下代码创建了这个VAO并绑定它：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Call the `ShowWindow` and `UpdateWindow` functions to display the current window;
    this is also a good place to initialize the global application. Depending on the
    amount of work that the application''s `Initialize` function ends up doing, the
    window may appear frozen for a little bit:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ShowWindow`和`UpdateWindow`函数来显示当前窗口；这也是初始化全局应用程序的好地方。根据应用程序的`Initialize`函数所做的工作量，窗口可能会在一小段时间内出现冻结：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You''re now ready to implement the actual game loop. You will need to keep
    track of the last frame time to calculate the delta time between frames. In addition
    to game logic, the loop needs to handle window events by peeking at the current
    message stack and dispatching messages accordingly:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经准备好实现实际的游戏循环了。你需要跟踪上一帧的时间，以计算帧之间的时间差。除了游戏逻辑，循环还需要处理窗口事件，通过查看当前消息堆栈并相应地分派消息：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the window events are processed, the `Application` instance needs to
    update and render. First, find the delta time between the last frame and this
    one, converting it into seconds. For example, a game that''s running at 60 FPS
    should have a delta time of 16.6 milliseconds, or 0.0166 seconds:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理完窗口事件后，`Application`实例需要更新和渲染。首先，找到上一帧和当前帧之间的时间差，将其转换为秒。例如，以60 FPS运行的游戏应该有16.6毫秒或0.0166秒的时间差：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Rendering the currently running application needs just a little bit more housekeeping.
    Set the OpenGL viewport with `glViewport` every frame and clear the color, depth,
    and stencil buffer. In addition to this, make sure all OpenGL states are correct
    before rendering. This means that the correct VAO is bound, depth test and face
    culling are enabled, and the appropriate point size is set:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染当前运行的应用程序只需要更多的维护工作。每帧都要用`glViewport`设置OpenGL视口，并清除颜色、深度和模板缓冲区。除此之外，确保在渲染之前所有的OpenGL状态都是正确的。这意味着正确的VAO被绑定，深度测试和面剔除被启用，并且设置了适当的点大小：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After the current `Application` instance has updated and rendered, the back
    buffer needs to be presented. This is done by calling `SwapBuffers`. If `vsynch`
    is enabled, `glFinish` needs to be called right after `SwapBuffers`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前`Application`实例更新和渲染后，需要呈现后备缓冲区。这是通过调用`SwapBuffers`来完成的。如果启用了`vsynch`，则需要在`SwapBuffers`之后立即调用`glFinish`：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s it for the window loop. After the window loop exits, it''s safe to
    return from the `WinMain` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口循环到此结束。窗口循环退出后，可以安全地从`WinMain`函数返回：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want to use a version of OpenGL other than 3.3, adjust the major and
    minor values in the `attribList` variable presented in Step 8\. Even though the
    `WinMain` function is written, you still can't compile this file; it would fail
    because `WndProc` was never defined. The `WndProc` function handles events such
    as mouse motion or resizing for a window. In the next section, you will implement
    the `WndProc` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用OpenGL的其他版本而不是3.3，调整Step 8中`attribList`变量中的主要和次要值。即使`WinMain`函数已经编写，你仍然无法编译这个文件；因为`WndProc`从未被定义过。`WndProc`函数处理诸如鼠标移动或窗口调整大小等事件。在下一节中，你将实现`WndProc`函数。
- en: Creating the event handler
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建事件处理程序
- en: 'In order to have a properly functioning window, or to even compile the application,
    at this point, the event processing function, `WndProc`, must be defined. The
    implementation here will be very simple, mostly focusing on how to destroy the
    window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个正常运行的窗口，甚至编译应用程序，在这一点上，事件处理函数`WndProc`必须被定义。这里的实现将非常简单，主要关注如何销毁窗口：
- en: 'Start implementing the `WndProc` function in `WinMain.cpp`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WinMain.cpp`中开始实现`WndProc`函数：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the `WM_CLOSE` message is received, you need to shut down the `Application`
    class and emit a destroy window message. Once the application is shut down, don''t
    forget to delete it:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到`WM_CLOSE`消息时，需要关闭`Application`类并发出销毁窗口消息。应用程序关闭后，不要忘记删除它：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the destroy message is received, the window''s OpenGL resources need to
    be released. This means deleting the global vertex array object, and then deleting
    the OpenGL context:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到销毁消息时，窗口的OpenGL资源需要被释放。这意味着删除全局顶点数组对象，然后删除OpenGL上下文：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The paint and erase background messages are safe to ignore since OpenGL is
    managing rendering to the window. If the message received isn''t one of the messages
    already handled, forward it to the default window message function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制和擦除背景消息是安全忽略的，因为OpenGL正在管理对窗口的渲染。如果收到的消息不是已经处理的消息之一，将其转发到默认的窗口消息函数：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that you have written the windows event loop, you should be able to compile
    and run a blank window. In the following section, you'll explore the downloadable
    samples for this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了窗口事件循环，应该能够编译和运行一个空白窗口。在接下来的部分，你将探索本书的可下载示例。
- en: Exploring the samples
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索样本
- en: All of the code presented in this book is available in the downloadable content
    for the book. There is one large sample, called `AllChapters`, which includes
    every sample in a single application. There is a `Bin` ZIP file that contains
    a pre-compiled executable of the `AllChapters` sample.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中提供的所有代码都可以在书的可下载内容中找到。有一个名为`AllChapters`的大型示例，其中包含单个应用程序中的每个示例。有一个`Bin` ZIP文件，其中包含`AllChapters`示例的预编译可执行文件。
- en: There are also individual folders for each chapter that contain multiple sub-folders.
    Every chapter contains `Sample00`, which is the code as it was written in the
    book with no additional content. The subsequently numbered samples add content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节还包含多个子文件夹的单独文件夹。每个章节都包含`Sample00`，这是书中编写的代码，没有额外的内容。随后编号的示例添加了内容。
- en: 'The `AllChapters` sample looks a bit different from the samples in the individual
    chapter folders. This application uses Nuklear ([https://github.com/vurtun/nuklear](https://github.com/vurtun/nuklear))
    to display its UI. The part of the UI that is displayed is a stats counter in
    the upper-right corner of the screen. It looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllChapters`示例看起来与各个章节文件夹中的示例有些不同。该应用程序使用Nuklear ([https://github.com/vurtun/nuklear](https://github.com/vurtun/nuklear))
    来显示其用户界面。显示的用户界面部分是屏幕右上角的统计计数器。它看起来像这样：'
- en: '![Figure 1.5: Stats counter for the AllChapters sample'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：AllChapters示例的统计计数器'
- en: '](img/Figure_1.5_B16191.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.5_B16191.jpg)'
- en: 'Figure 1.5: Stats counter for the AllChapters sample'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：AllChapters示例的统计计数器
- en: The top box contains some general information about the display that the application
    opened on. This information contains the display frequency, whether `vsynch` is
    enabled, and what the frame budget is in milliseconds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部框包含有关应用程序打开的显示器的一些常规信息。这些信息包括显示频率、是否启用`vsynch`以及以毫秒为单位的帧预算。
- en: The second box down contains high-level frame timings. The time displayed will
    turn red if there was a stale frame in the last 60 frames. Some stale frames are
    unavoidable; if the frame rate drops to 59.9, the text will show red for a second.
    Seeing red here occasionally is OK; it's only a concern if the numbers are solid
    red.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的第二个框包含高级帧定时。如果在最近的60帧中有一帧过时，显示的时间将变成红色。一些过时的帧是不可避免的；如果帧速率降至59.9，文本将在一秒钟内显示为红色。偶尔在这里看到红色是可以接受的；只有当数字完全变成红色时才会引起关注。
- en: The third box down contains two GPU timers; these measure how fast the sample
    is running on the GPU. This is useful for debugging any heavy draw calls. The
    final box contains CPU timers, which are helpful for figuring out which phase
    of the problem has a bottleneck.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个框中包含两个GPU定时器；这些定时器测量样本在GPU上的运行速度。这对于调试任何繁重的绘制调用非常有用。最后一个框包含CPU定时器，有助于找出问题的哪个阶段存在瓶颈。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Throughout this book, you will use C++ `stl` containers. The Standard Library
    is a bit slow in debug mode, mostly due to error checking. It's a good idea to
    profile any samples in release mode only.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您将使用C++ `stl`容器。标准库在调试模式下有点慢，主要是由于错误检查。建议仅在发布模式下对任何示例进行性能分析。
- en: These examples should do a fair job of demonstrating what you will learn in
    each of the upcoming chapters. They also provide an example for you to compare
    your code against.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例应该很好地演示了您将在接下来的每一章中学到的内容。它们还为您提供了一个可以与您的代码进行比较的示例。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you explored the process of setting up a new Win32 window.
    An OpenGL 3.3 Core context was set up to render to the window, with `vsynch` enabled.
    You learned about OpenGL loaders and how `glad` can load all the relevant OpenGL
    functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探讨了设置新的Win32窗口的过程。建立了一个OpenGL 3.3核心上下文来渲染窗口，并启用了`vsynch`。您了解了OpenGL加载器以及`glad`如何加载所有相关的OpenGL函数。
- en: This window will serve as a foundation for you to build on; all future samples
    are built on the framework you created in this chapter. In the next chapter, you
    will start to explore some of the math required for rendering and animation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口将作为您构建的基础；所有未来的示例都是基于您在本章中创建的框架。在下一章中，您将开始探索渲染和动画所需的一些数学知识。
