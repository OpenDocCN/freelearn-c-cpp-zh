- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Extended Reality with OpenXR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenXR实现扩展现实
- en: Similar to what Vulkan is for graphics, OpenXR, an integral part of the world
    of **Extended Reality** (**XR**), is an API that serves as a powerful tool for
    implementing XR applications. This chapter provides an overview of OpenXR and
    how to use it in conjunction with Vulkan. We start with a basic introduction to
    OpenXR, explaining its role and significance in XR applications, and follow with
    recipes that may be used to improve your XR applications, such as **single pass
    multiview** rendering, a technique that optimizes the rendering of stereo scenes.
    The chapter further expands into the realm of foveated rendering, a method that
    significantly bolsters **Frames Per Second** (**FPS**) by rendering different
    sections of the screen at diverse resolutions. We delve into the implementation
    of this technique using the **fragment shading rate** feature of the Vulkan extension,
    providing you with a practical understanding of its application. Lastly, we delve
    into the use of **half floats**, a practical aid in conserving memory space on
    **Head-Mounted Displays** (**HMDs**). By the end of this chapter, you will have
    gained an understanding of these concepts and will be equipped with the skills
    to apply them effectively in your XR projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vulkan在图形领域的用途类似，OpenXR是**扩展现实**（**XR**）世界的一个组成部分，是一个作为实现XR应用的强大工具的API。本章提供了OpenXR的概述以及如何与Vulkan结合使用。我们从OpenXR的基本介绍开始，解释其在XR应用中的作用和重要性，然后介绍可能用于改进您的XR应用的食谱，例如**单次多视图**渲染，这是一种优化立体场景渲染的技术。本章进一步扩展到注视点渲染的领域，这是一种通过以不同分辨率渲染屏幕的不同部分来显著提高**每秒帧数**（**FPS**）的方法。我们深入探讨了使用Vulkan扩展的**片段着色率**功能实现此技术的实现，为您提供了其实际应用的理解。最后，我们探讨了**半精度浮点数**的使用，这是在**头戴式显示器**（**HMDs**）上节省内存空间的实用工具。到本章结束时，您将了解这些概念，并具备在XR项目中有效应用这些技能的能力。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Getting started with OpenXR
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用OpenXR
- en: How to implement single pass multiview rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现单次多视图渲染
- en: Implementing static foveated rendering with a fragment density map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用片段密度图实现静态注视点渲染
- en: Retrieving eye gaze information from OpenXR in your app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用中从OpenXR检索注视点信息
- en: Implementing dynamic foveated rendering using Qualcomm’s fragment density map
    Offset extension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高通的片段密度图偏移扩展实现动态注视点渲染
- en: Using half floats to reduce memory load
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用半精度浮点数减少内存负载
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to install Android Studio and will also need
    a Meta Quest 2 or Meta Quest Pro to run the **Virtual Reality** (**VR**) sample
    application provided in the repository. Please follow these steps to install the
    tools needed to build, install, and run an application on the device:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要安装Android Studio，并且还需要Meta Quest 2或Meta Quest Pro来运行存储库中提供的**虚拟现实**（**VR**）示例应用。请按照以下步骤安装构建、安装和运行应用程序所需的工具：
- en: Download and install the Android Studio Hedgehog version from [https://developer.android.com/studio/releases](https://developer.android.com/studio/releases).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://developer.android.com/studio/releases](https://developer.android.com/studio/releases)下载并安装Android
    Studio Hedgehog版本。
- en: We also recommend installing the Meta Quest developer hub from [https://developer.oculus.com/downloads/package/oculus-developer-hub-win](https://developer.oculus.com/downloads/package/oculus-developer-hub-win).
    This tool provides several features that help the development of XR applications.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还建议安装Meta Quest开发者中心，从[https://developer.oculus.com/downloads/package/oculus-developer-hub-win](https://developer.oculus.com/downloads/package/oculus-developer-hub-win)。此工具提供了一些有助于XR应用开发的特性。
- en: 'Please follow the steps outlined in the following link to make sure that your
    device is developer-ready—that is, you can debug, deploy, and test VR apps: [https://developer.oculus.com/documentation/native/android/mobile-device-setup/](https://developer.oculus.com/documentation/native/android/mobile-device-setup/).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请按照以下链接中概述的步骤操作，以确保您的设备已准备好进行开发——也就是说，您可以调试、部署和测试VR应用：[https://developer.oculus.com/documentation/native/android/mobile-device-setup/](https://developer.oculus.com/documentation/native/android/mobile-device-setup/).
- en: To launch the project, simply launch Android Studio and open this chapter's
    `project` folder located in `source/chapter8` directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动项目，只需启动Android Studio并打开位于`source/chapter8`目录中的本章`project`文件夹。
- en: Getting started with OpenXR
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用OpenXR
- en: 'Before we dive into how our application code is structured, let’s talk about
    some important OpenXR concepts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨我们的应用程序代码结构之前，让我们讨论一些重要的 OpenXR 概念：
- en: '`XrInstance`: This is the starting point for an OpenXR application. It represents
    the application’s connection to an OpenXR runtime. It is the first object you
    create and the last thing you destroy.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrInstance`：这是 OpenXR 应用程序的起点。它表示应用程序与 OpenXR 运行时的连接。它是您创建的第一个对象，也是您最后销毁的对象。'
- en: '`XrSystemId`: After creating an instance, the application queries for a system
    ID, which represents a specific device or group of devices, such as a VR headset.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrSystemId`：在创建实例后，应用程序查询系统 ID，它代表一个特定的设备或设备组，例如 VR 头盔。'
- en: '`XrViewConfigurationType`: This is used to select a view configuration that
    the application will use to display images. Different configurations can represent
    different display setups, such as monoscopic, stereoscopic, and so on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrViewConfigurationType`：这用于选择应用程序将用于显示图像的视图配置。不同的配置可以表示不同的显示设置，例如单视图、立体视图等。'
- en: '`XrSession`: Once the instance is set up and the system ID and view configuration
    are determined, a session is created. A session represents the application’s interaction
    with a device. The session manages the life cycle, rendering parameters, and input
    data for the device.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrSession`：一旦设置了实例并确定了系统 ID 和视图配置，就会创建一个会话。会话表示应用程序与设备之间的交互。会话管理设备的生命周期、渲染参数和输入数据。'
- en: '`XrSpace`: Spaces represent coordinate systems within the XR environment. They
    are used to position objects in 3D space.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrSpace`：Spaces 代表 XR 环境中的坐标系。它们用于在 3D 空间中定位对象。'
- en: '`XrSwapchain`: A swapchain is a collection of textures used to buffer images
    for display. After the session has been established, the swapchain is created
    to handle the rendering.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XrSwapchain`：swapchain 是一组用于缓冲显示图像的纹理。在会话建立后，swapchain 被创建来处理渲染。'
- en: '`xrBeginFrame` and `xrEndFrame`: These are functions used to start and end
    the rendering of a frame. The `xrBeginFrame` function signals the start of a rendering
    frame, and `xrEndFrame` signals the end of a frame. They are called for each frame
    in the render loop.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xrBeginFrame` 和 `xrEndFrame`：这些是用于开始和结束帧渲染的函数。`xrBeginFrame` 函数表示渲染帧的开始，而
    `xrEndFrame` 函数表示帧的结束。它们在渲染循环中的每一帧都会被调用。'
- en: '*Figure 8**.1* depicts the basic idea about how to use OpenXR:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 8.1* 展示了如何使用 OpenXR 的基本概念：'
- en: '![Figure 8.1 – OpenXR object interaction diagram](img/B18491_08_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – OpenXR 对象交互图](img/B18491_08_01.jpg)'
- en: Figure 8.1 – OpenXR object interaction diagram
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – OpenXR 对象交互图
- en: In this recipe, we will learn about the main OpenXR initialization events, and
    which functions we need to use to render a frame and display them on a device.
    The recipe will also cover how the OpenXR code is handled in the repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解主要的 OpenXR 初始化事件，以及我们需要使用哪些函数来渲染帧并在设备上显示它们。该菜谱还将涵盖 OpenXR 代码在存储库中的处理方式。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first step in creating an OpenXR application involves setting up an `XrInstance`.
    This instance is the primary connection between your application and the OpenXR
    runtime. To create an `XrInstance`, you’ll need to call the `xrCreateInstance`
    function. Before you do this, you will need to decide which extensions your application
    requires. At the very least, your application will need to enable a graphics binding
    extension, which specifies the graphics API that will be used. You can also use
    `xrEnumerateInstanceExtensionProperties` to enumerate all extensions supported
    by the platform. Additionally, before calling `xrCreateInstance`, you will need
    to populate the `XrApplicationInfo` structure. This structure holds essential
    details about your application, such as the application’s name, engine name, and
    version information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 OpenXR 应用程序的第一步是设置一个 `XrInstance`。这个实例是您的应用程序与 OpenXR 运行时之间的主要连接。要创建一个
    `XrInstance`，您需要调用 `xrCreateInstance` 函数。在这样做之前，您需要决定您的应用程序需要哪些扩展。至少，您的应用程序需要启用一个图形绑定扩展，该扩展指定了将要使用的图形
    API。您还可以使用 `xrEnumerateInstanceExtensionProperties` 来枚举平台支持的所有扩展。此外，在调用 `xrCreateInstance`
    之前，您还需要填充 `XrApplicationInfo` 结构。这个结构包含有关您的应用程序的基本详细信息，例如应用程序的名称、引擎名称和版本信息。
- en: After these details are set, you can call `xrCreateInstance`, which will return
    an instance handle upon successful creation. Following the creation of the `XrInstance`,
    the next step involves querying for a `SystemId` and selecting an `XrViewConfigurationView`.
    The `SystemId` represents a specific XR device or a group of devices, such as
    a VR headset, and it can be retrieved using the `xrGetSystem` function. `XrViewConfigurationView`,
    on the other hand, allows you to choose the view configuration that your application
    will use for displaying images. This could range from monoscopic to stereoscopic
    configurations, depending on your device type. In the recipes in this chapter,
    we will be using the stereo view by specifying `XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些细节之后，你可以调用`xrCreateInstance`，它将在成功创建后返回一个实例句柄。在创建`XrInstance`之后，下一步涉及查询`SystemId`并选择一个`XrViewConfigurationView`。`SystemId`代表一个特定的XR设备或一组设备，如VR头戴式设备，可以使用`xrGetSystem`函数检索。另一方面，`XrViewConfigurationView`允许你选择应用程序用于显示图像的视图配置。这可以从单眼到立体配置不等，具体取决于你的设备类型。在本章的食谱中，我们将通过指定`XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO`来使用立体视图。
- en: The next step is to create a instance of `XrSession`. A `XrSession` represents
    your application’s active interaction with the XR device. It handles the rendering
    parameters, input data, and overall life cycle of the application’s interaction
    with the device. To create an `XrSession`, we will need to fill the graphics binding
    information in `XrSessionCreateInfo`. Since we are using Vulkan, we will specify
    graphics binding using the `XrGraphicsBindingVulkanKHR` structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`XrSession`实例。`XrSession`代表你的应用程序与XR设备之间的活跃交互。它处理渲染参数、输入数据以及应用程序与设备交互的整体生命周期。要创建一个`XrSession`，我们需要在`XrSessionCreateInfo`中填写图形绑定信息。由于我们使用Vulkan，我们将使用`XrGraphicsBindingVulkanKHR`结构指定图形绑定。
- en: 'Tracking spatial relationships is very important in XR platforms. An instance
    of `XrSpace` class represent something that is being tracked by the XR system.
    To interact with tracked objects, we will use `XrSpace` handles. Several spaces
    are known as reference spaces, which can be accessed using sessions and enumerations.
    There are three types of reference spaces in OpenXR:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在XR平台上跟踪空间关系非常重要。`XrSpace`类的一个实例代表XR系统正在跟踪的东西。为了与跟踪对象交互，我们将使用`XrSpace`句柄。有几个空间被称为参考空间，可以通过会话和枚举来访问。OpenXR中有三种类型的参考空间：
- en: '`XR_REFERENCE_SPACE_TYPE_LOCAL`: Seated or static space'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XR_REFERENCE_SPACE_TYPE_LOCAL`：坐着或静态空间'
- en: '`XR_REFERENCE_SPACE_TYPE_VIEW`: Head locked space'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XR_REFERENCE_SPACE_TYPE_VIEW`：头部锁定空间'
- en: '`XR_REFERENCE_SPACE_TYPE_STAGE`: An area bounded by an environment in which
    the user can move around'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XR_REFERENCE_SPACE_TYPE_STAGE`：由环境包围的区域，用户可以在其中移动'
- en: To get an `XrSpace` from these enumerations, you will use `xrCreateReferenceSpace`.
    Another kind of space you can create is `xrCreateActionSpace`, which is used when
    you need to create a space from a pose action. For instance, we use it to create
    an `XrSpace` for gaze location and orientation. `xrLocateSpace` is an API which
    is used to determine transform relative to other spaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这些枚举中获取`XrSpace`，你将使用`xrCreateReferenceSpace`。另一种你可以创建的空间是`xrCreateActionSpace`，当你需要从一个姿态动作创建空间时使用。例如，我们用它来创建注视位置和方向的`XrSpace`。`xrLocateSpace`是一个API，用于确定相对于其他空间的位置转换。
- en: To render graphics, we will need to create a swapchain, just like in Vulkan.
    To create one, you need to call `xrCreateSwapchain`. Next, we will use `xrEnumerateSwapchainImages`
    to acquire multiple `XrSwapchainImageVulkanKHR` instances that hold a reference
    to `vkImage`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染图形，我们需要创建一个swapchain，就像在Vulkan中一样。要创建一个swapchain，你需要调用`xrCreateSwapchain`。接下来，我们将使用`xrEnumerateSwapchainImages`来获取多个`XrSwapchainImageVulkanKHR`实例，这些实例持有对`vkImage`的引用。
- en: In OpenXR, a key concept is that of layers. Imagine layers as distinct sections
    or elements of the final rendered scene in a virtual or augmented reality experience.
    Rather than presenting a flat, single-image view, OpenXR creates a multi-dimensional
    perspective by independently rendering each layer and then compositing them to
    form the final image. The most frequently used layer is `XrCompositionLayerProjection`.
    This layer is responsible for rendering the main scene. To create a sense of depth
    and immersion typical of VR experiences, this layer incorporates multiple views—one
    for each eye in a VR headset. This arrangement produces a stereoscopic 3D effect.
    But `XrCompositionLayerProjection` isn’t the only layer at work. OpenXR also employs
    layers such as `XrCompositionLayerQuad`, `XrCompositionLayerCubeKHR`, and `XrCompositionLayerEquirectKHR`.
    Each of these plays a unique role in enhancing the rendering of the final image.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenXR中，一个关键概念是层。想象一下，层是虚拟或增强现实体验中最终渲染场景的独立部分或元素。OpenXR不是呈现一个平坦的单图像视图，而是通过独立渲染每个层并将它们组合成最终图像来创建一个多维视角。最常用的层是`XrCompositionLayerProjection`。这个层负责渲染主场景。为了创建类似于VR体验的深度和沉浸感，这个层结合了多个视图——每个VR头戴式设备中的一个眼睛的视图。这种安排产生了一个立体3D效果。但`XrCompositionLayerProjection`并不是唯一工作的层。OpenXR还使用了诸如`XrCompositionLayerQuad`、`XrCompositionLayerCubeKHR`和`XrCompositionLayerEquirectKHR`之类的层。这些中的每一个都在增强最终图像的渲染中扮演着独特的角色。
- en: 'Now we will move to the render loop; the application render loop consists of
    three main functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向渲染循环；应用程序的渲染循环由三个主要函数组成：
- en: '`xrWaitFrame` blocks until the OpenXR runtime determines that it’s the right
    time to start the next frame. This includes computations and rendering based on
    the user’s head pose.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xrWaitFrame`会阻塞，直到OpenXR运行时确定开始下一帧是正确的时间。这包括基于用户头部姿态的计算和渲染。'
- en: '`xrBeginFrame` is called by the application to mark the start of rendering
    for the given frame.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xrBeginFrame`由应用程序调用，以标记给定帧的渲染开始。'
- en: '`xrEndFrame` submits the frame for display.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xrEndFrame`提交帧以进行显示。'
- en: 'The next part is acquiring and releasing swapchain images: `xrAcquireSwapchainImage`
    gives the index of the current swapchain image but it doesn’t give you permission
    to write to the image. To write to the swapchain image, you will need to call
    `xrWaitSwapchainImage`. `xrReleaseSwapchainImage` is called just before `xrEndFrame`,
    before the rendering is done. `xrEndFrame` will use the most recently released
    swapchain image for displaying to the device.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是获取和释放swapchain图像：`xrAcquireSwapchainImage`提供了当前swapchain图像的索引，但它并不授予您写入图像的权限。要写入swapchain图像，您需要调用`xrWaitSwapchainImage`。`xrReleaseSwapchainImage`在`xrEndFrame`之前调用，在渲染完成之前。`xrEndFrame`将使用最近释放的swapchain图像来显示到设备上。
- en: The last important call is `xrPollEvents`, which is used to retrieve events
    from the event queue. Events in OpenXR represent various types of occurrences,
    such as changes in session state, input from the user, or changes in the environment.
    For instance, an event might be generated when the user puts on or takes off their
    headset, when they press a button on a controller, or when the tracking system
    loses or regains sight of a tracked object. It’s usually called once a frame.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的调用是`xrPollEvents`，它用于从事件队列中检索事件。OpenXR中的事件代表各种类型的发生，例如会话状态的变化、用户的输入或环境的变化。例如，当用户戴上或取下他们的头戴式设备、按下控制器上的按钮或跟踪系统失去或重新获得对跟踪对象的视线时，可能会生成一个事件。它通常每帧调用一次。
- en: In the repository, the code for OpenXR is encapsulated in the `OXR::Context`
    and `OXR::OXRSwapchain` classes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，OpenXR的代码封装在`OXR::Context`和`OXR::OXRSwapchain`类中。
- en: How to do it…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `OXR::Context` class in the repository manages most of OpenXR calls and
    states. In this recipe, we will show you the details of these functions and how
    to use them to initialize the OpenXR sample app in the repository:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的`OXR::Context`类管理了大多数OpenXR调用和状态。在这个菜谱中，我们将向您展示这些函数的详细信息以及如何使用它们来初始化仓库中的OpenXR示例应用：
- en: 'The `OXR::Context::initializeExtensions` method finds the extensions available
    in the OpenXR runtime and filters out the requested extensions that aren’t supported.
    Once the available extensions are fetched, it iterates through the requested extensions,
    eliminating any that aren’t available. That results in a list of extensions that
    are both requested and supported:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OXR::Context::initializeExtensions` 方法查找 OpenXR 运行时中可用的扩展，并过滤掉不受支持的请求扩展。一旦获取到可用的扩展，它将遍历请求的扩展，消除任何不可用的扩展。这导致了一个同时请求和受支持的扩展列表：'
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Context::createInstance()` method is responsible for creating an OpenXR
    instance with basic application information and the extension details:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::createInstance()` 方法负责使用基本应用程序信息和扩展详细信息创建一个 OpenXR 实例：'
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Context::systemInfo` method retrieves and stores the properties of the
    OpenXR system for a head-mounted display. It fetches the system ID and its properties,
    including system name, vendor ID, graphics properties, tracking properties, and
    eye gaze support:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::systemInfo` 方法检索并存储头戴式显示器的 OpenXR 系统属性。它获取系统 ID 及其属性，包括系统名称、供应商 ID、图形属性、跟踪属性和视线支持：'
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Context::enumerateViewConfigurations` function enumerates all the view
    configurations supported by the system and then selects and stores properties
    of the one that matches the predefined supported configuration. If the selected
    configuration supports the required number of viewports, it stores the configuration
    properties and the view configuration views.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::enumerateViewConfigurations` 函数枚举系统支持的所有视图配置，然后选择并存储与预定义支持的配置匹配的配置属性。如果所选配置支持所需数量的视口，它将存储配置属性和视图配置视图。'
- en: 'The `Context::initGraphics` function is designed to initialize the graphics
    requirements for Vulkan. It achieves this by obtaining key components such as
    the Vulkan instance and device extensions. `xrGetVulkanInstanceExtensionsKHR`
    and `xrGetVulkanDeviceExtensionsKHR` are functions used in the OpenXR API to retrieve
    the names of Vulkan instance and device extensions, respectively, that are needed
    by a particular OpenXR runtime:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::initGraphics` 函数旨在初始化 Vulkan 的图形需求。它通过获取关键组件，如 Vulkan 实例和设备扩展来实现这一点。`xrGetVulkanInstanceExtensionsKHR`
    和 `xrGetVulkanDeviceExtensionsKHR` 是 OpenXR API 中使用的函数，分别用于检索特定 OpenXR 运行时所需的
    Vulkan 实例和设备扩展的名称：'
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Context::initializeSession` function creates a new OpenXR session. It
    begins by creating an `XrGraphicsBindingVulkanKHR` object, which is used to bind
    Vulkan to the XR session. This object is populated with the Vulkan instance, physical
    device, and device, as well as the queue family index. This information allows
    the OpenXR runtime to interface with the Vulkan API. Then, an `XrSessionCreateInfo`
    object is created, which is used to specify the parameters for creating a new
    session. This object attributes are populated with the nature of the session to
    be created, the graphics binding, and the system ID. Finally, the `xrCreateSession`
    function is called to create the session:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::initializeSession` 函数创建一个新的 OpenXR 会话。它首先创建一个 `XrGraphicsBindingVulkanKHR`
    对象，该对象用于将 Vulkan 绑定到 XR 会话。该对象包含 Vulkan 实例、物理设备和设备，以及队列家族索引。这些信息允许 OpenXR 运行时与
    Vulkan API 交互。然后，创建一个 `XrSessionCreateInfo` 对象，用于指定创建新会话的参数。该对象的属性填充了要创建的会话的性质、图形绑定和系统
    ID。最后，调用 `xrCreateSession` 函数来创建会话：'
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Context::enumerateReferenceSpaces` function retrieves the types of reference
    spaces available for the current OpenXR session. It calls `xrEnumerateReferenceSpaces`
    to fill a vector of `XrReferenceSpaceType` structures with the available reference
    space types. Finally, it checks whether the `XR_REFERENCE_SPACE_TYPE_STAGE` type
    is available and stores this information in the `stageSpaceSupported_` variable.
    The `XR_REFERENCE_SPACE_TYPE_STAGE` type represents a standing-scale experience
    where the user has a small amount of room to move around.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::enumerateReferenceSpaces` 函数检索当前 OpenXR 会话可用的参考空间类型。它调用 `xrEnumerateReferenceSpaces`
    以填充一个包含 `XrReferenceSpaceType` 结构的向量，这些结构表示可用的参考空间类型。最后，它检查 `XR_REFERENCE_SPACE_TYPE_STAGE`
    类型是否可用，并将此信息存储在 `stageSpaceSupported_` 变量中。`XR_REFERENCE_SPACE_TYPE_STAGE` 类型代表一种站立式体验，用户有少量空间可以移动。'
- en: 'The `Context::createSwapchains` function is responsible for creating the swapchains
    needed for rendering. Based on the value of `useSinglePassStereo_`, it either
    creates a single swapchain that will be used for both views (in case of single-pass
    stereo rendering), or separate swapchains for each view. For each swapchain, it
    creates a new `OXRSwapchain` instance. The `OXRSwapchain` constructor is called
    with the Vulkan context, the OpenXR session, the viewport for the swapchain, and
    the number of views per swapchain. We call the `initialize` function to initialize
    the `OXRSwapchain` instance. The `initialize` function in the `OXRSwapchain` class
    sets up the color and depth swapchains for an OpenXR session by calling the `xrCreateSwapchain`
    function. Once `XrSwapchain` is created, we call `enumerateSwapchainImages` in
    `OXRSwapchain`, which is responsible for creating a vector of `XrSwapchainImageVulkanKHR`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context::createSwapchains` 函数负责创建渲染所需的 swapchain。根据 `useSinglePassStereo_`
    的值，它要么创建一个将用于两个视图的单一 swapchain（在单次通行立体渲染的情况下），要么为每个视图创建单独的 swapchain。对于每个 swapchain，它创建一个新的
    `OXRSwapchain` 实例。`OXRSwapchain` 构造函数使用 Vulkan 上下文、OpenXR 会话、swapchain 视口和每个 swapchain
    的视图数进行调用。我们调用 `initialize` 函数来初始化 `OXRSwapchain` 实例。`OXRSwapchain` 类中的 `initialize`
    函数通过调用 `xrCreateSwapchain` 函数为 OpenXR 会话设置颜色和深度 swapchain。一旦创建了 `XrSwapchain`，我们在
    `OXRSwapchain` 中调用 `enumerateSwapchainImages`，它负责创建一个 `XrSwapchainImageVulkanKHR`
    向量：'
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`OXRSwapchain` also provides functions such as `getSurfaceTexture` and `releaseSwapchainImages`.
    `getSurfaceTexture` is responsible for acquiring a swapchain by calling `xrAcquireSwapchainImage`
    and `xrWaitSwapchainImage`.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OXRSwapchain` 还提供了诸如 `getSurfaceTexture` 和 `releaseSwapchainImages` 等功能。`getSurfaceTexture`
    通过调用 `xrAcquireSwapchainImage` 和 `xrWaitSwapchainImage` 来获取 swapchain。'
- en: 'Before starting to render, `OXR::Context::beginFrame` first synchronizes frame
    submission with the display by calling `xrWaitFrame`, which returns an `XrFrameState`
    structure. The frame state specifies a predicted display time when the runtime
    predicts a frame will be displayed. The function also calls `xrBeginFrame`, which
    must be called before rendering starts, and retrieves some other important information,
    such as the head and view poses, and calculates view and camera transformations:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始渲染之前，`OXR::Context::beginFrame` 首先通过调用 `xrWaitFrame` 与显示进行帧提交同步，该函数返回一个 `XrFrameState`
    结构。帧状态指定了当运行时预测帧将被显示时的预测显示时间。该函数还调用 `xrBeginFrame`，必须在渲染开始之前调用，并检索一些其他重要信息，例如头部和视图姿态，并计算视图和相机变换：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once rendering has been completed, the application must call the `OXR::endFrame`
    method, which in turn calls `xrEndFrame`. The `XrFrameEndInfo` structure specifies
    the type of layer being presented (and its flags) and its associated spaces (with
    its poses and field of view angles and maybe depth information) and how the image(s)
    should be blended with underlying layers. Note that, for the sake of conciseness,
    only the critical sections of the code are displayed here. For a comprehensive
    understanding, please refer to the full code in the original source:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦渲染完成，应用程序必须调用 `OXR::endFrame` 方法，该方法反过来调用 `xrEndFrame`。`XrFrameEndInfo` 结构指定了正在呈现的层类型（及其标志）及其关联的空间（及其姿态、视场角度和可能深度信息），以及图像（们）应该如何与底层层混合。请注意，为了简洁起见，这里只显示了代码的关键部分。为了全面理解，请参阅原始源代码中的完整代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `android_main` function, outside of the `OXR::Context` class, serves as
    the main entry point for a native Android activity. It initializes both OpenXR
    (`oxrContext`) and Vulkan (`vkContext`) contexts and sets up their required extensions
    and features. After creating an instance, it establishes a session and creates
    swapchains for rendering. Shader modules for vertex and fragment shaders are also
    created. The function then enters a loop where it handles OpenXR events, begins
    a frame, carries out rendering actions, and ends the frame. This loop continues
    until the app is requested to be destroyed. Please note that, for brevity, a significant
    amount of detail has been omitted from this summary. You are encouraged to review
    the actual code in the repository for a comprehensive understanding:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android_main` 函数位于 `OXR::Context` 类之外，它是原生 Android 活动的入口点。它初始化 OpenXR (`oxrContext`)
    和 Vulkan (`vkContext`) 上下文，并设置它们所需的扩展和功能。创建实例后，它建立会话并为渲染创建 swapchain。还创建了顶点和片段着色器的着色器模块。然后该函数进入一个循环，处理
    OpenXR 事件，开始帧，执行渲染操作，并结束帧。这个循环会一直持续到应用程序被请求销毁。请注意，为了简洁，这里省略了大量的细节。鼓励您查看存储库中的实际代码以获得全面的理解：'
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This recipe involves a sequence of steps starting from initializing the OpenXR
    and Vulkan contexts to entering a game event loop for handling OpenXR events and
    rendering. The process is intricate and involves enabling specific features, handling
    graphics commands, and managing frames. This guide has provided a simplified overview,
    and we strongly recommend reviewing the full code in the repository for a complete
    understanding.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方涉及一系列步骤，从初始化OpenXR和Vulkan上下文到进入游戏事件循环以处理OpenXR事件和渲染。这个过程很复杂，涉及启用特定功能、处理图形命令和管理帧。本指南已提供简化的概述，我们强烈建议您查看存储库中的完整代码以获得全面理解。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'For more details, please refer to the OpenXR guide by Khronos:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多详细信息，请参阅Khronos的OpenXR指南：
- en: '[https://www.khronos.org/files/openxr-10-reference-guide.pdf](https://www.khronos.org/files/openxr-10-reference-guide.pdf)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/files/openxr-10-reference-guide.pdf](https://www.khronos.org/files/openxr-10-reference-guide.pdf)'
- en: How to implement single pass multiview rendering
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现单遍历多视图渲染
- en: XR devices must render scenes at least twice for each frame, generating one
    image for each eye. Single pass multiview rendering is a technique used to enhance
    the performance of XR applications by allowing the rendering of multiple views
    in a single pass. This effectively enables the rendering of the scene from both
    eye’s perspectives with one draw call.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: XR设备必须为每个帧至少渲染两次场景，为每只眼睛生成一个图像。单遍历多视图渲染是一种技术，通过允许在单个遍历中渲染多个视图来提高XR应用程序的性能。这实际上通过一个绘制调用实现了从双眼视角渲染场景。
- en: In this recipe, we will navigate how to enable the Multiview rendering feature
    in Vulkan and how to use it to render the scene for both eyes in one render pass.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将介绍如何在Vulkan中启用多视图渲染功能，以及如何使用它在一个渲染遍历中渲染双眼的场景。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the context of Vulkan, the `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES`
    extension specifies whether multiple views are supported in a single rendering
    pass. Once the feature is enabled, you can specify multiple viewports and scissor
    rectangles for your rendering pass. The graphics pipeline will then render the
    scene from different perspectives in a single pass, reducing the need for duplicate
    operations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan的上下文中，`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES`扩展指定是否在单个渲染遍历中支持多个视图。一旦启用该功能，您可以为您的渲染遍历指定多个视口和裁剪矩形。然后图形管线将在单个遍历中从不同的视角渲染场景，从而减少重复操作的需求。
- en: Besides enabling a Vulkan extension, you will also need to enable the `GL_EXT_multiview`
    extension in your shader code. `GL_EXT_multiview` is a GLSL extension that allows
    multiple views to be rendered in a single pass. `GL_EXT_multiview` introduces
    a new built-in variable, `gl_ViewIndex`, that can be used in your shaders to determine
    which view is being rendered. It contains the index of the current view being
    processed and can be used to adjust your drawing based on the view index (for
    instance, index `0` may represent the left eye, while index `1` can represent
    the right eye).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启用Vulkan扩展外，您还需要在着色器代码中启用`GL_EXT_multiview`扩展。`GL_EXT_multiview`是一个GLSL扩展，允许在单个遍历中渲染多个视图。`GL_EXT_multiview`引入了一个新的内置变量`gl_ViewIndex`，可以在您的着色器中使用，以确定正在渲染哪个视图。它包含正在处理的当前视图的索引，并且可以根据视图索引调整您的绘制（例如，索引`0`可能代表左眼，而索引`1`可能代表右眼）。
- en: We also need the ability to query whether multiview is supported by hardware
    or not using `VkPhysicalDeviceMultiviewFeatures`. Additionally, we need to specify
    that we will be using multiple views when creating the render pass. This is done
    by adding an instance of the `VkRenderPassMultiviewCreateInfo` structure to the
    `pNext` chain of the `VkRenderPassCreateInfo` structure. One other important part
    is that swapchain images need to have multiple layers (in our case, two—one for
    each eye), and the results of the rendering go to different layers of the attachments.
    You may think that we could have rendered the same scene twice (one for left and
    one for right), but that would mean we build a command buffer that sends all the
    geometry and textures twice. This extension helps us send data only once and only
    shaders are fired twice (for each view ID). The only difference between these
    two executions is uniform data for the camera.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用 `VkPhysicalDeviceMultiviewFeatures` 来查询硬件是否支持多视图。此外，在创建渲染通道时，我们需要指定我们将使用多个视图。这是通过将
    `VkRenderPassMultiviewCreateInfo` 结构体的一个实例添加到 `VkRenderPassCreateInfo` 结构体的 `pNext`
    链中实现的。另一个重要部分是，交换链图像需要具有多个层（在我们的例子中，是两个——每个眼睛一个），渲染的结果将发送到附件的不同层。你可能认为我们可以渲染相同的场景两次（一个用于左眼，一个用于右眼），但这意味着我们需要构建一个命令缓冲区，将所有几何和纹理发送两次。这个扩展帮助我们只发送一次数据，并且只有着色器被触发两次（对于每个视图ID）。这两个执行之间的唯一区别是摄像机的统一数据。
- en: To support multiview, code changes are required in various areas of the code
    base. In this case, we needed to change `Texture`, `RenderPass`, `Context` classes,
    and shader files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多视图，需要在代码库的各个区域进行代码更改。在这种情况下，我们需要更改 `Texture`、`RenderPass`、`Context` 类和着色器文件。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we will go through details on how to implement this
    recipe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将详细介绍如何实现这个菜谱：
- en: Extend `VulkanCore::Texture` to support `vkImageView` created using `VK_IMAGE_VIEW_TYPE_2D_ARRAY`;
    this is necessary if we have multiple layers in the same texture.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `VulkanCore::Texture` 扩展以支持使用 `VK_IMAGE_VIEW_TYPE_2D_ARRAY` 创建的 `vkImageView`；如果我们有同一纹理中的多个层，这是必要的。
- en: Add support for multiview in `VulkanCore::RenderPass`; this is achieved by connecting
    `VkRenderPassMultiviewCreateInfo` to `VkRenderPassCreateInfo`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VulkanCore::RenderPass` 中添加对多视图的支持；这是通过将 `VkRenderPassMultiviewCreateInfo`
    连接到 `VkRenderPassCreateInfo` 来实现的。
- en: Add support to enable multiview extension in `VulkanCore::Context`; this is
    abstracted in a function named `enableMultiView`, which simply enables `VkPhysicalDeviceMultiviewFeatures`
    if it is supported by a physical device.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VulkanCore::Context` 中添加支持以启用多视图扩展；这通过一个名为 `enableMultiView` 的函数实现，该函数简单地启用
    `VkPhysicalDeviceMultiviewFeatures`，如果物理设备支持它的话。
- en: The vertex shader is now passed two `Context::mvp(index)` was introduced, so
    that we can query MVP for the left and right eye.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在顶点着色器传递了两个 `Context::mvp(index)`，这样我们就可以查询左右眼的 MVP。
- en: We also introduced a constant named `kUseSinglePassStereo` that can be used
    to control whether we want to use a single pass or not.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还引入了一个名为 `kUseSinglePassStereo` 的常量，可以用来控制我们是否想要使用单通道。
- en: Given that the code is distributed across various files, we strongly suggest
    delving into the repository for a comprehensive review of the implementation.
    Specifically, the file located at `source/chapter8/app/src/main/cpp/main.cpp`
    should warrant your particular attention.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码分布在各个文件中，我们强烈建议深入研究存储库，以全面审查实现。特别是位于 `source/chapter8/app/src/main/cpp/main.cpp`
    的文件应引起你的特别注意。
- en: Implementing static foveated rendering with a fragment density map
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段密度图实现静态注视点渲染
- en: '**Foveated rendering** is a cutting-edge graphics rendering technique that
    leverages the human eye’s natural tendency to focus on specific regions of a scene,
    optimizing computational resources by allocating higher detail and resolution
    to the central, foveal vision, and progressively reducing it toward the peripheral
    vision. This mimics the way the human eye perceives detail, offering a substantial
    performance boost in graphics rendering without sacrificing visual quality.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注视点渲染**是一种前沿的图形渲染技术，它利用了人眼自然倾向于聚焦于场景特定区域的特点，通过将更高细节和分辨率分配给中央的注视点视觉，并逐渐减少对周边视觉的分配，从而优化计算资源。这模仿了人眼感知细节的方式，在图形渲染中提供了显著的性能提升，同时不牺牲视觉质量。'
- en: In this recipe, we will see how to implement fixed foveated rendering by using
    the **fragment density map** (**FDM**) extension.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何通过使用 **片段密度图**（**FDM**）扩展来实现固定注视点渲染。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The FDM device extension in Vulkan (`VK_EXT_fragment_density`) enables an application
    to specify different levels of detail to use in different areas of the render
    target by means of a texture that encodes how many times a fragment shader will
    be invoked for that area. The FDM may be modified on each frame to accommodate
    the user’s eye gaze direction. This recipe only works with HMDs that provide eye
    gaze detection, such as Meta’s Quest Pro. The recipe presented here works for
    a single-pass stereo rendering approach.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中的FDM设备扩展（`VK_EXT_fragment_density`）允许应用程序通过一个纹理来指定渲染目标不同区域使用不同细节级别，该纹理编码了片段着色器将对该区域调用多少次。FDM可以在每一帧中修改，以适应用户的视线方向。此配方仅适用于提供视线检测的HMD，如Meta的Quest
    Pro。此处提供的配方适用于单次传递立体渲染方法。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before creating and using an FDM and the FDM Offset extension, we need to enable
    the extensions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和使用FDM及其FDM偏移扩展之前，我们需要启用这些扩展：
- en: Before enabling the feature, it is necessary to check whether the physical device
    supports it. Doing so requires appending an instance of the `VkPhysicalDeviceFragmentDensityMapFeaturesEXT`
    structure to the `pNext` chain of `VkPhysicalDeviceFeatures2` passed to the `vkGetPhysicalDeviceFeatures2`
    function.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用功能之前，有必要检查物理设备是否支持它。这样做需要将一个`VkPhysicalDeviceFragmentDensityMapFeaturesEXT`结构实例添加到传递给`vkGetPhysicalDeviceFeatures2`函数的`VkPhysicalDeviceFeatures2`的`pNext`链中。
- en: '`VkPhysicalDeviceFragmentDensityMapFeaturesEXT:: fragmentDensityMap` specifies
    whether the device supports the FDM extension.'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VkPhysicalDeviceFragmentDensityMapFeaturesEXT::fragmentDensityMap`指定设备是否支持FDM扩展。'
- en: The extension has properties that need to be queried to be used properly. To
    do that, also include an instance of the `VkPhysicalDeviceFragmentDensityMapPropertiesEXT`
    structure to the `pNext` chain of `VkPhysicalDeviceProperties2` and query those
    properties with `vkGetPhysicalDeviceProperties2`. We will use these properties
    in *step 4*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该扩展具有需要查询以正确使用的属性。为此，还需要将一个`VkPhysicalDeviceFragmentDensityMapPropertiesEXT`结构实例添加到`VkPhysicalDeviceProperties2`的`pNext`链中，并使用`vkGetPhysicalDeviceProperties2`查询这些属性。我们将在*步骤4*中使用这些属性。
- en: 'The FDM extension is a device extension and its name needs to be passed in
    during the creation of the `VkDevice` object: `"VK_EXT_fragment_density_map"`
    (or the definition, `VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME`).'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM扩展是设备扩展，其名称需要在创建`VkDevice`对象时传递：`"VK_EXT_fragment_density_map"`（或定义，`VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME`）。
- en: An FDM’s size doesn’t map to the framebuffers on a one-to-one ratio. One texel
    of the map affects an *area* of the render target. This area’s size can be queried
    from `VkPhysicalDeviceFragmentDensityMapPropertiesEXT`, from the `minFragmentDensityTexelSize`
    and `maxFragmentDensityTexelSize` properties.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM的大小不会按一对一的比例映射到帧缓冲区。地图中的一个texel会影响渲染目标的一个*区域*。这个区域的大小可以从`VkPhysicalDeviceFragmentDensityMapPropertiesEXT`中查询，从`minFragmentDensityTexelSize`和`maxFragmentDensityTexelSize`属性中获取。
- en: 'In our recipe, we will create an FDM with texels that map to an area that is
    at least 32 x 32 of the render target, bounded by `minFragmentDensityTexelSize`:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们将创建一个FDM，其texel映射到至少为渲染目标32 x 32的区域，由`minFragmentDensityTexelSize`限制：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An FDM is a regular texture with some special usage flags:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM是一种具有一些特殊使用标志的常规纹理：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The format of the texture is `VK_FORMAT_R8G8_UNORM`. Each pixel stored in the
    map specifies the density of fragments to be used for that area of the render
    target, where `255` means the density should be the highest (or the default: one
    fragment per render target’s pixel; `128` for half the density, and so on). In
    our recipe, our map is initialized to `128` (half density) and then manipulated
    to have an area in the center with a radius equal to `2` texels with full density:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纹理的格式是`VK_FORMAT_R8G8_UNORM`。地图中存储的每个像素指定了用于渲染目标该区域的片段密度，其中`255`表示密度应该是最高的（或默认值：每个渲染目标的像素一个片段；`128`为半密度，依此类推）。在我们的配方中，我们的地图初始化为`128`（半密度），然后操作以使中心区域具有半径等于`2`个texel的全密度：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the image has two layers, one for each eye. The data is uploaded to
    the device twice, once for each layer of the image.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，图像有两个层，每个眼睛一个。数据被上传到设备两次，一次用于图像的每一层。
- en: Once the data has been uploaded for each layer of the map, the texture’s layout
    needs to be transitioned to the special layout, `VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦地图的每一层数据都已上传，纹理的布局需要过渡到特殊布局，`VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT`。
- en: 'The FDM needs to be specified and referenced by the render pass in a `VkAttachmentDescription`
    structure, just like any other attachment used in the render pass:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM（Fragment Density Map）需要在`VkAttachmentDescription`结构中由渲染通道指定和引用，就像渲染通道中使用的任何其他附件一样：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The FDM must not appear as a color or depth stencil attachment in the `VkSubpassDescription::pColorAttachments`
    or `VkSubpassDescription::pDepthStencilAttachment` arrays. Instead, it must be
    referenced in an instance of the special `VkRenderPassFragmentDensityMapCreateInfoEXT`
    structure:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM不能出现在`VkSubpassDescription::pColorAttachments`或`VkSubpassDescription::pDepthStencilAttachment`数组中的颜色或深度模板附件中。相反，它必须在特殊`VkRenderPassFragmentDensityMapCreateInfoEXT`结构的一个实例中引用：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bug prevention notice
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 故障预防通知
- en: 'The order in which this structure appears in the `VkRenderPassCreateInfo::
    pAttachments` array must match the index of the `VkImage` array passed to `VkFramebufferCreateInfo::pAttachments`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '此结构在`VkRenderPassCreateInfo:: pAttachments`数组中的顺序必须与传递给`VkFramebufferCreateInfo::pAttachments`的`VkImage`数组中的索引相匹配。'
- en: 'The instance of the `VkRenderPassFragmentDensityMapCreateInfoEXT` structure
    needs to be added to the `pNext` chain property of the `VkRenderPassCreateInfo`
    structure:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VkRenderPassFragmentDensityMapCreateInfoEXT`结构的实例需要添加到`VkRenderPassCreateInfo`结构的`pNext`链属性中：'
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The image view of the FDM needs to be part of the framebuffer as well. Its image
    view must be added to the `VkFramebufferCreateInfo::pAttachments` array and its
    index into this array must match that of the `VkAttachmentDescription` structure
    passed to the creation of the render pass.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM的图像视图也必须是帧缓冲区的一部分。其图像视图必须添加到`VkFramebufferCreateInfo::pAttachments`数组中，并且该数组中的索引必须与传递给渲染通道创建的`VkAttachmentDescription`结构中的索引相匹配。
- en: This marks the end of our guide on static foveated rendering. In the upcoming
    sections, we’ll expand our exploration into the realm of dynamic foveated rendering.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们关于静态注视点渲染指南的结束。在接下来的章节中，我们将扩展我们的探索，进入动态注视点渲染的领域。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, check out the extension information at the following
    links:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请查看以下链接中的扩展信息：
- en: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map.html
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map.html
- en: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_fragment_density_map_offset.html.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_fragment_density_map_offset.html.
- en: Retrieving eye gaze information from OpenXR in your app
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中从OpenXR检索视线信息
- en: The realm of VR has evolved to the extent that some HMDs are now equipped with
    the capability to track the user’s eye gaze. This feature, which identifies the
    direction in which the user is looking, can be harnessed for a variety of tasks,
    enhancing the interactivity and immersion of VR experiences. In this recipe, we
    will guide you through the process of enabling and retrieving eye gaze data from
    OpenXR in your application. Additionally, we will illustrate how to calculate
    the focal region—the specific area the user is looking at—in pixel coordinates
    on the render target used for display.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实领域已经发展到一定程度，一些HMD（头戴式显示器）现在配备了跟踪用户视线的能力。这个功能可以识别用户正在看的方向，可以用于各种任务，增强VR体验的交互性和沉浸感。在本食谱中，我们将指导您在应用程序中启用和检索从OpenXR获取的视线数据。此外，我们还将说明如何计算焦点区域——用户正在查看的特定区域——在用于显示的渲染目标上的像素坐标。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need an HMD that supports eye-tracking features, such
    as Meta’s Quest Pro. You will also need to provide permission to the app to track
    the user’s eye, which can be achieved through the **Settings** menu on most devices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，您需要一个支持眼动功能的眼镜，例如Meta的Quest Pro。您还需要允许应用程序跟踪用户的眼睛，这可以通过大多数设备上的**设置**菜单实现。
- en: Also, get acquainted with how spaces and actions are supported and used in OpenXR
    (see the *Getting started with* *OpenXR* recipe).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解如何在OpenXR中支持和使用空间和动作（参见“*开始使用* *OpenXR*”食谱）。
- en: This recipe was authored and tested with Meta’s Quest Pro device, so some of
    the code shown here is specific to that platform. Your implementation might require
    small tweaks to work on your device.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱由Meta的Quest Pro设备编写和测试，因此这里显示的一些代码是特定于该平台的。您的实现可能需要一些小的调整才能在您的设备上工作。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Adding eye gaze support requires allowing the device to track the user’s eyes.
    This requires executing the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加视线支持需要允许设备跟踪用户的眼睛。这需要执行以下步骤：
- en: 'Before using the eye-tracking feature in your app, you need to request permission
    by adding the following lines to the `AndroidManifest.xml` file of your app:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用眼动追踪功能之前，您需要通过将以下行添加到您的应用程序的`AndroidManifest.xml`文件中请求权限：
- en: '[PRE15]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Grant permission to your app to track the user’s eye with the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式授予您的应用程序跟踪用户眼球的权限：
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Enable the OpenXR extension when creating your OpenXR instance by adding `XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME`
    to the `XrInstanceCreateInfo::enableExtensionNames` array:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建OpenXR实例时启用OpenXR扩展，通过将`XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME`添加到`XrInstanceCreateInfo::enableExtensionNames`数组中：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We begin by adding a few member variables to the `OXR:Context` class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先向`OXR:Context`类添加几个成员变量：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Eye tracking is considered an input action in OpenXR, so we create an action
    set to store the eye-tracking action (`OXR::Context::eyegazeActionSet_`):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenXR中，眼动追踪被视为输入动作，因此我们创建一个动作集来存储眼动追踪动作（`OXR::Context::eyegazeActionSet_`）：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then create an action that represents the eye gaze input:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个表示眼球注视输入的动作：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ll need paths that identify the input action and its pose:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要路径来识别输入动作及其姿态：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The action and its pose need to be bound together using an instance of the
    `XrActionSuggestedBinding` structure:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要使用`XrActionSuggestedBinding`结构的实例将动作及其姿态绑定在一起：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Actions need to be attached to a session to work, which can be done by calling
    `xrAttachSessionActionSets` with the action set that stores the eye gaze action:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行动需要附加到会话上才能工作，这可以通过调用`xrAttachSessionActionSets`并传入存储眼球注视动作的动作集来完成：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also need to create an action space for the eye gaze action to define a
    position and orientation of the new space’s origin within a natural reference
    frame of the pose action:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为眼球注视动作创建一个动作空间，以在姿态动作的自然参考框架内定义新空间原点的位置和方向：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last initialization step is to create a local reference space, which we’ll
    use to base the eye gaze position and orientation. The type of the reference space
    is `XR_REFERENCE_SPACE_TYPE_VIEW` as the eye gaze is locked to the eye or headset
    location and orientation. The `eyePoseIdentity` variable is initialized with the
    identity orientation, at a height of `1.8` meters:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的初始化步骤是创建一个局部参考空间，我们将使用它来基于眼球注视的位置和方向。参考空间的类型是`XR_REFERENCE_SPACE_TYPE_VIEW`，因为眼球注视锁定在眼球或头戴式设备的定位和方向上。`eyePoseIdentity`变量初始化为身份方向，高度为`1.8`米：
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `OXR::Context::beginFrame` method, we update the current state of the
    eye gaze action, but only if the current state of the app is `focused`. We can
    then get the action’s state pose with `xrGetActionStatePose`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OXR::Context::beginFrame`方法中，我们更新眼球注视动作的当前状态，但仅当应用程序的当前状态是`focused`时。然后我们可以使用`xrGetActionStatePose`获取动作的状态姿态：
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If `actionStatePose` is `active`, that means we can go ahead and locate the
    action in `localReferenceSpace` at the predicted time from the frame state queried
    before:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`actionStatePose`是`active`，这意味着我们可以继续在`localReferenceSpace`中定位动作，在查询帧状态之前预测的时间：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If both the gaze’s orientation and position are valid, we can use them to calculate
    where, in pixel coordinates, the user is looking at the image being presented
    on the device:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果注视的方向和位置都有效，我们可以使用它们来计算用户在设备上展示的图像中注视的像素坐标：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calculating the screen coordinates of the user’s gaze is simple. The following
    function performs all the math to convert from an `XrPosef` structure (the eye
    gaze location) to the coordinates on the screen. It uses the swapchain dimensions
    to convert the canonical view direction in OpenXR, which points to the *-Z* direction,
    to screen space:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算用户注视点的屏幕坐标很简单。以下函数执行所有数学运算，将`XrPosef`结构（眼球注视位置）转换为屏幕上的坐标。它使用swapchain的尺寸将OpenXR中的规范视图方向（指向*-Z*方向）转换为屏幕空间：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The function uses the helper types and functions defined in `xr_linear.h`. The
    projection matrix is calculated in the function, and not cached at the class level,
    to allow it to be modified while the app is running.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数使用在`xr_linear.h`中定义的辅助类型和函数。投影矩阵在函数中计算，而不是在类级别缓存，以便在应用程序运行时可以修改它。
- en: The sample app in the repository displays a washed-out round cursor, about 10
    pixels in radius, for each eye if eye-tracking is supported by the device to help
    you see how the eye gaze behaves in the final output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库中的示例应用程序显示了一个褪色的圆形光标，半径约为10像素，如果设备支持眼动追踪，以帮助您了解眼球注视在最终输出中的行为。
- en: Implementing dynamic foveated rendering using Qualcomm’s fragment density map
    Offset extension
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高通的片段密度图偏移扩展实现动态注视点渲染
- en: In the *Implementing static foveated rendering with a fragment density map*
    recipe, we discussed how to render fragments at a lower density than one fragment
    per pixel using a map that dictates the fragment density for regions of the render
    target. Although useful, the application of a static map is limited because the
    user’s gaze changes as they look around to inspect the scene displayed on the
    device. Recomputing and modifying the map for each frame, based on the user’s
    input, may be computationally expensive and tax the CPU with extra work, making
    the performance gained with the FDM moot.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用片段密度图实现静态注视点渲染* 的配方中，我们讨论了如何使用一个指定渲染目标区域片段密度的图来渲染比每个像素一个片段更低的密度的片段。尽管很有用，但静态图的适用性有限，因为用户在环顾四周检查设备上显示的场景时，他们的注视点会发生变化。根据用户的输入重新计算和修改每帧的图，可能会造成计算成本高昂，并给CPU带来额外的工作负担，使得使用FDM获得的效果变得微不足道。
- en: Another option is to apply an offset to the static FDM and let the GPU perform
    the heavy lifting of translating the densities from the map to the rendered scene.
    Thanks to Qualcomm’s FDM Offset device extension, this is possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将偏移应用于静态FDM，并让GPU执行将密度从图转换为渲染场景的繁重工作。多亏了高通的FDM偏移设备扩展，这是可能的。
- en: In this recipe, we will show you how to use this extension to dynamically translate
    the FDM based on the user’s gaze direction.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向你展示如何使用这个扩展根据用户的注视方向动态转换FDM。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need an HMD that supports eye-tracking features, such
    as Meta’s Quest Pro. This recipe was authored and tested with Meta’s Quest Pro
    device, so some of the code shown here is specific to that platform. This recipe
    assumes you have already implemented static foveated rendering using a fragment
    density map. If not, you might want to refer to our previous guide on that topic
    to understand the foundational concepts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要一个支持眼动追踪功能的HMD，例如Meta的Quest Pro。这个配方是由Meta的Quest Pro设备编写和测试的，因此这里显示的一些代码是特定于该平台的。这个配方假设你已经使用片段密度图实现了静态注视点渲染。如果没有，你可能需要参考我们之前关于该主题的指南，以了解基础知识。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This extension simplifies the application code by applying an offset to the
    FDM at render time, inside the render loop:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展通过在渲染时间内在渲染循环中对FDM应用偏移来简化应用程序代码：
- en: 'All attachments used in the render pass where the offset is applied to the
    FDM must be created with the `VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`
    flag. Since we are rendering directly to swapchain images, the swapchain images
    need to be created with that flag. Swapchain images are created by OpenXR. Thankfully,
    Meta devices provide the ability to provide additional Vulkan flags to be used
    during the creation of swapchain images. For that, create an instance of the `XrVulkanSwapchainCreateInfoMETA`
    structure and add the flag mentioned before to its `addditionalCreateFlags` property:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用偏移到FDM的渲染通道中使用的所有附件都必须使用带有 `VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`
    标志创建。由于我们直接渲染到交换链图像，因此需要使用该标志创建交换链图像。交换链图像是由OpenXR创建的。幸运的是，Meta设备提供了在创建交换链图像时使用额外Vulkan标志的能力。为此，创建一个
    `XrVulkanSwapchainCreateInfoMETA` 结构体的实例，并将之前提到的标志添加到其 `additionalCreateFlags`
    属性中：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The instance of the `XrVulkanSwapchainCreateInfoMETA` structure must be added
    to the `pNext` chain of the `XrSwapchainCreateInfo` structure.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`XrVulkanSwapchainCreateInfoMETA` 结构体的实例必须添加到 `XrSwapchainCreateInfo` 结构体的
    `pNext` 链中。'
- en: Before enabling the FDM Offset feature, it is necessary to check whether the
    physical device supports it. Doing so requires appending an instance of the `VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM`
    structure to the `pNext` chain of `VkPhysicalDeviceFeatures2` passed to the `vkGetPhysicalDeviceFeatures2`
    function.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用FDM偏移功能之前，有必要检查物理设备是否支持它。这样做需要将 `VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM`
    结构体的实例追加到传递给 `vkGetPhysicalDeviceFeatures2` 函数的 `VkPhysicalDeviceFeatures2` 的
    `pNext` 链中。
- en: '`VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM:: fragmentDensityMapOffset`
    specifies whether the FDM Offset extension is supported.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::fragmentDensityMapOffset`
    指定了是否支持FDM偏移扩展。'
- en: The extension has properties that need to be queried to be used properly. To
    do that, also include an instance of the `VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM`
    structure to the `pNext` chain of `VkPhysicalDeviceProperties2` and query those
    properties with `vkGetPhysicalDeviceProperties2`. We will use them later.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该扩展具有需要查询以正确使用的属性。为此，还需要将`VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM`结构实例添加到`VkPhysicalDeviceProperties2`的`pNext`链中，并使用`vkGetPhysicalDeviceProperties2`查询这些属性。我们将在以后使用它们。
- en: 'The FDM Offset extension is a device extension and its name needs to be passed
    in during the creation of the `VkDevice` object: `"VK_QCOM_fragment_density_map_offset"`
    (or `VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME`).'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM偏移扩展是一个设备扩展，其名称需要在创建`VkDevice`对象时传递：`"VK_QCOM_fragment_density_map_offset"`（或`VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME`）。
- en: The FDM texture needs to be created with the `VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`
    creation flag.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FDM纹理需要使用`VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`创建标志来创建。
- en: 'The offsets are applied to the FDM by creating an instance of the `VkSubpassFragmentDensityMapOffsetEndInfoQCOM`
    structure and adding it to the `pNext` chain of the `VkSubpassEndInfo` structure.
    Note that, in this case, you need to call `vkCmdEndRenderPass2`. `vkCmdEndRenderPass`
    isn’t extensible (we’ll see how to calculate the offsets in the next step):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 偏移量通过创建`VkSubpassFragmentDensityMapOffsetEndInfoQCOM`结构实例并将其添加到`VkSubpassEndInfo`结构的`pNext`链中应用于FDM。注意，在这种情况下，您需要调用`vkCmdEndRenderPass2`。`vkCmdEndRenderPass`是不可扩展的（我们将在下一步中看到如何计算偏移量）：
- en: '[PRE31]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `eyeGazeScreenPosLeft` and `eyeGazeScreenPosRight` offsets can be calculated
    using the previous recipe, *Retrieving eye gaze information from OpenXR in your
    app*. In the sample app provided in the repository, they can be retrieved from
    the context with the `OXR::Context::eyeGazeScreenPos(int` `eye)` function:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`eyeGazeScreenPosLeft`和`eyeGazeScreenPosRight`偏移量可以使用之前的配方计算，即从OpenXR中检索您的应用中的眼动信息。在存储库中提供的示例应用中，它们可以通过`OXR::Context::eyeGazeScreenPos(int
    eye)`函数从上下文中检索：'
- en: '[PRE32]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This extension is powerful because it allows static FDM to be used to achieve
    dynamic foveation without the need to impose an extra CPU load of recalculating
    the map every frame. *Figure 8**.2* shows the result of rendering the bistro scene
    on a Quest Pro with an FDM plus Qualcomm’s FDM Offset extension. The white circle
    is the cursor used to help visualize the eye gaze direction.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个扩展功能强大，因为它允许使用静态FDM来实现动态视野，而不需要额外增加CPU负载来每帧重新计算映射。*图8.2*显示了在Quest Pro上使用FDM加上高通的FDM偏移扩展渲染餐厅场景的结果。白色圆圈是用于帮助可视化眼动方向的光标。
- en: '![Figure 8.2 – The bistro scene rendered on a Quest Pro with an FDM applied
    to the eye gaze direction](img/B18491_08_02.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 在Quest Pro上应用FDM渲染的餐厅场景](img/B18491_08_02.jpg)'
- en: Figure 8.2 – The bistro scene rendered on a Quest Pro with an FDM applied to
    the eye gaze direction
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 在Quest Pro上应用FDM渲染的餐厅场景
- en: This concludes our recipe on dynamic foveated rendering. In the next recipe,
    we will learn how we can reduce memory load since the VR devices have limited
    GPU memory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对动态视野渲染的配方介绍。在下一个配方中，我们将学习如何减少内存负载，因为VR设备具有有限的GPU内存。
- en: Using half floats to reduce memory load
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用半精度浮点数来减少内存负载
- en: A **half float**, also known as a **half-precision floating point**, is a binary
    floating-point format that occupies 16 bits. It plays a crucial role specifically
    for its application in VR devices and other low-performance hardware. A half-precision
    floating point has a smaller memory footprint and requires less bandwidth, which
    can significantly improve the performance and efficiency of such devices. They
    are ideal for scenarios where the precision of full single-precision floating-point
    numbers is not necessary, such as storing pixel values in graphics, performing
    large but simple computations in machine learning models, and certain calculations
    in 3D graphics. Employing 16 bits not only bolsters throughput but also diminishes
    register usage, a key determinant of GPU performance. The quantity of shaders
    that can run concurrently is directly contingent upon the available registers,
    thus making their efficient usage crucial. In this recipe, we demonstrate how
    to use half floats in Vulkan and how we can reduce memory consumption by storing
    vertex data in 16-bit floats instead of 32-bit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**半浮点数**，也称为**半精度浮点数**，是一种占用16位的二进制浮点格式。它在特定应用中扮演着关键角色，尤其是在VR设备和低性能硬件中。半精度浮点数具有较小的内存占用和更少的带宽需求，这可以显著提高这类设备的性能和效率。它们非常适合那些不需要全单精度浮点数精度的场景，例如在图形中存储像素值、在机器学习模型中进行大量但简单的计算以及在3D图形中的某些计算。使用16位不仅提高了吞吐量，还减少了寄存器使用，这是GPU性能的关键决定因素。可以同时运行的着色器数量直接取决于可用的寄存器数量，因此其有效使用至关重要。在这个菜谱中，我们展示了如何在Vulkan中使用半浮点数，以及我们如何通过将顶点数据存储在16位浮点数而不是32位浮点数中来减少内存消耗。'
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To implement a half float in your application, there are several Vulkan and
    GLSL features that you need to be aware of. Vulkan supports half floats by enabling
    the `storageBuffer16BitAccess` and `shaderFloat16` features. The `storageBuffer16BitAccess`
    feature allows you to use a 16-bit format for storage buffers, which can save
    memory and bandwidth. The `shaderFloat16` feature enables the use of 16-bit floating-point
    types in your shaders, which can improve performance by reducing the amount of
    data that needs to be processed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中实现半浮点数，你需要了解一些Vulkan和GLSL功能。Vulkan通过启用`storageBuffer16BitAccess`和`shaderFloat16`功能支持半浮点数。`storageBuffer16BitAccess`功能允许你使用16位格式进行存储缓冲区，这可以节省内存和带宽。`shaderFloat16`功能允许你在着色器中使用16位浮点类型，这可以通过减少需要处理的数据量来提高性能。
- en: On the GLSL side, you would need to enable the `GL_EXT_shader_explicit_arithmetic_types_float16`
    and `GL_EXT_shader_16bit_storage` extensions. The `GL_EXT_shader_explicit_arithmetic_types_float16`
    extension allows you to perform arithmetic operations with half-precision floating-point
    numbers directly in your shaders. Meanwhile, the `GL_EXT_shader_16bit_storage`
    extension enables you to store half-precision floating-point numbers in your shader
    storage blocks and interface blocks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL方面，你需要启用`GL_EXT_shader_explicit_arithmetic_types_float16`和`GL_EXT_shader_16bit_storage`扩展。`GL_EXT_shader_explicit_arithmetic_types_float16`扩展允许你在着色器中直接使用半精度浮点数进行算术运算。同时，`GL_EXT_shader_16bit_storage`扩展允许你在着色器存储块和接口块中存储半精度浮点数。
- en: By leveraging these Vulkan and GLSL features, you can effectively incorporate
    a half float in your application, optimizing performance, especially for low-performance
    devices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些Vulkan和GLSL功能，你可以在应用程序中有效地集成半浮点数，优化性能，尤其是在低性能设备上。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to effectively implement the 16-bit float, starting with
    the activation of specific features and then modifying the shader code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤有效地实现16位浮点数，首先激活特定功能，然后修改着色器代码：
- en: 'Initially, we must activate two specific features: `storageBuffer16BitAccess`
    (found in `VkPhysicalDeviceVulkan11Features`) and `shaderFloat16` (located in
    `VkPhysicalDeviceVulkan12Features`). To facilitate this, we have incorporated
    a function within the `VulkanCore::Context` class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始阶段，我们必须激活两个特定的功能：`storageBuffer16BitAccess`（位于`VkPhysicalDeviceVulkan11Features`中）和`shaderFloat16`（位于`VkPhysicalDeviceVulkan12Features`中）。为了便于实现这一点，我们在`VulkanCore::Context`类中集成了一个函数：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we change our shader code and add GLSL extensions to it. This is done
    inside the `app/src/main/assets/shaders/Common.glsl` file. We also change the
    vertex structure inside this file to use `float16_t` instead of `float`. We also
    use `glm::packHalf1x16` to convert a 32-bit float to 16-bit when loading GLB assets:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更改着色器代码并向其中添加GLSL扩展。这是在`app/src/main/assets/shaders/Common.glsl`文件中完成的。我们还更改了该文件中的顶点结构，使用`float16_t`代替`float`。此外，我们还使用`glm::packHalf1x16`在加载GLB资源时将32位浮点数转换为16位：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In conclusion, implementing a 16-bit float offers significant improvement in
    GPU performance, especially in the context of VR and other low-performance devices.
    By activating the necessary features in Vulkan and making the appropriate adjustments
    in our GLSL shaders, we can take advantage of the benefits that a 16-bit float
    has to offer. It’s a relatively straightforward process that involves enabling
    specific features, adjusting shader code, and modifying data structures to accommodate
    the half-precision format.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，实现16位浮点数在GPU性能上提供了显著的提升，尤其是在VR和其他低性能设备的环境中。通过在Vulkan中激活必要的特性，并在我们的GLSL着色器中进行适当的调整，我们可以利用16位浮点数带来的好处。这是一个相对直接的过程，涉及到启用特定特性、调整着色器代码以及修改数据结构以适应半精度格式。
- en: In this chapter, you embarked on a journey through the world of OpenXR. You
    started by grasping the fundamentals and swiftly moved on to mastering advanced
    techniques. You learned how to implement single pass multiview rendering and how
    to utilize the fragment density map for static foveated rendering. You also gained
    the skills to retrieve eye gaze information for your app. Further, you unlocked
    the secrets of implementing dynamic foveated rendering using Qualcomm’s fragment
    density map Offset extension. Lastly, you discovered the power of using half floats
    to significantly reduce memory load in your applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始了在OpenXR世界中的旅程。你首先掌握了基础知识，然后迅速过渡到掌握高级技术。你学习了如何实现单次多视图渲染以及如何利用片段密度图进行静态注视点渲染。你还获得了获取应用中注视点信息的能力。进一步地，你揭开了使用高通的片段密度图偏移扩展实现动态注视点渲染的秘密。最后，你发现了使用半精度浮点数在应用中显著减少内存负载的强大功能。
